{"id": "3djSDD", "name": "Diffusion Radar", "author": "JungleFish", "description": "diffusion radar", "tags": ["radar", "diffusion"], "likes": 12, "viewed": 635, "published": "Public API", "date": "1559703174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Author: asmith13\n//Free to use as you wish. Have fun\n\n#define green vec3(0.0,1.0,0.0)\n\n// returns a vec3 color from every pixel requested.\n// Generates a BnW Ping on normalized 2d coordinate system\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n               in float frontierBorder, in float timeResetSeconds, \n               in float radarPingSpeed, in float fadeDistance)\n{\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(iTime, timeResetSeconds) * radarPingSpeed;\n   \n    float circle;\n    // r is the distance to the center.\n    // circle = BipCenter---//---innerTail---time---frontierBorder\n    //illustration\n    //https://sketch.io/render/sk-14b54f90080084bad1602f81cadd4d07.jpeg\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n\tcircle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance\n        \n    return vec3(circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //normalize coordinates \n    vec2 uv = fragCoord.xy / iResolution.xy; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    uv.x *= iResolution.x/iResolution.y; //correct the aspect ratio\n    \n\tvec3 color;\n    // generate some radar pings\n    float fadeDistance = 1.0;\n    float resetTimeSec = 4.0;\n    float radarPingSpeed = 0.3;\n    vec2 greenPing = vec2(0.0, 0.0);\n    color += RadarPing(uv, greenPing, 0.25, 0.025, resetTimeSec, radarPingSpeed, fadeDistance) * green;\n    \n    //return the new color\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 200, 396, 396, 945], [947, 947, 1004, 1034, 1596]]}
{"id": "3l23RK", "name": "Pie - distance 2D", "author": "iq", "description": "Distance to a sector of a circle. Based on [url]https://www.shadertoy.com/view/tsjGzD[/url]", "tags": ["2d", "sdf", "distance", "pie"], "likes": 20, "viewed": 1507, "published": "Public API", "date": "1560262607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float t =            3.14*(0.5+0.5*cos(iTime*0.52));\n    vec2  w = vec2(0.50,0.25)*(0.5+0.5*cos(iTime*vec2(1.1,1.3)+vec2(0.0,2.0)));\n    \n    // distance\n    float d = sdPie(p,vec2(sin(t),cos(t)), 0.5);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdPie(m,vec2(sin(t),cos(t)), 0.5);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l23RK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1234, 1284, 1333, 1333, 1476], [1478, 1478, 1535, 1571, 2424]]}
{"id": "3l23zt", "name": "Mushroom 2D", "author": "lucastakejame", "description": "cogumelinho", "tags": ["2d", "mushroom"], "likes": 1, "viewed": 69, "published": "Public", "date": "1560750299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ss(a,b,c) smoothstep(a,b,c)\n#define SIN(a) (.5 + .5*sin(a))\n#define COS(a) (.5 + .5*cos(a))\n#define PI 3.1415\n\nstruct Circle\n{\n    vec2 c;\n    float r;\n};\n\n// complex number multiplication\nvec2 zm(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n    \n// returns 1 for values inside a and b value.\nfloat band(float a, float b, float x)\n{\n    return step(a,x) * step(x,b);\n}\n\n// like band, but will make gradient from 0 to 1 and 0 again inside [a,b]\nfloat sband(float a, float b, float x)\n{\n    float n = (x-a)/(b-a);\n    return (1.- 2.*abs(n-.5))*band(a,b,x);\n}\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    \n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat fCircle(vec2 uv, Circle c)\n{\n   return length(uv - c.c) - c.r;\n}\n\nfloat fBox(vec2 uv, vec2 b)\n{\n\tvec2 d = max(abs(uv) - b,0.);\n    return length(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 muv = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n\n    // mushroom head\n    Circle c0 = Circle(vec2(.0,.3), .4);\n    Circle c1 = Circle(vec2( .55,.1), .4);\n    Circle c2 = Circle(vec2(-.55,.1), .4);\n    Circle c3 = Circle(vec2(0,.06), .4);\n    \n    float an = .6*SIN(iTime);//angle\n    vec2 cuv = zm(uv, vec2(cos(an),sin(an))) + vec2(.0,-.2);\n    float head = fCircle(cuv, c0);\n    head = opSmoothUnion(head, fCircle(cuv, c1), .3);\n    head = opSmoothUnion(head, fCircle(cuv, c2), .3);\n    head = opSmoothUnion(head, fCircle(cuv, c3), .4);\n    \n    // sdf to mask\n    float headMask = 1.- ss(0.,.01,head);\n    \n    // mushroom head pattern\n    Circle cm = Circle(vec2(.1,.1), .09);\n    vec2 uvM = cuv * (1. - SIN(head*15. + 4.*iTime)*3.)\n        \t\t+ .031*vec2( 1.9*sin(cuv.y*10. + iTime),\n                        \t .5*cos(cuv.x*59.) )\n        \t\t+ vec2(1. - cuv.x*(cuv.x - 5.)*(cuv.y)*.5);\n    float mask = fCircle( mod(uvM*.9, .4 ), cm);\n    float hh = 1.- ss(0.,.051, mask);\n    \n    \n    // mushroom body\n    float dx = (.5 - ss(.6,-.6,uv.y)*.3*sin(uv.y*2.5 + .5*sin(iTime) ) ); \n    vec2 buv = uv*vec2(1.5,1.5) + vec2(dx, 0.) + vec2(-.6,.6);\n    float body = fBox(buv, vec2(.15,.5))-.3*ss(.6,-.6,uv.y);\n    float bodyMask = ss(0.04,.02, body);\n    \n    // eyes\n    vec2 eluv = vec2(abs(buv.x),buv.y);\n    eluv *= 2.*vec2(2.,1.);\n    eluv += vec2(-.3,-1.2);\n    \n    float blink = max(sband(.2, .4, mod(iTime, 5.)), sband(1., 1.2, mod(iTime, 3.)));\n    float eyes = fCircle(eluv * vec2(1., blink*20. + 1.), Circle(vec2(0.), .01));\n    float pupils = fCircle(eluv*vec2(1.,2.)*2. + vec2(.1 + .1*sin(iTime),.1 + 0.2*sin(3.*iTime)), Circle(vec2(0.), .01 + blink*.3));\n    float eyesMask = ss(.25, .2, eyes);\n    \n    \n    // mouth\n    vec2 mouv = vec2(abs(buv.x),buv.y + .04*cos(uv.x*1.));\n\tfloat mouth = fBox(mouv, vec2(.3,.01 + .015*cos(uv.x*14.)));\n    float mouthMask = ss(.01,.0, mouth);\n    \n    // beck\n    vec2 beuv = buv + vec2(.6, .03);\n    float bgrad = ss(-0.02,-.09, uv.x*.1);\n    float beck = fBox(beuv, vec2(.3, .001 + .001*bgrad ))- bgrad*bgrad*.3;\n    float beckMask = ss(.01,.0, beck);\n    \n    // add beck\n    float tipCircle = fCircle(buv, Circle(vec2(-1.,-.05), .04));\n    float bg = ss(.2,.14, tipCircle);\n    vec3 tip = mix(vec3(.9,.9,.1), vec3(1.,0.,0.), SIN(tipCircle*200.+ 10.*iTime));\n    \n    // smoke\n    float noise = texture(iChannel0, 5.*fragCoord.xy/iResolution.xy).r;\n    vec2 smuv = uv-vec2(.1,.3);\n    smuv *= vec2(1. + (uv.y+.3)*SIN(uv.y*5. + iTime*2.), .3*abs(uv.y));\n    float smokeCircle = fCircle(smuv, Circle(vec2(-.9,.2), .04));\n    float smokeMask = ss(.2,.1, smokeCircle);\n    smokeCircle = fCircle(smuv, Circle(vec2(-.7,.1), .04));\n    smokeMask = mix(smokeMask, ss(.2,.1, smokeCircle),.5);\n    smuv = uv*vec2(1. + (uv.y+.4)*SIN(uv.y*15. + iTime*2.), .3*abs(uv.y));\n    smokeCircle = fCircle(smuv, Circle(vec2(-.6,.4), .2));\n    smokeMask = mix(smokeMask, ss(.4,.0, smokeCircle),.5);\n   \n    \n    float cloud0 = ss(0., 0.1, uv.y - .50 - .07*sin(uv.x * 05. + iTime*0.5) - .07*sin(uv.x*2.2) );\n    float cloud1 = ss(0., 0.1, uv.y - .60 - .10*sin(uv.x * 07. + iTime*0.8) - .10*sin(uv.x*4.2) );\n    float cloud2 = ss(0., 0.1, uv.y - .70 - .08*sin(uv.x * 09. + iTime*0.5) - .15*sin(uv.x*5.2) );\n    float cloud3 = ss(0., 0.1, uv.y - .75 - .10*sin(uv.x * 11. + iTime*0.8) - .20*sin(uv.x*6.2) );\n   \n    vec4 clouds;\n    \n    clouds = mix(vec4(0.), vec4(.3), cloud0);\n    clouds.a += cloud0;\n    clouds = mix(clouds, vec4(.5), cloud1);\n    clouds.a += cloud1;\n    clouds = mix(clouds, vec4(.7), cloud2);\n    clouds.a += cloud2;\n    clouds = mix(clouds, vec4(.9), cloud3);\n    clouds.a += cloud3;\n    \n    \n    clouds.a = clamp(0., 1., clouds.a);\n    \n    vec2 skyuv = uv + .2*vec2(0.,-cos(uv.x) - 1.);\n    vec3 skyGrad = \n        .67*vec3(1., 0., 0.)*SIN(skyuv.y*2.20 + .3) +\n        .75*vec3(0., 1., 0.)*SIN(skyuv.y*2.41 + .6) +\n        .81*vec3(0., 0., 1.)*SIN(skyuv.y*1.92 + .9) ;\n    \n    vec3 sky = mix(skyGrad, clouds.xyz, clouds.a);\n    \n    // Composing\n    vec3 col;\n    \n    col = mix(sky, mix(vec3(.7,0.,0.), vec3(.9,.9,0.8),hh), headMask );\n    \n    // add body\n    \n    col = mix(col, vec3(.8,.8,.0), bodyMask);\n    \n    \n    // add eyes\n    col = mix(col,\n\t\t\tmix(vec3(0.),mix(vec3(1.), vec3(1.,0.,0.),eyes*eyes*5.), ss(0.,0.3, pupils)),\n            eyesMask);\n\n    // add mouth \n    col = mix(col,vec3(0.),mouthMask);\n    \n    col = mix(col,mix(vec3(1.), tip, bg), beckMask);\n    \n    col += mix(vec3(0.), vec3(1.), smokeMask);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //fragColor = vec4(ss(.05,.0,body));\n    //fragColor = vec4(smokeCircle);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l23zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 197, 222, 222, 279], [285, 331, 370, 370, 406], [408, 482, 522, 522, 594], [595, 595, 647, 647, 751], [753, 753, 787, 787, 823], [825, 825, 854, 854, 909], [912, 912, 969, 1019, 5716]]}
{"id": "3l2GDK", "name": "nova 2019 livecoding round 1", "author": "lovelyH", "description": "This is shader that I have writen on Nova 2019 demoparty during livecoding.\nI made copy after competitioin, and comented out stuff for Bonzomatic so iit will run on shadertoy.", "tags": ["livecoding", "nova", "2019", "demopary"], "likes": 4, "viewed": 232, "published": "Public", "date": "1561155502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#version 410 core\n\n//uniform float fGlobalTime; // in seconds\n//uniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n//uniform sampler1D texFFT; // towards 0.0 is bass / lower freq, towards 1.0 is higher / treble freq\n//uniform sampler1D texFFTSmoothed; // this one has longer falloff and less harsh transients\n//uniform sampler1D texFFTIntegrated; // this is continually increasing\n//uniform sampler2D texChecker;\n//uniform sampler2D texNoise;\n//uniform sampler2D texTex1;\n//uniform sampler2D texTex2;\n//uniform sampler2D texTex3;\n//uniform sampler2D texTex4;\n//float fMidiKnob;\n\n//layout(location = 0) out vec4 out_color; // out_color must be written in order to see anything\n\n//#define time fGlobalTime\n#define time iTime\n#define E 0.001\n#define INF 1000.0\n\n\nvec2 rot( vec2 p, float l){\n\tfloat s=sin(l),c=cos(l);\n\treturn vec2(\n\t\tc*p.x-s*p.y,\n\t\ts*p.x+c*p.y );\n}\n\n\nfloat mlight;\nint mmat;\n\nfloat map(vec3 p){\n\tfloat r=p.z, rc;\n\tvec3 ph;\n\tmlight= INF;\n\tmmat= 0;\n\t\n\tph= p;\n\tph.y= abs(abs(ph.y)-3.0)-3.0;\n\tr= max( r, -max( abs(ph.x)-2.0, abs(ph.y)-2.0 ) );\n\t\n\t// col\n\tph =p;\n\tph.x= abs(ph.x)-9.0;\n\tph.y= abs(abs(abs(ph.y)-9.0)-6.0)-3.0;\n\tr= min( r, length(ph.xy)-1.0 );\n\t\n\tph =p;\n\tph.x= abs(ph.x)-3.0;\n\tph.y= abs(ph.y)-18.0;\n\tr= min( r, length(ph.xy)-1.0 );\n\t//ce\n\tr= min( r, 10.0 - p.z );\n\tph.x= abs(ph.x);\n\tph.z -= 15.0;\n\tph.xz = rot( ph.xz, .3 );\n\tr= max( r,  ph.z );\n\t\n\t//b\n\tph= p;\n\tph.xy= abs(ph.xy)-5.0;\n\tph.y= abs(ph.y)-5.0;\n\tph.z -= .5;\n\tr= min( r, max( abs( length(ph)-.5 ) -.1, ph.z ) );\n\tph.z -= .1 * sin(7.*time);\n\tmlight= min( mlight, length(ph)+.1 );\n\t\n\t//f\n\t//float fp= .5+.3*sin(time) + texture( texFFT, .1 ).r * 200.0;\n    float fp= .5+.3*sin(time);\n\t//float fs= .1*time + 20.*texture( texFFTIntegrated, .2 ).r ;\n    float fs= time;\n\tph=p;\n\tph.z -= 5.;\n\tph.y -= 6.0;\n\tph.xz= rot( ph.xz, .4*fs);\n\tph.yz= rot( ph.yz, .5*fs );\n\t//if( 0.004 < texture( texFFT, .3 ).r )\n    if( mod( time, 5.0 ) < .5 )\n\t\tph.yz= ph.xz;\n\tph.xy= rot( ph.xy, 5.*fs );\n\tph.xy= abs(ph.xy)-fp;\n\tmlight= min( mlight, length(ph)+.1 );\n\tph.yz= rot( ph.yz, .4*fs );\n\tph.xy= rot( ph.xy, 6.*fs );\n\tph.xy= abs(ph.xy)-fp;\n\tmlight= min( mlight, length(ph)+.1 );\n\t\n\t//ct\n\tr= max( r, max(abs(p.x)-12.0, abs(p.y)-21.0 ) );\n\t\n\t//w\n\trc= p.z + 1.0 + .5 * sin(time);\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmmat= 1;\n\t}\n\t\n\tr= min( r, mlight );\n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 r= vec3(0);\n\tfloat power= 1.0;\n\tfor(int pa=0;pa<2;pa++){\n\t\tvec3 p;\n\t\tfloat t=0.0, dis, light= INF;\n\t\tbool hit= false;\n\t\tfor(int a=0;a<0x100;a++){\n\t\t\tp= sp + t * dir;\n\t\t\tdis= map(p);\n\t\t\tlight= min( light, mlight );\n\t\t\tif( dis < E ){\n\t\t\t\thit= true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt += dis;\n\t\t}\n\t\tint mat= mmat;\n\t\tfloat plight= mlight;\n\t\t\n\t\tif( hit ){\n\t\t\tvec3 n= normalize(vec3(\n\t\t\t\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t\t));\n\t\t\t\n\t\t\tvec3 c= mat==1 ? vec3(.1,.5,.9) : vec3(1);\n\t\t\t\n\t\t\tr += power* clamp( c\n\t\t\t\t* .1\n\t\t\t\t* (.5 + .5 *dot(n,-dir) )\n\t\t\t\t* (.5 + .5 *dot(n,vec3(0,0,1)) )\n\t\t\t\t* clamp( 1.0 - 0.01*t, 0.0, 1.0 )\n\t\t\t\t+ (.5 / (1.0 + plight ) )\n\t\t\t\t, 0.0, 1.0 );\n\t\t\t\n\t\t\tif( mat==1 ){\n\t\t\t\tpower *= 0.3;\n\t\t\t\tdir= reflect( dir, n );\n\t\t\t\tsp = p + 4.0 * E * dir;\n\t\t\t}else{\n\t\t\t\tpower= 0.0;\n\t\t\t}\n\t\t}else{\n\t\t\t// sky\n\t\t\tpower = 0.0;\n\t\t}\n\t\tr += vec3(.9,.5,.1) * (2.0 / (1.0 + light ));\n\t\tif( power < E )break;\n\t}\n\treturn r;\n}\n\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\tuv *= 2.0;\n\n  //vec2 m;\n  //m.x = atan(uv.x / uv.y) / 3.14;\n  //m.y = 1 / length(uv) * .2;\n  //float d = m.y;\n\n  //float f = texture( texFFT, d ).r * 100;\n  //m.x += sin( fGlobalTime ) * 0.1;\n  //m.y += fGlobalTime * 0.25;\n\n  //vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n  //t = clamp( t, 0.0, 1.0 );\n  //out_color = f + t;\n\t\n\t\n\tvec3 c, dir;\n\t\n\tif( mod( time, 9.0) < 3.0 ){\n\t\tc= vec3(\n\t\t\t0.0 + sin(.2*time),\n\t\t\t20.0 + sin(.3*time),\n\t\t\t7.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989 + .1 * sin(.15*time) );\n\t}\n\telse if( mod( time, 9.0) < 6.0 ){\n\t\tc= vec3(\n\t\t\t50.0 + sin(.2*time),\n\t\t\t0.0 + sin(.3*time),\n\t\t\t3.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989/2.0 + .1 * sin(.15*time) );\n\t}\n\telse{\n\t\tc= vec3(\n\t\t\t40.0 * sin(.2*time),\n\t\t\t40.0 * cos(.2*time),\n\t\t\t7.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989 -.2*time);\n\t}\n\t\n\t\n\tfragColor.xyz = render( c, dir );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2GDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 774, 801, 801, 875], [903, 903, 921, 921, 2323], [2327, 2327, 2360, 2360, 3394], [3397, 3397, 3430, 3430, 3595], [3596, 3596, 3653, 3653, 4973]]}
{"id": "3l2GRt", "name": "ray traincg sphere--modificado", "author": "jorge2017a1", "description": "ray traincg sphere--modificado", "tags": ["ray", "sphere", "tracing"], "likes": 4, "viewed": 81, "published": "Public", "date": "1560726054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\n\nvec3 colorplaneta( vec2 fragCoord )\n{\n    vec2 uv;\n    //Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    //Equalize the aspect ratio\n    ///uv.y /= iResolution.x/iResolution.y;\n    uv=fragCoord;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\n    //Fragment colour\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    \n    \n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.5, 0.0);\n\tfloat t = sphere(ro, rd, p, 1.25);\n\tvec3 nml = normalize(p - (ro+rd*t));\n    \n    \n\tvec3 bgCol = background(iTime, rd);\n\trd = reflect(rd, nml);\n    \n\t//vec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n    \n    \n    vec3 tmp3;\n    vec2 tmp2;\n    tmp2=vec2(uv.x, uv.y);\n    tmp3=colorplaneta(tmp2);\n    \n    vec3 col = background(iTime, rd) * tmp3;\n    \n    \n\tfragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2GRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 262], [264, 264, 299, 299, 649], [652, 652, 689, 689, 1211], [1215, 1215, 1272, 1272, 1906]]}
{"id": "3lB3R3", "name": "Simplex noise exercise", "author": "abelu", "description": "An exercise in simplex noise animation", "tags": ["noise", "simplex", "exercise"], "likes": 0, "viewed": 99, "published": "Public", "date": "1560363155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 mod289(vec3 x) { \n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec2 mod289(vec2 x) { \n  return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec3 permute(vec3 x) { \n  return mod289(((x*34.0)+1.0)*x); \n}\n\nfloat snoise(vec2 v) {\n  // Precompute values for skewed triangular grid\n  const vec4 C = vec4(0.211324865405187,\n                      // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,\n                      // 0.5*(sqrt(3.0)-1.0)\n                      -0.577350269189626,\n                      // -1.0 + 2.0 * C.x\n                      0.024390243902439);\n                      // 1.0 / 41.0\n\n  // First corner (x0)\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n\n  // Other two corners (x1, x2)\n  vec2 i1 = vec2(0.0);\n  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n  vec2 x1 = x0.xy + C.xx - i1;\n  vec2 x2 = x0.xy + C.zz;\n\n  // Do some permutations to avoid\n  // truncation effects in permutation\n  i = mod289(i);\n  vec3 p = permute(\n          permute( i.y + vec3(0.0, i1.y, 1.0))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(\n                      dot(x0,x0),\n                      dot(x1,x1),\n                      dot(x2,x2)\n                      ), 0.0);\n\n  m = m*m ;\n  m = m*m ;\n\n  // Gradients:\n  //  41 pts uniformly over a line, mapped onto a diamond\n  //  The ring size 17*17 = 289 is close to a multiple\n  //      of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n  // Compute final noise value at P\n  vec3 g = vec3(0.0);\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n  return 130.0 * dot(m, g);\n}\n\nfloat lines(in vec2 st, float b) {\n  float scale = 5.;\n  st *= scale;\n\n  return smoothstep(\n    0.,\n    .5 + b * .5,\n    abs((sin(st.x * PI) + b * 1.9)) * .35\n  );\n}\n\nvec2 rotate2d(in vec2 st, in float a) {\n  return st * mat2(cos(a), -sin(a),\n                   sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 ps = st - vec2(.5);\n  st *= 12.;\n\n  float noise = snoise(st) * .43 + .48;\n  float len = 1. - smoothstep(.0, .6 + .5 * sin(iTime * 2.), length(ps));\n  float pattern = lines(vec2(noise) * len, .3);\n\n  fragColor = vec4(\n    vec3(\n      pattern, \n      noise * len, \n      len\n    ), \n  1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lB3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 98], [100, 100, 121, 121, 172], [174, 174, 196, 196, 235], [237, 237, 259, 309, 1916], [1918, 1918, 1952, 1952, 2083], [2085, 2085, 2124, 2124, 2198], [2200, 2200, 2255, 2255, 2599]]}
{"id": "3lB3Rc", "name": "Double Simplex Truchet Weave", "author": "Shane", "description": "Continuing on from BigWIngs's double simplex Truchet weave pattern.", "tags": ["simplex", "truchet", "pattern", "double", "weave"], "likes": 23, "viewed": 655, "published": "Public API", "date": "1560496059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\n\tDouble Simplex Truchet Weave\n\t----------------------------\n\n\tAll too often, I'll be in the middle of coding something, then someone on \n    Shadertoy will post some interesting concept that sends me off on a tangent. \n\tBigWIngs puts up a lot of examples along those lines.\n\n    The other day, he posted a double quad Truchet that resulted in a really \n\tintense looking weave pattern -- The link is below. The basic premise was to \n\tdouble the usual amount of connecting points per side, then run\trandom \n\tsegments between them. It's such a simple idea, but opens up a heap of \n\tpossibilities.\n\n\tAnyway, BigWIngs also sketched up a very basic double sided simplex weave as \n\ta proof of concept, so this is just an extension on it.\n\n\tI was pleasantly surprised by how quickly it came together. Most of the time,\n\tthings that should take five minutes wind up taking much longer. The process\n\twas relatively quick because I was able to repurpose my quad version without\n\ttoo many incidents.\n\n\tIn regard to the lighting, I basically hacked away with a few samples to get \n\tthe look I wanted. There's very little science in there, so I wouldn't take \n\tany of it seriously... And I hope you like a monochrome palette -- It's the\n\tone I choose when I'm too lazy to make colors work. :D Either way, there's a\n\t\"CENTER_STRIPE\" define there for anyone who requires a splash of color.\n\n    Like the quad variation, if you wanted to produce a 3D extruded version,\n\tyou'd probably have to replace the Bezier curves with a mixture of arcs and \n\tlines, as it would be much faster.\n\n\tAt some point, I'd like to put together a proper 3D version, but I should \n\tprobably get back to what I'm supposed to be coding at the moment. :)\n\n\n\n\tBased On:\n\n    Double Triangle Truchet Doodle- BigWIngs\n\thttps://www.shadertoy.com/view/Ml2yzD\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n    Double Sided Quad Truchet - Shane\n\thttps://www.shadertoy.com/view/wl2GRG\n\n\n*/\n\n// I was undecided as to whether I wanted color, or not. Perhaps too busy?\n// Anyway, I've included it as an option.\n//#define CENTER_STRIPE\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.197)))*43758.5453); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // (1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n \n\nvec4 triPattern(vec2 p){\n    \n    \n    \n    // Scaling constant.\n    const float gSc = 4.;\n    p *= gSc;\n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Smoothing factor: This can do my head in, sometimes. If you don't take screen\n    // resolution into account, the fullscree image can look too blurry. If you do, the\n    // image can look too crisp and lose something in the translation... Then there's PPI\n    // to consider... Damned if you do, damned if you don't. :D\n    float sf = 4./450.*gSc;\n    //float sf = 4./min(750., iResolution.y)*gSc;\n    \n    \n     \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    //float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    //vec2 ioffs = vec2(1. - i, i);\n    \n    // Amalgamating to the two lines above into this.\n    vec2 ioffs = p.x < p.y? vec2(0, 1) : vec2(1, 0);\n    \n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\n    \n    // Make the vertices match up by swapping two of the vertices on alternate triangles. \n    // Actually, it's not really necessary here, but if you want to check neighboring\n    // properties, etc, it's a habit worth getting into.\n    if(ioffs.x<.5) { vec2 tmp = ip0; ip0 = ip2; ip2 = tmp; }\n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n    \n   \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges. There are faster ways to achieve this, but this will do.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Connecting points around the triangles. Two for each side. I should probably\n    // use a bit of trigonometry and hard code these, but I was feeling lazy. :)\n    const float offs = .204124; // Approx: length(ip0 - ip1)/4., or 1./sqrt(24.);\n    vec2 m01s = mix(ip0, ip1, .5 + offs);\n    vec2 m01t = mix(ip0, ip1, .5 - offs);\n    vec2 m12s = mix(ip1, ip2, .5 + offs);\n    vec2 m12t = mix(ip1, ip2, .5 - offs);\n    vec2 m20s = mix(ip2, ip0, .5 + offs);\n    vec2 m20t = mix(ip2, ip0, .5 - offs);\n    \n    // The boundary normals for each point. I should probably hardcode these as well.\n    vec2 n01 = -normalize(mix(ip0, ip1, .5));\n    vec2 n12 = -normalize(mix(ip1, ip2, .5));\n    vec2 n20 = -normalize(mix(ip2, ip0, .5));\n    \n    // Points, and their respective normals, to pass to the segment function.\n    vec4[6] pnt = vec4[6](vec4(m01s, n01), vec4(m01t, n01), \n                          vec4(m12s, n12), vec4(m12t, n12),\n                          vec4(m20s, n20), vec4(m20t, n20));\n    \n    \n    \n    // Shuffling the 6 array points and normals. I think this is the FisherâYates method, \n    // but don't quote me on it. It's been a while since I've used a shuffling algorithm, \n    // so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    for(int i = 5; i>0; i--){\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21((s*3. + ioffs + 1.)/3. + fi/6.);\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*6e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n        \n    }    \n\n    \n    vec3 d; // Distances for all three triangle cell segments.\n    \n    float dPnt = 1e5; // Distance for the edge points.\n    \n    for(int i = 0; i<3; i++){\n        \n        // The Bezier segments for each layer.\n        d[i] =  doSeg(p,  pnt[i*2], pnt[i*2 + 1], offs);\n        \n        // The two edge points for each side.\n        dPnt = min(dPnt, length(p - pnt[2*i].xy));\n        dPnt = min(dPnt, length(p - pnt[2*i + 1].xy));\n    }\n    \n    \n    d -= .05; // Giving the segment some width.\n    dPnt -= .0125; // Edge point size.\n    \n  \n    // Overall cell color and bump value.\n    vec3 col = vec3(.5);\n    float bump = .5;\n    \n    // Concentric triangle background pattern.\n    float pat = clamp(cos(tri*96.)*.5 + .5, 0., 1.);\n    \n    // Background triangle borders.\n    col = mix(col, col*1.5, 1. - smoothstep(0., sf, tri - .01));\n    col = mix(col, col*.5, 1. - smoothstep(0., sf, tri - .0));\n \t\n    // Applying the background pattern to the color and bump value.\n    col *= (1. - pat*.5);\n \tbump *= (1. - pat);\n\n     \n    // Extra base shadowing for the bump pass.\n    bump = mix(bump, 0., (1. - smoothstep(0., sf*3., min(min(d.x, d.y), d.z) - .03))*.5);\n\n    \n    // Rendering the layers. The bump value is similar to the color value, but differs slightly,\n    // in places, so ultimately needs its own variable. Obviously, this means doubling up on \n    // calculations, but thankfully, this is a 2D... ish example.\n    for(int i = 0; i<3; i++){\n        \n        // Shadows, stroke, color, etc.\n        col = mix(col, vec3(.0), (1. - smoothstep(0., sf*3., d[i] - .03))*.85);\n        col = mix(col, vec3(.0), 1. - smoothstep(0., sf, d[i] - .02));\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, d[i]));\n        col = mix(col, vec3(.03), 1. - smoothstep(0., sf, d[i] + .01));\n        #ifdef CENTER_STRIPE\n        col = mix(col, vec3(1, .05, .2), 1. - smoothstep(0., sf, d[i] + .065));\n        #endif\n        \n        // Bump shadow, stroke, etc.\n        bump = mix(bump, 0., (1. - smoothstep(0., sf*2., d[i] - .02))*.5);\n        bump = mix(bump, 0., (1. - smoothstep(0., sf, d[i] - .01)));\n        bump = mix(bump, .8, 1. - smoothstep(0., sf, d[i]));\n        bump = mix(bump, .5, 1. - smoothstep(0., sf, d[i] + .01));\n        #ifdef CENTER_STRIPE\n        bump = mix(bump, 0., 1. - smoothstep(0., sf, d[i] + .06));\n        bump = mix(bump, 1., 1. - smoothstep(0., sf, d[i] + .065));\n        #endif\n        \n    }\n    \n    // The edge points -- Tweaked a little to resemble rivots, or somthing like that.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dPnt));\n    col = mix(col, vec3(.4), 1. - smoothstep(0., sf, dPnt + .01));\n    \n    // Edge point bump values.\n    bump = mix(bump, 1., 1. - smoothstep(0., sf, dPnt - .01));\n    bump = mix(bump, 0., 1. - smoothstep(0., sf, dPnt));\n    bump = mix(bump, 1., 1. - smoothstep(0., sf, dPnt + .01));\n\n    \n    // Return the color and bump value.\n    return vec4(col, bump);\n    \n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct pixel coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/min(750., iResolution.y);\n    \n    // Scaling and translation.\n\tuv = rot2(3.14159/12.)*(uv + vec2(.1, .05)*iTime);\n     \n    // Three color samples.\n    vec4 col = triPattern(uv);\n    vec2 eps = normalize(vec2(1.732, 3))*.002;\n    vec4 col2 = triPattern(uv - eps);\n    vec2 eps2 = normalize(vec2(-1.732, 3))*.002;\n    vec4 col3 = triPattern(uv - eps2);\n    \n    // Using the samples for a bit of highlighting.\n    float b = max(col2.w - col.w, 0.)/length(eps)*.025;\n    float b2 = max(col3.w - col.w, 0.)/length(eps2)*.025;\n    \n    // Adding blue and reddish highlights. Mostly fake, but vaguely based on the\n    // concept of directional derivative lighting.\n    col.xyz += col2.xyz*(.15 + vec3(.25, .5, 1)*pow(b, 2.)/2.);\n    col.xyz += col3.xyz*(.15 + vec3(1, .3, .1)*pow(b2, 2.)/2.);\n    \n    // Mixing in some extra blue and red. Also fake. :)\n    col = mix(col*vec4(.75, 1, 1.25, 1), col*vec4(1.6, .9, .75, 1),(b + b2)*.5);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzyw, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n\n \n    // Rough gamma correction, then output to the screen.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lB3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2128, 2161, 2183, 2183, 2241], [2244, 2301, 2322, 2322, 2386], [2389, 2446, 2477, 2477, 2577], [2580, 2764, 2813, 3009, 4493], [4495, 4988, 5033, 5060, 6340], [6343, 6357, 6395, 6395, 6427], [6431, 6431, 6455, 6495, 13718], [13723, 13723, 13780, 13821, 15139]]}
{"id": "3lBGDc", "name": "404 ERROR", "author": "KilledByAPixel", "description": "Short looping fractal for a 404 error page.", "tags": ["fractal", "zoom", "pixel", "matrix", "recursion"], "likes": 6, "viewed": 379, "published": "Public", "date": "1561301730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 2;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(\t// glyph sheet\n\t0x01110, 0x11011, \n\t0x11011, 0x11011,\n\t0x11011, 0x11111, \n\t0x11011, 0x00011,\n\t0x01110, 0x00011\n);\t//  0        4\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nconst float loopTime = 2.;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0.,0.0,0.); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.1, RandFloat(419*glyphPosLast.x + 773*glyphPosLast.y)),\n   \t\tmix(0.5, 3.0, RandFloat(929*glyphPosLast.x + 499*glyphPosLast.y)),\n      \t1.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color.x += myColor.x*f;;\n        color.y = max(color.y, myColor.y*f);\n    color.z = max(color.z, myColor.z*pow(f, 1.3));\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // brighten\n    //color += vec3(0.05);\n    \n    //color.x+=.95;\n    \n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.01*sin(9.0*uv.y + pi*2.0*iTime/loopTime);\n\tuv.y += 0.01*sin(2.0*uv.x + 0.8*iTime/loopTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return i % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    \n    if (iterations%2==0)\n     \treturn ivec2(2,2);\n    else\n     \treturn ivec2(1,4);\n    /*\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 0;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    // find a random valid pixel in glyph\n    c -= RandInt(iterations) % c;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x, glyphSize - 1 - y/glyphCount);\n        }\n    }*/\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    return (glyphPos.x+glyphPos.y)%2;\n    \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\nuv.x*=1.5;\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = (iTime+1.)*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[962, 1518, 1542, 1542, 1588], [1589, 1589, 1609, 1609, 1646], [1648, 1648, 1672, 1672, 1812], [1814, 1930, 1980, 1980, 2224], [2226, 2226, 2249, 2249, 2275], [2276, 2276, 2391, 2391, 2808], [2810, 2810, 2849, 2917, 2971], [2973, 2973, 2995, 3004, 3124], [3127, 3232, 3258, 3258, 3283], [3284, 3284, 3320, 3320, 3373], [3374, 3374, 3411, 3411, 3604], [3663, 3663, 3689, 3689, 3714], [3716, 3716, 3757, 3757, 4548], [4552, 4552, 4649, 4649, 4960], [4968, 5025, 5092, 5092, 6263], [6266, 6351, 6408, 6436, 7451]]}
{"id": "3lBGDm", "name": "Circle truchet tiles bit viz", "author": "avin", "description": "simple truchet + soundviz", "tags": ["truchet"], "likes": 5, "viewed": 461, "published": "Public API", "date": "1559732065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LAYERS 3.\n#define PI_4 0.78539815\n#define PI_2 1.5707963\n\n#define SIZE 30.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define SF 1./min(iResolution.x,iResolution.y)\n\n#define sinp(v) (sin(v)*.5+.5)\n\nmat2 rot(float a){\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float m = 0.;\n    for(float i=0.; i<LAYERS; i++){\n        \n        float size = SIZE + sin(iTime)*5.;\n        float sv = texelFetch(iChannel0, ivec2(10., 0.), 0).x-.5;               \n        vec2 guv = uv*size * (1.+i*(sv)*.2) + vec2(sin(iTime*.3), cos(iTime*.2))*10.;\n        vec2 gid = floor(guv);\n        guv = fract(guv) - .5;\n\n        float gidHash = floor((rand1(gid.x + gid.y*100.))*2.);    \n        guv *= rot(PI_2 * (gidHash));\n\n        float sf = SF*size*2.;\n        float l = length(guv - .5);    \n        m += smoothstep(sf,.0, abs(l-.5));\n\n        l = length(guv + .5);    \n        m += smoothstep(sf,.0, abs(l-.5));\n    }\n            \n    m/=LAYERS;\n    \n    fragColor = vec4(1.-m);\n}", "image_inputs": [{"id": "4tfGz2", "previewfilepath": "https://soundcloud.com/modernproducers/play-this-shit-hard-drum-kit-demo", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/modernproducers/play-this-shit-hard-drum-kit-demo", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 234, 234, 310], [312, 312, 369, 369, 1142]]}
{"id": "3lBGDV", "name": "study4_rainRuning", "author": "firegump", "description": "just leaning. original shader by BigWIngs. ", "tags": ["study"], "likes": 6, "viewed": 470, "published": "Public", "date": "1561532911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t)  smoothstep(a,b,t)\n\nfloat N(float t){\n\treturn fract(sin(t*3456.)*6547.);//make a random value 0 to 1;\n}\n\nvec4 N14(float t){\n\treturn fract(sin(t*vec4(123., 1024., 3456., 9564))*vec4(6547.,345., 8799., 1564.));//make a random value 0 to 1;\n}//make a radom vec4 value\n\nstruct ray{//it's like creating your own value type.\n\tvec3 o, d;\n};\n    ray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n        ray a;\n        a.o = camPos;\n        \n        vec3 f = normalize(lookat - camPos);\n        vec3 r = cross(vec3(0.,1,0.), f);\n        vec3 u = cross(f, r);//zoom is the distance of camera to screen,.\n        vec3 c = a.o +  f* zoom;    //center of screen point, f is normalized\n        vec3 i = c + uv.x * r + uv.y * u;\n        a.d = normalize(i - a.o);//distance of ray from focus to screen.\n        return a;\n    \n    }\nvec3 ClosestPoint(ray r, vec3 p){//the point closest to the ray\n\t//dot  the projection of vector into another one;\n\treturn r.o+ max(0., dot(p - r.o, r.d))*r.d;//max :Prevent negative results\n}\nfloat DistRay(ray r, vec3 p){\n\treturn length(p - ClosestPoint(r, p));\n}\nfloat Bokeh(ray r, vec3 p, float size, float blur){\n    \n    float d = DistRay(r , p);\n    size *= length(p - r.o);\n    float c = S(size , size*(1. - blur) , d);//size(1 - blur)  normalize blur to (0, 1)\n\tc *= mix(.6 , 1., S(size*.8, size, d));//mix: mix two values as alpha;\n    return c;\n}\nvec3 StreetLights(ray r, float t, float roadWith){\n\n    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;\n    r.d.x = abs(r.d.x);\n    const float s = 1./ 10.;//s has to be a constant, represent a quantity\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;\n        vec3 p = vec3(roadWith , 3.5 , 100.- ti*100.);\n        m += Bokeh(r, p, .05, .1)*ti*ti*ti;//x^n can make curve flatter;\n    }\n    \n    \n    return  vec3(1., .7, .3) *m;\n}\n\nvec3 EnvLights(ray r, float t, float roadWith){\n\n    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;\n    r.d.x = abs(r.d.x);\n    const float s = 1./ 4.5;//s has to be a constant, represent a quantity\n    \n    vec3 c = vec3(0.);\n    \n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;\n        vec4 n = N14(i + side*100.);// make different\n        \n        float fade = ti*ti*ti;\n        \n        float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;// make the shop light blink\n        \n        fade = occlusion;\n        \n        float x = mix(2.5, 10., n.x);\n        float y = mix(.1, 1.5, n.y);\n        vec3 p = vec3(roadWith + x ,y , 70.- ti*70.);//light start point  is 50\n        \n        vec3 col = n.wzy;\n            \n        c += Bokeh(r, p, .05, .1)*fade*col*.5;//x^n can make curve flatter;\n    }\n    \n    \n    return  c;\n}\n\n\nvec3 HeadLights(ray r, float t, float roadWith){\n\n    t *= 2.;//make car faster than street lamp\n    float w1 = .25;//light width\n    float w2 = w1*1.2;\n    const float s = 1./ 10.;\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float n =N(i);\n        \n        if(n > .345) continue;//jump to top,cut % light\n        \n        float ti = fract(t + i);\n        float z =  100.- ti*100.;\n        //fract(t + i), if i=.9,fract's value will rise to 1 in short time\n        float fade = ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        float size = mix(.05, .03, focus);\n        roadWith *= -.3;\n        \n        m += Bokeh(r, vec3(roadWith -1.-w1, .15 ,z ), size, .1)*fade;\n        m += Bokeh(r, vec3(roadWith -1.+w1, .15 ,z ), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(roadWith -1.-w2, .15 ,z ), size, .1)*fade;//extra light effect\n        m += Bokeh(r, vec3(roadWith -1.+w2, .15 ,z ), size, .1)*fade;\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(roadWith -1.-w2, -.15 ,z ), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(roadWith -1.+w2, -.15 ,z ), size*3., 1.)*fade;\n        \n        m += ref*focus;\n        \n    }\n    \n    \n    return  vec3(.9, .9, 1.) *m;\n}\n\nvec3 TailLights(ray r, float t, float roadWith){\n    \n\tt *= .25;\n    float w1 = .25;//light width\n    float w2 = w1*1.2;\n    const float s = 1./ 10.;\n    float m = 0.;\n    for(float i = 0.;i< 1.;i += s){\n        float n =N(i);\n        \n        if(n > .5) continue;//jump to top,cut % light\n         \n        float lane = step(.25,n);//n = 0~ .5\n        \n        float ti = fract(t + i);\n        float z =  100.- ti*100.;\n        //fract(t + i), if i=.9,fract's value will rise to 1 in short time\n        float fade = ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        float size = mix(.05, .03, focus);\n        \n        float laneShift = S(.99, .95, ti);\n        float x = 1.5 - lane*laneShift;//control rightside car'lan\n        roadWith *= .3;\n        \n        float blink = step(0. ,sin(t*500.))*7.*lane*step(.96,ti);//return 0 | 7 lane control witch car blink\n        //step(.96,ti), car at far point ti = 0, instead close poing ti = 1,\n        m += Bokeh(r, vec3(roadWith + x - w1, .15 ,z ), size, .1)*fade;\n        m += Bokeh(r, vec3(roadWith + x + w1, .15 ,z ), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(roadWith + x - w2, .15 ,z ), size, .1)*fade;//extra light effect\n        m += Bokeh(r, vec3(roadWith + x + w2, .15 ,z ), size, .1)*fade*(1. + blink);//1|8 right taillight\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(roadWith + x - w2, -.15 ,z ), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(roadWith + x + w2, -.15 ,z ), size*3., 1.)*fade*(1. + blink*.1);\n        \n        m += ref*focus;\n        \n    }\n    \n    \n    return  vec3(1., .1, .03) *m;\n}\n\nvec2 Rain(vec2 uv, float t){\n    \n    \n    t *= 40.;\n    \n    vec2 a = vec2(3.,1.);\n    \n    vec2 st = uv*a;\n    st.y += t*.22;\n    \n    vec2 id = floor(st);//in same rect,make same id,seems like 11,21,31,41\n    \n    float n = fract(sin(id.x*76.34)*768.34);\n    st.y += n;  //make different rhythm,offset y eath box\n    id = floor(st); //initialize  id\n    st = fract(st)-.5;//movepoint to center\n    \n    t += fract(sin(id.x*76.34 + id.y*1453.7)*768.34)*6.283;//make per rect different time \n    //same id t plus value is same. multiply 2Ï,the reason : t is use to sin function\n    \n    float y = - sin( t + sin(t + sin(t)*.5 )) *.43;//water drop animation\n    vec2 p1 = vec2(0. , y);\n    vec2 o1 = (st - p1)/a;\n    float d = length(o1);\n    \n    float ml = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*a.x*vec2(1.,2.)) - .5)/vec2(1.,2.);\n    d = length(o2);//*vec2 change the y coordnate to create more drop\n    \n    float m2 = S(.3*(.5-st.y), .0, d)*S(-.1, .1, st.y - p1.y);\n    //if st.y>p1.yï¼return 1,else return 0, so can hide the point under of p1.\n    //5-st.y  scale by y\n    \n    //if(st.x > .46|| st.y > .49) ml = 1.;//debug line\n    \n\treturn vec2(ml*o1*30.+ m2*o2*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    float screenScale = iResolution.x/iResolution.y;\n    uv.x *= screenScale ;\n    \n  \tfloat g = S(0.,.5,.3*length(uv*vec2(1.,1.5)));\n    g *= g;\n    vec2 GM = g*uv*.2;//convex lens\n   \n\t    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.07+ m.x*.3;//if pause,can control time by moving mouse;\n    \n    float rt = t*230.;//run speed\n    float cameAnima = cos(rt)*.025;\n    float runRhythm = clamp(0.,3.,sin(rt + sin(rt+sin(rt)*.5)))*.03;\n    //the peak is to the left sine,move up quikly and down slowly,\n    //clamp is just let he stay at ground a moment\n    \n    float runSideId =  step(0.,sin(rt*.5));\n    \n    vec3 camPos = vec3(.5 + cameAnima * runSideId ,.2 + cameAnima, 0.);\n    vec3 lookat = vec3(.5 , .2+runRhythm , 1.);\n    \n    \n    //uv.x += sin(uv.y*40.)*.1;\n    vec2 rainDistort = Rain(uv*5. , t)*.5;\n    rainDistort += Rain(uv*7. , t)*.3;\n    \n    uv.x += sin(uv.y*70.)*.003;\n    uv.y += sin(uv.x*70.)*.003;\n    \n    ray r = GetRay(uv - rainDistort*.5 - GM, camPos, lookat, 2.);// - refract other  side\n   \n\t\n    \n    float roadWith = 4.2+ (.5 + sin(t/2.)*.5);// road width\n    \n    vec3 col = StreetLights(r, t, roadWith);\n    col += HeadLights(r, t, roadWith);\n    col += TailLights(r, t, roadWith);\n    col += EnvLights(r, t, roadWith);\n    \n    \n        \n    col += (r.d.y + .55)*vec3(.2,.1,.5)*.3;//sky color\n    //col = vec3(0.);\n    col += (S(.0,.5,r.d.y)*1.3)*vec3(.9,.2, .1)*.5;//sky color 2\n    \n    \n   \n    //col = vec3(g);\n    //col = vec3(rainDistort, 0.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 54, 54, 120], [122, 122, 140, 140, 256], [256, 355, 413, 413, 842], [843, 843, 876, 957, 1035], [1036, 1036, 1065, 1065, 1107], [1108, 1108, 1159, 1159, 1399], [1400, 1400, 1450, 1450, 1932], [1934, 1934, 1981, 1981, 2858], [2861, 2861, 2909, 2909, 4070], [4072, 4072, 4120, 4120, 5669], [5671, 5671, 5699, 5699, 6856], [6858, 6858, 6915, 6965, 8581]]}
{"id": "3lBGzt", "name": "ChamferBox Super Primitive", "author": "TLC123", "description": "My goal was  a super primitive of a Chamfer Box that also take a secondary rounding parameter on the new edges. Sphere, Cuboid and Octahedron in one continuum.\nfinalized 2019 with function sdOctahedron( in vec3 p, in float s)// by Iq  ", "tags": ["sdf"], "likes": 6, "viewed": 186, "published": "Public", "date": "1560621337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"ChamferBox\" by TLC123. https://shadertoy.com/view/ltdSzX\n// 2019-06-15 17:45:33\n// ChamferBox and map created by TLC123 \n// Everything else adapted from stuff Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n \n \n\nfloat sdOctahedron( in vec3 p, in float s)// by Iq 2019\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n\n \n\n \n \n\n\tfloat ChamferBox(vec3 op, vec3 b, float ch, float r) {\nvec3 p=abs(op)+vec3(ch)+vec3( r);\n       p=max(vec3(0),p-b); \n\nfloat d =sdOctahedron(   p,   ch)\n           ;\n \n \n return d  -r ;\t\t}\n//----------------------------------------------------------------------\n\n \n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n\n//a bunch of fudging  numbers to drive demo\n float vari=0.5;\n float pivot=.85;   \nvec3 box = 2.0*normalize( vec3 (  pivot + sin(48.2+iTime*0.783116+1.  )*vari ,pivot+sin(131.2+iTime*0.953116  )*vari ,pivot+sin(4.2+iTime*0.43 )*vari ));\n float mb= min(min(box.x,box.y),box.z);\n    \nfloat ch=   0.9* mb*( .5+sin(414.5+ 1.+iTime*0.53116  )*.450)  ;\n    float r=    mb*    ( (0.5+ cos(2.+iTime*0.261265)*.50)) ;\n\n    float d= ChamferBox(pos+ vec3(1.5,0.,1.5) , box ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    \n    \n  box = 2.*normalize( vec3 (pivot+sin(16.2+iTime*0.93116+1.  )*vari ,pivot+sin(311.2+iTime*0.953116  )*vari,pivot+sin(4.2+iTime*0.823116  )*vari ));\n \n  mb= min(min(box.x,box.y),box.z);      \n    ch=     0.9* mb*(.5+ sin(31.+iTime*0.73116  )*.450)  ;\n      r=        mb*  ( (0.5+ cos(2.3+iTime*0.3261265)*.50)) ;\n float  dd= ChamferBox(pos+ vec3(-1.5,0.,1.5) , box  ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    \n      d=min(d,dd);\n  box = 2.*normalize( vec3 (pivot+sin(34.2+iTime*0.973116+1.  )*vari,pivot+sin(234.2+iTime*0.7153116  )*vari ,pivot+sin(24.2+iTime*0.993116  )*vari ));\n \n    mb= min(min(box.x,box.y),box.z); \n       ch=    0.9*  mb*( .5+ sin(22.3+iTime*0.843116  )*.450)  ;\n      r=       mb*   ( (0.5+ cos(1.6+iTime*0.63261265)*.50)) ;\n      dd= ChamferBox(pos+ vec3(1.5,0.,-1.5) , box  , ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n   \n    d=min(d,dd);\n  box =  2.*normalize(vec3 (pivot+sin(43.2+iTime*0.83116+1.  )*vari ,pivot+ sin(3.2+iTime*0.8253116  )*vari ,pivot+sin(14.2+iTime*0.763116  )*vari ));\n \n    mb= min(min(box.x,box.y),box.z);      \n     ch=   0.9* mb*( 0.5+ sin(10.3+iTime*0.8143116  )*.450)  ;\n      r=       mb*   ( (0.5+ cos(1.2+iTime*0.563261265)*.50)) ;\n      dd= ChamferBox(pos+ vec3(-1.5,0.,-1.5) ,box   ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    d=min(d,dd);\n\nreturn vec2(  d  ,25);\n }\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=-0; i<250; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*0.2;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = 1.2*vec3( -0.5+3.5*cos(1.6*time + 6.0*mo.x), 3.0 + 2.0*mo.y, 0.5 + 3.5*sin(1.6*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.0, -0.0, 0. ) ;\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 298, 355, 355, 653], [667, 667, 721, 721, 854], [932, 1006, 1031, 1076, 2917], [2919, 2919, 2959, 2959, 3556], [3559, 3559, 3633, 3633, 3894], [3896, 3896, 3928, 3928, 4149], [4151, 4151, 4193, 4193, 4492], [4497, 4497, 4536, 4536, 6107], [6109, 6109, 6161, 6161, 6338], [6340, 6340, 6397, 6397, 6995]]}
{"id": "3lj3DW", "name": "Goursat - intersection", "author": "iq", "description": "Analytic intersection of a Goursat surface (degree 4 equation).", "tags": ["3d", "raytracing", "raycast", "intersection", "quartic", "goursat"], "likes": 31, "viewed": 2263, "published": "Public API", "date": "1559670793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic intersection of a Goursat surface (degree 4 equation). I think I\n// still have a bug...\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// (x4 + y4 + z4) - (r2^2)Â·(x2 + y2 + z2) + r1^4 = 0;\nfloat iGoursat( in vec3 ro, in vec3 rd, in float ka, float kb )\n{\n    float po = 1.0;\n\n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\n\n    // raw quartic\n    float k4 = dot(rd2,rd2);\n    float k3 = dot(ro ,rd3);\n    float k2 = dot(ro2,rd2) - kb/6.0;\n    float k1 = dot(ro3,rd ) - kb*dot(rd,ro)/2.0;\n    float k0 = dot(ro2,ro2) + ka - kb*dot(ro,ro);\n\n    // make leading coefficient 1\n    k3 /= k4;\n    k2 /= k4;\n    k1 /= k4;\n    k0 /= k4;\n    \n    // reduced cubic\n    float c2 = k2 - k3*(k3);\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n\n#if 1\n    // prevent |c1| from being too close to zero\n    // reduced cubic\n    if( abs(c1) < 0.1*abs(c2) )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n\n        c2 = k2 - k3*(k3);\n        c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n        c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n    }\n#endif\n\n\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    // 2 intersections\n    if( h>0.0 )\n    {\n        h = sqrt(h);\n\n        float s = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        \n        float x = s+u+4.0*c2;\n        float y = s-u;\n        float ks = x*x + y*y*3.0;\n        float k = sqrt(ks);\n\n\t\tfloat t = -0.5*po*abs(y)*sqrt(6.0/(k+x)) - 2.0*c1*(k+x)/(ks+x*k) - k3;\n        return (po<0.0)?1.0/t:t;\n    }\n\t\n\t// 4 intersections\n    float sQ = sqrt(Q);\n    float w = sQ*cos(acos(-R/(sQ*Q))/3.0);\n  //float w = sQ*cos(atan(sqrt(-h),-R)/3.0);\n\n    float d2 = -w - c2; if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?1.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?1.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?1.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?1.0/t4:t4;\n\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\nvec3 nGoursat( in vec3 pos, float ka, float kb )\n{\n    return normalize( 4.0*pos*pos*pos - 2.0*pos*kb );\n}\n\n#define AA 2\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.3*iTime;\n\tvec3 ro = vec3( 3.2*cos(an), 1.5, 3.2*sin(an) );\n    vec3 ta = vec3( 0.0, -0.05, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // object animation\n    float def = smoothstep(-1.0,-0.4,-cos(0.3*iTime));\n    float ra = 0.3 + def*0.6*sin(1.311*iTime+0.0);\n    float rb = abs(ra) + 0.6 + def*0.25*sin(0.73*iTime+3.0);\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float t = iGoursat( ro, rd, ra, rb );\n\n        // shading/lighting\t\n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p));\n        \n\t    if( t>0.0 )\n\t    {\n            vec3 pos = ro + t*rd;\n\t\t    vec3 nor = nGoursat( pos, ra, rb );\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n            float inn = dot(nor,normalize(pos));\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = (0.5+0.5*nor.y)*(0.6+0.4*inn)*(0.6+0.4*pow(0.5+0.5*inn,2.0));\n            \n            const float fr = 20.5;\n            vec3 th = abs(nor);\n            //col = vec3(0.4) + 0.4*smoothstep(-0.01,0.01,cos(pos.x*fr*0.5)*cos(pos.y*fr*0.5)*cos(pos.z*fr*0.5)); \n            col = vec3(0.6) + 0.4*smoothstep(-0.01,0.01,cos(pos.x*fr*0.5)*cos(pos.y*fr*0.5)*cos(pos.z*fr*0.5));\n            float wi = smoothstep(-1.0,-0.98-0.015*th.x,cos(pos.x*fr))\n                      *smoothstep(-1.0,-0.98-0.015*th.y,cos(pos.y*fr))\n                      *smoothstep(-1.0,-0.98-0.015*th.z,cos(pos.z*fr));\n            col *= wi;\n#if 0\n\t\t    col *= vec3(0.3,0.5,0.7)*amb + vec3(1.1,0.8,0.6)*dif;\n            col += wi*0.5*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n#else\n\t\t    col *= amb;\n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += col*fre;\n#endif            \n\t    }\n\t\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\t// dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3DW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1335, 1390, 1455, 1455, 3605], [3607, 3607, 3657, 3657, 3713], [3757, 3757, 3814, 3838, 6381]]}
{"id": "3lj3RG", "name": "procedual stone", "author": "ankd", "description": "procedual raymarching stone.\nshape : intersection box and plane sometime.\nmaterial : fbm(stonePos * any).", "tags": ["raymarchingstone"], "likes": 3, "viewed": 120, "published": "Public", "date": "1560005911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\n// params\n#define MARCHING_STEPS 100\n#define MATERIAL_COLOR_A vec3(0.2, 0.3, 0.9)\n#define MATERIAL_COLOR_B vec3(0.1, 0.2, 0.1)\n#define MATERIAL_COLOR_C vec3(0.3, 0.9, 0.1)\n\n#define SHADOW_STEPS 16\n#define AO_STEPS 8\n\n// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\nfloat hash(in float x) {\n  return fract(sin(x) * 43237.5324);\n}\nvec3 hash3(in float x) {\n  return vec3(\n      hash(x +   .0),\n      hash(x +  53.0),\n      hash(x + 117.0)\n    );\n}\nfloat noise(in vec3 x) {\n  vec3 f = fract(x);\n  vec3 i = floor(x);\n  f = f*f*(3.0-2.0*f);\n  float n = i.x*1.0 + i.y*57.0 + i.z*113.0;\n  return mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                 mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n             mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                 mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n}\nmat3 m = mat3( 0.64,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat fbm(in vec3 x) {\n  float f = 0.0;\n  f += 0.5000*noise(x); x=m*x*2.02;\n  f += 0.2500*noise(x); x=m*x*2.03;\n  f += 0.1250*noise(x); x=m*x*2.01;\n  f += 0.0625*noise(x);\n  return f;\n}\nfloat usin(in float x) {\n  return 0.5 + 0.5*sin(x);\n}\nvec2 rotate(in vec2 p, in float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, -s, s, c) * p;\n}\n\n\nfloat box(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat plane(in vec3 p, in vec3 n, in float h) {\n  return dot(p, n) - h;\n}\n\nfloat stone(in vec3 p, in float r, in float seed) {\n  float b = box(p, vec3(r));\n  for(int i=0;i<8;i++) {\n    float fi = float(i+1);\n    vec3 n = normalize(-1.0+2.0*hash3(fi*seed));\n    b = max(b, plane(p, n, 0.5*r+(0.1*hash(fi+seed))));\n  }\n  return b;\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) {\n  return d1.x<d2.x ? d1 : d2;\n}\nvec3 objTx(vec3 p) {\n\tp.y -= 1.0;\n\tp.xy = rotate(p.xy, iTime*0.20);\n\tp.yz = rotate(p.yz, iTime*0.14);\n\tp.zx = rotate(p.zx, iTime*0.17);\n    return p;\n}\n\nvec2 map(in vec3 p) {\n  float ground = plane(p+vec3(0.,0.2*fbm(p*7.0), 0.), vec3(0.,1.,0.), -1e-4);\n  vec3 q = p;\n  q = objTx(q);\n  float t = iTime*0.1;\n  float ft = fract(t);\n  float it = floor(t);\n\n  float s1 = stone(q, 0.5, it);\n  float s2 = stone(q, 0.5, it+1.0);\n  float obj = mix(s1, s2, ft);\n  return opU(vec2(ground, 0.), vec2(obj, 1.0));\n}\n\nvec2 march(in vec3 ro, in vec3 rd) {\n  float mn=0.0, mx=1000.0;\n  float thr = 1e-4;\n\n  float d=0.0, m=-1.0;\n  for(int i=0;i<MARCHING_STEPS;i++) {\n    vec3 pos = ro + rd*d;\n    vec2 tmp = map(pos);\n    if(tmp.x<thr || mx<tmp.x) break;\n    d += tmp.x*0.5;\n    m = tmp.y;\n  }\n  if(mx<d) m = -1.0;\n  return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 1e-4;\n  return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yxy * map(p + e.yxy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.xxx * map(p + e.xxx).x\n    );\n}\n\nfloat maxHei = 5.8;\nfloat calcSoftShadow(in vec3 ro, in vec3 rd, in float tmn, in float tmx) {\n  // bouding volume\n  float tp = (maxHei - ro.y)/rd.y;\n  if(tp>0.0) tmx = min(tmx, tp);\n\n  float res = 1.0;\n  float t = tmn;\n  for(int i=0;i<SHADOW_STEPS;i++) {\n    float h = map(ro + rd*t).x;\n    res = min(res, 8.0*h/t);\n    t += clamp(h, 0.02, 0.1);\n    if(res<0.005 || tmx<res) break;\n  }\n  return clamp(res, 0., 1.);\n}\nfloat calcAO(in vec3 pos, in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i=0;i<AO_STEPS;i++) {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos = nor*hr + pos;\n    float dd = map(aopos).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0-3.0*occ, 0., 1.) * (0.5+0.5*nor.y);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd){\n  // ray march and get position/normal/reflect vector.\n  vec2 res = march(ro, rd);\n  float d=res.x, m=res.y;\n  vec3 pos = ro + rd * d;\n  vec3 nor = calcNormal(pos);\n  vec3 ref = reflect(rd, nor);\n\n  // material\n  vec3 color = vec3(0.0);\n  if(m==0.0) {\n    color = mix(vec3(0.3, 0.13, 0.02), vec3(0.3, 0.8, 0.1),\n    pow(fbm(pos*0.5), 2.0));\n  }\n  else if(m==1.0) {\n    vec3 mtlpos = objTx(pos);\n    color = (\n      MATERIAL_COLOR_A*fbm(mtlpos*vec3(0., 0., 1.)*42.0) +\n      MATERIAL_COLOR_B*fbm(mtlpos*vec3(1.)*15.0) +\n      MATERIAL_COLOR_C*fbm(mtlpos*vec3(1.)* 1.0)\n    ) ;\n  }\n\n  // lighting\n  /*\n\treference :\n\t\"Raymarching - Primitives\" by iq \n\thttps://www.shadertoy.com/view/Xds3zN\n  */\n  float occ = calcAO(pos, nor);\n  vec3 lp = vec3(cos(iTime), 1.+5.0*usin(iTime*0.3), sin(iTime));\n  vec3 ld = normalize(lp - pos);\n  float lr = 1.0;\n  vec3 hal = normalize(ld - rd);\n  float amb = sqrt(clamp(0.5+0.5*nor.y, 0., 1.));\n  float dif = clamp(dot(nor, ld), 0., 1.);\n  float bac = clamp(dot(nor, normalize(vec3(-ld.x, 0., -ld.y))), 0., 1.) * clamp(1.0-pos.y, 0., 1.);\n  float dom = smoothstep(-0.2, 0.2, ref.y);\n  float fre = pow(clamp(1.0+dot(nor, rd), 0., 1.), 2.);\n  // calc SoftShadow\n  dif *= calcSoftShadow(pos, ld, 0.02, 2.5);\n  dom *= calcSoftShadow(pos, ref, 0.02, 2.5);\n  // calc specular\n  float spe = pow(clamp(dot(nor, hal), 0., 1.), 16.0) * dif * (0.04+0.96*pow(clamp(1.0+dot(hal, rd), 0., 1.), 5.0));\n  // calc 'light n?' from lighting params\n  vec3 lin = vec3(0.);\n  lin += 5.80 * dif*vec3(1.0);\n  lin += 2.85 * amb*vec3(1.0) * occ;\n  lin += 0.55 * bac*vec3(1.0) * occ;\n  lin += 0.85 * dom*vec3(1.0) * occ;\n  lin += 0.25 * fre*vec3(1.0) * occ;\n  // add distance attenuation\n  float att = 1.0/pow(length(ld)/lr + 1.0, 2.0);\n  lin *= att;\n  color *= lin;\n  if(m==1.0) color += 7.0 * spe*vec3(1.0, 1.0, 1.0);\n\n  color *= exp(-0.001*d*d*d);\n  return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n  vec3 color = vec3(0.);\n  float t = iTime * 0.3;\n\n  vec3 ro = vec3(cos(t), 1.+usin(t*0.3), sin(t));\n  ro.xz *= 1.0;\n  vec3 tar = vec3(0., 1., 0.);\n  vec3 cz = normalize(tar - ro);\n  vec3 cx = normalize(cross(cz, vec3(0., 1., 0.)));\n  vec3 cy = normalize(cross(cx, cz));\n  vec3 rd = mat3(cx, cy, cz) * normalize(vec3(p, 1.0));\n\n  color = render(ro, rd);\n\n  fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 365, 389, 389, 428], [429, 429, 453, 453, 544], [545, 545, 569, 569, 942], [1050, 1050, 1072, 1072, 1235], [1236, 1236, 1260, 1260, 1289], [1290, 1290, 1326, 1326, 1388], [1391, 1391, 1424, 1424, 1513], [1514, 1514, 1561, 1561, 1587], [1589, 1589, 1640, 1640, 1844], [1846, 1846, 1880, 1880, 1912], [1913, 1913, 1933, 1933, 2064], [2066, 2066, 2087, 2087, 2414], [2416, 2416, 2452, 2452, 2732], [2734, 2734, 2762, 2762, 2956], [2978, 2978, 3052, 3072, 3375], [3376, 3376, 3416, 3416, 3690], [3693, 3693, 3729, 3784, 5600], [5603, 5603, 5657, 5657, 6165]]}
{"id": "3lj3RV", "name": "Nicknakin/RaymarchingV2", "author": "Nicknakin", "description": "ray marching", "tags": ["raymarching"], "likes": 2, "viewed": 75, "published": "Public", "date": "1560283416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere(vec3 p, float r){\n    //vec3 q = fract(p)*2.0-1.0;\n    return length(p)-r;\n}\n\nfloat sdCube(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdUnion(float dist1, float dist2){\n\treturn min(dist1,dist2);   \n}\n\nfloat sdIntersect(float dist1, float dist2){\n\treturn max(dist1,dist2);  \n}\n\nfloat sdNegate(float dist1, float dist2){\n \treturn max(-dist1, dist2);   \n}\n\nfloat marchRay(vec3 o, vec3 r){\n \tfloat t = 0.0;\n    for(int i = 0; i < 512 && t >= 0.0; i++){\n\t\tvec3 p = o+r*t;\n        float cube = sdCube(fract(p)*2.0-1.0, vec3(0.9,0.9,0.9));\n        float sphere = sdSphere(fract(p)*2.0-1.0, 1.25);\n        \n        float d = sdNegate(sphere, cube)-0.1;\n        t += d*0.25;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\t\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    float theta = iTime/10.0;\n    r.xz *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    vec3 o = vec3(0.5, 0.5, -iTime);\n    \n    float t = marchRay(o, r);\n    \n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(fog);\n\n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 65, 91], [93, 93, 122, 122, 270], [272, 272, 312, 312, 343], [345, 345, 389, 389, 419], [421, 421, 462, 462, 496], [498, 498, 529, 529, 831], [834, 834, 891, 941, 1344]]}
{"id": "3lj3Ry", "name": "Stretchy Rainbow ", "author": "cdgiessen", "description": "scrolling rainbow", "tags": ["rainbow", "stretchy"], "likes": 3, "viewed": 224, "published": "Public", "date": "1560034613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float str = tan(uv.x*10.0 + sin(uv.x*5.0 + iTime) + sin(iTime)) ;\n    if(str > 2.0)\n        fragColor = vec4(1.0,0.0,0.0,0.0);\n    else if(str > 0.8)\n        fragColor = vec4(1,0.5,0.0,0.0);\n    else if(str > 0.25)\n        fragColor = vec4(1.0,1.0,0.0,0.0);\n    else if(str > -0.25)\n        fragColor = vec4(0.0,1.0,0.0,0.0);\n    else if(str > -0.8)\n        fragColor = vec4(0.0,0.8,1.0,0.0);\n    else if(str > -2.0)\n        fragColor = vec4(0.0,0.0,1.0,0.0);\n    else \n        fragColor = vec4(0.5,0.0,1.0,0.0);\n      \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 638]]}
{"id": "3lj3WG", "name": "Volumetric Lighting Experiment", "author": "SSHantaram", "description": "Volumetric absorption and scattering", "tags": ["raymarching", "volume", "lighting"], "likes": 8, "viewed": 763, "published": "Public", "date": "1560951420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\nconst float VOLUME_STEP = 0.03;\nconst float VOLUME_STEP_LIGHT = 0.1;\nconst float VOLUME_DENSITY = 0.04;\nconst float LIGHT_INTESITY = 0.03;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    x += vec3(10.0, 5.0, 6.0);\n    return 0.6*noise(x*5.0) + 0.4*noise(x*10.0) + 0.2*noise(x*16.0) - 0.2;\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float r) {\n    return length(center - p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n   \t//float sphere = sphereSDF(samplePoint, vec3(0.0, 0.0, 0.0), 1.0);\n    float box = boxSDF(samplePoint, vec3(1.5, 1.0, 1.5));\n    //return sphere;\n    return box;\n}\n\nfloat sampleVolume(vec3 p, float densityMultiplier) {\n    return layeredNoise(p)*densityMultiplier;\n}\n\n// integrate density along ray\nfloat marchDensity(vec3 startPoint, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float density = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = startPoint + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            // sum desity values\n         \tdensity += sampleVolume(samplePoint, VOLUME_DENSITY)*min(-d, VOLUME_STEP_LIGHT);\n            depth += VOLUME_STEP_LIGHT;\n        }\n        // opaque: stop early\n        if (density >= 1.0) return 1.0;\n    }\n    return density;\n}\n\nfloat volumeAbsorption(float lightIntensity, float acumulatedDensityToPoint) {\n    return max(0.0, lightIntensity - acumulatedDensityToPoint);\n}\n\n// integrate illumination along ray\nfloat marchVolumetricLighting(vec3 eye, vec3 marchingDirection, vec3 lightPos, float start, float end) {\n    float depth = start;\n    float accumulatedDensity = 0.0;\n    float brightness = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = eye + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            float densityAtPosition = sampleVolume(samplePoint, VOLUME_DENSITY);\n            // integrated density between eye and point\n            accumulatedDensity += densityAtPosition*min(-d, VOLUME_STEP);\n            // get integrated density between point and light\n            vec3 lightRay = vec3(lightPos - samplePoint);\n            float acumulatedDensityToLight = marchDensity(samplePoint, normalize(lightRay), start, end);\n            // point brightness is dimmed by volume between eye and point\n            float pointBrightness = volumeAbsorption(LIGHT_INTESITY, acumulatedDensityToLight);\n            // sum up brightness values along ray\n            brightness += volumeAbsorption(pointBrightness, accumulatedDensity);\n            depth += VOLUME_STEP;\n        }\n        if (brightness >= 1.0) return 1.0;\n    }\n    return brightness;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \t//vec3 eye = vec3(0.0, -5.0, -6.0);\n    vec3 eye = vec3(6.0*cos(iTime*0.1), -3.0, 6.0*sin(iTime*0.1));\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    vec3 lightPos = vec3(1.2*cos(iTime), 1.0, 1.2*sin(iTime));\n    \n    float brightness = marchVolumetricLighting(eye, worldDir, lightPos, MIN_DIST, MAX_DIST);\n\n    \n    vec3 color = vec3(1.0, 1.0, 1.0)*brightness;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 283, 303, 303, 398], [400, 423, 449, 449, 981], [983, 1022, 1053, 1053, 1161], [1163, 1208, 1232, 1232, 1250], [1252, 1252, 1299, 1299, 1336], [1338, 1338, 1371, 1371, 1801], [1803, 1803, 1845, 1845, 1877], [1879, 1922, 1956, 2027, 2124], [2126, 2126, 2179, 2179, 2227], [2229, 2260, 2345, 2345, 2954], [2956, 2956, 3034, 3034, 3100], [3102, 3138, 3242, 3242, 4466], [4468, 4468, 4533, 4533, 4665], [4667, 4740, 4769, 4769, 5079], [5081, 5110, 5159, 5194, 5325], [5328, 5328, 5385, 5385, 5937]]}
{"id": "3lj3Wm", "name": "Raymarch Object Oriented", "author": "Veggiebob", "description": "A simple framework for more detailed projects in the future", "tags": ["raymarch", "lighting", "object", "struct"], "likes": 3, "viewed": 526, "published": "Public API", "date": "1559799546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RERAY 5\n#define HIT_THRESHOLD 0.01\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflection;\n    int pi;//portal index\n};\nstruct SDF {\n    Material mat;\n    float d;\n};\nstruct Ray {\n    vec3 end;\n    int steps;\n    float d;\n    SDF sdf;\n};\nstruct Portal {\n\tvec3 start;\n\tvec2 rot;\n    int endPortal;//integer index of the ending portal\n    int filled;//1 if filled, 0 if empty\n    vec3 color;//color tint of portal\n};\n//ree kill the spacing\nconst int numLights = 1;\nconst Light lights[numLights] = Light[](\n    Light(vec3(-1., 1., 1.), vec3(1.), 1.0)\n    //Light(vec3(2., -1., 0.), vec3(1.), 1.0)\n);\n//portal definitions\nconst int numPortals = 2;\nconst Portal portals[numPortals] = Portal[](\n    //vec3 start, vec2 rot, int endPortalIndex, int filled, vec3 color\n\t//Portal(vec3(-1.5, -0.7, 1.), vec2(0., 0.), 1, 1, vec3(0.5, 0.3, 0.)),//orange portal\n    //Portal(vec3(1.5, 1., -1.), vec2(0., 0.), 0, 1, vec3(0., 0.3, 0.5))//blue portal\n    Portal(vec3(-1.5, 0., -1.), vec2(0., 0.), 1, 1, vec3(0.0, 0.8, 0.0)),//green portal\n    Portal(vec3(1.5, 0., -1.), vec2(0., 0.), 0, 1, vec3(0.9, 0.5, 0.5))//pink portal\n);\nconst Material def = Material(vec3(1.0, 1.0, 1.0), 0.8, 0.5, 0.0, -1);//default material\nconst Material soft = Material(vec3(1.0), 0.8, 0.0, 0.0, -1);\nconst Material showLight = Material(vec3(0.), 0.0, 0.0, 0.0, -1);//for showing lights\nconst Material object = Material(vec3(1.0, 1.0, 0.5), 0.8, 0.4, 0.0, -1);\nconst Material mirror = Material(vec3(1.0), 0.5, 0.0, 0.5, -1);//mirror\nconst Material portal = Material(vec3(1.), 0.0, 1.5, -1., 0);//portal\n//yay (I made this myself)\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat rand (float r) {\n    return 0.5+0.5*sin(1234.+pow(r, 4.));\n}\nvec3 rand3 (vec3 r) {\n    return vec3(rand(r.x), rand(r.y), rand(r.z));\n}\n//from https://www.shadertoy.com/view/Ml3SR8\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, .999, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\nfloat sq (float x) { return x*x; }\nvec2 sq (vec2 v) { return v*v; }\n//vec2 pow (vec2 v, float p) { return vec2(pow(v.x, p), pow(v.y, p)); }\n//pretty proud of this one\n//maps a 2d texture onto 3d surfaces using the normal and the position of the node\n//not exact but works for all surfaces\nvec2 getTexPos (vec3 p, vec3 n) {\n    //return sqrt(sq(p.xz*n.y) + sq(p.xy*n.z) + sq(p.yz*n.x));\n    return ((p.xz*n.y) + (p.xy*n.z) + (p.yz*n.x));\n}\n//thanks IQ https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r;\n}\nSDF portalSDF (vec3 p, int PI) {///// portal sdf\n    vec2 pa = p.xy;\n    p.x = pa.y;\n    p.y = pa.x;\n    float sd = sdSphere(p, 0.4);//sdRoundedCylinder(p, 0.2, 0.05, 0.0);\n    Material pp = portal;\n    pp.pi = PI;\n    return SDF(pp, sd);\n}\nSDF lightSDF (vec3 p, vec3 pp) {\n    return SDF(showLight, length(pp-p)-0.1);\n}\nSDF ground (vec3 p, float h) {\n    return SDF(soft, p.y-h);\n}\nSDF ground (vec3 p, float h, float thickness) {\n    float freq = 3.;\n    float displace = sin(p.x*freq)*sin(p.x*freq)*cos(p.z*freq)*cos(p.z*freq)*0.8;\n    return SDF(soft, abs(p.y-h)-thickness*displace);\n}\nSDF sphere (vec3 p, float r) {\n    return SDF(object, length(p)-r);\n}\n//thanks to IQ for the box sdf function\nSDF box (vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn SDF(def, length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0));\n}\nSDF room (vec3 p, vec3 b) {\n    return SDF(soft, -box(p, b).d);\n}\nSDF sdfADD (SDF a, SDF b) {\n    if(a.d<b.d) {\n        return a;\n    } else {\n        return b;\n    }\n}\nSDF sdf (vec3 p) {\n    vec2 rp = rotate2D(p.xz, 0.0);\n    SDF s = sdfADD(\n        sphere(p, 0.2), \n        sdfADD(\n            ground(p, -1.5, 0.3),\n            room(vec3(rp.x, p.y, rp.y), vec3(3.))\n        )\n    );\n    //show the lights (dev)\n    /*\n    for(int i = 0; i<numLights; i++) {\n        s = sdfADD(s, lightSDF(p, lights[i].position));\n    }\n*/\n    for(int i = 0; i<numPortals; i++) {//portal start\n        Portal por = portals[i];\n        //don't draw un-filled ones\n        if(por.filled==0) {\n            continue;\n        }\n        //rotate\n        vec3 rp = p-por.start;\n        rp.zy = rotate2D(rp.zy, por.rot.y);\n        rp.xz = rotate2D(rp.xz, por.rot.x);\n        s = sdfADD(s, portalSDF(rp, i));\n    }\n    return s;\n}\nRay trace (vec3 o, vec3 r, int reray) {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    SDF s = SDF(def, 10000.);\n    float t = 0.;\n    int steps = 0;\n    for(int i = 0; i<128; i++) {\n        p = o+r*t;\n        s = sdf(p);\n        t+=s.d*0.4;\n        //curve of light around portals\n        if(s.mat.reflection<0.&&s.d>0.&&reray==0) {\n            vec3 ppos = portals[s.mat.pi].start;\n            vec3 bend = normalize(p-ppos);\n            //interpolate\n            float x = length(p-ppos);\n            \n            float bend_amount = sin(pow(0.5, x*10.-1.651)) * (1.-max(0.0,dot(p-o, p-ppos))) * 0.01;\n            r = normalize(mix(r, bend, bend_amount));\n        }\n\t\t\n        if(s.d<HIT_THRESHOLD){\n            steps = i;\n            break;\n        }\n        if(t>10.0) {\n            steps = i;\n            t = 1000.;\n        \tbreak;\n        }\n    }\n    return Ray(p, steps, t, s);\n}\nconst float E = 0.0001;\nvec3 estimateNormal (vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x+E, p.y, p.z)).d-sdf(vec3(p.x-E, p.y, p.z)).d,\n        sdf(vec3(p.x, p.y+E, p.z)).d-sdf(vec3(p.x, p.y-E, p.z)).d,\n        sdf(vec3(p.x, p.y, p.z+E)).d-sdf(vec3(p.x, p.y, p.z-E)).d\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    uv.x-=iResolution.x/iResolution.y/2.;\n    uv.y-=0.5;\n    uv*=2.0;\n    float perspective = 0.8;\n    float time = iTime*0.5;\n    vec3 cam = vec3(sin(time), 0., cos(time));\n    cam.xz*=0.8;\n    vec3 ray = normalize(vec3(uv.x*perspective, uv.y*perspective, 1.0));\n    //cam.zy = rotate2D(cam.zy, mouse.y*5.0);\n    ray.zy = rotate2D(ray.zy, mouse.y*5.0);\n    \n    //cam.xz = rotate2D(cam.xz, -mouse.x*10.0);\n    ray.xz = rotate2D(ray.xz, -mouse.x*10.0);\n    vec3 col = vec3(0.);\n    \n    float ambient = 0.3;\n    Material m;\n    Material pm;\n    for(int times = 0; times<MAX_RERAY; times++) {//max reflections or teleportations\n        Ray t = trace(cam, ray, times);\n        m = t.sdf.mat;//the material\n        vec3 norm = estimateNormal(t.end);\n        vec3 tcol = m.color*ambient;\n        vec3 refl = reflect(normalize(ray), norm);\n        //calculate light intensity at the point for each light\n        for(int i = 0; i<numLights; i++) {\n            Light l = lights[i];\n            vec3 toLight = normalize(l.position-t.end);\n            float diffuse = max(0.0, dot(toLight, norm)*m.diffuse);\n            float specular = pow(max(0.0, dot(refl, toLight)), 16.0)*m.specular;\n            \n            //float levels = 5.;//levels of shadows\n            float lightAmount = (diffuse+specular);//intensity of light. Default is (diffuse+specular)\n            tcol += (1.-ambient)*m.color*l.intensity*l.color*lightAmount;// /float(numLights)\n        }\n        tcol -= float(t.steps)*float(t.steps)*0.00004;//ao\n        float fog = 1.0 / (1.0 + t.d*t.d*0.05);\n        tcol*=fog;\n        if(m.reflection>0.0&&times<MAX_RERAY-1) {\n            ray = refl;\n            //ray = normalize(ray + 0.5*ray*texture(iChannel0, t.end).xyz);//add distortion\n            //ray = normalize(ray + 0.5*ray*rand3(t.end*4.));//add distortion\n            cam = t.end + ray*HIT_THRESHOLD;\n            col += tcol*(1.-m.reflection);\n            /*\n            for(int reach = 0; reach<16; reach++) {\n                SDF s = sdf(cam);\n                if(s.d<=HIT_THRESHOLD*20.) {\n                    cam += ray*0.08;//(HIT_THRESHOLD-s.d)*40.;\n                } else {\n                    break;\n                }\n            }\n\t\t\t*/\n        } else if (m.reflection<0.) {//signifies a portal\n            Portal por = portals[m.pi];//in portal\n            Portal OUT = portals[por.endPortal];//out portal\n            col += tcol*0.0 + 0.4*por.color*pow(1.7-dot(normalize(cam-t.end), norm), 8.);//add portal glow\n            vec3 off = t.end-por.start;//offset from the original portal\n            cam = OUT.start+off;//specify the new starting position after portal\n            float sdd = t.sdf.d;\n            ray = normalize(mix(ray, -norm, 0.0));\n            for(int reach = 0; reach<20; reach++) {//leave the portal region sdf\n                SDF s = sdf(cam);\n                if(s.d<=HIT_THRESHOLD) {\n                    cam += ray*0.2;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            //tcol *= texture(iChannel1, getTexPos(t.end, norm)*0.1).r;//texture everything\n            if(pm.reflection>0.0) {\n            \tcol = col*(1.-pm.reflection) + tcol*(pm.reflection);\n            } else {\n                col += tcol;\n            }\n            break;\n        }\n        pm = m;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1609, 1715, 1751, 1751, 1833], [1834, 1834, 1856, 1856, 1900], [1901, 1901, 1922, 1922, 1974], [1975, 2020, 2053, 2053, 2254], [2255, 2255, 2275, 2275, 2289], [2290, 2290, 2308, 2308, 2322], [2323, 2544, 2577, 2640, 2693], [2694, 2778, 2842, 2842, 2963], [2964, 2964, 2998, 2998, 3024], [3025, 3025, 3057, 3073, 3265], [3266, 3266, 3298, 3298, 3345], [3346, 3346, 3376, 3376, 3407], [3408, 3408, 3455, 3455, 3613], [3614, 3614, 3644, 3644, 3683], [3684, 3724, 3750, 3750, 3857], [3858, 3858, 3885, 3885, 3923], [3924, 3924, 3951, 3951, 4026], [4027, 4027, 4045, 4045, 4763], [4764, 4764, 4803, 4803, 5640], [5665, 5665, 5695, 5695, 5932], [5933, 5933, 5990, 6040, 9521]]}
{"id": "3lj3zK", "name": "Floods", "author": "dagbrynildsentholander", "description": "flooding", "tags": ["raymarching", "terrain"], "likes": 7, "viewed": 403, "published": "Public API", "date": "1560284815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float maxDist = 75.;\nvec3 camRot = vec3(0, 0, 0);\nvec3 lightDir = vec3(.8,1.,-.1);\nvec3 lightColor = vec3(.65,.55,.5)*1.5;\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*16.+p.y*6463.)*3732.);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 id = floor(p*10.);\n    vec2 ld = fract(p*10.);\n    \n    ld = ld*ld*(3.-2.*ld);\n    \n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n    \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return bt;\n}\n\nfloat getWaterHeight(vec3 p)\n{\n    return  4.+ iTime/20.+smoothNoise(p.xz/3.+iTime/7.)/200.;\n}\n\nvec2 map(vec3 p)\n{\n    float waterHeight = getWaterHeight(p);\n    float a = p.y*0.3;\n    p+=vec3(sin(a), 0, cos(a))*4.;\n    float mat = 0.;\n    float terrainHeight=25.;\n    float base = smoothNoise(p.xz/640.)*terrainHeight;\n    base += 0.5*pow(smoothNoise(p.xz/320.), 3.)*terrainHeight;\n    base += 0.125*pow(smoothNoise(p.xz/80.), 3.)*terrainHeight;\n    base += 0.02*pow(smoothNoise(p.xz/20.), 2.)*terrainHeight;\n    //p-=vec3(sin(a), 0, cos(a))*7.;\n    base += 0.005*pow(smoothNoise(p.xz/7.), 2.)*terrainHeight;\n    if(p.y <= waterHeight)\n    {\n        mat = 1.;\n        return vec2(waterHeight-p.y, mat);\n    }\n    return vec2(base-p.y, mat);\n}\n\n\nvec2 ray(vec3 ro, vec3 rd, float minD, float maxD, float stepSize) // x channel - distance to hit, y channel - material\n{\n    float t = minD;\n    float lastVal; \n    \n    while(t < maxD)\n    {\n        vec2 mapSample = map(ro+rd*t);\n        if(mapSample.x > 0.)\n            return vec2(t-(abs(mapSample.x)/(abs(mapSample.x)+abs(lastVal)))*stepSize, mapSample.y);\n        t+=stepSize;\n        stepSize*=1.01;\n        lastVal = mapSample.x;\n    }\n    \n    return vec2(maxD, 0);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.01;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p).x;\n    vec3 grad = vec3(val - map(p - x).x, val - map(p - y).x, val - map(p - z).x);\n    return -normalize(grad);\n}\n\n\nvec3 lighting(vec3 n, vec3 ambientLight)\n{\n    return  max(pow(dot(normalize(lightDir), n), 5.), 0.0) * lightColor * 1.25 +ambientLight;\n}\n\nvec3 doFog(vec3 rgb, float dist, float maxD, vec3 rd, vec3 p)\n{\n    lightDir = normalize(lightDir);\n    vec3 fogColor = vec3(0.12, 0.11, 0.13);\n    fogColor += 2.*vec3(0.14, 0.12, 0.14)*pow(1.-abs(rd.y), 6.);\n    fogColor += .6*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 3.);\n    if(dist == maxD)\n    {\n    \tfogColor += .3*lightColor*smoothNoise(vec2(p.x, p.z)*10./rd.y/7000.)*smoothNoise(vec2(p.x, p.z)*10./rd.y/3000.)*pow(abs(rd.y), .5);\n        fogColor += .3*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 50.); \n    }\n    return mix(rgb, fogColor, pow(dist/maxD, 1.));\n}\n\nvec3 terrainColor(vec3 p)\n{\n    vec3 n = normal(p);\n    float xAlpha = pow(abs(n.x), 2.);\n    float yAlpha = pow(abs(n.y), 7.);\n    float zAlpha = pow(abs(n.z), 2.);\n    vec3 terrainColor = vec3(0);\n    terrainColor += texture(iChannel0, vec2(p.z, p.y)/7.).xyz*xAlpha;\n    terrainColor += .5*texture(iChannel1, vec2(p.x, p.z)/10.).xyz*yAlpha*vec3(.5,.63,.5);\n    terrainColor += .5*texture(iChannel1, vec2(p.x, p.z)/3.).xyz*yAlpha*vec3(.5,.63,.5);\n    terrainColor += texture(iChannel0, vec2(p.x, p.y)/7.).xyz*zAlpha;\n    return terrainColor*lighting(n, vec3(0.01));\n}\n    \nvec3 waterColor(vec3 p, vec3 rd)\n{\n    vec3 reflectedRd = reflect(rd, normal(p));\n    vec2 rayResult = ray(p, reflectedRd, 1., maxDist, 0.5);\n    vec3 reflection = doFog(terrainColor(p+reflectedRd*rayResult.x), rayResult.x, maxDist, reflectedRd, p);\n    return mix(vec3(.22, .2, .18), reflection, clamp(0.5-pow(rd.y, 2.), 0., 1.));\n}\n\nfloat screenRain(vec2 p, vec3 rd)\n{\n    p.y/=50.;\n\n    return smoothNoise(p+vec2(1., mod(iTime, iResolution.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -  iResolution.xy*.5)/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float lastXInput = 0.;\n    float lastYInput = 0.;\n    float deltaXInput = iMouse.x-lastXInput;\n    float deltaYInput = iMouse.y-lastYInput;\n    camRot+=vec3(deltaYInput/100., deltaXInput/100., 0);\n    vec3 camP = vec3(0, 6.+getWaterHeight(vec3(1)), iTime/4.);\n    vec3 camDir = normalize(vec3(sin(camRot.y), sin(camRot.x), cos(camRot.y)));\n    vec3 camRight = cross(camDir, vec3(0, 1., 0));\n    vec3 rd = normalize(camDir + camRight*1.*uv.x + vec3(0,1.,0)*1.*uv.y);\n    vec2 rayResult = ray(camP, rd, .3, maxDist, 0.1);\n    vec3 p = camP+rd*rayResult.x;\n\tvec3 col = vec3(0);\n    if(rayResult.y == 0.)\n        col = doFog(terrainColor(p), rayResult.x, maxDist, rd, p);\n    if(rayResult.y == 1.)\n        col = doFog(waterColor(p, rd), rayResult.x, maxDist, rd, p);\n    \n    col += .02*lightColor*pow(screenRain(uv*30.-camRot.y*15., rd), 25.);\n    col += .07*lightColor*pow(screenRain(uv*20.-camRot.y*10., rd), 25.);\n    col += .15*lightColor*pow(screenRain(uv*10.-camRot.y*10., rd), 25.);\n    col += .15*lightColor*pow(screenRain(uv*5.-camRot.y*10., rd), 25.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    lastXInput = iMouse.x;\n    lastYInput = iMouse.y;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 145, 145, 195], [197, 197, 224, 224, 590], [592, 592, 622, 622, 686], [688, 688, 706, 706, 1335], [1338, 1338, 1459, 1459, 1814], [1816, 1816, 1837, 1837, 2113], [2116, 2116, 2158, 2158, 2254], [2256, 2256, 2319, 2319, 2839], [2841, 2841, 2868, 2868, 3409], [3415, 3415, 3449, 3449, 3748], [3750, 3750, 3785, 3785, 3865], [3867, 3867, 3924, 3974, 5301]]}
{"id": "3lj3zy", "name": "Give it Moire", "author": "willstall", "description": "Just a simple wallpaper screensaver w/ too much moire", "tags": ["moire"], "likes": 7, "viewed": 755, "published": "Public API", "date": "1560052580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\n    precision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n#define SECONDS 60.0\n\nfloat random(vec2 st){ return fract(sin(dot(st.yx,vec2(14.7891,43.123)))*312991.41235); }\nfloat random (in float x) { return fract(sin(x)*43758.5453123); }\n\nfloat cell_random(float x,float scale)\n{   \n    float iPos = floor(x*scale);\n    return mix(random(iPos), random(iPos + 1.0), smoothstep(0.,1.,fract(x*scale)));\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nfloat lines(vec2 st)\n{\n    st -= st.y-st.x;    // go diagonal\n    return sin(st.x*10.0);\n}\n\nvec2 map(vec2 st, float t)\n{\n    vec2 pos = vec2(0.0);\n        pos += vec2(0.4)*rotate(TWO_PI*t);\n    \n    st = st-pos;\n\n    float freq = mix(1.5,2.25,cell_random(sin(PI + iTime*.15),5.0));\n    float amount = mix(0.08,0.35,cell_random(sin(TWO_PI*.75+iTime*.0025),10.0));\n    float c = length(st);\n    float sq = mix(1.0,10.0, cell_random(sin(PI + iTime*.005),50.0));\n    float scale = mix(sq,4.0,0.5+0.5*sin(st.x*st.y*st.y*4.0));\n    vec2 uv = st + (c)*freq*cos(c*scale-TWO_PI*4.0)*amount;\n\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float t = fract(iTime/SECONDS);\n\n    st = center(st);\n    st = st * 2.0 - 1.0;\n    st *= rotate(PI*0.25);\n\tst *= rotate(TWO_PI*iTime*0.0015);\n\n    vec2 m = map(st,t);\n\n    float r = cell_random(length(m)+iTime*0.023,10.0);\n\n    float stripes = sin(m.x*50.0);\n    float d = dot(m,st)+0.1;\n\n    float c_repeats = mix(20.0,100.0,cell_random(sin(iTime*.035),10.0));\n\n    vec3 c_sin = cos(vec3(0.15,.32,0.3)+d*c_repeats + iTime );\n    vec3 color = c_sin-d-stripes;\n        color += r;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 177, 177, 244], [245, 245, 272, 272, 310], [312, 312, 352, 352, 474], [476, 476, 502, 502, 569], [571, 571, 593, 593, 705], [707, 707, 729, 729, 797], [799, 799, 827, 827, 1306], [1308, 1308, 1363, 1363, 1923]]}
{"id": "3ljGW3", "name": "Seascape - my version", "author": "Voltage", "description": "My take on TDM's awesome seascape shader - https://www.shadertoy.com/view/Ms2SD1", "tags": ["procedural", "noise", "waves", "sea", "water", "subsurface"], "likes": 3, "viewed": 233, "published": "Public", "date": "1561360320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 12;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-5;\n#define EPSILON_NRM (0.15 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 10;\nconst int ITER_FRAGMENT = 6;\nconst float SEA_HEIGHT = 0.2;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.6;\nconst float SEA_FREQ = 0.56;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22) * 0.5;\nconst vec3 SEA_WATER_COLOR = vec3(0.1,0.2,0.4) * 0.75;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.0,1.0,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0)*0.5+0.2, (1.0-e.y)*0.6, (0.6+(1.0-e.y)*0.4)*0.7)*(pow(e.y,10.9)+0.05)*13.2;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \t//d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        //choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,4.0) * 0.75;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,2000.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    //vec3 color = vec3(fresnel);\n    //vec3 color = refracted;\n        \n    float atten = max(1.0 - dot(dist,dist) * 0.0001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.28 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0))*2.0;\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(0.0)*0.1,sin(0.0)*0.2+0.3,0);    \n    vec3 ori = vec3(0.0,3.5,5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); //dir.z += length(uv) * 0.15;\n    dir = normalize(dir);// * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0)/pow(length(dist),0.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljGW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[680, 688, 714, 714, 1060], [1061, 1061, 1083, 1083, 1163], [1164, 1164, 1190, 1190, 1491], [1493, 1505, 1543, 1543, 1585], [1586, 1586, 1632, 1632, 1732], [1734, 1741, 1767, 1767, 1902], [1904, 1911, 1952, 1952, 2123], [2125, 2125, 2144, 2144, 2588], [2590, 2590, 2618, 2618, 3066], [3068, 3068, 3131, 3131, 3701], [3703, 3714, 3749, 3749, 3940], [3942, 3942, 3998, 3998, 4510], [4512, 4520, 4577, 4577, 5417]]}
{"id": "3llXRr", "name": "superwarp checkerboard 1", "author": "cmarangu", "description": "drag te mose\ntest [img]https://www.shadertoy.com/view/3llXRr[/img]", "tags": ["circles", "checkerboard", "xor", "kaleidescope"], "likes": 4, "viewed": 144, "published": "Public", "date": "1561844548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    \n    // teh number of centers\n    const float numcenters = 3.0;\n    \n    // ...\n    const bool fancypantsmode = true;\n    \n    const float incr = PI*2.0/numcenters;\n    const float maxx = PI*2.0-0.01;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    float cx = iResolution.x/2.0;\n    float cy = iResolution.y/2.0;\n    \n    float w = iResolution.x;\n    float h = iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n    for (float d=0.0; d<=maxx; d+=incr) {\n        float _r = distance(iMouse.xy, vec2(cx, cy))/iResolution.x;\n        float _t = atan(iMouse.y-cy, iMouse.x-cx);\n    \tfloat r = iResolution.x*20.0*25.0*sin(_t-PI/3.0)*sin(_t-PI/3.0)/distance(\n            fragCoord,\n            vec2(cx+cos(d-_t)*w*_r, cy-sin(d-_t)*w*_r)\n       \t)+iTime*26.0;\n        b += r;\n        r = floor(r/255.0*2.0)*255.0/2.0;\n        a += r;\n    }\n    // c = floor(c/255*2)*255/2;\n    b *= 2.0/numcenters;\n    a = mod(a, 255.0);\n    b = mod(b, 255.0);\n    a *= 2.0;\n    \n    if (fancypantsmode) {\n    \t// black/blue/cyan/white gradient pattern\n    \tcol = vec3(min(a, b)/255.0, a/255.0, max(a, b)/255.0);\n    }\n    else {\n    \t// classic black/white crisp checkerboard pattern\n    \tcol = vec3(a/255.0, a/255.0, a/255.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1558]]}
{"id": "3lSGDK", "name": "Laser in red smoke", "author": "falldeaf", "description": "Based on https://www.shadertoy.com/view/llsSzB\n\nWas just playing around trying to get a smoldering effect but it didn't really work so I changed tac.", "tags": ["red", "smoke", "laser"], "likes": 6, "viewed": 512, "published": "Public API", "date": "1561056527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise & fbm from : https://www.shadertoy.com/view/Xds3Rj\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));\n}\n\nfloat lhash(float x, float y)\n{\n\tfloat h = 0.0;\n\t\n\tfor(int i = 0;i < 5;i++)\n\t{\n\t\th += (fract(21654.65155 * float(i) * sin(35.51 * x + 45.51 * float(i) * y * (5.0 / float(i))))* 2.0 - 1.0) / 10.0;\n\t}\n\treturn h / 5.0 + 0.02;\n\treturn (fract(21654.65155 * sin(35.51 * x + 45.51 * y))* 2.0 - 1.0) / 20.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\n\n//Fractal Brownian Motion \nfloat fbm(vec2 p)\n{\n\tfloat v = 0.0, f = 1.0, a = 0.5;\n\tfor(int i = 0;i < 5; i++)\n\t{\n\t\tv += noise(p * f) * a;\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//Fun start here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //change the animation speed\n    float time = iTime*1.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 -1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    vec4 m = iMouse / iResolution.xxxx;\n\n    float p = fbm(vec2(noise(uv+time/2.5),noise(uv*2.+cos(time/2.)/2.)));\n\t//uncomment for more plasma/lighting/plastic effect..\n    //p = (1. - abs(p * 2.0 - 1.0))*.8;\n\n\tvec3 col = pow(vec3(p),vec3(0.3))-0.4;\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.2,pow(1.0 / 2.0,0.5) - uv.y/40.0) );\n    float s = smoothstep(.35,.6,col.x);\n    float s2 = smoothstep(.47,.6,col.x);\n    float s3 = smoothstep(.51,.6,col.x);\n    //multiply by the inverse to get the \"smoky\" effect, first attempt\n    col*=vec3(1.3,.1,0.1)*s; //add red\n    col+=vec3(0.3,0.4,.1)*s2; //add orange\n    col+=vec3(1.,4.,.1)*s3; //add yellow\n    //made it more bright\n    col*=1.5;\n    \n    float burnpoint = m.x * 2.5 - 1.3;// 0.1;\n    float leftside = burnpoint;\n    float normalized = abs(uv.x - burnpoint);\n\n    if(uv.x < (burnpoint-0.1) + sin(uv.y*9.)/16.) col /= (normalized * 1.9)/0.3;\n    if(uv.x > (burnpoint+0.1) + sin(uv.y*9.)/16.) col /= (normalized * 1.9)/0.3;\n    col /= normalized * 1.;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 81, 81, 128], [130, 130, 150, 150, 213], [215, 215, 246, 246, 516], [518, 518, 539, 539, 826], [828, 855, 874, 874, 1003], [1005, 1022, 1079, 1112, 2285]]}
{"id": "3lsSzr", "name": "Fractal Variations ", "author": "Yusef28", "description": "In spirit of my usual color palatte I attamped to get some red and gold and I like the results. \nTry full screen!\n\nThe Original: https://www.shadertoy.com/view/llc3Ws\nAn early variation: https://www.shadertoy.com/view/WtsSzn", "tags": ["2d", "fractal", "planedeformation", "red", "anotherfractalthing"], "likes": 7, "viewed": 133, "published": "Public", "date": "1561899877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A lot of this was hacky and improvised without too much thought.\n//I made changes based on the stuff I know and looked at the result and made more changes.\n//for more info you can check out:\n\n//My earlier variation: https://www.shadertoy.com/view/WtsSzn\n//The Original: https://www.shadertoy.com/view/llc3Ws\n\n#define vNum 2.\n//number of variations\n\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //these lines let me divide the screen into for coord systems\n    //from 0-1 so I can have the 4 variations\n    float id = floor(uv*vNum).x+floor(uv*vNum).y*vNum;\n    uv = fract(uv*vNum);\n    \n    //these give me the vignetting,its applied to each of the 4 coord\n    //systems now. You can delete this and the \"*vig\" line at the\n    //end of the code to see it without, not a big deal\n    vec2 qt = uv;\n    qt *=  1.0 - qt.yx;\n    float vig = qt.x*qt.y*15.;\n    vig = pow(vig, 0.15);\n    \n    //saving uv by using a new variable for some reason...\n   \tvec2 st = uv;\n    \n    //all the basic screen scaling stuff at the beginning of most shaders\n    st=st*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    \n\n    //init a color variable\n    vec3 color;\n    \n    \n\t//I do this again? why? I already did it above. This is an example\n    //of a random accident that ends up working out.\n    st = st*2.0-1.; //it just scales the space back more\"*2.\" and shifts things \"-1\" riht and up I believe\n    \n    \n    \n    //this cool df thing comes from \"kig\" on shadertoy: https://www.shadertoy.com/view/lll3DB\n    //I improvised on it, not sure what it all does yet though.\n    float df = pow(abs(st.y+.9)*uv.x*uv.x, 2.9)+pow(abs(st.x+1.)*uv.y*uv.y, 2.);\n  \tst *= 1.0+.5*df;\n    //tryed adding even more to the df\n    //df /= pow(abs(st.y-1.39)*uv.x*uv.x*uv.x*uv.x, .9)+pow(abs(st.x-5.)*uv.y*uv.y, 0.4);\n\n    //moves pattern left in time, shows as a rotation because of the \n    //warping by the df code but it's just a shift left\n    st.x += iTime*1.0;\n    //st.y += iTime*1.0;\n    \n    //some more scaling\n    st/=1.328;\n    st/=10.;\n    \n    //gold color\n    vec3 gold = vec3(213., 123.,15.)/255.;\n    \n    \n    //a loop for the crazy fractal stuff\n    for(int i= 0;i<7;i++)\n    {\n        \n        //I mult the screen by the absolute value of sin(1.48)? what lol\n        //sin(1.48) is just a number, I could have just use the number with \n        //either a positive or negative value. lol what? This is the only\n        //i'll try to come back and fix this one.\n        st*=abs(sin(1.48 ));    \n        //then rotate the space \n        st = st*rot(1.4);\n        //and then I repeat the two above randomly based on what ends\n        //up looking good.\n        st = st*rot(1.4);\n        st*=abs(sin(2.48 ));\n        st = st*rot(1.4);\n        st/=abs(sin(10.48 ));\n        \n        //and then I scale the space once more after getting the absolute\n        //values of st.\n        st = abs(st)*2.0-1.0;\n        \n\t\t//This allows the fractal to move and actually is very important\n        //for some reason.\n\t\tst=fract(st+iTime/100.)-0.5;\n      \n        //here I add (subtract) some shapes that obviously end up being negative, to the color\n        //teh shapes are really just types of circles and they have I believe\n        //opacity values based on the index of the for loop.\n        \n        \t\t//the base color, id gives variation, it goes form (0-3)\n    \tcolor -= (cos(vec3(0.200+id/3.,0.994,0.9464) \n                      //another circle, with id for variation\n                  -  (  1./pow(1.0-smoothstep(0.5, 0.62+id/9. , length(st)), 1.)*2. \n                  //subtracting another circle I guess to create rings, and more id for \n                      //omre variation, and float(i) changes things based on the for loop index\n                      - (smoothstep(0.3, .48+id/2. , length(st))) + float(i)*40.)));\n    \t\n        //then I mix gold in based on the value of a basic length(st) when it's beyond 0.55\n        color = mix(color, gold, smoothstep(0.55,0.6, length(st)));\n        \n        \n        //most likely this is only really important because I didn't increase\n        //the scaling earlier. You could probably delete this and\n        //add st*=1.5 somewhere else and get a similar result.\n        //however the +id/9 adds somethign to it.. maybe it just shift based on \n        //the variation number (0 - 3)\n        st*=1.5+id/9.;\n\n    }\n    \n\tfragColor = vec4(color*vig/1.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 351, 370, 370, 427], [429, 429, 486, 486, 4540]]}
{"id": "3sjSRD", "name": "Deformed spheres", "author": "matistjati", "description": "Raymarching spheres using a deformed distance function", "tags": ["raymarching"], "likes": 1, "viewed": 141, "published": "Public", "date": "1560028044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mapSphere(vec3 p, vec3 ray, float radius)\n{\n\treturn length(p - ray) - radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat mapAll(vec3 p, float time)\n{\n    const float disp = 7.;\n    const float speed = 0.5;\n    float displacement = sin(sin(time * speed) * p.x * disp)\n        * cos(sin(time * speed) * p.y * disp)\n        * sin(sin(time * speed) * p.z * disp) * 0.25;\n\n    float sphere_0 = mapSphere(p, vec3(-2.*sin(time * speed),0.,0.), 1.0) + displacement;\n\tfloat sphere_1 = mapSphere(p, vec3(1.*sin(time * speed),0.,0.), 1.0) + displacement;\n\n    \n    return smin(sphere_0, sphere_1, 32.);\n}\n\nvec3 calculateNormal(in vec3 p, float time)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapAll(p + small_step.xyy, time) - mapAll(p - small_step.xyy, time);\n    float gradient_y = mapAll(p + small_step.yxy, time) - mapAll(p - small_step.yxy, time);\n    float gradient_z = mapAll(p + small_step.yyx, time) - mapAll(p - small_step.yyx, time);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 trace(vec3 ro, vec3 rd, float time)\n{\n    int maxSteps = 10;\n\n    float t = 0.0;\n    float totalDist = 0.0;\n    \n    int i = 0;\n    for (; i < maxSteps; i++)\n    {\n        vec3 position = ro + rd * t;\n    \tfloat dist = mapAll(position, time);\n        totalDist += dist;\n        \n        if (totalDist > 4.0)\n        {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        \n        if (dist < 0.01)\n        {\n            vec3 normal = calculateNormal(position, time);\n\t\t\t\n            vec3 lightPosition = vec3(2.0, -5.0, 3.0);\n\n            vec3 directionToLight = normalize(position - lightPosition);\n\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n\t\t\tvec3 light = vec3(0.0, abs(sin(iTime)), abs(cos(iTime))) * diffuseIntensity;\n            \n            \n            return light;\n            //return texture(iChannel0, position.xy, 0.0).xyz;\n        }\n        t += dist;        \n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 origin = vec3(.5, 0.0, -2);\n    // Time varying pixel color\n    vec3 col = trace(origin, vec3(uv.xy, 1), iTime);\n\n    fragColor = vec4(col.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 85], [87, 87, 128, 128, 202], [204, 204, 238, 238, 682], [684, 684, 729, 729, 1151], [1153, 1153, 1195, 1195, 2117], [2121, 2121, 2178, 2228, 2489]]}
{"id": "3sSSzG", "name": "Oak foise2", "author": "deerfeeder", "description": "A mirrored noise/", "tags": ["swirl", "perlin", "curl", "simplex"], "likes": 5, "viewed": 107, "published": "Public", "date": "1560938690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Oak foise\" by deerfeeder. https://shadertoy.com/view/MtKcD3\n// 2019-04-01 13:33:55\n\n\nconst int noiseSwirlSteps = 8;\nconst float noiseSwirlValue = 0.5;\nconst float noiseSwirlStepValue = noiseSwirlValue / float(noiseSwirlSteps);\n\nconst float noiseScale = 2.;\nconst float noiseTimeScale = 0.15;\n\n\nfloat simplex(vec3 v);\nfloat getNoise(vec3 v);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 0.5-fragCoord.xy / iResolution.xy;\n  \tuv = abs(uv);\n\tfloat noise = getNoise(vec3(uv * noiseScale, iTime*noiseTimeScale));\n    noise = noise * noise * noise * noise * 0.5;  //more contrast\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n\n\nfloat fbm3(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result /= (1. + 1./2. + 1./4.);\n    return result;\n}\n\nfloat fbm5(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result += simplex(v * 8.) / 8.;\n    result += simplex(v * 16.) / 16.;\n    result /= (1. + 1./2. + 1./4. + 1./8. + 1./16.);\n    return result;\n}\n\nfloat getNoise(vec3 v) {\n    //  make it curl\n    for (int i=0; i<noiseSwirlSteps; i++) {\n    \tv.xy += vec2(fbm3(v), fbm3(vec3(v.xy, v.z + 1000.))) * noiseSwirlStepValue;\n    }\n    //  normalize\n    return fbm5(v) / 2. + 0.5;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 219.0)) * 219.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 299.0)) * 299.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*4.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.790159 - 0.3095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.00, 1.0/3.00) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 3.22);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 200.0 *sin(iTime * 0.1) * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }", "image_inputs": [{"id": "MlB3Wc", "previewfilepath": "https://soundcloud.com/miiiis/mi-ish-sungod", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/miiiis/mi-ish-sungod", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 355, 412, 412, 661], [665, 665, 685, 685, 845], [847, 847, 867, 867, 1118], [1120, 1120, 1144, 1165, 1347], [1349, 1741, 1762, 1762, 1811], [1813, 1813, 1834, 1834, 1883], [1885, 1885, 1907, 1907, 1946], [1948, 1948, 1976, 1976, 2013], [2015, 2015, 2040, 2040, 4203]]}
{"id": "3t23DD", "name": "Hash without sin", "author": "Carandiru", "description": "copy of original hash without sine @https://www.shadertoy.com/view/4djSRW\njust comparing in slow motion\n", "tags": ["sin", "random", "hash", "psudeo"], "likes": 2, "viewed": 419, "published": "Public", "date": "1559641754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on all systems\n// and doesn't rely on trigonometry functions that lose accuracy with high values. \n// New one on the left, sine function on the right.\n\n// *NB: This is for integer scaled floats only! i.e. Standard noise functions.\n\n#define ITERATIONS 1\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//###############################################################################\n\n//----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\nfloat hashOld13(vec3 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec3(12.9898, 78.233, 1.618))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfloat a = 0.0, b = a;\n    float scaled_time = iTime * 0.00005f;\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t+1);\n        vec3 pos = vec3(position * v + scaled_time, (position.x + position.y) * v + scaled_time);\n        a += hash13(pos);\n    \tb += hashOld13(pos);\n    }\n    vec3 col = vec3(mix(b, a, step(uv.x, .5))) / float(ITERATIONS);\n\n    col = mix(vec3(.4, 0.0, 0.0), col, smoothstep(.5, .495, uv.x) + smoothstep(.5, .505, uv.x));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t23DD.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[473, 583, 606, 606, 691], [693, 803, 825, 825, 942], [944, 1054, 1077, 1077, 1180], [1182, 1292, 1314, 1314, 1443], [1445, 1556, 1577, 1577, 1711], [1713, 1824, 1846, 1846, 1965], [1967, 2077, 2099, 2099, 2232], [2235, 2346, 2367, 2367, 2503], [2505, 2616, 2638, 2638, 2763], [2765, 2874, 2896, 2896, 3044], [3046, 3155, 3176, 3176, 3325], [3327, 3436, 3457, 3457, 3606], [3608, 3717, 3739, 3739, 3873], [3958, 4049, 4074, 4103, 4356], [4357, 4357, 4382, 4411, 4671], [4672, 4672, 4698, 4698, 4856], [4858, 4949, 5006, 5006, 5578]]}
{"id": "3t23Wc", "name": "Basic blobs", "author": "Naiw", "description": "Playing around with sphere tracing.", "tags": ["spheretracing"], "likes": 3, "viewed": 142, "published": "Public", "date": "1561385837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nJust playing around.\n*/\n\nfloat sphere(vec3 pos, vec3 sp, float radius) \n{\n    return length(sp-pos)-radius;\n}\n\nfloat blend(float a, float b, float alpha) {\n\tfloat ramp = clamp(0.5+0.5*(b-a)/alpha,0.,1.0);\n    return mix(b,a,ramp)-alpha*ramp*(1.-ramp);\n}\n\nfloat distanceFunction(vec3 pos) {\n    float td = 100.0;\n    for(int i=10;i<30;i+=2) {\n        float ip = float(i)/50.0;\n        vec3 newP = vec3(pos.y,pos.y,pos.z);\n\t    td = blend(td,\n         sphere(newP,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    for(int i=11;i<30;i+=2) {\n        float ip = float(i)/50.0;\n        vec3 newP = vec3(pos.x,pos.x,pos.z);\n\t    td = blend(td,\n         sphere(newP,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    for(int i=1;i<30;i++) {\n        float ip = float(i)/50.0;\n\t    td = blend(td,\n         sphere(pos,vec3(sin(ip)*.5-cos(iTime*ip+sin(ip)),cos(ip)*.5+sin(iTime*ip+cos(ip)),4.0),0.2),0.3);\n    }    \n    return td;\n}\n\nstruct traceResult {\n\tfloat total_dist;\n    float dist;\n    vec3 position;\n};\n\n\nfloat trace(vec3 ro, vec3 rd) {\n\tfloat d = 0.0;\n    float td = 0.0;\n    vec3 rp;\n    for(int x=0;x<20;x++) {\n\t\trp = ro + rd * d;\n        td = distanceFunction(rp);\n        if(td < 0.001) {\n            break;\n        } else if(td > 10.0) {\n            return 0.;\n        }\n        d += td;\n    }\n    \n    traceResult tr = traceResult(d, td, rp);\n    vec3 light = vec3(sin(-iTime*.5)*10.,cos(iTime*.6)*10.,-4.);\n    vec3 l = normalize(light - tr.position);\n    vec2 e = vec2(0.01,0);\n    vec3 n = normalize(tr.dist - vec3(distanceFunction(tr.position-e.xyy),\n                            distanceFunction(tr.position-e.yxy),\n                            distanceFunction(tr.position-e.yyx)));\n    return clamp(dot(n,l),0.,1.);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    float color = trace(ro, rd);\n    \n    vec3 col = vec3(color);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t23Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 76, 76, 112], [114, 114, 158, 158, 256], [258, 258, 292, 292, 1024], [1106, 1106, 1137, 1137, 1835], [1839, 1839, 1896, 1896, 2136]]}
{"id": "3t23WG", "name": "Cosine - distance 2D", "author": "iq", "description": "Exact euclidean distance to a cosine wave of arbitrary amplitude, frequency, phase and offset. It is exact indeed but requires 12 iterations to get full floating point precision.", "tags": ["2d", "sdf", "distance", "cosine"], "likes": 26, "viewed": 957, "published": "Public API", "date": "1560942443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to cosine wave of arbitrary amplitude, frequency, phase and offset\n// by reducing the problem to the first quadrant of a unit cosine wave, and then\n// finding the derivative of the distance squared. The problem reduces to\n//\n// For y(x) = wÂ·cos(x)\n//\n// dÂ² (p,x) = (x-p.x)Â² + (wÂ·cos(x)-p.y)Â²\n// dÂ²'(p,x) = 2[x-p.x - wÂ·sin(x)Â·(wÂ·cos(x)-p.y)] = 0\n//\n// I implemented two different root finders. A simple bisection method which uses\n// 24 iterations to give full floating point precision, and an 8 iterations\n// bisection followed by 4 newtown-raphson method (12 iterations total) that\n// provides full floating point precision as well. I am always worried about\n// convergence of newtwon-raphson methods, so I give it only as an option.\n\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n#define METHOD 0  // make 1 for newtown-raphson\n   \n\n\n#if METHOD==0\n//----------------------------------------------------------------------\n// Distance to y(x) = a + b*cos(cx+d)\n//----------------------------------------------------------------------\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\n#else\n\n//----------------------------------------------------------------------\n// Distance to y(x) = a + b*cos(cx+d)\n//----------------------------------------------------------------------\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n    \n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<8; i++ ) // bisection, 7 bits more or less\n    {\n        float x = 0.5*(xa+xb);\n        float si = sin(x);\n        float co = cos(x);\n        float y = x-p.x+b*c*si*(p.y-b*c*co);\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    for( int i=0; i<4; i++ ) // newtown-raphson, 28 bits more or less\n    {\n        float si = sin(x);\n        float co = cos(x);\n        float  f = x - p.x + b*c*(p.y*si - b*c*si*co);\n        float df = 1.0     + b*c*(p.y*co - b*c*(2.0*co*co-1.0));\n        x = x - f/df;\n    }\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/3.0;\n    float ca = 0.0 + 0.4*cos(t*1.1+1.0); // offset    (y position)\n    float cb = 0.3 + 0.2*cos(t*1.2+0.0); // amplitude (y scale)\n    float cc = 9.0 + 6.0*cos(t*1.3+2.0); // frequency (x scale)\n    float cd = 2.0 + 2.0*cos(t*1.0+3.0); // phase     (x position)\n    \n    // sdf\n    float d = udCos( p, ca, cb, cc, cd );\n    \n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.05 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = udCos(m,ca, cb, cc, cd );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t23WG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1837, 4143, 4198, 4198, 5184]]}
{"id": "3t23zh", "name": "Dumbo Pink Elephants on Parade", "author": "nyri0", "description": "I wanted to recreate the whole scene but it's too much work, so here's one of the shots.\nReference: https://youtu.be/jcZUPDMXzJ8?t=124\nYou can adjust the anti-aliasing level or number of lines per cubic BÃ©zier curve.", "tags": ["2d", "animation", "vector", "disney", "bzier"], "likes": 16, "viewed": 587, "published": "Public API", "date": "1559413889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define SPLINE 8\n\n#define ZERO min(iFrame,0)\n\n/* A few explanations are given in my blog post:\n * https://nyri0.fr/en/blog/25\n */\n\n/* Adapted from https://stackoverflow.com/a/218081/8259873\n * Finds out if two lines AB and CD intersect each other */\nint intersects(vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    const vec2 m1 = vec2(1,-1);\n    float c = dot(B, A.yx * m1);\n    vec2 bt = (B - A).yx * m1;\n    if ((dot(C, bt) + c) * (dot(D, bt) + c) > 0.0) return 0;\n\n    c = dot(D, C.yx * m1);\n    bt = (D - C).yx * m1;\n    return ((dot(A, bt) + c) * (dot(B, bt) + c) > 0.0) ? 0 : 1;\n}\n\n/* Utility functions that help calculating the bounding box of \n * a cubic Bezier curve */\nfloat minv(vec4 v)\n{\n    return min(min(v.x,v.y),min(v.z,v.w));\n}\nfloat maxv(vec4 v)\n{\n    return max(max(v.x,v.y),max(v.z,v.w));\n}\n\n/* Calculates the position of the point with parameter t\n * on a cubic Bezier curve */\nvec2 valBezier(vec4 Xs, vec4 Ys, float t)\n{\n    float s = 1.0 - t;\n    vec4 vt = vec4(s*s*s, 3.0*s*s*t, 3.0*s*t*t, t*t*t);\n    return vec2(dot(Xs, vt), dot(Ys, vt));\n}\n\n/* Calculates the number of intersection between the Bezier\n * curve and a line between the given pixel and an arbitrary\n * point outside the curve */\nint nbBezierInter(vec2 uv, vec2[4] pts)\n{\n    const vec2 ref = vec2(0, 1.1);\n    vec4 Xs = vec4(pts[0].x, pts[1].x, pts[2].x, pts[3].x);\n    vec4 Ys = vec4(pts[0].y, pts[1].y, pts[2].y, pts[3].y);\n    if(uv.x < minv(Xs) || uv.x > maxv(Xs)\n       || uv.y < minv(Ys) || uv.y > maxv(Ys))\n        return intersects(uv, ref, pts[0], pts[3]);\n    const int slices = SPLINE;\n    int res = 0;\n    vec2 a = pts[0];\n    float ot = 0.0;\n    for(int i = 1; i < slices; i++)\n    {\n        float t = float(i)/float(slices-1);\n        vec2 b = valBezier(Xs, Ys, t);\n        res += intersects(uv, ref, a, b);\n        a = b;\n    }\n\n    return res;\n}\n\n/* These functions use a Catmull-Rom interpolation to find the control\n * points at the current time and then calculate the number of intersections\n * between the Bezier curve and a line between the given pixel and an\n * arbitrary point outside the curve */\nfloat barry_goldman(vec4 X, vec4 T, float t)\n{\n    vec3 A = ((T.yzw - t) * X.xyz + (t - T.xyz) * X.yzw) / (T.yzw - T.xyz);\n    vec2 B = ((T.zw - t) * A.xy + (t - T.xy) * A.yz) / (T.zw - T.xy);\n\treturn ((T.z - t) * B.x + (t - T.y) * B.y) / (T.z - T.y);\n}\nint nbBezierInter_catmullRom(vec2 uv, vec4[8] pts, vec4 times, float t)\n{\n    vec2[4] inter;\n    for(int l = 0; l < 2; l++) {\n        inter[2*l] = vec2(barry_goldman(vec4(pts[l].x, pts[l+2].x,\n                                           pts[l+4].x, pts[l+6].x),\n                                      times, t),\n                        barry_goldman(vec4(pts[l].y, pts[l+2].y,\n                                           pts[l+4].y, pts[l+6].y),\n                                      times, t));\n        inter[2*l+1] = vec2(barry_goldman(vec4(pts[l].z, pts[l+2].z,\n                                           pts[l+4].z, pts[l+6].z),\n                                      times, t),\n                        barry_goldman(vec4(pts[l].w, pts[l+2].w,\n                                           pts[l+4].w, pts[l+6].w),\n                                      times, t));\n    }\n    return nbBezierInter(uv, inter);\n}\n\n/* Extract 2 points from their compression into an integer */\nvec4 int_to_vec4(uint val) {\n    return vec4((float(val & 255u) - 128.0) / 70.0,\n                (float((val >> 8u) & 255u) - 128.0) / 70.0,\n                (float((val >> 16u) & 255u) - 128.0) / 70.0,\n                (float((val >> 24u) & 255u) - 128.0) / 70.0);\n}\n\n/* A nice looking jump from one position to another */\nvec2 jump(vec2 pos1, vec2 pos2, float t1, float t2, float t)\n{\n    if(t <= t1) return pos1;\n    if(t >= t2) return pos2;\n    float ti = smoothstep(t1, t2, t);\n    return vec2(pos1.x*(1.0-ti) + pos2.x*ti,\n                pos1.y*(1.0-ti) + pos2.y*ti + 0.4*ti*(1.0-ti)*abs(pos2.x-pos1.x));\n}\n\n/* Main function */\nvec3 shot1(vec2 pixCoord, float time)\n{\n    const int nbCurves = 27;\nconst uint data[216] = uint[216] (\n2690162012u,2841486681u,2874714461u,2924981334u,2973871703u,3143940700u,3144399716u,3094657395u,3212884084u,3097083283u,\n3097344153u,3114776992u,3098589607u,2947722947u,2881007538u,2846862001u,2796595631u,2645401777u,2581044653u,2178977244u,\n2112782816u,1926788067u,1992192728u,2327218121u,2092927670u,1722380470u,1537828521u,1335252901u,1335775126u,1218333352u,\n1201162398u,1316243318u,1366511220u,1484937090u,1552046210u,1650745971u,1566859876u,1432180576u,1381455197u,1431065677u,\n1497847116u,1665621317u,1749050183u,1832741437u,1950313789u,2018211403u,2051766347u,2337178439u,2201717582u,1966044481u,\n2014803247u,2200404259u,2552595239u,2640092476u,2756681554u,2840896849u,2857281876u,2924325965u,2957028941u,3075781451u,\n3109664596u,3093674593u,3228809317u,3113401990u,3113662866u,3098065571u,3048257704u,2930290360u,2863509160u,2846075559u,\n2795874723u,2661393062u,2613681825u,2178256862u,2078573013u,1925935831u,1957655243u,2327152585u,2075495093u,1688759987u,\n1504208040u,1335317918u,1302548375u,1218136486u,1200900251u,1316243064u,1383419508u,1535137669u,1585142656u,1634754422u,\n1534026096u,1315853436u,1265061486u,1330137936u,1363365704u,1498764620u,1582192981u,1682792780u,1783587917u,1851026514u,\n1934323284u,2336587845u,2201783109u,1948873787u,2014802985u,2200142363u,2569306915u,2672991026u,2705366596u,2856691264u,\n2873076293u,2940054844u,3023155005u,3091838021u,3142367305u,3092887895u,3211114585u,3112222330u,3112483200u,3096754574u,\n3063724180u,2929438379u,2862657179u,2845158040u,2794957205u,2660541080u,2596511380u,2227934409u,2161804491u,1992718036u,\n1991014086u,2376437176u,2242481573u,2041020587u,1958377895u,1705667514u,1622107562u,1419859116u,1419531425u,1502762390u,\n1552898450u,1687052687u,1635804302u,1517248631u,1433950831u,1266109569u,1214925687u,1263618388u,1313688401u,1364939093u,\n1431261531u,1531663950u,1632131915u,1749771593u,1833134155u,2319155764u,2233698875u,1914401339u,1963618843u,2199290126u,\n2501477142u,2655296293u,2689375568u,2890770504u,2907089997u,2974068292u,2973348164u,3125524038u,3159341643u,3143547997u,\n3261774686u,3163079295u,3180117128u,3147546004u,3131292571u,2980032684u,2913251743u,2895818141u,2829036698u,2660541086u,\n2579275412u,2194904024u,2095022803u,1942581971u,1940747209u,2376436667u,2242547109u,1772450737u,1655663013u,1403016877u,\n1319457696u,1251363486u,1267747478u,1350847880u,1400983684u,1602836869u,1568694153u,1517313664u,1433950832u,1266110081u,\n1231965047u,1263618144u,1313753937u,1364938836u,1397772635u,1565088074u,1632066889u,1749771593u,1833134155u,2319221557u,\n2184022588u,1864789575u,1863937830u,2115861015u,2400747037u,2639304749u\n);\n\n    vec2 uv = (2.0*pixCoord - iResolution.xy) / iResolution.y;\n    vec2 uv_base = vec2(5,2.2) * uv;\n    \n    vec2[5] positions = vec2[5] (\n        uv_base * mix(vec2(1.0,1.0), vec2(0.75,0.75), smoothstep(6.5,20.0,time))\n        \t- jump(vec2(0,0.6), vec2(0.0,-0.75), 6.5, 20.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(0.8,0.8), smoothstep(5.5,6.0,time))\n        \t- jump(vec2(0,0.6), vec2(4.5,-0.8), 5.5, 6.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(0.8,0.8), smoothstep(4.5,5.0,time))\n        \t- jump(vec2(0,0.6), vec2(-4.5,-0.8), 4.5, 5.0, time),\n        uv_base * mix(vec2(1.0,1.0), vec2(1.1,1.1), smoothstep(3.0,3.5,time))\n        \t- jump(vec2(0,0.6), vec2(4.6,1.0), 3.0, 3.5, time),        \n        uv_base * mix(vec2(1.0,1.0), vec2(1.1,1.1), smoothstep(2.0,2.5,time))\n        \t- jump(vec2(0,0.6), vec2(-4.6,1.0), 2.0, 2.5, time)\n    );\n    \n    int[5] nbInter = int[5] (0,0,0,0,0);\n    float[5] startingTimes = float[5] (5.5,4.5,3.0,2.0,0.0);\n\n    float animTime = 3.0*time;\n    int k;\n    k = int(animTime);\n    for(int i = 0; i < nbCurves; i++) {\n        vec4[8] pts;\n\n        for(int l = 0; l < 2; l++) {\n          pts[l] = int_to_vec4(data[2*nbCurves*(k % 4)+2*i+l]);\n          pts[2+l] = int_to_vec4(data[2*nbCurves*((k + 1) % 4)+2*i+l]);\n          pts[4+l] = int_to_vec4(data[2*nbCurves*((k + 2) % 4)+2*i+l]);\n          pts[6+l] = int_to_vec4(data[2*nbCurves*((k + 3) % 4)+2*i+l]);\n        }\n        vec4 times = vec4(-1, 0, 1, 2);\n\n        for(int j = 0; j < 5; j++) {\n            if(time >= startingTimes[j]) {\n        \t\tnbInter[j] += nbBezierInter_catmullRom(positions[j], pts, times, fract(animTime));\n            }\n        }\n    }\n\n    vec3 col = vec3(0.15,0,0.15);\n    \n    uv = uv + 0.05 * time * vec2(1,0.4);\n    if((nbInter[0] & 1) == 1) {\n        col = vec3(0.55,0.1,0.55);\n    }\n    if((nbInter[1] & 1) == 1) {\n        col = vec3(0.4,0.05,0.3);\n        float dd = mod(uv.y, 0.1);\n        col = mix(col, vec3(0.7,0.15,0.2), 1.0 - smoothstep(0.03, 0.045, dd) + smoothstep(0.085, 0.1, dd));\n    }\n    if((nbInter[2] & 1) == 1) {\n        col = vec3(0.05,0.6,0.6);\n        float dd = mod(uv.x, 0.1);\n        col = mix(col, vec3(0.3,0.9,0.5), 1.0 - smoothstep(0.03, 0.045, dd) + smoothstep(0.085, 0.1, dd));\n    }\n    if((nbInter[3] & 1) == 1 && (nbInter[1] & 1) == 0) {\n        col = vec3(0.1,0.25,0.9);\n        float dd = mod(uv.y - uv.x, 0.15);\n        col = mix(col, vec3(0.05,0.8,0.9), 1.0 - smoothstep(0.05, 0.07, dd) + smoothstep(0.13, 0.15, dd));\n    }\n    if((nbInter[4] & 1) == 1 && (nbInter[2] & 1) == 0) {\n        col = vec3(0.4,0.0,0.4);\n        vec2 uv_o = uv + vec2(0, 0.042 * round(12.0*uv.x));\n        vec2 uv_grid = vec2(round(12.0*uv_o.x), round(12.0*uv_o.y));\n        col = mix(vec3(0.8,0.77,0.2), col, smoothstep(0.35, 0.45, distance(12.0*uv_o, uv_grid)));\n    }\n    \n    return col;\n}\n\n/* Entry point, manages anti-aliasing */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AAf = float(AA);\n    vec3 avgcol = vec3(0);\n    for(int i = ZERO; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            vec2 coord = fragCoord + vec2(i, j) / AAf;\n            avgcol += shot1(coord, iTime);\n        }\n    }\n   \tfragColor = vec4(avgcol / (AAf * AAf), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t23zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 263, 311, 311, 588], [590, 681, 701, 701, 746], [747, 747, 767, 767, 812], [814, 901, 944, 944, 1068], [1070, 1221, 1262, 1262, 1853], [1855, 2113, 2159, 2159, 2366], [2367, 2367, 2440, 2440, 3273], [3275, 3337, 3365, 3365, 3602], [3604, 3659, 3721, 3721, 3947], [3949, 3969, 4008, 4008, 9529], [9531, 9572, 9629, 9629, 9923]]}
{"id": "3t2GDt", "name": "ZX Spectrum plasma", "author": "klk", "description": "Using pixels color mixing to break color limitations of ZX Spectrum", "tags": ["retro", "plasma", "zx", "8x8"], "likes": 4, "viewed": 436, "published": "Public API", "date": "1561554740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\n\n#define pal(c) vec3(c/4&1,c/2&1,c&1)*( c<8 ? .66 : 1.)\n\n\nstruct NC\n{\n    int i0;\n    int i1;\n    int w;\n};\n\n\nNC near(float3 col)\n{\n    const float3 W=float3(0.299,0.587,0.114);\n    NC res;\n    float rv=100.0;\n    float luma0=dot(col,W);\n    for(int i=0;i<15;i++)\n    {\n        for(int j=i+1;j<16;j++)\n        {\n            for(int f=0;f<4;f++)\n            {\n                float3 icol=mix(pal(i),pal(j),float(f)*.25);\n                float3 dist=(col-icol);\n                dist*=W;\n\n                float d=length(dist);\n                if(d<rv)\n                {\n                    res=NC(i,j,f);\n                    rv=d;\n                }\n            }\n        }\n    }\n    return res;\n}\n\n\nvec3 col(int x, int y)\n{\n\tfloat time=iTime;\n\tvec2 uv = vec2(float(x), float(y))/160.0;\n    vec2 uv0=uv;\n\tfloat i0=1.1;\n\tfloat i1=0.9;\n\tfloat i2=0.5;\n\tfloat i3=0.6;\n\tfloat i4=0.0;\n    float r=0.0;\n    float g=0.0;\n    float b=0.0;\n    float w=0.0;\n\tfor(int s=0;s<4;s++)\n\t{\n\t\tvec2 d;\n\t\td=vec2(cos(uv.y*i0-i4+time/i1),-sin(uv.x*i0-i4+time/i1))/i3;\n        d+=vec2(-d.y,d.x)*0.7;\n\t\tuv.xy+=d;\n        \n\t\ti0=(i0-0.2)*1.1;\n\t\ti1=(i1-2.0)*1.05;\n\t\ti2=(i2-1.51)*1.06;\n\t\ti3*=0.8237;\n\t\ti4+=0.05;\n\t    r+=(sin(uv.x-time)*0.75+0.5)/i2;\n\t    b+=(sin(uv.y+time)*0.75+0.5)/i2;\n\t    g+=(sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.75+0.5)/i2;\n        w+=1.0/i2;\n\t}\n    r/=w;\n    g/=w;\n    b/=w;\n\treturn vec3(r,g,b);\n}\n\nfloat4 border(int y)\n{\n    return float4(pal(int(float(y)+iTime*90.+sin(iTime))/12%8),1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n    int ix;\n    int iy;\n    \n    int sc=int(iResolution.y/192.);\n    \n    ix=int(fragCoord.x)/sc;\n    iy=int(fragCoord.y)/sc;\n    \n    int bx=int(iResolution.x)/sc-256;\n    int by=int(iResolution.y)/sc-192;\n    \n    if((ix<=bx/2)||(ix>=256+bx/2))\n    {\n        fragColor=border(iy);\n        return;\n    }\n    else\n        ix-=bx/2;\n\n    if((iy<=by/2)||(iy>=192+by/2))\n    {\n        fragColor=border(iy);\n        return;\n    }\n    else\n        iy-=by/2;\n    \n    int x0=(ix/8)*8;\n    int y0=(iy/8)*8;\n\n    int fx=ix-x0;\n    int fy=iy-y0;\n\n    NC nc=near(col(x0+4, y0+4));\n    if(iMouse.z>0.)\n    {        \n\t    float3 c=col(ix, iy);\n\t    fragColor = vec4(c,1.0);\n    }\n    else\n    {\n        fragColor = vec4(pal(nc.i0),1.0);\n        switch(nc.w)\n        {\n            case 1:if((fx%2+fy%2)==2)fragColor = vec4(pal(nc.i1),1.0);break;\n            case 2:if((fx+fy)%2==0)fragColor = vec4(pal(nc.i1),1.0);break;\n            case 3:if((fx%2+fy%2)<2)fragColor = vec4(pal(nc.i1),1.0);break;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2GDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 192, 192, 754], [757, 757, 781, 781, 1448], [1450, 1450, 1472, 1472, 1541], [1543, 1543, 1600, 1600, 2645]]}
{"id": "3t2GWK", "name": "antialiasing pixel-size point", "author": "FabriceNeyret2", "description": "top: antialiased. bottom: not.\nMouse.y = zoom.", "tags": ["antialiasing", "tuto"], "likes": 7, "viewed": 356, "published": "Public API", "date": "1561141777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    float s,v, t = iTime/14.;\n    vec2 R = iResolution.xy, u,\n         M = iMouse.xy/R;\n    if ( M == vec2(0) ) M.y = 2.*min(fract(t),fract(-t));  // auto-demo\n    \n    s = exp2(floor(7.*M.y)), v;                            // scaling\n    u = U = floor(U/s);\n    R /= s;\n    \n    U -= vec2( mod(float(iFrame)/16.,R.x), R.y/2. );       // locate points\n    U.x = mod(U.x+25., 50.)-25.;\n    \n    v  = smoothstep(1.5, 0., length( U ) ) / (1.5*1.5);    // antialiased dot\n    v += float( floor( U ) == vec2( 0, -exp2(7.)/s)  );    // aliased dot\n    \n    O = vec4( pow( v, 1./2.2 ) );                          // to sRGB\n    O.r += float (mod(floor(u.x),50.)==0.);                // bars\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2GWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 727]]}
{"id": "3tB3Rd", "name": "Mandelbrot Burning Ship Hybrid", "author": "rycvheldir", "description": "Renders a version where the second and from then on every fourth iteration is a burning ship iteration instead of a mandelbrot iteration.", "tags": ["fractal", "mandelbrot", "burningship"], "likes": 3, "viewed": 317, "published": "Public API", "date": "1560643900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// See here for more information on smooth iteration count:\n//\n// http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n// Modified to change the iteration formula\n\n// increase this if you have a very fast GPU\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float magnification = 16000. ;\n        float x_center = -0.706370390374415 ;\n        float y_center = 0.48035040536878 ;\n\n        \n        magnification = pow(magnification, 1./8.) ;\n        float zoom = 1./magnification+(1.-1./magnification)*(0.5+0.5*cos(.07*time));\n        zoom = pow( zoom,8.0);\n        \n        vec2 c = p ; // fragCoord.xy / iResolution.xy;\n        c=c*zoom;\n        c.y+= y_center;\n        c.x+=1.+x_center;\n\n        const float B = 256.0;\n        float l = 0.0;\n\t    vec2 z  = vec2(0.0);\n        \n        int k = 0 ;\n        for( int i=0; i<1200; i++ )\n        {\n            if (i%4 == 1 && k < 55) {\n                // z = z*z + c\t\t\n                z = vec2( z.x*z.x - z.y*z.y, 2.0*abs(z.x*z.y) ) + c; \n                k += 1;\n                }\n            else {\n                // z = z*z + c\t\t\n                z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n                }\n\t\t\n    \t\tif( dot(z,z)>(B*B) ) break;\n\n    \t\tl += 1.0;\n        }\n\n    \t// ------------------------------------------------------\n        // smooth interation count\n    \t//float sl = l - log(log(length(z))/log(B))/log(2.0);\n        \n        // equivalent optimized smooth interation count\n    \tfloat sl = l - log2(log2(dot(z,z))) + 4.0; \n    \t// ------------------------------------------------------\n\t\n        float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n        l = sl ; // mix( l, sl, al );\n\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tB3Rd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[310, 369, 426, 426, 2418]]}
{"id": "3tB3RG", "name": "Wobbling candy", "author": "jblanper", "description": "Experimenting with boolean operators and ray marching.", "tags": ["3d", "raymarching", "boolean"], "likes": 8, "viewed": 148, "published": "Public", "date": "1559899444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat displacement(vec3 p, float n) {\n  return sin(p.x * n) * cos(p.y * n + n) - sin(p.z + p.y * n);\n}\n\nfloat map (vec3 p) {\n  float time = iTime * .7;\n    \n  vec3 p1 = p;\n  p1.xz *= rotate(time * .3);\n  p1.yz *= rotate(time * .2);\n\n  float s1 = sphereSDF(p1, 1.3);\n  s1 += sin((p1.x + p1.y * p1.z) * (3.14 * 10.) - time * 2.) * .015 - sin((p1.x - p1.y * p1.z) * (3.14 * 12.) - time) * .01;\n\n  p.z -= time * .6 + sin((p.x * p.z) + time);\n  p.xy *= rotate(time * .2);\n  vec3 c = vec3(1.4, 1.4, 2.);\n  p = mod(p, c) - .5 * c;\n\n  float s2 = sphereSDF(p, .75);\n  s2 += sin((p.x + p.y * p.z) * 20. + time * 2.) * .03 + cos(length(p.x - p.y * p.z) * 65. - time) * .01;\n\n  return max(s1 * .6 + displacement(p1, 8. * (sin(time) * .7 + .4)) * .1, -s2 * .3);\n}\n\nfloat trace (vec3 ro, vec3 rd) {\n  float e = .0001;\n  float d = e * 2.;\n  float t = 0.;\n  for (int i = 0; i < 60; i++) {\n    if (d < e || t > 50.) continue;\n    d = map(ro + rd * t);\n    t += d;\n  }\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)));\n}\n\nfloat getLight (vec3 p, vec3 light, vec3 rd) {\n  vec3 nor = getNormal(p);\n  float lOcclusion = .8;\n  float ambient = clamp(.5 + .5 * nor.y, 0., 1.) * .3;\n  float diffuse = clamp(dot(nor, light), 0., 1.) * .8;\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, nor), 0.0, 1.0), 16.) * diffuse * .6;\n\n  return (ambient + diffuse + specular) * lOcclusion;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime * .6;\n    \n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  vec3 color;\n\n  // camera\n  vec3 ro = vec3(0., 0., 5.);\n  vec3 rd = normalize(vec3(uv, -3.));\n\n  float t = trace(ro, rd);\n  vec3 p = ro + rd * t;\n\n  // texture\n  color += sin(length(p + cos(atan(p.x, p.z * p.z) * 5.)) * 50.) * (t * .02);\n  color *= cos(dot(p.xy, uv) * 5. - iTime) * .5;\n\n  // lights\n  vec3 light1 = normalize(vec3(3., 2., 1.));\n  vec3 light2 = normalize(vec3(3., 5., -2.));\n  light1.xz *= rotate(time);\n  light2.xz *= rotate(-time * .2);\n  color += getLight(p, light1, rd) * vec3(.5, .6, .2);\n  color += getLight(p, light2, rd) * vec3(.2, .3, .8);\n  color += vec3(.6 + p.y * .3, .3 + p.x * .1, .4 + p.z * .5) * .3;\n\n  float fog = 1. / (1. + t * t * .1);\n  color *= fog * 3.;\n\n  if (t > 50.) color += .5 / length(uv);\n\n  fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tB3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 72], [74, 74, 109, 109, 135], [137, 137, 174, 174, 239], [241, 241, 261, 261, 887], [889, 889, 921, 921, 1101], [1103, 1103, 1128, 1128, 1268], [1270, 1270, 1316, 1316, 1658], [1660, 1660, 1717, 1717, 2616]]}
{"id": "3tBGDc", "name": "apollonian----v1--5", "author": "jorge2017a1", "description": "apllononia----v1--5", "tags": ["apollonian"], "likes": 17, "viewed": 434, "published": "Public", "date": "1561298233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4ds3zn\n// Created by inigo quilez - iq/2013---y modificado por jorge2017a1\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t\n        //antes\n        //p.x += 0.1*sin(  2.0*p.x ) ;\n\t\t//p.y += 0.1*sin(  2.0*p.y ) ;\n        //p.z += 0.1*sin( 2.0*p.z ) ;\n        \n        //despues\n        /*\n        p.x += 0.01*sin(  2.0*p.x ) ;\n\t\tp.y += 0.01*sin(  2.0*p.y ) ;\n        p.z += 0.01*sin( 2.0*p.z ) ;\n        */\n        \n        \n        p = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.200,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 )*0.3;\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.15*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        //rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.50,0.180,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        //rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n        rgb = mix( rgb, vec3(1.0), pow(clamp(1.0-2.0*tra.y,0.0,1.0),8.0) );\n        rgb = mix( rgb, vec3(0.250,0.35,1.50), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    //float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    float anim = 1.1+ 0.7*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    //float anim = 1.21 ;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBGDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[326, 419, 449, 449, 1030], [1032, 1032, 1080, 1080, 1333], [1335, 1335, 1391, 1391, 1642], [1644, 1644, 1698, 1712, 2944], [2946, 2946, 3003, 3003, 4101], [4103, 4103, 4197, 4197, 4424]]}
{"id": "3tBGRG", "name": "Rainbow Smoke", "author": "depp", "description": "Simple volumetric clouds with lighting and rainbow colors", "tags": ["clouds", "rainbow"], "likes": 11, "viewed": 276, "published": "Public", "date": "1559889827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// Hash Without Sine 2 https://www.shadertoy.com/view/XdGfRR\nfloat hash13(in uvec3 q) {\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash13(in vec3 p) {\n\treturn hash13(uvec3(ivec3(p)) * UI3);\n}\n\nvec3 hash33(in uvec3 q) {\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p) {\n\treturn hash33(uvec3(ivec3(p)));\n}\n\nfloat noise(in vec3 p) {\n    vec3 vf = floor(p);\n    uvec3 i = uvec3(ivec3(vf));\n    vec3 f = p - vf;\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(hash33(i + uvec3(0,0,0)), f - vec3(0.0,0.0,0.0)),\n                       dot(hash33(i + uvec3(1,0,0)), f - vec3(1.0,0.0,0.0)), u.x),\n            \t   mix(dot(hash33(i + uvec3(0,1,0)), f - vec3(0.0,1.0,0.0)),\n                \t   dot(hash33(i + uvec3(1,1,0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n           \t   mix(mix(dot(hash33(i + uvec3(0,0,1)), f - vec3(0.0,0.0,1.0)),\n               \t\t   dot(hash33(i + uvec3(1,0,1)), f - vec3(1.0,0.0,1.0)), u.x),\n               \t   mix(dot(hash33(i + uvec3(0,1,1)), f - vec3(0.0,1.0,1.0)),\n                       dot(hash33(i + uvec3(1,1,1)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z);\n}\n\nconst mat3 noisemat1 = mat3(\n\t-0.45579627,  0.75217353,  0.47590413,\n\t 0.03119306, -0.5208463 ,  0.85308038,\n\t-0.88953738, -0.40367575, -0.21393721);\nconst mat3 noisemat2 = mat3(\n\t 0.89766414,  0.22826049, -0.37695654,\n\t-0.03212991,  0.88702091,  0.46061001,\n\t 0.4395074 , -0.40136151,  0.80358085);\n\nvec3 noise3(in vec3 p) {\n\treturn vec3(noise(p), noise(noisemat1 * p), noise(noisemat2 * p));\n}\n\nfloat fogdensity(in vec3 pos, float r, vec2 sc) {\n    vec3 offset = noise3(1.2 * pos + vec3(8.0, sc));\n    offset += 0.5 * noise3(2.0 * pos + vec3(-8.0, sc));\n    float a = r - 5.0;\n    return clamp(3.0 * noise(pos * 0.6 + offset) - 0.2 - 0.2 * a * a, 0.0, 1.0);\n}\n\nvec4 fog(in vec3 pos, vec2 sc) {\n    float r = length(pos);\n    float density = fogdensity(pos, r, sc);\n    if (density < 0.001) {\n        return vec4(0.0);\n    }\n    vec3 lightdir = normalize(vec3(0.0, 0.0, 4.0) - pos);\n    vec3 pos2 = pos + 0.1 * lightdir;\n    float density2 = fogdensity(pos2, length(pos2), sc);\n    float occlusion = 1.0 - density2 * 2.0;\n    vec3 color = abs(pos);\n    color = smoothstep(\n        min(min(color.r, color.g), color.b),\n        max(max(color.r, color.g), color.b),\n        color);\n    return vec4(color * density * occlusion, density);\n}\n\nvec4 render(in vec3 origin, in vec3 dir, float jitter) {\n    vec2 sc = vec2(sin(iTime * 0.5), cos(iTime * 0.5));\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < 40; i++) {\n        float t = (float(i) + jitter) * 0.2;\n        vec3 pos = origin + t * dir;\n        vec4 fcolor = fog(pos, sc);\n        color += fcolor * (1.0 - color.a);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n    uv *= 0.6;\n\n    float s = sin(iTime), c = cos(iTime);\n    vec3 pos = vec3(s, -c, 0.0) * 4.0;\n    mat3 rot = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n    vec3 dir = vec3(-s, c, 0.0);\n    \n    float jitter = hash13(vec3(fragCoord, iTime * 60.0));\n    fragColor = render(pos, rot * normalize(vec3(1.0, -uv.x, uv.y + sin(iTime * 0.4))), jitter);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 218, 244, 244, 316], [317, 317, 342, 342, 383], [385, 385, 410, 410, 474], [476, 476, 497, 497, 532], [534, 534, 558, 558, 1324], [1627, 1627, 1651, 1651, 1721], [1723, 1723, 1772, 1772, 1987], [1989, 1989, 2021, 2021, 2562], [2564, 2564, 2620, 2620, 2926], [2928, 2928, 2983, 2983, 3406]]}
{"id": "3tj3DV", "name": "mirrored fbm", "author": "stormy", "description": "hello world", "tags": ["fbm", "color", "mirror"], "likes": 6, "viewed": 113, "published": "Public", "date": "1561198526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n#define f32 float\n#define s32 int\n#define b32 bool\n#define m2 mat2\n#define TAU 6.283185307179586\n#define DEG_TO_RAD (TAU / 360.0)\n#define zero_v2 vec2(0,0)\n\nv2 uv;\n\nf32 random (v2 p) {\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nf32 noise (v2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nf32 fbm(v2 p, f32 freq, f32 amp, f32 lacunarity, f32 gain, s32 octave) {\n    f32 accum = 0.;\n    //f32 ang = 1.6180339;\n    f32 ang = 0.5;\n\n    for(s32 i = 0; i < octave; i++) {\n        f32 n = noise(p) * amp;\n        accum += n;\n\n        amp *= gain;\n\n        p = (m2(cos(ang), sin(ang), -sin(ang), cos(ang)) * p) * freq + v2(1000., 0.);\n        p *= 2.;\n\n        freq *= lacunarity;\n    }\n\n    return accum;\n}\n\n\nf32 fbm_s(v2 p) {\n    return fbm(p, 1.5, .6, 1.1, .5, 5);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 fragCoord) {\n    f32 time = iTime * .1;\n    v2 resolution = iResolution.xy;\n    uv = (2. * gl_FragCoord.xy / resolution) - 1.;\n    uv.y *= resolution.y / resolution.x;\n\n    out_color.rgba = v4(0,0,0,1);\n    \n    v2 p = abs(uv);\n    p *= time * 10.;\n    p += v2(1000. - time * .02);\n   \n    v2 f1 = v2(fbm_s(p) + time * .02, fbm_s(p));\n    v2 f2 = v2(fbm_s(p + f1 + atan(fbm_s(f1) + p.x * p.y)), fbm_s(p + f1 * 2.));\n    v2 f3 = v2(fbm_s(p + f2 * 5.), fbm_s(p + f2 + atan(fbm_s(f2))));\n    f32 final = fbm_s(p + f3 * 4. + time * 4.);\n\n    //f32 r = clamp(final - 0.3, 0., 1.);\n    //f32 b = clamp(final, 0., .2);\n    \n    f32 r = clamp(final, 0., .1);\n    f32 g = clamp(final*final*final*final, 0., .9);\n    f32 b = clamp(final*.5, 0., 0.4);\n\n    out_color.rgb = v3(r, g, b);\n    out_color.rgb *= (1.2 - length(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 232, 232, 303], [305, 305, 323, 323, 701], [703, 703, 775, 775, 1114], [1117, 1117, 1134, 1134, 1176], [1179, 1179, 1234, 1234, 2039]]}
{"id": "3tj3DW", "name": "Sphere4 - intersection", "author": "iq", "description": "Analytic intersection of a sphere f(x,y,z)=x^4+y^4+z^4-r^4=0. Specialized the generic quartic equation solver for the only geometrically valid cases, reduced all canceling complex arithmetic, and optimized coefficients. It involved 5 sqrt/pow functions.", "tags": ["3d", "raytracing", "intersection", "analytical", "sphere4"], "likes": 19, "viewed": 1668, "published": "Public API", "date": "1559604516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic intersection of a sphere f(x,y,z)=x^4+y^4+z^4-r^4=0. I Specialized\n// the generic quartic equation solver for the only geometrically valid cases,\n// reduced all canceling complex operations, and optimized coefficients.\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat iSphere4( in vec3 ro, in vec3 rd, in float ra )\n{\n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    \n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    // -----------------------------\n    // skip the case of three real solutions for the cubic, which involves four\n    // complex solutions for the quartic, since we know this objcet is convex\n    // -----------------------------\n    if( h<0.0 ) return -1.0;\n    \n    // one real solution, two complex (conjugated)\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n\n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n\n#if 1\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n#else\n    float r = sqrt( c2*c2 + w.x*w.x + 2.0*w.x*c2 - c0 );\n    return -sqrt( 3.0*w.y*w.y/(4.0*r+w.x*2.0+c2*8.0)) - c1/r - k3;\n#endif    \n}\n\n// df/dx,df/dy,df/dx for f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nvec3 nSphere4( in vec3 pos )\n{\n    return normalize( pos*pos*pos );\n}\n\n#define AA 2\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 3.1*cos(an), 1.4, 3.1*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n\t    float t = iSphere4( ro, rd, 1.0 );\n\n        // shading/lighting\t\n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\t    if( t>0.0 && t<100.0 )\n\t    {\n            vec3 pos = ro + t*rd;\n\t\t    vec3 nor = nSphere4( pos );\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n#if 0\n            col = vec3(0.8);\n#else\n            const float fr = 3.14159*7.5;\n            vec3 uvw = pow(abs(nor),vec3(1.0/3.0));\n            //vec3 uvw = pos;\n            col = vec3(0.5);\n            float w = pow(1.0+dot(nor,rd),3.0);\n            col += 0.4*smoothstep(-0.01,0.01,cos(uvw.x*fr*0.5)*cos(uvw.y*fr*0.5)*cos(uvw.z*fr*0.5)); \n            col *= 1.0*smoothstep(-1.0,-0.98+0.2*w,cos(uvw.x*fr))\n                      *smoothstep(-1.0,-0.98+0.2*w,cos(uvw.y*fr))\n                      *smoothstep(-1.0,-0.98+0.2*w,cos(uvw.z*fr));\n#endif      \n\t\t    col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            \n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n\t    }\n\t\n        // gamma\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3DW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1466, 1503, 1558, 1662, 3225], [3227, 3286, 3316, 3316, 3355], [3399, 3399, 3456, 3480, 5680]]}
{"id": "3tj3Rc", "name": "Two way z curve expansion.", "author": "Bananaft", "description": "Drag mouse to see stuff.", "tags": ["morton"], "likes": 3, "viewed": 93, "published": "Public", "date": "1560543614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Fork of FabriceNeyret2's http://www.shadertoy.com/view/4sscDn\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n\nint xy2z(vec2 U) {       // --- grid location to curve index\n    ivec2 I = ivec2(U);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {      // --- curve index to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=4; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U = U / 2.;\n    float R = exp2(floor(log2(iResolution.y/2.)));\n    O = vec4(U/R, .5,0);\n    \n    int Z = xy2z(U);\n    int M = xy2z(iResolution.xy/4.);\n    if (iMouse.x > 20.)\n    \tM = xy2z(iMouse.xy/2.);\n    \n  //O = vec4( Z ) / R/R;               // display Z-index\n // O = vec4( z2xy(Z),0,0)/ R;         // pos from Z\n// O = vec4(ivec2(U)== z2xy(iFrame)); // browse index on Z-curve.\n    \n   if (Z <(M + iFrame) && Z >(M - iFrame)) O = vec4(fract(float(Z)/256.),fract(float(Z)/1024.),fract(float(Z)/512.),1.0); // * vec4(U,0,0)/R;\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 148, 166, 208, 361], [363, 363, 382, 424, 578], [580, 580, 619, 619, 1164]]}
{"id": "3tj3W3", "name": "Lit Cigarette", "author": "SSHantaram", "description": "lLit cigarette slowly burning. No smoke (yet?)", "tags": ["raymarching", "noise", "bump"], "likes": 10, "viewed": 382, "published": "Public API", "date": "1561375586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float BUMP_FACTOR = 0.1;\nconst float TEMPERATURE = 2200.0;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat octaveNoise( in vec3 p ) {\n    p += vec3(23.481, 67.44, 68.81);\n    return 0.7*noise(p) + 0.2*noise(p*4.0)  + 0.1*noise(p*10.0);\n}\n\nvec3 blackbody(float t)\n{\n    t *= TEMPERATURE;\n    \n    float u = ( 0.860117757 + 1.54118254e-4 * t + 1.28641212e-7 * t*t ) \n            / ( 1.0 + 8.42420235e-4 * t + 7.08145163e-7 * t*t );\n    \n    float v = ( 0.317398726 + 4.22806245e-5 * t + 4.20481691e-8 * t*t ) \n            / ( 1.0 - 2.89741816e-5 * t + 1.61456053e-7 * t*t );\n\n    float x = 3.0*u / (2.0*u - 8.0*v + 4.0);\n    float y = 2.0*v / (2.0*u - 8.0*v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = Y / y * x;\n    float Z = Y / y * z;\n\n    mat3 XYZtoRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                        -0.9692660,  1.8760108,  0.0415560,\n                         0.0556434, -0.2040259,  1.0572252);\n\n    return max(vec3(0.0), (vec3(X,Y,Z) * XYZtoRGB) * pow(t * 0.0004, 4.0));\n}\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat bumpCylynderSDF(vec3 p, float h, float r) {\n    // get distance to plane as usual\n    float d = cylinderSDF(p, h, r);\n    \n    vec3 normal;\n    float bump = 0.0;\n    \n  \t// only consider bumps if close to plane\n    if(d < BUMP_FACTOR*1.5)\n\t{\t\n\t\tnormal = normalize(vec3(p.x, p.y, 0.0));\n\t\tbump = octaveNoise(10.0*p + 0.4*vec3(iTime, iTime, iTime))*min(0.0, 1.7*(p.z + 1.4));\n\t}\n    return d - bump;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    \n    float cylinderRadius = 0.35;\n    float cylinder = bumpCylynderSDF(rotateX(radians(90.0))*(samplePoint + vec3(0.0, 1.0, 0.0)), 7.0, cylinderRadius);\n\n    return cylinder;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 shading(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    return lightIntensity * (k_d * dotLN);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 illumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.2, 0.2);\n    \n    color += shading(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.2, 0.2, 0.2);\n    \n    color += shading(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n\t\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat smokeDensity(vec2 uv) {\n    return octaveNoise(vec3(uv.x*0.01, uv.y*0.005, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(55.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0*sin(0.2*iTime), 3.0 + 2.0*sin(0.2*iTime), 8.0*cos(0.2*iTime));\n    \n    vec3 up = normalize(vec3(0.5, 1.0, 0.2));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), up);\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 color = vec3(0.6, 0.6, 1.0)*0.05*octaveNoise(0.2*p + vec3(0.0, 0.0, iTime));\n    \n    if (dist <= MAX_DIST - EPSILON) {\n        // The closest point on the surface to the eyepoint along the view ray\n    \t\n    \n    \t// Use the surface normal as the ambient color of the material\n        float pattern = sin(60.0*p.y - 2.0*iTime);\n        if (pattern < -0.9) pattern = -1.5;\n        else pattern = 1.0;\n    \tvec3 paper = vec3(0.8, 0.8, 0.7)*(0.95 + 0.05*pattern);\n    \tvec3 burnt = vec3(0.08, 0.05, 0.01);\n    \tvec3 glow = blackbody((0.3*sin(0.8*iTime) + 1.8)*octaveNoise(5.0*p));\n    \tfloat noiseVal = octaveNoise(8.0*p - 0.2*vec3(iTime, iTime, 0.0));\n    \tfloat mixing_burn = clamp(p.y + 0.7*noiseVal + 0.3, 0.0, 1.0);\n    \tif (mixing_burn < 0.75) mixing_burn = max(0.0, mixing_burn - 0.1);\n    \tfloat mixing_glow = clamp(p.y + 0.3*noiseVal, 0.0, 1.0);\n    \tif (mixing_glow < 0.6) mixing_glow = 0.0;\n    \tvec3 K_a = mix(paper, burnt, mixing_burn);\n    \tK_a = mix(K_a, glow, mixing_glow);\n    \tvec3 K_d = K_a;\n    \tvec3 K_s = vec3(1.0, 1.0, 1.0);\n    \tfloat shininess = 1.0;\n    \n    \tcolor = illumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    \t\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 211, 231, 231, 326], [328, 351, 377, 377, 909], [911, 911, 943, 943, 1047], [1049, 1049, 1074, 1074, 1835], [1837, 1883, 1910, 1910, 2057], [2059, 2176, 2221, 2290, 2896], [2898, 2898, 2947, 2985, 3303], [3305, 3545, 3579, 3579, 3764], [3766, 4187, 4278, 4278, 4584], [4599, 4853, 4918, 4918, 5050], [5052, 5141, 5170, 5170, 5480], [5482, 5974, 6101, 6101, 6386], [6388, 6758, 6838, 6838, 7610], [7612, 7939, 7988, 8023, 8154], [8156, 8156, 8185, 8185, 8245], [8247, 8247, 8304, 8304, 9955]]}
{"id": "3tjGDR", "name": "Infinite recursive helix", "author": "holtsetio", "description": "My first shadertoy doodle! Rendering of an infinite recursive helix with raymarching. It still has some glitches, which might be caused by floating point precision.\nThe helix distance function is in the ClosestPointHelix() function.\nSuggestions welcome!", "tags": ["raymarching", "fractal", "spiral", "loop", "helix", "infinite"], "likes": 29, "viewed": 556, "published": "Public", "date": "1559551586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Parameters \n#define FUZZ 0.99\n#define PHASELENGTH 2.50\n#define RECURSION_LEVEL 6\n#define NUM_STRANDS 3.0\n#define TR_RATIO 0.7\n#define RADIUS_FACTOR 0.38\n#define RIBBONRADIUS 0.032\n\n// comment/uncomment the following defines to toggle effects\n#define FLIPFLOP\n#define GLOWONLY\n\n//The Following don't work for now\n//#define VARIANCE\n//#define WOBBLE\n\n\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.0005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 30\n#define MAXDIST 55.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n#define PHASEN floor(iTime/PHASELENGTH)\n\nvec3 glow = vec3(0);\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg) {\n        xaxis *= -1.0;\n        //zaxis *= -1.0;\n        //off *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelix(vec4 p, float R, float T, float n_helices) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    #ifdef WOBBLE\n    \tR*= 1.0+0.2*sin(0.01*iTime/(abs(T))+res.theta*3.0);\n    #endif\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n\n    return res;\n}\n\nfloat getT(float R, float baseRot, float subphase, bool isNeg) {\n\tfloat T = tan(baseRot + pow(subphase,6.0) * (PI*0.5 - baseRot))*R;\n    T *= (isNeg ? -1.0 : 1.0);\n    return T;\n}\n\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\n\nResult HelixRecursive(vec4 pos, float R, float startTR, float Rmult, int iter, float strands) {\n\tHelixHit hit;\n    float baseRot = atan(startTR);\n    float phase = PHASE;\n    \n    mat4 transform = mat4(1.0);\n    \n    R = R/mix(1.0,Rmult,phase);\n    transform[3][0] = pow(phase,1.3)*R;\n    \n    float rot = 0.5*PI;\n    vec2 vrot = vec2(sin(rot),cos(rot));\n    \n    transform[1].y = vrot.y;\n    transform[1].z = -vrot.x;\n    transform[2].yz = vrot.xy;\n    \n    transform = rotationY(PI) * transform;\n    \n    float frac = (1.0/float(iter));\n    float subphase = 1.0 - (1.0-phase)*frac;\n    \n    bool flipflop = false;\n    #ifdef FLIPFLOP\n    \tflipflop = true;\n    #endif\n    \n    bool isNeg = flipflop&&(int(PHASEN)%2==0);\n    for (int i=0; i<iter-1; i++) {\n        float T = getT(R,baseRot,subphase,isNeg);\n\n        subphase -= frac;\n        \n        hit = ClosestPointHelix(transform*pos,R,T,strands);     \n        vec3 lookDir = (vec3(hit.p.y,-hit.p.x,-T));\n        float offset = -(hit.theta/TWOPI)*sqrt((T*T+R*R) * 4.0*PI*PI);\n        #ifdef MOVE\n        \toffset -= (i>0?abs(PHASE*T):0.0);\n        #endif\n       \n        transform = buildtransform(lookDir,offset,-hit.p.xyz,isNeg) * transform;\n            \n        #ifdef VARIANCE\n        Rmult *= 1.0-mod(hit.strand,strands)*(0.6/strands);\n\t\t#endif\n        \n        R *= Rmult;\n        isNeg = flipflop&&!isNeg;\n    }\n    float T = getT(R,baseRot,subphase,isNeg);\n    \n    vec4 p = transform*pos;\n    hit = ClosestPointHelix(p,R*sqrt(phase),T,strands);\n    \n    mat4 inv = inverse(transform);\n    Result res;\n\tres.dist = distance(pos,inv * hit.p)-RIBBONRADIUS;\n    res.n = inv * normalize(p-hit.p);\n\treturn res;\n}\n\nResult ED(vec4 p) {\n    float r1 = 7.0;\n    return HelixRecursive(p,r1,TR_RATIO,RADIUS_FACTOR,RECURSION_LEVEL,NUM_STRANDS);\n}\n\nvec3 getColor(vec4 n) {\n    float c = max(0.0,dot(n, normalize(vec4(3,8,2,0))));\n    float c2 = max(0.0,dot(n, normalize(vec4(3,-8,-1,0))));\n    return vec3(c*0.7+c2*0.3,0,c*0.3+c2*0.7);\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        glow += vec3(1) * pow(max(0.0,1.0-5.0*minDist),4.0) * 0.03;\n        \n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    #ifdef GLOWONLY\n    return vec3(1)-glow;\n    #else\n    if (res.dist < EPSILON) {\n     \tfloat shadow = (1.0/float(steps))*10.0;\n        shadow *= 1.0-pow(dist/MAXDIST,5.0);\n            \n        return getColor(res.n)*(shadow);   \n    }\n    return vec3(0,0,0);\n    #endif\n\t//return vec3(1,1,1) * (1.0-pow(float(steps)/float(MAXSTEPS),0.5)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n\tvec4 rayorig = vec4(20.0,0.0,-0.0,1);\n    \n    vec2 rot = vec2(0.3,0.1)*(iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(-0.5,1.0)*PI;\n    vec2 sins = sin(rot);\n    vec2 coss = cos(rot);\n    float ry = coss.y*raydir.y+sins.y*raydir.z;\n    raydir =  vec4(coss.x*raydir.x-sins.x*ry, sins.x*raydir.x+coss.x*ry, sins.y*raydir.y-coss.y*raydir.z,0.0);\n    \n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 599, 633, 633, 769], [771, 771, 839, 839, 1280], [1286, 1286, 1328, 1328, 1594], [1596, 1596, 1633, 1680, 1949], [2018, 2182, 2253, 2447, 3155], [3157, 3157, 3221, 3221, 3336], [3384, 3384, 3479, 3479, 5051], [5053, 5053, 5072, 5072, 5178], [5180, 5180, 5203, 5203, 5368], [5370, 5370, 5406, 5406, 6195], [6197, 6197, 6254, 6304, 6930]]}
{"id": "3tS3W3", "name": "IFS test", "author": "edo_m18", "description": "This is IFS test.\nI cannot understand the IFS sale factor to apply correctly.\n=> Modified that. I modified the size to normalize by sum scale.", "tags": ["ifs"], "likes": 1, "viewed": 151, "published": "Public", "date": "1561271315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\nconst float pi2 = pi * 2.0;\n\n#define repeat(p, span) mod(p, span) - (0.5 * span)\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nmat2  rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 offs)\n{\n    return length(max(abs(p + offs) - b, 0.0));\n}\n\nfloat map(vec3 p)\n{\n    //p.xz = repeat(p.xz, 5.0);\n    const int ITER = 3;\n    float scale = 2.0;\n    float offset = 0.65;\n    float sum = scale;\n    \n    vec3 z = p;\n    \n    float d = 1e5;\n    \n    float r = 0.5;\n    for (int i = 0; i < ITER; i++)\n    {\n        z = abs(z);\n        \n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n        \n        z = z * scale;// - offset *  (scale - 1.0) * float(i);\n        z = abs(z) - offset * float(i);\n        z.xy *= rot(sin(iTime * 0.1) * pi);\n        d = min(d, sdBox(z, vec3(0.5), vec3(0.)) / sum);\n        \n        sum *= scale;\n        scale *= r;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    float time = iTime * 0.3;\n    float dist = 5.;\n    vec3 ro = vec3(cos(time) * dist, 5, sin(time) * dist);\n    //vec3 ro = vec3(0, 5, 5);\n    vec3 ta = vec3(0);\n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    vec3 p = ro;\n    \n    float d = 0.;\n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        const vec3 light = normalize(vec3(1));\n        vec3 n = normal(p);\n        float diff = clamp(dot(n, light), 0.5, 1.0);\n        col = vec3(diff) *(n * 0.5 + 0.5);\n    }\n    else\n    {\n        vec3 fog = vec3(0.5, 0.8, 1.5) * abs(1.0 - uv.y);\n \t   col += fog * 0.5;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tS3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 141, 141, 313], [315, 315, 335, 335, 401], [403, 403, 443, 443, 493], [495, 495, 514, 546, 1179], [1181, 1181, 1202, 1202, 1379], [1381, 1381, 1438, 1438, 2255]]}
{"id": "3tS3zV", "name": "Nice Dots", "author": "Yusef28", "description": "Another cool basic pattern:\n\nInspiration: https://www.pinterest.de/pin/445504588118807802/", "tags": ["circle", "red", "dots", "pattern"], "likes": 4, "viewed": 429, "published": "Public", "date": "1560175747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(vec2 p)\n{\n    \n return fract(sin(dot(p, vec2(12.9898, 78.233)))*45378.23153);   \n}\n\nfloat makeCircle(vec2 p, float r)\n{\n float ss = 0.015;\n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\tuv+=iTime/8.;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.9, 0.9, 0.9);\n    vec3 red = vec3(0.7, 0.0, 0.1);\n    vec3 lightGrey = vec3(0.66);\n    vec3 darkGrey = vec3(0.4);\n    \n    \n    float seed = rnd(floor(uv*8.));\n    uv = fract(uv*8.)-0.5;\n    float circ = makeCircle(uv, 0.4);\n    \n    \n     \n    \n    \n    col = mix(col, red, circ*step(seed, 0.33) );\n    col = mix(col, lightGrey, circ*step(0.33, seed));\n    col = mix(col, darkGrey, circ*step(0.66, seed));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tS3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 92], [94, 94, 129, 129, 217], [219, 219, 276, 326, 972]]}
{"id": "3tSGDt", "name": "PBR stuff", "author": "zxxuan1001", "description": "Learning, learn, lea, l... \nBased on: https://learnopengl.com/PBR/Theory\nSDF: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["pbr"], "likes": 3, "viewed": 278, "published": "Public API", "date": "1561585092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define PI 3.1415926\n#define EPSILON 0.0001\nconst int MAX_STEPS = 100;\nconst float MAX_DISTANCE = 60.0;\nconst float AA_SIZE = 2.0;\nconst vec3 FOG_COLOR = vec3(0.9, 0.9, 0.7);\nconst float ROUGHNESS = 0.6;\nconst float METALLIC = 0.8;\n\nfloat plane(vec3 p) \n{\n    return p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 intersectSDF(vec2 d1, vec2 d2) \n{\n    return d1.x > d2.x? d1 : d2;\n}\n\nfloat opIntersection( float d1, float d2 ) \n{ \n    return max(d1, d2); \n}\n\nvec2 unionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x < d2.x? d1 : d2;\n}\n\nvec2 subtractionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x > -d2.x? d1 : vec2(-d2.x, d2.y);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * (1.0 - h); \n}\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec3 rotX(vec3 p, float d) \n{\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotY(vec3 p, float d) \n{\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nfloat displacement(vec3 p) {\n    float t1 = sin(iTime *0.5);\n    float t2 = cos(iTime);\n    float t3 = sin(iTime * 1.0);\n    return sin(2.0*p.x*t1)*sin(2.0*p.y*t2)*sin(2.0*p.z*t3);\n}\n\nfloat displacedTorus(vec3 p, vec2 d) {\n    float rst = sdTorus( p , d );\n    float disp = displacement(p);\n    return rst + disp;\n}\n\nvec2 sceneSDF(vec3 p) \n{\n    vec2 result = vec2(plane(p), -1.0);\n    \n    vec3 p1 = doTranslate(p,vec3(0.0, 2.5 , 0.0));\n    p1 = rotX(p1, -30.0 * PI / 180.0);\n    vec2 result1 = vec2( displacedTorus( p1, vec2(3.0, 1.2) ), 1.0);  \n    result1.x *= 0.4;\n    result = unionSDF(result, result1);\n    return result;\n}\n\nvec2 marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.01;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = tmax;\n            break;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).x;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).x;\n        occ += ( h - d ) * sca;\n        sca *= 0.85;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nconst vec2 OFFSET = vec2(EPSILON, 0.0);\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + OFFSET.xyy).x - sceneSDF(p - OFFSET.xyy).x,\n        sceneSDF(p + OFFSET.yxy).x - sceneSDF(p - OFFSET.yxy).x,\n        sceneSDF(p + OFFSET.yyx).x - sceneSDF(p - OFFSET.yyx).x\n    ));\n}\n\nvec3 ground(vec2 uv) \n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    uv *= 0.5;\n    float f = mod(floor(uv.x) + floor(uv.y), 2.0) * fract(uv.x) ; //Checkerboard   \n    //f = fract(uv.y); //strip\n    //f = abs(sin(uv.y) * sin(uv.x)); //grid\n    col = mix(col, vec3(242.0,236.0,172.0)/255.0, f);\n    return  col; \n}\n\n//Distribution/concentration\nfloat D_GGX(float dotnh, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotnh2 = dotnh * dotnh;\n    float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n    return a2 /(PI * denom * denom);\n}\n\nfloat G_SGGX(float dotnv, float roughness)\n{\n    //for direct lighting\n    float r = roughness + 1.0;\n    float k = (r * r) / 8.0; \n    /* for IBL\n    float k = roughness * roughness / 2.0;\n\t*/\n    return dotnv / (dotnv * (1.0 - k) + k);\n}\n//Geometry/shadowing masking\nfloat G_Smith(float dotnv, float dotnl, float roughness)\n{\n    \n    float ggx1 = G_SGGX(dotnv, roughness);\n    float ggx2 = G_SGGX(dotnl, roughness);\n    return ggx1 * ggx2;\n}\n//Fresnel/reflectivity\nvec3 Fs(float dothv, vec3 f0)\n{\n    return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n}\n\nvec3 PBL(vec3 ro, vec3 p, float objId) \n{\n    vec3 Lo = vec3(0.0);\n    vec3 lights[4];\n    vec3 lightColor = vec3(300.0, 100.0, 100.0);\n    lights[0] = vec3(0.0, 10.0, -5.0);\n    lights[1] = vec3(-5.0, 15.0, 3.0);\n    lights[2] = vec3(3.0, 20.0, 3.0);\n    lights[3] = vec3(-3.0, 20.0, 3.0);\n    \n    vec3 viewDir = ro - p;\n    vec3 V = normalize(viewDir);\n    vec3 N = getNormal(p);\n    vec3 albedo = vec3(0.2, 0.87, 0.6); //surface color\n    if (objId == -1.0) \n    {//floor     \n        albedo = ground(p.xz); \n    } \n    \n    for (int i = 0; i < 2; i++)\n    {\n        vec3 lightPos = lights[i];\n        \n        vec3 lightDir = lightPos - p;\n        float dist = length(lightDir);\n \n        vec3 L = normalize(lightDir);\n        vec3 H = normalize(viewDir + lightDir);\n        \n        float sd = calcShadow(p, normalize(lightPos));\n        float att = 1.0 / ( dist * dist );\n        vec3 radiance = lightColor * att * sd; \n\n        float dothv = max(dot(H, V), 0.0);\n        float dotnh = max(dot(N, H), 0.0);\n        float dotnv = max(dot(N, V), 0.0);\n        float dotnl = max(dot(N, L), 0.0);\n\t\t\n        //Cook-Torrance specular BRDF term\n        vec3 f0 = vec3(0.04);\n        f0 = mix(f0, albedo, METALLIC);  \n        vec3 F = Fs(dothv, f0);\n        \n        float D = D_GGX(dotnh, ROUGHNESS);\n        float GS = G_Smith(dotnv, dotnl, ROUGHNESS);\n        \n        vec3 nom = D * GS * F;\n        float denom = 4.0 * dotnv * dotnl;\n        vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n        vec3 Ks = F; //specular\n        vec3 Kd = vec3(1.0) - Ks; //diffuse \n        Kd *= 1.0 - METALLIC;\n        \n        //Lambert\n        vec3 Fl = albedo/PI; \n        \n        //final results\n        Lo += (Kd * Fl + Fct) * radiance * dotnl; \n    }\n    \n    float ao = calcAO(p, N);\n    vec3 ambient = vec3(0.1) * albedo * ao;\n    return ambient + Lo ;\n}\n\n \n\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 fog(in vec3 pixColor, in float dist) \n{\n    return mix(pixColor, vec3(0.8), 1.0 - exp(-dist * 0.003));\n}\n\nvec3 background(vec2 uv) \n{\n    vec3 col = mix(vec3(0.5, 0.5, 0.0), vec3(1.0, 0.0, 0.0), pow(0.5, uv.y * 0.2));\n    \n    return col;\n}\n\n\nvec3 render(in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // restore aspect ratio\n    \n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.1) + iMouse.xy / iResolution.xy ;\n    mouse -= 0.5;\n    float t = iTime * 0.1;\n    vec3 ro = vec3(12.0 * cos(mouse.x * 2.0 * PI + t),  10.0 + mouse.y * 20.0, 12.0 * sin(mouse.x * 2.0 * PI + t));\n    vec3 ta = vec3(0.0, 2.0, -2.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.2));\n    \n    vec2 h = marching(ro, rd);\n    vec3 p = ro + rd * h.x;\n    if (h.x < MAX_DISTANCE) \n    {\n        if (h.y == 0.0) \n        {\n            col = vec3(0.0);\n        } \n        \n        col += PBL(ro, p, h.y);\n    } else \n    {\n        //background\n        col = background(p.xy); \n    }\n    \n    col = fog(col, h.x); \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float count = 0.0;  \n    vec3 col = vec3(0.0);\n    for (float aay = 0.0; aay < AA_SIZE; aay++) \n    {\n        for (float aax = 0.0; aax < AA_SIZE; aax++) \n        {\n            col += render(fragCoord + vec2(aax, aay)/AA_SIZE);\n            count++;\n        }\n    }\n    col /= count;\n      \n \tcol = col / (col + vec3(1.0));\n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 268, 268, 286], [288, 288, 321, 321, 386], [388, 388, 426, 426, 461], [463, 463, 508, 508, 536], [538, 538, 572, 572, 607], [609, 609, 649, 649, 700], [702, 702, 753, 753, 867], [869, 869, 926, 926, 1027], [1029, 1029, 1087, 1087, 1187], [1189, 1189, 1229, 1229, 1254], [1256, 1256, 1285, 1285, 1502], [1504, 1504, 1533, 1533, 1749], [1752, 1752, 1780, 1780, 1997], [1999, 1999, 2027, 2027, 2181], [2183, 2183, 2221, 2221, 2314], [2316, 2316, 2340, 2340, 2629], [2631, 2631, 2665, 2665, 3159], [3161, 3161, 3203, 3203, 3594], [3596, 3596, 3638, 3638, 3925], [3967, 3967, 3991, 3991, 4222], [4224, 4224, 4247, 4247, 4532], [4534, 4563, 4607, 4607, 4799], [4801, 4801, 4845, 4871, 5040], [5041, 5070, 5128, 5128, 5245], [5246, 5269, 5300, 5300, 5366], [5368, 5368, 5409, 5409, 7231], [7236, 7236, 7277, 7277, 7447], [7449, 7449, 7493, 7493, 7558], [7560, 7560, 7587, 7587, 7694], [7697, 7697, 7730, 7780, 8654], [8658, 8658, 8715, 8715, 9136]]}
{"id": "3tSGWy", "name": "antialiasing fract (2)", "author": "FabriceNeyret2", "description": "from base version [url]https://shadertoy.com/view/wtjGzt[/url],\nhere I add the filtering of high frequencies. #BIAS / #SPREAD to trade thresholding.\nClick to switch off.\nIn addition, note how #grad() =||dFdxy()|| improves compare to fwidth().", "tags": ["antialiasing", "fract", "tuto", "short", "shannonnyquist"], "likes": 23, "viewed": 922, "published": "Public API", "date": "1560858521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Self-ref: https://www.shadertoy.com/view/3tSGWy\n\n// Improved version on \"antialiasing fract\"  https://shadertoy.com/view/wtjGzt\n// dealing with antialiasing of 2 use-case of fract: ramps and bars.\n// Here: also deal with Shannon-Nyquiest filtering for high frequencies.\n\n//#define grad(x) fwidth(x)\n  #define grad(x) length(vec2(dFdx(x),dFdy(x)))\n\n// w = pixel width = grad(continous signal) . c = possibly fracted signal.\n#define Nyquist(w,c) mix(.5, c, clamp((.5-BIAS-(w))/.25/SPREAD,0.,1.) )\n\n#define BIAS -.0  // < 0: prefer a bit of aliasing to blur \n#define SPREAD 1. // < 1: transition more brutal \n\nfloat aafract(float x) {    // --- antialiased fract\n    float v = fract(x),\n          w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = v < 1.-w ? v/(1.-w) : (1.-v)/w; // replace right step by down slope (-> chainsaw is continuous).\n               // shortened slope : added downslope near v=1 \n    return c; \n // return Nyquist(w,c); // version with high-freq filtering integrated\n}\n\nfloat aastep(float x) {     // --- antialiased step(.5)\n    float w = grad(x),      // pixel width. NB: x must not be discontinuous or factor discont out\n          c = smoothstep(.7,-.7,(abs(fract(x-.25)-.5)-.25)/w); // just use  (offseted) smooth squares\n    return c;\n // return Nyquist(w,c);    // version with high-freq filtering integrated\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;            // normalized coordinates\n    float a = atan(U.y,U.x), l = length(U); // polar coordinates\n \n    float v = 20.*a/6.28 + 10./l +iTime, // + sin(10.*l), // some fancy field\n        //v = 100.*exp(-3.*abs(.8*U.x+.2*U.y)),           // linear gradient\n        //v = 200.*a/6.28,                                // radial gradient\n          w = grad(v);                      // pixel width. \n#if 0\n    v = .5+.5*sin(6.28*v); // use with v = 200.*a/6.28 above\n#else\n    v = U.y > 0.\n            // top: spiral displayed with ramps, using fract\n            ? U.x < 0. ? fract( v ) : aafract( v )\n            // bottom: spiral displayed with bars, using step(fract)\n            : U.x < 0. ? step(.5,fract(v)) : aastep(v);\n#endif\n    // version with Nyquist not already integrated in aafract/aastep:\n    // ( just to demo Nyquist also applied to aliased fract case. ) \n    if (iMouse.z<=0.) v = Nyquist(w,v);\n  //v *= iMouse.y/R.y;\n    \n    O = vec4( pow(v, 1./2.2) ); // final conversion to sRGB ( NB: sqrt(v) would be a good approx )\n    if ( abs(U.x) < 1./R.y ) O = vec4(1,0,0,0); // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 610, 634, 662, 1046], [1048, 1048, 1071, 1103, 1394], [1396, 1396, 1437, 1437, 2603]]}
{"id": "3tSGzV", "name": "double warp", "author": "Mishka", "description": "variant of \"three in one\"", "tags": ["interactive"], "likes": 1, "viewed": 172, "published": "Public", "date": "1560171820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fract_sin_dot (vec2 uv) {\n        return fract(sin(dot(\n                         // uv.xy,\n                         // vec2(sin(4.*uv.x), sin(10.*uv.y)),\n                         vec2(sin(4.*uv.x), uv.y),\n                         0.1*iMouse.xy+vec2(1.0,1.0)))*\n        4. + 0.5*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(fract_sin_dot( uv ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), sin(10.*uv.y)) ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), uv.y) ));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 293], [295, 295, 352, 352, 612]]}
{"id": "4sdBWM", "name": "Fractal Voronoi II", "author": "oalpha", "description": "Just recursive voronoi again", "tags": ["voronoi", "noise"], "likes": 3, "viewed": 153, "published": "Public", "date": "1560562953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nnnn vec4(0.0, 0.0, 0.0, 0.0)\n#define nnnp vec4(0.0, 0.0, 0.0, 1.0)\n#define nnpn vec4(0.0, 0.0, 1.0, 0.0)\n#define nnpp vec4(0.0, 0.0, 1.0, 1.0)\n#define npnn vec4(0.0, 1.0, 0.0, 0.0)\n#define npnp vec4(0.0, 1.0, 0.0, 1.0)\n#define nppn vec4(0.0, 1.0, 1.0, 0.0)\n#define nppp vec4(0.0, 1.0, 1.0, 1.0)\n#define pnnn vec4(1.0, 0.0, 0.0, 0.0)\n#define pnnp vec4(1.0, 0.0, 0.0, 1.0)\n#define pnpn vec4(1.0, 0.0, 1.0, 0.0)\n#define pnpp vec4(1.0, 0.0, 1.0, 1.0)\n#define ppnn vec4(1.0, 1.0, 0.0, 0.0)\n#define ppnp vec4(1.0, 1.0, 0.0, 1.0)\n#define pppn vec4(1.0, 1.0, 1.0, 0.0)\n#define pppp vec4(1.0, 1.0, 1.0, 1.0)\nfloat Dot(vec2 a, vec4 b) {\n    return dot(a, b.xy);\n}\nfloat Dot(vec3 a, vec4 b) {\n    return dot(a, b.xyz);\n}\nfloat rand(float f, float o, float r, vec4 ss) {\n  return o + r * fract(sin(f * ss.x + ss.y) * ss.z + ss.z);\n}\nvec2 rand2(vec2 v, float o, float r, mat4 d, vec4 s) {\n    return vec2(\n        rand(Dot(v, d[0]), o, r, s),\n        rand(Dot(v, d[1]), o, r, s)\n    );\n}\nvec3 rand3(vec3 v, float o, float r, mat4 d, vec4 s) {\n    return vec3(\n        rand(Dot(v, d[0]), o, r, s),\n        rand(Dot(v, d[1]), o, r, s),\n        rand(Dot(v, d[2]), o, r, s)\n    );\n}\nvec4 rand4(vec4 v, float o, float r, mat4 d, vec4 s) {\n    return vec4(\n        rand(dot(v, d[0]), o, r, s),\n        rand(dot(v, d[1]), o, r, s),\n        rand(dot(v, d[2]), o, r, s),\n        rand(dot(v, d[3]), o, r, s)\n    );\n}\nvec4 rand4Rot(vec4 v, mat4 ds, vec4 ss) {\n    v = rand4(vec4(\n        dot(v, ds[0]),\n        dot(v, ds[1]),\n        dot(v, ds[2]),\n        dot(v, ds[3])\n    ), 0.0, 2.0 * 3.14159265358, ds, ss);\n  return mat4(\n            1.0,       0.0,       0.0,       0.0,\n            0.0,  cos(v.x), -sin(v.x),       0.0,\n            0.0,  sin(v.x),  cos(v.x),       0.0,\n            0.0,       0.0,       0.0,       1.0\n  ) * mat4(\n            1.0,       0.0,       0.0,       0.0,\n            0.0,       1.0,       0.0,       0.0,\n            0.0,       0.0,  cos(v.y), -sin(v.y),\n            0.0,       0.0,  sin(v.y),  cos(v.y)\n  ) * mat4(\n       cos(v.z),       0.0,       0.0,  sin(v.z),\n            0.0,       1.0,       0.0,       0.0,\n            0.0,       0.0,       1.0,       0.0,\n      -sin(v.z),       0.0,       0.0,  cos(v.z)\n  ) * mat4(\n       cos(v.w), -sin(v.w),       0.0,       0.0,\n       sin(v.w),  cos(v.w),       0.0,       0.0,\n            0.0,       0.0,       1.0,       0.0,\n            0.0,       0.0,       0.0,       1.0\n  ) * vec4(1.0, 0.0, 0.0, 0.0);\n}\nmat4 rand44(mat4 m, float o, float r, mat4 d, mat4 s) {\n    return mat4(\n        vec4(\n            rand(dot(m[0], d[0].xyzw), o, r, s[0]),\n            rand(dot(m[0], d[1].xyzw), o, r, s[1]),\n            rand(dot(m[0], d[2].xyzw), o, r, s[2]),\n            rand(dot(m[0], d[3].xyzw), o, r, s[3])\n        ),\n        vec4(\n            rand(dot(m[1], d[0].yzwx), o, r, s[0]),\n            rand(dot(m[1], d[1].yzwx), o, r, s[1]),\n            rand(dot(m[1], d[2].yzwx), o, r, s[2]),\n            rand(dot(m[1], d[3].yzwx), o, r, s[3])\n        ),\n        vec4(\n            rand(dot(m[1], d[0].zwxy), o, r, s[0]),\n            rand(dot(m[1], d[1].zwxy), o, r, s[1]),\n            rand(dot(m[1], d[2].zwxy), o, r, s[2]),\n            rand(dot(m[1], d[3].zwxy), o, r, s[3])\n        ),\n        vec4(\n            rand(dot(m[1], d[0].wxyz), o, r, s[0]),\n            rand(dot(m[1], d[1].wxyz), o, r, s[1]),\n            rand(dot(m[1], d[2].wxyz), o, r, s[2]),\n            rand(dot(m[1], d[3].wxyz), o, r, s[3])\n        )\n    );\n}\nfloat mix1(float x, float y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nvec2 mix1(vec2 x, vec2 y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nvec3 mix1(vec3 x, vec3 y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nvec4 mix1(vec4 x, vec4 y, float a) {\n  return (1.0 - a) * x + a * y;\n}\nfloat curve5(float a) {\n  return a * a * a * (a * (6.0 * a - 15.0) + 10.0);\n}\nvec2 curve5(vec2 a) {\n  return a * a * a * (a * (6.0 * a - 15.0) + 10.0);\n}\nvec4 curve5(vec4 a) {\n  return a * a * a * (a * (6.0 * a - 15.0) + 10.0);\n}\nfloat mix5(float x, float y, float a) {\n  return mix1(x, y, curve5(a));\n}\nvec2 mix5(vec2 x, vec2 y, float a) {\n  return mix1(x, y, curve5(a));\n}\nvec3 mix5(vec3 x, vec3 y, float a) {\n  return mix1(x, y, curve5(a));\n}\nvec4 mix5(vec4 x, vec4 y, float a) {\n  return mix1(x, y, curve5(a));\n}\nfloat perlinGradient(vec4 pos, mat4 ds, vec4 ss) {\n    vec4 f = fract(pos);\n    vec4 b = floor(pos);\n    vec4 z0 = mix5(vec4(\n        dot(rand4Rot(b, ds, ss), f),\n        dot(rand4Rot(b + npnn, ds, ss), f - npnn),\n        dot(rand4Rot(b + pnnn, ds, ss), f - pnnn),\n        dot(rand4Rot(b + ppnn, ds, ss), f - ppnn)\n    ), vec4(\n        dot(rand4Rot(b + nnnp, ds, ss), f - nnnp),\n        dot(rand4Rot(b + npnp, ds, ss), f - npnp),\n        dot(rand4Rot(b + pnnp, ds, ss), f - pnnp),\n        dot(rand4Rot(b + ppnp, ds, ss), f - ppnp)\n    ), f.w);\n    vec4 z1 = mix5(vec4(\n        dot(rand4Rot(b + nnpn, ds, ss), f - nnpn),\n        dot(rand4Rot(b + nppn, ds, ss), f - nppn),\n        dot(rand4Rot(b + pnpn, ds, ss), f - pnpn),\n        dot(rand4Rot(b + pppn, ds, ss), f - pppn)\n    ), vec4(\n        dot(rand4Rot(b + nnpp, ds, ss), f - nnpp),\n        dot(rand4Rot(b + nppp, ds, ss), f - nppp),\n        dot(rand4Rot(b + pnpp, ds, ss), f - pnpp),\n        dot(rand4Rot(b + 1.0, ds, ss), f - 1.0)\n    ), f.w);\n    vec4 z = mix5(z0, z1, f.z);\n    vec2 y = mix5(z.xz, z.yw, f.y);\n    return mix5(y.x, y.y, f.x);\n}\nfloat fractalNoise(vec4 p, mat4 ds,  vec4 ss) {\n    float value = 0.0;\n    float res = 2.0;\n    float scale = 1.0;\n    float scaleStep = 2.0;\n    vec4 f = ss;\n    for(int i = 0; i < 3; i++) {\n        f = rand4(f, 12345.6789012, 32109.8765432, ds, ss);\n        value += 3.0 * perlinGradient(vec4(p.xyz / res, p.w), ds, f) / scale;\n        scale = scale * scaleStep;\n        res = res / scaleStep;\n    }\n    float range = 0.75 / 2.0;\n    return value * range + range;\n}\nfloat Min(inout vec4 M, float m) {\n    float t;\n    for(int i = 0; i < 4; i++)\n        if(m < M[i]) {\n            t = m;\n            m = M[i];\n            M[i] = t;\n        }\n    return m;\n}\nfloat evoronoi( in vec2 x, vec4 c, /*float scale, */mat4 d, mat4 s ) {\n    float fallout = 64.0;\n    vec2 p = floor( x.xy );\n    vec2 f = fract( x.xy );\n    //mat4 s1 = rand44(s, 12345.6789012, 32109.8765432, d, s);\n    //mat4 d1 = rand44(d, 12.3456789012, 32.1098765432, d, s);\n    //mat4 d2 = rand44(d, 12.3456789012, 32.1098765432, d, s);\n    //mat4 d3 = rand44(d2, 12.3456789012, 32.1098765432, d, s);\n\n    //*\n    float res = 1.0e20;\n    //vec4 res = 1.0e20;\n    const float range = 1.0;\n    for( float j=-range; j<=range; j++ )\n    for( float i=-range; i<=range; i++ )\n    {\n        vec2 b = vec2( i, j );\n        /*\n        vec3  r = b - f + vec3(\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d, s[0])),\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d2, s[1])),\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d3, s[1]))\n        );\n\t\t//*/\n        vec2 r = b - f + rand2( p + b, 0.0, 1.0, d, s[0] );\n        float dis = length( r );\n\n        //res += exp( -fallout*dis );\n        res = min(res, dis);\n        //Min(res, dis);\n        //s1 = rand44(s1, 12345.6789012, 32109.8765432, d, s);\n        //d1 = rand44(d1, 12.3456789012, 32.1098765432, d, s);\n        //d2 = rand44(d2, 12.3456789012, 32.1098765432, d, s);\n    }\n    //return -1.125*(1.0/fallout)*log( res );\n    return res;\n    //*/\n    //return fractalNoise(vec3(p, x.z), 16.0, 1.0, 2.0, vec3(0.0), d, s[0]);\n}\nfloat evoronoi( in vec3 x, vec4 c, /*float scale, */mat4 d, mat4 s ) {\n    float fallout = 64.0;\n    vec3 p = floor( x.xyz );\n    vec3 f = fract( x.xyz );\n    //mat4 s1 = rand44(s, 12345.6789012, 32109.8765432, d, s);\n    //mat4 d1 = rand44(d, 12.3456789012, 32.1098765432, d, s);\n    //mat4 d2 = rand44(d, 12.3456789012, 32.1098765432, d, s);\n    //mat4 d3 = rand44(d2, 12.3456789012, 32.1098765432, d, s);\n\n    //*\n    //float res = 0.0;\n    //float res = 1.0e20;\n    vec4 res = vec4(1.0e20);\n    const float range = 1.0;\n    for( float k=-range; k<=range; k++ )\n    for( float j=-range; j<=range; j++ )\n    for( float i=-range; i<=range; i++ )\n    {\n        vec3 b = vec3( i, j, k );\n        /*\n        vec3  r = b - f + vec3(\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d, s[0])),\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d2, s[1])),\n            mix(0.0, 1.0, fractalNoise(vec4((p + b) * scale, x.w), d3, s[1]))\n        );\n\t\t//*/\n        vec3 r = b - f + rand3( p + b, 0.0, 1.0, d, s[0] );\n        float dis = length( r );\n\n        //res += exp( -fallout*dis );\n        //res = min(res, dis);\n        Min(res, dis);\n        //s1 = rand44(s1, 12345.6789012, 32109.8765432, d, s);\n        //d1 = rand44(d1, 12.3456789012, 32.1098765432, d, s);\n        //d2 = rand44(d2, 12.3456789012, 32.1098765432, d, s);\n    }\n    //return -1.125*(1.0/fallout)*log( res );\n    //return res;\n    return dot(res, c);\n    //*/\n    //return fractalNoise(vec3(p, x.z), 16.0, 1.0, 2.0, vec3(0.0), d, s[0]);\n}\nfloat fractalCell(vec3 p, vec4 c, mat4 ds,  mat4 ss) {\n    float value = 0.0;\n    float a = 1.0;\n    float aStep = 0.5;\n    float pStep = 2.0;\n    float tStep = 1.5;\n    vec3 t = vec3(0.0, 0.0, p.z+iTime*0.5);\n    mat4 f = ss;\n    const int steps = 5;\n    for(int i = 0; i < steps; i++) {\n        f = rand44(f, 12345.6789012, 32109.8765432, ds, ss);\n        value += evoronoi(p + t, c, ds, f) * a;\n        a *= aStep;\n        p *= pStep;\n        t *= tStep;\n    }\n    float r = aStep;\n    float sum = (1.0 - pow(r, float(steps))) / (1.0 - r);\n    return mix(0.0, 1.0, value / sum);\n}\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 dotseed = mat4(\n        84.4239141, 72.1623789, 54.2539214, 94.8233014,\n        45.8097063, 19.6603408, 41.9881591, 17.7513314,\n        70.6492482, 72.8228071, 31.9941736, 29.7793959,\n        68.9614210, 33.3000043, 38.8602285, 67.0907920\n    );\n    mat4 sineseed = mat4(\n        8442.39141, 7216.23789, 5425.39214, 9482.33014,\n        4580.97063, 1966.03408, 4198.81591, 1775.13314,\n        7064.92482, 7282.28071, 3199.41736, 2977.93959,\n        6896.14210, 3330.00043, 3886.02285, 6709.07920\n    );\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\t//uv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n    //float cs = cos(iTime*0.25), si = sin(iTime*0.25);\n\t//uv = uv*mat2(cs, -si, si, cs); \n    vec3 uvw = vec3(uv * 2.0, 3.1415926535898/8.0);\n    vec4 uvwx = vec4(uv, 0.0, iTime);\n\n    vec4 coeffs = vec4(1.0, 0.0, 0.0, 0.0);\n    coeffs = vec4(0.0, 1.0, 0.0, 0.0);\n    //coeffs = vec4(0.0, 0.0, 1.0, 0.0);\n    //coeffs = vec4(0.0, 0.0, 0.0, 1.0);\n    //coeffs = vec4(-1.0, 1.0, 0.0, 0.0);\n    float c = pow(fractalCell(uvw, coeffs, dotseed, sineseed), 2.0);\n    c = max(c + dot(rand3(uvw, 0.0, 1.0, dotseed, sineseed[0])*2.-1., vec3(0.015)), 0.);\n    c *= sqrt(c)*1.5;\n    \n    vec3 col = firePalette(c);\n    col = mix(\n        col,\n        col.zyx*0.15+c*0.85,\n        min(pow(dot(uv, uv)*1.2, 0.75), 1.)\n    );\n    col = pow(col, vec3(1.5));\n    \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n\t//fragColor = vec4(sqrt(vec3(clamp(c, 0., 1.))), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 635, 635, 662], [663, 663, 690, 690, 718], [719, 719, 767, 767, 829], [830, 830, 884, 884, 983], [984, 984, 1038, 1038, 1174], [1175, 1175, 1229, 1229, 1402], [1403, 1403, 1444, 1444, 2478], [2479, 2479, 2534, 2534, 3487], [3488, 3488, 3527, 3527, 3561], [3562, 3562, 3598, 3598, 3632], [3633, 3633, 3669, 3669, 3703], [3704, 3704, 3740, 3740, 3774], [3775, 3775, 3798, 3798, 3852], [3853, 3853, 3874, 3874, 3928], [3929, 3929, 3950, 3950, 4004], [4005, 4005, 4044, 4044, 4078], [4079, 4079, 4115, 4115, 4149], [4150, 4150, 4186, 4186, 4220], [4221, 4221, 4257, 4257, 4291], [4292, 4292, 4342, 4342, 5392], [5393, 5393, 5440, 5440, 5860], [5861, 5861, 5895, 5895, 6051], [6052, 6052, 6122, 6122, 7490], [7491, 7491, 7561, 7561, 9030], [9031, 9031, 9085, 9085, 9614], [9615, 9615, 9641, 9641, 9965], [9966, 9966, 10023, 10023, 11517]]}
{"id": "ll3yDN", "name": "Circle Fitting", "author": "BigWIngs", "description": "An old doodle I had lying around: making a spline by concatenating arcs. ", "tags": ["circlefitting"], "likes": 16, "viewed": 376, "published": "Public", "date": "1559779851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Circle Fitting 1 by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is an old doodle I had lying around. It is my attempt to come up with some sort of spline by\n// fitting arcs together. You can move the mouse to see the thing in action.\n// I figure that a reliable way to connect two arbitrary points which two arbitrary tangents by using\n// circle arcs would be very useful for many applications.\n// Perhaps the community can build on this, so I figured I'd make it public.\n\n/*\n\nSteps for fitting arcs into a spline\n\n1) Pick first arc the way you want\n2) draw line through arc center and end point. \n   New arc center has to be on this line to keep spline derivative smooth\n3) Pick end point for next arc, could be anywhere except for the line tangent\n   to the current arc end point\n4) Mark center between current arc end point and new point\n5) Draw line perpendicular through this center.\n   New arc center has to be on this line in order for it to go through both points.\n6) Find intersection between lines of steps 2 and 5\n7) Draw arc at the new center point with radius of the distance between center and new point\n8) Go to step 2 to add the next arc.\n\nThere are always two splines going through all the points (the arcs, and the anti arcs)\nYou can choose which one you like best, probably the shortest one\nYou can't indivdually control spline derivatives at each point. Since we are building this\nthing out of cirlces, you might get unintended loops.\nYou can change the way the spline flows by changing the type of arc you use to connect the\nfirst two points.\n*/\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n#define SHOW_HELPERS .7\n#define THICKNESS .01\nfloat circle(vec2 uv, vec2 p, float r, float w) {\n\tp -= uv;\n    float d = smoothstep(w, w*.5, abs(r-length(p)));\n    return d;\n}\n\nfloat arc(vec2 uv, vec2 p, vec2 a, vec2 b, float r, float w) {\n\tvec2 c = (a+b)/2.;\n    \n    return .1;\n}\n\nfloat point(vec2 uv, vec2 p, float r) {\n\treturn S(r, r*.8, length(uv-p));\n}\n\nvec2 R(vec2 a) {\n   return vec2(-a.y,a.x);\n}\n\nfloat lineseg(vec2 p, vec2 a, vec2 b,  float w) {\n    \n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\tfloat d = length(pa - ba * h);\n\n    return S(w, w*.8, d);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b,  float w) {\n    \n    vec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa,ba) / dot(ba,ba);\t\n\tfloat d = length(pa - ba * h);\n\n    return S(w, w*.8, d);\n}\n\n\n\nvec2 LineIntersect(vec2 a, vec2 b, vec2 c, vec2 d) {\n    float e = (b.x-a.x)*(d.y-c.y)-(b.y-a.y)*(d.x-c.x);\n    float r = ((a.y-c.y)*(d.x-c.x)-(a.x-c.x)*(d.y-c.y)) / e;\n    \n    vec2 p = a+r*(b-a);\n    \n    return p;\n}\n\nfloat Side(vec2 a, vec2 b, vec2 p){\n     return sign( ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x)) );\n}\nvec3 getCircle(vec2 p1, vec2 p2, vec2 p3) {\n\tfloat a = p1.x*(p2.y-p3.y)-p1.y*(p2.x-p3.x)+p2.x*p3.y-p3.x*p2.y;\n    float p1d = (p1.x*p1.x+p1.y*p1.y);\n    float p2d = (p2.x*p2.x+p2.y*p2.y);\n    float p3d = (p3.x*p3.x+p3.y*p3.y);\n    \n    float b = p1d*(p3.y-p2.y) + p2d*(p1.y-p3.y) + p3d*(p2.y-p1.y);\n    float c = p1d*(p2.x-p3.x) + p2d*(p3.x-p1.x) + p3d*(p1.x-p2.x);\n    float d = p1d*(p3.x*p2.y-p2.x*p3.y) + p2d*(p1.x*p3.y-p3.x*p1.y)+p3d*(p2.x*p1.y-p1.x*p2.y);\n    \n    vec2 p = vec2(-b/(2.*a), -c/(2.*a));\n    float r = length(p-p1);\n    return vec3(p, r);\n}\n\nvec4 fitArc(vec2 uv, vec2 lastCenter, vec2 start, vec2 end,  float side) {\n\tvec2 mid = (start+end)/2.;\n    vec2 perpendicular = (end-start).yx*vec2(-1,1);\n    vec2 arcCenter = LineIntersect(lastCenter, start, mid, mid+perpendicular);\n    float radius = length(start-arcCenter);\n    \n    float dist = length(uv-arcCenter)-radius;\n    dist = abs(dist);\t// signed or unsigned distance\n    \n    float mask = S(.02, 0.01, dist);\n    \n    perpendicular = (end-arcCenter).yx*vec2(-1,1);\n    vec2 maskPos = arcCenter+(mid-arcCenter)*2.;\n    \n    float r = length(end-maskPos);\n    float m = S(r, r-.001, length(maskPos-uv)); \n    \n    side = Side(end, start, arcCenter)*side;\n    if(side>0.) m = 1.-m;\n   \n    mask *= m;\n    \n    mask += lineseg(uv, start, end, .005);\n    mask += point(uv, arcCenter, .01);\n    return vec4(arcCenter, radius, mask);\n}\n\nvec3 circle3(vec2 uv, vec2 A, vec2 B, vec2 C, float dist) {\n     vec2 d = (A+B)/2.;\n    vec2 ab = B-A;\n    \n    vec2 e = (B+C)/2.;\n    vec2 bc = C-B;\n    \n    \n    vec2 f = d + vec2(-ab.y, ab.x)*dist;\n    vec2 g = e + vec2(-bc.y, bc.x);\n\n    vec2 p = LineIntersect(f, B, e, g);\n    \n    vec2 pe = p-e;\n    vec2 df = d-f;\n    \n    vec2 fb = B-f;\n    vec2 maskPos = LineIntersect(B, B+vec2(-fb.y, fb.x), g, p);\n    float r = length(B-maskPos);\n    float mask = S(r, r-.001, length(maskPos-uv)); \n    \n    float side = Side(A, B, maskPos);\n    if(side<0.) mask = 1.-mask;\n   // if(fract(iTime)<.5) mask = 1.-mask;\n    vec3 col = vec3(0);\n    col += circle(uv, p, length(p-B), THICKNESS)*max(SHOW_HELPERS*.2, mask);\n    \n    maskPos = LineIntersect(B, B+vec2(-fb.y, fb.x), d, f);\n    \n    r = length(B-maskPos);\n    mask = S(r, r-.001, length(maskPos-uv)); \n    if(dist<0.) mask = 1.-mask;\n   // if(fract(iTime)<.5) mask = 1.-mask;\n    col += circle(uv, f, length(f-B), THICKNESS)*max(SHOW_HELPERS*.2, mask);\n    \n    \n    vec3 helpers = vec3(0.);\n    helpers += point(uv, p, .015)*vec3(0,1,1);\n    helpers += lineseg(uv, A, B, .002)*.25;\n    helpers += lineseg(uv, B, C, .002)*.25;\n    helpers += lineseg(uv, d, f, .002)*.125;\n    helpers += line(uv, e, g, .002)*.125;\n    helpers += line(uv, f, B, .002)*vec3(1,1,0)*.1;\n    helpers += point(uv, d, .01)*vec3(0,1,0);\n    helpers += point(uv, e, .01);\n    helpers += point(uv, f, .01)*vec3(1,.5,0);\n    \n   \n    \n    //col += line(uv, f, B, .002)*vec3(1,1,0)*.5;\n    \n    vec2 n = R(B-f);\n    helpers += point(uv, B+n, .03)*vec3(1,0,1);\n    helpers += point(uv, B-n, .03)*vec3(1,0,1);\n    \n    helpers += lineseg(uv, B+n, B-n, .002)*vec3(1,1,0)*.5;\n     col += SHOW_HELPERS*helpers;\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tuv *= 2.;\n    vec2 M = iMouse.xy/iResolution.xy;\n    vec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    m *= 2.;\n    \n    vec3 col = vec3(0);\n    \n    float t = iTime;\n    vec2 p1 = vec2(-1.5,0);// +sin(vec2(.6, .1)*t)*vec2(.25,.5);\n    vec2 p2 = vec2(-.5,0);// + sin(vec2(.7, .2)*t)*vec2(.25,1.);\n    vec2 p3 = vec2(0,sin(iTime)*.2);// +sin(vec2(-.5, -.4)*t)*vec2(.25,.5);\n    vec2 p4 = vec2(.5,0)+p3;//sin(vec2(-.55, -.84)*t)*.5+vec2(.8,0)*0.;\n    vec2 p5 = vec2(1.5,0);//sin(vec2(-.25, -.14)*t)*.5+vec2(.8,0)*0.;\n    \n    if(iMouse.x>20.) p2 = m;\n    col.r += point(uv, p1, .02);\n    col.g += point(uv, p2, .02);\n    col.b += point(uv, p3, .02);\n   \tcol.rg += point(uv, p4, .02);\n    col.rb += point(uv, p5, .02);\n    \n    float s = 1.;//sin(t)*10.;\n    col += circle3(uv, p1, p2, p3, M.x*3.)*vec3(.1, .8, .8);\n    //col += circle3(uv, p4, p3, p2, 0.1)*vec3(.8,.8,.1);\n    //col += circle3(uv, p3, p4, p5, (m.y-.5)*10.)*vec3(.8,.1,.8);\n    \n    float side = -1.;\n    \n    vec4 a = fitArc(uv, vec2(-1.,2), p1, p2,side);\n    float d = a.a;\n    a = fitArc(uv, a.xy, p2, p3,-side);\n    d += a.a;\n    //d = min(d, a.a);\n     a = fitArc(uv, a.xy, p3, p4,side);\n    d += a.a;\n    //d = min(d, a.a);\n    a = fitArc(uv, a.xy, p4, p5,-side);\n    d+=a.a;//d = min(d, a.a);\n    \n   //  col += d*.1;//S(.02, 0.01, d)*vec3(.1, .8, .8);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[620, 1798, 1847, 1847, 1926], [1928, 1928, 1990, 1990, 2032], [2034, 2034, 2073, 2073, 2109], [2111, 2111, 2127, 2127, 2155], [2157, 2157, 2206, 2206, 2357], [2359, 2359, 2405, 2405, 2541], [2545, 2545, 2597, 2597, 2763], [2765, 2765, 2800, 2800, 2875], [2876, 2876, 2919, 2919, 3435], [3437, 3437, 3511, 3511, 4280], [4282, 4282, 4341, 4341, 6033], [6037, 6037, 6094, 6094, 7520]]}
{"id": "tdSSWc", "name": "Neon Room", "author": "taso69", "description": "Neon Room\nReferenced the techniques in these shaders\nhttps://www.shadertoy.com/view/MlscDj\nhttps://www.shadertoy.com/view/ldGyWW", "tags": ["3d", "glow"], "likes": 21, "viewed": 341, "published": "Public", "date": "1561552732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14195265359\n#define EPS 0.001\n\nmat2 rotate(float a){\n\tfloat s = sin(a); float c = cos(a);\n\treturn mat2(c, -s,s, c);\n}\n\nfloat hash21( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 hash22(vec2 p){\n    float n = hash21(p);\n    return vec2(n,hash21(n+p));\n}\n\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdCappedCylinder( vec3 pos, vec2 h ){\n  vec2 d = abs(vec2(length(pos.xz),pos.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 pos, vec3 a, vec3 b, float r ){\n    vec3 pa = pos - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdWireBox(vec3 pos,float W,float H, float D){\n    float r = 0.01;\n    float hw = 0.5*W, hh = 0.5*H, hd = 0.5*D;\n    float d= sdCapsule(pos- vec3(-hw,0.0,-hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r);\n    d = min(d,sdCapsule(pos- vec3(-hw,0.0,hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(hw,0.0,-hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(hw,0.0,hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,-hh,-hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,-hh,hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,hh,-hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,hh,hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r)); \n    d = min(d,sdCapsule(pos- vec3(-hw,-hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(-hw,hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(hw,-hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(hw,hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    return d;\n}\n\n\nfloat sdBox(vec3 pos, vec3 b){\n    vec3 d = abs(pos) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat sdWall(vec3 pos){\n    pos.xz = abs(pos.xz);\n    return min(5.0-pos.z,5.0-pos.x);\n}\n\n//Roof and Floor\nfloat sdRF(vec3 pos){\n    return min(pos.y + 1.0,3.0 - pos.y);\n}\n\nvec2 matMin(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n//https://www.shadertoy.com/view/ldGyWW\nvec3 map(vec3 pos){\n    vec2 dist = vec2(10000.0,-1.0);//x:dist, y:material\n    float light = 10000.0;//light object\n    \n    vec3 p = pos;\n    float rep = 2.5;\n    vec3 id = floor(pos/rep);\n    p.xz = mod(p.xz,rep) - rep*0.5;\n    vec2 rand = 1.2*hash22(id.xz) - vec2(0.6);\n    p -= vec3(rand.x,0.0,rand.y); \n    p.xz *= rotate(iTime);\n    p.y += 8.0*fract(-hash21(id.zz)*iTime*0.7+hash21(id.xz))-4.0; \n    float cube = sdWireBox(p,0.4,0.4,0.4);\n    dist = matMin(dist,vec2(cube,1.0));\n   \n    p = pos;\n    rep = 3.0;\n    id = floor(pos/rep);\n    p.xz = mod(p.xz,rep) - rep*0.5;\n    rand = 1.3*hash22(id.zx) - vec2(0.65);\n    p -= vec3(rand.x,0.0,rand.y); \n    p.y += 8.0*fract(-hash21(id.xz)*iTime*0.25+hash21(id.zx))-4.0;\n    float sphere = sdSphere(p,0.5);\n    dist = matMin(dist,vec2(sphere,2.0));\n\n    p = pos;\n    float wall = sdWall(p);\n    dist = matMin(dist,vec2(wall,1.0));\n    float roof = sdRF(p);\n    dist = matMin(dist,vec2(roof,2.0));\n\n    p = pos;\n    float tRep = 0.75;\n    vec2 tId = floor(pos.xz/tRep); \n    float lam = hash21(hash22(tId))*2.0 + 0.5;\n     float speed = 2.0*hash21(tId) - 1.0; \n    p.xz = mod(p.xz,tRep) - tRep*0.5;\n    p.y = mod(p.y+speed*iTime,lam) - lam * 0.5;\n    float tile = sdBox(p,vec3(tRep*0.45,lam*0.48,tRep*0.45));\n    float mask = clamp(5.0+4.0*sin(iTime),3.0,4.8);\n    tile = max(tile, -sdBox(pos,vec3(mask)));\n    dist = matMin(dist,vec2(tile,2.0));\n\n    light = min(cube,wall);\n    return vec3(dist,light);\n}\n\nvec3 calcNorm(vec3 pos){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 light = normalize(vec3(0.0,5.0,3.0));\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = vec3(0.0);\n    float gl =  0.0;\n    vec3 col_gl = pal(iTime*0.1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    vec3 col_rGl = pal(iTime*0.1+0.3, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\n    float t = 0.0;\n    vec3 m;\n    vec3 pos;\n    for(int i = 0; i < 64; i++){\n        pos = ro + t*rd;\n      \tm = map(pos);\n        if(m.x < EPS) break;\n        //t += m.x*0.75;\n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        t += min(min((step(0.0,rd.x)-fract(pos.x))/rd.x, \n            (step(0.0,rd.z)-fract(pos.z))/rd.z)+0.01,m.x)*0.75;\n        gl += 0.1 / (m.z*m.z*300.0);\n    }\n    pos = ro + t*rd;\n   \n    vec3 norm = calcNorm(pos);\n    vec3 v = normalize(ro-pos);\n    vec3 l = normalize(light-pos);\n    vec3 r = normalize(reflect(rd,norm));\n    \n    t = 0.0;\n    vec3 rRo = pos + norm*0.05;\n    vec3 rPos;\n    vec3 rM;\n    float rGl = 0.0;\n    for(int i = 0; i < 32; i++){\n        rPos = rRo + t * r;\n        rM = map(rPos);\n        if(rM.x < EPS) break;\n        //t += m.x * 0.75;\n        t += min(min((step(0.0,r.x)-fract(rPos.x))/r.x, \n            (step(0.0,r.z)-fract(rPos.z))/r.z)+0.01,rM.x)*0.75;\n        rGl += 0.1 / (rM.z*rM.z*300.0);\n    }\n    \n    float diff = clamp(dot(l, norm), 0.1, 1.0);//diffuse\n   \n    if(m.y == 2.0){\n        col = diff*vec3(0.10) + col_gl*gl + col_rGl*rGl;\n    }else{//grow object\n        col = col_gl * gl;\n    }  \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    if ((iResolution.x/iResolution.y) < (16.0/9.0)){\n        p /= (iResolution.x/iResolution.y) / (16.0/9.0);\n    }\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 ro = vec3(0.0,0.75,3.0);\n   \tro.xz *= rotate(iTime*0.25);\n    \n    vec3 cDir = normalize(lookAt-ro);\n    vec3 cSide = normalize(cross(cDir,up));\n    vec3 cUp = normalize(cross(cSide,cDir));\n     \n    vec3 rd= normalize(cSide * p.x + cUp * p.y + cDir * 2.0 );\n \n\tvec3 col = render(ro,rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSSWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 65, 65, 130], [132, 132, 155, 155, 225], [227, 227, 247, 247, 306], [308, 371, 438, 438, 481], [483, 483, 526, 526, 629], [631, 631, 684, 684, 813], [815, 815, 866, 866, 1983], [1986, 1986, 2016, 2016, 2109], [2111, 2111, 2145, 2145, 2175], [2177, 2177, 2200, 2200, 2265], [2267, 2284, 2305, 2305, 2348], [2350, 2350, 2378, 2378, 2412], [2414, 2454, 2473, 2473, 3912], [3914, 3914, 3938, 3938, 4227], [4273, 4273, 4303, 4303, 5772], [5774, 5774, 5830, 5830, 6431]]}
{"id": "tl23Ww", "name": "nothing shape", "author": "movAX13h", "description": "after a GIF dave posted on Twitter: https://twitter.com/beesandbombs/status/1136416601165746176", "tags": ["shapes", "reproduction"], "likes": 6, "viewed": 370, "published": "Public API", "date": "1559853869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI2 = 6.283185307179586476925286766559;\nconst float PI05 = 1.5707963267948966192313216916398;\nconst float PI025 = 0.78539816339744830961566084581988;\n\nvec2 rotate(vec2 v, float a)\n{\n    return vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\n\nfloat dir(vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\n\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3));\n}\n\nbool insideQuad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, d) < 0.0;\n\tbool b4 = dir(p, d, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3) && (b3 == b4));\n}\n\nbool insideTriStar(vec2 p, float s, float r)\n{\n    float d = s * 0.70710678118654752440084436210485;\n    vec2 a = vec2(-d, -s - d);\n    vec2 b = vec2(-d, d);\n    vec2 c = vec2(s + d, d);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        float r = float(i) * PI05 + r;\n    \tif (insideTri(p, rotate(a, r), rotate(b, r), rotate(c, r))) return true;\n    }\n    \n    return false;\n}\n\nbool insideSquare(vec2 p, vec2 pos, float size, float rot)\n{\n    vec2 _ = vec2(-0.5*size, 0.5*size);\n    vec2 a = rotate(_.xx, rot) + pos;\n    vec2 b = rotate(_.yx, rot) + pos;\n    vec2 c = rotate(_.yy, rot) + pos;\n    vec2 d = rotate(_.xy, rot) + pos;\n    return insideQuad(p, a, b, c, d);    \n}\n\n\nvec3 scene(vec2 p)\n{\n    vec3 col = vec3(1.0);\n    \n    float rot = - iTime;\n    float r = 0.64;\n\n    if (int(floor(iTime / PI025)) % 2 == 0) \n    {\n        for(int i = 0; i < 8; i++)\n        {\n            float a = rot + float(i) * PI025;\n            vec2 pos = vec2(r * cos(a), r * sin(a));        \n            if (insideSquare(p, pos, 0.38, iTime + float((i + 1) % 2) * PI025)) col = vec3(0.);    \n        }\n    }\n    else\n    {\n    \tif (insideSquare(p, vec2(0.), 1.285, 0.)) col = vec3(0.);\n    \tif (insideSquare(p, vec2(0.), 1.285, PI025)) col = vec3(0.);\n    \tif (insideTriStar(p, 0.38, rot)) col = vec3(1.);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(scene(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl23Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 245, 245, 322], [325, 325, 360, 360, 425], [427, 427, 475, 475, 608], [610, 610, 667, 667, 845], [847, 847, 893, 893, 1223], [1225, 1225, 1285, 1285, 1521], [1524, 1524, 1544, 1544, 2167], [2169, 2169, 2226, 2226, 2333]]}
{"id": "tl23zK", "name": "testtesttesttesttest", "author": "gwm5872", "description": "test", "tags": ["test"], "likes": 1, "viewed": 214, "published": "Public API", "date": "1560751824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl23zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "tl2GWm", "name": "[TWITCH] Sugar Rush", "author": "Flopine", "description": "Meet Susan the Unicorn! Based on an idea that I had with Jasmin68k during Outline :)\nMade during a Twitch stream here: https://www.twitch.tv/flopine ", "tags": ["raymarching", "specular", "balloon", "unicorn"], "likes": 14, "viewed": 214, "published": "Public", "date": "1559858312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\nfloat ITER = 100.;\nfloat PI = acos(-1.);\n\n#define time iTime\n\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\n// iq modeling function\nfloat capsule (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p-a; vec3 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.,1.);\n    return length(pa - ba*h) - r+smoothstep(0.1,0.6,abs(h-.5))*0.08;\n}\n\nfloat cutesule (vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 pa = p-a; vec3 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.,1.);\n    return length(pa - ba*h) - mix(r1,r2, h);\n}\n\nfloat body (vec3 p)\n{\n    return capsule (p, vec3(.65,0.,0.), vec3(-.65,0.,0.),0.5);\n}\n\nfloat neck (vec3 p)\n{\n    p.x += sin(p.y*2.)*0.2; \n    return cutesule (p-vec3(.9,.3,0.), vec3(0.), vec3(0.5,0.7,0.), 0.3, 0.45); \n}\n\nfloat face (vec3 p)\n{\n    return cutesule(p-vec3(1.4,1.,0.), vec3(0.), vec3(.6,-0.3,0.), 0.4,0.25);\n}\n\nfloat legs (vec3 p)\n{\n    p.z = abs(p.z)-0.5;\n    vec3 pp = p;\n\n    p.x += sin (p.y*2.)*0.1;\n    float l1 = capsule (p-vec3(.7,-1.3,0.), vec3(0.), vec3(0.,1.,-.2), 0.3);\n\n    p = pp;\n    p.x -= sin (p.y*2.)*0.2;\n    float l2 = capsule (p-vec3(-.7,-1.4,0.), vec3(0.), vec3(0.,1.2,-.2), 0.28);\n    return min(l2,l1);\n}\n\nfloat mane (vec3 p)\n{\n    p.z = abs(p.z)-0.15;\n    p -= vec3(.4,.5,0.);\n    p.xy *= rot(-PI/4.);\n    p.x += sin(p.y*2.)*0.3; \n    float s1 = length(p-vec3(0.,1.,0.))-0.3;\n    float s2 = length(p-vec3(0.,.6,0.))-0.25;\n    float s3 = length(p-vec3(0.,.3,0.))-0.2;\n    float s4 = length(p-vec3(0.,.05,0.))-0.1;\n    return min(min(s4,s2),min(s1, s3));\n}\n\nfloat tail (vec3 p)\n{\n    p += vec3(1.6,.8,0.);\n    p.xy *= rot(-PI/4.);\n    p.x += sin(p.y*2.)*0.3; \n    float s1 = length(p-vec3(0.,1.,0.))-0.4;\n    float s2 = length(p-vec3(0.,.4,0.))-0.35;\n    float s3 = length(p-vec3(0.,.1,0.))-0.3;\n    float s4 = length(p-vec3(0.,-0.2,0.))-0.2;\n\n    return min(min(s4,s2),min(s1, s3));\n}\n\nfloat horn (vec3 p)\n{\n    p.xy -= vec2(1.2);\n    p.xy *= rot(-PI/4.);\n    return cutesule(p, vec3(0.), vec3(0.,1.,0.), 0.25,0.08);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    float per = 5.5;\n    p.yz *= rot(mix(PI/10., -PI/10., floor(sin(time*2.)+1.)));\n    p.x -= time;\n    p.y -= -.3+abs(sin(time*2.));\n    p.x = mod(p.x-per*0.5, per)-per*0.5;\n\n    float prim1 = min(min(body(p),legs(p)), min(neck(p),face(p)));\n    float prim2 = horn(p);\n    float prim3 = min(mane(p),tail(p));\n\n    float d =  min(min(prim1, prim2),prim3);\n\n    if (d == prim1) mat_id =1;\n    if (d == prim2) mat_id =2;\n    if (d == prim3) mat_id =3;\n\n    return d;\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\n// iq shader: https://www.shadertoy.com/view/lsccR8\nfloat sdfStar5( in vec2 p )\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n\n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float per = 3.;\n    vec2 uu = mod(uv*10.,per)-per*0.5;\n    uu *= rot(sin(time*2.)*0.5);\n\n    vec3 ro = vec3(0.001,0.001,-6.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = clamp(vec3(smoothstep(0.1,0.11,sdfStar5(uu)))+vec3(0.8,0.6,0.8),0.,1.);\n\n    float shad = 0.; bool hit = false;\n\n    for(float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p+=d*rd*0.7;\n    }\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        vec3 l = normalize(vec3(1.,2.,-8.));\n        vec3 albedo;\n        if (mat_id == 1) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(0.5), vec3(0.,0.37,0.73));\n        if (mat_id == 2) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(3.), vec3(0.,0.37,0.73));\n        if (mat_id == 3) albedo = palette(dot(n, -rd),vec3(0.5), vec3(0.5), vec3(0.9), vec3(0.,0.37,0.73));\n\n        col = albedo + vec3(pow(max(0.,dot(reflect(rd,n), l)), 15.));\n        col *= vec3(1.-shad);\n    }\n\n\n    fragColor = vec4(pow(col, vec3(0.4545)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2GWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 375, 395, 395, 439], [441, 465, 514, 514, 670], [672, 672, 733, 733, 866], [868, 868, 889, 889, 954], [956, 956, 977, 977, 1088], [1090, 1090, 1111, 1111, 1191], [1193, 1193, 1214, 1214, 1509], [1511, 1511, 1532, 1532, 1860], [1862, 1862, 1883, 1883, 2189], [2191, 2191, 2212, 2212, 2323], [2337, 2337, 2357, 2357, 2825], [2827, 2827, 2883, 2883, 2914], [2917, 2917, 2940, 2940, 3055], [3057, 3109, 3138, 3162, 3496], [3498, 3498, 3555, 3555, 4808]]}
{"id": "tlB3WG", "name": "Moon Flyby", "author": "SSHantaram", "description": "Raymarched plane with procedural noise perturbations.", "tags": ["raymarching", "bump"], "likes": 8, "viewed": 185, "published": "Public", "date": "1560951455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float BUMP_FACTOR = 0.5;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    return 0.7*noise(x) + 0.2*noise(x*4.0) + 0.07*noise(x*8.0) + 0.02*noise(x*16.0) + 0.01*noise(x*32.0);\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\n// singed distanc function of plane with noise bump map\nfloat bumpPlaneSDF(vec3 p) {\n    // get distance to plane as usual\n    float d = planeSDF(p);\n    \n    vec3 normal;\n    float bump = 0.0;\n    \n  \t// only consider bumps if close to plane\n    if(d < BUMP_FACTOR*1.5)\n\t{\t\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n\t\tbump = layeredNoise(p)*BUMP_FACTOR;\n\t}\n    return d - bump;\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n    return bumpPlaneSDF(samplePoint);\n}\n\n// returns the distanse to the scene along this ray\n// by raymarching using the sceneSDF\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    //raymarching loop\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // get distance to scene\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        // exit if close enough\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        // step closer\n        depth += dist;\n        // exit if too far\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// lambert shading coefficient with raymarched shadows\nfloat lambertShading(vec3 p, vec3 lightDir) {\n    vec3 n = estimateNormal(p);\n    \n    // lambert shading coefficient\n    float brightness = max(0.0, dot(-lightDir, n));\n    \n    // trace ray from surface point in direction of the light source\n    // offset in direction of the normal to avoid self intersection\n    float distToLight = shortestDistanceToSurface(p + n * EPSILON * 100.0, -lightDir, MIN_DIST, MAX_DIST);\n    \n    // in shadow\n    if (distToLight + 10.0 * EPSILON < MAX_DIST) {\n        return 0.0;\n    }\n    \n    return brightness;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \tvec3 eye = vec3(2.0*sin(iTime*0.3 - 3.0), 3.0, iTime);\n    mat3 viewToWorld = viewMatrix(eye, eye + vec3(2.0*sin(iTime*0.3), -3.0, 8.0), vec3(0.2*sin((iTime-1.0)*0.3), 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 lightDir = normalize(vec3(-1.0, -1.0, -3.0));\n    \n    vec3 ambientLight = vec3(0.01, 0.01, 0.005);\n    vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n    \n    vec3 color = ambientLight;\n    \n    color += diffuseColor*lambertShading(p, lightDir);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlB3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 177, 197, 197, 292], [294, 317, 343, 343, 875], [877, 916, 947, 947, 1055], [1057, 1102, 1126, 1126, 1144], [1146, 1202, 1230, 1268, 1516], [1518, 1561, 1595, 1595, 1635], [1637, 1726, 1817, 1817, 2261], [2263, 2263, 2328, 2328, 2460], [2462, 2535, 2564, 2564, 2874], [2876, 2905, 2954, 2989, 3120], [3122, 3177, 3222, 3222, 3724], [3728, 3728, 3785, 3785, 4711]]}
{"id": "tlBGRK", "name": "XYZ Plane distance function", "author": "edo_m18", "description": "XYZ Plane distance function", "tags": ["plane"], "likes": 1, "viewed": 112, "published": "Public", "date": "1560216499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    p = abs(p);\n    \n    vec3 d = vec3(0.5, 0.5, 3.8) - p;\n    return max(d.x, max(d.y, d.z));\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    \n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    \n    return normalize(n);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 mo = (iMouse.xy / iResolution.xy) + 1.0;\n    vec3 ro = vec3(sin(iTime), 0, 9.);\n    vec3 ta = vec3(0, 0, 1.);\n    \n    vec3 p = ro;\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n    int march = 0;\n    const int max_march = 128;\n    for (int i = 0; i < max_march; i++)\n    {\n        d = map(p);\n        march = i;\n        \n        if (d < 0.01) break;\n        \n        p += ray * d;\n        t += d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 light = normalize(vec3(1, 1, 2));\n        vec3 n = getNormal(p);\n        float diff = clamp(dot(light, n), 0.1, 1.0);\n        \n        col = vec3(diff);\n    }\n    \n    vec3 fog = vec3(0.5, 0.8, 1.7) * t * 0.01;\n    float fog2 = pow((1.0 / float(max_march)) * float(march), 2.);\n\n    fragColor = vec4(col,1.0) * fog2 + fog.rgbr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 116], [118, 118, 142, 142, 325], [327, 327, 358, 358, 532], [534, 534, 591, 591, 1520]]}
{"id": "tlBGW3", "name": "Commented Mandelbrot (Flashes)", "author": "glyre", "description": "A Mandelbrot fractal, but I commented the code in a manner I wish I had seen a while back :)\n\nI made my own complex number type instead of using a vec2 for demonstration. I remember that specifically baffled me at one point.", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 60, "published": "Public", "date": "1561316009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A commented Mandelbrot fractal shader\n// Dedicated to the public domain via the Unlicense\n\n//\n// Complex Math\n//\n\n/** A complex number. */\nstruct complex {\n    float real;\n    float imag;\n};\n\n/** Add two complex numbers together. */\ncomplex complex_add(complex a, complex b) {\n    complex sum;\n    sum.real = a.real + b.real;\n    sum.imag = a.imag + b.imag;\n    return sum;\n}\n\n/** Multiply two complex numbers together. */\ncomplex complex_multiply(complex a, complex b) {\n    complex product;\n    product.real = a.real * b.real - a.imag * b.imag;\n    product.imag = a.real * b.imag + a.imag * b.real;\n    return product;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) {\n    return complex_multiply(a, a);\n}\n\n//\n// Mandelbrot Fractal\n//\n\n/**\n * The maximum number of Mandelbrot iterations. If we hit this value,\n * then we know the pixel under test lies in the Mandelbrot set.\n */\nconst int MAX_ITERATIONS = 100;\n\n// HSV to RGB converter by Sam Hocevar (http://sam.zoy.org/)\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  \tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Get normalized pixel coordinates\n    // Center is (0, 0), bottom-left is (-0.5, -0.5), and top-right is (0.5, 0.5)\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\n    // Correct the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Zoom the \"camera\" in and out of the scene\n    uv.xy += uv.xy * 0.5 * (sin(0.25 * 3.14 * iTime) - 0.5);\n \n    // Move the \"camera\" around the scene\n    uv.x -= 1.0 + 0.5 * cos(0.125 * 3.14 * iTime);\n    uv.y += 0.5 * sin(0.5 * 3.14 * iTime);\n\n    // Start iterating at zero (which is both a real and a complex number)\n    complex z;\n    z.real = 0.0;\n    z.imag = 0.0;\n\n    // Run a bunch of iterations to test if this pixel is in the Mandelbrot set\n    // The iterations variable is outside the loop so we can go back and retrieve it\n    int iterations;\n    for (iterations = 0; iterations < MAX_ITERATIONS; ++iterations) {\n        // Wrap pixel coordinates into a complex term (treat x as real and y as imaginary)\n        // This will let us check if the pixel is in the Mandelbrot set\n        // If it is not, we will remember how many iterations it took to figure out it's not\n        // This number of iterations plotted against the XY plane makes a fractal! Neat!\n        complex c;\n        c.real = uv.x;\n        c.imag = uv.y;\n\n        // Update the Mandelbrot algorithm (from Wikipedia)\n        z = complex_add(complex_square(z), c);\n\n        // If the series diverged\n        // We use the number 2 as an \"escape\" value to test for divergence\n        if (z.real * z.real + z.imag * z.imag > 2.0 * 2.0) {\n            // Stop iterating\n            break;\n        }\n    }\n\n    // The color intensity of this pixel\n    // As mentioned above, the fractal is not the set, per se...\n    // To get the fractal, we plot the # of iterations we took at each pixel\n    // The more iterations a pixel took, the brigher we make it (more intense)\n    float intensity = 0.25 + float(iterations) / float(MAX_ITERATIONS);\n\n    // Color this pixel according to its intensity\n    fragColor = vec4(1.5 * intensity * hsv2rgb(vec3(intensity + 1.5 * iTime, 0.75, 0.75)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBGW3.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[195, 236, 279, 279, 378], [380, 426, 474, 474, 625], [627, 659, 694, 694, 731], [938, 1064, 1086, 1086, 1252], [1254, 1254, 1309, 1428, 3425]]}
{"id": "tlj3RK", "name": "Essence of Helix 3.0", "author": "cmarangu", "description": "https://www.shadertoy.com/view/Wt2GR1 is the second version", "tags": ["tunnel", "spiral", "blue", "helix", "cyan"], "likes": 2, "viewed": 173, "published": "Public", "date": "1560302684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.1415926;\n    // 535897932384626433832795028841971693993751058209749\n    // ima bit rusty i know 370ish digits\n\tfloat squish = 1.0;\n    float squash = 1.1;\n    vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    vec2 xy = vec2(\n        (fragCoord.x-center.x)/squash,\n    \t(fragCoord.y-center.y)/squish\n    );\n    \n    // â for convenience\n    float x = xy.x;\n    float y = xy.y;\n    \n    float zr = iTime+500.0/sqrt(x*x+y*y);\n    float zt = mod(3.1415*2.0+1.0*atan(y,x), 3.141*2.0);\n    \n    // it makes it be all checkerboardy\n    float czk1 = 1.0/PI;\n    float czk2 = 30.0/PI;\n    // zr = floor(zr*czk1)/czk1;\n    zt = floor(zt*czk2)/czk2;\n    \n    float parx = 0.5 + 0.5*cos(zt*16.0+zr);\n    float pary = 0.5 + 0.5*cos(zt*16.0+zr*16.0);\n    \n    // parx = mod(1.5+(zr*6.0+zt), 6.0)/6.0;\n    // pary = mod((zt+zt), 3.141)/3.141;\n    \n    // a differet textrue thingy\n    // parx = mod(zt*12.0+zr*6.0, PI*2.0)/PI/2.0;\n    // pary = mod(zt*6.0+zr, PI*2.0)/PI/2.0;\n    \n    \n    // ugly black fog at the horizon. yuck.\n    // float fog = 5.0;\n    \n    // if (abs(y)<fog) {\n    //     parx = parx*sqrt(y/fog);\n    //     pary = pary*sqrt(y/fog);\n    // }\n    \n    vec3 col = vec3(min(parx, pary), parx, max(parx, pary));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlj3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1362]]}
{"id": "tljGWc", "name": "prinz sammy #1", "author": "prinzsammy", "description": "first project ", "tags": ["wiz"], "likes": 1, "viewed": 60, "published": "Public", "date": "1561410238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 C, in vec2 P )\n{\n   vec2 p = P.xy / iResolution.x;\n\n  float _ = sin (mod(floor(p.x * 32.) + floor(p.y * 25.), 2.)+iTime);\n    C = vec4(0.6,_,0.1,_);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 175]]}
{"id": "tlS3Wm", "name": "MandelToast", "author": "cafe", "description": "Toast of mandels", "tags": ["mandeltoast"], "likes": 0, "viewed": 47, "published": "Public", "date": "1559758447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 300\n#define AA 2\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );   \n    \n}\n\nvec2 zoom(vec2 uv, vec2 A, vec2 B){\n    return A + (B-A)*uv;\n}\n\nvec2 zoomOn(vec2 uv, vec2 p, float z){\n \treturn (uv/z+p);    \n}\n\nvec2 complexSquare(vec2 c){\n    return vec2(c.x*c.x - c.y*c.y, 2.*c.x * c.y);\n}\n\nfloat mandelbrot(vec2 uv){\n    \n    vec2 c = vec2(0.);\n    \n    int i=0;\n    \n    for(i ; i<ITERATIONS ; i++){\n        c = complexSquare(c) + uv;\n        \n        if(dot(c,c) > 4.){\n            break;\n        }\n        \n    }\n    return float(i)/float(ITERATIONS);\n}\n\nvec3 color(vec2 uv){\n    \n    float zoom = pow(2.,iTime);\n    \n    //uv = zoom(uv,vec2(-0.5),vec2(-0.4));\n    //uv = zoomOn(uv, vec2(-0.99,-.3), 10000.);\n    uv = zoomOn(uv, vec2(\n        0.3602404434376143632361252444495453084826078079585857504883758147401953460592,\n        -0.6413130610648031748603750151793020665794949522823052595561775430644485741727),\n        zoom);\n\n    // Time varying pixel color\n    float mandel = mandelbrot(uv);\n    \n    //mandel = pow(mandel,1./(log2(zoom)/2.));\n    \n    mandel = pow(mandel,0.2 + log2(zoom)/18.);\n    \n   \treturn palette(mandel, \n                  vec3(0.5, 0.5, 0.5), \n                  vec3(0.5, 0.5, 0.5), \n                  vec3(1.0, 1.0, 1.0), \n                  vec3(0.30, 0.20, 0.20));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y * vec2(1.,-1.);\n    \n    // (x,y), (x+.5,y) , (x+.5,y+.5) , (x, y+.5)\n    \n    vec3 col = vec3(0.);\n    \n    for(int i=0 ; i<AA ; i++){\n        for(int j=0 ; j<AA ; j++){\n            col += color(uv+vec2(float(2.*float(i)/float(AA)),\n                                 float(2.*float(j)/float(AA))\n                                )/iResolution.xy);\n        }\n    }\n    \n    col /= float(AA)*float(AA);\n    \n    uv += vec2(2.)/iResolution.xy;\n   \n\n    //vec3 col = color(uv);\n\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlS3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 109, 109, 160], [162, 162, 197, 197, 224], [226, 226, 264, 264, 289], [291, 291, 318, 318, 370], [372, 372, 398, 398, 638], [640, 640, 660, 660, 1382], [1384, 1384, 1441, 1491, 2059]]}
{"id": "tlS3WV", "name": "Sphere Slime", "author": "ichigotake", "description": "Slimes are dancing.", "tags": ["raymarching", "slime"], "likes": 1, "viewed": 64, "published": "Public", "date": "1561125150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\nconst float EPS = 0.002;\n\nmat2 rotate(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sphereSlime(vec3 p)\n{\n    float t = sin(iTime)*0.4;\n    p.xy *= rotate(t*PI*1.4);\n    return length(p) - abs(cos(p.x+iTime))*.2 - abs(sin(p.y+iTime))*.2;\n}\n\nfloat bgSphereSlimes(vec3 p)\n{\n    p = mod(p, 0.75)-0.2;\n    p.y -= 0.2;\n    p.x -= 0.2;\n    float t = cos(iTime)*0.3;\n    p.xy *= rotate((t+p.x/p.y)*PI*1.4);\n    return length(p) - 0.2 - abs(sin(p.x+iTime*1.2))*0.03 - abs(cos(p.y+iTime*1.2))*0.03;\n}\n\nfloat dist(vec3 p)\n{\n    return min(sphereSlime(p), bgSphereSlimes(p));\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        dist(p + vec3(EPS, 0.0, 0.0) - vec3(EPS, 0.0, 0.0)),\n        dist(p + vec3(0.0, EPS, 0.0) - vec3(0.0, EPS, 0.0)),\n        dist(p + vec3(0.0, 0.0, EPS) - vec3(0.0, 0.0, EPS))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.x;\n    vec3 color = vec3(0.0);\n    \n    vec3 ro = vec3(uv, 0.0);\n    vec3 rd = vec3(0.0, 0.0, 1.0);\n    \n    float d = 0.0;\n    for(int i=0; i<1; i++){\n        float fi = float(i);\n        vec3 p = ro + rd*fi;\n        d += dist(p);\n        if(d<0.01){\n            color = normal(p)*d;\n            color =  normalize(color + vec3(0.1, 0.2, 0.1));\n            break;\n        }\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlS3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 142], [144, 144, 171, 171, 305], [307, 307, 337, 337, 557], [559, 559, 579, 579, 632], [634, 634, 655, 655, 874], [876, 876, 933, 933, 1415]]}
{"id": "tlSGDV", "name": "Shaded voronoi flow", "author": "TSalty21", "description": "Just messing around", "tags": ["voronoi"], "likes": 6, "viewed": 103, "published": "Public", "date": "1561126009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    vec2 st = uv;\n    \n    st -= iTime*vec2(-0.1, 0.1);\n    \n    st *= 8.0;\n    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    float m_dist = 8.0;\n    float m_angle;\n    vec2 mb;\n    vec2 mr;\n    \n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n            \n            vec2 point = random2(i_st + neighbor);\n            \n            point = 0.5 + 0.5*sin(0.5*iTime + 6.2831*point);\n            \n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = dot(diff, diff);\n\n            // Keep the closer distance\n            if(dist < m_dist) {\n                m_dist = dist;\n                m_angle = atan(diff.y, diff.x);\n                mb = neighbor;\n                mr = diff;\n            }\n        }\n    }\n    \n    \n    \n    m_dist = 8.0;\n    vec2 nb;\n    vec2 nr;\n    \n    for (int y= -2; y <= 2; y++) {\n        for (int x= -2; x <= 2; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = mb + vec2(float(x),float(y));\n            \n            vec2 point = random2(i_st + neighbor);\n            \n            point = 0.5 + 0.5*sin(0.5*iTime + 6.2831*point);\n            \n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = dot(0.5*(mr+diff), normalize(diff-mr));\n\n            // Keep the closer distance\n            if(dist < m_dist) {\n                m_dist = dist;\n                nb = point;\n                nr = 0.5*(diff-mr);\n            }\n            \n        }\n    }\n    \n    \n    float n_dist = m_dist/1.0;\n    \n    float c_id = random(i_st + mb);\n    \n    float th = 0.35*0.5*(sin(iTime + 101.0*c_id)+1.0);\n    \n    float height = step(th, n_dist)*(n_dist-th)*(length(nr)-th);\n    vec3 point = vec3(uv.xy, height);\n    vec3 normal = normalize(vec3(step(th, n_dist)*nr, 1.0));\n    \n    vec3 light = vec3(-0.6, 0.6, 2.5);\n    \n    vec3 diff = light-point;\n    float l_intensity = 4.75/pow(length(diff), 2.0);\n    \n    \n    float t1 = l_intensity*clamp(0.0, 1.0, dot(normalize(diff), normal));\n    \n    vec3 bg = vec3(0.83, 0.46, 0.38);\n    vec3 c1 = vec3(0.22, 0.36, 0.94);\n    \n    vec3 col = 1.5*mix(t1*c1, (1.0-t1)*bg, 1.0-t1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 96], [98, 98, 122, 122, 215], [217, 217, 274, 324, 2788]]}
{"id": "tlSGWy", "name": "Julia sets test - 19/06/2019", "author": "clepirelli", "description": "Simple julia sets test\n\nMouse controlled sets can be enabled in the top of the code\n\n", "tags": ["fractal", "julia"], "likes": 1, "viewed": 296, "published": "Public API", "date": "1560900956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment this to enable mouse controlled set picking \n//#define MOUSE_CONTROLLED\n\nconst int MAX_ITER = 80;\n\nvec3 BASE_COLOR = vec3(205.0,100.0, 128.0) / 255.0;\n\n\n\nstruct complexNumber\n{\n    float real;\n    float imaginary;\n};\n\ncomplexNumber multiplyComplex(complexNumber a, complexNumber b)\n{\n\t//(x + yi) * (u + vi) = (xu - yv) + (xv + yu)i\n    \n    return complexNumber\n        (\n        \ta.real*b.real - a.imaginary*b.imaginary,\n            a.real*b.imaginary + b.real*a.imaginary\n        );\n}\n\ncomplexNumber toComplex(vec2 a)\n{\n\treturn complexNumber(a.x, a.y);\n}\n\ncomplexNumber addComplex(complexNumber a, complexNumber b)\n{\n\treturn complexNumber(a.real + b.real, a.imaginary + b.imaginary);\n}\n\nfloat modulusComplex(complexNumber a)\n{\n\treturn sqrt(a.real*a.real + a.imaginary*a.imaginary);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nconst float Epsilon = 1e-10;\n \nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n\treturn vec3(H, C, Q.x);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + Epsilon);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n\tfloat R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), .0, 1.);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 3.0;\n    #ifdef MOUSE_CONTROLLED\n\tcomplexNumber C = toComplex((iMouse.xy / iResolution.xy - vec2(.5))*3.0);\n\t#else\n    complexNumber C = toComplex(vec2(cos(iTime), sin(iTime))*.5);\n    #endif\n    \n    complexNumber Z = toComplex(uv);\n    int itn = 0;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        Z =  addComplex(multiplyComplex(Z,Z), C);\n        \n        if(modulusComplex(Z) >= 2.0) \n        {\n        \titn = i;\n            break;\n        }\n    }\n    \n    float itRatio = float(itn) / float(MAX_ITER);\n    \n    vec3 col = BASE_COLOR;\n    col = RGBtoHSV(col);\n    col.x *= itRatio;\n    col = HSVtoRGB(col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 230, 295, 343, 498], [500, 500, 533, 533, 568], [570, 570, 630, 630, 699], [701, 701, 740, 740, 797], [799, 891, 919, 972, 1253], [1255, 1316, 1344, 1344, 1451], [1453, 1514, 1541, 1541, 1690], [1692, 1753, 1781, 1781, 1861], [1864, 1864, 1921, 1921, 2677]]}
{"id": "tlSGzc", "name": "Apollonian--modifcado v3", "author": "jorge2017a1", "description": "Apollonian,fractal", "tags": ["fractal", "apollonian"], "likes": 1, "viewed": 61, "published": "Public", "date": "1560474938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu..........y modificado por Jorge flores///---13/jun/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATION 8\n#define tt iTime\n#define time (iTime*0.5)\n\nvec4 orb;\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        float r2 = dot(p,p);\n        \n        \n        orb = min( orb, vec4(abs(p-sin(p)*2.0),r2) );\n        float k =2.0/ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n    \n    \n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\n\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n\n    float d0=apollonian(p*0.41)*5.;;\n    float d1=abs(p.y-0.02);\n    float d3 = box(q+vec3(0.,-2.,0.), 2.9*vec3(3.,2.,2.3));\n    float d = max(d0, d3);\n    d=min(d,d1);\n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n    const vec2 g = vec2(0.001, 0.002);\n    \n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\n                          map(p + e.yyx+g.yyx)-map(p - e.yyx-g.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    \n    vec3 lookat = vec3(time, 1.5, 0.);\n    \n    \n\tvec3 ro = 1.4*vec3(-1., 1.5,-4.5);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-12., 2.0, -7.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.2, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.1, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.10,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.4,0.2,0.5), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.1,1.,0.2)));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 64.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.005, 32.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(5.,5.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(2000.0*exp(-0.74*t),1.0);\n\n     }\n    col=tonemap(col);\n    //col=pow(col,vec3(1.3,1.,1.));\n    \n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    \n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSGzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 239, 265, 265, 572], [574, 574, 601, 601, 700], [706, 706, 725, 725, 925], [927, 927, 952, 952, 1213], [1215, 1215, 1258, 1258, 1512], [1514, 1514, 1579, 1579, 1842], [1844, 1844, 1866, 1866, 2052], [2054, 2054, 2111, 2111, 3891]]}
{"id": "tlSGzG", "name": "Arc (circle segment) - 2D SDF", "author": "vegardno", "description": "Exact arc (circle segment) SDF.", "tags": ["2d", "sdf", "circle", "segment", "arc", "exact"], "likes": 10, "viewed": 707, "published": "Public", "date": "1559943251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat sdArc (in vec2 p, in float a0, in float a1, in float r )\n{\n    float a = mod(atan(p.y, p.x), radians(360.));\n\n    float ap = a - a0;\n    if (ap < 0.)\n        ap += radians(360.);\n    float a1p = a1 - a0;\n    if (a1p < 0.)\n        a1p += radians(360.);\n\n    // is a outside [a0, a1]?\n    // https://math.stackexchange.com/questions/1044905/simple-angle-between-two-angles-of-circle\n    if (ap >= a1p) {\n        \t// clamp angle to [a0, a1] by finding the closer one of the two\n        \t// https://gamedev.stackexchange.com/questions/4467/comparing-angles-and-working-out-the-difference\n            float da0 = abs(abs(a0 - a) - radians(180.)); \n            float da1 = abs(abs(a1 - a) - radians(180.)); \n            if (da0 > da1)\n                a = a0;\n            else\n                a = a1;\n    }\n\n    vec2 q = vec2(r * cos(a), r * sin(a));\n    return length(q - p); \n}\n\nfloat sdArc2 (in vec2 p, in float a0, in float a1, in float r )\n{\n    float a = mod(atan(p.y, p.x), radians(360.));\n\n    float ap = a - a0;\n    if (ap < 0.)\n        ap += radians(360.);\n    float a1p = a1 - a0;\n    if (a1p < 0.)\n        a1p += radians(360.);\n\n    // is a outside [a0, a1]?\n    // https://math.stackexchange.com/questions/1044905/simple-angle-between-two-angles-of-circle\n    if (ap >= a1p) {\n        // snap to the closest of the two endpoints\n        vec2 q0 = vec2(r * cos(a0), r * sin(a0));\n        vec2 q1 = vec2(r * cos(a1), r * sin(a1));\n        return min(length(p - q0), length(p - q1));\n    }\n\n    return abs(length(p) - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat a0 = mod(1. * iTime, radians(360.));\n    float a1 = mod(3. * iTime, radians(360.));\n\n\tfloat d = sdArc2( p, a0, a1, .5 );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSGzG.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1078, 1142, 1142, 1956], [1958, 1958, 2023, 2023, 2610], [2612, 2612, 2669, 2669, 3067]]}
{"id": "tslGDr", "name": "Ryan Raymarching", "author": "rmccampbell7", "description": "raymarching demo", "tags": ["raymarching"], "likes": 1, "viewed": 75, "published": "Public", "date": "1559835388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415927\n\n#define AA 2\n\n#define clamp01(x) clamp(x, 0., 1.)\n\nstruct DistMeta {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n};\n\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return dot(pos, norm) - d;\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistMeta opUnion(DistMeta a, DistMeta b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0:\n        return Material(vec3(.55), vec3(.8), 35.);\n    case 1:\n        return Material(vec3(1, 0, 0)*.9, vec3(.8), 20.);\n    case 2:\n        return Material(vec3(0, 1, 0)*.9, vec3(.8), 20.);\n    case 3:\n        return Material(vec3(0, 0, 1)*.9, vec3(.8), 20.);\n    case 4:\n        return Material(vec3(.4, 0, 1), vec3(.8), 15.);\n    default:\n        return Material(vec3(.25), vec3(0), 0.);\n    }\n}\n\n\nDistMeta map(vec3 pos) {\n    DistMeta res = DistMeta(sdPlane(pos, vec3(0,1,0), -6.), 0);\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(0,0,0), 5.), 1));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(10,0,-2), 4.), 2));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(-10,3,-2), 4.), 3));\n    res = opUnion(res, DistMeta(sdBox(pos - vec3(-8,-3,3), vec3(2)) - .4, 4));\n    return res;\n}\n\n\nDistMeta castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistMeta res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistMeta(t, matId);\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n    \n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float diffuse = clamp01(dot(normal, light1));\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess);\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp01(dot(normal, light2));\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);\n\n    float total = diffuse + ambient;\n    vec3 col = clamp01(total)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n    return clamp01(col);\n}\n\n\nvec3 render(vec3 origin, vec3 dir) {\n    vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    DistMeta res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy == vec2(0) ?\n        vec2(0) : (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n\n    float r = 30.;\n    float theta = 2.*PI*(iTime/10. + mouse.x*.5 + .25);\n    float phi = -mouse.y*PI/2.;\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi), r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 0, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float fov = 45.0;\n    float screenDist = 1. / tan(fov/2.*PI/180.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(AA);\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            col += render(cameraPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 257, 257, 290], [292, 292, 332, 332, 367], [369, 369, 405, 405, 454], [457, 457, 490, 490, 514], [516, 516, 553, 553, 577], [579, 579, 615, 615, 640], [642, 642, 684, 684, 756], [759, 759, 792, 792, 1224], [1227, 1227, 1251, 1251, 1627], [1630, 1630, 1671, 1671, 2049], [2052, 2052, 2079, 2079, 2330], [2333, 2333, 2391, 2391, 3072], [3075, 3075, 3111, 3111, 3305], [3308, 3308, 3359, 3359, 3539], [3542, 3542, 3599, 3599, 4522]]}
{"id": "tt23Wd", "name": "å¤§é¾ç« - Quicky#004", "author": "totetmatt", "description": "Quicky#004", "tags": ["2d", "quick"], "likes": 1, "viewed": 270, "published": "Public API", "date": "1561634510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nmat2 rot(float u) {\n    return mat2(cos(u),sin(u),-sin(u),cos(u));\n}\n\nfloat HexDist(vec2 p) {\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    \n    c = max(c, p.x);\n    return c;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    uv *= rot(time/5.);\n   vec2 uvv = uv;\n  uv = sin(uv*5.);\n  vec3 color = clamp(step(0.5+sin(uvv.x*2.+uvv.y*1.5+6.*uv.y+time*10.)/10. ,vec3(HexDist(uv))),0.,1.);\n  color.g = 0.;\n  color.b = 0.;\n    fragColor = vec4(\n        color,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt23Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 88], [90, 90, 113, 113, 224], [226, 226, 283, 283, 598]]}
{"id": "tt23Wh", "name": "[twitch] Grid & box", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nIt uses analytical raytracing to find intersection with 2 boxes and a plane.\nBy bouncing rays you can get rough global illumination and depth of field by jittering the starting ray.", "tags": ["raytracing", "gi", "dof"], "likes": 14, "viewed": 306, "published": "Public", "date": "1559398553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/GridBox.glsl\n\nThe shader uses analytical raytracing to find intersection with 2 boxes and a plane.\nBy bouncing rays you can get rough global illumination and depth of field by jittering the starting ray.\n*/\n\nfloat time = 0.0;\nfloat pi = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*685.655)*427.511);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 8.0));\n}\n\n\nfloat val = 0.0;\n//float val2 = max(abs(fract(time*0.1-0.5)-0.5)*4 - 1.0,0.0);\nfloat val2 = 0.0;\n\nfloat plane(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 planenorm, float dist) {\n  \n  float dn = dot(r,planenorm);\n  float dplane = (dist-dot(s,planenorm))/dn;\n  if(dplane<d && dplane>0.0) {\n    vec3 p = s + dplane * r;\n    vec3 hole = vec3(4);\n    p = abs(fract(p/hole+0.5)-.5);\n    if(max(p.x,max(p.y,p.z))>0.44) {\n      d = dplane;\n      n = planenorm * sign(dn);\n      emi = vec3(0.2,0.9,0.5) * 5.0 * val2;\n    }\n  }\n  \n  return d;\n}\n\nvoid backbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {\n  \n  vec3 invd = 1.0/r;\n  \n  vec3 t0 = ((pos-size) - s) * invd;\n  vec3 t1 = ((pos+size) - s) * invd;\n  vec3 mi = min(t0, t1);\n  vec3 ma = max(t0, t1);\n  \n  float front = min(min(ma.x,ma.y),ma.z);\n  float back = max(max(mi.x,mi.y),mi.z);\n  \n  if(front<d && front > 0.0 && front>back) {\n    d = front;\n    n = (1.0-clamp((ma-front)*1000.0,0.0,1.0)) * sign(t1-t0);\n    \n    vec3 p = s + d * r;\n    //vec2 diff=smoothstep(0.9,1.0, sin(p.zx + 10 * time * vec2(0.7,1.0)));\n    \n    //emi = vec3(dot(diff,vec2(1.0))) * step(p.y, -4.9) * 4;\n    \n    emi = vec3(0.4,0.5,0.9) * step(p.y, -4.9) * 4.0 * val * (1.0-val2);\n    emi += vec3(0.8,0.4,0.3) * step(p.z, -9.9) * 4.0 * (1.0-val) * (1.0-val2);\n  }\n}\n\nvoid frontbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {\n  \n  vec3 invd = 1.0/r;\n  \n  vec3 t0 = ((pos-size) - s) * invd;\n  vec3 t1 = ((pos+size) - s) * invd;\n  vec3 mi = min(t0, t1);\n  vec3 ma = max(t0, t1);\n  \n  float front = min(min(ma.x,ma.y),ma.z);\n  float back = max(max(mi.x,mi.y),mi.z);\n  \n  if(back<d && back > 0.0 && back<front) {\n    d = back;\n    emi = vec3(0);\n    n = (1.0-clamp(-(mi-back)*10000.0,0.0,1.0)) * sign(t1-t0);\n  }\n}\n\nvoid raytrace(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi) {\n  \n  backbox(s,d,r,n,emi, vec3(0), vec3(10,5,10));\n  \n  frontbox(s,d,r,n,emi, vec3(7,3,0), vec3(5,0.5,4));\n  \n  plane(s,d,r,n,emi, normalize(vec3(curve(time+3.2,0.8),1.0,curve(time+7.8,0.8))), 2.0 + (curve(time,0.8)-.5)*10.0);\n}\n\nvec3 hemispherenormal(vec2 rng) {\n  \n  float radius = sqrt(rng.x);\n  float angle = 2.0 * pi * rng.y;\n  \n  return vec3(radius * cos(angle), sqrt(1.0 - rng.x), radius * sin(angle));\n}\n\nvec3 hemi(float rn, int i) {\n  return hemispherenormal(fract(rn * vec2(7,17) + vec2(float(i)/7.0,floor(float(i/7))/7.0)));\n}\n\nvec2 rnd(vec2 uv) {\n  return fract(sin(uv * vec2(754.355) + uv.yx * vec2(845.312)) * vec2(387.655));  \n}\n\nfloat rnd1(vec2 uv) {\n  return fract(dot(sin(uv * vec2(754.355) + uv.yx * vec2(845.312)),vec2(387.655)));  \n}\n\nvoid cam(inout vec3 p) {\n  float t=time*0.3 + curve(time +32.0, 2.8)*4.0;\n  p.yz *= rot(sin(t*.7)*.3 + 0.4);\n  p.xz *= rot(t);\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  time = iTime * 0.2;\n  val = max(abs(fract(time*0.1)-0.5)*4.0 - 1.0,0.0);\n  val2 = max(curve(time, 1.3)*3.0-2.0,0.0);\n\n\n  vec3 s=vec3(0,0,-12);\n  vec3 t=vec3(0,0,0);\n  \n  cam(s);\n  \n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  //vec3 r=normalize(vec3(-uv, 1));\n  float fov = 1.0 + curve(time+11.0, 0.7)*0.4;\n  vec3 r = normalize(uv.x * cx + uv.y * cy + fov * cz);\n  \n  \n  vec3 col = vec3(0);\n  \n  float focus = 12.0 + curve(time, 0.7)*4.0;\n  \n  float ini = rnd1(uv);\n    \n  float dither=fract(time);\n    \n  const int steps=36;\n  for(int j=0; j<steps; ++j) {\n    float prod = 1.0;\n    vec2 randdof = vec2(j%6,j/6)+rnd(uv - vec2(3.7));\n    //randdof = vec2(cos(randdof.x), sin(randdof.x))*randdof.y;\n    vec3 dof = randdof.x * cx + randdof.y * cy;\n    dof *= 0.1;\n    vec3 vs = s + dof;\n    vec3 vr = normalize(r - dof / focus);\n        \n    for(int i=0; i<3; ++i) {\n      float d = 10000.0;\n      vec3 n = vec3(0,1,0);\n      vec3 emi = vec3(0);\n      raytrace(vs, d, vr, n, emi);\n      vs = vs + vr * d - n * 0.001;\n      \n      vec2 rand = rnd(uv + vec2(float(j)*2.1,float(i)*3.1) + dither);\n      vr = hemispherenormal(rand);\n      //vr = hemi(ini, j);\n      vr *= -sign(dot(vr,n));\n      \n      col += emi * prod;\n      prod *= 0.6;\n      \n    }\n  }\n  col /= float(steps);\n    \n  /*\n  if(d<9000.0) {\n    vec3 p = s + d * r;\n    col += fract(p/1.0 + 0.1);\n  }\n  */\n  \n  //col = n*0.5+0.5;\n  \n  \n  /*\n  float d = plane(s,r, normalize(vec3(0,1,0)), 10);\n  if(d>0.0) {\n    vec3 p=s + d * r;\n    \n  }\n  */\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt23Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 417, 436, 436, 505], [507, 507, 527, 527, 569], [571, 571, 602, 602, 707], [727, 808, 910, 910, 1267], [1269, 1269, 1365, 1365, 2060], [2062, 2062, 2159, 2159, 2544], [2546, 2546, 2622, 2622, 2851], [2853, 2853, 2886, 2886, 3034], [3036, 3036, 3064, 3064, 3160], [3162, 3162, 3181, 3181, 3266], [3268, 3268, 3289, 3289, 3377], [3379, 3379, 3403, 3403, 3510], [3513, 3513, 3570, 3570, 5323]]}
{"id": "tt23Ww", "name": "Rotation loop", "author": "avin", "description": "Remake of Dave's sketch\nhttps://twitter.com/beesandbombs/status/1136416601165746176", "tags": ["dave"], "likes": 10, "viewed": 479, "published": "Public API", "date": "1559849232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLACK_COL vec3(32,43,51)/255.\n#define WHITE_COL vec3(235,241,245)/255.\n\n#define PI2 6.2831852\n#define PI 3.1415926\n#define PI_2 1.5707963\n#define PI_4 0.78539815\n\n#define L 1./6.\n\n#define SQ_38 0.6164414002968976\n#define SQ_64 0.8\n\n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\nmat2 rot (float a){\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nfloat triangle(vec2 uv, vec2 pos, float size){    \n    uv/=size;\n    uv+=vec2(.25,.25) - pos;\n    \n    float m = SS(0., uv.x) * SS(0., uv.y);    \n    uv *= rot(-PI_2);\n    uv -= vec2(.5, 0.);\n    m *= SS(uv.x, uv.y);\n    \n    return m;        \n}\n\nfloat drawPhase1(float t, vec2 uv){\n    float m = 0.;\n    \n    for(float i=0.;i<8.;i++){\n        vec2 iuv = uv;\n        iuv *= rot(PI2*(i+t)/8.);\n        iuv-=vec2(0., (L+sqrt(.5)*L));\n        iuv *= rot(PI_4 - PI_2*(.5*t + 1.5*t*t - t*t*t));\n        float s = L*.5;\n    \tm += SS(abs(iuv.x), s) * SS(abs(iuv.y), s);\n    }\n    \n    return clamp(m, 0., 1.);\n}\n\nfloat drawPhase2(float t, vec2 uv){\n    \n    \n    float s = L*.5*(2.+sqrt(2.));\n    float m = step(abs(uv.x), s) * step(abs(uv.y), s);\n    \n    uv*=rot(PI_4);\n    m += step(abs(uv.x), s) * step(abs(uv.y), s);\n    \n    m = min(m, 1.);\n    \n    uv*=rot(-PI_4);    \n    \n    for(float i=0.;i<4.;i++){\n        vec2 iuv = uv;\n        \n    \tiuv *= rot(PI_2*i + PI_4*t);\n        m -= triangle(iuv, vec2(L*SQ_38,L*SQ_38), SQ_64);\n    }\n    \n    return clamp(m, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.5;\n    \n    float phaseV = fract(t);\n    \n    float m;\n    if(phaseV < .5){\n    \tm = drawPhase1(phaseV*2., uv);        \n    } else {        \n        m = drawPhase2(phaseV*2.-1., uv);\n    }       \n    vec3 col = mix(WHITE_COL, BLACK_COL, m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt23Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 346, 346, 422], [424, 424, 470, 470, 669], [671, 671, 706, 706, 1028], [1030, 1030, 1065, 1065, 1493], [1495, 1495, 1552, 1552, 1922]]}
{"id": "tt2GRt", "name": "sphere of destiny", "author": "shigawire", "description": "sphere", "tags": ["sphere"], "likes": 1, "viewed": 73, "published": "Public", "date": "1560784778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Q(vec3 axis, float ang) {\n    float halfang = ang/2.0;\n    return normalize(vec4(axis*sin(halfang),cos(halfang)));\n}\n\nvec3 rotq(vec3 pt, vec4 q) {\n\treturn pt+2.0*cross(q.xyz, cross(q.xyz,pt) + q.w*pt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 origin = vec2(cos(iTime),sin(iTime));\n    // A sphere is the points where\n    // x**2 + y**2 + z**2 - r**2 = 0\n    // r=1 .'. r**2=1. Calculate max(z) for current x,y on the sphere\n    float z = clamp( sqrt(1.0-((uv.x*uv.x)+(uv.y*uv.y))), 0.0,1.0);\n    \n    // 3d rot\n    vec3 pos = rotq(vec3(uv,z), Q(vec3(2.0,1.0,0.0),sin(iTime)/2.0));\n    uv = pos.xy; z=pos.z;\n    \n    // Time varying pixel color\n\t//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col=vec3(0.8);\n    col *= z;\n\n    // Output to screen\n    fragColor = vec4(clamp(col,0.0,1.0) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2GRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 121], [123, 123, 151, 151, 208], [210, 210, 267, 317, 984]]}
{"id": "tt2Gz3", "name": "Spiraling Tree", "author": "vox", "description": "Spiraling Tree", "tags": ["tree", "spiraling"], "likes": 2, "viewed": 379, "published": "Public API", "date": "1560568584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__)/GR)/E+1.0)*iTime/PI)\n#define stair floor\n#define jag fract\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(time)*.1);\n    square = scale(square, vec2(3./4.));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(1.0, -1.0));\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\n\n\nfloat square(vec2 uv, float iteration)\n{\n    uv = uv*2.-1.;\n    return 1.-smoothstep(0.0, 0.5, abs(saw(uv.y+time/PI)-uv.x));\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r;\n    return vec2(saw(r+time/E),\n                saw(theta+time/GR));\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    \n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+sin(time/GR/E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n    uv.xy = spiral(uv.xy*scale);\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = tree(uv.xy);\n        map += square(uv.xy, iteration);\n    }\n    \n    fragColor.rgb = phase(map)*\n        \t\t\tclamp(map, 0.0, 1.0);\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2Gz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 225, 225, 253], [255, 255, 275, 275, 380], [381, 381, 399, 399, 438], [440, 440, 458, 458, 507], [508, 678, 753, 753, 1286], [1289, 1289, 1322, 1322, 1354], [1355, 1355, 1414, 1414, 1522], [1530, 1530, 1589, 1589, 1632], [1633, 1633, 1692, 1692, 1749], [1750, 1750, 1809, 1809, 2125], [2126, 2126, 2177, 2177, 2357], [2359, 2359, 2406, 2406, 2586], [2588, 2588, 2608, 2608, 3463], [3467, 3467, 3507, 3507, 3593], [3596, 3596, 3618, 3618, 3766], [3768, 3768, 3791, 3791, 3900], [3902, 3902, 3959, 3959, 4623]]}
{"id": "ttB3Dc", "name": "cool S", "author": "MikazukiLaisa", "description": "cool s!", "tags": ["raymarching"], "likes": 0, "viewed": 67, "published": "Public", "date": "1561353250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a){\n\tfloat c=cos(a), s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p){\n    p.xz = p.xz * rotate(p.y*5.);\n\tvec3 d = abs(p) - .4;\n    return max(max(d.x,d.y),d.z);\n}\n\nfloat sdSphere(vec3 p){\n\t//return length(p) - .3 * sin(iTime) - .3;\n    return length(p) - .45;\n}\n\nfloat distanceFunction(vec3 p){\n    //p.xz = p.xz * rotate(iTime);\n\treturn max(sdBox(p), -sdSphere(p));\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 delta = vec2(0.01, 0.);\n    return normalize(vec3(\n        distanceFunction(p-delta.xyy),\n        distanceFunction(p-delta.yxy),\n        distanceFunction(p-delta.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(0,0,-3.);\n    float screenZ = 5.;\n    vec3 rayDir = normalize(vec3(p, screenZ));\n\tvec3 col = vec3(0.);\n    vec3 lightPos = vec3(0,0.,5.);\n    vec3 lightDir = normalize(vec3(cos(iTime),0.,sin(iTime)));\n    //vec3 lightDir = vec3(-1,-1,1);\n    \n    float depth = 0.0;\n    for(int i=0; i<128;i++){\n        vec3 rayPos = camPos + rayDir * depth;\n        float dist = distanceFunction(rayPos);\n\t        \n        if(dist < 0.000001){\n            float diff = clamp(dot(lightDir, getNormal(rayPos)), 0.1, 1.);\n            col = vec3(1.,1.,.6) * diff;\n            break;\n        }\n        depth += dist;\n\n    }\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttB3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 77], [79, 79, 99, 99, 192], [194, 194, 217, 261, 291], [293, 293, 324, 359, 398], [400, 400, 423, 423, 601], [603, 603, 660, 660, 1402]]}
{"id": "ttB3DV", "name": "Springs of Arbitrary Profile", "author": "blackle", "description": "How to make a spring whose profile is any arbitrary (symmetric) signed distance function.\n\nclick to look around", "tags": ["helix", "spring", "coil"], "likes": 26, "viewed": 485, "published": "Public", "date": "1561139611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//How to make a spring whose profile is any arbitrary signed distance function.\n//This is not particularly exact, but the code can be quite small when you sizecode it\n//also it requires that the profile be symmetric along the x and y axes.\n\n//// PROFILES ////\nfloat profileSphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat profileLine(vec2 p, vec2 dim) {\n    return distance(p, vec2(clamp(p.x, -dim.x/2.0, dim.x/2.0), 0.0))-dim.y;\n}\n\n//the rest of these are from http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat profileSquare(vec2 p, vec2 dim) {\n    vec2 d = abs(p)-dim;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat profileRhombus(vec2 p, vec2 dim) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,dim)+ndot(dim,dim))/dot(dim,dim),-1.0,1.0);\n    float d = length( q - 0.5*dim*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*dim.y + q.y*dim.x - dim.x*dim.y );\n}\n\nfloat profileCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat profileHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n//// SPRING DISTANCE FUNCTION ////\nvec3 closestPointOnCylinder(vec3 p, vec2 dim) {\n    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\n\nfloat profileForIndex(vec2 p, int profile) {\n    float dist;\n    if (profile == 0) {\n        dist = profileSphere(p, 0.12);\n    } else if (profile == 1) {\n        dist = profileLine(p, vec2(0.4, 0.04));\n    } else if (profile == 2) {\n        dist = profileSquare(p, vec2(0.05,0.1))-0.02;\n    } else if (profile == 3) {\n        dist = profileRhombus(p, vec2(0.1,0.07))-0.03;\n    } else if (profile == 4) {\n        dist = profileCross(p, vec2(0.15,0.05), 0.0)-0.03;\n    } else {\n        dist = profileHexagon(p, 0.1)-0.03;\n    }\n    return dist;\n}\n\nfloat spring(vec3 p, int profile) {\n    float radius = 0.5;\n    float height = 3.0 + sin(iTime);\n    float coils = 5.0/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    return profileForIndex(springCoords, profile) * ( max(radius/2.0-abs(length(p.xy)-radius), 0.0)*0.3 + 0.7);\n}\n\n//// ARRAY OF SPRINGS ////\nfloat scene(vec3 p) {\n    p -= vec3(0.0,4.0,0.0);\n    float dist = 10000.0;\n    for (int i = 0; i < 6; i++) {\n        dist = min(dist, spring(p, i));\n        dist = min(dist, profileSphere(vec2(p.x, 0.1+profileForIndex((p.yz+vec2(0.0,2.8))*0.4, i)), 0.1));\n        p += vec3(0.0,1.5,0.0);\n    }\n        \n    return dist;\n}\n\nvec3 sceneGrad(vec3 p) {\n    vec2 epsi = vec2(0.001,0.0);\n    float d1 = scene(p);\n    return normalize(vec3(\n        scene(p+epsi.xyy) - d1,\n        scene(p+epsi.yxy) - d1,\n        scene(p+epsi.yyx) - d1\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    vec2 mouse = iMouse.xy/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 origin = vec3(16.0,0.0,0.0);\n    vec3 dir = -normalize(origin + vec3(0.0,uv)*3.0);\n\torigin+=vec3(0.0,0.0,-0.4);\n    \n    mat3 rot_x = mat3( cos(mouse.x), sin(mouse.x), 0.0,\n                      -sin(mouse.x), cos(mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(mouse.y), 0.0, sin(mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(mouse.y), 0.0, cos(mouse.y));\n    \n    if (iMouse.z > 0.0) {\n\t    origin*=rot_y*rot_x;\n    \tdir*=rot_y*rot_x;\n    }\n    \n    vec3 point = origin;\n    bool interesected = false;\n    for (int i = 0; i < 80; i++) {\n        float dist = scene(point);\n        if (dist > 20.0) break;\n        if (abs(dist) < 0.001) {\n            interesected = true;\n            break;\n        }\n        point += dir * dist;\n    }\n\n    float col = 0.0;\n    if (interesected) {\n        vec3 grad = sceneGrad(point);\n        col = abs(dot(dir,grad));\n    }\n\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttB3DV.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[435, 454, 492, 492, 520], [522, 522, 559, 559, 637], [639, 739, 778, 778, 864], [866, 866, 895, 895, 923], [924, 924, 964, 964, 1179], [1181, 1181, 1235, 1235, 1420], [1422, 1422, 1469, 1469, 1659], [1661, 1696, 1743, 1743, 1820], [1822, 1822, 1866, 1866, 2367], [2369, 2369, 2404, 2404, 2956], [2958, 2985, 3006, 3006, 3307], [3309, 3309, 3333, 3333, 3523], [3525, 3525, 3582, 3582, 4718]]}
{"id": "ttBGDd", "name": "Stars over Lake (remix)", "author": "mosaic", "description": "Stars from https://www.shadertoy.com/view/XlfGRj\nMountains & trees from https://www.shadertoy.com/view/4lKcDD\nClick and drag to recompose starfield.\nI'd like to add a better shimmer to the water, but I'm not sure how to do that yet", "tags": ["2d"], "likes": 12, "viewed": 345, "published": "Public", "date": "1561524003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Contains code from \"Star Nest\" by Pablo Roman Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.005 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\n\n#define HASHSCALE1 443.8975\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float t = f * f * (3.0 - 2.0 * f);\n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\nfloat fbm(float x, float persistence, int octaves) {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    for (int i = 0; i < octaves; ++i) {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return (total / maxValue);\n}\n\nfloat msine2(vec2 uv) {\n    return (fbm(uv.x / 10., 0.25, 4)*20. + 0.5);\n}\n\n\nfloat xRandom(float x) {\n    return mod(x * 7241.6465 + 2130.465521, 64.984131);\n}\n\n\nfloat shape2(vec2 uv, int N, float radius_in, float radius_out, float zoom3) {\n    float color = 0.0;\n    float d = 0.0;\n    float a = atan(uv.x, uv.y) + PI;\n    float rx = TWO_PI / float(N);\n    d = cos(floor(.5 + a / rx) * rx - a) * length(uv);\n    color = smoothstep(.44, .44 + (2. + 1.2 * zoom3) / iResolution.y, abs(d - radius_in) + radius_out);\n    return (1. - color);\n}\n\nfloat trees2(vec2 uv) {\n    float zoom1 = 10.;\n    uv.x += .2;\n    uv *= zoom1;\n    uv.y+=1.0;\n    uv.y=-uv.y;\n    vec2 tuvy = vec2(0., 0.2 * msine2(vec2(floor(uv.x / 0.38), uv.y)));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (55.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1.5, 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = -1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += -0.25 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape2(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape2(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape2(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\n\nfloat msine(vec2 uv) {\n    float heightA = 0.025;\n    float heightB = 0.025;\n    float heightC = 0.013; //+0.071*sin(iTime/105.); //xD\n    uv.y = sin((uv.x + (1.))*5.0) * heightA;\n    uv.y = uv.y + sin((uv.x + (0. / 5.))*3.0) * heightB;\n    uv.y = uv.y + sin((uv.x + (1.))*2.0) * heightC;\n    return uv.y;\n}\n\nfloat layer_bghills(vec2 uv) {\n      //uv.y += 1.2;\n //uv.y-=0.5;\n     uv.x += 0.;\n    float d = smoothstep(5.5 + 20. / iResolution.y, 5.5, msine2(uv / 0.38 - 0.038)*40. + uv.y * 40. + 010.6);\n    d = smoothstep(-0.1555 + 8. / iResolution.y, -0.1555, .2 * msine2((uv * 10.) / 0.38 - 0.038) + uv.y * 11. + 0.86);\n    return d- trees2(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\t//uv.y*=iResolution.y/iResolution.x;\n    \n    uv.y=abs(uv.y);\n    \n    vec2 res = iResolution.xy / iResolution.y;\n     uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n    uv.y+=0.09;\n    if (uv.y<0.) uv.x +=0.01*sin(100.*uv.y+iTime);//line from hamtarodeluxe\n    uv.y=-abs(uv.y);\n    \n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x/20.;\n\tfloat a2=.8+iMouse.y/iResolution.y/20.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=layer_bghills(uv)*mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n   //fragColor=vec4(trees2(uv));\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBGDd.jpg", "access": "shaders20k", "license": "mit", "functions": [[59, 439, 462, 462, 582], [584, 584, 623, 623, 653], [655, 655, 677, 677, 830], [831, 831, 883, 883, 1207], [1209, 1209, 1232, 1232, 1283], [1286, 1286, 1310, 1310, 1368], [1371, 1371, 1449, 1449, 1748], [1750, 1750, 1773, 1773, 2825], [2828, 2828, 2850, 2850, 3135], [3137, 3137, 3167, 3202, 3476], [3478, 3478, 3535, 3563, 5091]]}
{"id": "ttj3Rd", "name": "Simple Squircle", "author": "badjano", "description": "simple squircle", "tags": ["squircle"], "likes": 1, "viewed": 158, "published": "Public", "date": "1560810718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define grad(x) length(vec2(dFdx(x),dFdy(x)))\n#define PI 3.14159265359\n\nfloat squircle(in vec2 pos, float n) {\n    vec2 tmp = pow(abs(pos),vec2(n));\n    return 1.-dot(vec2(1.0, 1.0), tmp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = 1./iResolution.xy;\n    vec2 uv = (fragCoord*scale - vec2(0.5));\n    uv *= vec2(iResolution.x/iResolution.y,1.) * 3.;\n\n    float ct = cos(iTime);\n    float st = sin(iTime);\n    \n    mat2 rot = mat2(ct, st, -st, ct);\n    \n    vec2 uv2 = rot * uv;\n    float n = mix(0.1,10.,sin(iTime*2. + PI*0.5) * .5 + .5);\n    float s = squircle(uv2,n);\n    float a;\n    bool b = (iMouse.w > 0.5 && iMouse.x > fragCoord.x) ||\n        (iMouse.w < 0.5 && fragCoord.x < iResolution.x*0.5);\n    if ( b ){\n    \ta = s;\n    } else {\n        a = abs(s)/grad(s);\n    }\n    fragColor = vec4(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttj3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 190], [192, 192, 249, 249, 836]]}
{"id": "ttj3Ry", "name": "HypnoSphere", "author": "xjorma", "description": "Inspired by https://www.instagram.com/p/Bxm4B4ZlS5h/ by monochromeandminimal", "tags": ["sphere", "hypnotic", "minimalist"], "likes": 9, "viewed": 503, "published": "Public API", "date": "1560218582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n//#define CUBE\n\n\nfloat sinnoise(vec3 p,float t)\n{\n    \n     for (int i=0; i<2; i++)\n    \tp += cos( p.yzx*3. + vec3(t,1.6,1.6)) / 3.,\n        p += sin( p.yzx + t + vec3(1.6,t,1.6)) / 2.,\n        p *= 1.3;\n    \n    return sin(length(p));\n}\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 map(in vec3 p)\n{\n#ifndef CUBE\n    float d = sdSphere(p,1.);\n#else\n    float d = sdBox(p,vec3(0.75));\n#endif\n    float n = sinnoise(p*2., iTime / 6. + 8.);\n\tfloat s = max(d,n/8.);\n    return minVecSelect(vec2(s, n),vec2(p.y + 1.1, 0));\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.02;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy*h).x + \n                      k.yyx * map(p + k.yyx*h).x + \n                      k.yxy * map(p + k.yxy*h).x + \n                      k.xxx * map(p + k.xxx*h).x );\n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 1.0;\n    float d;\n    float noise = 0.;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        vec2\th = map(p);\n        t += h.x*0.7;\n        d = dot(t*rd,cd);\n        noise = h.y;\n        if( abs(h.x)<0.0001 || d>dist ) break;\n    }\n\n    vec3 col = vec3(0.5);\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,10.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        vec3 diffcol = vec3(mix(saturate(pow(abs(sin(noise*16.))*1.5,15.)) ,1.,0.3)); \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),20.) * speccol;\n        col+= 0.2 * ambcol;\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],12.);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttj3Ry.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[125, 142, 174, 174, 362], [364, 364, 389, 389, 418], [420, 495, 530, 530, 554], [556, 556, 587, 587, 737], [739, 739, 774, 774, 800], [802, 802, 823, 823, 1043], [1046, 1046, 1071, 1071, 1338], [1341, 1341, 1390, 1390, 2234], [2236, 2236, 2314, 2314, 2386], [2388, 2388, 2430, 2430, 2594], [2596, 2596, 2653, 2653, 3742]]}
{"id": "ttj3W1", "name": "Marching circle", "author": "sgiobairog", "description": "Just messing around to get and idea for how this all works", "tags": ["basic", "shader"], "likes": 2, "viewed": 91, "published": "Public", "date": "1559430138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.xy *= 5.0;\n    /*vec2 center = vec2(\n        iResolution.x * 0.5, iResolution.y * 0.5);*/\n\tvec2 center = vec2(iMouse.x, iMouse.y);\n    // Time varying pixel color\n    float dist = distance(center,fragCoord) / 5.0;\n    float red = 2.0 * sin(iTime - dist);\n    float blue = 2.0 * cos(iMouse.y + dist);\n    float green = 4.0 * tan(iTime - dist);\n    vec3 col = vec3(red,green,blue);\n    vec3 col2 = vec3(0,6,12);\n    //vec3 col2 = 0.5 + 0.5 * tan(iTime + uv.xxy+vec3(0,6,12));\n\n    // Output to screen\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttj3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 682]]}
{"id": "ttjGDG", "name": "Seedling (mouse interactive)", "author": "mosaic", "description": "2d", "tags": ["2d"], "likes": 2, "viewed": 101, "published": "Public", "date": "1561001900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise3( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p ) //iq's\n{\n    float f = 0.0;\n    f += 0.5000*noise3( p ); p = m*p*2.02;\n    f += 0.2500*noise3( p ); p = m*p*2.03;\n    f += 0.1250*noise3( p ); p = m*p*2.01;\n    f += 0.0625*noise3( p );\n    return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set the origin to the middle of the screen (thanks fabrice)\n     vec2 st  = (fragCoord-.5*iResolution.xy) / iResolution.y;\n \t//mirror effect\n    st.x = .8 - abs(st.x);\n    //flip vertically\n    st.y= -st.y;\n    \n    //draw 3 circles \n    float channel1 = distance(st,vec2(0.3,.5))*3.;\n    float channel2 = distance(st,vec2(0.2,.5))*3.;\n    float channel3 =distance(st,vec2(0.5,.5))*3.;\n\n    //combine into a vec3, animate\n    vec3 colour= vec3(channel1,channel2,channel3)-(-iTime)/20.+iMouse.x/2000.;\n    \n    //uncomment line 38 and comment out line 38 to see this without fbm effect\n    //\t\t\t\t\t\t\t\t\t  *iMouse.y/200.\n   colour = fract(colour*1.5+fbm4(st.xy)*12.)/vec3(0.31);\n   //colour = fract(colour*1.5)/vec3(0.31);\n    \n    //this line gives it the green theme\n    colour*=vec3(.5,.1,.5)*2.;\n    //If the green is changed to brown, it can make a nice wood pattern\n      \n    // Output to screen\n    fragColor = 1.-vec4(colour,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 78, 78, 107], [109, 109, 138, 138, 338], [340, 340, 397, 463, 1341]]}
{"id": "ttjGDK", "name": "Escape tunnel", "author": "kasari39", "description": "using ifs and phantom mode", "tags": ["raymarching", "ifs", "phantommode"], "likes": 17, "viewed": 389, "published": "Public", "date": "1561210139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for(int i=0; i<6; i++) {\n        p = abs(p) - 1.0;\n        p.xz *= rot(0.7);\n        p.xy *= rot(0.8);\n    }\n    return box(p, vec3(0.0, 0.9, 0.2));\n}\n\nfloat map(vec3 p) {\n    float c = 8.0;\n\tp.z = mod(p.z, c) - c * 0.5;\n    return ifsBox(p);\n}\n\nvec3 hsv(float h, float s, float v) {\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 cPos = vec3(2.5*sin(0.4*iTime), 0.5*cos(1.3*iTime), -20.0*iTime);\n    vec3 cDir = vec3(0.0, 0.0, -1.0);\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float t = 0.0;\n    float acc = 0.0;\n    for (int i = 0; i < 199; i++){\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos);\n\n    \tdist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(pos.z-60.0*iTime, 50.0) < 8.0) {\n            a *= 5.0;\n        }\n    \tacc += a;\n\n    \tt += dist*0.5;\n        if (t > 100.0) break;\n    }\n\n    vec3 col = hsv(fract(0.06*iTime), 0.6, acc * 0.01);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 106], [108, 108, 135, 135, 194], [196, 196, 218, 218, 373], [375, 375, 394, 394, 467], [469, 469, 506, 506, 582], [584, 584, 641, 641, 1478]]}
{"id": "ttjGRc", "name": "Improved multicolored FBM", "author": "dust", "description": "I made multicolored fbm a while ago (https://www.shadertoy.com/view/XttBRj), but it wasn't amazing so I decided to have another shot. Much happier with this one ^_^.", "tags": ["procedural", "2d", "2d", "fractal", "noise", "noise", "perlinnoise", "fbm", "perlin", "rgb", "recursive", "fbmnoise"], "likes": 3, "viewed": 113, "published": "Public", "date": "1560575853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv));\n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n        \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = offs;//soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Compute fractal noise for a given pixel position\n#define SCALING_FBM\n//#define EXTRA_TRIG_FX\nfloat fbm(vec2 uv)\n{\n    const uint depth = 6u;\n    const vec2 dFreq = vec2(1.01f, 1.02f);\n    const float dAmpl = 1.2f;\n    float srct = iTime + 100.0f;\n    float t = min((srct * (0.075 / log(srct)) + sin(srct * 0.01)), 400.0);\n    vec2 sfreq = vec2(1.01f + (sin(t) * 2.0)); // Starting noise scaling frequency\n    vec2 rfreq = vec2(1.1f); // Starting noise rotational frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        f += ampl * Perlin(uv);//abs(Perlin(uv));\n        float fi = float(i);\n        #ifdef EXTRA_TRIG_FX\n        \tuv += vec2(cos(fi), \n        \t           sin(fi)) * (iTime * 0.25f) * rfreq;\n        #endif\n        //uv += vec2(t);\n        #ifdef SCALING_FBM\n        \tuv += pow(t, dot(sfreq, rfreq) * 0.25);\n            sfreq *= dFreq + vec2(0.1f * float(i));\n        #endif\n        rfreq *= dFreq + vec2(0.1f * float(i));\n        ampl *= dAmpl;\n    }\n    return f;\n}\n\n#define NOISE_MIRR\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    #ifdef NOISE_MIRR\n    \tfloat hAspect = (iResolution.x / iResolution.y) * 0.5f;\n    \tvec2 uv = abs((fragCoord / iResolution.y) - vec2(hAspect, 0.5f)) / cellSize;\n    #else\n    \tvec2 uv = (fragCoord / iResolution.y) / cellSize;\n    #endif\n    //uv += (vec2(0.1) + texture(iChannel1, uv).rr) * 0.1;\n    // Generate per-channel fbm()\n    // fbm(p + fbm(p + fbm(p)))\n    // FBM recursion function from iq through the Book of Shaders:\n    // http://www.iquilezles.org/www/articles/warp/warp.htm\n    // https://thebookofshaders.com/13/\n    float fbm0 = fbm(uv + vec2(\n        \t\t\t fbm(uv + vec2(\n                    \t fbm(uv)))));\n    vec2 uu = uv + vec2(sin(iTime), fbm0);\n    float fbm1 = fbm(uu + vec2(\n        \t\t\t fbm(uu + vec2(\n                    \t fbm(uv)))));\n    vec2 vv = uv + vec2(cos(iTime) * fbm1, fbm1 + fbm0);\n    float fbm2 = fbm(vv + vec2(\n        \t\t\t fbm(vv + vec2(\n                    \t fbm(vec2(fbm0, fbm1))))));\n\tvec3 rgb = vec3(fbm0, fbm1, fbm2);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 122, 144, 144, 653], [655, 696, 717, 717, 859], [861, 928, 951, 982, 2443], [2517, 2541, 2561, 2561, 3510], [3531, 3531, 3586, 3653, 4717]]}
{"id": "ttjGRd", "name": "ray tracing sphere---mod-v3", "author": "jorge2017a1", "description": "ray tracing sphere", "tags": ["ray", "sphere", "tracing"], "likes": 21, "viewed": 552, "published": "Public", "date": "1560804128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\n\nvec3 colorplaneta( vec2 fragCoord )\n{\n    vec2 uv;\n    //Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    //Equalize the aspect ratio\n    ///uv.y /= iResolution.x/iResolution.y;\n    uv=fragCoord;\n    \n    //Zoom out\n    uv *= 5.0;\n    \n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n\n    //Fragment colour\n    return col;\n}\n\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    \n    vec3 tmp3;\n    vec2 tmp2;\n    tmp2=vec2(rd.x*1.0, rd.y*1.0);\n    tmp3=colorplaneta(tmp2);\n    \n    \n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*tmp3 +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    \n    \n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.5, 0.0);\n\tfloat t = sphere(ro, rd, p, 1.25);\n\tvec3 nml = normalize(p - (ro+rd*t));\n    \n    \n\tvec3 bgCol = background(iTime, rd);\n\trd = reflect(rd, nml);\n    \n\tvec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n    \n    \n    \n    \n    \n\tfragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 262], [265, 265, 302, 302, 824], [827, 827, 862, 862, 1311], [1317, 1317, 1374, 1374, 1875]]}
{"id": "ttjGz3", "name": "Morrocan Fish Scale Tile Wave", "author": "Yusef28", "description": "Another cool pattern\nInspired by: https://www.pinterest.de/pin/421157002652020331/", "tags": ["pattern"], "likes": 7, "viewed": 402, "published": "Public", "date": "1560598055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 4.\n#define pi 3.14159265359\n\nfloat rnd(vec2 p)\n{\n return fract(sin(dot(p, vec2(12.9898, 78.233)))*43562.34532);   \n}\n\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n\nfloat circle(vec2 p, float r)\n{\n    float c;\n    float ss = 0.008;\n    c = length(p);\n    c = smoothstep(r-ss, r+ss, c);  \n\treturn c;    \n}\n\nfloat circles(vec2 p, float r)\n{\n    \n float c1 = (1.0-circle(p+vec2(0.5, 0.0), r))*(step(-0.5, p.x));   \nfloat c2 = (1.0-circle(p-vec2(0.5, 0.0), r))*(step(p.x, 0.5)); \n    \n    return c1+c2;\n}\n\n//rotation coord system that rotates based on an id that is randomized\n\nvec3 rotCoord(vec2 p)\n    \n{\n    float id = rnd(floor(p*scale));\n    vec2 m = floor(p*scale);\n    float index = mod(m.x+m.y, 2.0);\n        \n    \n    p = fract(p*scale)-0.5;\n    \n    if(index>0.0)\n    {\n        p = p*rot(pi/2.);\n    }\n    \n    /*\n\n //if index of row is even index = 0.0, else index = 1.0\n    float index = mod(m.y, 2.0);\n        \n    //flip all even rows 90 degrees\n    p = fract(p*scale)-0.5;\n    \n    if(index>0.0)\n    {\n        p = p*rot(pi/2.);\n    }\n\n*/\n   \n   \n   \n return vec3(p, index);   \n}\n\nfloat vig (vec2 st)\n{\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.2); \n    return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    float v = vig(st);\n    st+=iTime/8.;\n    \n    uv+=iTime/8.;\n    \n    \n    //uv = uv*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 stuff = rotCoord(uv);\n    \n    uv = stuff.xy;\n    float colID = stuff.z;\n    \n    \n    float c = 1.0-circles(uv, 0.5);\n    float outline= circles(uv, 0.5)-circles(uv, 0.485);\n\n    // Time varying pixel color\n    \n\t//col = vec3(1.0-circles(uv, 0.5));\n    float tx0 = vec3(texture(iChannel0, uv)).x;\n    float tx1 = vec3(texture(iChannel1, uv)).x;\n    float tx2 = vec3(texture(iChannel2, st)).x;\n    \n    vec3 col = vec3(0.4, 0., 0.)/1.5*tx2;\n    \n    col = mix(col, vec3(.8, 0., 0.)*tx0, c*step(0.1, colID));\n    col = mix(col, vec3(.8, 0., 0.)*tx0, (1.0-c)*step(colID, 0.1));\n    // Output to screen\n    col = mix(col, vec3(195., 155., 25.)/155.-tx1+(sin(iTime*2.+uv.x*4.+uv.y)+1.)/4., outline);\n    \n    \n    fragColor = vec4(col*v,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 62, 130], [132, 132, 151, 151, 203], [206, 206, 237, 237, 345], [347, 347, 379, 379, 541], [543, 615, 643, 643, 1130], [1132, 1132, 1153, 1153, 1252], [1254, 1254, 1311, 1361, 2308]]}
{"id": "ttjGzy", "name": "tentaclez 3 aliasing", "author": "anclin", "description": "tentaclez 3 aliasing", "tags": ["aliasing", "tentacles"], "likes": 2, "viewed": 54, "published": "Public", "date": "1560099443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y = fract(uv.y*3.);\n    //uv.y -= .5;\n    \n    float T = iTime * 2.5;\n    //T += uv.y*3.14*3.;\n    //T = abs(fract(iTime)-.5);\n    \n    \n    vec3 col = vec3(0);\n    \n    \n    float t = uv.x;// + iTime * .2;\n    float waves = 5.;\n    float s = cos(t * 3.14*2. * waves);\n    float h = mix(.0, .05, cos(T+3.14)*.5+.5);\n    \n    float s1 = s*h+h;\n    float s2 = s*h-h;\n    \n    // triangle thick part\n    float th = mix(.0, .5, sin(uv.x));\n    \n    //float R = (1.-step(s1+th, uv.y));\n    //float G = (   step(s2-th, uv.y-1.));\n    //float B = (   step(.5, uv.y));\n    \n    float a = 0.02; // aliasing\n    float R = smoothstep(s1+th+a, s1+th, uv.y);\n    float G = smoothstep(s2-th-a, s2-th, uv.y-1.);\n    //float B1 = step(s*.1+.5 + uv.x, 1.-uv.y);\n    //float B2 = step(s1 + .5, uv.y);\n    \n    //col = vec3(R);\n    col = vec3(R+G);\n    //col += step(s, uv.y);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1080]]}
{"id": "ttlSRr", "name": "Night of the Penguins", "author": "dr2", "description": "Winter is coming for the penguins down south...", "tags": ["raymarch", "water", "ice", "aurora", "replication", "penguin"], "likes": 16, "viewed": 478, "published": "Public API", "date": "1561915555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Night of the Penguins\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Winter is coming for the penguins down south; look around using mouse\n  (mouse in lower-right corner for day view).\n  Based on \"Endless Penguins\" (www.shadertoy.com/view/MlVyzR) and sky from\n  \"Ocean Structure\" (www.shadertoy.com/view/ltBczc) with tweaks.\n*/\n\n#define AA        0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId, obOff;\nfloat dstFar, tCur, fAng, obRot, szFac, hgSize, tWav;\nint idObj;\nbool isNite;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dh;\n  dMin = dstFar;\n  if (szFac > 0.) {\n    p.xz -= HexToPix (gId * hgSize) + obOff;\n    p.xz = Rot2D (p.xz, obRot);\n    dMin /= szFac;\n    p /= szFac;\n    p.y -= 1.55;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (3);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.4, -0.8);\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (6);\n    q = p;\n    q.y -= -1.53;\n    d = abs (q.y) - 0.01;\n    DMINQ (7);\n    dMin *= szFac;\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return Fbm2 (0.05 * p) - 0.5;\n}\n\nvoid SetPngConf ()\n{\n  vec2 g, w;\n  float t;\n  g = HexToPix (gId * hgSize);\n  if (GrndHt (g) < 0. || Hashfv2 (37. * gId + 99.) < 0.3) szFac = 0.;\n  else {\n    obRot = 2. * pi * Hashfv2 (37. * gId + 99.);\n    t = Hashfv2 (17. * gId + 99.);\n    szFac = 0.8 * (0.5 * sqrt3 - 0.3 * t);\n    w = Hashv2v2 (73. * gId + 77.);\n    obOff = hgSize * max (0., 0.5 * sqrt3 - szFac) * w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n    fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur + 1.3 * t, 1.)) *\n       sin (16. * pi * tCur);\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetPngConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.002;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0. || rd.y > 0. && p.y > 5.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetPngConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = -0.98 * ro.y / rd.y;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + dHit * rd;\n    d = p.y + 0.01 * step (GrndHt (p.xz), -0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 AurCol (vec3 ro, vec3 rd)\n{\n  vec4 col, mCol;\n  vec3 p, dp;\n  float ar;\n  dp = rd / rd.y;\n  p = ro + (50. - ro.y) * dp;\n  col = vec4 (0.);\n  mCol = vec4 (0.);\n  tWav = 0.05 * tCur;\n  for (float ns = 0.; ns < 50.; ns ++) {\n    p += dp;\n    ar = 0.05 - clamp (0.06 * WaveHt (0.008 * p.xz), 0., 0.04);\n    mCol = mix (mCol, ar * vec4 (HsvToRgb (vec3 (mix (0.34 + 0.007 * ns, 0.,\n       smoothstep (30., 45., ns)), 1., 1. - 0.013 * ns)), 1.), 0.5);\n    col += mCol;\n  }\n  return col;\n}\n\nvec3 NtSkyCol (vec3 rd)\n{\n  vec3 rds;\n  rds = floor (2000. * rd);\n  rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n  for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n  return 0.3 * vec3 (1., 1., 0.9) * min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n}\n\nvec3 SkyHzCol (vec3 ro, vec3 rd)\n{\n  vec4 aCol;\n  vec3 col;\n  float f, a;\n  a = atan (rd.x, - rd.z);\n  if (rd.y < 0.03 * Fbm1 (32. * a) + 0.005) {\n    col = (isNite ? 0.75 * vec3 (0.15, 0.3, 0.2) : vec3 (0.95, 0.95, 1.)) * (1. -\n       0.2 * Fbm2 (128. * vec2 (a, 4. * rd.y)));\n  } else {\n    if (isNite) {\n      aCol = AurCol (ro, rd);\n      col = (1. - 0.5 * aCol.a) * NtSkyCol (rd) + 0.6 * aCol.rgb;\n    } else {\n      ro.xz += 2. * tCur;\n      col = vec3 (0.2, 0.3, 0.6) + 0.2 * (1. - max (rd.y, 0.)) +\n         0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n      f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.01)));\n      col = mix (col, vec3 (1.), 0.2 + 0.8 * f * rd.y);\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  bool isSky, isGrnd, isWat, doSh;\n  isSky = false;\n  isGrnd = false;\n  isWat = false;\n  doSh = false;\n  tWav = 0.4 * tCur;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj != 7) {\n      gId = PixToHex (ro.xz / hgSize);\n      vn = ObjNf (ro);\n      if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);\n    }\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.1, 0.1, 0.15, 0.1);\n    else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n    else if (idObj == 6) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n    else if (idObj == 7) isGrnd = true;\n    doSh = true;\n  } else if (rd.y < 0.) {\n    dstGrnd = GrndRay (ro, rd);\n    ro += dstGrnd * rd;\n    if (ro.y < 0.) isWat = true;\n    else isGrnd = true;\n  } else isSky = true;\n  if (! isSky) {\n    if (isWat) {\n      ro += (- ro.y / rd.y) * rd;\n      rd = reflect (rd, VaryNf (0.5 * ro + vec3 (0.1 * tCur, 0., 0.1 * tCur), vec3 (0., 1., 0.), 0.1));\n      col = 0.9 * SkyHzCol (ro, rd);\n    } else {\n      if (isGrnd) {\n        col4 = vec4 (vec3 (0.95, 0.95, 1.) * min (0.9 + 0.2 * Fbm2 (ro.xz), 1.), 0.1);\n        vn = VaryNf (ro, vec3 (0., 1., 0.), 0.3);\n        doSh = (min (dstGrnd, dstObj) < dstFar);\n      }\n      if (isNite) {\n        if (isGrnd || idObj != 3) col = col4.rgb * vec3 (0.15, 0.3, 0.2) * (0.2 + 0.8 * max (0., vn.y));\n        else col = vec3 (0.7, 0., 0.) * max (- dot (vn, rd), 0.);\n      } else {\n        sh = doSh ? ObjSShadow (ro, sunDir) : 1.;\n        col = col4.rgb * (0.3 + 0.2 * max (dot (normalize (vec3 (vn.x, 0., vn.z)), - sunDir), 0.) +\n           0.6 * sh * max (dot (vn, sunDir), 0.)) +\n           col4.a * smoothstep (0.8, 1., sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n    }\n    col = mix (col, vec3 (0.9) * (isNite ? 0.8 * vec3 (0.15, 0.3, 0.2) : vec3 (1.)),\n       smoothstep (0.3, 1., min (dstGrnd, dstObj) / dstFar));\n  } else col = SkyHzCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPos (float t)\n{\n  return vec3 (5. * cos (0.01 * 2. * pi * t) + 0.1 * t, 10., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, spd, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  isNite = true;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > 0.45 && mPtr.y < -0.45) isNite = false;\n    else {\n      az += 2. * pi * mPtr.x;\n      el += 0.2 * pi * mPtr.y;\n    }\n  }\n  hgSize = 2.3;\n  spd = 10.;\n  ro = TrackPos (spd * tCur);\n  vd = normalize (TrackPos (spd * tCur + 0.1) - ro);\n  az += 0.5 * pi + atan (- vd.z, vd.x);\n  el += asin (vd.y) - 0.05 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 300.;\n  sunDir = normalize (vec3 (0.5, 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 1.8));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlSRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[129, 1168, 1190, 1190, 2751], [2753, 2753, 2776, 2776, 2810], [2812, 2812, 2832, 2832, 3364], [3366, 3366, 3399, 3399, 4530], [4532, 4532, 4553, 4553, 4745], [4747, 4747, 4784, 4784, 5208], [5210, 5210, 5244, 5244, 5490], [5492, 5492, 5515, 5515, 6038], [6040, 6040, 6072, 6072, 6526], [6528, 6528, 6553, 6553, 6815], [6817, 6817, 6851, 6851, 7535], [7537, 7537, 7572, 7572, 9855], [9857, 9857, 9882, 9882, 9949], [9951, 9951, 10007, 10007, 11453], [11455, 11455, 11488, 11488, 11515], [11517, 11517, 11559, 11559, 11610], [11612, 11612, 11647, 11647, 11709], [11711, 11711, 11756, 11756, 11859], [11861, 11861, 11918, 11918, 12001], [12003, 12003, 12027, 12027, 12257], [12259, 12259, 12283, 12283, 12343], [12345, 12345, 12369, 12369, 12486], [12488, 12488, 12518, 12518, 12631], [12665, 12665, 12689, 12689, 12749], [12751, 12751, 12775, 12775, 12828], [12830, 12830, 12854, 12854, 12984], [12986, 12986, 13010, 13010, 13230], [13232, 13232, 13257, 13257, 13403], [13405, 13405, 13430, 13430, 13616], [13618, 13618, 13643, 13643, 13868], [13870, 13870, 13892, 13892, 14046], [14048, 14048, 14069, 14069, 14224], [14226, 14226, 14255, 14255, 14467], [14469, 14469, 14508, 14508, 14688]]}
{"id": "ttS3Dy", "name": "Voronoi Diagram Pavleeto edition", "author": "pavleeto", "description": "Can we build Voronoi diagram using shaders? definitely!", "tags": ["voronoi"], "likes": 0, "viewed": 102, "published": "Public", "date": "1560924160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int COUNT = 4; \nvec2 positions[COUNT];\nvec3 colors[COUNT];\n\nvoid initPoints()\n{\n    positions[0] = vec2(0.1, 0.1);\n    positions[1] = vec2(0.2, 0.4);\n    positions[2] = vec2(0.6, 0.2);\n    positions[3] = vec2(0.9, 0.9);\n    \n    colors[0] = vec3(1.0, 0.0, 0.0);\n    colors[1] = vec3(0.0, 1.0, 0.0);\n    colors[2] = vec3(1.0, 1.0, 0.0);\n    colors[3] = vec3(0.0, 0.0, 1.0);\n}\n\nfloat dist(vec2 a, vec2 b)\n{\n    vec2 delta = abs(a-b);\n    \n    float n = sin(iTime)*0.5 + 1.5;\n    return pow(pow(delta.x, n) + pow(delta.y, n), 1.0/n);\n}\n\nvec3 voronoi(vec2 uv)\n{\n    int index = 0;\n    float minDist = dist(uv, positions[0]);\n    \n    for (int i=1; i<COUNT; ++i)\n    {\n        float cand = dist(uv, positions[i]);\n        if (cand < minDist) {\n            minDist = cand;\n            index = i;\n        }\n    }\n    \n    return colors[index];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initPoints();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = voronoi(uv);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 380], [382, 382, 410, 410, 538], [540, 540, 563, 563, 844], [846, 846, 903, 903, 1083]]}
{"id": "ttS3Wc", "name": "fractal--complex---v5", "author": "jorge2017a1", "description": "fractal--complex---v5", "tags": ["fractalcomplexv5"], "likes": 1, "viewed": 73, "published": "Public", "date": "1561338970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n//hecho por jorge flores p.....23/jun-2019\n\nstruct complex\n{\n    float re;\n    float im;\n}; \n\nconst float M_PI = 3.14159265359;\n\ncomplex complex_set(float re , float im)\n{\n\tcomplex cout;\n    cout.re = re;\n    cout.im = im;\n    return cout;\n}\n    \n\ncomplex complex_neg(complex p) \n{\n    complex cout;\n    cout.re = -p.re;\n    cout.im = -p.im;\n    return cout;\n}\n   \n\ncomplex complex_add(complex c1 , complex c2) \n{\n\t\n    complex cout;\n    cout.re = c1.re + c2.re;\n    cout.im = c1.im + c2.im;\n    return cout;\n}    \n\n\n\ncomplex complex_multiply(complex a, complex b) \n{\n    complex cout;\n\tcout.re= a.re * b.re - a.im * b.im;\n    cout.im =a.im * b.re + a.re * b.im;\n    return cout;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) \n{\n    return complex_multiply(a, a);\n}\n\n\ncomplex complex_sub(complex  c1 ,complex  c2) \n{\n    complex cout;\n\n    cout.re = c1.re - c2.re;\n    cout.im = c1.im - c2.im;\n    return  cout;\n}\n\n\n\n\n/*vec2 cmpxpow(in vec2 c, int p) {\n    vec2 orig = c;\n\tfor (int i = 0; i < p-1; ++i) {\n\t\tc = cmpxmul(c, orig);\n\t}\n    return c;\n}\n*/\n\n\nfloat complex_mag(complex c)\n{\n    \n    return sqrt(c.re * c.re + c.im * c.im);\n}\n\n\n\ncomplex complex_exp(complex z) \n{\n    complex tmp;\n    complex cout;\n    tmp.re= cos(z.im);\n    tmp.im= sin(z.im);\n    \n    cout.re=exp(z.re)*tmp.re;\n    cout.im=exp(z.re)*tmp.im;\n    \n    \n    return cout;\n}\n\n\n\nfloat complex_norm(complex c )\n{\n\tfloat result ;\n    \n    result = c.re * c.re + c.im * c.im;\n        \n    return  result;\n}\n    \n\ncomplex complex_pow(complex a, float b) \n{\n    float r = complex_mag(a);\n    float theta = atan(a.im, a.re);\n    complex tmp;\n    \n    tmp.re=b * log(r);\n    tmp.im=b *  theta;\n    \n    return complex_exp(tmp);\n    \n}\n\nvec3 getColor(float v)\n{\n    /*vec3 col = vec3(0.1) * sin(v);\n    col = mix(col, vec3(0.1, 0.2, 0.4), sin(1.-v));\n    col = mix(col, vec3(0.1, 0.2, 0.7), pow(sin(1.-v),2.));\n    return col;*/\n\t\n    float a = 1.;\n    float b = 0.2357022603955158;  // 1/3*sqrt(2)\n    float c = 0.12452650612453368; // 1/7*3^(1/8)\n    return vec3((1.-cos(a*v))*0.5, (1.-cos(b*v))*0.5, (1.-cos(c*v))*0.5);\n}\n\n\nvec3 mandelbrot(vec2 frag )\n{\n    \n\n  float maxI; \n  float Bailout;\n  complex z;\n  complex c;\n  float x;\n  float y;\n  float iter; \n  float it;  \n    \n    x=frag.x;\n    y=frag.y;\n    \n    z.re = x; \n    z.im = y;\n    \n    c.re = 0.5+0.5*cos(iTime);\n    c.im = 0.0;\n    \n    Bailout = 10.0;\n    \n  maxI=255.0;\n    \n  float tmp;\n    //for(float i = 0.; i < 15.; i++) \n    \n    for( iter = 0.0; iter< maxI; iter++)\n    {\n         z =complex_add(complex_pow(z, 2.0), c);\n         \n           \n        tmp=abs(z.re);\n        if (tmp > Bailout )\n        {       break;        }\n        \n        tmp=abs(z.im);\n         if ( tmp > Bailout )\n        {    break;    }\n         \n                            \n         if (complex_norm(z) > 100.0 )\n         { break;  }\n    }\n                      \n    \n     if ( abs(z.re) < Bailout )\n     {\n        it = iter / 255.0;\n     }\n     else\n     {\n        it = iter + 1.0;    \n         \n     }\n    \n    \n    \n      if (abs(z.im) < Bailout )\n       {\n     \t\n        it = iter / 255.0;\n       }\n        else\n       {\n        it = iter + 1.0;    \n       }\n\n    \n    \n    \n    vec3 col;\n    //color3 = vec3(it*1.0 / maxI);\n\t//col = vec3(it*1.0 / maxI,it*1.0 / maxI,it*1.0 / maxI);\n    //col = vec3(it*1.0 ,it*1.0 ,it*1.0 );\n\tcol= getColor(it*1.0);\n\t\n         \n    return col;\n}\n    \n\n\n\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;                \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //z *= SCALE*0.5 + 5.5*cos(iTime);\n    \n    z *= SCALE;\n    \n    \t\n    col=mandelbrot(z);\n    \n        \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttS3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 187, 229, 229, 299], [306, 306, 339, 339, 418], [424, 424, 471, 471, 568], [576, 576, 625, 625, 739], [741, 773, 809, 809, 846], [849, 849, 897, 897, 994], [999, 1134, 1164, 1164, 1215], [1219, 1219, 1252, 1252, 1427], [1431, 1431, 1463, 1463, 1555], [1562, 1562, 1604, 1604, 1779], [1781, 1781, 1805, 1972, 2168], [2171, 2171, 2200, 2200, 3477], [3493, 3493, 3550, 3550, 4062]]}
{"id": "ttSGRc", "name": "Flat water effects", "author": "mrange", "description": "I was looking for waves that would look good on a flat 2D plane. I didn't really find something to my liking so I tinkered a bit (with some inspiration from other shaders obviously). I thought the result was decent so I wanted to share.", "tags": ["waterraytrace"], "likes": 30, "viewed": 952, "published": "Public API", "date": "1560459624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n// Color computation inspired by: https://www.shadertoy.com/view/Ms2SD1\n\n// I was looking for waves that would look good on a flat 2D plane.\n// I didn't really find something to my liking so I tinkered a bit\n// (with some inspiration from other shaders obviously).\n// I thought the end result was decent so I wanted to share\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\nconst vec3 skyCol1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol  =  vec3(8.0,7.0,6.0)/8.0;\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nfloat gravityWave(in vec2 p, float k, float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return sin(p.y*k + w*iTime);\n}\n\nfloat capillaryWave(in vec2 p, float k, float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return sin(p.y*k + w*iTime);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nfloat seaHeight(in vec2 p) {\n  float height = 0.0;\n\n  float k = 1.0;\n  float kk = 1.3;\n  float a = 0.25;\n  float aa = 1.0/(kk*kk);\n\n  float h = 10.0;\n  p *= 0.5;\n\n  for (int i = 0; i < 3; ++i) {\n    height += a*gravityWave(p + float(i), k, h);\n    rot(p, float(i));\n    k *= kk;\n    a *= aa;\n  }\n  \n  for (int i = 3; i < 7; ++i) {\n    height += a*capillaryWave(p + float(i), k, h);\n    rot(p, float(i));\n    k *= kk;\n    a *= aa;\n  }\n\n  return height;\n}\n\nvec3 seaNormal(in vec2 p, in float d) {\n  vec2 eps = vec2(0.001*pow(d, 1.5), 0.0);\n  vec3 n = vec3(\n    seaHeight(p + eps) - seaHeight(p - eps),\n    2.0*eps.x,\n    seaHeight(p + eps.yx) - seaHeight(p - eps.yx)\n  );\n  \n  return normalize(n);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.15, 1));\n  return dir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n\n  final += 4.0*sunCol*pow(sunDot, 400.0);\n    \n  return final;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n    \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    float h = seaHeight(p.xz);\n    vec3 nor = mix(seaNormal(p.xz, dsea), vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n      \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2 * (p.y - h) * 2.0 * atten;\n      \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n  } else {\n    col = sky;\n  }\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[168, 691, 739, 739, 811], [813, 813, 863, 863, 958], [960, 960, 993, 993, 1078], [1080, 1080, 1108, 1108, 1533], [1535, 1535, 1574, 1574, 1777], [1779, 1779, 1800, 1800, 1858], [1860, 1860, 1884, 1884, 2139], [2141, 2141, 2196, 2196, 3319]]}
{"id": "ttSGz3", "name": "Glare of water", "author": "jaszunio15", "description": "Simple concept of simulating glare of water using Voronoi noise.\n\nShader License: CC BY 3.0\nAuthor: Jan MrÃ³z (jaszunio15)", "tags": ["voronoi", "water", "glare"], "likes": 28, "viewed": 501, "published": "Public", "date": "1560524381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan MrÃ³z (jaszunio15)\n\n//Layered voronoi\n#define VORONOI_NOISE_POW 5.0\n#define VORONOI_BRIGHTNESS_ADD 0.05\n#define SIZE_MUL 1.5\n#define ALPHA_MUL 0.9\n#define LAYERS 4\n\n//Colors\n#define WATER_COLOR vec4(0.0, 0.8, 0.8, 1.0)\n\n//Image size and displacement\n#define UV_MUL 3.0\n#define UV_DISPLACEMENT_STRENGTH 0.15\n#define UV_DISPLACEMENT_SIZE 5.0\n\n//Animation\n#define WATER_SPEED 0.5\n#define ANIMATION_SPEED 2.0\n\nfloat hash1_2(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\t\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\nvec2 rotate(vec2 point, float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(vec2 root, float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point;\n    point += root + 0.5;\n    return point;\n}\n\nfloat degFromRootUV(vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) + 0.2);   \n}\n\n//x - voronoi coordinates (grid step = 1)\nfloat voronoi(vec2 uv)\n{\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    \n    vec2 tempRootUV;\t//Used in loop only\n    vec2 tempPointUV;\t//Used in loop only\n    vec2 closestPointUV = pointUV;\n    float minDist = 2.0;\n    float dist = 2.0;\n    for (float x = -1.0; x <= 1.0; x+=1.0)\n    {\n     \tfor (float y = -1.0; y <= 1.0; y+=1.0)   \n        {\n         \ttempRootUV = rootUV + vec2(x, y);\n            deg = (iTime * hash1_2(tempRootUV) * ANIMATION_SPEED);\n            tempPointUV = voronoiPointFromRoot(tempRootUV, deg);\n            \n            dist = distance(uv, tempPointUV);\n            if(dist < minDist)\n            {\n             \tclosestPointUV = tempPointUV;\n               \tminDist = dist;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\n//Layered voronoi noise\nfloat fractVoronoi(vec2 uv, float sizeMul, float alphaMul, int layers)\n{\n \tfloat noise = 0.0;\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 uvOffset; //Used in loop only\n    for(int i = 0; i < layers; i++)\n    {\n        uvOffset = hash2_2(vec2(size, alpha)) * iTime * WATER_SPEED;\n        noise += pow(voronoi((uv + uvOffset) * size) * alpha + VORONOI_BRIGHTNESS_ADD, VORONOI_NOISE_POW);\n        size *= sizeMul;\n        alpha *= alphaMul;\n    }\n    \n    noise *= (1.0 - alphaMul)/(1.0 - pow(alphaMul, float(layers)));\n    return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x; \n    uv *= UV_MUL;\n    vec2 noise2D = noise2_2(uv * UV_DISPLACEMENT_SIZE) * UV_DISPLACEMENT_STRENGTH;\n    float fractVoro = fractVoronoi(uv + noise2D, SIZE_MUL, ALPHA_MUL, LAYERS);\n    float res = smoothstep(-0.2, 0.3, fractVoro);\n    fragColor = vec4(res) * WATER_COLOR + fractVoro;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGz3.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[383, 448, 471, 471, 538], [540, 540, 562, 562, 641], [644, 672, 696, 696, 1113], [1115, 1115, 1151, 1151, 1239], [1241, 1278, 1327, 1327, 1498], [1500, 1500, 1530, 1530, 1591], [1593, 1635, 1659, 1659, 2471], [2473, 2497, 2569, 2569, 3043], [3045, 3045, 3102, 3102, 3454]]}
{"id": "ttSGzd", "name": "Chewed sphere", "author": "Darien", "description": "Playing and learning Ray-marching. Cheated a bit by using 2D noise for 3D displacement... maybe that's why there's a rotation glitch? which I like! :D  ", "tags": ["raymarching", "sdf", "fbm"], "likes": 8, "viewed": 196, "published": "Public", "date": "1560708112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n#define STEPS 32\n#define OCTAVES 5\n\n\nmat3 rotateY(float a) {\n\treturn mat3(\n\t\tvec3(cos(a), 0., -sin(a)),\n\t\tvec3(0, 1., 0.),\n\t\tvec3(sin(a), 0, cos(a))\n\t\t);\n}\n\nmat3 rotateX(float a) {\n\treturn mat3(\n\t\tvec3(1., 0., 0.),\n\t\tvec3(0., cos(a), -sin(a)),\n\t\tvec3(0., sin(a), cos(a))\n\t\t);\t\n}\n\nfloat random(vec2 st) {\n\treturn fract(sin(dot(st, vec2(15.13123, 45.56251))) * 45666.12) *2.-1.;\n}\n\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t// Create grid to spread out our noise\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t// Create our hermite cubic interpolation\n\tvec2 h = f * f * (3.0 - 2.0 * f);\n\t// Do our bilinear interpolation:\n\treturn \tmix(a, b, h.x) + \n\t\t\t(c - a) * h.y * (1.0 - h.x) +\n\t\t\t(d - b) * h.x * h.y;\n}\n\nfloat fbm(vec3 p){\n\tfloat amp = 2.0;\n\tfloat fbm = 0.;\n\tfloat scale = 2.0;\n\tfor(int i = 0; i < OCTAVES; i++){\n\t\tfbm += noise(p.xy) * amp;\n\t\tp *= scale;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - 0.5 * r;\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\tp *= rotateX(-PI*0.35);\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\nfloat scene(vec3 p) {\n\tp *= rotateY(PI*iTime);\n\tfloat noisySphere = max(sphere(p + fbm(p)*0.5, 12.), sphere(p, 12.));\n\tfloat torus = fTorus(p, 6.9, 9.);\n\treturn max(torus, noisySphere);\n}\n\nvec3 getNormals(vec3 p) {\n\tvec3 delta = vec3(0.01, 0., 0.);\n\tfloat x = scene(p + delta.xyy) - scene(p - delta.xyy);\n\tfloat y = scene(p + delta.yxy) - scene(p - delta.yxy);\n\tfloat z = scene(p + delta.yyx) - scene(p - delta.yyx);\n\treturn normalize(vec3(x, y, z));\n}\n\nfloat rayMarching(vec3 pos, vec3 dir, out vec3 p) {\n\tfloat currentDist = 0.;\n\tconst float min = 0.01;\n\tconst float max = 1000.0;\n\tfor(int i = 0; i < STEPS; ++i) {\n\t\tp = pos + (dir * currentDist);\n\t\tfloat distance2Obj = scene(p);\n\t\tif(distance2Obj < min) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrentDist += distance2Obj;\n\t\tif(currentDist > max) {\n\t\t\tcurrentDist = 0.;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn currentDist;\n}\n\n\n// Standard Blinn lighting model.\n// This model computes the diffuse and specular components of the final surface color.\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition, vec3 col)\n{\n\tvec3 fromPointToLight = normalize(lightPosition - pointOnSurface); // Get normal\n\tfloat diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n\tvec3 diffuseColor = diffuseStrength * col;\n\tvec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n\tvec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n\tfloat specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0), 10.0);\n\t// Ensure that there is no specular lighting when there is no diffuse lighting.\n\tspecularStrength = min( diffuseStrength, specularStrength );\n\tvec3 specularColor = specularStrength * vec3( 1.0 );\n\tvec3 finalColor = diffuseColor + specularColor;\n\treturn finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n\tst.x *= iResolution.x / iResolution.y;\n\n\t// Define camera properties\n\tvec3 cameraPos = vec3(0., 0., -10.0);\n\tvec3 cameraDir = vec3(st.x, st.y, 1.);\n\tvec3 color = vec3(length(st))*0.05;\n\tvec3 p;\n\tfloat r = rayMarching(cameraPos, cameraDir, p);\n\t\n\tif(r > 0.0) {\n\t\tvec3 normals = getNormals(p);\n\t\tvec3 lightPosA = vec3(-12., 0., 0.);\n\t\tvec3 lightPosB = vec3(9., 0., -10.);\n\t\tfloat fbmCol = abs(fbm(p*4.0));\n\t\tvec3 colA = mix(vec3(cos(iTime)*0.5+0.5, .5, 0.25), vec3(0.1, 0.5, 0.9), fbmCol);\n\t\tvec3 colB = mix(colA, vec3(0.9, 0.9, 0.9), fbmCol);\n\t\tcolor = calculateLighting(p, normals, lightPosA, cameraPos, colA);\n\t\tcolor += calculateLighting(p, normals, lightPosB, cameraPos, colB);\t\n\t}\n\n\tfragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 86, 86, 181], [183, 183, 206, 206, 304], [306, 306, 329, 329, 404], [406, 406, 428, 428, 848], [850, 850, 868, 868, 1032], [1034, 1034, 1065, 1065, 1096], [1098, 1098, 1158, 1158, 1254], [1256, 1256, 1277, 1277, 1443], [1445, 1445, 1470, 1470, 1708], [1710, 1710, 1761, 1761, 2097], [2100, 2221, 2337, 2337, 3076], [3078, 3078, 3134, 3134, 3908]]}
{"id": "Wl23Dy", "name": "A 2d line", "author": "vchizhov", "description": "A simple example of drawing a 2d line.", "tags": ["line", "distance", "hessenormalform", "hyperplane"], "likes": 2, "viewed": 182, "published": "Public", "date": "1560983361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates in [-1,1]^2\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = 2.0*uv-vec2(1.0);\n    \n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 res = vec2(aspectRatio,1.0); // don't stretch out the screen\n    \n    ndc *= res; // rescale ndc to account for the aspect ratio\n\n    // first line point (note that coordinates are originally given in [-1,1]^2 and then\n    // remapped to account for stretching)\n    vec2 v0 = res * vec2(-cos(iTime),-sin(iTime));\n    //vec2 v0 = res*vec2(-1,-1);\n    \n    // second line point - reflected around (0,0)\n    vec2 v1 = -v0;\n    // normalized direction from v0 to v1\n    vec2 dir = normalize(v1-v0);\n    \n    \n    // pixel normalized coordinates (aspect ratio preserved)\n    vec2 p = ndc;\n    // some point on the line\n    vec2 c = v0;\n    // unit length normal of the line\n    vec2 n = vec2(-dir.y,dir.x);\n    // signed distance from p to the line\n    float dist = dot(p-v0, n);\n    \n    // thickness of the line\n    float thickness = 0.01 + 0.04*abs(sin(2.0*iTime));\n    //vec3 col = vec3(abs(dist)<thickness);\n    vec3 col = vec3(1.0-smoothstep(abs(dist), 0.0, thickness));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl23Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 105, 1280]]}
{"id": "wl23R3", "name": "Rust", "author": "Yusef28", "description": "Another Pattern ", "tags": ["pattern"], "likes": 2, "viewed": 105, "published": "Public", "date": "1560891713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 5.\n#define pi 3.14159265359\n\nfloat rnd(vec2 p)\n{\n return fract(sin(dot(p, vec2(12.9898, 78.233)))*43562.34532);   \n}\n\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n\nfloat circle(vec2 p, float r)\n{\n    float c;\n    float ss = 0.009;\n    c = length(p);\n    c = smoothstep(r-ss, r+ss, c);  \n\treturn c;    \n}\n\nfloat circles(vec2 p, float r)\n{\n    \n float c1 = (1.0-circle(p+vec2(0.5, 0.0), r))*(step(-0.47, p.x));   \nfloat c2 = (1.0-circle(p-vec2(0.5, 0.0), r))*(step(p.x, 0.47)); \n    \n    return c1+c2;\n}\n\n//rotation coord system that rotates based on an id that is randomized\n\nvec2 rotCoord(vec2 p)\n    \n{\n    float id = rnd(floor(p*scale));\n    vec2 m = floor(p*scale);\n    float index = mod(m.x+m.y, 2.0);\n        \n    \n    p = fract(p*scale)-0.5;\n    \n    if(index>0.0)\n    {\n        p = p*rot(pi/2.);\n    }\n    \n    if(id*scale>0.25*scale)\n    {\n        p = p*rot(pi/2.);\n    }\n   \n   \n return p;   \n}\n\nfloat vig(vec2 st)\n{\n st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.19);\n    return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    float v = vig(uv);\n    uv+=iTime/8.;\n    st+=iTime/8.;\n    //uv = uv*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = rotCoord(uv);\n\tfloat tx0 = vec3(texture(iChannel0, st)).x*1.9;\n    \n    \tfloat tx1 = vec3(texture(iChannel1, st)).x+0.2;\n\n    \n    // Time varying pixel color\n    vec3 col = vec3(212., 123., 15.)/155.*tx0/1.;\n\tcol = mix(col,vec3(.3, 0., 0.)*tx1, 1.0-circles(uv, 0.48));\n    \n    ///////////////////////\n    col = vec3(.5, 0., 0.)*tx1;//;\n\tcol = mix(col,vec3(212., 123., 15.)/155.*tx0/1.8, 1.0-circles(uv, 0.48));\n    \n    // Output to screen\n    fragColor = vec4(col*v,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 62, 130], [132, 132, 151, 151, 203], [206, 206, 237, 237, 345], [347, 347, 379, 379, 543], [545, 617, 645, 645, 945], [947, 947, 967, 967, 1063], [1065, 1065, 1122, 1172, 1835]]}
{"id": "wl23RK", "name": "Arc - distance", "author": "iq", "description": "Distance to an arc of arbitrary orientation and aperture", "tags": ["2d", "sdf", "distance", "arc"], "likes": 19, "viewed": 2179, "published": "Public API", "date": "1560306750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a sector of a circle\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float time = iTime;\n    float ta = 3.14*(0.5+0.5*cos(time*0.52+2.0));\n    float tb = 3.14*(0.5+0.5*cos(time*0.31+2.0));\n    float rb = 0.15*(0.5+0.5*cos(time*0.41+3.0));\n    \n    // distance\n    float d = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.7, rb);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdArc(m,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.7, rb);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23RK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1274, 1353, 1431, 1431, 1612], [1614, 1614, 1671, 1707, 2653]]}
{"id": "wl23RV", "name": "Inferno", "author": "dagbrynildsentholander", "description": "tried to get that pleasant \"burn in hell\" feel to it.", "tags": ["raymarching"], "likes": 9, "viewed": 424, "published": "Public API", "date": "1560341341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float maxDist = 500.;\nvec3 camRot = vec3(0, 0, 0);\nvec3 lightDir = vec3(1.2,.7,.8);\nvec3 lightColor = vec3(.8,.4,.3)*3.5;\nvec3 ambientLight = vec3(0);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*16.+p.y*6463.)*3732.);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 id = floor(p*10.);\n    vec2 ld = fract(p*10.);\n    \n    ld = ld*ld*(3.-2.*ld);\n    \n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n    \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return abs(bt);\n}\n\nfloat ridged(float x)\n{\n    return abs(1.-abs(x));\n}\n\nfloat vulcano(float x)\n{\n    return x*pow((abs(sin(x*2.1))+1.)/2., 3.);\n}\n\nvec2 map(vec3 p)\n{\n    float a = p.y/15.;\n    \n    float mat = 0.;\n    float terrainHeight=60.;\n    \n    if(p.y < 1.5)\n    \treturn vec2(1.5-p.y, 1.);\n    \n    p+=vec3(25.5*cos(a), -1.5*sin(a)*p.y/20., 0);\n    float base = vulcano(pow(ridged(smoothNoise(p.xz/1000.)), 5.))*terrainHeight;\n    base += .4*vulcano(pow(smoothNoise(p.xz/520.), 5.))*terrainHeight;\n        p+=vec3(25.5*cos(a), -1.5*sin(a)*p.y/20., 0)*.5;\n    base += .1*pow(smoothNoise(p.xz/104.), 2.)*terrainHeight;\n    //p+=vec3(25.5*cos(a), 0, 0)*2.5;\n    base += .02*smoothNoise(p.xz/32.)*terrainHeight;\n    base += .01*pow(smoothNoise(p.xz/16.), 2.)*terrainHeight;\n    base += .002*pow(smoothNoise(p.xz/4.), 2.)*terrainHeight;\n\n    return vec2(base-p.y, mat);\n}\n\n\nvec2 ray(vec3 ro, vec3 rd, float minD, float maxD, float stepSize) // x channel - distance to hit, y channel - material\n{\n    float t = minD;\n    float lastVal = 0.; \n    \n    while(t < maxD)\n    {\n        vec2 mapSample = map(ro+rd*t);\n        if(mapSample.x > 0.)\n            return vec2(t-(abs(mapSample.x)/(abs(mapSample.x)+abs(lastVal)))*stepSize, mapSample.y);\n        t+=stepSize;\n        stepSize*=1.01;\n        lastVal = mapSample.x;\n    }\n    \n    return vec2(maxD, 0);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.01;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p).x;\n    vec3 grad = vec3(val - map(p - x).x, val - map(p - y).x, val - map(p - z).x);\n    return -normalize(grad);\n}\n\n\nvec3 lighting(vec3 n)\n{\n    return  max(pow(dot(normalize(lightDir), n), 3.), 0.0) * lightColor +ambientLight;\n}\n\nvec3 doFog(vec3 rgb, float dist, float maxD, vec3 rd, vec3 p)\n{\n    lightDir = normalize(lightDir);\n    vec3 fogColor = vec3(0.12, 0.11, 0.13)*.5;\n    fogColor += 2.*vec3(.7, .1, 0)*pow(1.-abs(rd.y), 6.);\n    fogColor += .3*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 3.);\n    fogColor += 4.*vec3(.7, .1, 0)*clamp(2.-p.y, 0., 1.);\n    if(dist == maxD)\n    {\n    \tfogColor += vec3(.5, .4, .5)*smoothNoise(vec2(p.x, p.z)/rd.y/3000.)*smoothNoise(vec2(p.x, p.z)/5./rd.y/3000.)*pow(abs(rd.y), .5);\n        fogColor += .4*lightColor*pow(clamp(dot(rd, lightDir), 0., 1.), 50.); \n    }\n    return mix(rgb, fogColor, pow(dist/maxD, 1.));\n}\n\nvec3 fcknLAVA(vec3 p)\n{\n    float morph = sin(iTime+p.x+p.z)*smoothNoise(p.xz/10.); \n    \n    vec3 n = normal(p);\n    vec3 base = vec3(0);//lighting(n)*.5;\n    p+=vec3(cos(morph), 0, sin(morph));\n    base += vec3(.7, .1, 0)*smoothNoise(p.xz/10.+iTime/55.);\n    base += 2.*vec3(.7, .4, 0)*pow(smoothNoise(p.xz/10.+iTime/55.), 10.);\n    base += 2.*vec3(.7, .7, .7)*pow(smoothNoise(p.xz/10.+iTime/55.), 30.);\n    \n    return base;\n}\n\nvec3 terrainColor(vec3 p)\n{\n    vec3 n = normal(p);\n    float xAlpha = pow(abs(n.x), 2.);\n    float yAlpha = pow(abs(n.y), 7.);\n    float zAlpha = pow(abs(n.z), 2.);\n    vec3 terrainColor = vec3(0);\n    terrainColor += texture(iChannel0, vec2(p.z, p.y)/7.).xyz*xAlpha*.5;\n    terrainColor += .3*texture(iChannel1, vec2(p.x, p.z)/10.).xyz*yAlpha;\n    terrainColor += .2*texture(iChannel1, vec2(p.x, p.z)/3.).xyz*yAlpha;\n    terrainColor += texture(iChannel0, vec2(p.x, p.y)/7.).xyz*zAlpha*.5;\n    terrainColor+=texture(iChannel0, vec2(0, p.y)/3.).xyz*.2;\n    return terrainColor*lighting(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -  iResolution.xy*.5)/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float lastXInput = 0.;\n    float lastYInput = 0.;\n    float deltaXInput = iMouse.x-lastXInput;\n    float deltaYInput = iMouse.y-lastYInput;\n    camRot+=vec3(deltaYInput/100., deltaXInput/100., 0);\n    vec3 camP = vec3(50, 5., 170.);\n    vec3 camDir = normalize(vec3(sin(camRot.y), sin(camRot.x), cos(camRot.y)));\n    vec3 camRight = cross(camDir, vec3(0, 1., 0));\n    vec3 rd = normalize(camDir + camRight*1.*uv.x + vec3(0,1.,0)*1.*uv.y);\n    vec2 rayResult = ray(camP, rd, .3, maxDist, 0.1);\n    vec3 p = camP+rd*rayResult.x;\n\tvec3 col = vec3(0);\n\n    col = doFog(mix(fcknLAVA(p), terrainColor(p), clamp(p.y-1.1, 0., 1.)), rayResult.x, maxDist, rd, p);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    lastXInput = iMouse.x;\n    lastYInput = iMouse.y;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 173, 173, 223], [225, 225, 252, 252, 623], [625, 625, 648, 648, 677], [679, 679, 703, 703, 752], [754, 754, 772, 772, 1480], [1483, 1483, 1604, 1604, 1964], [1966, 1966, 1987, 1987, 2263], [2266, 2266, 2289, 2289, 2378], [2380, 2380, 2443, 2443, 3015], [3017, 3017, 3040, 3040, 3446], [3448, 3448, 3475, 3475, 4040], [4042, 4042, 4099, 4149, 5076]]}
{"id": "wl2GD1", "name": "Hex1", "author": "cdhanna92", "description": "I dunno, its trippy to stare at....", "tags": ["test"], "likes": 4, "viewed": 104, "published": "Public", "date": "1559447222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat hexDist(vec2 n) {\n\tn = abs(n);\n    float c = dot(n, normalize(vec2(1., 1.73)));\n    c = max(c, n.x);\n    return c;\n}\n\nbool inHex(vec2 n, float r) {\n\treturn hexDist(n) < r;// && hexDist(n) > r-.05;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat s = 20. + 15. * sin(cos((iTime * .5)));    \n    float r = .5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n\n    uv -= vec2(1. + .15 *cos(iTime * .2), .5 + .15*sin(iTime * .3));\n    uv = rotate(uv, 6.28 * fract(.1 * iTime));\n    \n    \n    vec2 hex = vec2(1., 1.73);\n    vec2 halfHex = hex * .5;\n    \n    \n    vec2 f1 = mod(uv * s, hex) - halfHex;\n    vec2 f2 = mod(uv * s - halfHex, hex) - halfHex;\n    \n    vec2 gv;\n    if (length(f1) < length(f2)){\n    \tgv = f1;\n    } else {\n    \tgv = f2;\n    }\n    vec2 id = (uv * s) - gv;\n\n    vec3 col = vec3(0.);\n    \n    float r2 = cos(.5*iTime+id.x+id.x*id.x+id.y*cos(id.x * id.y)) * r;\n    float r3 = sin(.5*iTime-id.x-id.x*id.x-id.y) * r;\n    \n    col.rg = (id.xy+s) * (1./s);\n  \tcol.rg *= cos(col.rg) / sin(col.rg);\n    \n    col.rgb *= inHex(gv, r2) ? 1. : .5; \n    col.rgb -= inHex(gv, r - .05) ? .5 : 0.;\n    \n    col.b = cos(col.r) * .25;\n    \n    col.rgb += .5 + .25 * cos(iTime * .1);\n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2GD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 32, 32, 116], [118, 118, 141, 141, 240], [242, 242, 271, 271, 322], [325, 325, 382, 382, 1427]]}
{"id": "wl2GD3", "name": "Noise through Voronoi Iterations", "author": "badjano", "description": "Visualization of noise through voronoi iterations using hashes", "tags": ["voronoi", "noise"], "likes": 1, "viewed": 81, "published": "Public", "date": "1561405984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float seed) {\n    return fract(sin(dot(seed, 78.233)) * 437585.453123);\n}\nvec2 hash2(vec2 p ) {\n   return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n}\n\nfloat voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float md = 5.0;\n    vec2 m = vec2(0.0);\n    const int _size = 1;\n    for (int i = -_size;i<=_size;i++) {\n        for (int j = -_size;j<=_size;j++) {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n+g);\n            o = 0.5+0.5*sin(iTime+5.038*o);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d<md) {\n              md = d;\n              m = n+g+o;\n            }\n        }\n    }\n    return md;\n}\n\nfloat ov(vec2 p) {\n    float v = 0.0;\n    float a = 0.15;\n    float s = (sin(iTime)*.5+.5);\n    for (int i = 0;i<8;i++) {\n        vec2 randVec = hash2(vec2(float(i),rand(float(i)))) * s * 2.;\n        v+= voronoi(p+randVec)*a;\n        p*=1. + 1.*s;\n        a*=0.999;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    vec4 a = vec4(0.0);\n    vec4 b = vec4(1.0);\n\tfragColor = vec4(mix(b, a, smoothstep(0.0, 0.5, ov(uv*5.0))));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2GD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 84], [85, 85, 106, 106, 206], [208, 208, 231, 231, 723], [725, 725, 743, 743, 1012], [1014, 1014, 1071, 1071, 1243]]}
{"id": "Wl2GDh", "name": "The Red Sea", "author": "Yusef28", "description": "Heavily based on: https://www.pinterest.ca/pin/290693350948093294/\n\nMy main learning Resource: https://thebookofshaders.com", "tags": ["2d", "waves", "red", "scene", "gold"], "likes": 30, "viewed": 389, "published": "Public", "date": "1559419826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------\n// Created by Shadertoy user Yusef28 - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//random function https://thebookofshaders.com/10/\nfloat rnd(vec2 p)\n{\n return fract(sin(dot(p, vec2(12.9898, 78.233)))*43562.1343523);   \n}\n\n\n// \"wave\" function creates a basic wave \n//p = position, \n//h = height, \n//f = wave frequency, \n//amp = wave amplitude \nfloat wave(vec2 p, float h, float f, float amp)\n{\n    p.y+=sin(p.x*f+iTime*2.)/amp;//+0.2; //shifts y\n    float wave = 1.0-smoothstep( h, h+0.005, p.y);\n    //float waveedge = 1.0- (wave+step(s+0.2, p.y));\n    return clamp(wave, 0., 1.);\n}\n\n\n// \"waveedge\" function creates edge for basic wave \n//p = position, \n//h = height, \n//f = wave frequency, \n//amp = wave amplitude \nfloat waveedge(vec2 p, float h, float f, float amp)\n{\n    p.y+=sin(p.x*f+iTime*2.)/amp;\n    float wave = smoothstep(p.y, p.y+0.005, h);\n    float waveedge = 1.0- (wave+smoothstep(h, h+0.005, p.y));\n    return waveedge;\n}\n\n\n// \"line\" function creates wave lines\n//p = position, \n//s = height, \n//f = wave frequency, \n//amp = wave amplitude \n//h = height\n//th = line thickness!\n\nfloat lines(vec2 p, float h,float f, float amp, float th, float num)\n{\n    p.y+=sin(p.x*f+iTime*2.)/amp-0.;\n    float wavelines = smoothstep(th,th+0.2, abs(sin(p.y*num)));\n    float linecut = wavelines - smoothstep(h,h+0.00, p.y);\n    \n    //I had to add texture to the waves here or else the teextures move\n    //at a different timing and it looks wierd\n    //I had to multiply p by a large value or the texture doesn't fill the\n    //lines properly\n    //I had to multiply instead of add because, well try adding it's\n    //actually pretty cool.\n    return max(linecut, 0.0)*vec3(texture(iChannel2, p*20.)).x*2.1;\n}\n\n\n//clamps are added to prevent negative numbers.\n\nvec3 makeWaves(vec2 p)\n{\n    \n    //making the sky here because this function returns the initial col\n    //so nothing can be added behind it, as far as I know.\n    \n    //everything I write is only as far as I know by the way.\n    \n    vec3 col = vec3(.0)+texture(iChannel1, vec2(p.x+iTime/4., p.y)).x*p.y/20.;\n    col+=vec3(55., 5., 5.)/255.*pow(texture(iChannel3, vec2(p.x+iTime/8., p.y)).x, 20.0)*1.3;\n    col+=vec3(102., 15., 5.)/255.*pow(texture(iChannel0, vec2(p.x+iTime/16., p.y)).x, 10.0)*2.;\n    \n    p.y+=0.5; //p.y+=0.3;\n    //p.y+=sin(p.x*4.-1.2)/4.;\n    p.y+=sin(p.x*7.-1.2+iTime)/14.;\n    \n\n    //initial wave variables, height, frequency, amplitude, \n    //line thickness, line number\n    float h = 0.99;\n    float f = 8.;\n    float amp = 9.;\n    float th = 0.2;\n    float num = 200.;\n    \n    //creating a wave, an edge line, and inner lines\n    float w = wave(p, h, f, amp);\n    float we = waveedge(p, h, f, amp);\n    float l = lines(p, h, f, amp, th, num);\n   \n\n    //going for 20 waves total\n    for(float i = 1.0 ; i<20. ; i++){  \n        \n        //random seed to make waves different\n        float seed = rnd(vec2(i))*100.;\n    \th-=i/300.; //random scaleing of i and then subtracting to lower the waves a bit\n    \tf=seed/6.+2.;//using seed to help create variation in wave frequency\n    \tnum=250.-seed*1.; //seed for variation in number of inner lines\n    \tfloat th2 = th+f/45.; //using frequency(which has the seed applied to it) \n        //to createrandomess in line thickness, jsut a tiny bit actually\n\n            \n      \tvec3 gold = vec3(202., 165., 55.)/255. //a nice gold color from the internet\n        *texture(iChannel0, vec2(p.x+seed, p.y)/6.).x*1.2;//mult by the first texture to give\n        //it a more metallic look.\n        \n\n\t\t//creating a wave, an edge line, and inner lines that MIGHT be used \n    \t//depending on the seed being > 25.\n        \n        //these are only used at the end of the function, this part\n        //could be done more simply and I wouldn't need an w2, we2, or l2 at all.\n      \t\n    \tfloat w2 = wave(p, h, f, amp);  \n    \tfloat we2 = waveedge(p, h, f, amp);\n    \tfloat l2 = lines(p, h, f, amp, th2, num);\n        \n\n\t//adding a wave to the scene\n    col = mix(clamp(col, 0., 1.), vec3(0.4, .0, .0)*p.y*0.9, clamp(w, 0.0, 1.0));\n    \n    //adding a gold edge to the scene were the wave is    \n    col = mix(clamp(col, 0., 1.), gold, we);\n        \n        if(seed > 35.)\n        {\n            //adding golden inner lines to the wave only 1/4 of the time\n            col = mix(clamp(col, 0.0, 1.0), vec3(gold),l); \n        }\n       \n        \n    //this is not nessesary but it basically holds the wave, edge and line of each previous\n    //for loop. I was using as part of a stratety for adding waves to the \n    //scene with different opacity amounts, but it's not nessesary any more\n    //but I keep it just to not have to make any more adjustments\n    w = w2;\n    we = we2;\n    l = l2;\n       \n       \n    \n    }\n    \n    return col;\n    \n}\n\nfloat makeMoon(vec2 p)\n{\n    float moon =1.0-smoothstep(0.1, 0.105,length(vec2(p.x-1.5, p.y-0.82))); \n    \n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  //clamping the sin so I get a nice \n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  //pause at the cresent\n    float space =1.0-smoothstep(0.1, 0.105,length(vec2(p.x-1.55-  clamp(sin(iTime/5.)/5., 0.0, 1.0), p.y-0.82))); \n\n return    clamp(moon-space, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;//for vignetting\n    \n\n    vec3 col = vec3(.1);//*texture(iChannel1, uv).x*uv.y;// 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 gold = vec3(202., 165., 55.)/255.;\n\n    //creates all the waves AND the sky since its behind the waves and the waves\n    //return most of the color for the whole scene.\n    col = makeWaves(uv);\n    \n    //creates a full move and a moving circle that subtracts from it to create\n    //the moon animation\n    vec3 moonCol = vec3(202., 165., 55.)/255.*texture(iChannel1, vec2(uv.x+sin(iTime*14.)/200., uv.y)).x;\n    \n    //I find I only needed to change resolution for the creation of the\n    //moove because it needs to be a circle so I put this at the very end.\n    //usually you would do this at the start of the scene but because I didn't \n    //I only felt like tacking it on later.\n    uv.x*=iResolution.x/iResolution.y;\n    col = mix(col, moonCol, makeMoon(uv) );\n    \n    \n    //vignetting using a copy of uv from the top of main to keep the dimentions.\n    st *=  1.0 - st.yx;\n    float vig =st.x*st.y*15.;\n    vig = pow(vig, 0.25);\n    \n    \n    // Output to screen\n    fragColor = vec4(col*2.*vig,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GDh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 294, 313, 313, 383], [386, 506, 555, 555, 745], [748, 879, 932, 932, 1099], [1102, 1256, 1326, 1326, 1873], [1876, 1925, 1949, 2152, 4929], [4931, 4931, 4955, 4955, 5296], [5299, 5299, 5356, 5406, 6609]]}
{"id": "Wl2GR3", "name": "Water with anti aliased lines", "author": "Pilo", "description": "Lines drawn over a water heightmap\n\nThe water comes from TDM Seascape shader: https://www.shadertoy.com/view/Ms2SD1", "tags": ["lines", "water", "smoothing"], "likes": 34, "viewed": 697, "published": "Public", "date": "1560532651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst float lineDistance = 0.25;\nconst float cameraHeight = 8.0;\nconst float cameraAngle = 0.8; // radians\n\n// sea\nconst int ITER_GEOMETRY = 2;\nconst float SEA_HEIGHT = 1.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\n\n\n\n\n\n\nconst int NUM_STEPS = 8;\n\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    float n = texture(iChannel0, uv).r;\n    \n    // ray\n    vec3 ang = vec3(0, cameraAngle, 0);    \n    vec3 ori = vec3(0, cameraHeight, 0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n             \n    // color    \n    float coord = p.z / lineDistance;\n    float c = abs(fract(coord) - 0.5) / fwidth(coord);\n    \n    c = 1.0 - min(c, 1.0);    \n    c = pow(c, 1.0 / 2.2);\n    \n\tfragColor = vec4(c);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[659, 667, 693, 693, 1039], [1040, 1040, 1062, 1062, 1142], [1143, 1143, 1169, 1169, 1470], [1472, 1479, 1520, 1520, 1691], [1693, 1693, 1712, 1712, 2156], [2159, 2159, 2215, 2215, 2727], [2729, 2737, 2794, 2794, 3374]]}
{"id": "wl2GRc", "name": "trying to seperate the sectors ", "author": "gchipunov", "description": "seperate stuff", "tags": ["timebased"], "likes": 1, "viewed": 65, "published": "Public", "date": "1560593955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nif(uv.x > 0.5)\n{\n uv.x = uv.x + 1.0;   \n}\n    else if(uv.x < uv. y)\n    {\n        uv.y = uv.x + 1.0;    \n    }\n    else if(uv.x  > 0.5)\n    {\n        uv.x = 0.4;\n    }\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2GRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 461]]}
{"id": "wl2GRG", "name": " Double Sided Quad Truchet", "author": "Shane", "description": "Recreating BigWIngs's double arc quad Truchet weave pattern, with some minor changes thrown in.", "tags": ["bezier", "square", "truchet", "pattern", "quad", "weave"], "likes": 25, "viewed": 828, "published": "Public API", "date": "1560347608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\t Double Sided Quad Truchet\n\t--------------------------\n\n\tBigWIngs posted a really interesting weave pattern the other day that I wanted to\n    recreate for my own amusement. I like it because the premise is incredibly simple, \n\tbut\tit leads to visually entertaining results -- In fact, I'm amazed at just how\n    much variation it provides. The link to his orginal example is below.\n\n\tThe idea is very simple: Instead of rendering two sets of arcs connecting the\n    midpoints of the grid cell boundaries (like with a standard Truchet arc pattern), \n\tdouble the connecting points on each edge, then connect four arc-like segments\n    between them -- Bezier curves are a good option, but not mandatory. The four \n\tcurve segments each connect random pairs of entry and exit points, which result \n\tin the crazy spaghetti pattern you see. :)\n\n\tBigWIngs rendered some presets and left the overall random pattern rendering as \n\tan exercise to the reader, so I gave it a go. I had to think about it for a while, \n\tbut then realized all that was required was to shuffle an array of 8 points, \n\tthen render the shuffled pairs. It seems to work, but I'm open to suggestion, if \n\tthere's a better way.\n\n    I also went out of my way to append smooth Bezier curves, which look fine, but my \n\tmethodology was a bit hacky, so I'm hoping BigWIngs, or someone else, will come up \n\twith something more robust.\n\n\tI didn't spend a great deal of time prettying this up, so I'm not sure what style\n\tthis is rendered in. Art deco grunge? :) I might bump map it later to make it pop\n\tout a bit more, or make a 3D version. By the way, if you wanted to produce a 3D \n\textruded version, you'd probably have to replace the Bezier curves with a mixture \n\tof arcs and lines, which would be much faster.\n\n\n\tBased On:\n\n\tCube-mapped Double Quad Truchet - BigWIngs\n\thttps://www.shadertoy.com/view/wlSGDD\n\n\n*/\n\n// The textured version. Without it, the look is cleaner, which makes the pattern\n// a little easier to discern. Sometimes, I prefer it.\n#define USE_TEXTURE\n\n// This will change the spacing of the boundary connecting points to loosen the weave \n// a little. I like it more, but I left the standard look as the default.\n//#define LOOSE_WEAVE\n\n// Grid outlines, which allows the viewer to see the individual tiles... and spoils\n// the illusion. :)\n//#define SHOW_GRID\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.917, 57.543)))*43758.5453); }\n\n// vec4 swap.\nvoid swap(inout vec4 a, inout vec4 b){ vec4 tmp = a; a = b; b = tmp; }\n\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout vec4 a, inout vec4 b){ a = a + b; b = a - b; a = a - b; }\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n    \n    \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.35, .5, .65), vec3(.25, .1, .02), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*(1.4142 - 1.)/1.4142;\n    // Segments between edge points need to be refactored. Comment this out to\n    // see why it's necessary.\n    if(abs(length(b.xy - a.xy) - r*2.)<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier arc from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :D\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\nvec4 DoubleQuadTruchet(vec2 p){\n    \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    \n    \n    \n    // Positioning the connecting points around the square grid cell. \"r\" is an offset\n    // from the mid point, which controls the tightness of the pattern. The value\n    // \".25\" gives the most even spread, whereas something like \".175\" will give\n    // a tighter looking loop pattern.\n    //\n    // The first two entries of the vec4 represent the positions, and the remaining\n    // two are their edge normals, which, by the way, would be easy enough to \n    // calculate, but I thought hardcoding them in would be easier.\n    //\n    // Only range values between .18 and .32 will work with this configuration. Larger ranges\n    // would work, but you'd have to render surrounding cells also to account for neighboring\n    // cell infringement.\n    float r = .25; \n    #ifdef LOOSE_WEAVE\n    r = .2;\n    #endif\n    vec4[8] pnt = vec4[8](vec4(-r, .5, 0, -1), vec4(r, .5, 0, -1), vec4(.5, r, -1, 0), vec4(.5, -r, -1, 0),\n                         vec4(r, -.5, 0, 1), vec4(-r, -.5, 0, 1), vec4(-.5, -r, 1, 0), vec4(-.5, r, 1, 0));\n    \n     \n    // Shuffling the 8 array points and normals. Afterward, the four array pairs should\n    // be rendered randomly. This also means the rendering order should be randomized,\n    // which is an added bonus. I think this is the FisherâYates method, but it's been \n    // a while since I've used a shuffling algorithm, so if there are inconsistancies, \n    // etc, feel free to let me know.\n    //\n    // There'd be some combinations, like four corner arcs, etc, that would be rendered \n    // more often, since lack of overlap would mean that different rendering orders would\n    // result in the same tile combination. However, as a general rule, this method works\n    // well enough. I mean, you could start including weighted distribution for certain \n    // arrangements... but who wants the extra headache? :)\n    //\n    for(int i = 7; i>0; i--){\n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        float rs = hash21(ip + fi/8.); // Random number.\n        //int j = int(floor(mod(rs*8e5, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(pnt[i], pnt[j]);\n         \n    }\n    \n    // Render all four connecting arc segments.\n    vec4 d;\n    \n    d.x = doSeg(p, pnt[0], pnt[1], r);\n    d.y = doSeg(p, pnt[2], pnt[3], r);\n    d.z = doSeg(p, pnt[4], pnt[5], r);\n    d.w = doSeg(p, pnt[6], pnt[7], r);\n    \n    return d; // The Truchet tile distance field value.\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n    \n    // Scaling and translation.\n    const float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 2./iResolution.y*gSc;\n    \n    // Scaling and translation.\n    vec2 p = uv*gSc + vec2(1, 0)*iTime;\n \n    // Grid fields: Square and diamond.\n    vec2 grid;\n    vec2 p2 = abs(fract(p) - .5);\n    grid.x = abs(max(abs(p2.x), abs(p2.y)) - .5); // Square grid.\n    grid.y = abs((abs(p2.x) +  abs(p2.y)) - .5*.7071); // Diamond background.\n    \n    \n    // The pattern itself.\n    vec4 d = DoubleQuadTruchet(p);\n    d -= .155; // Give the pattern some width.\n \n    // Background, line and edge colors. \n    vec3 col = vec3(1, .8, .6);\n    vec3 lCol = vec3(1, .95, .9);\n    vec3 eCol = vec3(1, .8, .6);\n    \n    // Subtle coloring, based on pixel height. I was going for an oxidized copper\n    // tone, so that kind of does it. :)\n    lCol = mix(lCol, lCol.yxz, -uv.y*.35 + .35);\n    eCol = mix(eCol, eCol.yxz, -uv.y*.2 + .2); \n    col = mix(col, col.yxz, -uv.y*.35 + .35);    \n    \n\t// Concentric diamond background pattern.\n    float pat = clamp(cos(grid.y*6.2831*8.), 0., 1.);\n    col *= 1. -  pat*.9;\n    \n    #ifdef USE_TEXTURE\n        \n        // Applying the pattern to the line element. Comment it out to give a\n        // a cleaner pattern look.\n        lCol *= vec3(.3, .45, .55) +  pat;\n        \n        // Home made texture algorithm... Sufficient for this example,\n        // but not my best work. :)\n        vec3 tx = GrungeTex(p/gSc);\n        vec3 tx2 = GrungeTex(p/gSc + 6.5);\n\n        // Apply the texture.\n        col *= min(tx2*4., 1.);\n        lCol *= min(tx*1.5, 1.);\n        eCol *= min(tx2*6., 1.);\n\n        float sAlpha = .75; // Darker texture shadowing.\n    #else\n \n        float sAlpha = .5; // Lighter shadowing when not using a texture.\n    #endif\n    \n\n    // Render the four arcs. Layers include shadowing, strokes, inner strokes,\n    // coloring, etc.\n    for(int i = 0; i<4; i++){\n       \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., d[i] - .01))*sAlpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i]))*.9);\n        col = mix(col, eCol, 1. - smoothstep(0., sf, d[i] + .03));\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d[i] + .09))*.9);\n        col = mix(col, lCol, 1. - smoothstep(0., sf, d[i] + .12));\n    }\n    \n    \n    // Displaying the grid.\n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., grid.x - .025))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid.x - .025))*.9);\n    col = mix(col, vec3(1, .9, .8)*1.2, (1. - smoothstep(0., sf, grid.x - .005))*.9);\n    #endif\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.xzy, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625));\n  \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2GRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2349, 2382, 2402, 2402, 2460], [2462, 2494, 2515, 2515, 2577], [2579, 2593, 2631, 2631, 2663], [2862, 3086, 3105, 3105, 3310], [3313, 3339, 3371, 3371, 3435], [3437, 3697, 3720, 3793, 4548], [4551, 4735, 4784, 4980, 6464], [6466, 6959, 7004, 7031, 8017], [8019, 8019, 8050, 8050, 10771], [10774, 10774, 10828, 10876, 13869]]}
{"id": "Wl2GWy", "name": "f(z) = i^z + c", "author": "JJJK", "description": "https://www.reddit.com/r/math/comments/c2fiql/a_very_interesting_fractal/\n\nQuick&dirty shadertoy \"port\".", "tags": ["fractalsmandelbrot"], "likes": 9, "viewed": 607, "published": "Public API", "date": "1560963003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMade by reddit user /u/jpayne36\n*/\n\nfloat scale = 1.0 / 128.0;\nvec2 pos = vec2(0.0, 0.0);\n\nfloat e = 2.718281828459045;\nfloat pi = 3.14159265;\n\nstruct cmplx { float r; float i; };\ncmplx c() { return cmplx(0.0, 0.0); }\ncmplx c(float r) { return cmplx(r, 0.0); }\ncmplx c(float r, float i) { return cmplx(r, i); }\n\ncmplx add(cmplx c1, cmplx c2) { return cmplx(c1.r + c2.r, c1.i + c2.i); }\ncmplx sub(cmplx c1, cmplx c2) { return cmplx(c1.r - c2.r, c1.i - c2.i); }\ncmplx mul(cmplx c1, cmplx c2) { return cmplx(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r); }\ncmplx div(cmplx c1, cmplx c2)\n{\n\tif (c2.r == 0.0 && c2.i == 0.0) { return c(); }\n\treturn cmplx( (c1.r*c2.r + c1.i*c2.i)/(c2.r*c2.r + c2.i*c2.i), (c1.i*c2.r - c1.r*c2.i)/(c2.r*c2.r + c2.i*c2.i) );\n}\n\nfloat c_abs(cmplx c) { return sqrt(c.r*c.r + c.i*c.i); }\ncmplx c_pow(cmplx c1, cmplx c2)\n{\n\tif (c1.r == 0.0 && c1.i == 0.0) { return c(); }\n\tfloat r, a, c, d;\n\tr = c_abs(c1);\n\tif (c1.r == 0.0) { a = pi / 2.0; } else { a = atan(c1.i/c1.r); }\n\tc = ( pow(r, c2.r) )/( pow(e, c2.i*a) );\n\td = c2.i*log(r) + c2.r*a;\n\treturn cmplx(c*cos(d), c*sin(d));\n}\n\nint mandelbrot(cmplx a, cmplx z, int iters)\n{\n\tfor (int i = 0; i < iters; i++)\n\t{\n\t\tif (c_abs(z) > 100.0) { return i; }\n\t\tz = add( c_pow(c(0.0,1.0), z), a );\n\t}\n\treturn iters;\n}\n\nvec4 effect(vec2 screen_coords)\n{\n\tvec2 uv = screen_coords/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec2 xy = vec2( (uv.x - iResolution.x/iResolution.y/2.0)/scale + pos.x, (uv.y - 0.5)/scale + pos.y );\n\tint a = mandelbrot( c(xy.x, xy.y), c(), 100 );\n\tfloat col = float(a)/100.0;\n\treturn vec4(vec3(col), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = sin(iTime*0.2)*0.5 + 0.5;\n    pos = vec2(0.0, -0.2);\n    float maxZoom = exp(9.5);\n    scale = mix(1.0/128.0, maxZoom/128.0, f);\n    \n    fragColor = effect(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 183, 194, 194, 220], [221, 221, 239, 239, 263], [264, 264, 291, 291, 313], [315, 315, 346, 346, 388], [389, 389, 420, 420, 462], [463, 463, 494, 494, 556], [557, 557, 588, 588, 754], [756, 756, 778, 778, 812], [813, 813, 846, 846, 1102], [1104, 1104, 1149, 1149, 1281], [1283, 1283, 1316, 1316, 1607], [1609, 1609, 1666, 1666, 1851]]}
{"id": "Wl2Gzc", "name": "Flat water effects 2", "author": "mrange", "description": "Continuation of my work on flat water effects here: https://www.shadertoy.com/view/ttSGRc\nWanted analytical normals for improved precision\n", "tags": ["raytracing", "fbm"], "likes": 17, "viewed": 1101, "published": "Public API", "date": "1560550686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\n// Color computation inspired by: https://www.shadertoy.com/view/Ms2SD1\n\n// Computes normal analytical for improved precision\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3);\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3);\nconst vec3 sunCol1 =  vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 =  vec3(1.0,0.8,0.7);\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nmat2 mrot(in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nmat2 mtrans(in mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  float k = 1.0;\n  float kk = 1.3;\n  float a = ia*0.19;\n  float aa = 1.0/(kk*kk);\n\n  float h = 10.0;\n  p *= 0.5;\n  \n  float angle = 0.0;\n\n  for (int i = 0; i < 3; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += gravityWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = gravityWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n\n  for (int i = 3; i < 7; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += capillaryWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = capillaryWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n  \n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.13, 1));\n  return dir;\n}\n\nvec3 skyColor(vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol1*pow(sunDot, 30.0);\n\n  final += 4.0*sunCol2*pow(sunDot, 300.0);\n    \n  return final;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2Gzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[168, 577, 636, 636, 702], [704, 704, 764, 764, 838], [840, 840, 906, 906, 980], [982, 982, 1050, 1050, 1147], [1149, 1149, 1216, 1216, 1291], [1293, 1293, 1362, 1362, 1460], [1462, 1462, 1485, 1485, 1555], [1557, 1557, 1581, 1581, 1634], [1636, 1636, 1670, 1670, 2703], [2705, 2705, 2726, 2726, 2784], [2786, 2786, 2810, 2810, 3067], [3069, 3069, 3124, 3124, 4273]]}
{"id": "wl2Gzt", "name": "Divine Spider", "author": "anclin", "description": "Divine Spider", "tags": ["spider", "divine"], "likes": 2, "viewed": 116, "published": "Public", "date": "1560797271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat SinLerp(float min, float max, float t) {\n \treturn mix(min, max, sin(t) * 0.5 + 0.5);   \n}\n\nfloat Sin01(float t) {\n \treturn SinLerp(0., 1., t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv,0);\n    \n    float t = iTime * .3;\n    \n    // polar\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    st.x = st.x/6.28+0.5;\n\tcol = vec3(st.x);\n    \n    \n    //st.x += st.y * SinLerp(0., 2., iTime);\n    uv = st;\n    \n    \n    \n    // zig zag\n    float p = 1.; // petals\n    float x = uv.x * p;// + t * 0.5;\n    float y = uv.y * SinLerp(.2, 1., t);\n    \n    // RINGS\n    float r = y + sin( uv.y * 7. * SinLerp(1., 2., t) - t*3.5);\n    // FLOWER\n    float z = min(fract(x), fract(1.-x)); \n    \n    \n    col = vec3(z);\n    col = vec3(r + z);\n    float s = 20.;//SinLerp(4., 15., t); // split of the petal\n    //col = vec3(r + fract( z * s) );\n    col = vec3(fract(r + fract( z * s) ));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Gzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 47, 47, 96], [98, 98, 120, 120, 151], [154, 154, 211, 261, 1129]]}
{"id": "wlB3Wc", "name": "IFS with scaling", "author": "edo_m18", "description": "IFS with scaling", "tags": ["ifs"], "likes": 3, "viewed": 132, "published": "Public", "date": "1561347847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define repeat(p, span) mod(p, span) - (0.5 * span)\n\nconst float pi = acos(-1.);\nconst float pi2= pi * 2.;\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 z = p;\n    \n    float scale = 2.0;\n    float sum = scale;\n    float d = 1e5;\n    \n    float time = abs(sin(iTime * 0.5) * 4.0);\n    float s = min(floor(time), 3.0) + 1.0;\n    \n    for (float i = 0.; i < s; i++)\n    {\n        float td = sdBox(z, vec3(0.5)) / sum;\n        \n        z = abs(z) - vec3(0, 2.0, 0);\n        d = min(td, d);\n        \n        z.xy *= rot(pi * 0.25);\n        z *= scale;\n        sum *= scale;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n\n    float dist = 5.0;\n    vec3 ro = vec3(cos(iTime) * dist, 1, sin(iTime) * dist);\n    vec3 ta = vec3(0, 0, 0);\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.8));\n    \n    vec3 p = ro;\n    float d = 0., t = 0.;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n = normal(p) * 0.5 + 0.5;\n        col = n;\n    }\n    else\n    {\n        col = vec3(0.5, 0.8, 1.5) * abs(uv.y * 0.5 - 1.0) ;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlB3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 127, 127, 193], [195, 195, 226, 226, 400], [402, 402, 431, 431, 474], [476, 476, 495, 495, 948], [950, 950, 971, 971, 1148], [1150, 1150, 1207, 1207, 1854]]}
{"id": "wlB3WW", "name": "Shape migration", "author": "mosaic", "description": "Adjustment of circle position via \"for loop\".\nThe layering and transparency creates some interesting shapes. \nIt was a bit annoying to centre. \nDoes this kind of effect have a name? ", "tags": ["2d"], "likes": 4, "viewed": 179, "published": "Public", "date": "1559598059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord/2.0  - 0.1 * iResolution.xy) / iResolution.y+0.35;\n \n    //background gradient colour\n    float pct = 1.8-st.y*1.6;\n     \n    //the loop repeats 50 times, so there are 50 circles drawn in total\n    for(int i=0; i<50;i++){\n        //change i to float so I can multiply by it\n        float i_float = float(i);\n        //here the circle function is called. The location of each circle is \n        //adjusted by the sin of the time value.\n        //The 50 circles are in different positions because the incremented i_float \n        //value is used:\n    \tpct += circle(st+(0.2*sin(iTime/3.-i_float*st.yx)),0.001)*st.y*1.5;\n    }\n \n\tpct=pct-1.;\n\n    // Output to screen, adjust colour\n    fragColor = vec4(pct+.1,pct+.1,pct,1.0)*vec4(0.9,0.,0.,0.)+vec4(0.,0.0,0.3,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlB3WW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 218], [220, 220, 277, 277, 1067]]}
{"id": "wlB3zG", "name": "Awesome McCool Fractal", "author": "wyatt", "description": "iterate : ln(z) -> z^n -> e^z", "tags": ["fractal", "complexnumbers"], "likes": 9, "viewed": 425, "published": "Public API", "date": "1559969606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 mul(vec2 a, vec2 b) {\n\treturn  mat2(a,-a.y,a.x) * b;\n}\nvec2 e (vec2 a) {\n\treturn exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\nvec2 ln (vec2 a) {\n\treturn vec2(log(length(a)),atan(a.y,a.x));\n}\nvec2 pw (vec2 a, vec2 b) {\n\treturn e(mul(ln(a),b));\n}\nvec2 pw (vec2 a, float n) {\n\tfloat f = n * atan(a.y,a.x);\n    return pow(length(a),n) * vec2(cos(f),sin(f));\n}\nvec4 col (vec2 U) {\n\t#define R iResolution.xy\n    float t = iTime*sqrt(iTime)/50.;\n    U = (U-0.5*R)/R.y;\n    U *= 1.+2./(1.-U.y);\n    U *= 1000.*exp(-fract(t)*17.);\n    float c = cos(iTime), s = sin(iTime);\n    U *= mat2(c,-s,s,c);\n    U.x += .367878;\n    vec2 z = U;\n    float o = mod(floor(t),5.);\n    float n = 2.6;\n    if (o==1.) n = 1.7;\n    if (o==2.) n = -2.1;\n    if (o==3.) n = -2.8;\n    if (o==4.) n = 2.;\n    n += .3*sin(1243.*floor(t));\n    for (float i = 0.; i < 20.; i++) {\n        if (length(z)==0.) return vec4(0);\n    \tz = ln(z);\n        z = pw(z,n);\n        if (length(z)>1e4) return vec4(1);\n        z = e(z);\n    }\n   \treturn min(abs(z.xyxy),1.);\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = 0.25*(\n        col(U+vec2(.5,0))+\n        col(U+vec2(0,.5))+\n        col(U-vec2(.5,0))+\n        col(U-vec2(0,.5))\n    )*exp(-.5*length(U-0.5*R)/R.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlB3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 59], [60, 60, 77, 77, 121], [122, 122, 140, 140, 186], [187, 187, 213, 213, 240], [241, 241, 268, 268, 351], [352, 352, 371, 371, 1021], [1022, 1022, 1063, 1063, 1223]]}
{"id": "wlBGDG", "name": "Blurry Circles", "author": "LJ", "description": "blurry circles", "tags": ["2d", "bokeh", "vfx", "sizecoding", "webgl1"], "likes": 32, "viewed": 966, "published": "Public API", "date": "1561071377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cc by-sa-nc\n// twitter: @LJ_1102\nvoid mainImage(out vec4 c,vec2 f)\n{\n    vec2 w=iResolution.xy,p=f.xy/w.xy*2.-1.,o=p;\n    p.x*=w.x/w.y;\n    vec3 d=vec3(0);\n    float t=iTime*.1,e=length(o),k=o.y+o.x,l,r,a;\n    for(int i=0;i<40;i++)\n        a=float(i),\n        r=fract(sin(a*9.7))*.8,\n        l=length(p=mod(p+vec2(sin(a+a-t),cos(t+a)+t*.1),2.)-1.),\n        d+=pow(mix(vec3(.6,.46,.4),vec3(.25,.15,.3)+vec3(0,k,k)*.25,a/40.),vec3(3.))*(pow(max(1.-abs(l-r+e*.2),0.),25.)*.2+smoothstep(r,r-e*.2,l))\n    ;\n    c.rgb=sqrt(d)*1.4;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBGDG.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[0, 36, 71, 71, 529]]}
{"id": "wlBGR3", "name": "Apollonian modificado v2", "author": "jorge2017a1", "description": "apollonian modificado v2,,,.ver referencia de apollonia", "tags": ["fractal", "apollonianv4"], "likes": 1, "viewed": 61, "published": "Public", "date": "1560473936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu..........y modificado por Jorge flores///---13/jun/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATION 8\n#define tt iTime\n#define time (iTime*0.5)\n\nvec4 orb;\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        float r2 = dot(p,p);\n        \n        \n        orb = min( orb, vec4(abs(p-sin(p)*2.0),r2) );\n        float k =1.5/ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n    \n    \n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\n\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n\n    float d0=apollonian(p*0.41)*5.;;\n    float d1=abs(p.y-0.02);\n    float d3 = box(q+vec3(0.,-2.,0.), 2.9*vec3(3.,2.,2.3));\n    float d = max(d0, d3);\n    d=min(d,d1);\n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n    const vec2 g = vec2(0.001, 0.002);\n    \n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\n                          map(p + e.yyx+g.yyx)-map(p - e.yyx-g.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    \n    vec3 lookat = vec3(time, 1.5, 0.);\n    \n    \n\tvec3 ro = 1.4*vec3(-1., 1.5,-4.5);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-12., 2.0, -7.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.2, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.1, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.10,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.4,0.2,0.5), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.1,1.,0.2)));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 64.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.005, 32.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(5.,5.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(2000.0*exp(-0.74*t),1.0);\n\n     }\n    col=tonemap(col);\n    //col=pow(col,vec3(1.3,1.,1.));\n    \n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    \n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBGR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 239, 265, 265, 572], [574, 574, 601, 601, 700], [706, 706, 725, 725, 925], [927, 927, 952, 952, 1213], [1215, 1215, 1258, 1258, 1512], [1514, 1514, 1579, 1579, 1842], [1844, 1844, 1866, 1866, 2052], [2054, 2054, 2111, 2111, 3891]]}
{"id": "wlBGRd", "name": "Kpl for VS - pic003", "author": "kipol", "description": "shader from cppn", "tags": ["abstractpainting"], "likes": 10, "viewed": 462, "published": "Public API", "date": "1560764254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.035022326, -0.02029945, 0.018505778, 0.012906424) + mat4(vec4(0.05392581969499588, -0.06193741038441658, -1.1496435403823853, -0.13049328327178955), vec4(0.4170045852661133, 0.24073562026023865, 0.570548951625824, 0.8341407179832458), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[1] = vec4(-0.020696174, 0.01385696, 0.026241628, -0.0067616403) + mat4(vec4(0.5619710087776184, 1.042479395866394, -0.8263165354728699, -0.7207739949226379), vec4(-0.8230406641960144, -1.207921028137207, 0.6806169152259827, -0.41663238406181335), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[2] = vec4(-0.0053295377, 0.02197065, 0.0048876614, 0.0005899789) + mat4(vec4(0.05554826557636261, 0.34079623222351074, 0.3709535598754883, 0.5395087599754333), vec4(0.36088061332702637, -0.6958171129226685, 0.18204621970653534, -0.6743152141571045), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\nbufA[3] = vec4(-0.008644993, 0.007726745, 0.02242221, -0.014627838) + mat4(vec4(0.5104420781135559, -0.3727065324783325, -1.0545977354049683, -0.10491696745157242), vec4(1.2406706809997559, 0.561448872089386, -0.9851856827735901, -0.16126567125320435), vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.007247362, 0.012622283, -0.019720739, 0.011773883) + mat4(vec4(0.06966425, -0.0012040122, -0.025521372, -0.12516569), vec4(-0.3381293, 0.012631387, -0.27746472, -0.06554171), vec4(-0.032917544, 0.06844392, 0.123151936, -0.102095895), vec4(-0.052147247, 0.028811751, -0.06843417, -0.29784077)) * bufB[0] + mat4(vec4(-0.09015242, 0.0615919, -0.022696791, -0.30480966), vec4(0.15610561, -0.005024175, -0.011832519, 0.184015), vec4(-0.08307784, -0.046518333, 0.10022456, 0.23117636), vec4(0.13829437, 0.08318428, -0.26868567, 0.13323952)) * bufB[1] + mat4(vec4(0.039565522, -0.032624077, 0.058952555, -0.15231487), vec4(-0.41566014, 0.13312668, 0.019703224, 0.07282753), vec4(0.031147778, 0.006148456, 0.30463007, -0.25047156), vec4(0.008613561, 0.05921119, -0.13342209, 0.26413482)) * bufB[2] + mat4(vec4(0.071540736, -0.14249952, 0.14174163, 0.062436257), vec4(-0.03321534, 0.10969266, -0.07840334, -0.541212), vec4(0.22945553, 0.062921025, -0.22334665, 0.17814787), vec4(0.32972935, 0.15878965, -0.16461177, 0.039970662)) * bufB[3] + mat4(vec4(-0.07641739, -0.30857807, 0.1258147, 0.39333934), vec4(-0.10262366, -0.098083064, -0.2912149, -0.20098038), vec4(-0.034448113, -0.16473004, -0.057463717, 0.23785518), vec4(-0.029662883, -0.28255934, -0.18816389, -0.24314518)) * bufB[4] + mat4(vec4(0.022512669, -0.2569233, -0.055807665, -0.16851768), vec4(-0.3210917, 0.06421914, 0.21113896, 0.14224073), vec4(-0.2649646, -0.068255745, -0.10079774, 0.19466509), vec4(0.123564, 0.14742169, 0.26554993, 0.0864629)) * bufB[5] + mat4(vec4(0.36861688, 0.0068259016, -0.18843073, 0.21423793), vec4(-0.40665212, -0.09753877, -0.05981735, 0.02636262), vec4(-0.19727838, 0.13647856, -0.13922752, 0.02912041), vec4(-0.014155782, 0.2698377, -0.115161195, 0.019997288)) * bufB[6] + mat4(vec4(0.081352726, -0.34743264, -0.1589021, -0.051750056), vec4(0.06587133, -0.0007466777, 0.016626704, 0.13913468), vec4(-0.11469093, -0.13122052, 0.07207088, -0.1031781), vec4(-0.09235611, 0.00017997451, 0.0071550887, 0.049754985)) * bufB[7];\nbufA[1] = vec4(0.030201923, -0.00967173, -0.02110268, 0.00695758) + mat4(vec4(0.1306984, -0.087288216, -0.21257515, 0.19114013), vec4(-0.18554823, 0.043527886, 0.0035406316, 0.103892386), vec4(-0.19419272, -0.089526914, 0.03345922, -0.025755886), vec4(-0.091265514, 0.17757908, 0.14633292, 0.56659347)) * bufB[0] + mat4(vec4(-0.04692455, -0.21622795, 0.086245455, -0.14893286), vec4(-0.2735357, 0.16177818, 0.09531667, 0.2694951), vec4(0.3339596, 0.1645638, 0.47427154, 0.094424725), vec4(0.078508325, 0.13651454, 0.033451382, 0.24305485)) * bufB[1] + mat4(vec4(-0.08266229, -0.23123638, 0.01318958, -0.0035924441), vec4(0.17620404, 0.13716248, 0.0035669922, 0.013860318), vec4(0.13144043, 0.18490058, -0.09724929, -0.09845527), vec4(-0.029824179, -0.11189098, -0.022227257, -0.07742282)) * bufB[2] + mat4(vec4(-0.097029, 0.34879005, 0.020646881, 0.2342826), vec4(-0.052276302, 0.103065416, -0.19271195, -0.025967536), vec4(0.2568858, -0.11760176, -0.32796335, 0.104997136), vec4(-0.106608264, -0.007309273, 0.3773588, 0.1096893)) * bufB[3] + mat4(vec4(-0.18554223, 0.2664043, 0.025777522, -0.116956025), vec4(0.10047355, 0.31516948, -0.084578015, 0.13131186), vec4(-0.025204541, -0.20210506, 0.060159944, 0.18834905), vec4(-0.07815044, -0.030376196, 0.10742265, -0.138959)) * bufB[4] + mat4(vec4(0.039150152, 0.22397216, 0.23127276, -0.2056446), vec4(0.08383801, 0.003165334, 0.14063483, 0.076965995), vec4(-0.098417476, -0.28967816, -0.027819756, -0.1290214), vec4(-0.03151819, 0.035782382, -0.19253162, -0.13054769)) * bufB[5] + mat4(vec4(-0.05035413, 0.08366375, 0.27027875, 0.0050622406), vec4(-0.10975114, 0.0040614624, 0.052506305, 0.267535), vec4(-0.3333833, -0.25832576, -0.015299467, 0.13634793), vec4(0.015757343, 0.011852452, -0.039323617, 0.21063177)) * bufB[6] + mat4(vec4(-0.105627194, 0.269618, 0.06604509, -0.17198728), vec4(0.20484151, -0.21050945, 0.12776496, -0.016729664), vec4(-0.08196898, -0.06145329, 0.3002203, 0.009630574), vec4(0.038303856, -0.03653167, -0.14484493, -0.31948572)) * bufB[7];\nbufA[2] = vec4(0.0012412892, 0.0038912944, 0.01211715, 0.0021933469) + mat4(vec4(-0.06478712, -0.08730999, 0.018730357, 0.14271909), vec4(-0.25912866, 0.106726095, -0.098368116, -0.4003152), vec4(0.2574547, 0.10141634, 0.15556473, 0.057950217), vec4(-0.19662978, 0.049875807, -0.30501664, -0.0849829)) * bufB[0] + mat4(vec4(-0.33176088, 0.10264731, -0.014363458, -0.25147563), vec4(-0.0153300725, -0.08400886, -0.10443716, 0.009120944), vec4(-0.15537126, 0.08256444, -0.06651629, 0.07316714), vec4(0.08081599, -0.0527877, -0.2986712, -0.10165975)) * bufB[1] + mat4(vec4(0.28628597, -0.23890357, -0.064063, -0.12685429), vec4(0.1216516, 0.2068959, -0.0046442514, -0.110076435), vec4(-0.107520245, -0.12678076, 0.19399796, -0.04452621), vec4(-0.09013378, -0.07808741, -0.03518435, -0.30675507)) * bufB[2] + mat4(vec4(0.47310042, 0.013269688, -0.21303484, 0.050646856), vec4(0.26143897, -0.020139663, 0.43201852, 0.17253342), vec4(0.1373907, -0.036909115, -0.17717516, 0.17021097), vec4(0.07803966, 0.3139184, 0.05683599, 0.15823396)) * bufB[3] + mat4(vec4(-0.08979131, 0.075833015, -0.25630993, -0.11390319), vec4(-0.07851753, -0.0505656, 0.102362074, -0.089536905), vec4(-0.05478443, 0.29987594, 0.016403845, 0.16241996), vec4(0.2428636, -0.14616865, -0.15479313, 0.20549506)) * bufB[4] + mat4(vec4(0.26591095, 0.03450501, -0.20094049, -0.25209376), vec4(0.089944884, 0.23409544, -0.33547595, -0.032648597), vec4(0.23819755, 0.011613911, -0.121998586, -0.10612968), vec4(-0.030816235, -0.041716527, 0.20255755, 0.25542203)) * bufB[5] + mat4(vec4(-0.31253055, -0.037475746, -0.027678123, -0.1831562), vec4(0.20685345, -0.06070872, -0.12961797, 0.13345565), vec4(0.22287527, 0.30632752, -0.06675815, -0.08680724), vec4(-0.07875384, -0.16636115, -0.21806274, -0.3767924)) * bufB[6] + mat4(vec4(-0.16000372, 0.013599232, -0.36736408, -0.19194205), vec4(-0.08817099, -0.047419704, 0.060244914, 0.26931828), vec4(-0.040732443, -0.1645503, -0.05190961, -0.17373468), vec4(-0.07734054, 0.27316326, 0.2040507, -0.1723326)) * bufB[7];\nbufA[3] = vec4(-0.0030992469, -0.011184195, 7.71535e-05, 0.0025829247) + mat4(vec4(0.006938933, -0.4829302, 0.22013108, 0.17538616), vec4(0.11726952, -0.20521669, 0.12588736, -0.17531398), vec4(-0.031044729, 0.2175083, -0.24628168, -0.006086408), vec4(0.19189171, -0.16200952, -0.061495103, -0.11166556)) * bufB[0] + mat4(vec4(0.0742415, -0.06310822, 0.032758936, -0.07994149), vec4(-0.11311298, 0.22465213, 0.277356, 0.17876789), vec4(0.07453088, 0.08764454, 0.16842866, -0.123438984), vec4(-0.13300258, 0.25727955, -0.2554967, 0.056494348)) * bufB[1] + mat4(vec4(0.033347152, 0.26488164, -0.021232817, -0.13024843), vec4(0.25906122, 0.009492315, -0.122901835, 0.10377672), vec4(0.21701196, -0.16394185, -0.052983407, 0.27189156), vec4(-0.05498598, 0.102262385, -0.0010639585, 0.0011543151)) * bufB[2] + mat4(vec4(-0.15778223, -0.026572406, 0.014099703, -0.020671444), vec4(0.1028982, 0.124995776, -0.096144326, 0.047570895), vec4(-0.3647089, 0.06541705, -0.15792672, -0.21250744), vec4(0.045073062, 0.009488003, -0.1897781, -0.14441653)) * bufB[3] + mat4(vec4(0.0028203428, -0.23277229, -0.28973305, -0.23076029), vec4(-0.19406241, 0.20306388, -0.1591721, 0.13088568), vec4(-0.32017604, 0.1860045, 0.13009971, 0.09450798), vec4(0.028319633, 0.4981141, 0.034875937, -0.0056222174)) * bufB[4] + mat4(vec4(0.13678305, 0.46803412, -0.08710918, -0.034737196), vec4(0.06714418, -0.023281753, -0.13477102, -0.011367813), vec4(0.100766174, -0.12109047, -0.20074803, -0.15688768), vec4(-0.040960595, -0.055577837, -0.02685942, 0.053983774)) * bufB[5] + mat4(vec4(-0.03738117, -0.30382726, 0.13899356, 0.023429893), vec4(-0.1534612, 0.3029139, -0.12865844, -0.058131523), vec4(0.04699375, -0.112777576, -0.052044068, -0.03526492), vec4(0.042680252, -0.1062399, 0.001808316, 0.16279277)) * bufB[6] + mat4(vec4(-0.12814817, -0.038618077, -0.30689335, 0.31996778), vec4(0.08470756, 0.26066455, 0.19715932, -0.13581975), vec4(-0.48391035, -0.30129582, -0.0117129, -0.089052744), vec4(0.010933122, -0.28527844, -0.15801568, 0.17364882)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(-0.00090773543, 0.024765398, 0.0017882739, 0.020023366) + mat4(vec4(0.08879379, 0.12343048, 0.19355975, -0.12374405), vec4(0.01863982, 0.006081436, -0.28790075, -0.14143473), vec4(-0.02720893, -0.42853922, 0.10649855, 0.115528874), vec4(0.23786508, 0.1969868, 0.010660044, 0.16246064)) * bufB[0] + mat4(vec4(0.026607761, 0.048703935, -0.18961304, -0.18366471), vec4(0.06129296, 0.06221729, 0.14217508, -0.1635111), vec4(-0.16886415, 0.11731002, 0.173397, 0.14713481), vec4(-0.43983415, 0.10836869, 0.016292755, 0.12481249)) * bufB[1] + mat4(vec4(0.04555885, -0.17353384, -0.086783044, 0.05165712), vec4(-0.21927592, -0.39395833, 0.15721674, -0.09877077), vec4(-0.11186699, 0.06362127, -0.25257665, -0.040733974), vec4(0.056015752, 0.06740569, 0.43103176, -0.18916978)) * bufB[2] + mat4(vec4(-0.12475818, 0.13856323, -0.27840132, -0.27511492), vec4(-0.061156143, 0.19584052, 0.0105112465, -0.30453813), vec4(0.20221807, -0.025222223, 0.11101244, 0.13390747), vec4(-0.036005344, -0.070177145, -0.26903045, 0.03767473)) * bufB[3] + mat4(vec4(0.10381153, -0.093029514, -0.05421546, -0.08994188), vec4(0.28404236, -0.2086251, 0.13576506, 0.16696061), vec4(0.057081047, -0.28580844, -0.17080912, -0.019509284), vec4(0.092917085, -0.25466847, 0.024005514, 0.17371719)) * bufB[4] + mat4(vec4(-0.015247954, -0.04300271, 0.28613928, -0.07935175), vec4(0.31666535, 0.09617357, -0.05340463, 0.10357364), vec4(0.27048782, -0.5126131, -0.113741, -0.16879974), vec4(-0.15886599, 0.0529517, 0.04584354, 0.07422389)) * bufB[5] + mat4(vec4(0.2803038, -0.050791554, 0.19581777, -0.18960537), vec4(0.2657508, -0.001195852, 0.08199292, 0.12749921), vec4(-0.019790828, 0.26955608, 0.021023596, 0.10193622), vec4(0.25661165, -0.18741308, 0.214057, -0.08472616)) * bufB[6] + mat4(vec4(-0.13851877, 0.022791559, -0.14375539, -0.1943161), vec4(0.3030522, -0.012153894, -0.34512034, -0.07664916), vec4(0.054631747, 0.04247656, 0.017985001, 0.1404649), vec4(0.009944865, -0.13738845, -0.0131364735, -0.11374011)) * bufB[7];\nbufA[1] = vec4(-0.0012479543, 0.013299171, 0.036112055, 0.0026284081) + mat4(vec4(0.1410142, 0.15386988, 0.14016427, -0.13730624), vec4(-0.16154712, -0.1840838, -0.159774, 0.164435), vec4(-0.005448891, 0.0374344, 0.08904779, -0.15388535), vec4(0.08477423, -0.39146984, 0.121625796, 0.30508634)) * bufB[0] + mat4(vec4(0.01729529, -0.016966227, 0.021125518, -0.22067052), vec4(-0.15038595, 0.034322694, 0.13805729, 0.121687986), vec4(-0.20570825, -0.10243875, 0.032073084, -0.18971257), vec4(0.11750898, -0.27404734, -0.014908258, -0.16930854)) * bufB[1] + mat4(vec4(-0.06903628, -0.008200997, 0.123458706, -0.045277894), vec4(0.018555824, 0.15074506, -0.15894051, 0.0457452), vec4(-0.0087089725, -0.05660394, -0.12442378, -0.24978863), vec4(-0.19002979, -0.07658155, -0.010954044, -0.0022202872)) * bufB[2] + mat4(vec4(0.12021923, -0.21945764, -0.38387406, -0.11215487), vec4(-0.056928486, 0.08625454, -0.102797315, 0.089583114), vec4(0.20152351, 0.25019833, 0.092476614, 0.14975376), vec4(0.13392055, 0.04899593, 0.02162546, 0.012287432)) * bufB[3] + mat4(vec4(0.0070266128, -0.15433593, 0.15137172, 0.092406526), vec4(0.15974915, -0.2066178, -0.14980882, -0.26719335), vec4(-0.056636285, 0.021860873, 0.14170478, 0.064436436), vec4(0.03509077, -0.0026965735, 0.13378963, 0.18373483)) * bufB[4] + mat4(vec4(-0.6217683, 0.19286385, 0.07791121, -0.06575137), vec4(0.030630141, -0.35912678, -0.13921645, 0.04094377), vec4(0.012982201, 0.2872065, 0.10403004, -0.24507925), vec4(-0.4921628, -0.003823506, 0.19566546, 0.3755831)) * bufB[5] + mat4(vec4(-0.0068867095, -0.20028202, -0.11322322, -0.2078925), vec4(0.022203654, -0.03529943, -0.07216249, 0.18009932), vec4(0.6040669, 0.09993692, -0.11191897, 0.27877912), vec4(0.2824283, 0.14316238, -0.16627951, 0.033872563)) * bufB[6] + mat4(vec4(0.16015439, 0.2977278, 0.142793, 0.15838353), vec4(-0.42774433, -0.025307637, -0.122773185, 0.06429173), vec4(0.0003094141, -0.09835425, 0.17642325, 0.040156852), vec4(0.010462057, 0.29117653, -0.17571612, -0.084046915)) * bufB[7];\nbufA[2] = vec4(0.026529664, -0.01242776, -0.0043740533, 0.019370092) + mat4(vec4(-0.1539365, -0.14288056, -0.011359423, 0.26306993), vec4(-0.013573965, -0.07667894, -0.08633115, -0.11908233), vec4(0.023698887, -0.28437123, 0.30312794, 0.12751691), vec4(-0.3706544, 0.20286742, -0.07888283, -0.20957625)) * bufB[0] + mat4(vec4(0.09871043, 0.05501519, 0.064644344, 0.041088514), vec4(0.20930055, 0.25351894, -0.010963009, 0.024286546), vec4(0.5341704, 0.008018036, 0.06935221, -0.013459402), vec4(0.039748468, 0.192669, -0.0031243481, 0.19659947)) * bufB[1] + mat4(vec4(-0.23867175, -0.025558436, -0.11052103, 0.015600082), vec4(0.16721575, -0.002079394, -0.1163773, -0.043800168), vec4(0.10092197, -0.124048255, 0.13005507, 0.066404164), vec4(0.007291374, 0.1517885, 0.046339735, 0.3279252)) * bufB[2] + mat4(vec4(0.09006087, -0.21475555, 0.1458534, -0.10406544), vec4(-0.0562395, -0.04348287, -0.17155112, 0.06927982), vec4(0.001947562, -0.36740687, -0.22876851, -0.19070977), vec4(-0.09489506, -0.0005410871, 0.19076075, 0.0009317053)) * bufB[3] + mat4(vec4(-0.07198116, 0.09044889, 0.11872409, 0.16211358), vec4(-0.022220993, -0.028346237, -0.18884891, 0.20488754), vec4(0.033748414, -0.011641094, 0.04735837, 0.0140157975), vec4(-0.16484472, 0.06720538, -0.19006224, 0.026064944)) * bufB[4] + mat4(vec4(-0.29928795, -0.22814187, 0.06562348, -0.21380728), vec4(0.104309045, 0.02910018, -0.033195168, 0.15406474), vec4(0.00020705078, -0.013078414, 0.3278131, -0.027912725), vec4(0.1595081, -0.1036482, 0.34183997, -0.27918974)) * bufB[5] + mat4(vec4(-0.14256398, 0.2222391, 0.13442846, 0.04041185), vec4(0.12126158, 0.12488864, 0.044337686, -0.056888387), vec4(0.027434643, 0.07557426, 0.012647263, 0.1222286), vec4(-0.15238811, 0.16037348, -0.25994864, 0.11139763)) * bufB[6] + mat4(vec4(-0.2463162, -0.2249026, -0.084073894, 0.15681647), vec4(-0.1290665, -0.14385645, 0.15252885, 0.101522624), vec4(-0.0045281914, 0.06989558, -0.025298832, -0.045506485), vec4(-0.1987432, -0.010060166, 0.015635395, 0.20046337)) * bufB[7];\nbufA[3] = vec4(0.023581317, -0.0059065847, 0.008340137, 0.010768675) + mat4(vec4(0.26819146, -0.06226256, 0.11397164, 0.22784705), vec4(0.070901945, 0.31232646, 0.25285044, -0.05563011), vec4(0.32464322, 0.09736343, 0.11874564, 0.1379752), vec4(0.016253278, -0.11876894, 0.08005561, 0.031421464)) * bufB[0] + mat4(vec4(0.02990523, 0.0013262902, 0.07011328, 0.29759973), vec4(-0.27153543, 0.0664171, -0.08465212, 0.061835207), vec4(0.0037559494, 0.043714337, 0.24483399, -0.09189925), vec4(-0.39639518, 0.31176788, 0.18063074, 0.18164372)) * bufB[1] + mat4(vec4(0.15699655, 0.32205516, 0.20365046, 0.33136162), vec4(-0.0707035, -0.042981394, -0.15346952, 0.22472575), vec4(0.05302049, -0.29749262, 0.02699632, 0.08309115), vec4(-0.042944033, 0.07041512, -0.28277737, -0.048805244)) * bufB[2] + mat4(vec4(0.42952383, 0.06486891, -0.1407325, -0.010195683), vec4(-0.056484062, -0.09470093, -0.09928726, -0.05478626), vec4(-0.13161765, -0.20298553, 0.2905649, -0.1725956), vec4(0.21814656, 0.14044373, 0.16925232, -0.27383986)) * bufB[3] + mat4(vec4(-0.21227957, -0.07286176, 0.018225228, -0.08190546), vec4(-0.13562295, 0.10554264, 0.058605883, 0.048077505), vec4(0.24059442, 0.2454994, 0.14643866, -0.18513037), vec4(-0.055715613, 0.34504384, 0.17449842, 0.030148922)) * bufB[4] + mat4(vec4(-0.15880808, 0.34455892, 0.05061618, -0.08458242), vec4(-0.09910439, -0.2825654, 0.12869224, 0.04991299), vec4(-0.36112204, -0.18513128, -0.040982112, -0.11501862), vec4(-0.10961858, -0.062334098, -0.05752234, -0.091576144)) * bufB[5] + mat4(vec4(0.095185585, -0.21602982, 0.11153104, -0.10970645), vec4(-0.019186327, -0.11191752, 0.018941745, 0.30498776), vec4(-0.040937174, 0.24124241, -0.031650923, 0.12098698), vec4(0.11348876, 0.21107006, -0.12679969, -0.1757425)) * bufB[6] + mat4(vec4(-0.018987427, 0.030258713, 0.052693784, 0.039312705), vec4(-0.15748952, -0.27357867, 0.28390545, -0.086138286), vec4(-0.077332765, 0.10969088, 0.22661953, -0.045946855), vec4(-0.03083391, 0.21943101, 0.12983665, 0.094466254)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.010618741, 0.007141143, 0.026242621, -0.016578896) + mat4(vec4(-0.069838375, -0.4399129, -0.05512888, 0.1874657), vec4(0.06413281, 0.14237791, -0.18251732, 0.2443734), vec4(-0.104252234, -0.15753637, 0.1310684, -0.09659173), vec4(0.27486184, 0.03149485, -0.14757882, -0.04903821)) * bufB[0] + mat4(vec4(0.022242183, -0.24927051, 0.14139883, 0.15030523), vec4(0.28026646, 0.15964344, -0.17434523, -0.08497675), vec4(-0.16069621, 0.17857179, 0.13292153, -0.122776076), vec4(-0.42344856, 0.23100074, -0.1695607, 0.26967686)) * bufB[1] + mat4(vec4(0.08157221, 0.09925214, -0.03623917, -0.11723899), vec4(0.026257247, -0.27085996, -0.14118083, 0.071838185), vec4(0.04993575, 0.054240815, -0.06280207, -0.06215952), vec4(-0.1276642, -0.40386498, -0.10073023, 0.07134006)) * bufB[2] + mat4(vec4(0.2392366, -0.21677125, 0.15735213, 0.17199434), vec4(-0.21573511, -0.24393243, 0.03326026, 0.1810962), vec4(0.1251264, -0.09150808, -0.27319807, -0.1348337), vec4(0.077261515, -0.49895474, 0.046482448, -0.288604)) * bufB[3] + mat4(vec4(-0.47867796, 0.1797845, -0.103126645, -0.18048376), vec4(0.09072384, 0.3027625, 0.04936829, 0.26682904), vec4(0.014398234, -0.2918249, 0.019457556, -0.034472678), vec4(0.10120273, -0.0955138, 0.0927553, 0.2942644)) * bufB[4] + mat4(vec4(0.026654182, -0.06404044, -0.116903, 0.22064953), vec4(0.29567766, 0.14776178, -0.17214113, 0.097403094), vec4(0.051024824, -0.19262217, -0.114967845, -0.14018503), vec4(-0.26157776, -0.19712704, -0.090822674, 0.08117975)) * bufB[5] + mat4(vec4(-0.33189082, -0.12848467, -0.06279263, 0.11579304), vec4(0.42611066, 0.112809576, -0.16538635, -0.12563446), vec4(-0.105617024, -0.0068421634, 0.13038631, -0.2540529), vec4(0.14566626, -0.04945879, -0.07609732, -0.2506076)) * bufB[6] + mat4(vec4(0.1587547, 0.08101927, 0.084841214, 0.16278614), vec4(0.13204612, -0.079741985, 0.048393708, 0.004625291), vec4(0.24085216, 0.017246839, 0.20810854, -0.09619213), vec4(0.14973374, 0.16101468, 0.13505797, 0.28088775)) * bufB[7] + in0;\nbufA[1] = vec4(-0.056647908, 0.04482958, 0.031812645, -0.018519847) + mat4(vec4(0.24281491, -0.19296888, -0.14254138, -0.08184434), vec4(0.04881286, -0.05247893, -0.28696918, -0.091749266), vec4(0.18154868, 0.104438595, -0.13252918, -0.12612736), vec4(-0.3250179, -0.004976563, 0.19359604, -0.034515716)) * bufB[0] + mat4(vec4(0.12391495, -0.04755945, 0.077008896, 0.011678568), vec4(0.11065586, -0.01208154, -0.3586444, -0.1446697), vec4(0.032717377, 0.04220549, 0.03599193, -0.20008913), vec4(0.16581006, 0.053284876, -0.10856268, -0.09695318)) * bufB[1] + mat4(vec4(-0.28343534, 0.06264322, 0.071057715, -0.06308187), vec4(-0.0008548618, 0.22329079, 0.097872086, -0.035899892), vec4(-0.065978214, -0.20150238, 0.32321438, 0.2359113), vec4(0.099962175, 0.09760388, 0.17573254, 0.14698194)) * bufB[2] + mat4(vec4(-0.26774448, 0.064815626, -0.22315872, 0.08960176), vec4(0.06089649, 0.02870766, 0.0031973724, -0.20174354), vec4(-0.30556482, -0.12623082, 0.33117333, 0.06374136), vec4(0.18227865, 0.015603094, -0.44080916, 0.10959866)) * bufB[3] + mat4(vec4(0.152401, -0.012298313, -0.079305254, -0.16206767), vec4(0.053304546, 0.100868896, -0.005878477, 0.22975668), vec4(0.0051519265, 0.17788607, -0.12750323, -0.08411847), vec4(-0.18274957, -0.09729535, 0.15837003, 0.38314658)) * bufB[4] + mat4(vec4(0.15754883, 0.040822465, -0.02736126, -0.09781719), vec4(0.18656732, -0.0282488, 0.10419713, 0.29264408), vec4(-0.07141531, 0.08135913, 0.29291043, -0.14859141), vec4(0.07317201, 0.09159522, -0.053854596, 0.15316138)) * bufB[5] + mat4(vec4(-0.22691028, -0.089993194, -0.16893798, -0.049588703), vec4(0.20669368, 0.0053614196, -0.101521276, -0.034800738), vec4(-0.10811427, -0.35548598, -0.079348646, -0.45401278), vec4(0.031173741, -0.27176362, 0.06085525, -0.22498237)) * bufB[6] + mat4(vec4(-0.114444815, -0.16664337, -0.1632605, -0.058468897), vec4(0.2155082, -0.16572435, 0.18255436, 0.24716066), vec4(-0.11633201, -0.15740755, -0.22295527, 0.2596538), vec4(0.30876905, 0.07884093, 0.0058033187, -0.00031092335)) * bufB[7] + in1;\nbufA[2] = vec4(0.014584822, 0.01403275, 0.023581883, -0.0030764705) + mat4(vec4(0.007212227, -0.18713641, -0.3602914, -0.05581616), vec4(-0.10179494, -0.060699612, 0.15337105, -0.2769239), vec4(-0.2107867, 0.16709727, -0.28562596, 0.10724306), vec4(0.13774204, 0.26539266, -0.03913856, -0.032133475)) * bufB[0] + mat4(vec4(0.3071964, -0.13898197, -0.12690327, -0.047861125), vec4(-0.40273133, -0.046488468, -0.04620862, -0.04441271), vec4(-0.25104964, 0.24075511, -0.13897948, 0.021531157), vec4(-0.23510751, 0.074128896, 0.015311155, 0.18641794)) * bufB[1] + mat4(vec4(-0.015060444, -0.071039215, 0.13818088, 0.03849557), vec4(0.2265055, -0.16016875, 0.069368675, -0.114795744), vec4(-0.26652563, -0.0340035, -0.027119787, -0.032733135), vec4(0.0942954, 0.0510196, 0.050668925, 0.14748517)) * bufB[2] + mat4(vec4(0.03645335, 0.12186389, 0.024768464, -0.08862236), vec4(0.0073505216, 0.07813965, 0.034780934, 0.09032123), vec4(0.040205386, 0.25418407, -0.25943884, 0.027439607), vec4(0.07349637, 0.3292241, 0.08870709, 0.21622328)) * bufB[3] + mat4(vec4(0.022246515, 0.2548457, 0.2777853, 0.049780436), vec4(0.046675134, 0.1526991, 0.23539099, 0.10480024), vec4(0.21500105, 0.0119178565, 0.2698917, -0.29525265), vec4(0.11839921, 0.26326582, -0.01600443, 0.0771731)) * bufB[4] + mat4(vec4(-0.016854484, 0.13841349, -0.097221635, -0.33559898), vec4(0.04160463, 0.120488495, 0.16418868, 0.2508479), vec4(-0.0741532, 0.091962, -0.29891944, 0.049636874), vec4(-0.40537882, -0.045361858, 0.2856894, -0.073659144)) * bufB[5] + mat4(vec4(-0.18424065, 0.13899137, 0.09630163, 0.28146553), vec4(-0.06079049, -0.15063457, 0.19316933, -0.24495736), vec4(-0.20072928, -0.17604138, -0.04090952, -0.080709755), vec4(-0.0043213996, -0.15336856, -0.175681, 0.2031114)) * bufB[6] + mat4(vec4(0.2136767, 0.21471198, 0.015517448, 0.2871597), vec4(-0.19099653, -0.047660705, -0.052414656, 0.3049646), vec4(-0.1789628, -0.019069038, -0.20718025, 0.39256522), vec4(0.07633464, 0.1963815, 0.042058676, 0.013676206)) * bufB[7] + in2;\nbufA[3] = vec4(0.02835229, 0.010539764, 0.0028108803, -0.019533925) + mat4(vec4(0.13857597, -0.10635203, 0.07561386, 0.07616162), vec4(0.18327306, 0.11831314, -0.09904204, -0.267804), vec4(0.03594872, -0.07313839, 0.3636314, 0.12966125), vec4(0.23200105, 0.07845535, -0.03803329, -0.21786132)) * bufB[0] + mat4(vec4(0.107045464, 0.19480026, -0.09192805, -0.03942138), vec4(0.27447477, -0.06268928, 0.038538758, -0.015478185), vec4(-0.014576297, -0.23692562, 0.3307044, -0.15995349), vec4(0.034247372, -0.04021423, -0.24975255, 0.22129512)) * bufB[1] + mat4(vec4(0.003013884, 0.02028021, 0.15770942, 0.014838588), vec4(-0.057836395, 0.032944057, -0.15854597, -0.13988674), vec4(0.017885549, -0.06382104, 0.08123111, 0.12946428), vec4(0.20969757, -0.43904272, -0.17227015, -0.31316462)) * bufB[2] + mat4(vec4(0.14767112, -0.17869729, 0.13251482, -0.31360263), vec4(0.37541333, -0.35245803, -0.17180103, 0.17685562), vec4(-0.21305811, -0.2097253, 0.11386393, 0.06067269), vec4(-0.0039265305, 0.0851223, -0.15003575, -0.13484047)) * bufB[3] + mat4(vec4(-0.35089818, -0.0052604624, -0.15715808, 0.22133026), vec4(-0.24785148, -0.123606384, -0.18206, -0.11017736), vec4(0.046788994, 0.16547456, -0.19568399, 0.008108924), vec4(-0.29774433, 0.00471175, -0.1007762, -0.17325196)) * bufB[4] + mat4(vec4(0.09746535, 0.33275598, -0.047245167, -0.11310144), vec4(-0.015182381, -0.14850597, -0.07332459, 0.11497547), vec4(0.018080885, 0.24106973, -0.066750035, 0.05114624), vec4(-0.169193, -0.10812926, -0.37353116, -0.2653524)) * bufB[5] + mat4(vec4(-0.30484143, -0.24108262, -0.20758843, -0.07033534), vec4(-0.4407624, -0.0091153635, 0.040908765, 0.06537372), vec4(0.008042734, 0.047727197, 0.2244575, 0.4819548), vec4(-0.08034639, 0.052700065, 0.008142524, -0.1962406)) * bufB[6] + mat4(vec4(0.03758401, -0.14589949, -0.27277038, -0.2827568), vec4(0.0061045126, 0.018914752, -0.21188772, 0.33479828), vec4(0.024856059, -0.061210427, -0.16685364, 0.20526677), vec4(-0.11307932, -0.21482132, 0.19035286, -0.058035288)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.024447065, -0.0065997136, -0.020911325, 0.018264664) + mat4(vec4(0.07843969, 0.11109713, -0.22925621, -0.18940715), vec4(-0.089005016, 0.058212496, 0.28881145, -0.002871968), vec4(0.07874462, -0.016723527, 0.16948146, 0.122694165), vec4(0.074016556, 0.26941037, 0.13950486, -0.06593216)) * bufB[0] + mat4(vec4(-0.2239914, 0.14413059, 0.35306573, 0.09096214), vec4(-0.15990578, 0.27806184, -0.17989531, 0.05150438), vec4(-0.23291422, 0.07878018, 0.017089827, 0.18173528), vec4(0.13558346, -0.20163755, -0.055697188, -0.03994605)) * bufB[1] + mat4(vec4(0.050356798, -0.20777164, -0.21084239, -0.088526875), vec4(0.042108327, 0.120642655, 0.23004591, -0.036343053), vec4(0.043508787, 0.268447, -0.026219483, -0.03300331), vec4(0.21999513, -0.0812402, -0.043053832, 0.32188565)) * bufB[2] + mat4(vec4(-0.04405297, -0.20550837, -0.0587055, 0.2945101), vec4(0.38218227, 0.11558188, 0.36405852, -0.058435615), vec4(-0.18211631, -0.19574478, -0.10625969, -0.115900956), vec4(-0.22754928, -0.1187628, -0.2850278, -0.24722528)) * bufB[3] + mat4(vec4(-0.20236528, 0.047012534, 0.11249767, 0.07272749), vec4(-0.1281295, 0.26861486, -0.15358579, -0.074018225), vec4(-0.18553208, 0.07711307, 0.055308998, 0.26617697), vec4(-0.035079025, -0.15359539, 0.1664641, 0.2110733)) * bufB[4] + mat4(vec4(-0.15441003, -0.36566758, -0.118590355, 0.0137882), vec4(0.013185356, 0.06867107, -0.07383222, 0.14498776), vec4(-0.05959629, 0.20499498, -0.006502052, -0.008188403), vec4(-0.08699415, 0.12767914, 0.09814154, 0.23833188)) * bufB[5] + mat4(vec4(0.020704538, 0.3596543, 0.039980225, 0.10257418), vec4(-0.015550388, 0.072057225, -0.15759681, 0.15211037), vec4(-0.0949935, 0.051244304, -0.33959988, -0.1621093), vec4(-0.20521493, -0.08881603, 0.019585207, -0.06794708)) * bufB[6] + mat4(vec4(0.13503921, 0.07264471, 0.28798068, -0.048967507), vec4(-0.18343352, 0.032762922, 0.1902775, -0.080996685), vec4(0.10281374, -0.026354281, 0.123563886, -0.040997636), vec4(0.006025424, -0.07720926, -0.090724625, -0.07179808)) * bufB[7];\nbufA[1] = vec4(-0.008874102, 0.026735619, 0.010189454, 0.0025451735) + mat4(vec4(-0.21314584, 0.06233864, -0.11450743, -0.49038106), vec4(-0.029246105, -0.16110952, -0.05171185, 0.198681), vec4(-0.09143113, 0.18225485, 0.41730538, -0.07104813), vec4(-0.039306834, 0.2848535, -0.053128492, -0.098473504)) * bufB[0] + mat4(vec4(0.18720965, 0.07905521, 0.10688543, -0.0447787), vec4(0.011578242, -0.039645668, -0.06705441, -0.26834244), vec4(0.07325841, -0.023256907, -0.13320811, -0.07163476), vec4(-0.2045265, 0.30783737, -0.001845696, 0.3010566)) * bufB[1] + mat4(vec4(-0.0024895829, 0.06745131, -0.095818706, -0.10111809), vec4(-0.09241468, 0.056133274, 0.17158882, -0.28783995), vec4(0.115459956, 0.14072812, 0.23254207, -0.06021448), vec4(0.024170117, -0.32346702, -0.051700328, -0.01160732)) * bufB[2] + mat4(vec4(-0.13002504, -0.12049328, -0.12919438, -0.15405542), vec4(-0.09233488, -0.17907536, -0.22982803, 0.09117911), vec4(0.5295474, 0.19546081, 0.2643308, -0.1033375), vec4(-0.044201836, -0.18380383, -0.29402572, 0.07437936)) * bufB[3] + mat4(vec4(-0.0007554096, 0.004505129, -0.1501719, -0.041647475), vec4(0.114607, -0.14015874, -0.4981313, 0.057208084), vec4(0.028177692, -0.10613425, -0.029501844, 0.02136557), vec4(-0.13941786, -0.33059204, -0.3174945, 0.015949655)) * bufB[4] + mat4(vec4(0.20269333, 0.14591311, 0.056904342, 0.035418432), vec4(-0.16263108, -0.41918147, -0.0511233, 0.41566846), vec4(0.35738778, -0.31531242, -0.026406445, -0.24941114), vec4(-0.18398832, 0.18186045, -0.095728494, -0.045031834)) * bufB[5] + mat4(vec4(-0.07128366, 0.049689263, -0.13676438, -0.010830676), vec4(0.16891599, -0.031191789, 0.0743212, 0.046662856), vec4(0.012636815, 0.098951876, -0.38149256, -0.005370461), vec4(0.13090211, -0.027249498, 0.1496368, 0.28568962)) * bufB[6] + mat4(vec4(-0.18064287, -0.19577505, 0.079194166, 0.15966636), vec4(-0.03876835, 0.040453926, 0.02628013, -0.2675246), vec4(0.24997638, -0.0040670545, 0.04748497, -0.3096089), vec4(-0.035985805, 0.0371217, 0.040130634, 0.025183344)) * bufB[7];\nbufA[2] = vec4(-0.026508324, 0.057821915, 0.053845055, -0.010029131) + mat4(vec4(0.13749379, 0.35062978, 0.029368827, 0.017069371), vec4(-0.49570304, 0.28102812, -0.2606788, -0.06425771), vec4(-0.28645125, 0.029283812, 0.117440775, 0.10196673), vec4(-0.22542891, 0.2756543, -0.026864178, -0.12481861)) * bufB[0] + mat4(vec4(-0.12858526, -0.36296257, -0.17031907, -0.22416787), vec4(-0.08867632, 0.037892483, -0.06260093, 0.12015338), vec4(0.20248792, -0.054576267, -0.14785546, 0.018355887), vec4(0.22998318, 0.19374953, 0.04309262, 0.15403624)) * bufB[1] + mat4(vec4(-0.078509994, -0.34251043, -0.2439287, 0.1397673), vec4(-0.06204944, 0.20155269, -0.041234106, 0.030916872), vec4(-0.31191346, -0.043732148, 0.04174067, -0.104727425), vec4(-0.18538456, 0.07070673, 0.2017215, -0.32594192)) * bufB[2] + mat4(vec4(-0.025278289, 0.3140941, 0.3498839, 0.37262204), vec4(-0.04255557, 0.092590794, 0.04995954, 0.29607925), vec4(-0.2831805, -0.00176823, -0.28173223, 0.03892717), vec4(0.35449266, -0.16902909, 0.11494307, 0.07792814)) * bufB[3] + mat4(vec4(-0.12977925, -0.11169264, 0.20246759, 0.25959614), vec4(0.07738424, -0.18559422, 0.15347445, -0.061486572), vec4(-0.023988448, -0.26993677, -0.24059401, -0.08962756), vec4(-0.2325535, -0.045240466, 0.2751021, 0.29735667)) * bufB[4] + mat4(vec4(0.020324204, 0.06217086, -0.31459224, 0.19819313), vec4(-0.20266287, 0.06482059, 0.06026823, 0.20143667), vec4(-0.43939796, -0.06192357, 0.26767507, 0.16668637), vec4(0.030301562, 0.13602288, -0.15064275, -0.081913054)) * bufB[5] + mat4(vec4(0.07041697, -0.1163648, -0.0066984063, 0.25393862), vec4(0.25673303, 0.072139345, 0.028394565, 0.1433071), vec4(0.086474285, 0.02673448, 0.07054115, 0.16361953), vec4(-0.056751955, -0.13025793, -0.054032516, -0.04942781)) * bufB[6] + mat4(vec4(-0.16995011, -0.0735084, -0.43806013, -0.075938426), vec4(0.2483615, -0.17924568, 0.444355, -0.051419236), vec4(0.1594907, -0.3414286, -0.0003150213, -0.06379005), vec4(0.1443271, 0.0125328945, 0.30763376, 0.22116998)) * bufB[7];\nbufA[3] = vec4(0.041447945, 0.035839286, 0.06665748, -0.08557006) + mat4(vec4(-0.12188504, 0.23495744, 0.09078204, -0.0662647), vec4(-0.010639418, -0.14827825, 0.0014845561, 0.15213358), vec4(-0.0022727137, 0.09653232, 0.13875398, 0.2222872), vec4(-0.22252251, 0.12422398, -0.2364834, 0.32214496)) * bufB[0] + mat4(vec4(0.0062893736, -0.16376445, -0.1287047, -0.20207658), vec4(0.20374589, -0.15092058, 0.03146533, 0.012796644), vec4(0.2510554, 0.11411248, 0.13739878, 0.14365733), vec4(0.4418271, -0.014559326, 0.0052288766, 0.025997186)) * bufB[1] + mat4(vec4(0.073340155, 0.1711071, 0.4088479, 0.26283765), vec4(-0.07639865, 0.09442133, 0.13646023, -0.2723166), vec4(-0.12960838, 0.023573097, 0.24569894, -0.0050871004), vec4(0.30299497, -0.17203328, 0.17036663, 0.2779696)) * bufB[2] + mat4(vec4(0.06576418, -0.13247073, 0.15094757, 0.29581213), vec4(-0.28432134, -0.0053768526, 0.009624123, 0.09347373), vec4(0.061225206, -0.3870436, -0.21482883, 0.32273838), vec4(-0.44842523, -0.03733134, -0.0033607723, -0.25557455)) * bufB[3] + mat4(vec4(0.24303183, 0.18785004, -0.0014477998, 0.04108119), vec4(0.07924503, 0.09194916, 0.04428376, 0.08879996), vec4(-0.13431291, 0.09831655, -0.27349374, 0.016853208), vec4(-0.25515616, -0.18767557, -0.16588569, 0.18008113)) * bufB[4] + mat4(vec4(-0.116812535, 0.1471797, -0.20797578, -0.1280296), vec4(0.1322624, -0.36399218, 0.0446915, -0.16132809), vec4(-0.16094841, 0.047896374, -0.109721676, -0.0914746), vec4(0.13732405, 0.009546272, -0.16186771, 0.08093964)) * bufB[5] + mat4(vec4(-0.18942358, 0.16687518, -0.0061333687, -0.06324309), vec4(0.07454099, 0.08214017, 0.025058905, 0.20500264), vec4(0.1086473, -0.22524723, 0.070560575, 0.1289449), vec4(0.2742881, 0.08967203, 0.048431043, -0.079843566)) * bufB[6] + mat4(vec4(0.06484405, -0.018308327, 0.10789169, -0.04166101), vec4(-0.12056734, -0.10953515, -0.31461954, 0.23971103), vec4(-0.0306058, 0.1946146, 0.06430828, 0.262275), vec4(-0.27206022, -0.04730064, -0.17375526, 0.14634404)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.091378555, -0.058348347, -0.0201467, -0.056310553) + mat4(vec4(0.21467045, 0.1376415, 0.110163406, -0.021298207), vec4(0.054215558, -0.035342406, 0.20944543, -0.004427444), vec4(0.021275638, -0.23082413, 0.3693675, -0.08572785), vec4(-0.24130833, -0.19709258, -0.0016858805, 0.2232008)) * bufB[0] + mat4(vec4(0.06242182, 0.053177845, 0.007824526, 0.31364265), vec4(0.076932706, 0.17826246, -0.1278367, -0.13885649), vec4(-0.118408754, -0.119253166, -0.039416913, -0.005702574), vec4(0.25523934, 0.11308603, 0.17337684, -0.090866834)) * bufB[1] + mat4(vec4(0.20721862, 0.39620656, 0.41879216, -0.17729856), vec4(0.050512612, 0.025982898, 0.06972742, -0.28316274), vec4(0.094451, 0.11898992, -0.2984136, -0.37003493), vec4(-0.31803814, 0.08542717, -0.06607016, -0.17375948)) * bufB[2] + mat4(vec4(0.1754949, 0.21347436, -0.023534203, 0.32675543), vec4(0.24432723, 0.35811585, -0.5643289, -0.12239321), vec4(0.0692874, -0.2393267, 0.08367825, 0.18083815), vec4(-0.07113156, -0.17442623, -0.032080617, 0.2599624)) * bufB[3] + mat4(vec4(-0.05213306, -0.1296546, -0.17338063, 0.12947965), vec4(-0.18105303, -0.17638327, 0.14983313, -0.010728387), vec4(0.22368003, 0.18091509, -0.0931844, -0.2598466), vec4(-0.20059201, -0.20592564, 0.022419494, 0.27251327)) * bufB[4] + mat4(vec4(-0.23340334, 0.0890384, 0.16699529, -0.10330252), vec4(-0.06935931, -0.07944219, 0.011961148, 0.23190397), vec4(0.29397643, 0.16036448, 0.23126873, 0.28711456), vec4(-0.5050033, 0.086296886, 0.38589874, 0.33563954)) * bufB[5] + mat4(vec4(0.12798406, -0.21731766, 0.26573485, -0.41893893), vec4(-0.13874912, 0.1225234, 0.1215977, -0.27139276), vec4(-0.036308806, 0.03296974, -0.11423123, -0.13080823), vec4(0.20774168, 0.41469747, 0.010452655, -0.16093364)) * bufB[6] + mat4(vec4(-0.10247651, -0.011276807, -0.14299677, -0.05907503), vec4(-0.1380547, 0.105275206, -0.16955367, 0.016053436), vec4(-0.1491372, 0.23086266, -0.21436213, 0.023083096), vec4(-0.20868929, -0.2720337, 0.04016613, -0.093039855)) * bufB[7];\nbufA[1] = vec4(0.020227654, 0.05655869, 0.02879173, -0.0010876155) + mat4(vec4(-0.39338884, 0.35886782, 0.07143733, -0.3823724), vec4(0.016491188, -0.19443768, -0.18735456, 0.3297002), vec4(0.16720279, -0.2285589, 0.35033372, 0.2167981), vec4(-0.056305543, -0.06919555, 0.22028457, -0.03801244)) * bufB[0] + mat4(vec4(-0.2236926, 0.081844434, 0.073321976, -0.2910984), vec4(0.17740487, -0.10743837, 0.19509542, 0.2965181), vec4(-0.39583004, 0.07073184, 0.20524223, -0.24692617), vec4(-0.21924251, 0.033071596, 0.014189433, -0.27048194)) * bufB[1] + mat4(vec4(-0.015139631, -0.08049059, 0.5170259, -0.060832504), vec4(0.0965696, -0.45700684, -0.20288405, 0.047621854), vec4(0.026434494, 0.08971453, 0.09704391, -0.10083511), vec4(0.17128189, 0.106818594, -0.02803735, 0.04971021)) * bufB[2] + mat4(vec4(0.03508818, 0.022956371, -0.2267539, 0.1596562), vec4(0.33256853, 0.29602686, -0.17396498, -0.006368995), vec4(-0.014951627, 0.06833273, -0.07392775, -0.065251864), vec4(0.347173, -0.2860433, 0.16253088, 0.17714186)) * bufB[3] + mat4(vec4(-0.13288309, -0.28375342, -0.1758874, 0.023713425), vec4(0.057436157, 0.15540828, -0.12962142, -0.09465522), vec4(0.26256147, -0.11093815, 0.016709857, -0.04961727), vec4(0.2239084, -0.22305374, 0.010519089, 0.246959)) * bufB[4] + mat4(vec4(-0.4585331, 0.28561705, -0.035236284, 0.10654512), vec4(-0.025383404, -0.13029753, 0.29280522, 0.2213817), vec4(-0.11264322, -0.012526434, -0.05861116, -0.120355174), vec4(0.21657336, 0.1278672, -0.0315414, 0.14939812)) * bufB[5] + mat4(vec4(0.098485745, -0.028041638, 0.06073813, 0.021238256), vec4(0.09579782, 0.13713992, 0.104928106, -0.16545144), vec4(-0.2306353, -0.01817968, -0.1372663, -0.16862638), vec4(-0.03617571, -0.4678661, 0.34661123, -0.031839278)) * bufB[6] + mat4(vec4(-0.21363655, -0.10704725, -0.32054588, -0.05482057), vec4(0.0132973865, -0.045271423, 0.026618233, 0.40149876), vec4(0.024894364, -0.23738207, 0.1524702, -0.26680517), vec4(0.024951741, 0.042894296, -0.024373598, 0.07495067)) * bufB[7];\nbufA[2] = vec4(0.014836865, 0.13502918, -0.044287466, -0.093842946) + mat4(vec4(-0.10272317, -0.12445259, 0.23542425, 0.31342754), vec4(0.2562097, -0.16924818, -0.00904445, 0.089083835), vec4(-0.00023713554, -0.14836644, 0.07676743, -0.14020734), vec4(-0.12770112, 0.10068447, -0.07098099, 0.2898902)) * bufB[0] + mat4(vec4(-0.05649991, -0.17510493, 0.32925612, -0.012017842), vec4(-0.0061492873, 0.1843042, -0.14417571, -0.06300594), vec4(0.06661286, 0.21637645, -0.15743874, -0.07062903), vec4(-0.17401125, -0.26921847, 0.08564736, 0.0667394)) * bufB[1] + mat4(vec4(-0.33146444, -0.16291922, 0.015261055, -0.11542587), vec4(-0.16895658, 0.19888507, -0.20458436, -0.05113833), vec4(0.21293698, 0.22479263, -0.14467385, -0.21935499), vec4(-0.06370547, 0.06274645, -0.10362018, -0.096778505)) * bufB[2] + mat4(vec4(-0.03838965, -0.110978626, 0.01797122, 0.17102024), vec4(0.09247003, 0.26383108, -0.037645623, 0.3001975), vec4(-0.12920855, 0.04422217, -0.22939664, -0.20011377), vec4(0.011279304, -0.10733479, 0.011719596, -0.26319405)) * bufB[3] + mat4(vec4(0.1112735, -0.12188516, 0.22331315, 0.34230822), vec4(0.19697689, 0.29779464, 0.12187176, 0.25123435), vec4(-0.16801818, -0.41542843, 0.21906355, 0.19210698), vec4(0.22066273, -0.29855862, 0.12157504, -0.15689765)) * bufB[4] + mat4(vec4(0.09439741, -0.24263537, 0.071099825, -0.09700039), vec4(0.07957579, -0.029659862, -0.050787542, -0.13419704), vec4(0.16424233, 0.11398967, 0.13766116, 0.1880572), vec4(-0.23978777, -0.13006449, -0.04211178, -0.25387636)) * bufB[5] + mat4(vec4(-0.09897759, -0.14265816, -0.32927528, 0.20307702), vec4(0.23970377, -0.05970605, -0.07223086, 0.0023714802), vec4(-0.033487972, -0.44534716, -0.14206836, -0.029304123), vec4(-0.060940683, -0.30204302, -0.08514628, 0.28870568)) * bufB[6] + mat4(vec4(0.11971161, -0.17368248, 0.19630492, 0.023228604), vec4(-0.037911788, -0.106500424, 0.049261477, 0.105142824), vec4(-0.54915035, -0.14596191, 0.045026135, -0.103957824), vec4(-0.03971627, 0.23055242, 0.32343736, -0.010879001)) * bufB[7];\nbufA[3] = vec4(0.046404943, -0.029016923, 0.020221092, -0.08195147) + mat4(vec4(-0.13477142, 0.00827801, 0.046456296, 0.22709435), vec4(0.1308072, -0.062648274, -0.07505697, -0.076330915), vec4(-0.03763408, -0.014356859, 0.1590917, 0.05312983), vec4(0.1483096, -0.04277402, -0.10428823, 0.5973707)) * bufB[0] + mat4(vec4(0.1958799, 0.015943917, 0.0859572, 0.06506278), vec4(0.10142839, 0.07122185, -0.15099755, -0.12983775), vec4(-0.18777254, -0.039478865, -0.5253516, 0.6627805), vec4(0.44352785, -0.05380592, -0.58899194, 0.18402377)) * bufB[1] + mat4(vec4(-0.1034881, 0.06963375, -0.041632254, 0.058339458), vec4(0.115118414, -0.081906356, 0.23439986, -0.2111852), vec4(0.104598925, -0.10830961, -0.1297643, -0.09184501), vec4(0.0052791866, 0.4930674, -0.27728426, -0.21709812)) * bufB[2] + mat4(vec4(0.069109954, 0.077851236, 0.24261126, -0.34906706), vec4(-0.17095764, 0.023558134, -0.16461912, 0.18856312), vec4(0.03295034, 0.07081265, 0.20957917, 0.007543044), vec4(-0.12090014, 0.12417441, 0.0050429627, -0.073696196)) * bufB[3] + mat4(vec4(-0.1953115, -0.2451067, -0.10277769, -0.14098805), vec4(-0.0023005418, 0.0726669, -0.08695928, -0.12125938), vec4(0.4306205, -0.2587734, 0.20638281, 0.047781684), vec4(-0.31469062, 0.07329201, -0.37197316, 0.16140063)) * bufB[4] + mat4(vec4(-0.09557946, 0.12716414, -0.07848857, -0.023414105), vec4(-0.064001605, 0.12504926, -0.060617786, 0.08832514), vec4(0.23059987, -0.23716918, -0.23596145, 0.2775831), vec4(0.28394878, -0.11104968, 0.12937576, -0.28220677)) * bufB[5] + mat4(vec4(-0.2906984, 0.12970294, 0.030087119, 0.1807194), vec4(-0.0061073117, 0.09396447, 0.15470219, -0.17366849), vec4(0.08502642, -0.15468465, 0.17494562, -0.08793563), vec4(-0.19471163, -0.21397103, -0.19319296, -0.012757432)) * bufB[6] + mat4(vec4(-0.14906482, -0.04513449, 0.13131504, 0.006229128), vec4(0.21292697, -0.30420443, 0.18747807, -0.04063418), vec4(-0.2042967, -0.257605, 0.08641315, -0.09776967), vec4(0.17795992, -0.04962707, -0.12740721, 0.2163536)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.09833077, 0.054418176, -0.048223227, 0.051002875) + mat4(vec4(0.20165266, -0.2571639, -0.13196857, -0.014630785), vec4(-0.25203863, -0.12882067, -0.21747679, 0.1907066), vec4(-0.20299922, 0.24962732, 0.29254588, -0.15471993), vec4(0.23175934, -0.08884075, -0.080305256, 0.088641904)) * bufB[0] + mat4(vec4(0.0828605, 0.4130337, -0.09824575, -0.16667151), vec4(-0.17253062, -0.04789495, -0.022905534, 0.25656182), vec4(0.08669836, -0.10589228, -0.27408442, -0.37236285), vec4(-0.18686944, -0.21707225, -0.09149773, 0.011891334)) * bufB[1] + mat4(vec4(-0.059195463, 0.07488677, -0.047500864, 0.29407284), vec4(-0.07158503, 0.14171115, 0.41896096, 0.10786146), vec4(0.03144595, -0.5135676, -0.13198502, -0.022422306), vec4(0.036280088, 0.078245945, -0.094425075, 0.09216257)) * bufB[2] + mat4(vec4(-0.28373948, -0.08192991, -0.2540202, -0.017866991), vec4(-0.19244553, -0.2068889, -0.14602602, -0.068094924), vec4(-0.051813964, 0.12575491, 0.2843164, -0.023074461), vec4(-0.1725795, 0.002589968, 0.08465194, -0.19735205)) * bufB[3] + mat4(vec4(-0.009761618, -0.076610796, -0.09542639, -0.09657886), vec4(-0.16313308, 0.10232767, -0.16348104, 0.17728014), vec4(-0.19893496, 0.023502428, -0.107214965, -0.26579058), vec4(0.14625005, -0.15177886, -0.069540106, -0.3360011)) * bufB[4] + mat4(vec4(0.10451042, 0.20020327, 0.08494536, -0.1762302), vec4(-0.11935651, 0.23933084, -0.26735112, -0.30907816), vec4(0.017021138, 0.08436788, 0.05673079, 0.047383707), vec4(-0.038788896, 0.05368702, -0.33254525, 0.039104674)) * bufB[5] + mat4(vec4(0.14373057, 0.055462573, 0.062442627, -0.25468487), vec4(-0.009430438, -0.25212142, -0.39659813, 0.063766666), vec4(-0.008731995, 0.20193206, 0.18187737, -0.26494935), vec4(-0.15440212, -0.1764273, -0.35309908, -0.17367013)) * bufB[6] + mat4(vec4(0.27104828, 0.031247612, 0.0052847858, -0.13724764), vec4(0.17896265, -0.057748668, -0.29573646, -0.13178252), vec4(-0.16851163, -0.003753003, 0.072531134, 0.13154799), vec4(0.24713333, 0.16299276, 0.36542943, 0.0024521146)) * bufB[7];\nbufA[1] = vec4(0.04555465, -0.0916264, 0.025501639, -0.0797136) + mat4(vec4(0.1513231, -0.208528, -0.09232099, -0.1589989), vec4(0.2256045, 0.08381184, -0.03107439, 0.16330945), vec4(0.20076331, 0.50386095, 0.10536451, -0.20210104), vec4(0.006666927, 0.10710603, 0.30493414, -0.02586814)) * bufB[0] + mat4(vec4(0.35253474, 0.022287553, -0.1365271, 0.1353031), vec4(-0.20575266, 0.024861922, -0.09888993, -0.11896045), vec4(0.056083385, 0.06879534, -0.28414717, 0.10690169), vec4(0.07441211, -0.15033172, -0.37128046, -0.2695964)) * bufB[1] + mat4(vec4(0.26935384, 0.25969264, 0.05145487, 0.10830803), vec4(-0.0061912485, 0.05587271, -0.30811954, -0.21127628), vec4(0.1295246, 0.18242411, 0.061500322, -0.050166197), vec4(0.24065375, -0.17983891, 0.2610238, 0.057886623)) * bufB[2] + mat4(vec4(0.26576078, 0.09941774, 0.18138322, -0.21062203), vec4(-0.25827038, 0.19018467, 0.11474641, 0.06640839), vec4(-0.0054386924, -0.21509728, -0.04994168, 0.070109814), vec4(-0.09959576, 0.22368802, -0.2806071, 0.20230956)) * bufB[3] + mat4(vec4(0.04099571, 0.269444, -0.22625145, 0.22175492), vec4(0.02045273, -0.3515006, 0.010580817, -0.07818541), vec4(0.12819505, 0.18312916, 0.41703755, -0.014198244), vec4(0.558227, 0.23843904, -0.1837419, -0.25334698)) * bufB[4] + mat4(vec4(-0.08927821, -0.2670345, -0.31870642, 0.22935048), vec4(-0.18304603, 0.03432857, 0.0767621, 0.3006079), vec4(-0.037915263, 0.35734975, -0.42461732, 0.018344682), vec4(-0.40082827, 0.40106806, 0.15361269, -0.09799758)) * bufB[5] + mat4(vec4(-0.2995419, 0.14502421, -0.061845005, -0.023767704), vec4(-0.068238124, -0.34390995, -0.11155049, -0.08563697), vec4(-0.12380586, 0.05785125, -0.32284465, -0.063625224), vec4(0.12167888, -0.019325357, -0.008687492, 0.5042734)) * bufB[6] + mat4(vec4(-0.20071723, 0.036530532, 0.500492, -0.3567519), vec4(-0.08795307, -0.1541681, 0.2802183, -0.24409185), vec4(-0.15888949, 0.3089125, 0.2413039, -0.042157926), vec4(0.4386573, -0.01716726, 0.096343175, 0.0399142)) * bufB[7];\nbufA[2] = vec4(-0.044126358, 0.051972255, -0.043788392, 0.042218305) + mat4(vec4(-0.01216839, 0.20969307, -0.322111, 0.06337672), vec4(0.16229402, -0.39506805, 0.21645129, 0.22832912), vec4(-0.13449216, -0.046434112, 0.11464327, 0.029846529), vec4(0.082174845, 0.045830287, 0.08592665, 0.12509541)) * bufB[0] + mat4(vec4(-0.3903989, -0.19671163, 0.16409345, -0.048208885), vec4(0.26691523, -0.0035908958, -0.15511487, -0.30769297), vec4(0.12719479, -0.031084271, 0.18809332, -0.047534745), vec4(0.23352104, -0.17237093, 0.23058528, 0.11081454)) * bufB[1] + mat4(vec4(-0.16069035, 0.1251949, -0.05569425, 0.2119139), vec4(-0.09340268, 0.16799086, -0.33077276, -0.01924143), vec4(0.09727626, 0.15275969, 0.3022671, -0.29600358), vec4(0.23467767, 0.07003816, -0.08802594, -0.2542075)) * bufB[2] + mat4(vec4(-0.2587514, -0.23281929, -0.022862036, 0.040673066), vec4(0.050747406, 0.25956962, 0.19086945, -0.19595063), vec4(0.20270175, -0.011953621, -0.1917323, 0.12241429), vec4(0.31335658, 0.11641854, 0.009437097, 0.13023409)) * bufB[3] + mat4(vec4(-0.07314371, -0.07042245, -0.2035682, 0.0142605845), vec4(-0.06436931, -0.41070306, -0.087564155, 0.14597887), vec4(-0.046016302, 0.14143682, 0.12947065, -0.13249174), vec4(0.004914443, 0.12792668, 0.03236982, 0.23722562)) * bufB[4] + mat4(vec4(0.051706653, -0.11104483, 0.5170574, 0.30331182), vec4(-0.01871773, 0.11007718, 0.21648261, 0.03312397), vec4(-0.17018476, 0.056373596, -0.06563616, -0.12776953), vec4(0.17362328, 0.116169676, -0.3246494, -0.061039492)) * bufB[5] + mat4(vec4(-0.033526387, -0.08226827, 0.43641508, 0.0018420306), vec4(0.27489352, 0.07153247, -0.15970644, 0.18063241), vec4(0.37113795, 0.014097171, 0.13247524, -0.12434086), vec4(-0.08094214, 0.07329475, -0.16885369, 0.02050546)) * bufB[6] + mat4(vec4(0.18943422, -0.08628953, 0.23760033, 0.059888244), vec4(-0.1904113, 0.06387547, -0.043942973, -0.25788015), vec4(-0.16221793, 0.07397221, -0.21446411, 0.104339965), vec4(0.11596044, 0.38119835, -0.043407418, 0.06218998)) * bufB[7];\nbufA[3] = vec4(-0.02563738, 0.07453802, 0.01578986, 0.07646519) + mat4(vec4(-0.09213535, 0.19859073, 0.08077167, 0.08125488), vec4(-0.27388853, -0.32181808, 0.24934159, -0.14194511), vec4(0.42648414, 0.04506408, 0.22953011, 0.12506996), vec4(0.2066278, -0.15794419, -0.012041615, -0.039080296)) * bufB[0] + mat4(vec4(-0.17500232, -0.012135948, 0.077285685, 0.14110813), vec4(0.030931266, -0.021096887, 0.21803926, -0.12151801), vec4(0.097730905, -0.056194596, -0.21490811, -0.11105026), vec4(0.002485781, 0.1496146, -0.24681142, -0.087490536)) * bufB[1] + mat4(vec4(0.24532086, 0.02515453, 0.38313767, 0.27410138), vec4(0.057949007, 0.06928681, 0.5112264, 0.2166674), vec4(-0.18624622, -0.25127095, 0.35689396, -0.11333762), vec4(0.26681203, 0.19309334, -0.0051415777, -0.2298836)) * bufB[2] + mat4(vec4(-0.15182678, 0.02512292, 0.3464609, -0.27389625), vec4(-0.13934283, 0.109909505, 0.068894215, 0.40177262), vec4(0.122896515, 0.56340504, -0.010636497, 0.3532702), vec4(0.14112946, -0.18579382, 0.09224363, -0.017580811)) * bufB[3] + mat4(vec4(0.030468868, -0.235311, -0.13204111, 0.20761494), vec4(-0.24326432, -0.1487142, -0.17665051, 0.18403381), vec4(-0.54593146, -0.20131831, 0.07611906, -0.011012999), vec4(0.10110932, 0.044580203, 0.15768257, -0.062157188)) * bufB[4] + mat4(vec4(-0.20370854, -0.051604174, 0.17517462, -0.2517666), vec4(0.3747894, 0.36486608, -0.09841301, 0.09553689), vec4(-0.16847919, -0.09462541, -0.064092204, -0.0063707326), vec4(-0.015295217, -0.03408272, 0.035607588, 0.021083293)) * bufB[5] + mat4(vec4(0.39921018, 0.07283116, 0.061690334, -0.29299173), vec4(0.26940346, -0.09038799, 0.47311985, -0.12607022), vec4(-0.050351255, -0.15718243, -0.21079107, 0.1028176), vec4(0.14647983, 0.08288881, -0.2784353, -0.0544648)) * bufB[6] + mat4(vec4(-0.21125163, -0.07283727, 0.111264266, -0.38460845), vec4(-0.03169613, -0.0597247, -0.20133193, -0.1643692), vec4(0.2089769, 0.034918718, 0.057727557, 0.2041535), vec4(-0.08991245, -0.040857427, 0.13304411, -0.05839531)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.049310327, -0.039463475, 0.05425033, 0.011326355) + mat4(vec4(0.17441589, -0.10719187, -0.049967095, -0.14391051), vec4(0.10761328, -0.31444383, -0.1677751, 0.13854142), vec4(-0.39630717, -0.094832756, 0.31889337, -0.12153876), vec4(0.13954164, 0.18268272, 0.3299222, 0.21778512)) * bufB[0] + mat4(vec4(-0.11244572, 0.03734414, 0.2831894, 0.23513287), vec4(-0.07224861, -0.0038895987, -0.0031550187, 0.003390144), vec4(-0.0855897, 0.20114413, 0.15398319, -0.14079492), vec4(0.0357255, 0.10135716, 0.28919366, 0.29669568)) * bufB[1] + mat4(vec4(-0.0041086012, -0.09014776, -0.25063714, -0.059682738), vec4(0.30545345, -0.08213706, -0.02670222, 0.04014164), vec4(0.12618078, 0.16888474, -0.10397014, 0.13343413), vec4(-0.024193544, -0.1769409, -0.014431215, -0.03868831)) * bufB[2] + mat4(vec4(0.25372133, -0.29311207, 0.48758128, 0.1699305), vec4(0.45067996, -0.05364004, -0.06449066, -0.10928605), vec4(0.09759073, -0.33421054, -0.063329786, -0.26654634), vec4(0.32105875, -0.51209486, -0.07498054, 0.0016391375)) * bufB[3] + mat4(vec4(0.12836069, 0.1294461, -0.017449517, -0.32400718), vec4(-0.14596352, 0.2687605, 0.3320294, -0.049944725), vec4(-0.21400395, -0.17612892, -0.37979832, 0.25154182), vec4(0.1242007, -0.12990184, 0.21761209, 0.25066927)) * bufB[4] + mat4(vec4(-0.2226105, 0.05220635, 0.0064034276, 0.38008288), vec4(0.021027662, 0.25331295, 0.14731428, 0.276965), vec4(-0.3484062, 0.291554, 0.19399841, -0.29049596), vec4(0.009274175, 0.0046717594, 0.09335534, -0.11065682)) * bufB[5] + mat4(vec4(-0.3213359, 0.37625462, -0.5397647, -0.1352386), vec4(-0.1800668, 0.0077840686, 0.18483539, 0.4001831), vec4(0.03330887, -0.18088797, 0.048344348, -0.30630845), vec4(0.09451839, -0.0106499465, -0.25291255, -0.57652634)) * bufB[6] + mat4(vec4(0.09813024, -0.15891486, 0.090538114, -0.3224561), vec4(0.3399583, -0.092298254, -0.46438974, -0.19093175), vec4(-0.099534005, -0.013033444, 0.061747428, 0.099533506), vec4(0.20662428, -0.3414194, 0.3114172, 0.2596591)) * bufB[7];\nbufA[1] = vec4(0.09648705, 0.043127332, -0.05020903, 0.12940069) + mat4(vec4(0.07908006, -0.04489131, 0.09234484, 0.05048923), vec4(0.09841186, -0.33142495, -0.36337385, 0.12040648), vec4(0.077757, 0.0066281515, 0.20017838, 0.11544311), vec4(0.095890366, 0.022225933, -0.11293014, -0.34008574)) * bufB[0] + mat4(vec4(0.042057782, -0.11760418, -0.0076514427, 0.10912386), vec4(-0.22701403, 0.044532955, 0.41663957, -0.012757724), vec4(-0.0014435942, -0.047949716, 0.089169756, 0.23290712), vec4(0.17587504, -0.019285396, 0.04744393, 0.13982219)) * bufB[1] + mat4(vec4(0.092570305, -0.07192292, 0.055032916, -0.06884011), vec4(0.022869289, -0.19426122, 0.29573762, 0.022388553), vec4(-0.33703166, -0.12422418, -0.24536926, 0.042044014), vec4(0.029025964, 0.3237375, -0.235502, -0.31067017)) * bufB[2] + mat4(vec4(0.10140501, -0.24257568, 0.4417448, -0.33034506), vec4(0.07901319, 0.10041013, -0.20015316, -0.1477448), vec4(0.10925409, -0.286202, -0.24554344, 0.08675419), vec4(-0.03601872, 0.336365, -0.09399448, -0.29758093)) * bufB[3] + mat4(vec4(0.16918233, 0.09278764, -0.06759332, -0.24149892), vec4(0.023888128, -0.04621064, -0.15091912, -0.17686704), vec4(0.06909965, -0.07718372, 0.3648079, 0.09720598), vec4(0.41102165, -0.006446347, 0.21109743, -0.17303628)) * bufB[4] + mat4(vec4(-0.18222745, -0.28924537, -0.042289477, -0.044622764), vec4(0.06590158, 0.20128417, -0.102477156, 0.28460217), vec4(-0.46993452, 0.08258647, 0.068882465, 0.07342406), vec4(0.1073091, 0.16018705, -0.031465363, -0.13428776)) * bufB[5] + mat4(vec4(-0.22322811, -0.07429118, 0.15521543, 0.1813492), vec4(-0.47649613, 0.116867185, 0.28229624, -0.25443786), vec4(0.3977926, 0.45747936, -0.25634125, -0.101015866), vec4(-0.25141975, 0.019537503, -0.028466893, -0.37223917)) * bufB[6] + mat4(vec4(0.117988154, -0.10495977, 0.22906923, 0.046950955), vec4(-0.10702314, -0.5906195, 0.015940117, 0.33634585), vec4(0.11230944, 0.17258583, -0.30240783, 0.09250878), vec4(0.2954357, -0.111861885, 0.010382944, -0.129878)) * bufB[7];\nbufA[2] = vec4(0.0014226078, 0.18108448, 0.05594689, 0.05470278) + mat4(vec4(0.10954096, 0.22918543, 0.3061698, -0.08253376), vec4(-0.33712223, 0.09764458, 0.4758913, -0.0684582), vec4(-0.27978605, 0.1564769, 0.008109985, -0.07879867), vec4(0.2457603, -0.10547976, -0.12186126, -0.08690713)) * bufB[0] + mat4(vec4(0.001307446, -0.27701598, 0.02445424, -0.033733327), vec4(0.11471109, -0.031824324, -0.5936979, 0.22847928), vec4(-0.05192838, 0.050274182, -0.14364696, -0.08031055), vec4(-0.16594268, 0.17244302, -0.1503155, -0.38164017)) * bufB[1] + mat4(vec4(-0.11898521, 0.29948294, 0.11725536, 0.18861745), vec4(0.018878434, 0.18979536, -0.06296623, -0.32179847), vec4(-0.3577774, 0.18228978, 0.06880394, -0.11566647), vec4(-0.16475095, 0.044562664, 0.09154193, 0.059640754)) * bufB[2] + mat4(vec4(0.30588472, -0.30461273, 0.0035282387, 0.36218557), vec4(0.044588875, -0.24393404, 0.12973331, 0.08484998), vec4(-0.032318782, 0.10468461, 0.1507965, 0.08605477), vec4(0.06014255, 0.26094103, 0.1335347, -0.39420515)) * bufB[3] + mat4(vec4(0.088977434, -0.05873104, -0.44169465, -0.058169886), vec4(-0.044818234, -0.1724443, -0.124501504, 0.2011478), vec4(0.031819794, -0.48597184, -0.114723876, -0.15261127), vec4(-0.061014436, -0.17337944, 0.012049411, -0.1325832)) * bufB[4] + mat4(vec4(-0.61291885, 0.18889964, 0.01356514, -0.118787475), vec4(0.35619727, -0.26709816, 0.22002758, -0.41361997), vec4(0.28885898, 0.20870127, -0.21409018, 0.0012242566), vec4(-0.46700996, -0.59712875, -0.3702499, 0.28041768)) * bufB[5] + mat4(vec4(0.20644677, -0.45786688, -0.14659709, 0.3342389), vec4(-0.057896856, 0.11313018, -0.27392876, -0.10035008), vec4(0.23946394, 0.23512752, -0.29249173, 0.07384836), vec4(0.023341818, -0.24521895, 0.0602615, -0.17677595)) * bufB[6] + mat4(vec4(0.06651006, 0.13660838, 0.09524751, -0.3289074), vec4(0.14700602, -0.2309903, -0.015065451, -0.17629655), vec4(-0.36019328, 0.32891062, 0.20687927, 0.011469798), vec4(-0.08323675, 0.3009442, 0.060897816, 0.3573505)) * bufB[7];\nbufA[3] = vec4(0.06078902, 0.0263254, -0.106270835, 0.030020174) + mat4(vec4(0.03708064, 0.22929701, 0.044884324, -0.21493223), vec4(-0.40160522, -0.24646115, 0.18690109, -0.2032443), vec4(0.23964812, -0.22865337, 0.32984507, 0.10486585), vec4(-0.022197727, 0.2025173, -0.23888655, 0.0023832961)) * bufB[0] + mat4(vec4(0.18838643, 0.14116439, 0.19106849, 0.13343848), vec4(-0.0883966, -0.21011116, 0.16435425, 0.043351747), vec4(0.18879229, 0.13353631, 0.054724164, -0.2443976), vec4(0.044938724, 0.15219149, 0.21762706, -0.0058947043)) * bufB[1] + mat4(vec4(0.41836828, 0.29484752, 0.05882771, 0.079897374), vec4(-0.19906333, 0.096838646, 0.077307634, 0.13146348), vec4(0.14618056, 0.11432545, -0.21011887, -0.048496388), vec4(0.1707215, 0.59611404, -0.07861439, 0.028754042)) * bufB[2] + mat4(vec4(-0.16999273, -0.016694674, 0.08543361, 0.03482683), vec4(0.18958884, 0.4390058, 0.086200014, -0.118864164), vec4(0.06267322, -0.11324204, -0.07983137, -0.20616241), vec4(0.4628982, 0.20565395, 0.15767208, -0.3097559)) * bufB[3] + mat4(vec4(0.051855396, 0.013009268, 0.14055882, -0.12885886), vec4(-0.10007832, -0.20493273, -0.10618122, -0.07165679), vec4(-0.05852887, 0.20383213, 0.037903555, 0.09195614), vec4(0.44333023, -0.013326078, -0.0162471, -0.44160548)) * bufB[4] + mat4(vec4(-0.21731843, 0.07918449, 0.19121483, 0.022961667), vec4(0.26618642, 0.2374836, -0.20453393, 0.2201216), vec4(-0.059189502, 0.22872579, 0.10808795, 0.0280353), vec4(-0.24957147, 0.15962766, 0.12103716, 0.23951101)) * bufB[5] + mat4(vec4(-0.3690102, 0.34488702, -0.16457884, -0.28702092), vec4(-0.23489518, -0.2817006, -0.07234193, 0.124722116), vec4(0.25547472, -0.12553005, 0.022584094, 0.2921667), vec4(-0.091302596, 0.026706845, 0.2748765, -0.19317807)) * bufB[6] + mat4(vec4(-0.15531854, -0.17430173, -0.19190243, -0.14953338), vec4(0.11733544, -0.046222724, 0.52953607, 0.05597632), vec4(0.15473704, 0.085916854, 0.22432072, -0.2679783), vec4(-0.47191402, -0.18220136, 0.004501957, 0.25262737)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.008659524, 0.13896865, 0.20719159, -0.13253284) + mat4(vec4(0.2538267, 0.058676336, 0.18251145, -0.16517329), vec4(-0.16966642, 0.2942402, 0.09012356, -0.057658993), vec4(-0.072281644, -0.05285255, 0.10770886, -0.030593619), vec4(-0.10999975, -0.06638536, -0.07263863, -0.09633157)) * bufB[0] + mat4(vec4(-0.09763893, 0.13928618, 0.15668647, 0.087941386), vec4(-0.15842365, 0.26538095, 0.23462313, 0.10346431), vec4(0.27764463, 0.0022857885, -0.26453453, 0.15666498), vec4(-0.16721053, -0.22264762, 0.014069604, -0.4223739)) * bufB[1] + mat4(vec4(0.17275366, 0.21312284, 0.042952135, -0.004911232), vec4(0.11609789, -0.21141662, 0.15810716, -0.03505625), vec4(0.14910527, 0.2146849, 0.46997854, -0.34459475), vec4(0.005601259, 0.07973084, -0.073866464, -0.29238552)) * bufB[2] + mat4(vec4(0.08242545, 0.40047956, 0.10634125, -0.21746986), vec4(-0.03875481, -0.07239307, 0.07710221, -0.2929328), vec4(0.31435114, 0.09745779, -0.20338416, -0.389185), vec4(0.564487, -0.3493018, -0.1291495, 0.14967236)) * bufB[3] + mat4(vec4(0.0148455, -0.25201496, -0.28163424, 0.25755665), vec4(-0.096878454, -0.19581626, 0.10315153, 0.25291827), vec4(0.028854093, -0.15653405, -0.04739351, 0.4456272), vec4(-0.029195651, -0.056986466, 0.30047086, -0.36159402)) * bufB[4] + mat4(vec4(0.16893893, -0.022455709, -0.17422476, -0.07583615), vec4(-0.23874605, -0.16432445, 0.01116653, 0.02811502), vec4(-0.41542846, 0.13600658, 0.15379533, -0.39249787), vec4(-0.052016344, -0.13817677, -0.102939054, -0.2909199)) * bufB[5] + mat4(vec4(0.08263286, 0.121487126, -0.11061312, 0.19867612), vec4(0.15213636, -0.13242385, 0.10190352, -0.0359659), vec4(-0.34982964, -0.22332872, 0.44205332, -0.36106947), vec4(-0.5919018, -0.22307222, 0.07409882, -0.15649429)) * bufB[6] + mat4(vec4(0.08633056, 0.0026700876, 0.11525046, 0.7334044), vec4(0.0674368, -0.07955788, -0.41075516, 0.7239343), vec4(-0.024916321, 0.2753463, 0.4540179, -0.21127824), vec4(-0.25300312, 0.23359543, -0.23688899, -0.10057053)) * bufB[7];\nbufA[1] = vec4(-0.010253543, 0.11845847, -0.06700246, -0.070128694) + mat4(vec4(-0.00975535, -0.14190648, -0.053803492, 0.2700528), vec4(0.16922927, 0.034736633, -0.15109386, 0.10039582), vec4(0.3945825, -0.18928128, -0.09652841, 0.3729427), vec4(-0.115050085, 0.081185006, -0.13573278, -0.2886958)) * bufB[0] + mat4(vec4(0.0324379, 0.28761262, 0.47459313, -0.048865728), vec4(-0.07831431, 0.09179615, -0.030803828, 0.06869656), vec4(-0.061162814, -0.0643675, 0.18950424, 0.47761944), vec4(-0.38236815, 0.0010762117, -0.19887772, 0.28486678)) * bufB[1] + mat4(vec4(0.2618422, 0.13826865, 0.40180716, 0.2946186), vec4(-0.14434992, 0.13371179, 0.18607263, 0.15528706), vec4(-0.22169557, 0.14503364, -0.25171143, -0.13324313), vec4(-0.22440895, -0.20075263, -0.34978303, -0.1123877)) * bufB[2] + mat4(vec4(0.3173881, -0.24030599, 0.5330754, 0.13474362), vec4(-0.115182325, 0.3259539, 0.037811138, 0.40254006), vec4(-0.23699816, 0.007412058, -0.47459197, 0.16800451), vec4(-0.09565125, -0.35751024, -0.26539606, -0.024293413)) * bufB[3] + mat4(vec4(0.08400804, 0.16448952, -0.26880506, -0.04750064), vec4(-0.22719581, -0.19195539, 0.2746393, 0.18470757), vec4(0.30708915, -0.22117797, -0.09705254, 0.027309183), vec4(-0.47473305, -0.2807709, -0.10771416, 0.04660897)) * bufB[4] + mat4(vec4(0.70818657, -0.018289506, 0.16403873, -0.45456174), vec4(0.12239469, -0.2969133, 0.21998511, 0.4553886), vec4(0.18906124, -0.044468448, 0.04680858, -0.023110135), vec4(-0.1253242, -0.29148623, -0.5340617, -0.2868094)) * bufB[5] + mat4(vec4(0.6301106, 0.26093113, 0.014776035, -0.13901314), vec4(0.1136367, -0.07073197, -0.20277014, -0.14790323), vec4(-0.021096865, -0.14768943, 0.16093855, 0.19120881), vec4(0.16507243, 0.13477619, -0.023409277, 0.17739475)) * bufB[6] + mat4(vec4(-0.08372462, -0.27883157, 0.2082229, 0.34746003), vec4(-0.6794335, 0.10153871, -0.35110605, -0.02565731), vec4(-0.31311572, 0.13830411, -0.19402494, -0.6173469), vec4(-0.3284254, -0.068640135, 0.20647852, 0.1989239)) * bufB[7];\nbufA[2] = vec4(-0.03006415, 0.26772273, -0.0039509884, -0.15091774) + mat4(vec4(-0.031415183, 0.087866254, 0.12056083, 0.035957403), vec4(0.045347467, -0.16916068, 0.068533584, 0.14617038), vec4(0.061970145, 0.13553716, -0.16422263, -0.25467083), vec4(0.13199674, -0.30614644, 0.42531303, -0.20412365)) * bufB[0] + mat4(vec4(0.23020358, -0.105096154, -0.27251962, -0.1567153), vec4(0.011990239, -0.017223371, 0.016260479, -0.32198057), vec4(-0.04795313, -0.18440984, 0.22415084, -0.14788067), vec4(-0.1814249, 0.22933383, 0.16735113, -0.20212281)) * bufB[1] + mat4(vec4(-0.18605727, -0.41135255, -0.36705193, -0.00784761), vec4(0.17606442, -0.2531343, 0.18136838, -0.1475955), vec4(0.22729139, -0.06377001, 0.08565687, -0.14645441), vec4(-0.28144774, 0.07697351, 0.642412, -0.2590077)) * bufB[2] + mat4(vec4(0.03862418, -0.14180225, 0.38178977, -0.044708602), vec4(-0.23925765, -0.13151257, -0.19455959, 0.11365497), vec4(0.022421326, -0.0594604, -0.14479372, 0.11244611), vec4(-0.29260474, 0.2499954, -0.4569944, 0.117615975)) * bufB[3] + mat4(vec4(-0.09733348, -0.70816743, -0.39928365, 0.24135865), vec4(0.19998774, 0.3414118, -0.09899232, -0.29480934), vec4(0.36903983, -0.36922345, 0.30145103, 0.27266648), vec4(0.0723216, -0.39017865, -0.27715817, 0.012958095)) * bufB[4] + mat4(vec4(0.090773314, 0.07258846, 0.20505373, -0.06344248), vec4(0.35722658, -0.31354472, 0.40549332, -0.19002843), vec4(-0.029057251, 0.32293862, -0.13676256, 0.3835807), vec4(0.31918088, -0.29060408, 0.18808053, 0.0036034787)) * bufB[5] + mat4(vec4(-0.17771098, -0.10699173, 0.18275395, 0.11504387), vec4(-0.33185703, 0.11591176, 0.07303012, 0.38057178), vec4(0.45859456, -0.29742837, -0.33328438, -0.11177309), vec4(-0.15438153, -0.042431723, 0.4411904, 0.07446238)) * bufB[6] + mat4(vec4(0.038738884, 0.2330852, 0.056642152, -0.43330517), vec4(-0.21146952, 0.00799525, 0.17909972, -0.120695725), vec4(0.1578295, 0.089416236, 0.11984588, 0.2488035), vec4(0.10453331, -0.13445789, -0.48852503, 0.4234623)) * bufB[7];\nbufA[3] = vec4(-0.07532936, 0.07956913, -0.011387418, -0.036479667) + mat4(vec4(0.36350667, -0.05666064, -0.021973247, -0.21061221), vec4(0.20310919, 0.03181924, 0.13943042, -0.03124947), vec4(0.08529683, -0.51282585, -0.30048978, -0.07056396), vec4(0.059908997, 0.18077366, 0.09338182, -0.101343066)) * bufB[0] + mat4(vec4(0.36625, -0.29182464, -0.054958582, 0.38941061), vec4(0.058564436, -0.14727592, 0.094741106, -0.13252325), vec4(0.16572765, -0.23608555, -0.49733946, -0.1762938), vec4(0.2716811, -0.10744113, 0.15835631, -0.12221606)) * bufB[1] + mat4(vec4(0.26542667, -0.08752734, -0.011805017, -0.2933594), vec4(-0.15029559, 0.16958675, 0.27210695, -0.00084592483), vec4(-0.022908356, 0.28883302, 0.14798588, -0.1859789), vec4(-0.15554501, 0.01666535, -0.076530255, 0.27927268)) * bufB[2] + mat4(vec4(0.133365, -0.24087556, -0.015117578, -0.017878015), vec4(-0.016917909, 0.04444952, 0.122061715, -0.02022217), vec4(0.18051755, 0.17667027, -0.045875166, 0.2477773), vec4(0.07500952, 0.040779423, -0.36225685, 0.5216184)) * bufB[3] + mat4(vec4(-0.108113855, -0.1299506, 0.041907944, -0.15751083), vec4(0.27800882, 0.32515815, 0.24606836, 0.5217485), vec4(0.043559924, -0.3517873, -0.12749048, -0.22871415), vec4(0.074866064, -0.5058325, -0.034348637, 0.011342927)) * bufB[4] + mat4(vec4(0.09596191, 0.052627463, 0.063195154, -0.23167117), vec4(-0.056604575, -0.12483692, -0.08464235, -0.18444258), vec4(0.07514917, -0.09152633, -0.23945837, 0.06342518), vec4(0.24449338, 0.13372377, 0.1306023, 0.44973034)) * bufB[5] + mat4(vec4(-0.55843425, -0.35226893, 0.115407445, 0.08358865), vec4(-0.5640226, 0.5004561, 0.31139556, -0.1374765), vec4(-0.21400036, -0.07303242, 0.041994058, -0.326192), vec4(0.111593515, -0.4178491, -0.17098877, 0.31326076)) * bufB[6] + mat4(vec4(0.4662072, -0.019523665, 0.05299573, -0.08354999), vec4(-0.2803353, 0.3109778, 0.11745559, 0.5279129), vec4(0.10839666, -0.25435495, 0.2820068, -0.22322878), vec4(0.39722922, -0.019412387, -0.51989794, -0.38795224)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.09276742488145828, 0.006313864141702652, 0.09400972723960876, 0.0) + mat4(vec4(-0.009082479402422905, -0.09618537873029709, -0.05412061884999275, 0.0), vec4(-0.1024560034275055, -0.009011960588395596, -0.10777462273836136, 0.0), vec4(0.10663172602653503, 0.01759677194058895, 0.0405387207865715, 0.0), vec4(-0.05050364136695862, -0.08828376233577728, -0.07829759269952774, 0.0)) * bufB[0] + mat4(vec4(0.03429563343524933, 0.07135413587093353, 0.04201420769095421, 0.0), vec4(0.005571917165070772, -0.019401568919420242, 0.11412903666496277, 0.0), vec4(0.020174480974674225, -0.06661857664585114, -0.0535488985478878, 0.0), vec4(-0.11750896275043488, -0.07272236049175262, -0.09138499200344086, 0.0)) * bufB[1] + mat4(vec4(0.0736083835363388, 0.019975261762738228, 0.04345898702740669, 0.0), vec4(-0.07747188955545425, -0.047622401267290115, -0.05897551774978638, 0.0), vec4(0.04516145586967468, 0.0470823310315609, 0.00815138965845108, 0.0), vec4(0.06326532363891602, 0.04919764772057533, 0.1357603818178177, 0.0)) * bufB[2] + mat4(vec4(-0.018590908497571945, -0.021667737513780594, -0.06427363306283951, 0.0), vec4(-0.01847735233604908, 0.01852480135858059, 0.11320092529058456, 0.0), vec4(-0.029709089547395706, 0.08342652022838593, 0.03224649280309677, 0.0), vec4(-0.019444430246949196, 0.007755672093480825, 0.10132010281085968, 0.0)) * bufB[3] + mat4(vec4(0.07365400344133377, 0.015257793478667736, -0.09280645847320557, 0.0), vec4(0.01364419236779213, -0.0906759724020958, -0.09422896802425385, 0.0), vec4(0.11033598333597183, 0.04519486799836159, -0.08464454114437103, 0.0), vec4(0.11080411076545715, 0.1359335482120514, 0.12313579767942429, 0.0)) * bufB[4] + mat4(vec4(0.1463177651166916, 0.15343278646469116, 0.16645309329032898, 0.0), vec4(-0.15586480498313904, -0.12489683926105499, 0.0077819605357944965, 0.0), vec4(0.08433365821838379, 0.0905037373304367, 0.036559220403432846, 0.0), vec4(0.025482652708888054, 0.07461335510015488, 0.15126948058605194, 0.0)) * bufB[5] + mat4(vec4(-0.10709093511104584, -0.11167994141578674, -0.16960687935352325, 0.0), vec4(-0.19009053707122803, -0.1603417843580246, -0.11009759455919266, 0.0), vec4(-0.14509636163711548, -0.1415204405784607, -0.13188472390174866, 0.0), vec4(-0.12020419538021088, -0.1305268108844757, -0.05733203515410423, 0.0)) * bufB[6] + mat4(vec4(0.08011387288570404, 0.11546795815229416, 0.12679047882556915, 0.0), vec4(-0.17172864079475403, -0.13398389518260956, -0.21410366892814636, 0.0), vec4(0.006712683476507664, 0.042790357023477554, 0.12579475343227386, 0.0), vec4(-0.12514819204807281, -0.08413729816675186, -0.1964339017868042, 0.0)) * bufB[7];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(2., -2.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.01*sin(iTime), 50.01*sin(0.09*iTime), 0.2*sin(0.04*iTime), sin(0.13*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 142, 142, 71483], [71485, 71485, 71542, 71592, 72037]]}
{"id": "WlBGRG", "name": "floating light line effect", "author": "ankd", "description": "floating light line effect using 3D noise.", "tags": ["2d", "effect"], "likes": 6, "viewed": 243, "published": "Public", "date": "1559894815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tfloating light line effect\n\tauthor - ankd\n*/\n\n#define SPEED_Y 3.0\n#define SPEED_Z 2.8\n#define POWER 9.0\n#define UV_WIDTH vec2(60.0, 1.0)\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y -= iTime*SPEED_Y;\n    vec3 col = vec3(pow(snoise(vec3(uv*UV_WIDTH, iTime*SPEED_Z)), POWER));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 534, 555, 555, 604], [605, 605, 626, 626, 675], [676, 676, 698, 698, 738], [739, 739, 767, 767, 819], [820, 820, 844, 844, 2983], [2985, 2985, 3042, 3092, 3293]]}
{"id": "wlBGWc", "name": "fractal--complex---v4", "author": "jorge2017a1", "description": "fractal--complex---v4", "tags": ["fractalcomplexv4"], "likes": 3, "viewed": 51, "published": "Public", "date": "1561338963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n//hecho por jorge flores p.....23/jun-2019\n\nstruct complex\n{\n    float re;\n    float im;\n}; \n\nconst float M_PI = 3.14159265359;\n\ncomplex complex_set(float re , float im)\n{\n\tcomplex cout;\n    cout.re = re;\n    cout.im = im;\n    return cout;\n}\n    \n\ncomplex complex_neg(complex p) \n{\n    complex cout;\n    cout.re = -p.re;\n    cout.im = -p.im;\n    return cout;\n}\n   \n\ncomplex complex_add(complex c1 , complex c2) \n{\n\t\n    complex cout;\n    cout.re = c1.re + c2.re;\n    cout.im = c1.im + c2.im;\n    return cout;\n}    \n\n\n\ncomplex complex_multiply(complex a, complex b) \n{\n    complex cout;\n\tcout.re= a.re * b.re - a.im * b.im;\n    cout.im =a.im * b.re + a.re * b.im;\n    return cout;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) \n{\n    return complex_multiply(a, a);\n}\n\n\ncomplex complex_sub(complex  c1 ,complex  c2) \n{\n    complex cout;\n\n    cout.re = c1.re - c2.re;\n    cout.im = c1.im - c2.im;\n    return  cout;\n}\n\n\n\n\n/*vec2 cmpxpow(in vec2 c, int p) {\n    vec2 orig = c;\n\tfor (int i = 0; i < p-1; ++i) {\n\t\tc = cmpxmul(c, orig);\n\t}\n    return c;\n}\n*/\n\n\nfloat complex_mag(complex c)\n{\n    \n    return sqrt(c.re * c.re + c.im * c.im);\n}\n\n\n\ncomplex complex_exp(complex z) \n{\n    complex tmp;\n    complex cout;\n    tmp.re= cos(z.im);\n    tmp.im= sin(z.im);\n    \n    cout.re=exp(z.re)*tmp.re;\n    cout.im=exp(z.re)*tmp.im;\n    \n    \n    return cout;\n}\n\n\n\nfloat complex_norm(complex c )\n{\n\tfloat result ;\n    \n    result = c.re * c.re + c.im * c.im;\n        \n    return  result;\n}\n    \n\ncomplex complex_pow(complex a, float b) \n{\n    float r = complex_mag(a);\n    float theta = atan(a.im, a.re);\n    complex tmp;\n    \n    tmp.re=b * log(r);\n    tmp.im=b *  theta;\n    \n    return complex_exp(tmp);\n    \n}\n\nvec3 getColor(float v)\n{\n    /*vec3 col = vec3(0.1) * sin(v);\n    col = mix(col, vec3(0.1, 0.2, 0.4), sin(1.-v));\n    col = mix(col, vec3(0.1, 0.2, 0.7), pow(sin(1.-v),2.));\n    return col;*/\n\t\n    float a = 1.;\n    float b = 0.2357022603955158;  // 1/3*sqrt(2)\n    float c = 0.12452650612453368; // 1/7*3^(1/8)\n    return vec3((1.-cos(a*v))*0.5, (1.-cos(b*v))*0.5, (1.-cos(c*v))*0.5);\n}\n\n\nvec3 mandelbrot(vec2 frag )\n{\n    \n\n  float maxI; \n  float Bailout;\n  complex z;\n  complex c;\n  float x;\n  float y;\n  float iter; \n  float it;  \n    \n    x=frag.x;\n    y=frag.y;\n    \n    z.re = x; \n    z.im = y;\n    \n    c.re = 0.5;\n    c.im = 0.0;\n    \n    Bailout = 10.0;\n    \n  maxI=255.0;\n    \n  float tmp;\n    //for(float i = 0.; i < 15.; i++) \n    \n    for( iter = 0.0; iter< maxI; iter++)\n    {\n         z =complex_add(complex_pow(z, 2.0), c);\n         \n           \n        tmp=abs(z.re);\n        if (tmp > Bailout )\n        {       break;        }\n        \n        tmp=abs(z.im);\n         if ( tmp > Bailout )\n        {    break;    }\n         \n                            \n         if (complex_norm(z) > 100.0 )\n         { break;  }\n    }\n                      \n    \n     if ( abs(z.re) < Bailout )\n     {\n        it = iter / 255.0;\n     }\n     else\n     {\n        it = iter + 1.0;    \n         \n     }\n    \n    \n    \n      if (abs(z.im) < Bailout )\n       {\n     \t\n        it = iter / 255.0;\n       }\n        else\n       {\n        it = iter + 1.0;    \n       }\n\n    \n    \n    \n    vec3 col;\n    //color3 = vec3(it*1.0 / maxI);\n\t//col = vec3(it*1.0 / maxI,it*1.0 / maxI,it*1.0 / maxI);\n    //col = vec3(it*1.0 ,it*1.0 ,it*1.0 );\n\tcol= getColor(it*1.0);\n\t\n         \n    return col;\n}\n    \n\n\n\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;                \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\nz *= SCALE*0.5 + 5.5*cos(iTime);\n    \t\n    col=mandelbrot(z);\n    \n        \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 187, 229, 229, 299], [306, 306, 339, 339, 418], [424, 424, 471, 471, 568], [576, 576, 625, 625, 739], [741, 773, 809, 809, 846], [849, 849, 897, 897, 994], [999, 1134, 1164, 1164, 1215], [1219, 1219, 1252, 1252, 1427], [1431, 1431, 1463, 1463, 1555], [1562, 1562, 1604, 1604, 1779], [1781, 1781, 1805, 1972, 2168], [2171, 2171, 2200, 2200, 3462], [3478, 3478, 3535, 3535, 4015]]}
{"id": "wlBGWt", "name": "Julia distance estimator", "author": "matistjati", "description": "A julia set colored using distance estimation", "tags": ["distanceestimation", "juliaset", "jula"], "likes": 2, "viewed": 108, "published": "Public", "date": "1561669908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float escapeRadius = 128.;\nconst float speed = .225;\n\n//const vec2 origin = vec2(-0.05,.6805);\nconst vec2 origin = vec2(0.);\n\nvec2 cMul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 cPow(vec2 z, float p)\n{\n\n    float r = pow(length(z),abs(p));\n\n   \tfloat theta = atan(z.y, z.x)*p;\n   \n    return r*vec2(cos(theta), sin(theta));\n}\n\nfloat dist(vec2 pos, vec2 c, out float iter)\n{\n    vec2 z = pos;\n    vec2 dz = vec2(0.);\n\n\tconst float maxIter = 250.;\n    \n    const float power = 2.;\n\n    \n    float m2;\n    float i=0.;\n    for(;i<maxIter;i++)\n    {\n        dz = 2.* mat2(z,-z.y,z.x) * dz + 1.;\n\t\t//z = cPow(z,power)+c;\n        z = mat2(z,-z.y,z.x)*z+c;\n        \n        m2 = dot(z,z);\n        if( m2>escapeRadius)\n            break;\n    }\n\n\n    iter = i/maxIter;\n\n    return sqrt( m2/dot(dz, dz))*0.5f*log(m2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tz = 0.5-0.5*abs(cos(speed*iTime));\n\n    float zoom = pow( 0.5, 13.0*tz );\t\n    \n\tvec2 uv = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 c = origin + uv;//*zoom;\n\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float iterations = 0.;\n\t\n    \n    float p = abs(sin(iTime*.3));\n    \n    float d = abs(dist(c, mix(vec2(0., 1.), vec2(0., .65), p), iterations));\n    \n    float t = clamp(pow(4.*d/zoom,.2),0.,1.);\n\n    fragColor = vec4((1.-t)*vec3(0.8, 0.,0.6),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 132, 159, 159, 209], [211, 211, 239, 239, 363], [365, 365, 411, 411, 846], [849, 849, 906, 906, 1398]]}
{"id": "WlBGzV", "name": "Dags raymarched terrain test 1", "author": "dagbrynildsentholander", "description": "simple raymarching scene, pretty straight forward rendering. Inspired by Inigo Quilez. Put together in about 3 hours.\n\nUpdate(2019-06-11)\nIncreased height of terrain, modified fov.", "tags": ["raymarching", "terrain", "space"], "likes": 10, "viewed": 492, "published": "Public API", "date": "1560182724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Dag Brynildsen Tholander 2019 06 10\n\nvec3 lightDir = vec3(1.,1.,1.);\nvec3 lightColor = vec3(1,.8,.75);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*12.+p.y*525.)*1256.);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    vec2 id = floor(p*1.);\n    vec2 ld = fract(p*1.);\n    ld = ld*ld*(3.-2.*ld);\n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n        \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return bt;\n}\n\nfloat map(vec3 p)\n{\n    float a = p.y/1.3;\n    p+=vec3(cos(a), 0, sin(a)); // achieves the effect of 3d noise by morphing the 2d noise\n    float base = 0.;\n    base+=1.15*pow(smoothNoise(p.xz/30.), .5);\n    base+=.25*pow(smoothNoise(p.xz/10.), 3.);\n    base+=.125*pow(smoothNoise(p.xz/5.), 3.);\n    base+=.02*pow(smoothNoise(p.xz), 2.);\n    base+=.005*smoothNoise(p.xz*3.);\n    return base*30.-p.y*1.3; // as suggested by Dave_Hoskins\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.01;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p);\n    vec3 grad = vec3(val - map(p - x), val - map(p - y), val - map(p - z));\n    return -normalize(grad);\n}\n\nfloat ray(vec3 ro, vec3 rd, float minD, float maxD, float stepsize)\n{\n    float t = minD;\n    float lastVal;\n    \n    while(t < maxD)\n    {\n        vec3 p = ro+rd*t;\n        float val = map(p);\n\n        if(val>0.)\n            return t-(abs(val)/(abs(val)+abs(lastVal)))*stepsize; // my way of doing a linear interpolation to get closest to the 'terrain'\n        \n        t+=stepsize;\n        stepsize*=1.01; // increase stepsize with distance, increases performance but causes artifacts and errors\n        lastVal = val;\n    }\n    return t;\n}\n\nvec3 lighting(vec3 n, vec3 ambientLight)\n{\n    return  max(dot(normalize(lightDir), n), 0.0) * lightColor * 1. +ambientLight;\n}\n\nvec3 fog(vec3 rgb, vec3 rd, float dist, float maxDist)\n{\n    vec3 fogColor = mix(vec3(.4,.4,.7), vec3(0), rd.y*1.2);\n    fogColor += vec3(.3,.2,.2)*pow(1.-abs(rd.y), 6.);\n    fogColor+=.75*lightColor*pow(clamp(dot(normalize(rd), normalize(lightDir)), 0., 1.),5.);\n\tif(dist>maxDist-0.5)\n    {\n        fogColor+= lightColor*pow(clamp(dot(normalize(rd), normalize(lightDir)), 0., 1.),500.);\n    }\n    return mix(rgb, fogColor, dist/maxDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // cam setup\n    vec3 camRot = vec3(0, iTime/10., 0.);\n    vec3 camDir = vec3(sin(camRot.y), 0, cos(camRot.y));\n    vec3 camRight = cross(camDir, vec3(0,1.,0));\n    vec3 camPos = vec3(0., 30., iTime);\n\n    vec3 rayDir = camDir + camRight*2.5*(uv.x-0.5)+ vec3(0,1.,0)*2.5*(uv.y-0.5); // changes were made kind of as suggested by Shane\n    float viewDist = 100.;\n    \n\t// raymarching\n\tfloat rayResult = ray(camPos, rayDir, 0.5, viewDist, 0.06);\n    vec3 hitPoint = rayResult*rayDir+camPos;\n    \n    // Triplanar texturing\n    \n    vec3 n = normal(camPos+rayDir*rayResult);\n    float xAlpha = pow(abs(n.x), 3.);\n    float yAlpha = pow(abs(n.y), 5.);\n    float zAlpha = pow(abs(n.z), 3.);\n    vec3 terrainColor = vec3(0);\n    terrainColor += texture(iChannel0, vec2(hitPoint.z, hitPoint.y)/3.).xyz*xAlpha;\n    terrainColor += texture(iChannel1, vec2(hitPoint.x, hitPoint.z)/3.).xyz*yAlpha;\n    terrainColor += texture(iChannel0, vec2(hitPoint.x, hitPoint.y)/3.).xyz*zAlpha;\n    \n    // Final color\n    vec3 col = fog(lighting(n, vec3(.1,.1,.1)).xyz*terrainColor, rayDir,rayResult,viewDist);\n    \n    //col = vec3(smoothNoise(uv)); visualize noise\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 131, 131, 180], [182, 182, 209, 209, 567], [569, 569, 588, 588, 1005], [1007, 1007, 1028, 1028, 1296], [1298, 1298, 1367, 1367, 1840], [1842, 1842, 1884, 1884, 1969], [1971, 1971, 2027, 2027, 2411], [2413, 2413, 2470, 2520, 3771]]}
{"id": "wlj3D1", "name": "Sponge inside", "author": "avin", "description": "raymarching experiment", "tags": ["raymarching", "infinity"], "likes": 5, "viewed": 440, "published": "Public API", "date": "1559454240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLACK_COL vec3(23, 32, 38) / 255.0\n#define WHITE_COL vec3(245, 248, 250) / 255.0\n\nfloat map(vec3 p) {\n    return length(mod(p, 2.0) - 1.0) - 1.3;\n}\n\nvec3 getNormal(vec3 p) {\n    float t = map(p);\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(vec3(t - map(p + d.xyy), t - map(p + d.yxy), t - map(p + d.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 camDir = normalize(vec3(uv * 1.0, (sin(iTime) * 0.5 + 0.5) * 0.75 + 0.25));\n    vec3 camPos = vec3(1.0, (cos(iTime) * 3.0) - 1.57 , - iTime * 2.5);\n\n    float t = -0.5;\n    for(int i = 0 ; i < 100; i += 1) {\n        t += map(camDir * t + camPos);\n    }\n    vec3 surf = camDir * t + camPos;\n    vec3 light = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 normal = getNormal(surf);\n\n    vec3 col = mix(BLACK_COL, WHITE_COL, dot(light, normal));\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlj3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 109, 109, 155], [157, 157, 181, 181, 324], [326, 326, 381, 381, 933]]}
{"id": "Wlj3DD", "name": "Palace on the Hill", "author": "dr2", "description": "Day/night, inside/outside views (mouse in small window to select view)", "tags": ["raymarch", "cloud", "architecture", "building"], "likes": 14, "viewed": 450, "published": "Public API", "date": "1559641972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Palace on the Hill\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nbool HexNeb (vec2 a, vec2 b);\nvec2 SSBump (float w, float s, float x);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, bSize, drSize;\nvec2 gId, hillPos;\nfloat tCur, dstFar, baseHt, wallThk, hgSize, drAng, hillRad;\nint idObj;\nbool isShad, isNt;\nconst int idWall = 1, idFlr = 2, idRoof = 3, idWbar = 4, idChim = 5, idDoor = 6,\n   idRail = 7, idLmp = 8, idTabl = 9, idGrnd = 10;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat BldDf (vec3 p)\n{\n  vec3 q, pAbs, pMod;\n  float dMin, d, twrRad, dWin, dTwr, dDoor, rUp, rRad;\n  twrRad = 0.5;\n  pMod = vec3 (mod (p.xz + 0.5, 1.) - 0.5, mod (p.y, bSize.y) - 0.5 * bSize.y).xzy;\n  pAbs = abs (vec3 (p.xz, pMod.y - 0.1).xzy) - bSize;\n  dMin = dstFar;\n  q = p;\n  d = max (PrBoxAn2Df (q.xz, bSize.xz, wallThk), abs (q.y - bSize.y) - bSize.y);\n  dDoor = PrBox2Df ((q - vec3 (0., bSize.y - 1.05, 0.)).xy, drSize.xy);\n  d = max (d, - dDoor);\n  dWin = abs (q.y - bSize.y) - bSize.y;\n  q = vec3 (pMod.xz, pMod.y - 0.1).xzy;\n  dWin = max (dWin, min (max (PrBox2Df (q.xy, vec2 (0.2, 0.6)), pAbs.x + 0.7),\n     max (PrBox2Df (q.zy, vec2 (0.2, 0.6)), pAbs.z + 0.7)));\n  d = max (d, - dWin);\n  dTwr = twrRad + 0.5 * wallThk - length (pAbs);\n  d = max (d, dTwr);\n  DMIN (idWall);\n  q = vec3 (pAbs.xz, p.y).xzy;\n  d = PrCylAnDf ((q - vec3 (0., bSize.y + 0.25, 0.)).xzy, twrRad, 0.07, bSize.y + 0.25);\n  q.y = pMod.y - 0.1;\n  d = max (d, - min (PrBox2Df (q.xy, vec2 (0.08, 0.6)), PrBox2Df (q.zy, vec2 (0.08, 0.6))));\n  DMIN (idWall);\n  q = p;\n  q.y = pMod.y - 0.1;\n  d = max (min (length (vec2 (pAbs.z, q.y)) - 0.3 * wallThk,\n     max (length (vec2 (pMod.x, pAbs.z)) - 0.3 * wallThk, pAbs.y)), pAbs.x + 0.7);\n  d = max (d, - dDoor);\n  d = min (d, max (min (length (vec2 (pAbs.x, q.y)) - 0.3 * wallThk,\n     max (length (vec2 (pAbs.x, pMod.z)) - 0.3 * wallThk, pAbs.y)), pAbs.z + 0.7));\n  d = max (d, abs (p.y - bSize.y) - bSize.y);\n  DMIN (idWbar);\n  q = p;\n  q.y = mod (p.y - 0.5 * wallThk + 0.5 * (bSize.y - 0.5 * wallThk),\n     bSize.y - 0.5 * wallThk) - 0.5 * (bSize.y - 0.5 * wallThk);\n  d = PrBoxDf (q, vec3 (bSize.xz, 0.5 * wallThk).xzy);\n  d = max (max (d, - max (PrBox2Df (q.xz, bSize.xz - 1.1), abs (p.y - bSize.y) - 0.2)), dTwr);\n  DMIN (idFlr);\n  rRad = 12.;\n  rUp = rRad - 0.721 + 0.01;\n  q = p;\n  q.y -= 2. * bSize.y - rUp;\n  d = min (PrCylDf (q.yzx, rRad, bSize.x + wallThk), PrCylDf (q, rRad, bSize.z + wallThk));\n  d = max (max (d, rUp - q.y), dTwr);\n  DMIN (idRoof);\n  q = vec3 (pAbs.xz, p.y - 2. * bSize.y - 0.9).xzy;\n  d = 0.7 * PrCylDf (q.xzy, (twrRad + 0.07) * (0.6 - 0.4 * q.y / 0.4), 0.4);\n  DMIN (idRoof);\n  q = p;\n  q.y -= 2. * bSize.y + 0.8;\n  d = min (PrBoxDf (q, vec3 (bSize.x + wallThk, 0.1, 0.2)),\n     PrBoxDf (q, vec3 (0.2, 0.1, bSize.z + wallThk)));\n  DMIN (idChim);\n  q.y -= 0.3;\n  q.xz = pMod.xz;\n  d = PrCylAnDf (q.xzy, 0.13, 0.05, 0.2);\n  q.xz = abs (p.xz);\n  d = max (d, max (min (q.x, q.z) - 0.5, 0.5 - min (bSize.x - q.x, bSize.z - q.z)));\n  DMIN (idChim);\n  q = vec3 (pAbs.x + bSize.x - drSize.x + 0.02, p.y - bSize.y + 1.05, pAbs.z - 0.5 * wallThk);\n  q.xz = Rot2D (q.xz, - drAng);\n  q.x -= 0.5 * drSize.x - 0.016;\n  d = PrRoundBoxDf (q, vec3 (0.5 * drSize.x - 0.005, drSize.y - 0.01, drSize.z), 0.005);\n  DMINQ (idDoor);\n  rRad = 0.02;\n  q = p;\n  q.y -= bSize.y + 0.4;\n  d = min (PrCylDf (vec3 (pAbs.x + 1., q.yz), rRad, bSize.z - 1.),\n     PrCylDf (vec3 (q.xy, pAbs.z + 1.).yzx, rRad, bSize.x - 1.));\n  q.xz = mod (q.xz + 0.25, 0.5) - 0.25;\n  q.y -= -0.2;\n  d = min (d, max (PrCylDf (q.xzy, rRad, 0.2), PrBoxAn2Df (p.xz, bSize.xz - 1., 0.1)));\n  DMIN (idRail);\n  rRad = 0.15;\n  q = p;\n  q.y -= 2. * bSize.y - wallThk - rRad;\n  q.xz = abs (abs (q.xz) - 0.5 * bSize.xz) - 1.5 * rRad;\n  d = PrSphDf (q, rRad);\n  DMIN (idLmp);\n  q = p;\n  q.xz = abs (abs (q.xz) - 0.5 * bSize.xz);\n  q.y -= 0.62;\n  d = PrCylDf (q.xzy, 0.3, 0.02);\n  q.y -= -0.32;\n  d = min (d, PrCylDf (q.xzy, 0.03, 0.3));\n  q.y -= 0.4;\n  d = min (d, PrCylDf (q.xzy, 0.01, 0.1));\n  DMIN (idTabl);\n  q.y -= 0.1;\n  d = PrSphDf (q, 0.3 * rRad);\n  DMIN (idLmp);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cId, rr;\n  float dMin, d, r;\n  q = p;\n  q.y -= baseHt;\n  if (! isShad) d = PrBoxDf (q + vec3 (0., - bSize.y, 0.), bSize + vec3 (1., 1.6, 1.));\n  dMin = (isShad || d < 0.1) ? BldDf (q) : d;\n  if (! isShad) {\n    q = p;\n    q.y -= -0.005;\n    q.y -= 5.01 * (1. - smoothstep (12., 28., length (q.xz)));\n    d = 0.8 * PrCylDf (q.xzy, 32., 0.001);\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat HillDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  if (length (gId) == 0. || HexNeb (gId, vec2 (0.))) d = dstFar;\n  else {\n    q = p;\n    q.xz -= HexToPix (gId * hgSize) + hillPos;\n    q.y += hillRad * smoothstep (0., hillRad, length (q.xz));\n    d = PrCylDf (q.xzy, hillRad, hillRad);\n  }\n  return d;\n}\n\nvoid SetHillConf ()\n{\n  vec2 rr;\n  rr = Hashv2v2 (gId);\n  hillRad = 0.4 * hgSize * (1. - 0.5 * length (rr));\n  hillPos = (0.7 * hgSize * rr.x - hillRad) * sin (2. * pi * rr.y + vec2 (0.5 * pi, 0.));\n}\n\nfloat HillRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, tol;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  tol = 0.0005;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetHillConf ();\n    }\n    d = HillDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.002;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < tol || dHit > dstFar || p.y < 0. || rd.y > 0. && p.y > 20.) break;\n  }\n  if (d >= tol) dHit = dstFar;\n  return dHit;\n}\n\nvec3 HillNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (- HillDf (p + e.xxx), HillDf (p + e.xyy), HillDf (p + e.yxy), HillDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, rds, mDir, vn, clCol;\n  vec2 q;\n  float mRad, bs, ts, f, ff, fd;\n  if (isNt) {\n    rd.xz = Rot2D (rd.xz, 0.001 * tCur);\n    mDir = normalize (vec3 (0., 0.1, -1.));\n    mRad = 0.02;\n    col = vec3 (0.02, 0.02, 0.04) + vec3 (0.06, 0.04, 0.02) *\n       pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n    bs = dot (rd, mDir);\n    ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n    if (ts > 0.) {\n      ts = bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - mDir) / mRad);\n        col += 0.8 * vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n           (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n      }\n    } else {\n      rds = floor (2000. * rd);\n      rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n      for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n      col += 0.5 * smoothstep (0.01, 0.04, rd.y) * vec3 (0.8, 0.8, 0.6) *\n         min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n    }\n  } else {\n    rd.y = abs (rd.y) + 0.0001;\n    q = 0.02 * (ro.xz + tCur + ((50. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.7, 0.7, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isShad = true;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat TxPattern (vec3 p)\n{\n  float t, tt, c;\n  p = abs (0.5 - fract (4. * p));\n  c = 0.;\n  t = 0.;\n  for (float j = 0.; j < 6.; j ++) {\n    p = abs (p + 3.) - abs (p - 3.) - p;\n    p /= clamp (dot (p, p), 0., 1.);\n    p = 3. - 1.5 * p;\n    if (mod (j, 2.) == 0.) {\n      tt = t;\n      t = length (p);\n      c += exp (-1. / abs (t - tt));\n    }\n  }\n  return c;\n}\n\nvec4 BldCol (vec3 ro, vec3 vn, bool inRoom)\n{\n  vec4 col4;\n  vec2 q;\n  float f;\n  q = abs (ro.xz) - bSize.xz;\n  f = max (q.x, q.y);\n  if (idObj == idWall) {\n    q = vec2 (abs (ro.x), abs (ro.y - baseHt - bSize.y + 1.05)) - drSize.xy;\n    if (max (q.x, q.y) < 0.05) {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.1);\n    } else if (f > 0.9 * wallThk) {\n      col4 = vec4 (1., 1., 1., 0.2);\n      q = SSBump (0.2 * wallThk, 0.5 * wallThk,\n         mod (ro.y - baseHt - 0.5 * wallThk + 0.5 * (bSize.y - 0.5 * wallThk),\n         bSize.y - 0.5 * wallThk) - 0.5 * (bSize.y - 0.5 * wallThk));\n      if (q.x + q.y != 0.) {\n        vn.y += 0.2 * (q.y - q.x);\n        vn = normalize (vn);\n        col4.rgb *= dot (q, vec2 (0.8, 1.1));\n      }\n    } else if (f < -0.9 * wallThk) {\n      col4 = vec4 (0.9, 1., 0.9, 0.2);\n      q = abs (abs (mod (ro.xz + 0.5, 1.) - 0.5) - 0.46);\n      if (abs (vn.z) > 0.99 && (abs (ro.x) > 1. || ro.y - baseHt > bSize.y))\n         col4.rgb *= 0.5 + 0.5 * smoothstep (0.01, 0.02, q.x);\n      if (abs (vn.x) > 0.99) col4.rgb *= 0.5 + 0.5 * smoothstep (0.01, 0.02, q.y);\n    } else {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n    }\n  } else if (idObj == idFlr) {\n    col4 = vec4 (0.8, 0.5, 0.3, 0.2);\n    if (abs (ro.y - baseHt - bSize.y) > 0.5 * bSize.y) {\n      if (vn.y > 0.99) {\n        col4 = mix (col4, vec4 (0.4, 0.3, 0.1, 0.), Fbm2 (vec2 (4., 32.) *\n           ro.xz)) * (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (8. * ro.z + 0.5, 1.)));\n      } else if (vn.y < -0.99) {\n        col4 = vec4 (vec3 (0., 0., 1.), 0.2);\n        if (f < -0.21)\n          col4 = vec4 (mix (col4.rgb, vec3 (1., 1., 0.3), step (1.7, TxPattern (0.5 * ro))), 0.2);\n      }\n    } else if (abs (vn.y) < 0.01) {\n      col4 *= 1.5;\n    }\n   } else if (idObj == idRoof) {\n    if (vn.y > 0.1) {\n      col4 = vec4 (0.8, 0.8, 0.7, 0.3);\n    } else {\n      col4 = vec4 (1., 1., 1., 0.2);\n      f = 0.;\n      if (abs (vn.z) > 0.99) q = ro.xy;\n      else if (abs (vn.x) > 0.99) q = ro.zy;\n      else f = 99.;\n      if (f == 0.) {\n        f = abs (length (q - vec2 (0., 2. * bSize.y + baseHt + 0.34)) - 0.24);\n        if (f < 0.04) col4 = isNt ? vec4 (0.8, 0.8, 0.6, -1.) : vec4 (0.8, 0.8, 0., 0.5);\n      }\n    }\n  } else if (idObj == idChim) {\n    col4 = vec4 (0.7, 0.7, 0.75, 0.2);\n  } else if (idObj == idWbar) {\n    col4 = vec4 (0.4, 0.5, 0.3, 0.2);\n  } else if (idObj == idDoor) {\n    if (length (qHit.xy - vec2 (drSize.x - 0.4, -0.1)) < 0.05) col4 = vec4 (0.8, 0.8, 0., 0.3);\n    else col4 = (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (12. * qHit.x + 0.5, 1.))) *\n       mix (vec4 (0.7, 0.5, 0.2, 0.2), vec4 (0.5, 0.25, 0.1, 0.1),\n       Fbm2 (vec2 (24., 4.) * qHit.xy));\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.8, 0.8, 0.5, 0.3);\n  } else if (idObj == idLmp) {\n    col4 = vec4 (1., 1., 0.8, -1.);\n  } else if (idObj == idTabl) {\n    col4 = vec4 (0.7, 0.4, 0.1, 0.2);\n  }\n  return col4;\n}\n\nvec3 BldIntLit (vec4 col4, vec3 ro, vec3 vn, float sh)\n{\n  vec3 col, ltDir;\n  float dif, att, f;\n  if (idObj != idFlr) {\n    dif = 0.;\n    for (float sx = -1.; sx <= 1.; sx += 2.) {\n      for (float sz = -1.; sz <= 1.; sz += 2.) {\n        ltDir = vec3 (0.5 * sx * bSize.x, 2. * bSize.y + baseHt - 0.2, 0.5 * sz * bSize.z) - ro;\n        att = length (ltDir);\n        if (att > 0.) ltDir /= att;\n        dif = max (dif, max (dot (vn, ltDir), 0.) / (1. + 0.1 * att * att));\n      }\n    }\n    col = col4.rgb * (0.1 + 0.8 * dif);\n  } else {\n    col = 0.15 * col4.rgb;\n    f = length (abs (ro.xz) - 0.5 * bSize.xz);\n    if (vn.y > 0.99) col = col * (1.5 - 0.5 * smoothstep (1., 2., f)) * \n       (0.8 + 0.2 * smoothstep (0.35, 0.4, f)) + 0.2 * sh;\n    else if (vn.y < -0.99 && ro.y > baseHt + 2. * bSize.y - 0.3)\n       col = 1.3 * col * (2. - smoothstep (1., 2., f));\n  }\n  return col;\n}\n\nvec3 BldExtLit (vec4 col4, vec3 ro, vec3 rd, vec3 vn, float sh)\n{\n  vec3 col, ltDir;\n  float dif, att;\n  if (! isNt) {\n    dif = max (dot (vn, sunDir), 0.);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n       0.7 * sh * dif) + col4.a * sh * smoothstep (0., 0.1, dif) *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else {\n    dif = 0.;\n    for (float sx = -1.; sx <= 1.; sx += 1.) {\n      for (float sz = -1.; sz <= 1.; sz += 2.) {\n        ltDir = vec3 (sx * (bSize.x + 2.), baseHt + 1., sz * (bSize.z + 3.)) - ro;\n        att = length (ltDir);\n        if (att > 0.) ltDir /= att;\n        dif = max (dif, max (dot (vn, ltDir), 0.) / (1. + 0.01 * att * att));\n      }\n    }\n    col = 0.7 * col4.rgb * (0.2 + 0.8 * dif);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, gCol, vn, roo;\n  vec2 q, vf;\n  float dstObj, dstHill, sh, f, fogHt;\n  bool isGrnd, isBg, inRoom;\n  int idObjT;\n  hgSize = 40.;\n  wallThk = 0.08;\n  drSize = vec3 (0.6, 0.85, 0.25 * wallThk);\n  drAng = pi + 0.5 * pi * smoothstep (0., 1.5, 3.5 - length (vec2 (ro.x, abs (ro.z) - bSize.z)));\n  roo = ro;\n  isGrnd = false;\n  isBg = false;\n  isShad = false;\n  dstObj = ObjRay (ro, rd);\n  dstHill = HillRay (ro, rd);\n  gCol = vec3 (0.2, 0.5, 0.3) * (isNt ? 0.05 : 1.);\n  inRoom = false;\n  vf = vec2 (0.);\n  if (min (dstObj, dstHill) < dstFar) {\n    if (dstObj < dstHill) {\n      ro += dstObj * rd;\n      gCol *= 0.7 + 0.3 * Fbm2 (2. * ro.xz);\n      vn = ObjNf (ro);\n      if (idObj == idGrnd) {\n        col = vec3 (0.5, 0.4, 0.2) * (0.6 + 0.4 * Fbm2 (32. * ro.xz)); \n        f = smoothstep (0., 1., PrRoundBox2Df (ro.xz, bSize.xz + vec2 (1., 2.), 1.));\n        if (f > 0.) {\n          vn.xz = Rot2D (vn.xz, 0.3 * pi * f * Fbm2 (32. * vec2 (sin (atan (ro.z, - ro.x)) + 1.,\n             0.03 * ro.y)));\n          gCol = mix (col * (isNt ? 0.4 : 1.), gCol, f);\n          isGrnd = true;\n        } else vf = vec2 (64., 0.5);\n        col4 = vec4 (col, 0.);\n      } else {\n        q = abs (ro.xz) - bSize.xz;\n        f = max (q.x, q.y);\n        inRoom = (idObj != idDoor && f < 0. && ro.y < baseHt + 2. * bSize.y ||\n           idObj == idDoor && qHit.z > 0.);\n        col4 = BldCol (ro, vn, inRoom);\n        q = abs (ro.xz) - bSize.xz;\n        f = max (q.x, q.y);\n        if (idObj == idWall) {\n          q = vec2 (abs (ro.x), abs (ro.y - baseHt - bSize.y + 1.05)) - drSize.xy;\n          if (max (q.x, q.y) > 0.05 && f > 0.9 * wallThk) vf = vec2 (64., 0.5);\n        } else if (idObj == idRoof && vn.y < 0.1) vf = vec2 (64., 0.5);\n      }\n    } else if (dstHill < dstFar) {\n      ro += dstHill * rd;\n      gCol *= 0.7 + 0.3 * Fbm2 (2. * ro.xz);\n      gId = PixToHex (ro.xz / hgSize);\n      SetHillConf ();\n      vn = HillNf (ro);\n      q = ro.xz - HexToPix (gId * hgSize) - hillPos;\n      vn.xz = Rot2D (vn.xz, 0.03 * pi * dot (sin (vec2 (13., 23.) *\n         (pi * Hashfv2 (gId) + atan (q.y, - q.x))), vec2 (1.)));\n      isGrnd = true;\n    }\n  } else {\n    if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n      col = isNt ? vec3 (0.07) : mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.41, 0.55), \n         smoothstep (-0.02, 0.01, rd.y));\n      isBg = true;\n    } else if (rd.y >= 0.) {\n      col = SkyCol (ro, rd);\n      isBg = true;\n    } else {\n      ro += (- ro.y / rd.y) * rd;\n      gCol *= 0.7 + 0.3 * Fbm2 (2. * ro.xz);\n      vn = vec3 (0., 1., 0.);\n      isGrnd = true;\n    }\n  }\n  if (! isBg) {\n    if (col4.a < 0.) {\n      col = col4.rgb * max (0.6 - 0.4 * dot (rd, vn), 0.); \n    } else {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      sh = 1.;\n      if (! isNt) {\n        if (dstObj < min (dstHill, dstFar) && (idObj != idGrnd || ro.y > 0.1 || rd.y < 0.)) {\n          idObjT = idObj;\n          sh = ObjSShadow (ro, sunDir);\n          idObj = idObjT;\n        }\n      }\n      if (inRoom) col = BldIntLit (col4, ro, vn, sh);\n      else if (! isGrnd) col = BldExtLit (col4, ro, rd, vn, sh);\n      else if (isNt) col = gCol;\n      else {\n        gCol *= 0.5 + 0.5 * smoothstep (baseHt - 3., baseHt - 0.1, ro.y);\n        col = gCol * (0.2 + 0.3 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.))), 0.) +\n           0.7 * sh * max (dot (vn, sunDir), 0.));\n        col = mix (col, vec3 (0.4, 0.5, 0.7) - 0.05, smoothstep (0.7, 1., length (ro) / dstFar));\n      }\n    }\n  }\n  fogHt = baseHt - 0.5;\n  if (ro.y < fogHt) {\n    f = Fbm2 (0.1 * (roo.xz + ((fogHt - roo.y) / rd.y) * rd.xz + 1.5 * tCur));\n    col = mix (col, (isNt ? vec3 (0.1) + 0.1 * f : vec3 (0.7, 0.65, 0.7) + 0.2 * f),\n       (1. - smoothstep (fogHt - 2., fogHt, ro.y)) *\n       clamp (f * (1. - smoothstep (-0.05, -0.001, rd.y)), 0., 1.));\n    if (ro.y < 0.001) col = mix (col, (isNt ? vec3 (0.1) : vec3 (0.4, 0.5, 0.8) + 0.02),\n       smoothstep (-0.05, -0.001, rd.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa, mMid, ut, mSize, ms, tu;\n  float el, az, asp, zmFac, tCyc, t, tt, ti, s, regId, winHt, sr, rz;\n  bool mMove;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.85;\n  mSize = (1./5.) * vec2 (asp, 1.) * winHt;\n  mMid = vec2 (asp, winHt - mSize.y) * vec2 (1. - mSize.y, -1.);\n  ut = abs (uv - mMid) - mSize;\n  mMove = true;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    mMove = ! mMove;\n  }\n  regId = 0.;\n  ms = mPtr.xy + 0.5 * vec2 (1., winHt);\n  if (ms.x > 1. - mSize.x / asp && abs (ms.y - 0.5 * mSize.y) < 0.5 * mSize.y) regId = 1.;\n  if (abs (mPtr.y) > 0.5 * winHt) regId = -1.;\n  tCyc = 100.;\n  isNt = (mod (tCur, 2. * tCyc) > tCyc);\n  if (mPtr.z > 0. && regId == 1.) {\n    if (ms.x > 1. - 0.5 * mSize.x / asp) mMove = ! mMove;\n    if (ms.y < 0.5 * mSize.y) isNt = ! isNt;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && regId == 0.) {\n    az = 3. * pi * mPtr.x;\n    el = pi * mPtr.y;\n    if (! mMove) {\n      el -= -0.05 * pi;\n      el = clamp (el, -0.4 * pi, 0.01 * pi);\n    }\n  } else {\n    if (! mMove) {\n      az = -0.4 * (floor (0.3 * tCur) + smoothstep (0., 0.1, mod (0.3 * tCur, 1.)));\n      el = -0.05 * pi;\n    }\n  }\n  baseHt = 5.;\n  bSize = vec3 (8., 2., 4.);\n  if (mMove) {\n    t = (4. / tCyc) * mod (tCur, tCyc);\n    az += pi * step (2., t);\n    ti = mod (t, 1.);\n    s = (t <= 2.) ? 1. : -1.;\n    tt = (smoothstep (0.25, 0.75, ti) - step (min (abs (t - 0.5), abs (t - 2.5)), 0.5)) * s;\n    ro = vec3 (0., baseHt + 1.4, 15. * tt);\n    rz = abs (ro.z) / bSize.z - 1.;\n    if (rz > 0.) ro.y += 0.4 * rz * rz;\n    tu = vec2 (0.75 - ti, ti - 0.25);\n    tu *= step (tu, vec2 (0.));\n    if (tt == 0.) az -= 4. * pi * (tu.x - tu.y) * s;\n    else if (abs (tt) == 1.) az -= 2. * pi * (tu.x + tu.y) * s;\n    if (tt == 0.) el += 0.2 * (0.5 * pi - abs (0.5 * pi - mod (az, pi)));\n    el = clamp (el, -0.2 * pi, 0.2 * pi);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  sunDir = normalize (vec3 (-1., 0.5, -1.));\n  if (mMove) {\n    zmFac = 2.;\n    sunDir.xz = Rot2D (sunDir.xz, 0.1 * tCur);\n  } else {\n    ro = vuMat * vec3 (0., baseHt + 1., -50.);\n    zmFac = 3.6;\n    sunDir = vuMat * sunDir;\n  }\n  dstFar = 400.;\n  col = vec3 (0.);\n  if (abs (uvs.y) < winHt) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  }\n  if (max (ut.x, ut.y) < 0.) {\n    if (min (abs (ut.x), abs (ut.y)) * canvas.y < 2.) col = vec3 (0.2, 0.2, 0.1);\n    else if (mPtr.z > 0. && regId == 1. && (min (abs (ut.x + mSize.x),\n       abs (ut.y + mSize.y)) * canvas.y < 1.)) col = vec3 (0.3, 0.3, 0.1);\n\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nbool HexNeb (vec2 a, vec2 b)\n{\n  vec2 d = a - b;\n  return (d.x == 0. && abs (d.y) == 1. || abs (d.x) == 1. && d.y == 0. ||\n    d.x * d.y == -1.);\n}\n\nvec2 SSBump (float w, float s, float x)\n{\n  return vec2 (step (x + s, w) * step (- w, x + s), step (x - s, w) * step (- w, x - s));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlj3DD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1403, 1425, 1425, 4988], [4990, 4990, 5012, 5012, 5412], [5414, 5414, 5447, 5447, 5624], [5626, 5626, 5647, 5647, 5839], [5841, 5841, 5864, 5864, 6140], [6142, 6142, 6163, 6163, 6342], [6344, 6344, 6378, 6378, 7509], [7511, 7511, 7533, 7533, 7729], [7731, 7731, 7763, 7763, 9254], [9256, 9256, 9293, 9293, 9531], [9533, 9533, 9559, 9559, 9894], [9896, 9896, 9941, 9941, 12777], [12779, 12779, 12835, 12835, 13661], [13663, 13663, 13728, 13728, 14472], [14474, 14474, 14509, 14509, 18526], [18528, 18528, 18584, 18584, 21886], [21888, 21888, 21920, 21920, 22020], [22022, 22022, 22055, 22055, 22144], [22146, 22146, 22192, 22192, 22239], [22241, 22241, 22285, 22285, 22360], [22362, 22362, 22409, 22409, 22456], [22458, 22458, 22491, 22491, 22518], [22520, 22520, 22562, 22562, 22613], [22615, 22615, 22668, 22668, 22729], [22731, 22731, 22755, 22755, 22985], [22987, 22987, 23011, 23011, 23071], [23073, 23073, 23103, 23103, 23220], [23222, 23222, 23263, 23263, 23355], [23357, 23357, 23402, 23402, 23505], [23507, 23507, 23564, 23564, 23647], [23649, 23649, 23671, 23671, 23709], [23711, 23711, 23741, 23741, 23854], [23888, 23888, 23912, 23912, 23972], [23974, 23974, 23998, 23998, 24051], [24053, 24053, 24077, 24077, 24207], [24209, 24209, 24233, 24233, 24293], [24295, 24295, 24319, 24319, 24539], [24541, 24541, 24566, 24566, 24712], [24714, 24714, 24739, 24739, 24925], [24927, 24927, 24952, 24952, 25177], [25179, 25179, 25201, 25201, 25355], [25357, 25357, 25378, 25378, 25533], [25535, 25535, 25564, 25564, 25776], [25778, 25778, 25817, 25817, 25997]]}
{"id": "Wlj3DW", "name": "Sonar Ping", "author": "charon", "description": "Noise creates random terrain which lights up depending on time and it's distance from a sonar emitter point", "tags": ["distance", "sonar"], "likes": 1, "viewed": 76, "published": "Public", "date": "1559601101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n\n\n\n// noise function taken from https://www.shadertoy.com/view/4sdGD8\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n\n    \n    // generatying rays to cast from camera based on coordinates\n    \t\t// z serves to modify field of view\n    \t\t// y moves to look up and to horizon\n    //vec3 rayDir = normalize( vec3(uv.x, uv.y , 1 ));\n    vec3 rayDir = normalize( vec3(uv.x, uv.y , 0.25 - distance(uv, vec2(0,0))/4.0 ));\n    \n    vec3 position = vec3(0,0,0);\n    \n    vec3 color = vec3(0, 0.3, 1.0);\n   \n    for (float i = 1.0; i < 100.0; i+=0.5){\n        \tif (pow(snoise(rayDir.xz*i/5.0), 3.0) < 0.2)\n            {\n                color = vec3(1,0.5,0);\n            \tposition = rayDir*i;\n                i = 101.0;\n            }\n   \t\t\t\n\n    }\n\n    float t = time*5.0;\n    \n    if (position == vec3(0,0,0))\n        fragColor = vec4 (0,0,0,1);\n   \telse if (distance (position, vec3 (0, 0, 5)) < t + 0.50 && distance (position, vec3 (0, 0, 5)) > t)\n    \tfragColor = vec4(0.8, 0.8, 1.0, 1.0);\n        else{\n            float depth = 1.0-distance(vec3(0,0,0),position)/10.0;\n        fragColor = vec4(depth + 0.1, depth, depth+0.2, 1); \n        }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlj3DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 869, 926, 977, 2047]]}
{"id": "Wlj3Rt", "name": "Wooden mandelbrot set", "author": "matistjati", "description": "A mandelbrot set rendering colored by combining distance estimation and texture indexing", "tags": ["mandelbrot"], "likes": 2, "viewed": 130, "published": "Public", "date": "1560880904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float escapeRadius = 128.;\n\nconst vec2 origin = vec2(-0.05,.6805);\n#define experimental 0\n\nvec2 cMul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 cPow(vec2 z, float p)\n{\n\n    float r = pow(length(z),abs(p));\n\n   \tfloat theta = atan(z.y, z.x)*p;\n   \n    return r*vec2(cos(theta), sin(theta));\n}\n\nfloat dist(vec2 pos, out vec2 lastPos, out vec2 derivative, out float iter)\n{\n    vec2 z = vec2(0.0);\n    vec2 dz = vec2(0.0);\n#if experimental\n\tfloat maxIter = abs(sin(iTime*0.5)*100.)+10.;\n#else\n\tconst float maxIter = 1024.;\n#endif\n    \n#if experimental\n    float power = abs(sin(iTime*0.1)*3.);\n#else\n    const float power = 2.;\n#endif\n    \n    float m2;\n    float i=0.;\n    for(;i<maxIter;i++)\n    {\n        dz = 2.* mat2(z,-z.y,z.x) * dz + 1.;\n\t\tz = cPow(z,power)-abs(pos);\n        \n        m2 = dot(z,z);\n        if( m2>escapeRadius)\n            break;\n    }\n\n\tderivative = dz;\n    iter = i/maxIter;\n    lastPos = z;\n    return sqrt( m2/dot(dz, dz))*0.5f*log(m2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tz = 0.5-0.5*cos(0.225*iTime);\n    float zoom = pow( 0.5, 13.0*tz );\t\n    \n\tvec2 uv = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 c = origin + uv*zoom;\n\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec2 z=vec2(0.,0.);\n    float iterations = 0.;\n    vec2 dz = vec2(0.,0.);\n    float d = abs(dist(c, z, dz, iterations));\n    \n    float t = clamp(pow(4.*d/zoom,.2),0.,1.);\n\n    fragColor = vec4((1.-t)*vec3(0.56, 0.3,0.1),1.);\n\tif (iterations==1.) fragColor = vec4(texture(iChannel0, z, 0.0).xyz, 1.);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlj3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 124, 124, 174], [176, 176, 204, 204, 328], [330, 330, 407, 407, 1001], [1004, 1004, 1061, 1061, 1593]]}
{"id": "wlj3Ry", "name": "funky waves", "author": "anclin", "description": "funky waves", "tags": ["waves", "funky"], "likes": 1, "viewed": 53, "published": "Public", "date": "1560095877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y = fract(uv.y*1.);\n    uv.y -= .5;\n    \n    float T = (iTime + uv.y*3.*uv.x) * 2.5;\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    \n    float t = uv.x;// + iTime * .2;\n    float waves = 5.;\n    float s = cos(t * 3.14*2. * waves);\n    float h = mix(.0, .05, cos(T+3.14)*.5+.5);\n    \n    s = s*h+h;\n    \n    float th = .15;//mix(0., .2, uv.x);\n    float R = (1.-step(s+th, uv.y));\n    float G = (   step(s-th, uv.y));\n    float B = (   step(s + (sin(T))*.5*th, uv.y));\n    \n    col = vec3(R,G,B);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlj3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 714]]}
{"id": "wlj3WG", "name": "Truchet Tiles and Gold Tunnels", "author": "Yusef28", "description": "Another Red, Gold, and Black Pattern using Truchet Tiles and cool background thing.\nInspiration: https://www.pinterest.de/pin/290693350948519653/", "tags": ["2d", "truchet", "red", "pattern", "tile", "gold"], "likes": 5, "viewed": 103, "published": "Public", "date": "1561063737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 4.\n\n//classic rotation matrix\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n//classic hash function\nfloat rnd(vec2 p)\n{\n return fract(sin(dot(p, vec2(12.9898, 78.233)))*43526.235342);  \n}\n\n//classic function for rotating a coordinate sytem based on\n//the floored valaues of a scaled system (used for making all\n//kinds of truchets (almost said all kinds of gains)\nvec2 rotCoord(vec2 p)\n{\n    \n vec2 ipod = floor(p*scale);  \n vec2 fpod = fract(p*scale)-0.5;\n    \n    float index = rnd(ipod);\n    \n    if(index >0.75)\n    {\n     p = fpod*rot(3.14);   \n    }\n    else if(index >0.5)\n    {\n     p = fpod*rot(3.14/2.);   \n    }    \n    else if(index >0.25)\n    {\n     p = fpod*rot(-3.14/2.);   \n    }    \n    else\n    {\n     p = fpod;   \n    }\n    \n    \n return p+0.5;   \n}\n\n//function for creating the gold square plating\n\nfloat shadeSquares(vec2 p)\n    {\t\n    //I decided to add some small ring shapes to the plating\n    vec2 coor2 = fract(p*20.);\n \tcoor2 = coor2-0.5;\n float c = (1.0-smoothstep(0.1, 0.101,length(coor2)))\n     -(1.0-smoothstep(0.05, 0.051,length(coor2)));\n \n \t\n        //and this is for the gold squares\n    p = p*2.0-1.0;\n    p = abs(p);\n    vec2 st = smoothstep(98.2, 99.9, (p*100.));\n    float border = max(st.x, st.y);\n    \n    \n    p = floor(p*10.)/10.;\n    float sq = max(p.x, p.y)-border/6.;\n    \n  //this adds the circles to the squares and returns everything\n return sq-max(0., c*sq/10.);   \n}\n\n\n//creates a circle\n//p = uv or other position, r is radius, ss is smoothstep amount \nfloat circle(vec2 p, float r, float ss)\n{\n    \n ///float ss = 0.0009;\n    float c = length(p/1.35);\n    float ci = smoothstep(r-ss, r+ss, c);\n    \n return ci;   \n}\n\n\n//creates a ring, one circle subtracted by another\n//p = uv or other position,\n//r is radius, \n//th is thickness of ring\n//ss is smoothstep amount\n\nfloat ring(vec2 p, float r, float th, float ss)\n{\n //   p = p*2.0-1.0;\n    //p = abs(p*5.)-0.4;\n    float c1 = 1.0-circle(p, r, ss);\n    float c2 = 1.0-circle(p, r-th, ss);\n    \n    float ri = c1-c2;\n    return ri;\n}\n\n//vignetting for screen\nfloat vig (vec2 st)\n{\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.15); \n    return vig;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float v = vig(uv);//get vignett shade\n    uv.x*=iResolution.x/iResolution.y;\n    \n    uv+=iTime/5.;//move pattern diagonally down with time\n    \n    \n    //create textures\n    float tx0 = vec3(texture(iChannel0, uv)).x;\n    //this texture moves to create a shine animation on the truchet edges\n\tfloat tx1 = vec3(texture(iChannel1, uv+iTime/10.)).x;\n    float tx2 = vec3(texture(iChannel2, uv)).x;\n    float tx3 = vec3(texture(iChannel3, uv)).x;\n    \n    vec2 rotUV = rotCoord(uv);\n    uv = fract(uv*scale/4.);\n    \n    float shades = shadeSquares(uv);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0., 0., 0.);\n    vec3 Dred = vec3(.8, 0., 0.)*tx0;//dred was supposed to be\"dark red\" but ...\n    vec3 Bred = vec3(0.3, 0.1, 0.1)-tx1/3.+tx3/5.;\n    vec3 gold = vec3(213., 123., 15.)/255.;\n    gold =gold-tx2/10.\n        +abs(sin(uv.x*3.+uv.y*3.+iTime/2.+shades*4.))/3.-0.12;\n    \n    //another color option:\n    \n    //Bred = vec3(213., 123., 15.)/255.-pow(tx1/3., 1.5)*5.;\n    //Dred = Bred*tx0;\n    //Bred = gold-tx1/1.;\n    \n    ///creating the gold sqaure plating and adding to screen\n    col = mix(col, gold, shadeSquares(uv));\n    \n    //unused but gives me an idea for the next one!\n    //col = mix(col, Dred,ring(uv-1., 0.49, 0.2, 0.0009));\n    \n    //sha is shadow, used to give the truchet some depth\n    float sha = 0.1;//shadow subtraction thing\n    \n    //setting uv now to the rotated uv for truchet stuff\n    uv = rotUV;\n    \n    //adding a ring to one side of the truchet tile, \n    //the upper right corner?\n    col = mix(col, Dred,ring(uv-1., 0.49, 0.2, 0.0009));\n    \n    //adding a shadow below the ring, so much hacking of those variabls is just about positioning\n    col = mix( col, vec3(.0, 0., 0.)-sha, ring(uv-1., 0.5, 0.01, 0.042));\n    col = mix(col, vec3(.0, 0., 0.)-sha, ring(uv-1., 0.25, 0.01, 0.042));\n    \n    //adding an outine to the ring, so much hacky positioning\n    col = mix( col, Bred, ring(uv-1., 0.49, 0.05, 0.0009));\n    col = mix(col, Bred, ring(uv-1., 0.3, 0.05, 0.0009));\n    \n    //adding a ring to the other side of the truchet tile, \n    //the upper right corner?\n    col =mix(col,  Dred, ring(uv, 0.49, 0.2, 0.0009));\n    \n    //adding a shadow below the ring, \n    col = mix( col, vec3(.0, 0., 0.)-sha, ring(uv, 0.5, 0.01, 0.042));\n    col = mix(col, vec3(.0, 0., 0.)-sha, ring(uv, 0.25, 0.01, 0.042));\n    \n    //adding an outline to the ring\n    col = mix( col, Bred, ring(uv, 0.49, 0.05, 0.0009));\n    col = mix(col, Bred, ring(uv, 0.3, 0.05, 0.0009));\n    \n    // Output to screen\n    fragColor = vec4(col*1.5*v,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlj3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 44, 63, 63, 115], [117, 141, 160, 160, 228], [230, 405, 428, 428, 809], [811, 860, 892, 954, 1458], [1461, 1546, 1587, 1615, 1709], [1712, 1860, 1909, 1955, 2076], [2078, 2102, 2123, 2123, 2223], [2226, 2226, 2283, 2333, 4961]]}
{"id": "Wlj3z3", "name": "Stackless Quadtree Search", "author": "paniq", "description": "Enumerating the leaves of a quadtree intersecting an isosurface. No stack required. Solution is also applicable to binary search and octree recursion.", "tags": ["binary", "quadtree", "search", "stackless"], "likes": 24, "viewed": 944, "published": "Public API", "date": "1560529280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces );\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nuint part1by1 (uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint compact1by1(uint x) {\n    x = (x & 0x55555555u);\n    x = ((x ^ (x >> 1)) & 0x33333333u);\n    x = ((x ^ (x >> 2)) & 0x0f0f0f0fu);\n    x = ((x ^ (x >> 4)) & 0x00ff00ffu);\n    x = ((x ^ (x >> 8)) & 0x0000ffffu);\n    return x;\n}\n\nuvec2 unpack_morton2x16(uint p) {\n    return uvec2(\n        compact1by1(p),\n        compact1by1(p >> 1));\n}\n    \nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\nfloat map(vec2 p) {\n    float d0 = length(p) - 0.5;\n    float d1 = length(p + vec2(-0.25,0.0)) - 0.3;\n    float d2 = length(p + vec2(0.0, 0.5)) - 0.2;\n    return max(min(d0,d2), -d1);\n}\n\n#define MAX_LEVEL 7u\n\nvec3 get_rect(uint c, uint level) {\n    uvec2 v = unpack_morton2x16(c);\n    float r = 1.0 / float(1u << level);\n    vec2 center = (vec2(v) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;\n    return vec3(center, r);\n}\n\nvoid draw_rect(uint c, uint level) {\n    vec3 rc = get_rect(c, level);\n    //rc.z -= 0.002;// * float(level);\n    rectangle(rc.xy - rc.z, vec2(rc.z) * 2.0);\n}\n\nuint find_lsb(uint value) {\n    // with GL4, this loop can be replaced with\n    // a single use of findLSB()\n    uint count = 0u;\n    for (uint i = 0u; i < MAX_LEVEL; ++i) {\n        if ((value & 3u) != 0u)\n            break;\n        count += 2u;\n        value >>= 2u;\n    }\n    return count;\n}\n\nuint lowest_level(uint p) {\n    uint used_levels = min(MAX_LEVEL, find_lsb(p) / 2u);\n    return MAX_LEVEL - used_levels; \n}\n\nvoid draw_point(uint p, uint level) {\n    float l = float(1u << MAX_LEVEL);\n\tfloat x = float(p) / (l * l);\n    x = x*2.0 - 1.0;\n    circle(x, -0.9 + float(level)*0.01, 0.003);\n}\n\nuint surface_cells_found = 0u;\nuint surface_cell_misses = 0u;\nuint total_steps = 0u;\n\nbool walk(inout uint p, inout uint level, bool is_active) {\n    const uint topstep = 1u << (MAX_LEVEL * 2u);\n    if (p >= topstep)\n        return false;\n    vec3 rc = get_rect(p, level);\n    float d = map(rc.xy);\n    uint stepsz = topstep >> (level * 2u);\n    bool hit = abs(d) < (rc.z * sqrt(2.0));\n    if (hit) {\n        set_source_rgb(0.0,1.0,0.0);\n        draw_point(p, level);\n        fill();\n        if ((level == MAX_LEVEL)||is_active) {\n            draw_rect(p, level);\n            stroke();\n            if (level == MAX_LEVEL) {\n            \tsurface_cells_found++;\n            }\n        }\n    } else {\n        surface_cell_misses++;\n        set_source_rgb(1.0,0.0,0.0);\n        draw_point(p, level);\n        fill();\n        if (is_active) {\n            draw_rect(p, level);\n            stroke();\n        }\n    }\n    if (hit && (level < MAX_LEVEL)) {\n        level += 1u;\n    } else {\n        p += stepsz;\n        level = lowest_level(p);\n    }\n    if (is_active)\n        return false;\n    return true;\n}\n\nvoid paint() {\n    surface_cells_found = 0u;\n    \n    set_source_rgb(vec3(0.0));\n    clear();\n    \n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0));\n    add_field(map(get_origin()));\n    stroke();\n    \n    set_line_width_px(1.0);\n    \n    set_source_rgb(vec3(0.0));\n    \n    uint p = 0u;\n    uint level = 0u;\n    int maxi = iFrame % 1600;\n    for (int i = 0; i < 1600; ++i) {\n        total_steps++;\n        if (!walk(p, level, (i == maxi)))\n            break;\n    }\n  \n    \n    \n}\n\nvoid paint_post(inout vec4 fragColor, vec2 fragCoord) {\n\n    vec3 c = PrintValue((fragCoord - vec2(0.0, 10.0)) / vec2(8.0, 15.0), \n\t\tfloat(surface_cells_found), 10.0, 0.0) * vec3(0.0,1.0,0.0);\n\n    c += PrintValue((fragCoord - vec2(0.0, 30.0)) / vec2(8.0, 15.0), \n\t\tfloat(surface_cell_misses), 10.0, 0.0) * vec3(1.0,0.0,0.0);\n\n    c += PrintValue((fragCoord - vec2(0.0, 50.0)) / vec2(8.0, 15.0), \n\t\tfloat(total_steps), 10.0, 0.0);\n\n    \n    fragColor += vec4(c, 1.0);\n   \n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n    paint_post(fragColor, fragCoord);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlj3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6059, 6143, 6167, 6167, 6374], [6380, 6380, 6406, 6406, 6609], [6611, 6611, 6644, 6644, 6718], [6724, 6724, 6755, 6755, 6803], [6805, 6805, 6824, 6824, 6990], [7014, 7014, 7049, 7049, 7225], [7227, 7227, 7263, 7263, 7385], [7387, 7387, 7414, 7495, 7680], [7682, 7682, 7709, 7709, 7805], [7807, 7807, 7844, 7844, 7984], [8072, 8072, 8131, 8131, 9084], [9086, 9086, 9100, 9100, 9575], [9577, 9577, 9632, 9632, 10055], [10232, 10292, 10319, 10319, 10345], [10347, 10407, 10428, 10428, 10535], [10537, 10537, 10574, 10574, 10660], [10662, 10662, 10708, 10708, 10741], [10743, 10881, 10909, 10909, 11369], [11397, 11397, 11416, 11416, 11449], [11451, 11451, 11469, 11469, 11502], [11504, 11504, 11528, 11528, 11632], [11634, 11634, 11651, 11651, 11672], [11674, 11674, 11701, 11723, 12006], [12008, 12008, 12036, 12036, 12270], [12272, 12272, 12296, 12296, 12382], [12384, 12384, 12411, 12411, 12624], [12626, 12626, 12652, 12652, 12880], [12882, 12882, 12904, 12904, 13030], [13032, 13032, 13052, 13052, 13112], [13114, 13114, 13146, 13146, 13173], [13175, 13175, 13196, 13196, 13218], [13220, 13220, 13244, 13244, 13304], [13306, 13306, 13340, 13340, 13364], [13366, 13366, 13380, 13380, 13444], [13446, 13446, 13472, 13472, 13510], [13512, 13512, 13538, 13538, 13559], [13561, 13561, 13584, 13584, 13679], [13681, 13681, 13705, 13705, 13774], [13776, 13776, 13801, 13801, 13848], [13850, 13850, 13867, 13867, 13980], [13982, 13982, 14005, 14005, 14134], [14136, 14136, 14164, 14164, 14292], [14294, 14294, 14318, 14318, 14458], [14460, 14460, 14498, 14498, 14632], [14634, 14634, 14671, 14671, 14706], [14708, 14708, 14735, 14735, 14785], [14787, 14787, 14817, 14817, 14873], [14875, 14875, 14904, 14904, 15085], [15087, 15087, 15109, 15109, 15276], [15278, 15278, 15291, 15291, 15330], [15332, 15332, 15362, 15362, 15391], [15393, 15393, 15426, 15426, 15483], [15485, 15485, 15511, 15511, 15561], [15563, 15563, 15584, 15584, 15649], [15651, 15651, 15675, 15675, 15758], [15760, 15760, 15775, 15775, 15816], [15818, 15818, 15834, 15834, 15872], [15874, 15874, 15892, 15892, 15949], [15951, 15951, 15981, 16003, 16385], [16387, 16387, 16445, 16445, 16483], [16485, 16485, 16514, 16514, 16550], [16552, 16552, 16600, 16600, 16631], [16633, 16633, 16667, 16667, 16726], [16728, 16728, 16805, 16805, 16970], [16972, 16972, 17049, 17049, 17129], [17131, 17131, 17207, 17207, 17323], [17325, 17325, 17401, 17401, 17479], [17481, 17481, 17519, 17519, 17553], [17555, 17555, 17577, 17577, 17623], [17625, 17625, 17652, 17652, 17696], [17698, 17698, 17720, 17720, 18114], [18116, 18116, 18145, 18145, 18173], [18175, 18175, 18224, 18224, 18485], [18487, 18487, 18560, 18560, 18614], [18616, 18616, 18648, 18648, 18684], [18686, 18686, 18742, 18742, 18798], [18800, 18800, 18830, 18830, 18923], [18924, 18924, 18964, 18964, 18987], [18989, 19035, 19074, 19074, 20230], [20232, 20232, 20262, 20262, 20364], [20366, 20366, 20418, 20418, 20458], [20460, 20460, 20482, 20482, 20533], [20535, 20535, 20567, 20567, 20589], [20591, 20606, 20628, 20628, 20920], [20922, 20922, 20954, 20954, 20976], [20978, 20978, 20997, 20997, 21029], [21078, 21141, 21183, 21183, 21249], [21251, 21321, 21372, 21372, 21724], [21726, 21760, 21806, 21806, 22318], [22320, 22389, 22435, 22435, 22941], [22943, 22943, 22976, 22976, 23192], [23194, 23194, 23253, 23253, 23298], [23300, 23300, 23343, 23343, 23404], [23406, 23406, 23448, 23448, 23490], [23492, 23552, 23609, 23609, 23846], [23937, 24085, 24116, 24116, 24274], [24276, 24276, 24370, 24370, 25406]]}
{"id": "wlj3zV", "name": "Torus Pipes", "author": "iq", "description": "A sequence of connected torus sections (not a truchet or any other cell based acceleration structure). It's really a tested for the torus section SDF in [url]https://www.shadertoy.com/view/tl23RK[/url]", "tags": ["3d", "raymarching", "sdf", "torus", "pipes"], "likes": 69, "viewed": 2822, "published": "Public API", "date": "1561539545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#define AA 1\n\n// https://www.shadertoy.com/view/tl23RK\nfloat sdSqCappedTorus(in vec3 p, in vec2 sc, in float ra)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return dot(p,p) + ra*ra - 2.0*ra*k;\n}\n\nvec3 hash( float n )\n{\n    vec3 m = n*vec3(23.0,41.0,17.0) + vec3(9.0,1.0,31.0);\n    return fract( m*fract( m*0.3183099 ) );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec3 pp = vec3(0.0);\n    vec3 ww = vec3(0.0,1.0,0.0);\n    \n    float d = length(pos-pp);\n    \n    vec4 data = vec4(0.0);\n                   \n    for( int i=0; i<32; i++ )\n    {\n        // segment parameters        \n        vec3 ran = hash(float(i));\n        float ra = 0.13 + 0.08*ran.x; // radius\n        float ap = 1.10 + 0.80*ran.y; // aperture\n        vec3  up = normalize( sin(75.0*ran.z+vec3(0.0,1.0,4.0))); // orientation\n\n        // world to torus transformation\n        vec2 sc = vec2(sin(ap),cos(ap));\n        vec3 ou = normalize(cross(ww,up));\n        vec3 vv = cross(ou,ww);\n        vec3 uu =  sc.x*ou + sc.y*ww;\n             ww = -sc.y*ou + sc.x*ww;\n        vec3 cpos = (pos-pp)*mat3(uu,ww,vv) + ra*vec3(-sc.x,sc.y,0.0);\n        \n        // distance evaluation        \n        float tmp = sdSqCappedTorus(cpos, sc, ra );\n        if( tmp<d )\n        {\n            d = tmp;\n            data = vec4( float(i), cpos.xy, ap );\n        }\n        \n        // prepare next segment        \n        pp += 2.0*ra*sc.x*uu;\n        ww = sc.y*uu - sc.x*ww;\n    }\n    \n    return vec2(sqrt(d) - 0.035, // distance\n                data.x + 0.5+0.5*(atan(data.y,data.z))/data.w // u\n               );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).x );\n}\n\n#define ZERO min(iFrame,0)\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.15*(iTime-8.0);\n    vec3 ta = vec3( 0.25, -0.06, -0.75 );\n\tvec3 ro = ta + vec3( 1.7*cos(an), 0.6, 1.7*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // raymarch\n        const float tmax = 3.5;\n        float t = 0.5;\n        float m = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 h = map(pos);\n            m = h.y;\n            if( h.x<0.001 || t>tmax ) break;\n            t += h.x;\n        }\n    \n        // shade/light\n        vec3 col = vec3(0.1 - 0.015*length(p) + 0.05*rd.y );\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n\t\t\tfloat occ = calcAO(pos, nor);\n            float amb = 0.5 + 0.5*nor.y;\n            // material\n            vec3 mat = 0.5 + 0.5*cos( m*0.06 + vec3(0.00,1.0,1.8) + 1.0 );\n            mat += 0.05*nor;\n            // lighting\n            col = mat*1.5*occ*vec3(amb+fre*fre*col*0.4);\n            //col *= 4.0*smoothstep( 0.9, 1.0, sin(1.0*m+iTime*3.0) );\n            col *= 1.0-smoothstep( 0.98, 1.0, sin(1.0*m+iTime*3.0) );\n            col += fre*occ*0.5*vec3(0.5,0.7,1.0)*smoothstep(0.0,0.1,reflect(rd,nor).y);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlj3zV.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[656, 697, 756, 756, 883], [885, 885, 907, 907, 1011], [1013, 1013, 1038, 1038, 2241], [2243, 2307, 2339, 2339, 2585], [2615, 2615, 2657, 2657, 3003], [3005, 3005, 3062, 3086, 5172]]}
{"id": "WljGR3", "name": "\"Slotsspot\"", "author": "BryanClifford", "description": "Turn on the music, put on the headphones if you want, and press \"Start\"!\nMore: https://slotsspot.com/slots-themes/music/", "tags": ["game", "music", "shader", "card", "dice", "casino", "slots", "gambling"], "likes": 3, "viewed": 300, "published": "Public", "date": "1560502261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 100\n#define EPS 0.00001\n#define MAX_DIST 20.0\n#define PI2 6.28318530718 \n\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*7.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\treturn c.z * mix(vec3(2.0), rgb, c.y);\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat distfunc(vec3 pos, vec4 o1) {\n\treturn sphere(pos - o1.xyz, o1.w);\n}\n\nvec3 surfnorm(vec3 pos, vec4 o1) {\n    vec2 eps = vec2(1.0, EPS);\n\treturn normalize(vec3(\n    \tdistfunc(pos + eps.yxx, o1) - distfunc(pos - eps.yxx, o1),\n\t    distfunc(pos + eps.xyx, o1) - distfunc(pos - eps.xyx, o1),\n    \tdistfunc(pos + eps.xxy, o1) - distfunc(pos - eps.xxy, o1)\n    ));\n}\n\nvec3 calcray(vec3 campos, vec3 camtgt, vec3 camup, vec2 st) {\n    vec3 camdir = normalize(camtgt - campos);\n    vec3 camright = normalize(cross(camup, campos));\n\tcamup = cross(camdir, camright);\n\n    return normalize(camright * st.x + camup * st.y + camdir);\n}\n\nvec4 raymarch(vec3 campos, vec3 raydir, vec4 o1) {\n\tfloat totaldist = 1.0;\n\tvec3 pos = campos;\n\tfloat dist = EPS;\n\t\n\tfor (int i = 1; i < MAX_ITER; i++) {\n    \tif (dist < EPS || totaldist > MAX_DIST)\n        \tbreak;\n\t\n    \tdist = distfunc(pos, o1);\n\t    totaldist += dist;\n    \tpos += dist * raydir;\n    }\n    \n    return vec4(pos, dist);\n}\n\nvec2 normuv(in vec2 uv, in vec2 res) {\n\tuv = -2.0 + 4.0 * uv.xy / res.xy;\n    uv.x *= res.x / res.y;\n    \n    return uv;\n}\n\nfloat normsin(float x) {\n    return sin(x) * 1.5 + 1.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = -normuv(fragCoord.xy, iResolution.xy);\n\tvec2 mouse_uv = iMouse.xy / iResolution.xy;\n    \n    vec3 campos = vec3(1, EPS, 1);\n    vec3 camtgt = vec3(1.0, 2.0, 1.0);\n    vec3 camup = vec3(1.0, 1.0, 2.0);\n    \n    float angle = iTime * 1.5;\n    mat2 rmat = mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n    \n\tcamup.xz = rmat * camup.xz;\n    \n    vec4 sphere_obj = vec4(2.0, 2.0, 1.0, 3.0);\n\n    vec3 st_raydir = calcray(campos, camtgt, camup, uv);\n    vec3 mouse_raydir = calcray(campos, camtgt, camup, mouse_uv);\n\t\n    vec4 stmarch = raymarch(campos, st_raydir, sphere_obj);\n    stmarch.y *= exp(sin(iTime) * 10.0);\n    vec4 msmarch = raymarch(campos, mouse_raydir, sphere_obj);\n       \t\n    vec3 color = vec3(5.0, 5.0, 5.0);\n    \n    if (stmarch.w < EPS) {\n        vec3 norm = surfnorm(stmarch.xyz, sphere_obj);\n\t\t\t\t\t\t\n        float az = atan(stmarch.z / stmarch.x);\n        float inc = acos(stmarch.y / length(stmarch.xyz));\n\t\tfloat d = acos(cos(az) * cos(abs(inc)));\n        float twist = pow(inc, 1.0);\n        \n        color = hsv2rgb(vec3(\n            normsin((twist + iTime) * 3.0),\n            1.0, \n            pow(normsin((az+twist+iTime)*5.0),2.25)\n        ));\n    }\n    \n    fragColor = vec4(color, 4.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 116, 116, 239], [241, 241, 279, 279, 314], [316, 316, 351, 351, 389], [391, 391, 425, 425, 681], [683, 683, 744, 744, 943], [945, 945, 995, 995, 1284], [1286, 1286, 1324, 1324, 1408], [1410, 1410, 1434, 1434, 1467], [1469, 1469, 1524, 1524, 2785]]}
{"id": "wljGRd", "name": "[twitch] Lost Tree", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl", "tags": ["raymarching", "tree", "stars"], "likes": 18, "viewed": 303, "published": "Public", "date": "1560807435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nOriginal Bonzomatic shader can be found here: http://lezanu.fr/LiveCode/LostTree.glsl\n*/\n\n#define time iTime\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,137,235);\n  vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*5672.655), fract(sin(val+st.x)*5672.655), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nfloat tri(float t) {\n  return abs(fract(t)-0.5);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 light=vec3(6,0,0);\n\nfloat at=0.0;\nfloat at2=0.0;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  p.xz *= sign(p.y);\n  \n  float trunk = step(bp.y,0.0);\n  \n  p.y=-abs(p.y);\n  \n  float t=time*2.0;\n  float rotamount = trunk*0.5+0.5;\n  float rot2 = 0.3 + (1.0-trunk)*0.2;\n  float noi = 1.0 + (1.0-trunk)*2.0;\n  p.xy *= rot(sin(t*0.5) * 0.2 * p.y * rotamount);\n  p.zy *= rot(sin(t*0.6) * 0.25 * p.y * rotamount);\n  \n  p.y += 0.53;\n  \n  \n  p+=(noise(p*6.0)-.5)*0.05 * noi;\n  p+=(noise(p*2.0)-.5)*0.2 * noi;  \n  vec3 bp2=p;\n    \n  float d = 10000.0;\n  for(int i=0; i<7; ++i) {\n    p.xz = abs(p.xz);\n    float sizey = 0.2 - 0.005*float(i) - (1.0-trunk)*0.03;\n    float sizex = 0.53 - 0.07*float(i);\n    d = min(d, max(length(p.xz)-0.1*sizex, abs(p.y-sizey)-sizey));\n    p.xy *= rot(rot2);\n    p.zy *= rot(rot2);\n    p.y += sizey*1.9;    \n  }\n  \n  d = min(d, max(length(p.xz)-0.01, abs(p.y-0.3)-0.3));\n  \n  d += (1.0-trunk)*0.007;\n    \n  float leaf = length(p-vec3(0,0,0.1))-0.2;\n  leaf = max(leaf, 0.3-length(p-vec3(0,0.31,0)));\n  \n  leaf += -0.1+noise(bp2*3.0)/7.0 + (1.0-trunk);\n    \n  d = min(d, leaf);\n  d *= 0.5;\n  \n  float planet = length(bp-vec3(0,3,0))-3.2;\n  float tris = tri(bp.x)*0.2 + tri(bp.z*0.7+.2)*0.3 + tri(bp.z*1.8+.2)*0.1;\n  float pdist = 5.6 + tris;\n  planet = max(planet, pdist-length(bp-vec3(0,6.0,0)));\n  d=min(d, planet);\n  \n  float ast = (length(bp-light) - 1.0);\n  at += 0.2/(0.2+ast);\n  \n  float ast2 = (length(bp+light) - 1.2);\n  at2 += 0.2/(0.2+ast2);\n  \n  d=min(d, ast*0.6);\n  d=min(d, ast2*0.6);\n    \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time*.5)*0.4-0.2);\n  p.xz *= rot(time*0.2);\n  \n}\n\nvec3 sky(vec3 r) {\n  return mix(vec3(0), vec3(0.5,0.6,1.0), pow(clamp(-r.y*0.5+0.7,0.0,1.0),5.0));\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n  return clamp(map(p+n*d)/d,0.0,1.0)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,-8);\n  vec3 r=normalize(vec3(-uv, 0.8));\n  \n  cam(s);\n  cam(r);\n  \n  s.y -= 1.0;\n  \n  \n  \n  light.xy *= rot(time);\n  light.yz *= rot(time*.7);\n  \n  vec3 p=s;\n  float i=0.0;\n  bool outside = false;\n  for(i=0.0; i<100.0; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      i += d/0.001;\n      break;\n    }\n    if(d>100.0) {\n      outside = true;\n      break;\n    }\n    p+=r*d;\n  }\n  \n  \n  vec3 col = vec3(0);\n  \n  vec3 lcol = vec3(1.0,0.7,0.2);\n  vec3 lcol2 = vec3(0.3,1.0,0.5);\n  \n  col += pow(at * 0.1,0.6) * 0.8*lcol;\n  col += pow(at2 * 0.1,0.6) * 0.4*lcol2;\n  \n  float fog=1.0-clamp(length(p-s)/100.0,0.0,1.0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l = normalize(light-p);\n  \n  float fre = pow(1.0-abs(dot(n,r)), 4.0);\n  \n  float ao = pow(getao(p, n, 1.0) * getao(p, n, 0.5) * pow(getao(p, n, 0.05),3.0), 0.4);\n  \n  // hack: if close to one of the lights, we direct the normal toward the light to get full illumination\n  if(length(light-p)<2.0) n = l;\n  if(length(-light-p)<2.0) n = -l;\n  \n  col += max(0.0, dot(n,l)) * fog * lcol * 40.0 * ao / pow(length(light-p),2.0);\n  col += max(0.0, dot(n,-l)) * fog * lcol2 * 30.0 * ao / pow(length(-light-p),2.0);\n   \n  \n  if(outside) {\n    col += sky(r);\n    vec3 stars = vec3(smoothstep(0.0,1.0,noise(r*53.0)), smoothstep(0.0,1.0,noise(r*33.0)), smoothstep(0.0,1.0,noise(r*127.0)));\n    stars = mix(vec3(1.0), pow(stars, vec3(10.0)), 0.7);\n    col += vec3(6) * smoothstep(0.9,1.0,noise(r*120.0)) * stars;\n  } else {\n    col += sky(reflect(r,n)) * fre * ao;\n    col += sky(n) * fre * ao;\n  }\n    \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 193, 193, 262], [264, 264, 285, 285, 568], [570, 570, 590, 590, 620], [622, 622, 661, 661, 738], [794, 794, 813, 813, 2274], [2276, 2276, 2300, 2300, 2370], [2372, 2372, 2390, 2390, 2472], [2474, 2474, 2512, 2512, 2560], [2562, 2562, 2619, 2619, 4435]]}
{"id": "wljGRy", "name": "test123123", "author": "RPG59", "description": "test123", "tags": ["test123"], "likes": 1, "viewed": 58, "published": "Public", "date": "1560087716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 32\n#define MAX_DISTANCE 100.\n\nfloat sphere(vec3 at) {\n    float radius = .5;\n\treturn length(at) - radius;\n}\n\nfloat ground(vec3 at) {\n\treturn at.y + 1.;\n}\n\nfloat world(vec3 at) {\n\treturn min(sphere(at), ground(at));\n}\n\nfloat trace(vec3 camera, vec3 coord) {\n    float L = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; ++i) {\n    \tfloat d = world(camera + coord * L);\n        L += d;\n        if(L > MAX_DISTANCE) break;\n    }\n    \n    return L;\n}\n\nvec3 getNormals(vec3 coord) {\n\tvec2 e = vec2(.01, 0);\n    float w = world(coord);\n    \n    return normalize(vec3(world(coord + e.xyy) - w,\n                          world(coord + e.yxy) - w,\n                          world(coord + e.yyx) - w));\n}\n\nvec3 diffLight(vec3 lightPos, vec3 coord) {\n    vec3 norm = getNormals(coord);\n    vec3 lightDir = normalize(lightPos - coord);\n    return vec3(max(dot(norm, lightDir), .0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 camera = vec3(0., 0., 3.);\n    vec3 coord = normalize(vec3(uv, -2.));\n   \n    \n  \tfloat color = trace(camera, coord);\n    vec3 light = diffLight(vec3(cos(iTime), 2.+sin(iTime), 2), (camera + coord * color));\n\n    fragColor = vec4(light, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 71, 71, 125], [127, 127, 150, 150, 171], [173, 173, 195, 195, 234], [236, 236, 274, 274, 459], [461, 461, 490, 490, 707], [709, 709, 752, 752, 885], [887, 887, 943, 943, 1288]]}
{"id": "wljGWV", "name": "Phantom Star", "author": "kasari39", "description": "phantom star!", "tags": ["raymarching", "ifs", "phantommode"], "likes": 22, "viewed": 447, "published": "Public", "date": "1561226599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.3, 0.0, -1.0));\n    vec3 cUp  = vec3(0.5, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 106], [164, 164, 192, 192, 298], [300, 300, 329, 329, 420], [422, 422, 444, 444, 634], [636, 636, 666, 666, 838], [840, 840, 897, 897, 1877]]}
{"id": "wlS3Dy", "name": "ç¬è¸", "author": "long", "description": "ç¬è¸å­¦ä¹ ", "tags": [], "likes": 0, "viewed": 72, "published": "Public API", "date": "1560927106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size) {\n    uv -= p;\n    uv /= size;\n    \n    float mask = Circle(uv, vec2(0.), .45, .05);\n    \n    mask -= Circle(uv, vec2(-.13, .2), .07, .01);\n    mask -= Circle(uv, vec2(.13, .2), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0., 0.), .3, .02);\n    mouth -= Circle(uv, vec2(0., .1), .3, .02);\n    \n    mask -= mouth;\n\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -=0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float t = iTime;\n    vec2 p = vec2(cos(t)*.3, sin(t)*.3);\n    \n    float mask = Smiley(uv, p, .3);\n    \n    \n    col = vec3(1., 1., 0.)*mask;\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 138], [140, 140, 183, 183, 520], [522, 522, 579, 629, 947]]}
{"id": "WlS3Rd", "name": "Minimally Profane", "author": "khlorghaal", "description": "the most minimalist dirty joke in existence", "tags": ["minimalist"], "likes": 1, "viewed": 66, "published": "Public", "date": "1560642773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat t= iTime;    \n    float p= sin(t*.5);\n    float f= sin(t*(5.+p*0.05));    \n    f= f*(.5*p)+.4;\n    f= f<uv.x? 1.:0.;\n    fragColor = vec4(f,f,f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlS3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 256]]}
{"id": "WlS3RV", "name": "three in one", "author": "Mishka", "description": "a variant of @party compo shader", "tags": ["interactive"], "likes": 1, "viewed": 95, "published": "Public", "date": "1560170589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fract_sin_dot (vec2 uv) {\n        return fract(sin(dot(\n                         uv.xy,\n                         // vec2(sin(4.*uv.x), sin(10.*uv.y)),\n                         // vec2(sin(4.*uv.x), uv.y),\n                         0.1*iMouse.xy+vec2(1.0,1.0)))*\n        4. + 0.5*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(fract_sin_dot( uv ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), sin(10.*uv.y)) ),\n                      fract_sin_dot( vec2(sin(4.*uv.x), uv.y) ));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlS3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 293], [295, 295, 352, 352, 612]]}
{"id": "wlS3zt", "name": "mandelbrot orbit-Modificado", "author": "jorge2017a1", "description": "mandelbrot orbit-Modificado", "tags": ["mandelbrot", "orbit"], "likes": 2, "viewed": 55, "published": "Public", "date": "1560693018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Creado por FabriceNeyret2 en 2019-06-07 y modificado por jorge flores.p\n\n\nvoid mainImage( out vec4 o, vec2 u ) {\n   \n    float v, l = 1e5, t;\n    \n    \n    t=iTime;\n    \n    vec2 R = iResolution.xy, z, z0,\n         c = (u-.5*R)/R.y/pow(t,t/20.) - vec2(1.001105,.300717);\n    \n    \n    //for (float k = 6.3; k >0.; k -= 6e-3)\n    for (float k = 6.3; k >0.; k -= 8e-3)\n    { \n        v = dot( z = mat2(z,-z.y,z.x)*z + c , z );\n        if ( v< l )  l=v, z0=z;\n        if (v > 4. ) break;\n    }\n    \n    // display either map(last z) or map(shortest z) :\n    \n\n    float tmp;\n    tmp=abs(length(z0)-.5);\n    o = vec4(z0.x+tmp,z0.y+tmp,tmp,1.0);  \n    \n \n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlS3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 115, 115, 656]]}
{"id": "WlSGD3", "name": "Zen", "author": "hookdump", "description": "zzz", "tags": ["zen"], "likes": 4, "viewed": 128, "published": "Public", "date": "1561274392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 1.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.05;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.5;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 10.0;\t// how fast to rotate (0 = no rotation)\nconst float dotSize \t\t\t= 0.3;\t// how much to scale recursion at each step\nconst int   recursionCount\t\t= 6;\t// how deep to recurse\nconst float blur\t\t\t\t= 4.0;\t// how much blur\nconst float outline\t\t\t\t= 0.015; // how thick is the outline\nconst float brightness\t\t\t= 0.;\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s + p.y*c));\n}\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 1.0)));\n}\n\nfloat GetFocusRotation(int i) \n{ \n    float theta = 2.0*pi*RandFloat(i);\n    return theta + turnSpeed*mix(-1.0, 1.0, RandFloat(30+i))*iTime; \n}\n\nvec2 GetFocusPos(int i) \n{ \n    bool side = (RandFloat(50+i) < 0.5);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat YinYang2( vec2 p, out float dotDistance, float co, float scale)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n\t   c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, r));\n    dotDistance = r;\n    \n    // top\n    r = length(2.0*p - vec2(0, 1));\n    if (p.x >= 0.0)\n\t\tc = mix(0.0, c, smoothstep(1.0-b, 1.0+b, r));\n    if (p.y >= 0.0)\n         dotDistance = r;\n    \n    // outline\n    r = length(p);\n    c = mix(c, co, smoothstep(1.0-b, 1.0, r));\n    \n    return c;\n}\n\nvec4 RecursiveYinYang(vec2 p, int iterations, float scale)\n{\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < recursionCount; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = YinYang2(p, dotDistance, co, scale);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n            \n            co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = ((dotDistance < dotSize+outline+b) && (p.y > 0.0))? 1 : 0;\n            float value = brightness*fract(0.41*float(iterations + r + i2));\n            float hue = 0.133*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co - value, 1.0); // stop if outside or reached limit\n        }\n     \t\n\t\t// check if top or bottom\n        co = (p.y > 0.0)? 1.0 : 0.0;\n        p.y += mix(0.5, -0.5, co);\n        \n        scale *= 2.0/dotSize;\n        p *= 2.0/dotSize;\t\t// apply recursion scale\n        p = Rotate(p, -theta);\t// cancel out rotation\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n\tvec2 p = (2.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 p2 = p;\n    \n    // wander center\n\tp.x += 0.3*sin(0.234*iTime);\n\tp.y += 0.3*sin(0.2*iTime);\n    \n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n\t// update zoom, apply pow to make rate constant\n    const float recursionSize = 2.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get focus offset\n\tvec2 offset = GetFocusPos(iterations);\n\tfor (int i = 0; i < 7; ++i)\n\t\toffset += (GetFocusPos(iterations+i+1) / recursionSize) * pow(1.0 / recursionSize, float(i));\n    \n    // apply zoom and offset\n\tp = p*zoom + offset;\n    \n    // make the yin yang\n    color = RecursiveYinYang(p, iterations, zoom);\n    \n    // wander hue\n    color.x += (0.1*p2.y + 0.1*p2.x + 0.05*iTime);\n    \n    // map to rgp space\n    color = HsvToRgb(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSGD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[903, 1055, 1079, 1079, 1125], [1126, 1126, 1160, 1160, 1265], [1266, 1266, 1290, 1290, 1435], [1437, 1437, 1469, 1469, 1580], [1582, 1582, 1608, 1608, 1738], [1740, 1824, 1895, 1895, 2433], [2435, 2435, 2495, 2522, 3686], [3688, 3772, 3818, 3844, 4780]]}
{"id": "wlSGDD", "name": "Cube-mapped Double Quad Truchet", "author": "BigWIngs", "description": "See comments for details. Mouse to move", "tags": ["cubemap", "truchet", "double", "quad"], "likes": 58, "viewed": 1481, "published": "Public", "date": "1559713614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cube-mapped Double Quad Truchet by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Playing around with truchet tiles. This makes use of the normal quad tiling\n// but has two exit points per edge instead of one making for a lot more random\n// looking effect. The lines from entry to exit point are made of segmented\n// bezier splines which isn't terribly performant but looks nice.\n// \n// In order to get this onto a sphere without any poles I used a cubemapping\n// technique which works well with quad truchet because it seemlessly fits\n// corners where three edges meet.\n//\n// I didn't make completely random entry-exit point combinations. Perhaps \n// someone can come up with a clever algorithm for this. Instead, I made a bunch\n// of presets that I choose from randomly, subsequently I rotate the entry-exit\n// points by a random offset to get the variety you see. There should be many more\n// variations though if the points were truly random. A quick calculation (and I\n// might be wrong) yields 8 factorial divided by two different combinations,\n// which is more than 20 thousand\n//\n// Set SHOWGRID to true to be able to see the truchet tiles.\n//\n// Use these to change the effect\n\n#define SHOWGRID false\n#define BEZIER_STEPS 8\n#define GRID_SIZE 5.\n#define SPLINE_WIDTH .1\n#define SPLINE_COLOR vec3(1)\n#define SPLINE_SOFTNESS .5\n#define SHADOW_WIDTH 3.\n#define CYCLE_VARIATIONS 0.\n\n// entry-exit point presets\nfloat g[64] = float[64] (\n\t0., 3., 1., 5., 2., 7., 4., 6.,\n    0., 1., 2., 3., 4., 7., 5., 6.,\n    0., 7., 1., 5., 2., 6., 3., 4.,\n    0., 4., 1., 3., 2., 5., 6., 7.,\n    0., 5., 1., 4., 2., 7., 3., 6.,\n    0., 6., 1., 5., 2., 4., 3., 7.,\n    0., 2., 1., 5., 3., 4., 6., 7.,\n    0., 7., 2., 6., 3., 4., 5., 1.\n);\n\nfloat N21(vec2 p) {\n\tp = fract(p*vec2(123.34,345.56));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat dLineSeg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n// distance to segmented cubic bezier\nfloat dBezier(vec2 p, vec4 a, vec4 b) {\n    \n    vec2 p1=a.xy, p2=p1+a.zw, p3=b.xy+b.zw, p4=b.xy;\n        \n    float d = 100.;\n    \n    vec2 pb = p1;\n    vec2 ppb;\n    \n    for(int i=0;i<BEZIER_STEPS;i++) {\n    \tfloat t = float(i+1)/float(BEZIER_STEPS);\n        \n        ppb = pb;\n        \n        vec2 p12 = mix(p1, p2, t);\n        vec2 p23 = mix(p2, p3, t);\n        vec2 p34 = mix(p3, p4, t);\n        \n        vec2 p1223 = mix(p12, p23, t);\n        vec2 p2334 = mix(p23, p34, t);\n        \n        pb = mix(p1223, p2334, t);\n        \n        d = min(d, dLineSeg(p, ppb, pb));\n    }\n    \n    return d;\n}\n\n\n// returns position and tangent that we need to draw bezier spline\nvec4 GetVec(float i, float s) {\n    \n    i = mod(i, 8.);\n    // i  ->  0   1   2   3   4   5   6   7\n    // x  -> -1   1   2   2   1  -1  -2  -2\n    // y  ->  2   2   1  -1  -2  -2  -1   1\n     \n    float a = 6.2832*i/(8./9.);\n    vec2 pos = vec2(\n        round(cos(a-.5*3.1415-.3)*2.),\n        round(cos(a-.3)*2.)\n    );\n    \n    i = floor(i/2.);\n    \n    // i  ->  0  1  2  3\n    // x  ->  0 -1  0  1\n    // y  -> -1  0  1  0\n    \n    float m2 = mod(i, 2.); \t\t// 0 1 0 1 0 1\n   \tvec2 tangent = vec2(\n        i==1. ? -1. : m2,\n        i==0. ? -1. : 1.-m2\n    );\n    \n    // you can scale tangent to get different looking splines\n    //tangent *= 3.;//mix(.25, 2.5, fract(sin(s*345.23)*5434.));\n\t \n    return vec4(pos.x, pos.y, tangent.x, tangent.y)*.25;\n}\n\n// draw a spline with a shadow\nvec4 Spline(vec2 uv, float w, int k, float n, float s) {\n\tfloat d = dBezier(uv, GetVec(g[k+0]+n, s+1.), GetVec(g[k+1]+n, s+2.));\n    float m = smoothstep(w, w*SPLINE_SOFTNESS, d);\n    \n    vec3 col = m*SPLINE_COLOR;\n    float shadow = max(m, smoothstep(w*SHADOW_WIDTH, 0., d));\n    \n    return vec4(col, shadow);\n}\n\nvec4 QuadTruchetTex(vec2 uv) {\n    vec2 gv = fract(uv)-.5;\n\tvec2 id = floor(uv);\n    float n = N21(id);  \n    \n    float t = iTime*CYCLE_VARIATIONS;\n    int k = int(floor(fract(n*3425.12+floor(t*3.))*8.))*8;\n    float s = n*10.;\n    n = floor(n*8.)+floor(t*2.);\n    float w = SPLINE_WIDTH;\n\n    // draw four entry-exit splines\n    vec4 s1 = Spline(gv, w, k, n, s);\n    vec4 s2 = Spline(gv, w, k+2, n, s+2.);\n    vec4 s3 = Spline(gv, w, k+4, n, s+4.);\n    vec4 s4 = Spline(gv, w, k+6, n, s+6.);\n    \n    // composite splines\n    vec4 col = mix(s1, s2, s2.a);\n    col = mix(col, s3, s3.a);\n    col = mix(col, s4, s4.a);\n    \n    if(SHOWGRID && (gv.x>.48||gv.y>.48)) col.r = 1.;\n    \n    return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 ro) {\n\tvec3 f = normalize(vec3(0)-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n    return rd;\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    //mattz' trick for less distortion in the corners\n    // st.xy = atan(st.xy*tan(0.868734829276))/0.868734829276;\n    \n    // iq version, no trig, short and sweet\n    //st.xy *= 3.0/(2.0+abs(st.xy));\n    //st.xy *= 1.25 - 0.25*st.xy*st.xy;\n    \n    // mattz's no trig version\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n    \n    \n    return st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // set up camera\n    vec3 ro = vec3(0,0.,-2.5);\n    ro.yz *= Rot(-M.y*3.+sin(iTime*.1));\n    vec3 rd = GetRayDir(uv, ro);\n    \n    // marching loop\n    float dO=0., dS;\n    vec3 p;\n    for(float i=0.; i<100.; i++) {\n    \tp = ro + rd * dO;\n        dS = length(p)-1.;\n        dS = min(dS, -(length(p)-4.));\t// background\n        \n        if(dS<.001) break;\n        dO += dS;\n    }\n    \n    vec4 col = vec4(0);\n    \n    // handle material\n    if(dS<.001) {\n        float d = length(p-ro);\n        vec3 n = normalize(p);\n        float fresnel = 1.+dot(rd, n);\n        fresnel *= fresnel;\n        fresnel *= fresnel;\n        \n       \tp.xz *= Rot(iTime*.1);\n        vec3 cc = WorldToCube(p);\n        col = QuadTruchetTex(cc.xy*GRID_SIZE+cc.z*10.);\n       \n        // soften edge of main sphere a bit\n        if(length(p)<1.2) col = mix(col, vec4(.5), fresnel);\n        \n        // darken background\n        col /= max(1., d*.3);\n    }\n    \n    // vignette\n    col *= vec4(1.-dot(uv,uv));\n   \t\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGDD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1527, 1869, 1888, 1888, 1978], [1980, 1980, 1999, 1999, 2062], [2064, 2064, 2104, 2104, 2220], [2222, 2260, 2299, 2299, 2863], [2866, 2933, 2964, 2964, 3689], [3691, 3722, 3778, 3778, 4036], [4038, 4038, 4068, 4068, 4736], [4738, 4738, 4772, 4772, 4976], [4978, 5080, 5106, 5106, 5741], [5743, 5743, 5800, 5800, 6939]]}
{"id": "WlSGDm", "name": "Lines truchet tiles", "author": "avin", "description": "simple truchet tiles\nhttps://en.wikipedia.org/wiki/Truchet_tiles", "tags": ["truchet"], "likes": 4, "viewed": 397, "published": "Public API", "date": "1559730352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI_4 0.78539815\n#define PI_2 1.5707963\n\n#define SIZE iResolution.y*.1\n#define SF SIZE/min(iResolution.x,iResolution.y)\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\n\nmat2 rot(float a){\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n            \n    vec2 guv = uv*SIZE;\n    vec2 gid = floor(guv);\n    guv = fract(guv) - .5;\n    \n    float gidHash = floor((rand1(gid.x + gid.y*100.) + iTime*.1)*2.);    \n    guv *= rot(PI_2 * (gidHash));\n    \n    float sf = SF*SIZE;\n            \n    // float m = 1. - (smoothstep(guv.x-SF, guv.x, guv.y) - smoothstep(guv.x, guv.x+SF, guv.y));        \n    float m = 1. - smoothstep(SF,0.,abs(guv.y-guv.x));      \n    \n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 200, 200, 276], [278, 278, 335, 335, 844]]}
{"id": "wlSGDw", "name": "rainbow grid", "author": "mahalis", "description": "gentle psychedelia", "tags": ["grid", "rainbow"], "likes": 3, "viewed": 548, "published": "Public API", "date": "1559748169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float twoPi = 6.283;\n\nvec3 hash3(vec2 p) {\n\tvec3 q = vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)));\n\treturn fract(sin(q) * 43758.5453);\n}\n\n// extremely questionable implementation of iqâs Voronoise\nfloat voronoise(vec2 x) {\n\tvec2 cell = floor(x);\n\tvec2 cellCoordinate = fract(x);\n\t\n\tfloat accum = 0.;\n\tfloat weight = 0.;\n\tfor(int x = -2; x <= 2; x++) {\n\t\tfor(int y = -2; y <= 2; y++) {\n\t\t\tvec2 cellOffset = vec2(y, x);\n\t\t\tvec3 noiseValue = hash3(cell + cellOffset); // for Perlin noise, ditch the first two components\n\t\t\tfloat cellDistance = length(cellOffset - cellCoordinate + noiseValue.xy);\n\t\t\tfloat smoothedDistance = (1.0 - smoothstep(0., 1.414 /* sqrt(2) */, cellDistance));\n\t\t\taccum += noiseValue.z * smoothedDistance;\n\t\t\tweight += smoothedDistance;\n\t\t}\n\t}\n\treturn accum / weight;\n}\n\n// palette function also from an iq article\nvec3 palette(float v) {\n    return vec3(0.5) + 0.5 * vec3(cos(twoPi * (v + vec3(0.0, 0.333, 0.667))));\n}\n\nfloat stripe(float v, float w) {\n\tfloat halfW = w * 0.5;\n\tfloat normV = fract(v);\n\tfloat alias = fwidth(v);\n\treturn min(smoothstep(0.5 - halfW - alias, 0.5 - halfW, normV), smoothstep(0.5 + halfW + alias, 0.5 + halfW, normV));\n}\n\nvec2 direction(float a) {\n\treturn vec2(cos(a), sin(a));\n}\n\nvec2 rotate(vec2 p, float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3. * fragCoord/iResolution.x;\n    uv.y += 0.1 * sin(uv.x + iTime * 0.1);\n\t// color\n\n\tvec2 noiseCoordinate1 = uv * 8. + direction(fract(iTime * 0.043) * twoPi) * sin(fract(iTime * 0.07) * twoPi);\n\tfloat noiseValue1 = voronoise(noiseCoordinate1);\n\tvec2 noiseCoordinate2 = uv * 9. + direction(fract(iTime * -0.01) * twoPi) * sin(fract(iTime * 0.023) * twoPi) * 2.;\n\tfloat noiseValue2 = voronoise(noiseCoordinate2);\n\tvec2 noiseCoordinate3 = uv * 11. + direction(fract(iTime * 0.0074) * twoPi) * sin(fract(iTime * 0.019) * twoPi) * 3.;\n\tfloat noiseValue3 = voronoise(noiseCoordinate3);\n\n\tfloat noiseValue = noiseValue1 * noiseValue2 * noiseValue3 * 3.; // is this normalization factor right? probably not\n\tvec3 color = palette(3. * noiseValue);\n\n\tuv = rotate(uv, cos(iTime * 0.001) * 0.04 * twoPi);\n\t// distort\n\tuv += 0.014 * (sin(uv * 8. + iTime * 0.4) + sin(uv * 11. + iTime * 0.31) * vec2(1., -1.));\n\n\t// grid\n\n\tvec2 diagonalDirection = vec2(sqrt(3.0) * 0.5, 0.5);\n\tconst float lineScale = 10.;\n\tconst float lineWidth = 0.02;\n\t\n\tfloat v = max(max(stripe(dot(uv, diagonalDirection) * lineScale, lineWidth), stripe(dot(uv, vec2(-diagonalDirection.x, diagonalDirection.y)) * lineScale, lineWidth)), stripe((uv.y + 0.15) * lineScale, lineWidth));\n    \n    fragColor = vec4(v * color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 48, 48, 186], [188, 249, 274, 274, 841], [843, 887, 910, 910, 991], [993, 993, 1025, 1025, 1221], [1223, 1223, 1248, 1248, 1280], [1282, 1282, 1312, 1312, 1405], [1407, 1407, 1464, 1464, 2763]]}
{"id": "wlSGRc", "name": "[TWITCH] Coral beast", "author": "Flopine", "description": "This is a shader I made during a live session on Twitch. You can watch them here: https://www.twitch.tv/flopine\nIt's heavily inspired by the book \"Art Forms in Nature\" by Ernst Haeckel. https://www.amazon.fr/Art-Forms-Nature-Ernst-Haeckel/dp/0486229874", "tags": ["raymarching", "fractal", "nature", "symmetry", "coral"], "likes": 7, "viewed": 233, "published": "Public", "date": "1560461322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\nfloat PI = acos(-1.);\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise (vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p =p.yx;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\n// polynomial smooth iq\nfloat smin (float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat torus (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nfloat inner_body (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 1.;\n    float t = torus (p.xzy, vec2(0.8,0.5));\n\n    p=pp;\n    float c = cyl(p.xzy, .4-abs(p.y)*p.y*0.5+sin(p.y*2.+time)*0.1+0.15, 1.5);\n\n    return stmin(c,t,0.2,3.);\n}\n\nfloat first_tentacles (vec3 p)\n{\n    moda(p.xz, 7.);\n    p.x -= 1.5;\n    p.x += sin(p.y*2.+time)*0.3;\n    float c1 = cyl(p.xzy, 0.2-p.y*0.1, 2.); \n\n    p.y -= 2.;\n    p.xy *= rot(time*0.5);\n    float t = torus(p, vec2(0.3,0.05));\n    moda(p.xy, 5.);\n    p.x -= 0.5;\n    p.y += sin(p.x*5.+time)*0.1;\n    float c2 = cyl(p.yzx, 0.05-p.x*0.1, 0.2);\n\n    return min(min(t,c2),c1);\n}\n\nfloat second_tentacles (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 2.5;\n    float t = torus(p.xzy,vec2(2.5,1.));\n\n    p = pp;\n    p.xz *= rot(PI/7.);\n    moda(p.xz, 7.);\n    p.x -= 2.;\n    p.x += sin(p.y*2.-time)*0.3;\n    float c1 = cyl(p.xzy, 0.2-p.y*0.3, 2.);\n    return smin(c1,t, 0.5);\n}\n\nfloat beating_dots (vec3 p)\n{\n    p.y += 2.5;\n    moda(p.xz, 15.);\n    p.x -= 3.5;\n    return length(p)-(0.2+exp(-fract(time))*0.15);\n}\n\nfloat background (vec3 p)\n{\n    p.x += texNoise(p.yz*0.04).r*0.6;\n    p.y += texNoise(p.xz*0.04).r*0.5;\n    return -cyl(p,20.,1e10);\n}\n\nint mat_id;        \nfloat SDF (vec3 p)\n{\n    float b = background(p);\n    mo(p.xz,vec2(2.5,1.));\n    p.xz *= rot(PI/2.);\n    mo(p.yz, vec2(3.8));\n    p.xz*=rot(time*0.5);\n    float s = min(stmin(beating_dots(p),second_tentacles(p),0.1,3.),\n                  min(inner_body(p),first_tentacles(p))\n                 );\n    float d = min(b,s);\n    if (d == b) mat_id = 1;\n    if (d == s) mat_id = 2;\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.001,0.001,-20.5), p = ro, col = vec3(0.);\n    vec3 rd = normalize(vec3 (uv,1.));\n\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i =0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            hit = true;\n            break;\n        }\n        p+=d*rd*0.85;\n    }\n    float t = length(ro-p);\n    if (hit) \n    {\n        vec3 n = getnorm(p);\n        vec3 l = vec3(0., -5., -2.);\n        if (mat_id == 1) col = vec3(shad)*0.4;\n        if (mat_id == 2) col = mix(vec3(0.1,0.,0.2),vec3(0.8,1.,0.8),lighting(n,l));\n    }\n    else col = vec3(0.);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 482, 507, 507, 745], [747, 747, 784, 784, 927], [930, 930, 962, 962, 1010], [1012, 1012, 1032, 1032, 1075], [1078, 1102, 1142, 1142, 1235], [1237, 1237, 1287, 1287, 1390], [1392, 1392, 1430, 1430, 1469], [1471, 1471, 1501, 1501, 1570], [1572, 1572, 1599, 1599, 1797], [1799, 1799, 1831, 1831, 2176], [2178, 2178, 2211, 2211, 2464], [2466, 2466, 2495, 2495, 2601], [2603, 2603, 2630, 2630, 2737], [2759, 2759, 2779, 2779, 3150], [3152, 3152, 3175, 3175, 3288], [3290, 3290, 3323, 3323, 3360], [3362, 3362, 3418, 3418, 4223]]}
{"id": "wlSGWd", "name": "GPU hacks #08 - OpenCL", "author": "PrzemyslawZaworski", "description": "Next step in mastering GPU programming - this time we use OpenCL to render raymarching fractal.", "tags": ["framework", "tutorial", "code"], "likes": 12, "viewed": 385, "published": "Public", "date": "1561493825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nReference: https://www.khronos.org/files/opencl-quick-reference-card.pdf\nSave code as demo.cl and compile by NVCC compiler (or equivalent):\nnvcc -x cu -o demo.exe demo.cl -luser32 -lgdi32 -lOpenCL\nPaste own code inside ComputeKernel. Press ESC to exit program.\n*/\n\n/*\n#include <windows.h>\n#include <CL/cl.h>\n\n#define width 1280\n#define height 720\n\nstatic const char* ComputeKernel =\n\"float3 map (float3 p)\"\n\"{\"\n\t\"for (int i = 0; i < 16; ++i)\"\n\t\"{\"\n\t\t\"p = fabs(p/dot(p,p)-(float3)(0.64,0.46,0.93));\"   \n\t\"}\"\t\n\t\"return (float3)(p.x/50.,p.y/50.,p.z/50.);\"\n\"}\" \n\"float4 raymarch (float3 ro, float3 rd)\"\n\"{\"\n\t\"float3 c = (float3)(0.,0.,0.);\"\n\t\"float t = 0.0;\"\n\t\"for(int i=0; i<50; ++i)\"\n\t\"{\"\n\t\t\"t+=0.5;\"\n\t\t\"c+=map(ro+t*rd);\"\n\t\"}\"\n\t\"return clamp((float4)(c,1.0),(float4)(0.0,0.0,0.0,0.0),(float4)(1.0f,1.0f,1.0f,1.0f));\"\n\"}\"\n\"__kernel void mainImage(__global uchar4 *fragColor, float iTime)\"\n\"{\"\n\t\"unsigned int id = get_global_id(0);\"\n\t\"int2 iResolution = {1280, 720};\"\n\t\"int2 fragCoord = {id % iResolution.x, id / iResolution.x};\" \n\t\"float2 uv = {(2.0 * fragCoord.x - (float)iResolution.x - 1.0) / iResolution.y, (2.0 * fragCoord.y - (float)iResolution.y) / iResolution.y};\"\n\t\"float3 ro = {0.0,3.0*cos(iTime * 0.05),6.0};\"\n\t\"float3 rd = normalize((float3)(uv,2.0));\"\n\t\"rd = (float3)(dot((float3)(1,0,0),rd), dot((float3)(0, cos(iTime * 0.3),sin(iTime * 0.3)),rd),  dot((float3)(0,-sin(iTime * 0.3),cos(iTime * 0.3)),rd));\"\n\t\"rd = (float3)(dot((float3)(cos(iTime * 0.1),sin(iTime * 0.1),0),rd),  dot((float3)(-sin(iTime * 0.1),cos(iTime * 0.1),0),rd), dot((float3)(0,0,1),rd));\"\n\t\"float4 q = raymarch(ro,rd);\"\n\t\"fragColor[id] = (uchar4)( q.z * 255, q.y * 255, q.x * 255, 255);\"\n\"}\";\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif (uMsg == WM_KEYUP && wParam == VK_ESCAPE)\n\t{\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"OpenCL Demo\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"OpenCL Demo\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, width, height, 0, 0, 0, 0);\n\tconst BITMAPINFO bmi = { {sizeof(BITMAPINFOHEADER),width,height,1,32,BI_RGB,0,0,0,0,0},{0,0,0,0} };\n\tunsigned char* host = (unsigned char*) malloc(width*height*sizeof(uchar4));\n\tsize_t bytes;\t\n\tcl_uint platformCount;\n\tclGetPlatformIDs(0, 0, &platformCount);\n\tcl_platform_id* platforms = (cl_platform_id*) malloc(sizeof(cl_platform_id) * platformCount);\n\tclGetPlatformIDs(platformCount, platforms, 0);\n\tcl_context_properties properties[] = {CL_CONTEXT_PLATFORM, (cl_context_properties)platforms[0], 0};\n\tcl_context context = clCreateContextFromType (properties, CL_DEVICE_TYPE_GPU, 0, 0, 0);\n\tclGetContextInfo (context, CL_CONTEXT_DEVICES, 0, 0, &bytes);\n\tcl_device_id* info = (cl_device_id*) malloc (bytes);\t\n\tclGetContextInfo (context, CL_CONTEXT_DEVICES, bytes, info, 0);\t\n\tcl_program program = clCreateProgramWithSource (context, 1, &ComputeKernel, 0, 0);\n\tclBuildProgram (program, 0, 0, 0, 0, 0);\n\tcl_kernel kernel = clCreateKernel (program, \"mainImage\", 0);\t\n\tcl_command_queue queue = clCreateCommandQueue (context, info[0], 0, 0); \n\tcl_mem buffer = clCreateBuffer (context, CL_MEM_WRITE_ONLY, width*height*sizeof(uchar4), 0, 0);\n\tclSetKernelArg (kernel, 0, sizeof(cl_mem), (void*)&buffer);\n\tsize_t size = width * height;\n\twhile (!exit)\n\t{\n\t\twhile(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif( msg.message==WM_QUIT ) exit = 1;\n\t\t\tTranslateMessage( &msg );\n\t\t\tDispatchMessage( &msg );\n\t\t}\n\t\tfloat time = GetTickCount() * 0.001f;\n\t\tclSetKernelArg (kernel, 1, sizeof(cl_float), (void*)&time);\n\t\tclEnqueueNDRangeKernel(queue,kernel, 1, 0, &size, 0, 0, 0, 0);\t\n\t\tclEnqueueReadBuffer (queue, buffer, 1, 0, width*height*sizeof(uchar4), host, 0, 0, 0);\t\t\n\t\tStretchDIBits(GetDC(hwnd),0,0,width,height,0,0,width,height,host,&bmi,DIB_RGB_COLORS,SRCCOPY);\n\t}\n\treturn 0;\n}\n*/\n\nvec3 map (vec3 p)\n{\n\tfor (int i = 0; i < 16; ++i)\n\t{\n\t\tp = abs(p/dot(p,p)-vec3(0.64,0.46,0.93));    \n\t}\t\n\treturn p/50.;\n}\n\t\t\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n\tvec3 c = vec3(0,0,0);\n    float t = 0.0;\n\tfor(int i=0; i<50; ++i)\n\t{\n\t\tt+=0.5;\n\t\tc+=map(ro+t*rd);\n\t}\n\treturn vec4(c,1.0);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3 (0.0,3.0*cos(iTime * 0.05),6.0) ;\n\tvec3 rd = normalize(vec3(uv,2.0)) ;\n    rd = vec3(dot(vec3(1,0,0),rd), dot(vec3(0, cos(iTime * 0.3),sin(iTime * 0.3)),rd), dot(vec3(0,-sin(iTime * 0.3),cos(iTime * 0.3)),rd));\n    rd = vec3(dot(vec3(cos(iTime * 0.1),sin(iTime * 0.1),0),rd), dot(vec3(-sin(iTime * 0.1),cos(iTime * 0.1),0),rd), dot(vec3(0,0,1),rd));\n    fragColor = raymarch(ro,rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 4094, 4113, 4113, 4215], [4219, 4219, 4252, 4252, 4377], [4380, 4380, 4437, 4437, 4902]]}
{"id": "wlSGzd", "name": "Breathing tar", "author": "Darien", "description": "Combining FBM with raymarching... ", "tags": ["raymarching", "sdf", "fbm"], "likes": 5, "viewed": 273, "published": "Public", "date": "1560709291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n#define OCTAVES 5\n#define STEPS 32\n#define MIN_DIST 0.1\n#define MAX_DIST 10.0\n\nmat3 rotateX(float a) {\n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., cos(a), -sin(a)),\n        vec3(0., sin(a), cos(a))\n        );\n}\n\n//  Simplex 3D Noise\n//  by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm(vec3 p) {\n  float n = 0.0;\n  float a = 0.5;\n  float s = 2.0;\n  for(int i = 0; i < OCTAVES; i++) {\n    n += snoise(p + vec3(0., 0., iTime*0.1)) * a;\n    p *= s;\n    a *= 0.5;\n  }\n  return n;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - 0.5 * r;\n}\n\nfloat scene(vec3 p) {\n    return sphere(p + fbm(p*0.4), 12.0);\n}\n\nvec3 getNormals(vec3 p) {\n    vec3 delta = vec3(0.001, 0., 0.);\n    float x = scene(p + delta.xyy) - scene(p - delta.xyy);\n    float y = scene(p + delta.yxy) - scene(p - delta.yxy);\n    float z = scene(p + delta.yyx) - scene(p - delta.yyx);\n    return normalize(vec3(x, y, z));\n}\n\n\nfloat rayMarch(vec3 pos, vec3 dir, out vec3 p) {\n    float currentDist = 0.;\n    for(int i = 0; i < STEPS; ++i) {\n        p = pos + (dir * currentDist);\n        float distanceToObj = scene(p);\n        if(distanceToObj < MIN_DIST) {\n            break;\n        }\n        currentDist += distanceToObj;\n        if(currentDist > MAX_DIST) {\n            currentDist = 0.;\n            break;\n        }\n    }\n    return currentDist;\n}\n\n// Standard Blinn lighting model.\n// This model computes the diffuse and specular components of the final surface color.\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition)\n{\n    vec3 fromPointToLight = normalize(lightPosition - pointOnSurface); // Get normal\n    float diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n    vec3 diffuseColor = diffuseStrength * vec3(abs(fbm(pointOnSurface)*2.0)); // Here the color\n    vec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n    vec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n    float specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0), 10.0);\n    // Ensure that there is no specular lighting when there is no diffuse lighting.\n    specularStrength = min( diffuseStrength, specularStrength );\n    vec3 specularColor = specularStrength * vec3( 1.0 );\n    vec3 finalColor = diffuseColor + specularColor;\n    return finalColor;\n}\n\nfloat rect(vec2 st, float horz, float vert, float soft) {\n    float h = smoothstep(-horz, -horz+soft, st.x);\n    h *= smoothstep(horz, horz-soft, st.x);\n    float v =  smoothstep(-vert, -vert+soft, st.y);\n    v *= smoothstep(vert, vert-soft, st.y);\n    return h * v;// * d;\n}\n\nfloat crossShape(vec2 st, float thick, float size, float soft) {\n    float c = rect(st, thick, size, soft);\n    c += rect(st, size, thick, soft);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 st = gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n\tst.x *= iResolution.x / iResolution.y;\n\n    vec3 cameraPos = vec3(0., 0., -10.);\n    vec3 cameraDir = vec3(st.x, st.y, 1.0);\n    vec3 p;\n    vec3 color = vec3(0.);\n    float dist = rayMarch(cameraPos, cameraDir, p);\n\n    //Red cross\n    vec3 redCross = vec3(crossShape(st, 0.003, 0.02, 0.001), 0., 0.);\n\n\n    if(dist > 0.){\n        vec3 lightPos = vec3(-1., 7., -10.);\n        float camDist = normalize(length(cameraPos - p));\n        vec3 normal = getNormals(p);\n        color = calculateLighting(p, normal, lightPos, cameraPos);\n    }\n\n    color += redCross;\n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 128, 128, 252], [254, 306, 327, 327, 364], [365, 365, 392, 392, 440], [442, 442, 463, 463, 2293], [2295, 2295, 2314, 2314, 2496], [2498, 2498, 2529, 2529, 2563], [2565, 2565, 2586, 2586, 2629], [2631, 2631, 2656, 2656, 2910], [2913, 2913, 2961, 2961, 3339], [3341, 3462, 3568, 3568, 4389], [4391, 4391, 4448, 4448, 4666], [4668, 4668, 4732, 4732, 4829], [4831, 4831, 4886, 4886, 5539]]}
{"id": "WlSGzK", "name": "@party compo shader", "author": "Mishka", "description": "Interactive shader controlled by a mouse. Try to replace line 4 with line 3 or 5.\n\nFurther details: https://github.com/anhinga/2019-python-drafts/tree/master/vispy/atparty-2019", "tags": ["interactive"], "likes": 1, "viewed": 91, "published": "Public", "date": "1560144058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fract_sin_dot (vec2 uv) {\n    return fract(sin(dot(\n                         //  uv.xy,\n                         vec2(sin(4.*uv.x), sin(10.*uv.y)),\n                         // vec2(sin(4.*uv.x), uv.y),\n                         0.1*iMouse.xy+vec2(1.0,1.0)))*\n        4. + 0.5*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float value = fract_sin_dot( uv );\n\n    fragColor = vec4(vec3(value),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 290], [292, 292, 349, 349, 471]]}
{"id": "WlXSzn", "name": "Octave Metaballs", "author": "stormy", "description": "an fbm-like octave combination looped applied to some domain warped metaballs = fun", "tags": ["metaballs", "domain", "metaball", "domainwarping", "octave"], "likes": 3, "viewed": 484, "published": "Public API", "date": "1561676238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Metaball octaves by Justas Dabrila\n// Licensed under CC BY 4.0\n#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n#define f32 float\n#define s32 int\n#define b32 bool\n#define m2 mat2\n#define TAU 6.283185307179586\n#define DEG_TO_RAD (TAU / 360.0)\n#define zero_v2 vec2(0,0)\n\nv2 aspect;\n\nv2 to_uv(in v2 p) {\n    return (((v2(2.) * p) / iResolution.xy) - v2(1.)) * aspect;\n}\n\nf32 IGN_dither(in v2 p) {\n    // From http://advances.realtimerendering.com/s2014/index.html#_NEXT_GENERATION_POST\n    // NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\n    return fract(52.9829189*fract(dot(p, vec2(0.06711056, 0.00583715))));\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord ) {\n    aspect = v2(1, iResolution.y / iResolution.x);\n\n    v2 uv = to_uv(fragCoord.xy);\n\n    f32 scale = 10.;\n    uv.xy *= scale;\n\n    const f32 div = 10.;\n    const s32 octaves = 50;\n\n#if 1\n    out_color.b  = .01;\n    out_color.r = .005;\n#endif\n\n#if 1\n    f32 all_balls = 0.;\n    for(s32 octave = 0;\n            octave < octaves;\n            octave++\n    ) {\n        f32 f_octave = f32(octave + 1);\n        f32 octave_t = f_octave/f32(octaves);\n\n        f32 num_balls = div * f_octave;\n\n        f32 l = length(uv);\n        f32 angular_divisor = TAU * (1. / num_balls);\n        f32 uv_angle = atan(uv.y, uv.x) + TAU * .1 * f_octave + sin((f32(octave) / 2.) * iTime * .1);\n        f32 angle = abs(mod(uv_angle, angular_divisor) - angular_divisor * .5);\n\n        v2 p = v2(cos(angle), sin(angle)) * l;\n\n        f32 life_t = fract(iTime * .1 + smoothstep(.4, .8, abs(sin(iTime))) * f_octave * .02);\n        //f32 life_t = fract(iTime * .1 + 987 * octave * .01);\n        life_t /= fwidth(p.x) * 60.;\n\n        v2 mb_pos = p + v2(-1, 0) * life_t * scale;\n        f32 mb = 1. / length(mb_pos) * f_octave * .01;\n\n        out_color += v4(.03, .0,.0,.0) * mb * (1. - life_t);\n\n        all_balls += mb;\n    }\n    \n    all_balls /= f32(octaves);\n    out_color += v4(.0, .1, .2, 0) * all_balls;\n#endif\n\n    out_color -= IGN_dither(gl_FragCoord.xy) * .01;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXSzn.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 283, 302, 302, 368], [370, 370, 395, 557, 633], [635, 635, 692, 692, 2033]]}
{"id": "ws2SzG", "name": "âscaleMARK (Textureless)", "author": "blackle", "description": "most of the code for my 4k \"scalemark\"", "tags": ["4k"], "likes": 7, "viewed": 141, "published": "Public", "date": "1560141859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define MAXDEPTH 6\n\nfloat polarized;// = false;\n\nvec3 ML(float F) {\n    return mat3(1.5,-.2,-.1,-.6,1.1,.2,-.1,.1,1.5)*(.5-.5*cos(2.*F*vec3(5.2,5.7,7.2)));\n}\n\nstruct Ray\n{\n  vec3 m_origin;\n  vec3 m_direction;\n  vec3 m_point;\n  vec3 m_color;\n  float m_attenuation;\n  float m_lag;\n};\n\nfloat sdLine(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sidecond(vec2 p, vec2 a, vec2 b) {\n    return dot(p-b, (a-b).yx*vec2(-1.,1.));\n}\n\nfloat sdProfile(vec2 p) {\n    vec2 a = vec2(0.0);\n    vec2 c = vec2(0.05, 0.4);\n    vec2 d = vec2(0.05, 5.0);\n    vec2 e = vec2(0.0, 5.0);\n    float dist = min(min(sdLine(p,e,a), sdLine(p,c,d)), sdLine(p,a,c));\n    if (sidecond(p, a, c) < 0.0\n        && sidecond(p, e, a) < 0.0\n        && sidecond(p, c, d) < 0.0) dist *= -1.0;\n    return dist;\n}\nfloat triangle(vec2 pp) {\n    vec2 p = pp + vec2(0.5,4.0);\n    vec2 a = vec2(0.0);\n    vec2 c = vec2(4.0, 0.0);\n    vec2 d = vec2(0.0, 8.0);\n    float dist = min(min(sdLine(p,d,a), sdLine(p,c,d)), sdLine(p,a,c));\n    if (sidecond(p, a, c) < 0.0\n        && sidecond(p, d, a) < 0.0\n        && sidecond(p, c, d) < 0.0) dist *= -1.0;\n    return dist;\n}\n\nfloat half_ring(vec2 p, float radius, float thickness) {\n    return abs(max(length(p)-radius,-0.4-p.x))-thickness;\n}\n\nfloat square(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat scene(vec3 p) {\n    float ruler = sdProfile(vec2(p.z,-square(p.xy, vec2(0.8,4.0))))-0.05;\n    float ruler_hole = min(length(p.xy+vec2(0.0,3.0))-0.3, length(p.xy+vec2(0.0,-4.0))-0.1);\n    vec2 ruler2pos = vec2(-1.0,1.0)*p.xy+vec2(5.5,0.0);\n    float ruler2 = sdProfile(vec2(p.z,-half_ring(ruler2pos, 3.3, 0.7)))-0.05;\n    vec2 ruler3pos = p.xy+vec2(5.0,0.0);\n    float ruler3 = sdProfile(vec2(p.z,-abs(triangle(ruler3pos)+0.5)+0.5))-0.05;\n    return max(min(min(ruler, ruler2),ruler3),-ruler_hole);\n}\n\nfloat stress_blob(vec2 p) {\n    return pow(max(1.0-length(p),0.0),4.0);\n}\n\nfloat stress(vec3 p) {\n    vec2 ruler2pos = vec2(-1.0,1.0)*p.xy+vec2(5.5,0.0);\n    vec2 ruler3pos = p.xy+vec2(5.0,0.0);\n    return (0.5+0.5*sin(p.x*2.0))*0.25 + (0.5+0.5*cos(p.y*0.5))*0.25\n         + max(1.0-sdLine(p.xy, vec2(0.0,3.7), vec2(0.0,-3.7)),0.0)\n         + max(1.0-abs(max(length(ruler2pos)-3.3,-0.4-ruler2pos.x)),0.0)\n         + max(1.0-abs(triangle(ruler3pos)+0.5),0.0)\n         + stress_blob(p.xy+vec2(0.0,3.3))*2.0\n         + stress_blob(p.xy+vec2(0.0,2.7))*2.0\n         + stress_blob(p.xy+vec2(0.3,-4.0))*3.0\n         + stress_blob(p.xy+vec2(-0.3,-4.0))*3.0\n         + stress_blob(p.xy+vec2(-5.2,-2.6))*5.0\n         + stress_blob(p.xy+vec2(-5.2,2.6))*5.0\n         + stress_blob(p.xy+vec2(4.5,0.4))*4.0\n         + stress_blob(p.xy+vec2(4.5,3.0))*4.0\n         + stress_blob(p.xy+vec2(3.2,2.9))*4.0\n         + stress_blob(p.xy+vec2(-6.3,-4.0))\n         + stress_blob(p.xy+vec2(-6.3,4.0))\n         - stress_blob(p.xy+vec2(0.3,3.0))\n         - stress_blob(p.xy+vec2(-0.3,3.0));\n}\nvec3 sceneGrad(vec3 point) {\n    float t = scene(point);\n    return normalize(vec3(\n        t - scene(point + vec3(0.0001,0.0,0.0)),\n        t - scene(point + vec3(0.0,0.0001,0.0)),\n        t - scene(point + vec3(0.0,0.0,0.0001))));\n}\n\nbool castRay(inout Ray ray) {\n    // Cast ray from origin into scene\n    float sgn = sign(scene(ray.m_origin));\n    for (int i = 0; i < 100; i++) {\n        float dist = length(ray.m_point - ray.m_origin);\n        if (dist > 40.0) {\n            return false;\n        }\n\n        float smpl = scene(ray.m_point);\n        \n        if (abs(smpl) < 0.0001) {\n            return true;\n        }\n        \n        if (sgn < 0.0) ray.m_lag -= stress(ray.m_point)*4.0*smpl;\n        \n        ray.m_point += smpl * ray.m_direction * sgn;\n    }\n    ray.m_attenuation*=0.0;\n    return false;\n}\n\n\nvec3 backlight(vec3 dir, float lag) {\n    return ML(0.3+polarized*lag)*3.0*smoothstep(0.0,1.0,-0.8-dir.z*4.0)*(dir.z>-0.1?1.0:pow(min(0.5+0.5*cos(dir.x/dir.z*400.0),0.5+0.5*cos(dir.y/dir.z*400.0)),0.02));\n}\nvoid phongShadeRay(inout Ray ray) {\n        vec3 normal = -sceneGrad(ray.m_point);\n\n        vec3 reflected = reflect(ray.m_direction, normal);\n        float frensel = abs(dot(ray.m_direction, normal));\n        //oh god blackle clean this up\n        ray.m_color += backlight(reflected,ray.m_lag)*0.8* (1.0 - frensel*0.98)*ray.m_attenuation;\n      \n            // ray.m_attenuation*=0.0;\n        \n        // if (normal.z < -0.99 && sin(ray.m_point.y*60.0)>0.8 && ray.m_point.x<-0.6+(sin(ray.m_point.y*60.0/5.0)>0.5?0.1:0.0)) {\n        //     ray.m_attenuation*=0.0;\n        // }\n}\n\nvoid transmitRay(inout Ray ray) {\n\tfloat ior = 1.4;\n    float sgn = sign(scene(ray.m_origin));\n    vec3 normal = -sgn*sceneGrad(ray.m_point);\n    //float frensel = clamp(abs(dot(ray.m_direction, normal))+0.5, 0.0,1.0); //this equation is bullshit\n    ray.m_point -= normal*0.0005;\n    \n    ray.m_direction = refract(ray.m_direction, normal, sgn>0.0?1.0/ior:ior);\n    float frensel = abs(dot(ray.m_direction, normal));\n    ray.m_attenuation *= exp(-length(ray.m_point-ray.m_origin)*0.01)/exp(0.0);\n\n    ray.m_origin=ray.m_point;\n}\n\nvoid recursivelyRender(inout Ray ray) {\n    for (int i = 0; i < MAXDEPTH; i++) {\n        if (castRay(ray)) {\n            phongShadeRay(ray);\n            transmitRay(ray);\n        } else {\n            ray.m_color += (i==0?pow(1.0-polarized,2.0):1.0)*backlight(ray.m_direction, ray.m_lag)*ray.m_attenuation;\n\t\t\treturn;\n        }\n    }\n}\n\nvec2 Nth_weyl(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\n#define SAMPLES 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpolarized = sqrt(smoothstep(0.0, 1.0,iTime-10.0));\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv_base = (fragCoord/iResolution.xy)*2.0 - vec2(1.0,1.0);\n    uv_base.y *= iResolution.y/iResolution.x;\n    float pixelsize = 1.0/iResolution.x*2.5;\n\n\tvec3 cameraOrigin = vec3(4.0*sin(iTime*0.25), 4.0*cos(iTime*0.25), 5.0*abs(sin(iTime*0.1)))*4.0;\n\tvec3 focusOrigin = vec3(0.0, 0.0, 0.3);\n\tvec3 cameraDirection = normalize(focusOrigin-cameraOrigin);\n\n\tvec3 up = vec3(0.0,0.0,-1.0);\n\tvec3 plateXAxis = normalize(cross(cameraDirection, up));\n\tvec3 plateYAxis = normalize(cross(cameraDirection, plateXAxis));\n\n\tfloat fov = radians(40.0);\n\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < SAMPLES;i++){\n   \t\tvec2 uv = uv_base + Nth_weyl(i)*pixelsize;\n\t\tvec3 platePoint = (plateXAxis * -uv.x + plateYAxis * uv.y) * tan(fov /2.0);\n\n   \t\tRay ray = Ray(cameraOrigin, normalize(platePoint + cameraDirection), cameraOrigin, vec3(0.0), 1.0, 0.0);\n    \trecursivelyRender(ray);\n    \tcol+= ray.m_color/float(SAMPLES);\n    }\n\n    col *= pow(max(1.0 - pow(length(uv_base)*0.7, 4.0), 0.0),3.0); \n    \n    fragColor = vec4(sqrt(log(max(col+vec3(0.01,0.01,0.02),0.0)*.7+1.0))*0.9, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2SzG.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[230, 243, 261, 261, 351], [477, 477, 516, 516, 635], [637, 637, 677, 677, 723], [725, 725, 750, 750, 1071], [1072, 1072, 1097, 1097, 1420], [1422, 1422, 1478, 1478, 1538], [1540, 1540, 1570, 1570, 1654], [1656, 1656, 1677, 1677, 2161], [2163, 2163, 2190, 2190, 2236], [2238, 2238, 2260, 2260, 3228], [3229, 3229, 3257, 3257, 3463], [3465, 3465, 3494, 3533, 4043], [4046, 4046, 4083, 4083, 4252], [4253, 4253, 4288, 4288, 4831], [4833, 4833, 4866, 4866, 5362], [5364, 5364, 5403, 5403, 5698], [5700, 5700, 5722, 5722, 5781], [5802, 5802, 5859, 5859, 7046]]}
{"id": "wsS3z3", "name": "RYMRCH WKSP - 3D Sphere Shadows", "author": "trevortheblack", "description": "The 3D section of Electric Square's raymarching workshop\nhttps://github.com/ajweeks/RaymarchingWorkshop\n\n", "tags": ["raymarching"], "likes": 2, "viewed": 70, "published": "Public", "date": "1559756199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TREVOR BLACK\n// LICENSE - There Ain't One\n// This is my take on the 2D raymarching from the RaymarchingWorkshop\n\n\n// Companion shader for Raymarching Workshop run at Electric Square\n// Workshop site: https://github.com/ajweeks/RaymarchingWorkshop\n\n// MIT license\n\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define SHADOW_FALLOFF 0.1\n\n// -------------------------\n// SDF FUNCTION DECLARATIONS\nfloat sdSphere   (vec3 p, float s);\nfloat sdBox      (vec3 p, vec3 b);\nfloat sdPlane    (vec3 p, vec4 n);\nfloat sdCylinder (vec3 p, vec3 c);\nfloat sdTorus    (vec3 p, vec2 t);\nfloat sdRoundBox (vec3 p, vec3 b, float r);\n\n// -------------------------\n// SDF UTILITY DECLARATIONS\nfloat opU(float d1, float d2);\nfloat opBlend(float d1, float d2);\n\n// --------------\n// NOISE AND RAND\nfloat rand(vec2 co);\nfloat goldNoise(in vec2 co, in float seed);\n\n\n// --------------------------\n// MAIN FUNCTION DECLARATIONS\nfloat sdf(vec3 pos);\nvec2 normalizeScreenCoords(vec2 screenCoord);\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget);\nvec3 render(vec3 camPos, vec3 rayDir);\nvec3 calcNormal(vec3 pos);\n\n// compute pixel colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(0.0, 0.0, -1.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);\n    \n    vec3 col = render(camPos, rayDir);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\nvec2 normalizeScreenCoords(vec2 screenCoords)\n{\n    vec2 result = 2.0 * (screenCoords/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    \n    float fPersp = 2.0;\n    vec3 vDir = normalize((uv.x * camRight) + (uv.y * camUp) + (camForward * fPersp));\n    return vDir;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float res = sdf(rayOrigin + rayDir * t);\n        if(res < (0.0001*t))\n            return t;\n        t += res;\n    }\n    return -1.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col;\n    float t = castRay(rayOrigin, rayDir);\n    \n    vec3 L = normalize(vec3(sin(iTime)*1.0, cos(iTime*0.5)+0.5, -0.5));\n    \n    if (t == -1.0)\n    {\n        // Skybox color\n        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.4);\n    }\n    else\n    {\n        vec3 pos = rayOrigin + t*rayDir;\n        vec3 N = calcNormal(pos);\n        \n        vec3 objectSurfaceColor = vec3(0.4, 0.8, 0.1);\n        float NDotL = max(dot(N,L), 0.0);\n        vec3 LDir = vec3(1.80, 1.27, 0.99) * NDotL;\n        vec3 LAmb = vec3(0.03, 0.04, 0.1);\n        vec3 diffuse = objectSurfaceColor * (LDir + LAmb);\n        \n        col = diffuse;\n        \n        \n        // Add shadows\n        \n        // HARD SHADOWS\n        float shadow = 0.0;\n        vec3 shadowRayOrigin = pos + N * 0.01;\n        vec3 shadowRayDir = L;\n        float shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n        if(shadowRayIntersection != -1.0)\n            shadow = 1.0;\n        \n        col = mix(col, col*0.2, shadow);\n        \n        /* SOFT SHADOWS\n        float shadowRayCount = 128.0;        \n        float shadow = 0.0;\n        for(float s = 0.0; s < shadowRayCount; s++)\n        {\n            vec3 shadowRayOrigin = pos + N * 0.01;\n            float rX = goldNoise(vec2(rayDir.xy), 0.0) * 2.0 - 1.0;\n            float rY = goldNoise(vec2(rayDir.xy), 1.0) * 2.0 - 1.0;\n            float rZ = goldNoise(vec2(rayDir.xy), 2.0) * 2.0 - 1.0;\n            vec3 shadowRayDir = L + SHADOW_FALLOFF * vec3(rX, rY, rZ);\n            float shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n            if(shadowRayIntersection != -1.0)\n                shadow += 1.0;\n        }\n        \n        col = mix(col, col*0.2, shadow/shadowRayCount);\n        */     \n\n        // Gamma Correction\n        col = pow(col, vec3(0.4545));\n    }\n    \n    return col;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = sdf(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(sdf(pos + eps_zero.xyy),\n        sdf(pos + eps_zero.yxy), sdf(pos + eps_zero.yyx)) - c);\n}\n\n\n// SDF \nfloat sdf(vec3 pos)\n{\n    float t = sdSphere(pos - vec3(0.0, 0.0, 10.0), 3.0);\n    return t;\n}\n\n\n// -------------------------\n// SDF FUNCTION DEFINITIONS\n// -------------------------\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;   \n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y,d.z)), 0.0);\n}\n\nfloat sdPlane    (vec3 p, vec4 n)\n{ // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCylinder (vec3 p, vec3 c)\n{\n    return length(p.xz-c.xy) - c.z;\n}\n\nfloat sdTorus    (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdRoundBox (vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - r +\n        min(max(d.x, max(d.y,d.z)), 0.0);                 \n}\n\n// -------------------------\n// SDF Utility Library\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    float k = 0.2;\n    return sminCubic(d1, d2, k);\n}\n// --------------------------\n\n// -------------------------\n// NOISE and RAND\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat goldNoise(in vec2 co, in float seed)\n{\n    return fract(tan(distance(co*(seed+PHI), vec2(PHI,PI)))*SQ2);\n}\n\n// --------------------------\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3z3.jpg", "access": "shaders20k", "license": "mit", "functions": [[1145, 1169, 1226, 1226, 1502], [1505, 1505, 1552, 1552, 1679], [1681, 1681, 1741, 1741, 2055], [2057, 2057, 2101, 2101, 2301], [2303, 2303, 2345, 2345, 4194], [4196, 4196, 4223, 4244, 4478], [4481, 4489, 4510, 4510, 4583], [4586, 4672, 4705, 4705, 4733], [4735, 4735, 4764, 4764, 4867], [4869, 4869, 4904, 4928, 4962], [4964, 4964, 4999, 4999, 5037], [5039, 5039, 5074, 5074, 5148], [5150, 5150, 5194, 5194, 5317], [5372, 5408, 5452, 5452, 5530], [5532, 5532, 5563, 5563, 5589], [5591, 5591, 5626, 5626, 5680], [5712, 5759, 5780, 5780, 5857], [5908, 6054, 6098, 6098, 6166]]}
{"id": "Wt23D3", "name": "Plasma Cube", "author": "adelciotto", "description": "A retro plasma cube'\n\nSet the RETRO_MODE variable to 0 to disable pixelated effect.", "tags": ["raymarch", "retro", "cube", "plasma"], "likes": 3, "viewed": 542, "published": "Public API", "date": "1561377336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plasma Cube by adelciotto\n// References:\n// - https://github.com/ajweeks/RaymarchingWorkshop\n// - https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm \n\n#define RETRO_MODE 1\n\nconst float RETRO_PIXEL_SIZE = 4.0; \nconst float PI = 3.1415926535; \nconst float MIN_DIST = 0.0; \nconst float MAX_DIST = 100.0; \nconst float EPSILON = 0.001; \nconst float GAMMA_CORRECTION = 0.4545; \nconst int MAX_MARCHING_STEPS = 63; \n\nfloat t = 0.0; \n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, - s, c);\n}\n\nfloat cubeSDF(vec3 p) {\n    p.xz *= rotate(t);\n    p.yx *= rotate(t * 0.6);\n    p.zx *= rotate(t * 0.4);\n    p.y += sin(t * 0.2);\n    vec3 d = abs(p) - vec3(1.0);\n    float dist = length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n    return dist - 0.1;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(\n        vec3(\n            cubeSDF(vec3(p.x + EPSILON, p.yz)) - cubeSDF(vec3(p.x - EPSILON, p.yz)),\n            cubeSDF(vec3(p.x, p.y + EPSILON, p.z)) - cubeSDF(vec3(p.x, p.y - EPSILON, p.z)),\n            cubeSDF(vec3(p.xy, p.z + EPSILON)) - cubeSDF(vec3(p.xy, p.z - EPSILON))\n        )\n    );\n}\n\n// modified plasma effect from https://www.bidouille.org/prog/plasma\nvec3 plasma(vec3 p, float scale) {\n    p *= scale;\n    \n    float time = t * 0.3;\n    float v1 = sin(p.x + time);\n    float v2 = sin(p.y + time);\n    float v3 = sin(p.z + time);\n    float v4 = sin(p.x + p.y + p.z + time);\n    float v5 = sin(length(p) + 1.7 * time);\n    float v = v1 + v2 + v3 + v4 + v5;\n    \n    v *= 2.0;\n    vec3 col = vec3(sin(v * PI), sin(v * PI + 2.0 * PI / 3.0), sin(v * PI + 4.0 * PI / 3.0));\n    return col * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragCoord = gl_FragCoord.xy;\n    #if RETRO_MODE\n    fragCoord = ceil(fragCoord / RETRO_PIXEL_SIZE) * RETRO_PIXEL_SIZE;\n    #endif\n    vec2 uv = vec2(fragCoord - 0.5 * iResolution.xy);\n    uv = 2.0 * uv.xy / iResolution.y;\n    \n    t = iTime + 0.33 * sin(uv.x * 1.76 + uv.y + iTime);\n    \n    vec3 camPos = vec3(0, 0, - 6);\n    vec3 at = vec3(0, 0, 0);\n    vec3 camForward = normalize(at - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    vec3 rayDir = normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n    \n    float depth = MIN_DIST;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < MAX_MARCHING_STEPS; i ++ ) {\n        vec3 p = camPos + depth * rayDir;\n        float dist = cubeSDF(p);\n        if (dist < EPSILON) {\n            vec3 light = normalize(vec3(sin(t) * 1.0, cos(t * 0.5) + 0.5, - 0.5));\n            vec3 norm = estimateNormal(p);\n            vec3 directional = vec3(1.80, 1.27, 0.99) * max(dot(norm, light), 0.0);\n            vec3 ambient = vec3(0.02, 0.02, 0.02);\n            vec3 diffuse = plasma(p, 1.0) * (directional + ambient);\n            col = diffuse;\n            break;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            break;\n        }\n    }\n    \n    col = pow(col, vec3(GAMMA_CORRECTION));\n    fragColor = vec4(smoothstep(0.0, 1.0, col), 1.0);\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt23D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 450, 476, 476, 561], [563, 563, 586, 586, 824], [826, 826, 855, 855, 1172], [1174, 1243, 1277, 1277, 1689], [1691, 1691, 1748, 1748, 3157]]}
{"id": "Wt23Rt", "name": "MetaShader", "author": "gabrielmuller", "description": "this is what the fragments do when you're not looking", "tags": ["generator"], "likes": 1, "viewed": 235, "published": "Public", "date": "1560916805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831853\n#define VIDEO false\nfloat wave(float x, float freq, float phase) {\n    return (sin(x * freq + phase) + 1.) * 0.5;\n}\n\nfloat rand(inout float seed) {\n    seed += wave(seed, 1., 12.) * 0.6;\n    return fract(sin(seed)*1000000.);\n}\n\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nfloat choose(vec3 v, inout float seed) {\n    return v[int(mod(seed++, 3.))];\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n        (c - a)* u.y * (1.0 - u.x) +\n        (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 omni(vec3 v, inout float seed) {\n    float p = rand(seed);\n    vec3 res = v;\n    for (int i = 0; i < 3; i++) {\n        if (p < 0.15) {\n            vec2 tmp = vec2(choose(v, seed), choose(v, seed));\n            tmp = rotate2d((choose(v, seed)+1.) * TAU) * tmp;\n            res[i] = wave(tmp.x, tmp.y*5.+0.6, choose(v, seed));\n        } else if (p < 0.2) {\n            res[i] = pow(choose(v, seed), choose(v, seed)+0.2);\n        } else if (p < 0.3) {\n            float s = choose(v, seed) + choose(v, seed);\n            res[i] = mix(choose(v, seed), rand(s), choose(v, seed)*0.03);\n        } else if (p < 0.35) {\n            res[i] = length(vec2(choose(v, seed), choose(v, seed))) / 1.4;\n        } else if (p < 0.40) {\n            res[i] = pow(min(choose(v, seed), choose(v, seed)), 0.8);\n        } else if (p < 0.48) {\n            res[i] = noise(vec2(choose(v, seed), choose(v, seed)));\n        } else if (p < 0.50) {\n            res[i] = 1. - choose(v, seed);\n        } else if (p < 0.55) {\n            res[i] = choose(v, seed);\n        } else if (p < 0.65) {\n            res[i] = pow(max(smoothstep(choose(v, seed), choose(v, seed), choose(v, seed)), choose(v, seed)), 2.);\n        } else if (p < 0.75) {\n            float r = rand(seed) + 0.5;\n            res[i] = pow(abs(choose(v, seed) - r + choose(v, seed)*r), 0.5);\n        } else if (p < 0.85) {\n            float modulus = choose(v, seed);\n            res[i] = mod(choose(v, seed), modulus) + modulus/2.;\n        } else {\n        \tres[i] = fbm(vec2(choose(v, seed), choose(v, seed)) * 30. * pow(choose(v, seed), 3.));\n        }\n    }\n    res = vec3(rotate2d(choose(v, seed)) * res.xy, res.z);\n\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/vec2(min(iResolution.x, iResolution.y));\n    float size = pow(wave(iTime, 0.3, -2.4) + 1., pow(wave(iTime, 0.08, 0.), 2.)*6.5) + 1.;\n    float seed;\n    vec2 cam = (vec2(wave(iTime, 0.02, 0.), wave(iTime, 0.0111, 0.5)));\n    cam = (cam * iResolution.xy + iMouse.xy) * 0.1;\n    vec2 pos = (uv*size + cam);\n    float border = 0.1 + size * 0.005;\n    float brightness = 1.0;\n    if (size < 100. && (fract(pos.x) < border || fract(pos.y) < border)) {\n        seed = floor(iTime);\n        pos = fract(pos * 0.01);\n    } else {\n    \tseed = floor(pos.x)*1.00180820 + floor(pos.y)*1000.58765 + iDate.z*101.;\n        pos = fract(pos);\n\n    }\n    vec3 warped;\n    float timeNoise = noise(vec2(iTime*rand(seed)*2.));\n    if (VIDEO) {\n        warped = vec3(texture(iChannel0, pos).xz, timeNoise);\n    } else {\n        pos = rotate2d(rand(seed)) * pos * 0.7;\n        warped = vec3(pos, timeNoise);\n    }\n    int iters = int(pow(rand(seed), 2.) * 3. + 2.);\n    for (int i = 0; i < iters; i++) {\n    \twarped = omni(warped, seed);\n    }\n    float interval = pow(rand(seed), 5.);\n\n    fragColor = vec4(hsb2rgb(vec3(\n        fract(rand(seed) + warped.x * interval),\n        pow(warped.y, 0.8),\n        pow(warped.z, 0.4))\n    ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt23Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 88, 88, 137], [139, 139, 169, 169, 248], [250, 250, 275, 275, 347], [349, 349, 377, 377, 463], [466, 466, 506, 506, 544], [546, 546, 572, 572, 900], [920, 920, 944, 966, 1220], [1222, 1222, 1248, 1248, 1480], [1482, 1482, 1519, 1519, 3154], [3157, 3157, 3214, 3214, 4457]]}
{"id": "wt23WV", "name": "nova 2019 live coding round 2", "author": "lovelyH", "description": "It's shader that I wrote on livecoding on nova 2019.\nI replace parts specific for bonzomatic and make it work on shader toy.\nI left most of orginal code commented out.\nTunel is default effect in bonzomatic. I just left it during livecoding.", "tags": ["livecoding", "nova", "demoparty", "2019"], "likes": 5, "viewed": 383, "published": "Public", "date": "1561237954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define E 0.001\n#define INF 1000.0\n#define ROUND_TIME 12.0\n#define time iTime\nfloat rtime;\nint roundId;\n\nvec2 rot(vec2 p, float l){\n\tfloat s=sin(l), c=cos(l);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y );\n}\n\n\nint rand( int seed ){\n\tint s= roundId*12 + seed;\n\t//return (s*(34*s+1))%7;\n    return int(mod(float(s*(34*s+1)),7.));\n}\n\n\nvec3 tball(vec3 p){\n\t\n\tfloat t= 12.0* (rtime - 2.0);\n\t\n\tfor( int a=0;a<0x10;a++){\n\t\tint ra= rand(a);\n\t\t//switch(ra){\n\t\t \t//case 0: \n        \tif( ra==0 ){\n            \tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) ); \n            }\n            //break;\n\t\t\t//case 1: \n        \telse if( ra==1 ){\n\t\t\t\tif( p.x < 2.0 ){\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t}\n            }\n\t\t\t//break;\n\t\t\t//case 2: \n    \t\telse if(ra==2){\n\t\t\t\tif( -2.0 < p.x ){\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t}\n    \t\t}\n\t\t\t//break;\n\t\t \t//case 3:\n        \telse if( ra==3 ){\n    \t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n            }\n    \t\t//break;\n\t\t\t//case 4: \n        \telse if(ra==4){\n\t\t\t\tif( p.x < 2.0 ){\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t}\n            }\n\t\t\t//break;\n\t\t\t//case 5: \n        \telse {\n\t\t\t\tif( -2.0 < p.x ){\n\t\t\t\t\tp.x -= 2.0;\n\t\t\t\t\tp.xz= rot( p.xz, -clamp(t,0.0,3.141592653589) );\n\t\t\t\t\tp.x += 2.0;\n\t\t\t\t}\n\t\t\t//break;\n            }\n\t\t//}\n\t\tt -= 3.141592653589;\n\t}\n\t\n\t//p.z += (rtime);\n\t\n\treturn p;\n}\n\nfloat mball(vec3 p){\n\t\n\tp.z= abs(p.z);\n\t\n\tfloat h= max( 0.0, max( 2.0 - rtime, rtime - ROUND_TIME + 2.0 ) );\n\t\n\tp.z -= h;\n\t\n\treturn max( length(p)-.5, -p.z );\n}\n\n\n\nfloat map(vec3 p){\n\tfloat r=INF, rc;\n\t\n\tr= min( r, length(p-tball(vec3(0,0,0)))-.2 );\n\t\n\tr= min( r, mball(p-tball(vec3( 0,0,0))) );\n\tr= min( r, mball(p-tball(vec3( 4,0,0))) );\n\tr= min( r, mball(p-tball(vec3(-4,0,0))) );\n\t\n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p;\n\tfloat t=0.0, dis;\n\tbool hit= false;\n\tfor(int a=0;a<0x100;a++){\n\t\tp = sp + t * dir;\n\t\tdis= map(p);\n\t\tif ( dis < E ){\n\t\t\thit= true;\n\t\t\tbreak;\n\t\t}\n\t\tt += dis;\n\t}\n\t\n\tif( hit ){\n\t\t\n\t\tvec3 n= normalize(vec3(\n\t\t\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t));\n\t\t\n\t\treturn vec3(1);\n\t}else{\n\t\treturn vec3(0);\n\t}\n}\n\n\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\trtime= mod( time, ROUND_TIME );\n\troundId= int( floor( time / ROUND_TIME ) );\n\n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1. / length(uv) * .2;\n  float d = m.y;\n\n  \t//float f = texture( texFFT, d ).r * 100;\n    float f= 0.0;\n  //m.x += sin( fGlobalTime ) * 0.1;\n    m.x += sin( time ) * 0.1;\n  //m.y += fGlobalTime * 0.25;\n    m.y += time * 0.25;\n\n  //vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n    vec4 t = plas( m * 3.14, time ) / d;\n  t = clamp( t, 0.0, 1.0 );\n  out_color = f + t;\n\t\n\tif( map(12.0*vec3(uv.x,0.0,uv.y)) < 0.0 ){\n\t\tout_color= vec4(1);\n\t}\n\t\n\tif( rtime < abs(uv.y) || ROUND_TIME - rtime - 1.0 < abs(uv.y) ){\n\t\tout_color= vec4(0);\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt23WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 131, 131, 210], [213, 213, 234, 234, 332], [335, 335, 354, 354, 1483], [1485, 1485, 1505, 1505, 1645], [1649, 1649, 1667, 1667, 1883], [1887, 1887, 1920, 1920, 2351], [2355, 2355, 2388, 2388, 2553], [2555, 2555, 2612, 2612, 3410]]}
{"id": "wt2GDd", "name": "Commodore 64 plasma", "author": "klk", "description": "Living with color limitations of Commodore 64", "tags": ["retro", "plasma", "commodore", "8x8"], "likes": 3, "viewed": 519, "published": "Public API", "date": "1561647399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\n\nfloat3 pal(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(  1.0,   1.0,   1.0);\n    else if (c ==  2)col = float3(103.7,  55.4,  43.0)/255.0;\n    else if (c ==  3)col = float3(111.9, 163.5, 177.9)/255.0;\n    else if (c ==  4)col = float3(111.4,  60.7, 133.6)/255.0;\n    else if (c ==  5)col = float3( 88.1, 140.6,  67.1)/255.0;\n    else if (c ==  6)col = float3( 52.8,  40.3, 121.4)/255.0;\n    else if (c ==  7)col = float3(183.9, 198.7, 110.6)/255.0;\n    else if (c ==  8)col = float3(111.4,  79.2,  37.2)/255.0;\n    else if (c ==  9)col = float3( 66.9,  57.4,   0.0)/255.0;\n    else if (c == 10)col = float3(153.7, 102.6,  89.1)/255.0;\n    else if (c == 11)col = float3( 67.9,  67.9,  67.9)/255.0;\n    else if (c == 12)col = float3(107.8, 107.8, 107.8)/255.0;\n    else if (c == 13)col = float3(154.2, 209.8, 131.6)/255.0;\n    else if (c == 14)col = float3(107.8,  94.1, 180.9)/255.0;\n    else             col = float3(149.5, 149.5, 149.5)/255.0;\n    return col;\n}\n\nstruct NC\n{\n    int i0;\n    int i1;\n    int w;\n};\n\n\nNC near(float3 col)\n{\n    const float3 W=float3(0.299,0.587,0.114);\n    NC res;\n    float rv=100.0;\n    float luma0=dot(col,W);\n    for(int i=0;i<15;i++)\n    {\n        for(int j=i+1;j<16;j++)\n        {\n            for(int f=0;f<4;f++)\n            {\n                float3 icol=mix(pal(i),pal(j),float(f)*.25);\n                float3 dist=(col-icol);\n                dist*=W;\n\n                float d=length(dist*dist);\n                if(d<rv)\n                {\n                    res=NC(i,j,f);\n                    rv=d;\n                }\n            }\n        }\n    }\n    return res;\n}\n\n\nvec3 col(int x, int y)\n{\n\tfloat time=iTime;\n\tvec2 uv = vec2(float(x), float(y))/160.0;\n    vec2 uv0=uv;\n\tfloat i0=1.1;\n\tfloat i1=0.9;\n\tfloat i2=0.5;\n\tfloat i3=0.6;\n\tfloat i4=0.0;\n    float r=0.0;\n    float g=0.0;\n    float b=0.0;\n    float w=0.0;\n\tfor(int s=0;s<4;s++)\n\t{\n\t\tvec2 d;\n\t\td=vec2(cos(uv.y*i0-i4+time/i1),-sin(uv.x*i0-i4+time/i1))/i3;\n        d+=vec2(-d.y,d.x)*0.7;\n\t\tuv.xy+=d;\n        \n\t\ti0=(i0-0.2)*1.1;\n\t\ti1=(i1-2.0)*1.05;\n\t\ti2=(i2-1.51)*1.06;\n\t\ti3*=0.8237;\n\t\ti4+=0.05;\n\t    r+=(sin(uv.x-time)*0.75+0.5)/i2;\n\t    b+=(sin(uv.y+time)*0.75+0.5)/i2;\n\t    g+=(sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.75+0.5)/i2;\n        w+=1.0/i2;\n\t}\n    r/=w;\n    g/=w;\n    b/=w;\n\treturn vec3(r,g,b);\n}\n\nfloat4 border(int y)\n{\n    return float4(pal(int(float(y)+iTime*90.+sin(iTime))/12%16),1);\n}\n\nint ilen(int x, int y)\n{\n    return x*x+y*y;\n}\n\n\nvoid mainImage(out vec4 o, in vec2 fc )\n{\n    int sc=int(iResolution.y/200.);\n    \n    int ix=int(fc.x)/sc;\n    int iy=int(fc.y)/sc;\n    \n    int bx=int(iResolution.x)/sc-320;\n    int by=int(iResolution.y)/sc-200;\n    \n    o=border(iy);\n    if(!((ix<=bx/2)||(ix>=320+bx/2)))\n    {\n        ix-=bx/2;\n\n        if(!((iy<=by/2)||(iy>=200+by/2)))\n        {\n            iy-=by/2;\n\n            int x0=(ix/8)*8;\n            int y0=(iy/8)*8;\n\n            int fx=ix-x0;\n            int fy=iy-y0;\n\n            NC nc=near(col(x0+4, y0+4));\n\n            o = vec4(pal(nc.i0),1.0);\n            if(iMouse.z>0.)\n            {\n                switch(nc.w)\n                {\n                    case 1:if((fx%2+fy%2)==2)o = vec4(pal(nc.i1),1.0);break;\n                    case 2:if((fx+fy)%2==0)o = vec4(pal(nc.i1),1.0);break;\n                    case 3:if((fx%2+fy%2)<2)o = vec4(pal(nc.i1),1.0);break;\n                }\n            }\n            else\n            {\n                switch(nc.w)\n                {\n                    case 1:if(ilen(fx-3,fy-3)<2)o = vec4(pal(nc.i1),1.0);break;\n                    case 2:if(ilen(fx-3,fy-3)<6)o = vec4(pal(nc.i1),1.0);break;\n                    case 3:if(ilen(fx-3,fy-3)>=2)o = vec4(pal(nc.i1),1.0);break;\n                }\n            }\n        }\n    }\n    if(sc>1)\n    {\n        o*=1.0-abs(fract(fc.y/float(sc))-0.65);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 81, 81, 1125], [1179, 1179, 1200, 1200, 1767], [1770, 1770, 1794, 1794, 2461], [2463, 2463, 2485, 2485, 2555], [2557, 2557, 2581, 2581, 2603], [2606, 2606, 2647, 2647, 3963]]}
{"id": "wt2GDh", "name": "a19", "author": "fnorbi19", "description": "a1", "tags": ["a1"], "likes": 8, "viewed": 432, "published": "Public API", "date": "1559407837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float Amplitude = 0.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 0.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\tcolor += doLine(fragPos, RADIUS, fragPos.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 163, 184, 184, 353], [355, 355, 379, 379, 429], [431, 431, 460, 460, 553], [555, 555, 591, 591, 802], [804, 804, 839, 839, 903], [905, 905, 947, 947, 1414], [1416, 1416, 1467, 1467, 1719], [1722, 1722, 1779, 1779, 2110]]}
{"id": "wt2GDt", "name": "walking raymarching by suraimu", "author": "suraimu752", "description": "walking raymarching by suraimu752", "tags": ["raymarching"], "likes": 2, "viewed": 94, "published": "Public", "date": "1561612663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 lightDirection = vec3(1., 1., -.7);\n\nvec3 trans(vec3 p){\n    return mod(p, 4.) - 2.;\n}\n\nfloat dfPlane(vec3 p){\n    return p.y + 0.5;\n}\n\nfloat dfSphere(vec3 p){\n    return length(trans(p)) - .7;\n}\n\nfloat distanceFunc(vec3 p){\n    return dfSphere(p);\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)) - distanceFunc(p + vec3( -d, 0.0, 0.0)),\n        distanceFunc(p + vec3(0.0,   d, 0.0)) - distanceFunc(p + vec3(0.0,  -d, 0.0)),\n        distanceFunc(p + vec3(0.0, 0.0,   d)) - distanceFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nmat3 kaiten(float frec){\n    float r = 2. * frec * 3.14159265358979;\n    return mat3(\n        cos(r),  0., sin(r),\n            0.,  1.,     0.,\n        -sin(r), 0., cos(r)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cameraPos = vec3(0., sin(iTime * 0.5) * 3., -5. + iTime);\n    float screenZ = 2.5;\n    vec3 rayDirection = normalize(vec3(p, screenZ)) * kaiten(iTime*0.025);\n\n    vec3 col = vec3(0.);\n\n    float depth = 0.0;\n    for(int i = 0; i < 499; i++){\n        vec3 rayPos = cameraPos + rayDirection * depth;\n        float dist = distanceFunc(rayPos);\n        depth += dist;\n\n        if(dist < 0.0001){\n            col = vec3(1.) * clamp(dot(getNormal(rayPos), lightDirection), 0.2, 1.0);\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 62, 92], [94, 94, 116, 116, 140], [142, 142, 165, 165, 201], [203, 203, 230, 230, 256], [258, 258, 281, 281, 600], [602, 602, 626, 626, 782], [784, 784, 841, 891, 1557]]}
{"id": "Wt2GRG", "name": "Cubic Dance", "author": "MadEqua", "description": "Entry for the June 2019 ShaderToy compo from Graphics Programming Discord. ", "tags": ["cubes", "repetition", "rainbow"], "likes": 12, "viewed": 1294, "published": "Public API", "date": "1560002081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PRIMARY_STEPS 32\n#define SECONDARY_STEPS 16\n\n#define RM_EPSILON 0.01\n#define BIAS_EPSILON 0.02\n\n#define MAX_DIST 30.\n\n#define REFLECTIONS 1\n#define SHADOWS 1\n\nstruct Light {\n    vec3 dir;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nstruct ScenePoint {\n    vec3 p;\n    vec3 color; //Color of material\n    float d; //Distance to closest object\n    float t; //Distance on ray that generated this point\n};\n\nLight lights[4];\n\nfloat rand(float v) {\n    return fract(sin(v) * 5454.7367);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 4451.5453);\n}\n\nvec3 cam2world(vec3 v, vec3 pos, vec3 lookAt) {\n    vec3 z = normalize(lookAt - pos);\n    vec3 y = vec3(0., 1., 0.);\n    vec3 x = normalize(cross(z, y));\n    y = normalize(cross(x, z));\n    return normalize(mat3(x, y, z) * v);\n}\n\nvec2 repeat(inout vec2 p, vec2 size) {\n\tvec2 h = size * .5;\n\tvec2 cell = floor((p + h) / size);\n\tp = mod(p + h, size) - h;\n\treturn cell;\n}\n\nfloat roundBox(vec3 p, vec3 c, vec3 b, float r) {\n    vec3 d = abs(p - c) - b;\n    return length(max(d, 0.)) - r + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\n// All components are in the range [0â¦1], including hue.\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nfloat stoppingCurve(float t, float stopFactor) {\n  return mix(rand(floor(t)), rand(floor(t) + 1.), pow(smoothstep(0., 1., fract(t)), stopFactor));\n}\n\nScenePoint scene(vec3 p, int neighboursToCheck) {\n    ScenePoint result;\n\n    float dist = MAX_DIST;\n    vec2 cellId;\n    vec3 repP;\n\n    for(int x = -neighboursToCheck; x <= neighboursToCheck; ++x) {\n        for(int y = -neighboursToCheck; y <= neighboursToCheck; ++y) {\n            vec3 currentRepP = p;\n            vec2 currentCellId = repeat(currentRepP.xy, vec2(1.));\n\n            vec2 offset = vec2(float(x), float(y));\n            currentCellId += offset;\n\n            currentRepP.xy -= offset; // * cellSize = 1.0\n\n            float timeOffset1 = mod(currentCellId.x * currentCellId.y, 2.0);\n            float timeOffset2 = mod(currentCellId.x + currentCellId.y, 2.0);\n            float timeOffset3 = mod(currentCellId.x, 2.0);\n            float timeOffset4 = mod(currentCellId.y, 2.0);\n            float timeOffsetFinal = mix(mix(timeOffset1, timeOffset2, sin(iTime * .4 + 56.2) * .5 + .5),\n                                        mix(timeOffset3, timeOffset4, sin(iTime * .5 + 12.5) * .5 + .5),\n                                        sin(iTime * .6 + 23.4) * .5 + .5);\n\n            currentRepP.z += stoppingCurve(1.7 * iTime + timeOffsetFinal, 5.) * 2.5;\n\n            const float minSize = .31;\n            const float maxSize = .43;\n            float sizeAnim = stoppingCurve(0.9 * iTime + timeOffsetFinal, 5.) * (maxSize - minSize) + minSize;\n            float currentCubeDist = roundBox(currentRepP, vec3(0.), vec3(sizeAnim), .07);\n            if(currentCubeDist < dist) {\n                dist = currentCubeDist;\n                cellId = currentCellId;\n                repP = currentRepP;\n            }\n        }\n    }\n\n    float wallX = (-cellId.x + 6.) / 13.;\n    float cubeDiagonal = (repP.x + .5) * (repP.y + .5);\n\n    vec3 cubeBaseHsv = vec3(wallX, 1., 1.);\n    cubeBaseHsv.r += .1 * rand(cellId.y);\n\n    vec3 cubeColor1 = hsv2rgb(cubeBaseHsv);\n    vec3 cubeColor2 = hsv2rgb(vec3(cubeBaseHsv.r + .2 * rand(cellId.x), cubeBaseHsv.g, cubeBaseHsv.b));\n\n    result.color = mix(cubeColor1, cubeColor2, cubeDiagonal);\n    result.d = dist;\n    return result;\n}\n\nbool rm(vec3 ro, vec3 rd, out ScenePoint sp, int steps, int neighboursToCheck) {\n    float t = 0.;\n    vec3 p;\n\n    for(int i = 0; i < steps && t < MAX_DIST; ++i) {\n        p = ro + rd * t;\n        sp = scene(p, neighboursToCheck);\n        if(sp.d < RM_EPSILON) {\n            sp.p = p;\n            sp.t = t;\n            return true;\n        }\n        t += sp.d;\n    }\n    return false;\n}\n\nvec3 normal(ScenePoint sp) {\n    vec2 e = vec2(RM_EPSILON, 0.);\n    float x = scene(sp.p - e.xyy, 1).d;\n    float y = scene(sp.p - e.yxy, 1).d;\n    float z = scene(sp.p - e.yyx, 1).d;\n    return normalize(vec3(sp.d) - vec3(x, y, z));\n}\n\nfloat cheapAo(vec3 p, vec3 n, float dist) {\n    float d = scene(p + n * dist, 1).d / dist;\n    return clamp(d, 0., 1.);\n}\n\n/*float ao(vec3 p, vec3 n, float strength) {\n    const int AO_SAMPLES = 2;\n    float k = 1.;\n    float d = 0.;\n    float occ = 0.;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        d = scene(p + .1 * k * n, 0).d;\n        occ += 1. / pow(2., k) * (k * .1 - d);\n        k += 1.;\n    }\n    return 1. - clamp(strength * occ, 0., 1.);\n}*/\n\nvec3 lighting(vec3 cameraPos, vec3 normal, ScenePoint sp) {\n    vec3 albedo = sp.color;\n    vec3 specular = vec3(1.);\n    float shininess = 100.;\n\n    vec3 V = normalize(cameraPos - sp.p);\n\n    vec3 sum = vec3(0.);\n    for(int i = 0; i < 4; ++i) {\n        vec3 L = -lights[i].dir;\n        vec3 H = normalize(V + L);\n\n        float difFactor = max(0., dot(L, normal));\n        float specFactor = pow(max(0., dot(H, normal)), shininess);\n        sum += lights[i].diffColor * albedo * difFactor +\n               lights[i].specColor * specular * specFactor;\n    }\n    return sum;\n}\n\nvec3 shadeAndReflection(vec3 cameraPos, vec3 rd, ScenePoint sp) {\n    vec3 result;\n\n    vec3 normal = normal(sp);\n    vec3 light = lighting(cameraPos, normal, sp);\n    float ao = cheapAo(sp.p, normal, .15);\n\n    bool hit;\n    result = light * ao;\n    \n#if REFLECTIONS\n    ScenePoint reflectionSp;\n    vec3 reflected = reflect(rd, normal);\n    hit = rm(sp.p + reflected * BIAS_EPSILON, reflected, reflectionSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result = mix(light, lighting(cameraPos, reflected, reflectionSp), .5) * ao;\n    }\n#endif\n    \n#if SHADOWS\n    ScenePoint shadowSp;\n    hit = rm(sp.p + normal * BIAS_EPSILON, -lights[0].dir, shadowSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result *= vec3(.2);\n    }\n#endif\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lights[0].dir = normalize(vec3(0., -.3, -1.));\n    lights[0].diffColor = vec3(1.);\n    lights[0].specColor = vec3(1.);\n\n    lights[1].dir = normalize(vec3(1., 0., 0.));\n    lights[1].diffColor = vec3(.3);\n    lights[1].specColor = vec3(.05);\n\n    lights[2].dir = normalize(vec3(0., 1., 0.));\n    lights[2].diffColor = vec3(.3);\n    lights[2].specColor = vec3(.05);\n\n    lights[3].dir = normalize(vec3(-1., 0., 0.));\n    lights[3].diffColor = vec3(.3);\n    lights[3].specColor = vec3(.05);\n\n    vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    float curve = stoppingCurve(iTime * .5 + 12., 5.);\n    float curve2 = stoppingCurve(iTime * .8 + 195., 50.);\n\n    vec3 cameraPos = vec3(6. * (curve - .5) + iTime, 1.9 * (curve2 + .5), 10.);\n    vec3 lookAt = vec3(iTime, 0., 0.);\n    vec3 rd = cam2world(vec3(uv, 1.), cameraPos, lookAt); \n\n    ScenePoint sp;\n    vec3 col = vec3(.05);\n\n    bool hit = rm(cameraPos, rd, sp, PRIMARY_STEPS, 1);\n    if(hit) {\n        col = shadeAndReflection(cameraPos, rd, sp);\n    }\n\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2GRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 429, 450, 450, 490], [492, 492, 512, 512, 580], [582, 582, 629, 629, 810], [812, 812, 850, 850, 950], [952, 952, 1001, 1001, 1102], [1104, 1163, 1185, 1185, 1345], [1347, 1347, 1395, 1395, 1495], [1497, 1497, 1546, 1546, 3569], [3571, 3571, 3651, 3651, 3958], [3960, 3960, 3988, 3988, 4195], [4197, 4197, 4240, 4240, 4318], [4320, 4655, 4714, 4714, 5232], [5234, 5234, 5299, 5299, 5988], [5990, 5990, 6045, 6045, 7149]]}
{"id": "wt2GWG", "name": "Colored Blob", "author": "badjano", "description": "colored blob", "tags": ["noise", "blob", "fract"], "likes": 9, "viewed": 189, "published": "Public", "date": "1560984538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOD3 vec3(.1031,.11369,.13787)\n#define grad(x) length(vec2(dFdx(x),dFdy(x)))\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat fbm(vec3 p)\n{\n    float r = 0.;\n    float m = 0.5;\n    for (int i=0; i<5;i++){\n        r += perlin_noise(p) * m;\n        p *= 2.;\n        m *= 0.5;\n    }\n    return r;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) - vec2(0.5);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    float d = length(uv);\n    float n = fbm(vec3(uv*0.2,iTime*0.025) * 5.)*0.5 + 0.5;\n    d += n*2.;\n    d = pow(d,5.);\n    float e = d+.5;\n    int m = int(e-.5);\n    e = abs(fract(e)-.5)/grad(e);\n    float h = fbm(vec3(float(m)*13480.09134,1026.7392,7492.1264)+iTime*.1)*3.;\n    fragColor = vec4(hsv2rgb(vec3(h,1.,1.)),1.) * vec4(clamp(e,0.,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 108, 108, 260], [262, 262, 290, 290, 1229], [1231, 1231, 1250, 1250, 1406], [1408, 1408, 1430, 1430, 1593], [1595, 1595, 1652, 1652, 2104]]}
{"id": "wt2GWV", "name": "Oemfoe Freewheeling 1", "author": "oemfoe", "description": "Oemfoe Freewheeling 1", "tags": ["test"], "likes": 0, "viewed": 221, "published": "Public API", "date": "1561229496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.001;\n\n\nmat3 rotY(float r){return mat3(cos(r), 0., sin(r), 0., 1., 0., -sin(r), 0., cos(r));}\nmat3 rotX(float r){return mat3(1., 0., 0., 0., cos(r), sin(r), 0., -sin(r), cos(r));}\nmat3 rotZ(float r){return mat3(cos(r), sin(r), 0., -sin(r), cos(r), 0., 0., 0., 1.);}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat plane(vec3 p){\n    //p = rotY(iTime / 4.) * p;\n    float crazy = abs(p.x/2. - floor(p.x/2. + .5)) * 2.;\n    float crazy2 = abs(p.z/2. - floor(p.z/2. + .5)) * 2.;\n    float var1 = sin(p.x + iTime) * cos(p.z + iTime) / 2. + p.y + 5.;\n\tfloat var2 = -crazy * crazy2 / 2. * (sin(iTime) * .5 + .5) + p.y + 5.;\n\t//return mix(var1, var2, cos(iTime / 8.) / .5 + .5);\n    return var1;\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sph1(vec3 p){\n    return sphere(p - vec3(sin(iTime * 2.), 0., 0.), .2);\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec3 normal2(vec3 p){\n    return normalize(vec3(\n        plane(vec3(p.x + E, p.y, p.z)) - plane(vec3(p.x - E, p.y, p.z)),\n        plane(vec3(p.x, p.y + E, p.z)) - plane(vec3(p.x, p.y - E, p.z)),\n        plane(vec3(p.x, p.y, p.z + E)) - plane(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\nvec3 carpos(float t){\n    return vec3(sin(t / 2.) * 4., 0., sin(t) * 4. + 8.);\n}\n\nfloat cyl(vec3 p, float r, float h){\n\treturn max(length(p.xy) - r, abs(p.z) - h);\n}\n\nfloat map(vec3 p){\n    \n    float pl = plane(p);\n    \n    vec3 cp = carpos(iTime);\n    vec3 cp2 = carpos(iTime + E);\n    vec2 dir = normalize(cp2.xz - cp.xz);\n    \n    vec3 bp = carpos(iTime - (sin(iTime) * .5 + .5));\n    bp.y -= plane(bp);\n    bp.y += .4;\n    \n    cp.y -= plane(cp);\n    vec3 n2 = normal2(cp);\n    cp.y += 0.4;\n    \n    mat3 rot = rotY(-atan(dir.x, dir.y) - 1.57) * rotZ(-acos(n2.x) - 1.57) * rotX(acos(n2.z) - 1.57);\n    cp = rot * (p - cp);\n    \n    float autoke = box(cp, vec3(.4, .1, .2));\n    \n    float whl = 1000.;\n    whl = min(whl, cyl(cp - vec3(.3, .2, .2), .1, .02));\n    whl = min(whl, cyl(cp - vec3(-.3, .2, .2), .1, .02));\n    whl = min(whl, cyl(cp - vec3(-.3, .2, -.2), .1, .02));\n    whl = min(whl, cyl(cp - vec3(.3, .2, -.2), .1, .02));\n\n    \n    float sph = sph1(p - bp);\n    \n    return min(pl, smin(sph, min(autoke, whl), .2));\n}\n\n\nvec3 normal(vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + E, p.y, p.z)) - map(vec3(p.x - E, p.y, p.z)),\n        map(vec3(p.x, p.y + E, p.z)) - map(vec3(p.x, p.y - E, p.z)),\n        map(vec3(p.x, p.y, p.z + E)) - map(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= .5;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 sky = vec3(0., .5, 1.);\n    vec3 c = sky;\n    \n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    float t = 0.;\n    \n    for (int step = 0; step < 200; step++){\n    \tvec3 p = rotX(.5) * (ro + t * rd);\n        float d = map(p);\n        if (d < E){\n            vec3 n = normal(p);\n            float shading = dot(n, normalize(ro - p));\n            c = vec3(1.);\n            \n            if (sph1(p) < E)\n            \tc *= texture(iChannel0, vec2(atan(p.x), atan(p.y))).x;\n            if (plane(p) < E)\n                c = vec3(.8, .3, .0);\n            c *= shading;\n            c = mix(c, sky, smoothstep(0., .5, length(p - ro) / 100.));\n            break;\n        }\n        else if (d > 100.)\n        {\n            break;\n        }\n        t += d;\n    }\n\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 110], [111, 111, 130, 130, 196], [197, 197, 216, 216, 282], [284, 284, 325, 325, 418], [420, 420, 440, 472, 802], [805, 805, 836, 836, 864], [866, 866, 885, 885, 945], [947, 947, 973, 973, 1066], [1068, 1068, 1089, 1089, 1344], [1346, 1346, 1367, 1367, 1426], [1428, 1428, 1464, 1464, 1511], [1513, 1513, 1531, 1531, 2380], [2383, 2383, 2403, 2403, 2646], [2649, 2649, 2706, 2706, 3638]]}
{"id": "wtB3DV", "name": "Circle Of Life  (in progress)", "author": "SSHantaram", "description": "This is an atempt to recreate an effect I achieved with javascript and canvas. Unfortunately using the fragment shader is less than ideal for this effect!", "tags": ["2d", "triangles", "pseudorandom"], "likes": 15, "viewed": 298, "published": "Public API", "date": "1561307504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int numTriangles = 500;\nconst float GRID_SIZE = 0.05;\nconst float ARBITRARY_OFFSET = 17.567;\nconst float RADIUS = 7.0;\nconst float EPSILON = 0.0001;\nconst float WORLD_SPEED = 1.0;\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec2 getTriangleCenter(vec2 pos) {\n    vec2 gridPoint = vec2(floor(pos.x), floor(pos.y));\n    vec2 delta = pos - gridPoint;\n    if (delta.x + delta.y < 1.0) return vec2(gridPoint.x + 1.0/3.0, gridPoint.y + 1.0/3.0);\n    else return vec2(gridPoint.x + 2.0/3.0, gridPoint.y + 2.0/3.0);\n}\n\nfloat fastNoise(vec2 pos, float offset) {\n    return random(vec3(pos, 0.0) + vec3(ARBITRARY_OFFSET, 2.0*ARBITRARY_OFFSET, 5.0*ARBITRARY_OFFSET));\n}\n\nbool insideTriangle(vec2 P, vec2 A, vec2 B, vec2 C) {\n    vec2 v1 = B - A;\n    vec2 v2 = C - A;\n    \n    float divisor = determinant(mat2(v1, v2));\n    \n    float a = (determinant(mat2(P, v2)) - determinant(mat2(A, v2)))/divisor;\n    if (a <= -EPSILON) return false; // free anti-aliasing\n    \n    float b = -(determinant(mat2(P, v1)) - determinant(mat2(A, v1)))/divisor;\n    if (b <= -EPSILON) return false; // free anti-aliasing\n    \n    return (a + b) <= 1.0 + EPSILON; // free anti-aliasing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 A = vec2(0.5, 0.5);\n    //vec2 B = vec2(0.0, 1.0);\n    //vec2 C = vec2(1.0, 1.0);\n    \n    float width = iResolution.x/iResolution.y;\n    \n    vec2 worldOffset = vec2(0.8*iTime, 0.2*iTime) * WORLD_SPEED;\n    //worldOffset += vec2(0.8, 0.2)*1000.0;\n    \n    // coordinates centered on screen: height = 1.0, width depends on resolution\n    vec2 pos = (fragCoord/iResolution.y + vec2(-0.5*width, -0.5))/GRID_SIZE;\n    pos += worldOffset;\n    vec2 triangleCenter = getTriangleCenter(pos);\n\n    // black background\n    float val = 0.0;\n\n    float start_x = floor(min(pos.x, worldOffset.x));\n    float start_y = floor(min(pos.y, worldOffset.y));\n    float end_x = floor(max(pos.x, worldOffset.x) + 1.0);\n    float end_y = floor(max(pos.y, worldOffset.y) + 1.0);\n\n    for (float x  = start_x; x <= end_x; x += 1.0) {\n        for (float y  = start_y; y <= end_y; y += 1.0) {\n            vec2 dir, offset, A, B, C;\n            float distFromCircle, moveSpeed, rotation, dirVariance;\n            mat2 rotMat, dirRotMat;\n            \n            // triangle 1\n            vec2 S = vec2(x + 1.0/3.0, y + 1.0/3.0);\n            dir = S - worldOffset;\n            \n           \tmoveSpeed = 0.01 * fastNoise(S, 1.0);\n            distFromCircle = max(0.0, dir.x*dir.x + dir.y*dir.y - RADIUS*RADIUS);\n            rotation = distFromCircle*(fastNoise(S, 2.0) - 0.5);\n            rotMat = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n            offset = dir*distFromCircle*moveSpeed;\n            A = offset + S + rotMat*vec2(-1.0/3.0, -1.0/3.0);\n            B = offset + S + rotMat*vec2(+2.0/3.0, -1.0/3.0);\n            C = offset + S + rotMat*vec2(-1.0/3.0, +2.0/3.0);\n            if (insideTriangle(pos, A, B, C)) {\n               \tval = fastNoise(S, 0.0);\n                break;\n           \t}\n            \n            // triangle 2\n            S = vec2(x + 2.0/3.0, y + 2.0/3.0);\n            dir = S - worldOffset;\n            \n            moveSpeed = 0.01 * fastNoise(S, 1.0);\n            distFromCircle = max(0.0, dir.x*dir.x + dir.y*dir.y - RADIUS*RADIUS);\n            rotation = distFromCircle*(fastNoise(S, 2.0) - 0.5);\n            rotMat = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n            offset = dir*distFromCircle*moveSpeed;\n            A = offset + S + rotMat*vec2(-2.0/3.0, +1.0/3.0);\n            B = offset + S + rotMat*vec2(+1.0/3.0, -2.0/3.0);\n           \tC = offset + S + rotMat*vec2(+1.0/3.0, +1.0/3.0);\n            if (insideTriangle(pos, A, B, C)) {\n                val = fastNoise(S, 0.0);\n                break;\n            \t\n            }\n        }\n    }\n    \n    vec3 col = vec3(val, val, val);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 258, 279, 279, 410], [414, 480, 502, 502, 560], [561, 561, 583, 583, 641], [642, 642, 664, 664, 722], [726, 884, 916, 916, 1336], [1340, 1389, 1414, 1414, 1465], [1466, 1466, 1491, 1491, 1542], [1543, 1543, 1568, 1568, 1619], [1620, 1620, 1645, 1645, 1696], [1698, 1698, 1732, 1732, 1983], [1985, 1985, 2026, 2026, 2132], [2134, 2134, 2187, 2187, 2630], [2632, 2632, 2689, 2782, 5414]]}
{"id": "wtB3R3", "name": "Stairs to Nowhere", "author": "dr2", "description": "Alternative version of the NYC artwork (use mouse to explore)", "tags": ["raymarch", "symmetry", "architecture", "folly"], "likes": 16, "viewed": 402, "published": "Public API", "date": "1560443648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Stairs to Nowhere\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrCapsDf (vec3 p, float r, float h);\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 szFlr;\nvec3 sunDir, vnCylOut;\nfloat dstFar, tCur, szFac, flSpc, nFlr, twrRad, bCylRad, bCylHt, dCylOut, bSizeV, cIdV;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.73205, sqrt2 = 1.41421;\nconst int idFlr = 1, idStr = 2, idRl = 3, idStn = 4, idCln = 5, idMir = 6;\n\n#define SZ(x) (szFac * (x))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, stSpc, xLim1, xLim2, bRad, r, a, x;\n  bool topFlr, botFlr;\n  r = length (p.xz) - twrRad;\n  a = 2. * pi * ((floor (6. * atan (p.x, - p.z) / (2. * pi)) + 0.5) / 6.);\n  stSpc = SZ(6.);\n  xLim1 = abs (dot (p.xz, sin (a + vec2 (0.5 * pi, 0.)))) - SZ(22.);\n  xLim2 = xLim1 + SZ(16.);\n  bRad = SZ(0.35);\n  topFlr = (cIdV == 2. * nFlr - 1.);\n  botFlr = (cIdV == 0.);\n  dMin = dstFar;\n  if (topFlr) {\n    d = length (max (abs (vec2 (p.y + 0.5 * szFlr.w, r + szFlr.z + stSpc)) -\n       vec2 (0.5 * szFlr.w, szFlr.z), 0.));\n    DMIN (idFlr);\n    d = max (length (vec2 (p.y + SZ(0.4), abs (r + szFlr.z + stSpc - SZ(0.5))) -\n       (szFlr.z - SZ(0.1))) - bRad, - xLim2);\n    DMIN (idRl);\n  }\n  d = max (length (max (abs (vec2 ((topFlr ? - p.y : abs (p.y)) - flSpc,\n     r - 0.4 * (szFlr.z + stSpc))) - vec2 (szFlr.w, 1.4 * (szFlr.z + stSpc)), 0.)), - xLim1);\n  DMIN (idFlr);\n  d = max (length (max (abs (vec2 (p.y + szFlr.w, r)) - vec2 (szFlr.w,\n     2. * szFlr.z + stSpc + SZ(0.5)), 0.)), xLim2);\n  DMIN (idFlr);\n  p.zx = Rot2D (p.zx, a);\n  p.z = abs (p.z) - twrRad;\n  for (float sz = -1.; sz <= 1.; sz += 2.) {\n    if (! topFlr || sz < 0.) {\n      q.x = abs (p.x) - szFlr.x;\n      q.yz = p.yz - sz * vec2 (szFlr.y - szFlr.w, - (szFlr.z + stSpc));\n      d = abs (q.y) - (szFlr.y - szFlr.w - SZ(0.005));\n      q.xy = vec2 (q.x + sz * q.y, - sz * q.x + q.y) / sqrt2;\n      x = mod (q.x, SZ(sqrt2));\n      d = max (max (max (q.y - min (x, SZ(sqrt2) - x), abs (q.z) - szFlr.z),\n         - SZ(1.) - q.y), d);\n      DMIN (idStr);\n    }\n  }\n  d = max (length (vec2 (p.y + flSpc - SZ(4.), abs (r - szFlr.z) -\n     (2. * szFlr.z + stSpc - SZ(0.8)))) - bRad, - xLim1);\n  DMIN (idRl);\n  d = max (length (vec2 (p.y - SZ(3.5), abs (r - SZ(0.4)) -\n     (2. * szFlr.z + stSpc - SZ(0.1)))) - bRad, xLim2);\n  DMIN (idRl);\n  q = vec3 (abs (p.x) - szFlr.x - SZ(4.), p.y + 0.5 * flSpc,\n     abs (p.z - (szFlr.z + stSpc)) - szFlr.z);\n  d = max (length (vec2 ((q.x + q.y) / sqrt2, q.z)) - bRad,\n     abs (abs (p.x) - szFlr.x) - SZ(8.));\n  DMIN (idRl);\n  q.xz = vec2 (abs (p.x) - szFlr.x + SZ(4.), abs (p.z + szFlr.z + stSpc) - szFlr.z);\n  if (! botFlr) {\n    d = max (length (vec2 ((q.x - (p.y + 1.5 * flSpc)) / sqrt2, q.z)) - bRad,\n       abs (abs (p.x) - szFlr.x) - SZ(8.));\n    DMIN (idRl);\n  }\n  if (! topFlr) {\n    d = max (length (vec2 ((q.x - (p.y - 0.5 * flSpc)) / sqrt2, q.z)) - bRad,\n       abs (abs (p.x) - szFlr.x) - SZ(8.));\n    DMIN (idRl);\n  }\n  q.x = abs (p.x) - SZ(22.);\n  d = min (length (vec2 (q.x, p.y + flSpc - SZ(4.))),\n     length (vec2 (abs (p.x) - SZ(6.), p.y - SZ(3.5)))) - bRad;\n  d = max (d, max (abs (p.z) - (2. * szFlr.z + stSpc), szFlr.z - abs (abs (p.z) -\n     (szFlr.z + stSpc))));\n  DMIN (idRl);\n  q.yz = vec2 (p.y + flSpc - SZ(2.5), abs (abs (p.z) - (szFlr.z + stSpc)) - szFlr.z);\n  d = PrCapsDf (q.xzy, SZ(0.7), SZ(2.));\n  DMIN (idStn);\n  if (! topFlr) {\n    d = length (vec2 (q.x, p.z)) - SZ(0.8);\n    DMIN (idCln);\n    d = max (p.z + 0.7 * twrRad, abs (p.y) - flSpc);\n    DMIN (idMir);\n  }\n  d = PrCapsDf (vec3 (abs (p.x) - SZ(6.), p.y - SZ(2.5), q.z).xzy, SZ(0.7), SZ(2.));\n  DMIN (idStn);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps, sy;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.y == 0.) rd.y = 0.001;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    d = abs (sy) + eps;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n      p.y = p.y - bSizeV * (cIdV + 0.5);\n      d = min (ObjDf (p), d);\n    }\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h, sy;\n  sh = 1.;\n  d = SZ(0.05);\n  for (int j = 0; j < 40; j ++) {\n    p = ro + d * rd;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n      p.y -= bSizeV * (cIdV + 0.5);\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = abs (sy);\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.002, -0.002);\n  cIdV = floor (p.y / bSizeV);\n  p.y -= bSizeV * (cIdV + 0.5);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd;\n  rd = normalize (vec3 (rd.x, max (0.001, rd.y), rd.z));\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.2 * pow (sd, 256.), vec3 (0.9),\n     clamp (3. * (Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz)) - 0.5) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV, sh;\n  InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - bCylHt) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (48. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.3) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.7, 0.8, 0.7);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (12. * aa, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, sunDir), 0.));\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    qh = HexGrid (0.75 * ro.xz);\n    f = max (length (qh.xy) - 0.5, 0.) * b;\n    vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vn = VaryNf (64. * ro, vn, 0.2 * b);\n    col = vec3 (0.72, 0.72, 0.75) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n       (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rot, refCol;\n  float dstObj, sh, nDotS;\n  bSizeV = 2. * flSpc;\n  dstObj = ObjRay (ro, rd);\n  rot = ro + dstObj * rd;\n  refCol = vec3 (1.);\n  if (dstObj < dstFar && idObj == idMir && length (rot.xz) < 0.33 * twrRad) {\n    ro = rot;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    refCol = vec3 (0.7, 1., 1.);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idFlr) {\n      col4 = vec4 (0.7, 0.4, 0.2, 0.1);\n      if (vn.y > 0.99) col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (0.5 * length (ro.xz) / SZ(1.), 1.));\n    } else if (idObj == idStr) {\n      col4 = vec4 (0.6, 0.3, 0.2, 0.1);\n    } else if (idObj == idRl) {\n      col4 = vec4 (0.7, 0.7, 0.9, 0.4);\n    } else if (idObj == idStn) {\n      col4 = vec4 (0.9, 0.9, 0.1, 0.4);\n    } else if (idObj == idCln) {\n      col4 = vec4 (0.6, 0.8, 0.6, 0.2);\n    } else if (idObj == idMir) {\n      col4 = vec4 (0.5, 0.6, 0.6, 0.4);\n    }\n    nDotS = max (dot (vn, sunDir), 0.);\n    if (idObj != idFlr && idObj != idStr) nDotS *= nDotS;\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotS) + col4.a * step (0.95, sh) * sh *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  col *= refCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, azt, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  azt = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    azt = (1.2/16.) * pi * (floor (0.2 * tCur) + smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  }\n  zmFac = 2.8 + 6. * smoothstep (0.2 * pi , 0.7 * pi, abs (az));\n  az += azt;\n  el = clamp (el, -0.4 * pi, 0.03 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  szFac = 0.2;\n  szFlr = SZ(vec4 (14., 8.5, 4., 0.5));\n  flSpc = 2. * szFlr.y - szFlr.w;\n  nFlr = 3.;\n  twrRad = SZ(60.);\n  bCylRad = 80.;\n  bCylHt = 24.;\n  ro = vuMat * vec3 (0., 1.5 * nFlr * flSpc, - bCylRad + 1.);\n  dstFar = 200.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3R3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 763, 785, 785, 3930], [3932, 3932, 3965, 3965, 4465], [4467, 4467, 4504, 4504, 4954], [4956, 4956, 4977, 4977, 5230], [5232, 5232, 5266, 5266, 5787], [5789, 5789, 5821, 5821, 6118], [6120, 6120, 6146, 6146, 6496], [6498, 6498, 6529, 6529, 9207], [9209, 9209, 9244, 9244, 10613], [10615, 10615, 10671, 10671, 12194], [12196, 12196, 12239, 12239, 12303], [12305, 12305, 12329, 12329, 12559], [12561, 12561, 12585, 12585, 12645], [12647, 12647, 12670, 12670, 12803], [12805, 12805, 12862, 12862, 12945], [12947, 12947, 12977, 12977, 13090], [13124, 13124, 13148, 13148, 13278], [13280, 13280, 13305, 13305, 13491], [13493, 13493, 13514, 13514, 13669], [13671, 13671, 13700, 13700, 13912], [13914, 13914, 13953, 13953, 14133]]}
{"id": "wtB3RG", "name": "GPU hacks #07 - DirectX 12", "author": "PrzemyslawZaworski", "description": "Tiny framework in C language for fullscreen shaders with DirectX 12 (less than 200 lines of code, rest is shader bytecode). \nCode tested with NVIDIA RTX 2070 and Windows 10 (~112 FPS in 1280x720 resolution).", "tags": ["procedural", "tutorial", "fire", "smoke", "code"], "likes": 16, "viewed": 1231, "published": "Public", "date": "1559940262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nSave code as firesmoke.c and compile from Visual Studio command line:\ncl.exe firesmoke.c d3d12.lib dxgi.lib dxguid.lib user32.lib kernel32.lib gdi32.lib\nCompile own HLSL Shader Model 6.0 code to output header file containing object code:\ndxc /T vs_6_0 /Fh vertex.sh vertex.hlsl\ndxc /T ps_6_0 /Fh pixel.sh pixel.hlsl\nTo use timer, define inside HLSL pixel shader code: \ncbuffer PerFrameConstants : register (b0) {float iTime;}\nand\nuse pixel coordinates as:\nfloat4 position : SV_POSITION\n*/\n\n/*\nReferences:\nhttps://docs.microsoft.com/en-us/windows/desktop/api/_direct3d12/\nhttps://github.com/wolfgangfengel/graphicsdemoskeleton\nhttps://www.shadertoy.com/view/MdfGRX\nhttps://www.shadertoy.com/view/Xt3cDn\n*/\n\n/*\n#include <windows.h>\n#include <d3d12.h>\n#include <dxgi1_4.h>\n\n#define WIDTH 1280\n#define HEIGHT 720\n#define FRAMES 2\n\nconst unsigned char VertexShader[] = \n{\n\t0x44, 0x58, 0x42, 0x43, 0x8D, 0x77, 0x50, 0xF6, 0x0A, 0x33, 0x48, 0xCC, 0xA8, 0x0C, 0x1A, 0xA3, \n\t0x59, 0xCD, 0x7F, 0x7B, 0x01, 0x00, 0x00, 0x00, 0x41, 0x06, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, \n\t0x34, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, \n\t0x39, 0x01, 0x00, 0x00, 0x53, 0x46, 0x49, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x31, 0x31, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, \n\t0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E, 0x00, 0x4F, 0x53, 0x47, \n\t0x31, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5F, \n\t0x50, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x50, 0x53, 0x56, 0x30, 0x78, 0x00, 0x00, \n\t0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, \n\t0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, \n\t0x00, 0x00, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x01, 0x00, 0x44, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x01, 0x00, 0x44, 0x03, 0x03, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, \n\t0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x44, 0x58, 0x49, 0x4C, 0x00, 0x05, 0x00, \n\t0x00, 0x60, 0x00, 0x01, 0x00, 0x40, 0x01, 0x00, 0x00, 0x44, 0x58, 0x49, 0x4C, 0x00, 0x01, 0x00, \n\t0x00, 0x10, 0x00, 0x00, 0x00, 0xE8, 0x04, 0x00, 0x00, 0x42, 0x43, 0xC0, 0xDE, 0x21, 0x0C, 0x00, \n\t0x00, 0x37, 0x01, 0x00, 0x00, 0x0B, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, \n\t0x00, 0x07, 0x81, 0x23, 0x91, 0x41, 0xC8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39, 0x92, 0x01, 0x84, \n\t0x0C, 0x25, 0x05, 0x08, 0x19, 0x1E, 0x04, 0x8B, 0x62, 0x80, 0x10, 0x45, 0x02, 0x42, 0x92, 0x0B, \n\t0x42, 0x84, 0x10, 0x32, 0x14, 0x38, 0x08, 0x18, 0x4B, 0x0A, 0x32, 0x42, 0x88, 0x48, 0x90, 0x14, \n\t0x20, 0x43, 0x46, 0x88, 0xA5, 0x00, 0x19, 0x32, 0x42, 0xE4, 0x48, 0x0E, 0x90, 0x11, 0x22, 0xC4, \n\t0x50, 0x41, 0x51, 0x81, 0x8C, 0xE1, 0x83, 0xE5, 0x8A, 0x04, 0x21, 0x46, 0x06, 0x51, 0x18, 0x00, \n\t0x00, 0x06, 0x00, 0x00, 0x00, 0x1B, 0x8C, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x40, 0x02, 0xA8, \n\t0x0D, 0x84, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x20, 0x01, 0x00, 0x00, 0x00, 0x49, 0x18, 0x00, \n\t0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x82, 0x60, 0x42, 0x20, 0x00, 0x00, 0x00, 0x89, 0x20, 0x00, \n\t0x00, 0x13, 0x00, 0x00, 0x00, 0x32, 0x22, 0x08, 0x09, 0x20, 0x64, 0x85, 0x04, 0x13, 0x22, 0xA4, \n\t0x84, 0x04, 0x13, 0x22, 0xE3, 0x84, 0xA1, 0x90, 0x14, 0x12, 0x4C, 0x88, 0x8C, 0x0B, 0x84, 0x84, \n\t0x4C, 0x10, 0x38, 0x23, 0x00, 0x25, 0x00, 0x8A, 0x19, 0x80, 0x39, 0x02, 0x30, 0x98, 0x23, 0x40, \n\t0x8A, 0x31, 0x44, 0x54, 0x44, 0x56, 0x0C, 0x20, 0xA2, 0x1A, 0xC2, 0x81, 0x80, 0x61, 0x04, 0x62, \n\t0xB8, 0x45, 0x9A, 0x22, 0x4A, 0x98, 0xFC, 0x17, 0xA5, 0x26, 0x14, 0x6C, 0x1A, 0x10, 0x00, 0x00, \n\t0x00, 0x13, 0x14, 0x72, 0xC0, 0x87, 0x74, 0x60, 0x87, 0x36, 0x68, 0x87, 0x79, 0x68, 0x03, 0x72, \n\t0xC0, 0x87, 0x0D, 0xAF, 0x50, 0x0E, 0x6D, 0xD0, 0x0E, 0x7A, 0x50, 0x0E, 0x6D, 0x00, 0x0F, 0x7A, \n\t0x30, 0x07, 0x72, 0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, 0x90, 0x0E, 0x71, 0xA0, 0x07, 0x73, 0x20, \n\t0x07, 0x6D, 0x90, 0x0E, 0x78, 0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, 0x90, 0x0E, 0x71, 0x60, 0x07, \n\t0x7A, 0x30, 0x07, 0x72, 0xD0, 0x06, 0xE9, 0x30, 0x07, 0x72, 0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, \n\t0x90, 0x0E, 0x76, 0x40, 0x07, 0x7A, 0x60, 0x07, 0x74, 0xD0, 0x06, 0xE6, 0x10, 0x07, 0x76, 0xA0, \n\t0x07, 0x73, 0x20, 0x07, 0x6D, 0x60, 0x0E, 0x73, 0x20, 0x07, 0x7A, 0x30, 0x07, 0x72, 0xD0, 0x06, \n\t0xE6, 0x60, 0x07, 0x74, 0xA0, 0x07, 0x76, 0x40, 0x07, 0x6D, 0xE0, 0x0E, 0x78, 0xA0, 0x07, 0x71, \n\t0x60, 0x07, 0x7A, 0x30, 0x07, 0x72, 0xA0, 0x07, 0x76, 0x40, 0x07, 0x43, 0x9E, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x3C, 0x06, 0x10, 0x00, 0x01, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x79, 0x10, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0xC8, 0x02, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x32, 0x1E, 0x98, 0x14, 0x19, 0x11, 0x4C, \n\t0x90, 0x8C, 0x09, 0x26, 0x47, 0xC6, 0x04, 0x43, 0xA2, 0x12, 0x18, 0x01, 0x28, 0x83, 0x62, 0x28, \n\t0x90, 0x42, 0x28, 0x87, 0x92, 0xA0, 0x2A, 0x89, 0x11, 0x80, 0x42, 0x28, 0x03, 0xE2, 0x19, 0x00, \n\t0xEA, 0xB1, 0x0C, 0x82, 0x08, 0x04, 0x02, 0x01, 0x00, 0x79, 0x18, 0x00, 0x00, 0x52, 0x00, 0x00, \n\t0x00, 0x1A, 0x03, 0x4C, 0x90, 0x46, 0x02, 0x13, 0xC4, 0x83, 0x0C, 0x6F, 0x0C, 0x24, 0xC6, 0x45, \n\t0x66, 0x43, 0x10, 0x4C, 0x10, 0x88, 0x61, 0x82, 0x40, 0x10, 0x1B, 0x84, 0x81, 0x98, 0x20, 0x10, \n\t0xC5, 0x06, 0x61, 0x30, 0x28, 0xD8, 0xCD, 0x4D, 0x10, 0x08, 0x63, 0xC3, 0x80, 0x24, 0xC4, 0x04, \n\t0x81, 0x79, 0x26, 0x08, 0xC4, 0x41, 0x04, 0xEE, 0x6D, 0x2E, 0x8D, 0x2E, 0xED, 0xCD, 0x6D, 0x82, \n\t0x40, 0x20, 0x5C, 0xA6, 0xAC, 0xBE, 0xA0, 0x9E, 0xA6, 0x92, 0xA8, 0x92, 0x9E, 0x9C, 0x26, 0x08, \n\t0x44, 0x32, 0x41, 0x20, 0x94, 0x0D, 0x48, 0xD2, 0x18, 0x84, 0xF3, 0x40, 0xD1, 0x06, 0x81, 0x91, \n\t0x36, 0x0C, 0xC4, 0x32, 0x4D, 0x10, 0x04, 0x60, 0x03, 0xB0, 0x61, 0x20, 0x2C, 0x6B, 0x43, 0x70, \n\t0x6D, 0x18, 0x86, 0x0A, 0x9B, 0x20, 0x34, 0xD0, 0x86, 0x40, 0x23, 0xD1, 0x16, 0x96, 0xE6, 0x46, \n\t0x04, 0xEA, 0x69, 0x2A, 0x89, 0x2A, 0xE9, 0xC9, 0x69, 0x82, 0x50, 0x2C, 0x13, 0x84, 0x82, 0xD9, \n\t0x10, 0x10, 0x13, 0x84, 0xA2, 0xD9, 0xB0, 0x10, 0x9D, 0xF7, 0x81, 0xC1, 0x37, 0x84, 0x01, 0xF1, \n\t0x01, 0x1B, 0x02, 0x31, 0xE0, 0x32, 0x65, 0xF5, 0x05, 0xF5, 0x36, 0x97, 0x46, 0x97, 0xF6, 0xE6, \n\t0x36, 0x41, 0x28, 0x9C, 0x0D, 0x0B, 0x41, 0x06, 0x5E, 0x19, 0x80, 0x41, 0x18, 0x0C, 0x61, 0x40, \n\t0x7C, 0xC0, 0x86, 0xC0, 0x0C, 0x36, 0x0C, 0x63, 0x70, 0x06, 0xC0, 0x86, 0xA2, 0xE2, 0xD0, 0x00, \n\t0x00, 0xAA, 0xB0, 0xB1, 0xD9, 0xB5, 0xB9, 0xA4, 0x91, 0x95, 0xB9, 0xD1, 0x4D, 0x09, 0x82, 0x2A, \n\t0x64, 0x78, 0x2E, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x53, 0x02, 0xA2, 0x09, 0x19, 0x9E, \n\t0x8B, 0x5D, 0x18, 0x9B, 0x5D, 0x99, 0xDC, 0x94, 0xC0, 0xA8, 0x43, 0x86, 0xE7, 0x32, 0x87, 0x16, \n\t0x46, 0x56, 0x26, 0xD7, 0xF4, 0x46, 0x56, 0xC6, 0x36, 0x25, 0x48, 0x2A, 0x91, 0xE1, 0xB9, 0xD0, \n\t0xE5, 0xC1, 0x95, 0x05, 0xB9, 0xB9, 0xBD, 0xD1, 0x85, 0xD1, 0xA5, 0xBD, 0xB9, 0xCD, 0x4D, 0x11, \n\t0x26, 0xAC, 0x0E, 0x19, 0x9E, 0x8B, 0x5D, 0x5A, 0xD9, 0x5D, 0x12, 0xD9, 0x14, 0x5D, 0x18, 0x5D, \n\t0xD9, 0x94, 0x40, 0xAB, 0x43, 0x86, 0xE7, 0x52, 0xE6, 0x46, 0x27, 0x97, 0x07, 0xF5, 0x96, 0xE6, \n\t0x46, 0x37, 0x37, 0x25, 0x40, 0x03, 0x00, 0x00, 0x00, 0x79, 0x18, 0x00, 0x00, 0x42, 0x00, 0x00, \n\t0x00, 0x33, 0x08, 0x80, 0x1C, 0xC4, 0xE1, 0x1C, 0x66, 0x14, 0x01, 0x3D, 0x88, 0x43, 0x38, 0x84, \n\t0xC3, 0x8C, 0x42, 0x80, 0x07, 0x79, 0x78, 0x07, 0x73, 0x98, 0x71, 0x0C, 0xE6, 0x00, 0x0F, 0xED, \n\t0x10, 0x0E, 0xF4, 0x80, 0x0E, 0x33, 0x0C, 0x42, 0x1E, 0xC2, 0xC1, 0x1D, 0xCE, 0xA1, 0x1C, 0x66, \n\t0x30, 0x05, 0x3D, 0x88, 0x43, 0x38, 0x84, 0x83, 0x1B, 0xCC, 0x03, 0x3D, 0xC8, 0x43, 0x3D, 0x8C, \n\t0x03, 0x3D, 0xCC, 0x78, 0x8C, 0x74, 0x70, 0x07, 0x7B, 0x08, 0x07, 0x79, 0x48, 0x87, 0x70, 0x70, \n\t0x07, 0x7A, 0x70, 0x03, 0x76, 0x78, 0x87, 0x70, 0x20, 0x87, 0x19, 0xCC, 0x11, 0x0E, 0xEC, 0x90, \n\t0x0E, 0xE1, 0x30, 0x0F, 0x6E, 0x30, 0x0F, 0xE3, 0xF0, 0x0E, 0xF0, 0x50, 0x0E, 0x33, 0x10, 0xC4, \n\t0x1D, 0xDE, 0x21, 0x1C, 0xD8, 0x21, 0x1D, 0xC2, 0x61, 0x1E, 0x66, 0x30, 0x89, 0x3B, 0xBC, 0x83, \n\t0x3B, 0xD0, 0x43, 0x39, 0xB4, 0x03, 0x3C, 0xBC, 0x83, 0x3C, 0x84, 0x03, 0x3B, 0xCC, 0xF0, 0x14, \n\t0x76, 0x60, 0x07, 0x7B, 0x68, 0x07, 0x37, 0x68, 0x87, 0x72, 0x68, 0x07, 0x37, 0x80, 0x87, 0x70, \n\t0x90, 0x87, 0x70, 0x60, 0x07, 0x76, 0x28, 0x07, 0x76, 0xF8, 0x05, 0x76, 0x78, 0x87, 0x77, 0x80, \n\t0x87, 0x5F, 0x08, 0x87, 0x71, 0x18, 0x87, 0x72, 0x98, 0x87, 0x79, 0x98, 0x81, 0x2C, 0xEE, 0xF0, \n\t0x0E, 0xEE, 0xE0, 0x0E, 0xF5, 0xC0, 0x0E, 0xEC, 0x30, 0x03, 0x62, 0xC8, 0xA1, 0x1C, 0xE4, 0xA1, \n\t0x1C, 0xCC, 0xA1, 0x1C, 0xE4, 0xA1, 0x1C, 0xDC, 0x61, 0x1C, 0xCA, 0x21, 0x1C, 0xC4, 0x81, 0x1D, \n\t0xCA, 0x61, 0x06, 0xD6, 0x90, 0x43, 0x39, 0xC8, 0x43, 0x39, 0x98, 0x43, 0x39, 0xC8, 0x43, 0x39, \n\t0xB8, 0xC3, 0x38, 0x94, 0x43, 0x38, 0x88, 0x03, 0x3B, 0x94, 0xC3, 0x2F, 0xBC, 0x83, 0x3C, 0xFC, \n\t0x82, 0x3B, 0xD4, 0x03, 0x3B, 0xB0, 0x03, 0x00, 0x00, 0x71, 0x20, 0x00, 0x00, 0x0B, 0x00, 0x00, \n\t0x00, 0x16, 0x30, 0x0D, 0x97, 0xEF, 0x3C, 0xFE, 0xE2, 0x00, 0x83, 0xD8, 0x3C, 0xD4, 0xE4, 0x17, \n\t0xB7, 0x6D, 0x00, 0x04, 0x03, 0x20, 0x8D, 0x09, 0x54, 0xC3, 0xE5, 0x3B, 0x8F, 0x2F, 0x4D, 0x4E, \n\t0x44, 0xA0, 0xD4, 0xF4, 0x50, 0x93, 0x5F, 0xDC, 0x36, 0x00, 0x00, 0x00, 0x00, 0x61, 0x20, 0x00, \n\t0x00, 0x1E, 0x00, 0x00, 0x00, 0x13, 0x04, 0x41, 0x2C, 0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, \n\t0x00, 0x44, 0x33, 0x00, 0xA5, 0x40, 0x55, 0x02, 0x45, 0x00, 0x00, 0x00, 0x00, 0x23, 0x06, 0x09, \n\t0x00, 0x82, 0x60, 0x60, 0x50, 0x4D, 0x14, 0x25, 0xC4, 0x88, 0x41, 0x02, 0x80, 0x20, 0x18, 0x18, \n\t0x95, 0x23, 0x49, 0x43, 0x31, 0x62, 0x90, 0x00, 0x20, 0x08, 0x06, 0x86, 0xF5, 0x4C, 0xD3, 0x60, \n\t0x8C, 0x18, 0x24, 0x00, 0x08, 0x82, 0x81, 0x71, 0x41, 0x14, 0xA5, 0x1C, 0x23, 0x06, 0x09, 0x00, \n\t0x82, 0x60, 0x80, 0x5C, 0x47, 0x55, 0x35, 0xC4, 0x88, 0x41, 0x02, 0x80, 0x20, 0x18, 0x20, 0xD7, \n\t0x51, 0x55, 0xC6, 0x30, 0x62, 0x90, 0x00, 0x20, 0x08, 0x06, 0xC8, 0x75, 0x54, 0x55, 0x21, 0x8C, \n\t0x18, 0x24, 0x00, 0x08, 0x82, 0x01, 0x72, 0x1D, 0x55, 0xB5, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, \n\t0x00\n};\n\nconst unsigned char PixelShader[] =\n{\n\t0x44, 0x58, 0x42, 0x43, 0xB4, 0xBD, 0xA2, 0xA9, 0xCF, 0x2E, 0x04, 0x0D, 0xAC, 0x7A, 0xA9, 0xF6, \n\t0x85, 0x28, 0xFA, 0x45, 0x01, 0x00, 0x00, 0x00, 0xA2, 0x1C, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, \n\t0x34, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, \n\t0x46, 0x01, 0x00, 0x00, 0x53, 0x46, 0x49, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x31, 0x34, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, \n\t0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5F, 0x50, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x00, \n\t0x4F, 0x53, 0x47, 0x31, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, \n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x53, 0x56, 0x5F, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x00, 0x50, 0x53, 0x56, 0x30, 0x84, 0x00, \n\t0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, \n\t0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, \n\t0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \n\t0x44, 0x03, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \n\t0x44, 0x10, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x58, 0x49, 0x4C, 0x54, 0x1B, 0x00, 0x00, 0x60, 0x00, \n\t0x00, 0x00, 0xD5, 0x06, 0x00, 0x00, 0x44, 0x58, 0x49, 0x4C, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, \n\t0x00, 0x00, 0x3C, 0x1B, 0x00, 0x00, 0x42, 0x43, 0xC0, 0xDE, 0x21, 0x0C, 0x00, 0x00, 0xCC, 0x06, \n\t0x00, 0x00, 0x0B, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x07, 0x81, \n\t0x23, 0x91, 0x41, 0xC8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39, 0x92, 0x01, 0x84, 0x0C, 0x25, 0x05, \n\t0x08, 0x19, 0x1E, 0x04, 0x8B, 0x62, 0x80, 0x14, 0x45, 0x02, 0x42, 0x92, 0x0B, 0x42, 0xA4, 0x10, \n\t0x32, 0x14, 0x38, 0x08, 0x18, 0x4B, 0x0A, 0x32, 0x52, 0x88, 0x48, 0x90, 0x14, 0x20, 0x43, 0x46, \n\t0x88, 0xA5, 0x00, 0x19, 0x32, 0x42, 0xE4, 0x48, 0x0E, 0x90, 0x91, 0x22, 0xC4, 0x50, 0x41, 0x51, \n\t0x81, 0x8C, 0xE1, 0x83, 0xE5, 0x8A, 0x04, 0x29, 0x46, 0x06, 0x51, 0x18, 0x00, 0x00, 0x08, 0x00, \n\t0x00, 0x00, 0x1B, 0x8C, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x40, 0x02, 0xA8, 0x0D, 0x84, 0xF0, \n\t0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x20, 0x6D, 0x30, 0x86, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x09, \n\t0xA8, 0x00, 0x49, 0x18, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x82, 0x60, 0x42, 0x20, 0x4C, \n\t0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x89, 0x20, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x32, 0x22, \n\t0x48, 0x09, 0x20, 0x64, 0x85, 0x04, 0x93, 0x22, 0xA4, 0x84, 0x04, 0x93, 0x22, 0xE3, 0x84, 0xA1, \n\t0x90, 0x14, 0x12, 0x4C, 0x8A, 0x8C, 0x0B, 0x84, 0xA4, 0x4C, 0x10, 0x74, 0x33, 0x00, 0x17, 0xA5, \n\t0x44, 0xF4, 0x45, 0x00, 0x43, 0x70, 0x4E, 0x23, 0x4D, 0x40, 0x33, 0x49, 0x28, 0x00, 0x14, 0x46, \n\t0x00, 0x4A, 0x30, 0x88, 0xCC, 0x11, 0x80, 0xC1, 0x1C, 0x01, 0x52, 0x0C, 0x60, 0x8C, 0x39, 0x86, \n\t0x50, 0x31, 0x86, 0x31, 0xE6, 0x00, 0x52, 0x47, 0x0D, 0x97, 0x3F, 0x61, 0x0F, 0x21, 0xF9, 0xDC, \n\t0x46, 0x15, 0x2B, 0x31, 0xF9, 0xC5, 0x6D, 0x23, 0x02, 0x00, 0x00, 0xE8, 0xDC, 0x33, 0x5C, 0xFE, \n\t0x84, 0x3D, 0x84, 0xE4, 0x87, 0x40, 0x33, 0x2C, 0x04, 0x0A, 0x5A, 0x21, 0x98, 0x71, 0x86, 0x5E, \n\t0x19, 0x80, 0x01, 0x14, 0x0B, 0x01, 0x0C, 0x00, 0x34, 0x4B, 0x01, 0x0C, 0x00, 0x80, 0xEA, 0x1C, \n\t0x41, 0x50, 0x0C, 0x67, 0x8E, 0x31, 0x97, 0xF0, 0x40, 0x40, 0x1A, 0x98, 0x29, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x13, 0x14, 0x72, 0xC0, 0x87, 0x74, 0x60, 0x87, 0x36, 0x68, 0x87, 0x79, 0x68, 0x03, \n\t0x72, 0xC0, 0x87, 0x0D, 0xAF, 0x50, 0x0E, 0x6D, 0xD0, 0x0E, 0x7A, 0x50, 0x0E, 0x6D, 0x00, 0x0F, \n\t0x7A, 0x30, 0x07, 0x72, 0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, 0x90, 0x0E, 0x71, 0xA0, 0x07, 0x73, \n\t0x20, 0x07, 0x6D, 0x90, 0x0E, 0x78, 0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, 0x90, 0x0E, 0x71, 0x60, \n\t0x07, 0x7A, 0x30, 0x07, 0x72, 0xD0, 0x06, 0xE9, 0x30, 0x07, 0x72, 0xA0, 0x07, 0x73, 0x20, 0x07, \n\t0x6D, 0x90, 0x0E, 0x76, 0x40, 0x07, 0x7A, 0x60, 0x07, 0x74, 0xD0, 0x06, 0xE6, 0x10, 0x07, 0x76, \n\t0xA0, 0x07, 0x73, 0x20, 0x07, 0x6D, 0x60, 0x0E, 0x73, 0x20, 0x07, 0x7A, 0x30, 0x07, 0x72, 0xD0, \n\t0x06, 0xE6, 0x60, 0x07, 0x74, 0xA0, 0x07, 0x76, 0x40, 0x07, 0x6D, 0xE0, 0x0E, 0x78, 0xA0, 0x07, \n\t0x71, 0x60, 0x07, 0x7A, 0x30, 0x07, 0x72, 0xA0, 0x07, 0x76, 0x40, 0x07, 0x3A, 0x0F, 0x24, 0x90, \n\t0x21, 0x23, 0x25, 0x40, 0x00, 0x1E, 0x00, 0x30, 0xE4, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x60, 0xC8, 0x83, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0xC0, 0x90, 0x47, 0x01, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x21, \n\t0xCF, 0x03, 0x04, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x9E, 0x08, 0x08, \n\t0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x3C, 0x13, 0x10, 0x00, 0x01, 0x00, \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x79, 0x2A, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00, 0x00, 0x18, 0xF2, 0x60, 0x40, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x90, 0x05, 0x02, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x1E, 0x98, 0x14, 0x19, 0x11, \n\t0x4C, 0x90, 0x8C, 0x09, 0x26, 0x47, 0xC6, 0x04, 0x43, 0x3A, 0x05, 0x32, 0x02, 0x40, 0xA6, 0x04, \n\t0x46, 0x00, 0xCA, 0xA0, 0x18, 0x0A, 0xA1, 0x1C, 0x4A, 0x82, 0x4E, 0x49, 0x94, 0x41, 0x21, 0x90, \n\t0x98, 0x01, 0xA0, 0x30, 0x03, 0x40, 0x7B, 0x2C, 0x83, 0x20, 0x8E, 0x03, 0x00, 0x00, 0x79, 0x18, \n\t0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x1A, 0x03, 0x4C, 0x90, 0x46, 0x02, 0x13, 0xC4, 0x83, 0x0C, \n\t0x6F, 0x0C, 0x24, 0xC6, 0x45, 0x66, 0x43, 0x10, 0x4C, 0x10, 0x8C, 0x65, 0x82, 0x60, 0x30, 0x1B, \n\t0x84, 0x81, 0x98, 0x20, 0x18, 0xCD, 0x06, 0x61, 0x30, 0x28, 0xC0, 0xCD, 0x4D, 0x10, 0x0C, 0x67, \n\t0xC3, 0x80, 0x24, 0xC4, 0x04, 0x41, 0xA8, 0x18, 0x41, 0x95, 0xC9, 0x19, 0xC9, 0x85, 0xB5, 0x95, \n\t0x0D, 0xBD, 0xB9, 0xCD, 0xD1, 0x85, 0xB9, 0xD1, 0xCD, 0x4D, 0x10, 0x8C, 0x67, 0x03, 0x42, 0x2C, \n\t0x0C, 0x41, 0x0C, 0x0D, 0xB0, 0x21, 0x70, 0x36, 0x10, 0x00, 0xF0, 0x00, 0x13, 0x84, 0xC0, 0x62, \n\t0x91, 0x46, 0x95, 0xD6, 0x56, 0x36, 0x41, 0x30, 0xA0, 0x09, 0x82, 0x11, 0x6D, 0x30, 0x12, 0xC9, \n\t0x20, 0x26, 0x6A, 0x83, 0xD0, 0x54, 0x1B, 0x06, 0x22, 0xB2, 0x26, 0x08, 0x45, 0xB0, 0x01, 0xD8, \n\t0x30, 0x10, 0x59, 0xB6, 0x21, 0xD0, 0x36, 0x0C, 0x03, 0xB6, 0x4D, 0x10, 0xB6, 0x6B, 0x43, 0xD0, \n\t0x91, 0x68, 0x0B, 0x4B, 0x73, 0xE3, 0x32, 0x65, 0xF5, 0x05, 0xF5, 0x36, 0x97, 0x46, 0x97, 0xF6, \n\t0xE6, 0x36, 0x41, 0x38, 0xA4, 0x09, 0xC2, 0x31, 0x6D, 0x08, 0x88, 0x09, 0xC2, 0x41, 0x4D, 0x10, \n\t0x0E, 0x65, 0xC3, 0x42, 0x80, 0x41, 0x18, 0x88, 0xC1, 0x18, 0x90, 0xC1, 0x40, 0x06, 0x44, 0x19, \n\t0x00, 0x1B, 0x02, 0x33, 0x60, 0x32, 0x65, 0xF5, 0x45, 0x15, 0x26, 0x77, 0x56, 0x46, 0x37, 0x41, \n\t0x38, 0x92, 0x0D, 0x0B, 0x81, 0x06, 0x61, 0x90, 0x06, 0x63, 0x50, 0x06, 0x03, 0x19, 0x10, 0x65, \n\t0x00, 0x6C, 0x08, 0xD4, 0x60, 0xC3, 0x70, 0x06, 0x6B, 0x00, 0x6C, 0x28, 0xB0, 0x8F, 0x0D, 0x20, \n\t0xA0, 0x0A, 0x1B, 0x9B, 0x5D, 0x9B, 0x4B, 0x1A, 0x59, 0x99, 0x1B, 0xDD, 0x94, 0x20, 0xA8, 0x42, \n\t0x86, 0xE7, 0x62, 0x57, 0x26, 0x37, 0x97, 0xF6, 0xE6, 0x36, 0x25, 0x20, 0x9A, 0x90, 0xE1, 0xB9, \n\t0xD8, 0x85, 0xB1, 0xD9, 0x95, 0xC9, 0x4D, 0x09, 0x8C, 0x3A, 0x64, 0x78, 0x2E, 0x73, 0x68, 0x61, \n\t0x64, 0x65, 0x72, 0x4D, 0x6F, 0x64, 0x65, 0x6C, 0x53, 0x82, 0xA4, 0x0C, 0x19, 0x9E, 0x8B, 0x5C, \n\t0xD9, 0xDC, 0x5B, 0x9D, 0xDC, 0x58, 0xD9, 0xDC, 0x94, 0xE0, 0xA9, 0x44, 0x86, 0xE7, 0x42, 0x97, \n\t0x07, 0x57, 0x16, 0xE4, 0xE6, 0xF6, 0x46, 0x17, 0x46, 0x97, 0xF6, 0xE6, 0x36, 0x37, 0x45, 0xB0, \n\t0xB6, 0x3A, 0x64, 0x78, 0x2E, 0x76, 0x69, 0x65, 0x77, 0x49, 0x64, 0x53, 0x74, 0x61, 0x74, 0x65, \n\t0x53, 0x82, 0xAE, 0x0E, 0x19, 0x9E, 0x4B, 0x99, 0x1B, 0x9D, 0x5C, 0x1E, 0xD4, 0x5B, 0x9A, 0x1B, \n\t0xDD, 0xDC, 0x94, 0x80, 0x0D, 0x00, 0x79, 0x18, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x33, 0x08, \n\t0x80, 0x1C, 0xC4, 0xE1, 0x1C, 0x66, 0x14, 0x01, 0x3D, 0x88, 0x43, 0x38, 0x84, 0xC3, 0x8C, 0x42, \n\t0x80, 0x07, 0x79, 0x78, 0x07, 0x73, 0x98, 0x71, 0x0C, 0xE6, 0x00, 0x0F, 0xED, 0x10, 0x0E, 0xF4, \n\t0x80, 0x0E, 0x33, 0x0C, 0x42, 0x1E, 0xC2, 0xC1, 0x1D, 0xCE, 0xA1, 0x1C, 0x66, 0x30, 0x05, 0x3D, \n\t0x88, 0x43, 0x38, 0x84, 0x83, 0x1B, 0xCC, 0x03, 0x3D, 0xC8, 0x43, 0x3D, 0x8C, 0x03, 0x3D, 0xCC, \n\t0x78, 0x8C, 0x74, 0x70, 0x07, 0x7B, 0x08, 0x07, 0x79, 0x48, 0x87, 0x70, 0x70, 0x07, 0x7A, 0x70, \n\t0x03, 0x76, 0x78, 0x87, 0x70, 0x20, 0x87, 0x19, 0xCC, 0x11, 0x0E, 0xEC, 0x90, 0x0E, 0xE1, 0x30, \n\t0x0F, 0x6E, 0x30, 0x0F, 0xE3, 0xF0, 0x0E, 0xF0, 0x50, 0x0E, 0x33, 0x10, 0xC4, 0x1D, 0xDE, 0x21, \n\t0x1C, 0xD8, 0x21, 0x1D, 0xC2, 0x61, 0x1E, 0x66, 0x30, 0x89, 0x3B, 0xBC, 0x83, 0x3B, 0xD0, 0x43, \n\t0x39, 0xB4, 0x03, 0x3C, 0xBC, 0x83, 0x3C, 0x84, 0x03, 0x3B, 0xCC, 0xF0, 0x14, 0x76, 0x60, 0x07, \n\t0x7B, 0x68, 0x07, 0x37, 0x68, 0x87, 0x72, 0x68, 0x07, 0x37, 0x80, 0x87, 0x70, 0x90, 0x87, 0x70, \n\t0x60, 0x07, 0x76, 0x28, 0x07, 0x76, 0xF8, 0x05, 0x76, 0x78, 0x87, 0x77, 0x80, 0x87, 0x5F, 0x08, \n\t0x87, 0x71, 0x18, 0x87, 0x72, 0x98, 0x87, 0x79, 0x98, 0x81, 0x2C, 0xEE, 0xF0, 0x0E, 0xEE, 0xE0, \n\t0x0E, 0xF5, 0xC0, 0x0E, 0xEC, 0x30, 0x03, 0x62, 0xC8, 0xA1, 0x1C, 0xE4, 0xA1, 0x1C, 0xCC, 0xA1, \n\t0x1C, 0xE4, 0xA1, 0x1C, 0xDC, 0x61, 0x1C, 0xCA, 0x21, 0x1C, 0xC4, 0x81, 0x1D, 0xCA, 0x61, 0x06, \n\t0xD6, 0x90, 0x43, 0x39, 0xC8, 0x43, 0x39, 0x98, 0x43, 0x39, 0xC8, 0x43, 0x39, 0xB8, 0xC3, 0x38, \n\t0x94, 0x43, 0x38, 0x88, 0x03, 0x3B, 0x94, 0xC3, 0x2F, 0xBC, 0x83, 0x3C, 0xFC, 0x82, 0x3B, 0xD4, \n\t0x03, 0x3B, 0xB0, 0xC3, 0x8C, 0xCC, 0x21, 0x07, 0x7C, 0x70, 0x03, 0x74, 0x60, 0x07, 0x37, 0x90, \n\t0x87, 0x72, 0x98, 0x87, 0x77, 0xA8, 0x07, 0x79, 0x18, 0x87, 0x72, 0x70, 0x83, 0x70, 0xA0, 0x07, \n\t0x7A, 0x90, 0x87, 0x74, 0x10, 0x87, 0x7A, 0xA0, 0x87, 0x72, 0x00, 0x00, 0x00, 0x00, 0x71, 0x20, \n\t0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x26, 0x30, 0x0D, 0x97, 0xEF, 0x3C, 0xFE, 0xE2, 0x00, 0x83, \n\t0xD8, 0x3C, 0xD4, 0xE4, 0x17, 0xB7, 0x6D, 0x04, 0xDB, 0x70, 0xF9, 0xCE, 0xE3, 0x0B, 0x01, 0x55, \n\t0x14, 0x44, 0x54, 0x3A, 0xC0, 0x50, 0x12, 0x06, 0x20, 0x60, 0x7E, 0x71, 0xDB, 0x76, 0x20, 0x0D, \n\t0x97, 0xEF, 0x3C, 0xFE, 0x44, 0x44, 0x13, 0x02, 0x44, 0x98, 0x5F, 0xDC, 0xB6, 0x05, 0x10, 0x0C, \n\t0x80, 0x34, 0x06, 0x10, 0xA5, 0x44, 0xF4, 0x45, 0x00, 0x43, 0x70, 0x4E, 0x23, 0x4D, 0x40, 0x33, \n\t0x49, 0x36, 0x50, 0x0D, 0x97, 0xEF, 0x3C, 0xBE, 0x34, 0x39, 0x11, 0x81, 0x52, 0xD3, 0x43, 0x4D, \n\t0x7E, 0x71, 0xDB, 0x66, 0x00, 0x0D, 0x97, 0xEF, 0x3C, 0x7E, 0x80, 0x34, 0x40, 0x84, 0xF9, 0xC5, \n\t0x6D, 0x1B, 0x82, 0x34, 0x5C, 0xBE, 0xF3, 0xF8, 0x42, 0x44, 0x00, 0x13, 0x11, 0x02, 0xCD, 0xB0, \n\t0x10, 0x56, 0xF0, 0x0C, 0x97, 0xEF, 0x3C, 0x3E, 0xD5, 0x00, 0x11, 0xE6, 0x17, 0xB7, 0x0D, 0x00, \n\t0x00, 0x00, 0x61, 0x20, 0x00, 0x00, 0x5D, 0x05, 0x00, 0x00, 0x13, 0x04, 0x44, 0x2C, 0x10, 0x00, \n\t0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x74, 0x47, 0x00, 0xE8, 0x94, 0x40, 0x11, 0x90, 0x29, 0x40, \n\t0x81, 0x82, 0x29, 0xB9, 0x19, 0x80, 0xD2, 0x28, 0x85, 0xE2, 0x2A, 0xA4, 0x32, 0x2A, 0xBB, 0x62, \n\t0x29, 0x9B, 0x02, 0x29, 0xED, 0x5C, 0x59, 0x4E, 0x04, 0x02, 0x63, 0x04, 0xAD, 0x39, 0xE7, 0xB4, \n\t0x37, 0x46, 0x10, 0xEE, 0x22, 0x3B, 0x77, 0x63, 0x04, 0xB7, 0x8F, 0x86, 0xEF, 0x37, 0x46, 0xD0, \n\t0x83, 0xAE, 0x89, 0x82, 0xC1, 0x18, 0xC1, 0x0C, 0xE2, 0x27, 0x0C, 0x06, 0x63, 0x04, 0x6D, 0xCB, \n\t0xAA, 0x38, 0x18, 0x8C, 0x11, 0xE4, 0xF1, 0x78, 0xFA, 0xBF, 0x30, 0x46, 0x00, 0x82, 0x20, 0x88, \n\t0xFF, 0xC2, 0x18, 0x01, 0x08, 0x82, 0x20, 0x08, 0x0A, 0x63, 0x04, 0x20, 0x08, 0x82, 0x28, 0x18, \n\t0x8C, 0x11, 0xB8, 0x7D, 0x2C, 0xDA, 0xBF, 0x30, 0x46, 0xE0, 0xF6, 0xB1, 0x68, 0x7F, 0x63, 0x04, \n\t0x64, 0xC9, 0xEB, 0xF7, 0x37, 0x46, 0xD0, 0x9A, 0x73, 0x9E, 0x82, 0xC1, 0x18, 0x01, 0x08, 0x82, \n\t0xA0, 0x18, 0x0E, 0x63, 0x04, 0xE7, 0x9C, 0xB3, 0x29, 0x38, 0x8C, 0x11, 0x80, 0x20, 0x08, 0xA2, \n\t0xDF, 0x18, 0x41, 0xC9, 0xEB, 0x23, 0x08, 0x06, 0x63, 0x04, 0x20, 0x08, 0x82, 0xE0, 0x37, 0x46, \n\t0x70, 0xFB, 0x68, 0x08, 0x82, 0xC1, 0x18, 0x01, 0x08, 0x82, 0x20, 0xEE, 0x8D, 0x11, 0x80, 0x20, \n\t0x08, 0xC2, 0xDE, 0x18, 0x01, 0x08, 0x82, 0x60, 0x0A, 0x06, 0x63, 0x04, 0x3A, 0x6B, 0xCE, 0xF1, \n\t0x37, 0x46, 0xC0, 0x9A, 0x73, 0x4E, 0x7F, 0x63, 0x04, 0x73, 0xCE, 0x9A, 0xF3, 0x37, 0x46, 0x60, \n\t0xCE, 0x39, 0x6B, 0x7F, 0x63, 0x04, 0xAD, 0x39, 0xE7, 0xF4, 0x37, 0x46, 0x70, 0xCE, 0x39, 0x9B, \n\t0x82, 0xC1, 0x18, 0x01, 0x08, 0x82, 0xA0, 0x08, 0x06, 0x63, 0x04, 0x73, 0xCE, 0x9A, 0xEB, 0x37, \n\t0x46, 0x00, 0x82, 0x20, 0xC8, 0x7F, 0x63, 0x04, 0x3A, 0x6B, 0xCE, 0xE1, 0x37, 0x46, 0xE0, 0xF6, \n\t0xB1, 0x08, 0x82, 0xC1, 0x18, 0x41, 0xAC, 0xFF, 0xFF, 0x5D, 0x06, 0x63, 0x04, 0xB2, 0xFE, 0xFF, \n\t0x77, 0x19, 0x8C, 0x11, 0xA8, 0xFC, 0xFF, 0xDF, 0x65, 0x30, 0x46, 0xB0, 0xF2, 0xFF, 0x7F, 0x97, \n\t0xC1, 0x18, 0x81, 0xE8, 0xFF, 0xFF, 0x5D, 0x06, 0x63, 0x04, 0xA3, 0xFF, 0xFF, 0x77, 0x19, 0x8C, \n\t0x11, 0xEC, 0xFF, 0xFF, 0xDF, 0x65, 0x30, 0x46, 0xC0, 0xFF, 0xFF, 0x7F, 0x97, 0xC1, 0x18, 0x01, \n\t0x08, 0x82, 0xA4, 0x1B, 0x06, 0x63, 0x04, 0x20, 0x08, 0xA2, 0x66, 0x18, 0x8C, 0x11, 0x80, 0x20, \n\t0x08, 0xC2, 0xDF, 0x18, 0x01, 0x08, 0x82, 0x20, 0xFE, 0x8D, 0x00, 0x8C, 0x11, 0x80, 0x20, 0x08, \n\t0x92, 0x60, 0x30, 0x46, 0x00, 0x82, 0x20, 0x08, 0x82, 0xC1, 0x18, 0x01, 0x08, 0x82, 0x20, 0x7E, \n\t0x01, 0x00, 0x23, 0x06, 0x09, 0x00, 0x82, 0x60, 0x80, 0xCD, 0x82, 0x1F, 0x84, 0xC2, 0x2B, 0xBC, \n\t0xC2, 0x28, 0x8C, 0x18, 0x24, 0x00, 0x08, 0x82, 0x01, 0xA2, 0x0B, 0xAD, 0x00, 0x0B, 0xB0, 0x20, \n\t0x0B, 0x7E, 0x30, 0x62, 0x90, 0x00, 0x20, 0x08, 0x06, 0xC8, 0x2E, 0xB8, 0x42, 0x2C, 0xC4, 0x02, \n\t0x29, 0xFC, 0x81, 0x09, 0x74, 0x20, 0x1F, 0x0B, 0xE0, 0x00, 0x3E, 0x36, 0xD8, 0x81, 0x7C, 0x2C, \n\t0x88, 0x03, 0xF8, 0x58, 0x1C, 0x04, 0xF1, 0x31, 0x82, 0x90, 0x8F, 0x0D, 0x83, 0x7C, 0x4C, 0x98, \n\t0x03, 0xF8, 0x58, 0x20, 0xC0, 0x67, 0xC4, 0xC0, 0x00, 0x40, 0x10, 0x0C, 0x22, 0x71, 0x58, 0x85, \n\t0xC0, 0x92, 0x80, 0x3E, 0x76, 0x08, 0xF4, 0xB1, 0x68, 0xA0, 0xCF, 0x88, 0x01, 0x02, 0x80, 0x20, \n\t0x18, 0x54, 0xE4, 0xA0, 0x0A, 0x02, 0x28, 0x50, 0x23, 0x06, 0x08, 0x00, 0x82, 0x60, 0x50, 0x95, \n\t0xC3, 0x2A, 0x08, 0x79, 0x10, 0x8C, 0x18, 0x20, 0x00, 0x08, 0x82, 0x41, 0x65, 0x0E, 0xAC, 0x40, \n\t0xE4, 0x81, 0x35, 0x62, 0x80, 0x00, 0x20, 0x08, 0x06, 0xD5, 0x39, 0xB4, 0x02, 0x31, 0x0A, 0xC1, \n\t0x2C, 0x41, 0x30, 0x50, 0x61, 0x98, 0x06, 0xD0, 0xBF, 0x81, 0x30, 0x50, 0x01, 0xC8, 0x01, 0x90, \n\t0xBF, 0x81, 0x30, 0x50, 0x01, 0xD0, 0x01, 0xF0, 0xBE, 0x81, 0x30, 0x50, 0x01, 0xD8, 0x01, 0xF0, \n\t0xBE, 0x81, 0x30, 0x50, 0x01, 0xE0, 0x01, 0xF0, 0xBE, 0x81, 0x30, 0x50, 0x01, 0xE8, 0x01, 0xF0, \n\t0xBE, 0x81, 0x30, 0x1C, 0x11, 0x80, 0x82, 0xF0, 0xCD, 0x32, 0x0C, 0x42, 0x60, 0x86, 0x23, 0x1F, \n\t0x3B, 0x16, 0xF9, 0x18, 0xA2, 0xC8, 0xC7, 0x84, 0x51, 0x80, 0x8F, 0x09, 0xA3, 0x00, 0x1F, 0x1B, \n\t0x05, 0x22, 0x3E, 0x23, 0x06, 0x07, 0x00, 0x82, 0x60, 0xF0, 0xE0, 0x03, 0x2E, 0x84, 0x01, 0x3C, \n\t0x8C, 0x26, 0x04, 0x80, 0x15, 0x41, 0x7C, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0xD2, 0x87, \n\t0x5C, 0x48, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0xDA, 0x07, 0x5D, 0x10, 0x46, 0x0C, 0x0C, \n\t0x00, 0x04, 0xC1, 0x20, 0xE2, 0x87, 0x5D, 0x38, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0xEA, \n\t0x87, 0x5E, 0x60, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0xF2, 0x07, 0x5F, 0x28, 0x46, 0x0C, \n\t0x0C, 0x00, 0x04, 0xC1, 0x20, 0xFA, 0x87, 0x5F, 0x50, 0x6C, 0x18, 0xE4, 0x63, 0xC3, 0x20, 0x1F, \n\t0x1B, 0x06, 0xF9, 0x98, 0xF1, 0x06, 0xF2, 0x31, 0x03, 0x0E, 0xE4, 0x63, 0x46, 0x1C, 0xC8, 0xC7, \n\t0xE6, 0x60, 0x88, 0x8F, 0xD1, 0xC1, 0x10, 0x1F, 0xAB, 0x83, 0x21, 0x3E, 0x96, 0x0C, 0xF2, 0xB1, \n\t0x64, 0x90, 0x8F, 0x25, 0x83, 0x7C, 0x2C, 0xEA, 0x03, 0xF9, 0x58, 0x30, 0xC1, 0xC7, 0x24, 0x50, \n\t0x90, 0x8F, 0x09, 0x01, 0x7C, 0x2C, 0x18, 0x05, 0xF8, 0x5C, 0x60, 0xA6, 0x02, 0x96, 0xC0, 0x0A, \n\t0x04, 0xAE, 0x20, 0x1E, 0xA4, 0x82, 0x96, 0xC0, 0x0A, 0x04, 0xAE, 0x80, 0x1E, 0xA4, 0x02, 0x7B, \n\t0xC0, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x31, 0xAF, 0x00, 0x9F, 0x0B, 0xCC, 0x54, 0x70, 0x13, 0x58, \n\t0x81, 0xC0, 0x15, 0xF0, 0x83, 0x54, 0x80, 0x13, 0x58, 0x81, 0xC0, 0x15, 0xFC, 0x83, 0x54, 0x10, \n\t0x12, 0x58, 0x81, 0xC0, 0x17, 0x80, 0x32, 0x26, 0x88, 0x8F, 0x05, 0x9E, 0x7C, 0x2C, 0xEB, 0x05, \n\t0xF8, 0x5C, 0x60, 0xA6, 0x02, 0xB2, 0xC0, 0x0A, 0x04, 0xAE, 0x20, 0x25, 0xA4, 0x82, 0xB2, 0xC0, \n\t0x0A, 0x04, 0xAE, 0x80, 0x25, 0xA4, 0x02, 0x97, 0xC0, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x91, 0x41, \n\t0x3A, 0xC0, 0xE7, 0x02, 0x33, 0x15, 0xBC, 0x05, 0x56, 0x20, 0x70, 0x05, 0x34, 0x21, 0x15, 0xC0, \n\t0x05, 0x56, 0x20, 0x70, 0x05, 0x37, 0x21, 0x15, 0xE4, 0x04, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x8C, \n\t0x09, 0xE2, 0x63, 0x81, 0x1D, 0xC8, 0xC7, 0x82, 0x01, 0x3E, 0x16, 0xB0, 0x83, 0x7C, 0x6C, 0xEB, \n\t0xE0, 0x63, 0xC1, 0x10, 0x1F, 0x0B, 0xDE, 0x41, 0x3E, 0x16, 0xEC, 0x81, 0x7C, 0x2C, 0x28, 0xE0, \n\t0x63, 0x78, 0xE0, 0x0F, 0xF0, 0xB9, 0xC0, 0x4C, 0x05, 0xA3, 0x81, 0x15, 0x08, 0x5C, 0x01, 0x5A, \n\t0x48, 0x05, 0xA4, 0x81, 0x15, 0x08, 0x5C, 0xC1, 0x5A, 0x48, 0x05, 0x6D, 0x81, 0x15, 0x08, 0x7C, \n\t0x01, 0x28, 0x1B, 0x05, 0x95, 0x80, 0xCF, 0x05, 0x66, 0x2A, 0x70, 0x0D, 0xAC, 0x40, 0xE0, 0x0A, \n\t0xE6, 0x42, 0x2A, 0x78, 0x0D, 0xAC, 0x40, 0xE0, 0x0A, 0xEC, 0x42, 0x2A, 0xC0, 0x0B, 0xAC, 0x40, \n\t0xE0, 0x0B, 0x40, 0x19, 0x13, 0xC4, 0xC7, 0x82, 0x5A, 0x90, 0x8F, 0xC1, 0x02, 0x4E, 0xC0, 0xE7, \n\t0x02, 0x33, 0x15, 0xEC, 0x06, 0x56, 0x20, 0x70, 0x05, 0xA0, 0x21, 0x15, 0xF0, 0x06, 0x56, 0x20, \n\t0x70, 0x05, 0xA3, 0x21, 0x15, 0x94, 0x06, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x6C, 0x17, 0xC8, 0x02, \n\t0x3E, 0x17, 0x98, 0xA9, 0xC0, 0x3C, 0xB0, 0x02, 0x81, 0x2B, 0x58, 0x0D, 0xA9, 0xE0, 0x3C, 0xB0, \n\t0x02, 0x81, 0x2B, 0x70, 0x0D, 0xA9, 0x00, 0x36, 0xB0, 0x02, 0x81, 0x2F, 0x00, 0x65, 0x4C, 0x10, \n\t0x1F, 0x0B, 0xDA, 0x41, 0x3E, 0x16, 0x0C, 0xF0, 0xB1, 0x60, 0x2C, 0xE4, 0x63, 0x5B, 0x07, 0x1F, \n\t0x0B, 0x86, 0xF8, 0x58, 0x60, 0x16, 0xF2, 0xB1, 0x40, 0x1E, 0xE4, 0x63, 0x41, 0x01, 0x1F, 0xC3, \n\t0x83, 0x20, 0x3E, 0x46, 0x0F, 0x81, 0x7C, 0x2C, 0x18, 0xE0, 0x63, 0x41, 0x5C, 0xC8, 0xC7, 0x62, \n\t0xA2, 0x2F, 0xE4, 0x63, 0x2A, 0xE1, 0x17, 0xF2, 0xB1, 0x97, 0xF8, 0x0B, 0xF9, 0x8C, 0x18, 0x1C, \n\t0x00, 0x08, 0x82, 0xC1, 0x63, 0x22, 0xE6, 0xF1, 0x16, 0xFE, 0x31, 0x9A, 0x10, 0x00, 0x46, 0x04, \n\t0xF1, 0x19, 0x31, 0x30, 0x00, 0x10, 0x04, 0x83, 0x08, 0x45, 0xCE, 0xC3, 0x18, 0x31, 0x30, 0x00, \n\t0x10, 0x04, 0x83, 0x28, 0x45, 0xD0, 0x43, 0x18, 0x31, 0x30, 0x00, 0x10, 0x04, 0x83, 0x48, 0x45, \n\t0xD2, 0xC3, 0x18, 0x31, 0x30, 0x00, 0x10, 0x04, 0x83, 0x68, 0x45, 0xD6, 0x23, 0x19, 0x31, 0x30, \n\t0x00, 0x10, 0x04, 0x83, 0x88, 0x45, 0xD8, 0xA3, 0x18, 0x31, 0x30, 0x00, 0x10, 0x04, 0x83, 0xA8, \n\t0x45, 0xDA, 0x23, 0xB1, 0x61, 0x90, 0x8F, 0x0D, 0x83, 0x7C, 0x6C, 0x18, 0xE4, 0x63, 0x46, 0x5F, \n\t0xC8, 0xC7, 0x0C, 0xBF, 0x90, 0x8F, 0x19, 0x7F, 0x21, 0x1F, 0x0B, 0x8D, 0x21, 0x3E, 0x26, 0x1A, \n\t0x43, 0x7C, 0x6C, 0x34, 0x86, 0xF8, 0x58, 0x32, 0xC8, 0xC7, 0x92, 0x41, 0x3E, 0x96, 0x0C, 0xF2, \n\t0xB1, 0x68, 0x35, 0xE4, 0x63, 0xC1, 0x04, 0x1F, 0x93, 0x5C, 0x43, 0x3E, 0x26, 0x04, 0xF0, 0xB1, \n\t0x20, 0x36, 0xE0, 0x73, 0x81, 0x99, 0x0A, 0x74, 0x04, 0x2B, 0x10, 0xB8, 0x82, 0xFF, 0x90, 0x0A, \n\t0x76, 0x04, 0x2B, 0x10, 0xB8, 0x02, 0x11, 0x91, 0x0A, 0x48, 0x04, 0x2B, 0x10, 0xF8, 0x02, 0x50, \n\t0xC6, 0xF4, 0x06, 0x7C, 0x2E, 0x30, 0x53, 0x41, 0x99, 0x60, 0x05, 0x02, 0x57, 0xA0, 0x22, 0x52, \n\t0x81, 0x99, 0x60, 0x05, 0x02, 0x57, 0xD0, 0x22, 0x52, 0xC1, 0x8B, 0x60, 0x05, 0x02, 0x5F, 0x00, \n\t0xCA, 0x98, 0x20, 0x3E, 0x16, 0x78, 0xF2, 0xB1, 0x6C, 0x3D, 0xE0, 0x73, 0x81, 0x99, 0x0A, 0xE4, \n\t0x04, 0x2B, 0x10, 0xB8, 0x82, 0x1B, 0x91, 0x0A, 0xE6, 0x04, 0x2B, 0x10, 0xB8, 0x02, 0x1D, 0x91, \n\t0x0A, 0x78, 0x04, 0x2B, 0x10, 0xF8, 0x02, 0x50, 0x46, 0x06, 0xF7, 0x01, 0x9F, 0x0B, 0xCC, 0x54, \n\t0xD0, 0x27, 0x58, 0x81, 0xC0, 0x15, 0x88, 0x89, 0x54, 0xE0, 0x27, 0x58, 0x81, 0xC0, 0x15, 0x94, \n\t0x89, 0x54, 0x70, 0x26, 0x58, 0x81, 0xC0, 0x17, 0x80, 0x32, 0x26, 0x88, 0x8F, 0x05, 0x76, 0x20, \n\t0x1F, 0x0B, 0x06, 0xF8, 0x58, 0xA0, 0x1F, 0xF2, 0xB1, 0xAD, 0x83, 0x8F, 0x05, 0x43, 0x7C, 0x2C, \n\t0xE8, 0x0F, 0xF9, 0x58, 0xB0, 0x07, 0xF2, 0xB1, 0xA0, 0x80, 0x8F, 0xE1, 0x01, 0x8B, 0xC0, 0xE7, \n\t0x02, 0x33, 0x15, 0xC4, 0x0A, 0x56, 0x20, 0x70, 0x05, 0x76, 0x22, 0x15, 0xC8, 0x0A, 0x56, 0x20, \n\t0x70, 0x05, 0x79, 0x22, 0x15, 0xEC, 0x09, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x6C, 0x14, 0x70, 0x04, \n\t0x3E, 0x17, 0x98, 0xA9, 0x80, 0x57, 0xB0, 0x02, 0x81, 0x2B, 0x08, 0x15, 0xA9, 0xA0, 0x57, 0xB0, \n\t0x02, 0x81, 0x2B, 0x20, 0x15, 0xA9, 0xC0, 0x54, 0xB0, 0x02, 0x81, 0x2F, 0x00, 0x65, 0x4C, 0x10, \n\t0x1F, 0x0B, 0x6A, 0x41, 0x3E, 0x06, 0x0B, 0x66, 0x02, 0x9F, 0x0B, 0xCC, 0x54, 0x90, 0x2E, 0x58, \n\t0x81, 0xC0, 0x15, 0xB8, 0x8A, 0x54, 0xA0, 0x2E, 0x58, 0x81, 0xC0, 0x15, 0xC4, 0x8A, 0x54, 0x30, \n\t0x2B, 0x58, 0x81, 0xC0, 0x17, 0x80, 0xB2, 0x5D, 0x90, 0x13, 0xF8, 0x5C, 0x60, 0xA6, 0x02, 0x7A, \n\t0xC1, 0x0A, 0x04, 0xAE, 0x20, 0x57, 0xA4, 0x82, 0x7A, 0xC1, 0x0A, 0x04, 0xAE, 0x80, 0x57, 0xA4, \n\t0x02, 0x5F, 0xC1, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x31, 0x41, 0x7C, 0x2C, 0x68, 0x07, 0xF9, 0x58, \n\t0x30, 0xC0, 0xC7, 0x82, 0x38, 0x91, 0x8F, 0x6D, 0x1D, 0x7C, 0x2C, 0x18, 0xE2, 0x63, 0x01, 0x9D, \n\t0xC8, 0xC7, 0x02, 0x79, 0x90, 0x8F, 0x05, 0x05, 0x7C, 0x0C, 0x0F, 0x82, 0xF8, 0x18, 0x3D, 0x04, \n\t0xF2, 0xB1, 0x60, 0x80, 0x8F, 0x05, 0xBB, 0x22, 0x1F, 0x0B, 0x5E, 0x02, 0x3E, 0x06, 0x26, 0xEA, \n\t0x22, 0x1F, 0x5B, 0x89, 0x5E, 0x91, 0x8F, 0xF9, 0x08, 0xBB, 0xC8, 0x67, 0xC4, 0xE0, 0x00, 0x40, \n\t0x10, 0x0C, 0x9E, 0x9A, 0xA9, 0x17, 0x3F, 0x69, 0x99, 0xD1, 0x84, 0x00, 0x30, 0x22, 0x88, 0xCF, \n\t0x88, 0x81, 0x01, 0x80, 0x20, 0x18, 0x44, 0x37, 0x63, 0x2F, 0xC6, 0x88, 0x81, 0x01, 0x80, 0x20, \n\t0x18, 0x44, 0x38, 0x73, 0x2F, 0xC2, 0x88, 0x81, 0x01, 0x80, 0x20, 0x18, 0x44, 0x39, 0x83, 0x2F, \n\t0xC6, 0x88, 0x81, 0x01, 0x80, 0x20, 0x18, 0x44, 0x3A, 0xA3, 0x2F, 0xC9, 0x88, 0x81, 0x01, 0x80, \n\t0x20, 0x18, 0x44, 0x3B, 0xB3, 0x2F, 0xC5, 0x88, 0x81, 0x01, 0x80, 0x20, 0x18, 0x44, 0x3C, 0xC3, \n\t0x2F, 0x89, 0x0D, 0x83, 0x7C, 0x6C, 0x18, 0xE4, 0x63, 0xC3, 0x20, 0x1F, 0x33, 0x58, 0x45, 0x3E, \n\t0x66, 0xB4, 0x8A, 0x7C, 0xCC, 0x70, 0x15, 0xF9, 0x18, 0xAC, 0x0C, 0xF1, 0xB1, 0x58, 0x19, 0xE2, \n\t0x63, 0xB2, 0x32, 0xC4, 0xC7, 0x92, 0x41, 0x3E, 0x96, 0x0C, 0xF2, 0xB1, 0x64, 0x90, 0x8F, 0x45, \n\t0xBA, 0x22, 0x1F, 0x0B, 0x26, 0xF8, 0x98, 0xD4, 0x2B, 0xF2, 0x31, 0x21, 0x80, 0x8F, 0x05, 0xE0, \n\t0x02, 0x9F, 0x0B, 0xCC, 0x54, 0x90, 0x36, 0x58, 0x81, 0xC0, 0x15, 0xB8, 0x8C, 0x54, 0xA0, 0x36, \n\t0x58, 0x81, 0xC0, 0x15, 0xC4, 0x8C, 0x54, 0x30, 0x33, 0x58, 0x81, 0xC0, 0x17, 0x80, 0x32, 0x86, \n\t0x5D, 0xE0, 0x73, 0x81, 0x99, 0x0A, 0xE8, 0x06, 0x2B, 0x10, 0xB8, 0x82, 0x9C, 0x91, 0x0A, 0xEA, \n\t0x06, 0x2B, 0x10, 0xB8, 0x02, 0x9E, 0x91, 0x0A, 0x7C, 0x06, 0x2B, 0x10, 0xF8, 0x02, 0x50, 0xC6, \n\t0x04, 0xF1, 0xB1, 0xC0, 0x93, 0x8F, 0x65, 0xFA, 0x02, 0x9F, 0x0B, 0xCC, 0x54, 0x10, 0x3A, 0x58, \n\t0x81, 0xC0, 0x15, 0x98, 0x8D, 0x54, 0x20, 0x3A, 0x58, 0x81, 0xC0, 0x15, 0xA4, 0x8D, 0x54, 0xB0, \n\t0x36, 0x58, 0x81, 0xC0, 0x17, 0x80, 0x32, 0x32, 0x30, 0x19, 0xF8, 0x5C, 0x60, 0xA6, 0x02, 0xD6, \n\t0xC1, 0x0A, 0x04, 0xAE, 0x20, 0x6E, 0xA4, 0x82, 0xD6, 0xC1, 0x0A, 0x04, 0xAE, 0x80, 0x6E, 0xA4, \n\t0x02, 0xBB, 0xC1, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x31, 0x41, 0x7C, 0x2C, 0xB0, 0x03, 0xF9, 0x58, \n\t0x30, 0xC0, 0xC7, 0x82, 0x94, 0x91, 0x8F, 0x6D, 0x1D, 0x7C, 0x2C, 0x18, 0xE2, 0x63, 0x01, 0xCB, \n\t0xC8, 0xC7, 0x82, 0x3D, 0x90, 0x8F, 0x05, 0x05, 0x7C, 0x0C, 0x0F, 0x76, 0x06, 0x3E, 0x17, 0x98, \n\t0xA9, 0x00, 0x7C, 0xB0, 0x02, 0x81, 0x2B, 0x28, 0x1D, 0xA9, 0x20, 0x7C, 0xB0, 0x02, 0x81, 0x2B, \n\t0x40, 0x1D, 0xA9, 0x40, 0x75, 0xB0, 0x02, 0x81, 0x2F, 0x00, 0x65, 0xA3, 0x70, 0x36, 0xF0, 0xB9, \n\t0xC0, 0x4C, 0x05, 0xEB, 0x83, 0x15, 0x08, 0x5C, 0x01, 0xEC, 0x48, 0x05, 0xEC, 0x83, 0x15, 0x08, \n\t0x5C, 0xC1, 0xEC, 0x48, 0x05, 0xB5, 0x83, 0x15, 0x08, 0x7C, 0x01, 0x28, 0x63, 0x82, 0xF8, 0x58, \n\t0x50, 0x0B, 0xF2, 0x31, 0x58, 0xA8, 0x1B, 0xF8, 0x5C, 0x60, 0xA6, 0x02, 0xFC, 0xC1, 0x0A, 0x04, \n\t0xAE, 0xA0, 0x77, 0xA4, 0x82, 0xFC, 0xC1, 0x0A, 0x04, 0xAE, 0x00, 0x7C, 0xA4, 0x02, 0xF1, 0xC1, \n\t0x0A, 0x04, 0xBE, 0x00, 0x94, 0xED, 0x42, 0xE8, 0xC0, 0xE7, 0x02, 0x33, 0x15, 0x8C, 0x10, 0x56, \n\t0x20, 0x70, 0x05, 0xE8, 0x23, 0x15, 0x90, 0x10, 0x56, 0x20, 0x70, 0x05, 0xEB, 0x23, 0x15, 0xB4, \n\t0x0F, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x8C, 0x09, 0xE2, 0x63, 0x41, 0x3B, 0xC8, 0xC7, 0x82, 0x01, \n\t0x3E, 0x16, 0x80, 0x8E, 0x7C, 0x6C, 0xEB, 0xE0, 0x63, 0xC1, 0x10, 0x1F, 0x0B, 0x46, 0x47, 0x3E, \n\t0x16, 0xC8, 0x83, 0x7C, 0x2C, 0x28, 0xE0, 0x63, 0x78, 0x10, 0xC4, 0xC7, 0xE8, 0x21, 0x90, 0x8F, \n\t0x05, 0x03, 0x7C, 0x2C, 0x40, 0x1F, 0xF9, 0xD8, 0x4B, 0x04, 0xF0, 0xB1, 0xB7, 0xC1, 0x1F, 0xF9, \n\t0xD8, 0x4A, 0xA8, 0x8F, 0x7C, 0xAC, 0x6D, 0xF4, 0x47, 0x3E, 0x23, 0x06, 0x07, 0x00, 0x82, 0x60, \n\t0xF0, 0x90, 0x11, 0x09, 0xB5, 0x0E, 0x0F, 0x8D, 0x26, 0x04, 0x80, 0x11, 0x41, 0x7C, 0x46, 0x0C, \n\t0x0C, 0x00, 0x04, 0xC1, 0x20, 0x32, 0xA3, 0x12, 0x32, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, \n\t0x3A, 0x23, 0x13, 0x12, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0x42, 0xA3, 0x13, 0x32, 0x46, \n\t0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0x4A, 0xA3, 0x14, 0x4A, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, \n\t0x20, 0x52, 0x23, 0x15, 0x2A, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0x5A, 0xA3, 0x15, 0x4A, \n\t0x6C, 0x18, 0xE4, 0x63, 0xC3, 0x20, 0x1F, 0x1B, 0x06, 0xF9, 0x98, 0xB1, 0x3B, 0xF2, 0x31, 0x83, \n\t0x77, 0xE4, 0x63, 0x46, 0xEF, 0xC8, 0xC7, 0x7E, 0x67, 0x88, 0x8F, 0x81, 0xCF, 0x10, 0x1F, 0x0B, \n\t0x9F, 0x21, 0x3E, 0x96, 0x0C, 0xF2, 0xB1, 0x64, 0x90, 0x8F, 0x25, 0x83, 0x7C, 0x2C, 0x4A, 0x1F, \n\t0xF9, 0x58, 0x30, 0xC1, 0xC7, 0x24, 0xF6, 0x91, 0x8F, 0x09, 0x01, 0x7C, 0x2C, 0x78, 0x1F, 0xF8, \n\t0x5C, 0x60, 0xA6, 0x02, 0x3C, 0xC2, 0x0A, 0x04, 0xAE, 0xA0, 0x87, 0xA4, 0x82, 0x3C, 0xC2, 0x0A, \n\t0x04, 0xAE, 0x00, 0x8C, 0xA4, 0x02, 0x31, 0xC2, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x31, 0xFB, 0x03, \n\t0x9F, 0x0B, 0xCC, 0x54, 0x30, 0x4A, 0x58, 0x81, 0xC0, 0x15, 0xA0, 0x91, 0x54, 0x40, 0x4A, 0x58, \n\t0x81, 0xC0, 0x15, 0xAC, 0x91, 0x54, 0xD0, 0x46, 0x58, 0x81, 0xC0, 0x17, 0x80, 0x32, 0x26, 0x88, \n\t0x8F, 0x05, 0x9E, 0x7C, 0x2C, 0x4B, 0x21, 0xF8, 0x5C, 0x60, 0xA6, 0x02, 0x58, 0xC2, 0x0A, 0x04, \n\t0xAE, 0xA0, 0x8E, 0xA4, 0x82, 0x58, 0xC2, 0x0A, 0x04, 0xAE, 0x00, 0x8F, 0xA4, 0x02, 0x3D, 0xC2, \n\t0x0A, 0x04, 0xBE, 0x00, 0x94, 0x91, 0x41, 0x0D, 0xC1, 0xE7, 0x02, 0x33, 0x15, 0xEC, 0x12, 0x56, \n\t0x20, 0x70, 0x05, 0xA0, 0x24, 0x15, 0xF0, 0x12, 0x56, 0x20, 0x70, 0x05, 0xA3, 0x24, 0x15, 0x94, \n\t0x12, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x8C, 0x09, 0xE2, 0x63, 0x81, 0x1D, 0xC8, 0xC7, 0x82, 0x01, \n\t0x3E, 0x16, 0xE0, 0x90, 0x7C, 0x6C, 0xEB, 0xE0, 0x63, 0xC1, 0x10, 0x1F, 0x0B, 0x76, 0x48, 0x3E, \n\t0x16, 0xEC, 0x81, 0x7C, 0x2C, 0x28, 0xE0, 0x63, 0x78, 0xA0, 0x46, 0xF0, 0xB9, 0xC0, 0x4C, 0x05, \n\t0xEF, 0x84, 0x15, 0x08, 0x5C, 0x01, 0x2D, 0x49, 0x05, 0xF0, 0x84, 0x15, 0x08, 0x5C, 0xC1, 0x2D, \n\t0x49, 0x05, 0xB9, 0x84, 0x15, 0x08, 0x7C, 0x01, 0x28, 0x1B, 0x05, 0x3B, 0x82, 0xCF, 0x05, 0x66, \n\t0x2A, 0xD0, 0x27, 0xAC, 0x40, 0xE0, 0x0A, 0x7E, 0x49, 0x2A, 0xD8, 0x27, 0xAC, 0x40, 0xE0, 0x0A, \n\t0xC4, 0x49, 0x2A, 0x20, 0x27, 0xAC, 0x40, 0xE0, 0x0B, 0x40, 0x19, 0x13, 0xC4, 0xC7, 0x82, 0x5A, \n\t0x90, 0x8F, 0xC1, 0x02, 0x29, 0xC1, 0xE7, 0x02, 0x33, 0x15, 0x9C, 0x14, 0x56, 0x20, 0x70, 0x05, \n\t0xEC, 0x24, 0x15, 0xA0, 0x14, 0x56, 0x20, 0x70, 0x05, 0xEF, 0x24, 0x15, 0xC4, 0x13, 0x56, 0x20, \n\t0xF0, 0x05, 0xA0, 0x6C, 0x17, 0x60, 0x09, 0x3E, 0x17, 0x98, 0xA9, 0x40, 0xA6, 0xB0, 0x02, 0x81, \n\t0x2B, 0xB8, 0x27, 0xA9, 0x60, 0xA6, 0xB0, 0x02, 0x81, 0x2B, 0xD0, 0x27, 0xA9, 0x80, 0x9F, 0xB0, \n\t0x02, 0x81, 0x2F, 0x00, 0x65, 0x4C, 0x10, 0x1F, 0x0B, 0xDA, 0x41, 0x3E, 0x16, 0x0C, 0xF0, 0xB1, \n\t0xE0, 0x95, 0xE4, 0x63, 0x5B, 0x07, 0x1F, 0x0B, 0x86, 0xF8, 0x58, 0x20, 0x4B, 0xF2, 0xB1, 0x40, \n\t0x1E, 0xE4, 0x63, 0x41, 0x01, 0x1F, 0xC3, 0x83, 0x20, 0x3E, 0x46, 0x0F, 0x81, 0x7C, 0x2C, 0x18, \n\t0xE0, 0x63, 0x41, 0x3D, 0xC9, 0xC7, 0x5E, 0x22, 0x80, 0x8F, 0xF9, 0x91, 0x49, 0xC9, 0xC7, 0x56, \n\t0x62, 0x9D, 0xE4, 0x63, 0x7C, 0x84, 0x52, 0xF2, 0x19, 0x31, 0x38, 0x00, 0x10, 0x04, 0x83, 0x67, \n\t0xAE, 0x66, 0x8A, 0x97, 0xD6, 0x6A, 0x34, 0x21, 0x00, 0x8C, 0x08, 0xE2, 0x33, 0x62, 0x60, 0x00, \n\t0x20, 0x08, 0x06, 0x51, 0x5D, 0xD1, 0x94, 0x31, 0x62, 0x60, 0x00, 0x20, 0x08, 0x06, 0x91, 0x5D, \n\t0xD5, 0x94, 0x30, 0x62, 0x60, 0x00, 0x20, 0x08, 0x06, 0xD1, 0x5D, 0xD9, 0x94, 0x31, 0x62, 0x60, \n\t0x00, 0x20, 0x08, 0x06, 0x11, 0x5E, 0xE1, 0x54, 0x32, 0x62, 0x60, 0x00, 0x20, 0x08, 0x06, 0x51, \n\t0x5E, 0xE5, 0x54, 0x31, 0x62, 0x60, 0x00, 0x20, 0x08, 0x06, 0x91, 0x5E, 0xE9, 0x54, 0x62, 0xC3, \n\t0x20, 0x1F, 0x1B, 0x06, 0xF9, 0xD8, 0x30, 0xC8, 0xC7, 0x0C, 0x75, 0x92, 0x8F, 0x19, 0xEB, 0x24, \n\t0x1F, 0x33, 0xD8, 0x49, 0x3E, 0xE6, 0x4E, 0x43, 0x7C, 0xEC, 0x9D, 0x86, 0xF8, 0x18, 0x3C, 0x0D, \n\t0xF1, 0xB1, 0x64, 0x90, 0x8F, 0x25, 0x83, 0x7C, 0x2C, 0x19, 0xE4, 0x63, 0x11, 0x3E, 0xC9, 0xC7, \n\t0x82, 0x09, 0x3E, 0x26, 0xED, 0x93, 0x7C, 0x4C, 0x08, 0xE0, 0x63, 0x81, 0x3F, 0xC1, 0xE7, 0x02, \n\t0x33, 0x15, 0x9C, 0x16, 0x56, 0x20, 0x70, 0x05, 0x6C, 0x25, 0x15, 0xA0, 0x16, 0x56, 0x20, 0x70, \n\t0x05, 0x6F, 0x25, 0x15, 0xC4, 0x15, 0x56, 0x20, 0xF0, 0x05, 0xA0, 0x8C, 0x51, 0x29, 0xF8, 0x5C, \n\t0x60, 0xA6, 0x02, 0xD9, 0xC2, 0x0A, 0x04, 0xAE, 0xE0, 0xAE, 0xA4, 0x82, 0xD9, 0xC2, 0x0A, 0x04, \n\t0xAE, 0x40, 0xAF, 0xA4, 0x02, 0xBE, 0xC2, 0x0A, 0x04, 0xBE, 0x00, 0x94, 0x31, 0x41, 0x7C, 0x2C, \n\t0xF0, 0xE4, 0x63, 0x19, 0x4E, 0xC1, 0xE7, 0x02, 0x33, 0x15, 0xFC, 0x16, 0x56, 0x20, 0x70, 0x05, \n\t0xA4, 0x25, 0x15, 0x80, 0x17, 0x56, 0x20, 0x70, 0x05, 0xA7, 0x25, 0x15, 0xA4, 0x16, 0x56, 0x20, \n\t0xF0, 0x05, 0xA0, 0x8C, 0x0C, 0xC8, 0x0A, 0x3E, 0x17, 0x98, 0xA9, 0x40, 0xBD, 0xB0, 0x02, 0x81, \n\t0x2B, 0x78, 0x2D, 0xA9, 0x60, 0xBD, 0xB0, 0x02, 0x81, 0x2B, 0x90, 0x2D, 0xA9, 0x80, 0xB6, 0xB0, \n\t0x02, 0x81, 0x2F, 0x00, 0x65, 0x4C, 0x10, 0x1F, 0x0B, 0xEC, 0x40, 0x3E, 0x16, 0x0C, 0xF0, 0xB1, \n\t0xE0, 0xAC, 0xE4, 0x63, 0x5B, 0x07, 0x1F, 0x0B, 0x86, 0xF8, 0x58, 0xA0, 0x56, 0xF2, 0xB1, 0x60, \n\t0x0F, 0xE4, 0x63, 0x41, 0x01, 0x1F, 0xC3, 0x83, 0xBC, 0x82, 0xCF, 0x05, 0x66, 0x2A, 0xF0, 0x2F, \n\t0xAC, 0x40, 0xE0, 0x0A, 0xC6, 0x4B, 0x2A, 0xF8, 0x2F, 0xAC, 0x40, 0xE0, 0x0A, 0xCC, 0x4B, 0x2A, \n\t0x40, 0x2F, 0xAC, 0x40, 0xE0, 0x0B, 0x40, 0xD9, 0x28, 0x94, 0x16, 0x7C, 0x2E, 0x30, 0x53, 0x41, \n\t0x8A, 0x61, 0x05, 0x02, 0x57, 0xE0, 0x5E, 0x52, 0x81, 0x8A, 0x61, 0x05, 0x02, 0x57, 0x10, 0x5F, \n\t0x52, 0xC1, 0x7C, 0x61, 0x05, 0x02, 0x5F, 0x00, 0xCA, 0x98, 0x20, 0x3E, 0x16, 0xD4, 0x82, 0x7C, \n\t0x0C, 0x16, 0x66, 0x0B, 0x3E, 0x17, 0x98, 0xA9, 0xC0, 0xC6, 0xB0, 0x02, 0x81, 0x2B, 0xD8, 0x2F, \n\t0xA9, 0xE0, 0xC6, 0xB0, 0x02, 0x81, 0x2B, 0xF0, 0x2F, 0xA9, 0x00, 0xC4, 0xB0, 0x02, 0x81, 0x2F, \n\t0x00, 0x65, 0xBB, 0xF0, 0x5B, 0xF0, 0xB9, 0xC0, 0x4C, 0x05, 0x61, 0x86, 0x15, 0x08, 0x5C, 0x81, \n\t0x89, 0x49, 0x05, 0x62, 0x86, 0x15, 0x08, 0x5C, 0x41, 0x8A, 0x49, 0x05, 0x2B, 0x86, 0x15, 0x08, \n\t0x7C, 0x01, 0x28, 0x63, 0x82, 0xF8, 0x58, 0xD0, 0x0E, 0xF2, 0xB1, 0x60, 0x80, 0x8F, 0x05, 0xBE, \n\t0x25, 0x1F, 0xDB, 0x3A, 0xF8, 0x58, 0x30, 0xC4, 0xC7, 0x82, 0xF0, 0x92, 0x8F, 0x05, 0xF2, 0x20, \n\t0x1F, 0x0B, 0x0A, 0xF8, 0x18, 0x1E, 0x04, 0xF1, 0x31, 0x7A, 0x08, 0xE4, 0x63, 0xC1, 0x00, 0x1F, \n\t0x0B, 0x46, 0x4C, 0x3E, 0xF6, 0x12, 0x01, 0x7C, 0x2C, 0x20, 0x31, 0xF9, 0x58, 0x6A, 0x05, 0xF0, \n\t0x19, 0x31, 0x38, 0x00, 0x10, 0x04, 0x83, 0xE9, 0xCF, 0xC4, 0x2C, 0x70, 0xAF, 0x11, 0x83, 0x03, \n\t0x00, 0x41, 0x30, 0x98, 0x40, 0x8D, 0xCC, 0x02, 0xF8, 0xB2, 0xE0, 0xC4, 0xE4, 0x63, 0xC2, 0x89, \n\t0xC9, 0xC7, 0x86, 0x13, 0x93, 0x8F, 0xD1, 0xD7, 0x10, 0x1F, 0x43, 0xB1, 0x21, 0x3E, 0x86, 0x62, \n\t0x43, 0x7C, 0x46, 0x0C, 0x0C, 0x00, 0x04, 0xC1, 0x20, 0x42, 0x35, 0x37, 0xBB, 0xAD, 0x11, 0x03, \n\t0x03, 0x00, 0x41, 0x30, 0x88, 0x52, 0xED, 0xCD, 0x6A, 0x6B, 0xC4, 0xC0, 0x00, 0x40, 0x10, 0x0C, \n\t0x22, 0x55, 0x83, 0xB3, 0xDA, 0xB2, 0xE1, 0xCC, 0xE4, 0x63, 0x03, 0x9A, 0xC9, 0xC7, 0x86, 0x34, \n\t0x93, 0x8F, 0x25, 0x03, 0x7C, 0x2C, 0x19, 0xE0, 0x63, 0xC9, 0x00, 0x1F, 0xFB, 0xAD, 0x18, 0x83, \n\t0x8F, 0x05, 0x22, 0x26, 0x9F, 0x11, 0x83, 0x03, 0x00, 0x41, 0x30, 0x98, 0x64, 0xAD, 0xCE, 0x82, \n\t0x10, 0x1B, 0x31, 0x38, 0x00, 0x10, 0x04, 0x83, 0x69, 0xD6, 0xEE, 0x2C, 0x18, 0x31, 0x0B, 0x68, \n\t0x4C, 0x3E, 0x26, 0xD0, 0x98, 0x7C, 0x8C, 0xC4, 0x84, 0xF8, 0x58, 0x8D, 0x11, 0xF1, 0xB1, 0xA1, \n\t0xC6, 0xE0, 0x63, 0x99, 0x8A, 0xC9, 0xC7, 0x54, 0x8C, 0xBD, 0xE2, 0x63, 0x42, 0x20, 0x1F, 0x0B, \n\t0x1E, 0xF9, 0x58, 0x70, 0xC8, 0xC7, 0x06, 0x48, 0x3E, 0x16, 0x20, 0xF2, 0xB1, 0x22, 0x92, 0x8F, \n\t0x05, 0x89, 0x7C, 0xAC, 0xB8, 0x2F, 0xF8, 0x18, 0x71, 0x5F, 0xF0, 0xB1, 0xE1, 0xBE, 0xE0, 0x63, \n\t0xCA, 0x7D, 0xC1, 0xC7, 0xF8, 0x6B, 0xD4, 0xE0, 0x63, 0xFE, 0x25, 0x6E, 0x30, 0x18, 0x6E, 0x08, \n\t0x66, 0x0D, 0x0D, 0x66, 0x19, 0x82, 0x21, 0x18, 0xA8, 0x00, 0x1C, 0x81, 0x7F, 0x83, 0x60, 0xA0, \n\t0x02, 0x70, 0x04, 0xFE, 0x0D, 0x82, 0x81, 0x0A, 0xC0, 0x11, 0xF8, 0x37, 0x08, 0x46, 0x0C, 0x0E, \n\t0x00, 0x04, 0xC1, 0x60, 0x62, 0xB7, 0x57, 0x1B, 0x76, 0x6C, 0xC4, 0xE0, 0x00, 0x40, 0x10, 0x0C, \n\t0xA6, 0x76, 0x83, 0xB5, 0x81, 0xC7, 0x46, 0x0C, 0x0E, 0x00, 0x04, 0xC1, 0x60, 0x72, 0xB7, 0x58, \n\t0x1B, 0x7A, 0x6C, 0xC4, 0xE0, 0x00, 0x40, 0x10, 0x0C, 0xA6, 0x77, 0x9B, 0xB5, 0xE1, 0xC7, 0x46, \n\t0x0C, 0x0E, 0x00, 0x04, 0xC1, 0x60, 0x82, 0x37, 0x5A, 0x1B, 0xC0, 0x6C, 0xC4, 0xE0, 0x00, 0x40, \n\t0x10, 0x0C, 0xA6, 0x78, 0xAB, 0xB5, 0x21, 0xCC, 0x6C, 0xF8, 0x31, 0xF9, 0xD8, 0x00, 0x66, 0xF2, \n\t0xB1, 0x21, 0xCC, 0xE4, 0x63, 0x63, 0x36, 0xC4, 0xC7, 0xC8, 0x6C, 0x88, 0x8F, 0x95, 0xD9, 0x10, \n\t0x1F, 0x4B, 0x12, 0xF9, 0x58, 0x40, 0xC8, 0xC7, 0x14, 0x45, 0x3E, 0x16, 0x14, 0xF2, 0xB1, 0x65, \n\t0x91, 0x8F, 0x05, 0x86, 0x7C, 0xAC, 0x78, 0xE0, 0x63, 0x01, 0x9C, 0xC9, 0xC7, 0x0A, 0x08, 0x3E, \n\t0x16, 0xC8, 0x99, 0x7C, 0xAC, 0x88, 0xE0, 0x63, 0x01, 0x9D, 0xC9, 0x67, 0xC4, 0x20, 0x01, 0x40, \n\t0x10, 0x0C, 0x94, 0x93, 0x53, 0x37, 0x7F, 0xF3, 0x37, 0x90, 0x2B, 0x46, 0x0C, 0x12, 0x00, 0x04, \n\t0xC1, 0x40, 0x39, 0x39, 0x75, 0xF3, 0x37, 0x7F, 0x8B, 0xB7, 0x61, 0xC4, 0x20, 0x01, 0x40, 0x10, \n\t0x0C, 0x94, 0x93, 0x53, 0x37, 0x7F, 0xF3, 0x37, 0x78, 0x0B, 0x46, 0x0C, 0x12, 0x00, 0x04, 0xC1, \n\t0x40, 0x39, 0x39, 0x75, 0xF3, 0x37, 0x7F, 0xBB, 0x37, 0x3A, 0xC3, 0x70, 0x20, 0x00, 0xBA, 0x01, \n\t0x00, 0x00, 0x36, 0x4B, 0x60, 0xF8, 0x88, 0x5D, 0xDF, 0xB7, 0x29, 0x17, 0x18, 0x3E, 0x52, 0xD7, \n\t0xBA, 0x6D, 0xB6, 0x04, 0x86, 0x8F, 0xD8, 0xF5, 0xAD, 0x1B, 0xB2, 0x81, 0xE1, 0x23, 0x75, 0xAD, \n\t0xE7, 0x96, 0x4B, 0x60, 0xF8, 0x88, 0x5D, 0xDF, 0xBD, 0x19, 0x07, 0x18, 0x13, 0xF3, 0xD8, 0x39, \n\t0x6D, 0xC7, 0x01, 0xC6, 0xC4, 0x3C, 0x76, 0x5E, 0x1B, 0xB3, 0x41, 0xE2, 0x23, 0x76, 0xAD, 0xF7, \n\t0x76, 0x9F, 0x1B, 0x7F, 0x80, 0x31, 0x31, 0x8F, 0x9D, 0xDF, 0xD6, 0x1F, 0x60, 0x4C, 0xCC, 0x63, \n\t0xE7, 0xB8, 0xF9, 0x07, 0x18, 0x13, 0xF3, 0xD8, 0x79, 0x6E, 0xD3, 0x02, 0xC6, 0xC4, 0x3C, 0x76, \n\t0xBE, 0x1B, 0xB5, 0x80, 0x31, 0x31, 0x8F, 0x9D, 0xF3, 0x56, 0x2D, 0x60, 0x4C, 0xCC, 0x63, 0xE7, \n\t0xBD, 0x7D, 0x15, 0x3E, 0x42, 0xE3, 0xBD, 0xD5, 0x1B, 0x10, 0x9F, 0x89, 0x34, 0xE6, 0x4A, 0x50, \n\t0x7C, 0x91, 0x50, 0xD3, 0xF6, 0x4A, 0x50, 0x7C, 0x91, 0x50, 0xD7, 0x06, 0x4B, 0x50, 0x7C, 0x91, \n\t0x50, 0xDB, 0x16, 0x97, 0x48, 0x3E, 0xE2, 0xD3, 0xB5, 0x8F, 0xD0, 0x26, 0x97, 0x48, 0x3E, 0xE2, \n\t0xD3, 0xB5, 0x8F, 0xD4, 0x36, 0x97, 0x48, 0x3E, 0xE2, 0xD3, 0xB5, 0x8F, 0xD8, 0x46, 0x97, 0x48, \n\t0x3E, 0xE2, 0xD3, 0xB5, 0x8F, 0xDC, 0x16, 0x3A, 0x50, 0x7C, 0x91, 0x50, 0xF3, 0xF6, 0x39, 0x50, \n\t0x7C, 0x91, 0x50, 0xEB, 0x06, 0x3A, 0x50, 0x7C, 0x91, 0x50, 0xEF, 0x16, 0x6D, 0x60, 0xF8, 0x48, \n\t0x5D, 0xEF, 0xB5, 0xD9, 0x16, 0x18, 0x3E, 0x62, 0xD7, 0x78, 0x6E, 0x8A, 0x03, 0xC6, 0xC4, 0x3C, \n\t0xB6, 0x5E, 0xDB, 0xE2, 0x80, 0x31, 0x31, 0x8F, 0xAD, 0xDB, 0xC6, 0x38, 0x60, 0x4C, 0xCC, 0x63, \n\t0xEB, 0xB7, 0xA1, 0x15, 0x3E, 0x42, 0xE7, 0xB5, 0x51, 0x1B, 0x18, 0x3E, 0x52, 0xD7, 0x3B, 0x6E, \n\t0xE2, 0x03, 0xC6, 0xC4, 0x3C, 0xB6, 0xAE, 0xDB, 0xF8, 0x80, 0x31, 0x31, 0x8F, 0xAD, 0xEF, 0x46, \n\t0x3E, 0x60, 0x4C, 0xCC, 0x63, 0xEB, 0xBC, 0xD9, 0x15, 0x3E, 0x42, 0xE7, 0xBA, 0xF1, 0x12, 0x18, \n\t0x3E, 0x62, 0xD7, 0xB8, 0x6D, 0xE8, 0x06, 0x85, 0x8F, 0xD0, 0xF9, 0x6D, 0x90, 0x02, 0xC5, 0x17, \n\t0x09, 0xB6, 0x6D, 0x91, 0x02, 0xC5, 0x17, 0x09, 0xF6, 0x6D, 0x92, 0x02, 0xC5, 0x17, 0x09, 0x36, \n\t0x6E, 0xDD, 0x06, 0x86, 0x8F, 0xD4, 0x35, 0x4F, 0x9B, 0x70, 0x81, 0xE1, 0x23, 0x76, 0x9D, 0xE3, \n\t0x26, 0x18, 0x50, 0x7C, 0x91, 0x60, 0xF3, 0x36, 0x18, 0x50, 0x7C, 0x91, 0x60, 0xF7, 0x56, 0x5C, \n\t0x60, 0xF8, 0x88, 0x5D, 0xE7, 0xBB, 0x91, 0x1B, 0x18, 0x3E, 0x52, 0xD7, 0xBC, 0x6E, 0x99, 0x04, \n\t0xC6, 0xC4, 0x3C, 0xF6, 0x4E, 0xDB, 0x56, 0x96, 0x12, 0xD1, 0x17, 0x01, 0x0C, 0xC1, 0x39, 0x8D, \n\t0x34, 0x01, 0xCD, 0x24, 0xFD, 0x42, 0x40, 0x15, 0x05, 0x11, 0x99, 0x26, 0x81, 0x31, 0x31, 0x8F, \n\t0xBD, 0xD7, 0xB6, 0x49, 0x60, 0x4C, 0xCC, 0x63, 0xEF, 0xB6, 0xC5, 0x13, 0x18, 0x13, 0xF3, 0xD8, \n\t0x7B, 0x6E, 0xF2, 0x04, 0xC6, 0xC4, 0x3C, 0xF6, 0xAE, 0xDB, 0x3C, 0x81, 0x31, 0x31, 0x8F, 0xBD, \n\t0xEF, 0x86, 0x5A, 0x60, 0x4C, 0xCC, 0x63, 0xEF, 0xBD, 0x95, 0x1B, 0x18, 0x3E, 0x52, 0xD7, 0x7C, \n\t0x6F, 0x85, 0x01, 0x85, 0x8F, 0xD0, 0x3A, 0x6F, 0x84, 0x01, 0xC5, 0x17, 0x09, 0x37, 0x6D, 0xC8, \n\t0x05, 0x86, 0x8F, 0xD8, 0xB5, 0x4E, 0xDB, 0x72, 0x81, 0xE1, 0x23, 0x76, 0xAD, 0xDF, 0x96, 0x6C, \n\t0x60, 0xF8, 0x88, 0x5D, 0xEB, 0xBA, 0xA5, 0x16, 0x18, 0x13, 0xF3, 0xD8, 0x3C, 0x6D, 0xAA, 0x05, \n\t0xC6, 0xC4, 0x3C, 0x36, 0x5F, 0x5B, 0x58, 0xE1, 0x23, 0x75, 0x4E, 0x5B, 0x5A, 0xE1, 0x23, 0x75, \n\t0x6E, 0x1B, 0x62, 0x40, 0xE1, 0x23, 0xF4, 0x5E, 0x9B, 0x6F, 0x01, 0xF1, 0x45, 0x82, 0x6E, 0x8B, \n\t0x01, 0x85, 0x8F, 0xD0, 0x3B, 0x6E, 0x81, 0x06, 0xC6, 0xC4, 0x3C, 0x36, 0x9F, 0xDB, 0x5D, 0xE1, \n\t0x23, 0x75, 0xBE, 0x9B, 0x63, 0x40, 0xE1, 0x23, 0xF4, 0xBE, 0xDB, 0xAD, 0x81, 0x31, 0x31, 0x8F, \n\t0xCD, 0xF3, 0x26, 0x68, 0x60, 0x4C, 0xCC, 0x63, 0xF3, 0xBA, 0xFD, 0x16, 0x10, 0x5F, 0x24, 0xEC, \n\t0x06, 0x68, 0x60, 0x4C, 0xCC, 0x63, 0xF3, 0xB8, 0xE1, 0x1A, 0x18, 0x13, 0xF3, 0xD8, 0x7C, 0x6F, \n\t0xE9, 0x06, 0x85, 0x8F, 0xD4, 0x39, 0x6E, 0xCE, 0x06, 0x04, 0x8B, 0x34, 0xB8, 0x3D, 0x1B, 0x10, \n\t0x2C, 0xD2, 0xE4, 0x26, 0x6D, 0x60, 0xF8, 0x88, 0x5D, 0xEF, 0xB6, 0x55, 0x1B, 0x18, 0x3E, 0x62, \n\t0xD7, 0x7B, 0x6E, 0xDB, 0x06, 0x86, 0x8F, 0xD8, 0xF5, 0xCE, 0x5B, 0xAE, 0x81, 0x31, 0x31, 0x8F, \n\t0xDD, 0xD3, 0x96, 0x57, 0xF8, 0x48, 0xAD, 0xD3, 0x76, 0x28, 0x50, 0xF8, 0x08, 0xCD, 0xD3, 0x46, \n\t0x78, 0x60, 0x4C, 0xCC, 0x63, 0xF7, 0xBB, 0xF9, 0x15, 0x3E, 0x52, 0xEB, 0xBA, 0x15, 0x1E, 0x18, \n\t0x13, 0xF3, 0xD8, 0x3D, 0x6F, 0x86, 0x07, 0xC6, 0xC4, 0x3C, 0x76, 0xDF, 0x9B, 0x61, 0x40, 0xE1, \n\t0x23, 0xB5, 0xDE, 0xDB, 0xA4, 0x40, 0xE1, 0x23, 0x34, 0xDF, 0x9B, 0xB7, 0x81, 0xE1, 0x23, 0x76, \n\t0xCD, 0xD7, 0x66, 0x6E, 0x60, 0xF8, 0x88, 0x5D, 0xF3, 0x3B, 0x69, 0x60, 0x0D, 0x02, 0x7E, 0xE4, \n\t0xC2, 0xF2, 0xDA, 0xC2, 0xE4, 0xC6, 0xD0, 0x80, 0x80, 0xB2, 0x82, 0x7E, 0x82, 0xAC, 0x7E, 0x48, \n\t0xEC, 0xCA, 0xC6, 0xE8, 0xDE, 0xE4, 0x80, 0x9A, 0x48, 0x60, 0x64, 0x80, 0x80, 0xAC, 0x62, 0x80, \n\t0x60, 0x80, 0xB4, 0x5C, 0xCA, 0xF0, 0xD2, 0xE8, 0x2C, 0x31, 0xA0, 0xF0, 0x91, 0x7A, 0xB7, 0xCD, \n\t0x52, 0xA0, 0xF0, 0x11, 0xBA, 0xB7, 0x4D, 0xDD, 0xA0, 0xF0, 0x11, 0x3B, 0xCF, 0x8D, 0x31, 0xA0, \n\t0xF0, 0x91, 0x7A, 0xCF, 0x2D, 0x53, 0xA0, 0xF0, 0x11, 0xBA, 0xCF, 0x0D, 0xAF, 0xF0, 0x11, 0x3B, \n\t0xE7, 0xED, 0x31, 0xA0, 0xF0, 0x91, 0x7A, 0xE7, 0x8D, 0x53, 0xA0, 0xF0, 0x11, 0xBA, 0xE7, 0xED, \n\t0xDC, 0xC0, 0xF0, 0x11, 0xBB, 0xEE, 0x69, 0xD3, 0x2B, 0x7C, 0xC4, 0xD6, 0x6B, 0x43, 0x14, 0x28, \n\t0x7C, 0xA4, 0xE6, 0x6B, 0x9B, 0x37, 0x30, 0x3E, 0x13, 0xB8, 0x6E, 0xDC, 0xE8, 0x0D, 0x8C, 0xCF, \n\t0x04, 0xAE, 0x3B, 0x37, 0x46, 0x81, 0xC2, 0x47, 0x6A, 0x7E, 0x37, 0xCB, 0x01, 0xC3, 0x47, 0xE8, \n\t0x9A, 0xAE, 0xAD, 0xB7, 0x60, 0xF8, 0x22, 0xC1, 0x96, 0x0D, 0x12, 0x1F, 0xA9, 0x6B, 0x9D, 0xB7, \n\t0x7B, 0xDC, 0x0E, 0x03, 0x0A, 0x1F, 0xB1, 0x77, 0xDA, 0x28, 0x05, 0x0A, 0x1F, 0xA9, 0x7B, 0xDA, \n\t0x14, 0x03, 0x0A, 0x1F, 0xB1, 0xF7, 0xDB, 0x2E, 0x05, 0x0A, 0x1F, 0xA9, 0xFB, 0xDB, 0x8A, 0x0D, \n\t0x8C, 0xCF, 0x04, 0x2E, 0x3C, 0xB7, 0xC6, 0x80, 0xC2, 0x47, 0xEC, 0x5D, 0x37, 0x4D, 0x81, 0xC2, \n\t0x47, 0xEA, 0x5E, 0x37, 0x37, 0xE2, 0x33, 0x81, 0xC1, 0x44, 0x07, 0x0C, 0x1F, 0xA1, 0xEB, 0x9A, \n\t0x36, 0xC8, 0x80, 0xC2, 0x47, 0xEC, 0xBD, 0xB7, 0x4E, 0x81, 0xC2, 0x47, 0xEA, 0xBE, 0xB7, 0xD2, \n\t0x01, 0xC3, 0x47, 0xE8, 0xBA, 0xBE, 0x0D, 0xDB, 0xC0, 0xF8, 0x4C, 0xE0, 0xC2, 0x6F, 0x43, 0x1D, \n\t0x30, 0x7C, 0x84, 0xAE, 0x6B, 0xDD, 0x56, 0x07, 0x0C, 0x1F, 0xA1, 0xEB, 0xBA, 0x37, 0x6E, 0x83, \n\t0xC4, 0x47, 0xE8, 0x7A, 0xEF, 0xED, 0x5E, 0xB7, 0x66, 0x83, 0x81, 0x45, 0x1A, 0x93, 0x37, 0x20, \n\t0x3E, 0x13, 0xB8, 0xEC, 0xCD, 0x40, 0x7C, 0xC4, 0xA7, 0x6F, 0x4B, 0x14, 0x28, 0x7C, 0xC4, 0xE6, \n\t0x6D, 0xF3, 0x37, 0x30, 0x7C, 0x84, 0xB6, 0x69, 0xDB, 0x4A, 0x09, 0x0C, 0x1F, 0xA1, 0x6B, 0xDB, \n\t0x36, 0x7C, 0x03, 0xC3, 0x47, 0x68, 0x9B, 0xCE, 0x6D, 0xDF, 0xC0, 0xF0, 0x11, 0xDA, 0xA6, 0x79, \n\t0xAB, 0x14, 0x28, 0x7C, 0xC4, 0xEE, 0x6B, 0xC3, 0x14, 0x28, 0x7C, 0xC4, 0xEE, 0x71, 0xDB, 0x14, \n\t0x28, 0x7C, 0xC4, 0xEE, 0x77, 0xBB, 0x1C, 0x30, 0x7C, 0xA4, 0xAE, 0x69, 0xDB, 0x62, 0x09, 0x0C, \n\t0x1F, 0xA1, 0xEB, 0xBB, 0xB6, 0x7F, 0x03, 0xC3, 0x47, 0x68, 0xBB, 0xAE, 0x8D, 0x96, 0xC0, 0xF0, \n\t0x11, 0xBA, 0xBE, 0x71, 0xDB, 0x1C, 0x30, 0x7C, 0xA4, 0xAE, 0x69, 0xDE, 0x6E, 0x09, 0x0C, 0x1F, \n\t0xA1, 0xEB, 0x7B, 0xB7, 0x33, 0x82, 0x85, 0xA2, 0xC9, 0xDE, 0x0D, 0x1C, 0xC9, 0x47, 0x7C, 0xDA, \n\t0x5F, 0x04, 0x49, 0x02, 0x7C, 0x84, 0x36, 0x78, 0x03, 0x47, 0xF2, 0x11, 0x9F, 0xF6, 0x17, 0x41, \n\t0x92, 0x00, 0x1F, 0xA9, 0x2D, 0xDE, 0xC0, 0x91, 0x7C, 0xC4, 0xA7, 0xFD, 0x45, 0x90, 0x24, 0xC0, \n\t0x47, 0x6C, 0xDB, 0x2D, 0x48, 0x56, 0x87, 0x6A, 0x86, 0xBF, 0x41, 0x78, 0xE3, 0x2D, 0x48, 0x56, \n\t0x87, 0x6A, 0x86, 0xBF, 0x41, 0x7A, 0xB3, 0x37, 0x30, 0x3E, 0x13, 0x69, 0x6E, 0xDD, 0xEE, 0x0D, \n\t0x8C, 0xCF, 0x44, 0x9A, 0x7B, 0xB7, 0xD1, 0x01, 0xC3, 0x47, 0xEA, 0xBA, 0xAE, 0x4D, 0x97, 0xC0, \n\t0xF0, 0x11, 0xBA, 0xC6, 0x69, 0x33, 0x1D, 0x30, 0x7C, 0xA4, 0xAE, 0x6B, 0xDC, 0x68, 0x0B, 0x0C, \n\t0x1F, 0xA1, 0x6B, 0xFC, 0xB6, 0xD4, 0x01, 0xC3, 0x47, 0xEA, 0xBA, 0xDE, 0x6D, 0x95, 0x40, 0x59, \n\t0x1D, 0xAA, 0x19, 0xFE, 0x06, 0xA9, 0x6F, 0x63, 0x25, 0x50, 0x56, 0x87, 0x6A, 0x86, 0xBF, 0x41, \n\t0x6A, 0xDC, 0x5A, 0x09, 0x94, 0xD5, 0xA1, 0x9A, 0xE1, 0x6F, 0x90, 0x3A, 0x37, 0xCE, 0x01, 0x65, \n\t0x75, 0xA8, 0x66, 0xF8, 0x1B, 0xA4, 0xEE, 0x4D, 0x6D, 0xF0, 0x11, 0xDB, 0xD6, 0x0D, 0x06, 0x1F, \n\t0xB9, 0x4D, 0xB7, 0x00, 0x59, 0x1D, 0xAA, 0x19, 0xFE, 0x06, 0xB1, 0x6C, 0x03, 0xE3, 0x33, 0x91, \n\t0x06, 0xC7, 0xCD, 0xD8, 0xC0, 0xF8, 0x4C, 0xA4, 0xC1, 0x75, 0x63, 0x1D, 0x30, 0x7C, 0xA4, 0xAE, \n\t0x6D, 0xDA, 0x00, 0x0F, 0x0C, 0x1F, 0xA9, 0x6D, 0xFA, 0x36, 0x53, 0x02, 0xC3, 0x47, 0xEA, 0xDA, \n\t0xBE, 0x0D, 0xB8, 0xC0, 0xF0, 0x11, 0xBA, 0xCE, 0x6D, 0xEB, 0x1C, 0x50, 0x56, 0x87, 0x6A, 0x86, \n\t0xBF, 0x41, 0x6C, 0xDA, 0x3C, 0x07, 0x94, 0xD5, 0xA1, 0x9A, 0xE1, 0x6F, 0x10, 0xBB, 0xB6, 0xE1, \n\t0x02, 0xC3, 0x47, 0xE8, 0x3A, 0xCF, 0x2D, 0xDF, 0xC0, 0xF0, 0x91, 0xDA, 0xA6, 0x75, 0x53, 0x25, \n\t0x30, 0x7C, 0xA4, 0xAE, 0xED, 0xDE, 0x1A, 0x05, 0x94, 0xD5, 0xA1, 0x9A, 0xE1, 0x6F, 0x10, 0x3B, \n\t0x37, 0x47, 0x01, 0x65, 0x75, 0xA8, 0x66, 0xF8, 0x1B, 0xC4, 0xD6, 0xED, 0x51, 0x40, 0x59, 0x1D, \n\t0xAA, 0x19, 0xFE, 0x06, 0xB1, 0x77, 0x33, 0x2E, 0x30, 0x7C, 0x84, 0xAE, 0x73, 0xDE, 0xF8, 0x0D, \n\t0x0C, 0x1F, 0xA9, 0x6D, 0xBA, 0x37, 0x4F, 0x01, 0xC3, 0x47, 0xEC, 0x9A, 0xA6, 0x0D, 0x73, 0xC0, \n\t0xF0, 0x11, 0xBB, 0xA6, 0x6F, 0x93, 0x25, 0x30, 0x7C, 0xA4, 0xAE, 0x6F, 0xDB, 0x92, 0x0B, 0x0C, \n\t0x1F, 0xA1, 0x6B, 0xBD, 0xB6, 0xC0, 0x03, 0xC3, 0x47, 0x6A, 0xBB, 0xB6, 0xAD, 0x96, 0xC0, 0xF0, \n\t0x91, 0xBA, 0xBE, 0x73, 0xFB, 0x53, 0x56, 0x87, 0x6A, 0x86, 0xBF, 0x41, 0xEE, 0xDA, 0x00, 0x03, \n\t0x94, 0xD5, 0xA1, 0x9A, 0xE1, 0x6F, 0x90, 0xDB, 0xB6, 0xC0, 0x00, 0x65, 0x75, 0xA8, 0x66, 0xF8, \n\t0x1B, 0xE4, 0xBE, 0x0D, 0x97, 0xC0, 0xF0, 0x91, 0xBA, 0xBE, 0x79, 0x43, 0x3C, 0x30, 0x26, 0xE6, \n\t0xB9, 0xE9, 0xDA, 0x0E, 0x0F, 0x8C, 0x89, 0x79, 0x6E, 0x9A, 0xB6, 0x63, 0x03, 0xC3, 0x47, 0xE8, \n\t0x5A, 0xC7, 0x2D, 0xF1, 0xC0, 0x98, 0x98, 0xE7, 0xA6, 0x6D, 0x23, 0x1D, 0x30, 0x7C, 0xC4, 0xAE, \n\t0x6B, 0xDB, 0x76, 0x09, 0x0C, 0x1F, 0xA9, 0x6B, 0xBC, 0x36, 0x68, 0x03, 0xC3, 0x47, 0xE8, 0x7A, \n\t0xA7, 0xED, 0x74, 0xC0, 0xF0, 0x11, 0xBB, 0xAE, 0x73, 0xAB, 0x2D, 0x30, 0x7C, 0xA4, 0xAE, 0x71, \n\t0xDC, 0xA6, 0x0D, 0x0C, 0x1F, 0xA1, 0xEB, 0xFD, 0xB6, 0x36, 0xE3, 0x33, 0x81, 0xE1, 0xE6, 0x8D, \n\t0xCD, 0xF8, 0x4C, 0x60, 0xB8, 0x7B, 0xD3, 0x36, 0x30, 0x7C, 0x84, 0xAE, 0x77, 0xDD, 0x54, 0x07, \n\t0x0C, 0x1F, 0xB1, 0xEB, 0x9A, 0x37, 0x65, 0x83, 0xC4, 0x47, 0xE8, 0x5A, 0xDF, 0xED, 0xFE, 0xB6, \n\t0x35, 0xE3, 0x33, 0x81, 0x01, 0xA7, 0xAD, 0x75, 0xC0, 0xF0, 0x11, 0xBB, 0xB6, 0x6B, 0xCB, 0x2D, \n\t0x30, 0x7C, 0xA4, 0xAE, 0x73, 0xDA, 0x04, 0x0F, 0x0C, 0x1F, 0xB1, 0x6D, 0x1A, 0xB7, 0x53, 0x02, \n\t0xC3, 0x47, 0xEC, 0xDA, 0xC6, 0x2D, 0xB8, 0xC0, 0xF0, 0x91, 0xBA, 0xCE, 0x6F, 0x0B, 0x37, 0x30, \n\t0x7C, 0x84, 0xAE, 0x79, 0xDB, 0xF4, 0x0D, 0x0C, 0x1F, 0xB1, 0x6D, 0x7A, 0x37, 0xE2, 0x02, 0xC3, \n\t0x47, 0xEA, 0x3A, 0xD7, 0x4D, 0xDC, 0xC0, 0xF0, 0x11, 0xBA, 0xE6, 0x73, 0x3B, 0x2E, 0x30, 0x7C, \n\t0xA4, 0xAE, 0xF3, 0xDE, 0xC6, 0x0D, 0x0C, 0x1F, 0xA1, 0x6B, 0x9E, 0xB7, 0xE2, 0x80, 0x61, 0x62, \n\t0x1E, 0x83, 0x33, 0x26, 0x1F, 0xF1, 0x69, 0xDB, 0xFA, 0x0D, 0x0C, 0x1F, 0xB1, 0xED, 0x9A, 0xB6, \n\t0xC1, 0x03, 0xC3, 0x47, 0x6C, 0xBB, 0xBE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n\t0x00, 0x00\n};\n\nIDXGISwapChain3* mSwapChain;\nID3D12Device* mDevice;\nID3D12Resource* mRenderTarget[FRAMES];\nID3D12CommandAllocator* mCommandAllocator;\nID3D12CommandQueue* mCommandQueue;\nID3D12DescriptorHeap* mDescriptorHeap;\nID3D12PipelineState* mPSO;\nID3D12GraphicsCommandList* mCommandList;\nID3D12RootSignature* mRootSignature;\nHANDLE mfenceEvent;\nID3D12Fence* mFence;\nUINT64 mFenceValue;\nUINT mframeIndex;\nID3D12Resource* buffer;\n\nvoid WaitForPreviousFrame()\n{\n\tconst UINT64 fence = mFenceValue;\n\tmCommandQueue->lpVtbl->Signal(mCommandQueue, mFence, fence);\n\tmFenceValue++;\n\tif (mFence->lpVtbl->GetCompletedValue(mFence) < fence)\n\t{\n\t\tmFence->lpVtbl->SetEventOnCompletion(mFence, fence, mfenceEvent);\n\t\tWaitForSingleObject(mfenceEvent, INFINITE);\n\t}\n\tmframeIndex = mSwapChain->lpVtbl->GetCurrentBackBufferIndex(mSwapChain);\n}\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif ((uMsg == WM_KEYUP && wParam == VK_ESCAPE) || uMsg==WM_CLOSE || uMsg==WM_DESTROY)\n\t{\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win;\n\tZeroMemory( &win, sizeof(WNDCLASS) );\n\twin.style = CS_OWNDC|CS_HREDRAW|CS_VREDRAW;\n\twin.lpfnWndProc = WindowProc;\n\twin.hInstance = 0;\n\twin.lpszClassName = \"DirectX 12 Demo\";\n\twin.hbrBackground =(HBRUSH)(COLOR_WINDOW+1);\n\tRegisterClass(&win);\n\tHWND hWnd = CreateWindowEx(0, win.lpszClassName, \"DirectX 12 Demo\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, WIDTH, HEIGHT, 0, 0, 0, 0);\n\tHDC hdc = GetDC(hWnd);\n\tIDXGIFactory4* pFactory;\n\tCreateDXGIFactory1((REFIID)&IID_IDXGIFactory4, (LPVOID*)(&pFactory));\n\tD3D12CreateDevice(NULL, D3D_FEATURE_LEVEL_12_0, (REFIID)&IID_ID3D12Device, (LPVOID*)(&mDevice));\n\tD3D12_COMMAND_QUEUE_DESC queueDesc = {D3D12_COMMAND_LIST_TYPE_DIRECT, 0, D3D12_COMMAND_QUEUE_FLAG_NONE, 0};\n\tmDevice->lpVtbl->CreateCommandQueue(mDevice, &queueDesc, (REFIID)&IID_ID3D12CommandQueue, (LPVOID*)(&mCommandQueue));\n\tDXGI_SWAP_CHAIN_DESC descSwapChain = {(DXGI_MODE_DESC){WIDTH,HEIGHT,{0,0},DXGI_FORMAT_R8G8B8A8_UNORM,0,0},(DXGI_SAMPLE_DESC){1,0},1L << (1 + 4),FRAMES,hWnd,1,3,0};\n\tIDXGISwapChain* SwapChain;\n\tpFactory->lpVtbl->CreateSwapChain(pFactory, (IUnknown *)mCommandQueue, &descSwapChain, &SwapChain);\n\tSwapChain->lpVtbl->QueryInterface(SwapChain, (REFIID)&IID_IDXGISwapChain3, (LPVOID*)(&mSwapChain));\n\tSwapChain->lpVtbl->Release(SwapChain);\n\tD3D12_INPUT_ELEMENT_DESC layout[] ={{ \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }};\t\n\tID3DBlob* blob;\n\tD3D12_ROOT_PARAMETER timeParam;\n\tZeroMemory(&timeParam, sizeof(timeParam));\n\ttimeParam.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;\n\ttimeParam.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;\n\ttimeParam.Constants = (D3D12_ROOT_CONSTANTS){ 0,0, 1  };\n\tD3D12_ROOT_SIGNATURE_DESC descRootSignature = {1, &timeParam, 0, NULL, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT};\n\tD3D12SerializeRootSignature(&descRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &blob, 0);\n\tmDevice->lpVtbl->CreateRootSignature(mDevice, 0, blob->lpVtbl->GetBufferPointer(blob), blob->lpVtbl->GetBufferSize(blob), (REFIID)&IID_ID3D12RootSignature, (LPVOID*)(&mRootSignature));\n\tD3D12_RASTERIZER_DESC rasterizer ={D3D12_FILL_MODE_SOLID,D3D12_CULL_MODE_BACK,0,D3D12_DEFAULT_DEPTH_BIAS,D3D12_DEFAULT_DEPTH_BIAS_CLAMP,0.0f,1,0,0,0,0};\n\tD3D12_BLEND_DESC blendstate = { 0, 0,{0, 0, 1, 0, D3D12_BLEND_OP_ADD, 1, 0, D3D12_BLEND_OP_ADD, D3D12_LOGIC_OP_NOOP, D3D12_COLOR_WRITE_ENABLE_ALL} };\n\tstatic D3D12_GRAPHICS_PIPELINE_STATE_DESC pDesc;\n\tpDesc.pRootSignature = mRootSignature;\t\n\tpDesc.VS = (D3D12_SHADER_BYTECODE){VertexShader,sizeof(VertexShader)};\n\tpDesc.PS = (D3D12_SHADER_BYTECODE){PixelShader,sizeof(PixelShader)};\n\tpDesc.InputLayout = (D3D12_INPUT_LAYOUT_DESC) {layout, _countof(layout)};\t\n\tpDesc.RasterizerState = rasterizer;\n\tpDesc.BlendState = blendstate;\n\tpDesc.DepthStencilState = (D3D12_DEPTH_STENCIL_DESC){0,0,0,0,0,0,0,0};\n\tpDesc.SampleMask = UINT_MAX;\n\tpDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;\n\tpDesc.NumRenderTargets = 1;\n\tpDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;\n\tpDesc.SampleDesc.Count = 1;\n\tmDevice->lpVtbl->CreateGraphicsPipelineState(mDevice, &pDesc, (REFIID)&IID_ID3D12PipelineState, (LPVOID*)(&mPSO));\n\tstatic D3D12_DESCRIPTOR_HEAP_DESC descHeap = {D3D12_DESCRIPTOR_HEAP_TYPE_RTV, FRAMES, D3D12_DESCRIPTOR_HEAP_FLAG_NONE, 0};\n\tmDevice->lpVtbl->CreateDescriptorHeap(mDevice, &descHeap, (REFIID)&IID_ID3D12DescriptorHeap, (LPVOID*)(&mDescriptorHeap));\n\tUINT mrtvDescriptorIncrSize = mDevice->lpVtbl->GetDescriptorHandleIncrementSize(mDevice, D3D12_DESCRIPTOR_HEAP_TYPE_RTV);\n\tD3D12_CPU_DESCRIPTOR_HANDLE rtvHandle;\n\t((void(__stdcall*)(ID3D12DescriptorHeap*, D3D12_CPU_DESCRIPTOR_HANDLE*)) mDescriptorHeap->lpVtbl->GetCPUDescriptorHandleForHeapStart)(mDescriptorHeap, &rtvHandle);\n\tfor (UINT i = 0; i < FRAMES; i++)\n\t{\n\t\tmSwapChain->lpVtbl->GetBuffer(mSwapChain, i, (REFIID)&IID_ID3D12Resource, (LPVOID*)(&mRenderTarget[i])); \n\t\tmDevice->lpVtbl->CreateRenderTargetView(mDevice, mRenderTarget[i], NULL, rtvHandle);\n\t\trtvHandle.ptr += mrtvDescriptorIncrSize;\n\t}\n\tmDevice->lpVtbl->CreateCommandAllocator(mDevice, D3D12_COMMAND_LIST_TYPE_DIRECT, (REFIID)&IID_ID3D12CommandAllocator, (LPVOID*)(&mCommandAllocator));\n\tmDevice->lpVtbl->CreateCommandList(mDevice, 0, D3D12_COMMAND_LIST_TYPE_DIRECT, mCommandAllocator, mPSO, (REFIID)&IID_ID3D12CommandList, (LPVOID*)(&mCommandList));\n\tD3D12_VIEWPORT mViewport = { 0.0f, 0.0f, (float)(WIDTH), (float)(HEIGHT), 0.0f, 1.0f };\n\tD3D12_RECT mRectScissor = { 0, 0, (LONG)(WIDTH), (LONG)(HEIGHT) };\n\tfloat vertices[] ={ -1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0, 0.0f, 1.0f, 1.0f, 0.0f};\n\tstatic D3D12_HEAP_PROPERTIES heapProperties ={D3D12_HEAP_TYPE_UPLOAD,D3D12_CPU_PAGE_PROPERTY_UNKNOWN,D3D12_MEMORY_POOL_UNKNOWN,1,1};\n\tstatic D3D12_RESOURCE_DESC VertexBufferDesc ={D3D12_RESOURCE_DIMENSION_BUFFER,0,_countof(vertices) * 12,1,1,1,DXGI_FORMAT_UNKNOWN,{1,0},1,0};\n\tmDevice->lpVtbl->CreateCommittedResource(mDevice,&heapProperties,0,&VertexBufferDesc,D3D12_RESOURCE_STATE_GENERIC_READ,NULL,(REFIID)&IID_ID3D12Resource, (LPVOID*)(&buffer));\n\tfloat* data;\n\tbuffer->lpVtbl->Map(buffer, 0, NULL, (void**)(&data));\n\tmemcpy(data, vertices, sizeof(vertices));\n\tbuffer->lpVtbl->Unmap(buffer, 0, NULL);\n\tD3D12_VERTEX_BUFFER_VIEW mDescViewBufVert = {buffer->lpVtbl->GetGPUVirtualAddress(buffer), sizeof(vertices), 12};\n\tmCommandList->lpVtbl->Close(mCommandList);\n\tmDevice->lpVtbl->CreateFence(mDevice, 0, D3D12_FENCE_FLAG_NONE, (REFIID)&IID_ID3D12Fence, (LPVOID*)(&mFence));\n\tmFenceValue = 1;\n\tmfenceEvent = CreateEventEx(NULL, FALSE, FALSE, EVENT_ALL_ACCESS);\n\twhile (!exit)\n\t{\n\t\twhile (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif (msg.message == WM_QUIT) exit = 1;\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t\tmCommandAllocator->lpVtbl->Reset(mCommandAllocator);\n\t\tmCommandList->lpVtbl->Reset(mCommandList, mCommandAllocator, mPSO);\n\t\tmCommandList->lpVtbl->SetGraphicsRootSignature(mCommandList, mRootSignature);\n\t\tfloat timer = GetTickCount() * 0.001f;\n\t\tmCommandList->lpVtbl->SetGraphicsRoot32BitConstants(mCommandList,0,1,&timer,0);\n\t\tmCommandList->lpVtbl->RSSetViewports(mCommandList, 1, &mViewport);\n\t\tmCommandList->lpVtbl->RSSetScissorRects(mCommandList, 1, &mRectScissor);\n\t\tD3D12_RESOURCE_BARRIER barrierRTAsTexture = {0, 0,{ mRenderTarget[mframeIndex], D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RENDER_TARGET }};\n\t\tmCommandList->lpVtbl->ResourceBarrier(mCommandList, 1, &barrierRTAsTexture);\n\t\t((void(__stdcall*)(ID3D12DescriptorHeap*, D3D12_CPU_DESCRIPTOR_HANDLE*)) mDescriptorHeap->lpVtbl->GetCPUDescriptorHandleForHeapStart)(mDescriptorHeap, &rtvHandle);\n\t\trtvHandle.ptr += mframeIndex * mrtvDescriptorIncrSize;\n\t\tfloat clearColor[] = { 0.0f, 0.0f, 0.0f, 1.0f };\n\t\tmCommandList->lpVtbl->ClearRenderTargetView(mCommandList, rtvHandle, clearColor, 0, NULL);\n\t\tmCommandList->lpVtbl->OMSetRenderTargets(mCommandList, 1, &rtvHandle, TRUE, NULL);\n\t\tmCommandList->lpVtbl->IASetPrimitiveTopology(mCommandList, D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n\t\tmCommandList->lpVtbl->IASetVertexBuffers(mCommandList, 0, 1, &mDescViewBufVert);\n\t\tmCommandList->lpVtbl->DrawInstanced(mCommandList, 6, 1, 0, 0);\n\t\tD3D12_RESOURCE_BARRIER barrierRTForPresent = {0, 0,{ mRenderTarget[mframeIndex], D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT }};\n\t\tmCommandList->lpVtbl->ResourceBarrier(mCommandList, 1, &barrierRTForPresent);\n\t\tmCommandList->lpVtbl->Close(mCommandList);\n\t\tID3D12CommandList* ppCommandLists[] = { (ID3D12CommandList *) mCommandList };\n\t\tmCommandQueue->lpVtbl->ExecuteCommandLists(mCommandQueue, _countof(ppCommandLists), ppCommandLists);\n\t\tmSwapChain->lpVtbl->Present(mSwapChain, 0, 0);\n\t\tWaitForPreviousFrame();\n\t}\n\tWaitForPreviousFrame();\n\tCloseHandle(mfenceEvent);\n\tmDevice->lpVtbl->Release(mDevice);\n\tmSwapChain->lpVtbl->Release(mSwapChain);\n\tbuffer->lpVtbl->Release(buffer);\n\tfor (UINT n = 0; n < FRAMES; n++) mRenderTarget[n]->lpVtbl->Release(mRenderTarget[n]);\t\n\tmCommandAllocator->lpVtbl->Release(mCommandAllocator);\n\tmCommandQueue->lpVtbl->Release(mCommandQueue);\n\tmDescriptorHeap->lpVtbl->Release(mDescriptorHeap);\n\tmCommandList->lpVtbl->Release(mCommandList);\n\tmPSO->lpVtbl->Release(mPSO);\n\tmFence->lpVtbl->Release(mFence);\n\tmRootSignature->lpVtbl->Release(mRootSignature);\n\treturn 0;\n}\n*/\n\nconst mat3 rotationMatrix = mat3(1.0,0.0,0.0,0.0,0.47,-0.88,0.0,0.88,0.47);\n\t\nfloat hash(float p)\n{\n    uint x = uint(p  + 16777041.);\n    x = 1103515245U*((x >> 1U)^(x));\n    uint h32 = 1103515245U*((x)^(x>>3U));\n    uint n =  h32^(h32 >> 16);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+0.0  ), hash(n+1.0),f.x),mix( hash(n+57.0 ), hash(n+58.0 ),f.x),f.y),\n           mix(mix( hash(n+113.0), hash(n+114.0),f.x),mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n} \n\nvec4 map( vec3 p )\n{\n\tfloat d = 0.2 - p.y;\t\n\tvec3 q = p  - vec3(0.0,1.0,0.0)*iTime;\n\tfloat f  = 0.50000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n\tf += 0.25000*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;\n\tf += 0.12500*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;\n\tf += 0.06250*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n\tf += 0.03125*noise( q );\n\td = clamp( d + 4.5*f, 0.0, 1.0 );\n\tvec3 col = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.1,0.1), d ) + 0.05*sin(p);\n\treturn vec4( col, d );\n}\n\nvec3 raymarch( vec3 ro, vec3 rd )\n{\n\tvec4 s = vec4( 0,0,0,0 );\n\tfloat t = 0.0;\t\n\tfor( int i=0; i<128; i++ )\n\t{\n\t\tif( s.a > 0.99 ) break;\n\t\tvec3 p = ro + t*rd;\n\t\tvec4 k = map( p );\n\t\tk.rgb *= mix( vec3(3.0,1.5,0.15), vec3(0.5,0.5,0.5), clamp( (p.y-0.2)/2.0, 0.0, 1.0 ) );\n\t\tk.a *= 0.5;\n\t\tk.rgb *= k.a;\n\t\ts = s + k*(1.0-s.a);\t\n\t\tt += 0.05;\n\t}\n\treturn clamp( s.xyz, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(0.0,4.9,-40.);\n\tvec3 rd = normalize(vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y,2.0)) * rotationMatrix;\n\tvec3 volume = raymarch( ro, rd );\n\tvolume = volume*0.5 + 0.5*volume*volume*(3.0-2.0*volume);\n\tfragColor = vec4( volume, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[709, 65304, 65325, 65325, 65518], [65520, 65520, 65543, 65543, 65863], [65866, 65866, 65886, 65886, 66372], [66374, 66374, 66409, 66409, 66750], [66752, 66752, 66809, 66809, 67068]]}
{"id": "wtB3WD", "name": "mdubstestmand", "author": "mdub", "description": "initialise o", "tags": ["mandelbrot"], "likes": 1, "viewed": 109, "published": "Public", "date": "1559572383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// compaction of Wicpar's shader https://www.shadertoy.com/view/XtlSW7\n// with the help of coyote     (see its forum for steps)\n\n\n    void mainImage( out vec4 o, vec2 z ) {\n    o = vec4(0);\n    vec2 c = iResolution.xy;\n    c = z = (z-.5*c)/c.y/pow(o.w=iTime,o.w/20.) - vec2(1.001105,0.300717);\n    o++;\n    for (float k = 6.3; k >0.; k -= 6e-3)\n    {  dot(z = mat2(z,-z.y,z.x)*z + c    // GLSL bug without the {} !!! (z != z.x,z.y )\n          ,z) > 4. ?  o = cos(k*vec4(4,2,1,0)) : o; }\n    \n      // dot(z =  z.x*z + z.y*vec2(-z.y,z.x) + c\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 134, 172, 172, 542]]}
{"id": "wtB3zG", "name": "Bees & Boms GIF", "author": "BigWIngs", "description": "See comments. I challenge you to code golf this!", "tags": ["checker", "gif"], "likes": 16, "viewed": 331, "published": "Public", "date": "1559953614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quick and dirty recreation of \n// https://twitter.com/InfinityLoopGIF/status/1137051249373798400\n//\n// Done for fun in 20 minutes, could be much smaller and more elegant, I know ;)\n// \n// I challenged people to golf it, so...\n\n// latest version from Fabrice, 398 chars!\n#define r *= mat2( cos(t + vec4(0,11,33,0)) ) //\n#define k(s) max( s f +.02 , .7* abs(s cos(h-t*3.75)/h -P.y) ) -.01//\nvoid mainImage(out vec4 O, vec2 U) {\n    float d = 1e2, f,e,h, t = .8;\n    vec3 b = iResolution, c,\n         P = vec3(0, 1.8, -3),\n         D = vec3((U+U-b.xy)/b.y, 1);\n    D.zy r;  t = .4*iTime;\n    for ( D.zx r, P.zx r; --d > 1.;\n          e = max( min(k(),k(-)), max(c.x,c.z) -2.2 ))\n        b = abs(c = abs( fract(P += D*e) -.5 ) -.25 ),\n        f = c.x*c.z / max(b.x,b.z),\n        h = dot(P,P)*.6+1., c = abs(P),\n    O = f > e  ? vec4(.2,.6,1,1) : ++O*e; }\n\n        /*\n// 834144373 version, 412 chars. Might not work well on mac, if it doesn't please comment\n#define r(a) *= mat2( cos(a + vec4(0,11,33,0)) )\n#define k(s) max( s f +.02 , .7* abs(s cos(h-t*3.75)/h -P.y) ) -.01\n\n#define mainImage(O,U)                              \\\n    float d = 1e2, f,e,h,                           \\\n          t = .4*iTime;                             \\\n    vec3 b = iResolution, c,                        \\\n         P = vec3(0,1.8,-3),                        \\\n         D = vec3((U+U-b.xy)/b.y, 1);                   \\\n    D.zy r(.8);                                     \\\n    for (D.zx r(t), P.zx r(t); --d > 1.; )          \\\n        c /= b = abs(c = abs( fract(P += D*e) -.5 ) -.25 ),\\\n        f = min(b.x,b.z)*c.x*c.z,                   \\\n        h = dot(P,P)*.6+1., c = abs(P),             \\\n        e = max( min(k(),k(-)), max(c.x,c.z) -2.2 );\\\n    O = f > e  ? vec4(.2,.6,1,1) : ++O*e\n */       \n/*\n// Abje and Fabrice bring it to 424 chars!\n#define r(a) *= mat2( cos(a + vec4(0,11,33,0)) )\n#define k(s) max( s f +.02 , .7* abs(s cos(h-t*3.75)/h -P.y) ) -.01\n\n#define mainImage(O,U)                              \\\n    float d = 1e2, f,e,h,                           \\\n          t = .4*iTime;                             \\\n    vec3 b = iResolution, c,                        \\\n         P = vec3(0,1.8,-3),                        \\\n         D = vec3(U+U-b.xy, b.y);                   \\\n    D.zy r(.8);                                     \\\n    for (D.zx r(t), P.zx r(t); --d > 0.; )          \\\n        c /= b = abs(c = abs( fract(P += D/length(D)*e) -.5 ) -.25 ),\\\n        f = min(b.x,b.z)*c.x*c.z,                   \\\n        h = dot(P,P)*.6+1., c = abs(P),             \\\n        e = max( min(k(),k(-)), max(c.x,c.z) -2.2 );\\\n    e < .1 ? f >0. ? O = vec4(.2,.6,1,1) : O : O++\n */\n\n/*\n// 834144373 shaved off another 34 characters!\n#define r(s) mat2(cos(s+vec4(0,11,33,0)))\n#define k(p) max(p f+.01,abs(p h-t.y)*.7)\n\n#define mainImage(O,U)                           \\\n    float d = 99.,                                 \\\n          f,e,h,                                  \\\n          u = iTime;                              \\\n    vec3 R = iResolution,                         \\\n         t = vec3(0,1.8,-3),                      \\\n         g = normalize(vec3(U+U-R.xy, R.y)),     \\\n         a,b,c,s;                                 \\\n    g.zy *= r(.8);                                \\\n    mat2 o = r(u*.4);                             \\\n    g.zx *= o;                                    \\\n    t.zx *= o;                                    \\\n    O = vec4(.2,.6,.9,1);                         \\\n    while (--d>0.)               \t\t\t  \t  \\\n        b = abs(a = abs(fract(t += g*e)-.5)-.25),       \\\n        c = a/b,                                  \\\n        f = min(b.x,b.z)*c.x*c.z,                 \\\n        h = dot(t,t)*.6+1.,\t\t\t\t\t      \\\n        h = cos(h-u*1.5)/h,              \t      \\\n        s = abs(t)-2.2,                           \\\n        e = max(min(k(),k(-)),max(s.x,s.z)),  \t \\\n        e < .01 ? d=0.: d;                       \\\n    O = e < .01 ? f >0. ? O : O-O : O/O\t\t\t  \\\n  */\n\n/*\n// abje version - 496 chars\n#define r(s) mat2(cos(s+vec4(0,11,33,0)))\n#define k(p) max(p f+.01,abs(p h-t.y)*.7)\n\n#define mainImage(O,U)                            \\\n    float d = 0.,                                 \\\n          f,e,h,l,                                \\\n          u = iTime;                              \\\n    vec3 R = iResolution,                         \\\n         t = vec3(0,1.8,-3),                      \\\n         g = normalize(vec3(U+U-R.xy, R.y)),      \\\n         a,b,c,s;                                 \\\n    g.zy *= r(0.8);                               \\\n    mat2 o = r(u*.4);                             \\\n    g.zx *= o;                                    \\\n    t.zx *= o;                                    \\\n    for (int i = 0; i < 99; i++) {                \\\n        a = abs(fract(t)-.5)-.25,                 \\\n        b = abs(a),                               \\\n        c = a/b;                                  \\\n        f = min(b.x,b.z)*c.x*c.z;                 \\\n        e = dot(t,t)*.6,                          \\\n        h = cos(e-iTime*1.5)/(e+1.),              \\\n        l = min(k(),                              \\\n                k(-));                            \\\n        s = abs(t);                               \\\n        l = max(l, max(s.x,s.z)-2.2);             \\\n        if (l < .01) break;                       \\\n        t += g*l;                                 \\\n    }                                             \\\n    O = l < .01 ? f <0. ? vec4(.2,.6,.9,0) : vec4(.12) : vec4(1)\n  */      \n        \n        \n// After Fabrice is done with it...  517 characters\n/*\n#define v vec3//\n#define N normalize//\n#define C(b) S(( B - abs( mod( b-p, T ) -T/2.) ))               //\n#define M(s) max( .5* abs(s-cos(d-2.*iTime) / d + p.y) -.0025 , \\\n                  s min( C(), C(v(.2,0,.2)) ) )                 //\n#define S(b) length( min(b,.0)) - max( min(b.x,min(b.y,b.z)),.0)//\n#define mainImage(O,U)                                          \\\n    v B = v(.1, 1, .1), T = v(.4,1,.4),                         \\\n      R = iResolution,                                          \\\n      p = 2.* v( sin( iTime*.3 + vec2(0,11)), 1).xzy,           \\\n      f = N( v(0,-.3,0) - p ),                                  \\\n      r = N( v(f.z,0,-f.x)  );                                  \\\n    float d, e, V, n=0.;                                        \\\n    for( ; n++ < 2e2 ; )                                        \\\n        d = 2.* dot(p.xz, p.xz) +2.,                            \\\n        e = max( min( V=M(-), d=M() ), S( .99-abs(p-.1)) ),     \\\n        p += e * N( mat3(f,r,cross(f,r)) * v(R.y,U-.5*R.xy) );  \\\n    e<.001 ? V < d ? O : O = B.xxyy    : O++\n*/\n        \n/* original shader.... 1462 characters\n\n// IQ\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat Map(vec3 p) {\n\t\n    float cd = dot(p.xz, p.xz);\n    float w = .5*cos(cd*2.-iTime*2.)/max(cd+1., 1.);\n    \n    float d = (abs(p.y+w)-.005)*.5;\n    vec3 bp1 = mod(p, vec3(.4, 1, .4))- vec3(.2, .5, .2);\n    vec3 bp2 = mod(p-vec3(.2, 0., .2), vec3(.4, 1, .4))- vec3(.2, .5, .2);\n    float checker = min(sdBox(bp1, vec3(.1, 1., .1)), sdBox(bp2, vec3(.1, 1, .1)));\n    \n    d = max(d, -checker);\n    \n    float d2 = (abs(p.y-w)-.005)*.5;\n    d2 = max(d2, checker);\n    \n    d = min(d, d2);\n    \n    \n    d = max(d, sdBox(p-vec3(.1), vec3(.99)));\n    \n    return d;\n}\n\nint Mat(vec3 p) {\n\t\n    float cd = dot(p.xz, p.xz);\n    float w = .5*cos(cd*2.-iTime*2.)/max(cd+1., 1.);\n    \n    float d = (abs(p.y+w)-.005)*.5;\n    vec3 bp1 = mod(p, vec3(.4, 1, .4))- vec3(.2, .5, .2);\n    vec3 bp2 = mod(p-vec3(.2, 0., .2), vec3(.4, 1, .4))- vec3(.2, .5, .2);\n    float checker = min(sdBox(bp1, vec3(.1, 1., .1)), sdBox(bp2, vec3(.1, 1, .1)));\n    \n    d = max(d, -checker);\n    \n    float d2 = (abs(p.y-w)-.005)*.5;\n    d2 = max(d2, checker);\n    \n    return d<d2 ? 0 : 1;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n\n    vec3 ro = vec3(0, 2, -2);\n\tro.xz *= Rot(iTime*.3);\n    \n    vec3 f = normalize(vec3(0,-.3,0)-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n    \n    float dS, dO;\n    vec3 p;\n    for(int i=0; i<200; i++) {\n        p = ro + dO * rd;\n        dS = Map(p);\n        dO += dS;\n        if(dS<.001 || dO>4.) break;\n    }\n    \n    if(dS<.001) {\n        vec3 n = Normal(p);\n        \n        int mat = Mat(p);\n        \n        if(mat==0)\n            col = vec3(0);\n        else\n            col = vec3(.1, .1, 1);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 392, 428, 428, 853]]}
{"id": "WtBGDm", "name": "Virus #1", "author": "jblanper", "description": "Inspired by https://vimeo.com/124721382. I modified the getNormal function to get a nice white aura.", "tags": ["3d", "raymarching", "blob"], "likes": 2, "viewed": 124, "published": "Public", "date": "1559731839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by https://vimeo.com/124721382\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat map (vec3 p) {\n  vec3 p1 = p;\n  p1.xz *= rotate(iTime * .3);\n  p1.yz *= rotate(iTime * .2);\n  float s1 = sphereSDF(p1, .6);\n  s1 += sin((p1.x + p1.y * p1.z) * (3.14 * 10.) - iTime * 2.) * \n      .015 - sin((p1.x - p1.y * p1.z) * (3.14 * 12.) - iTime) * .01;\n\n  p.z -= iTime * .2;\n  vec3 c = vec3(2., 1.3, 2.);\n  p = mod(p, c) - .5 * c;\n\n  float s2 = sphereSDF(p, .3);\n  s2 += sin((p.x + p.y * p.z) * 20. + iTime * 2.) * \n      .03 + cos(length(p.x - p.y * p.z) * 65. - iTime) * .01;\n\n  return min(s1 * .3, s2 * .28);\n}\n\nfloat trace (vec3 ro, vec3 rd) {\n  float e = .001;\n  float d = e * 2.;\n  float t = 0.;\n  for (int i = 0; i < 60; i++) {\n    if (d < e || t > 50.) continue;\n    d = map(ro + rd * t);\n    t += d;\n  }\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  vec2 e = .01 * vec2(-1., 1.);\n  vec3 nor = e.xyy*map(p+e.xyy) +\n    e.yxy*map(p+e.yxy) +\n    e.yyx*map(p+e.yyx);// +\n    //e.xxx*map(p+e.xxx); // comment to get white aura\n    \n  return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  float color;\n\n  // camera\n  vec3 ro = vec3(0., 0., 3.);\n  vec3 rd = normalize(vec3(uv, -3.));\n\n  float t = trace(ro, rd);\n  vec3 p = ro + rd * t;\n\n  // lighting\n  vec3 light = normalize(vec3(1.));\n  vec3 nor = getNormal(p);\n  float diff = clamp(dot(nor, light), 0., 1.);\n\n  // float color = p.z;\n  color += diff;\n  float fog = 1. / (1. + t * t * .1);\n  color *= fog * 1.5;\n\n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 65, 65, 115], [117, 117, 152, 152, 178], [180, 180, 200, 200, 704], [706, 706, 738, 738, 917], [919, 919, 944, 944, 1150], [1152, 1152, 1209, 1209, 1722]]}
{"id": "WtBGRt", "name": "wave flag", "author": "Stephen_epa", "description": "learn shape function", "tags": ["2d"], "likes": 2, "viewed": 150, "published": "Public", "date": "1560612397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float FiveTriangle(vec2 uv, float rotate)\n{\n    float N = 5.;\n    float a = atan(uv.x, uv.y) + rotate;\n    float b = 3.1415926*2./N;\n    float d = cos(floor(a/b+.5)*b-a) + (1.-abs(fract(a/b+.5)-.5)*2.);\n    return d*length(uv);\n}\n\nvoid WaveFlag(vec2 uv, inout vec3 col)\n{\n    vec2 p = uv;\n    p = 2.*p-1.;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 p1 = p, p2 = p, p3 = p, p4 = p, p5 = p;\n    p1 -= vec2(-1.3, .5);\n    float gap = .42;\n \tfloat r = .61;\n    float a = 3.7;\n    p2 = p1 + r * vec2(cos(a), sin(a));\n    a -= gap;\n    p3 = p1 + r * vec2(cos(a), sin(a));\n    a -= gap;\n    p4 = p1 + r * vec2(cos(a), sin(a));\n    a -= gap;\n    p5 = p1 + r * vec2(cos(a), sin(a));\n    col = mix(col, vec3(.9, .8, 0.), 1.-smoothstep(.5, .6, FiveTriangle(p1*2.5, 3.14)));\n    col = mix(col, vec3(.9, .8, 0.), 1.-smoothstep(.59, .85, FiveTriangle(p2*8.8, 3.14/2.)));\n    col = mix(col, vec3(.9, .8, 0.), 1.-smoothstep(.59, .85, FiveTriangle(p3*8.8, 3.14/3.)));\n    col = mix(col, vec3(.9, .8, 0.), 1.-smoothstep(.59, .85, FiveTriangle(p4*8.8, 3.14/4.)));\n    col = mix(col, vec3(.9, .8, 0.), 1.-smoothstep(.59, .85, FiveTriangle(p5*8.8, 3.14/5.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n \tuv.y += sin(iTime+uv.x*15.)*.03; // may be noise wave, it's so rhythmic\n\tvec3 col = vec3(0.);\n    vec3 bgcol = mix(vec3(.9, .3, 0.), vec3(.9, .8, .1), uv.y);\n    bgcol = vec3(.8, 0., 0.);\n    col += bgcol;\n\tWaveFlag(uv, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 229], [231, 231, 271, 271, 1146], [1148, 1148, 1205, 1205, 1511]]}
{"id": "WtBGWK", "name": "lord created IFS", "author": "sayachang_bot", "description": "tested IFS", "tags": ["ifs"], "likes": 1, "viewed": 83, "published": "Public", "date": "1561047673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\nconst float EPS = .001;\n\nvec3 hsv(float h, float s, float v){return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\nvec2 rot(vec2 p, float a){\n    return vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\nvec3 rep(vec3 p, float a){\n    return mod(p-.5*a,a)-.5*a;\n}\n\nfloat dBox(vec3 p){\n    vec3 d = abs(rep(p,2.))-.15;\n    return length(max(d,0.0));\n}\n\nfloat indexer(float i){\n    return floor(8192.*i)/8.;\n}\n\nvec2 map(vec3 p){\n    vec3 q=p;\n    // use IFS\n    // https://qiita.com/kaneta1992/items/21149c78159bd27e0860\n    for(int i=0;i<10;++i){\n        q=abs(q)-1.3;\n        q.xy=rot(q.xy,4.9);\n        q.xz=rot(q.xz,-1.75);\n    }\n    float index = floor(indexer(q.x)+indexer(q.y)+indexer(q.z))/10.;\n    q.xy=rot(q.xy,iTime);\n    q.yz=rot(q.yz,iTime);\n    return vec2(dBox(q),index);\n}\n\nvec3 normal(vec3 p){\n    vec2 xy=vec2(EPS,.0);\n    return normalize(vec3(\n        map(p+xy.xyy).x-map(p-xy.xyy).x,\n        map(p+xy.yxy).x-map(p-xy.yxy).x,\n        map(p+xy.yyx).x-map(p-xy.yyx).x\n    ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.xy;\n    vec3 ro=vec3(0.,.0,-10.+mod(iTime,64.)*abs(sin(iTime/64.))), rd=normalize(vec3(p,1.8)), N;\n    ro.xy=rot(ro.xy, PI/2.+PI);\n    ro.xz=rot(ro.xz, PI/2.);\n    vec3 ray=ro;\n    vec2 d=vec2(EPS);\n    for(int i=0;i<32;++i){\n        d=map(ray);\n        if(d.x<EPS){\n            N=normal(ray);\n            break;   \n        }\n        ray+=d.x*rd;\n    }\n    \n    vec3 L=normalize(vec3(-1.));\n    float hl=.5+.5*max(0.,dot(N,L));\n    fragColor = vec4(hsv(EPS*d.y,.98,1.4)/ray.z+.88*hl, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 89, 89, 162], [164, 164, 190, 190, 255], [257, 257, 283, 283, 316], [318, 318, 337, 337, 403], [405, 405, 428, 428, 460], [462, 462, 479, 479, 839], [841, 841, 861, 861, 1051], [1053, 1053, 1110, 1110, 1666]]}
{"id": "wtBGzK", "name": "[twitch] Broken Space", "author": "NuSan", "description": "Live streamed on twitch: https://www.twitch.tv/nusan_fx\nMade originally with Kodelife", "tags": ["raymarching", "neon"], "likes": 15, "viewed": 655, "published": "Public", "date": "1560202316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nLive streamed on twitch: https://www.twitch.tv/nusan_fx\nMade originally with Kodelife\n\n*/\n\nfloat time=0.0;\nfloat bpm=0.0;\n\nfloat knobtime(int x) {return iTime*4.0;}\nfloat key(float x) {return clamp((sin(x*3.0 - iTime)-0.97)*100.0,0.0,1.0);}\n\n//////////// GEOMETRY ////////////\n\nfloat pi=acos(-1.0);\n\nfloat sph(vec3 p, float s) {return length(p)-s;}\nfloat cyl(vec2 p, float s) {return length(p)-s;}\nfloat boxgrid(vec3 p, vec3 s, vec3 r) {p=abs(p)-s; p=abs(max(p,p.yzx))-r; return max(p.x,max(p.y,p.z));}\nfloat boxgrid(vec3 p, float s, float r) {return boxgrid(p, vec3(s), vec3(r));}\nfloat octa(vec3 p, float s) { p=abs(p); return dot(p,normalize(vec3(0.7)))-s;}\n\n\n//////////// MORPH ////////////\n\nfloat rnd(float t) { return fract(sin(t*758.655)*352.741); }\nfloat curve(float t, float d) { t/=d; return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0)); }\n\nmat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nmat3 rotaxis(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat noise(vec3 p) {\n    vec3 ip=floor(p);\n    p=fract(p);\n    p=smoothstep(0.0,1.0,p);\n    vec3 st=vec3(7,137,233);\n    vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n    vec4 v=mix(fract(sin(val)*9853.241), fract(sin(val+st.x)*9853.241), p.x);\n    vec2 v2=mix(v.xz,v.yw,p.y);\n    return mix(v2.x,v2.y,p.z);\n}\n\n#define repeat(VALUE,DISTANCE) (fract((VALUE)/DISTANCE+0.5)-0.5)*DISTANCE\n#define repid(VALUE,DISTANCE) (floor((VALUE)/DISTANCE+0.5)-0.5)\n\n//////////// PALETTES ////////////\n\nfloat pulse(float t, float s) {\n    float v=smoothstep(0.0,1.0,fract(t));\n    return mix(v,1.0-v,pow(v,s));\n}\nfloat pulse(float t) { return pulse(t,8.0); }\n\nfloat ipulse(float t, float s) {\n    return 1.0-pulse(t,s);\n}\n\nfloat ipulse(float t) { return ipulse(t,8.0); }\n\nvec3 tweakcolor(vec3 col) {\n    col *= rotaxis(vec3(1), time*0.2);\n    //col = mix(vec3(dot(col, vec3(0.7))), col, 1.0);\n    col *= 0.4;\n    col *= pow(col, vec3(1.3));\n\n    return col;\n}\n\n//////////// SHADING ////////////\nfloat map(vec3 p);\n\nvec3 getnorm(vec3 p) {\n    vec2 off=vec2(0.1,0);\n    return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat getao(vec3 p, vec3 n, float d) {\n    return clamp(map(p+n*d)/d,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float d) {\n    return clamp(map(p+r*d),0.0,1.0);\n}\n\n//////////// TUNNEL ////////////\n\nvec3 tunnel(vec3 p) {\n    float t=knobtime(0)*0.1;\n    vec3 off=vec3(0);\n    off.x += sin(p.z*0.01 + t + 12.3)*60.0;\n    off.y += sin(p.z*0.012 + t)*50.0;\n    return off;\n}\n\n//////////// MAP ////////////\n\nvec2 fractal(inout vec3 p) {\n\n    float s=10.0;\n    float mm=10000.0;\n    float id=0.0;\n    for(int i=0; i<4; ++i) {\n        float t=knobtime(3)*0.2 + float(i);//curve(time, 0.3+i*0.3);;\n        p.xy *= rot(t);\n        p.yz *= rot(t*0.7);    \n        id += dot(sign(p), vec3(1,1.7,2.3));\n        p=abs(p);\n        mm=min(mm, min(p.x,min(p.y,p.z)));\n        p-=s;\n        s*=0.5;\n    }\n\n    return vec2(mm, id);\n}\n\n// KODELIFE\n\nfloat oo = 0.0;\nvec3 trp=vec3(0);\nfloat tra=0.0;\nfloat map(vec3 p) {\n\n    float tt = knobtime(0);\n    \n    vec3 bp=p;\n    \n    p.xz*=rot(time*0.1);\n    p.xy*=rot(time*0.12);\n        \n    vec2 mm = fractal(p);\n    \n    float d = abs(mm.x)-0.3;\n    float dist = rnd(mm.y);\n\n    float t1 = max(d,sph(bp, 60.0));\n    float t2 = sph(bp, 40.0 + sin(tt*0.1+dist*32.0 + pow(fract(bpm),5.0))*20.0);\n    t2 = abs(t2)-0.3;\n    t2 = max(t2, -d+0.3);\n    \n    d=min(t1, t2);\n    \n    p=bp;\n    \n    p+=tunnel(p);\n    \n    vec3 bp2 = p;\n    \n    p.xy *= rot(sin(p.z*0.01 + tt*0.1));\n    p.yz *= rot(sin(p.z*0.01 + tt*0.1)*0.3);\n    p+=noise(p*0.02)*30.0;\n    p=repeat(p, 40.0);\n    float t3 = boxgrid(p, 7.0, 0.2);\n    t3 = min(t3, cyl(p.xy, 1.0));\n    t3 = min(t3, cyl(p.yz, 1.0));\n    t3 = min(t3, max(abs(cyl(bp.xy, 100.0 + sin(tt*0.3 + bp.z*0.05)*20.0))-3.0, abs(p.z)-0.4)*0.7);\n    t3=max(t3, -cyl(bp.xy, 80.0)); \n    \n    d=min(d, t3);\n    \n    float t5=abs(octa(bp2, 120.0))-1.0;\n    t5 = max(t5, mm.x-0.2);\n    oo+=0.2/(0.2+t5);\n    d=min(d, t5);\n    \n    \n    tra=(t1<=d)?1.0:0.0;\n        \n    return d;\n}\n\nvec3 sky(vec3 r) {\n    vec3 col=vec3(0);\n    vec3 rr = abs(repeat(r,0.1))*13.0;\n    col += max(rr.z,rr.y);\n    col *= pow(abs(r.x),10.0);\n    return col;\n}\n\nvec3 raymarch(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec3 s=vec3((curve(time, 0.7)-.5)*5.0,0,-150.0);\n    vec3 t=vec3(0,0,0);\n    \n    s -= tunnel(s);\n    t -= tunnel(t);\n    \n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz, vec3(sin(time*0.1)*0.1,1,0)));\n    vec3 cy=normalize(cross(cz, cx));\n    \n    float fov = 0.3 + pulse(bpm*0.5,20.0)*0.2;\n    vec3 r=normalize(uv.x*cx + uv.y*cy + fov*cz);\n    \n    float maxdist=300.0;\n        \n    vec3 p=s;\n    float at=0.0;\n    float dd=0.0;\n    for(int i=0; i<200; ++i) {\n        float d=map(p);\n        if(d<0.001) {\n            if(tra>0.5) {\n                //vec3 n=getnorm(p);\n                float didi = 1.0-length(p)/60.0;\n                col += vec3(0.0002*float(i)*didi,0,0);\n                d=0.2;\n            } else {\n                break;\n            }\n        }\n        if(dd>maxdist) break;\n        p+=r*d;\n        dd+=d;\n        at += (1.0-tra)*1.0/(1.0+d);\n    }\n\n    float fog = 1.0-clamp(dd/maxdist,0.0,1.0);\n    \n    vec3 n=getnorm(p);\n    vec3 l=normalize(vec3(1,3,-2));\n    vec3 h=normalize(l-r);\n    float spec=max(0.0,dot(h,n));\n    float fres=pow(1.0-abs(dot(r,n)), 3.0);\n    \n    vec3 col1 = vec3(0.7,0.8,0.6);\n    vec3 col2 = vec3(0.8,0.8,0.5)*3.0;\n    float iter = pow(abs(r.z), 7.0);\n    vec3 atmocol = mix(col1, col2, iter);\n    \n    float ao=1.0;//getao(p,n,3.0) * getao(p,n,1.5) * 3.0;\n    float sss=getsss(p,r,2.0) + getsss(p,r,10.0);\n    \n    float fade = fog * ao;\n    col += (max(0.0,dot(n,l)) * .5+.5) * 0.7 * fade * atmocol * 0.2;\n    col += max(0.0,dot(n,l)) * (0.3 + 0.6*pow(spec,4.0) + 0.9*pow(spec,30.0)) * fade * atmocol*0.7;\n    col += pow(1.0-fog,5.0) * vec3(0.7,0.5,0.2);\n    col += pow(oo*0.15,0.7)*vec3(0.5,0.7,0.3);\n    \n    col += pow(at*0.035,0.4) * atmocol;\n\n    col += key(fract(length(p)*0.02)) * vec3(0.2,1.0,fract(trp.x*0.1)) * 10.0 * fog;\n    col *= 1.8,\n\n    col = tweakcolor(col);\n    \n    col *= 1.2-length(uv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime;\n    bpm=time*90.0/60.0;\n    vec2 uv = -0.5 + 1. * fragCoord/iResolution.xy;\n    uv.y=-uv.y;\n    uv.x *= iResolution.x/float(iResolution.y);\n\n    vec2 buv=uv;\n    \n    vec3 col=vec3(0);\n    col += raymarch(uv);\n \n    col *= 1.2-length(buv);\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 150, 150, 168], [169, 169, 189, 189, 244], [246, 304, 332, 332, 352], [353, 353, 381, 381, 401], [402, 402, 441, 441, 506], [507, 507, 548, 548, 585], [586, 586, 615, 615, 664], [667, 700, 720, 720, 760], [761, 761, 792, 792, 887], [889, 889, 908, 908, 983], [985, 985, 1023, 1023, 1495], [1497, 1497, 1518, 1518, 1812], [1953, 1989, 2020, 2020, 2098], [2099, 2099, 2121, 2121, 2144], [2146, 2146, 2178, 2178, 2207], [2209, 2209, 2232, 2232, 2256], [2258, 2258, 2285, 2285, 2445], [2447, 2501, 2523, 2523, 2634], [2636, 2636, 2674, 2674, 2716], [2718, 2718, 2757, 2757, 2797], [2799, 2833, 2854, 2854, 3005], [3007, 3038, 3066, 3066, 3450], [3452, 3514, 3533, 3533, 4565], [4567, 4567, 4585, 4585, 4722], [4724, 4724, 4748, 4748, 6678], [6680, 6680, 6737, 6737, 7029]]}
{"id": "Wtj3Dd", "name": "Mandelnoise", "author": "SSHantaram", "description": "With fragCoord as input a noise function is used to calculate an x and y offset from a point of interest", "tags": ["random", "madelbrot"], "likes": 2, "viewed": 74, "published": "Public", "date": "1561581788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITERATIONS = 150;\nconst float ESCAPE_RADIUS = 10.0;\nconst float ZOOM_FACTOR = 0.1;\nconst float OFFSET_FACTOR = 1.0;\n\nfloat hash(vec3 p) {\n    \n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat layeredNoise(in vec3 x) {\n    return 0.7*noise(x) + 0.24*noise(x*4.0) + 0.055*noise(x*8.0) + 0.01*noise(x*16.0) + 0.005*noise(x*32.0);\n}\n\nfloat smoothIterationCount(vec2 c) {\n    \n    float smoothCount = 0.0;\n\tvec2 z  = vec2(0.0);\n    \n    for( int i=0; i < MAX_ITERATIONS; i++ ) {\n        \n    \tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        \n    \tif( dot(z,z)>(ESCAPE_RADIUS*ESCAPE_RADIUS) ) break;\n        \n    \tsmoothCount += 1.0;\n    }\n    return smoothCount - log2(log2(dot(z,z))) + 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 xy = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // pseudo random offset\n    float xCoord = 2.0*OFFSET_FACTOR*layeredNoise(vec3(xy + vec2(12.0, 43.0 + iTime*0.05), iTime*0.1)) - OFFSET_FACTOR;\n    float yCoord = 2.0*OFFSET_FACTOR*layeredNoise(vec3(xy + vec2(25.0, 64.0 - iTime*0.02), iTime*0.1 + 100.0)) - OFFSET_FACTOR;\n    \n    vec2 c = vec2(xCoord, yCoord);\n    c = vec2(-0.05, 0.6805) + c*ZOOM_FACTOR;\n    \n    float sl = smoothIterationCount(c);\n    \n    vec3 col = vec3(1.0, 1.0, 1.0)*sl*0.02;\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtj3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 151, 151, 251], [253, 253, 279, 279, 758], [760, 760, 791, 791, 902], [904, 904, 940, 940, 1270], [1272, 1272, 1329, 1329, 1898]]}
{"id": "wtj3zc", "name": "sponge--fractal--modificado2", "author": "jorge2017a1", "description": "sponge fractal modificado", "tags": ["3d", "fractal", "sponge", "codesource"], "likes": 7, "viewed": 197, "published": "Public", "date": "1560606468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// http://www.iquilezles.org/www/articles/menger/menger.htm\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.20, 0.00,  0.30 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    //float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n    //float ani =  -10.0*cos(0.5*iTime );\n    float ani;\n    ani=1.0;\n    \n\tfloat off = 1.5*sin( 0.01*iTime );\n    //off=0.005*iTime;\n    off=0.0005;\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.3*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0,-1.1,1.0,1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.002 || t>15.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\n// light\nvec3 light = normalize(vec3(1.0,0.9,0.3));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\n    vec3 col = mix( vec3(0.3,0.2,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow( pos, light, 0.01, 64.0 );\n\n\t\tfloat dif = max(0.1 + 0.9*dot(nor,light),0.0);\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        //lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n\n        /*vec3 matcol = vec3(\n            0.5+0.5*cos(0.0+2.0*tmat.z),\n            0.5+0.5*cos(1.0+2.0*tmat.z),\n            0.5+0.5*cos(2.0+2.0*tmat.z) );\n        col = matcol * lin;*/\n        col=lin;\n    }\n\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    //vec3 ro = 1.1*vec3(2.5*sin(0.25*ctime),1.0+1.0*cos(ctime*.13),2.5*cos(0.25*ctime));\n    vec3 ro = vec3(0.55*sin(0.25*ctime),0.5+1.0*cos(ctime*.13),1.5+cos(0.25*ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtj3zc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1139, 1166, 1166, 1197], [1198, 1198, 1229, 1229, 1320], [1448, 1448, 1471, 1471, 2256], [2258, 2258, 2300, 2300, 2580], [2582, 2582, 2647, 2647, 2873], [2875, 2875, 2905, 2905, 3143], [3145, 3198, 3237, 3261, 4215], [4217, 4217, 4274, 4274, 4848], [4851, 4851, 4945, 4945, 5164]]}
{"id": "wtj3zK", "name": "simple flower", "author": "boysx", "description": "simple flower uwu", "tags": ["2d", "simple"], "likes": 5, "viewed": 322, "published": "Public API", "date": "1560319306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)-0.5;\n    vec2 uv2 = uv;\n    vec2 uv3;\n    float stalk;\n    float petal;\n    float center;\n    float clouds;\n    uv.x *= iResolution.x/iResolution.y;\n\tuv *= 5.;\n    uv3 = uv;\n    \n    uv3 -= vec2(0.2, 0.0);\n    if(uv2.y < 0.15)\n   \t\tstalk = 1.- smoothstep(0.80, 1.0, abs((uv3.x + sin(uv3.y * 0.5)) * 20.));\n    \n    uv -= vec2(-0.2, 0.8);\n    float r = cos(atan(uv.y, uv.x) * 7.) * .6 + 0.1;\n    petal = smoothstep(r-0.05, r, 1.-length(uv));\n    \n    center = smoothstep(0.8 - 0.01, 0.8, 1.-length(uv));\n    \n    vec2 c0 = uv3;\n    c0.x += iTime;\n    c0 = mod(c0, vec2(8., 4.)) - vec2(1.8, 1.4);\n    \n    if(uv2.y > 0.05)\n    {\n    \tr = (sin(c0.x * 8.) * 0.8 + 9.);\n    \tc0 *= 5.;\n    \tclouds += 1.-smoothstep(r-0.1, r, length(vec2(c0.x, c0.y * 3.)));\n    }\n\n    \n    // mix layer together\n    vec3 col = vec3(0.0, 0.6, 1.0);\n    col = mix(col, vec3(1.0, 1.0, 1.0), clouds);\n    col = mix(col, vec3(0.2, 0.6, 0.2), stalk);\n    col = mix(col, vec3(1.0, 0.4, 0.4), petal);\n    col = mix(col, vec3(1.0, 1.0, 0.4), center);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtj3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1156]]}
{"id": "wtjGDc", "name": "[twitch] Sable Bat", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SableBat.glsl", "tags": ["raymarching", "animal", "sand"], "likes": 17, "viewed": 303, "published": "Public", "date": "1561412690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SableBat.glsl\n*/\n\nfloat time;\nfloat pi=acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*.5+.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k) * h;\n}\n\nfloat wings(vec3 p) {\n  \n  p.x = abs(p.x);\n  \n  float flop = pow(max(0.0,sin(time*4.0 - p.x*0.15)*0.8+0.2),10.0);\n  p.xz *= rot(clamp(p.x,0.0,2.0) * 0.3 * flop);\n  \n  float ang = p.x + p.y*0.5;\n  float decal = -2.0;\n  p.y -= decal;\n  p.xy *= rot(-0.2 * clamp(ang*0.9-ang*ang*0.3, -5.0, 2.0));\n  p.y += decal;\n  \n  vec3 p2 = p;\n  float size = 0.4;\n  p2.x = (fract(p2.x/size+0.5)-0.5)*size;\n  p2.y -= clamp(p2.y,-2.0 + cos(p.x*0.5)*1.5,0.0);\n  float d = max(length(p2)-0.2, abs(p.x)-5.0);\n  \n  p.xz *= rot(p.x * 0.012);  \n  \n  vec3 p3 = p;\n  float size2 = 0.3;\n  p3.x = (fract(p3.x/size2+0.5)-0.5)*size2;\n  p3.y -= clamp(p3.y,-1.0 + cos(p.x*0.5)*0.8,-0.5);\n  p3.z =abs(p.z+0.1)-0.15;\n  d = smin(d, max(length(p3)-0.17, abs(p.x)-4.2), 0.2);\n  d = smin(d, p.z+0.16, -0.12);\n  \n  \n  d*=0.5;\n  \n  return d;\n  \n}\n\nfloat body(float d, vec3 p) {\n  \n  vec3 bp = p;\n  vec3 bp2 = p;\n  \n  p.y-=0.4;\n  p.zy *= rot(abs(p.y)*0.2);\n    \n  vec3 p2 = p;\n  \n  p2.y -= clamp(p2.y,-1.0,2.0);\n    \n  d = smin(d, length(p2)-0.5 + p.y*0.19, 0.8);\n  d = smin(d, length(bp+vec3(0,1.3,-0.9))-0.9, 0.2);\n  //bp.x=abs(bp.x)-0.4;\n  bp.x=smin(bp.x,-bp.x, 0.2)+0.4;\n  bp.xy *= rot(bp.x*0.5);\n  d = smin(d, -(length(bp+vec3(0,1.3,-1.4))-0.12), -0.6);\n  d = smin(d, -(length(bp+vec3(-0.17,0.7,-1.4))-0.1), -0.2);\n  \n  bp2.x = abs(bp2.x);\n  bp2.xz *= rot(-bp2.x*0.3 + bp2.y*0.14);\n  bp2.yz *= rot(-0.6);\n  bp2 -= vec3(0.1,0.0,-1.2);\n  float hear = length(bp2 + vec3(-0.5,2.5,-1.2))-0.6;\n  hear = smin(hear, -(length(bp2 + vec3(-0.5,2.5,-1.6))-0.6), -0.3);\n  hear = smin(hear, -(length(bp2 + vec3(-0.9,2.1,-1.1))-0.1), -0.4);\n  \n  d=smin(d, hear, 0.17);\n  \n  return d;\n}\n\nfloat claws(float d, vec3 p) {\n  \n  p.x=-abs(p.x);\n  vec3 bp=p;\n  \n  p += vec3(0.5,-2.0,0);\n  \n  p.zy *= rot(sin(time*4.0+1.0)*0.5+0.3);\n  p.y -= 0.5;\n  \n  p.x=-abs(p.x);\n  p.xz *= rot(0.4);\n  p.x=-abs(p.x);\n  p.xz *= rot(0.2);\n  \n  float donut = length(vec2(length(p.zy)-0.6, p.x)) - 0.2;\n  donut = smin(donut, -(length(p-vec3(0,1,-0.4))-0.7), -1.4 + clamp(-bp.x*0.5,0.0,1.0)-0.4);\n  bp.xy *= rot(0.15);\n  donut = smin(donut, max(length(bp.xz+vec2(0.2,0.0))-0.12, abs(bp.y-1.0)-1.0), 0.2);\n  d = smin(d, donut, 0.2);\n  \n  return d;\n  \n}\n\nfloat noise(vec2 p) {\n  vec2 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec2 st=vec2(37,133);\n  vec4 val = fract(sin(dot(ip, st) + vec4(0,st.x, st.y, st.x+st.y))*2375.655);\n  vec2 v = mix(val.xz,val.yw, p.x);\n  return mix(v.x, v.y, p.y);\n}\n\nfloat mat = 0.0;\nfloat map(vec3 p) {\n  \n  vec3 tp = p;\n  tp.z += time*10.0;\n  tp.y += sin(time*0.7)*5.0;\n  float f = noise(tp.xz*0.08)*0.5;\n  f += noise(tp.xz*0.16)*0.25;\n  f += noise(tp.xz*0.32)*0.125;\n  f = abs(f-0.5);\n  float d2 = 8.0-tp.y + f*13.0;\n  d2 *= 0.7;  \n  \n  \n  p.yx *= rot(sin(time*0.7) * 0.3);\n  p.yz *= rot(-0.7 + sin(time) * 0.3);\n  \n  \n  p.y += sin(time*4.0 + 2.5 + abs(p.x)*0.4)*0.3;\n  \n  float d = wings(p);\n  \n  d = body(d, p);\n  \n  d = claws(d, p);\n  \n  \n  d = min(d, d2);\n  \n  mat = abs(d-d2)<0.01?1.0:0.0;\n  \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  p.yz *= rot(sin(time)*0.2+0.2);\n  p.xz *= rot(2.7 + time*0.4);\n  p.yz *= rot(sin(time)*0.1-0.1);\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // We mod the time to make it repeat, because as we scroll the ground, the lack of precision start to be visible\n  time = mod(iTime, 50.0);\n\n  vec3 s=vec3(0,0,-18);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  float i=0.0;\n  float dd=0.0;\n  for(i=0.0; i<100.0; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      i += d/0.001;\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  \n  float curmat=mat;\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float itfog = pow((1.0-i/100.0)*1.1,3.0);\n  float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n  \n  vec3 l=normalize(-vec3(1,3,-2));\n  vec3 h=normalize(l-r);\n  float fre=pow(1.0-abs(dot(n,r)),3.0);\n  \n  float ao = clamp(map(p+n*0.5)/0.5,0.0,1.0);\n    \n  vec3 col = vec3(0);\n  vec3 diff = mix(vec3(0.4,0.5,0.9)*2.0, vec3(0.9,0.6,0.5)*2.0, curmat);\n  col += max(0.0, dot(n,l)) * fog * ao * (diff +  2.0*pow(max(0.0,dot(h,n)), 10.0)*(1.0-curmat));\n  col += (n.y * 0.5 + 0.5) * vec3(1,0.5,0.3) * 0.8 * fog;\n  col += fre * vec3(1,0.7,0.5) * 3.0 * fog * ao * (-n.y*.5+.5) * (1.0-curmat*0.6);\n  \n  vec3 rr = normalize(p);\n  vec2 skyuv = vec2(abs(atan(rr.x,rr.z)), rr.y);\n  float ff = (-noise(skyuv*vec2(4,30))*0.1-noise(skyuv*vec2(6,19)*2.0)*0.05) * 0.33;\n  vec3 sky = mix(vec3(1,0.7,0.5)*0.3, vec3(1.0,0.2,0.2)*3.0, pow(max(0.0,r.z), 80.0)) * pow(max(0.0,-r.y*0.5+1.2 + ff),5.0);\n  col += sky * pow((1.0-fog)*1.2, 3.0);\n          \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 238, 238, 309], [311, 311, 350, 350, 433], [435, 435, 456, 456, 1240], [1242, 1242, 1271, 1271, 2068], [2070, 2070, 2100, 2100, 2607], [2609, 2609, 2630, 2630, 2861], [2880, 2880, 2899, 2899, 3410], [3412, 3412, 3436, 3436, 3544], [3547, 3547, 3604, 3604, 5285]]}
{"id": "wtjGDW", "name": "smth like distance semicircle", "author": "Imsure1200q_1UWE130", "description": "you get the point", "tags": ["bl"], "likes": 0, "viewed": 309, "published": "Public API", "date": "1559662070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define squv *= iResolution.x/iResolution.y;\n#define PI 3.14159\n#define pi PI\n#define twopi 6.2831854\n\nmat2x2 rot( float d ) {\n    return mat2x2 ( cos(d), sin(d),\n                    -sin(d), cos(d) );\n}\n\nfloat map( float a, float a1, float a2, float b1, float b2 ) {\n    return (a - a1) / (a2 - a1) * (b2 - b1) + b1;\n}\n\nfloat totalAtan( float y, float x ) {\n    float v = 0.;\n    \n    if(x>0.)v=atan(y/x);\n    if(y>=0. && x<0.)v=pi+atan(y/x);\n    if(y<0. && x<0.)v=-pi+atan(y/x);\n    if(y>0. && x==0.)v=pi/2.;\n    if(y<0. && x==0.)v=-pi/2.;\n    if (v<0.) v=v+2.*pi;\n    \n    return v;\n}\n\nfloat dsemicircle( vec2 p, vec2 o, float r, float nr, float xr ) {\n    \n    //float rcos = dot(normalize(p-o), vec2(1.,0.));\n    \n    //nr += 0.01;\n    //xr += 0.01;\n    if(nr < 0.) {\n        float abnr = abs(nr);\n        float ffnr = floor( abnr / ( twopi ) ) + 1.;\n        float addition = ffnr * twopi;\n        nr += addition;\n    }\n    //nr += pi;\n    nr = mod(nr, twopi);\n    \n    //nr %= 2.*PI;\n    //xr %= 2.*PI;\n    xr = clamp(xr, 0., twopi);\n    \n    \n    float rd = totalAtan(p.y-o.y, p.x-o.x);\n    float dr = 0.;\n    float xnr = xr+nr;\n    \n    bool isContained = false;\n    \n    if(rd >= nr && rd <= xnr) { isContained = true; }\n    if(xnr >= twopi) {\n        dr = xnr - twopi;\n        if(rd+0.001 <= dr) { isContained = true; }\n    }\n    if(!isContained) {\n        if(rd < xnr) {\n        float rav = (dr+nr)/2.;\n        if(dr == 0.) dr = xnr;\n        //float chr = mix(dr, nr, step(rav, rd));\n        float chr = rd >= rav ? nr : \n            rd-xnr+twopi >= nr-rd ? xnr : nr;\n        rd = chr;\n        } else {\n            float rav = (twopi+xnr)/2.;\n            float chr = rd >= rav ? nr : xnr;\n            rd = chr;\n        }\n    }\n    \n    mat2x2 ro = rot(rd);\n    \n    vec2 rr = ro * vec2(r, 0.);\n    vec2 pr = rr + o;\n    \n    return distance(pr, p);\n    //return rd;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    mo.x squv uv.x squv\n\n    // Time varying pixel color\n    ///vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(pow(sin(dsemicircle( uv, vec2(0.5), distance(mo, vec2(0.5)), iTime, PI)*64.+iTime)/2.+0.5, 0.07));\n    \n        \n    //vec3 col = vec3(dsemicircle(uv, vec2(0.5), distance(mo, vec2(0.5)), 0.)/pi/2.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 126, 126, 203], [205, 205, 267, 267, 319], [321, 321, 358, 358, 587], [589, 589, 655, 754, 1883], [1885, 1885, 1942, 1992, 2471]]}
{"id": "WtjGR3", "name": "Fire in the Wind - 2", "author": "GabrieleGiuseppini", "description": "Reverse-engineered \"Flame in the Wind\" by kuvkar, and changed it in order to render burning fire rather than candle fire.\n\nTo be used in Floating Sandbox (https://gamejolt.com/games/floating-sandbox/353572).", "tags": ["fire"], "likes": 3, "viewed": 197, "published": "Public", "date": "1560501619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Based on \"Flame in the Wind\" by kuvkar (https://www.shadertoy.com/view/4tXXRn)\n//\n\nfloat GetNoise(vec2 uv) // -> (0.25, 0.75)\n{\n    float n = (texture(iChannel0, uv).r - 0.5) * 0.5;\n    n += (texture(iChannel0, uv * 2.0).r - 0.5) * 0.5 * 0.5;\n    \n    return n + 0.5;\n}\n\nmat2 GetRotationMatrix(float angle)\n{\n    mat2 m;\n    m[0][0] = cos(angle); m[0][1] = -sin(angle);\n    m[1][0] = sin(angle); m[1][1] = cos(angle);\n\n    return m;\n}\n\n\n#define paramWindSpeedMagnitude -80.0\n#define flamePersonalitySeed 1000.0\n\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5); // (x=[-0.5, 0.5], y=[-0.5, 0.5])\n    vec2 flameSpacePosition = uv + vec2(0.0, 0.5); // (x=[-0.5, 0.5], y=[0.0, 1.0])\n    uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    float paramTime = iTime;\n    \n    ////////////////////////////////////////\n    \n    //\n    // Flame time\n    //\n    \n    #define FlameSpeed 0.23\n    float flameTime = paramTime * FlameSpeed;\n\n    //\n    // Apply wind\n    //\n    \n    // Rotation angle\n    float windAngle = -sign(paramWindSpeedMagnitude) * 0.4 * smoothstep(0.0, 100.0, abs(paramWindSpeedMagnitude));\n    \n    // Rotation angle is higher the higher we go\n    windAngle *= flameSpacePosition.y;\n\n    // Make rotation angle time-dependent\n    windAngle *= (1.0 + sin(iTime)) / 2.0;\n    \n    // Rotate around bottom\n    uv = GetRotationMatrix(windAngle) * (uv + vec2(0.0, 0.5)) - vec2(0.0, 0.5);\n\n    \n    //\n    // Get noise for this fragment and time\n    //\n    \n    #define NoiseResolution 0.7\n    float fragmentNoise = GetNoise(uv * NoiseResolution + vec2(flamePersonalitySeed)/777.0 + vec2(0.0, -flameTime/0.8));\n    \n    \n    //\n    // Rotate fragment based on noise and vertical extent\n    //\n    \n    float angle = (fragmentNoise - 0.5);\n\n    // Magnify rotation amount based on distance from center of quad\n    angle /= max(0.1, length(uv));\n\n    // Straighten the flame at the bottom and make full turbulence higher up\n    angle *= smoothstep(-0.1, 0.5, flameSpacePosition.y);\n\n    // Smooth the angle\n    angle *= 0.45;\n\n    // Rotate!\n    uv += GetRotationMatrix(angle) * uv;    \n    \n    \n    \n    //\n    // Calculate thickness\n    //\n    \n    #define FlameWidth 0.5\n    float thickness = 1.0 - smoothstep(0.1, FlameWidth, abs(uv.x));\n    \n    // Taper flame depending on randomized height\n    float variationH = fragmentNoise * 1.4;\n    thickness *= smoothstep(1.3, variationH * 0.5, flameSpacePosition.y); // Taper up\n    thickness *= smoothstep(-0.15, 0.15, flameSpacePosition.y); // Taper down\n    \n    // Focus (less halo, larger body)\n    #define FlameFocus 2.0\n    thickness = pow(clamp(thickness, 0.0, 3.0), FlameFocus);\n\n    \n    //\n    // Emit\n    //\n    \n    vec3 col1 = mix(vec3(1.0, 1.0, 0.6), vec3(1.0, 1.0, 1.0), thickness);\n    col1 = mix(vec3(1.0, 0.4, 0.1), col1, smoothstep(0.3, 0.8, thickness));    \n\n    // Blend with background\n    float alpha = smoothstep(0.0, 0.5, thickness);\n    fragColor = mix(vec4(1.0), vec4(col1, 1.0), alpha);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 133, 133, 275], [277, 277, 314, 314, 440], [518, 569, 626, 626, 3123]]}
{"id": "WtjGRc", "name": "Paper scroll", "author": "Ping2_0", "description": "Made with paper, scissors and a little thread.\nSoundcloud music : Jamal Green - Equilinox game music", "tags": ["2d", "paper", "cutting"], "likes": 101, "viewed": 2833, "published": "Public", "date": "1560537760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Ping 2.0 14/06/2019\n * \n * TODO : \tCloud rocking\n**/\nconst vec3 c0 = vec3(.042,0.530,0.159);\nconst vec3 c1 = vec3(.142,0.630,0.259);\nconst vec3 c2 = vec3(0.242,0.730, 0.359);\nconst vec3 c3 = vec3(0.342,0.830,0.459);\nconst vec3 c4 = vec3(0.442,0.930,0.559);\n\nconst vec3 c5 =vec3(1);\nconst vec3 c6 = vec3(0.95, 0.95 ,1.0);\nconst vec3 c7 = vec3(0.9, 0.9,1.0);\n//const vec3 c8 = vec3(0.85, 0.85 ,1.0);\n//const vec3 c9 = vec3(0.8,0.85, 0.95);\n\n// min dist 2 circles (or ellipsis)\n#define GRND1 min(length(fract(op)*vec2(1, 3) - vec2(0.5,0.18)) - 0.3,     length(fract(op+vec2(0.5, 0))*vec2(1, 2) - vec2(0.5,0.09)) - 0.35)\n#define GRND2 min(length(fract(op)*vec2(1.2, 2.5) - vec2(0.5,0.45)) - 0.4, length(fract(op+vec2(0.65, 0))*vec2(1, 1.4) - vec2(0.5,0.25)) - 0.35)\n#define GRND3 min(length(fract(op)-vec2(0.5,0.3))-0.35, length(fract(op+vec2(0.5, 0))-vec2(0.5,0.25))-0.3)\n#define GRND4 min(length(fract(op)-vec2(0.5,0.1))-0.3, length(fract(op+vec2(0.5, 0))-vec2(0.5,0.1))-0.4)\n#define GRND5 min(length(fract(op)-vec2(0.5,0.2))-0.5, length(fract(op+vec2(0.5, 0))-vec2(0.5,0.2))-0.5)\n\n#define txc(c, n, f) c*n + (1.0125-n)*texture(iChannel0, op*f).r\n\nvec3 ground(in vec2 u, in vec3 c, in float shadow_pos)\n{\n\tif(u.y<0.4)\n\t{\n\t\tconst float b = 0.005; //blur\n\t\tvec2 op = u*2.0;\n\t\top.x += iTime*0.05;\n\t\tc=mix(c, txc(c0, 0.98, vec2(2.5,2.5)), smoothstep(b*5.0, -b*5.0, GRND5));\n\n\t\top = vec2(u.x*3.0 + iTime*0.1 - shadow_pos, u.y*3.0-0.5);\n\t\tc=mix(c, c*0.75, smoothstep(b*30.0, -b*30.0, GRND4));\n\t\top.x += shadow_pos;\n\t\tc=mix(c, txc(c1, 0.98, vec2(1.33,1.33)), smoothstep(b*3.0, -b*3.0, GRND4));\n\n\t\top = vec2(u.x*4.0 + iTime*0.2 - shadow_pos, u.y*3.0-0.2);\n\t\tc=mix(c, c*0.9, smoothstep(b*10.0, -b*10.0, GRND3));\n\t\top.x += shadow_pos;\n\t\tc=mix(c, txc(c2, 0.98, vec2(0.75, 1.0)), smoothstep(b*0.5, -b*0.5, GRND3));\n\t\t\n\t\top = vec2(u.x*5.0 + iTime*0.4 - shadow_pos, u.y*2.0);\n\t\tc=mix(c, c*0.82, smoothstep(b*20.0, -b*20.0, GRND2));\n\t\top.x += shadow_pos;\n\t\tc=mix(c, txc(c3, 0.98, vec2(0.4,1.0)), smoothstep(b*3.0, -b*3.0, GRND2));\n\t\t\n\t\top = vec2(u.x*8.0 + iTime -shadow_pos, u.y*2.0+0.02);\n\t\tc=mix(c, c*0.75, smoothstep(b*30.0, -b*30.0, GRND1));\n\t\top += vec2(shadow_pos, -0.02);\n        c=mix(c, txc(c4, 0.96, vec2(0.5, 1.0)), smoothstep(b*5.0, -b*5.0, GRND1));\t\t\n\t}\t\n\treturn c;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 cloud(in vec2 u, in vec2 p, in float iscale,in vec3 c, const in vec3 cloud_color, in vec2 shadow_pos, in float shadow_factor, in float blur, in float shadow_blur)\n{\n\tu *= iscale;\n\tp *= iscale;\n    \n    // thread shadow\n\tc=mix(c, c*.95, smoothstep(shadow_blur*0.2, -shadow_blur*0.2, sdLine(u, p+vec2(shadow_pos.x,0.07), vec2(p.x + shadow_pos.x, iscale))));\n    \n    // cloud shadow\n\tvec2 st = u - p -shadow_pos ;\n\tfloat d = length(st) - 0.07;\n\td = min(d, length((st  -vec2(0.06, 0))) - 0.055);\n\td = min(d, length((st  +vec2(0.06, 0))) - 0.055);\n\tc=mix(c, c*shadow_factor, smoothstep(shadow_blur, -shadow_blur, d));\n\t\n    // cloud\n\tst += shadow_pos;\n\td = length(st) - 0.07;\n\td = min(d, length((st  -vec2(0.06, 0))) - 0.055);\n\td = min(d, length((st  +vec2(0.06, 0))) - 0.055);\n    vec2 op = st; \n\tc=mix(c, cloud_color*0.98 + (1.0-0.98)*texture(iChannel0, st*2.5).r, smoothstep(blur, -blur, d));\n\t\n    // thread\n\tc=mix(c, cloud_color*0.65, smoothstep(blur / (iscale*iscale), -(blur*0.5)/(iscale*iscale), sdLine(u, p + vec2(0,0.065), vec2(p.x, iscale))));\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 4.0/3.0; // dev in 4/3 screen\n    \n    // beautiful sky\n\tfloat d = length(uv-vec2(0.25,0.5)); // -0.5;\n   \tvec3 c = mix(vec3(.4,0.4,.8), vec3(0.55,0.8,0.8), smoothstep(1.7, 0., d));\n\n    // gorgeous ground\n\tfloat shadow_pos =  - smoothstep(1.0, 0.0, uv.x)*0.06 - 0.1 ;\n\tc = ground(uv, c, shadow_pos);\n\t\n    // wonderful clouds\n\tvec2 np = vec2(1.4-fract((iTime+50.0)*0.005) *1.5 , 0.8);\n\tc = cloud(uv, np, 2.0, c, c7, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.01, 0.03);\n\t\n\tnp = vec2(1.4-fract((iTime)*0.0055) *1.5 , 0.75+ sin(iTime*0.1)*0.01); // x : -1 1\n\tc = cloud(uv, np, 2.0, c, c7, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.01, 0.03);\n\n    np = vec2(1.4-fract((iTime + 100.0)*0.0045) *1.5 , 0.8+ sin(0.5+iTime*0.01)*0.02); // x : -1 1\n    c = cloud(uv, np, 2.0, c, c7, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.01, 0.03);\n\n     np = vec2(1.4-fract((iTime + 0.75)*0.0045) *1.5 , 0.88+ sin(0.75+iTime*0.01)*0.03); // x : -1 1\n    c = cloud(uv, np, 2.0, c, c7, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.01, 0.03);\n\n    \n\tnp = vec2(1.41-fract((iTime+75.0)*0.007) *1.5 , 0.88+ sin(iTime*0.05)*0.01); // x : -1 1\n\tc = cloud(uv, np, 1.5, c, c6, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.005, 0.04);\n\n   \tnp = vec2(1.41-fract((iTime+50.0)*0.0071) *1.5 , 0.85+ sin(0.5+iTime*0.042)*0.0095); // x : -1 1\n\tc = cloud(uv, np, 1.5, c, c6, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.005, 0.04);\n\n   \tnp = vec2(1.41-fract((iTime+35.0)*0.0067) *1.5 , 0.82+ sin(0.9+iTime*0.035)*0.012); // x : -1 1\n\tc = cloud(uv, np, 1.5, c, c6, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.005, 0.04);\n\n    \n\tnp = vec2(1.50-fract(iTime*0.011) *1.75 , 0.85 + sin(iTime*0.2)*0.025); // x : -1 1\n\tc = cloud(uv , np, 1.0, c, c5, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.002, 0.04);\n\n   \tnp = vec2(1.50-fract((iTime+50.0)*0.01) *1.75 , 0.85 + sin(1.5+iTime*0.08)*0.0125); // x : -1 1\n\tc = cloud(uv , np, 1.0, c, c5, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.002, 0.04);\n\n   \tnp = vec2(1.50-fract((iTime+35.0)*0.009) *1.75 , 0.8 + sin(0.5+iTime*0.05)*0.025); // x : -1 1\n\tc = cloud(uv , np, 1.0, c, c5, vec2(shadow_pos, -0.1)*0.2, 0.8,  0.002, 0.04);\n\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4ll3zj", "previewfilepath": "https://soundcloud.com/jamalgreenmusic/wonderful-waltz?in=jamalgreenmusic/sets/equilinox-full-soundtrack", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jamalgreenmusic/wonderful-waltz?in=jamalgreenmusic/sets/equilinox-full-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 1153, 1209, 1209, 2270], [2272, 2347, 2396, 2396, 2515], [2517, 2517, 2686, 2686, 3585], [3587, 3587, 3644, 3644, 5817]]}
{"id": "WtjGRV", "name": "Nicknaking/RaymarchV1", "author": "Nicknakin", "description": "Ray marching", "tags": ["raymarching"], "likes": 1, "viewed": 67, "published": "Public", "date": "1560270397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereDist(vec3 p, float r){\n    vec3 q = fract(p)*2.0-1.0;\n    return length(q)-r;\n}\n\nfloat marchRay(vec3 o, vec3 r){\n \tfloat t = 0.0;\n    for(int i = 0; i < 512; i++){\n\t\tvec3 p = o+r*t;\n        float d = sphereDist(p, 0.25f);\n        t += d*0.25;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\t\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    float theta = iTime/10.0;\n    r.xy *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    r.xz *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    vec3 o = vec3(0.0,0.0, -iTime);\n    \n    float t = marchRay(o, r);\n    \n    float fog = 1.0/(1.0+t*t*0.01);\n    vec3 fc = vec3(fog);\n\n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 91], [93, 93, 124, 124, 276], [279, 279, 336, 386, 861]]}
{"id": "WtjGWD", "name": "Trajectory", "author": "mosaic", "description": "What does this look like.. maybe a scifi planetary defense scene, or rising bubbles in raspberry soda", "tags": ["2d"], "likes": 3, "viewed": 292, "published": "Public", "date": "1559695258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = (fragCoord/2.1  - 0.1 * iResolution.xy) / iResolution.y+0.35;\n \n    float pct = 1.8-st.y*1.6;\n     \n    for(int i=0; i<50;i++){\n        //change i to float so I can multiply by it\n        float i_float = float(i);\n    \tpct += circle(st+(0.6*sin(iTime/3.-i_float*st.yx)),0.01)*st.y*1.5;\n    }\n \n    \n\tpct=pct-1.;\n\n    // Output to screen, adjust colour\n    fragColor = vec4(pct+.1,pct+.1,pct,1.0)*vec4(0.9,0.,0.,0.)+vec4(0.,0.0,0.3,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 45, 45, 219], [224, 224, 281, 281, 738]]}
{"id": "wtjGWy", "name": "Tri-Planar Texture Mapping", "author": "edo_m18", "description": "Tri-Planar Texture Mapping.\n\nRefer to : https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821", "tags": ["triplanartexturemapping"], "likes": 5, "viewed": 296, "published": "Public", "date": "1561019739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, 0.00001));\n    \n    // normalized total value to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz);\n    vec4 yaxis = texture(tex, p.xz);\n    vec4 zaxis = texture(tex, p.xy);\n    \n    // blend the results of the 3 planar projections.\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec3 offs, float r)\n{\n    return length(p - offs) - r;\n}\n\nfloat map(vec3 p)\n{\n    float d1 = sdSphere(p, vec3(-2, -1, 0), 1.0);\n    float d2 = sdBox(p, vec3(0.5));\n    return min(d1, d2);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    float time = iTime * 0.5;\n    vec3 ro = vec3(cos(time) * 7., 2., sin(time) * 7.);\n    vec3 ta = vec3(0);\n    \n    vec3 p = ro;\n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n\n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n = normal(p);\n        vec3 tex = tex3D(iChannel0, p, n);\n        col = tex;\n    }\n    else\n    {\n    \tvec3 sky = vec3(0.5, 0.8, 1.5) * abs(1.0 - uv.y);\n    \tcol = sky;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 216], [218, 218, 261, 261, 710], [712, 712, 741, 741, 784], [786, 786, 830, 830, 865], [867, 867, 886, 886, 998], [1000, 1000, 1021, 1021, 1198], [1200, 1200, 1257, 1257, 1941]]}
{"id": "wtjGzK", "name": "Alien Spacecraft (mouse rotate)", "author": "mosaic", "description": "I used one \"for loop\" to both create the geometry and movement (starting line 163).\nFeedback welcome\n\nRef:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://github.com/ajweeks/RaymarchingWorkshop#camera", "tags": ["3d"], "likes": 4, "viewed": 224, "published": "Public", "date": "1560489494", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n\n\n*/\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    \n    \n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n \n\n \n\n\nfloat sceneSDF(vec3 samplePoint) {  \n    //Uncomment to slowly spin the whole scene\n    //samplePoint = rotateY(iTime/5.+ iMouse.y/100.) * samplePoint;// ;\n   \tsamplePoint = rotateY(radians(47.)+ iMouse.x/100.) * samplePoint;// ;\n    \n    vec3 pos = samplePoint;\n    \n    //mirror the geomerty on the x axis\n    pos.x = abs(pos.x);\n     \n    float bunch =sdEllipsoid(rotateZ(radians(90.0)) * pos-vec3(0.,0.,0.),vec3(0.05,20.,0.5)*3.);\n     \n    for(int i=0; i<8;i++){\n      \tfloat i_float = float(i);\n    \tfloat elip = sdEllipsoid(pos-vec3(i_float*.3*(sin(iTime)+.9),0.,0.),vec3(0.05,0.6/i_float,0.5)*3.);\n    \t\n    \tfloat eliprot = 100.;\n      \tfloat elip2 = smin(eliprot,elip,0.08);\n           \n        bunch = smin(bunch,elip2,0.08);\n        \n       }\n    \n    return bunch;\n    \n    \n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n     vec3 eye = vec3(8.0, 5.0 * sin(0.2 ), 7.0);\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.1, 0.1, 0.2, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 174, 201, 201, 348], [350, 396, 423, 423, 570], [572, 618, 645, 645, 792], [794, 885, 931, 931, 963], [965, 1049, 1091, 1091, 1123], [1125, 1214, 1261, 1261, 1294], [1296, 1404, 1437, 1437, 1867], [1869, 1956, 1990, 1990, 2018], [2020, 2137, 2182, 2251, 2857], [2859, 3102, 3135, 3135, 3161], [3163, 3163, 3222, 3222, 3316], [3318, 3318, 3359, 3359, 3462], [3470, 3470, 3504, 3625, 4259], [4261, 4682, 4773, 4773, 5079], [5094, 5348, 5413, 5413, 5545], [5547, 5636, 5665, 5665, 5975], [5977, 6469, 6609, 6609, 7199], [7201, 7571, 7656, 7656, 8456], [8458, 8785, 8834, 8869, 9000], [9002, 9002, 9059, 9059, 10019]]}
{"id": "wtS3Wc", "name": "fractal--complex--v6", "author": "jorge2017a1", "description": "fractal--complex--v6", "tags": ["fractalcomplexv6"], "likes": 2, "viewed": 85, "published": "Public", "date": "1561339573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n//hecho por jorge flores p.....23/jun-2019\n\nstruct complex\n{\n    float re;\n    float im;\n}; \n\nconst float M_PI = 3.14159265359;\n\ncomplex complex_set(float re , float im)\n{\n\tcomplex cout;\n    cout.re = re;\n    cout.im = im;\n    return cout;\n}\n    \n\ncomplex complex_neg(complex p) \n{\n    complex cout;\n    cout.re = -p.re;\n    cout.im = -p.im;\n    return cout;\n}\n   \n\ncomplex complex_add(complex c1 , complex c2) \n{\n\t\n    complex cout;\n    cout.re = c1.re + c2.re;\n    cout.im = c1.im + c2.im;\n    return cout;\n}    \n\n\n\ncomplex complex_multiply(complex a, complex b) \n{\n    complex cout;\n\tcout.re= a.re * b.re - a.im * b.im;\n    cout.im =a.im * b.re + a.re * b.im;\n    return cout;\n}\n\n/** Square a complex number. */\ncomplex complex_square(complex a) \n{\n    return complex_multiply(a, a);\n}\n\n\ncomplex complex_sub(complex  c1 ,complex  c2) \n{\n    complex cout;\n\n    cout.re = c1.re - c2.re;\n    cout.im = c1.im - c2.im;\n    return  cout;\n}\n\n\n\n\n/*vec2 cmpxpow(in vec2 c, int p) {\n    vec2 orig = c;\n\tfor (int i = 0; i < p-1; ++i) {\n\t\tc = cmpxmul(c, orig);\n\t}\n    return c;\n}\n*/\n\n\nfloat complex_mag(complex c)\n{\n    \n    return sqrt(c.re * c.re + c.im * c.im);\n}\n\n\n\ncomplex complex_exp(complex z) \n{\n    complex tmp;\n    complex cout;\n    tmp.re= cos(z.im);\n    tmp.im= sin(z.im);\n    \n    cout.re=exp(z.re)*tmp.re;\n    cout.im=exp(z.re)*tmp.im;\n    \n    \n    return cout;\n}\n\n\n\nfloat complex_norm(complex c )\n{\n\tfloat result ;\n    \n    result = c.re * c.re + c.im * c.im;\n        \n    return  result;\n}\n    \n\ncomplex complex_pow(complex a, float b) \n{\n    float r = complex_mag(a);\n    float theta = atan(a.im, a.re);\n    complex tmp;\n    \n    tmp.re=b * log(r);\n    tmp.im=b *  theta;\n    \n    return complex_exp(tmp);\n    \n}\n\nvec3 getColor(float v)\n{\n    /*vec3 col = vec3(0.1) * sin(v);\n    col = mix(col, vec3(0.1, 0.2, 0.4), sin(1.-v));\n    col = mix(col, vec3(0.1, 0.2, 0.7), pow(sin(1.-v),2.));\n    return col;*/\n\t\n    float a = 1.;\n    float b = 0.2357022603955158;  // 1/3*sqrt(2)\n    float c = 0.12452650612453368; // 1/7*3^(1/8)\n    return vec3((1.-cos(a*v))*0.5, (1.-cos(b*v))*0.5, (1.-cos(c*v))*0.5);\n}\n\n\ncomplex complex_sin(complex c )\n{\ncomplex result;\n\n    result.re = sin(c.re) * cosh(c.im);\n    result.im = cos(c.re) * sinh(c.im);\n    return  result;\n\n}\n\n\nvec3 mandelbrot(vec2 frag )\n{\n    \n\n  float maxI; \n  float Bailout;\n  complex z;\n  complex c;\n  float x;\n  float y;\n  float iter; \n  float it;  \n    \n    x=frag.x;\n    y=frag.y;\n    \n    z.re = x; \n    z.im = y;\n    \n    c.re = 0.5*cos(iTime);\n    c.im = 0.0;\n    \n    Bailout = 10.0;\n    \n  maxI=255.0;\n    \n  float tmp;\n    //for(float i = 0.; i < 15.; i++) \n    \n    for( iter = 0.0; iter< maxI; iter++)\n    {\n        // z =complex_add(complex_pow(z, 2.0), c);\n        //z = Sin(z) + Exp(z) + c\n        z= z = complex_add(complex_add(complex_sin(z), complex_exp(z)), c);\n        \n           \n        tmp=abs(z.re);\n        if (tmp > Bailout )\n        {       break;        }\n        \n        tmp=abs(z.im);\n         if ( tmp > Bailout )\n        {    break;    }\n         \n                            \n         if (complex_norm(z) > 100.0 )\n         { break;  }\n    }\n                      \n    \n     if ( abs(z.re) < Bailout )\n     {\n        it = iter / 255.0;\n     }\n     else\n     {\n        it = iter + 1.0;    \n         \n     }\n    \n    \n    \n      if (abs(z.im) < Bailout )\n       {\n     \t\n        it = iter / 255.0;\n       }\n        else\n       {\n        it = iter + 1.0;    \n       }\n\n    \n    \n    \n    vec3 col;\n    //color3 = vec3(it*1.0 / maxI);\n\t//col = vec3(it*1.0 / maxI,it*1.0 / maxI,it*1.0 / maxI);\n    //col = vec3(it*1.0 ,it*1.0 ,it*1.0 );\n\tcol= getColor(it*1.0);\n\t\n         \n    return col;\n}\n    \n\n\n\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;                \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //z *= SCALE*0.5 + 5.5*cos(iTime);\n    \n    z *= SCALE;\n    \n    \t\n    col=mandelbrot(z);\n    \n        \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtS3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 187, 229, 229, 299], [306, 306, 339, 339, 418], [424, 424, 471, 471, 568], [576, 576, 625, 625, 739], [741, 773, 809, 809, 846], [849, 849, 897, 897, 994], [999, 1134, 1164, 1164, 1215], [1219, 1219, 1252, 1252, 1427], [1431, 1431, 1463, 1463, 1555], [1562, 1562, 1604, 1604, 1779], [1781, 1781, 1805, 1972, 2168], [2171, 2171, 2204, 2204, 2324], [2327, 2327, 2356, 2356, 3740], [3756, 3756, 3813, 3813, 4325]]}
{"id": "wtS3zc", "name": "study2_mouseTracking", "author": "firegump", "description": "just leaning, Click left mouse to control eyes.  thanks for The Art of Code's tutorial by BigWings", "tags": ["study"], "likes": 8, "viewed": 190, "published": "Public", "date": "1560492474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S( a, b, t) smoothstep( a, b, t)\n#define sat(x) clamp(x, 0.0, 1.0)\n\nfloat remap01(float a, float b, float t){\n\treturn sat((t-a)/(b-a));//clamp to 0-1;\n}\nfloat remap(float a, float b, float c, float d, float t){\n\treturn remap01( a, b, t)*(d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect){\n    \n    return (uv - rect.xy)/(rect.zw - rect.xy);//2d projection function;\n   \n\n}\n\nvec4 Eye(vec2 uv,float side, vec2 m, float smile){\n    uv -= .5;\n    uv.x *= side;\n    float d = length(uv);\n    \n    vec4 irisCol = vec4(.3,.5,1.,1.);\n    vec4 col = mix(vec4(1.),irisCol, S(.1,.7,d));\n    //can add sat function to clamp brighter area;\n    col.a = S(0.5, 0.48, d);\n    col.rbg *= 1.0 - S(0.45,0.5,d)*.5*(-uv.y -uv.x*side);//eye outline\n    \n    d = length(uv - m*.5);\n    \n    col.rgb = mix(col.rgb, vec3(0.0), S(0.3,0.28,d));//iris outline\n    \n    irisCol.rgb *= 1.0 + S( 0.25, 0.05, d);//make irisColor brighter\n    float irisMask = S(0.28,0.25,d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    d = length(uv - m*.6);\n    \n    float pupilSize = mix(.4,.16, smile);//mix also use to coutrol float\n    float pupilMask = S(pupilSize,pupilSize*.85,d);\n    pupilMask *= irisMask;//cut out pupil's outside area\n    col.rgb = mix(col.rgb, vec3(0.0), pupilMask);//pupil\n    \n    //eye highlight\n    float t = iTime*3.;\n    vec2 offs = vec2( sin(t + uv.y*25.), sin(t + uv.x*25.));\n    offs *= .01*(1. - smile);//depend ux.x change the light shape\n    uv += offs;\n    float highlight = S(.1, .09, length(uv - (- 0.15, 0.15)));\n    highlight += S(.07, .05, length(uv - (0.08,-0.08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    \n   \t\n    \n    return col;\n}\nvec4 Brow(vec2 uv, float smile){\n    float offs = mix(.2, 0.,smile);\n    uv.y += offs;\n    \n\tfloat y = uv.y;\n    uv.y += uv.x*mix(.5,.8,smile)- mix(.1,.3,smile); //brow move\n    uv.x -= mix(0.,.1,smile);\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n    float d1 = length(uv);\n    float s1 = S(.45,.45 - blur, d1);\n    float d2 = length(uv - vec2(.1, - .2)*.7);//*.7 get biger cricle\n    float s2 = S(.5,.5-blur,d2);\n    \n    float browMask = sat(s1-s2);//clamp to 0 1\n    \n    float colMask = remap01(.7,.8,y)*.7;//get a gradient\n    colMask *= S(.6, 1., browMask);\n    colMask *= smile;\n   \tvec4 browCol = mix(vec4(.4,.1,.2,sat((browMask+4.)*browMask-0.8)), vec4(.9,.7,.5,1),colMask);\n    col = browCol;\n    \n    //shadow\n    uv.y += .15 - offs*.35;//let shadow'position a little bit down\n    blur += mix(0.,.1,smile);\n   \n    \n    d1 = length(uv);\n    s1 = S(.45,.45 - blur, d1);\n    d2 = length(uv - vec2(.1, - .2)*.7);//*.7 get biger cricle\n    s2 = S(.5,.5-blur,d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col*1.2, vec4(0., 0., 0.,S(0., 1.,shadowMask)*.5),1.-browMask);\n    \n    \n    \n\n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile){\n    uv -= .5;\n    uv.y *= 1.5;\n\tvec4 col = vec4 (.5, .18, .05, 1.);\n    \n    uv.y -= uv.x*uv.x*2.*smile;//as uv.x biger  y move up more;\n    \n    uv.x *= mix(2.5, 1. ,smile);\n    float d = length(uv);\n    col.a = S( .5, .49, d );\n    \n    //teeth\n    vec2 tUv = uv;\n    tUv.y += (abs(tUv.x)*.7 + .1)*(1.-smile);\n    float td = length(tUv - vec2( 0. , .6));//move tooth to point;\n    vec3 toothCol = vec3(1.)*S(.6,0.35,d);//tooth shadow\n    col.rgb = mix(col.rgb,toothCol,S(0.4,0.37,td));\n    \n    td = length(uv - vec2(0.,- .5));\n    col.rgb = mix(col.rbg, vec3(1.,0.5, 0.5) ,S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n\tvec4 col = vec4 (0.8,0.6,0.4,1.0);\n    \n    float d = length(uv);\n    \n    col.a = S(.5 , 0.49, d);\n    \n    float edgeShade = remap01( 0.35, 0.5,d );\n    edgeShade *= edgeShade;\n    col.rgb *= 1.0 - edgeShade*0.5;//col is vec4;\n    \n    //make a outline;\n    col.rgb = mix(col.rgb, vec3(0.6, 0.3, 0.1),S(0.47,0.48,d));\n    \n    //highlight\n    float highlight_alpha = S( 0.41, 0.405, d);\n    highlight_alpha *= remap(0.41, -0.2 , 0.75, 0.0, uv.y);\n    highlight_alpha *= S(.18,.19,length(uv - vec2(.2,.075)));\n    //remap(highest point,lowest point,max return value,min return value,input)\n    col.rbg = mix(col.rgb, vec3(1.0),highlight_alpha);\n    \n    \n    \n    d = length(uv-vec2(0.25,-0.2));//vec2 is create position;\n    float cheek_alpha = S(.2,.01,d)*0.4;\n    cheek_alpha *= S(0.17,0.16,d);//let cheek have little shape\n    col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek_alpha);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv,vec2 m, float smile){\n\tvec4 col = vec4 (0.0);\n    float side = sign(uv.x);//sign, if x>0 return1,x=0 return 0,x<0 return -1;\n    uv.x = abs(uv.x); //mirror  \n    \n    vec4 head = Head(uv);\n    //vec4 eye = Eye(uv);\n    vec4 eye = Eye(within(uv, vec4(0.03,-.1,.37,.25)),side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-0.3,-0.4,.3,-0.1)), smile);//project mouth rect\n    //within( minX, minY, maxX, maxY)\n    vec4 brow = Brow(within(uv, vec4(0.02,0.17,.4,0.43)),smile);\n    \n    col = mix(col , head , head.a);//blend colors as  head's alpha;\n    col = mix(col , eye, eye.a);\n    col = mix(col , mouth, mouth.a);\n    col = mix(col , brow, brow.a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=  .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;//normalize to  0 1\n\tm -= .5;\n\n\tuv -= m*(.26-dot(uv,uv));\n\tfloat smile = cos(iTime)*.5 + .5;\n    fragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtS3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 117, 117, 160], [161, 161, 218, 218, 257], [259, 259, 291, 291, 375], [377, 377, 427, 427, 1666], [1667, 1667, 1699, 1699, 2820], [2822, 2822, 2855, 2855, 3465], [3467, 3467, 3486, 3486, 4393], [4395, 4395, 4436, 4436, 5087], [5090, 5090, 5147, 5197, 5469]]}
{"id": "WtSGDD", "name": "Beneath Water Light Rays", "author": "charon", "description": "Using noise it creates the lower surface of water and rays of light.", "tags": ["raycasting", "water", "columes"], "likes": 1, "viewed": 126, "published": "Public", "date": "1559511839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat lightIntensity = 20.0;\nfloat density = 0.2;\nfloat surface = 8.0;\n\n\n// noise function taken from https://www.shadertoy.com/view/4sdGD8\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // moving light\n\t//vec3 lightSource = vec3(0.5+5.0*(cos(time)), 5.0, 10.0 + 2.0*(sin(time)));\n   \n    // startionary light\n    vec3 lightSource = vec3(0.5, 5.0, 10.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n\n    \n    // generatying rays to cast from camera based on coordinates\n    \t\t// z serves to modify field of view\n    \t\t// y moves to look up and to horizon\n    vec3 rayDir = normalize( vec3(uv.x, uv.y + sin(time/4.0)+1.0, 5));\n    \n    \n    \n    vec3 color = vec3(0, 0.3, 0.5);\n    bool brokeSurface = false;\n    for (float i = 1.0; i < 100.0; i+=1.0){\n        float d = distance(i * rayDir, lightSource);\n        \t\n\t\t\tcolor += lightIntensity \n                * pow(2.7, -1.0 * pow(d,1.3) * density) //diffuse based on distance to light\n                * pow(2.7, -1.0 * i * density) //diffuse based on distance to camera (0,0,0)\n                //stationary noise\n                //* pow(snoise(rayDir.xz*50.0), 3.0);\n        \t\t// shifting noise\n\t\t\t\t* pow(snoise(rayDir.xz*i + time/4.0), 3.0);\n        \n        if (!brokeSurface && (i * rayDir).y > surface){\n            brokeSurface = true;\n        \tcolor.y += snoise(rayDir.xz*i + time/4.0)* lightIntensity*10.0* pow(2.7, -1.0 * i * density) ;\n        \ti = 40.0;\n        }\n           \n    }\n   \n\tcolor *= pow(dot(rayDir, normalize(lightSource))-0.2, 6.0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 939, 996, 1123, 2446]]}
{"id": "WtSGDm", "name": "Circle truchet tiles", "author": "avin", "description": "simple truchet tiles\nhttps://en.wikipedia.org/wiki/Truchet_tiles", "tags": ["truchet"], "likes": 3, "viewed": 384, "published": "Public API", "date": "1559729073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI_4 0.78539815\n#define PI_2 1.5707963\n\n#define SIZE 30.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define SF SIZE/min(iResolution.x,iResolution.y)\n\nmat2 rot(float a){\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n            \n    vec2 guv = uv*SIZE;\n    vec2 gid = floor(guv);\n    guv = fract(guv) - .5;\n    \n    float gidHash = floor((rand1(gid.x + gid.y*100.) + iTime*.1)*2.);    \n    guv *= rot(PI_2 * (gidHash));\n    \n    float sf = SF*1.5;\n    float l = length(guv - .5);    \n    float m = smoothstep(sf,.0, abs(l-.5));\n       \n    l = length(guv + .5);    \n    m += smoothstep(sf,.0, abs(l-.5));\n    \n    fragColor = vec4(1.-m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 186, 186, 262], [264, 264, 321, 321, 810]]}
{"id": "wtSGWK", "name": "dichotomy", "author": "dackdel", "description": "copied this from lennyjpg", "tags": ["yinyang", "dichotomy"], "likes": 1, "viewed": 250, "published": "Public API", "date": "1561105160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float d = length(uv-3.75);\n    float f = sin(d);\n\tvec2 u=fract(uv*f);\n    float t = iTime*.13;\n    t+=sin(t*2.0);\n    u-=0.5;\n    vec2 m = uv-vec2(0.5,0.2);\n    float a = atan(m.y,m.x);\n    u = rotate2d( a+t*PI ) * u;\n    u+=0.5;\n//    float k = smoothstep(0.5,0.51,u.x);\n    float k = smoothstep(.5,.51,u.x);\n\n    //  float k = smoothstep(uv.x-0.5,uv.y+0.5,u.x);\nvec3 final = mix(vec3(1.5,0.2,0.1),vec3(0.0,0.0,.2),k);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 199, 199, 694]]}
{"id": "WtSGWw", "name": "Non-polynomial smoothstep", "author": "iq", "description": "A non polynomial smoothstep() functions invented by vassvik, that I found has a simple analytic inverse.", "tags": ["2d", "smoothstep", "inverse"], "likes": 11, "viewed": 756, "published": "Public API", "date": "1559693046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A non polynomial smoothstep() function that I found has a simple\n// analytic inverse.\n//\n// In yellow, the inverse_smoothstep. In gray, the smoothstep of the\n// inverse_smoothstep, which gives the identity. In blue, the smoothstep for \n// reference and symmetry of the image.\n\n\nfloat my_smoothstep( float x, float n )\n{\n    return pow(x,n) / (pow(x,n) + pow(1.0-x,n) );\n    \n    // single pow() optimization, if x is not 0.0\n    //\n    // return 1.0/(1.0+pow(1.0/x-1.0,n) );\n}\n\nfloat inverse_smoothstep( float x, float n )\n{\n    // nicely enough, the inverse is the function\n    // itself with the parameter inverted.\n    return my_smoothstep(x,1.0/n); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float dx = 1.0/iResolution.y;\n    vec2  p = ( vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    float n = 1.0 + 5.0*pow(0.5 +0.5*sin(0.5*iTime),2.0);\n    \n    if( p.x>0.0 && p.x<1.0 )\n    {\n        // background\n        col = vec3( 0.2 + 0.02*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n\n        // gray: smoothstep of inverse_smoothstep = identity\n        {\n        float y = my_smoothstep( inverse_smoothstep( p.x, n ), n );\n        float di = abs(p.y-y)/sqrt(2.0)/dx;\n        col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0, 1.5, di ) );\n        }\n\n        // blue: smoothstep\n        {\n        float y = my_smoothstep( p.x, n );\n        float dy = my_smoothstep(p.x-sign(p.x-0.5)*dx, n) - y; // distance estimation\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);            // http://iquilezles.org/www/articles/distance/distance.htm\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n        \n        // yellow: inverse_smoothstep\n        {\n        float y = inverse_smoothstep( p.x, n );\n        float dy = inverse_smoothstep(p.x-sign(p.x-0.5)*dx, n) - y; // distance estimation\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);                 // http://iquilezles.org/www/articles/distance/distance.htm\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSGWw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1079, 1360, 1401, 1401, 1558], [1560, 1560, 1606, 1699, 1737], [1739, 1739, 1796, 1796, 3248]]}
{"id": "wtSGWy", "name": "Mandelbrot set test - 19/06/2019", "author": "clepirelli", "description": "simple test of the mandelbrot set", "tags": ["mandelbrot"], "likes": 0, "viewed": 304, "published": "Public API", "date": "1560899420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 500;\n\nvec3 BASE_COLOR = vec3(205.0,100.0, 128.0) / 255.0;\n\n\nstruct complexNumber\n{\n    float real;\n    float imaginary;\n};\n\ncomplexNumber multiplyComplex(complexNumber a, complexNumber b)\n{\n\t//(x + yi) * (u + vi) = (xu - yv) + (xv + yu)i\n    \n    return complexNumber\n        (\n        \ta.real*b.real - a.imaginary*b.imaginary,\n            a.real*b.imaginary + b.real*a.imaginary\n        );\n}\n\ncomplexNumber toComplex(vec2 a)\n{\n\treturn complexNumber(a.x, a.y);\n}\n\ncomplexNumber addComplex(complexNumber a, complexNumber b)\n{\n\treturn complexNumber(a.real + b.real, a.imaginary + b.imaginary);\n}\n\nfloat modulusComplex(complexNumber a)\n{\n\treturn sqrt(a.real*a.real + a.imaginary*a.imaginary);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nconst float Epsilon = 1e-10;\n \nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n\treturn vec3(H, C, Q.x);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + Epsilon);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n\tfloat R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), .0, 1.);\n}\n\n//original code from : http://www.chilliant.com/rgb2hsv.html\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\n//code from Unity's Mathf.PingPong\nfloat pingpong(float t, float l)\n{\n    t = mod(t, l * 2.);\n    return l - abs(t - l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.0/ pow(2.0, pingpong(iTime+1.0, 16.0));\n\tcomplexNumber C = toComplex(uv);\n\tC.real += 0.281717921930775;\n    C.imaginary += 0.5771052841488505;\n    \n    complexNumber Z = toComplex(vec2(.0));\n    int itn = 0;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        Z =  addComplex(multiplyComplex(Z,Z), C);\n        \n        if(modulusComplex(Z) >= 2.0) \n        {\n        \titn = i;\n            break;\n        }\n    }\n    \n    float itRatio = float(itn) / float(MAX_ITER);\n    \n    vec3 col = BASE_COLOR;\n    col = RGBtoHSV(col);\n    col.x *= itRatio;\n    col = HSVtoRGB(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 210, 258, 413], [415, 415, 448, 448, 483], [485, 485, 545, 545, 614], [616, 616, 655, 655, 712], [714, 806, 834, 887, 1168], [1170, 1231, 1259, 1259, 1366], [1368, 1429, 1456, 1456, 1605], [1607, 1668, 1696, 1696, 1776], [1778, 1813, 1847, 1847, 1900], [1902, 1902, 1959, 2009, 2756]]}
{"id": "WtsSzn", "name": "Another fractal thing", "author": "Yusef28", "description": "Just screwing around with an older upload all day and came out with this.", "tags": ["2d", "fractal", "planedeformation", "anotherfractalthing"], "likes": 6, "viewed": 185, "published": "Public", "date": "1561845484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 qt = uv;\n    qt *=  1.0 - qt.yx;\n    float vig = qt.x*qt.y*15.;\n    vig = pow(vig, 0.15);\n    \n    \n   vec2 st = uv;\n   // st.x+=iTime/100.;\n    st=st*2.-1.;\n     st.x *= iResolution.x/iResolution.y;\n\t;\n    //st += vec2(.0);\n    vec3 re ;\n    //st*=1.;\n    \n    \n    vec3 color;//vec3(1.);\n    int s;\n    st = st*2.0-1.;\n    //this cool df thing comes from \"kig\" on shadertoy: https://www.shadertoy.com/view/lll3DB\n    float df = pow(abs(st.y+.9)*uv.x*uv.x, 2.9)+pow(abs(st.x+1.)*uv.y*uv.y, 2.);\n  \t  //df /= pow(abs(st.y-1.39)*uv.x*uv.x*uv.x*uv.x, .9)+pow(abs(st.x-5.)*uv.y*uv.y, 0.4);\n\n    st *= 1.0+.5*df;\n    st.x += iTime*1.0;\n    //st.y += iTime*1.0;\n    \n    st/=1.328;\n    st/=10.;\n    \n    for(int i= 0;i<7;i++)\n    {\n        \n        st*=abs(sin(1.48 ));       \n        st = st*rot(1.4);\n        st = st*rot(1.4);\n        st*=abs(sin(2.48 ));\n        st = st*rot(1.4);\n        st/=abs(sin(10.48 ));\n        st = abs(st)*2.0-1.0;\n        \n\n\t\tst=fract(st+iTime/100.)-0.5;\n      \n    \tcolor -= (sin(vec3(0.9400,0.114,0.464) -  (  1./pow(1.0-smoothstep(0.7, 0.72 , length(st)), 1.)*2. - (smoothstep(0.36, 0.38 , length(st))) + float(i)*40.  )  )    );\n    \tst*=2.;\n       //s = i/int(re);\n       // color=sqrt(color);\n    }\n    \n\tfragColor = vec4(color*vig/1.7,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 76], [78, 78, 135, 135, 1461]]}
{"id": "wtXXRn", "name": "shortest binary counter", "author": "FabriceNeyret2", "description": ".", "tags": ["halftweet", "golf"], "likes": 7, "viewed": 291, "published": "Public API", "date": "1561737400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    O = vec4 ( int(9.*iTime+U.y) >> int(U)/32 &1 ); }\n//  O = vec4 ( int(9.*iTime) >> int(U)/32 &1 ); }   // variant (57 chars)", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 90]]}
{"id": "WtXXzr", "name": "Goose bumps", "author": "jblanper", "description": "Experimenting with displacement functions applied to signed distance functions.", "tags": ["3d", "raymarching", "bw"], "likes": 4, "viewed": 144, "published": "Public", "date": "1561714034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// most of the algorithms are derived from tutorial made \n// by BigWIngs (@The_ArtOfCode) and IÃ±igo Quilez\n\n#define MAX_STEPS 100\n#define MAX_DIST 60.\n#define EPSILON .001\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sceneSDF (vec3 p) {\n  float s = length(p - vec3(0.)) - .8;\n  s += sin(length((fract(p * 10.) - .5) * (sin(iTime * .4) * 3. + 4.2) * .2) * (cos(iTime * .1) * 1. + 2.) - iTime) * sin(iTime * .3) * .05;\n  s += sin((p.x * p.y + iTime * .08) * 10. * sin(iTime * .01) * 2.5) * .08;\n  return s * .8;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    depth += dist;\n    if (depth >= MAX_DIST) return 0.;\n  }\n  return 0.;\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDir (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  // camera\n  vec3 ro = vec3(0., 0., -5.);\n  ro.xz *= rotate(iTime * .1);\n  vec3 rd = getRayDir(uv, ro, vec3(0., 0., 0.), 4.);\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 lightPos1 = vec3(8., 8., -5.);\n    vec3 lightPos2 = vec3(-12., -8., -10.);\n    lightPos2.xz *= rotate(iTime * .5);\n    float phong1 = getLight(lightPos1, p, rd, 1., Material(.1, .5, .7));\n    float phong2 = getLight(lightPos2, p, rd, .7, Material(.1, .6, 0.));\n    color += phong1;// * vec3(.5, .5, .7);\n    color += phong2;// * vec3(.5, .5, .7);\n  } else {\n    color += .05 / length(uv);\n  }\n\n  // gamma correction\n  color = pow(color, vec3(1.0/2.2));\n\n  fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 196, 196, 246], [248, 248, 273, 273, 548], [550, 550, 575, 575, 735], [737, 737, 772, 772, 990], [1066, 1066, 1156, 1199, 1682], [1684, 1684, 1751, 1751, 2043], [2045, 2045, 2102, 2102, 2921]]}
{"id": "XtVBWG", "name": "snowoman", "author": "lovelyH", "description": "Winter shader with female snowman (snowoman).\nPublished at Nova 2019 demoparty in 4KB gfx category.", "tags": ["snow", "boobs"], "likes": 2, "viewed": 186, "published": "Public", "date": "1561906832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// iCam = vec3( 2.15, -7.57, 2.56 );\n/// iCamRX = 1.383\n/// iCamRZ = -0.625\n\n// #define EDITOR_MODE\n//#define DEBUG_MODE\n#ifndef EDITOR_MODE\n#define ANIMATED_MODE\n#endif\n\n#ifdef DEBUG_MODE\n#define E 0.01\n#else\n#define E 0.00001\n#endif\n\n#define INF 1000.0\n\n\n\n\n/// smooth mix\nfloat smoothmix( float val1, float val2, float x){\n\tx= clamp(x,0.0,1.0);\n\treturn mix( val1, val2, -(2.*x*x*x - 3.*x*x) );\n}\n\n/// rand 2d\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n/// classic noise 2d\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n/// rand 1D\n///@todo implementit it right, don't just use 2D, it's overkill\nfloat rand(float a){\n\treturn rand( vec2(a) );\n}\n\n/// classic noise 3d\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat noise(vec3 p){\n\tvec3 a = floor(p);\n\tvec3 d = p - a;\n\td = d * d * (3.0 - 2.0 * d);\n\n\tvec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 k1 = permute(b.xyxy);\n\tvec4 k2 = permute(k1.xyxy + b.zzww);\n\n\tvec4 c = k2 + a.zzzz;\n\tvec4 k3 = permute(c);\n\tvec4 k4 = permute(c + 1.0);\n\n\tvec4 o1 = fract(k3 * (1.0 / 41.0));\n\tvec4 o2 = fract(k4 * (1.0 / 41.0));\n\n\tvec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n\tvec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n\treturn o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n/// FBM (perlin noise) 2D\n///@warning require noise\n#define FBM_NUM_OCTAVES 5\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < FBM_NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n/// FBM (perlin noise) 2D\n/// return value from 0.0 to 1.0\n///@warning require noise\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < FBM_NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\n\nfloat max3(float a, float b, float c){return max(max(a,b),c);}\nfloat min3(float a, float b, float c){return min(min(a,b),c);}\n\n\n\nfloat mulPower( float power, float value ){ return 1.0 + power * (clamp(value,0.0,1.0) - 1.0); }\n\n\n\nvec2 rot( vec2 p, float l ){\n\tfloat s=sin(l),c=cos(l);\n\treturn vec2(\n\t\tc*p.x - s*p.y,\n\t\ts*p.x + c*p.y\n\t);\n}\n\n\n\nfloat cube(vec3 p, vec3 size){\n\tp= abs(p) - size;\n\treturn min( 0.0, max3( p.x, p.y, p.z ) ) + max( 0.0, length( max( p, 0.0 ) ) );\n}\n\n\nfloat cylinder(vec3 p, float radius, float height ){\n\tp= abs(p);\n\tvec2 ph= vec2( length(p.xy) - radius, p.z - height );\n\treturn min( 0.0, max( ph.x, ph.y ) ) + max( 0.0, length( max( ph, 0.0 ) ) );\n}\n\n\n\nfloat cone(vec3 p, float radius, float height){\n\tfloat lpxy= length(p.xy);\n\n\tfloat rc1= length( p - vec3(0,0,height)); /// top\n\tfloat rc2= length( vec2( lpxy - radius, p.z ) ); /// side \n\tfloat rc3; /// more or less inside\n\tfloat rc3h; /// more or less inside\n\tfloat rc3d= length(vec2(radius,height));\n\t{\n\t\tfloat sl= height / rc3d;\n\t\tfloat cl= radius / rc3d;\n\t\t\n\t\tvec2 h= vec2( lpxy - radius, p.z );\n\t\tvec2 h2= vec2(\n\t\t\tcl*h.x - sl*h.y,\n\t\t\tsl*h.x + cl*h.y\n\t\t);\n\n\t\trc3= h2.y;\n\t\trc3h= h2.x;\n\t}\n\n\tif( false ){\n\t}else if(height < p.z ){ /// top\n\t\t// return min( rc1, rc3);\n\t\tif( 0.0 < rc3h + rc3d )\n\t\t\treturn rc3;\n\t\telse\n\t\t\treturn rc1;\n\t}else if( radius < lpxy ){ /// side outside\n\t\tif( p.z <= 0.0 || 0.0 < rc3h ){\n\t\t\treturn rc2;\n\t\t}else{\n\t\t\treturn min( rc2, max( rc3, -p.z) );\n\t\t}\n\t}else if(p.z <= 0.0){ /// bottom\n\t\treturn -p.z;\n\t}else{ /// inside or close to side\n\t\treturn min3( rc3, rc1, rc2);\n\t}\n}\n\n\n\nint mapMatId= 0;\nconst vec3 ghostPos= vec3(-14.5, 16.0, 1.2 );\n\n\n\nfloat map(vec3 p){\n\tvec3 ph;\n\tfloat r, rc;\n\n\t/// ground\n\tmapMatId= 0;\n\tr= p.z;\n\n\t/// snowman balls\n\tph= p-vec3(0,0,0.4);\n\trc= length(ph)-0.5 - 0.05;\n\tph.z -= 0.7;\n\trc= min( rc, length(ph)-0.4 - 0.05 );\n\tph.z -= 0.6;\n\trc= min( rc, length(ph)-0.3 - 0.05 );\n\n\t/// breast\n\tph= p-vec3(0.0,-0.30,1.25);\n\tph.x= abs(ph.x)-0.15;\n\trc= min( rc, length(ph)-0.17 - 0.05);\n\n\t/// snow 2 apply\n\tif( rc < r ){\n\t\tmapMatId= 5;\n\t\tr= rc;\n\t}\n\n\t/// snow modification\n\t#ifndef DEBUG_MODE\n\tr += 0.1 * fbm( p*1.9 );\n\t#endif\n\n\t/// nose\n\tph= p - vec3( -0.0, -0.1, 1.7 );\n\tph.yz= vec2( ph.z, -ph.y );\n\trc= cone( ph, 0.05, 0.4 ) - 0.02;\n\tif( rc < r ){\n\t\tmapMatId= 2;\n\t\tr= rc;\n\t}\n\n\t/// eyes & lips & nipples\n\tph= p-vec3(0.0,-0.27,1.8); /// eyes\n\tph.x= abs(ph.x)-0.1;\n\trc= length(ph)-0.05;\n\tph= p-vec3(0.0,-0.27,1.55); /// lips\n\tph.x= abs(ph.x)-0.05;\n\trc= min( rc, length(ph)-0.04 );\n\tph.x -= 0.10;\n\tph.y -= 0.03;\n\tph.z -= 0.02;\n\trc= min( rc, length(ph)-0.04 );\n\tph= p-vec3(0.0,-0.47,1.26); /// nipples\n\tph.x= abs(ph.x)-0.18;\n\trc= min( rc, length(ph)-0.04);\n\tif( rc < r ){ /// apply\n\t\tmapMatId= 3;\n\t\tr= rc;\n\t}\n\n\t/// hat\n\tph= p-vec3(0.0,-0.0,1.97);\n\trc= cylinder(ph,0.22,0.02);\n\trc= min( rc, cylinder(ph,0.15,0.2) );\n\tif( rc < r ){ /// apply\n\t\tmapMatId= 7;\n\t\tr= rc;\n\t}\n\n\t/// animal feeder\n\t{\n\t\tph= p- vec3(-6.5,18.0,0.0);\n\t\t\n\t\t/// columns\n\t\tvec3 ph2= ph;\n\t\tph2.xy= abs(ph2.xy) - 0.8;\n\t\trc= cube(ph2,vec3(0.1,0.1,1.0));\n\t\t\n\t\t/// roof\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x) - 0.5;\n\t\tph2.z -= 1.36;\n\t\tph2.xz= rot( ph2.xz, 0.25*3.141592653589 );\n\t\trc= min( rc, cube(ph2,vec3(0.9,1.1,0.03)));\n\n\t\t/// side walls\n\t\tph2= ph - vec3(0,0,0.6);\n\t\tph2.z= abs(ph2.z) - 0.3;\n\t\tph2.x= abs(ph2.x) - 0.8;\n\t\trc= min( rc, cube(ph2,vec3(0.1,0.9,0.1)));\n\n\t\t/// back wall\n\t\tph2= ph - vec3(0,0,0.6);\n\t\tph2.z= abs(ph2.z) - 0.3;\n\t\tph2.y -= 0.8;\n\t\trc= min( rc, cube(ph2,vec3(0.9,0.1,0.1)));\n\n\t\t/// apply\n\t\tif( rc < r ){\n\t\t\tmapMatId= 4;\n\t\t\tr= rc;\n\t\t}\n\t}\n\n\t/// trees - R.I.P. GPU\n#ifdef DEBUG_MODE\n\tfloat ax=0.0, ay=0.0;\n#else\n\tfor(float ax=-1.0;ax<=1.0;ax++)for(float ay=-1.0;ay<=1.0;ay++)\n#endif\n\t{\n\t\tconst float va= 4.0;\n\t\tph= p;\n\t\tvec3 phi= p;\n\t\tphi.xy= (floor( phi.xy / va ) + vec2(ax,ay) ) * va;\n\n\t\tif( 12.0 < length(phi) )\n\t\t{\n\t\t\tph.xy -= phi.xy;\n\t\t\tph.xy -= va/2.0;\n\t\t\tph.xy += (-1.0 * 2.0*rand(phi.xy)) * va / 6.0;\n\t\t\t\n\t\t\trc= cone( ph, 0.1 + 0.15*rand(phi.xy+0.04), 2.5 + 0.2*rand(phi.xy+0.05) );\n\t\t\tif( rc < r ){\n\t\t\t\tmapMatId= 6;\n\t\t\t\tr= rc;\n\t\t\t}\n\t\t\tph.z -= 0.7 + 0.3*rand(phi.xy+0.01);\n\t\t\trc= cone( ph, 1.0, 1.0 );\n\n\t\t\tph.z -= 0.5 + 0.3*rand(phi.xy+0.02);\n\t\t\trc= min( rc, cone( ph, 0.8, 0.8 ) );\n\n\t\t\tph.z -= 0.4 + 0.3*rand(phi.xy+0.03);\n\t\t\trc= min( rc, cone( ph, 0.6, 0.8 ) );\n\n\t\t\trc -= 0.2;\n\n\t\t\tif( rc < r ){\n\t\t\t\tfloat rcb= rc;\n\t\t\t\t#ifndef DEBUG_MODE\n\t\t\t\t\trc= max( rc, 0.57-fbm(24.0*p) );\n\t\t\t\t#endif\n\t\t\t\tif( rc < r )\n\t\t\t\t{\n\t\t\t\t\tmapMatId= rc==rcb ? 0 : 1;\n\t\t\t\t\tr= rc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// ghost\n\tph= p - ghostPos;\n\tif( 0.0 < ph.z )\n\t\trc= length(ph);\n\telse\n\t\trc= length(ph.xy);\n\trc -= .5;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmapMatId= 8;\n\t}\n\n\t/// done\n\treturn r;\n}\n\n\n\n/// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n\t// float res = 1.0;\n\t// for( float t=mint; t < maxt; )\n\t// {\n\t// \tfloat h = map(ro + rd*t);\n\t// \tif( h<0.001 )\n\t// \t\treturn 0.0;\n\t// \tres = min( res, k*h/t );\n\t// \tt += h;\n\t// }\n\t// return res;\n\n    float res = 1.0;\n    float ph = 1e20;\n    float t= mint;\n    #ifdef DEBUG_MODE\n    for( int a=0;a<0x8;a++)\n    #else\n    for( int a=0;a<0x40;a++)\n    #endif\n    {\n\t\tfloat h = map(ro + rd*t);\n\t\t// if( h < E )\n\t\t// \treturn 0.0;\n\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, 10.0*d/max(0.0,t-y) );\n\t\tph = h;\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p= sp;\n\tfloat dis= map(p);\n\tbool isHit= false;\n\tfloat t= dis;\n\t#ifdef DEBUG_MODE\n\tfor(int a=0;a<0x40;a++)\n\t#else\n\tfor(int a=0;a<0x200;a++)\n\t#endif\n\t{\n\t\tp= sp + t * dir;\n\t\tdis= map(p);\n\t\tif( dis < E ){\n\t\t\tisHit= true;\n\t\t\tbreak;\n\t\t}\n\t\tt += dis;\n\t}\n\n\tif( isHit ){\n\t\tint matId= mapMatId;\n\t\tvec2 h= vec2(0,E);\n\t\tvec3 nor= normalize(vec3(\n\t\t\tmap(p+h.yxx) - map(p-h.yxx),\n\t\t\tmap(p+h.xyx) - map(p-h.xyx),\n\t\t\tmap(p+h.xxy) - map(p-h.xxy)\n\t\t\t));\n\n\t\tfloat cs= 1.0;\n\t\tfor( float d=0.003; d < 0.04; d *=1.5 ){\n\t\t\tcs= min( cs, max( 0.0, map( p + d * nor ) / d ) );\n\t\t}\n\n\t\t/// shadows + dot nor sunDir\n\t\tfloat sun= 1.0;\n\t\tconst vec3 sunDir= normalize( vec3( 0.35, -0.23, 0.9 ) );\n\t\t{\n\t\t\tfloat dsd= dot(nor,sunDir);\n\t\t\tif( dsd < 0.0 ){\n\t\t\t\tsun= 0.0;\n\t\t\t}else{\n\t\t\t\tsun= shadow( p+2.*E*nor, sunDir, 0.01, 50.0, 2.0 );\n\t\t\t\tsun= clamp( sun, 0.0, 1.0 );\n\t\t\t\tsun *= (dsd);\n\t\t\t}\n\t\t}\n\n\t\t/// base color\n\t\tvec3 baseColor= vec3(1);\n\t\tswitch(matId){\n\t\t\tcase 0: baseColor= vec3(.9); break; /// snow 1\n\t\t\tcase 1: baseColor= vec3(.10,.50,.10); break; /// green\n\t\t\tcase 2: baseColor= vec3(.60,.15,.05); break; /// carrot\n\t\t\tcase 3: baseColor= vec3(.30,.30,.30) * fbm( p*28.0 ); break; /// coal\n\t\t\tcase 4: baseColor= vec3(.70,.50,.20); break; /// wood\n\t\t\tcase 5: baseColor= vec3(.9); break; /// snow 2\n\t\t\tcase 6: baseColor= vec3(.20,.13,.05); break; /// tree wood\n\t\t\tcase 7: baseColor= vec3(.25,.15,.30) * mulPower(0.75,fbm(p*19.0)); break; /// hat\n            case 8: return vec3(.15,.01,.01)*pow(clamp( 9.0*(0.1 - length(vec2( abs(rot(p.xy-ghostPos.xy,-0.4).x)-.15, p.z-ghostPos.z))) , 0.0, 1.0 ), 2.0); /// ghost\n\t\t\tdefault: baseColor= vec3(1,0,0); break;\n\t\t}\n\n\t\t/// final result\n\t\treturn baseColor\n\t\t\t* mulPower( 0.5, dot(nor,-dir) )\n\t\t\t* mulPower( 0.13, cs )\n\t\t\t\n\t\t\t* mulPower( mix( 0.8, 0.95, clamp(0.05*length(p), 0.0, 1.0 )), sun )\n\n\t\t\t* mulPower( 1.0, 1.0 / (1.0 + 0.00015*t*t*t) )\n\n\t\t\t* ( matId==0 ? mulPower( ( 0.050*(length(p) + 2.0) ) , fbm(p*0.9) ) : mulPower( 0.4 , fbm(p*4.1) ) )\n\t\t;\n\t}else{\n\t\treturn vec3(0);\n\t}\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t#ifdef EDITOR_MODE\n\tvec3 p= iCam;\n\tfloat rx= iCamRX;\n\tfloat rz= iCamRZ;\n\t#else\n\tvec3 p= vec3(2.1538, -7.57222, 2.560973);\n\tfloat rx= 1.383296;\n\tfloat rz= -0.625;\n\t#ifdef ANIMATED_MODE\n\t{\n\t\tfloat t= (iTime+40.0) * 1.0;\n\t\tp.x += 0.7*sin(t*0.1);\n\t\tp.y += 0.06*cos(t*0.17);\n\t\trz -= 0.15*sin(t*0.1);\n\t\trx += 0.07*sin(t*0.04+0.5);\n\t}\n\t#endif\n\t#endif\n\n\tvec3 dir= normalize( vec3( uv.x, uv.y, -4.0 ) );\n\tdir.yz= rot(dir.yz, rx );\n\tdir.xy= rot(dir.xy, -rz );\n\n\tfragColor.xyz= render( p, dir );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVBWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 275, 325, 325, 398], [400, 412, 432, 432, 499], [501, 522, 542, 542, 750], [752, 828, 848, 848, 875], [877, 898, 919, 919, 956], [957, 957, 977, 977, 1438], [1440, 1518, 1537, 1537, 1809], [1811, 1896, 1915, 1915, 2089], [2094, 2094, 2132, 2132, 2156], [2157, 2157, 2195, 2195, 2219], [2223, 2223, 2266, 2266, 2319], [2323, 2323, 2351, 2351, 2430], [2434, 2434, 2464, 2464, 2566], [2569, 2569, 2621, 2621, 2768], [2772, 2772, 2819, 2819, 3670], [3740, 3740, 3758, 3758, 6736], [6740, 6803, 6876, 7071, 7492]]}
