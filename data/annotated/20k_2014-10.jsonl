{"id": "4d2SR3", "name": "ze interference", "author": "yastero", "description": "ze", "tags": ["ze"], "likes": 2, "viewed": 122, "date": "1414362279", "time_retrieved": "2024-06-20T18:13:12.472558", "image_code": "uniform float iOvertoneVolume;\nfloat pi = 3.1415;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    float col = 0.0;\n    float vol = texture(iChannel0, vec2(0.5)).x;\n\n    col += sin((17.0 - (9.0 * vol)) *\n               (pow(uv.x * (3.0 + (10.0 * vol) + sin(iTime * 0.9)), 2.0) +\n                pow(uv.y * (11.0 + (-10.0 * vol) + sin(iTime * 1.1)), 2.0)));\n\n    fragColor = vec4(col,col,col,1.0);\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2SR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2SzG", "name": "2D Reflections", "author": "dila", "description": "Simulates up to two light bounces from mirrors. Inspired by \"2D Shadow Casting\" by Tharich. Click and drag to move the light.", "tags": ["2d", "raymarch", "light", "shadows", "reflections", "mirrors"], "likes": 28, "viewed": 941, "date": "1413285987", "time_retrieved": "2024-06-20T18:13:12.472558", "image_code": "#define LIGHTING_DIRECT /* uncomment to enable direct lighting calculation with shadows */\n#define LIGHTING_BOUNCE_ONCE /* uncomment to enable the first reflection */\n//#define LIGHTING_BOUNCE_TWICE /* uncomment to enable a second reflection */\n\nstruct Slide {\n\tvec2 pos;\n    vec2 normal;\n};\n\n#define SLIDE_COUNT 6\n\nmat2 rotation(float theta) {\n\treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));  \n}\n\nfloat boxDistance(vec2 pos, vec2 center, vec2 normal, vec2 scale) {\n    mat2 rot = mat2(normal.x, -normal.y, normal.y, normal.x);\n\tvec2 delta = rot * (pos - center);\n    delta = clamp(delta, -scale, scale);\n    vec2 clampPos = center + delta * rot;\n    return length(clampPos - pos);\n}\n\nvec2 map(vec2 pos, Slide slides[SLIDE_COUNT]) {\n    float dist = 100.0;\n    float hit = -1.0;\n    for (int i = 0; i < SLIDE_COUNT; ++i) {\n     \tfloat thisDist = boxDistance(pos, slides[i].pos, slides[i].normal, vec2(0.2, 0.01));\n        if (thisDist < dist) {\n         \thit = float(i);\n            dist = thisDist;\n        }\n    }\n    return vec2(dist, hit);\n}\n\nvec3 trace(vec2 origin, vec2 dir, float far, Slide slides[SLIDE_COUNT]) {\n \tfloat t = 0.0;\n    float hit = -1.0;\n    for (int i = 0; i < 16; ++i) {\n     \tvec2 pos = origin + dir * t;\n        vec2 d = map(pos, slides);\n        t += d.x * 1.0;\n        hit = d.y;\n        if (t >= far) {\n         \treturn vec3(t, 1.0, -1.0);   \n        }\n        if (d.x < 0.0) {\n         \treturn vec3(t, 0.0, hit);   \n        }\n    }\n\treturn vec3(t, 0.0, hit);\n}\n\nfloat reflection(vec2 a, vec2 b, float power, float fresnel, Slide slides[SLIDE_COUNT]) {\n    float r = 0.0;\n\n#ifdef LIGHTING_DIRECT\n\tvec2 delta = b - a;\n    float len = length(delta);\n\tvec3 visa = trace(a, delta/len, len, slides);\n\tr += visa.y / (1.0 + len * len * power);\n#endif\n\n#ifdef LIGHTING_BOUNCE_ONCE\n    for (int i = 0; i < SLIDE_COUNT; ++i) {\n        vec2 deltai = a - slides[i].pos;\n        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);\n\n        vec2 rayi = refi - b;\n        float leni = length(rayi);\n        rayi /= leni;\n        vec3 pathi = trace(b, rayi, leni, slides);\n        if (pathi.z != float(i)) {\n            continue;\n        }\n\t\tvec2 hiti = b + rayi * pathi.x;\n        \n        vec2 delta = hiti - a;\n        float len = length(delta);\n        delta /= len;\n        vec3 path = trace(a, delta, len*0.99, slides);\n        if (path.y == 0.0) {\n            continue;   \n        }\n\n        float pathLength = leni;\n        float prod = abs(dot(-normalize(delta), slides[i].normal));\n        r += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);\n    }\n#endif // LIGHTING_BOUNCE_ONCE\n    \n#ifdef LIGHTING_BOUNCE_TWICE\n\tfor (int i = 0; i < SLIDE_COUNT; ++i) {\n        vec2 deltai = a - slides[i].pos;\n        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);\n        for (int j = 0; j < SLIDE_COUNT; ++j) {\n            if (j==i) {\n                continue;\n            }\n            \n        \tvec2 deltaj = refi - slides[j].pos;\n        \tvec2 refj = slides[j].pos - reflect(deltaj, slides[j].normal);\n            \n            vec2 rayj = refj - b;\n            float lenj = length(rayj);\n            rayj /= lenj;\n            vec3 pathj = trace(b, rayj, lenj, slides);\n            if (pathj.z != float(j)) {\n                continue;\n            }\n            vec2 hitj = b + rayj * pathj.x;\n            \n            vec2 rayi = refi - hitj;\n            float leni = length(rayi);\n            rayi /= leni;\n            hitj += rayi * 0.01;\n            vec3 pathi = trace(hitj, rayi, leni, slides);\n            if (pathi.z != float(i)) {\n                continue;\n            }\n            vec2 hiti = rayi + hitj * pathi.x;\n            \n            vec2 delta = hiti - a;\n            float len = length(delta);\n            delta /= len;\n            vec3 path = trace(a, delta, len*0.99, slides);\n            if (path.y == 0.0) {\n                continue;\n            }\n\n        \tfloat pathLength = lenj;\n        \tfloat prod = abs(dot(-normalize(delta), slides[i].normal));\n            prod *= abs(dot(-normalize(rayi), slides[j].normal));\n        \tr += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);\n        }\n    }\n#endif // LIGHTING_BOUNCE_TWICE\n \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    Slide slides[SLIDE_COUNT];\n    \n    slides[0].pos = vec2(0.0, 0.0);\n    slides[0].normal = vec2(0.0, 1.0) * rotation(-iTime*0.5);\n\n    slides[1].pos = vec2(-0.2, -0.8);\n    slides[1].normal = vec2(0.0, 1.0) * rotation(-3.14/2.5);\n    \n    slides[2].pos = vec2(0.3, -0.8);\n    slides[2].normal = vec2(0.0, 1.0) * rotation(3.14/2.5);\n    \n    slides[3].pos = vec2(1.2, 0.5);\n    slides[3].normal = vec2(0.0, 1.0) * rotation(3.14/8.0);\n    \n    slides[4].pos = vec2(-1.0, -0.2);\n    slides[4].normal = vec2(1.0, 0.0);\n\n    slides[5].pos = vec2(-1.0, 0.2);\n    slides[5].normal = vec2(1.0, 0.0);\n    \n    vec2 lightPos = vec2(cos(iTime), sin(iTime)) * 0.6;\n    \n    if (iMouse.z >= 1.0) {\n    \tlightPos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    \tlightPos.x *= iResolution.x / iResolution.y;\n    }\n    \n    float lighting = reflection(lightPos, uv, 1.0, 0.0, slides);\n    lighting = 0.3 + lighting * 0.7;\n    \n    vec2 delta = lightPos - uv;\n    float dist = 1.0 / (1.0 + dot(delta, delta) * 100.0);\n    float orb = clamp(pow(0.1 + dist,8.0),0.0,1.0);\n\n    vec3 colour = vec3(1.0);\n    colour.y *= 0.5 + 0.5 * cos(1.57 - iTime / 10.0);\n    colour.z *= 0.5 + 0.5 * cos(1.57 + iTime / 20.0);\n    \n\tvec3 tex = texture(iChannel0, uv * 2.0).xyz;\n        \n    vec3 ground = (tex * lighting + orb) * colour;\n    \n    float solid = abs(map(uv,slides).x) < 0.01 ? 1.0 : 0.0;\n    \n    vec3 final = mix(ground, vec3(lighting,lighting,lighting), solid);\n    \n    fragColor = vec4(final, 1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2SzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2XDh", "name": "Basic ray marching", "author": "dmmn", "description": "Basic Ray Marching", "tags": ["raymarching"], "likes": 2, "viewed": 132, "date": "1414058631", "time_retrieved": "2024-06-20T18:13:12.478672", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat map( in vec3 p) {\n    vec3 firstSpherePosition =  vec3(0.0, 0.0, 2.0);\n    vec3 q = p;\n    q.xz = mod(p.xz + firstSpherePosition.xz + 2.0, 4.0) - 2.0;\n    float dSphere = length( q ) - 1.0 + cos(iTime) * .15;\n    \n    float dPlane = p.y + 1.0;\n    \n    float blendingRatio = 1.;\n    float ratio = clamp(.5 + .5 * (dSphere - dPlane) / blendingRatio, 0., 1.);\n    \n    float dist = mix(dSphere, dPlane, ratio) - blendingRatio * ratio * (1. - ratio);\n    \n    return dist;\n}\n\nvec3 calcNormal (in vec3 p) {\n\tvec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3( \tmap(p + e.xyy) - map(p - e.xyy),\n                            map(p + e.yxy) - map(p - e.yxy),\n                          \tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize( vec3( p, 1.0 ));\n    float rotation = (1.0 - (iMouse.x / iResolution.x) * 2.0) * PI;\n    vec3 direction = vec3(cos(rotation + PI * .5), 0.0, sin(rotation + PI * .5));\n    rd = normalize(direction + vec3( cos(rotation) * p.x, p.y, sin(rotation) * p.x ));\n\n    vec3 col = vec3(.8);\n    \n    float tmax = 100.0;\n    float h = 1.0;\n    float t = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        if (h < 0.00001 || h > tmax) break;\n        h = map( ro + rd * t);\n        t += h;\n    }\n    \n    if (t < tmax) {\n        col = calcNormal(ro + rd * t);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2XDW", "name": "ufo diamonds", "author": "rickiters", "description": "slight mods to lsd ufos", "tags": ["raymarching"], "likes": 2, "viewed": 165, "date": "1412140800", "time_retrieved": "2024-06-20T18:13:12.933140", "image_code": "const vec3 background  = vec3(0.0, 0.0, 0.2);\nconst vec3 light_1     = vec3(4.0, 8.0,  3.0);\nconst vec3 light_2     = vec3(-4.0, 8.0, -7.0);\nconst vec2 eps         = vec2(0.001, 0.0);\nconst int maxSteps     = 164;\n\n//const float time = iTime;\n\nvec3 shade(vec3 color, vec3 point, vec3 normal, vec3 rd)\n{\n\t\n\tvec3 dtl       = normalize(light_1 - point);\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\tdtl      =  normalize(light_2 - point);\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\n// estimates the distance from Point p to implicit given geometry\nfloat distanceEstimator(vec3 p)\n{\n\tfloat t = mod(iTime, 70.0);\n\tp = p - vec3(t, t * 0.5, t * 0.3);\n\t\n\tfloat rpm = 1.0;\n\tvec3 repeater = mod(p, vec3(rpm)) - 0.5 * vec3(rpm);\n\n\tfloat sphere = length(repeater) - 0.06 * rpm;\n\t\n\tvec2 cylinder = vec2(min(length(repeater.xz) - 0.59, .015), repeater.y);\n\tfloat doughnut = length(cylinder) - 0.015 * rpm;\n\t//return doughnut;\n\treturn min(doughnut, sphere);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat ratio  = iResolution.x / iResolution.y;\n\tvec2 fragment = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 uv = -1.0 + 2.0 * fragment;\n\tuv.x *= ratio;\n\t\n\t//camera setup taken from iq's raymarching box: https://www.shadertoy.com/view/Xds3zN\n\tvec3 ta = vec3( 0.0, 0.0, -3.5 );\n\tvec3 ro = vec3( -3.0 + 3.2*cos(0.3*iTime + 6.0), 4.0, 1.0 + 3.2*sin(0.2*iTime + 6.0) );\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n\t\n\tvec3 col             = background;\n\tfloat t              = 0.0;\n\tvec3 p               = vec3(0.0);\n\t\n\t// march\n\tfloat steps = 0.0;\n\tfor (int i = 0; i < maxSteps; i++) {\n\t\tp = ro + t * rd;\n\t\tfloat distanceEstimation = distanceEstimator(p);\n\t\tif (distanceEstimation > 0.0005) {\n\t\t\tt += distanceEstimation;\n\t\t\tsteps += 1.0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//vec3 c = (cos(p * 0.5 - 0.5) + 1.0) / 2.0;\n    vec3 c = vec3(1.0);\n\tvec3 normal = normalize(vec3(distanceEstimator(p + eps.xyy) - distanceEstimator(p - eps.xyy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yxy) - distanceEstimator(p - eps.yxy),\n\t\t\t\t\t\t\t\t distanceEstimator(p + eps.yyx) - distanceEstimator(p - eps.yyx)));\n\t\n\tcol = shade(c, p, normal, rd);\n\t//col = mix(col, background, smoothstep(0.8, 1.0, float(steps) / float(maxSteps)));\n\t\n\t\n\tfragColor = vec4(col, 1.0); \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d2XzG", "name": "Energy Sphere", "author": "akaitora", "description": "Energy Sphere.  Special Thanks foes to ElusivePete.", "tags": ["warp", "energysphere"], "likes": 11, "viewed": 317, "date": "1413260973", "time_retrieved": "2024-06-20T18:13:13.266567", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec2 getNewUV( vec2 uv, vec2 pos, float radius, float strength, out float dist)\n{\n\tvec2 fromUVToPoint = pos - uv;\n\tdist = length( fromUVToPoint );\n\t\n\tfloat mag = (1.0 - (dist / radius)) * strength;\n\tmag *= step( dist, radius );\n\t\n\treturn uv + (mag * fromUVToPoint);\n}\n\nvec4 proceduralTexture2D( vec2 uv, vec2 resolution )\n{\n\tvec2 fragCoord = (uv  * resolution.x );\n\tvec3 brightColor = vec3( 1.0, 1.0, 1.0 );\n\tvec3 darkColor = vec3( 0.0, 0.0, 0.0 );\n\tvec2 p = floor( (fragCoord.xy / resolution.x) * 10.0 );\n\t\n\t\n\tfloat t = mod(p.x + p.y, 2.0) * 10.0;\n\tvec3 color = mix( darkColor, brightColor, t);\n\treturn vec4( color, 1.0 );\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tfloat radius = 0.50;\n\t\n\tfloat ct = cos( iTime / 3.0 );\n\tfloat st0 = sin( iTime / 3.0 );\n\tfloat st1 = sin( iTime );\n\t\n\tvec2 origin = vec2( 0.0, 0.0 );\n\tfloat x = origin.x + ( ct * st0) * 2.70;\n\tfloat y = origin.y + ( st1 ) * 0.50;\n\tvec2 pos = vec2(x,y);\n\t\n\t\n\tfloat dist = 0.0;\n\tvec2 newUV = getNewUV( uv, pos, radius, 0.5, dist);\n\t\n\tfloat start = 0.42;\n\tfloat glowT = sin(iTime)*0.5 + 0.5;\n\tfloat outlineRadius = radius +  (1.0-glowT)*0.01 + (glowT * 0.08);\n\tvec4 highlight = vec4( 0.00, 0.00, 0.00, 1.0 );\n\tfloat t = (outlineRadius - start) / max( (dist - start), 0.01);\n\thighlight = mix( vec4( 0.00, 0.00, 0.00, 1.0 ), vec4( 0.00, 0.50, 0.80, 1.0 ), t);\n\t\n\tvec4 color = proceduralTexture2D( newUV, iResolution.xy ) + highlight;\n\tcolor.a = 1.0;\n\t\n\tfragColor = color;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBSRd", "name": "camera control", "author": "rickiters", "description": "a simple CSG attempt to work a camera relative to person in a rollercoaster car, a mix of raymarching and raycasting, also working with a 'conservative factor' for distance field estimations", "tags": ["raymarching", "simple", "camera", "conservativemarch", "rollercoaster"], "likes": 4, "viewed": 287, "date": "1414726570", "time_retrieved": "2024-06-20T18:13:15.939519", "image_code": "//// input\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77;\nconst int kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\nint kRed = k1;\nint kGreen = k2;\nint kBlue = k3;\n\nfloat lodBias = -2.2;\nfloat time = 0.;\n\nfloat PI = 3.14159;\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen coords to -asp to +asp for x, -1 to +1 for y, asp = aspect ratio\n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n/*\n//// convert screen coords to -1 to +1 for x, -1 to +1 for y, asp = assumed to be 1.0\n// normalized device coords\nvec2 ndc_noasp(vec2 p)\n{\n    p *= vec2(2.0/iResolution.x,2.0/iResolution.y);\n    p += -1.;\n\treturn p;\n}\n*/\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n//const vec3 background  = vec3(0.0, 0.0, 0.2);\nconst vec3 light_1     = vec3(4.0, 8.0,  3.0);\nconst vec3 light_2     = vec3(-4.0, 8.0, -7.0);\n//const vec2 eps         = vec2(0.001, 0.0);\n//const int maxSteps     = 64;\n\n// some lighting\nvec3 shade(vec3 color, vec3 point, vec3 normal,vec3 rd)\n{\n\t\n\tvec3 dtl       = normalize(light_1 - point);\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\tdtl      =  normalize(light_2 - point);\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    loc *= 10.;\n    vec2 loct = loc.xz * vec2(.1,-.1);\n    vec3 ret3 = texture(iChannel2,loct,lodBias).xyz;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.b += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n\t    vec2 loc2 = loct;\n        if (fract(loc2.x*.05) >= .5)\n            ret3.b -= .45;\n        if (fract(loc2.y*.05) >= .5)\n            ret3.g -= .45;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return skyplanecolor;\n}\n\n\n//// raymarch\nvec3 sceneCol;\n\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// c.xy is the position if xz, c.z is the radius\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat scene1(vec3 pr)\n{\n    //vec3 pr = p;\n    //pr.x += 4.0;\n    //pr.xy *= rot(iTime*.5);\n    pr.xz *= rot(1.57);\n    sceneCol = fract(pr*8.0);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    //float d1 = sdBox(pr,vec3(.25,.5,.75));\n    //float d2 = sdSphere(p,1.0); // p or pr, it's a sphere\n    pr.xy *= rot(1.57);\n\tfloat d2 = sdCappedCylinder(pr,vec2(.50,12));\n    //float d3 = sdTorus(pr,vec2(1.0,.25));\n    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));\n    //return opU(d1,d2);\n    //return opI(d1,d2);\n    return opS(d1,d2);\n    //return opS(d2,d1);\n    //return d1;\n    //return d2;\n    //return d3;\n    //return d4;\n}\n\nfloat opRep_scene1(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return scene1(q);\n}\n\nfloat opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat sceneT(vec3 p)\n{\n\tvec3 pr = p;\n    pr.xy *= rot(iTime*.8);    //vec3 pr = \n    pr.yz *= rot(iTime*.7);    //vec3 pr = \n    float d4 = sdTorus(pr,vec2(.125,.03125));\n    return d4;\n}\n\nfloat opRep_sceneT(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return sceneT(q);\n}\n\nfloat opRepLimit_sceneT(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return sceneT(q);\n}\n\nfloat opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat opRepLimitCenter_sceneT(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return sceneT(q);\n}\n\nfloat scene2(vec3 p)\n{\n\treturn opRep_scene1(p,vec3(10.0));\n}\n\nvec3 deform_torus(vec3 p)\n{\n    float d = p.y + 1.1*sin(5.0*atan(p.z,p.x));\n    vec3 pr = vec3(p.x,d,p.z);\n    return pr;\n}\n\nfloat scene4(vec3 p)\n{\n\tfloat rs1 = opRepLimitCenter_scene1(p,vec3(5.0),vec3(9.0));\n    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));\n    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));\n    p.y -= 1.9;\n    vec3 pd = deform_torus(p);\n\t//float tor0 = sdTorus(pd,vec2(8.5,.1));\n\tfloat tor1 = sdTorus(pd,vec2(9.5,.1));\n\tfloat tor2 = sdTorus(pd,vec2(10.5,.1));\n\t//float tor3 = sdTorus(pd,vec2(11.5,.1));\n    //float tor = opU(opU(opU(tor0,tor1),tor2),tor3);\n    float tor = opU(tor1,tor2);\n    //return opU(rs1,pn);\n    return opU(rs1,tor);\n}\n\nfloat scene5(vec3 p)\n{\n    vec3 torusmove = vec3(0.);//.7*sin(vec3(iTime,iTime*1.1,iTime*1.3));\n    //float d3 = sdSphere(p + vec3(-1,-.75,1.0),.25); // p or pr, it's a sphere\n    float d3 = sdSphere(p + vec3(0.,0.,5.),.25); // p or pr, it's a sphere\n    float d3_2 = sdSphere(p + vec3(-1.,0.,4.),.25); // p or pr, it's a sphere\n    float d3_3 = sdSphere(p + vec3(-2.,0.,3.),.25); // p or pr, it's a sphere\n    float c0 = sdSphere(p + vec3(-10.,0.,-10.),.5); // p or pr, it's a sphere\n    float c1 = sdSphere(p + vec3(10.,0.,-10.),.5); // p or pr, it's a sphere\n    float c2 = sdSphere(p + vec3(-10.,0.,10.),.5); // p or pr, it's a sphere\n    float c3 = sdSphere(p + vec3(10.,0.,10.),.5); // p or pr, it's a sphere\n    d3 = opU(opU(opU(opU(c0,c1),c2),c3),d3);\n    d3 = opU(d3_3,opU(d3,d3_2));\n    vec3 pr;\n    pr.xz = p.xz * rot(1.57);\n    pr.y = p.y;\n    sceneCol = fract(pr*8.0);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    pr.xy *= rot(1.57);\n    // +Y+Z+X\n\tfloat d2 = sdCappedCylinder(pr,vec2(.50,12));\n    pr -= vec3(1.,0.,0.)+torusmove;\n    //pr.xy *= rot(iTime*.2);\n   \t//pr.xz *= rot(iTime*.5);\n    //float d4 = sdTorus(pr,vec2(.5,.125));\n    //float d4 = opRep_sceneT(pr,vec3(1.));\n    float d4 = opRepLimitCenter_sceneT(pr,vec3(1.),vec3(2.0,3.0,4.0));\n//    float d4 = sdTorus(pr + vec3(-.75,-1.5,-1.0)+vec3(0.0,torusmove,0.0),vec2(.5,.125));\n    return opU(d3,opU(d4,opS(d1,d2)));\n    //return sdCylinder(pr,vec3(1.0));\n}\n\nfloat scenerails(vec3 p)\n{\n    p.y -=1.9;\n    vec3 pd = deform_torus(p);\n\t//float tor0 = sdTorus(pd,vec2(8.5,.1));\n\tfloat tor1 = sdTorus(pd,vec2(9.5,.1));\n\tfloat tor2 = sdTorus(pd,vec2(10.5,.1));\n\t//float tor3 = sdTorus(pd,vec2(11.5,.1));\n    //float tors = opU(opU(opU(tor0,tor1),tor2),tor3);\n    float tors = opU(tor1,tor2);\n    return tors;\n}\n\nfloat scenetunnel(vec3 p)\n{\n    vec3 pbox = vec3(p.x-20.,p.y,p.z+20.);\n    vec3 ptor = vec3(p.x,p.y-3.1,p.z);\n\tvec3 pd = deform_torus(ptor);\n\tfloat dtorm = sdTorus(pd,vec2(10.,1.5));\n\tfloat db = sdBox(pbox,vec3(20.));\n    float d = opS(db,dtorm);\n    //float d = dtorm;\n    //float d = dtorm;\n    return d;\n}\n\nfloat scene(vec3 p)\n{\n\t//float d = scene1(p);\n    //float d = scene2(p);\n    float d4 = scene4(p);\n    float d5 = scene5(p);\n    float d45 = opU(d4,d5);\n    float dtunnel = scenetunnel(p);\n    float drails = scenerails(p);\n    float d = opU(opU(d45,drails),dtunnel);\n    //float d = opU(d45,drails);\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = .001;\n    float d0x = scene(vec3(p.x - eps,p.yz));\n    float d1x = scene(vec3(p.x + eps,p.yz));\n    float d0y = scene(vec3(p.x,p.y - eps,p.z));\n    float d1y = scene(vec3(p.x,p.y + eps,p.z));\n    float d0z = scene(vec3(p.xy,p.z - eps));\n    float d1z = scene(vec3(p.xy,p.z + eps));\n    //return vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(.5/eps);\n    //return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(2.5/eps));\n    return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z));\n    //return vec3(1.0,0.0,0.0);\n}\n    \nvec3 getTex(vec3 p)\n{\n\tp = fract(p);\n    //p.xy *= rot(iTime*.5);\n    //p.xz *= rot(iTime*.25);\n    return p;\n    //return vec3(1.0);\n}\n    \n/*float getNormalZ(vec3 p)\n{\n    const float eps = .0001;\n    float d0z = scene(vec3(p.xy,p.z + eps));\n    float d1z = scene(vec3(p.xy,p.z - eps));\n    //return (d1 - d0)/eps;\n    return (d1z-d0z)/eps;\n}\n*/  \n\n// very simple ambient occlusion\nfloat getAO(vec3 rs,vec3 rd)\n{\n    // move away along the normal\n    float d = .3;\n    float k = 1.0;\n    float ret = 1.0;\n    for (int i = 1;i<5;++i) {\n        float fi = float(i);\n        k *= .5;\n        float distBack = scene(rs + rd*(d*fi));\n        ret -= k*(fi*d - distBack);\n    }\n    return ret;\n    //return 1.0;\n    //return distBack/k;\n    //return k/distBack;\n}\n\nvec3 march(vec3 rs,vec3 rd,out bool hit)\n{\n    const float conserve = .87;//1.0; // .87; // compensate for errors in distance function esp. rotate box repeat\n    const int steps = 180;\n    float eps = .001;\n    float toobig = 1000.0;\n\tvec3 col = vec3(0.0,0.0,0.0);\n    hit = false;\n    for (int i=0;i<steps;++i) {\n        float d = scene(rs);\n        if (d > toobig) { // bail early if clearly can't hit anything\n            hit = false;\n            break;\n        }\n        if (d < eps) {\n            //if (true) {\n            if (rs.y >= 0.0) { // hit above ground\n                vec3 norm = getNormal(rs);\n \t\t\t\t// normal color, very simple lighting .5 ambient, .5 directional\n \t\t\t\t// normal in opposite direction of light gets the light\n                //col += max(-norm.x,0.0)*.5+.5; // dir +1x\n                //col += max(norm.y,0.0)*.5+.5; // dir -1y\n                //col += max(-norm.z,0.0)*.5+.5; // dir +1z\n                //col += -norm.z; // dir +1z, no ambient all directional\n                col += shade(vec3(1.),rs,norm,rd)*.9;\n\t\t\t\tcol += sceneCol*.1;\n                //col += getTex(rs); // texture color\n                //col += norm*.5 + vec3(.5); // normal color 0 to 1\n                //col += norm; // raw normal color -1 to 1\n    \t\t\t//col += float(i)*(10.0/256.0); // brighter if more iterations\n                float ao = getAO(rs,norm);\n                col *= ao;\n                hit = true;\n            }\n            break;\n        }\n        rs += rd*d*conserve; // compensate for the slight error from rotating boxes distance modulo function\n    }\n\n    return col;\n}\n\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.2;\n    //bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy); // -asp to +asp for x, -1 to +1 for y\n    vec2 mouse;// = vec2(0.0,0.0);\n    \n    // if (iMouse.x == 0.0 && iMouse.y == 0.0) // hack for mouse not yet clicked\n    if (iMouse.x == 0.0 ) // hack for mouse not yet clicked\n        mouse = vec2(0.0,0.0);\n    else\n    \tmouse = ndc(iMouse.xy);\n    \t//mouse = ndc(iMouse.xy);\n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0; // about 53 degrees vertical\n    //const float zoom = 1.0; // exactly 90 degrees vertical\n    // make a ray, left handed coords\n    \n    // ray source\n    float k = PI*2./15.;\n    float m = 5. * k;\n    float rad = 10.;\n    float angy = k * time; \n    float angm = m *time;\n    vec2 posxz = vec2(rad*cos(angy),rad*sin(angy));\n    float medy = 2.4;\n    float ampy = 1.1;\n    float rsy = medy + -ampy*sin(angm);\n    vec3 rs = vec3(posxz.x,rsy,posxz.y);\n    \n    // ray direction\n    vec3 rd = vec3(pos,1.0); // ray direction to the pixel\n    // zoom factor\n    rd.xy /= zoom;\n    \n    // from mouse\n    float pitch = mouse.y*PI*.5; // -PI/2 to +PI/2\n    float yaw = mouse.x*PI * iResolution.y/iResolution.x; // -PI to +PI\n    //float roll = 0.;//PI*.25; //time * .1;\n    rd.yz *= rot(pitch); // pitch\n    rd.xz *= rot(yaw); // yaw\n\t//rd.xy *= rot(roll); // roll\n    \n    // from orientation\n    //float opitch = -.125*PI;\n    float opitch = -atan(cos(angm)*m*ampy/(rad*k));\n    float oyaw = -angy;\n    //float oroll = 0.;\n    rd.yz *= rot(opitch);\n    rd.xz *= rot(oyaw);\n    //rd.xy *= rot(oroll);\n\n     // normalized ray direction for the marching, unnormalized for the sky gradient\n    vec3 nrd = normalize(rd);\n    //rs += rc * -7.0; // - distance to lookat\n       \n    // ray march for color\n    bool hit; // did hit something\n    vec3 marchcol = march(rs,nrd,hit);\n    \n\n    \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float cursrad = 1.0/30.0;\n    bool iscursor = d2<cursrad*cursrad;\n    \n    // sky plane color\n    //rs -= nrd * 2.3;\n    //rs.z += nrd.z;\n    // raycast a plane to infinity\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n   \n    \n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else if (hit)\n\t\tcomp = marchcol;\n\telse\n        comp = skyplanecolor;\n\tfragColor = vec4(comp,1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBSRK", "name": "Color Grid 1", "author": "iq", "description": "Some sort of undefined colored grid thingy.", "tags": ["procedural", "2d", "grid"], "likes": 84, "viewed": 7562, "date": "1413498904", "time_retrieved": "2024-06-20T18:13:15.939519", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  px = 4.0*(-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    float id = 0.5 + 0.5*cos(iTime + sin(dot(floor(px+0.5),vec2(113.1,17.81)))*43758.545);\n    \n    vec3  co = 0.5 + 0.5*cos(iTime + 2.0*id + vec3(0.0,1.0,2.0) );\n    \n    vec2  pa = smoothstep( 0.0, 0.2, id*(0.5 + 0.5*cos(6.2831*px)) );\n    \n    fragColor = vec4( co*pa.x*pa.y, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBSRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBSzc", "name": "Distance fields How do they work", "author": "twitchingace", "description": "Messing around with a first look into distance field based ray marching. Nothing worth looking at.", "tags": ["3d", "distancefield", "raymarch"], "likes": 8, "viewed": 251, "date": "1414195486", "time_retrieved": "2024-06-20T18:13:15.939519", "image_code": "vec3 eye = vec3(0,0,-10);\nvec3 sphere1Pos = vec3(-.5,.2,.5);\nvec3 sphere2Pos = vec3(-.5,.3,-.1);\nvec3 torusPos = vec3(0,0,0.);\nconst float maxIterations = 64.;\n\nstruct ray{\n \tvec3 position;\n    vec3 direction;\n};\n    \nfloat smin( float a, float b, float k){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat distSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat distTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distFunc(vec3 p){\n    float d1 = distSphere(p - sphere1Pos, .5);\n\tfloat d2 = distSphere(p - sphere2Pos,0.3);\n    float d3 = distTorus(p - torusPos, vec2(.75,.2));\n    //return min(min(d1,d2),d3);\n    return smin(smin(d1,d2, .2),d3, .2);\n}\n    \nray lookAt(in vec2 uv, in vec3 targetPoint){\n\tvec3 forward = normalize(targetPoint - eye);\n    vec3 up = vec3(0.,1.0,0.0);\n    vec3 right = cross(forward, up);\n    up = cross(forward, right);\n    //return ray(eye, normalize(up + right + forward));\n    vec3 ro = eye + forward * .1 + right * uv.x + up * uv.y;\n    vec3 rd = forward;\n    return ray(ro,rd);\n}\n\nvec3 rayMarch(ray marcher){\n    float epsilon = 0.00001;\n    float t = 0.;\n    for (float i = 0.; i < maxIterations; i++){\n        vec3 point = marcher.position + marcher.direction * t;\n        float d = distFunc(point);\n        if (d < epsilon){\n            return vec3(1.-i/maxIterations); \n        }\n        t+=d;\n    }\n    return vec3(0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    eye = vec3(cos(iTime) * 5. ,sin(iTime) * 3., sin(iTime) * 5.);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    ray eyeRay = lookAt(uv, vec3(0)); \n\tfragColor = vec4(rayMarch(eyeRay),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBSzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBXz3", "name": "Vector reflect/clip", "author": "iq", "description": "How to clip and reflect a vector to a hemisphere (useful for making sure your vectors are in the positive side of a plane/normal). More info: [url]https://iquilezles.org/www/articles/dontflip/dontflip.htm[/url]", "tags": ["2d", "reflect", "vectors", "clip"], "likes": 31, "viewed": 2484, "date": "1414140907", "time_retrieved": "2024-06-20T18:13:16.830667", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// A useful trick to avoid certain type of discontinuities\n// during rendering and procedural content generation. More info:\n//\n// https://iquilezles.org/www/articles/dontflip/dontflip.htm\n\n\n\n// Flip v if in the negative half plane defined by r (this works in 3D too)\nvec2 flipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : -v;\n}\n\n// Reflect v if in the negative half plane defined by r (this works in 3D too)\nvec2 reflIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : v-2.0*r*k;\n}\n\n// Clip v if in the negative half plane defined by r (this works in 3D too)\nvec2 clipIfNeg( in vec2 v, in vec2 r )\n{\n    float k = dot(v,r);\n    return (k>0.0) ? v : (v-r*k)*inversesqrt(1.0-k*k/dot(v,v));\n}\n\n//===============================================================\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n\n    if( p.x<w1 )\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n\n    if( pz.x>0.0 )\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n//===============================================================\n\nfloat line( in vec2 p, in vec2 a, in vec2 b, float w , float e)\n{\n    return 1.0 - smoothstep( -e, e, sdLine( p, a, b ) - w );\n}\n\nfloat arrow( in vec2 p, in vec2 a, in vec2 b, float w1, float w2, float e )\n{\n    return 1.0 - smoothstep( -e, e, sdArrow( p, a, b, w1, w2) );\n}\n\n//===============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.x;\n    vec2 q = p;\n    p.x = mod(p.x,1.0/3.0) - 1.0/6.0;\n    \n    p.y -= 0.5*iResolution.y/iResolution.x;\n    p.y += 0.04;\n    \n    float e = 1.0/iResolution.x;\n   \n    float time = iTime;\n    \n    //time = mod( time, 8.0 );\n    float an = 0.3*(1.0-smoothstep(-0.1,0.1,sin(0.125*6.283185*(time+1.0/2.0))));\n    \n    vec2 r = vec2( sin(an), cos(an) );\n    vec2 pe = r.yx*vec2(-1.0,1.0);\n    \n    vec3 col = vec3(0.15);\n    col = vec3(21,32,43)/255.0;\n\n    float wi = 0.0015;\n    float s = dot(p,r);\n    if( s>0.0 )\n    {\n        float r = length(p);\n        if( r<0.12 )\n        {\n            float nr = r/0.12;\n            col += 0.25*nr*nr;\n        }\n        col = mix(col,vec3(0.7), 1.0-smoothstep(-e,e,abs(r-0.12)-wi));\n    }\n\n    col = mix( col, vec3(0.7), arrow(p, vec2(0.0), r*0.18, wi, 0.01, e) );\n    col = mix( col, vec3(0.7), line(p, -0.12*pe, 0.12*pe, wi, e) );\n\n    {\n    float an = cos(0.5*6.283185*time);\n    vec2 v = vec2( -cos(an), sin(an) )*0.12;\n    vec2 f;\n         if( q.x<0.333 ) f = flipIfNeg( v, r );\n    else if( q.x<0.666 ) f = reflIfNeg( v, r );\n    else                 f = clipIfNeg( v, r );\n\n    col = mix( col, col+0.2, arrow(p, vec2(0.0), v, wi, 5.0*wi, e) );\n    col = mix( col, vec3(1.0,0.7,0.2), arrow(p, vec2(0.0), f, wi, 5.0*wi, e) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBXzK", "name": "Laser Party (not for epileptics)", "author": "darxkies", "description": " Inspired by https://www.shadertoy.com/view/4dsSRM", "tags": ["whitneymusicbox"], "likes": 25, "viewed": 2085, "date": "1413555246", "time_retrieved": "2024-06-20T18:13:16.830667", "image_code": "// Whitney Music Box - Jim Bumgardner\n// whitneymusicbox.org\n\nconst float rad = 0.6;\nconst float dots = 32.0;\nconst float duration = 180.0;\nconst vec3 colorsep = vec3(0,2.09,4.18);\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI2 = 2.0*3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  float tm = mod(iTime,duration)/duration;\n  p.y *= iResolution.y/iResolution.x;\n\n  vec3 gradient = vec3(0.0);\n\n  for (float i=1.0; i<=dots; i++)\n  {\n    float i2pi = i*PI2;\n    float ang = mod(tm*i2pi, PI2);\n    float amp = rad*(1.0-(i-1.0)/dots);\n    float cang = i2pi/dots;\n    //float fade = 0.7 - pow(smoothstep(0.0,1.0,ang),2.0)*0.5;\n    float fade = 0.5 + 0.1 * tan(ang);\n    vec2 star_pos = vec2(cos(ang) * amp, -sin(ang) * amp);\n    gradient += (cos(cang+colorsep) + 1.0/2.0) * ((fade / 384.0) / pow(length(star_pos - p), 1.5)) * fade;\n  }\n  fragColor = vec4( gradient, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dBXzV", "name": "mactkg::BPM", "author": "mactkg", "description": "BPM", "tags": ["timesuburi"], "likes": 0, "viewed": 100, "date": "1413651570", "time_retrieved": "2024-06-20T18:13:16.830667", "image_code": "float bpm = 140.0;\nfloat v = 60.0/bpm;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(mod(iTime, v)/v, 1.0, 1.0 ,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djSRG", "name": "RNM Normalmap combine", "author": "bazhenovc", "description": "Added RNM technique to this awesome shader: https://www.shadertoy.com/view/MsSXzG", "tags": ["normalmap"], "likes": 12, "viewed": 296, "date": "1413212584", "time_retrieved": "2024-06-20T18:13:17.285076", "image_code": "// A fork of: https://www.shadertoy.com/view/MsSXzG by TDM\n// added RNM normal blending method to the original TDM demo\n\n/*\n * |===============================================|\n * |      RNM           |   DERIVATIVES ADDITION   |\n * |===============================================|\n * |  NORMALS ADDITION  |   DERIVATIVES BLENDING   |\n * |===============================================|\n */\n\n// normalmap texture\nvec3 textureNormal(vec2 uv) {\n    uv = fract(uv) * 3.0 - 1.5;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    ret = ret * 0.5 + 0.5;    \n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.98,dot(uv,uv)));\n}\n\n// normals combine: normals addition\nvec3 combineNormals0(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    return normalize(n0 + n1) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives addition\nvec3 combineNormals1(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    n0 = vec3(n0.xy + n1.xy, n0.z * n1.z);\n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives blending\nvec3 combineNormals2(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\tn0  = vec3(n0.xy * n1.z + n1.xy * n0.z, n0.z * n1.z);    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: RNM\nvec3 combineNormalsRNM(vec3 n0, vec3 n1) {\n    vec3 t = n0 * vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    vec3 u = n1 * vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    vec3 r = t * dot(t, u) / t.z - u;\n    return r * 0.5 + 0.5;\n}\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color;\n    vec2 time = vec2(sin(iTime * 0.1), cos(iTime * 0.1));\n    vec3 n0 = textureNormal(uv + time);\n    vec3 n1 = textureNormal(uv - time + vec2(0.25));\n    \n    // combine normals\n    if(uv.x < 0.0) {\n        if(uv.y > 0.0) {\n    \t\tcolor = combineNormalsRNM(n0, n1);\n        } else {\n            color = combineNormals0(n0,n1);\n        }\n    } else {\n        if(uv.y > 0.0) {\n        \tcolor = combineNormals1(n0,n1);\n        } else {            \n        \tcolor = combineNormals2(n0,n1);\n        }\n    }\n    \n    // borders\n    color += max(smoothstep(0.01,0.005,abs(uv.x)),0.0);\n    color += max(smoothstep(0.01,0.005,abs(uv.y)),0.0);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djSWm", "name": "Rainbow flower", "author": "bauble", "description": "Messing around with trigonometric functions", "tags": ["2d", "radial", "textureless"], "likes": 7, "viewed": 189, "date": "1412721477", "time_retrieved": "2024-06-20T18:13:17.291158", "image_code": "// License: CC0 1.0\n// http://creativecommons.org/publicdomain/zero/1.0/\n\nconst int iterations = 8;\nconst float colour_separation = 6.283185307/float(iterations);\nfloat angle_separation = colour_separation * (sin(iTime * 0.002)* 16.0 + 16.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = dot(uv, uv);\n    float a = atan(uv.x, uv.y);\n    vec3 c = vec3(0);\n    for (int i = 0; i < 16; ++i)\n    {\n    \tfloat x = (pow(d, 0.02) * 2.5 - 2.3 + sin((a + float(i) * angle_separation) *5.0) * 0.1) * 10.0;\n    \tx = x < 1.0 ? x : 2.0 - x;\n        vec3 r = vec3(sin(float(i) * colour_separation        ) * 0.5 + 0.5,\n                      sin(float(i) * colour_separation + 2.094) * 0.5 + 0.5,\n                      sin(float(i) * colour_separation + 4.189) * 0.5 + 0.5);\n        c += r*x;\n    }\n    c = c / float(iterations) * 2.0;\n    vec3 f = pow(c, vec3(0.8));\n    f *= clamp(c * 2.0, vec3(0.25), vec3(1.0));\n\tfragColor = vec4(f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djSWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4djXDD", "name": "Metaballs 2-D", "author": "GraphicsMuncher", "description": "Metaballs. No spaghetti. ", "tags": ["2d", "metaballs"], "likes": 1, "viewed": 152, "date": "1412298295", "time_retrieved": "2024-06-20T18:13:17.291158", "image_code": "#define NUM_BALLS 5\n#define STRAT 4.0\n#define WIDTH 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    vec2 pos;\n    float t = iTime;\n    float sum = 0.0;\n    for( int i = 0; i < NUM_BALLS; i++ )\n    {\n        float st = sin( t );\n        float fi = float(i);\n        \n    \tpos = 0.5*vec2( 0.5*st + 0.5*cos(t+fi)+cos( t + float(i)), cos ( (1.0+0.5*fi)*t +st + float(i)));\n        float d = 0.02/((pos.x-uv.x)*(pos.x-uv.x) + (pos.y-uv.y)*(pos.y-uv.y) );\n        sum+=d;\n    }\n    sum = floor(STRAT*sum)/STRAT;\n    sum = step(WIDTH,sum)*sum;\n    vec2 mPos = iMouse.xy/iResolution.xy; mPos.x = 1.0-mPos.x;\n    vec3 col = vec3(1,1,0)-vec3(mPos,0);\n\tfragColor = vec4(sum*col + vec3(0.7-0.2*length(uv))*step(sum,0.01)*col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djXDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSSDw", "name": "doughy", "author": "dzira", "description": "just messing around", "tags": ["2d"], "likes": 1, "viewed": 144, "date": "1412438810", "time_retrieved": "2024-06-20T18:13:17.291158", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv-0.5)*10.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 p1 = vec2(cos(iTime*1.1)-0.5,-.2+sin(iTime*0.8));\n    vec2 p2 = vec2(0.0,.4+0.4*sin(iTime+1.0));\n    vec2 p3 = vec2(.4+sin(iTime),0.0);\n    p1 = mix(mix(p1,p2,uv.y),mix(p2,p3,uv.x),uv.x), 0.0, 1.0;\n    float x = clamp(smoothstep(0.0,2.0,distance(uv,p1)), 0.0, 1.0);\n    x = sqrt(1.0-x*x);\n\tfragColor = vec4(mix(vec3(.1,.0,.15), vec3(1.0,.8,.4), x),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSSRG", "name": "Halftone plasma flower", "author": "klk", "description": "oldschool-like 2d effect of sine plasma in polar coordinates, with cmyk halftone raster", "tags": ["2d", "plasma", "halftone"], "likes": 31, "viewed": 1291, "date": "1412941536", "time_retrieved": "2024-06-20T18:13:17.291158", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat vx(float x,float y, float a)\n{\n    float l=1.0/sqrt(a*a+(1.0-a)*(1.0-a));\n    float u=x*a-y*(1.0-a);\n    float v=x*(1.0-a)+y*a;\n    u*=l;\n    v*=l;\n//    return (sin(u)+sin(v)+2.0)/2.0;\n    float scale=0.00043*iResolution.x;\n    u=fract(u*scale)-0.5;\n    v=fract(v*scale)-0.5;\n\treturn 1.0-sqrt(u*u+v*v)*sqrt(2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iMouse.xy) / max(iResolution.x,iResolution.y)*4.0-0.5;\n    float t=iTime;\n    float r=length(uv);\n\tfloat a=atan(uv.x,uv.y)/M_PI/2.0+sin(r+t)*0.1;\n\t\n    fragColor = vec4(\n        vx(uv.x, uv.y,iMouse.x/iResolution.x*2.0-0.5),0,0,1\n        );\n//    return;\n    \n    fragColor = vec4(\n         (r-sin(r*M_PI*2.0+t*4.0)*0.1-sin(a*M_PI*22.0+t*4.0)*0.1+sin(a*M_PI*12.0+t)*0.4-1.5)+vx(uv.x*150.0,uv.y*150.0,0.12)\n        ,(r-sin(r*M_PI*3.0+t*5.0)*0.1-sin(a*M_PI*26.0+t*5.0)*0.1-sin(a*M_PI*8.0-t )*0.4-1.5)+vx(uv.x*150.0,uv.y*150.0,0.34)\n        ,(r-sin(r*M_PI*2.0+t*8.0)*0.1-sin(a*M_PI*24.0+t*6.0)*0.1-sin(a*M_PI*10.0  )*0.4-1.5)+vx(uv.x*150.0,uv.y*150.0,0.69)\n        ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSXWm", "name": "Gauss shit", "author": "joon", "description": "Hazy drug effect.", "tags": ["2d", "gauss", "shitcode"], "likes": 5, "viewed": 238, "date": "1412472702", "time_retrieved": "2024-06-20T18:13:17.588118", "image_code": "/*\nShitty little gaussian effect\nLoad a track into channel0\nA kernel uses the mouse as input, so try it!\n*/\nfloat gauss (vec2 kernel, float amp, float spreadx, float spready,vec2 fragCoord)\n{\n    vec2 delta = (fragCoord.xy - kernel)/iResolution.xy;\n    vec2 d1 = delta*delta;\n    d1.x /= 2.0*spreadx*spreadx;\n    d1.y /= 2.0*spready*spready;\n    return amp*exp (-(d1.x + d1.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iChannelTime[0];\n    float s = texture (iChannel0, vec2 (0,0)).x;\n    fragColor = vec4 (0,0,0.2,1);\n    //First kernel\n    vec2 k1 = vec2 (0.3*iResolution.x, 0.3*iResolution.y);\n\tk1.x += 0.5*(160.0*cos (0.7*iTime) + 160.0*cos (0.7*t));\n\tk1.y -= 0.5*(240.0*sin (0.2*iTime) + 240.0*sin (0.2*t));\n    fragColor.y += gauss (k1, 0.5 + 0.2*s, 0.3, 0.3,fragCoord);\n    //Second kernel\n    vec2 k2 = vec2 (iResolution.x, 0.13*iResolution.y);\n\tk2.x -= 0.5*(100.0*cos (1.5*iTime) + 100.0*cos (1.5*t));\n\tk2.y += 0.5*(150.0*sin (0.5*iTime) + 150.0*sin (0.5*t));\n\tfragColor.y += gauss (k2, 0.4 + 0.15*s, 0.2, 0.2,fragCoord);\n    //Third kernel\n\tvec2 k3 = vec2 (0.5*iResolution.x, 0.65*iResolution.y);\n\tk3.x += 130.0*cos (0.9*t);\n\tk3.y -= 95.0*sin (1.3*t);\n    float v = gauss (k3, 0.1*s + 0.5 + 0.2*cos (t), 0.3, 0.3,fragCoord);\n\tfragColor.y += v;\n    fragColor.x += 0.2*s + 0.5*sin (t);\n    //Fourth kernel\n\tvec2 k4 = vec2 (0.69*iResolution.x, 0.55*iResolution.y);\n\tk4.x -= 200.0*cos (0.7*t);\n\tk4.y += 150.0*sin (t + s);\n\tfragColor.x += gauss (k4, abs (0.8*sin (t)), 0.3, 0.3,fragCoord);\n    //Fifth kernel\n\tvec2 k5 = vec2 (0.73*iResolution.x, 0.28*iResolution.y);\n\tk5.x -= 185.0*cos (1.25*t);\n\tk5.y += 150.0*sin (0.95*t);\n\tfragColor.z += gauss (k5, abs (0.5*cos (0.5*t + s)), 0.3, 0.4,fragCoord);        \n    //Add mouse for fun\n    vec2 ofs = iMouse.xy;\n    ofs.x += 43.0*cos (t + 0.5*iTime);\n    ofs.y -= 56.0*sin (t + 0.5*iTime);\n    fragColor.y += gauss (ofs, 0.3, 0.2, 0.2,fragCoord);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSXWw", "name": "Playing with stuff", "author": "ga2arch", "description": "Playing with functions taken from iq works trying to understand them. ", "tags": ["3d", "lighting", "shadows"], "likes": 4, "viewed": 238, "date": "1412428574", "time_retrieved": "2024-06-20T18:13:17.594230", "image_code": "vec3 rotateX (float a, vec3 v) {\n    return vec3(v.x, \n                cos(a)*v.y + sin(a) * v.z,\n                cos(a)*v.z - sin(a) * v.y);\n}\n\nvec3 rotateY (float a, vec3 v) {\n    return vec3(cos(a)*v.x + sin(a) * v.z, \n                v.y,\n                cos(a)*v.z - sin(a) * v.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*\n        vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat map (in vec3 p) {\n    vec3 q = rotateY(iTime, p);\n\n    float plane = p.y + 1.0;\n\n    float sphere = length(q) - 1.2;\n\n    //q = rotateY(0.6, p);\n    float cube = sdBox(q, vec3(1.0));\n    float m = max(-sphere, cube);\n\n    return min(plane, m);\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3(0.2,0.0,0.0);\n\n    return normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx)) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = map(ro + rd*t);\n        h = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos )*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    \n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nfloat intersect (in vec3 ro, in vec3 rd) {\n\n    float h = 1.0;\n    float tmax = 45.0;\n    float t = 0.0;\n\n    for (int i=0; i<180; i++) {\n        if (h < 0.0001 || t > tmax) break;\n\n        h = map(ro + t*rd);\n        t += h;\n    }\n\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3 (0.0, 1.0, 4.0);\n    vec3 rd = normalize(vec3(p, -1.0));\n\n    float tmax = 20.0;\n    float t = intersect(ro, rd);\n\n    vec3 lig = normalize(\n        rotateY(iTime/2.0, vec3(-0.5,0.7,-1.0))\n        );\n\n    vec3 bgc = 0.8*vec3(0.8,0.9,1.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n\n    if (t<tmax) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal (pos);\n        vec3 ligh = normalize(lig - pos);\n        \n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        \n        col = brdf;\n        //col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*t*t ),0.0,1.0) );\n    } else {\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        col += sun;\n    }\n\n    //col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    col = pow( col, vec3(0.75) );\n    col = 1.3*col-0.1;\n    col *= vec3( 1.0, 1.04, 1.0);\n    col *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2Sz3", "name": "Train Ride", "author": "dr2", "description": "Take a long trip through the mountains and enjoy the view.", "tags": ["raymarching", "landscape", "railway"], "likes": 62, "viewed": 6429, "date": "1414412032", "time_retrieved": "2024-06-20T18:13:20.782360", "image_code": "// \"Train Ride\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Borrows ideas and techniques published on Shadertoy.\n// Thanks everyone for a great learning resource!!\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)),\n     step (c.b, c.g));\n  vec4 q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  float d = q.x - min (q.w, q.y);\n  const float e = 1.e-10;\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 BrickSurfCol (vec2 p) {\n  vec2 q = p * (1. / 20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y / 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (10. * p)) * (0.3 + 0.7 * q.x * q.y) *\n     (0.3 + 0.2 * sin (2. * Hashfv2 (i) + vec3 (1., 1.2, 1.4)));\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 150.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, vec2 b)\n{\n  return max (length (p.xz) - b.x, abs (p.y) - b.y);\n}\n\nmat3 trainMat[5], trMat;\nvec3 trainPos[5], trPos, qTrWin, sunDir, sunCol, moonDir, moonCol;\nvec2 trkOffset;\nfloat tCur, dirTrWin;\nint idObj;\nbool isNight;\nconst float dstFar = 250.;\n\nvec3 TrackPath (float t)\n{\n  float y = 0.01 + sin (0.021 * t) * sin (1. + 0.023 * t);\n  return vec3 (15. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     11. * sin (0.0032 * t) + 100. * trkOffset.x, 2. * y * y, t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = p * 0.06;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4) {\n      ht += 50. * pow (Noisefv2 (0.003 * q), 4.) - 1.;\n      if (hiRes == 0) break;\n    }\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y += 0.07 * Noisefv2 (0.0001 * p) + 0.04 * Noisefv2 (2.1 * p) +\n     0.03 * Noisefv2 (2.3 * p.yx);\n  float g = smoothstep (4., 35., abs (p.x - pt.x));\n  return SmoothMin (ht, pt.y * (1. - g) + ht * g, 0.5);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.02, 0.1, 0.02), gCol8 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + gCol7);\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol8, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.06;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.1 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol1 = vec3 (0.05, 0.05, 0.15), sbCol2 = vec3 (0.2, 0.25, 0.5);\n  vec3 col;\n  if (isNight) col = 0.3 * clamp (sbCol1 - 0.12 * rd.y * rd.y, 0., 1.);\n  else col = sbCol2 + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const vec3 sCol1 = vec3 (0.06, 0.04, 0.02), sCol2 = vec3 (0.03, 0.03, 0.06),\n     mBrite = vec3 (-0.5, -0.4, 0.77);\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * (f - 0.4) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  if (isNight) {\n    vec3 bgCol = SkyBg (rd) + sCol1 * pow (clamp (dot (rd, moonDir), 0., 1.), 30.);\n    col = bgCol;\n    const float moonRad = 0.04;\n    vec3 vn;\n    bool mHit = false;\n    float bs = - dot (rd, moonDir);\n    float cs = dot (moonDir, moonDir) - moonRad * moonRad;\n    float ts = bs * bs - cs;\n    if (ts > 0.) {\n      ts = - bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - moonDir) / moonRad);\n        mHit = true;\n      }\n    }\n    if (mHit) {\n      col += 1.4 * moonCol * clamp (dot (mBrite, vn) *\n         (0.3 + Noisefv3 (5. * vn)), 0., 1.);\n    } else {\n      vec3 st = (rd + vec3 (1.));\n      for (int j = 0; j < 10; j ++) {\n        st = 11. * abs (st) / dot (st, st) - 3.;\n      }\n      col += min (1., 1.5e-6 * pow (min (16., length (st)), 4.5));\n    }\n    col = mix (col, sCol2, cloudFac) + bgCol;\n  } else {\n    float s = max (dot (rd, sunDir), 0.);\n    col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n       0.65 * min (pow (s, 256.), 0.3));\n    col = mix (col, vec3 (0.55), cloudFac);\n  }\n  return col;\n}\n\nfloat TrainDf (vec3 p, float dHit, float dir)\n{\n  const float eRad = 0.25;\n  vec3 q;\n  float d;\n  q = p;\n  if (dir == 0.) {\n    q.y -= 0.15;\n    d = length (max (abs (q) - vec3 (0.42, 0.25, 0.95), 0.)) - eRad;\n  } else {\n    q.yz += vec2 (2.6, 0.7 * dir);\n    d = length (vec4 (max (abs (q.x) - 0.45, 0.), max (2.5 - q.y, 0.),\n       max (- q.z * dir, 0.),\n       max (length (q.yz + vec2 (0., - 0.2 * dir)) - 3., 0.))) - eRad;\n  }\n  if (d < dHit) {\n    dHit = d;  idObj = 21;\n    if (dir == 0.) q.y -= 0.1;\n    else q.y -= 2.85;\n    qTrWin = abs (q);\n    dirTrWin = dir;\n  }\n  q = vec3 (p.y + 0.32, abs (p.x) - 0.46, p.z + 0.4);\n  vec2 ww = vec2 (0.12 - sign (q.y) * 0.02, 0.04);\n  d = min (PrCylDf (q, ww), PrCylDf (q - vec3 (0., 0., 1.), ww));\n  if (d < dHit) {\n    dHit = d;  idObj = 22;\n  }\n  if (dir != 0.) {\n    q = p;\n    if (dir > 0.) {\n      q.x = abs (q.x) - 0.2;\n      q.yz += vec2 (0.2, -1.6);\n      d = PrCylDf (q.xzy, vec2 (0.05, 0.1));\n      if (d < dHit) {\n        dHit = d;  idObj = 23;\n      }\n    } else {\n      q.yz += vec2 (0.15, 1.6);\n      d = PrCylDf (q.xzy, vec2 (0.07, 0.1));\n      if (d < dHit) {\n        dHit = d;  idObj = 24;\n      }\n    }\n  }\n  return dHit;\n}\n\nfloat RailDf (vec3 p, float dHit)\n{\n  vec2 w = vec2 (abs (p.x) - 0.5, p.y + 0.57);\n  float d = min (length (max (abs (w - vec2 (0., 0.14)) - vec2 (0.02), 0.)),\n     SmoothMin (length (max (abs (w - vec2 (0., 0.08)) - vec2 (0.01, 0.08), 0.)),\n     length (max (abs (w - vec2 (0., -0.02)) - vec2 (0.04), 0.)), 0.06));\n  if (d < dHit) {\n    dHit = d;  idObj = 10;\n  }\n  vec3 q = vec3 (p.x, p.y + 0.7, mod (p.z, 2.4) - 1.2);\n  d = PrOBoxDf (q, vec3 (0.75, 0.03, 0.15));\n  if (d < dHit) {\n    dHit = d;  idObj = 11;\n  }\n  return dHit;\n}\n\nfloat BridgeDf (vec3 p, float dHit, float hg)\n{\n  vec3 q = p;\n  float d = max (abs (q.x) - 0.85, q.y + 0.68);\n  q.y += 4.5;\n  q.z = mod (q.z + 1.3, 2.6) - 1.3;\n  d = max (max (d, - max (length (q.yz +\n     vec2 (4. * clamp (q.y / 4., -0.5, 0.5), 0.)) - 5.5, abs (q.z) - 0.9)), - hg);\n  if (d < dHit) {\n    dHit = d;  idObj = 12;\n  }\n  return dHit;\n}\n\nfloat PlatformDf (vec3 p, float dHit, float hg)\n{\n  vec3 q = vec3 (p.x, p.y, mod (p.z, 150.) - 75.);\n  vec3 qq = q + vec3 (-1.9, -0.4, 0.);\n  float d = min (min (PrBoxDf (vec3 (abs (q.x) - 1.7, q.y + 0.5, q.z),\n     vec3 (0.7, 0.05, 5.)), max (PrBoxDf (qq, vec3 (0.1, 0.7, 2.)),\n     - PrBoxDf (qq, vec3 (0.15, 0.5, 1.5)))),\n     max (PrCylDf (vec3 (abs (abs (q.x) - 1.7) - 0.4, q.y + 4.5, abs (q.z) - 4.4),\n     vec2 (0.13, 4.)), - hg));\n  if (d < dHit) {\n    dHit = d;  idObj = 13;\n  }\n  d = PrCylDf (q + vec3 (-1.9, -1.2, 0.), vec2 (0.1, 0.06));\n  if (d < dHit) {\n    dHit = d;  idObj = 14;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = TrainDf (trainMat[0] * (p - trainPos[0]), dHit, -1.);\n  dHit = TrainDf (trainMat[1] * (p - trainPos[1]), dHit, 0.);\n  dHit = TrainDf (trainMat[2] * (p - trainPos[2]), dHit, 0.);\n  dHit = TrainDf (trainMat[3] * (p - trainPos[3]), dHit, 0.);\n  dHit = TrainDf (trainMat[4] * (p - trainPos[4]), dHit, 1.);\n  float hg = p.y;\n  p.xy -= TrackPath (p.z).xy;\n  p.y -= 0.9;\n  dHit = RailDf (p, dHit);\n  dHit = BridgeDf (p, dHit, hg);\n  dHit = PlatformDf (p, dHit, hg);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nvec4 ObjCol (vec3 p, vec3 n)\n{\n  vec3 col = vec3 (0.);\n  float sp;\n  float dkFac = 1.;\n  if (idObj >= 10 && idObj <= 19) {\n    sp = 0.;\n    if (idObj == 10) {\n      col = vec3 (0.3);\n      sp = 1.;\n    } else if (idObj == 11) {\n      col = vec3 (0.12, 0.08, 0.04) * (1.5 + Noisefv2 (30. * p.xz));\n    } else if (idObj == 12) {\n      if (n.y > 0.9) col = vec3 (0.025) * (2. + Noisefv2 (15. * p.xz));\n      else col = 0.1 * BrickCol (0.5 * p, n);\n      dkFac = 0.4;\n    } else if (idObj == 13) {\n      p.xy -= TrackPath (p.z).xy;\n      col = vec3 (0.26, 0.22, 0.2) * BrickCol (0.3 * p, n);\n      dkFac = 0.2;\n    } else if (idObj == 14) {\n      if (isNight) col = vec3 (1., 0., 0.);\n      else col = vec3 (0.7, 1., 0.7);\n    }\n  } else if (idObj >= 21 && idObj <= 29) {\n    sp = 0.7;\n    if (idObj == 21) {\n      col = vec3 (0.7, 0.2, 0.2);\n      dkFac = 0.02;\n      sp = 0.7;\n    } else if (idObj == 22) {\n      col = vec3 (0.7, 0.3, 0.);\n      dkFac = 0.1;\n    } else if (idObj == 23) {\n      col = vec3 (1., 0., 0.);\n    } else if (idObj == 24) {\n      if (isNight) col = vec3 (1.);\n      else col = vec3 (1., 1., 0.);\n    }\n  }\n  if (isNight) col *= dkFac;\n  return vec4 (col, sp);\n}\n\nvoid TrainCarPM (float t)\n{\n  vec3 vp, vd, ve, vf;\n  trPos = TrackPath (tCur + t);\n  vp = TrackPath (tCur + t + 0.1) - trPos;\n  vd = - normalize (vec3 (vp.x, 0., vp.z));\n  ve = normalize (vec3 (0., vp.yz));\n  trPos.y += 0.9;\n  trMat = mat3 (vec3 (1., 0., 0.), vec3 (0., ve.z, - ve.y), ve) *\n      mat3 (vec3 (- vd.z, 0., vd.x), vec3 (0., 1., 0.), vd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec2 vDir)\n{\n  const float eps = 0.01;\n  vec4 col4;\n  vec3 col, vn;\n  float f;\n  vec3 roo = ro;\n  float dstHit = dstFar;\n  float dstGrnd = GrndRay (ro, rd);\n  idObj = 0;\n  float dstObj = ObjRay (ro, rd);\n  int idObjT = idObj;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.6;\n  }\n  bool isLit = true;\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    if (idObjT == 21 && (qTrWin.y < 0.2 &&\n       (qTrWin.x < 0.45 || qTrWin.x > 0.65) || dirTrWin == 0. &&\n       qTrWin.x < 0.3 && qTrWin.z < 0.7)) idObjT = 20;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObjT == 20) {\n      rd = reflect (rd, vn);\n      ro += eps * rd;\n      dstGrnd = GrndRay (ro, rd);\n      if (dstGrnd < dstFar) {\n        ro += dstGrnd * rd;\n        dstHit = dstGrnd;\n        refFac *= 0.4;\n        isGrnd = true;\n      } else {\n        col = refFac * SkyCol (ro, rd);\n        isLit = false;\n      }\n    } else {\n      col4 = ObjCol (ro, vn);\n      col = refFac * col4.xyz;\n      if (! isNight) {\n        col *=  sunCol * (0.3 + (max (0., dot (sunDir, vn)) +\n           col4.w * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 20.)));\n      } else {\n        if (idObjT == 21) col *= moonCol * (0.6 +\n           col4.w * pow (max (dot (rd, reflect (moonDir, vn)), 0.), 40.));\n      }\n      dstHit = dstObj;\n      isLit = ! (idObjT == 14 || (idObjT >= 20 && idObjT <= 29));\n    }\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n      isLit = false;\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    if (! isNight) {\n      f = dot (sunDir, vn);\n      col = sunCol * mix (col * (max (f, 0.) + 0.1), vec3 (refFac),\n         step (f, 0.) * col4.w * pow (max (dot (reflect (sunDir, vn), rd), 0.), 3.));\n    }\n  }\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  if (isNight && isLit) {\n    vec3 vLight = ro - trainPos[0];\n    vLight.z -= 2.2;\n    float dstLightI = 1. / length (vLight);\n    vLight *= dstLightI;\n    f = dot (vLight.xz, vDir);\n    if (dstLightI > 0.02 && f > 0.4) {\n      col *= (0.1 + pow (f, 8.)) * min (1., 100. * dstLightI * dstLightI);\n    } else {\n      col = RgbToHsv (col);\n      col.y = 0.1;\n      col.z *= col.z;\n      col.z *= 0.3 * col.z;\n      col = HsvToRgb (col);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 1.8;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (0.4, 0.5, 0.5));\n  moonDir = normalize (vec3 (0.3, 0.25, 0.5));\n  sunCol = vec3 (1., 0.9, 0.8);\n  moonCol = vec3 (1., 0.9, 0.5);\n  float dt = 0.3;\n  isNight = mod (floor (tCur / 1000.), 2.) != 0.;\n  float trStart = 12.;\n  float trGap = 2.2;\n  float tz;\n  tz = tCur + trStart - 2. * trGap;\n  vec2 vDir = normalize ((TrackPath (tz + dt).xz -\n     TrackPath (tz - dt).xz) / (2. * dt));\n  float dGap = sqrt (1. - vDir.x * vDir.x);\n  TrainCarPM (trStart);\n  trainPos[0] = trPos;  trainMat[0] = trMat;\n  TrainCarPM (trStart - trGap * dGap);\n  trainPos[1] = trPos;  trainMat[1] = trMat;\n  TrainCarPM (trStart - (2. * trGap + 0.25) * dGap);\n  trainPos[2] = trPos;  trainMat[2] = trMat;\n  TrainCarPM (trStart - (3. * trGap + 0.5) * dGap);\n  trainPos[3] = trPos;  trainMat[3] = trMat;\n  TrainCarPM (trStart - (4. * trGap + 0.5) * dGap);\n  trainPos[4] = trPos;  trainMat[4] = trMat;\n  bool fixCam = mod (floor (tCur / 500.), 2.) == 0.;\n  mat3 scMat;\n  vec3 ro, rd, vd;\n  if (fixCam) {\n    tz = ceil (tCur / 100.) * 100.;\n    ro = TrackPath (tz - 40.);\n    float dx = 2. * mod (tz / 100., 2.) - 1.;\n    ro.x += 13. * dx;\n    float gh = GrndHt (ro.xz, 0);\n    ro.xy += vec2 (-3. * dx, 3. + 0.1 * gh * gh);\n    vd = normalize (TrackPath (tCur + 8.) - ro);\n    vec3 u = - vd.y * vd;\n    float f = 1. / sqrt (1. - vd.y * vd.y);\n    scMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  } else {\n    tz = tCur + trStart - 6. * trGap * dGap;\n    ro = TrackPath (tz);\n    ro.y += 4.;\n    vd = TrackPath (tz + dt) - TrackPath (tz - dt);\n    vd.y = 0.;\n    vd = normalize (vd);\n    scMat = mat3 (vd.z, 0., - vd.x, 0., 1., 0., vd);\n  }\n  rd = scMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd, vDir);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2Sz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s2Xz3", "name": "Fake bounce 2.0", "author": "zachernuk", "description": "Some more stepping and fake placement of things. I know that the depth, shading, shadow and bounce aren't technically correct but I love the way the asthetic is developing into some seriously paleofuturistic 1980s techno-optimism. ", "tags": ["80s", "silly", "fake3d", "neon", "fakeshaded"], "likes": 5, "viewed": 212, "date": "1414437573", "time_retrieved": "2024-06-20T18:13:20.782360", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    vec2 ballCenter = vec2(0.5,0.5);\n    float radius = 0.2;\n\tfloat xCoord = 1.6*abs(mod(iTime/1.,2.0)-1.0);\n  \tfloat yCoord = radius+0.3*pow(abs(sin(iTime*3.6)),1.);\n\n    \n    float yCoordL = radius+0.3*pow(abs(sin((iTime-1./60.0)*3.6)),1.);\n\n    \n    float yV = abs(yCoord - yCoordL)*10.0;\n    \n    float zCoord = abs(mod(iTime/3.,2.0)-1.0);\n    \n    float ballDepth = 1.6+4.*zCoord;\n    \n\n     \n    ballCenter[1] = yCoord;\n    ballCenter[0] = xCoord;\n    \n\n    float yThreshold = 0.5+0.15*sin(iTime*0.15);\n    \n    float rOut= (mod(1./(-abs(uv[1]-yThreshold))/5.-iTime*1.2,1.));\n    //let's fog it off so that we're not getting the horrible moire.\n    \n    \n           \n    rOut = step(rOut,0.15);\n    rOut  = rOut*3.*abs(uv[1]-yThreshold);\n    \n    float gOut =  uv[1]>yThreshold?.2:.7;\n    gOut = gOut*3.*(abs(uv[1]-yThreshold)+0.07);\n    \n        vec3 clr = vec3(rOut,\n                       gOut,\n                        0.5+0.15*sin(iTime*10.));\n\n    \n        \n        float dx = abs(uv[0]-ballCenter[0])/radius;\n          \n        float dy = (uv[1]-0.12)*9.5;\n        float dist = sqrt(dy*dy+dx*dx)*ballDepth/(yCoord+0.8);\n        \n    \tclr = mix(vec3(0.0),clr,clamp(dist*1.,0.4,1.));       \n    \n    \n   \tdy = (uv[1]-ballCenter[1]);\n   \tdx = (uv[0]-ballCenter[0])*(1.+.14*yV);\n    \n    dist = sqrt(dy*dy+dx*dx);\n    if(dist<radius/ballDepth) {\n        \n        //let's do something more interesting with the ball's shading.\n        dy = (uv[1]-ballCenter[1]-0.03);\n        dx = (dx)*0.9;\n    \tdist = sqrt(dy*dy+dx*dx);\n   \t    \n        \n        dist*=9.;\n        dist = pow(dist,.60);\n \t\tclr = mix(vec3(0.0,0.3,0.4),vec3(1.),1.-dist);\n        \n    }\n    \n    \n\tfragColor = vec4(clr,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2Xz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sBSRd", "name": "Circular wind", "author": "bytewave", "description": "Just messing around", "tags": ["screensaver"], "likes": 5, "viewed": 339, "date": "1414729068", "time_retrieved": "2024-06-20T18:13:20.782360", "image_code": "float rand2d(vec2 co,float seed)\n{\n\treturn fract(sin(dot(co.xy ,vec2(seed,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv += vec2(1. + (sin(iTime * .2) * 0.5),1.); // Pan uv\n    uv *= 1.27; // Zoom uv\n    \n    //BackGround\n    vec3 BackGround = vec3(0.,0.,0.); //BackGround out\n    vec2 pos = vec2(0.,0.); //Warping Circle position\n    vec2 premod = vec2(0.,0.); //Not Warping Circle position\n    float space = 1. / 5.; //Cicles Space\n    \n    for(int i = 0;i <5;i++)\n    {\n        for(int j = 0;j <5 ;j++)\n        {\n            float fi = float(i); // float iterator\n            pos = vec2( fi * 3. * space,float(j) * space); // Circle on a grid\n            pos += sin ( rand2d(pos * fi, 55.) * ((iTime)  * 0.01) * 11.6 ) + 1.; // Displacement\n            float value = clamp(  tan( 1.7 - length(pos - uv) * 3.)   , 0.,1.) * .0424 ; // Circle tan value\n            vec3 Color = vec3(pos.x,pos.y,1. - pos.y); // position to color\n            BackGround += value * Color; // output color\n        }\n    }\n            \n    //Lines\n    vec3 l = vec3(0.,0.,0.);\n    float fi = 0.;\n    float Width = .04;\n    float WidthVariation = .4;    \n    float Intensity = 55.;\n    float Contrast =  1.5;\n    float Height =  1.75;\n    float Speed =  .15;\n    float SpeedVariation =  1.01;\n    \n    \n    for(int i = 0;i <5 ;i++)\n    {\n        fi = float(i);\n        \n        \n        l += pow( max (Width * ((fi + 1.) * WidthVariation) - abs(uv.y - Height + (sin(uv.x + (iTime * Speed) * (fi * SpeedVariation)) * (0.1 * fi) ) ) ,0.) , Contrast) * Intensity;\n    }   \n    \n    //Vignet\n    float vignet = pow(1. - length(uv2 - vec2(0.5,0.5) ) ,1.5);\n    \n    //Composition\n    vec4 Composition = vec4(BackGround * vignet + (l * BackGround * 0.3) + (l * 0.5) ,1.0);\n\tfragColor = Composition;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBSRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sBXRd", "name": "Quality Time", "author": "Branch", "description": "Quality Time", "tags": ["qualitytime"], "likes": 5, "viewed": 140, "date": "1414732466", "time_retrieved": "2024-06-20T18:13:21.139993", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b, float c ){\n  return 1.-floor(length(max(abs(coord-pos)-b,c)));\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat hexacon(vec2 coord, vec2 pos, float size, float thickness){\n    coord -= pos;\n    float COLOR=0.;\n    COLOR += 2.*sdCapsule(coord, vec2(0.33,-0.5)*size, vec2(-0.33,-0.5)*size, thickness);\n    COLOR += 2.*sdCapsule(coord, vec2(0.33,-0.5)*size, vec2(0.66,0.0)*size, thickness);\n    COLOR += 2.*sdCapsule(coord, vec2(0.33,0.5)*size, vec2(0.66,0.0)*size, thickness);\n    COLOR += 2.*sdCapsule(coord, vec2(0.33,0.5)*size, vec2(-0.33,0.5)*size, thickness);\n    COLOR += 2.*sdCapsule(coord, vec2(-0.33,0.5)*size, vec2(-0.66,0.0)*size, thickness);\n    COLOR += 2.*sdCapsule(coord, vec2(-0.33,-0.5)*size, vec2(-0.66,0.0)*size, thickness);\n    return COLOR;\n}\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat outlinetexture(){\n\tvec2 p = gl_FragCoord.xy / iResolution.xy;\n    return floor(length(texture(iChannel2, p).rgb)*1.04);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 s = coord*(1.0+sin(iTime+coord.x*1.5+coord.y*0.8)*0.1);\n\tfloat vignette = 1.0 / max(0.25 + 0.5*dot(coord,coord),1.);\n    coord *= 6.;\n    coord.x = mod(coord.x+floor(coord.y*1.)*.5,1.)-.5;\n    coord.y = mod(coord.y,1.)-.25;\n    \n    float modulotime = mod(iTime,10.);\n\ts *= rotate(iTime*0.4+3.);\n    s /= 0.3+0.64*(cos(s.x)+cos(s.y));\n    s.x+=cos(iTime*0.1)*13.;\n    s.y+=(iTime*4.5);\n\tvec3 COLOR =(vec3(0.9,0.4,0.5)\n        \t\t+vec3(floor(mod(s.y,1.)*3.+.015))\n        \t\t*vec3(0.2,0.5,0.2) );\n    COLOR += .1*sdCapsule(coord, vec2(-0.15,-0.15), vec2(0.15,0.15), 0.05);\n    COLOR += .1*sdCapsule(coord, vec2(0.15,-0.15), vec2(-0.15,0.15), 0.05);\n    coord = vec2(mod(s.x,.999)-.333,mod(s.y,.75)-0.21);\n   \tCOLOR -= hexacon(coord, vec2(0.0), .3-0.1*sin(iTime*5.+s.x+s.x), 0.02);\n   \tCOLOR -= hexacon(coord, vec2(0.5,0.333), .3-0.1*sin(iTime*5.+s.x), 0.02);\n   \tCOLOR -= hexacon(coord, vec2(-0.5,0.333), .3-0.1*sin(iTime*5.+s.x), 0.02);\n    \n\tfragColor = vec4( (texture(iChannel0,s).rgb*.04+.7*(COLOR))*vignette*vec3(1.8,1.,1.3)\n         \t\t\t\t,1.0);\n        \n} ", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBXRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sBXRy", "name": "Simple 2D Metaball", "author": "zombocom", "description": "My first shader: A simple method of rendering 2D metaballs. Just add the distance between the metaballs and the fragment together and treshold them. You can move one of the blobs with your mouse too.", "tags": ["2d", "simple", "metaball"], "likes": 13, "viewed": 1302, "date": "1413026311", "time_retrieved": "2024-06-20T18:13:21.139993", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 metaballs[5];\n    \n    metaballs[0] = vec3(sin(iTime) * 0.1 + 0.4, cos(iTime) * 0.1 + 0.4, 0.2);\n    \n    metaballs[1] = vec3(0.8, 0.2, 0.05);\n    metaballs[2] = vec3(1, 0.6, 0.03);\n    metaballs[3] = vec3(0.4, 0.8, 0.02);\n    \n    metaballs[4] = vec3(iMouse.xy / iResolution.y, 0.1);\n    \n\tvec2 ssnormal = fragCoord.xy / iResolution.y;\n    \n    float frag = 0.0;\n    \n    for(int i = 0; i < 5; i++)\n        frag += metaballs[i].z / distance(metaballs[i].xy, ssnormal);\n    \n    frag = clamp(frag, 0.0, 1.0);\n    frag = frag == 1.0 ? 1.0 : 0.0;\n    \n    fragColor = vec4(frag, frag, frag, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBXRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sBXzG", "name": "Star Map 1", "author": "morgan3d", "description": "Procedural space background. This is a nice alternative to cube maps, which are static and require a lot of memory at the resolutions needed for representing stars. Drag to rotate.", "tags": ["space", "stars", "nebula", "skybox", "starfield", "skysphere"], "likes": 48, "viewed": 3567, "date": "1413034463", "time_retrieved": "2024-06-20T18:13:22.243080", "image_code": "// Star map shader...procedural space background\n\n// Uncomment to see the lat-long grid for context\n// #define SHOW_LARGE_GRID\n#define SHOW_SPHERE\n#define SHOW_SPHERE_GRID\n#define SHOW_PLANET\n\nconst float pi = 3.1415927;\nconst float deg = pi / 180.0;\n\n// See derivation of noise functions by Morgan McGuire at https://www.shadertoy.com/view/4dS3Wd\nconst int NUM_OCTAVES = 4;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n// 1 octave value noise\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x);\tfloat a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n// Multi-octave value noise\nfloat NOISE(float x) { float v = 0.0; float a = 0.5; float shift = float(100); for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nfloat NOISE(vec2 x) { float v = 0.0; float a = 0.5; vec2 shift = vec2(100); mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50)); for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(x); x = rot * x * 2.0 + shift; a *= 0.5; } return v; }\n// Fast hash2 from https://www.shadertoy.com/view/lsfGWH\nfloat hash2(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat maxComponent(vec2 v) { return max(v.x, v.y); }\nfloat maxComponent(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat minComponent(vec2 v) { return min(v.x, v.y); }\nmat3 rotation(float yaw, float pitch) { return mat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); }\nfloat square(float x) { return x * x; }\n\n///////////////////////////////////////////////////////////////////////\n\n// Only globals needed for the actual spheremap\n\n// starplane was derived from https://www.shadertoy.com/view/lsfGWH\nfloat starplane(vec3 dir) { \n    float screenscale = 1.0 / iResolution.x;\n\n    // Project to a cube-map plane and scale with the resolution of the display\n    vec2 basePos = dir.xy * (0.5 / screenscale) / max(1e-3, abs(dir.z));\n         \n\tconst float largeStarSizePixels = 20.0;\n    \n    // Probability that a pixel is NOT on a large star. Must change with largeStarSizePixels\n\tconst float prob = 0.97;\n    \t\n\tfloat color = 0.0;\n\tvec2 pos = floor(basePos / largeStarSizePixels);\n\tfloat starValue = hash2(pos);\n    \n    // Big stars\n\tif (starValue > prob) {\n\n        // Sphere blobs\n\t\tvec2 delta = basePos - largeStarSizePixels * (pos + vec2(0.5));\n\t\tcolor = max(1.0 - length(delta) / (0.5 * largeStarSizePixels), 0.0);\n\t\t\n        // Star shapes\n        color *= 1.0 / max(1e-3, abs(delta.x) * abs(delta.y));\n        \n        // Avoid triplanar seams where star distort and clump\n        color *= pow(abs(dir.z), 12.0);\n    } \n\n    // Small stars\n\n    // Stabilize stars under motion by locking to a grid\n    basePos = floor(basePos);\n\n    if (hash2(basePos.xy * screenscale) > 0.997) {\n        float r = hash2(basePos.xy * 0.5);\n        color += r * (0.3 * sin(iTime * (r * 5.0) + r) + 0.7) * 1.5;\n    }\n\t\n    // Weight by the z-plane\n    return color * abs(dir.z);\n}\n\n\nfloat starbox(vec3 dir) {\n\treturn starplane(dir.xyz) + starplane(dir.yzx) + starplane(dir.zxy);\n}    \n\n\nfloat starfield(vec3 dir) {\n    return starbox(dir) + starbox(rotation(45.0 * deg, 45.0 * deg) * dir);\n}\n\n\nvec3 nebula(vec3 dir) {\n    float purple = abs(dir.x);\n    float yellow = noise(dir.y);\n    vec3 streakyHue = vec3(purple + yellow, yellow * 0.7, purple);\n    vec3 puffyHue = vec3(0.8, 0.1, 1.0);\n\n    float streaky = min(1.0, 8.0 * pow(NOISE(dir.yz * square(dir.x) * 13.0 + dir.xy * square(dir.z) * 7.0 + vec2(150.0, 2.0)), 10.0));\n    float puffy = square(NOISE(dir.xz * 4.0 + vec2(30, 10)) * dir.y);\n\n    return clamp(puffyHue * puffy * (1.0 - streaky) + streaky * streakyHue, 0.0, 1.0);\n}\n\n\nvec3 sun(vec3 d) {\n    float angle = atan(d.x, d.y);    \n    float falloff = pow(max(d.z, 0.0), 10.0);\n\tvec3 core = vec3(2.8, 1.5 + 0.5 * noise(iTime * 0.25 + d.xy * 5.0), 1.5) * falloff; \n    float corona = NOISE(vec2(d.z * 250.0 + iTime, iTime * 0.2 + angle * 50.0)) * smoothstep(0.95, 0.92, d.z) * falloff * square(d.z);\n    \n    return core * (1.0 - corona);\n}\n\n\nvec4 planet(vec3 view) {\n#ifdef SHOW_PLANET\n    const float PLANET_RADIUS = 0.65;\n    if (view.y > -PLANET_RADIUS) {\n        return vec4(0.0);\n    } \n    \n    // Compute the point on the planet sphere\n    float angle  = atan(view.x, view.z);\n    float radius = sqrt((1.0 + view.y) / (1.0 - PLANET_RADIUS));\n    \n    vec3 s = vec3(radius * normalize(view.xz), sqrt(1.0 - square(radius)));\n    \n    \n    vec3 dir = s;\n    dir = rotation(0.0, iTime * 0.01) * dir;\n    float latLongLine = 0.0;// (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n    \n    // Antialias the edge of the planet\n    vec4 surface = vec4(1.2 * vec3(1.0, 0.3, 0.4) * \n  \t\t\t(noise(dir * 39.0 + 3.5) * 0.5 + noise(dir * 26.0) + 2.0 * noise(dir * 13.0 + 1.0)) *\n         vec3(s.yx * 0.5 + 0.5, 0.0).rbg, smoothstep(0.992, 0.988, radius));\n\n    // Keep the clouds above the planet\n    vec4 cloud = vec4(vec3(1.5),\n                      smoothstep(1.0, 0.995, radius) * \n                      square(NOISE(vec2(iTime * 0.1, 0.0) + dir.xz * 11.0 * square(dir.y) + dir.yx * 3.0 + dir.zy * 1.2)));\n    \n    return vec4(\n        mix(surface.rgb, cloud.rgb, cloud.a) * (max(0.1, s.y) * vec3(1.0 - latLongLine)),\n        max(surface.a, cloud.a));\n#else\n    return vec4(0.0);\n#endif\n}\n\n\nvec3 sphereColor(vec3 dir) {\n    vec3 n = nebula(dir);\n    vec4 p = planet(dir);\n    vec3 color = \n        sun(dir) + \n        mix(vec3(starfield(dir)) * (1.0 - maxComponent(n)) +  // Nebula holds out star\n    \t    n, // nebula\n            p.rgb, p.a); // planet\n    \n\treturn color;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Spheremap visualization code from https://www.shadertoy.com/view/4sSXzG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n\t// Of the background\n\tconst float verticalFieldOfView = 60.0 * deg;\n\tconst float insetSphereRadius = 0.22;\n\n    float yaw   = -((iMouse.x / iResolution.y) * 2.0 - 1.0) * 3.0;\n    float pitch = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * 3.0;\n    \n\tvec3 dir = rotation(yaw, pitch) * normalize(vec3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / ( -2.0 * tan(verticalFieldOfView / 2.0))));\n    \n    fragColor.rgb = sphereColor(dir);\n#\tifdef SHOW_LARGE_GRID\n\t    float latLongLine = (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n        fragColor.rgb += latLongLine * vec3(0.0, 0.7, 1.5);\n#\tendif\n    \n    \n    #ifdef SHOW_SPHERE\n    // Inset sphere\n    vec2 spherePoint = (fragCoord.xy * scale - insetSphereRadius * 1.1) / insetSphereRadius;\n    if (length(spherePoint) <= 1.0) {\n        \n        // Antialias using many samples\n        vec3 c = vec3(0);\n        for (int x = -3; x <= 3; ++x) {\n\t        for (int y = -3; y <= 3; ++y) {\n\t\t\t    vec2 s = clamp(((fragCoord.xy + vec2(x, y) / 7.0) * scale - insetSphereRadius * 1.1) / insetSphereRadius, vec2(-1.0), vec2(1.0));\n\t\t        dir = rotation(iTime, -iTime * 0.17) * vec3(s.xy, sqrt(max(0.0, 1.0 - dot(s.xy, s.xy))));\n\t\t\t\tc += sphereColor(dir);\n#\t\t\t\tifdef SHOW_SPHERE_GRID\n\t    \t\t\tfloat latLongLine = (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));\n        \t\t\tc += latLongLine * vec3(0.0, 0.7, 1.5);\n#\t\t\t\tendif\n            }\n        }\n        c /= 36.0;\n                    \n        // Fade the inset sphere to antialias its border transition\n        fragColor.rgb = mix(sqrt(fragColor.rgb), c, clamp((1.0 - length(spherePoint)) * 100.0, 0.0, 1.0));\n    }\n    #endif\n    \n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBXzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sjXzG", "name": "Terrain Tubes", "author": "iq", "description": "Testing some super cheap cosine-based noise, and some random ideas on tubes.", "tags": ["procedural", "3d", "distancefield", "terrain"], "likes": 137, "viewed": 16455, "date": "1413297020", "time_retrieved": "2024-06-20T18:13:24.146286", "image_code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n#define USE_BOUND_PLANE\n\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat noi( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nfloat terrainLow( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n\treturn t*55.0;\n}\n\nfloat terrainMed( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n            \n    return t*55.0;\n}\n\nfloat terrainHigh( vec2 p )\n{\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n    \n    t +=   0.05*textureLod( iChannel0, 0.001*q, 0.0 ).x;\n    t +=   0.03*textureLod( iChannel0, 0.005*q, 0.0 ).x;\n    t += t*0.03*textureLod( iChannel0, 0.020*q, 0.0 ).x;\n\n\treturn t*55.0;\n}\n\nfloat tubes( vec3 pos, float time )\n{\n    float sep = 400.0;\n\n    pos.z -= sep*0.025*noi( 0.005*pos.xz*vec2(0.5,1.5) );\n    pos.x -= sep*0.050*noi( 0.005*pos.zy*vec2(0.5,1.5) );\n    \n    vec3 qos = mod( pos + sep*0.5, sep ) - sep*0.5; \n    qos.y = pos.y - 70.0;\n    qos.x += sep*0.3*cos( 0.01*pos.z);\n    qos.y += sep*0.1*cos( 0.01*pos.x );\n\n    float sph = length( qos.xy ) - sep*0.012;\n\n    sph -= (1.0-0.8*smoothstep(-10.0,0.0,qos.y))*sep*0.003*noi( 0.15*pos.xy*vec2(0.2,1.0) );\n\n    return sph;\n}\n\n\nfloat tubesH( vec3 pos, float time )\n{\n    float t = tubes( pos, time );\n\n    t += 1.0*texture( iChannel3, 0.01*pos.yz ).x;\n    t += 2.0*texture( iChannel0, 0.005*pos.xy ).x;\n\n    return t;\n}\n\nvec2 map( in vec3 pos, float time )\n{\n    float m = 0.0;\n\tfloat h = pos.y - terrainMed(pos.xz);\n\n    float sph = tubes( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n    m = mix( m, 1.0, w ) - 1.0*w*(1.0-w);\n    m = clamp(m,0.0,1.0);\n\n    return vec2( h, m );\n}\n\nfloat mapH( in vec3 pos, in float time )\n{\n    float y = terrainHigh(pos.xz);\n        \n    float h = pos.y - y;\n    \n    float sph = tubesH( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n\n    return h;\n}\n\nvec2 interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float time )\n{\n    float t = tmin;\n    float  m = 0.0;\n\tfor( int i=0; i<160; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        vec2 res = map( pos, time );\n        m = res.y;\n        if( res.x<(0.001*t) || t>tmax  ) break;\n        t += res.x * 0.5;\n\t}\n\n\treturn vec2( t, m );\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd )\n{\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\n\nvec3 calcNormalHigh( in vec3 pos, float t, in float time )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*mapH( pos + e.xyy, time ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx, time ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy, time ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx, time ) );\n}\n\n\nvec3 calcNormalMed( in vec3 pos, float t )\n{\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 1100.0*vec2( cos(0.0+0.23*time), cos(1.5+0.205*time) );\n\treturn vec3( p.x, 0.0, p.y );\n}\n\nvec3 dome( in vec3 rd, in vec3 light1 )\n{\n\tfloat sda = clamp(0.5 + 0.5*dot(rd,light1),0.0,1.0);\n    float cho = max(rd.y,0.0);\n    \n    vec3 bgcol = mix( mix(vec3(0.00,0.40,0.60)*0.7, \n                          vec3(0.80,0.70,0.20),                        pow(1.0-cho,3.0 + 4.0-4.0*sda)), \n                          vec3(0.43+0.2*sda,0.4-0.1*sda,0.4-0.25*sda), pow(1.0-cho,10.0+ 8.0-8.0*sda) );\n    bgcol *= 0.8 + 0.2*sda;\n    return bgcol*0.75;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 sp = xy*vec2(iResolution.x/iResolution.y,1.0);\n\n    //--------------------------\n\n    // animate    \n    float camid = floor((0.0+iTime-0.0)/9.0);\n    float time = 16.5 + (0.0+iTime-0.0)*0.1 + 20.0*iMouse.x/iResolution.x + 72.1*camid + 19.0*max(0.0,camid-1.0);\n\n    // camera    \n\tfloat cr = 0.18*sin(-0.1*time);\n\tvec3  ro = camPath( time + 0.0 );\n\tvec3  ta = camPath( time + 3.0 );\n    ro.y = terrainLow( ro.xz ) + 60.0 + 30.0*sin(1.0*(time-14.4));\n\tta.y = ro.y - 200.0;\n    // camera to world transformation\n    mat3 cam = setCamera( ro, ta, cr );\n    \n    // light      \n    vec3 light1 = normalize( vec3(-0.8,0.2,0.5) );\n    \n    //--------------------------\n    \n    // generate ray\n    vec3 rd = cam * normalize(vec3(sp.xy,1.5));\n        \n    // background    \n    vec3 bgcol = dome( rd, light1 );\n    \n    // raymarch\n    float tmin = 10.0;\n    float tmax = 4500.0;\n    \n#ifdef USE_BOUND_PLANE\n    // intersect boundg plane\n    float maxh = 130.0;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n    \n\tfloat sundotc = clamp( dot(rd,light1), 0.0, 1.0 );\n    vec3  col = bgcol;\n    \n    vec2 res = interesct( ro, rd, tmin, tmax, time );\n    if( res.x>tmax )\n    {\n        // sky\t\t\n\t\tcol += 0.2*0.12*vec3(1.0,0.5,0.1)*pow( sundotc,5.0 );\n\t\tcol += 0.2*0.12*vec3(1.0,0.6,0.1)*pow( sundotc,64.0 );\n\t\tcol += 0.2*0.12*vec3(2.0,0.4,0.1)*pow( sundotc,512.0 );\n\n        // clouds\n  \t\tvec2 sc = ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, 0.25*vec3(0.5,0.9,1.0), 0.4*smoothstep(0.0,1.0,texture(iChannel0,0.000005*sc).x) );\n\n        // sun scatter\n        col += 0.2*0.2*vec3(1.5,0.7,0.4)*pow( sundotc, 4.0 );\n    }\n\telse\n\t{\n        // mountains\t\t\n        float t = res.x;\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormalHigh( pos, t, time );\n        vec3 sor = calcNormalMed( pos, t );\n        vec3 ref = reflect( rd, nor );\n\n        // rock\n        col = vec3(0.07,0.06,0.05);\n        col *= 0.2 + sqrt( texture( iChannel0, 0.01*pos.xy*vec2(0.5,1.0) ).x *\n                           texture( iChannel0, 0.01*pos.zy*vec2(0.5,1.0) ).x );\n        vec3 col2 = vec3(1.0,0.2,0.1)*0.01;\n        col = mix( col, col2, 0.5*res.y );\n        \n        // grass\n        float s = smoothstep(0.6,0.7,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.15,0.2,0.01*nor.x+texture(iChannel0, 0.001*pos.zx).x);\n        vec3 gcol = 0.13*vec3(0.22,0.23,0.04);\n        gcol *= 0.3+texture( iChannel1, 0.03*pos.xz ).x*1.4;\n        col = mix( col, gcol, s );\n        //col *= texture( iChannel0, 0.3*pos.xz ).x*3.2;\n        nor = mix( nor, sor, 0.3*s );\n        vec3 ptnor = nor;\n\n        // trees\n        s = smoothstep(0.9,0.95,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.1,0.13,-0.17+texture(iChannel0, 0.001*pos.zx).x);\n        vec3 tor = -1.0 + 2.0*texture( iChannel1, 0.015*pos.xz ).xyz;\n        tor.y = 1.5;\n        tor = normalize(tor);\n        col = mix( col, 0.11*vec3(0.22,0.25,0.02)*1.0, s );\n        nor = mix( nor, tor, 0.7*s );\n        \n\t\t// snow\n        s = ptnor.y + 0.008*pos.y - 0.2 + 0.2*(texture(iChannel1,0.00015*pos.xz+0.0*sor.y).x-0.5);\n        float sf = fwidth(s) * 1.5;\n        s = smoothstep(0.84-sf, 0.84+sf, s );\n        col = mix( col, 0.15*vec3(0.42,0.6,0.8), s);\n        nor = mix( nor, sor, 0.5*smoothstep(0.9, 0.95, s ) );\n\n        // lighting\t\t\n        float amb = clamp( nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sha = mix( calcShadow( pos, light1 ), 1.0, res.y );\n        float spe = pow( clamp( dot(ref,light1), 0.0, 1.0 ), 4.0 ) * dif;\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n        lin += dif*vec3(11.0,6.00,3.00)*vec3( sha, sha*sha*0.5+0.5*sha, sha*sha*0.8+0.2*sha );\n\t\tlin += amb*vec3(0.25,0.30,0.40);\n        lin += bac*vec3(0.35,0.40,0.50);\n        lin += spe*vec3(4.00,4.00,4.00)*res.y;\n        \n        col *= lin;\n\n        // fog\n        col = mix( col, 0.25*mix(vec3(0.4,0.75,1.0),vec3(0.3,0.3,0.3), sundotc*sundotc), 1.0-exp(-0.0000008*t*t) );\n\n        // sun scatter\n        col += 0.15*vec3(1.0,0.8,0.3)*pow( sundotc, 8.0 )*(1.0-exp(-0.003*t));\n\n        // background\n        col = mix( col, bgcol, 1.0-exp(-0.00000004*t*t) );\n    }\n    \n    // gamma\n\tcol = pow( col, vec3(0.45) );\n \n    // color grading    \n    col = col*1.4*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n    \n    // vignetting\t\n \tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n \n    // camera fade\n    col *= smoothstep( 0.0, 0.1, 2.0*abs(fract(0.5+iTime/9.0)-0.5) );\n   \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjXzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sS3zw", "name": "Motion blurred sickles", "author": "kig", "description": "shutterSpeed 1/15, t=508.31", "tags": ["raytracing", "motionblur", "camerasimulation"], "likes": 1, "viewed": 172, "date": "1414095892", "time_retrieved": "2024-06-20T18:13:26.091954", "image_code": "#define SHADOWS\n#define REFLECTION\n#define SECOND_BOUNCE\n//#define OCULUS\n#define SAILS\n#define MBLUR_SAMPLES 4.0\n\n#define FOG_D 80.0\n\n#define L_COUNT 1.0\n#define M_COUNT 1.0\n#define N_COUNT 3.0\n#define I_COUNT 3.0\n#define J_COUNT 3.0\n\nstruct tSphere {\n\tvec3 center;\n\tfloat radius;\n\tvec3 color;\n\tfloat spec;\n};\n\n// return ray p,d distance to triangle v0,v1,v2\n// returns -1.0 if no intersection\n// writes UV value to the uv vector\nfloat rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tuv = vec2(u,v);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn -1.0;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\tfloat m = float(t <= 0.00001 || (a > -0.00001 && a < 0.00001));\n\t\n\tt = mix(t, -1.0, m);\n\t\n\treturn t;\n\n}\n\n\nfloat raySphereDet(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nbool rayBV(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b);\n\tif (d < 0.0) {\n\t\treturn true;\n\t};\n\tfloat t = -b - sqrt(d);\n\treturn (t < -(2.0*radius) || t > closestHit+(2.0*radius));\n}\n\nfloat rayIntersectsSphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn -1.0;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t < 0.0 || t > closestHit) { // 2\n\t\treturn -1.0;\n\t} else {\n\t\treturn t;\n\t}\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat intersect(float time, inout vec3 ray, vec3 dir, inout vec3 nml, inout tSphere sphere, inout float doAA, inout float pick)\n{\n\tfloat dist = 5000.0;\n\n\tsphere.radius = doAA = -2.0;\n\tsphere.center = ray+dist*dir;\n\tnml = -dir;\n\tpick = -1.0;\n\n\tfloat b,k,d;\n\tfloat aaBorder = 1.15;\n\n\tfloat l=0.0,m=0.0,n=0.0;\n\tfloat tl = l+time;\n\tvec3 mContrib = vec3(0.0, 0.0, 0.0);\n\t\n\tfor (float n=0.0; n<N_COUNT; n++) {\n\t\tfloat r = min(n, 1.0)*10.0;\n\t\tfloat tn = time + (n*6.28/9.0);\n\t\tvec3 nContrib = mContrib + (vec3(sin(tn), -cos(tn), -cos(tn))*r);\n\t\tif (rayBV(ray, dir, nContrib, 14.0, dist)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdoAA = max(doAA, -0.5);\n\n\t\tfor (float i=0.0; i<I_COUNT; i++) {\n\t\t\tfloat ikOff = sin(time+i)*5.0;\n\t\t\tfloat sikOff = cos(time+i)*5.0;\n\t\t\tvec3 iContrib = nContrib + vec3(ikOff, sikOff, ikOff);\n\t\t\tif (rayBV(ray, dir, iContrib, 7.0, dist)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdoAA = max(doAA, -0.3);\n\t\t\tfor (float j=0.0; j<J_COUNT; j++) {\n\t\t\t\tfloat kOff = + cos(time*5.0+j)*2.5;\n\t\t\t\tfloat skOff = - sin(time*5.0+j)*2.5;\n\t\t\t\tk = l*(M_COUNT*N_COUNT*I_COUNT*J_COUNT) + m*(N_COUNT*I_COUNT*J_COUNT) + n*(I_COUNT*J_COUNT) + i*J_COUNT + j;\n\t\t\t\tr = 0.8+0.5*cos(k);\n\t\t\t\tvec3 cen = iContrib + vec3(kOff, skOff, kOff);\n\t\n\t#ifdef SAILS\n\t\t\t\t// Do sails first since they're occluded by the sphere.\t\t\t\t\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sail intersect\n\t\t\t\tif (!rayBV(ray, dir, cen, r*2.5, dist) && rayBV(ray, dir, cen, r*1.25, dist)) {\n\t\t\t\t\tfloat a = 8.0*time*(1.0+i+j)+k+j*i;\n\t\t\t\t\tvec3 px = vec3(sin(a), cos(a), 0.0);\n\t\t\t\t\tvec3 py = vec3(cos(a), -sin(a), 0.0);\n\t\t\t\t\tvec3 pz = vec3(0.0, 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\tvec3 p1 = cen - py*5.25*r - px*3.2*r;\n\t\t\t\t\tvec3 p2 = cen + py*5.25*r - px*3.2*r;\n\t\t\t\t\tvec3 p3 = cen + py*0.0*r + px*0.7*r;\n\t\t\t\t\tvec2 uv;\n\t\t\t\t\tfloat t = rayIntersectsTriangle(ray, dir, p2, p3, p1, uv);\n\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\tsphere.radius = 100.0;\n\t\t\t\t\t\tnml = pz;\n\t\t\t\t\t\tif(dot(nml, dir) < 0.0) {\n\t\t\t\t\t\t\tnml = -nml;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.center = p1;\n\t\t\t\t\t\tsphere.color = vec3(0.5, 0.1, 0.05);\n\t\t\t\t\t\tsphere.spec = 8.0;\n\t\t\t\t\t\tpick = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t#endif\n\t\n\t\t\t\td = raySphereDet(ray, dir, cen, r*aaBorder, dist, b);\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sphere intersect\n\t\t\t\tif (d > 0.0 && -b - sqrt(d) > -r*aaBorder) {\n\t\t\t\t\tdoAA = max(doAA, 0.0);\n\t\t\t\t\t// d = b*b - dot(rc,rc) + (r*r)*(aaBorder*aaBorder)\n\t\t\t\t\t// eliminate aaBorder^2 by\n\t\t\t\t\t// d_r = b^2 - rc^2 + r^2 * aaBorder^2 - r^2 * aaBorder^2 + r^2\n\t\t\t\t\t//     = b^2 - rc^2 + r^2\n\t\t\t\t\t// rewrite -r^2 * aaBorder^2 + r^2 = -r^2 * (aaBorder^2 - 1)\n\t\t\t\t\td = d - (r*r)*(aaBorder*aaBorder - 1.0);\n\t\t\t\t\tif (d > 0.0) {\n\t\t\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\t\tsphere.radius = r;\n\t\t\t\t\t\t\tsphere.center = cen;\n\t\t\t\t\t\t\tnml = normalize(sphere.center - ray - dist*dir);\n\t\t\t\t\t\t\tfloat odd = mod(n+j, 2.0);\n\t\t\t\t\t\t\tfloat ay = abs(nml.y);\n\t\t\t\t\t\t\tfloat fy = float(ay < 0.05 || (ay > 0.75 && ay < 0.78));\n\t\t\t\t\t\t\tsphere.color = mix(vec3(0.1), mix(vec3(0.95, 0.8, 0.7), vec3(0.2), fy), odd);\n\t\t\t\t\t\t\t// Switch off AA for points inside the sphere\n\t\t\t\t\t\t\tsphere.spec = mix(64.0, 8.0, odd);\n\t\t\t\t\t\t\tpick = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (sphere.radius > 0.0 && sphere.radius < 100.0) {\n\t\tdoAA = mix(doAA, -0.1, float(dot(nml, dir) > 0.4));\n\t}\n\n\tray += dist*dir;\n\treturn dist;\n}\n\nfloat pickIntersect(float time, vec3 ray, vec3 dir)\n{\n\ttSphere sphere;\n\tvec3 nml;\n\tfloat doAA, pick;\n\tfloat t = intersect(time, ray, dir, nml, sphere, doAA, pick);\n\treturn pick;\n}\n\n\n\n\nvec3 shadeBg(vec3 dir, vec3 nml)\n{\n\n    vec3 lightPos_ = vec3(\n        -cos(iTime*0.1)*-8.5, \n        3.5+sin(iTime*0.05)*3.0, \n        -(sin(iTime*0.1)*4.0-5.4)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec3 shade(vec3 ray, vec3 dir, vec3 nml, float dist, tSphere sphere, inout float doAA)\n{\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\tvec3 bgCol = shadeBg(dir, dir);\n\tif (sphere.radius > 0.0) {\n\t\tfloat a = 1.0 - abs(dot(dir, nml));\n\t\tif (sphere.spec < 0.0) {\n\t\t\tcol += a * vec3(2.5, 1.6, 1.3);\n\t\t}\n\t\t\n\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\tfog *= fog;\n\t\tcol = (1.0-fog)*col + fog*bgCol;\n\t} else {\n\t\tcol = bgCol;\n\t}\n\n\treturn col;\n}\n\n#ifdef OCULUS\nvec2 hmdWarp(vec2 texIn) {\n\tvec2 u_lensCenter = vec2(0.0, 0.0);\n\tvec2 u_scaleIn = vec2(0.45, 0.7);\n\tvec2 u_scale = vec2(0.7);\n\tvec4 u_hmdWarpParam = vec4(0.7);\n\tvec2 u_screenCenter = vec2(0.0);\n\tif (texIn.x > 0.0) {\n\t\tu_lensCenter = vec2(-0.05, 0.0);\n\t\ttexIn.x = (0.85 - texIn.x);\n\t} else {\n\t\tu_lensCenter = vec2(0.05, 0.0);\n\t\ttexIn.x = (-0.85 - texIn.x);\n\t}\n\tvec2 theta = (texIn - u_lensCenter) * u_scaleIn;\n\tfloat rSq = theta.x * theta.x + theta.y * theta.y;\n\tvec2 theta1 = theta * (u_hmdWarpParam.x + u_hmdWarpParam.y * rSq + \n\t\tu_hmdWarpParam.z * rSq * rSq + u_hmdWarpParam.w * rSq * rSq * rSq);\n\treturn u_lensCenter + u_scale * theta1;\n}\n#endif\n\nvec3 getDir(vec2 fragCoord)\n{\n\tvec2 pixelAspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 pixelRatio = vec2(2.0) / iResolution.xy;\n\tvec2 uv = (fragCoord*pixelRatio - 1.0)*pixelAspect;\n\n#ifdef OCULUS\t\n\tvec2 tc = hmdWarp(uv);\n\tuv = tc;\n\tuv.x *= iResolution.x / iResolution.y;\n#endif\n\t\n\tvec3 dir = vec3(uv, 1.0);\n\tdir.xy = rotate(dir.xy, cos(iTime*0.1));\n\tdir.xz = rotate(dir.xz, sin(iTime*0.15));\n\treturn normalize(dir);\n}\n\nvec3 doReflections(vec2 fragCoord, float time, vec3 oray, vec3 dir, vec3 onml, tSphere oSphere, float odist, float picked)\n{\n\tvec3 ncol = vec3(0.0);\n\tvec3 xvec = normalize(cross(onml, vec3(1.0, 0.0, 0.0)));\n\tvec3 yvec = normalize(cross(onml, vec3(0.0, 1.0, 0.0)));\n\tfloat doAA_, target, k=0.0;\n\t//for (float ix=0.0; ix<3.0; ix++) \n\t//{\n\t\tfloat ix = 0.0;\n\t\tk++;\n\t\tfloat xx = floor(ix / 2.0);\n\t\tfloat yy = ix-(xx*2.0);\n\t\tvec4 tex = texture(iChannel0, mod(fragCoord.xy*2.0+vec2(xx,yy), 256.0)/256.0);\n\t\tvec3 nml = onml;\n\t\tvec3 ray = oray;\n\t\tvec3 diff = oSphere.color;\n\t\tfloat dist = odist;\n\t\ttSphere sphere = oSphere;\n\t\tvec3 v = normalize(pow(tex.rgb, vec3(2.0)));\n\t\tvec3 ref = reflect(dir, normalize(nml + v*(2.0/sphere.spec)) );\n\n\t\t// reflection\n#ifdef REFLECTION\n\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\tfog *= fog;\n\t\tdist = intersect(time, ray, ref, nml, sphere, doAA_, target);\n\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\tncol += (1.0-fog)*diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\tfog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\tfog *= fog;\n\t\t// second reflection\n#endif\n\t\t//if (oSphere.radius / odist < 1.0) {\n\t\t//\tbreak;\n\t\t//}\n#ifdef SECOND_BOUNCE\n\t\tif (sphere.radius > 0.0) {\n\t\t\tdiff *= sphere.color;\n\t\t\tref = reflect(ref, nml);\n\t\t\tdist = intersect(time, ray, ref, nml, sphere, doAA_, target);\n\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\tncol += (1.0-fog)*diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\t}\n#endif\n\t//}\n\treturn ncol / k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat xOff = 0.0;\n#ifdef OCULUS\n\txOff = 1.0;\n\tif (fragCoord.x < iResolution.x*0.5) xOff = -1.0;\n#endif\n\n\tvec3 eye = vec3(-xOff*0.5, -0.0, -30.0);\n\n\tvec3 mdir;\n\tmdir = getDir(iMouse.zw);\n\t\n\tvec3 nml = vec3(0.0);\t\t\n\tvec3 col = vec3(0.0);\n\t\n\ttSphere sphere;\n\tfloat doAA, doAA_;\n\t\n\tfloat shutterSpeed = 1.0 / 30.0;\n\tfloat iso = 100.0;\n\tfloat exposureCompensation = +1.0;\n\t\n\t// Auto ISO\n\tiso = 1.0 / shutterSpeed;\n\t\n\tfloat picked = -2.0;\n\tfloat k = 0.0;\n\tconst float mblur_sample_count = MBLUR_SAMPLES;\n\tfloat box_size = ceil(sqrt(MBLUR_SAMPLES));\n\tfor (float dt = 0.0; dt < mblur_sample_count; dt++) {\n\t\tk++;\n\t\tfloat tx = floor(dt/box_size);\n\t\tfloat ty = dt - tx*box_size;\n\t\tvec4 tex = texture(iChannel0, mod(fragCoord.xy*box_size+vec2(tx,ty), 256.0)/256.0);\n\t\tfloat time = (iTime + (tex.r*2.0-dt/mblur_sample_count)*shutterSpeed) + 450.0 ;\n\n\t\tfloat i = 0.0;\n\t\tvec3 ray = eye;\n\t\tfloat x = floor(0.5*i);\n\t\tfloat y = 1.0-x;\n\t\tvec3 dir = getDir(fragCoord.xy+(vec2(x,y)*0.5));\n\n\t\tfloat target = -1.0;\n\t\tfloat dist = intersect(time, ray, dir, nml, sphere, doAA, target);\n\n\t\tif (picked == -2.0 && target >= 0.0 && iMouse.z > 1.0) { \n\t\t\tpicked = pickIntersect(time, eye, mdir);\n\t\t}\n\t\t\n\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\tcol += shade(ray, dir, nml, dist, sphere, doAA_);\n\n\t\tif ( sphere.radius > 0.0 )\n\t\t{\n\t\t\tcol += doReflections(fragCoord, time, ray, dir, nml, sphere, dist, picked);\n\t\t}\n\t\tif (doAA == -2.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tcol = 1.0 - exp((-col/k) * iso * shutterSpeed * pow(2.0, exposureCompensation));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sS3zw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSSWw", "name": "objblend", "author": "rickiters", "description": "smooth blending between objects", "tags": ["raymarchblend"], "likes": 2, "viewed": 127, "date": "1412396074", "time_retrieved": "2024-06-20T18:13:28.098105", "image_code": "//// input\n// keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\nconst int kRed = k1;\nconst int kGreen = k2;\nconst int kBlue = k3;\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen coords to -asp to +asp for x, -1 to +1 for y, asp = aspect ratio\n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    vec2 loct = loc.xz * vec2(.1,-.1);\n    float lodBias = -.2;\n    vec3 ret3 = texture(iChannel2,loct,lodBias).xyz;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.g += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return skyplanecolor;\n}\n\n\n//// raymarch\nvec3 sceneCol;\n\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\n// CSG union like, blend d1 B d2\nfloat opUBlend(float d1,float d2,float k)\n{\n\tfloat h = clamp(.5 + .5*(d2 - d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.0-h);\n    //return d2;\n    //return min(d1,d2);\n}\n        \nfloat scene1(vec3 pr)\n{\n    //vec3 pr = p;\n    //pr.x += 4.0;\n    vec3 off = vec3(.5+4.0*sin(iTime*.25),0.,0.);\n    float d3 = sdSphere(pr+off,1.0); // p or pr, it's a sphere\n//    sceneCol = fract((pr+off)*8.0);\n    sceneCol = fract(pr*8.0);\n    pr.xy *= rot(iTime*.5);\n    pr.xz *= rot(iTime*.25);\n    //sceneCol = fract(pr*8.0);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    //float d1 = sdBox(pr,vec3(.25,.5,.75));\n\n    pr.xy *= rot(1.57);\n\tfloat d2 = sdCappedCylinder(pr,vec2(.50,12));\n    //float d3 = sdTorus(pr,vec2(1.0,.25));\n    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));\n    //return opU(d1,d2);\n    //return opI(d1,d2);\n    float dHolebox = opS(d1,d2);\n    //return opU(dHolebox,d3);\n    return opUBlend(dHolebox,d3,.4);\n    //return opS(d2,d1);\n    //return d1;\n    //return d2;\n    //return d3;\n    //return d4;\n    //return dHolebox;\n}\n\nfloat opRep_scene1(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return scene1(q);\n}\n\nfloat opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat scene2(vec3 p)\n{\n\treturn opRep_scene1(p,vec3(10.0));\n}\n\nfloat scene3(vec3 p)\n{\n\treturn opRepLimit_scene1(p,vec3(10.0),vec3(2.0,3.0,4.0));\n}\n\nfloat scene4(vec3 p)\n{\n\tfloat rs1 = opRepLimitCenter_scene1(p,vec3(10.0),vec3(9.0));\n    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));\n    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));\n    //return opU(rs1,pn);\n    return rs1;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat d = scene1(p);\n    //float d = scene2(p);\n    //float d = scene3(p);\n    //float d = scene4(p);\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = .001;\n    float d0x = scene(vec3(p.x - eps,p.yz));\n    float d1x = scene(vec3(p.x + eps,p.yz));\n    float d0y = scene(vec3(p.x,p.y - eps,p.z));\n    float d1y = scene(vec3(p.x,p.y + eps,p.z));\n    float d0z = scene(vec3(p.xy,p.z - eps));\n    float d1z = scene(vec3(p.xy,p.z + eps));\n    //return vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(.5/eps);\n    //return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(2.5/eps));\n    return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z));\n    //return vec3(1.0,0.0,0.0);\n}\n    \n//const vec3 background  = vec3(0.0, 0.0, 0.2);\nconst vec3 light_1     = vec3(4.0, 8.0,  3.0);\nconst vec3 light_2     = vec3(-4.0, 8.0, -7.0);\n//const vec2 eps         = vec2(0.001, 0.0);\n//const int maxSteps     = 64;\n\n#define time iTime\n\nvec3 shade(vec3 color, vec3 point, vec3 normal,vec3 rd)\n{\n\t\n\tvec3 dtl       = normalize(light_1 - point);\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\tdtl      =  normalize(light_2 - point);\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\nvec3 getTex(vec3 p)\n{\n\tp = fract(p);\n    //p.xy *= rot(iTime*.5);\n    //p.xz *= rot(iTime*.25);\n    return p;\n    //return vec3(1.0);\n}\n    \n// very simple ambient occlusion\nfloat getAO(vec3 rs,vec3 rd)\n{\n    // move away along the normal\n    float d = .3;\n    float k = 1.0;\n    float ret = 1.0;\n    for (int i = 1;i<5;++i) {\n        float fi = float(i);\n        k *= .5;\n        float distBack = scene(rs + rd*(d*fi));\n        ret -= k*(fi*d - distBack);\n    }\n    return ret;\n    //return 1.0;\n    //return distBack/k;\n    //return k/distBack;\n}\n\nvec3 march(vec3 rs,vec3 rd,out bool hit)\n{\n    const float conserve = .87; // compensate for errors in distance function esp. rotate box repeat\n    const int steps = 180;\n    float eps = .001;\n    float toobig = 1000.0;\n\tvec3 col = vec3(0.0,0.0,0.0);\n    hit = false;\n    for (int i=0;i<steps;++i) {\n        float d = scene(rs);\n        if (d > toobig) { // bail early if clearly can't hit anything\n            hit = false;\n            break;\n        }\n        if (d < eps) {\n            if (rs.y >= 0.0) { // hit above ground\n                //col += getTex(rs); // normal color\n                //col += getNormal(rs)*.5 + vec3(.5); // normal color\n    \t\t\t//col += float(i)*(10.0/256.0); // brighter if more iterations\n                \n                \n                vec3 norm = getNormal(rs);\n \t\t\t\t// normal color, very simple lighting .5 ambient, .5 directional\n \t\t\t\t// normal in opposite direction of light gets the light\n                //col += norm*.5 + vec3(.5); // normal color\n                //col += max(-norm.x,0.0)*.5+.5; // dir +1x\n                //col += max(norm.y,0.0)*.5+.5; // dir -1y\n                //col += max(-norm.z,0.0)*.5+.5; // dir +1z\n                col += shade(vec3(1.),rs,norm,rd)*.95;\n                //col += -norm.z; // dir +1z, no ambient all directional\n                \n                col += sceneCol*.05;\n                //col += getTex(rs)*.25; // texture color\n                //col += norm*.5 + vec3(.5); // normal color 0 to 1\n                //col += norm; // raw normal color -1 to 1\n    \t\t\t//col += float(i)*(10.0/256.0); // brighter if more iterations\n                float ao = getAO(rs,norm);\n                col *= ao;\n                hit = true;\n            }\n            break;\n        }\n        rs += rd*d*conserve; // compensate for the slight error from rotating boxes distance modulo function\n    }\n\n    return col;\n}\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy);\n    vec2 mouse;// = vec2(0.0,0.0);\n    \n    if (iMouse.x == 0.0) // hack for mouse not yet clicked\n        mouse = vec2(0.0,0.0);\n    else\n    \tmouse = ndc(iMouse.xy);\n    \n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0;\n    // make a ray, left handed coords\n    vec3 rs; // ray start\n    vec3 rd = vec3(pos,1.0); // ray direction to the pixel\n    vec3 nrd;\n    vec3 rc = vec3(0.0,0.0,1.0); // ray direction from center of camera\n    // zoom factor\n    rd.xy /= zoom;\n    vec3 cd = vec3(0.0,0.0,1.0); // camera direction (center, look at)\n    if (movexy) { // mouse move camera in xy, always facing forward\n\t    rs = vec3(0.0,6.0,-5.0) + vec3(mouse*5.99,0.0); // ray start\n        nrd = normalize(rd);\n    } else { // mouse rotates camera 2 different ways\n\t    rs = vec3(0.0,.4,0.0); // ray start\n        rd.yz *= rot(mouse.y*3.14 ); // pitch\n        rc.yz *= rot(mouse.y*3.14 ); // pitch\n        if (roll) {\n            rd.xy *= rot(mouse.x*3.14 ); // roll\n            rc.xy *= rot(mouse.x*3.14 ); // roll\n        } else {\n            rd.xz *= rot(mouse.x*3.14 ); // yaw\n            rc.xz *= rot(mouse.x*3.14 ); // yaw\n        }\n        nrd = normalize(rd); // normalized for the marching, unnormalized for the sky gradient\n        rs += rc * -4.0;\n    }\n    \n\n    \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float rad = 1.0/30.0;\n    bool iscursor = d2<rad*rad;\n    \n    // sky plane color\n    //rs -= nrd * 2.3;\n    //rs.z += nrd.z;\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n   \n    // march color\n    bool hit; // did hit something\n    vec3 marchcol = march(rs,nrd,hit);\n    \n    \n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else if (hit)\n\t\tcomp = marchcol;\n\telse\n        comp = skyplanecolor;\n\tfragColor = vec4(comp,1.0);\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSSWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sSSzG", "name": "Microscopic Bouncing Triangles", "author": "fizzer", "description": "This is an old shader I made back in 2012. I think it looks nice enough for a small Shadertoy. It's also the shader that I used to make my profile picture back when I joined.", "tags": ["triangles", "blur", "defocus"], "likes": 42, "viewed": 2486, "date": "1412981268", "time_retrieved": "2024-06-20T18:13:28.098105", "image_code": "float time;\n\nfloat smoothTri(vec2 p, vec2 p0, vec2 p1, vec2 p2, float smoothness)\n{\n    vec3 e0, e1, e2;\n\n    e0.xy = normalize(p1 - p0).yx * vec2(+1.0, -1.0);\n    e1.xy = normalize(p2 - p1).yx * vec2(+1.0, -1.0);\n    e2.xy = normalize(p0 - p2).yx * vec2(+1.0, -1.0);\n\n    e0.z = dot(e0.xy, p0) - smoothness;\n    e1.z = dot(e1.xy, p1) - smoothness;\n    e2.z = dot(e2.xy, p2) - smoothness;\n\n    float a = max(0.0, dot(e0.xy, p) - e0.z);\n    float b = max(0.0, dot(e1.xy, p) - e1.z);\n    float c = max(0.0, dot(e2.xy, p) - e2.z);\n\n    return smoothstep(smoothness * 2.0, 1e-7, length(vec3(a, b, c)));\n}\n\nfloat layer(vec2 p, float smoothness, float index)\n{\n    float a = 0.0;\n    for(int i = 0; i < 8; i += 1)\n    {\n        float u0 = (float(i + 0) / 8.0 * 2.0 - 1.0) * 3.0;\n        float u1 = (float(i + 1) / 8.0 * 2.0 - 1.0) * 3.0;\n\n        float y = 0.0 + abs(cos(u0 * 130.0 + index)) * 0.9;\n\n        vec2 o = vec2(index * 0.1 - 4.0, abs(cos(time * 3.0 + index + u0)));\n\n        vec2 p0 = vec2(u0, 0.0) + o;\n        vec2 p1 = vec2(u1, 0.0) + o;\n        vec2 p2 = vec2((u0 + u1) * 0.5, y) + o;\n\n        a += smoothTri(p, p0, p1, p2, smoothness);\n    }\n    return a;\n}\n\nfloat vignet(vec2 t)\n{\n    return max(0.0,1.0 - (t.x * t.x * t.x * t.x + t.y * t.y * t.y * t.y));\n}\n\nfloat vignet2(vec2 t)\n{\n    return max(0.0,t.x * t.x + t.y * t.y);\n}\n\nvec3 scene(vec2 p)\n{\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 5; i += 1)\n    {\n        float z = float(5 - i);\n        float z2 = abs((float(5 - i)) - 0.0) * 2.0;\n        float c = (10.0 - z2) * 0.15;\n        float f = z2 * z2 * 0.002 * (1.0 + vignet2(p) * 10.0) * 0.5;\n        float index = float(i) * 16.0;\n        vec2 o = vec2(cos(time), 0.7);\n        float a0 = clamp(layer(p * z + o, f, index), 0.0, 1.0);\n        float a1 = clamp(layer(p * z + o, f * 30.0, index), 0.0, 1.0);\n\n        vec3 cc = vec3(0.1, 0.4, 1.0);\n\n        col = mix(col, vec3(c) * cc, a0) + mix(col, vec3(c) * cc, a1) * 0.2;\n    }\n    return col;\n}\n\nfloat jitter()\n{\n    return fract(gl_FragCoord.x * 0.1943244 + gl_FragCoord.y * 0.525634);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = vec3(0.0);\n    float j = jitter();\n    vec2 p = (fragCoord.xy / iResolution.xy - vec2(0.5)) * 2.6;\n    p.y *= iResolution.y / iResolution.x;\n    for(int i = 0; i < 2; i += 1)\n    {\n        time = iTime + (float(i) + j) / 40.0;\n        fragColor.rgb += scene(p);\n    }\n    fragColor.rgb = sqrt(fragColor.rgb * 0.5 * vignet(p)) + jitter() / 255.0;\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSSzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ssXRl", "name": "Flag: Greece", "author": "4rknova", "description": "Flag of Greece. (1978 to date)", "tags": ["flag", "greece"], "likes": 3, "viewed": 812, "date": "1413723008", "time_retrieved": "2024-06-20T18:13:28.104188", "image_code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS .001\n\n#define SUPERSAMPLING 4.\n#define ANIMATE\n\n#define FLAG_GR_PROP      3./2.\n#define FLAG_GR_COL_BLUE  vec3(.14117647058, .25098039215, .94901960784)\n#define FLAG_GR_COL_WHITE vec3(1)\n#define FLAG_GR_LINES     9.\n#define FLAG_GR_CROSS_X   2./5. * FLAG_GR_PROP\n#define FLAG_GR_CROSS_Y   4./9.\n\nvec3 flag_gr(in vec2 p) {\n    if (p.x > FLAG_GR_PROP || p.x < 0. ||\n        p.y > 1. || p.y <0.) return vec3(0.);\n    \n    float st = floor(FLAG_GR_LINES * p.y);\n    vec3 c = FLAG_GR_COL_BLUE;\n\t\n    // Cross\n    if (p.x < FLAG_GR_CROSS_X && p.y > FLAG_GR_CROSS_Y)\n    {\n        if (st == 6. ||\n           length(p.x - FLAG_GR_CROSS_X / 2.) < (1. / FLAG_GR_LINES * .5)\n        ) c = FLAG_GR_COL_WHITE;\n    }\n    // Stripes\n    else if (mod(st, 2.) > 0.) c = FLAG_GR_COL_WHITE;\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x/iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * vec2(ar, 1);\n    \n    float zoom = 1.4;\n    vec2  pos  = vec2(.5,.25);\n    \n    uv = uv * zoom - pos; // Position the flag\n    vec2 pv = uv;\n\n#ifdef ANIMATE // Wave animation    \n    vec2 cv = uv;    \n\tpv.y = uv.y + (.3 + cv.x) * pow(sin(cv.x * 6. - iTime * 6.0), 2.) * .032;\n    pv.x = uv.x + cv.y * cos(cv.x - cv.y * 2. - iTime * .5) * .05;\n#endif\n    \n    vec3 col = vec3(0);\n\n#ifdef SUPERSAMPLING\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x) / zoom;\n    for (float i = -SUPERSAMPLING; i < SUPERSAMPLING; ++i) {\n        for (float j = -SUPERSAMPLING; j < SUPERSAMPLING; ++j) {\n    \t\tcol += flag_gr(pv + vec2(i, j) * (e/SUPERSAMPLING)) \n                / (4.*SUPERSAMPLING*SUPERSAMPLING);\n        }\n    }\n#else\n     col = flag_gr(pv);\n#endif\n    \n    float s = 1.;\n    \n#ifdef ANIMATE\n    s = pow(dot(normalize(vec3(pv - uv, 1)), normalize(vec3(0, 25, 4))), .4);\n#endif\n    \n\tfragColor = vec4(col * s, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssXRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2SzK", "name": "Alien Beacon", "author": "otaviogood", "description": "Our investigation of the signal from the planet's surface brought us to what seems to be an alien beacon. Based on the rock formation around the beacon, it was probably left here millions of years ago.", "tags": ["procedural", "noise", "terrain"], "likes": 63, "viewed": 3579, "date": "1414387470", "time_retrieved": "2024-06-20T18:13:30.413463", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    float t2 = t*t;\n    float t3 = t*t*t;\n    return 0.5 *((2.0 * p1) +\n                 (-p0 + p2) * t +\n    \t\t\t (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n    \t\t\t (-p0 + 3.0 * p1- 3.0 * p2 + p3) * t3);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    t = mod(t, 14.0);\t// repeat after 14 time units\n    float bigTime = floor(t);\n    float smallTime = fract(t);\n    // Can't do arrays right, so write this all out.\n    if (bigTime == 0.0) return CatmullRom(c00, c01, c02, c03, smallTime);\n    if (bigTime == 1.0) return CatmullRom(c01, c02, c03, c04, smallTime);\n    if (bigTime == 2.0) return CatmullRom(c02, c03, c04, c05, smallTime);\n    if (bigTime == 3.0) return CatmullRom(c03, c04, c05, c06, smallTime);\n    if (bigTime == 4.0) return CatmullRom(c04, c05, c06, c07, smallTime);\n    if (bigTime == 5.0) return CatmullRom(c05, c06, c07, c08, smallTime);\n    if (bigTime == 6.0) return CatmullRom(c06, c07, c08, c09, smallTime);\n\n    if (bigTime == 7.0) return CatmullRom(c07, c08, c09, c10, smallTime);\n    if (bigTime == 8.0) return CatmullRom(c08, c09, c10, c11, smallTime);\n    if (bigTime == 9.0) return CatmullRom(c09, c10, c11, c12, smallTime);\n    if (bigTime == 10.0) return CatmullRom(c10, c11, c12, c13, smallTime);\n    if (bigTime == 11.0) return CatmullRom(c11, c12, c13, c00, smallTime);\n    if (bigTime == 12.0) return CatmullRom(c12, c13, c00, c01, smallTime);\n    if (bigTime == 13.0) return CatmullRom(c13, c00, c01, c02, smallTime);\n    return vec4(0.0);\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2SzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2XDm", "name": "Integral", "author": "okro", "description": "Waves", "tags": ["wave", "sin"], "likes": 2, "viewed": 152, "date": "1412917785", "time_retrieved": "2024-06-20T18:13:30.413463", "image_code": "\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv / 3.;\n    p.x *= iResolution.x / iResolution.y;\n    p.y -= .2;\n    vec3 blue = vec3(.4, .5, 1.0);\n\n \n    vec3 col = vec3(1.);\n    \n    float old = p.x * 200.;\n    p.x *= 200.;\n    p.x = float(int(p.x));\n\n    float y = cos(p.x/10.+time)/10.;\n    \n    if (p.y  <= y) {\n        col = blue;\n        col = vec3(1.0-smoothstep(0., .4, abs(p.x - old)));\n    }\n    \n    col.b = 1.0;\n    col.g = .7;\n    \n  \n    col *= smoothstep(-.4, .12, p.y);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2XDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld2XzV", "name": "Lighting room", "author": "caosdoar", "description": "Reference:\nhttp://www.slate.com/blogs/the_eye/2014/10/17/intersections_art_installation_by_anila_quayyum_agha_uses_laser_cut_wood.html", "tags": ["3d", "lighting", "shadows", "distance", "alahambra"], "likes": 15, "viewed": 703, "date": "1414096878", "time_retrieved": "2024-06-20T18:13:31.940906", "image_code": "// caosdoar@gmail.com 2014\n\n// Some defines to control the mouse inputs\n#define MOUSE_INPUT 0\n#define MOUSE_INPUT_MODE 0\n\n// Anti-aliased step from Stefan Gustavson\nfloat aastep(float threshold, float value) \n{\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n   \n// The inverted box for the room\nfloat room(vec3 p)\n{\n    vec3 d = abs(p) - vec3(10.0, 3.5, 10.0);\n    return -max(d.x, max(d.y, d.z));\n}\n\nfloat mapTerrain(vec3 p)\n{\n    return room(p);\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n\tfloat maxd = 30.0;\n    float h = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( h<(0.001*t)||t>maxd ) break;\n\t    h = mapTerrain( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\n// An approximation to calculate regular polygons\nfloat poly(vec2 p, vec2 c, float l, float r)\n{\n    vec2 v = p - c;\n    float v_l = length(v);\n    vec2 n = v / v_l;\n    float a = acos(dot(n, vec2(1.0, 0.0)));\n    float pi_l = 3.14159265/l;\n    a = mod(a, 2.0*pi_l);\n    a = abs(a - pi_l);\n    float d = cos(pi_l);\n    return v_l - r * (d / cos(a));\n}\n\nfloat polylines(vec2 p, vec2 c, float l)\n{\n    vec2 v = p - c;\n    float v_l = length(v);\n    vec2 n = v / v_l;\n    float a = acos(dot(n, vec2(1.0, 0.0))) + 3.14159265 / l;\n    float line_angle = floor(a * l / 6.283185) * 6.283185 / l;\n    vec2 line_dir = normalize(vec2(cos(line_angle), sin(line_angle)));\n    return length((-v)-dot(-v,line_dir)*line_dir);\n}\n\n// A fancy circle\nfloat circle_curves(vec2 p, float r, float l)\n{\n    vec2 n = normalize(p);\n    float a = acos(dot(n, vec2(1.0, 0.0)));\n    float pi_l = 3.14159265/l;\n    a = mod(a, 2.0*pi_l);\n    a = abs(a - pi_l);\n    float s = a/pi_l;\n    s *= s;\n    return length(p) - (r - 0.01*r*s);\n}\n\n// Just a square\nfloat square(vec2 p, float lh)\n{\n    vec2 d = abs(p) - lh;\n    return max(d.x, d.y);\n}\n\nvec2 rotate_point(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\n// WIP test for the middle pattern\nfloat alahambra_pattern(vec2 p)\n{\n    /*p *= 1.5;\n    \n    float a = poly(p, vec2(0.0), 8.0, 0.3);\n    float b = poly(p, vec2(0.3, 0.3), 8.0, 0.3);\n    float c = poly(p, vec2(-0.3, 0.3), 8.0, 0.3);\n    float d = poly(p, vec2(0.3, -0.3), 8.0, 0.3);\n    float e = poly(p, vec2(-0.3, -0.3), 8.0, 0.3);\n    float f = poly(p, vec2(0.3, 0.0), 8.0, 0.3);\n    float g = poly(p, vec2(-0.3, 0.0), 8.0, 0.3);\n    float h = poly(p, vec2(0.0, 0.3), 8.0, 0.3);\n    float i = poly(p, vec2(0.0, -0.3), 8.0, 0.3);\n    \n    float lines = \n        min(abs(a), \n        min(abs(b), \n        min(abs(c), \n        min(abs(d), \n        min(abs(e),\n        min(abs(f),\n        min(abs(g),\n        min(abs(h),\n        abs(i)))))))));\n   \tlines = min(1.0, lines * 100.0);\n    return lines;*/\n   \n    float a = poly(p, vec2(0.0), 12.0, 0.1);\n    \n    float b = poly(p, vec2(0.0), 6.0, 0.15);\n    float b1 = poly(p, vec2(0.225, 0.13), 6.0, 0.15);\n    float b2 = poly(p, vec2(-0.225, 0.13), 6.0, 0.15);\n    float b3 = poly(p, vec2(0.225, -0.13), 6.0, 0.15);\n    float b4 = poly(p, vec2(-0.225, -0.13), 6.0, 0.15);\n    float b5 = poly(p, vec2(0.0, 0.26), 6.0, 0.15);\n    float b6 = poly(p, vec2(0.0, -0.26), 6.0, 0.15);\n    \n    float c = polylines(p, vec2(0.0), 12.0);\n    //float lines = min(abs(a), abs(b) * (c) );\n    \n    float s0 = square(rotate_point(p, 3.14159/12.0), 0.085);\n    float s1 = square(rotate_point(p, 3.14159*5.0/12.0), 0.085);\n    float s2 = square(rotate_point(p, 3.14159*9.0/12.0), 0.085);\n    \n    float lines = abs(abs(b) - 0.01) * 300.0;\n    lines = min(lines, abs(abs(b1) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b2) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b3) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b4) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b5) - 0.01) * 300.0);\n    lines = min(lines, abs(abs(b6) - 0.01) * 300.0);\n    \n    lines = min(lines, abs(s0) * 300.0);    \n    lines = min(lines, abs(s1) * 300.0);    \n    lines = min(lines, abs(s2) * 300.0);\n    \n    return lines;\n    //return min(1.0, lines * 100.0);\n}\n\n// One of the faces of the shadow box\nfloat shadowPlane(vec2 p)\n{\n    //return aastep(0.5, alahambra_pattern(p));\n    \n    vec2 p_abs = abs(p);\n    float p_abs_min = min(p_abs.x, p_abs.y);\n    float d = length(p);\n    \n    float c0 = min(1.0, abs(d - 0.35) * 80.0);\n    float c1 = min(1.0, abs(d - 0.48) * 80.0);\n    float c2 = min(1.0, abs(circle_curves(p, 0.55, 40.0)) * 120.0);\n    float c3 = min(1.0, abs(circle_curves(p, 0.59, 40.0)) * 80.0);\n    float s0 = min(1.0, abs(square(p, 0.595)) * 90.0);\n    float s1 = min(1.0, abs(square(p, 0.8)) * 90.0);\n    float s2 = min(1.0, abs(square(p, 1.0)) * 10.0);\n    /*s2 *= s2;\n    s2 *= s2;*/\n    \n    float lines = min(c0, min(c1, min(c2, min(c3, min(s0, min(s1, s2))))));\n    \n    \n    vec2 p45 = vec2(p.x-p.y,p.x+p.y) * 0.7071;\n    \n    float g0 = min(1.0, abs(square(fract(p45 * 40.0) * 2.0 - 1.0, 1.0)) * 2.0);\n    g0 = mix(1.0, g0, step(0.0, square(p, 0.8)));\n    float g1 = alahambra_pattern(p);\n    g1 = mix(1.0, g1, step(d - 0.35, 0.0));\n    \n    float patterns = min(g0, g1);\n    \n    return aastep(0.5, min(lines, patterns));\n}\n\n// Box in the middle of the room that creates the shadows\nfloat shadowBox(vec3 l)\n{\n    vec2 uv;\n    vec3 labs = abs(l);\n    float lmax = max(labs.x, max(labs.y, labs.z));\n    if (labs.x == lmax) uv = l.yz;\n    if (labs.y == lmax) uv = l.xz;\n    if (labs.z == lmax) uv = l.xy;\n    \n\tuv /= lmax;\n    \n    return shadowPlane(uv);\n    \n    /*uv = floor(uv * 5.0);\n    return mod(uv.x+uv.y, 2.0) * 0.5 + 0.5;\n    return length(uv);*/\n}\n\nfloat mapLamp(vec3 p)\n{\n    float l = 2.0;\n    vec3 d = abs(p) - l;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));\n}\n\nfloat raymarchLamp(vec3 ro, vec3 rd)\n{\n\tfloat maxd = 30.0;\n    float h = 1.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n        if( h<(0.001*t)||t>maxd ) break;\n\t    h = mapLamp( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\n// Simplest lighting possible\nfloat lighting(vec3 p, vec3 n)\n{\n    vec3 l = -normalize(p);\n    float c = dot(n, l);\n    float shadow = shadowBox(-l);\n    c *= shadow;\n    return c;\n}\n\n// Transform from spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s  = sin(p);\n    vec2 c  = cos(p);\n    return normalize(vec3(c.x * s.y, c.y, s.x * s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if MOUSE_INPUT\n    \n#if MOUSE_INPUT_MODE == 0 \n    // Rotate camera around the center\n    vec2 camSphe = vec2(0.0, 1.175) + iMouse.xy / iResolution.xy * vec2(5.0, 0.7);\n    vec3 co = sphe2cart(camSphe) * 9.0;\n    vec3 cd = vec3(0.0, 0.0, 0.0);\n#else\n    // Rotate the camera from the corner\n    vec3 co = vec3(8.5, -2.0, 8.5);\n    vec2 camSphe = vec2(0.0, 1.57) + (vec2(iMouse.x, -iMouse.y) / iResolution.xy - vec2(0.5)) * vec2(3.0, 1.5);\n    vec3 cd = co + sphe2cart(vec2(-2.4, 1.3) + camSphe);\n#endif\n\n#else\n    \n    vec2 camSphe;\n    if (iMouse.z < 1.0)\n    {\n        camSphe = vec2(iTime * 0.1, sin(iTime * 0.2) * 0.2 + 1.5);\n    }\n    else\n    {\n        camSphe = vec2(0.0, 1.175) + iMouse.xy / iResolution.xy * vec2(5.0, 0.7);\n    }\n    \n    vec3 co = sphe2cart(camSphe) * 9.0;\n    vec3 cd = vec3(0.0, 0.0, 0.0);\n    \n#endif\n    \n    // Camera\n    vec3 cf = normalize(cd - co);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    \n    // Raymarch\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0;\n    vec3 rd = normalize(cf + cr * uv.x + cu * uv.y);\n    float a = raymarch(co, rd);\n    vec3 p0 = co + rd * a;\n    vec3 n = calcNormal(p0);\n    \n    // Profit!\n    vec3 colour = lighting(p0, n) * vec3(0.85, 0.75, 0.6);\n    \n    // Raymarch lamp\n    float a1 = raymarchLamp(co, rd);\n    if (a1 > 0.0)\n    {\n    \tvec3 p1 = co + rd * a1;\n        colour = mix(vec3(0.1), colour, shadowBox(p1));\n    }\n    \n\tfragColor = vec4(vec3(colour),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2XzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBSDm", "name": "Blobs and spirals", "author": "toothmang", "description": "A neat generalized form of \"blob eat blob.\" Try modifying NUM_BRANCHES (1, 2, 4, and 8 are good starts).", "tags": ["procedural", "2d", "spiral", "polar"], "likes": 7, "viewed": 238, "date": "1412644346", "time_retrieved": "2024-06-20T18:13:33.171152", "image_code": "#define alpha 0.\n#define beta 10.\n\n#define PI 3.14159\n\n// Thanks to Lance for the insight on making more than 1 spiral branch\n#define NUM_BRANCHES 4.\n\n#define pulse_period 2.5\n#define twist_period (5.)\n#define amplitude 10.\n\nvec4 getCornerColors(vec2 coord)\n{\n    vec2 halfRes = iResolution.xy * 0.5;\n    float totalArea = iResolution.x * iResolution.y;\n    \n    vec3 cornerColors[4];\n\t\n    cornerColors[0] = vec3(1.0, 0.0, 0.0);\n    cornerColors[1] = vec3(0.0, 0.0, 1.0);\n    cornerColors[2] = vec3(0.0, 1.0, 0.0);\n    cornerColors[3] = vec3(1.0, 1.0, 0.0);\n        \n    vec2 cornerCoords[4];\n    \n    cornerCoords[0] = vec2(-1.) * halfRes;\n    cornerCoords[1] = vec2(1., -1.) * halfRes;\n    cornerCoords[2] = vec2(1.) * halfRes;\n    cornerCoords[3] = vec2(-1., 1.) * halfRes;\n    \n\tvec3 result = vec3(0.0);\n        \n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 cCoord = cornerCoords[i] * iResolution.xy;\n\n\t\tvec2 d = cornerCoords[i] - coord;\n        \n        float a = abs(d.x * d.y);\n\n\t\tfloat w = a / totalArea;\n\n\t\tresult += w * cornerColors[i];\n    }\n    \n\treturn vec4(result, 1.0);\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 50.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 0.5)\n\t{\n\t\treturn vec4(vec3(0), 1.0);\n\t}\n\telse\n\t{\n\t\treturn vec4(vec3(remainder), 1.0);\n\t}\n}\n\nvec4 spiral5(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec4 spiral6(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * -NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec2 twist2(vec2 coord)\n{\n\tvec2 diff = coord;\n\n\tfloat l = length(diff);\n\n\tfloat twistRadius = length(iResolution.xy * 0.5);\n    \n\tif (l < twistRadius)\n\t{\n\t\tfloat adjustedCurrTime = iTime;\n\n\t\tfloat k = floor(adjustedCurrTime / twist_period);\n        \n        float dt = mod(iTime, twist_period) / twist_period;\n\n\t\tfloat rad = PI * 0.1;\n        \n        //rad = rad * (sin(l / 20. + iTime));\n        \n        rad *= sin(l / 20.) + (l / length(iResolution.xy) * 0.5);// * sin(iTime);\n        \n        \n\t\tvec2 unitDiff = normalize(diff);\n\n\t\tfloat diffRad = atan(unitDiff.y, unitDiff.x);\n\n\t\tfloat newRad = diffRad + rad;\n        \n\t\tvec2 newDiff = vec2(cos(newRad), sin(newRad)) * l;\n\n\t\tvec2 newCoord = newDiff;\n\n\t\treturn newCoord;\n\t}\n\telse\n\t{\n\t\treturn coord;\n\t}\n}\n\nvec2 pulse3(vec2 coord)\n{\n\t// this indicates how many periods have passed\n\tfloat k = floor(iTime / pulse_period);\n\n\t// currTime - (k * period) basically gives us the remainder of the above division, so if we divide\n\t// that by the period we have a representation of time passed relative to the period,  parameterized\n\t// to be between 0 and 1\n\tfloat dt = (iTime - (k * pulse_period)) / pulse_period;\n\n\tdt = iTime / pulse_period;\n\t\n\tvec2 diff = coord;\n\n\t// Length of diff comes in handy for a few things\n\tfloat l = length(diff);\n\n\t// Same trick as the above. Use amplitude as indicator of how many periods away we are and flip the offset direction based on evenness\n\tint i = int(floor(l / amplitude));\n\n\t//bool isEven = mod(i, 2) == 0.;\n    bool isEven = true;\n\n\t//float sign = isEven ? 1.0 : -1.0;\n\n\tfloat sign = sin(l / 20.);\n\t\n\tfloat offset =  amplitude * sin(dt * PI * 2.0);\n\n\tfloat newL = l + (sign * offset);\n\t//float newL = l + offset;\n\n\tvec2 normDiff = normalize(diff);\n\tvec2 newDiff = normDiff * newL;\n\n\treturn newDiff;\n}\n\nvec4 distLight(vec2 coord)\n{\n    float dist = length(coord);\n    \n    float t = dist / length(iResolution.xy * 0.5);\n    \n    t = 1.0 - t;\n    \n    float v = mix(0., 0.8, t);\n    \n    return vec4(vec3(v), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n    \n    uv = pulse3(uv);\n    uv = twist2(uv);\n    \n    //fragColor = getCornerColors(uv);\n    \n    \n    fragColor = \n        (spiral6(uv) \n        * spiral5(uv))\n    \t* distLight(uv);\n        //* getCornerColors(uv);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBSR3", "name": "Noisey Squares", "author": "codevinsky", "description": "Some squares... with colors... and shit", "tags": ["checkers"], "likes": 5, "viewed": 194, "date": "1414213382", "time_retrieved": "2024-06-20T18:13:33.177383", "image_code": "float randomNoise(vec2 p) {\n  return fract(sin(47.*p.x+p.y*9973.) + iTime * 0.5);\n}\n\nfloat smoothNoise(vec2 p) {\n  vec2 nn = vec2(p.x, p.y+1.);\n  vec2 ee = vec2(p.x+1., p.y);\n  vec2 ss = vec2(p.x, p.y-1.);\n  vec2 ww = vec2(p.x-1., p.y);\n  vec2 cc = vec2(p.x, p.y);\n \n  float sum = 0.;\n  sum += randomNoise(nn)/8.;\n  sum += randomNoise(ee)/8.;\n  sum += randomNoise(ss)/8.;\n  sum += randomNoise(ww)/8.;\n  sum += randomNoise(cc)/2.;\n \n  return sum;\n}\n\nfloat interpolatedNoise(vec2 p) {\n  float q11 = smoothNoise(vec2(floor(p.x), floor(p.y)));\n  float q12 = smoothNoise(vec2(floor(p.x), ceil(p.y)));\n  float q21 = smoothNoise(vec2(ceil(p.x), floor(p.y)));\n  float q22 = smoothNoise(vec2(ceil(p.x), ceil(p.y)));\n \n  float r1 = mix(q11, q21, fract(p.x));\n  float r2 = mix(q12, q22, fract(p.x));\n \n  return mix (r1, r2, fract(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.yy;\n    \n\n\n    float tiles = 4.;\n    q = floor(q * tiles);\n  \t// Six components of noise in a fractal sum\n\n\tfloat x = interpolatedNoise(q + 2.);\n    float y = interpolatedNoise(q + 4. );\n    float z = interpolatedNoise(q + 8. );\n    vec3 col = vec3(x,y,z);\n    float lum = (0.2126 * col.x) + (0.7152 * col.y) + (0.0722 * col.z); \n\tfragColor = vec4(col , 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBSRc", "name": "Nyan Kitten", "author": "4rknova", "description": "nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan", "tags": ["nyancat"], "likes": 1, "viewed": 392, "date": "1414280399", "time_retrieved": "2024-06-20T18:13:34.159189", "image_code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define CAMERA_ANIMATION\n#define CAMERA_ANIMATION_ROTATE\n#define CAMERA_ANIMATION_ZOOM\n#define RAINBOW_TRAIL_QUANTIZATION\n#define RAINBOW_TRAIL_FADING\n\n#define SUPERSAMPLING\n#define AA\t4.\n\n#define SZ 12.                 // Stars size\n#define RP 8.5                 // Rainbow wave length\n#define RS 13.5                // Rainbow wave speed\n#define RA 0.013               // Rainbow wave amplitude\n#define R6 vec4(.5, .0, .9, 1) // Rainbow wave color 6\n#define R5 vec4(.0, .4, .9, 1) // Rainbow wave color 5\n#define R4 vec4(.0, .9, .0, 1) // Rainbow wave color 4\n#define R3 vec4(.9, .9, .0, 1) // Rainbow wave color 3\n#define R2 vec4(.9, .6, .0, 1) // Rainbow wave color 2\n#define R1 vec4(.9, .0, .0, 1) // Rainbow wave color 1\n#define BG vec3(.0, .2, .4567) // Background color\n#define SS 0.15625             // Size of sprite segment\n#define SC 6.0                 // Number of sprite segments\n#define SU RS                  // Animation speed\n#define BT iTime         // Base time\n\nvec3 background(vec2 p, inout vec4 fragColor)\n{\n    fragColor = vec4(BG, 1);\n    return BG;\n}\n\nvec2 grid(vec2 p, vec2 sz)\n{\n    return floor(p * sz);\n}\n\n#define _ 0. // Color Palette Index 0\n#define B 1. // Color Palette Index 1\n#define D 2. // Color Palette Index 2\n#define O 3. // Color Palette Index 3\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\n// Star sprite\nvoid star(vec2 p, inout vec4 col)\n{\n    p = p * iResolution.xy;\n    \n    vec2 scale = vec2(.1);\n    \n    vec3 res = BG;\n\n   vec2 gv = grid(p, scale); // The grid guide\n    \n   // if (gv.x >= 0. && gv.y >= 0. &&\n   //     gv.x <= 15. && gv.y <= 15.) {\n    {   \n        \tres = vec3(mod(gv.x + gv.y, 2.) * .1 + BG);\n     \n        // Indexing is upside down.\n        int y = 1 - int(scale.y - gv.y + 10.);\n\n    \tfloat m = 0.;\n\t\tQ(0, _,_,_,_,_,B,B,B)\n\t\tQ(1, _,_,_,B,B,B,D,O)\n\t\tQ(2, _,_,B,B,D,D,D,O)\n\t\tQ(3, _,B,B,O,D,D,O,O)\n\t\tQ(4, _,B,D,O,O,O,O,O)\n\t\tQ(5, B,B,D,D,O,O,D,D)\n\t\tQ(6, B,D,D,D,O,D,D,D)\n        \n    \tfloat ldx = 15. - gv.x; // Calculate the left  bit index\n        float rdx = gv.x;       // Calculate the right bit index\n        float bit = 0.;\n        \n        if (gv.x >= 8.)\tbit = mod(m / pow(4., ldx), 4.); // Decode\n        else            bit = mod(m / pow(4., rdx), 4.); // Mirror\n    \tbit = floor(bit);                                // Sharpen    \n    \t\n        // Colorize\n             if (bit > 2.) res = vec3(1,0,0);\n        else if (bit > 1.) res = vec3(1);\n        else if (bit > 0.) res = vec3(0);\n    }\n    \n    col = vec4(res, 1);\n}\n\n\nvoid rainbow(vec2 p, inout vec4 fragColor)\n{\n    float x = \n#ifdef RAINBOW_TRAIL_QUANTIZATION\n    \tfloor(RP * p.x);\n#else\n        p.x;\n#endif\n\n    // Transformation\n    p.y += sin(x * RP + RS * BT) * RA; // Wavy line\n    p.y = p.y * 1.2 - .22;             // Scale\n\n    // Bounds test\n    if (p.y >= .7 || p.y <= 0.1 || p.x > .33) return;\n    else if (p.y > .6) fragColor = R6; // Color 6\n    else if (p.y > .5) fragColor = R5; // Color 5\n    else if (p.y > .4) fragColor = R4; // Color 4\n    else if (p.y > .3) fragColor = R3; // Color 3\n    else if (p.y > .2) fragColor = R2; // Color 2\n\telse               fragColor = R1; // Color 1\n        \n#ifdef RAINBOW_TRAIL_FADING\n    fragColor.xyz = abs(mix(BG, fragColor.xyz,\n                               pow(clamp(1.2 + p.x, 0., 1.), 1.4)));\n#endif\n}\n\nvoid nyan(vec2 p, inout vec4 fragColor)\n{\n    p.x *=0.7; \n    if (p.x >= 1. || p.x <= 0. || p.y >= 1. || p.y <= 0. ) return;\n    float x = (floor(mod(BT * SU, SC)) + p.x) * SS;\n\tvec4 s = texture(iChannel0, vec2(x, p.y));\n\tif (s.w > 0.) fragColor = s;\n}\n\nvoid draw(vec2 sp, vec2 p, inout vec4 fragColor)\n{\n    // Draw elements using the painter's algorithm.\n    background(p, fragColor);\n  //  star(sp, fragColor);\n    rainbow(p, fragColor);\n    nyan(p, fragColor);\n}\n\nvec2 camera(vec2 p)\n{\n#ifdef CAMERA_ANIMATION_ZOOM\n    p *= (3.5 + 0.5 * cos(RP + BT * 0.42 + 0.92));\n#else\n    p *= 3.;\n#endif\n    \n    p -= vec2(1.2 + .3 * cos(1.29 + BT), 1. + sin(0.3 * BT) * .6);\n    \n#ifdef CAMERA_ANIMATION_ROTATE\n    float bt = 0.1 * cos(BT);\n    float st = sin(bt);\n    float ct = cos(bt);\n    p = vec2(p.x * ct - p.y * st, p.y * ct + p.x * st);\n#endif\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(\n        fragCoord.x / iResolution.y, \n        1.0 - fragCoord.y / iResolution.y);\n\t\n    vec2 p = uv;\n\n#ifdef CAMERA_ANIMATION\n    p = camera(uv);\n#else\n    p = p * 3. - vec2(1.2, 1.);\n#endif\n    \n#ifdef SUPERSAMPLING\n    // Antialiasing via supersampling\n    vec3 col = vec3(0);    \n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\t\n            draw(uv, p + vec2(i, j) * (e/AA), fragColor);\n            \n            col += fragColor.xyz / (4.*AA*AA);\n        }\n    }\n    \n    fragColor = vec4(col, 1);\n#else\n    draw(p);\n#endif /* SUPERSAMPLING */\n\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4tfGDH", "previewfilepath": "https://soundcloud.com/techno-sound/nyan-cat-song", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/techno-sound/nyan-cat-song", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBSzV", "name": "Sketch 2014-10-20 A", "author": "YoYo", "description": "Just an experiment", "tags": ["2d", "glitch"], "likes": 5, "viewed": 141, "date": "1413772288", "time_retrieved": "2024-06-20T18:13:34.159189", "image_code": "float spiral(float angle, float radius, float frequency, float rate)\n{\n\treturn fract(0.3 * radius * frequency + rate * iTime + angle);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy - (iResolution.xy * 0.5);\n    float angle = atan(pos.y, pos.x) / (2.0 * 3.14159);\n    float radius = sqrt(dot(pos, pos));\n    float spiral1 = spiral(angle, radius, 10.0 + 0.1 * sin(0.5 * iTime), 2.0);\n    float spiral2 = spiral(angle, radius, 20.0 + 0.05 * cos(0.7 * iTime), -1.9);\n    float spiral3 = spiral(angle, radius, 15.0, 0.5 * sin(0.84 * iTime));\n\tfragColor = vec4(spiral1, spiral2, (1.0 - spiral1 - spiral2), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBSzy", "name": "exploration-001a", "author": "yastero", "description": "random", "tags": ["random"], "likes": 1, "viewed": 97, "date": "1414363899", "time_retrieved": "2024-06-20T18:13:34.159189", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    float i,j,k = 0.0;\n    float t = iTime;\n    float vol = texture(iChannel0, vec2(abs(sin(t) * 100.0), 1.0)).x;\n\n    i += 1.0 - abs(\n        (2.4 * uv.x +\n         sin(0.1 * (t + (vol*10.0)) + (uv.y * (1.0 + (vol*7.0))) +\n         sin(t + (uv.y * 13.0)))) * (1.0 + (vol * 50.0)));\n\n    j += abs(sin(t * 10.0 * uv.x * uv.y)) * 10.0;\n\n    k += sin(uv.x + t);\n\n    k += uv.x + vol;\n\n    fragColor = vec4(i,j+k,k,1.0);\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBXDm", "name": "Point in Quad", "author": "iq", "description": "Tests whether a point is inside a quad. Note than the quadrilateral can intersect itself. Derived from https://www.shadertoy.com/view/lsBSDm", "tags": ["2d", "quad", "interior"], "likes": 18, "viewed": 1880, "date": "1412654050", "time_retrieved": "2024-06-20T18:13:34.165294", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Point in Quad test. Note that it works for selfintersecting quads. No square roots\n// required. Derived form this shader: https://www.shadertoy.com/view/lsBSDm\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat pointInQuad( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = a-d;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k0 = cross2d( f, g );\n    float k1 = cross2d( e, g );\n    float k2 = cross2d( f, e );\n    float k3 = cross2d( g, h );\n    float k4 = cross2d( e, h );\n    float k5 = cross2d( f, h );\n    \n    float l0 = k2 - k3 + k0;\n    float l1 = k2 + k3 + k1;\n    float m0 = l0*l0 + k0*(2.0*k4 - l0);\n    float m1 = l1*l1 + k1*(2.0*k5 - l1);\n    float n0 = m0    + k0*(2.0*k4 + k3 - k2);\n    float n1 = m1    + k1*(2.0*k5 - k3 - k2);\n    \n    float b0 = step( m0*m0, l0*l0*n0 );\n    float b1 = step( m1*m1, l1*l1*n1 );\n\n    float res = (m0>0.0) ? ((m1>0.0) ? b1*b0 : \n                                       b0) : \n                           ((m1>0.0) ? b1 : \n                                       b1 + b0 - b1*b0);\n\n    if( l0*l1 < 0.0 )  res -= b1*b0;\n    \n    return res;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec2 a = cos( 1.11*iTime + vec2(0.1,4.0) );\n    vec2 b = cos( 1.13*iTime + vec2(1.0,3.0) );\n    vec2 c = cos( 1.17*iTime + vec2(2.0,2.0) );\n    vec2 d = cos( 1.15*iTime + vec2(3.0,1.0) );\n    \n    float isQuad = pointInQuad( p, a, b, c, d );\n    \n    vec3 col = vec3( isQuad*0.5 );\n    \n    float h = 2.0/iResolution.y;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n    \n\tfragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBXDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldBXz3", "name": "Queasy Checkerboard", "author": "jcreed", "description": "Go home, checkerboard, you are drunk.", "tags": ["grid"], "likes": 26, "viewed": 672, "date": "1414258341", "time_retrieved": "2024-06-20T18:13:34.165294", "image_code": "#define time iTime*0.5\n\nfloat grid(vec2 p) {\n  vec2 orient = normalize(vec2(1.0,3.0));\n  vec2 perp = vec2(orient.y, -orient.x);\n  float g = mod(floor(1. * dot(p, orient)) + floor(1. * dot(p, perp)), 2.);\n  return g;\n}\n\n#define samp 30.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord.xy / 50. + vec2(-time, time);\n  vec2 q = (fragCoord.xy - (iResolution.xy / 2.)) / iResolution.x / 1.5 ;\n  vec4 c = vec4(grid(p));\n  if (q.x + 0.1 * q.y > 100.) {\n    fragColor = c;\n  }\n  else {\n    vec4 cc = vec4(0.0);\n    float total = 0.0;\n    \n    float radius = length(q) * 100.;\n    for (float t = -samp; t <= samp; t++) {\n      float percent = t / samp;\n      float weight = 1.0 - abs(percent);\n\t  float u = t / 100.;\n      vec2 dir = vec2(fract(sin(537.3 * (u + 0.5)) ) , fract(sin(523.7 * (u + 0.25)) ));\n      dir = normalize(dir) * 0.01;\n      float skew = percent * radius;\n      vec4 samplev = vec4(\n          grid(vec2(0.03,0.) + p +  dir * skew),\n          grid(radius * vec2(0.005,0.00) + p +  dir * skew),\n          grid(radius * vec2(0.007,0.00) + p +  dir * skew),\n          1.0);\n      cc += samplev * weight;\n      total += weight;\n    }\n\n\n    fragColor = cc / total - length(q ) * vec4(1.,1.,1.,1.) * 1.5;\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBXz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjSWD", "name": "Blob eat blob", "author": "toothmang", "description": "An accidental discovery while trying to make a simple spiral", "tags": ["procedural", "2d"], "likes": 12, "viewed": 1565, "date": "1412317959", "time_retrieved": "2024-06-20T18:13:34.553170", "image_code": "#define alpha 0.0\n#define beta 10.0\n\nvec4 getCornerColors(vec2 coord)\n{\n    vec4 cornerColors[4];\n\t\n    cornerColors[0] = vec4(1.0, 0, 0, 1.0);\n    cornerColors[1] = vec4(0, 0, 1.0, 1.0);\n    cornerColors[2] = vec4(0, 1.0, 0.0, 1.0);\n    cornerColors[3] = vec4(1.0, 1.0, 0.0, 1.0);\n        \n    vec2 cornerCoords[4];\n    cornerCoords[0] = vec2(0);\n    cornerCoords[1] = vec2(1, 0);\n    cornerCoords[2] = vec2(1);\n    cornerCoords[3] = vec2(0, 1);\n\n    \n\tvec4 result = vec4(0.0);\n\n\tfloat totalArea = dot(iResolution.xy, iResolution.xy);\n\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 cCoord = cornerCoords[i] * iResolution.xy;\n\n\t\tvec2 diff = coord - cCoord;\n\n\t\tfloat area = dot(diff, diff);\n\n\t\tresult += ((totalArea - area) / totalArea) * cornerColors[i];\n\t}\n\n\treturn result;\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 50.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 0.5)\n\t{\n\t\treturn vec4(vec3(0), 1.0);\n\t}\n\telse\n\t{\n\t\treturn vec4(vec3(remainder), 1.0);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n\t//fragColor = spiral4(uv) * vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = spiral4(uv) * (getCornerColors(fragCoord.xy) * 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjSzy", "name": "dithering: chroma-noise", "author": "hornet", "description": "noise\nvariance\nhistogram\nshows how using chroma noise gives a different distribution of noise (click mouse to switch between average and luminance histogram weighting)", "tags": ["noise", "distribution"], "likes": 6, "viewed": 259, "date": "1413476038", "time_retrieved": "2024-06-20T18:13:35.650307", "image_code": "const int HIST_NUM_BUCKETS = 32;\nconst int HIST_ITER_PER_BUCKET = 1024;\nconst float HIST_NUM_BUCKETS_F = float(HIST_NUM_BUCKETS);\nconst float HIST_ITER_PER_BUCKET_F = float(HIST_ITER_PER_BUCKET);\nconst float HIST_SCALE = 5.0;\n\nconst int VAR_NUM_AVG = 256;\nconst float VAR_NUM_AVG_F = float(VAR_NUM_AVG);\nconst float VAR_SCALE = 3.0;\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\n//note: triangular pdf rand [0;2[\nvec3 hash32t(vec2 p)\n{\n\tp = fract(p * vec2(5.3987, 5.4421));\n\tp += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\tfloat pxy = p.x * p.y;\n\treturn fract(pxy * vec3(95.43070, 97.59010, 93.83690))\n\t\t + fract(pxy * vec3(75.04909, 75.04957, 75.04961));\n}\n\n\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\nvec2 remap( vec2 a, vec2 b, vec2 v )\n{\n\treturn clamp( (v-a) / (b-a), vec2(0.0), vec2(1.0) );\n}\n\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\n// ====\n\nvec3 n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n    return vec3( hash12n( n + 1337.0*t ) );\n}\n\nvec3 n1rand_rgb( vec2 n )\n{\n\tfloat t = fract( iTime );\n\treturn hash32n( n + 1337.0*t );\n}\n\nvec3 n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n    return 0.5 * hash32t( n + 1337.0*t ).xxx;\n}\n\nvec3 n2rand_rgb( vec2 n )\n{\n\tfloat t = fract( iTime );\n    return 0.5 * hash32t( n + 1337.0*t );\n}\n\n\nfloat lum( vec3 c )\n{\n    if ( iMouse.z < 1.0 )\n    {\n        //relative rgb-luminance weighted\n        //return sqrt( 0.299*c.r*c.r + 0.587*c.g*c.g + 0.114*c.b*c.b ); //perceived luminance... skewed?\n        return 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;\n\t\t//return dot( c, vec3(0.22, 0.707, 0.071) );\n    }\n    else\n    \treturn dot( c, vec3(0.33333) ); //average\n}\n\nvec3 eval( int iter, float t, float seed )\n{\n    if ( iter == 0 )\n        return n1rand( vec2(t, 0.5) + seed );\n    else if ( iter == 1 )\n        return n2rand( vec2(t, 0.5) + seed );\n    else if ( iter == 2 )\n        return n1rand_rgb( vec2(t,0.5) + seed );\n\telse\n        return n2rand_rgb( vec2(t,0.5) + seed );\n}\n\nfloat histogram( int iter, vec2 luv )\n{\n\tfloat t = luv.x;\n\tvec2 bucket = vec2( truncate(t,HIST_NUM_BUCKETS_F), truncate(t,HIST_NUM_BUCKETS_F)+1.0/HIST_NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n    float var = 0.0;\n\tfor ( int i=0;i<HIST_ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/HIST_ITER_PER_BUCKET_F;\n\t\t\n\t\tvec3 r = eval( iter, t, seed );\n        \t\t\n\t\tbucketval += step(bucket.x,lum(r)) * step(lum(r),bucket.y);\n\t}\n\tbucketval /= HIST_ITER_PER_BUCKET_F;\n\tbucketval *= HIST_SCALE;\n\treturn step( bucketval, luv.y );\n}\n\n\nfloat variance( int iter, vec2 luv )\n{\n    vec3 sum = vec3(0.0);\n    for ( int i=0; i<VAR_NUM_AVG; ++i )\n    {\n        float seed = float(i) / VAR_NUM_AVG_F;\n        vec3 r = eval( iter, luv.x, seed );\n        sum += r;\n    }\n    vec3 mean = sum / VAR_NUM_AVG_F;\n    \n    float var = 0.0;\n\tfor ( int i=0; i<VAR_NUM_AVG; ++i )\n\t{\n\t\tfloat seed = float(i)/VAR_NUM_AVG_F;\n\t\tvec3 r = eval( iter, luv.x, seed );\n\t\t\n        vec3 diff = r - mean;\n        var += dot( diff, diff );\n\t}\n    var /= float(VAR_NUM_AVG-1);\n    var *= VAR_SCALE;\n    float oc = step( var, luv.y );\n    return step( luv.y, oc );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 o = vec3(0.0);\n    if ( uv.x < 1.0/4.0 )\n    {\n\t\to = eval( 0, uv.x, uv.y );\n\t\tif ( uv.y < 1.0 / 4.0 )\n        {\n            vec2 luv = remap( vec2(0.0/4.0, 0.0/4.0), vec2(1.0/4.0, 2.0/4.0), uv );\n\t\t\to = vec3( 0.85 - 0.7 * histogram( 0, luv ) );\n        }\n        else if ( uv.y < 2.0/4.0 )\n        {\n            vec2 luv = remap( vec2(0.0/4.0, 1.0/4.0), vec2(1.0/4.0, 2.0/4.0), uv );\n            o = vec3( 0.85 - 0.7 * variance( 0, luv ) );\n        }\n    }\n\telse if ( uv.x < 2.0/4.0 )\n\t{\n\t\to = eval( 1, uv.x, uv.y );\n\t\tif ( uv.y < 1.0 / 4.0 )\n        {\n            vec2 luv = remap( vec2(1.0/4.0, 0.0/4.0), vec2(2.0/4.0, 2.0/4.0), uv );\n\t\t\to = vec3( 0.85 - 0.7 * histogram( 1, luv ) );\n        }\n        else if ( uv.y < 2.0/4.0 )\n        {\n            vec2 luv = remap( vec2(1.0/4.0, 1.0/4.0), vec2(2.0/4.0, 2.0/4.0), uv );\n            o = vec3( 0.85 - 0.7 * variance( 1, luv ) );\n        }\n\t}\n\telse if ( uv.x < 3.0 / 4.0 )\n\t{\n        o = eval( 2, uv.x, uv.y );\n\t\tif ( uv.y < 1.0 / 4.0 )\n        {\n            vec2 luv = remap( vec2(2.0/4.0, 0.0/4.0), vec2(3.0/4.0, 2.0/4.0), uv );\n\t\t\to = vec3( 0.85 - 0.7 * histogram( 2, luv ) );\n        }\n        else if ( uv.y < 2.0/4.0 )\n        {\n            vec2 luv = remap( vec2(2.0/4.0, 1.0/4.0), vec2(3.0/4.0, 2.0/4.0), uv );\n            o = vec3( 0.85 - 0.7 * variance( 2, luv ) );\n        }\n\t}\n    else\n    {\n        o = eval( 3, uv.x, uv.y );\n\t\tif ( uv.y < 1.0 / 4.0 )\n        {\n            vec2 luv = remap( vec2(3.0/4.0, 0.0/4.0), vec2(4.0/4.0, 2.0/4.0), uv );\n\t\t\to = vec3( 0.85 - 0.7 * histogram( 3, luv ) );\n        }\n        else if ( uv.y < 2.0/4.0 )\n        {\n            vec2 luv = remap( vec2(3.0/4.0, 1.0/4.0), vec2(4.0/4.0, 2.0/4.0), uv );\n            o = vec3( 0.85 - 0.7 * variance( 3, luv ) );\n        }\n\n    }\n\n\t//display lines\n    if ( abs(uv.x - 1.0/4.0) < 0.002 ) o = vec3( 0.0 );\n\tif ( abs(uv.x - 2.0/4.0) < 0.002 ) o = vec3( 0.0 );\n    if ( abs(uv.x - 3.0/4.0) < 0.002 ) o = vec3( 0.0 );\n\t\n\tfragColor = vec4( o, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjXRK", "name": "1D Quadratic Trig Spline", "author": "demofox", "description": "Trigonometry based \"quadratic\" (3 point) spline, based on these:\nhttp://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1997/9705/9705n/9705n.htm\nhttp://www.drdobbs.com/database/implementing-uniform-trigonometric-splin/184410198", "tags": ["2d", "spline", "trig"], "likes": 5, "viewed": 220, "date": "1413920271", "time_retrieved": "2024-06-20T18:13:36.195872", "image_code": "#define A  0.0\n#define B  (iMouse.z <= 0.0 ? (sin(iTime*1.5) * 0.5) : iMouse.y / iResolution.y - 0.5)\n#define C  0.2\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n#define PI 3.14159265359\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // convert time from 0-1 to 0-pi/2\n    float T = coords.x * PI * 0.5;\n    \n    // pre-calculate sin and cosine\n    float snt = sin(T);  // sin 0 = 0.  sin pi/2 = 1\n    float cst = cos(T);  // cos 0 = 1.  cos pi/2 = 0\n\n    // interpolating spline, not an exterpolating spline, so should pass through the end control points\n    // but not the middle control points.\n\t// basis - google: graph y = (0.5*sin(x)*(sin(x)+1.0)), y = (0.5*cos(x)*(cos(x)+1.0)), y = (0.5*sin(x)*(sin(x)-1.0))+(0.5*cos(x)*(cos(x)-1.0)) from 0 to pi/2\n    // basis sum - google: graph y = (0.5*cos(x)*(cos(x)-1.0)) + (0.5*sin(x)*(sin(x)+1.0)) + (0.5*cos(x)*(cos(x)+1.0)) + (0.5*sin(x)*(sin(x)-1.0)) \n    return\n        C *  (0.5*snt*(snt+1.0)) + \n        B * -(0.5*snt*(snt-1.0)) +        \n        B * -(0.5*cst*(cst-1.0)) +         \n        A *  (0.5*cst*(cst+1.0)) - \n        coords.y;\n}\n\n// gradiant function for finding G for a generic function when you can't\n// get it analytically using partial derivatives.  We could do\n// partial derivatives of F above, but I'm being lazy.\nvec2 Grad( in vec2 coords )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( F(coords+h.xy) - F(coords-h.xy),\n                 F(coords+h.yx) - F(coords-h.yx) ) / (2.0*h.x);\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    vec2  g = Grad(coords);\n    return abs(v)/length(g);\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.5,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n        \n    dist = SDF(percent);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= (percent.x >= 0.0 && percent.x <= 1.0) ? vec3(dist) : vec3(0.95);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjXRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldjXWD", "name": "Glow Dance", "author": "Blackhart", "description": "my simple glow experiment", "tags": ["sphere", "glow"], "likes": 7, "viewed": 359, "date": "1412342097", "time_retrieved": "2024-06-20T18:13:36.195872", "image_code": "#define GLOW 1.0\n\nfloat\tdSphere(vec2 pCenter, float pRayon, vec2 fragCoord)\n{\n    return length(fragCoord.xy - pCenter) - pRayon;\n}\n\nvec3\tsGlow(vec3 pColor, float ld)\n{\n    return pColor * exp(-(ld/25.0)*0.5) * GLOW;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float\tlt1 = sin(iTime);\n    float\tlt2 = cos(iTime);\n    float\tld1 = dSphere(vec2(iResolution.xy*0.5) - vec2(50.0*lt1, 200.0*lt2), 10.0,fragCoord);\n    float\tld2 = dSphere(vec2(iResolution.xy*0.5), 10.0,fragCoord);\n    float\tld3 = dSphere(vec2(iResolution.xy*0.5) + vec2(200.0*lt1, 50.0*lt2), 10.0,fragCoord);\n    vec3\tlColor = sGlow(vec3(1.0, 0.0, 0.0), ld1);\n    lColor += sGlow(vec3(0.0, 1.0, 0.0), ld2);\n    lColor += sGlow(vec3(0.0, 0.0, 1.0), ld3);\n    fragColor = vec4(lColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjXWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSXzc", "name": "Persian Symettry 2", "author": "NPWR", "description": "Wow bwoi", "tags": ["psychedelic"], "likes": 6, "viewed": 663, "date": "1414331604", "time_retrieved": "2024-06-20T18:13:36.201960", "image_code": "vec2 fold = vec2(-0.5, -0.5);\nvec2 translate = vec2(1.5);\nfloat scale = 1.25;\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec2 rotate(vec2 p, float a){\n\treturn vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\tp *= 0.02;\n\tfloat x = p.y;\n\tp = abs(mod(p, 2.0) - 1.);\n\tfor(int i = 0; i < 32; i++){\n\t\tp = abs(p - fold) + fold;\n\t\tp = p*scale - translate;\n\t\tp = rotate(p, 3.14159/(0.10+sin(iTime*0.0022+float(i)*0.251)*0.50001+0.501));\n\t}\n\tfloat i = x*500.0 + atan(p.y, p.x) + iTime*0.003;\n\tfloat h = floor(i*6.0)/5.0 + 0.1;\n\th += smoothstep(0.0, 0.4, mod(i*6.0/5.0, 1.0/5.0)*5.10)/5.10 - 1.1;\n\tfragColor=vec4(hsv(h, 1.0, smoothstep(-1.0, 3.0, length(p))), 30);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldSXzz", "name": "Verbose Raytracer", "author": "GraphicsMuncher", "description": "Basic analytical raytracer.\n\nThe code is purposefully unoptimized and not very GPU-friendly. My hope is that someone can start at main() and read through each function step by step.", "tags": ["raytracer", "basic", "tutorial", "readable"], "likes": 9, "viewed": 475, "date": "1412198131", "time_retrieved": "2024-06-20T18:13:37.765624", "image_code": "//\n// Scene variables\n//\n\n#define NUM_SPHERES 4\n#define MAX_BOUNCES 3\n#define NUM_LIGHTS  1\n#define DRAW_ROOM\n#define DRAW_SPHERES\n\nvec2 mouse;\nvec2 uv;\nfloat hit = 0.0;\n\n//\n// Scene constants\n//\n\n#define NUM_PLANES 5\n#define PI 3.14159265358979323846264\n#define INFINITY 1e32\n#define EPSILON  1e-3\n\nvec3 ambLight = vec3(0.2);\n\n\n//\n// Material struct\n//\n\nstruct mat_t\n{\n    vec3 ka;  // ambient color\n\tvec3 kd;  // diffuse color\n    vec3 ks;  // specular color\n    float ns; // specular exponent (shininess)\n} mats;\n\n//\n// Ray struct\n//\n\nstruct ray_t\n{\n\tvec3 o; // origin\n    vec3 d; // direction\n} ray;\n\n\n//\n// Point light struct\n//\n\nstruct pLight_t\n{\n\tvec3 pos; // position of the light\n    vec3 col; // color (intensity) of the light\n} lights[ NUM_LIGHTS ];\n\n//\n// Intersection struct\n//\n\nstruct intersection_t\n{\n    mat_t mat;   // material at intersection point\n    vec3 hitpt;  // position in world space\n    vec3 iray;   // incoming ray direction\n    vec3 normal; // normal vector\n\tfloat t;     // direction along iray from ray origin\n} ist;\n\nvec3 intersection_shade( intersection_t hit )\n{\n\tvec3 endCol = vec3(0);\n\n    // Ambient\n    endCol += hit.mat.ka * ambLight;\n    \n    for( int i = 0; i < NUM_LIGHTS; i++ )\n    {\n        // Diffuse\n        vec3 l = normalize( lights[ i ].pos - hit.hitpt );\n        vec3 n = hit.normal;\n    \tendCol += hit.mat.kd * max( dot( n, l ), 0.0 ) * lights[ i ].col;\n        \n        // Specular\n        vec3 r = reflect( -l, n);\n    \tvec3 v = -hit.iray;\n    \tfloat s =  pow( max( dot( r, v ), 0.0) , hit.mat.ns );\n    \tendCol += hit.mat.ks * s * lights[ i ].col;\n    }\n    \n    return endCol;\n}\n\n//\n// Plane struct\n//\n\nstruct plane_t\n{\n    mat_t mat;   // material\n    vec3 center; // location\n\tvec3 normal; // normal defining plane\n    vec3 up;     // up vector defining orientation\n    vec2 dims;   // dimensions along up and normal x up\n\n} planes[ NUM_PLANES ];\n\nintersection_t plane_intersect( plane_t p, ray_t r)\n{\n\tintersection_t ist;\n    ist.t = INFINITY;\n    \n    float t = dot( ( p.center - r.o ), p.normal ) / dot( r.d, p.normal );\n    if( t < 0.0 ) { return ist; }\n    \n    vec3 pt = (r.d * t) + r.o;\n    vec3 rad = pt - p.center;\n    if( ( abs( dot( rad, p.up ) ) < p.dims.y ) && ( abs( dot( rad, cross( p.up, p.normal ) ) ) < p.dims.x ) )\n    {\n    \tist.t = t;\n        ist.iray = r.d;\n        ist.hitpt = pt;\n        ist.normal = p.normal;\n        ist.mat = p.mat;\n    }\n    \n    return ist;\n}\n\n//\n// Sphere struct\n//\n\nstruct sphere_t\n{\n    mat_t mat;\n\tvec3 pos;\n    float r;\n} spheres[ NUM_SPHERES ];\n\nintersection_t sphere_intersect( sphere_t s, ray_t r )\n{\n    intersection_t intersection;\n    \n    float a = dot( r.d, r.d );\n    float b  = 2.0 * dot( r.o - s.pos, r.d );\n    float c  = - (s.r * s.r) + dot( r.o  - s.pos, r.o - s.pos );\n    float d  = b*b - 4.0*a*c;\n    if( d < 0.0 ) { ist.t = INFINITY; return ist; }\n    ist.t = ( - b - sqrt( d ) ) / (2.0 * a);\n    if( ist.t < 0.0 ) { ist.t = INFINITY; return ist; }\n    ist.iray = r.d;\n    ist.hitpt = (r.d * ist.t) + r.o;\n    ist.normal = normalize( ist.hitpt - s.pos );\n    ist.mat = s.mat;\n    \n    return ist;\n}\n\n//\n// Camera struct\n//\n\nstruct camera_t\n{\n\tvec3 pos;\n    \n} cam;\n\nray_t camera_getRay( camera_t c, vec2 uv )\n{\n    ray_t ray;\n    ray.o = c.pos;\n    \n    // Rotate camera according to mouse position\n    float ca = cos(mouse.x), sa = sin(mouse.x);\n    mat3 rotX = mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n    ca = cos(mouse.y), sa = sin(mouse.y);\n    mat3 rotY = mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);\n    mat3 rotM = rotX * rotY;\n    \n\tray.o = rotM*c.pos;\n    ray.d = rotM*normalize( vec3( uv, -1.0 ) ); // should be -1! facing into scene\n    \n\treturn ray;\n}\n\n//\n// Scene functions\n//\n\nvoid init_scene( void )\n{\n    // Initialize lights\n    float w = float(NUM_LIGHTS)*8.0;\n    float lr = w*0.5;\n    for( int i = 0; i < NUM_LIGHTS; i++)\n    {\n    \tlights[ i ].pos = vec3( -lr + w*float( i + 1 ) / float( NUM_LIGHTS + 1 ), 2, 3 );\n        lights[ i ].col = vec3( 0.8 );\n    }\n    \n    // Initialize camera\n    cam.pos = vec3( 0.0, 0.0, 3.9 );\n\n    // Initialize spheres\n    float t = iTime * 0.5;\n#ifdef DRAW_SPHERES\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        float ifrc = float(i)/float(NUM_SPHERES)*2.0*PI;\n        float r = 1.0;\n        spheres[ i ].r = r;\n        r *= 2.0;\n        float ipi = float( i ) * 2.0 * PI / float( NUM_SPHERES );\n        spheres[ i ].pos = vec3( r * sin( ipi + t ), r * cos( ipi + t ), -0.0 );\n        spheres[ i ].mat.kd = vec3( 0.4 ) + 0.4 * vec3( sin(ifrc + t), sin(ifrc + t + 2.0*PI/3.0), sin(ifrc + t + 2.0*2.0*PI/3.0));      \n        spheres[ i ].mat.ka = spheres[ i ].mat.kd;\n        spheres[ i ].mat.ks = vec3(0.7);\n        spheres[ i ].mat.ns = 128.0;\n    }\n#endif\n#ifdef DRAW_ROOM\n    float br = 4.0;\n    for( int i = 0; i < NUM_PLANES; i++)\n    {\n        float fiPI = float(i)*0.5*PI;\n        planes[ i ].center = vec3(cos(fiPI)*br,0,-sin(fiPI)*br);\n        planes[ i ].normal = -normalize( planes[ i ].center );\n        planes[ i ].up     = vec3(0,1,0);\n        planes[ i ].dims   = vec2(br);\n        planes[ i ].mat.ka = vec3(0.1);\n\t    planes[ i ].mat.ks = vec3(0.3);\n    \tplanes[ i ].mat.ns = 128.0;\n\n    }\n    planes[ 3 ].center = vec3(0,br-EPSILON,0);\n    planes[ 3 ].normal = vec3(0,-1,0);\n    planes[ 3 ].up     = vec3(0,0,1);\n    planes[ 3 ].dims   = vec2(br);\n    planes[ 3 ].mat.ka = vec3(0.1);\n    planes[ 3 ].mat.ks = vec3(0.0);\n    planes[ 3 ].mat.ns = 128.0;\n    planes[ 4 ].center = vec3(0,-br+EPSILON,0);\n    planes[ 4 ].normal = vec3(0,1,0);\n    planes[ 4 ].up     = vec3(0,0,1);\n    planes[ 4 ].dims   = vec2(br);\n    planes[ 4 ].mat.ka = vec3(0.1);\n    planes[ 4 ].mat.ks = vec3(0.0);\n    planes[ 4 ].mat.ns = 128.0;\n    planes[ 0 ].mat.kd = vec3(0.9,0.1,0.1);\n    planes[ 1 ].mat.kd = vec3(0.8,0.8,0.8);\n    planes[ 2 ].mat.kd = vec3(0.1,0.9,0.1);\n    planes[ 3 ].mat.kd = vec3(0.8,0.8,0.8);\n    planes[ 4 ].mat.kd = vec3(0.8,0.8,0.8);\n#endif\n}\n\nvec3 intersect_scene( ray_t ray )\n{\n    vec3 endCol = vec3(0);\n    vec3 specMod = vec3(1);\n    intersection_t bestI;\n    intersection_t ht;\n    ray_t r = ray;\n    for( int j = 0; j < MAX_BOUNCES; j++)\n    {\n        bestI.t = INFINITY;\n        // Intersect geometry, finding closest point\n#ifdef DRAW_SPHERES\n        for(int i = 0; i < NUM_SPHERES; i++)\n        {\n            ht = sphere_intersect( spheres[ i ], r );\n            if( ht.t < bestI.t ) { bestI = ht; }\n        }\n#endif\n#ifdef DRAW_ROOM\n        for( int i = 0; i < NUM_PLANES; i++)\n        {\n            ht = plane_intersect( planes[ i ], r );\n            if( ht.t < bestI.t ) { bestI = ht; }\n        }\n#endif\n        // Quit if we don't hit anything\n        if( bestI.t == INFINITY ) { break; }\n     \thit = 1.0;\n        \n        // Shade\n        endCol += specMod*intersection_shade( bestI );\n        specMod *= bestI.mat.ks; // Keep track of specular intensity of each reflection\n        \n        // Reflect ray about normal\n        r.o = bestI.hitpt + bestI.normal * EPSILON;\n        r.d = reflect( r.d, bestI.normal );        \n    }\n    \n    return endCol;\n}\n\n//\n// Main loop\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get screen coordinate\n\tuv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n    uv.x *= (iResolution.x/iResolution.y);\n    mouse = -1.0 + 2.0 * ( iMouse.xy / iResolution.xy );\n    mouse *= 2.0*PI;\n    \n    // Initialize scene\n    init_scene();\n    \n    // Intersect scene\n    ray_t ray = camera_getRay( cam, uv );\n    vec3 col = intersect_scene( ray );\n    \n    // Add background\n    col = hit*col + (1.0-hit)*(1.0-0.2*length(uv))*vec3(1,1,0);\n    fragColor = vec4( col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2SDD", "name": "Unreal Intro", "author": "fizzer", "description": "A remake of the castle fly-by sequence from the classic 90's videogame Unreal. The geometry is converted directly from the level data and I made everything else myself. \"Alter your reality...forever\".\nhttp://www.youtube.com/watch?v=26I-Pw-yPJ4", "tags": ["procedural", "videogame", "flyby", "unreal"], "likes": 145, "viewed": 18538, "date": "1412368341", "time_retrieved": "2024-06-20T18:13:41.662912", "image_code": "// Created by Edd Biddulph\n// License for this shader: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is a recreation of the castle fly-by sequence from the original Unreal, released in 1998 and\n// developed by Epic MegaGames. http://epicgames.com/\n//\n// This was mostly inspired by P_Malin's amazing Doom shader - https://www.shadertoy.com/view/lsSXzD\n//\n// I made a custom tool to convert the geometry from the original files from the game, but the textures\n// were made 'by hand'. Unreal's levels are composed of convex shapes called 'brushes'. The brushes\n// are combined using CSG operations to produce the level geometry. My tool detects cuboid-shaped brushes\n// from which a distance field is simple to create. Most of the non-cuboid-shaped brushes can be created\n// by cutting a cuboid with less than 4 oriented planes so my tool first generates a cuboid and adds\n// those planes into the distance field code.\n\n\n#define time (iTime-6.0)\nfloat flagTime=0.0;\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    p=fract(p/256.0);\n    return textureLod(iChannel0, p, 0.0).r;\n}\n\n// Distorted texture coordinates for the rippling flag.\nvec2 flagTC(vec2 p)\n{\n    float tm=-flagTime*1.4;\n    return vec2(p.x+p.x*(cos(p.x*7.0+tm*6.0))*0.02+cos(p.y*6.0+tm*7.5)*0.01*p.x,p.y+p.x*cos(p.x*4.0+tm*5.0)*0.01);\n}\n\nvec3 flagTexture2(vec2 p)\n{\n    p.x+=0.05;\n    p.y+=0.05;\n    float d=1e2;\n    d=min(d,length(p-vec2(-0.85,-0.13+p.x*-0.4))-0.5);\n    d=min(d,length(p-vec2(-0.8,-1.2))-0.9);\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(0.4,-0.63))-vec2(0.5,0.3))));\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(0.9,0.0))-vec2(0.3,0.8))));\n    d=min(d,length(max(vec2(0.0),abs(p-vec2(-0.9,0.0))-vec2(0.3,0.8))));\n    vec2 p2=p+vec2(0.0,-0.07);\n    d=min(d,length((p2-vec2(0.1,0.2))*vec2(1.0,0.9))+0.1-p2.y*1.3);\n    d=max(d,-length(p-vec2(0.1,0.5))+0.15);\n    vec2 p3=p+vec2(0.0,0.1);\n    d=min(d,max(p.x, max(-(length((p3-vec2(0.1,0.2))*vec2(1.0,0.9))+0.1-p3.y*1.1), dot(p-vec2(0.0,0.12),normalize(vec2(-0.75,-1.0))))));\n    return mix(vec3(0.2,0.1,0.1),vec3(1.0,0.2,0.1)*0.9,(0.3+(1.0-smoothstep(0.0,0.02,d))))*\n        mix(0.7,1.0,smoothNoise2(p*40.0)*0.25+smoothNoise2(p*20.0)*0.25);\n}\n\nvec4 flagTexture(vec2 p2)\n{\n    vec2 p=p2.xy*0.7+vec2(0.5);\n    vec2 c=flagTC(p);\n    vec2 e=vec2(1e-2,0.0);\n    float g=max(length((flagTC(p+e.xy)-c)/e.x),length((flagTC(p+e.yx)-c)/e.x));\n\n    float b=step(abs(c.y-0.5),0.3)*step(c.x,0.8);\n    float nb=-1.0+abs(c.y-0.5)*3.3;\n    return vec4(flagTexture2((c*2.0-vec2(1.0))*vec2(-1.0,1.0))*(1.0-smoothstep(0.0,2.0,g)),\n                step(abs(c.y-0.5)*2.0,0.7)*step(abs(c.x-0.5)*2.0,1.0)*smoothstep(nb+0.199,nb+0.2,smoothNoise2(c*vec2(32.0,0.5))));\n}\n\n\n// Brick pattern for tex_wmbrrw.\nfloat brickt3(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.4,0.36)));\n    return 1.0-smoothstep(0.01,0.2,brick)-smoothNoise2(p2*vec2(7.0,4.0)*3.0)*0.2;\n}\n\n// Brick pattern for tex_nfloor6.\nfloat brickt2(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.465,0.465)));\n    return 1.0-smoothstep(0.0,0.04,brick)+smoothNoise2(p2*vec2(4.0,4.0)*3.0)*0.0;\n}\n\n// Brick pattern for tex_wmcs.\nfloat brickt(vec2 p2)\n{\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.44,0.32))*vec2(11.0/4.0,1.0));\n    return 1.0-smoothstep(0.0,0.18,brick)+smoothNoise2(p2*vec2(8.0,4.0)*3.0)*0.4;\n}\n\n// Roof texture.\nvec3 tex_Roof(vec2 p)\n{\n    vec2 tc0=floor(p*vec2(6.0,3.0));\n    p.y+=0.5/3.0;\n    vec2 tc=floor(p*vec2(6.0,3.0));\n    vec2 tt=fract(p*vec2(6.0,3.0));\n\n    tt.x+=smoothNoise2(p*10.0)*0.05+smoothNoise2(p*30.0)*0.02;\n\n    float spike=smoothstep(0.8,1.0,smoothNoise2(vec2(p.x*100.0,tc.y*7.0+tc.x*1.0)))*0.4;\n    float j=smoothNoise2(vec2(p.x*8.0,tc.y*3.0+tc.x*8.0))*0.1;\n    float sh=1.0-(smoothstep(-spike,0.05,tt.y-0.5+j)-sqrt(smoothstep(0.05,0.7,tt.y-0.5+j)));\n    sh*=smoothstep(0.0,0.1,tt.x)-smoothstep(0.9,1.0,tt.x+cos(tc0.x*9.0+tc0.y*2.0)*0.1);   \n\n    vec3 col=mix(vec3(1.4,0.9,0.5)*0.5,vec3(1.0,0.7,0.5),smoothNoise2(p*vec2(128.0,8.0)))*mix(0.1,1.0,sh)*0.5;\n    col*=vec3(1.0)+3.0*vec3(0.5,0.5,0.7)*pow(smoothNoise2(p+tc0),4.0);\n    col*=sqrt(smoothNoise2(p*8.0-tc0*4.0)*0.5+smoothNoise2(p*64.0-tc0*1.0)*0.2);\n\n    return col;\n}\n\nvec3 tex_wrck(vec2 p)\n{\n    p+=smoothNoise2(p)*0.2;\n    vec3 col=mix(vec3(0.1,0.22,0.1)*0.3,vec3(0.3,0.4,0.25),smoothNoise2(p*2.0)*0.5+smoothNoise2(p*8.0)*0.25+smoothNoise2(p*32.0)*0.125);\n    col=mix(vec3(0.4,0.3,0.1)*0.4,col*0.8,sqrt(smoothNoise2(p*64.0)*0.5+smoothNoise2(p*13.0)*0.125));\n    vec2 p2=p+smoothNoise2(p*4.0)*0.3;\n    col+=3.0*vec3(0.2,0.3,0.3)*pow(smoothNoise2(p2*4.0)*0.5,4.0);\n\n    float ly=fract(p.y*12.0)-0.5+smoothNoise2(vec2(p.x*14.0,floor(p.y)))*0.2+smoothNoise2(vec2(p.x*5.0,floor(p.y*12.0)))*0.68;\n    float lines=1.0-(smoothstep(0.0,0.1,ly)-smoothstep(0.1,0.8,ly))*0.3;\n\n    col=mix(col,col*lines*(1.0+(smoothstep(-0.05,0.0,ly)-smoothstep(0.0,0.05,ly))*0.5),smoothstep(0.0,0.5,smoothNoise2(p*4.0)));\n    col*=mix(0.7,1.0,smoothNoise2(p*16.0));\n    col=mix(col,vec3(dot(col,vec3(1.0/3.0))),0.75);\n\n    return col*0.8;\n}\n\nvec3 tex_wmbrrw(vec2 p)\n{\n    float s=mix(0.5,1.2,sqrt(smoothNoise2(p*3.0))+smoothNoise2(p*80.0));\n    vec3 col=mix(mix(vec3(0.1),vec3(0.7,0.25,0.05),0.4)*0.4,\n                 mix(vec3(0.1),vec3(0.3,0.2,0.09),0.4)*0.7*s,\n                 sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(5.0,12.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.05;\n    p2.x+=floor(p2.y)*0.5;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0)*0.5;\n\n    float brick=brickt3(p2);\n    vec3 bn=normalize(vec3(brickt3(p2+vec2(1e-3,0.0))-brick,brickt3(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(vec3(2.0),vec3(0.3+bh*1.0),brick);\n\n    col.rgb*=vec3(0.5)+vec3(0.5)*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    vec2 shadp=fract(p*2.0-vec2(0.12,0.04));\n    float shadow=mix(0.2,1.0,1.0-smoothstep(0.05,0.3,length(max(vec2(0.0),abs(shadp-vec2(0.5))-vec2(0.2,0.21)))));\n    col*=shadow;\n    vec2 beamp=fract(p*2.0);\n    float hbeammask=1.0-smoothstep(0.07,0.08,abs(beamp.y-0.1));\n    float vbeammask=1.0-smoothstep(0.07,0.08,abs(beamp.x-0.1));\n\n    col*=1.0-2.0*vec3(0.4,0.4,0.5)*smoothstep(0.5,1.0,pow(max(0.0,smoothNoise2((p.yx*20.0)*vec2(1.0,1.0))),2.0));\n\n    col=mix(col,0.3*mix(vec3(1.0,0.6,0.4)*0.5,vec3(1.0,0.7,0.4)*0.3,\n                        smoothNoise2(beamp*vec2(5.0,128.0))+smoothNoise2(beamp*vec2(4.0,256.0)*2.0)*0.75\n                       ),hbeammask);\n\n    col*=smoothstep(0.05,0.16,abs(beamp.x-0.1))*smoothstep(0.05,0.16,abs(beamp.x-1.1));\n\n    col=mix(col,0.3*mix(vec3(1.0,0.6,0.4)*0.5,vec3(1.0,0.7,0.4)*0.3,\n                        smoothNoise2(beamp*vec2(128.0,5.0))+smoothNoise2(beamp*vec2(256.0,4.0)*2.0)*0.75\n                       ),vbeammask);\n\n    vec2 nn=vec2(smoothNoise2(p*1.0),smoothNoise2(p*10.0+vec2(23.0)))*2.0;\n    col*=1.0+vec3(0.4,0.4,0.5)*smoothstep(0.5,1.0,smoothNoise2((p.yx*20.0+nn)*vec2(1.0,2.0))+\n                                          smoothNoise2(p*8.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n\n    col*=1.0+vec3(0.4)*smoothstep(0.5,1.0,smoothNoise2(p.yx*2.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    return col*1.75;\n}\n\nvec3 tex_nfloor6(vec2 p)\n{\n    p.x+=floor(hash(floor(p.y*2.0))*10.0);\n    p.y+=floor(hash(floor(p.x*2.0))*10.0);\n    float s=mix(0.5,1.2,sqrt(smoothNoise2(p*3.0))+smoothNoise2(p*80.0));\n    vec3 col=mix(mix(vec3(0.1),vec3(0.18,0.25,0.05),0.4)*0.4,\n                 mix(vec3(0.1),vec3(0.2,0.175,0.09),0.4)*0.7*s,\n                 sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(2.0,2.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.02;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0)*0.5;\n\n    float brick=brickt2(p2);\n    vec3 bn=normalize(vec3(brickt2(p2+vec2(1e-3,0.0))-brick,brickt2(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(1.1,1.1+bh*1.0,brick);\n    vec2 nn=vec2(smoothNoise2(p*4.0),smoothNoise2(p*10.0+vec2(23.0)))*4.0;\n    col*=1.0+2.0*vec3(0.25,0.33,0.5)*smoothstep(0.5,1.0,smoothNoise2(p.yx*20.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    col*=1.0+1.0*vec3(0.4)*smoothstep(0.5,1.0,smoothNoise2(p.yx*2.0+nn)+smoothNoise2(p*7.0)*0.2)+smoothNoise2(p.yx*128.0)*0.3;\n\n    col+=vec3(0.1)*smoothstep(0.4,0.9,smoothNoise2(p.yx*40.0))*smoothstep(0.8,0.9,smoothNoise2(p*50.0));\n    col*=1.2;\n\n    col.rgb*=vec3(0.6)+vec3(0.3)*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    col.rgb*=vec3(1.0)+0.5*vec3(2.0,0.75,0.5)*max(0.0,1.0-abs(brick-0.6)*2.0)*1.0;\n\n    return col;\n}\n\nvec3 tex_wmcs(vec2 p)\n{\n    float s=mix(0.2,1.2,sqrt(smoothNoise2(p*3.0)));\n    vec3 col=mix(vec3(0.15,0.2,0.2)*0.4,vec3(0.2,0.15,0.11)*0.7*s,sqrt(max(0.0,smoothNoise2(p*8.0)+0.15*smoothNoise2(p*32.0))))*0.7;\n    vec2 p2=p*vec2(4.0,10.0)+vec2(smoothNoise2(p*24.0),smoothNoise2(p*24.0+vec2(2.0)))*0.02;\n    p2.x+=floor(p2.y)*0.5;\n\n    float bh=pow(0.5+0.5*cos(floor(p2.y)*14.0)*cos(floor(p2.x)*1.0),2.0);\n\n    float brick=brickt(p2);\n    vec3 bn=normalize(vec3(brickt(p2+vec2(1e-3,0.0))-brick,brickt(p2+vec2(0.0,1e-3))-brick,0.04));\n\n    col*=mix(0.9,1.4+bh*1.0,brick);\n    col*=1.0+0.4*smoothstep(0.8,0.9,smoothNoise2(p.yx*20.0)+smoothNoise2(p*70.0)*0.2)+smoothNoise2(p.yx*128.0)*0.4;\n    col*=1.0+0.5*smoothstep(0.8,0.9,smoothNoise2(p.yx*60.0)+smoothNoise2(p*7.0)*0.15)+smoothNoise2(p.yx*64.0)*0.2;\n    col*=1.1;\n    col+=vec3(0.2)*smoothstep(0.4,0.9,smoothNoise2(p.yx*20.0))*smoothstep(0.8,0.9,smoothNoise2(p*40.0));\n\n    col.rgb*=0.5+0.5*dot(bn,normalize(vec3(1.0,-1.0,1.0)));\n\n    col.rgb*=1.0+max(0.0,1.0-abs(brick-0.7)*2.0);\n\n    return col;\n}\n\nvec2 rotate(float angle, vec2 v)\n{\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\n// Distance to a (non-rounded) cuboid.\nfloat cuboid(vec3 p,vec3 a,vec3 b)\n{\n    vec3 d=abs(p-(a+b))-(b-a);\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat smallerTower0(vec3 p)\n{\n    float d=1e5;\n    p.xz=abs(p.xz);\n\n    {\n        float d2=dot(p.xz,normalize(vec2(1.0)))-(-1285.0 - -1680.0);\n        d=min(d,max(d2,p.y-(4257.0-2880.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(-1285.0- -1680.0),4257.0 - 2880.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(4371.0-4257.0),-(-1088.0 - -1285.0)).xzy));\n        d=min(d,max(d2,p.y-(4371.0-2880.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*0.0,5404.0 - 2880.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*-(4371.0 - 5404.0),(-1088.0 - -1680.0)).xzy));\n        d=min(d,max(d2,abs(p.y-((4371.0+5404.0)*0.5-2880.0))-(5404.0-4371.0)*0.5));\n    }\n\n    return d;\n}\n\nfloat smallerTower(vec3 p)\n{\n    p-=vec3(-1680, 2880, -448);\n    vec3 p2=vec3(dot(normalize(vec2(1.0)),p.xz),p.y,dot(normalize(vec2(1.0,-1.0)),p.xz));\n\n    return max(smallerTower0(p),smallerTower0(p2));\n}\n\nfloat tower0(vec3 p)\n{\n    float d=1e5;\n    p.xz=abs(p.xz);\n\n    {\n        float d2=dot(p.xz,normalize(vec2(1.0)))-(2166.0-1536.0);\n        d=min(d,max(d2,p.y-(7639.0-5440.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(2166.0-1536.0),7639.0-5440.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(7822.0-7639.0),-(2482.0-2166.0)).xzy));\n        d=min(d,max(d2,p.y-(7639.0-5440.0)));\n    }\n\n    {\n        float d2=dot(p-(vec3(normalize(vec2(1.0))*(2482.0-1536.0),7822.0-5440.0).xzy),\n                     normalize(vec3(normalize(vec2(1.0))*(9472.0-7822.0),(2482.0-1536.0)).xzy));\n        d=min(d,max(d2,abs(p.y-((7822.0+9472.0)*0.5-5440.0))-(9472.0-7822.0)*0.5));\n    }\n\n    return d;\n}\n\nfloat tower(vec3 p)\n{\n    p-=vec3(1536, 5440, -192);\n    vec3 p2=vec3(dot(normalize(vec2(1.0)),p.xz),p.y,dot(normalize(vec2(1.0,-1.0)),p.xz));\n\n    return max(tower0(p),tower0(p2));\n}\n\nfloat mountains(vec3 p)\n{\n    p=(p-vec3(640.0,28.0,65.0)).xzy;\n\n    p.y+=smoothNoise2(p.xz*20e-4)*500.0;\n\n    return dot(vec2(length(p.xz),p.y+5000.0), normalize(vec2(-1.8,1.0)))*0.75;\n}\n\n\nfloat sceneMaterial(vec3 p)\n{\n    p=p.xzy;\n\n    float material2=step(mountains(p),2.0)*2.0;\n\n    // Name=Brush1247\n    float material_d=min(cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00)),\n                         cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00)));\n\n    // Name=Brush72\n    material_d=min(material_d,smallerTower(p.xzy));\n\n    return max(material2,max(step(material_d,1.0+step(-1600.0,p.y)),step(7640.0,p.z)));\n}\n\n// The distance to the level geometry covering the whole scene. Most of the code in this\n// function was generated by my tool.\nfloat scene(vec3 p)\n{\n    float d=-1e5;\n    p=p.xzy;\n\n    d=max(d,2.0-cuboid(p,vec3(-3020.00,-2984.00,64.00),vec3(2996.00,3032.00,5504.00))); // Name=Brush1244\n    d=min(d,mountains(p));\n\n    // Name=Brush1247\n    d=min(d,cuboid(p,vec3(-432.00,-864.00,800.00),vec3(1232.00,416.00,1880.00))); // Name=Brush852\n    d=max(d,2.0-cuboid(p,vec3(-416.00,-848.00,1856.00),vec3(1216.00,400.00,1880.00))); // Name=Brush856\n    d=min(d,cuboid(p,vec3(-304.00,-736.00,1856.00),vec3(1104.00,288.00,2208.00))); // Name=Brush858\n    d=min(d,cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00))); // Name=Brush854\n    d=min(d,cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00))); // Name=Brush860\n    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 2406.554199,dot(p,vec3(-0.941742,0.000000,0.336336)) - 477.866821);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(472.00,-992.00,1696.00),vec3(552.00,-864.00,2144.00)))); // Name=Brush82\n    }\n    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 1653.160645,dot(p,vec3(-0.941742,0.000000,0.336336)) - 1231.260254);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(72.00,-992.00,1696.00),vec3(152.00,-864.00,2144.00)))); // Name=Brush84\n    }\n    d=min(d,cuboid(p,vec3(-1128.00,-608.00,1248.00),vec3(-360.00,160.00,1472.00))); // Name=Brush86\n    d=min(d,cuboid(p,vec3(-1896.00,-608.00,672.00),vec3(-1128.00,16.00,1152.00))); // Name=Brush88\n    d=max(d,2.0-cuboid(p,vec3(-1880.00,-592.00,1120.00),vec3(-1368.00, 0.00,1152.00))); // Name=Brush90\n    d=max(d,2.0-cuboid(p,vec3(-1112.00,-592.00,1440.00),vec3(-440.00,144.00,1472.00))); // Name=Brush92\n    d=min(d,cuboid(p,vec3(-1752.00,-480.00,1120.00),vec3(-1368.00,-96.00,1376.00))); // Name=Brush94\n    d=min(d,cuboid(p,vec3(-1160.00,-640.00,672.00),vec3(-1000.00,-480.00,1568.00))); // Name=Brush113\n    d=min(d,cuboid(p,vec3(-1160.00,32.00,672.00),vec3(-1000.00,192.00,1568.00))); // Name=Brush105\n    d=min(d,cuboid(p,vec3(-424.00,288.00,672.00),vec3(1256.00,736.00,2208.00))); // Name=Brush106\n    d=max(d,2.0-cuboid(p,vec3(-408.00,288.00,1856.00),vec3(-296.00,400.00,2016.00))); // Name=Brush107\n    d=max(d,2.0-cuboid(p,vec3(1112.00,288.00,1856.00),vec3(1224.00,400.00,2016.00))); // Name=Brush108\n    d=max(d,2.0-cuboid(p,vec3(-232.00,-672.00,1856.00),vec3(1048.00,288.00,2208.00))); // Name=Brush118\n    d=min(d,cuboid(p,vec3(-808.00,-416.00,1440.00),vec3(-424.00,-32.00,1880.00))); // Name=Brush109\n    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2313.337891,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.897705,max(dot(p,vec3(0.847998,-0.000000,-0.529999)) - -1960.569824,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543457)));\n     d=min(d,max(pls,cuboid(p,vec3(-76.00,-1072.00,2208.00),vec3(284.00,-592.00,2400.00)))); // Name=Brush120\n    }\n    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2991.736328,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.898071,max(dot(p,vec3(0.847999,-0.000000,-0.529998)) - -1282.169800,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543701)));\n     d=min(d,max(pls,cuboid(p,vec3(324.00,-1072.00,2208.00),vec3(684.00,-592.00,2400.00)))); // Name=Brush121\n    }\n    d=min(d,cuboid(p,vec3(224.00,-936.00,1920.00),vec3(384.00,-912.00,1952.00))); // Name=Brush122\n    d=min(d,cuboid(p,vec3(408.00,-480.00,1856.00),vec3(1112.00,736.00,2720.00))); // Name=Brush123\n    d=max(d,2.0-cuboid(p,vec3(-64.00,-1056.00,2360.00),vec3(272.00,-608.00,2400.00))); // Name=Brush124\n    d=max(d,2.0-cuboid(p,vec3(336.00,-1056.00,2360.00),vec3(672.00,-608.00,2400.00))); // Name=Brush125\n    d=min(d,cuboid(p,vec3(472.00,-592.00,2304.00),vec3(600.00,-480.00,2400.00))); // Name=Brush126\n    d=max(d,2.0-cuboid(p,vec3(488.00,-608.00,2360.00),vec3(584.00,-480.00,2400.00))); // Name=Brush127\n    d=min(d,cuboid(p,vec3(284.00,-864.00,2304.00),vec3(324.00,-736.00,2400.00))); // Name=Brush128\n    d=max(d,2.0-cuboid(p,vec3(272.00,-848.00,2360.00),vec3(336.00,-752.00,2400.00))); // Name=Brush129\n    d=max(d,2.0-cuboid(p,vec3(72.00,-1072.00,2360.00),vec3(136.00,-1056.00,2400.00))); // Name=Brush130\n    d=max(d,2.0-cuboid(p,vec3(472.00,-1072.00,2360.00),vec3(536.00,-1056.00,2400.00))); // Name=Brush131\n    { float pls=max(dot(p,vec3(0.664365,0.000000,0.747409)) - 3130.480957,dot(p,vec3(-0.664365,0.000000,0.747409)) - 2322.613525);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(232.00,-944.00,1568.00),vec3(376.00,-720.00,1824.00)))); // Name=Brush132\n    }\n    d=max(d,2.0-cuboid(p,vec3(24.00,-720.00,1568.00),vec3(600.00,-544.00,1824.00))); // Name=Brush39\n    d=max(d,2.0-cuboid(p,vec3(488.00,-480.00,2360.00),vec3(584.00,-464.00,2504.00))); // Name=Brush40\n    d=max(d,2.0-cuboid(p,vec3(424.00,-464.00,2360.00),vec3(984.00,-192.00,2688.00))); // Name=Brush41\n    d=max(d,2.0-cuboid(p,vec3(424.00,288.00,2208.00),vec3(760.00,720.00,2688.00))); // Name=Brush46\n    d=max(d,2.0-cuboid(p,vec3(408.00,552.00,2208.00),vec3(424.00,680.00,2336.00))); // Name=Brush93\n    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,2192.00),vec3(408.00,720.00,2208.00))); // Name=Brush49\n    d=max(d,2.0-cuboid(p,vec3(280.00,288.00,2192.00),vec3(408.00,304.00,2208.00))); // Name=Brush50\n    { float pls=dot(p,vec3(0.000000,0.316228,0.948683)) - 4690.290527;\n     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(632.00,600.00,2376.00)))); // Name=Brush53\n    }\n    { float pls=dot(p,vec3(-0.406138,0.000000,0.913812)) - 3651.997070;\n     d=min(d,max(pls,cuboid(p,vec3(472.00,600.00,2208.00),vec3(616.00,720.00,2272.00)))); // Name=Brush54\n    }\n    d=min(d,cuboid(p,vec3(616.00,480.00,2208.00),vec3(760.00,720.00,2272.00))); // Name=Brush55\n    d=min(d,cuboid(p,vec3(616.00,352.00,2208.00),vec3(760.00,416.00,2272.00))); // Name=Brush56\n\n    // Name=Brush58\n    d=min(d,tower(p.xzy));\n\n    { float pls=dot(p,vec3(0.000000,0.307820,0.951445)) - 4668.122559;\n     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(760.00,560.00,2360.00)))); // Name=Brush65\n    }\n    d=min(d,cuboid(p,vec3(-496.00,-2136.00,672.00),vec3(592.00,-1688.00,1584.00))); // Name=Brush66\n    d=max(d,2.0-cuboid(p,vec3(80.00,-1704.00,1448.00),vec3(144.00,-1688.00,1512.00))); // Name=Brush69\n    d=max(d,2.0-cuboid(p,vec3(-176.00,-1704.00,1448.00),vec3(-112.00,-1688.00,1512.00))); // Name=Brush70\n    d=max(d,2.0-cuboid(p,vec3(-432.00,-1704.00,1448.00),vec3(-368.00,-1688.00,1512.00))); // Name=Brush71\n\n    // Name=Brush72\n    d=min(d,smallerTower(p.xzy));\n\n    { float pls=max(dot(p,vec3(-0.707107,0.000000,-0.707106)) - 531.747742,max(dot(p,vec3(-0.000001,-0.707107,-0.707106)) - -1267.131348,max(dot(p,vec3(0.707107,-0.000000,-0.707106)) - -3880.601807,dot(p,vec3(-0.000000,0.707107,-0.707107)) - -2081.721680)));\n     d=min(d,max(pls,cuboid(p,vec3(-1848.00,-576.00,1376.00),vec3(-1272.00, 0.00,1568.00)))); // Name=Brush73\n    }\n    d=max(d,2.0-cuboid(p,vec3(-1831.53,-559.53,1536.00),vec3(-1288.47,-16.47,1568.00))); // Name=Brush866\n    d=min(d,cuboid(p,vec3(-1368.00,-352.00,1120.00),vec3(-1112.00,-96.00,1568.00))); // Name=Brush864\n    { float pls=dot(p,vec3(-0.316228,0.000000,-0.948683)) - -2028.916870;\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1368.00,-328.00,1440.00),vec3(-1112.00,-120.00,1568.00)))); // Name=Brush76\n    }\n    d=min(d,cuboid(p,vec3(152.00,-560.00,1568.00),vec3(176.00,-544.00,1824.00))); // Name=Brush95\n    d=min(d,cuboid(p,vec3(448.00,-560.00,1568.00),vec3(472.00,-544.00,1824.00))); // Name=Brush97\n    d=min(d,cuboid(p,vec3(176.00,-544.00,1568.00),vec3(448.00,-536.00,1824.00))); // Name=Brush99\n    d=min(d,cuboid(p,vec3(232.00,-804.00,1706.00),vec3(376.00,-796.00,1718.00))); // Name=Brush155\n    { float pls=max(dot(p,vec3(0.000000,-0.470588,0.882353)) - 3512.470703,dot(p,vec3(0.000000,0.454709,-0.890640)) - -3531.819092);\n     d=min(d,max(pls,cuboid(p,vec3(-232.00,48.00,2016.00),vec3(264.00,288.00,2144.00)))); // Name=Brush159\n    }\n    d=max(d,2.0-cuboid(p,vec3(-616.00,-400.00,1856.00),vec3(-408.00,-48.00,1880.00))); // Name=Brush167\n    d=min(d,cuboid(p,vec3(-664.00,-288.00,1856.00),vec3(-520.00,-160.00,2048.00))); // Name=Brush168\n    d=max(d,2.0-cuboid(p,vec3(-664.00,-256.00,1856.00),vec3(-520.00,-192.00,2016.00))); // Name=Brush169\n    { float pls=max(dot(p,vec3(0.229039,0.000000,-0.973417)) - -3312.824951,dot(p,vec3(-0.229039,0.000000,0.973417)) - 3530.870605);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1384.00,-328.00,1376.00),vec3(-1112.00,-240.00,1552.00)))); // Name=Brush265\n    }\n    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,1856.00),vec3(1240.00,416.00,2016.00))); // Name=Brush323\n    d=min(d,cuboid(p,vec3(-1384.00,-352.00,1505.50),vec3(-1309.00,-240.00,1568.00))); // Name=Brush353\n    { float pls=dot(p,vec3(-0.311770,0.000000,-0.950157)) - -2045.926514;\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-1400.00,-240.00,1525.50),vec3(-1368.00,-120.00,1536.00)))); // Name=Brush355\n    }\n    d=max(d,2.0-cuboid(p,vec3(88.00,-608.00,2360.00),vec3(152.00,-592.00,2400.00))); // Name=Brush360\n    d=max(d,2.0-cuboid(p,vec3(384.00,-896.00,1568.00),vec3(392.00,-864.00,1584.00))); // Name=Brush523\n    d=max(d,2.0-cuboid(p,vec3(232.00,-896.00,1568.00),vec3(240.00,-864.00,1584.00))); // Name=Brush524\n    // Name=Brush784\n    // Name=Brush785\n    d=min(d,cuboid(p,vec3(224.00,-1824.00,688.00),vec3(384.00,-864.00,1584.00))); // Name=Brush851\n    { float pls=max(dot(p,vec3(0.000000,0.576682,0.816969)) - 741.234497,dot(p,vec3(0.000000,-0.576682,0.816969)) - 3859.928955);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(224.00,-1488.00,736.00),vec3(384.00,-1216.00,1408.00)))); // Name=Brush853\n    }\n    d=min(d,cuboid(p,vec3(216.00,-1488.00,688.00),vec3(392.00,-1442.00,1312.00))); // Name=Brush855\n    { float pls=max(dot(p,vec3(0.000000,0.536233,-0.844070)) - -3762.050537,dot(p,vec3(0.000000,-0.576683,0.816968)) - 3859.932861);\n     d=min(d,max(pls,cuboid(p,vec3(216.00,-1488.00,1312.00),vec3(392.00,-1352.00,1408.00)))); // Name=Brush857\n    }\n    { float pls=max(dot(p,vec3(0.000000,-0.536233,-0.844070)) - -862.103333,dot(p,vec3(0.000000,0.576683,0.816968)) - 741.230042);\n     d=min(d,max(pls,cuboid(p,vec3(216.00,-1352.00,1312.00),vec3(392.00,-1216.00,1408.00)))); // Name=Brush859\n    }\n    d=min(d,cuboid(p,vec3(216.00,-1262.00,688.00),vec3(392.00,-1216.00,1312.00))); // Name=Brush861\n    d=max(d,2.0-cuboid(p,vec3(232.00,-1824.00,1568.00),vec3(376.00,-864.00,1584.00))); // Name=Brush865\n    d=max(d,2.0-cuboid(p,vec3(-480.00,-2112.00,1568.00),vec3(576.00,-1704.00,1584.00))); // Name=Brush867\n    d=min(d,cuboid(p,vec3(376.00,-1728.00,1376.00),vec3(456.00,-1648.00,1632.00))); // Name=Brush67\n    d=min(d,cuboid(p,vec3(152.00,-1728.00,1376.00),vec3(232.00,-1648.00,1632.00))); // Name=Brush68\n    d=min(d,cuboid(p,vec3(224.00,-1448.00,872.00),vec3(384.00,-1256.00,928.00))); // Name=Brush1140\n    { float pls=max(dot(p,vec3(-0.832049,0.000000,0.554702)) - 2658.138916,dot(p,vec3(0.832049,0.000000,0.554702)) - 5187.567871);\n     d=max(d,2.0-max(pls,cuboid(p,vec3(728.00,-416.00,3392.00),vec3(792.00,-384.00,3536.00)))); // Name=Brush1229\n    }\n    { float pls=dot(p,vec3(-0.707107,0.000000,-0.707107)) - -1448.154785;\n     d=min(d,max(pls,cuboid(p,vec3(-544.00,-592.00,1440.00),vec3(-416.00,-400.00,1696.00)))); // Name=Brush57\n    }\n    d=max(d,2.0-cuboid(p,vec3(-544.00,-544.00,1440.00),vec3(-400.00,-416.00,1552.00))); // Name=Brush60\n    { float pls=dot(p,vec3(0.000000,-0.780869,-0.624695)) - -1214.406372;\n     d=min(d,max(pls,cuboid(p,vec3(-432.00,-464.00,1492.00),vec3(-352.00,-416.00,1552.00)))); // Name=Brush63\n    }\n    { float pls=dot(p,vec3(0.000000,0.780869,-0.624695)) - -2713.674805;\n     d=min(d,max(pls,cuboid(p,vec3(-432.00,-544.00,1492.00),vec3(-352.00,-496.00,1552.00)))); // Name=Brush74\n    }\n    { float pls=max(dot(p,vec3(-0.975610,-0.000000,0.219512)) - 282.536896,max(dot(p,vec3(0.871576,0.000000,0.490261)) - 2339.308105,max(dot(p,vec3(-0.800001,-0.000000,0.599999)) - 1638.397461,dot(p,vec3(-0.284087,0.000000,0.958798)) - 3174.972900)));\n     d=max(d,2.0-max(pls,cuboid(p,vec3(208.00,-2848.00,1568.00),vec3(400.00,-2112.00,1760.00)))); // Name=Brush465\n    }\n    // Name=Brush869\n    // Name=Brush862\n    d=min(d,cuboid(p,vec3(-844.00,-228.00,2664.00),vec3(-836.00,-220.00,2920.00))); // Name=Brush100\n    d=min(d,cuboid(p,vec3(1220.00,-860.00,1856.00),vec3(1228.00,-852.00,2112.00))); // Name=Brush10\n    // Name=Brush1175\n    // Name=Brush111\n    // Name=Brush114\n    // Name=Brush115\n    // Name=Brush116\n    // Name=Brush117\n    // Name=Brush119\n    d=min(d,cuboid(p,vec3(408.00,-480.00,2720.00),vec3(424.00,736.00,2752.00))); // Name=Brush110\n    d=min(d,cuboid(p,vec3(1096.00,-480.00,2720.00),vec3(1112.00,736.00,2752.00))); // Name=Brush112\n    d=min(d,cuboid(p,vec3(424.00,720.00,2720.00),vec3(1096.00,736.00,2752.00))); // Name=Brush42\n    d=min(d,cuboid(p,vec3(424.00,-480.00,2720.00),vec3(1096.00,-464.00,2752.00))); // Name=Brush43\n    // Name=Brush101\n    { float pls=dot(p,vec3(0.000000,-0.430730,0.902481)) - 3708.376465;\n     d=min(d,max(pls,cuboid(p,vec3(280.00,-416.00,1856.00),vec3(408.00,288.00,2192.00)))); // Name=Brush51\n    }\n    { float pls=dot(p,vec3(0.000000,-0.431455,0.902134)) - 3735.306152;\n     d=min(d,max(pls,cuboid(p,vec3(264.00,-448.00,1856.00),vec3(280.00,288.00,2208.00)))); // Name=Brush52\n    }\n    // Name=Brush1\n    d=min(d,cuboid(p,vec3(188.00,-1692.00,1408.00),vec3(196.00,-1684.00,1664.00))); // Name=Brush9\n    d=min(d,cuboid(p,vec3(412.00,-1692.00,1408.00),vec3(420.00,-1684.00,1664.00))); // Name=Brush44\n    d=max(d,2.0-cuboid(p,vec3(1096.00,520.00,2736.00),vec3(1112.00,648.00,2752.00))); // Name=Brush91\n    { float pls=max(dot(p,vec3(-0.195090,0.980785,0.000000)) - 668.334656,max(dot(p,vec3(0.195090,-0.980785,0.000000)) - -604.334656,max(dot(p,vec3(0.980785,0.195091,-0.000000)) - 2393.832764,dot(p,vec3(-0.980785,-0.195091,0.000000)) - -2361.832764)));\n     d=min(d,max(pls,cuboid(p,vec3(1093.03,526.75,2736.00),vec3(1114.97,561.25,2752.00)))); // Name=Brush61\n    }\n    d=min(d,cuboid(p,vec3(1069.26,618.11,2719.03),vec3(1106.74,645.89,2752.97))); // Name=Brush64\n    { float pls=max(dot(p,vec3(-0.471398,0.881921,0.000000)) - 73.059395,max(dot(p,vec3(0.471398,-0.881921,0.000000)) - -9.059571,max(dot(p,vec3(0.881922,0.471395,-0.000000)) - 2450.862061,dot(p,vec3(-0.881922,-0.471395,0.000000)) - -2418.862305)));\n     d=min(d,max(pls,cuboid(p,vec3(1049.40,574.12,2720.00),vec3(1078.60,609.88,2736.00)))); // Name=Brush75\n    }\n    // Name=Brush78\n    // Name=Brush80\n    d=max(d,2.0-cuboid(p,vec3(800.00,720.00,2736.00),vec3(928.00,736.00,2752.00))); // Name=Brush83\n    { float pls=max(dot(p,vec3(-0.773011,0.634392,0.000000)) - -355.351471,max(dot(p,vec3(0.773011,-0.634392,0.000000)) - 419.351379,max(dot(p,vec3(0.634392,0.773011,-0.000000)) - 2217.433838,dot(p,vec3(-0.634392,-0.773011,0.000000)) - -2185.433838)));\n     d=min(d,max(pls,cuboid(p,vec3(830.56,711.67,2736.00),vec3(865.44,744.33,2752.00)))); // Name=Brush85\n    }\n    { float pls=max(dot(p,vec3(-0.923879,-0.382685,0.000000)) - -2156.288574,max(dot(p,vec3(0.923879,0.382685,-0.000000)) - 2220.288574,max(dot(p,vec3(-0.382683,0.923880,0.000000)) - 616.273071,dot(p,vec3(0.382683,-0.923880,0.000000)) - -584.272949)));\n     d=min(d,max(pls,cuboid(p,vec3(878.16,682.49,2720.00),vec3(913.84,709.51,2736.00)))); // Name=Brush87\n    }\n    { float pls=max(dot(p,vec3(-0.509803,0.000000,0.860291)) - 2943.598877,max(dot(p,vec3(0.947492,0.000000,0.319779)) - -100.432518,max(dot(p,vec3(-0.975610,0.000000,-0.219512)) - 888.975403,dot(p,vec3(-0.970143,0.000000,0.242536)) - 1967.017944)));\n     d=max(d,2.0-max(pls,cuboid(p,vec3(-720.00,1632.00,1104.00),vec3(-464.00,1888.00,1360.00)))); // Name=Brush259\n    }\n    d=min(d,cuboid(p,vec3(-720.00,1696.00,1104.00),vec3(-568.00,1888.00,1164.00))); // Name=Brush402\n    d=min(d,cuboid(p,vec3(-720.00,1696.00,1164.00),vec3(-568.00,1712.00,1180.00))); // Name=Brush467\n    d=min(d,cuboid(p,vec3(-584.00,1816.00,1164.00),vec3(-568.00,1888.00,1180.00))); // Name=Brush469\n    d=min(d,cuboid(p,vec3(-720.00,1712.00,1164.00),vec3(-704.00,1888.00,1180.00))); // Name=Brush470\n    { float pls=dot(p,vec3(-0.355995,0.000000,0.934488)) - 3215.349365;\n     d=min(d,max(pls,cuboid(p,vec3(-736.00, 4.00,1440.00),vec3(-568.00,108.00,1504.00)))); // Name=Brush48\n    }\n    d=max(d,2.0-cuboid(p,vec3(-702.67,1888.00,1164.00),vec3(-576.00,2176.00,1284.00))); // Name=Brush2\n    // Name=Brush133\n\n    d=min(d,p.z-1400.0);\n\n    return d;\n}\n\n// The camera position and Euler angles for a given point in time. The original spline\n// control points are accessible in the original level data, but it was too costly to store\n// them in the shader so I manually created an approximate path with some custom additions.\nvoid cameraPoint(float t, inout vec3 pos, inout vec3 rot)\n{\n    t=mod(t,29.0);\n\n    pos.y=3300.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-8.0)-2.0)*0.25)) * 2500.0;\n    pos.y-=(1.0-smoothstep(0.0,1.0,(abs(t-15.0)-0.8)*0.5)) * 1200.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-3.5)-0.0))) * 1000.0;\n    pos.y+=(1.0-smoothstep(0.0,1.0,(abs(t-18.0))*0.25)) * 600.0;\n\n    pos.x=600.0;\n    pos.x-=(1.0-smoothstep(0.0,1.0,(abs(t-7.0)-0.7)*0.35)) * 3000.0;\n    pos.x+=(1.0-smoothstep(0.0,1.0,(abs(t-12.0)-2.0)*0.4)) * 3500.0;\n    pos.x-=(1.0-smoothstep(0.0,1.0,(abs(t-19.0)-0.0)*0.1)) * 2500.0;\n\n    pos.z=-4200.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-8.1))*0.122)) * 6000.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-15.0)-1.0)*0.5)) * 1000.0;\n    pos.z+=(1.0-smoothstep(0.0,1.0,(abs(t-19.0)-0.5)*0.2)) * 600.0;\n\n    rot.x=0.0;\n    rot.x+=(1.0-smoothstep(0.0,1.0,abs(t-5.0)*0.5-0.0))*0.5;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-10.0)*0.25-0.0))*0.15;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-3.5)*0.75-0.0))*0.4;\n    rot.x-=(1.0-smoothstep(0.0,1.0,abs(t-2.0)*0.3-0.0))*0.1;\n    rot.x-=(1.0-smoothstep(0.0,1.0,(abs(t-20.0)-1.0)*0.25))*0.1;\n    rot.x+=(1.0-smoothstep(0.0,1.0,(abs(t-9.0)-1.0)))*0.1;\n    rot.x+=(1.0-smoothstep(0.0,1.0,(abs(t-12.0)-1.0)))*0.3;\n    rot.x-=(1.0-smoothstep(0.0,1.0,(abs(t-8.0))))*0.15;\n\n    rot.y=1.0;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-5.0)*0.5-0.0))*0.5;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-8.0)*0.5-1.0))*1.3;\n    rot.y+=(1.0-smoothstep(0.0,1.0,abs(t-13.0)*0.5-1.0))*0.4;\n    rot.y-=(1.0-smoothstep(0.0,1.0,abs(t-21.0)*0.5-1.5))*0.15;\n    rot.y-=(1.0-smoothstep(0.0,1.0,abs(t-10.0)*0.75))*0.9;\n    rot.y+=(1.0-smoothstep(0.0,1.0,(abs(t-14.0)*0.8)))*0.3;\n\n    rot.z-=(1.0-smoothstep(0.0,1.0,abs(t-20.0)*0.25-0.2))*0.1;\n    rot.z+=(1.0-smoothstep(0.0,1.0,abs(t-12.0)*0.3-0.0))*0.1;\n\n    rot.xz*=smoothstep(0.0,2.0,t)*(1.0-smoothstep(24.0,26.0,t));\n}\n\n\nfloat flareMask(vec2 p,vec2 o,vec2 d,float l,float r,float g)\n{\n    p-=o;\n    float u=dot(p,d);\n    float v=length(p-u*d);\n\n    return (1.0-(max(0.0,u)/l))*max(0.0,(smoothstep(-r,0.0,u)-smoothstep(l-r,l,u)-smoothstep(0.0,max(r,r+u*g),v)));\n}\n\nfloat fireFbm(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<3;i+=1)\n        f+=smoothNoise2(p*pow(2.0,float(i)))/pow(2.0,float(i+1));\n    return f;\n}\n\nvec3 fire(vec2 p, float tm)\n{\n    float a=0.0;\n\n    vec2 p2=p+vec2(cos(p.y*8.0-tm*3.0)*0.05*clamp(p.y,0.0,1.0),0.0);\n    float fn=fireFbm(p2*5.0+vec2(0.0,-tm*4.2));\n    float fm=flareMask(p2,vec2(0.0),vec2(0.0,1.0),1.1,0.3,0.0);\n    fm*=smoothstep(0.0,0.1,p.y)*(1.0-smoothstep(0.0,max(0.0,0.5-p.y*0.4),abs(p.x)));\n    a+=pow(mix(fm*pow(max(0.0,fn),4.0),fm,fm*fm*0.9),0.4)*1.25;\n\n    a*=0.9;\n\n    return mix(vec3(1.4,0.25,0.2)*0.9,vec3(1.5,1.5,0.6),a)*a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - vec2(1.0);\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Set up the primary ray.\n    vec3 rd=normalize(vec3(uv.xy,-1.52));\n    vec3 ro=vec3(0.0),angs=vec3(0.0);\n    cameraPoint(time*0.5,ro,angs);\n\n    rd.yz=rotate(angs.x*3.1415926,rd.yz);\n    rd.xy=rotate(angs.z*3.1415926,rd.xy);\n    rd.zx=rotate(angs.y*3.1415926,rd.zx);\n\n    // Raymarch through the scene.\n    float t=70.0,d=0.0;\n    vec3 rp=ro;\n    float material=0.0;\n    for(int i=0;i<130;i+=1)\n    {\n        rp=ro+rd*t;\n        d=scene(rp);\n        if(d<0.1)\n            break;\n        t+=d;\n    }\n\n    // Obtain distance field gradient for material selection.\n    float d3=scene(rp+vec3(0.0,0.1,0.0))-d;\n\n    // Obtain a material index for the shading point.\n    material = sceneMaterial(rp);\n\n    vec3 rp2=rp;\n    rp2.xz=rotate(3.1415926*0.125,rp2.xz);\n\n    vec2 mtc0 = rp.xz*0.004;\n    vec2 mtc1 = rp.xz*2e-3;\n    vec2 mtc2 = (rp2.xy+vec2(rp2.z,0.0))*1e-3*vec2(2.0,1.0);\n\n    vec3 col=vec3(1.0);\n    if(material > 1.5)\n    {\n        col=tex_wrck(vec2(abs(atan(rp.z,rp.x)/3.1415926-0.0)*8.0,rp.y*4e-4));\n    }\n    else if(d3>1e-2)\n    {\n        col=mix(tex_nfloor6(mtc0), tex_Roof(mtc0)*0.7,  material);\n    }\n    else\n    {\n        vec2 ttc=mix(mtc2, mtc1, step(d3, -1e-2));\n        col=mix(tex_wmcs(ttc), tex_wmbrrw(ttc * 2.0), material);\n    }\n\n    // Apply some good old ambient occlusion.\n    float ao = 1.0;\n    {\n        float ao_strength = 0.25, ao_eps = 80.0;\n        float w = ao_strength / ao_eps;\n        float dist = 2.0 * ao_eps;\n        for(int i = 0; i < 2; i++)\n        {\n            float d = scene(rp + normalize(vec3(-2.0,2.0,-4.0)) * dist);\n            ao -= (dist - d) * w;\n            w *= 0.5;\n            dist = dist * 2.0 - ao_eps;\n        }\n    }\n    ao=clamp(ao, 0.0, 1.0);\n\n\n    vec3 sun=vec3(0.5,0.5,0.4)*pow(0.5+0.5*dot(rd,normalize(vec3(-2.0,2.0,-4.0))),2.0);\n    vec3 absrp=abs(rp-vec3(-40.0,4028.0,65.0));\n    if(max(absrp.x,max(absrp.y,absrp.z))>6000.0)\n    {\n        vec2 cloudtc=rd.xz/rd.y;\n        fragColor.rgb=mix(vec3(0.0),vec3(0.3,0.3,0.4),0.5+0.5*rd.y)*0.75;\n        fragColor.rgb+=sun;\n        fragColor.rgb=mix(fragColor.rgb,vec3(1.0),(smoothNoise2(cloudtc*4.0)*0.25+\n                                                         smoothNoise2(cloudtc*2.0)*0.5+smoothNoise2(cloudtc))*max(0.0,rd.y));\n    }\n    else\n    {\n    \t// Obtain distance field gradient for lighting.\n        float d2=scene(rp+normalize(vec3(-1.0,10.0,-1.0)))-d;\n        \n        // Apply lighting and hardcoded shadows.\n        vec3 dl=vec3(0.2,0.2,0.4)*(0.3+max(0.0,0.7+d3*7.0))*4.0*mix(0.4,1.0,ao)*smoothstep(2000.0,9000.0,rp.y+1000.0);\n        dl+=vec3(0.5,0.5,0.4)*(0.5+max(0.0,0.3+d2*7.0))*0.9*ao*smoothstep(1000.0,8000.0,rp.y+1000.0);\n        dl+=vec3(0.1,0.15,0.1)*max(0.8,(0.5+max(0.1,10.0-d2*8.0)))*0.2*(1.0-smoothstep(1000.0,3500.0,rp.y+1000.0));\n        dl*=smoothstep(0.0,1200.0,distance(rp,vec3(604.0,3228.0,-546.0)));\n        dl*=max(step(-1345.855957,rp.z),smoothstep(400.0,800.0,distance(rp,vec3(804.0,3928.0,-946.0))));\n        dl*=smoothstep(200.0,900.0,distance(rp,vec3(1204.0,4028.0,1146.0)));\n        dl*=smoothstep(20.0,900.0,distance(rp,vec3(1905.0,3728.0,1046.0)));\n        {\n            vec3 lp=rp-vec3(604.0,3228.0,-3366.0);\n            lp.x=abs(lp.x);\n            float sh=max(smoothstep(-120.0,100.0,lp.y),smoothstep(1.0,10.0,length(max(vec2(0.0),abs(lp.xz-vec2(225.0,0.0))-vec2(100.0)))));\n            dl+=(0.9+0.1*cos(time*15.0))*sh*2.0*max(0.0,0.2+d3*17.0)*vec3(1.0,0.65,0.3)*(1.0-smoothstep(0.0,280.0,distance(lp,vec3(225.0,0.0,0.0))));\n        }\n        dl*=1.0-smoothstep(1000.0,15000.0,distance(rp.xz,vec2(604.080750,1366.0)));\n        fragColor.rgb=col*dl*1.7;\n    }\n\n    // Render the first flag.\n    {\n        flagTime=time;\n        float ft=(ro.z+454.0)/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x-=-1505.0;\n        frp.y-=5712.0;\n        frp.xy=frp.xy*4e-3;\n        if(abs(frp.x)<1.0 && abs(frp.y)<0.6)\n        {\n            vec4 fl=flagTexture(frp.xy);\n            fragColor.rgb=mix(fragColor.rgb,fl.rgb,fl.a*step(ft,t)*step(0.0,ft));\n        }\n    }\n\n\t// Render the second flag.\n    {\n        flagTime=time+10.0;\n        float ft=(ro.z+1720.0)/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x-=2614.0;\n        frp.y-=4095.0;\n        frp.xy=frp.xy*4e-3;\n        if(abs(frp.x)<1.0 && abs(frp.y)<0.6)\n        {\n            vec4 fl=flagTexture(frp.xy);\n            fragColor.rgb=mix(fragColor.rgb,fl.rgb,fl.a*step(ft,t)*step(0.0,ft));\n        }\n    }\n\n    // Apply some fog.\n    fragColor.rgb=mix(vec3(0.15,0.15,0.18)*4.2,fragColor.rgb,exp(-t*5e-6));\n\n\n    // Render the torch flames and their reflections.\n    {\n        float ft=(ro.z+3380.0)/-rd.z;\n        vec3 frp=ro+rd*ft;\n        frp.x=abs(frp.x-600.0);\n        frp.y-=3200.0;\n        float refl=step(frp.y,0.0);\n        frp.y=abs(frp.y);\n        frp.xy=(frp.xy-vec2(225.0,120.0))*4e-3;\n        if(abs(frp.x)<0.8 && abs(frp.y)<1.0)\n        {\n            vec3 ff=fire(frp.xy,time)*step(0.0,ft);\n            ff*=vec3((1.0-refl)*step(ft,t))+col*refl*step(0.0,rd.z)*1.5;\n            fragColor.rgb=mix(fragColor.rgb,vec3(0.0),clamp(dot(ff,vec3(1.0/3.0))*2.0,0.0,1.0));\n            fragColor.rgb+=ff;\n        }\n    }\n\n\n    fragColor.rgb+=vec3(1.0,0.6,0.3)*(1.0-smoothstep(0.0,0.5,abs(mod(time*0.5,29.0)-1.5)))*0.12;\n\n    fragColor.rgb+=sun*0.28;\n    fragColor.rgb*=1.25;\n}\n\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2SDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2SWD", "name": "Raymarch Tut Thingy - Oculus", "author": "squeakyneb", "description": "My simple raymarching shader with tutorial comments now with OCULUS SUPPORT!", "tags": ["raymarching", "example", "simple", "raymarched", "tutorial", "sample", "oculus", "rift", "dk2"], "likes": 3, "viewed": 512, "date": "1412329622", "time_retrieved": "2024-06-20T18:13:42.329743", "image_code": "const float EPS = 0.001; // this defines \"close enough\", because raymarching doesn't actually hit\nconst int MAXI = 100;\t // how much work we are willing to do (speed vs. accuracy)\nconst float MAXD = 30.; // if we are this far away from everything, we are lost in the skies of eternity\n\n// OK NOW YOU SHOULD GO SCROLL DOWN TO MAIN AND FOLLOW THE FUNCTION CALLS FROM THERE OK\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat scenedist(vec3 p){ // this defines what is actually in the scene\n\tfloat s1 = length(p)-1.; \t\t\t\t// this is just a sphere\n\tfloat s2 = length(p-vec3(1.,0.,0.))-0.3;// this is a smaller sphere, shifted x-wards\n\treturn min(s1,s2); // add them together (like boolean OR)\n\t// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t\t\t\t\t\t  // if you understand, good. if not, not much I can do.\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions godammit\n\t\t\tscenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),\n\t\t\tscenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),\n\t\t\tscenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));\n}\n\nvec3 renderworld(vec2 uv, float screen){ // this is where we do everything\n\t\n\t// put the camera somewhere\n\t// sin and cos are useful for making circles, so we spin around\n\tvec3 camPos = vec3(4.*sin(iTime),4.*cos(iTime),1.)-vec3(.0,.0,.0);\n\t// what to look at (the center for now)\n\tvec3 camTarg = vec3(0.);\n\t// which way is up? I like Z. This is world-relative for now.\n\tvec3 camUp = normalize(vec3(0.,0.,1.));\n\t\n\t// camera points to target from camera\n\t// remember that all directions must be normalised, or shit goes craycray\n\tvec3 camDir = normalize(camTarg - camPos);\n\t// right is perpendicular to up and forwards\n\tvec3 camRight = normalize(cross(camUp,camDir));\n\t// change UP to be relative to camera\n\tcamUp = normalize(cross(camDir,camRight));\n    \n    // shift camera for MAD 3D OCULUS RIFTING BRO\n    camPos += camRight*screen*0.1;\n\t\n\t// This pixel will cast ray in the camera direction, but a bit up/down and sidewise\n\tvec3 rayDir = normalize(camDir+uv.x*camRight+uv.y*camUp);\n\t\n\t// the first distance we will jump\n\tfloat dist = scenedist(camPos);\n\t// must maintain the total or we will not know where we hit when we do\n\tfloat total = dist;\n\t\n\t// now we march along the ray a lot\n\tfor(int i = 0;i<MAXI;i++){\n\t\tdist = scenedist(camPos+rayDir*total); // distance to closest thing (safe jump distance)\n\t\ttotal += dist;\t\t\t\t\t\t   // add it to our progress\n\t\tif(dist<EPS || dist>MAXD){continue;}   // quit if we hit something or are lost\n\t}\n\tvec3 dest = camPos+rayDir*total; // this is where we ended up\n\tvec3 c;\t\t\t\t\t\t\t // this will be our pixel colour\n\tif(dist<EPS){\t\t\t\t\t // if we score a hit\n\t\tc = getNormal(dest);         // we make colours\n\t\t\t\t\t\t\t\t\t // this is where your material and lighting shit goes when you are pro\n\t}else{\t\t\t\t\t\t\t // no hit, we are lost in the sky\n\t\tc = hsv(.55,smoothstep(-1.5,1.,uv.y),1.); // make teh pretty blue skies\n\t}\n\t\t\n\treturn c; // give the colour back\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // IS LIKE C(++), you start with the main\n{\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\t// the usual screen position thing\n    float screen = sign(uv.x-.5);\t\t\t\t// -1 for left eye, +1 for right eye\n    uv.x = mod(uv.x,0.5)*2.;\t\t\t\t\t// actually split the screen into two 0..1 ranges\n    uv = (uv-.5);\t\t\t\t\t\t\t\t// centre the coordinate system\n    uv.y /= (iResolution.x/2.)/iResolution.y;\t// add vertical space for aspect ratio thing\n    \n\t// step 1: figure out where you are\n\t// step 2: do everything else\n\tvec3 c = renderworld(uv,screen);\n\t\n\t// you can insert screen-space code here if you want. Blurs and shit are really expensive though.\n\t\n\tfragColor = vec4(c,1.0);// make this pixel pretty colours\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2SWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2SWW", "name": "Morph Demo", "author": "akaitora", "description": "Morph Demo", "tags": ["morphing"], "likes": 18, "viewed": 1475, "date": "1412226990", "time_retrieved": "2024-06-20T18:13:43.269053", "image_code": "// By: Brandon Fogerty\n// bfogerty at gmail dot com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float EPS = 0.01;\nconst int MAXI = 100;\n\nmat4 transpose( mat4 m )\n{\n\tmat4 t = mat4( vec4( m[0][0], m[1][0], m[2][0], m[3][0] ),\n\t\t\t\t   vec4( m[0][1], m[1][1], m[2][1], m[3][1] ),\n\t\t\t\t   vec4( m[0][2], m[1][2], m[2][2], m[3][2] ),\n\t\t\t\t   vec4( m[0][3], m[1][3], m[2][3], m[3][3] ) );\n\treturn t;\n}\n\nmat4 invert( mat4 mat )\n{\n\tvec3 right = \tvec3( mat[0][0], mat[0][1], mat[0][2] );  \n\tvec3 up = \t\tvec3( mat[1][0], mat[1][1], mat[1][2] );\n\tvec3 fwd = \t\tvec3( mat[2][0], mat[2][1], mat[2][2] );\n\tvec3 pos = \t\tvec3( mat[3][0], mat[3][1], mat[3][2] );\n\t\n\tmat4 t = transpose( mat );\n\t\n\tt[0][3] = -dot(right, pos);\n\tt[1][3] = -dot(right, pos);\n\tt[2][3] = -dot(right, pos);\n\t\n\treturn t;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat cube( vec3 ray, float r, mat4 transform )\n{\n\tvec3 rayPrime = vec3(transpose( transform ) * vec4(ray,1));\n\tfloat d = length(max(abs(rayPrime)-vec3(0.5,0.5,0.5),0.0))-r;\n\t\n\treturn d;\n}\n\nfloat sphere( vec3 ray, float r, mat4 transform )\n{\n\tvec3 rayPrime = vec3(invert( transform ) * vec4(ray,1));\n\tfloat d = length(rayPrime)-r;\n\t\n\treturn d;\n}\n\nfloat torus( vec3 ray, vec2 t, mat4 transform )\n{\n    vec3 rayPrime = vec3(invert( transform ) * vec4(ray,1));\n\tvec2 q = vec2(length(rayPrime.xz)-t.x,rayPrime.y);\n\treturn length(q)-t.y;\n}\n\nfloat SceneDist( vec3 ray )\n{\t\n\tfloat t = iTime;\n\tfloat c = cos( t );\n\tfloat s = sin( t );\n\t\n\tmat4 rotX = mat4(      vec4(1,0,0,0),\n\t\t\t\t\t\t   vec4(0,c,-s,0),\n\t\t\t\t\t\t   vec4(0,s,c,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 rotY = mat4(      vec4(c,0,-s,0),\n\t\t\t\t\t\t   vec4(0,1,0,0),\n\t\t\t\t\t\t   vec4(s,0,c,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 rotZ = mat4(      vec4(c,s,0,0),\n\t\t\t\t\t\t   vec4(-s,c,0,0),\n\t\t\t\t\t\t   vec4(0,0,1,0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 pos = mat4(       vec4(1,0,0,s*1.0),\n\t\t\t\t\t\t   vec4(0,1,0,0),\n\t\t\t\t\t\t   vec4(0,0,1,c*1.0),\n\t\t\t\t\t\t   vec4(0,0,0,1) );\n\t\n\tmat4 transform = pos * rotZ * rotY * rotY;\n\n\tfloat d1 = cube( ray, 0.15, transform );\n\t//float d2 = sphere( ray, 0.5, transform );\n    float d2 = torus( ray, vec2(0.7, 0.1), transform);\n\tfloat tVal = sin(iTime)*0.5+0.5;\n\tfloat final = mix(d1,d2, tVal);\n\t\n\treturn final;\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t\t\t\t\t\t  // if you understand, good. if not, not much I can do.\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions\n\t\t\tSceneDist(pos + eps.yxx) - SceneDist(pos - eps.yxx),\n\t\t\tSceneDist(pos + eps.xyx) - SceneDist(pos - eps.xyx),\n\t\t\tSceneDist(pos + eps.xxy) - SceneDist(pos - eps.xxy)));\n}\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 Lighting( vec3 camPos, vec3 pos, vec3 normal, vec3 diffuseColor )\n{\n\tvec3 lightPos = vec3(0,0,10);\n\tvec3 lightDir = normalize( lightPos - pos );\n\tvec3 viewDir = normalize( camPos - pos );\n\tvec3 lightAmbientColor = vec3(0.1,0.1,0.1);\n\tvec3 lightSpecularColor = vec3(1,1,1);\n\t\n\tvec3 halfDir = normalize(viewDir + lightDir);\n\t//float lightSpecularIntensity = pow( clamp(dot( normal, halfDir ), 0.0, 1.0), 2.0 );\n\tfloat lightSpecularIntensity = pow( clamp(dot( normal, reflect(lightDir, normal )), 0.0, 1.0), 80.0 );\n\t\n\tfloat lightDiffuseIntensity = clamp( dot( -normalize(pos), lightDir ), 0.00, 1.0);\n\t\n\t\n\treturn lightAmbientColor + (lightDiffuseIntensity * diffuseColor) + (lightSpecularIntensity * lightSpecularColor);\n\t\n}\n\nvec3 RenderScene( vec2 uv, vec2 fragCoord )\n{\n\tvec3 color = vec3(1,0,0);\n\t\n\t//vec3 camPos = vec3( sin(iTime) * 3.0, 0.0, cos(iTime) * 3.0);\n\tvec3 camPos = vec3(0,0,-3);\n\tvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 camUp = vec3(0,1.0,0);\n\tvec3 camFwd = normalize( camTarget - camPos );\n\tvec3 camRight = normalize( cross( camUp, camFwd ) );\n\tcamUp = normalize( cross( camRight, camFwd ) );\n\t\n\tfloat dist = SceneDist( camPos );\n\tfloat total = dist;\n\tvec3 rayDir = vec3( normalize( camFwd + camRight * uv.x + camUp * uv.y ) );\n\t\n\tfor(int i=0; i < MAXI; ++i)\n\t{\n\t\tdist = SceneDist( camPos + rayDir * total );\n\t\ttotal += dist;\n\t\t\n\t\tif( dist <= EPS )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvec3 dest = camPos + rayDir * total;\n\tif( dist <= EPS )\n\t{\n        float t = sin(iTime)*0.5+0.5;\n        vec3 diffuse = mix( vec3(1.0,0.0,0.0), vec3(1.0,1.0,0.0), t);\n\t\tcolor = Lighting( camPos, dest, getNormal( dest ), diffuse );\n\t}\n\telse\t\n\t{\n        vec2 p = floor( iTime + fragCoord.xy/iResolution.x*10.0 );\n        float s = mod( p.x + p.y, 2.0 );\n        vec3 bg0 = vec3(s,s,s);\n        \n        vec3 bg1 = hsv(.55,smoothstep(-1.5,1.,uv.y),1.);\n        \n        float t = sin(iTime) * 0.5 + 0.5;\n        color = mix( bg0, bg1, t);\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - 0.5) * vec2(2.0, 2.0 * iResolution.y / iResolution.x);\n\tvec3 color = RenderScene( uv,fragCoord );\n\t\n\t// Scan line\n\tcolor -= mod(fragCoord.y, 2.0) < 1.0 ? 0.5 : 0.0;\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2SWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2XDw", "name": "ShaderToyTest", "author": "dila", "description": "A test shader :)", "tags": ["3d"], "likes": 10, "viewed": 767, "date": "1412865870", "time_retrieved": "2024-06-20T18:13:43.269053", "image_code": "mat3 worldRotation() {\n\tfloat xang = iTime * 0.5;\n    float yang = iTime * 0.0;\n    float zang = iTime * 0.5;\n    \n\tmat3 zrot = mat3(\n    \tcos(zang), -sin(zang), 0.0,\n        sin(zang), cos(zang), 0.0,\n        0.0, 0.0, 1.0);\n    \n    mat3 yrot = mat3(\n        cos(yang), 0.0, -sin(yang),\n        0.0, 1.0, 0.0,\n        sin(yang), 0.0, cos(yang));\n\n    mat3 xrot = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(xang), -sin(xang),\n        0.0, sin(xang), cos(xang));\n    \n    return zrot * yrot * xrot;\n}\n\nvec3 viewToWorld(vec3 pos) {\n\tvec3 world = worldRotation() * pos;\n    world.z += iTime * 10.0;\n    return world;\n}\n\nvec3 worldToView(vec3 pos) {\n\tvec3 view = pos;\n    view.z -= iTime * 10.0;\n\treturn view * worldRotation();\n}\n\nvec2 dist(vec3 pos) {\n\tpos = viewToWorld(pos);\n    \n    float len = length(pos.xy);\n    float tun = len - 6.0;\n    \n    float theta = atan(pos.y, pos.x) * 20.0;\n    float phi =  (pos.z + theta) * 0.5;\n    \n    float disp = sin(phi) * sin(pos.z);\n    \n    float damp = pow(1.0 / (1.0 + abs(pos.z) * 0.1), 1.0);\n\n    tun += disp * (1.0 - damp);\n    \n    return vec2(tun,disp);\n}\n\nvec2 trace(vec3 ray) {\n    float t = 0.0;\n    vec2 disp;\n    for(int i = 0; i < 16; ++i){\n        disp = dist(ray * t);\n        t += abs(disp.x) * 0.5;\n    }\n    return vec2(t, disp.y);\n}\n\nvec3 normal(vec2 coord) {\n\tvec3 ray = vec3(coord.xy, 1.0);\n    float delta = 1.0 / iResolution.x;\n    \n    vec3 rhl = normalize(ray + vec3(-delta, 0.0, 0.0));\n    vec3 hl = rhl * trace(rhl).x;\n    \n    vec3 rhr = normalize(ray + vec3(delta, 0.0, 0.0));\n    vec3 hr = rhr * trace(rhr).x;\n    \n    vec3 rvl = normalize(ray + vec3(0.0, -delta, 0.0));\n    vec3 vl = rvl * trace(rvl).x;\n    \n    vec3 rvr = normalize(ray + vec3(0.0, delta, 0.0));\n    vec3 vr = rvr * trace(rvr).x;\n    \n    return normalize(cross(hr-hl, vr-vl));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 coord = (fragCoord.xy + 0.5) / iResolution.xy * 2.0 - 1.0;\n    coord.y *= iResolution.y / iResolution.x;\n    vec3 eye = normalize(vec3(coord.xy, 1.0));\n\n    vec2 alpha = trace(eye);\n    vec3 norm = normal(coord);\n    \n    vec3 view = eye * alpha.x;\n    vec3 world = viewToWorld(view);\n    \n    vec3 lighting = vec3(0.1,0.1,0.1);\n    vec3 glow = vec3(0.0,0.0,0.0);\n    \n    for (int i=-1; i<2; ++i) {\n        float lang = world.z * 0.5 + iTime * 3.0;\n        vec3 lpos = vec3(cos(lang)*sin(lang*2.0), sin(lang), 0.0) * 3.0;\n        float lightz = (floor(world.z/50.0)+float(i))* 50.0;\n        vec3 light = vec3(lpos.x, lpos.y, lightz);\n        vec3 surfaceToLight = light - world;\n        float lightDist = dot(surfaceToLight, surfaceToLight);\n        surfaceToLight = normalize(surfaceToLight);\n        float shine = 1.0 / (1.0 + lightDist * 0.01);\n        vec3 ref = surfaceToLight - 2.0 * norm * dot(surfaceToLight, norm);\n\n\t\tvec3 lcol = vec3(cos(world.z+iTime), sin(world.z), cos(world.z)) * 0.5 + 0.5;\n        \n        float spec = pow(0.3 + max(dot(eye, -ref),0.0), 8.0);\n        vec3 diff = vec3(sin(world.x), cos(world.x), sin(world.x)) * 0.5 + 0.5;\n        diff *= alpha.y * 0.5 + 0.5;    \n        \n        lighting += (diff + spec) * lcol * shine;\n        \n        vec3 viewLight = worldToView(light);\n        if (viewLight.z > 0.0) {\n            viewLight /= viewLight.z;\n            vec2 orbdiff = coord - viewLight.xy;\n        \tfloat dist = dot(orbdiff, orbdiff);\n        \tfloat orb = 1.0 / (1.0 + dist * 100.0);\n            orb = pow(0.1 + orb, 4.0);\n        \tglow += orb * lcol;\n        }\n    }\n    \n    float fog = 1.0 / (1.0 + alpha.x * 0.1);\n   \n    vec3 col = clamp(lighting * fog + glow, 0.0, 1.0);\n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2XDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2XRG", "name": "Insert a Hidden Meaning Here", "author": "caaaaaaarter", "description": "A little demo with some raymarched cubes.", "tags": ["raymarching", "reflection", "cubes"], "likes": 1, "viewed": 149, "date": "1413408109", "time_retrieved": "2024-06-20T18:13:43.699304", "image_code": "const float radius = 8.0;\nconst float lightingConstant = 16.0;\nfloat sphereRad = sin(iTime*0.4)*0.5+4.0;\n \nfloat intersectSphere(vec3 oc, vec3 dir)\n{\n    oc = oc - vec3(0.5,0.0,0.5);\n    float b = 2.0 * dot(dir, oc);\n    float c = dot(oc, oc) - sphereRad*sphereRad;\n    float disc = b * b - 4.0 * c;\n \n    if (disc < 0.0)\n        return -1.0;\n \n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n \n    float t0 = q;\n    float t1 = c / q;\n \n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n \n    // if t1 is less than zero, the object is in the ray's negative direction\n    // and consequently the ray misses the sphere\n    if (t1 < 0.0)\n        return -1.0;\n \n    // if t0 is less than zero, the intersection point is at t1\n    if (t0 < 0.0) {\n        return t1;\n    } else {\n        return t0; \n    }\n}\nvec4 realColorForRay(vec3 origin, vec3 direction, bool isSpherePass) {\n    vec3 skyCol = clamp(vec3(direction.y*0.5),0.0,1.0) + vec3(0.0,0.05,0.3);\n    vec4 col = vec4(skyCol,99999999999.0);\n    for (int i=0; i<=2; i++) {\n        for (float j=-radius; j<=radius; j+= 1.0) {\n            highp float dist = (j-origin[i])/direction[i];\n            if (dist > 0.0 && dist < col[3]) {\n                vec3 impactLocation = origin+direction*dist;\n                if (abs(impactLocation.x-0.5)>0.6 || abs(impactLocation.y-0.5)>0.6 || isSpherePass)\n                if (abs(impactLocation.x)<=9.0 && abs(impactLocation.y)<=9.0 && abs(impactLocation.z)<=9.0)\n                if ((i==0 || mod(impactLocation[0],2.0) < 1.0) && (i==1 || mod(impactLocation[1],2.0) < 1.0) && (i==2 || mod(impactLocation[2],2.0) < 1.0)) {\n                    col = vec4(vec3(0.8-length(impactLocation)/lightingConstant)+vec3(0.1,0.1,0.1),dist);\n                }\n            }\n        }\n    }\n    return col;\n}\nvec3 colorForRay(vec3 origin, vec3 direction) {\n    vec4 col = realColorForRay(origin,direction,false);\n\t\n    float sphereHitDist = intersectSphere(origin,direction);\n    if ((sphereHitDist < col[3]) && sphereHitDist != -1.0) {\n        col = vec4(vec3(0.07*sin(-iTime*0.5)+0.07)+realColorForRay(origin+direction*(sphereHitDist-0.1),refract(direction,normalize(origin+direction*sphereHitDist),sin(iTime*0.5)/4.0+0.75),true).rgb,sphereHitDist);\n    }\n    \n    return vec3(col.rgb)+vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    highp vec3 cameraOrigin = vec3(-sin(sin(iTime*2.1)*0.2)*9.0+0.5,0.5+cos(iTime*2.1)*1.0,-18.0+sin(iTime*0.04)*10.0);\n    highp vec3 cameraDirection  = normalize(vec3( (fragCoord.x/iResolution.x*512.0-256.0),(fragCoord.y/iResolution.x*512.0-(iResolution.y/iResolution.x*256.0)), 300.0));\n\n    \n\tfragColor = vec4(colorForRay(cameraOrigin,cameraDirection),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2XRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls2XWh", "name": "Infinisphere", "author": "hellochar", "description": "First sketch, playing around with raycasting. Couldn't figure out how to do shadows correctly though :(", "tags": ["3d", "raytracing", "spheres"], "likes": 1, "viewed": 137, "date": "1413152571", "time_retrieved": "2024-06-20T18:13:43.699304", "image_code": "float SPHERE_DISTANCE = 12.0;\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// distance from pos to the closest sphere's outline.\nfloat sphereMap( in vec3 pos ) {\n    vec3 actualPos = mod(pos, SPHERE_DISTANCE);\n    float spherePos = SPHERE_DISTANCE/2.0;// + 2.0 * cos((floor(pos.z / SPHERE_DISTANCE) + 1.0) * iTime / 4.0);\n    float radius = (1.0 +cos(iTime + pos.x / 60.0));\n    return length(actualPos - vec3(spherePos)) - radius;\n}\n\nfloat floorMap( in vec3 pos ) {\n    return pos.z + 10.0;\n}\n\nfloat map( in vec3 pos ) {\n    return min(sphereMap(pos), floorMap(pos));\n    // return sphereMap(pos);\n}\n\nvec3 normal( in vec3 pos, in float t) {\n    float e = 0.001 * t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPos( float t ) {\n    /*return vec3(0.3 * cos(t * 0.17),\n                -40.0 + 0.4 * sin(t * 0.4),\n                -12.0 + 1.9 * cos(t * 0.23)\n                );*/\n    float angle = iMouse.x / iResolution.x * 6.2831;\n    mat3 rotMatrix = rotationMatrix( vec3(0, 0.0, 1.0), angle);\n    return rotMatrix * vec3(60.0, 20.0, 0.0);\n}\n\nbool raycast( in vec3 rO, in vec3 rD, out float t ) {\n    bool hit = false;\n    for(int i = 0; i < 100; i++) {\n        float dist = map(rO + t * rD);\n        if(dist < 0.0) { // move outward in the normal's direction\n            vec3 norm = normal(rO+t*rD, t);\n            \n        }\n        if(dist < 0.01) {\n            hit = true;\n            break;\n        }\n        t += max(0.1, dist);\n    }\n    \n\treturn true;\n}\n\nfloat accumulateShadowFactor( in vec3 rO, in vec3 rD ) {\n    float strongestShadow = 0.0;\n    float t = 2.01 + 6.0;\n    for(int i = 0; i < 100; i++) {\n        float dist = map(rO + t*rD);\n        if(dist < 0.01) {\n            strongestShadow = max(strongestShadow, 100.0 / t);\n            break;\n        }\n        strongestShadow = max(strongestShadow, (1.0 / dist) / t);\n        t += max(0.1, dist);\n    }\n    return strongestShadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fovX = radians(60.0),\n          fovY = fovX * iResolution.y / iResolution.x;\n\tvec2 xy = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    vec3 camPosition = camPos(iTime);\n    vec3 camTarget = vec3(0.0, 0.0, iMouse.y / iResolution.y * 250.0 - 125.0);\n    vec3 up = vec3(0.0, .0, 1.0);\n    \n    vec3 camDirection = normalize(camTarget - camPosition),\n         camRight = cross(camDirection, up),\n    \t camUp = cross(camRight, camDirection);\n    \n    vec3 rO = camPosition;\n    \n    float angleX = -mix(0.0, fovX, xy.x);\n    float angleY = -mix(0.0, fovY, xy.y);\n    mat3 rotAroundUp = rotationMatrix(camUp, angleX);\n    // rotate camDirection to the correct X angle\n    vec3 rD = rotAroundUp * camDirection;\n    vec3 rotatedCamRight = rotAroundUp * camRight;\n    mat3 rotAroundRight = rotationMatrix(rotatedCamRight, angleY);\n    rD = rotAroundRight * rD;\n    \n    float t = 0.0;\n\tbool hit = raycast( rO, rD, t);\n    \n    vec3 dif1Dir = normalize(vec3(1.0, -1.0, 1.0));\n    vec3 ambientLight = vec3(0.2, 0.17, 0.14);\n    \n    vec3 fogColor = vec3(0.38, 0.40, 0.45);\n    float fogFactor = exp(-t / 200.0);\n    \n    vec3 col = vec3(0.0);\n    \n    if( hit ) {\n        vec3 norm = normal( rO + t*rD, t );\n        float dif1Comp = clamp(dot(dif1Dir, norm), 0.0, 1.0);\n        float shadowFactor = 0.0; //accumulateShadowFactor( rO + t*rD, dif1Dir);\n        \n    \tcol = ambientLight;\n        col += vec3(0.7, 0.75, 0.79) * dif1Comp * (1.0 - shadowFactor);\n        col = mix(col, fogColor, 1.0 - fogFactor);\n        \n        // col = vec3(clamp(abs(map(rO+t*rD)) * 100.0, 0.0, 1.0));\n    } else {\n        col = fogColor;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2XWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBGDK", "name": "Flare Mania", "author": "mu6k", "description": "A follow up to my other flare shader. This one is more abstract. It draws the halos in a for loop using noise functions.", "tags": ["flare2d"], "likes": 34, "viewed": 1225, "date": "1414741906", "time_retrieved": "2024-06-20T18:13:43.699304", "image_code": "\n\nvec4 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy);}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\nvec4 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);}\nvec4 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod);}\nvec4 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751),m);}\n\n#define t iTime\n\nvec3 flare(vec2 uv, vec2 pos, float seed, float size)\n{\n\tvec4 gn = noise(seed-1.0);\n\tgn.x = size;\n\tvec3 c = vec3(.0);\n\tvec2 p = pos;\n\tvec2 d = uv-p;\n\t\n\t\n\tc += (0.01+gn.x*.2)/(length(d));\n\t\n\tc += vec3(noise(atan(d.x,d.y)*256.9+pos.x*2.0).y*.25)*c;\n\t\n\tfloat fltr = length(uv);\n\tfltr = (fltr*fltr)*.5+.5;\n\tfltr = min(fltr,1.0);\n\t\n\tfor (float i=.0; i<20.; i++)\n\t{\n\t\tvec4 n = noise(seed+i);\n\t\tvec4 n2 = noise(seed+i*2.1);\n\t\tvec4 nc = noise (seed+i*3.3);\n\t\tnc+=vec4(length(nc));\n\t\tnc*=.65;\n\t\t\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tfloat ip = n.x*3.0+float(i)*.1*n2.y*n2.y*n2.y;\n\t\t\tfloat is = n.y*n.y*4.5*gn.x+.1;\n\t\t\tfloat ia = (n.z*4.0-2.0)*n2.x*n.y;\n\t\t\tvec2 iuv = (uv*(mix(1.0,length(uv),n.w*n.w)))*mat2(cos(ia),sin(ia),-sin(ia),cos(ia));\n\t\t\tvec2 id = mix(iuv-p,iuv+p,ip);\n\t\t\tc[i] += pow(max(.0,is-(length(id))),.45)/is*.1*gn.x*nc[i]*fltr;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy -.5;\n\tuv.x*= iResolution.x/ iResolution.y;\n\tuv *= 2.0;\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy -.5;\n\tmouse.x*= iResolution.x/ iResolution.y;\n\tmouse *= 2.0;\n\t\n\tvec3 color = vec3(.0);\n\t\n    vec2 pos;\n    if (iMouse.z < .5)\n    {\n        pos = vec2(sin(t),cos(t*.7));\n    }\n\n    else pos = mouse.xy;\n\t\n\t\tcolor += flare(uv,pos,t-mod(t,2.00),0.15)*vec3(1.9,1.9,2.4);\n\t\n\t\n\tcolor+=noise(fragCoord.xy).xyz*.01;\n\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBSDm", "name": "Inverse Bilinear", "author": "iq", "description": "Inverse bilinear interpolation: given a point p and a quad compute the bilinear coordinates of p in the quad. More info [url=http://www.iquilezles.org/www/articles/ibilinear/ibilinear.htm]in this article[/url].", "tags": ["2d", "interpolation", "bilinear"], "likes": 66, "viewed": 25860, "date": "1412646115", "time_retrieved": "2024-06-20T18:13:44.408628", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Inverse bilinear interpolation: given four points defining a quadrilateral, compute the uv\n// coordinates of any point in the plane that would give result to that point as a bilinear \n// interpolation of the four points.\n//\n// The problem can be solved through a quadratic equation. More information in this article:\n//\n// http://www.iquilezles.org/www/articles/ibilinear/ibilinear.htm\n\n\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Will not be in the range [0..1]^2 if the point is\n// outside the quad.\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation\n    if( abs(k2)<0.001 )\n    {\n        res = vec2( (h.x*k1+f.x*k0)/(e.x*k1-g.x*k0), -k0/k1 );\n    }\n    // otherwise, it's a quadratic\n\telse\n    {\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        \n        if( u<0.0 || u>1.0 || v<0.0 || v>1.0 )\n        {\n           v = (-k1 + w)*ik2;\n           u = (h.x - f.x*v)/(e.x + g.x*v);\n        }\n        res = vec2( u, v );\n    }\n    \n    return res;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    p -= a; b -= a;\n\treturn length( p-b*clamp(dot(p,b)/dot(b,b),0.0,1.0) );\n}\n\n// simple hash\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+3.0,n+7.0))*321.513); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3( 0.35 + 0.1*p.y );\n\n    // move points\n    vec2 a = cos( 1.11*iTime + vec2(0.1,4.0) );\n    vec2 b = cos( 1.13*iTime + vec2(1.0,3.0) );\n    vec2 c = cos( 1.17*iTime + vec2(2.0,2.0) );\n    vec2 d = cos( 1.15*iTime + vec2(3.0,1.0) );\n\n    // d = c+a-b; // enable this to test parallelograms\n    \n    // area of the quad\n    vec2 uv = invBilinear( p, a, b, c, d );\n    \n    // inside of quad if uv in [0..1]^2\n    if( max( abs(uv.x-0.5), abs(uv.y-0.5))<0.5 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    \n    // quad borders\n    float h = 2.0/iResolution.y;\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n \n    // dither\n    col += (1.0/255.0)*hash3(p.x+1920.0*p.y);\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBSWm", "name": "Waterworld", "author": "frankenburgh", "description": "Bird's eye view of a water-terrain-rendering with opacity of water depending on depth. Shadows on terrain and water (2 levels). Use Fullscreen! :)\nCLICK and MOVE MOUSE to:  X -> Change water height  /  Y -> Change water clarity.", "tags": ["waves", "terrain", "sea", "shadow", "water", "ocean", "fractals", "waterrendering", "fraction"], "likes": 148, "viewed": 7708, "date": "1412623403", "time_retrieved": "2024-06-20T18:13:45.596509", "image_code": "// Water + Terrain shader   \n// 10/2014 Created by Frank Hugenroth /frankenburgh/\n// 'hash' and 'noise' function by iq\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// V1.1  - added 'real' water height (hits terrain) and waterheight is visible on shadow\n//\n// CLICK and MOVE the MOUSE to:\n// X -> Change water height  /  Y -> Change water clarity.\n\n// some parameters....\n\nfloat coast2water_fadedepth = 0.10;\nfloat large_waveheight      = 0.50; // change to adjust the \"heavy\" waves\nfloat large_wavesize        = 4.;  // factor to adjust the large wave size\nfloat small_waveheight      = .6;  // change to adjust the small random waves\nfloat small_wavesize        = .5;   // factor to ajust the small wave size\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\nfloat water_glossylight_fact= 120.; // range [1..200]\nfloat particle_amount       = 70.;\nvec3 watercolor             = vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\nvec3 watercolor2            = vec3(0.06, 0.07, 0.11); // deep-water color (RGB, should be darker than the low-water color)\nvec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\nvec3 light;\n\n\n#define USETEXTUREHEIGHT 0\n//#define USETEXTUREHEIGHT 1\n\n\n// calculate random value\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 2d noise function\nfloat noise1( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n\nfloat height_map( vec2 p )\n{\n#if USETEXTUREHEIGHT\n  float f = 0.15+textureLod(iChannel2, p*0.6, 0.0).r*2.;\n#else\n  mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n  p = p*6.;\n  float f = 0.6000*noise1( p ); p = m*p*1.1;\n  f += 0.2500*noise1( p ); p = m*p*1.32;\n  f += 0.1666*noise1( p ); p = m*p*1.11;\n  f += 0.0834*noise( p ); p = m*p*1.12;\n  f += 0.0634*noise( p ); p = m*p*1.13;\n  f += 0.0444*noise( p ); p = m*p*1.14;\n  f += 0.0274*noise( p ); p = m*p*1.15;\n  f += 0.0134*noise( p ); p = m*p*1.16;\n  f += 0.0104*noise( p ); p = m*p*1.17;\n  f += 0.0084*noise( p );\n  const float FLAT_LEVEL = 0.525;\n  if (f<FLAT_LEVEL)\n      f = f;\n  else\n      f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\n#endif\n  return clamp(f, 0., 10.);\n}\n\nvec3 terrain_map( vec2 p )\n{\n  return vec3(0.7, .55, .4)+texture(iChannel1, p*2.).rgb*.5; // test-terrain is simply 'sandstone'\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height )\n{\n  vec2 p2 = p*large_wavesize;\n  vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float f = 0.6000*noise( p );\n  f += 0.2500*noise( p*m );\n  f += 0.1666*noise( p*m*m );\n  float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;\n\n  p *= small_wavesize;\n  f = 0.;\n  float amp = 1.0, s = .5;\n  for (int i=0; i<9; i++)\n  { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\n \n  return wave+f*small_waveheight;\n}\n\nfloat nautic(vec2 p)\n{\n  p *= 18.;\n  float f = 0.;\n  float amp = 1.0, s = .5;\n  for (int i=0; i<3; i++)\n  { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+iTime*s ))-.5); amp = amp*.5; s*=-1.227; }\n  return pow(1.-f, 5.);\n}\n\nfloat particles(vec2 p)\n{\n  p *= 200.;\n  float f = 0.;\n  float amp = 1.0, s = 1.5;\n  for (int i=0; i<3; i++)\n  { p = m*p*1.2; f += amp*noise( p+iTime*s ); amp = amp*.5; s*=-1.227; }\n  return pow(f*.35, 7.)*particle_amount;\n}\n\n\nfloat test_shadow( vec2 xy, float height)\n{\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n    for (int j=1; j<25; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n    return hit;\n}\n\nvec3 CalcTerrain(vec2 uv, float height)\n{\n  vec3 col = terrain_map( uv );\n  float h1 = height_map(uv-vec2(0., 0.01));\n  float h2 = height_map(uv+vec2(0., 0.01));\n  float h3 = height_map(uv-vec2(0.01, 0.));\n  float h4 = height_map(uv+vec2(0.01, 0.));\n  vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\n  vec3 r0 = vec3(uv, height);\n  vec3 rd = normalize( light - r0 );\n  float grad = dot(norm, rd);\n  col *= grad+pow(grad, 8.);\n  float terrainshade = test_shadow( uv, height );\n  col = mix(col*.25, col, terrainshade);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = vec3(-0., sin(iTime*0.5)*.5 + .35, 2.8); // position of the sun\n\tvec2 uv = (fragCoord.xy / iResolution.xy - vec2(-0.12, +0.25));\n\n    float WATER_LEVEL = 0.94; // Water level (range: 0.0 - 2.0)\n    if (iMouse.z>0.)\n\t\tWATER_LEVEL = iMouse.x*.003; \n    float deepwater_fadedepth   = 0.5 + coast2water_fadedepth;\n    if (iMouse.z>0.)\n\t  deepwater_fadedepth = iMouse.y*0.003 + coast2water_fadedepth;\n    \n    float height = height_map( uv );\n    vec3 col;\n    \n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(iTime*.1), waveheight);\n    if (height > level)\n    {\n        col = CalcTerrain(uv, height);\n    }\n    if (height <= level)\n    {\n        vec2 dif = vec2(.0, .01);\n        vec2 pos = uv*15. + vec2(iTime*.01);\n        float h1 = water_map(pos-dif,waveheight);\n        float h2 = water_map(pos+dif,waveheight);\n        float h3 = water_map(pos-dif.yx,waveheight);\n        float h4 = water_map(pos+dif.yx,waveheight);\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n        uv += normwater.xy*.002*(level-height);\n        \n        col = CalcTerrain(uv, height);\n\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n        vec3 r0 = vec3(uv, WATER_LEVEL);\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n        float watershade  = test_shadow( uv, level );\n        watercolor *= 2.2+watershade;\n   \t\twatercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\n   \t\twatercolor /= (1.+specular1*1.25);\n   \t\twatercolor += watershade*specular2*water_specularcolor;\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\n        \n        col = mix(col, watercolor, coastfade);\n    }\n    \n\tfragColor = vec4(col , 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsBXDW", "name": "Dance floor", "author": "Nrx", "description": "Simple test...", "tags": ["color", "tiles"], "likes": 45, "viewed": 6251, "date": "1412149017", "time_retrieved": "2024-06-20T18:13:45.596509", "image_code": "vec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfrag *= 1.0 - 0.2 * cos (frag.yx) * sin (3.14159 * 0.5 * texture (iChannel0, vec2 (0.0)).x);\n\tfrag *= 5.0;\n\tfloat random = rand (floor (frag));\n\tvec2 black = smoothstep (1.0, 0.8, cos (frag * 3.14159 * 2.0));\n\tvec3 color = hsv2rgb (vec3 (random, 1.0, 1.0));\n\tcolor *= black.x * black.y * smoothstep (1.0, 0.0, length (fract (frag) - 0.5));\n\tcolor *= 0.5 + 0.5 * cos (random + random * iTime + iTime + 3.14159 * 0.5 * texture (iChannel0, vec2 (0.7)).x);\n\tfragColor = vec4 (color, 1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsBXDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsjSWw", "name": "Orbiting2", "author": "guil", "description": "test", "tags": ["fractal", "orbits"], "likes": 6, "viewed": 233, "date": "1412876021", "time_retrieved": "2024-06-20T18:13:45.602606", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 cinv( vec2 z ) { float d = dot(z,z);return vec2(z.x,-z.y)/d; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 1.75*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\n\tvec2 z = vec2(1.);\n\tfloat f = 4.;\n\tfloat g = 4.;\n   \n\t\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tfloat w = float(i)*.7+iTime*.5;\n\t\tvec2 z1 = 2.*vec2(cos(w),sin(w));\n\t\tz = cinv(z+p) - cinv(z-p) ;\n\t\tf = min( f, dot(z+z1,z+z1));\n\t\tg = min( g, dot(z-z1,z-z1));\n    \n\t}\n\t\n\tf = 1.0+log(f)/15.0;\n\tg = 1.0+log(g)/15.0;\n   \n\tfragColor = abs(vec4(g,f*.7,0.,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjSWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSSzc", "name": "Plas.mAcid", "author": "joates", "description": "@shadertoy.. this is really good fun !!", "tags": ["plasma", "acid"], "likes": 3, "viewed": 131, "date": "1414312116", "time_retrieved": "2024-06-20T18:13:45.766282", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t =0.2*iTime;\n    vec2  s =iResolution.xy/60.+abs(mod(t,8.)-4.);\n    vec2  p =fragCoord.xy/iResolution.x*s-s/2.;\n    float v =.0+sin((p.x+3.*t))+sin((p.y+6.*t)/2.)+sin((p.x+p.y+2.*t)/2.);\n    p += s/2.*vec2(sin(t/3.),cos(t/2.));\n    v += sin(sqrt(p.x*p.x+p.y*p.y+1.)+t);\n    float R =sin(.2*PI*v),G =cos(.75*PI*v),B =sin(.9*PI*v);\n\n    // restrict the color palette\n    R = ceil(R*255. /  8.) *  8. / 256.;\n    G = ceil(G*255. / 16.) * 16. / 256.;\n    B = ceil(B*255. /  8.) *  8. / 256.;\n\n    if(mod(R,16.) < 1.) R =G*.5+.5; // less red (more green, blue & yellow)\n    vec3 col =vec3(R,G,B);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSXDm", "name": "Cosine", "author": "okro", "description": "Wanted to learn how to make this simple effect.", "tags": ["wave", "sin", "pretty"], "likes": 4, "viewed": 248, "date": "1412649919", "time_retrieved": "2024-06-20T18:13:45.766282", "image_code": "#define time iTime/1.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= .5;\n    \n    vec3 col = vec3(1.);\n\n    for (int i = 0; i <8; ++i)\n    {\n        float y = cos(uv.x + time * 3. + float(i)/4.) / 2.8;\n        float f = smoothstep(.05, .1, abs(uv.y - y));\n        col.g *= f;\n\n        float g = smoothstep(.06, .101, abs(uv.y - y));\n        col.g = mix(col.g, g, .22);  \n    }\n    \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSXRK", "name": "Terrain with Water", "author": "bolt304", "description": "Terrain with water reflection modifcated from the prev one I did", "tags": ["terrainreflection"], "likes": 2, "viewed": 240, "date": "1413671216", "time_retrieved": "2024-06-20T18:13:45.772279", "image_code": "struct Ray\n{\n\tvec3 origin;\n    vec3 dir;\n};\n    \nstruct Plane\n{\n\tvec3 p;\n    vec3 n;\n};\n    \n    \nstruct Light\n{\n\n    float specular;\n    vec3 position;\n    float diffuse;\n};\n    \nstruct LightDir\n{\n\n    vec3 dir;\n    float diffuse;\n};\n    \n    \n    \nfloat noise(vec2 uv)\n{\n \treturn texture(iChannel0, uv).r;   \n}\n\nfloat fbm(vec2 p)\n{\n \tfloat f = 0.0;   \n    f += 0.5    * noise(p); p *= 2.07;\n    f += 0.250  * noise(p);\tp *= 2.03;\n    f += 0.125  * noise(p);\tp *= 2.05;\n    f += 0.0625 * noise(p);\tp *= 2.08;\n    f /= 0.9375;\n    return f;\n}\n\nmat4 rotateY(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa, 0.0, -sena, 0.0,\n               0.0  , 1.0, 0.0, 0.0,\n               sena , 0.0, cosa , 0.0\t,\n               0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateX(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( 1.0, 0.0, 0.0, 0.0,\n             0.0,\tcosa , sena, 0.0,\n             0.0, -sena , cosa , 0.0,\n             0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateZ(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa ,sena , 0.0,  0.0,\n                -sena, cosa, 0.0,   0.0,\n             \t0.0\t ,0.0  , 1.0,  0.0,\n             \t0.0  ,0.0  , 0.0,  1.0\t);\n}\n\n\n    \nbool intersectPlane(in Ray r, in Plane p, out vec3 c)\n{\n\tfloat dotP=dot(r.dir, p.n);\n\tif(abs(dotP)<0.001)\n\t\treturn false;\n\tfloat t=-(dot(r.origin,p.n)-dot(p.p,p.n))/dotP;\n\tc=r.origin+t*r.dir;\n\tif(t>0.0)\n        return true;\n\treturn false;\n}\n    \n\n\nvec3 camera(in vec3 dir)\n{\n    vec3 cam =  dir;\n   \n        \n    vec2 m = iMouse.xy;\n    m /= iResolution.xy;\n    float cosa = cos(m.x * 2.0 - 1.0);\n    float sena = sin(m.x * 2.0 - 1.0);\n    float cosb = cos(m.y * 2.0 - 1.0);\n    float senb = sin(m.y * 2.0 - 1.0);\n    mat4 rotY = rotateY(-(m.x * 2.0 - 1.0));\n    mat4 rotX = rotateX(m.y * 2.0 - 1.0);\n\n\n    cam = normalize(vec3(rotY *rotX *  vec4(cam, 0.0))); \n    \n   return cam;\n}\n\n#define FREQ 0.00725\n#define HIGH_MODIF 2.5\n#define NORMAL_OFFSET 0.1\n//#define QUAD_DEPTH\nconst vec4 fogColor = vec4(1.0, 0.8, 0.4, 1.0);\n#define MAX_DIST 17.0\n#define MIN_DIST 0.01\n#define DELTA_T\t0.01\n#define SUN_EXP 20.0\n#define IT 1024\nvec3 vSun = normalize(vec3(0.3, 0.4, -0.9));\nconst vec4 sunColor = vec4(0.9, 0.6, 0.1, 1.0);\n#define PHONG_SHADING\nfloat f(in vec2 v)\n{\n return (2.0 * fbm(v * FREQ) - 1.0) * HIGH_MODIF;   \n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec3 n = vec3( f(vec2(p.x-NORMAL_OFFSET,p.z)) - f(vec2(p.x+NORMAL_OFFSET,p.z)),\n                         2.0 * NORMAL_OFFSET,\n                         f(vec2(p.x,p.z-NORMAL_OFFSET)) - f(vec2(p.x,p.z+NORMAL_OFFSET)) );\n    return normalize( n );\n}\n\nbool castRay( in vec3 ro, in vec3 rd, out float T , out vec3 N)\n{\n    const float delt = DELTA_T;\n    const float mint = MIN_DIST;\n    const float maxt = MAX_DIST;\n    \n   \tbool res = false;\n    vec3 p;\n    for(int i = 0; i < IT; ++i)\n   // for( float t = mint; t < maxt; t += delt )\n    {\n        //precission seems less important as we move far away\n        #ifdef QUAD_DEPTH\n      \tfloat dt = smoothstep(DELTA_T, 0.8, (float(i * i) / float(IT * IT)));\n        #else \n       \tfloat dt = DELTA_T;\n        #endif\n        float t =  dt * float(i)+ MIN_DIST;\n        p = ro + rd*t;\n        if( p.y < (f(p.xz)  ))\n        {\n            T = t - 0.5*delt;\n            \n           \tres = true;\n            break;\n        }\n    }\n    if(res) N = getNormal(p);\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = fogColor;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec2 ss = uv * 2.0 - vec2(1.0);//from 1.0 to -1.0\n\tss.y*= iResolution.y / iResolution.x;//aspect ratio\n\tRay cam;\n    cam.origin = vec3(0.0, sin(iTime * 1.1) * 1.0 + 2.0 ,-iTime * 2.0);\n    cam.dir = normalize(vec3(ss.x, ss.y, -1.0));\n    cam.dir = camera(cam.dir);\n    vec3 d = cam.dir;\n    vec3 o = cam.origin;\n    LightDir l;\n    l.dir= vSun;\n    l.diffuse = 1.7;\n\tPlane wp;\n    wp.n = vec3(0.0, 1.0, 0.0);\n    wp.p = vec3(0.0,0.0, 0.0);\n    vec3 n;\n    \n\tfloat t;\n    if(castRay(o, d, t, n))\n    {\n        //moar phong\n        //lets phong shading model\n        vec3 ip = o + d * t;\n        vec3 lv = l.dir;\n\n        float dif = max(0.3, dot(lv, n));\n        \n        float h = ((ip.y/ HIGH_MODIF) );\n        \n       \tvec4 mColor = mix(texture(iChannel1, 2.0 * ip.xy / HIGH_MODIF + vec2(1.0)) \n                          * mix(vec4(1.0), vec4(0.1,0.954, 0.3, 1.0), \n                      smoothstep(0.0, 1.0, h * 0.125)), vec4(1.0, 0.89, 0.97, 1.0), smoothstep(0.0, 1.0, h));\n        color\t= mix(fogColor, mColor, smoothstep(1.0, 0.0, (t ) / (DELTA_T * float(IT) + MIN_DIST)));\n        #ifdef PHONG_SHADING\n        color = l.diffuse * dif* color;\n        #endif\n        if(ip.y < 0.0)\n        {\n            //compute intersection point\n            //interscetion with the water\n            //o.y + m.y = 0.0\n            //m.y = -o.y\n            //m.x = \n            Ray r;\n            r.dir = d;\n            r.origin = o;\n            \n            vec3 m;\n            intersectPlane(r, wp, m);\n           \n            //reflect\n            vec3 d = reflect(d,wp.n);\n            if(castRay(m, d, t, n))\n            {\n                vec3 newip = m + d * t;\n                h = newip.y / MAX_DIST;\n                vec4 mColor = mix(texture(iChannel1, 2.0 * newip.xy / HIGH_MODIF + vec2(1.0)) \n                          * mix(vec4(1.0), vec4(0.1,0.954, 0.3, 1.0), \n                      smoothstep(0.0, 1.0, h * 0.125)), vec4(1.0, 0.89, 0.97, 1.0), smoothstep(0.0, 1.0, h));\n                color = mix(mColor, color, 0.8);\n            }\n            else\n            {\n                color\t= mix(fogColor, color, smoothstep(1.0, 0.0, (t ) / (DELTA_T * float(IT) + MIN_DIST)));\n                \n            }\n            color = mix(color, vec4(0.0,0.1, 0.9, 1.0), 0.2);\n            \n            \n        }\n        \n        //color = vec4(n,1.0);//l.diffuse * d  ;  \n        \n       t = t / (MAX_DIST);\n        float tInv = 1.0/t;\n        //height fog color\n        color = mix(color, vec4(0.0, 0.1, 0.4, 1.0), smoothstep(0.3, -0.6, h * tInv));\n        //color = vec4(t / 50.0, t  / 50.0 , t  / 50.0, 1.0);\n    }\n    \n    //get the angle from the view to the sun\n    float s = pow(max(0.0, dot(cam.dir, l.dir)), SUN_EXP);\n   \tcolor = mix(color, sunColor, smoothstep(0.0, 1.0, s));\n    \n\tfragColor = color;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsSXz3", "name": "Daffodil", "author": "daeken", "description": "My first attempt at simulating something organic.", "tags": ["flower", "shaderforth"], "likes": 0, "viewed": 159, "date": "1414254998", "time_retrieved": "2024-06-20T18:13:46.748301", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n\t@vec4 uniform =iDate\n;\n:m gtime iTime ;\n\n:m overlap 5 ;\n\n: split ( p:vec2 time:float -> vec3 )\n\tp cart->polar =pol\n\t[\n\t\t\tpol .y 10 / time 7.1 / + sin 10 /\n\t\t\tpol .y 100 * sin 350 /\n\t\t+\n\t\t0\n\t] pol + pi 2 * mod =pol\n\tpol .x 60 deg->rad mod 30 deg->rad - 30 deg->rad / =dist\n\n\t0 =top\n\t{ dist 30 overlap + deg->rad 30 deg->rad / / =dist 1 =top }\n\t{\n\t\t{ dist 30 overlap - deg->rad 30 deg->rad / / =dist }\n\t\t{\n\t\t\t\t1 dist abs - 1 + dist sign neg *\n\t\t\t\t30 overlap + deg->rad 30 deg->rad /\n\t\t\t/ =dist\n\t\t\t1 =top\n\t\t} dist abs 30 overlap - deg->rad 30 deg->rad / < if\n\t}\n\tpol .x 120 deg->rad mod 60 deg->rad >= if\n\n\t[\n\t\tdist abs\n\t\tpol .y\n\t\ttop\n\t]\n;\n\n: warp ( ip:vec3 time:float -> vec3 )\n\tip [\n\t\ttime 5 / ip .y + sin 10 /\n\t\t\ttime 3.7 / ip .x + sin 100 /\n\t\t\t1 ip .z - 75 /\n\t\t+\n\t\t0\n\t] +\n;\n\n:m matunion { .x } amin ;\n\n: shape ( to:float p:vec2 -> vec2 )\n\tgtime to + =time\n\n\tp time split time warp =flower\n\n\t[\n\t\tflower .y 1 flower .x 2 / - -\n\t\tflower .x\n\t]\n;\n\n: shape-deriv ( p:vec2 -> float )\n\t$[-.1:+.1:.05] !size =>len\n\t\t/{ p shape .x }\n\t\\+ len /\n;\n\n:m petal-color [ .95 .95 0 ] ;\n:m interior-color [ 1 .8 0 ] ;\n:m stamen-color [ 1 1 0 ] ;\n\n:m earth-color [ .67 .30 .05 ] ;\n:m leaf-color [ .10 .39 .08 ] ;\n:m stem-color [ .10 .70 .06 ] ;\n\n: background ( p:vec2 -> vec3 )\n\t\t{ [\n\t\t\tstem-color\n\t\t\tp .x p .y + 7.1 * sin abs .3 * .7 +\n\t\t\tp .x 3.7 * sin abs .5 * .5 +\n\t\t\tp .x 57 * p .y 13 * + sin abs .1 * .9 +\n\t\t\tp .x 2 * .5 +\n\t\t] /abs \\* }\n\t\t{ [\n\t\t\t[\n\t\t\t\tearth-color\n\t\t\t\tp .x p .y .3 + * sin\n\t\t\t\tp .x 3.7 * p .y -1.1 * + gtime 3.7 / + sin\n\t\t\t] /abs \\*\n\t\t\t[\n\t\t\t\tleaf-color\n\t\t\t\tp .x p .y .7 * + gtime 7.9 / + sin\n\t\t\t\tp .y 3.7 * sin\n\t\t\t] /abs \\*\n\t\t] /{ 0 1 clamp } \\+ }\n\t\t\tp .x p .y .3 gtime 3.7 / sin .05 * + * + abs p .y 7.9 * sin .02 * + .1 <\n\t\t\tp .y 0 <\n\t\tand if\n;\n\n: texture ( d:float p:vec2 -> vec3 )\n\t{ gtime split .x } p gradient =dist\n\tp gtime split gtime warp =flower\n\tp cart->polar =pol\n\t\t{\n\t\t\t[\n\t\t\t\tpetal-color\n\t\t\t\td neg 500 * 0 1 clamp\n\t\t\t\tdist 90 * pol .y pol .x 79 * sin * * 1 pol .y - 20 * + sin abs .05 * .95 +\n\t\t\t\tflower .z .9 + 0 1 clamp\n\t\t\t] \\*\n\t\t\td sign 1 + 2 / p background *\n\t\t+ }\n\t\t{\n\t\t\t\t{ [\n\t\t\t\t\tinterior-color\n\t\t\t\t\t.5 1 pol .y 5 * smoothstep .2 +\n\t\t\t\t\tpol .x 13 * sin pol .x 9 * sin * abs .1 * .9 +\n\t\t\t\t] \\* }\n\t\t\t\t{ [\n\t\t\t\t\tstamen-color\n\t\t\t\t\tpol .y 137 * sin pol .x 17 * sin * abs .7 * .3 +\n\t\t\t\t] \\* }\n\t\t\t\tpol .y .05 >\n\t\t\tif\n\t\t}\n\t\tpol .y pol .x p .x + 17 * sin .01 * .3 + >\n\tif\n;\n\niResolution frag->position =p\n&shape-deriv p gradient p texture ->fragcolor\n*/\n\nvec3 background(vec2 p) {\n\tvec3 temp_11;\n\tif((((abs(((p).x) + (((p).y) * (0.3 + ((sin((iTime) / 3.7)) * 0.05))))) + ((sin(((p).y) * 7.9)) * 0.02)) < 0.1) && (((p).y) < 0.0)) {\n\t\ttemp_11 = ((((abs(vec3(0.1, 0.7, 0.06))) * (abs(((abs(sin((((p).x) + ((p).y)) * 7.1))) * 0.3) + 0.7))) * (abs(((abs(sin(((p).x) * 3.7))) * 0.5) + 0.5))) * (abs(((abs(sin((((p).x) * 57.0) + (((p).y) * 13.0)))) * 0.1) + 0.9))) * (abs((((p).x) * 2.0) + 0.5));\n\t} else {\n\t\ttemp_11 = (clamp(((abs(vec3(0.67, 0.3, 0.05))) * (abs(sin(((p).x) * (((p).y) + 0.3))))) * (abs(sin(((((p).x) * 3.7) + (((p).y) * -1.1)) + ((iTime) / 3.7)))), 0.0, 1.0)) + (clamp(((abs(vec3(0.1, 0.39, 0.08))) * (abs(sin((((p).x) + (((p).y) * 0.7)) + ((iTime) / 7.9))))) * (abs(sin(((p).y) * 3.7))), 0.0, 1.0));\n\t}\n\treturn temp_11;\n}\nvec3 warp(vec3 ip, float time) {\n\treturn (ip) + (vec3((sin(((time) / 5.0) + ((ip).y))) / 10.0, ((sin(((time) / 3.7) + ((ip).x))) / 100.0) + ((1.0 - ((ip).z)) / 75.0), 0.0));\n}\nvec2 cart_polar(vec2 p) {\n\treturn vec2(atan((p).y, (p).x), length(p));\n}\nvec3 split(vec2 p, float time) {\n\tfloat dist;\n\tfloat top;\n\tvec2 pol = cart_polar(p);\n\tpol = mod((vec2(((sin((((pol).y) / 10.0) + ((time) / 7.1))) / 10.0) + ((sin(((pol).y) * 100.0)) / 350.0), 0.0)) + (pol), 6.28318);\n\tdist = ((mod((pol).x, 1.04719666667)) - 0.523598333333) / 0.523598333333;\n\ttop = 0.0;\n\tif((mod((pol).x, 2.09439333333)) >= 1.04719666667) {\n\t\tdist = (dist) / 1.16666666667;\n\t\ttop = 1.0;\n\t} else {\n\t\tif((abs(dist)) < 0.833333333333) {\n\t\t\tdist = (dist) / 0.833333333333;\n\t\t} else {\n\t\t\tdist = (((1.0 - (abs(dist))) + 1.0) * (- (sign(dist)))) / 1.16666666667;\n\t\t\ttop = 1.0;\n\t\t}\n\t}\n\treturn vec3(abs(dist), (pol).y, top);\n}\nvec2 shape(float to, vec2 p) {\n\tfloat time = (iTime) + (to);\n\tvec3 flower = warp(split(p, time), time);\n\treturn vec2(((flower).y) - (1.0 - (((flower).x) / 2.0)), (flower).x);\n}\nvec3 texture(float d, vec2 p) {\n\tvec3 temp_36;\n\tvec3 temp_32;\n\tvec2 h = vec2(1e-05, 0.0);\n\tfloat dist = ((split(p, iTime)).x) / (abs(length((vec2(((split((p) + (h), iTime)).x) - ((split((p) - (h), iTime)).x), ((split((p) + ((h).yx), iTime)).x) - ((split((p) - ((h).yx), iTime)).x))) / (2.0 * ((h).x)))));\n\tvec3 flower = warp(split(p, iTime), iTime);\n\tvec2 pol = cart_polar(p);\n\tif(((pol).y) > (((sin((((pol).x) + ((p).x)) * 17.0)) * 0.01) + 0.3)) {\n\t\ttemp_32 = ((((vec3(0.95, 0.95, 0.0)) * (clamp((- (d)) * 500.0, 0.0, 1.0))) * (((abs(sin((((dist) * 90.0) * (((pol).y) * (sin(((pol).x) * 79.0)))) + ((1.0 - ((pol).y)) * 20.0)))) * 0.05) + 0.95)) * (clamp(((flower).z) + 0.9, 0.0, 1.0))) + ((((sign(d)) + 1.0) / 2.0) * (background(p)));\n\t} else {\n\t\tif(((pol).y) > 0.05) {\n\t\t\ttemp_36 = ((vec3(1.0, 0.8, 0.0)) * ((smoothstep(0.5, 1.0, ((pol).y) * 5.0)) + 0.2)) * (((abs((sin(((pol).x) * 13.0)) * (sin(((pol).x) * 9.0)))) * 0.1) + 0.9);\n\t\t} else {\n\t\t\ttemp_36 = (vec3(1.0, 1.0, 0.0)) * (((abs((sin(((pol).y) * 137.0)) * (sin(((pol).x) * 17.0)))) * 0.7) + 0.3);\n\t\t}\n\t\ttemp_32 = temp_36;\n\t}\n\treturn temp_32;\n}\nfloat shape_deriv(vec2 p) {\n\treturn ((((((shape(-0.1, p)).x) + ((shape(-0.05, p)).x)) + ((shape(0.0, p)).x)) + ((shape(0.05, p)).x)) + ((shape(0.1, p)).x)) / 5.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (((((fragCoord).xy) / ((iResolution).xy)) * 2.0) - 1.0) * (vec2(((iResolution).x) / ((iResolution).y), 1.0));\n\tvec2 h = vec2(1e-05, 0.0);\n\tfragColor = vec4(texture((shape_deriv(p)) / (abs(length((vec2((shape_deriv((p) + (h))) - (shape_deriv((p) - (h))), (shape_deriv((p) + ((h).yx))) - (shape_deriv((p) - ((h).yx))))) / (2.0 * ((h).x))))), p), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2SWD", "name": "Signalmesh - Occulus", "author": "squeakyneb", "description": "A simplified version of my Signalmesh shader in Oculus Rift mode.", "tags": ["raymarching", "raymarched", "oculus", "rift", "dk2"], "likes": 3, "viewed": 201, "date": "1412329554", "time_retrieved": "2024-06-20T18:13:47.627019", "image_code": "#define lowdef //comment out for more magic\n\n#ifdef lowdef\nconst float MAXDIST = 30.0;\nconst float EPSILON = 0.01;\nconst int   MAXITER = 25;\n#else\nconst float MAXDIST = 100.0;\nconst float EPSILON = 0.001;\nconst int   MAXITER = 150;\n#endif\n\nstruct RayResult {\n\tvec3 pos;\n\tvec3 normal;\n\tfloat dist;\n\tfloat mindist;\n\tfloat totaldist;\n};\n\nfloat defRepeat(float p, float s){\n\treturn mod(p,s)-s*0.5;\t\n}\n\nvec3 rotX(vec3 p, float a){\n\tmat4 m = mat4(\n\t\t1.0,0.0,0.0,0.0,\n\t\t0.0,cos(a),sin(a),0.0,\n\t\t0.0,-sin(a),cos(a),0.0,\n\t\t0.0,0.0,0.0,1.0);\n\treturn (m*vec4(p,1.0)).xyz;\n}\n\nvec3 rotZ(vec3 p, float a){\n\tmat4 m = mat4(\n\t\tcos(a),sin(a),0.0,0.0,\n\t\t-sin(a),cos(a),0.0,0.0,\n\t\t0.0,0.0,1.0,0.0,\n\t\t0.0,0.0,0.0,1.0);\n\treturn (m*vec4(p,1.0)).xyz;\n}\n\nfloat cylinderX(vec3 p, float radius){\n\treturn length(p.zy)-radius;\n}\n\nfloat box(vec3 p, vec3 size){\n\treturn length(max(abs(p)-size,0.0));\n}\n\nfloat boxZ(vec3 p, vec2 size){\n\treturn length(max(abs(p.xy)-size,0.0));\n}\n\nfloat rbox(vec3 p, vec3 size, float r){\n\treturn length(max(abs(p)-size,0.0))-r;\n}\n\nfloat mesh(vec3 p, float size, float thick){\n\tp = mod(p,size)-size*0.5;\n\tfloat x = length(max(abs(p.yz)-vec2(size*thick),0.0));\n\tfloat y = length(max(abs(p.xz)-vec2(size*thick),0.0));\n\tfloat z = length(max(abs(p.xy)-vec2(size*thick),0.0));\n\treturn min(x,min(y,z))-thick*0.1;\n}\n\n\nfloat sceneDist(vec3 p){\n\tp = rotZ(p,0.4*sin(p.z*0.4+iTime)+iTime);\n\t\n\tfloat v1 = mesh(p,0.35,0.1);\n\t\n\tfloat b1 = boxZ(p,vec2(1.0,1.0));\n\t\n\treturn max(b1,v1);\n}\n\nvec3 getNormal(vec3 pos){\n\tvec2 eps = vec2(0.0, EPSILON);\n\treturn normalize(vec3(\n\t\t\tsceneDist(pos + eps.yxx) - sceneDist(pos - eps.yxx),\n\t\t\tsceneDist(pos + eps.xyx) - sceneDist(pos - eps.xyx),\n\t\t\tsceneDist(pos + eps.xxy) - sceneDist(pos - eps.xxy)));\n}\n\nRayResult castRay(vec3 rPos, vec3 rDir){\n\tRayResult result;\n\tresult.dist=MAXDIST;\n\tresult.mindist=MAXDIST;\n\tresult.totaldist=0.0;\n\t\n\tfor (int i = 0; i < MAXITER; i++)\n\t{\n\t\t\n\t\tif (result.dist < result.mindist) { result.mindist = result.dist;}\n\t\tif (result.dist < EPSILON || result.dist > MAXDIST) {continue;}\n\t\t\n\t\tresult.dist = sceneDist(rPos); // Evalulate the distance at the current point\n\t\tresult.totaldist += result.dist;\n\t\trPos += result.dist * rDir; // Advance the point forwards in the ray direction by the distance\n\t}\n\tresult.pos = rPos;\n\tresult.normal = getNormal(result.pos);\n\treturn result;\n}\n\n\nvec3 getC(float x, float k){\n\tfloat y=clamp(1.0-x,0.0,1.0);\n\tx = clamp(x,0.0,1.0);\n\ty *= k;\n\treturn vec3(exp(-y*0.1)+0.2,\n\t\t\t\texp(-y*0.3),\n\t\t\t\texp(-y*0.7)\n\t\t\t   )*(1.0-exp(-x*k));\n}\n\nfloat ss(float x){\n\treturn 0.5+0.5*sin(x);\n}\n\n#define mBpm 147.75 // useless really\nconst float sBeat = 1.0/(mBpm / 60.0);\n#define mStart 9.75\nvec3 getCamPos(){\n\tvec3 p;\n\tfloat t = iChannelTime[0];\n\t\tp = vec3(1.7,-2.0,-t*3.0);\t\n\t\n\treturn p;\n}\n\nvec3 getCamTarget(){\n\tvec3 p;\n\tfloat t = iChannelTime[0];\n\t\tp = vec3(0.0,0.0,-t*3.0+3.0);\n\treturn p;\t\n}\n\nvec3 renderWorld(vec2 uv,float screen){\n\t\n\tfloat t = iTime;\n\t\n\t\n\tvec3 camPos = getCamPos();\n\tvec3 camTarget = getCamTarget();\n\t\n\tvec3 camDir = normalize(camTarget-camPos);\n\tvec3 camRight = normalize(cross(camDir,vec3(0.0,1.0,0.0))); // right is normal to forward and up\n\tvec3 camUp = normalize(cross(camDir,camRight)); // up is normal to forward and right\n\tcamPos += camRight*screen*0.15;\n\t\n\tRayResult ray = castRay(camPos,normalize(camRight*uv.x + camUp*uv.y + camDir));\n\t\n\tvec3 c;\n\t\n\tif(ray.dist<EPSILON){\n\t\tfloat vDiffuse = max(0.0, dot(ray.normal,-camDir )   );\n\t\t\n\t\tc = getC(vDiffuse+0.4*pow(ss(ray.pos.z*0.5-iTime*6.0),5.0),\n\t\t\t\t 40.0);\n\t}else{\n\t\tc = getC(1.0-clamp(ray.mindist,0.0,.8),400.0);\t\n\t}\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float screen = sign(uv.x-.5);\n    uv.x = mod(uv.x,0.5)*2.;\n    uv = (uv-.5);\n    uv.y /= (iResolution.x/2.)/iResolution.y;\n\tuv *= 2.5;\n\tvec3 c = renderWorld(uv,screen);\n\t\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2XDD", "name": "Somewhere in 1993", "author": "nimitz", "description": "Experiments in making low poly terrain.", "tags": ["3d", "raymarching", "terrain", "lowpoly", "mockup", "hud"], "likes": 86, "viewed": 3182, "date": "1412910246", "time_retrieved": "2024-06-20T18:13:49.196844", "image_code": "// Somewhere in 1993 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/Md2XDD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define PALETTE 6.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 4.\n#define ITR 100\n#define FAR 700.\n#define time mod(iTime,500.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 1.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*100.+50.,sin(time)*30.+30.,300.+sin(time*.9+sin(time*0.88+0.2))*100.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.03*tk,.04*tk,abs(d-0.5));\n    d = sin(a*3.+1.59-time*3.5-rt);\n    rz += smoothstep(0.0,.07*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(1.75,-.8))*7.;\n    p.x *= 1.5;\n    float sd = floor(time*8.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 1.;\n    vec2 fl = vec2(2.,2.);\n    for(float i=0.;i<7.;i++)\n    {\n    \tif(hash2(sd+i+10.).x<0.3)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+1.);\n\t\tp1 = (floor(p1*fl) + .5)/fl;\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n        if (p1 == p2) p2 = vec2(.5);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+3.);\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+5.);\n\t\tp2 = (floor(p2*fl) + .5)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+7.);\n\t\t\tp2 = (floor(p2*fl) + .5)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .8;\n    }\n\n    d = smoothstep(0.03, .08,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(0.99, 1., seek);\n    float sk2 = step(1.-sk1, .5);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.25;\n    p *= ll * -.3+1.29;\n    p *= 2.;\n    vec3 col = vec3(0);\n    float d= 1.;\n    //crosshairs\n    float rz = crosshair(p*1.1, .9,1.+sk1);\n    rz = min(rz,crosshair(p*2.7,2., -time*6.5-1.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-1.45, -0.67))+0.02;\n    d = smoothstep(0.3,0.31,d2);\n    d = max(d,smoothstep(0.35,.55,min(sin(p.x*80.+1.9),sin(p.y*80.+time*15.))+1.4));\n    d = min(d,smoothstep(0.002,0.009,abs(d2-0.3)));\n    vec3 enp = enpos()/1000.;\n    enp.z = 1.-enp.z;\n    float en = smoothstep(0.025, 0.033, loz(enp.xz+p-vec2(1.47, 1.4))) ;\n    en += mod(floor(time*2.5), 2.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*100.+sin(time)*20.)*3.+3.);\n    d2 = max(d,(p.x+0.59)*200.);\n    d2 = max(d2,-(p.x+0.66)*200.);\n    float d3 = max(d,(p.x-0.66)*200.);\n    d3 = max(d3,-(p.x-.59)*200.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.59, .6, -p.y);\n    d2 += smoothstep(0.59, .6, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*12.),12.);\n    vec2 p2 = p+vec2(-1.32,.94);\n    d = 1.;\n    for(float i=0.;i<5.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.1;\n    }\n    d = smoothstep(0.023,.03,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.35,0.4,0.48)*(3.35)*PALETTE)*0.5+.5);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.5);\n}\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat tnoise(in vec2 p)\n{\n    p*=.008;\n    float z=2.;\n\tfloat rz = 0.;\n\tfor (float i= 1.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*1.))/z;\n\t\tz = z*2.;\n\t\tp = p*1.8;\n        p*= m2;\n\t}\n\treturn rz*9.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.5773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(6.*tnoise(p.xz)+p.y+20.+(tri(p.z*0.001)-0.4)*22.,1.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.5*log(abs(p.x)))*0.05-8.;\n    //flat water\n    d = ou(d,vec2(p.y+30., 2.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*50.;\n    d = ou(d,vec2((oct(roty(p-enp, time*2.5))-6.)*0.66,8.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .1;\n    float h=precis*2.0;\n    float d = 0.;\n    float c = 1.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*1.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*.1;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), 0., 1.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(0.9985,.999,1.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(0);\n    um.x = 0.5+(smoothstep(-2.,2.,sin(time*.7-0.1))-0.5)*.1;\n    um.y = sin(time+1.)*0.02;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-2., 2., sin(time*0.7+1.57))-0.5)*50., sin(time)*5.-1., time*50.);\n    um.x *= 3.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*5.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+1.5708),0.,sin(um.x+1.5708)));\n    mat2 ori = mm2( smoothstep(-.5,.5,sin(time*0.7+0.78))-.5 + smoothfloor(time*0.04,.45)*6.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.75+eye);\n\t\n    vec3 bg = sin(vec3(0.35,0.4,0.48)*11.3*PALETTE)*0.5+.5;\n    vec3 col = bg*floor(-rd.y*50.+6.)*0.06;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.7,0.2, 0.1));\n        float dif = clamp(dot(nor, ligt), 0., 1.);\n        float fre = pow(clamp(1. + dot(nor, rd), 0., 1.), 2.);\n        if (rz.y == 1.)\n        {\n            float mx = abs(pos.x*.1)-10.;\n            mx = smoothstep(-20.,10.,mx);\n            col = mix(vec3(0.,0.37,0),vec3(0.2,.17,0.15),mx);\n        }\n        else\n            col = sin(vec3(0.35,0.4,0.48)*rz.y*PALETTE)*0.5+.55;\n        col = col*dif + col*0.4 + .3*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*50.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > .997)\n    {\n        vec3 ray1 = vec3(0.7, 1., -1);\n        vec3 ray2 = vec3(-0.7, 1., -1);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.5+ro+(eye-ray1*0.01)*30.);\n        lz += segm(ro,rd,ro-ray2,up*.5+ro+(eye-ray2*0.01)*30.);\n        float sw = mod(floor(time*20.),2.);\n        lz *= sw;\n        col = col*(1.-smoothstep(0.0,1.,lz))+lz*vec3(1.,0.,0.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > .999)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.03;\n            rn.xy += d*10.;\n            float s = sw*smoothstep(0.9998, .9999,dot(rd,normalize(rn)));\n            col = col*(1.-smoothstep(0., 1., s))+s*vec3(1.-d.x, .0, 0.1);\n        }\n    }\n    \n    //hud\n    float lk = 0.;\n    if (tgt > .99)lk = 4.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(1.-smoothstep(0., 1., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*1.3*iResolution.x)*0.15)*(sin(p.y*10.+time*410.)*0.4)+1.;\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2XR3", "name": "Plas.mAtrix.+spin", "author": "joates", "description": "added a bit of spin into the mix (without spin -> https://www.shadertoy.com/view/lsBXzc)", "tags": ["pulse", "plasma", "zoom", "matrix", "rotation", "acid"], "likes": 4, "viewed": 295, "date": "1414520415", "time_retrieved": "2024-06-20T18:13:49.554562", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pulse = 1.;        // pulse: on/off\n    float mag = 80.;\n    \n    float gs = iResolution.x / 20.;\n    float ar = iResolution.x / iResolution.y;\n    float t =0.2*iTime;\n\n    if (pulse != 0.) {\n        pulse = sqrt( abs( mod( t, .4 ) - .2 ) ) * 16.;\n        mag = 160.;\n    }\n    vec2 s =iResolution.xy/mag+pulse;\n\n    // correct aspect ratio\n    vec2 p =fragCoord.xy/iResolution.x;\n\n    if (pulse != 0.) {\n        p *= s-s/2.;         // scale\n    }\n\n    // rotate\n    float sa =sin(t);\n    float ca =clamp(cos(t * 4.),-.9,.9);\n    vec2  rp =vec2( p.x*ca - p.y*sa, p.x*sa + p.y*ca );\n    if (pulse != 0.) { p = rp; }\n    else { p = rp * mag * .1;  }\n\n    // calculate the cumulative value of several sine functions\n    float v =sin(p.x+.8*t)+.5*sin(p.y+.8*t)+.5*sin(p.x+p.y+.9*t);\n    p += s/2.*vec2(sin(t/.9),cos(t/.6));\n    v += sin(sqrt(p.x*p.x+p.y*p.y+1.)+t);\n\n    // color blending\n    float R =sin(.2 *PI*v),\n          G =cos(.75*PI*v),\n          B =sin(.9 *PI*v);\n\n    // restricted color palette (nice effect)\n    // code by McRam (https://www.shadertoy.com/view/ld2XRG)\n    R = ceil(R*255. /  8.) *  8. / 256.;\n    G = ceil(G*255. / 16.) * 16. / 256.;\n    B = ceil(B*255. /  8.) *  8. / 256.;\n\n    if(mod(R,16.) < 1.) R =G*.5+.5;\n    vec3 col =vec3(R,G,B);\n\n    // grid\n    col *= 0.4 * 1./length( sin( 1.*.1 * gs*p.x ) );\n    col *= 0.8 * 1./length( sin( ar*.1 * gs*p.y ) );\n\n    // deinterlaced scanlines\n    col *= .33 * length( sin( 5. * p.y * gs ) );\n\n    col =clamp(col,vec3(.0),vec3(1.));           // safe range\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md2XWw", "name": "LinearDitherForSRGB", "author": "TimothyLottes", "description": "Showing how to dither in linear for output in sRGB", "tags": ["dithering"], "likes": 15, "viewed": 1670, "date": "1412834259", "time_retrieved": "2024-06-20T18:13:50.172623", "image_code": "#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n//\n// TEMPORAL DITHERING TEST IN LINEAR\n//\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return vec3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nF3 photoLuma=F3(0.2126,0.7152,0.0722);\nF1 PhotoLuma(F3 c){return dot(c,photoLuma);}\n\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Used for stills.\nF3 Step3(F2 uv){\n F1 a=Step2(uv,0.07);    \n F1 b=Step2(uv,0.11);    \n F1 c=Step2(uv,0.13);\n #if 0\n  // Monochrome can look better on stills.\n  return F3(a);\n #else\n  return F3(a,b,c);\n #endif\n}\n\n// Used for temporal dither.\nF3 Step3T(F2 uv){\n F1 a=Step2(uv,0.07*fract(iTime));    \n F1 b=Step2(uv,0.11*fract(iTime));    \n F1 c=Step2(uv,0.13*fract(iTime));\n return F3(a,b,c);}\n\n#define STEPS 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n F2 uv=fragCoord.xy;\n F2 uv2=fragCoord.xy/iResolution.xy;F2 uv3=F2(uv2.x,1.0-uv2.y); \n F3 color=texture(iChannel0,uv2).rgb;\n F3 color2=texture(iChannel1,uv3*2.0).rgb;\n // BOTTOM: Show bands.\n if(uv2.y<0.1){color=F3(uv2.x);color=floor(color*STEPS+Step3(uv)*4.0)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.2){color=F3(uv2.x);color=floor(color*STEPS)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.3){color=F3(uv2.x);color=floor(color*STEPS+Step3T(uv)*4.0)*(1.0/(STEPS-1.0));}   \n // Show video and texture.\n else if(uv2.y<0.9){\n  if(uv2.x<0.3)color=color2;\n  color=Linear3(color);\n  // Add grain in linear space.\n  #if 0\n   // Slow more correct solutions.\n   #if 1\n    // Too expensive.\n    // Helps understand the fast solutions.\n    F3 amount=Linear3(Srgb3(color)+(4.0/STEPS))-color;\n   #else\n    // Less too expensive.\n    F1 luma=PhotoLuma(color);\n    // Implement this as a texture lookup table.\n    F1 amount=Linear1(Srgb1(luma)+(4.0/STEPS))-luma;\n   #endif\n  #else\n   // Fast solutions.\n   #if 1\n    // Hack 1 (fastest).\n    // For HDR need saturate() around luma.\n    F1 luma=PhotoLuma(color);\n    F1 amount=mix(\n     Linear1(4.0/STEPS),\n     Linear1((4.0/STEPS)+1.0)-1.0,\n     luma);\n   #else\n    // Hack 2 (slower?).\n    // For HDR need saturate() around color in mix().\n    F3 amount=mix(\n     F3(Linear1(4.0/STEPS)),\n     F3(Linear1((4.0/STEPS)+1.0)-1.0),\n     color);\n   #endif\n  #endif\n  color+=Step3T(uv)*amount;\n  // The following represents hardware linear->sRGB xform\n  // which happens on sRGB formatted render targets,\n  // except using a lot less bits/pixel.\n  color=max(F3(0.0),color);\n  color=Srgb3(color);\n  color=floor(color*STEPS)*(1.0/(STEPS-1.0));}\n // TOP: Show dither texture.\n else{color=Step3(uv)*1.0+0.5;}    \n fragColor=F4(color,1.0);}\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBSR3", "name": "Playing with atan", "author": "zachernuk", "description": "Getting to grips with the language and what to do with certain features like tangent. Looking forward to putting it all together!", "tags": ["2d", "atan"], "likes": 4, "viewed": 156, "date": "1414217124", "time_retrieved": "2024-06-20T18:13:50.172623", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    vec2 center = vec2(0.5,0.5);\n    float amt = 1.99;\n   \tfloat r = length(uv-center);\n    vec2 centered = uv-center;\n    float tanny = atan(centered.x,centered.y)*1.0;\n    tanny+=iTime+.05*sin(r*130.)+2.*r;\n    \n    vec4 clr =   vec4(sin(tanny*1.0),\n                        sin(tanny*1.0+amt),\n                      \tsin(tanny*1.0+2.0*amt),\n                        1.0\n                       );\n    clr*=1.0-1.0*sqrt(dot(centered,centered));\n    \n\tfragColor =clr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBSz3", "name": "VR test scene", "author": "RavenWorks", "description": "Here's my first WebVR raymarching test scene, now ported to ShaderToy's VR mode!\nStandalone version here: [url]http://raven.works/projects/raymarchFull/[/url]", "tags": ["procedural", "wood", "oculus", "marble", "rift", "vr", "pillars", "webvr"], "likes": 7, "viewed": 1989, "date": "1414250370", "time_retrieved": "2024-06-20T18:13:50.178620", "image_code": "\n\nconst float PI =3.14159265;\nconst float PI2=6.28318531;\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center)-size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.xz),tp.y)) - size;\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_planeX(vec3 p, float planeX){\n    return p.x-planeX;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_planeZ(vec3 p, float planeZ){\n    return p.z-planeZ;\n}\n\nfloat obj_cylForeverZ(vec2 p, float middleY, float radius){\n    return abs(length(vec2(p.x,p.y-middleY))) - radius;\n}\n\nfloat distSmooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout float curD, inout int curMaterial, float newD, int newMaterial){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){//blend colors too?\n    curD = distSmooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -distSmooth( newD , -curD , blendPower );\n}\n\nconst float cylMidZ = -1.5;\n\nvec3 rotMod(vec3 p, vec2 middle, float modFrac){\n    vec2 cylRel = vec2(p.x-middle.x,p.z-middle.y);\n    float cylAng = atan(cylRel.y,cylRel.x);\n    float cylDist = length(cylRel);\n    float modSlice = PI2/modFrac;\n    float newAng = (mod((cylAng+modSlice*0.5),(modSlice)))-(modSlice*0.5);\n    return vec3(cos(newAng)*cylDist,p.y,sin(newAng)*cylDist);\n\n}\n\nfloat middleMod(float val,float modDist){\n    return mod(val+modDist*0.5,modDist)-modDist*0.5;\n}\n\nfloat room(vec3 p, out int material){\n\n\n\n\n\n\n    float distance = 9999.9;\n    material = 0;\n\n    const float pillarGapX = 2.5;\n    const float pillarGapZ = 0.5;\n\n    const float floorTileGap = 0.5;\n    const float floorTileGrout = 0.07;\n\n    const float ceilY = 9.0;\n\n    const float mirrorY = 0.5;\n\n    vec3 pillarP = vec3(mod(p.x,pillarGapX*2.0),-abs(p.y-mirrorY)+mirrorY,mod(p.z,pillarGapZ*2.0));\n\n    // ceiling flat\n    hardAdd(distance,material,\n            -obj_planeY(p ,ceilY),\n            3);\n\n    // ceiling groove\n    hardSubtract(distance,\n                 obj_cylForeverZ(vec2(middleMod(p.x,5.0),p.y),ceilY,2.3));\n\n    // base\n    hardAdd(distance,material,\n            obj_box(pillarP,vec3(pillarGapX,-1.4,pillarGapZ),vec3(0.4,0.15,0.4),0.0),\n            1);\n\n    // base blend\n    smoothAdd(distance,\n              obj_cylinder(pillarP,vec3(pillarGapX,-1.15,pillarGapZ),vec2(0.3,0.1),0.0),\n              0.11);\n\n    // floor\n    hardAdd(distance,material,\n            obj_box(vec3(mod(p.x,floorTileGap*2.0),p.y,mod(p.z,floorTileGap*2.0)),vec3(floorTileGap,-1.5-floorTileGap,floorTileGap),vec3(floorTileGap-floorTileGrout),floorTileGrout),\n            2);\n\n    //column\n    hardAdd(distance,material,\n            obj_cylinder(pillarP,vec3(pillarGapX,mirrorY,pillarGapZ),vec2(0.25,2.0),0.0),\n            1);\n\n\n\n\n\n\n\n    return distance;\n\n}\n\n\n\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    vec3 cameraPos = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    \n    //scene movement\n    float fwdDist = iTime*0.2;\n    cameraPos.z -= fwdDist;\n    \n    \n    \n    // Raymarching.\n    const vec3 e=vec3(0.00007,0,0);\n    const float maxd=40.0; //Max depth\n    vec3 p;\n\n    float f=0.0;\n    float d=0.01;\n    int surfaceMaterial = 0;\n    for(int i=0;i<96;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=cameraPos+curCameraRayUnit*f;\n        d = room(p,surfaceMaterial);\n    }\n\n\n    vec3 color;\n    int dummyMaterial;\n\n    if (f < maxd){\n\n        vec3 surfaceColor;\n        float specA, specP;\n        float difP = 1.0;\n        vec3 normalCheat = vec3(0.0,0.0,0.0);//generally not advisable in stereo, but it's used very shallowly here\n\n        if (surfaceMaterial == 1){\n\n            vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\n            surfaceColor = mix(vec3(0.0,0.8,0.5),vec3(0.70),marbleAmt);\n            specA = mix(1.0,0.8,marbleAmt);\n            specP = mix(16.0,28.0,marbleAmt);\n\n        }\n        if (surfaceMaterial == 2) {\n\n            vec3 marbleP = p;\n            vec3 intensityP = p;\n\n            float tileSize = 1.0;\n            if ( ceil(mod(p.x,tileSize*2.0)/tileSize) == ceil(mod(p.z,tileSize*2.0)/tileSize) ) {\n                surfaceColor = vec3(0.45,0.0,0.0);\n                marbleP.x *= -1.0;\n                intensityP.x *= -1.0;\n                marbleP.z += 1.0;\n                intensityP.z += 1.0;\n            } else {\n                surfaceColor = vec3(0.75,0.75,0.6);\n            }\n            specA = 1.0;\n            specP = 16.0;\n\n\n\n\n            marbleP.x += marbleP.z*0.5;\n            marbleP.z += marbleP.x*0.4;\n\n            marbleP.x += sin(marbleP.x*  3.8)*0.125;\n            marbleP.z += sin(marbleP.z*  3.6)*0.135;\n\n            marbleP.x += sin(marbleP.z* 20.0)*0.025;\n            marbleP.z += sin(marbleP.x* 25.0)*0.025;\n\n            marbleP.x += sin(marbleP.z* 40.0)*0.025;\n            marbleP.z += sin(marbleP.x* 45.0)*0.025;\n\n            marbleP.x += sin(marbleP.z*150.0)*0.01;\n            marbleP.z += sin(marbleP.x*160.0)*0.011;\n\n            marbleP *= 36.0;\n\n\n\n\n            intensityP.z -= 10000.0;\n\n            intensityP.x += intensityP.z*0.3;\n            intensityP.z += intensityP.x*0.1;\n\n            intensityP.x += sin(intensityP.x*1.2)*0.36;\n            intensityP.z += sin(intensityP.z*1.3)*0.21;\n\n            intensityP.x += sin(intensityP.z*2.2)*0.8;\n            intensityP.z += sin(intensityP.x*2.3)*0.9;\n\n            intensityP *= 6.0;\n\n\n            float intensityAmt = (sin(intensityP.x)*sin(intensityP.z))*0.5+0.5;\n            intensityAmt = 1.0-pow(1.0-intensityAmt,0.5);\n\n            float marbleAmt = (sin(marbleP.x)*sin(marbleP.z))*0.5+0.5;\n\n\n            float marbleGrainAmt = marbleAmt;\n            marbleGrainAmt = 1.0-((1.0-pow(marbleGrainAmt,1.5))*(1.0-intensityAmt)*1.125);\n            marbleGrainAmt = 1.0-pow(1.0-marbleGrainAmt,5.0);\n\n            surfaceColor *= marbleGrainAmt;\n            specA *= marbleGrainAmt;\n\n\n\n            float marbleGashAmt = marbleAmt;\n            marbleGashAmt *= 0.5 + 18.0*intensityAmt;\n            marbleGashAmt += pow(intensityAmt,2.5)*18.0;\n            marbleGashAmt = clamp(marbleGashAmt,0.0,1.0);\n\n            float marbleGoldAmt = pow(marbleGashAmt,1.0);\n            float marbleShadeAmt = pow(marbleGashAmt,16.0);\n\n            surfaceColor *= marbleShadeAmt;\n            specA *= marbleShadeAmt;\n\n            vec3 myNormalCheat = vec3(\n                sin( p.x*200.0 + sin(p.z*100.0)*0.5 + sin(p.z*17.0)*(5.0+sin(p.x*20.0)*4.0) )*0.000015,\n                0.0,\n                0.0\n            );\n\n            surfaceColor = mix(vec3(1.0,0.9,0.0),surfaceColor,marbleGoldAmt);\n            specP = mix(256.0,specP,marbleGoldAmt);\n            specA = mix(1.0,specA,marbleGoldAmt);\n            difP = mix(6.0,difP,marbleGoldAmt);\n            normalCheat = mix(myNormalCheat,normalCheat,marbleGoldAmt);\n\n        }\n        if (surfaceMaterial == 3){\n\n            float splinters =\n                pow(abs( ( sin(p.x*100.0)*0.5 + sin(p.y*100.0)*0.5 ) ), 0.1)\n                *\n                (sin(p.z*2.0+sin(p.x*10.0)*4.0+sin(p.x*27.0)*3.0)*0.5+0.5);\n\n            float waves = sin(\n                p.z*10.0 +\n                sin(p.z*3.0 + sin(p.x*11.0)*0.5 )*1.0 +\n                sin((p.z + sin(p.z*0.5)*5.5)*0.15 + sin(p.x*0.8)*2.0) * 14.0 +\n                pow(abs(sin((p.x*1.0 + sin(p.x*3.0)*0.5)*25.0)),0.5) * 0.5\n            );\n\n            float grain = splinters * 0.3 + waves * 0.7;\n            grain = pow(grain*0.5+0.5,0.25);\n\n            surfaceColor = mix(vec3(0.2,0.1,0.1),vec3(0.4,0.2,0.05),grain);\n            specP = mix(30.0,20.0,grain);\n            specA = grain;\n\n        }\n\n        vec3 n = vec3(d-room(p-e.xyy,dummyMaterial),\n                      d-room(p-e.yxy,dummyMaterial),\n                      d-room(p-e.yyx,dummyMaterial));\n        n += normalCheat;\n        vec3 N = normalize(n);\n\n        vec3 pointLightPos = vec3(0.0,2.0,-4.5-fwdDist);\n        vec3 L = normalize(pointLightPos-p);\n\n        float diffuse=max(dot(N,L),0.0);\n        vec3 H = normalize(L-curCameraRayUnit);\n        float specular = max(dot(H,N),0.0);\n        color = pow(diffuse,difP)*surfaceColor + pow(specular,specP)*specA;\n\n        float lightDist = (length(pointLightPos-p)) * 0.04;\n        lightDist = max(0.0,min(1.0,lightDist));\n        color *= pow(1.0-lightDist, 2.0);\n\n    } else {\n\n        color = vec3(0.0,0.0,0.0);\n\n    }\n\n\n\n    fragColor = vec4(color,1.0);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    \n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov/180.0*PI)/2.0)*(iResolution.x/iResolution.y))*180.0/PI;\n    vec4 fovAngsMono = vec4(horizFov/2.0, horizFov/2.0, vertFov/2.0, vertFov/2.0);\n    \n\n\n    \n\n\n\n    vec2 fragFrac = fragCoord.xy/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n\n\n/*\n    vec3 cameraRight,cameraUp,cameraFwd;\n    quatToAxes(headOrientation,cameraRight,cameraUp,cameraFwd);\n\tcameraFwd *= -1.0;\n*/\n    float camLookY = sin(PI*0.5+iTime*-0.2)*0.5 - 0.25;\n    vec3 cameraRight = vec3(1.0,0.0,0.0);\n    vec3 cameraFwd = -vec3(0.0,sin(camLookY),cos(camLookY));\n    vec3 cameraUp = cross(cameraRight,cameraFwd);\n\n    \n\n\n\n\n    // position\n\n    vec3 cameraPos = vec3(0.0);\n\n\n\n\n    \n\n\n\n    float fovL = -fovAngs.x/180.0*PI;\n    float fovR =  fovAngs.y/180.0*PI;\n    float fovU = -fovAngs.z/180.0*PI;\n    float fovD =  fovAngs.w/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)/sin(PI*0.5 - fovHalfY);\n\n\n    // determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;//0 to 1\n    vPos.x -= (-fovL/(fovHalfX*2.0));\n    vPos.y -= (-fovU/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n    mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBXR3", "name": "Jack-o'-lantern", "author": "P_Malin", "description": "A shader doodle for halloween\n(Works in VR mode - try uncommmenting #define SCENE_DOMAIN_REPEAT)", "tags": ["halloween", "pumpkin"], "likes": 100, "viewed": 13341, "date": "1414360243", "time_retrieved": "2024-06-20T18:13:53.142647", "image_code": "// Jack-o'-lantern\n// @P_Malin\n\n// A little shadertoy doodle for halloween\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\n//#define SCENE_DOMAIN_REPEAT\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0, -0.5, 0.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    vLightColour *= hash(iTime) * 0.2 + 0.8;\n    float fDist = 7.0;\n\n    float fAngle = radians(190.0) + sin(iTime * 0.25) * 0.2;\n    float fHeight = 2.0 + sin(iTime * 0.1567) * 1.5;\n    \n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n\t\n    \n    if(iMouse.z > 0.0)\n    {\n        fAngle = vMouse.x * 2.0 * 3.14;\n        fHeight = vMouse.y * fDist;\n    }\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iTime < 2.0)\n    {\n        kExposure = iTime / 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\nfloat GetCarving2dDistance(const in vec2 vPos )\n{\n    if(fCarving < 0.0)\n        return 10.0;\n    \n\tfloat fMouthDist = length(vPos.xy + vec2(0.0, -0.5)) - 1.5;\n\tfloat fMouthDist2 = length(vPos.xy + vec2(0.0, -1.1 - 0.5)) - 2.0;\n\t\n\tif(-fMouthDist2 > fMouthDist )\n\t{\n\t\tfMouthDist = -fMouthDist2;\n\t}\n\n    float fFaceDist = fMouthDist;\n\n    vec2 vNosePos = vPos.xy + vec2(0.0, -0.5);\n    vNosePos.x = abs(vNosePos.x);\n    float fNoseDist = dot(vNosePos.xy, normalize(vec2(1.0, 0.5)));\n    fNoseDist = max(fNoseDist, -(vNosePos.y + 0.5));\n    if(fNoseDist < fFaceDist)\n    {\n        fFaceDist = fNoseDist;\n    }\n\n\n    vec2 vEyePos = vPos.xy;\n    vEyePos.x = abs(vEyePos.x);\n    vEyePos.x -= 1.0;\n    vEyePos.y -= 1.0;\n    float fEyeDist = dot(vEyePos.xy, normalize(vec2(-1.0, 1.5)));\n    fEyeDist = max(fEyeDist, dot(vEyePos.xy, normalize(vec2(1.0, 0.5))));\n    fEyeDist = max(fEyeDist, -0.5+dot(vEyePos.xy, normalize(vec2(0.0, -1.0))));\n    if(fEyeDist < fFaceDist)\n    {\n        fFaceDist = fEyeDist;\n    }\n    \n    return fFaceDist;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos.xy);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n    \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.5)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n    \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n\n#ifdef SCENE_DOMAIN_REPEAT\n\tfloat fRepeat = 12.0;\n\tfloat fOffset = (fRepeat * 0.5);\n\tvPumpkinDomain.xz = fract((vPos.xz + fOffset) / fRepeat) * fRepeat - fOffset;\n#endif \n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n// LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n            #ifdef SCENE_DOMAIN_REPEAT\n                float fRepeat = 12.0;\n                float fOffset = (fRepeat * 0.5);\n                vec2 vTile = floor((intersection.vPos.xz + fOffset) / fRepeat);\n            \tvPointLightPos.xz += vTile * fRepeat;\n            #endif             \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos, vPointLightPos) * vLightColour;\n            }\n            else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; // too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    // Hack for this scene when using 1 bounce.\n    // remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n\t\n    // Face glow\n    float t = -(_vRayOrigin.z + 2.8) / _vRayDir.z;\n    \n    if( t > 0.0 )\n    {\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\n\n        float fDist = abs(GetCarving2dDistance(vPos.xy * vec2(1.0, 1.0)));\n        float fDot = max(0.0, _vRayDir.z);\n        fDot = fDot * fDot;\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\n    }\n    \n    \n\treturn vColour;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragRayOri.z = -fragRayOri.z;\n    fragRayDir.z = -fragRayDir.z;\n    \n    fragRayOri *= 15.5;\n    \n    fragRayOri.y += 3.5;\n    fragRayOri.z -= 8.0;\n    \n\tvec3 vResult = GetSceneColour(fragRayOri, fragRayDir);\n\t    \n\tvResult = ApplyTonemap(vResult);\n\t\n\tvResult = ApplyGamma(vResult);\t\t\n    \n    vResult = ApplyBlackLevel(vResult);\n    \n    fragColor = vec4( vResult, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBXR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBXRK", "name": "Moving Lights", "author": "blastxu", "description": "Three harcoded lights moving, they can blend together. Added a conical light.", "tags": ["2d"], "likes": 7, "viewed": 304, "date": "1413678122", "time_retrieved": "2024-06-20T18:13:53.142647", "image_code": "//This holds the lights\nstruct LightSource{\n\n    float InnerRad;  //Ligh has full force until it reaches this point\n    float OuterRad;  //Light goes diffuminating from end of inner to end of outer\n    float Intensity; //How \"strong\" this light is\n    vec4  Color;     //Color of the light duh!\n    vec4  Pos;//Position of this light\n};\n\n    struct ConeLight{\n\tvec4 Position;\n\tvec4 WhereToLook;\n\tfloat Angle;\n\tfloat Luminosity;\n\tvec4 LightTint;\n\tfloat Reach; //How far can this light go.\n};\n\nfloat lerp(float p0, float p1, float t)\n{\n  return (1.0 - t) * p0 + t * p1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ConeLight Cone;\n\tCone.Position = vec4(iResolution.x / 2.0, iResolution.y/2.0,  0.0, 1.0);\n\tCone.WhereToLook = vec4(cos(iTime) * iResolution.x, sin(iTime) * iResolution.y, 0.0, 1.0);\n\tCone.Angle = 2.0;\n\tCone.LightTint = vec4(1.0, 1.0, 0.0, 1.0);\n\tCone.Reach = 300.0;\n\tCone.Luminosity = 2.0;\n    \n    LightSource lights[3];\n    \n    //Lights\n    lights[0].InnerRad = 50.0;\n    lights[0].OuterRad = 100.0;\n    lights[0].Intensity = 1.0;\n    lights[0].Color = vec4(1.0, 0.0, 0.0, 1.0);\n    lights[0].Pos = vec4((cos(iTime) * iResolution.x)/2.0 + 50.0, iResolution.y/2.0, 0.0, 1.0);\n    \n    lights[1].InnerRad = 50.0;\n    lights[1].OuterRad = 100.0;\n    lights[1].Intensity = 1.0;\n    lights[1].Color = vec4(0.0, 1.0, 0.0, 1.0);\n    lights[1].Pos = vec4(iResolution.x/2.0, (sin(iTime) * iResolution.y)/2.0, 0.0, 1.0);\n    \n    lights[2].InnerRad = 50.0;\n    lights[2].OuterRad = 100.0;\n    lights[2].Intensity = 1.0;\n    lights[2].Color = vec4(0.0, 0.0, 1.0, 1.0);\n    lights[2].Pos = vec4((sin(iTime) * -iResolution.x)/2.0 + iResolution.x - 50.0, iResolution.y/2.0, 0.0, 1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Tint for this fragment\n    vec4 FragTint = vec4(-1.0, -1.0, -1.0, -1.0); \n    \n    for(int i = 0; i < 3; ++i)\n  \t{\n    \t//This is the distance to the center of the \n    \t//light source\n        float Distance = length(vec4(fragCoord,0.0,1.0) - lights[i].Pos);\n        Distance /= lights[i].InnerRad;\n        float OutRad = lights[i].OuterRad/ lights[i].InnerRad;\n        if(Distance < 1.0)\n          FragTint += (lights[i].Color * lights[i].Intensity);\n        else if(Distance < OutRad)\n          FragTint += lights[i].Color * lights[i].Intensity * lerp(1.0, 0.0, (Distance - 1.0) / (OutRad - 1.0));\n  \t}\n    \n      //Get the vector for the cone direction\n    vec4 DirectionToLook = Cone.WhereToLook - Cone.Position;\n    DirectionToLook = normalize(DirectionToLook);\n\t\n    //Get the vector to the fragment\n\tvec4 DirectionToFrag = vec4(fragCoord,0,1) - Cone.Position;\n\tDirectionToFrag = normalize(DirectionToFrag);\n  \n \t//Get the angle between  vectors\n\tfloat ResultantAngle = acos(dot(DirectionToLook, DirectionToFrag));\n\t\n    //Get the distance to that fragment from the center\n    float DistanceFromOrigin = length(vec4(fragCoord, 0, 1) - Cone.Position);\n    //Normalize distance\n    float Normalizeddistance = DistanceFromOrigin/Cone.Reach;\n    \n\t//Normalise the angles\n\tfloat AngleToCompare = ResultantAngle / (Cone.Angle/2.0);\n    \n    if(AngleToCompare <= 1.0 && Normalizeddistance <= 1.0)\n\t\tFragTint += Cone.LightTint * Cone.Luminosity * smoothstep(1.0, 0.0, AngleToCompare) * smoothstep(1.0, 0.0, Normalizeddistance);     \n    \n    \n    vec4 Color = texture(iChannel0, uv);\n    Color += FragTint;\n\tfragColor = Color;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBXRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjSDD", "name": "Twisty bendy", "author": "Coldberg", "description": "oldschool rubber/jelly box effect", "tags": ["effect", "rubber", "box", "twist", "jelly"], "likes": 20, "viewed": 1124, "date": "1412360107", "time_retrieved": "2024-06-20T18:13:53.142647", "image_code": "#define EPSILON \t0.005\n#define MAXDIST \t100.0\n#define MAXSTEPS\t100\n#define FOV\t\t\t60.0\n#define MSAA\n\nmat3 rotate_x (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (1.0, 0.0, 0.0),\n\t\tvec3 (0.0, cfi, -sfi),\n\t\tvec3 (0.0, sfi, cfi)\n\t);\n}\n\nmat3 rotate_y (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, 0.0, sfi),\n\t\tvec3 (0.0, 1.0, 0.0),\n\t\tvec3 (-sfi, 0.0, cfi)\n\t);\n}\n\nmat3 rotate_z (float fi) {\n\tfloat cfi = cos (fi);\n\tfloat sfi = sin (fi);\n\treturn mat3 (\n\t\tvec3 (cfi, -sfi, 0.0),\n\t\tvec3 (sfi, cfi, 0.0),\n\t\tvec3 (0.0, 0.0, 1.0)\n\t);\n}\n\nvec4 tex3d (sampler2D t, vec3 pt, vec3 pn, float scale) {\n\treturn \n\t\ttexture  (t, pt.yz*scale)*abs (pn.x) +\n\t\ttexture  (t, pt.xz*scale)*abs (pn.y) +\n\t\ttexture  (t, pt.xy*scale)*abs (pn.z);\n}\n\nfloat map (vec3 p, float t) {\n    vec3 b = vec3 (0.5, 2.0, 0.5);\n    float r = 0.1;\n \treturn length(max(abs(p)-b,0.0))-r; //length(max(abs(p) - b, 0.0));\n}\n\nvec3 normal (vec3 p, float t) {\n    float d = map (p, t);\n    return normalize (vec3 (\n        map (p - vec3 (EPSILON, 0.0, 0.0), t) - d,\n        map (p - vec3 (0.0, EPSILON, 0.0), t) - d,\n        map (p - vec3 (0.0, 0.0, EPSILON), t) - d\n    ));\n}\n\nfloat march (vec3 ro, vec3 rd, float time) {\n \tfloat d = EPSILON;\n    float t = 0.0;\n    \n    for (int i = 0; i < MAXSTEPS; ++i) {\n     \tvec3 p = ro + rd * d;\n       \tt = map (p, time);\n        if (t < EPSILON || d >= MAXDIST) \n            break;\n        d += t;\n    }\n    return d;\n    \n}\n\nvec3 hsv2rgb (vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 frame (vec2 uv, float t) {\n    uv *= tan (radians (FOV)/2.0);\n\tvec3 up = vec3 (0.0, 1.0, 0.0) ;\n\tvec3 fw = vec3 (1.0, 0.0, 0.0) * rotate_y (t);\n\tvec3 rt = cross (fw, up); \n    \n    vec3 rd = normalize (uv.y * up + uv.x * rt + fw);\n    vec3 ro = -5.0*fw;\n    \n    \n    float d = march (ro, rd, t);\n    vec3 p = ro + d*rd;\n    vec3 nm = normal (p, t);\n    \n    float dl = max (dot (nm, fw), 0.0);\n \n        \n    if (d < MAXDIST) {\n     \treturn vec4 (hsv2rgb (vec3 (tex3d (iChannel0, p, nm, 0.25).r, 1.0, 1.0))*pow (dl,2.0),1.0);\n    }\n    \n    return vec4 (1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/\n\t\tmin (iResolution.x, iResolution.y);\n    \n    float t = iTime + cos (uv.y)*sin (iTime)*uv.y*4.0;\n    float d = 0.25/min (iResolution.x, iResolution.y);\n    #ifdef MSAA\n\tfragColor = 0.125*(\n        frame (uv+1.0*vec2(+d, +d), t)+\n        frame (uv+1.0*vec2(-d, +d), t)+\n        frame (uv+1.0*vec2(-d, -d), t)+\n        frame (uv+1.0*vec2(+d, -d), t)+        \n        frame (uv+2.0*vec2(+d, +d), t)+\n        frame (uv+2.0*vec2(-d, +d), t)+\n        frame (uv+2.0*vec2(-d, -d), t)+\n        frame (uv+2.0*vec2(+d, -d), t)\n   );\n    #else\n\tfragColor = frame (uv, t);\n    #endif        \n    \n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjSDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjSRG", "name": "terrain marching 7", "author": "rmotfage", "description": "v7\ncolors", "tags": ["procedural", "terrain"], "likes": 7, "viewed": 346, "date": "1413533033", "time_retrieved": "2024-06-20T18:13:55.397369", "image_code": "\nprecision highp float;\n\n#define LACU 2.0\n#define MAXGRASSSTEEP 0.4\n#define MAXGRASSALTITUDE .8\n#define MAXSNOWSTEEP   0.35\n#define MAXSNOWALTITUDE 0.4\n#define NORMALEPSILON 0.02\n#define SEALEVEL 0.01 //std 0.3\n#define CAMERAALTITUDE 1.3 //std 1.0\n#define CAMERASCREENDISTANCE 0.5 //std 0.4\n#define LOWITER 5\n#define HIGHITER 8\n#define COLORITER 5\n#define PENUMBRAFACTOR 0.01\n\n\n\n\n/* ****************************************************************** */\nfloat conv(float f) {\n\tf*=f*f*f;  //sealevel 0.01 - flat landscape with few hills\n\t//f = f *(f *(f *(16.5333 - 6.4 * f )-13.6)+4.46667);\n\t//f = f* (f* (f* (f* (33.4169-13.3668 *f)-29.2398)+10.4428)-0.253133); // plains with holes\n\t//f = f* (f* (f* (f* (f* (119.616-40.3125 *f)-131.004)+63.0956)-11.5608)+1.16577);\n    if (f < SEALEVEL){f = SEALEVEL;}\n    return f;\n}\n\n\n// ***** noise code ***************************************************\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//iq hash\nfloat hash( float n )\n{\n    return fract(sin(n)*54321.98761234);  // value has no meaning that I could find\n}\n\n//iq derivative noise function\n// returns vec3(noise, dnoise/dx, dnoise/dy)\nvec3 noised(vec2 pos )\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n    \n    vec2 u = (10.0+(-15.0+6.0*f)*f)*f*f*f;  // f=6*x^5-15*x^4+10*x^3  df/dx=30*x^4-60*x^3+30*x^2; horner of df is 30.0*f*f*(f*(f-2.0)+1.0)\n    \n    float n = p.x + p.y*57.0;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0); // do not know why 57 & 58\n    float d = hash(n+ 58.0);\n    \n    return vec3( a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n    30.0*f*f*(f*(f-2.0)+1.0) * (vec2(b-a,c-a)+(a-b-c+d)*u.yx) );\n    \n}\n\n//iq  noise function\nfloat noise(vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    f= (10.0+(-15.0+6.0*f)*f)*f*f*f; // smooth\n    \n    float n = p.x + p.y*57.0;\n    \n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \n    return res;\n}\n\n\n/* ****************************************************************** */\n\n\n/* ****************************************************************** */\n\n\n// fractional brownian motion\n// iter is number of octaves\n\nvec3 fbmDerivative(vec2 p, int iter) {\n    \n    float f = 0.0;\n\tfloat dfx = 0.0;\n\tfloat dfy = 0.0;\n    float fLacunarity = LACU;\n    \n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\t\t\n\tfor (int i=0;i<20;i++) {\n\t\tvec3 value = noised( p ); \n\t\t\n\t\tf += amplitude * value.x;\n\t\tdfx +=  value.y;\n\t\tdfy +=  value.z;\n\t\tp = p * fLacunarity; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif (i>iter) {break;}\n\t}\n\tf/=sumAmplitude;\n\t\n    return vec3( conv(f), dfx, dfy);\n}\n\n// same as above, without derivatives\nfloat fbm(vec2 p, int iter){\n\tint idx=0;\n    float f = 0.0;\n\tfloat amplitude = 0.5;\n\tfloat sumAmplitude = 0.0;\n\tfor (int i=0;i<20;i++) {\n\t\tfloat value = noise( p ); \n\t\tf += amplitude * value;\n\t\tp = p * LACU; \n\t\tsumAmplitude+=amplitude;\n\t\tamplitude/=2.0;\n\t\tif ( i>iter ) {break;}\n\t}\n\tf/=sumAmplitude;\n    return conv(f);\n}\n\nvec3 getNormal( vec3 p, int iter ) {\n\t//using noise derivative\n\t//not sure this code is correct\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, iter);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); } //sea is flat\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n// #####################################################################\nvec3 GenerateTerrainColor(vec3 position, vec3 normal) {\n    float x = position.x;\n    float y = position.z;\n    float z = position.y;\n\tfloat n = getNormal(position,COLORITER).y;\n    float l = 1.0;\n    vec3 terrainColor;\n    vec3 cmin,cmax;\n    \n    // notes\n    \n//Surface de lac 0,02 Ã  0,04 \n//ForÃªt de conifÃ¨res 0,05 Ã  0,15 \n//Surface de la mer 0,05 Ã  0,15 \n//Sol sombre 0,05 Ã  0,15 \n//Cultures 0,15 Ã  0,25 \n//Sable lÃ©ger et sec 0,25 Ã  0,45 \n//Calcaire[1] environ 0,40 \n//Glace environ 0,60 \n//Neige tassÃ©e 0,40 Ã  0,70 \n//Neige fraÃ®che 0,75 Ã  0,90 \n//Miroir parfait 1 \n\n    \n    // *** palette ***\n    \n    // water\n    vec3 ocean      = vec3( 0.08, .12, .5);\n    vec3 shore      = vec3( 0.1, .2,.6);\n    \n    // base layer\n    vec3 beach      = vec3(224.0, 202.0, 181.0)/255.0; \n    vec3 earth      = vec3(239.0, 200.0, 143.0)/255.0; \n    vec3 calcaire   = vec3(132.0, 50.0, 50.0)/255.0;  // marron rouge\n    vec3 rocks      = vec3(105.0, 85.0, 110.0)/255.0; // gris\n    \n    // grass layer\n    vec3 grass1 = vec3 (8.0, 24.0, 4.0)/255.0;\n    vec3 grass2 = vec3 (16.0, 48.0, 4.0)/255.0;\n    \n    // snow layer\n    vec3 snow1 = vec3 ( .78,.78,.78);\n    vec3 snow2 = vec3 ( .9,.9,.9);\n    \n    if ( z <= SEALEVEL) {\n        //water\n        terrainColor = mix (ocean, shore , smoothstep( 0.0, 1.0,  noise( position.xz * 16.0)) );    \n\t\t//terrainColor=shore;\n        return terrainColor;\n    }\n    \n    \n\t// add some noise\n\t// input noise divisor define size of stains in transition areas\n    // multiplicator define the size of the range of altitude with mixed color\n    z += noise( position.xz * 32.0 )* 0.1;   \n    \n    // base color\n    terrainColor = mix (        beach,    earth, smoothstep(SEALEVEL    , SEALEVEL+0.1 , z) );\n    terrainColor = mix ( terrainColor, calcaire, smoothstep(SEALEVEL+0.1, SEALEVEL+0.3 , z) );\n    terrainColor = mix ( terrainColor,    rocks, smoothstep(SEALEVEL+0.3,          1.0  , z) );\n    \n    //add grass\n    if (( n > MAXGRASSSTEEP ) && ( z <  MAXGRASSALTITUDE )) {\n        terrainColor = mix( grass1, grass2, smoothstep(0.0 , 1.0, noise( position.xz * 32.0 )));\n    }\n    \n    // add snow\n    if (( n > MAXSNOWSTEEP) && ( z > MAXSNOWALTITUDE )) {\n        return mix( snow1, snow2, smoothstep(0.0 , 1.0, noise( position.xz * 1.0 )*0.1));\n\t}\n    return vec3(terrainColor);;\n}\n\n\n\n// ###################################################################\n\n\n\n// ###################################################################\nvec4 castRay( vec3 startPosition, vec3 lookatDirection )  {\n    // return vec4 = last worldPosition, 1 if terrain / 0 if sky\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n    vec3 p;\n\tfloat delta;\n    lastStep=step;\n    for( int i = 0; i < 180; i++ ) { // GLSL limitation: loop on int only\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z),LOWITER);\n\t\tdelta = p.y -  altitude;\n        if(delta<0.0 ){\n            // we are under floor: linear interpolate the intersect\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            altitude = fbm( vec2(p.x, p.z),HIGHITER ); //high definition altitude\n            return vec4(p.x,altitude,p.z,walkStep);\n        }\n        if( p.y <  0.001){\n\t\t\t// under the flow, exit\n            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);\n            p = startPosition + lookatDirection * walkStep;\n            return vec4(p.x,0,p.z,walkStep);\n        }\n        if (p.y > 5.0) {break;} // far in the sky\n        lastAltitude = altitude;\n        lastStep=step;\n        lastY = p.y;\n        step = max(max(0.05,.5*delta) , float(i)/2000.0); // step is big when far from floor and far from camera\n\t\t//step+=0.0005;\n        walkStep += step;\n        \n    }\n    return  vec4(p.x,p.y,p.z,-walkStep);  \n}\n\n// ###################################################################\n\nvec3 calcLookAtDirection( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface (since we locked horizon at horizontal ):its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  (screenPointInWorld-cP);\n    \n}\n\n// #################################################################\n\nvec3 calcStartPosition( vec3 cP, vec3 cD, float screenDistance, vec2 z ){\n    // cameraPosition\n    // cameraDirection\n    // camera-screen distance\n    // position of pixel on screen\n    \n    // normalize camera direction\n    vec3 cDnorm = normalize (cD);\n    \n    // we are looking for u & v, the unity vectors on screen, in world coordinates\n    // we know that u is // to surface =&gt; its Y is 0\n    // we know that cDnorm is perpendicular to u\n    // we project to surface to find u.x and u.y\n    vec3 u = vec3(cDnorm.z, 0.0,cDnorm.x);\n    \n    vec3 v = cross( cDnorm, u);\n    \n    //screen point 0,0 in world coordiante\n    vec3 screenPointOO = cP + cDnorm * screenDistance;\n    \n    //z in world coordiantes\n    vec3 screenPointInWorld= screenPointOO + u*z.x + v*z.y;\n    \n    return  screenPointInWorld;\n    \n}\n\n// #################################################################\nvec3 getNormal( vec3 p ) {\n\t//noise derivative\n    vec3 value;\n\tvalue = fbmDerivative( p.xz, HIGHITER);\n\tif (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); }\n\tfloat dfx=value.y;\n\tfloat dfz=value.z;\n\t//float vy = 1.0 ;\tvy -= dfx*dfx + dfz*dfz;vy=sqrt(vy);\n\t\n\treturn normalize(vec3( -value.y, 1.0, -value.z));\n}\n\n\n vec3 getNormalC( vec3 p ) {\n\t//central differences\n    float eps=NORMALEPSILON;\n    vec3  n = vec3( fbm( vec2(p.x-eps,p.z), HIGHITER ) - fbm( vec2(p.x+eps,p.z), HIGHITER ), \n\t\t\t\t  \t2.0*eps,\n    \t\t\t\tfbm(vec2(p.x,p.z-eps), HIGHITER ) - fbm(vec2(p.x,p.z+eps), HIGHITER ) );\n    return normalize( n );\n}\n\n\n// #################################################################\nfloat castRay2Sun( vec3 startPosition, vec3 lookatDirection )  {\n    float step = 0.03;\n    float lastStep;\n    float altitude = 0.0;\n    float lastAltitude;\n    float lastY;\n    float walkStep = 0.0;\n\tfloat delta;\n    float result = 1.0;\n    vec3 p;\n    lastStep=step;\n    for( int i = 0; i < 20; i++ ) { // GLSL limitation: loop on int only\n        walkStep += step;\n        p = startPosition + lookatDirection * walkStep;\n        altitude = fbm( vec2(p.x, p.z) , HIGHITER);\n\t\tdelta = p.y -  altitude;\n        \n        // if we are about to intersect (=> delta is small)\n        // and we are not too far from our starting point ( / walkStep)\n        // we are on the border of the penumbra\n        // so we can shade by penumbrafactor + constantThatDefineBorderSize * delta/walkstep\n        result = min( result, PENUMBRAFACTOR + 16.0 * delta / walkStep );\n\t\t\n        if( delta < .0){\n\t\t\treturn PENUMBRAFACTOR; //penombre \n        }        \n        \n        \n    }\n    return result;  \n    //return 1.0;\n}\n\nvec3 getShading( vec3 position , vec3 normal ) {\n    vec3 uAmbientColor = vec3 (0.18, 0.18, 0.2) / 2.0;         // ambiant light color\n    vec3 uLightingDirection = vec3(-0.9, 0.2, 0.1); // sunlight direction\n    vec3 uDirectionalColor = vec3( 1.47, 1.35, 1.25);  // sunlight color\n    \n    float penombre = 1.0;\n    vec3 color;\n    \n    // march to sun. if we intersect a moutain, we are in its shadow\n    penombre = castRay2Sun(  position ,uLightingDirection) ;\n    //if (castRay2Sun(  position ,uLightingDirection) < 1.0) {penombre=vec3(0.1);}\n    \n    \n    //directional lightning (sun)\n    float directionalLightWeighting = max(dot(normal, uLightingDirection), 0.0);\n    \n    //final lightning: ambiant, sun, penumbra\n    color = uAmbientColor;\n    color += uDirectionalColor * directionalLightWeighting * penombre;\n    \n\t//color = vec3(1.0, 1.0, 1.0) * penombre; // usefull to debug penumbra\n    \n    return color;\n    \n}\n\n// #################################################################\n\nvec4 applyFog ( vec3 color, float far) {\n\t//just to hide clipping\n    return vec4( mix( color ,vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,far/25.0) ) ,1.0);\n}\n\n// #################################################################\n\nvec4 colorize(vec3 startPosition, vec3 lookatDirection, vec4 position) {\n    \n    vec3 p = position.xyz; //startPosition + lookatDirection * position.w;\n    vec3 n = getNormal( p );\n    vec3 s = getShading( p, n );\n    vec3 m = GenerateTerrainColor( position.xyz, n ); //getMaterial( p, n );\n    return applyFog( m * s, position.w );\n    \n    //return vec4(  m *s ,1.0);\n    \n}\n\n// ###################################################################\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 uCameraXYZ = vec3( 0.0, CAMERAALTITUDE, 0.0); // camera postion\n    vec3 uCameraDirXYZ = vec3(0, -0.40, .707160) ; // camera direction\n    vec4 color;\n    \n    uCameraXYZ.z = iTime/1.9;\n\t\n    \n    float uScreenDistance = CAMERASCREENDISTANCE;  // distance camera/screen\n    \n    \n    float sx=float(iResolution.x);\n    float sy=float(iResolution.y);\n    vec2 z,zn;\n    \n    z.x = fragCoord.x / sx - 0.5;\n    z.y = fragCoord.y / sy - 0.5;\n    \n    vec3 lookatDirection = calcLookAtDirection( uCameraXYZ,uCameraDirXYZ, uScreenDistance, z );\n    vec3 startPosition  = calcStartPosition( uCameraXYZ, uCameraDirXYZ, uScreenDistance, z );\n    \n    vec4 gotcha = castRay( startPosition, lookatDirection );\n    \n    if (gotcha.w > 0.0 ) {\n        color = colorize( startPosition, lookatDirection, gotcha);\n        } else {\n        // sky color;\n        color = vec4( mix ( vec3(0.7,0.9,1.0), vec3(0.5,0.5,0.6), smoothstep(0.0,1.0,-gotcha.w/30.0)), 1.0);\n        \n    }\n    \n    // gamma correction\n    fragColor = pow( color, vec4(1.0/2.2,1.0/2.2,1.0/2.2,1.0) );\n    \n}   // main", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdjXzK", "name": "Rotating Colors", "author": "mAlk", "description": "My first tests with shadertoy. Starting from iq's colored squares I ended up with this.", "tags": ["2d", "rotation"], "likes": 1, "viewed": 128, "date": "1413976115", "time_retrieved": "2024-06-20T18:13:55.397369", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat2 ro = mat2(cos(iTime/8.0),sin(iTime/8.0),-sin(iTime/8.0),cos(iTime/8.0));\n    vec2 uv = ro*(fragCoord.xy-iResolution.xy/2.0)+iResolution.xy/2.0;\n    vec2 px = 2.0*(iResolution.xy-2.0*uv)/iResolution.xy;\n    vec3 co = 0.5+0.5*(cos(iTime+4.0*px.x*px.y+vec3(3.142,1.571,0.0)));\n    fragColor = vec4(mix(co.zxy,co.xyz,abs(sin(iTime*0.25))),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjXzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSSzV", "name": "Belgian Flag", "author": "yakoudbz", "description": "Simple shader for test", "tags": ["fast", "flag", "fps", "belgium", "60fps", "belgique", "belgie"], "likes": 2, "viewed": 268, "date": "1413760053", "time_retrieved": "2024-06-20T18:13:55.397369", "image_code": "// \n//***** BELGIAN FLAG ***** \n// by Yakoudbz\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat siny = sin(fragCoord.y/iResolution.y*15.+iTime*7.);\n\tfloat x = fragCoord.x/iResolution.x -siny/300.;\n\t\n\tfloat red = smoothstep(.3,.31,x);\n    float green = min(red,smoothstep(.7,.69,x));\n    \n\tfragColor = vec4( red*.7 ,green*.5, .0, 1. )-siny/20.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSXzy", "name": "Checkerboard 3D", "author": "kuvkar", "description": "checkerboard on the move!", "tags": ["raytracing", "antialiasing"], "likes": 8, "viewed": 448, "date": "1413210007", "time_retrieved": "2024-06-20T18:13:55.397369", "image_code": "mat4 cam;\nmat3 rot;\nvec3 lookFrom;\nvec3 lookAt;\n\nvec2 _fragCoord;\n\n\nstruct Plane\n{\n    vec3 normal;\n    vec3 position;\n};\n\nstruct Ray\n{\n    vec3 from;\n    vec3 direction;\n};\n\nconst int NUM_PLANES = 1;\n\n//#define USE_TEXTURE \n\nPlane planes[NUM_PLANES];    \n    \nvec4 trace(Ray ray)\n{\n    for (int i = 0; i < NUM_PLANES; ++i)\n    {\n        \n        \n        Plane p = planes[i];\n        vec3 originalPosition = p.position;\n        \n        float a = dot(p.position - ray.from, p.normal);\n        float b = dot(ray.direction, p.normal);\n        float t = a / b;\n\n        vec3 worldpos = ray.from + ray.direction * t;\n        vec2 uv = vec2(worldpos.x, worldpos.z);\n\n        #ifdef USE_TEXTURE\n        uv *= 0.16;\n        vec4 tex = texture(iChannel0, uv);\n        #endif\n        \n        if (t > 0.0)\n        {\n            float c = 0.0;\n\n            if(mod(worldpos.x, 1.0) > 0.5 && mod(worldpos.z, 1.0) > 0.5)\n            {\n                c = 1.0;\n            }\n\n            if(mod(worldpos.x, 1.0) < 0.5 && mod(worldpos.z, 1.0) < 0.5)\n            {\n                c = 1.0;\n            }\n            #ifdef USE_TEXTURE\n            return tex;\n\t\t\t#else\n            return vec4(c, 0.41 * float(i + 1), 0.0, 1.0);\n            #endif\n            \n        }\n\n    }    \n    \n    return vec4(0.0,0.25,_fragCoord.y / iResolution.y, 0.0);\n}\n\nvec2 getNormalizedPosition(vec2 screenCoord)\n{\n    float midx = iResolution.x * 0.5;\n    float midy = iResolution.y * 0.5;\n    \n    float mx = screenCoord.x - midx;\n    float my = screenCoord.y - midy;\n    return vec2(mx / midx, my / midy);\n}\n\n\nRay getRay(vec2 screenCoord)\n{\n    vec3 p = vec3(getNormalizedPosition(screenCoord), 0.0);\n    \n    Ray r;\n    r.from = lookFrom;\n    \n    vec3 look = lookAt - lookFrom;\n    \n    p.z = look.z;\n    p.z /= length(look);\n    p = normalize(p);\n    r.direction = p;\n    r.direction *= rot;\n    \n    return r;\n}\n\n\nvoid lookat(vec3 to)\n{\n    lookAt = to;\n    vec3 fwd = normalize(lookFrom - to);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 v = normalize(cross(up, fwd));\n    vec3 w = normalize(cross(fwd, v));\n    \n    rot[0] = v;\n    rot[1] = w;\n    rot[2] = fwd;\n\n\n}\n\nvec4 drawPlanes()\n{\n    \n    vec4 totalCol = vec4(0.0, 0.0, 0.0, 0.0);    \n\tconst int kernel = 11;\n    const float filterOffset = 1.0 / float(kernel);\n    \n    for (int x = -kernel; x < kernel; x+=2)\n    {\n        for (int y= -kernel; y < kernel; y+=2)\n        {\n            vec2 offset = vec2(x, y) * filterOffset;\n            \n            vec2 pos = _fragCoord.xy + offset;\n\t\t    Ray r = getRay(pos);\n\t\t    totalCol += trace(r);\n        }\n    }\n    vec4 col = totalCol / float (kernel * kernel);\n    return col;\n}\n\nvec3 rotateX(float angle, vec3 point)\n{\n    mat3 rotx;\n    rotx[0] = vec3(1.0, 0.0, 0.0);\n    rotx[1] = vec3(0.0, cos(angle), -sin(angle));\n    rotx[2] = vec3(0.0, sin(angle), cos(angle));\n    return rotx * point;\n}\n\nvec3 rotateZ(float angle, vec3 point)\n{\n    mat3 rotz;\n    rotz[0] = vec3(cos(angle), -sin(angle), 0.0);\n    rotz[1] = vec3(sin(angle), cos(angle), 0.0);\n    rotz[2] = vec3(0.0, 0.0, 1.0);\n    return rotz * point;\n}\n    \n    \nvoid rotateCamZ(float angle)\n{\n    mat3 rotz;\n    rotz[0] = vec3(cos(angle), -sin(angle), 0.0);\n    rotz[1] = vec3(sin(angle), cos(angle), 0.0);\n    rotz[2] = vec3(0.0, 0.0, 1.0);\n    \n    rot *= rotz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _fragCoord = fragCoord;\n    float move = iTime;\n    lookFrom = vec3(0.0, -0.0, -move * 2.0);\n    \n    vec3 at = vec3(0.0, -0.0, -1.0);\n    \n    lookat(lookFrom + at);\n    \n    \n    rotateCamZ(sin(move * 0.5) * 0.5);\n    \n    Plane p;\n    p.position = vec3(0.0, -1.0, 1.0);\n    p.normal = vec3(0.0, 1.0, 0.0);\n    planes[0] = p;\n    fragColor = drawPlanes();\n    \n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSXzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2SzV", "name": "sdf raymarching: min rings", "author": "hornet", "description": "from the demo 'min' by loopit: http://www.pouet.net/prod.php?which=62851\n- code cleaned up a bit, but still in a terrible state\n\nadded a hue-offset not present in original (as it looks cool :D )", "tags": ["raymarching", "sdf", "distance", "min", "loopit"], "likes": 52, "viewed": 2469, "date": "1414085404", "time_retrieved": "2024-06-20T18:13:57.058082", "image_code": "const vec4 parms = vec4( 0.0, -1.0, 0.0, 2.25 );\nconst vec4 parms2 = vec4( 1, 10, -0.05, 1.0 );\nconst vec4 parms3 = vec4( 0.075, 0.1, 1, 1 );\n\nconst vec4 camctr = vec4( 0, -10, 0, 1 );\nconst vec4 campos = vec4( 7, 8, 9, 1 );\n\nconst float PI = 3.14159265358979;\n\nconst float NEAR_CLIP = 2.8;\nconst float FAR_CLIP = 30.0;\n\n#define NUM_ITERATIONS 128\nconst float NUM_ITERATIONS_F = float(NUM_ITERATIONS);\nconst float TERM_DIST = 0.5;\nconst float STEP_MULT = 0.25;\n\nconst float ASPECT  = 2.35;\nconst float ASPECT0 = 16.0/9.0;\n\n\n//nvidia hsv\nfloat min_channel(vec3 v)\n{\n\tfloat t = (v.x<v.y) ? v.x : v.y;\n\tt = (t<v.z) ? t : v.z;\n\treturn t;\n}\n\nfloat max_channel(vec3 v)\n{\n\tfloat t = (v.x>v.y) ? v.x : v.y;\n\tt = (t>v.z) ? t : v.z;\n\treturn t;\n}\nvec3 rgb_to_hsv(vec3 RGB)\n{\n\tvec3 HSV = vec3(0,0,0);\n\tfloat minVal = min_channel(RGB);\n\tfloat maxVal = max_channel(RGB);\n\tfloat delta = maxVal - minVal; //Delta RGB value \n\tHSV.z = maxVal;\n\t// If gray, leave H & S at zero\n\tif (delta != 0.0) { \n\t\tHSV.y = delta / maxVal;\n\t\tvec3 delRGB;\n\t\tdelRGB = ( ( vec3(maxVal) - RGB ) / 6.0 + ( delta / 2.0 ) ) / delta;\n\t\tif      ( RGB.x == maxVal ) HSV.x = delRGB.z - delRGB.y;\n\t\telse if ( RGB.y == maxVal ) HSV.x = 1.0/3.0 + delRGB.x - delRGB.z;\n\t\telse if ( RGB.z == maxVal ) HSV.x = 2.0/3.0 + delRGB.y - delRGB.x;\n\t\tif ( HSV.x < 0.0 ) { HSV.x += 1.0; }\n\t\tif ( HSV.x > 1.0 ) { HSV.x -= 1.0; }\n\t}\n\treturn (HSV);\n}\nvec3 hsv_to_rgb(vec3 HSV)\n{\n\tvec3 RGB = HSV.zzz;\n\tif ( HSV.y != 0.0 ) {\n\t\tfloat var_h = HSV.x * 6.0;\n\t\tfloat var_i = floor(var_h); // Or ... var_i = floor( var_h )\n\t\tfloat var_1 = HSV.z * (1.0 - HSV.y);\n\t\tfloat var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));\n\t\tfloat var_3 = HSV.z * (1.0 - HSV.y * (1.0-(var_h-var_i)));\n\t\tif      (var_i == 0.0) { RGB = vec3(HSV.z, var_3, var_1); }\n\t\telse if (var_i == 1.0) { RGB = vec3(var_2, HSV.z, var_1); }\n\t\telse if (var_i == 2.0) { RGB = vec3(var_1, HSV.z, var_3); }\n\t\telse if (var_i == 3.0) { RGB = vec3(var_1, var_2, HSV.z); }\n\t\telse if (var_i == 4.0) { RGB = vec3(var_3, var_1, HSV.z); }\n\t\telse                 { RGB = vec3(HSV.z, var_1, var_2); }\n\t}\n\treturn (RGB);\n}\n\n\n// ============================================================\n// most primitive distance-functions honestly stolen from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\nvec3 sat( vec3 t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\n\n// ====\nvec4 select( vec4 a, vec4 b ) {\n\treturn (a.x<b.x) ? a : b;\n}\n\n// ====\nvec2 rot2d( vec2 p, float a )\n{\n\tvec2 sc = vec2(sin(a),cos(a));\n\tvec2 ret;\n\tret.x = dot( p, sc.yx*vec2(1,-1) );\n\tret.y = dot( p, sc.xy );\n\treturn ret;\n}\n\n// ====\n//note: local sphere, radius r\nfloat sdSphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\n// ====\nfloat sdPlane( vec3 p, vec3 pointonplane, vec3 norm )\n{\n\treturn dot( norm, p-pointonplane);\n}\n\n//note: [-1;1[\n//note: honestly stolen from iq: https://www.shadertoy.com/view/Xsl3Dl\nvec3 shash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat mytrunc( float x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\nvec3 mytrunc( vec3 x, vec3 num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\n\n\nvec2 sdHalfCircle( vec3 p )\n{\n\tvec3 ofs = shash3( mytrunc( p, vec3(13)));\n    vec3 h2 = shash3( mytrunc( p, vec3(32) + ofs ) );\n    vec3 h3 = shash3( mytrunc( p, vec3(16) ) );\n\tp += 0.02  * h2;\n\tp += 0.01  * h3;\n\n\tconst float spherer = 1.0;\n\tfloat ds = sdSphere( p, spherer );\n\tds = max( ds, -sdSphere( p, 0.9 * spherer ));\n\tds = max( ds,  p.x-0.1);  //cut sides\n\tds = max( ds, -p.x-0.1); // -\n\t\n    vec2 ret;\n    ret.x = ds + parms2.z + 0.001*(iMouse.z>0.5 ? iMouse.x : 0.0 );\n    ret.y = min( max(h3.x, h2.x ), max( ofs.x, h2.y ) );\n    ret.y = step( 0.75, ret.y );\n\treturn ret;\n}\n\nvec2 sel_min( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec4 cylinder_radialrepeat( vec3 p, float r )\n{\n\tvec2 d = vec2( FAR_CLIP, 0 );\n\n\tp *= parms2.w;\n\t{\n\t\tvec3 dp = p; //vec3( dp2d.x, p.y, dp2d.y );\n\n\t\tdp.zx = rot2d( dp.xz, 0.3*iTime );\n\t\tvec2 ds = sdHalfCircle( dp );\n\n\t\tdp.xy = rot2d( dp.xy, -0.7 * iTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*1.3 ) );\n\n\t\tdp.xz = rot2d( dp.xz, 1.1*iTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*1.8 ) );\n\n\t\tdp.xz = rot2d( dp.xz, -1.3*iTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*2.8 ) );\n\n\t\td = sel_min( d, ds );\n\t}\n\n\treturn vec4( d, vec2(0,0) );\n}\n\n// ============================================================\n\nvoid init1( out vec3 cam_eye, out vec3 cam_lookat, out vec3 cam_up ) {\n\tcam_eye    = vec3( 10, 10, 10 );\n\tcam_lookat = vec3( 0, 0, 0 );\n\tcam_up     = normalize( vec3( 0.2, 1, 0 ) );\n}\n\nvec4 scene1( vec3 p )\n{\n\tvec4 d = vec4( FAR_CLIP, 0.0, 0.0, -1.0 ); //note: background\n\n\tvec3 cyl_pos = vec3( 0, -10, 0 );\n\tfloat cyl_scl = 10.0;\n\tfloat cyl_r = 0.1;\n\tvec4 crr = cylinder_radialrepeat( (p-cyl_pos)/cyl_scl, cyl_r*0.5 );\n\tcrr.x *= cyl_scl;\n\n    return crr;\n}\n\n// ===\nvoid init( out vec3 cam_eye, out vec3 cam_lookat, out vec3 cam_up )\n{\n\tinit1( cam_eye, cam_lookat, cam_up );\n}\n\n// ====\nvec4 scene( vec3 p )\n{\n\treturn scene1( p );\n}\n\n// ====\n//[0;1[\nfloat nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// ============================================================\n\nvec4 raymarch( inout vec3 p, inout vec3 dir, out int out_steps, out float dmin )\n{\n    int iter = 0;\n\tvec4 d;\n\tfloat rdt = 0.0;\n    dmin = 100000.0;\n\tfor ( int i=0; i<NUM_ITERATIONS; i++ )\n\t{\n        iter += 1;\n\t\td = scene( p );\n\n        dmin = min( dmin, d.x );\n        \n\t\tif ( (d.x < 0.0 ) || (rdt > FAR_CLIP) ) {\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat dt = 0.01 + STEP_MULT * d.x; //note: constant-multiply to compensate for distorted space, actual dist < dist - could use gradient-approximation instead? (see iq)\n\t\t\tp += dir * dt;\n\t\t\trdt += dt;\n\t\t}\n\t}\n\n\tout_steps = iter;\n\treturn d;\n\n}\n\n// ====\n//note: way too big but only used for approx dir\nconst vec3 GRAD_EPS = vec3( 0.5, 0, 0 );\n\nvec3 grad3( vec3 p, float d )\n{\n\treturn normalize( vec3( scene( p + GRAD_EPS.xyz ).x - d,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.zxy ).x - d,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.yzx ).x - d ) );\n}\n//note: more expensive version\nvec3 grad6( vec3 p )\n{\n\treturn normalize( vec3( scene( p + GRAD_EPS.xyz ).x - scene( p - GRAD_EPS.xyz ).x,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.zxy ).x - scene( p - GRAD_EPS.zxy ).x,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.yzx ).x - scene( p - GRAD_EPS.yzx ).x ) );\n}\n\n// ====\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cam_eye;\n\tvec3 cam_lookat;\n\tvec3 cam_up;\n\n\tinit( cam_eye, cam_lookat, cam_up );\n\n\tcam_eye = campos.xyz;\n\tcam_lookat = camctr.xyz;\n\n\n\tvec3 negz = normalize( cam_lookat - cam_eye );\n\tvec3 u = cross( negz, cam_up );\n\tvec3 v = cross( u, negz );\n\n    vec2 texcoord0 = fragCoord.xy / iResolution.xy - vec2(0.5);\n\tvec2 uv = texcoord0;\n\n    u *= uv.x;\n\tv *= uv.y;\n\n\tfloat aspect = mix( ASPECT, ASPECT0, parms2.x );\n\tu *= aspect;\n\n\tconst float dist = 1.0; //...also controls fov :p\n\tvec3 dir = dist * negz + u + v;\n\tdir = normalize( dir );\n\n\tvec3 p_org = cam_eye + NEAR_CLIP * dir;\n\tvec3 p = p_org;\n\t\n\tfloat rnd = nrand( texcoord0.xy + 0.01 * fract( iTime ) );\n\n\t\n\t//note: jitter startpos\n\tp -= 4.0*TERM_DIST * dir * rnd;\n\n    float dmin;\n\tint i;\n\tvec4 d = raymarch( p, dir, i, dmin );\n\n    //fragColor = vec4( abs(dmin) * (dmin<0.0 ? vec3(1.0,0.5,0.5) : vec3(0.5,1.0,0.5)), 1.0 ); return;\n    \n    bool valid = d.x < 0.0;\n    \n\tvec4 outcol = vec4( d.yyy, valid ? 1.0 : 0.0 );\n\toutcol.rgb = max( vec3(0), outcol.rgb );\n\n    //vec3 n = grad3( p, d.x );\n    //outcol.rgb *= 1.5 - vec3( dot(n,-dir) );\n\n    outcol.rgb *= outcol.aaa;\n\n    \n\t//note: iteration-glow\n\tfloat it_f = float(i) + 0.5 - rnd;\n\tfloat iterations = it_f / NUM_ITERATIONS_F;\n\tfloat glowits = parms2.y * pow(iterations,2.3);\n\tconst vec3 gc0 = vec3(104,79,255)/255.0;\n\tvec3 glowcol = mix( 0.5*gc0, 2.0*gc0, parms.x );\n\toutcol.rgb += 3.0*glowits * glowcol;\n\n\t//note: vignette\n\tfloat vign = 1.5-length(texcoord0.xy*vec2(2.35,1));\n\tvign = pow(vign, 2.0);\n\toutcol.rgb *= vec3( sat(vign) );\n\n    //note: vertical color-shift\n    vec3 hsv = rgb_to_hsv( outcol.rgb );\n    hsv.x -= 0.1 * pow(0.9-fragCoord.y / iResolution.y, 2.0);\n    outcol.rgb = hsv_to_rgb( hsv );\n    \n    \n    fragColor = outcol;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2SzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2XDW", "name": "Weird Eye Fractal", "author": "akaitora", "description": "Just trying to see what I can throw together in about 10 minutes.", "tags": ["fractal", "eye", "weird"], "likes": 2, "viewed": 112, "date": "1412317545", "time_retrieved": "2024-06-20T18:13:57.233882", "image_code": "// By: Brandon Fogerty\n// bfogerty at gmail dot com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * iResolution.y/iResolution.x;\n\t\n\tfloat t = iTime * 0.1;\n\t\n\t// Rotate the uv coordinates.\n\tfloat x1 = uv.x;\n\tfloat y1 = uv.y;\n\tuv.x = x1*cos(t) - y1*sin(t);\n\tuv.y = x1*sin(t) + y1*cos(t);\n\t\n\t// Render a line pattern along the x axis\n\tfloat zoomFactor = 50.0+(sin(iTime * 1.0)*0.50 + 0.50)*5.0;\n\tfloat x = sin(uv.x * zoomFactor);\n\tfloat y = sin(uv.y * zoomFactor);\n\tfloat c = sin( cos(tan( cos(x) + sin(y) )) + tan( cos(x) + sin(y) ) );\n\tfragColor = vec4( c*uv.x, c*uv.y, c*sin(uv.x*uv.y+iTime), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2XDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms2XWw", "name": "Twist Scroller", "author": "ac3t1ne", "description": "Greetz!", "tags": ["2d", "retro", "amiga", "ac3t1ne", "scroller"], "likes": 14, "viewed": 966, "date": "1412966488", "time_retrieved": "2024-06-20T18:13:57.239880", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    int bitz[8];\n    bitz[0] = 1; bitz[1] = 2; bitz[2] = 4; bitz[3] = 8; bitz[4] = 16; bitz[5] = 32; bitz[6] = 64; bitz[7] = 128;\n    \n    int message[105];\n    message[0] = 0; //hacky\n    message[1] = 248; message[2] = 30; message[3] = 19; message[4] = 19; message[5] = 30; message[6] = 248; \n    message[7] = 0; message[8] = 60; message[9] = 102; message[10] = 195; message[11] = 129; message[12] = 195;\n    message[13] = 66; message[14] = 0; message[15] = 129; message[16] = 153; message[17] = 153; message[18] = 153;\n    message[19] = 219; message[20] = 126; message[21] = 0; message[22] = 1; message[23] = 1; message[24] = 255;\n    message[25] = 255; message[26] = 1; message[27] = 1; message[28] = 0; message[29] = 132; message[30] = 134;\n    message[31] = 131; message[32] = 255; message[33] = 255; message[34] = 128; message[35] = 0; message[36] = 255;\n    message[37] = 7; message[38] = 30; message[39] = 120; message[40] = 224; message[41] = 255;\n    message[42] = 0; message[43] = 255; message[44] = 153; message[45] = 153; message[46] = 153; message[47] = 153;\n    message[48] = 129; message[49] = 0; message[50] = 0; message[51] = 0; message[52] = 0; message[53] = 0; \n    message[54] = 0;message[55] = 0; message[56] = 0; message[57] = 63; message[58] = 224; message[59] = 124; \n    message[60] = 124; message[61] = 224; message[62] = 63; message[63] = 0; message[64] = 248; message[65] = 30; \n    message[66] = 19; message[67] = 19; message[68] = 30; message[69] = 248; message[70] = 0; message[71] = 132; \n    message[72] = 142; message[73] = 155; message[74] = 217; message[75] = 113; message[76] = 113; message[77] = 0; \n    message[78] = 0; message[79] = 0;  message[80] = 0; message[81] = 0; message[82] = 0; message[83] = 0; \n    message[84] = 0; message[85] = 255; message[86] = 153; message[87] = 153; message[88] = 153; message[89] = 153;\n    message[90] = 129; message[91] = 0; message[92] = 255; message[93] = 17; message[94] = 17; message[95] = 59;\n    message[96] = 110; message[97] = 196; message[98] = 0;message[99] = 255; message[100] = 153; message[101] = 153; \n    message[102] = 153; message[103] = 153; message[104] = 129;\n\t\n    \n    const float speed = 130.0;\n    const int msgLen = 105;\n   \t\n    const float squares = 8.0;\n    const float height = 70.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 rainbow = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec4 rainbow2 = vec4(0.5+0.5*sin(iTime),uv,1.0);\n\t\n    float offset = (iResolution.y/2.0) + (sin((iTime*2.0)+fragCoord.x/180.0)*height);\n    float a = (sin((iTime)+fragCoord.x/360.0) * height)+offset;\n    float b = (sin((iTime+1.57)+fragCoord.x/360.0) * height)+offset;\n    float c = (sin((iTime+3.14)+fragCoord.x/360.0) * height)+offset;\n    float d = (sin((iTime+4.71)+fragCoord.x/360.0) * height)+offset;\n    float squareHeight;\n    float squareWidth = (height*1.5) / squares;\n    int xP;\n    int yP;\n    int temp;\n    float space = (squareWidth * 7.0);\n\tfloat scrollPos = mod(iTime*speed,(space + iResolution.x + (float(msgLen)*squareWidth)));\n    \n    \n \n     if ((fragCoord.y > a) &&   (fragCoord.y < b))\n     {\n          \n         squareHeight = (b-a)/squares;\n         yP = int((fragCoord.y - a) / squareHeight);\n         xP = int((fragCoord.x - iResolution.x + (scrollPos)) / squareWidth);\n         for (int arr = 0; arr < msgLen; arr++)\n         {\n             if (arr == xP)\n             {\n              \ttemp = message[arr];\n                 break;\n             }\n         }\n         for (int inc = 0; inc < 8; inc++)\n         {\n         \tif (inc != yP)\n            {\n                if (temp >= bitz[7-inc])\n                {\n                temp -= bitz[7-inc];\n                }\n            }\n            else if (temp >= bitz[7-inc])\n            {\n              fragColor = rainbow2;\n               break;\n            }\n            \n         }\n         \n        \n     }\n    \n   \n     if ((fragCoord.y > b) &&   (fragCoord.y < c))\n     {\n         \n      squareHeight = (c-b)/squares;\n         yP = int((fragCoord.y - b) / squareHeight);\n         xP = int((fragCoord.x - iResolution.x + (scrollPos)) / squareWidth);\n         for (int arr = 0; arr < msgLen; arr++)\n         {\n             if (arr == xP)\n             {\n              \ttemp = message[arr];\n                 break;\n             }\n         }\n         for (int inc = 0; inc < 8; inc++)\n         {\n         \tif (inc != yP)\n            {\n                if (temp >= bitz[7-inc])\n                {\n                temp -= bitz[7-inc];\n                }\n            }\n            else if (temp >= bitz[7-inc])\n            {\n              fragColor = rainbow;\n               break;\n            }\n            \n         }\n         \n     }\n    \n    \n     if ((fragCoord.y > c) &&   (fragCoord.y < d))\n     {\n         \n      squareHeight = (d-c)/squares;\n         yP = int((fragCoord.y - c) / squareHeight);\n         xP = int((fragCoord.x - iResolution.x +(scrollPos)) / squareWidth);\n         for (int arr = 0; arr < msgLen; arr++)\n         {\n             if (arr == xP)\n             {\n              \ttemp = message[arr];\n                 break;\n             }\n         }\n         for (int inc = 0; inc < 8; inc++)\n         {\n         \tif (inc != yP)\n            {\n                if (temp >= bitz[7-inc])\n                {\n                temp -= bitz[7-inc];\n                }\n            }\n            else if (temp >= bitz[7-inc])\n            {\n              fragColor = rainbow2;\n               break;\n            }\n            \n         }\n         \n     }\n    \n    \n     if ((fragCoord.y > d) &&   (fragCoord.y < a))\n     {\n         \n     squareHeight = (a-d)/squares;\n         yP = int((fragCoord.y - d) / squareHeight);\n         xP = int((fragCoord.x - iResolution.x + (scrollPos)) / squareWidth);\n         for (int arr = 0; arr < msgLen; arr++)\n         {\n             if (arr == xP)\n             {\n              \ttemp = message[arr];\n                 break;\n             }\n         }\n         for (int inc = 0; inc < 8; inc++)\n         {\n         \tif (inc != yP)\n            {\n                if (temp >= bitz[7-inc])\n                {\n                temp -= bitz[7-inc];\n                }\n            }\n            else if (temp >= bitz[7-inc])\n            {\n              fragColor = rainbow;\n               break;\n            }\n            \n         }\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2XWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBXRK", "name": "Audiosurf III", "author": "4rknova", "description": "Yet another audio visualization.", "tags": ["visualization", "audio"], "likes": 25, "viewed": 1756, "date": "1413690821", "time_retrieved": "2024-06-20T18:13:57.621746", "image_code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution 4.0 International (CC BY 4.0)\n// https://creativecommons.org/licenses/by/4.0/\n\n// Coloring function is based on DXRob's Aura Shader:\n// https://www.shadertoy.com/view/lsXXDj\n\n#define PI  3.14159265359\n#define EPS .001\n\n#define CIRCLE_RADIUS .5\n#define CIRCLE_GLOW   .1\n#define SAMPLE_SCALE  .2\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 1. Calculate the uv coordinates in [-1, 1] xy space.\n\tvec2  uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    // 2. Sample the audio stream.\n    // Calculate the polar coordinates based on uv value.\n    // Atan will return a value in the range of [-1, 1] so\n    // we need to transform back to [0, 1] before sampling.\n    float x = atan(-uv.x, -uv.y) / PI;\n    // The samples are not going to seamlessly merge on the edges\n    // so what we are going to do to make it nicer is display them\n    // twice and invert the sampling order for the second repetition.\n    x = (x < 0. ? 1. + x : 1. - x);\n    vec3  s = texture(iChannel0, vec2(x, .25)).xyz * SAMPLE_SCALE;\n        \n    // 3. Define the geometry.\n    // Correct the uv coordinates with regards to the aspect\n    // ratio to calculate correct circle radius.\n    vec2  cv = uv * vec2(iResolution.x / iResolution.y, 1.);\n    float ds = length(cv);\n         \n    // 4. Calculate the pixel color.\n    float sr = (ds - s.x) / CIRCLE_RADIUS;\n    float cl = (1. - sqrt(abs(1. - sr))) / sr + CIRCLE_GLOW;\n\n    // 5. PostFX\n    vec3 col = cl * vec3(abs(cos(iTime)), .5 + uv.x * uv.y, ds - uv.y);\n    float grain = hash(hash(uv) * cv * iTime) * .05;\n    float fade  = smoothstep(EPS, 2., iTime);\n\n    fragColor = vec4((col + grain) * fade, 1);\n}", "image_inputs": [{"id": "Xsl3zr", "previewfilepath": "https://soundcloud.com/pmylund/carl-sagan-you-are-here", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/pmylund/carl-sagan-you-are-here", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBXRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBXWm", "name": "Spiral out", "author": "toothmang", "description": "Just an Archimedean spiral in GLSL.", "tags": ["procedural", "2d", "animation", "polar"], "likes": 2, "viewed": 272, "date": "1412632120", "time_retrieved": "2024-06-20T18:13:58.427695", "image_code": "#define alpha 0.0\n#define beta 10.0\n\n// Thanks to Lance for the insight on making more than 1 spiral branch\n#define NUM_BRANCHES 1.\n\n#define PI 3.14159\n\nvec4 getCornerColors(vec2 coord)\n{\n    vec4 cornerColors[4];\n\t\n    cornerColors[0] = vec4(1.0, 0, 0, 1.0);\n    cornerColors[1] = vec4(0, 0, 1.0, 1.0);\n    cornerColors[2] = vec4(0, 1.0, 0.0, 1.0);\n    cornerColors[3] = vec4(1.0, 1.0, 0.0, 1.0);\n        \n    vec2 cornerCoords[4];\n    cornerCoords[0] = vec2(0);\n    cornerCoords[1] = vec2(1, 0);\n    cornerCoords[2] = vec2(1);\n    cornerCoords[3] = vec2(0, 1);\n\n    \n\tvec4 result = vec4(0.0);\n\n\tfloat totalArea = dot(iResolution.xy, iResolution.xy);\n\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tvec2 cCoord = cornerCoords[i] * iResolution.xy;\n\n\t\tvec2 diff = coord - cCoord;\n\n\t\tfloat area = dot(diff, diff);\n\n\t\tresult += ((totalArea - area) / totalArea) * cornerColors[i];\n\t}\n\n\treturn result;\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 50.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 0.5)\n\t{\n\t\treturn vec4(vec3(0), 1.0);\n\t}\n\telse\n\t{\n\t\treturn vec4(vec3(remainder), 1.0);\n\t}\n}\n\nvec4 spiral5(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\t//coord = coord / fres;\n\n\t//coord = (2.0 * coord) - vec2(1.0);\n\n\t//coord = coord - (iResolution.xy * 0.5);\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\t//float remainder = abs(cos(phi) - cos(phi_r));\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvec4 spiral6(vec2 coord)\n{\n\tfloat alpha_t = alpha - iTime * 50.;\n\n\t//coord = coord / fres;\n\n\t//coord = (2.0 * coord) - vec2(1.0);\n\n\t//coord = coord - (iResolution.xy * 0.5);\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(x * x + y * y);\n\n\tfloat phi = atan(y, x) * -NUM_BRANCHES;\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\t//float remainder = abs(cos(phi) - cos(phi_r));\n\n\tfloat remainder = abs(sin(phi) - sin(phi_r));\n\n\tremainder += abs(cos(phi) - cos(phi_r));\n\n\tif (remainder < 1.0)\n\t{\n\t\tvec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n\n\t\tfloat t = (phi / (2. * PI)) + 0.5;\n\n\t\treturn mix(c1, c2, remainder);\n\t}\n\telse\n\t{\n        vec4 c1 = vec4(1, 0, 0, 1);\n\t\tvec4 c2 = vec4(0, 0, 1, 1);\n        return mix(c1, c2, remainder);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n\t//fragColor = spiral4(uv) * vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = spiral5(uv) * (getCornerColors(fragCoord.xy) * 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBXWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjSzy", "name": "1D Cubic Trig Spline", "author": "demofox", "description": "Trigonometry based \"cubic\" (4 point) spline, as described here:\nhttp://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1997/9705/9705n/9705n.htm\nhttp://www.drdobbs.com/database/implementing-uniform-trigonometric-splin/184410198", "tags": ["2d", "spline", "trig"], "likes": 9, "viewed": 866, "date": "1413919778", "time_retrieved": "2024-06-20T18:13:59.021916", "image_code": "#define A  0.0\n#define B  (iMouse.z <= 0.0 ? 0.4 : iMouse.y / iResolution.y - 0.5)\n#define C  (sin(iTime*1.5) * 0.5)\n#define D  0.2\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n#define PI 3.14159265359\n\n// F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    // convert time from 0-1 to 0-pi/2\n    float T = coords.x * PI * 0.5;\n    \n    // pre-calculate sin and cosine\n    float snt = sin(T);  // sin 0 = 0.  sin pi/2 = 1\n    float cst = cos(T);  // cos 0 = 1.  cos pi/2 = 0\n\n    // interpolating spline, not an exterpolating spline, so should pass through the end control points\n    // but not the middle control points.\n\t// basis - google: graph y = (0.5*cos(x)*(cos(x)-1.0)), y = (0.5*sin(x)*(sin(x)+1.0)), y = (0.5*cos(x)*(cos(x)+1.0)), y = (0.5*sin(x)*(sin(x)-1.0)) from 0 to pi/2\n    // basis sum - google: graph y = (0.5*cos(x)*(cos(x)-1.0)) + (0.5*sin(x)*(sin(x)+1.0)) + (0.5*cos(x)*(cos(x)+1.0)) + (0.5*sin(x)*(sin(x)-1.0)) \n    return\n        D *  (0.5*snt*(snt+1.0)) + \n        B * -(0.5*snt*(snt-1.0)) +        \n        C * -(0.5*cst*(cst-1.0)) +         \n        A *  (0.5*cst*(cst+1.0)) - \n        coords.y;\n}\n\n// gradiant function for finding G for a generic function when you can't\n// get it analytically using partial derivatives.  We could do\n// partial derivatives of F above, but I'm being lazy.\nvec2 Grad( in vec2 coords )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( F(coords+h.xy) - F(coords-h.xy),\n                 F(coords+h.yx) - F(coords-h.yx) ) / (2.0*h.x);\n}\n\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    vec2  g = Grad(coords);\n    return abs(v)/length(g);\n}\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.33,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(0.66,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,D));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    dist = SDF(percent);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= (percent.x >= 0.0 && percent.x <= 1.0) ? vec3(dist) : vec3(0.95);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjXDm", "name": "Barber", "author": "okro", "description": "Barber polls!", "tags": ["2d", "stripes", "barber", "poll"], "likes": 2, "viewed": 237, "date": "1412917506", "time_retrieved": "2024-06-20T18:13:59.021916", "image_code": "\n#define time iTime*10.\n\n\nfloat stripe(vec2 uv) {\n    return cos(uv.x*20.-time+uv.y*-30.);\n}\n\nfloat glass(vec2 uv) {\n    return cos(dot(uv.xy, vec2(12.41234,2442.123))*cos(uv.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float a = iResolution.x/iResolution.y;\n    uv.x *= a;\n    \n\n    float g = stripe(uv);\n\n    \n    vec3 col = vec3(smoothstep(0., .2, g));\n\n    col.r = .8;\n    col /= (pow(glass(vec2(uv.x*30., uv.y)),2.))+.5;\n    \n  \n    //Mask sides\n    col *= smoothstep(.12, .0, abs(uv.x - .5*a));\n\n    //Mask top and bottom\n    col *= smoothstep(.33, .30, abs(uv.y - .5));\n\n    if (uv.y > .80 && uv.y < .94 || uv.y < .2 && uv.y >.06) {\n       col = vec3(smoothstep(.13, .0, abs(uv.x - .5*a)));\n    \n    }\n\n    if (uv.y > .77 && uv.y < .87 || uv.y < .23 && uv.y >.13) {\n       col = vec3(smoothstep(.15, .0, abs(uv.x - .5*a)));\n        \n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjXDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsjXzV", "name": "SphereAndWalls", "author": "capitanminero", "description": "A little demo with ambient occlusion, soft shadows, bump mapping and texturing", "tags": ["3d", "raymarching", "softshadows", "ambientocclusion"], "likes": 9, "viewed": 380, "date": "1414071296", "time_retrieved": "2024-06-20T18:14:00.288630", "image_code": " #define MAX_ITERATIONS 140\n \n\n\t// rotations from euler angles\n    mat4 fromEuler(vec3 ang) {\n        vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n        vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n        vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n        mat4 m;\n        m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n        m[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n        m[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n        m[3] = vec4(0.0,0.0,0.0,1.0);\n        return m;\n    }           \n\n    // rotate (operate) vec3 from mat4\n    vec3 rotate(vec3 v, mat4 m) {\n       return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n    } \n\n    // p: point\n    // Distance function (some objects)\n    vec3 map( in vec3 p ) {\n        float sr = 1.0;  // sphere radius\n        vec3 box = vec3(3.5,1.7,0.3);\n        float rbox = 0.1;\n        float id = 1.0;  // 3 = floor, 2 wall, 1 sphere\n\n        // Sphere\n        float distS = length(p + vec3( sin(iTime * 0.21) * 3.0,0.3,cos(iTime * 0.21) * 3.0))-sr;\n        \n        // First wall\n        float distQ = length(max(abs(p)-box,0.0))-rbox;\n        // Cuboid moved 2.0 to the right (2on wall)\n        float distQ2 = length(max(abs(p + vec3(-2.0,.0,2.0)) - vec3(0.3,1.7,3.5), 0.0))-rbox;\n\n        // Window in the wall\n        vec3 d = abs(p) - vec3(0.5,0.8,1.0);\n        float distQ3 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\n        // External wall (parcel limit) without ceiling\n        vec3 d2 = vec3(10.0,2.0,10.0) - abs(p);\n        float distQ4 = max( min( d2.x,  d2.z ), -d2.y );\n\n        // Column\n        float distCol = length(max(abs(p + vec3(2.5,.0,4.5)) - vec3(0.3,1.7,0.3), 0.0))-rbox;\n\n\n        float distTot = min( min( distS, distQ), distQ2 );\n        distTot = max( -distQ3,distTot );\n        distTot = min( distCol,distTot );\n        distTot = min( distTot, distQ4 );\n\n        if (distS > distTot) {\n            id = 2.0;\n        }\n\n        float distP = p.y + 1.6;\n\n        if (distP < distTot) {\n            id = 3.0;\n        }\n\n        distTot = min(distP, distTot);\n\n        return vec3(distTot, id, 0.0 );\n    }\n\n\n\t// texture\n    float fbm( vec3 p, vec3 n )\n    {\n        return texture( iChannel0, (p.xy + p.zy) / 4.0).x;\n    }\n\n\t// bump mapping\n    vec3 doBumpMap( in vec3 pos, in vec3 nor )\n    {\n        float e = 0.0015;\n        float b = 0.1;\n        \n        float ref = fbm( pos, nor );\n        vec3 gra = b*vec3( fbm( vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                            fbm( vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                            fbm( vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n        \n        vec3 tgrad = gra - nor * dot ( nor , gra );\n        return normalize ( nor - tgrad );\n    }\n\n\n    // p: point to calculate gradient\n\t// id: object id\n    // Calculate normal by gradient\n    vec3 calcNormal( in vec3 p, in float id ) {\n        vec3 eps = vec3(0.002,0.0,0.0);\n\n        vec3 nor = normalize( vec3(\n            map( p + eps.xyy).x - map(p - eps.xyy).x,\n            map( p + eps.yxy).x - map(p - eps.yxy).x,\n            map( p + eps.yyx).x - map(p - eps.yyx).x));\n\n        if (id == 2.0) {\n            return doBumpMap(p,nor);\n        }\n\n        return nor;\n    }\n\n\n    // shadow\n    // ro: ray origin\n    // rd: ray destination\n    float softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n    {\n        float res = 1.0;\n        float h = mint;\n        for( int i=0; i < 100; i++ )\n        {\n            ro += rd * h;\n            h = map(ro).x;\n            if( h<0.01 )\n                return 0.0;\n            res = min( res, k*h );\n            if (h > maxt)\n                break;\n        }\n\n        return res;\n    }\n\n\t// ambientOclussion\n    float ambientOclussion( in vec3 p, in vec3 n) {\n        float step = 0.1;\n        float res = 1.0;\n        vec4 vstep = vec4( n*step, step );\n        vec4 np = vec4(p,0.0) + vstep;\n        for (int i=0; i < 5; i++) {\n            res -= (np.w - map( np.xyz ).x) * 0.25;\n            np += vstep;\n        }\n\n        return max(res,0.0);\n    }\n\n    // p: point to colorize\n\t// id: object id of point\n    vec3 colorize( in vec3 p, in float id ) {\n        vec3 n = calcNormal( p, id);\n\n        // light pos2 (rotate)\n        vec3 lighto2 = vec3(800.0 * sin(iTime*0.04),1000.0,800.0 * cos(iTime * 0.04));\n        vec3 tolight2 = normalize(lighto2 - p);\n        vec3 colorLight2 = vec3(0.8,0.9,0.9);\n\n\n        // text col\n        float ambientOc = ambientOclussion( p, n );\n        vec3 direct2 = colorLight2 * 1.0 * max(dot(n,tolight2),0.0) / (ambientOc);// * ambientOc);\n\n        float shadow2 = softShadow(p, tolight2, 0.2, 50.0, 5.0) * ambientOc;\n\n        vec3 textureOut;\n        if (id == 2.0) {\n            highp vec3 v3 = vec3(.4,.4,.4);\n            textureOut =  max( texture(iChannel0, (p.xy + p.zy) / 4.0 ).xyz, v3);\n        }\n        else if (id == 1.0)\n            textureOut = vec3(.2,.5,.6);\n        else\n            textureOut = vec3(.2,.5,.2);\n\n        vec3 ambient = vec3(.5,.5,.5);\n\n\n        return  (textureOut * ambient * ambientOc) + (textureOut * direct2 * shadow2);  // One light\n\n    }\n\n\n    // ro: ray origin\n    // rd: ray direction (normalizada)\n    vec3 rayMarch( in vec3 ro, in vec3 rd, out float idObj, out vec3 ptCol ) {\n\n        float dist = 0.0;\n        vec3 vdist;\n        vec3 np = ro;\n        for( int i = 0; i < MAX_ITERATIONS; i++ ) {\n            \n            vdist = map(np);\n            dist = vdist.x;\n            if (dist < 0.001)\n                break;\n            np += rd * dist;\n\n        }\n\n        idObj = vdist.y;\n        ptCol = np;\n\n        if (dist < 0.01) {\n            return colorize(np, vdist.y);\n        }\n\n        return vec3( 0.6, .6, 0.8);    \n\n    }\n\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        // Obtenemos xy de fragment y normalizamos (haciendo cuadrados los pÃ­xeles si hace falta)\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 p = -1.0 + 2.0 * uv;\n        p.x *= iResolution.x/iResolution.y;\n\n\n        // cam calculation (camo = origin, camd = destination/target)\n        vec3 camo = vec3( 9.0*sin( iTime * -0.2), 1.0, 9.0*cos(iTime*-0.2 ));//vec3(iCamX, iCamY, iCamZ);\n        vec3 camd = camo;\n        camd = normalize(camd);\n        vec3 up = vec3(0.0,1.0,0.0);\n        vec3 left = normalize(cross(camd, up));\n        camd = normalize( left*p.x + up*p.y - 2.0*camd );\n        \n        float idObj;\n        vec3 ptCol;\n        \n        vec4 color = vec4( rayMarch( camo, camd, idObj, ptCol ), 1 );\n\n        if (idObj == 3.0)  // agua\n                {\n            float lambda = 10.0;\n            float ptColx = ptCol.x - cos(ptCol.y );\n            float ptColz = ptCol.z - sin(ptCol.z );\n\n            vec3 normalFloor = normalize(vec3(  .02 * sin( ptColx * lambda * 0.5 + iTime * 7.1) + \n                                                .01 * sin( (ptColx + ptColz * 0.3) * lambda + iTime * 8.0) + \n                                                .005 * sin( (ptColx - ptColz * 0.9) * lambda*2.1 + iTime * 5.2),\n                1.0, \n                .02 * cos( ptColz * lambda * 0.5 + iTime * 7.6) + \n                .01 * cos( ptColz * lambda + iTime * 8.0) + \n                .005 * cos( ptColz * lambda *1.9 + iTime * 5.6)));\n            vec3 newcamd = normalize( reflect( camd, normalFloor ));\n            float dot = dot( newcamd, normalFloor );\n            float dot2 = sqrt(dot);\n            vec3 color3 = (1.0 - dot2) * rayMarch( vec3(ptCol.x, -1.51, ptCol.z), newcamd, idObj, ptCol) + dot2 * vec3(0.1,0.3,0.1);\n\n            color = vec4(color3,1.0);\n\n        }\n\n\t\t// Calculate and assign color\n        fragColor = color;\n\n    }\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSSRy", "name": "exploration-001b", "author": "yastero", "description": "random", "tags": ["random"], "likes": 2, "viewed": 106, "date": "1414363978", "time_retrieved": "2024-06-20T18:14:00.288630", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n    float i,j,k = 0.0;\n    float t = iTime;\n    float vol = texture(iChannel0, vec2(abs(sin(t) * 100.0), 1.0)).x;\n\n    i += 1.0 - abs(\n        (2.4 * uv.x +\n         sin(0.1 * (t + (vol*10.0)) + (uv.y * (1.0 + (vol*7.0))))));// +\n//         sin(t + (uv.y * 13.0)))) * (1.0 + (vol * 50.0)));\n\n//    j += abs(sin(t * 10.0 * uv.x * uv.y)) * 10.0;\n\n//    k += sin(uv.x + t);\n\n    k += uv.x + vol;\n\n    fragColor = vec4(i,j+k,k,1.0);\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSSRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSSzV", "name": "Red Noise", "author": "fab", "description": "Failed attempt at implementing my own Perlin noise shader, turned into an odd noise mess out of frustration.", "tags": ["2d", "noise"], "likes": 4, "viewed": 224, "date": "1413766187", "time_retrieved": "2024-06-20T18:14:00.288630", "image_code": "// Range: 0..1\nfloat intensity = 0.6;\n\n// Number of octaves in the Perlin noise generation\nconst int iterations = 17;\n\nfloat rand(vec2 co){\n    return mod(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)*iTime/1.0, 1.0);\n}\n\nfloat getOctHarsh(float oct, vec2 pos, float att){\n    float x = pos.x;\n    float y = pos.y;\n    float divx = iResolution.x / pow(2.0, oct);\n    float divy = iResolution.y / pow(2.0, oct);\n    x = floor(x / divx);\n    y = floor(y / divy);\n    return rand(divx * divy * vec2(x, y)) / (att * att * oct);\n}\n\nfloat getOct(float octave, vec2 pos, float att){\n    float divx = iResolution.x / pow(2.0, octave);\n    float divy = iResolution.y / pow(2.0, octave);\n    \n    // neighbor noise values\n    vec2 below       = vec2( pos.x        , pos.y - divy );\n    vec2 above       = vec2( pos.x        , pos.y + divy );\n    vec2 left        = vec2( pos.x - divx , pos.y        );\n    vec2 right       = vec2( pos.x + divx , pos.y        );\n    vec2 topleft     = vec2( pos.x - divx , pos.y - divy );\n    vec2 topright    = vec2( pos.x + divx , pos.y - divy );\n    vec2 bottomleft  = vec2( pos.x - divx , pos.y + divy );\n    vec2 bottomright = vec2( pos.x + divx , pos.y + divy );\n    \n    // LR weights\n    float wr = mod(pos.x, divx)/divx;\n    float wl = 1.0 - wr;\n    wr = wr * wr - 0.5;\n    wl = wl * wl - 0.5;\n    if(wr < 0.0) wr = 0.0;\n    if(wl < 0.0) wl = 0.0;\n    \n    // AB weights\n    float wa = mod(pos.y, divy)/divy;\n    float wb = 1.0 - wa;\n    wa = wa * wa - 0.5;\n    wb = wb * wb - 0.5;\n    if(wa < 0.0) wa = 0.0;\n    if(wb < 0.0) wb = 0.0;\n    \n    float corners = 2.0;\n    // corner weigts\n    float wtl = (wl + wa)/corners;\n    float wtr = (wr + wa)/corners;\n    float wbl = (wl + wb)/corners;\n    float wbr = (wr + wb)/corners;\n    \n    return (1.0 - wl - wr - wa - wb - wtl - wtr - wbl - wbr) * getOctHarsh(octave, pos, att) +\n        \twl * getOctHarsh(octave, left, att) +\n        \twr * getOctHarsh(octave, right, att) + \n        \twa * getOctHarsh(octave, above, att) + \n        \twb * getOctHarsh(octave, below, att) +\n        \twtl * getOctHarsh(octave, topleft, att) +\n            wtr * getOctHarsh(octave, topright, att) +\n       \t\twbl * getOctHarsh(octave, bottomleft, att) +\n        \twbr * getOctHarsh(octave, bottomright, att);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 green = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n    float noise = 0.0;\n   \n    for(int i = 2; i < iterations; i++){\n    \tnoise += getOct(float(i), fragCoord.xy, 1.0);    \n    }\n    \n    noise *= intensity;\n\tfragColor = noise * red + (noise - 3.0) * green + (noise - 2.0) * blue;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsSXzG", "name": "Normalmap combining", "author": "TDM", "description": "normals combining techniques", "tags": ["normals", "combiner"], "likes": 15, "viewed": 836, "date": "1413133351", "time_retrieved": "2024-06-20T18:14:00.737285", "image_code": "/*\n * |===============================================|\n * |         GT         |   DERIVATIVES ADDITION   |\n * |===============================================|\n * |  NORMALS ADDITION  |   DERIVATIVES BLENDING   |\n * |===============================================|\n */\n\n// normalmap texture\nvec3 textureNormal(vec2 uv) {\n    uv = fract(uv) * 3.0 - 1.5;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    ret = ret * 0.5 + 0.5;    \n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.98,dot(uv,uv)));\n}\n\n// normals combine: normals addition\nvec3 combineNormals0(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    return normalize(n0 + n1) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives addition\nvec3 combineNormals1(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;\n    n0 = vec3(n0.xy + n1.xy, n0.z * n1.z);\n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: derivatives blending\nvec3 combineNormals2(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\tn0 = vec3(n0.xy * n1.z + n1.xy * n0.z, n0.z * n1.z);    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\n// normals combine: GT\nvec3 combineNormals3(vec3 n0, vec3 n1) {\n    n0 = n0 * 2.0 - 1.0;\n    n1 = n1 * 2.0 - 1.0;    \n\t\n    mat3 m = mat3(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),n1);\n    m[1] = normalize(cross(m[2],m[0]));\n    m[0] = normalize(cross(m[1],m[2]));\n    n0 = m * n0;\n    \n    return normalize(n0) * 0.5 + 0.5;\n}\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color;\n    vec2 time = vec2(sin(iTime * 0.1), cos(iTime * 0.1));\n    vec3 n0 = textureNormal(uv + time);\n    vec3 n1 = textureNormal((uv - time) * 2.0 + vec2(0.25));\n    \n    // combine normals\n    if(uv.x < 0.0) {\n        if(uv.y > 0.0) {\n    \t\tcolor = combineNormals3(n0,n1);\n        } else {\n            color = combineNormals0(n0,n1);\n        }\n    } else {\n        if(uv.y > 0.0) {\n        \tcolor = combineNormals1(n0,n1);\n        } else {            \n        \tcolor = combineNormals2(n0,n1);\n        }\n    }\n    \n    // borders\n    color += max(smoothstep(0.01,0.005,abs(uv.x)),0.0);\n    color += max(smoothstep(0.01,0.005,abs(uv.y)),0.0);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSXzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2XDW", "name": "3d sierpinski triangle", "author": "al13n", "description": "Implementation of a simple example from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/", "tags": ["raymarching", "fractal", "distanceestimation"], "likes": 5, "viewed": 515, "date": "1412140174", "time_retrieved": "2024-06-20T18:14:01.179736", "image_code": "float DE(vec3 p, float pixsize) {\n    const vec3 p0 = vec3(-1,-1,-1);\n    const vec3 p1 = vec3(1,1,-1);\n    const vec3 p2 = vec3(1,-1,1);\n    const vec3 p3 = vec3(-1,1,1);\n\n    const int maxit = 15;\n    const float scale = 2.;\n    for (int i = 0; i < maxit; ++i) {\n        float d = distance(p, p0);\n        vec3 c = p0;\n        \n        float t = distance(p, p1);\n        if (t < d) {\n            d = t;\n            c = p1;\n        }\n        \n        t = distance(p, p2);\n        if (t < d) {\n            d = t;\n            c = p2;\n        }\n        \n        t = distance(p, p3);\n        if (t < d) {\n            d = t;\n            c = p3;\n        }\n        \n        p = (p-c)*scale;\n    }\n    \n    return length(p) * pow(scale, float(-maxit))\n        - pixsize; // let the leaves be one pixel in size\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float unit_pixsize = 1./(iResolution.x+iResolution.y);\n    \n    // camera parameters\n    vec3 origin = vec3(-4,mouse*2.-1.);\n    vec3 direction = normalize(vec3(1, uv*2.-1.));\n    \n    float ang1 = sin(iTime*0.9+42.)*2.+42.;\n    float ang2 = sin(iTime*1.1)*3.;\n    \n    mat3 rotation1 = mat3(\n        1,0,0,\n        0,cos(ang1),-sin(ang1),\n        0,sin(ang1),cos(ang1)\n    );\n    mat3 rotation2 = mat3(\n        cos(ang2),0,-sin(ang2),\n        0,1,0,\n        sin(ang2),0,cos(ang2)\n    );\n    mat3 rotation = rotation1 * rotation2;\n    \n    const float diameter = 100.;\n    const int maxit = 40;\n    const float eps = 1e-5;\n    \n    vec3 p = origin;\n    int it = maxit;\n    for (int i = 1; i <= maxit; ++i) {\n        if (dot(p, p) > diameter) {\n            it = i;\n            break;\n        }\n        float d = DE(rotation * p, unit_pixsize * distance(p, origin));\n        if (d < eps) {\n            it = i;\n            break;\n        }\n        p += direction * d;\n    }\n\n    if (it == 0)\n\t\tfragColor = vec4(.5, .5, .9, 1.0);\n    else {\n        float t = 1. - float(it) / float(maxit);\n        fragColor = vec4(t,t,t,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2XDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd2Xzy", "name": "What?", "author": "puzzleweaver", "description": "Does your face hurt yet?\n\nJust try to follow something, good luck.", "tags": ["boredom"], "likes": 1, "viewed": 129, "date": "1413338739", "time_retrieved": "2024-06-20T18:14:01.179736", "image_code": "const float zoom = 10.0;\nfloat t = (iTime)/1.0;\nbool is;\nfloat a1 = 1.0, a2 = 1.23, a3 = 1.54, a4 = 2.23, a5 = 1.54, a6 = 1.63;\n\nfloat xCoord(float time){\n    return zoom*cos(time*1.42784);\n}\nfloat yCoord(float time){\n    return zoom*sin(time*2.42784);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = fragCoord.xy;\n    vec2 c = ((coord - vec2(iResolution)/2.0)/iResolution.x)*zoom;\n    float x = c.x+xCoord(t), y = c.y+xCoord(t);\n    \n    vec2 c1 = vec2(cos(t*a1), sin(t*3.4321));\n    c1 *= zoom;\n    vec2 c2 = vec2(sin(t*a2), cos(t*3.0));\n    c2 *= zoom;\n    vec2 c3 = vec2(sin(t*a3), cos((t+1.0)*2.435));\n    c3 *= zoom;\n    vec2 c4 = -c1;\n    vec2 c5 = -c2;\n    vec2 c6 = -c3;\n    \n    float l1 = length(c1-c);\n    float l2 = length(c1+c)/sin(t*2.23431);\n    float l3 = length(c3-c)/cos(t*3.431);\n    float l4 = length(c4-c)/sin(t*1.0543);\n    float l5 = length(c5+c)/sin(t*2.23431);\n    float l6 = length(c6-c)/cos(t*3.431);\n    \n    bool bo1 = (mod(floor(l1), 2.0) == 0.0) ^^ (mod(floor(l4), 2.0) == 0.0);\n    bool bo2 = (mod(floor(l2), 2.0) == 0.0) ^^ (mod(floor(l5), 2.0) == 0.0);\n    bool bo3 = (mod(floor(l3), 2.0) == 0.0) ^^ (mod(floor(l6), 2.0) == 0.0);\n    \n    float r = sin(iTime)*0.5+0.5, g = sin(iTime+3.1415926*2.0/3.0)*0.5+0.5,\n        b = sin(iTime+3.1415926*4.0/3.0)*0.5+0.5;\n    vec3 color = vec3(r, g, b);\n    if(bo1) color.x = 1.0-color.x;\n    if(bo2) color.y = 1.0-color.y;\n    if(bo3) color.z = 1.0-color.z;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2Xzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBSzc", "name": "catch?", "author": "ahihi", "description": "THE SUSPENSE IS UNBEARABLE\n\ntodo: make the button light into an actual light source", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 150, "date": "1414233719", "time_retrieved": "2024-06-20T18:14:01.185840", "image_code": "#define TAU 6.283185307179586\n\nvec2 rect2polar(vec2 p) {\n    return vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 polar2rect(vec2 p) {\n    return vec2(cos(p.x) * p.y, sin(p.x) * p.y);\n}\n\n#define NO_MATERIAL 0\n#define WHITE_MATERIAL 1\n#define RED_MATERIAL 2\n#define BLACK_MATERIAL 3\n#define LIGHT_MATERIAL 4\n#define GROUND_MATERIAL 5\n\nstruct ObjectDistance {\n    float distance;\n    int material;\n};\n\nObjectDistance distanceUnion(ObjectDistance a, ObjectDistance b) {\n    if(a.distance < b.distance) {\n        return a;\n    } else {\n     \treturn b;\n    }\n}\n\nObjectDistance distanceDifference(ObjectDistance b, ObjectDistance a) {\n    if(-a.distance > b.distance) {\n        a.distance *= -1.0;\n        return a;\n    } else {\n        return b;\n    }        \n}\n\nObjectDistance sphere(float radius, int material, vec3 p) {\n  \treturn ObjectDistance(length(p) - radius, material);\n}\n\nObjectDistance box(vec3 b, int material, vec3 p)\n{\n  vec3 d = abs(p) - b;\n  return ObjectDistance(\n      min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),\n      material\n  );\n}\n\nObjectDistance cylinder(vec2 h, int material, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n  return ObjectDistance(\n      min(max(d.x, d.y), 0.0) + length(max(d, 0.0)),\n      material\n  );\n}\n\nObjectDistance ground(float y, int material, vec3 p) {\n     return ObjectDistance(p.y - y, material);   \n}\n\nObjectDistance halve(float buttonRadius, float spacing, int material, vec3 p) {\n    float overshoot = 0.1;\n    ObjectDistance od;\n    \n    od = sphere(1.0, material, p);\n    \n    od = distanceDifference(\n        od,\n        box(\n            vec3(1.0 + overshoot, 0.5 + overshoot, 1.0 + overshoot),\n            material,\n            p + vec3(0.0, 0.5 + overshoot - spacing/2.0, 0.0)\n        )\n    );\n    \n    od = distanceDifference(\n        od,\n        cylinder(vec2(buttonRadius + spacing, 0.5), material, p + vec3(0.0, 0.0, 0.6))\n    );\n    \n    return od;\n}\n\nObjectDistance button(float radius, float innerRadius, int material, int innerMaterial, vec3 p) {\n    ObjectDistance od;\n    \n    od = cylinder(vec2(radius, 0.5), material, p + vec3(0.0, 0.0, 0.5));\n    \n    od = distanceUnion(\n    \tod,\n        cylinder(vec2(innerRadius, 0.5), innerMaterial, p + vec3(0.0, 0.0, 0.52))\n    );\n    \n    return od;\n}\n\nObjectDistance pokeball(vec3 p) {\n    float buttonRadius = 0.13;\n    float buttonInnerRadius = 0.65 * buttonRadius;\n    float spacing = 0.08;\n    \n    ObjectDistance od;\n    \n    od = halve(buttonRadius, spacing, RED_MATERIAL, p);\n    \n    od = distanceUnion(\n        od,\n        halve(buttonRadius, spacing, WHITE_MATERIAL, p * vec3(1.0, -1.0, 1.0))\n    );\n    \n    od = distanceUnion(\n        od,\n        sphere(0.97, BLACK_MATERIAL, p)\n    );\n    \n    od = distanceUnion(\n        od,\n        button(buttonRadius, buttonInnerRadius, WHITE_MATERIAL, LIGHT_MATERIAL, p)\n    );\n    \n    return od;\n}\n\nvec3 wobble(vec3 p) {\n    float angle = pow(sin(2.0 * iTime), 3.0) * 0.1 * sin(15.0 * iTime);\n    vec2 xy = polar2rect(rect2polar(p.xy) + vec2(angle, 0.0));\n    p.xy = xy;\n    float translation = angle;\n    p.x -= translation;\n    return p;\n}\n\nObjectDistance sceneDistance(vec3 p) {    \n\tObjectDistance od;\n    \n    od = ground(-1.0, GROUND_MATERIAL, p);\n    \n    od = distanceUnion(\n        od,\n        pokeball(wobble(p))\n    );\n            \n    return od;\n}\n\n#define THRESHOLD 0.001\n#define SHADOW_THRESHOLD 0.01\n#define MAX_ITERATIONS 256\n#define MAX_SHADOW_ITERATIONS 256\n#define NORMAL_DELTA 0.001\n#define MAX_DEPTH 60.0\n\nstruct MarchResult {\n    float length;\n    float distance;\n    int material;\n    int iterations;\n};\n    \nMarchResult march(vec3 origin, vec3 direction) {\n    MarchResult result = MarchResult(0.0, 0.0, NO_MATERIAL, 0);\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n\t    ObjectDistance sd = sceneDistance(origin + direction * result.length);\n        result.distance = sd.distance;\n        result.material = sd.material;\n        result.iterations++;\n        \n        if(result.distance < THRESHOLD || result.length > MAX_DEPTH) {\n            break;\n        }\n        \n        result.length += result.distance * (1.0 - 0.5*THRESHOLD);\n    }\n\n    if(result.length > MAX_DEPTH) {\n        result.material = NO_MATERIAL;\n    }\n    \n    return result;\n}\n\n// this is wrong, but looks very cool!\nfloat marchGlitchyShadow(vec3 lightPos, vec3 surfacePos, float k) {\n    vec3 origin = lightPos;\n    vec3 target = surfacePos;\n    \n    vec3 travel = target - origin;\n    vec3 forward = normalize(travel);\n    float maxLength = length(travel);\n    \n    float length = 0.0;\n    float distance = 0.0;\n    int iterations = 0;\n    for(int i = 0; i < MAX_SHADOW_ITERATIONS; i++) {\n        if(length >= maxLength) {\n         \treturn 1.0;   \n        }\n        \n        ObjectDistance od = sceneDistance(origin + forward * length);\n        distance = od.distance;\n        \n        if(abs(distance) < THRESHOLD) {\n            return 0.0;\n        }\n        \n        length += distance;\n        iterations++;\n    }\n\n    return 1.0;\n}\n\nfloat marchShadow(vec3 lightPos, vec3 surfacePos, float k) {\n    vec3 origin = lightPos;\n    vec3 target = surfacePos;\n    \n    vec3 travel = target - origin;\n    vec3 forward = normalize(travel);\n    float maxLength = length(travel) * 0.9;\n    \n    float length = 0.0;\n    float distance = 0.0;\n    float light = 1.0;\n    int iterations = 0;\n    for(int i = 0; i < MAX_SHADOW_ITERATIONS; i++) {\n        if(length >= maxLength - SHADOW_THRESHOLD) {\n         \tbreak;\n        }\n        \n        ObjectDistance od = sceneDistance(origin + forward * length);\n        distance = od.distance;\n        \n        if(distance < SHADOW_THRESHOLD) {\n            return 0.0;\n        }\n        \n        light = min(light, k * distance / length);\n        length += distance * 0.999;\n        \n        iterations++;\n    }\n\n    //return 1.0 - float(iterations) / float(MAX_SHADOW_ITERATIONS);\n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pxPos = 2.0*(0.5 * iResolution.xy - fragCoord.xy) / iResolution.xx;\n    \n    vec2 camXZ = polar2rect(vec2(-TAU/4.0 + 0.3 * iTime, 3.0));\n  \tvec3 camPos = vec3(camXZ.x, 1.0 + 0.5 * sin(1.0 * iTime), camXZ.y);\n    \n    vec3 camLook = vec3(0.0, 0.0, 0.0);\n    \n    vec3 camUp = vec3(0.0, 1.0, 0.0); \n    vec3 camForward = normalize(camLook - camPos);\n    vec3 camLeft = normalize(cross(camUp, camForward));\n    vec3 camUp2 = cross(camForward, camLeft);\n    vec3 camPosForward = camPos + camForward;\n    vec3 screenPos = camPosForward - pxPos.x * camLeft - pxPos.y * camUp2;\n    vec3 rayForward = normalize(screenPos - camPos);\n    \n    MarchResult mr = march(camPos, rayForward);\n    \t\n    vec3 rayEnd = camPos + mr.length * rayForward;\n    vec3 color;\n    vec3 bgColor = vec3(0.1);\n    \n    /*if(mr.distance < 0.0) {\n       \tcolor = vec3(0.0, 1.0, 1.0);\n    } else */if(mr.material == NO_MATERIAL) {\n        color = bgColor;\n    } else {\n        vec3 baseColor;\n        \n        if(mr.material == WHITE_MATERIAL) {\n            baseColor = vec3(1.0);\n        } else if(mr.material == RED_MATERIAL) {\n            baseColor = vec3(1.0, 0.0, 0.0);\n        } else if(mr.material == BLACK_MATERIAL) {\n            baseColor = vec3(0.2);\n        } else if(mr.material == LIGHT_MATERIAL) {\n         \tbaseColor = vec3(1.0, 0.7, 0.7);   \n        } else if(mr.material == GROUND_MATERIAL) {\n            float tile = mod(floor(rayEnd.x) + floor(rayEnd.z), 2.0);\n            \n            if(tile < 1.0) {\n\t         \tbaseColor = vec3(0.2);\n            } else {\n                baseColor = vec3(0.3);\n            }\n        }\n        \n        float deltaTwice = 2.0 * NORMAL_DELTA;\n        vec3 dx = vec3(NORMAL_DELTA, 0.0, 0.0);\n        vec3 dy = vec3(0.0, NORMAL_DELTA, 0.0);\n        vec3 dz = vec3(0.0, 0.0, NORMAL_DELTA);\n        vec3 normal = normalize(vec3(\n            (sceneDistance(rayEnd + dx).distance - sceneDistance(rayEnd - dx).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dy).distance - sceneDistance(rayEnd - dy).distance) / deltaTwice,\n            (sceneDistance(rayEnd + dz).distance - sceneDistance(rayEnd - dz).distance) / deltaTwice\n        ));\n\n       \tvec2 lightXZ = polar2rect(vec2(-0.5 * iTime, 3.0));\n        vec3 lightPos = vec3(lightXZ.x, 5.0, lightXZ.y);\n\n        float ambient = 0.2;\n        float diffuse = max(0.0, dot(normal, normalize(lightPos - rayEnd)));\n        float specular = pow(diffuse, 16.0);\n\t\tfloat shadow = 1.0;\n        shadow = marchShadow(lightPos, rayEnd, 32.0);\n        //shadow = marchGlitchyShadow(lightPos, rayEnd, 8.0);\n\n        color = ((ambient + shadow * diffuse) * baseColor + specular) * (1.0 - mr.length * 0.01);\n        //color = vec3(rayIterations / MAX_TRACE_ITERATIONS, 0.0, shadow);\n\n    }\n        \n\t//color = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), float(mr.iterations)/float(MAX_ITERATIONS));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBSzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBXzc", "name": "HelloWorldShader!", "author": "zachernuk", "description": "Just learning about Shaders / GLSL and what kinds of things can be done with them - they seem a lot more powerful than doing things in CPU!", "tags": ["primitives"], "likes": 3, "viewed": 140, "date": "1414191081", "time_retrieved": "2024-06-20T18:14:01.185840", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    vec2 realCenter = fragCoord.xy / iResolution.xy;\n    vec2 center = vec2(0.5+0.15*cos(iTime*1.05343),0.5+0.15*sin(iTime));\n    vec2 dist = uv-center;\n    float d = sqrt(dot(dist,dist));\n    d = pow((d+0.86),1000.0);\n    if(uv[0]>0.9 &&\n       uv[0]<1.2 && \n       uv[1]>0.35&&\n       uv[1]<0.65) { d = 0.0; }\n    float gg = 0.5*pow(sin(uv[0]*10.0+\n                      iTime+\n                      0.25*sin(5.0*iTime)),100.0);\n\tfragColor = vec4(1.0-d,\n                        gg,\n                        0,\n                        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBXzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdBXzd", "name": "Simple loading screen", "author": "ndel", "description": "Simple animation for a loading screen", "tags": ["2d", "simple", "loadingcreen"], "likes": 39, "viewed": 1365, "date": "1414752299", "time_retrieved": "2024-06-20T18:14:01.185840", "image_code": "\n#define SMOOTH(r) (mix(1.0, 0.0, smoothstep(0.9,1.0, r)))\n#define M_PI 3.1415926535897932384626433832795\n\nfloat movingRing(vec2 uv, vec2 center, float r1, float r2)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = -atan(d.y,d.x);\n    theta  = mod(-iTime+0.5*(1.0+theta/M_PI), 1.0);\n    //anti aliasing for the ring's head (thanks to TDM !)\n    theta -= max(theta - 1.0 + 1e-2, 0.0) * 1e2;\n    return theta*(SMOOTH(r/r2)-SMOOTH(r/r1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    float ring = movingRing(uv, vec2(iResolution.x/2.0,iResolution.y/2.0), 20.0, 30.0);\n    fragColor = vec4( 0.1 + 0.9*ring );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBXzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdjXRy", "name": "Chain of stars", "author": "gaz", "description": ".", "tags": ["2d", "3d", "billboard"], "likes": 4, "viewed": 319, "date": "1413299336", "time_retrieved": "2024-06-20T18:14:01.882760", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nstruct Quad\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n    \nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}   \n\nvec3 rotate( in vec3 p, in vec3 t )\n{\n    p.yz = rotate( p.yz, t.x );\n    p.zx = rotate( p.zx, t.y );\n\tp.xy = rotate( p.xy, t.z );\n    return p;\n}\n\nQuad rotate( in Quad m, in vec3 t )\n{\n    m.a = rotate(m.a, t);\n    m.b = rotate(m.b, t);\n    m.c = rotate(m.c, t);\n    m.d = rotate(m.d, t);\n    return m;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat deStar( in vec2 p)\n{\n    float time = -1.5 * iTime;\n    vec2 v0 = rotate( vec2(0.4, 0.0), PI2 / 5.0 * 0.0 + time) + vec2(0.5);\n    vec2 v1 = rotate( vec2(0.4, 0.0), PI2 / 5.0 * 1.0 + time) + vec2(0.5);\n    vec2 v2 = rotate( vec2(0.4, 0.0), PI2 / 5.0 * 2.0 + time) + vec2(0.5);\n    vec2 v3 = rotate( vec2(0.4, 0.0), PI2 / 5.0 * 3.0 + time) + vec2(0.5);\n    vec2 v4 = rotate( vec2(0.4, 0.0), PI2 / 5.0 * 4.0 + time) + vec2(0.5);\n    float de = 1.0;\n    de  = min( de, sdSegment( p, v0, v2) );\n    de  = min( de, sdSegment( p, v2, v4) );\n    de  = min( de, sdSegment( p, v4, v1) );\n    de  = min( de, sdSegment( p, v1, v3) );\n    de  = min( de, sdSegment( p, v3, v0) );\n    return de;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, in Quad q, out vec3 p)\n{\n    float z = 10.0;\n    vec3 n = cross( q.c - q.a, q.b - q.a );\n    float t = dot( q.a - ro, n ) / dot( rd, n );\n    if ( t > 0.0 )\n\t{\n    \tp = ro + rd * t;\n        if ( dot( cross( q.b - q.a, n ), p - q.a ) > 0.0 ) \n        if ( dot( cross( q.c - q.b, n ), p - q.b ) > 0.0 ) \n        if ( dot( cross( q.d - q.c, n ), p - q.c ) > 0.0 )\n        if ( dot( cross( q.a - q.d, n ), p - q.d ) > 0.0 ) z = t;\n    }\n    return z;\n}\n\nvec2 getUV(in Quad q, in vec3 p)    \n{\n\tvec3 ap = p - q.a;\n    vec3 bp = p - q.b;\n    vec3 dp = p - q.d;\n    vec3 ab = q.b - q.a;\n    vec3 ad = q.d - q.a;\n    float x0 = dot( bp, ab );\n    float x1 = dot( ap, ab );\n\tfloat y0 = dot( dp, ad );\n    float y1 = dot( ap, ad );\n    return vec2( x0 / ( x0 - x1 ), y0 / ( y0 - y1 ) );\n}\n\nQuad genQuad( in vec3 center)\n{\n \treturn Quad(\n        center + vec3(  1.0,  1.0, 0.0) * 0.5,\n        center + vec3( -1.0,  1.0, 0.0) * 0.5,\n        center + vec3( -1.0, -1.0, 0.0) * 0.5,\n        center + vec3(  1.0, -1.0, 0.0) * 0.5);\n}\n\nQuad quads( in int i )\n{\n    float time = 0.3 * iTime ;\n    vec3 theta = vec3( 0.2, 0.2, 0.6 * iTime );\n\tif ( i < 15)\n    {\n        time *= -1.0;\n        theta *= -1.0;\n    }\n    Quad s = genQuad(\n    \tvec3( 3.0 * sin( float( i ) * PI2 / 15.0 + time ),\n    \t\t  0.1, \n    \t\t  3.0 * cos( float( i ) * PI2 / 15.0 + time ) - 3.0\n    \t) );\n\treturn  rotate( s, theta );  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize( vec3( p, -1.8 ) );\n\tvec3 ro = vec3( 0.0, 0.0, 1.8 );\n    vec3 col =  vec3( 0.2 + 0.2 * p.y );\n    float z = 10.0;\n    for (int i = 0; i < 30; i++ )\n    {\n    \tQuad s = quads( i );\n    \tvec3 pos;\n    \tfloat d = castRay(ro, rd, s, pos);\n    \tif ( z > d )\n    \t{\n        \tvec2 uv = getUV( s, pos );\n            float dd = deStar(uv);\n            if ( dd < 0.025)\n            {\n                z = d;\n                col = hsv(mod(float(i), 15.0)/15.0, 0.8, 0.8) ;\n            }\n    \t}\n    } \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjXRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdSXRd", "name": "POP UP THE VOLYME JOOJOO", "author": "Branch", "description": "POP UP THE VOLYME JOOJOO", "tags": ["popupthevolymejoojoo"], "likes": 1, "viewed": 123, "date": "1414731340", "time_retrieved": "2024-06-20T18:14:02.391738", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b, float c ){\n  return 1.-floor(length(max(abs(coord-pos)-b,c)));\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\n\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 3.0*texture( iChannel0, original_coord * 0.6 + vec2(iTime*0.02) ).b * 0.6;\n    collision += 2.5*texture( iChannel0, original_coord * 0.1 + vec2(iTime*0.001) ).b * 0.4;\n    return -min(max(-collision,0.0),1.0);\n}\nvec3 overlay(){\n\tvec2 p = gl_FragCoord.xy / iResolution.xy;\n\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n        \n    vec3 COLOR = vec3(0.0);\n    float collision = 0.0;\n    for( float i = 0.0; i < 14.0; i++){\n        vec2 triangle_position = vec2(-mod(iTime+i*0.2+i*0.55,4.0)+2.0,sin(iTime+i));\n        triangle_position.y /= triangle_position.x + 2.3;\n        collision += triangle( coord, triangle_position, iTime+i, 0.03, 0.9 + sin(i*5235.1112313+iTime) * 0.2);\n    }\n    ;\n    if(collision<0.0){\n        COLOR = vec3(0.5);\n    }\n    return COLOR;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n        \n\tfloat vignette = 1.0 / max(0.25 + 0.3*dot(coord,coord),1.);\n    coord.x += 0.6;\n    coord /= 1.6+sin(iTime*2.0)*0.1;\n    coord *= rotate(0.2 + 0.1*sin(iTime));\n\tvec3 COLOR =(vec3(0.9,0.5,0.4)\n        \t\t+vec3(floor(mod(coord.y*2.,1.)*3.+.015))\n        \t\t*vec3(1.0,0.4,0.9) );\n    \n    \n    vec2 position = vec2(0.);\n    vec2 size = vec2(11.,0.3);\n    if(coord.x<0.){\n    size.y += (.631*sin(coord.x*4.)+1.)*texture(iChannel1,.4*coord+vec2(iTime*.17,0.)).r*1.;\n    size.y += (.341*sin(coord.x*2.)+1.)*texture(iChannel1,.4*coord+vec2(iTime*.127,0.)).r*.3;\n    size.y /= -.5+pow(-coord.x*.017-1.2,3.)+.1*sin(iTime+-coord.x*11.);\n    } else {\n    size.y += (.631*sin(coord.x*4.)+1.)*texture(iChannel1,.4*coord+vec2(-iTime*.17,0.)).r*1.;\n    size.y += (.341*sin(coord.x*2.)+1.)*texture(iChannel1,.4*coord+vec2(-iTime*.127,0.)).r*.3;\n    size.y /= -.5+pow(-coord.x*.017-1.2,3.)+.1*sin(iTime+-coord.x*11.);\n\n    }\n    float corner = 0.1;\n    COLOR -= max(roundBox(coord*5., position, size, corner )*2.,0.);\n    COLOR += overlay();\n    float head_size = sin(iTime)*.06+mod(iTime*2.,1.)*.03;\n    COLOR += 4.*circle(coord, vec2(0.), .5+head_size);\n    for(float i=0.; i<3.141*2.; i+=3.141*.25){\n    \tCOLOR += 4.*sdCapsule(coord, vec2(0.0), vec2(cos(i+iTime),sin(i+iTime))*.7, 0.1);\n    }\n    \n    \n    if(length(coord*vec2(.6,1.-sin(coord.x*5.-3.141*.5)))-.1<.15)\n    COLOR = vec3(1.);\n    if(length(coord)-.1<.1)\n    COLOR = vec3(0.);\n    if(length(coord)-.1<.01)\n    COLOR = vec3(1.);\n    \n    \n\tfragColor = vec4( COLOR*vignette\n         \t\t\t\t,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSXRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2SR3", "name": "simple ridiculous blue", "author": "yastero", "description": "learning the shader ropes", "tags": ["blue"], "likes": 1, "viewed": 126, "date": "1414363273", "time_retrieved": "2024-06-20T18:14:02.682893", "image_code": "uniform float iOvertoneVolume;\n\nvec4 blue_lines(vec2 fragCoord) {\n  float v = texture(iChannel0, vec2(0.5)).x;\n  float t = iTime;\n\n  vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n\n  float r, g, b = 0.0;\n  float i, j, k = 0.0;\n\n  float z = 6.0 + 4.0 * sin(t);\n\n  i = sin(pow(uv.x*z,2.0)+ abs(sin(t*70.0)*pow(uv.y*z,2.0)));\n  j = pow(i, 50.0*abs(sin(t*4.0*v)));\n  b = j;\n\n  return vec4(r, g, b, 1.0);\n}\n\nvec4 name_tbd(vec2 fragCoord) {\n  float v = iOvertoneVolume;\n  float t = iTime;\n\n  vec2 uv = 2.0*(fragCoord.xy/iResolution.xy) - 1.0;\n\n  float r, g, b = 0.0;\n  float h, i, j, k = 0.0;\n\n  float vv = 1.0;\n  float z = 2.0;\n  float w = 1000.0 + (1000.0 * pow(sin(t*3.0),3.0));\n\n  h = (w * pow(uv.x*z,2.0)) + pow(uv.y*z,2.0);\n  i = sin(h);\n  if (h > 4.0) {\n    i = 0.0;\n  }\n  j = pow(i, 50.0*abs(sin(vv*4.0)));\n  b = j;\n\n  return vec4(r, g, b, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float t = iTime;\n\n  fragColor = mix(blue_lines(fragCoord), name_tbd(fragCoord), sin(t));\n}\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2SR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2XDm", "name": "seascape + horizon", "author": "Linusmartensson", "description": "Remix of https://www.shadertoy.com/view/Ms2SD1 by TDM to go below the horizon line.", "tags": ["water"], "likes": 25, "viewed": 1448, "date": "1412786315", "time_retrieved": "2024-06-20T18:14:03.567681", "image_code": "// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 38;\nconst float PI\t \t= 3.14159265;\nconst float EPSILON\t= 1e-4;\nfloat EPSILON_NRM\t= 0.1 / iResolution.x;\n\n// sea\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 1.6;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 1.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nconst float SKY_INTENSITY = 1.0;\nfloat SEA_TIME = iTime * SEA_SPEED;\n\n// math\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 sky_color(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret * SKY_INTENSITY;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    mat2 m = mat2(1.6,1.2,-1.2,1.6);\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map(vec3 p) {\n    return map_detailed(p);\n}\nvec3 sea_color(in vec3 p, in vec3 n, in vec3 eye, in vec3 dist) {  \n    float fresnel_o = 1.0 - max(dot(n,-eye),0.0);\n    float fresnel = pow(fresnel_o,3.0) * 0.65;\n        \n    // reflection\n    vec3 refl = sky_color(reflect(eye,n));\n    \n    // color\n    vec3 ret = SEA_BASE;    \n    ret = mix(ret,refl,fresnel);\n    \n    // wave peaks    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    ret += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    return ret;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\nfloat hftracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = 1.0;\n    float hm = 0.0;    \n    float tmid = 1.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        //tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \ttmid += map(p);\n\t\t\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.4,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,-0.3,PI),iMouse.x*0.01);\n\tmat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.2,time*1.0);\n    ori.y += abs(map_detailed(-ori));\n    vec3 dir = normalize(vec3(uv.xy,-1.0));\n    dir = rotate(normalize(dir),rot);\n    \n    // tracing\n    vec3 p;\n    float dens = hftracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist)*EPSILON_NRM);\n             \n    // color\n    vec3 color = sea_color(p,n,dir,dist);\n    vec3 light = normalize(vec3(0.0,1.0,0.8));  \n    color += vec3(diffuse(n,light,80.0) * SEA_WATER_COLOR) * 0.12; \n    color += vec3(specular(n,light,dir,60.0));  \n    \n    // post\n    color = mix(sky_color(dir),color, clamp(1.0-length(dist)/100.0,0.0,1.0)); \n    color = pow(color,vec3(0.75));\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2XRV", "name": "Mandelbrot \"doubles\" (split)", "author": "rogerdahl", "description": "Small modification of [url=https://www.shadertoy.com/view/XdsXWN\"]this shader[/url] by TekF. Adds the split screen feature suggested by iq that lets the single and double precision be compared.", "tags": ["doubleprecision"], "likes": 3, "viewed": 206, "date": "1413866545", "time_retrieved": "2024-06-20T18:14:04.452651", "image_code": "// webgl mandelbrot shader test\n// by Franc[e]sco\n// adapted by TekF\n\n#define SPLIT_SCREEN_FAKE_DOUBLE_SINGLE_COMPARE\n\n// my work & home PCs get very different results, so toggle some things\n// it seems to be caused by the precision of the pan value\n#if (1)\n\t// Work PC (GeForce GTX 770)\n\tconst vec4 pan = vec4(-0.31750109, 0.48999993, 0.00000000000000588, .0);\n\tconst float period = 175.0; // higher quality results at this position, so can zoom closer\n#else\n\t//Home PC (Radeon HD 7700)\n\tconst vec4 pan = vec4(-0.3175011, 0.49, .00000000011, .0);\n\tconst float period = 142.0;\n#endif\n\n//const vec4 pan = vec4(-0.300853, 0.441, 0.00000000000000032, -0.0000000000238951); // does anyone have a good point to zoom on?\n//const vec4 pan = vec4(-0.3151, 0.445, 0, -.000000013);\n\n\nconst int maxIterations = 256;\nconst vec3 colourPhase = vec3(5,7,11)/80.0;\nconst vec3 colourPhaseStart = vec3(1);\n\nconst float initialZoom = 3.5;\n\n\nvec2 DoubleMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\t// c = a*b\n\t// (c.y+c.x) = (a.x+a.y)*(b.x+b.y);\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n\t// if we add it to the big, it might lose precision in the middle of the number\n\t// which would be as bad as a float, so:\n\n// trying out some ideas to make the \"doubles\" more robust:\n\t\n// try to add it to c.x, and detect how much underflowed to add to c.y\n// I don't expect this will work, because the compiler will optimise it out\n/*c.x = l+r;\nfloat rf = c.x-l; // the part of r that actually made it after rounding.\nr = r - rf;\nc.y += r;*/\n// note that a.x*b.x already underflows, so using the full precision will make that a more serious problem.\n// => need upper & lower halfs of .x's... uh...\n\nc.x = l;\nc.y += r;\n\n/*\nThis introduces more errors!\ncould try taking the difference between c.x and c.x+r, and that remainder is the value to add to c.y\n// do something more robust, otherwise the vals can both lose too much precision\n\tfloat cp = log2(abs(c.x));\n\tfloat rp = log2(abs(r));\n\tconst float precis = 20.0;\n\tif ( rp > cp-precis )\n\t{\n\t\t// chop rp up into 2 bits, put the bigger bits in the top val\n\t\tfloat cut = exp2(cp-precis);\n\t\tfloat r2 = fract(r/cut)*cut;\n\t\tc.y += r2;\n\t\tc.x += r-r2;\n\t}\n\telse\n\t{\n\t\tc.y += r;\n\t}\n*/\n\treturn c;\n}\n\nvec3 fractal( vec2 pos ) {\n\t\n\t// randomly tweaked the calculations for semi-constant zooming\n\t// I don't really know what I'm doing here, but it works\n\tfloat T = abs(fract((iTime/period)*.5+.5)*2.0-1.0001)*period; // using exactly 1.0 breaks it, I don't know why\n\tfloat zoom = pow(initialZoom, (-T + initialZoom + 1.0) / 5.0);\n\n\tvec4 Z = vec4(0), C = vec4(0);\n\tint iterations;\n\tbool ignore = false;\n\t\n\t// convert to texels, center the set on screen and apply zoom\n\tvec2 pixel;\n\tpixel = (pos / iResolution.xy - 0.5) * zoom; \n    float aspectRatio = iResolution.x / iResolution.y;\n\tpixel.y /= aspectRatio; // fix aspect ratio\n\n\tfloat a = iTime*.05;\n\tpixel = pixel*cos(a)+vec2(1,-1)*sin(a)*pixel.yx;\n\n\n#ifdef SPLIT_SCREEN_FAKE_DOUBLE_SINGLE_COMPARE\n    if (pos.x > iResolution.x / 2.0) {\n\t\tC.xy = pixel;\n    }\n    else {\n        C.zw = pixel;\n    }\n#else\n\tC.zw = pixel;\n#endif\n    \n\tC -= pan;\n\t\n\tfor (int i = 0; i < maxIterations; i++) {\n\t\tif (ignore)\n\t\t\tbreak;\n\t\t\n\t\t// complex number operations\n\t\t// Z = Z*Z + C\n\t\tvec4 Z2;\n\t\t//Z.x * Z.x - Z.y * Z.y, \n\t\tZ2.xz = DoubleMul(Z.xz,Z.xz) - DoubleMul(Z.yw,Z.yw);\n\t\tZ2.yw = 2.0*DoubleMul(Z.xz,Z.yw);\n\t\tZ = Z2 + C; // apply panning\n\t\t\n\t\t// stop immediately if the point is outside a radius of 2 from (0,0) (the bounds of the mandelbrot set)\n\t\t//if ( dot((DoubleMul(Z.xz,Z.xz) + DoubleMul(Z.yw,Z.yw)),vec2(1)) > 4.0 ) // smooth\n\t\tif ( max(abs(dot(Z.xz,vec2(1))),abs(dot(Z.yw,vec2(1)))) > 2.0 ) // scallops\n\t\t\tignore = true;\n\t\t\n\t\titerations = i;\n\t}\n\t\n\t//return pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(2.2));\n\treturn pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(1.5));\n\t//return 1.0-abs(sin(colourPhase.xyz * float(iterations) + colourPhaseStart));//*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//fragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;\n\t\n/*\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.75) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.75) );\n\tfragColor.rgb /= 8.0;*/\n\t\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\n\tfragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2XRy", "name": "Spheregrid", "author": "kuvkar", "description": "raytraced, reflecting and rotating spheres in a grid dancing with music", "tags": ["3d", "raytracing", "reflections"], "likes": 4, "viewed": 240, "date": "1413316888", "time_retrieved": "2024-06-20T18:14:05.755727", "image_code": "mat4 cam;\nmat3 rot;\nvec3 lookFrom;\nvec3 lookAt;\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n    \n};\n    \nstruct Ray\n{\n    vec3 from;\n    vec3 direction;\n};\n\nconst int SPHERES_COUNT = 9;\n    \nSphere spheres[SPHERES_COUNT];\n\n\nconst float distort = 1.0;\nfloat d = 4.0 / distort;\nvec3 lightPos = vec3(1000, 1000, 2000.0);\nvec4 ambient = vec4(0.15, 0.15, 0.15, 0.15);\n\nvec4 ColorCircle(in Sphere sp, Ray ray, float t, vec3 temp, out vec3 norm, out vec3 hit)\n{\n    vec3 hitp = ray.from + t * ray.direction;\n    vec3 normal = hitp - sp.position;\n    normal = normalize(normal);\n    \n    vec3 lightDir = normalize(lightPos - sp.position );\n    vec3 ldiff = lightPos - sp.position;\n    \n    float d = dot(normal, normalize(lightDir));  \n    d = max(d, 0.0);\n    \n    vec3 ldiff2 = lightPos - hitp;\n    vec3 R = reflect(normalize(-ldiff2), normal);    \n    R = normalize(R);\n    \n    float spec = dot(R, normalize(-ray.direction));    \n    \n    spec = max(0.0, spec);\n    spec = pow(spec, 10.0);\n    \n    vec4 specColor = vec4(spec, spec, spec, spec);\n    norm = normal;\n    hit = hitp;\n    return vec4(d, d, d, d) * sp.color + ambient + spec;\n}\n\n\n\nvec4 traceSphere(in Sphere sp, Ray ray, out vec3 hitp, out vec3 normal, out float hitdistance)\n{\n    \n    float d;\n    vec3 temp = ray.from - sp.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(temp, ray.direction);\n    float c = dot(temp, temp) - sp.radius * sp.radius;\n    float disc = b * b - 4.0 * a * c;\n    \n    if (disc >= 0.0)\n    {\n        float e = sqrt(disc);\n        float denom = 2.0 * a;\n        float t = (-b - e) / denom;\n        \n        if ( t > 0.0)\n        {\n\t        hitdistance = t;\n            return ColorCircle(sp, ray, t, temp, normal, hitp);\n        }\n        \n        t = (-b + e) / denom;\n        \n        if (t > 0.0)\n        {\n\t        hitdistance = t;\n            return ColorCircle(sp, ray, t, temp, normal, hitp);\n        }       \n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n\nvec4 traceSpheres(Ray ray, int bounceIndex, out vec3 hitp, out vec3 normal)\n{\n    \n    \n    float closestHit = 99999.0;\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i = 0; i < SPHERES_COUNT; ++i)\n    {\n\t    float hitDistance = 0.0;\n        vec4 result = traceSphere(spheres[i], ray, hitp, normal, hitDistance);\n       \t\n        if (hitDistance > 0.0)\n        {\n            if (hitDistance < closestHit)\n            {\n                closestHit = hitDistance;\n                col = result;\n            }\n            \n        }\n    }\n    \n    \n    return col;\n}\n\n\nvec2 getNormalizedPosition(vec2 screenCoord)\n{\n    float midx = iResolution.x * 0.5;\n    float midy = iResolution.y * 0.5;\n    \n    float mx = screenCoord.x - midx;\n    float my = screenCoord.y - midy;\n    return vec2(mx / midx, my / midx);\n}\n\n\nRay getRay(vec2 screenCoord)\n{\n    vec3 p = vec3(getNormalizedPosition(screenCoord), 0.0);\n    \n    Ray r;\n    r.from = lookFrom;\n    \n    vec3 look = lookAt - lookFrom;\n    \n    p.z = look.z;\n    p.z /= length(look);\n    p.z *= d;\n    p = normalize(p);\n    r.direction = p;\n    r.direction *= rot;\n    \n    return r;\n}\n\n\nvoid lookat(vec3 to)\n{\n    lookAt = to;\n    vec3 fwd = normalize(lookFrom - to);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 v = normalize(cross(up, fwd));\n    vec3 w = normalize(cross(fwd, v));\n    \n    rot[0] = v;\n    rot[1] = w;\n    rot[2] = fwd;\n\n\n}\n\nvec4 draw(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 totalCol = vec4(3.0, 1.0 + sin(iTime * 0.25), uv.y * 4.0 + 1.0 - sin(iTime * 0.5), 0.0);    \n\tconst int kernel = 3;\n    const float filterOffset = 1.0 / float(kernel);\n     \n    \n    for (int x = -kernel; x < kernel; x+=2)\n    {\n        for (int y= -kernel; y < kernel; y+=2)\n        {\n            vec3 hitp = vec3(0.0, 0.0, 0.0);\n            vec3 normal = vec3(0.0, 0.0, 0.0);\n            vec2 offset = vec2(x, y) * filterOffset;\n            \n            vec2 pos = fragCoord.xy + offset;\n\t\t    Ray r = getRay(pos);\n\t\t    totalCol += traceSpheres(r, 0, hitp, normal);\n            \n            if (hitp != vec3(0.0, 0.0, 0.0))\n            {\n\t            vec3 ref = reflect(r.direction, normal);\n                Ray r2;\n                r2.from = hitp;\n                r2.direction = normalize(ref);\n                r2.from += r2.direction * 1.0;\n                \n                vec4 reflectCol = traceSpheres(r2, 0, hitp, normal);\n                totalCol += reflectCol * 0.95;\n                \n            }\n        }\n    }\n    \n    return totalCol / float (kernel * kernel);\n}\n\nvec3 rotatey(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), 0.0, sin(angle));\n    mat[1] = vec3(0.0, 1.0, 0.0);\n    mat[2] = vec3(-sin(angle), 0.0, cos(angle));\n    return mat * point;\n}\n\nvec3 rotatez(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), -sin(angle), 0.0);\n    mat[1] = vec3(sin(angle), cos(angle), 0.0);\n    mat[2] = vec3(0.0, 0.0, 1.0);\n    return mat * point;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = mod(iTime, 4.0);\n    \n    d = 4.0 / distort;\n    \n    \n    lookFrom = vec3(0.0, -0.0, 800.0);\n    \n    vec3 at = vec3(0.0, 0.0, -1.0);\n    \n    lookat(lookFrom + at);\n    float yp = -1.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float w = texture( iChannel0, vec2(uv.y,1.0) ).x;\n    float wave2 = texture( iChannel0, vec2(uv.x,1.0) ).x;\n    \n    \n    float radius = 30.0 * (1.0 + w * 0.05);\n\tfloat toRotate = iTime;\n    \n    for (int i = 0; i < SPHERES_COUNT; ++i)\n    {\n        \n        Sphere s;\n        float fi = float(i);\n        float xp = fi;\n        \n        xp = mod(xp, 3.0);\n        yp += mod(fi, 3.0) == 0.0 ? 1.0 : 0.0;\n        xp -= 1.0;\n        float y = yp - 1.0;\n        \n        vec3 spos = vec3(xp * radius * 2.5, y * radius * 2.5, 0.0);\n        spos = rotatez(toRotate, spos);    \n        spos = rotatey(sin(toRotate), spos);    \n        s.position = spos;\n        s.radius = radius;\n        \n        float r = (sin(iTime + 2.0) + 1.0) * 0.5;\n        float g = (cos(iTime) + 1.0) * 0.5;\n        g *= wave2;\n        float b = mod(fi, 2.0);\n        vec4 color = vec4(r, g, b, 0.0);\n        s.color = color;\n        spheres[i] = s;\n    }\n    \n    fragColor = draw(fragCoord);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBSRV", "name": "On/Off Spikes", "author": "movAX13h", "description": "My first rm shader with shadow pass. No AA. Mouse enabled. \nThank you srtuss for support. Thank you morgan3d for the nebula function.", "tags": ["shadows", "raymarcher"], "likes": 103, "viewed": 16680, "date": "1413586923", "time_retrieved": "2024-06-20T18:14:07.125660", "image_code": "// On/Off Spikes, fragment shader by movAX13h, oct 2014\n\n#define HARD_SHADOW\n#define GLOW\n#define EDGES\n#define NUM_TENTACLES 6\n#define BUMPS\n#define NUM_BUMPS 8\n#define BACKGROUND\n#define SUN_POS vec3(15.0, 15.0, -15.0)\n//#define SUN_SPHERE\n\n#define SPHERE_COL vec3(0.6, 0.3, 0.1)\n#define MOUTH_COL vec3(0.9, 0.6, 0.1)\n#define TENTACLE_COL vec3(0.06)\n\n#define GAMMA 2.2\n\n//---\n#define resolution iResolution\n#define mouse iMouse\n#define pi2 6.283185307179586476925286766559\n#define pih 1.5707963267949\n\n// Using the nebula function of the \"Star map shader\" by morgan3d \n// as environment map and light sphere texture (https://www.shadertoy.com/view/4sBXzG)\nconst float pi= 3.1415927;const int NUM_OCTAVES = 4;float hash(float n) { return fract(sin(n) * 1e4); } float hash(vec2 p){return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 +p.x))));}float noise(float x) { float i = floor(x);float f = fract(x); float u = f * f * (3.0 - 2.0 * f);return mix(hash(i),hash(i+1.0),u);}float noise(vec2 x){vec2 i=floor(x);vec2 f=fract(x);\tfloat a = hash(i); float b=hash(i + vec2(1.0,0.0));float c=hash(i+vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }float NOISE(vec2 x){ float v = 0.0; float a = 0.5; vec2 shift=vec2(100);mat2 rot=mat2(cos(0.5),sin(0.5), -sin(0.5), cos(0.50)); for (int i = 0; i < NUM_OCTAVES;++i) {v+=a*noise(x);x = rot* x * 2.0 + shift; a *= 0.5; } return v; }float square(float x) { return x * x;}mat3 rotation(float yaw, float pitch){return mat3(cos(yaw),0,-sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); }vec3 nebula(vec3 dir) { float purple = abs(dir.x); float yellow = noise(dir.y);vec3 streakyHue = vec3(purple + yellow, yellow * 0.7, purple);vec3 puffyHue = vec3(0.8, 0.1, 1.0);float streaky = min(1.0, 8.0 * pow(NOISE(dir.yz*square(dir.x) * 13.0+ dir.xy * square(dir.z) * 7.0 + vec2(150.0, 2.0)),10.0));float puffy=square(NOISE(dir.xz * 4.0 + vec2(30, 10)) * dir.y);\nreturn pow(clamp(puffyHue * puffy * (1.0 - streaky) + streaky * streakyHue, 0.0, 1.0), vec3(1.0/2.2));}\n// ---\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\n// polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// globals\nfloat glow, bite;\nvec3 sphere_col;\nvec3 sun = normalize(SUN_POS);\nfloat focus = 5.0;\nfloat far = 23.0;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat edge;\n};\n\nHit scene(vec3 p)\n{\n\tfloat d, d1, d2, d3, f, e = 0.15;\n\t\n\tvec3 q = p;\n\tq.xy = rotate(q.xy, 1.5);\n\t\n\t// center sphere\n\td1 = sdSphere(q, 0.3);\n\td = d1; \n    vec3 col = sphere_col; \n    \n\t// tentacles\n\tfloat r = length(q);\n\tfloat a = atan(q.z, q.x);\n\ta += 0.4*sin(r-iTime);\n\t\n\tq = vec3(a*float(NUM_TENTACLES)/pi2,q.y,length(q.xz)); // circular domain\n\tq = vec3(mod(q.x,1.0)-0.5*1.0,q.y,q.z); // repetition\n\t\n\td3 = sdCappedCylinder(q-vec3(0.0,0.0,0.9+bite), vec2(0.1-(r-bite)/18.0,0.8));\n\td2 = min(d3, sdBox(q-vec3(0.0, 0.0, 0.1+bite), vec3(0.2, 0.2, 0.2))); // close box\n\td2 = smin(d2, sdBox(q-vec3(0.0, 0.0, 0.4+bite), vec3(0.2, 0.05, 0.4)), 0.1); // wide box\n\t\n    f = smoothstep(0.11, 0.28, d2-d1);\n\tcol = mix(MOUTH_COL, col, f);\n\te = mix(e, 0.0, f);\n\td = smin(d1, d2, 0.24);\n    \n\tcol = mix(TENTACLE_COL, col, smoothstep(0., 0.48, d3-d));\n\t\n    #ifdef SUN_SPHERE\n\td = min(d, sdSphere(p-sun, 0.1));\n    #endif\n    \n\t#ifdef BUMPS\n\tfor(int i = 0; i < NUM_BUMPS; i++)\n\t{\n        d2 = float(i);\n        d1 = sdSphere(p-0.18*smoothstep(0.1, 1.0, glow)*\n                      vec3(sin(4.0*iTime+d2*0.6), sin(5.3*iTime+d2*1.4), cos(5.8*iTime+d2*0.6)),\n                      0.03);\n\t\t\n\t\td = smin(d1, d, 0.2);\n\t\t//d = min(d1, d);\n\t}\n\t#endif\n\t\n\t#ifdef BACKGROUND\n\tq = p;\n\tq.yz = mod(q.yz, 1.0);\n\tq -= vec3(-.6, 0.5, 0.5);\n\td1 = sdBox(q, vec3(0.1, 0.48, 0.48));\n\tif (d1 < d) { d = d1; col = vec3(0.1); }\n\t#endif\n\t\n\treturn Hit(d, col, e);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p) // by srtuss\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc / h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.3*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = 0.4*pow(max(0.0, dot(ref, lightPos)), 6.5);\n\n\treturn (hit.color.rgb + \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //time = iTime;\n    glow = max(0.0, min(1.0, 2.0*sin(iTime*0.7-5.0)));\n    bite = smoothstep(0.0, 1.0, 1.6*sin(iTime*0.7));\n    sphere_col = SPHERE_COL*glow;\n\n    \n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) / resolution.y;\n\t\n\tfloat d = clamp(1.5*sin(0.3*iTime), 0.5, 1.0);\n\tvec3 cp = vec3(10.0*d, -2.3*d, -6.2*d+4.0*clamp(2.0*sin(iTime*0.5), 0.0, 1.0)); // anim curious spectator\n\t\n\tif (mouse.z > 0.5)\n\t{\n\t\tvec2 mrel = mouse.xy/resolution.xy-0.5;\n\t\tfloat mdis = (8.0+6.0*mrel.y);\n\t\tcp = vec3(mdis*cos(-mrel.x*pih), 4.0*mrel.y, mdis*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t// raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.9;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun)*m;\n\n    #ifdef EDGES\n\tfloat edge = edges(ray);\n\tcol = mix(col, vec3(0.0), h.edge*edge*smoothstep(0.3, 0.35, length(ray)));\n    #endif\n    \n\tvec3 neb = nebula(n);\n\tcol += min(glow, 0.1)*neb.brg;\n\t\n\t// HARD SHADOW with low number of rm iterations (from obj to sun)\n\t#ifdef HARD_SHADOW\n\tvec3 ray1 = ray;\n\tdir = normalize(SUN_POS - ray1);\n\tray1 += n*0.002;\n\t\n\tfloat sunDist = length(SUN_POS-ray1);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray1 + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\n\tcol -= 0.24*smoothstep(0.5, -0.3, min(dist, sunDist)/max(0.0001,sunDist));\n\t#endif\n\t\n\t// ILLUMINATION & free shadow with low number of rm iterations (from obj to sphere)\n\t#ifdef GLOW\n\tdir = normalize(-ray);\n\tray += n*0.002;\n\t\n\tfloat sphereDist = max(0.0001, length(ray)-0.3);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\t\n\tvec3 neb1 = nebula(dir*rotation(0.0, iTime*0.4)).brg;\n    \n\tcol += (0.7*sphere_col+glow*neb1)*(0.6*(smoothstep(3.0, 0.0, sphereDist))*min(dist, sphereDist)/sphereDist + \n\t\t   0.6*smoothstep(0.1, 0.0, sphereDist));\n\t#endif\n    \n\tcol -= 0.2*smoothstep(0.6,3.7,length(pos));\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.9;\n\tcol = pow(col, vec3(1.0 / GAMMA));\n    \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBSRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBSWm", "name": "Kiss", "author": "hugo", "description": "My 1st shader! \\o/", "tags": ["shit"], "likes": 0, "viewed": 117, "date": "1412469091", "time_retrieved": "2024-06-20T18:14:07.125660", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x = 1.0 + (((iResolution.x - iResolution.y) / (2.0*iResolution.y))) - (fragCoord.x / iResolution.y);\n \tfloat s = 0.15 + sin(t)*0.07;\n    float l = 1000.0 + sin(t*0.1)*500.0;\n\n\n    float d = distance(vec2(uv.y + sin(uv.x*0.05*t)*uv.x, uv.y), vec2(0.5,0.5));\n    \n    if(d < 0.30 && d > 0.29) {\n        if(mod(uv.x, 2.0) >= 1.0) {\n        \tfragColor = vec4(0.37,0.43,0.54,1.0);\n        } else {\n            fragColor = vec4(0.88,0.89,0.94,1.0);\n        }\n    } else {\n        fragColor = vec4(0,0,0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBSWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsjXRG", "name": "AocTest", "author": "dila", "description": "Testing ambient occlusion.", "tags": ["raymarchambientocclusion"], "likes": 13, "viewed": 470, "date": "1413225686", "time_retrieved": "2024-06-20T18:14:07.125660", "image_code": "mat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sphereDistance(vec3 pos) {\n\treturn length(pos) - 0.6;   \n}\n\nfloat cubeDistance(vec3 pos) {\n\tvec3 clamped = clamp(pos, -0.5, 0.5);\n    return length(pos - clamped);\n}\n\nfloat planeDistance(vec3 pos) {\n\tvec3 origin = vec3(0.0, -0.5, 0.0);\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 delta = pos - origin;\n    float prod = dot(delta, normal);\n    return prod;\n}\n\nfloat combinedDistance(vec3 pos) {\n    pos *= xrotate(0.5) * yrotate(iTime);\n    \n    float cube = cubeDistance(pos);\n    \n    float sphere = sphereDistance(pos);\n    \n\tfloat x = max(cube - sphere, cube);\n    \n\treturn min(x, planeDistance(pos));\n}\n\nfloat aoc(vec3 origin, vec3 ray) {\n    float delta = 0.1;\n    const int samples = 6;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = combinedDistance(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 origin = vec3(0.0, 0.0, -2.0);\n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    float t = 0.0;\n    \n    for (int i = 0; i < 64; ++i) {\n        vec3 pos = origin + ray * t;\n        float d = combinedDistance(pos);\n        if (d < 0.0) {\n         \tbreak;   \n        }\n        t += d;\n    }\n    \n    vec3 worldPos = origin + ray * t;\n    \n    float shade = 1.0 - aoc(worldPos, -ray);\n    \n    shade = pow(max(shade, 0.0), 8.0);\n    \n    float fog = 1.0 / (1.0 + t);\n    \n    float col = shade * fog;\n    \n\tfragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjXRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsSSzy", "name": "C64 Rasterbars", "author": "Harha", "description": "I was going to render it using some GLSL functions but that failed due to my limited knowledge of GLSL. :( No idea how I could make an algorithm for this even though I have some experience in C64 Assembly programming, doesn't help in GLSL I guess. :D", "tags": ["c64", "commodore", "raster", "fail", "64", "bar", "rasterbar"], "likes": 9, "viewed": 639, "date": "1413034980", "time_retrieved": "2024-06-20T18:14:07.768041", "image_code": "// Variables\nvec4 final_col = vec4(0.0); // <-- Fixed according to the suggestion by user inferno\n\n// Color palette arrays\n// Not sure how accurate they are but whatever, looks enough C64'ish to me\nvec4 PALETTE_RED[4];\nvec4 PALETTE_GREEN[4];\nvec4 PALETTE_BLUE[4];\nvoid buildPalette()\n{\n    // Red color palette\n    PALETTE_RED[0] = vec4( 0.533, 0.223, 0.196, 1.0);\n    PALETTE_RED[1] = vec4( 0.721, 0.411, 0.384, 1.0);\n    PALETTE_RED[2] = vec4( 0.749, 0.807, 0.447, 1.0);\n    PALETTE_RED[3] = vec4( 1.000, 1.000, 1.000, 1.0);\n    // Green color palette\n    PALETTE_GREEN[0] = vec4( 0.333, 0.627, 0.286, 1.0);\n    PALETTE_GREEN[1] = vec4( 0.580, 0.878, 0.537, 1.0);\n    PALETTE_GREEN[2] = vec4( 0.749, 0.807, 0.447, 1.0);\n    PALETTE_GREEN[3] = vec4( 1.000, 1.000, 1.000, 1.0);\n    // Blue color palette\n    PALETTE_BLUE[0] = vec4( 0.250, 0.192, 0.552, 1.0);\n    PALETTE_BLUE[1] = vec4( 0.470, 0.411, 0.768, 1.0);\n    PALETTE_BLUE[2] = vec4( 0.403, 0.713, 0.741, 1.0);\n    PALETTE_BLUE[3] = vec4( 1.000, 1.000, 1.000, 1.0);\n}\n\nvec4 rasterline(in vec2 xy, in int axis, in vec4 line_color, in float raster_size, in float line_pos, in float line_offset)\n{\n    float line_pos_final = line_pos + (line_offset);\n    float line_pos_max = line_pos_final + raster_size;\n    float line_pos_min = line_pos_final - raster_size;\n    \n    if (axis == 0 && xy.x < line_pos_max && xy.x > line_pos_min)\n    {\n        return line_color;\n    }\n    \n    if (axis == 1 && xy.y < line_pos_max && xy.y > line_pos_min)\n    {\n        return line_color;\n    }\n    \n    return vec4(0.0);\n}\n\nvoid rasterbar(in vec2 xy, in int axis, in vec4 palette_0[4], in vec4 palette_1[4], in float bar_pos, in float size_0)\n{\n    // Lol, I'm new to GLSL so I just dealt with my lack of knowledge and hardcoded this...\n    // This kinda loses it's point if I do it this way though. :( Maybe I'll figure this out later...\n    final_col += rasterline(xy, axis, palette_0[0], 0.015 * size_0, bar_pos, 0.2300 * size_0);\n    final_col += rasterline(xy, axis, palette_0[1], 0.005 * size_0, bar_pos, 0.2100 * size_0);\n    final_col += rasterline(xy, axis, palette_0[0], 0.005 * size_0, bar_pos, 0.2000 * size_0);\n    final_col += rasterline(xy, axis, palette_0[1], 0.015 * size_0, bar_pos, 0.1800 * size_0);\n    final_col += rasterline(xy, axis, palette_0[0], 0.005 * size_0, bar_pos, 0.1600 * size_0);\n    final_col += rasterline(xy, axis, palette_0[1], 0.015 * size_0, bar_pos, 0.1400 * size_0);\n    final_col += rasterline(xy, axis, palette_0[2], 0.005 * size_0, bar_pos, 0.1200 * size_0);\n    final_col += rasterline(xy, axis, palette_0[1], 0.005 * size_0, bar_pos, 0.1100 * size_0);\n    final_col += rasterline(xy, axis, palette_0[2], 0.015 * size_0, bar_pos, 0.0900 * size_0);\n    final_col += rasterline(xy, axis, palette_0[3], 0.005 * size_0, bar_pos, 0.0700 * size_0);\n    final_col += rasterline(xy, axis, palette_0[2], 0.005 * size_0, bar_pos, 0.0600 * size_0);\n    final_col += rasterline(xy, axis, palette_0[3], 0.005 * size_0, bar_pos, 0.0500 * size_0);\n    final_col += rasterline(xy, axis, palette_0[2], 0.005 * size_0, bar_pos, 0.0400 * size_0);\n    final_col += rasterline(xy, axis, palette_0[3], 0.020 * size_0, bar_pos, 0.0200 * size_0);\n    \n    final_col += rasterline(xy, axis, palette_1[0], 0.015 * size_0, bar_pos, -0.2300 * size_0);\n    final_col += rasterline(xy, axis, palette_1[1], 0.005 * size_0, bar_pos, -0.2100 * size_0);\n    final_col += rasterline(xy, axis, palette_1[0], 0.005 * size_0, bar_pos, -0.2000 * size_0);\n    final_col += rasterline(xy, axis, palette_1[1], 0.015 * size_0, bar_pos, -0.1800 * size_0);\n    final_col += rasterline(xy, axis, palette_1[0], 0.005 * size_0, bar_pos, -0.1600 * size_0);\n    final_col += rasterline(xy, axis, palette_1[1], 0.015 * size_0, bar_pos, -0.1400 * size_0);\n    final_col += rasterline(xy, axis, palette_1[2], 0.005 * size_0, bar_pos, -0.1200 * size_0);\n    final_col += rasterline(xy, axis, palette_1[1], 0.005 * size_0, bar_pos, -0.1100 * size_0);\n    final_col += rasterline(xy, axis, palette_1[2], 0.015 * size_0, bar_pos, -0.0900 * size_0);\n    final_col += rasterline(xy, axis, palette_1[3], 0.005 * size_0, bar_pos, -0.0700 * size_0);\n    final_col += rasterline(xy, axis, palette_1[2], 0.005 * size_0, bar_pos, -0.0600 * size_0);\n    final_col += rasterline(xy, axis, palette_1[3], 0.005 * size_0, bar_pos, -0.0500 * size_0);\n    final_col += rasterline(xy, axis, palette_1[2], 0.005 * size_0, bar_pos, -0.0400 * size_0);\n    final_col += rasterline(xy, axis, palette_1[3], 0.020 * size_0, bar_pos, -0.0200 * size_0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Don't mind my code, it's dumb. But hey, it's my first GLSL script, yay! This is fun.\n    buildPalette();\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 xy_norm;\n\txy_norm.x = (fragCoord.x / iResolution.x) * aspectRatio;\n    xy_norm.y = fragCoord.y / iResolution.y;\n    vec2 xy_final = -1.0 + 2.0 * xy_norm;\n    \n    float bar_0_pos = 0.25 * sin(iTime * 2.5) + 0.625;\n    float bar_1_pos = 0.1 * sin(xy_final.x + iTime * 5.0);\n    float bar_2_pos = 0.1 * sin(xy_final.y + iTime * 2.5) - 0.625;\n    float bar_3_pos = 0.1 * cos((xy_final.y * 2.5) + iTime * 5.0) + 2.25;\n    float bar_4_pos = 0.1 * cos(iTime * 5.0) + 1.75;\n    float bar_5_pos = 0.25 * cos((xy_final.x * 2.0) + iTime * 2.5) + 1.125;\n    \n    if (xy_final.x < 0.75)\n    {\n   \t\trasterbar(xy_final, 1, PALETTE_BLUE, PALETTE_BLUE, bar_0_pos, 0.5);\n    \trasterbar(xy_final, 1, PALETTE_GREEN, PALETTE_GREEN, bar_1_pos, 0.5);\n        rasterbar(xy_final, 1, PALETTE_RED, PALETTE_BLUE, bar_2_pos, 1.0);\n    }\n    else\n    {\n        rasterbar(xy_final, 0, PALETTE_RED, PALETTE_GREEN, bar_5_pos, 0.5);\n        rasterbar(xy_final, 0, PALETTE_GREEN, PALETTE_BLUE, bar_4_pos, 0.5);\n        rasterbar(xy_final, 0, PALETTE_RED, PALETTE_RED, bar_3_pos, 0.5);\n    }\n    \n    fragColor = final_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSSzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XssXzM", "name": "Sun Shield", "author": "jbum", "description": "Some quick fun with polar coords.", "tags": ["circle", "polar"], "likes": 3, "viewed": 139, "date": "1413490453", "time_retrieved": "2024-06-20T18:14:07.768041", "image_code": "// Sun Shield - Jim Bumgardner\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PId2 = PI/2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  p.y *= iResolution.y/iResolution.x;\n\n  float a = atan(p.x, p.y)+iTime*.001;\n  float d = length(p)*6.0;\n  fragColor = vec4(\n\t                  mix(\n\t                   vec3(.5*sin(vec3(iTime*.999,iTime,-iTime*.666)+a*pow(2.0,1.0+ceil(d)))),\n\t                   vec3(1.0+.5*sin(vec3(iTime*.555,-iTime,iTime*1.111)+a*pow(2.0,1.0+ceil(d+sin(iTime*0.1))))), 0.5),\n\t\t\t\t\t\t  \n                      1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XssXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
