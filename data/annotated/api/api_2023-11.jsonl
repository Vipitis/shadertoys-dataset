{"id": "dltfRB", "name": "exercise sprite", "author": "jorge2017a2", "description": "exercise sprite", "tags": ["bitmap", "sprite", "exercise", "icon"], "likes": 15, "viewed": 156, "published": 3, "date": "1701378971", "time_retrieved": "2024-07-30T17:19:44.942225", "image_code": "///por jorge2017a2\n//30-nov-2023-\n//referencia tunel ...https://www.shadertoy.com/view/ctdBzB\n//tmabien referencia al grande grupo de shadertoy....:)\n\n#define antialiasing(n) n/min(288.,512.)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nconst int NAVE_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,\n0,2,1,2,2,1,1,1,1,0,0,0,5,0,0,0,\n0,0,0,2,2,2,1,1,1,1,1,1,1,3,4,0,\n0,0,0,2,2,1,3,4,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\nconst int HOJA1_BITMAP[256] = int[](\n2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,\n2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,\n2,2,1,1,2,2,2,2,2,2,1,1,1,1,2,2,\n2,2,2,1,1,1,2,2,2,1,1,1,0,2,2,2,\n2,2,2,1,1,1,1,2,1,1,1,1,0,2,2,2,\n2,1,2,2,1,1,0,1,2,1,1,0,0,2,2,1,\n1,1,1,2,1,1,0,0,1,0,1,0,1,2,2,1,\n0,0,1,1,1,1,1,0,0,1,1,0,0,2,0,0,\n0,3,1,0,1,1,0,1,0,1,0,0,0,1,0,3,\n0,3,1,1,0,0,1,0,1,1,1,0,0,1,0,3,\n1,3,3,1,0,0,1,1,0,1,0,0,1,1,1,3,\n1,3,3,1,1,0,1,1,1,0,1,1,1,1,1,3,\n0,1,3,1,1,0,0,1,0,1,0,1,1,0,1,1,\n1,0,1,0,0,1,1,0,0,0,0,1,0,1,0,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0);\n\n\nconst int HOJA2_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,\n0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,\n0,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0,\n0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,\n0,0,1,1,1,0,0,0,1,1,0,1,1,0,0,0,\n0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,1,\n1,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,\n1,0,0,1,1,0,1,1,1,0,1,0,0,0,1,0,\n1,1,0,1,1,1,1,1,0,0,1,0,0,1,1,0,\n1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,\n0,1,1,1,0,1,1,1,0,1,1,0,1,1,0,0,\n0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,\n0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,\n0,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,\n0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1);\n\n\nvec3 RGB3(float r ,float g, float b)\n{ return vec3(r/255.,g/255.,b/255.);}\n\n\nvec3 GetColorNave(int opc)\n{   switch(opc)\n    {\n        \n    case 0:return RGB3(0.,0.,0.);\n    case 1:return RGB3(140.,140.,140.);\n    case 2:return RGB3(255.,0.,255.);\n    case 3:return RGB3(255.,255.,255.);\n    case 4:return RGB3(0.,159.,98.);\n    case 5:return RGB3(255.,255.,0.);\n\n    }\n    return vec3(1.0);\n}\n\n\nvec3 GetColrHoja1(int opc)\n{   switch(opc)\n    {\n    case 0:return RGB3(152.,232.,0.);\n    case 1:return RGB3(80.,160.,0.);\n    case 2:return RGB3(0.,0.,0.);\n    case 3:return RGB3(72.,88.,0.);\n   }\n    return vec3(1.0);\n}\n\nvec3 GetColrHoja2(int opc)\n{   switch(opc)\n    {\n    \n    case 0:return RGB3(80.,160.,0.);\n    case 1:return RGB3(152.,232.,0.);\n   }\n    return vec3(1.0);\n}\n\nvec3 PonerNave(vec2 uv, ivec2 pos, vec3 col)\n{   int opc=0;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave(opc);\n    }\n    return col;\n}\n\n\nvec3 HacerHoja1(vec2 uv, ivec2 pos, vec3 col)\n{   int opc=0;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( HOJA1_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColrHoja1(opc);\n    }\n    return col;\n}\n\nvec3 HacerHoja2(vec2 uv, ivec2 pos, vec3 col)\n{   int opc=0;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( HOJA2_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColrHoja2(opc);\n    }\n    return col;\n}\n\n\nfloat rand(vec2 co)\n{ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);}\n\nfloat noise(vec2 co)\n{\n    vec2 p = floor(co);\n    vec2 f = fract(co);\n    float a = rand(p);\n    float b = rand(p + vec2(1.0, 0.0));\n    float c = rand(p + vec2(0.0, 1.0));\n    float d = rand(p + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nvec3 PonerIcono(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {  \n        opc=int(mod(noise(vec2(pix.x,pix.y))*4.0 ,4.0) );\n        if(opc!=0) col=GetColorNave(opc);\n    }\n    return col;\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(0.468, 0.500, 0.500);\n    vec3 c = vec3(0.838, 1.000, 1.000);\n    vec3 d = vec3(-0.422, 0.638, -0.252);\n    return a + b * cos(6.28318*(c*t+d));\n}\n   \n   \nvec3 circulos( in vec2 fragCoord ,vec3 pcol )\n{\n    vec2 uv = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col=pcol;\n    \n    if( uv.y>-0.75) \n    {\n    float t=iTime;\n    float c=iTime*6.0;\n    \n    vec2 pos=vec2(0.5*sin(t),0.5*cos(t));\n    float d0   = length(uv+pos)-0.0015;\n    col+=mix(col, vec3(0.5),d0);\n   \n    float da   = length(uv+pos);\n    float d   = 5. / da;\n    vec3 c1=palette(iTime + d/5.0)*0.5;\n    vec3 c2=palette(iTime + d/2.0)*0.35;\n    \n    col= (col+ c1+c2)/1.0;    \n    col *= abs(sin(4.*d + c));\n    col = mix(col, vec3(0.0),abs(1.0-da*1.15)-0.05);\n    }\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col= circulos(fragCoord,vec3(0.0) );\n    ivec2 pos2=ivec2(3,5);\n    ivec2 pos1=ivec2(3,7);\n    float NES_RES_X=512.0;\n    float NES_RES_Y=288.0;\n    \n    float t=iTime;\n    col=PonerNave(uv*0.5+0.25*vec2(-0.25+0.5*sin(t),0.8+ 0.5*cos(t)), pos1, col);\n    \n    \n    ivec2 pos3=ivec2(0,1);\n    ivec2 pos4=ivec2(0,0);\n    vec2 uvr=uv+vec2(t*0.5,0.0);\n    uvr.x=mod(uvr.x,32.0/NES_RES_X);\n    \n    col=HacerHoja1(uvr,pos3,col);\n    col=HacerHoja2(uvr,pos4,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2052, 2052, 2090, 2090, 2126], [2129, 2129, 2157, 2157, 2444], [2447, 2447, 2475, 2475, 2669], [2671, 2671, 2699, 2699, 2828], [2830, 2830, 2876, 2876, 3143], [3146, 3146, 3193, 3193, 3461], [3463, 3463, 3510, 3510, 3778], [3781, 3781, 3802, 3802, 3870], [3872, 3872, 3894, 3894, 4204], [4207, 4207, 4254, 4254, 4537], [4539, 4539, 4562, 4562, 4767], [4776, 4776, 4823, 4823, 5387], [5392, 5392, 5449, 5496, 6036]], "test": "untested"}
{"id": "Dt3fWN", "name": "Accurate Gold BRDF", "author": "ThePlaneGuy45", "description": "gold ig\n\ni spent way to long making the goldIOR and goldExtinction functions in desmos...\n\nfeel free to use the N/K approximate functions but pls use credit", "tags": ["tonemapping", "fresnel", "wavelength", "gold", "conductor"], "likes": 2, "viewed": 186, "published": 3, "date": "1701367214", "time_retrieved": "2024-07-30T17:19:45.990422", "image_code": "vec3 tonemap(vec3 color) {\n\n    return 1.0-1.0/(color+1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    col.rgb *= EXPOSURE;\n    col.rgb /= col.w;\n    \n    \n    fragColor = vec4(tonemap(col.rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define EXPOSURE 10.0\n\n\n/*\n\nAccurate Gold BRDF © 2023 by ThePlaneGuy45 is licensed under CC BY-SA 4.0 \n\nThe reason I claim this is \"accurate\" is that it uses a correct Fresnel equation\n(not a schlick approximation) and it also is wavelength-based, not RGB-based.\nHowever, this does mean that the standard method of color-specific IOR/extinction\nvalues is not going to work. I spent an hour or two making two Taylor's series to\napproximate the correct IOR/extinction values for a given wavelength. The data I \nused to create these functions can be found here: \nhttps://refractiveindex.info/?shelf=main&book=Au&page=Johnson\nThe data on that website is subsequently from a 1972 research paper:\nP. B. Johnson and R. W. Christy. Optical constants of the noble metals\nand can be found here:\nhttps://journals.aps.org/prb/abstract/10.1103/PhysRevB.6.4370\n\nOTHER CREDITS:\n\nsphere intersection function:\nhttps://iquilezles.org/articles/intersectors/\n\ndielectric-conductor fresnel function:\nhttps://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\n\n*/\n\nfloat goldIOR(float w) {\n    float w2 = w *w;\n    float w3 = w2*w;\n    float w4 = w3*w;\n    return \n        w<0.188?1.28:\n        w<0.5?-77.1267*w4+76.864*w3-39.4179*w2+12.076*w:\n        w<0.7?134.363*w4-426.744*w3+506.806*w2-266.53*w+52.4802:\n        w<1.937?0.46148*w2-0.62019*w+0.38851:\n        0.92;\n}\nfloat goldExtinction(float w) {\n    float w2 = w *w;\n    float w3 = w2*w;\n    float w4 = w3*w;\n    return \n        w<0.188?1.188:\n        w<0.5?283.4*w4-326.327*w3+109.469*w2-4.83043*w:\n        w<0.7?18.3333*w4-36.2*w3+14.7817*w2+16.3835*w-6.6343:\n        w<1.937?-0.25913*w2+8.52819*w-1.82265:\n        13.78;\n}\nvec2 goldNK(float wavelength) {\n    return vec2(goldIOR(wavelength), goldExtinction(wavelength));\n}\n\n/* Special wavelengths:\n * 0.645µm: red   (#FF0000)\n * 0.510µm: green (#00FF00)\n * 0.440µm: blue  (#0000FF)\n */\n \nfloat Fresnel(float etaN, float etaK, float ct) {\n\n    float ct2 = ct*ct;\n    float st2 = 1.0 - ct2;\n    float etaN2 = etaN*etaN;\n    float etaK2 = etaK*etaK;\n    \n    float t0 = etaN2 - etaK2 - st2;\n    float pyt = sqrt(t0*t0+4.0*etaN2*etaK2);\n    float t1 = pyt+ct2;\n    float a = sqrt(0.5*(pyt+t0));\n    float t2 = 2.0 * a * ct;\n    float rs = (t1-t2)/(t1+t2);\n    \n    float t3 = ct2*pyt + st2*st2;\n    float t4 = t2*st2;\n    float rp = rs*(t3-t4)/(t3+t4);\n    \n    return 0.5*(rp+rs);\n\n}\n\nfloat sharpstep(float e0, float e1, float x) {\n    return clamp((x-e0)/(e1-e0),0.0,1.0);\n}\nvec3 rgbFromWavelength(float w) {\n\n    float r0 = w-4.0;\n    r0*=-3.125*r0;\n    r0+=0.5;\n    float r = max(r0, min(\n        sharpstep(5.1, 5.775, w),\n        1.0-sharpstep(7.0, 7.9, w)\n    ));\n    float g = min(\n        sharpstep(4.4, 4.75, w),\n        1.0-sharpstep(5.775, 6.45, w)\n    );\n    float b = min(\n        sharpstep(3.6, 4.0, w),\n        1.0-sharpstep(4.75, 5.1, w)\n    );\n    return vec3(r, g, b);\n}\n \nstruct BRDF {\n\n    vec3 l;\n    vec3 c;\n    \n};\n\nBRDF goldBRDF(vec3 rd, vec3 n, float wavelength) {\n\n    vec3 v = -rd;\n    \n    float cosThetaVN = dot(v, n);\n    \n    vec2 nk = goldNK(wavelength*0.1);\n    \n    float fres = Fresnel(nk.x, nk.y, cosThetaVN);\n    \n    return BRDF(\n    \n        reflect(rd, n),\n        fres * rgbFromWavelength(wavelength)\n    \n    );\n\n}", "buffer_a_code": "// iq\nstruct sph {\n    vec2 i;\n    vec3 n;\n    bool hit;\n};\nsph sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, in float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) {\n        return sph(\n            vec2(0),\n            vec3(0),\n            false\n        );\n    }\n    h = sqrt( h );\n    return sph(\n        vec2(-b-h, -b+h),\n        normalize(ro+(-b-h)*rd-ce),\n        true\n    );\n}\n\nvec3 random(inout uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return vec3(v)*(1.0/float(0xffffffffU));\n}\nvec3 GGX(in vec2 a, in vec3 n, inout uvec3 state) {\n\n    vec2 rn = random(state).xy;\n\n    vec3 vh = normalize(vec3(a.x * n.x, a.y * n.y, n.z));\n    float ls = vh.x*vh.x+vh.y*vh.y;\n    \n    vec3 t0 = ls>0.0 ? vec3(-vh.y,vh.x,0) / sqrt(ls) : vec3(1,0,0);\n    vec3 t1 = cross(vh, t0);\n    \n    float r = sqrt(rn.x);\n    float phi = 6.283185307179586 * rn.y;\n    vec2 tr = sin(phi+vec2(1.570796326794897,0));\n    vec2 t = r*tr;\n    float s = 0.5*(1.0+vh.z);\n    t.y = (1.0-s)*sqrt(1.0-t.x*t.x)+s*t.y;\n    \n    vec3 nh = t.x*t0 + t.y*t1 + sqrt(max(0.0, 1.0 - t.x*t.x - t.y*t.y)) * vh;\n    return normalize(vec3(a.x*nh.x, a.y*nh.y, max(0.0, nh.z)));\n\n}\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    uvec3 state = uvec3(fragCoord, iFrame);\n    fragCoord -= iResolution.xy*0.5;\n    fragCoord /= iResolution.y;\n    vec2 mouse = iMouse.xy - iResolution.xy*0.5;\n    mouse /= iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(fragCoord, 1.0));\n    \n    mat2x2 rot;\n    rot = rot2(-8.0 * mouse.y);\n    ro.yz *= rot;\n    rd.yz *= rot;\n    rot = rot2(-8.0 * mouse.x);\n    ro.xz *= rot;\n    rd.xz *= rot;\n    \n    sph rayCast = sphIntersect(ro, rd, \n        vec3(0, 0, 0),\n        1.0\n    );\n    \n    vec3 color = vec3(0.0);\n    \n    if(rayCast.hit) {\n    \n        vec3 t = normalize(vec3(rayCast.n.z, 0.0, -rayCast.n.x));\n        vec3 b = normalize(cross(rayCast.n, t));\n        \n        vec3 microfacet = GGX(vec2(0.01, 0.01), vec3(0,0,1), state);\n    \n        const float ot = 1.0/3.0;\n    \n        vec3 rand = random(state);\n        \n        vec3 wrgb = vec3(\n        \n            4.000+rand.x*0.750,\n            4.750+rand.y*1.025,\n            5.775+rand.z*1.225\n        \n        );\n        \n        rand = random(state);\n    \n        float wavelength = rand.x<ot?wrgb.x:rand.y<2.0*ot?wrgb.y:wrgb.z;\n    \n        BRDF shader = goldBRDF(rd, worldSpace(microfacet, t,b,rayCast.n), wavelength);\n        \n        color = texture(iChannel0, shader.l).rgb * shader.c;\n    \n    } else {\n    \n        color = texture(iChannel0, rd).rgb;\n    \n    }\n    \n    fragColor += vec4(color, 1.0);\n    \n    if(iFrame==0||iMouse.z>0.0){fragColor = vec4(color, 1.0);}\n    \n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "const float sunBrightness = 3.0;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n\n    #if 0\n\n    float d = dot(rayDir, normalize(vec3(1,1,1)));\n    d = clamp(d, 0.0, 1.0);\n    \n    float sd = pow(d, 100.0);\n    \n    vec3 skyColor = vec3(0.2, 0.3, 0.3);\n    vec3 sunColor = vec3(10.0, 9.5, 9.0);\n    \n    fragColor = vec4(mix(skyColor, sunBrightness*sunColor, sd), 1.0);\n    \n    #elif 0\n    \n    fragColor = texture(iChannel0, rayDir);\n    \n    #else\n    \n    const vec3  sunLightPosition = vec3(1, 1, 1);\n    const float sunFocus = 50.0;\n    const float sunIntensity = 10.0;\n    \n    const vec3 skyColorHorizon = vec3(1.0);\n    const vec3 skyColorZenith  = vec3(0.5, 0.8, 1.0);\n    \n    const vec3 groundColor = vec3(0.5, 0.5, 0.5);\n    \n    \n    float gradT = pow(smoothstep(0.0, 0.4, rayDir.y), 0.35);\n    vec3  grad  = mix(vec3(1.0), vec3(0.5, 0.8, 1.0), gradT);\n    float sun   = pow(max(dot(rayDir, normalize(sunLightPosition)), 0.0), sunFocus) * sunIntensity;\n    \n    float groundT = smoothstep(-0.01, 0.0, rayDir.y);\n    float sunMask = float(groundT >= 1.0);\n    vec3 sky = mix(groundColor, grad, groundT) + sun*sunMask;\n    \n    fragColor = vec4(sky, 1.0);\n    \n    #endif\n    \n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3fWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 62], [64, 64, 121, 121, 289]], "test": "untested"}
{"id": "cltfzB", "name": "Sparks BG (Tabyltop)", "author": "DrieStone", "description": "Took this so I can overlay it over an image/cam", "tags": ["voronoi", "burn", "fire", "particles", "sparks"], "likes": 5, "viewed": 371, "published": 3, "date": "1701365668", "time_retrieved": "2024-07-30T17:19:46.763355", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n#define PI 3.1415927\n#define TWO_PI 6.283185\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.7, -1.0)\n\n#define PARTICLE_SIZE 0.009\n\n#define PARTICLE_SCALE (vec2(0.5, 1.6))\n#define PARTICLE_SCALE_VAR (vec2(0.25, 0.2))\n\n#define PARTICLE_BLOOM_SCALE (vec2(0.5, 0.8))\n#define PARTICLE_BLOOM_SCALE_VAR (vec2(0.3, 0.1))\n\n#define SPARK_COLOR vec3(1.0, 0.4, 0.05) * 1.5\n#define BLOOM_COLOR vec3(1.0, 0.4, 0.05) * 0.8\n#define SMOKE_COLOR vec3(1.0, 0.43, 0.1) * 0.8\n\n#define SIZE_MOD 1.05\n#define ALPHA_MOD 0.9\n#define LAYERS_COUNT 15\n\n\nfloat hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    //vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n \tfloat noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset;\n    for (int i = 0; i < layers; i++)\n    {\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n        \n        //Adding noise with movement\n     \tnoise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    noise *= (1.0 - alphaMod)/(1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n//Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n//Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;   \n}\n\nvec2 randomAround2_2(in vec2 point, in vec2 range, in vec2 uv)\n{\n \treturn point + (hash2_2(uv) - 0.5) * range;\n}\n\n\nvec3 fireParticles(in vec2 uv, in vec2 originalUV)\n{\n    vec3 particles = vec3(0.0);\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    float dist = 2.0;\n    float distBloom = 0.0;\n   \n   \t//UV manipulation for the faster particle movement\n    vec2 tempUV = uv + (noise2_2(uv * 2.0) - 0.5) * 0.1;\n    tempUV += -(noise2_2(uv * 3.0 + iTime) - 0.5) * 0.07;\n\n    //Sparks sdf\n    dist = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_SCALE, PARTICLE_SCALE_VAR, rootUV));\n    \n    //Bloom sdf\n    distBloom = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_BLOOM_SCALE, PARTICLE_BLOOM_SCALE_VAR, rootUV));\n\n    //Add sparks\n    particles += (1.0 - smoothstep(PARTICLE_SIZE * 0.6, PARTICLE_SIZE * 3.0, dist)) * SPARK_COLOR;\n    \n    //Add bloom\n    particles += pow((1.0 - smoothstep(0.0, PARTICLE_SIZE * 6.0, distBloom)) * 1.0, 3.0) * BLOOM_COLOR;\n\n    //Upper disappear curve randomization\n    float border = (hash1_2(rootUV) - 0.5) * 2.0;\n \tfloat disappear = 1.0 - smoothstep(border, border + 0.5, originalUV.y);\n\t\n    //Lower appear curve randomization\n    border = (hash1_2(rootUV + 0.214) - 1.8) * 0.7;\n    float appear = smoothstep(border, border + 0.4, originalUV.y);\n    \n    return particles * disappear * appear;\n}\n\n\n//Layering particles to imitate 3D view\nvec3 layeredParticles(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float smoke) \n{ \n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 offset = vec2(0.0);\n    vec2 noiseOffset;\n    vec2 bokehUV;\n    \n    for (int i = 0; i < layers; i++)\n    {\n        //Particle noise movement\n        noiseOffset = (noise2_2(uv * size * 2.0 + 0.5) - 0.5) * 0.15;\n        \n        //UV with applied movement\n        bokehUV = (uv * size + iTime * MOVEMENT_DIRECTION * MOVEMENT_SPEED) + offset + noiseOffset; \n        \n        //Adding particles\t\t\t\t\t\t\t\tif there is more smoke, remove smaller particles\n\t\tparticles += fireParticles(bokehUV, uv) * alpha * (1.0 - smoothstep(0.0, 1.0, smoke) * (float(i) / float(layers)));\n        \n        //Moving uv origin to avoid generating the same particles\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n        \n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    // Calculate vignette\n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n    uv *= 1.8;\n    \n    // Calculate smoke and particle layers\n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0); \n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n    smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n    vec3 particles = layeredParticles(uv, SIZE_MOD, ALPHA_MOD, LAYERS_COUNT, smokeIntensity);\n    \n    // Fire effect color\n    vec3 fireEffectColor = particles + smoke + SMOKE_COLOR * 0.02;\n    fireEffectColor *= vignette;\n    fireEffectColor = smoothstep(-0.08, 1.0, fireEffectColor);\n\n    // Get webcam input\n    vec4 webcamColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Blend the webcam image and the fire effect\n    vec3 finalColor = mix(webcamColor.rgb, fireEffectColor, clamp(length(fireEffectColor), 0.0, 1.0));\n\n    fragColor = vec4(finalColor, 1.0);}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltfzB.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[631, 631, 657, 657, 724], [726, 726, 751, 751, 830], [832, 860, 884, 910, 1327], [1329, 1357, 1385, 1385, 1840], [1843, 1843, 1950, 1950, 2443], [2445, 2472, 2514, 2514, 2602], [2604, 2641, 2696, 2696, 2874], [2876, 2914, 2947, 2947, 3014], [3016, 3016, 3080, 3080, 3128], [3131, 3131, 3183, 3183, 4459], [5485, 5485, 5542, 5578, 6777]], "test": "untested"}
{"id": "dttfD8", "name": "infinite balls", "author": "aerowave", "description": "raymarcher base: https://www.shadertoy.com/view/4dSBz3\n\nalso if anyone understands why my attempt to improve performance (lines 42-46 of Buffer A), please leave a comment!", "tags": ["raymarching"], "likes": 2, "viewed": 174, "published": 3, "date": "1701364921", "time_retrieved": "2024-07-30T17:19:47.695863", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define CRT 1\n\n// Super simple raymarching example. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/4dSBz3\n//\n// This is the shader used as example in my ray march tutorial: https://www.shadertoy.com/view/4dSfRc\n//\n// Created for the Shadertoy Competition 2017 \n//\n\n//\n// Distance field function for the scene. It combines\n// the seperate distance field functions of three spheres\n// and a plane using the min-operator.\n//\nfloat sceneSDF(vec3 p) {\n    return length(mod(p + 1.5, 3.) - 1.5) - 0.4;\n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(\n        e.xyy * sceneSDF(p + e.xyy) +\n        e.yyx * sceneSDF(p + e.yyx) +\n        e.yxy * sceneSDF(p + e.yxy) +\n        e.xxx * sceneSDF(p + e.xxx));\n}\n\nint CRT_ = CRT + 1;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    int MAX_STEPS = 4096;\n\n    // does this even work as an optimization? i thought reducing\n    if (CRT_ > 0 && int(fragCoord.y * float(CRT_) + fragCoord.x) % (CRT_ * CRT_) != iFrame % (CRT_ * CRT_)) {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy) - (1.0 / float(CRT_ * CRT_));\n        return;\n    }\n\n    // start of raymarcher code\n    vec3 cameraPos = vec3(1.5, 1.5, 0) + vec3(3.0 * iMouse.xy/iResolution.xy, -iTime * 2.0);\n    vec3 ro = vec3(0, 0, 1);                           // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n\n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        h = sceneSDF(ro + rd * t + cameraPos);\n        t += h;\n        // hit distance gets bigger the farther away the ray is from the camera\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t + cameraPos;\n        vec3 normal = calcNormal(p);\n\n        fragColor = vec4(normal + vec3(0.5, 0.5, 0.5), 1);\n    } else {\n        fragColor = vec4(0,0,0,1);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 147]], "test": "untested"}
{"id": "ctdBzB", "name": "Colorful-tunnel", "author": "mokasiri", "description": "colorful-tunnel", "tags": ["tunnel"], "likes": 3, "viewed": 145, "published": 3, "date": "1701364310", "time_retrieved": "2024-07-30T17:19:48.586482", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.600,0.827,1.000);\n    vec3 b = vec3(0.502,1.000,1.000);\n    vec3 c = vec3(0.200,0.800,1.000);\n    vec3 d = vec3(-0.422, 0.638, -0.252);\n    return a + b * cos(6.28318*(c*t+d));\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    float d;\n    float t=iTime;\n    float c=iTime*6.0;\n    \n    vec2 pos=vec2(0.5*sin(t),0.5*cos(t));\n    d   = length(uv+pos)-0.15;\n   \n    d   = length(uv+pos);\n    d   = 5. / d;\n    col = palette(iTime + d/5.);\n    \n    col *= abs(sin(10.*d + c));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 222], [228, 228, 285, 285, 668]], "test": "untested"}
{"id": "dlcBzB", "name": "Looped Square", "author": "cmzw", "description": "Looped square / command key", "tags": ["2d", "distancefield", "sdf"], "likes": 13, "viewed": 268, "published": 3, "date": "1701357761", "time_retrieved": "2024-07-30T17:19:49.532950", "image_code": "// https://www.shadertoy.com/user/timestamp\nfloat sdLoopedSquare(vec2 p)\n{\n    p = abs(p) - .5;\n    vec2 q = abs(p + .25);\n    return max(p.x,p.y) > 0.\n        ? abs(length(p) - .25)\n        : min(q.x, q.y);    \n}\n\n/*\nfloat sdLoopedSquare(vec2 p)\n{\n    p *= 2.0;\n    p = abs(p)-1.0;\n    vec2 b = (p + vec2(p.y, -p.x))*sqrt(0.5);\n    vec2 c = abs(p + 0.5);\n    float d = max(p.x,p.y) * 10.0;\n    float e = length(vec2(abs(length(p)-.5),\n        step(0.38, abs(atan(b.y,b.x)*0.1591))));\n    \n    return min(max(min(c.x,c.y),d),e)*.5;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 c;\n\n    float d = sdLoopedSquare(p) - cos(iTime*.8)*.05 -.05;\n        \n    // iq coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-25.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 74, 74, 213], [537, 537, 594, 594, 989]], "test": "untested"}
{"id": "dlcBRB", "name": "Fluid Chroma", "author": "fingertwister", "description": "Test of fluid implementation using Chroma 3000 shader. \n\nToggle brushes by pressing key 1-9 on the keyboard, then press LMB and drag to add color and interact with the fluid. \n", "tags": ["fluid", "dev"], "likes": 1, "viewed": 135, "published": 3, "date": "1701357337", "time_retrieved": "2024-07-30T17:19:50.756679", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// grid (velocity, density)\n\n#define dt 0.15\n#define K 0.03\n#define VS 0.4\n#define PI 3.14159265357989\n\nvec2 penForce(float time, float fq, float dist, float radius) {\n    float magnitude =  0.001 * abs(dist / radius);\n    return magnitude * vec2(cos(fq * time * PI * 2.), sin(fq * time * PI * 2.));\n}\n\nvec2 getMouseDelta(vec2 pos) {\n    vec2 oldMouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 0), 0).w,\n        texelFetch(iChannel0, ivec2(1, 0), 0).w);\n    if (oldMouse.x > 0.) {\n        vec2 diff = (pos - 0.5) - (oldMouse - 0.5);\n        return -diff;\n    }\n    return vec2(0.);\n}\n\nfloat simple_rnd(vec3 coords) {\n    return fract(sin(74.2134 * dot(coords, vec3(72.3451, 135.98312, 23.22))) * 3452.1393);\n}\n\n\n// ----------------------------------------------------------------\n// Simplex noise code generated at: https://stegu.github.io/webgl-noise/webdemo/periodic.html\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// ----------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float S = K / dt;\n    vec2 step = vec2(1.0) / iResolution.xy;\n    vec2 extForce = vec2(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy;\n    vec2 nMousePos = mouse.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    \n    if (iFrame < 10) {\n        fragColor = vec4(\n            0.001 * snoise(0.00125 * fragCoord.xy), \n            0.001 * snoise(0.00125 * fragCoord.yx), 1.0, 0.0);\n        return;\n    }\n    // external force\n    if (iMouse.z > 0.) {\n        vec2 mDelta = getMouseDelta(nMousePos);\n        float dist = circleSdf(uv, nMousePos, PEN_FORCE_RADIUS, ar);\n        if (dist < 0.) {\n            float p = -1.0 * dist / PEN_FORCE_RADIUS;\n            extForce = mix(0., 0.3, p) * mDelta; //penForce(iTime, 1.0, dist, PEN_FORCE_RADIUS);\n        }\n    }\n    \n    //extForce = vec2(sin(iTime)) * 0.0001 * (texture(iChannel1, uv) - 0.5).xy;\n    \n    vec4 left = texture(iChannel0, uv + vec2(step.x, .0));\n    vec4 right = texture(iChannel0, uv - vec2(step.x, 0.));\n    vec4 top = texture(iChannel0, uv - vec2(0., step.y));\n    vec4 bottom = texture(iChannel0, uv + vec2(0., step.y));\n    \n    vec4 center = texelFetch(iChannel0, ivec2(fragCoord), 0);    \n    \n    // density\n    float divX = 0.5 * (left.x - right.x);\n    float divY = 0.5 * (top.y - bottom.y);\n    float divU = divX + divY;\n    vec2 divD = vec2(left.z - right.z, top.z - bottom.z) * vec2(0.5);\n    float nextDensity = center.z - dt * dot(vec3(divD, divU), center.xyz);\n    nextDensity = clamp(nextDensity, 0.5, 3.0);\n    center.z = nextDensity;\n    \n    // u - velocity\n    vec2 lapl = (left.xy + right.xy + top.xy + bottom.xy) - center.xy * 4.0;\n    vec2 viscF = VS * lapl;\n    \n    // advection\n    \n    vec2 uvAdv = uv - dt * center.xy * step;\n    center.xy = texture(iChannel0, uvAdv).xy;\n    center.xy += dt * viscF;\n    center.xy -= S * divD;\n    center.xy += dt * extForce;\n    center.xy *= 0.9995;\n    \n    if (((uv.x + step.x) > 1.0) || ((uv.x - step.x) < 0.0)) {\n        center.x = 0.;\n    } \n    if (((uv.y + step.y) > 1.0) || ((uv.y - step.y) < 0.0)) {\n        center.y = 0.;\n    }\n    \n    fragColor = center;\n    if (fragCoord.y < 1.) {\n        if (fragCoord.x < 1.) {\n            if (iMouse.z > 0.) {\n                fragColor.w = nMousePos.x;\n            } else {\n                fragColor.w = 0.0;\n            }\n        } else if (fragCoord.x >= 1. && fragCoord.x < 2.) {\n            if (iMouse.z > 0.) {\n                fragColor.w = nMousePos.y;\n            } else {\n                fragColor.w = 0.0;\n            }\n        }\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvec4 shaderColors[NUM_BRUSHES] = vec4[NUM_BRUSHES](\n    vec4(0.65, 0.94, 0.94, 0.3),\n    vec4(0.95, 0.38, 0.38, 0.3),\n    vec4(0.13, 0.58, 0.58, 0.3),\n    vec4(0.95, 0.48, 0.49, 0.3),\n    vec4(0.92, 0.96, 0.96, 0.3),\n    vec4(0.06, 0.99, 0.99, 0.3),\n    vec4(0.74, 1.00, 1.0, 0.3),\n    vec4(0.54, 0.89, 0.87, 0.3),\n    vec4(1.00, 0.19, 0.19, 0.3)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float rMix = (0.5 + 0.5 * sin(iTime));\n    vec4 col = vec4(1.);\n    float ar = iResolution.x / iResolution.y;\n    if (iFrame < 10) {\n        float hdist = mod(fragCoord.x, 40.0);\n        float vdist = mod(fragCoord.y, 40.0);\n        int hcol = int(floor(fragCoord.x / 40.0)) % NUM_BRUSHES;\n        int vcol = int(floor(fragCoord.y / 40.0)) % NUM_BRUSHES;\n        col = hdist < 4. ? shaderColors[hcol] : vec4(0.);\n        //col += vdist < 2. ? shaderColors[vcol] : vec4(0.);\n        \n    } else {\n        vec2 u = texelFetch(iChannel2, ivec2(fragCoord), 0).xy;\n        col = texture(iChannel1, uv + u);\n        vec4 addedColor = vec4(0.);\n        float numActive = 0.;\n        for (int i=0; i < NUM_BRUSHES; i++) {\n            vec4 mouse = texelFetch(iChannel3, indexToCoord(i, iResolution), 0);    \n            //float dynR = 0.25 * length(iMouse.xy - mouse.xy) / iResolution.x;\n            float dynR = mix(PEN_INK_RADIUS * 2., PEN_INK_RADIUS * 6., sin(iTime * 0.5) * 0.5 + 0.5);\n            if (mouse.xy != vec2(0.)) {      \n                float dist = circleSdf(uv, mouse.xy / iResolution.xy, mix(dynR, dynR * 1., rMix), ar);\n                if (dist < 0.) {\n                    vec4 inkColor = shaderColors[i];\n                    vec4 b = reflect(addedColor, inkColor);\n                    float p = smoothstep(0., 1.0, -1. * dist / dynR);\n                    vec4 a = mix(b, vec4(inkColor.xyz, 1.0), p);\n                    addedColor += mix(b, a, sin(iTime * 0.5) * 0.5 + 0.5);\n                    numActive += 1.;\n                }\n            }\n        }\n        if (numActive > 0.) {\n            addedColor = addedColor / numActive;\n        }\n        float overflow = dot(col, vec4(1.0));\n        if (overflow > 4.0) {;\n            col = addedColor * 0.5;\n        } else {\n            col = (col + addedColor);\n        }\n    }\n    col *= 0.995;\n    fragColor = clamp(col, vec4(0.), vec4(1.));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// NOTE: This shader is intended to be used at the Chroma creator tool app. \n// If you want to explore music expressions with your shaders, you just have to try it. \n// \n// See the Chroma template shader for more details: https://www.shadertoy.com/view/ctGcWG\n// \n// Added fluid dynamics with multiple brush support (turn on and off brushes with key 1-9). \n// The brush and mouse management are adapted from the Chroma template shader. \n// This is just a starting point. A lot more can be done. \n\n#define PEN_FORCE_RADIUS 0.2\n#define PEN_INK_RADIUS 0.01\n\n#define NUM_BRUSHES 9\n\n/**\n * Lookup function for texture data buffers.\n *\n * Maps 2D fragment coordinates to its corresponding 1d buffer position (index = y * width + x)\n *\n * Discussion: \n * Note that using textures as data storage on shadertoy will be dependent on the canvas size \n * since the buffers allocated will follow those dimensions. \n * \n * Since we have a super small buffer, we could probably get away with using the x-value for index \n * (and hard code y to 0). We would save a few cpu cycles this way. \n * But we do it properly just in case to avoid strange errors if the shader is modified.\n *\n */\n\nint fragToIndex(in vec2 fragCoord, in vec3 iResolution) {\n    ivec2 icoord = ivec2(fragCoord);\n    ivec2 ires = ivec2(iResolution);\n    int fragIndex = icoord.y * ires.x + icoord.x;\n    return fragIndex;\n}\n\n/**\n * Reverse lookup function for texture data buffers. \n *\n * Maps a 1d buffer position to its corresponding 2D fragment coordinates\n */\n\nivec2 indexToCoord(in int index, in vec3 iResolution) {\n    int h = int(iResolution.y);\n    int y = index / h;\n    int x = index - (y * h);\n    return ivec2(x, y);\n}\n\nfloat circleSdf(vec2 uv, vec2 pt, float radius, float ar) {\n    return length(vec2(ar, 1.0) * (uv - pt)) - radius;\n}", "buffer_c_code": "/**\n * KEYBOARD\n *\n * Implement a mouse state memory for each brush controlled by the keyboard. \n *\n * Use the following rules:\n * - Initialise the buffer to zero\n * - Each brush is mapped to a numeric key. \n * - A key can be toggled or not toggled (like Caps Lock)\n * - If a key is toggled then the mouse xyzw position will be tracked for that brush\n * - If a key is not toggled then we keep the last mouse position (.xy) and zero the rest (.zw)\n * \n * Ultimately a buffer with mouse coordinates for each brush index will be produced\n * At brush index a vec4 is stored with the following properties:\n * - xy - The mouse screen position\n * - zw - The mouse start posistion (iMouse.zw) if toggled, otherwise vec2(0.) \n */\n\n#define keyToggle(ascii) ( texelFetch(iChannel3, ivec2((ascii),2),0).x > 0.)\n\n#define ASCII_NUM_1 49\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    if (iFrame < 10) {\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    int fragIndex = fragToIndex(fragCoord, iResolution);\n    for (int i = 0; i < NUM_BRUSHES; i++) {\n        int key = ASCII_NUM_1 + i;\n        if (fragIndex == i) {\n            if (keyToggle(key)) {\n                fragColor = iMouse;\n            } else {\n                fragColor.zw = vec2(0.);\n            }\n        }\n    }   \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/**\n * BRUSH TRANSITION\n *\n * Implement a brush transition memory that eases the current mouse positions to its corresponding target \n *\n * Use the following rules:\n * - Initialise the buffer to zero\n * - Use the similar indexing system as in Buffer A (keyboard)\n * - Buffer A contains the target values\n * - Buffer B contains the intermediate values\n * - For valid brush indices, store a new intermediate value by mixing the target value with the intermediate value\n * - For empty values, skip mixing and just output zero\n */\n \n#define MOTION_EASING_FACTOR 0.15\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int fragIndex = fragToIndex(fragCoord, iResolution);\n    fragColor = vec4(0.);\n    if (fragIndex < NUM_BRUSHES) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        if (fragColor.z >= 0.) {\n            vec4 colB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n            fragColor.xy = mix(colB.xy, fragColor.xy, MOTION_EASING_FACTOR);\n        }\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 121]], "test": "untested"}
{"id": "DtdBRS", "name": "Shader_user_video_Learn", "author": "Gerych", "description": "shaderuservideo_learn", "tags": ["shaderuservideolearn"], "likes": 0, "viewed": 126, "published": 3, "date": "1701356850", "time_retrieved": "2024-07-30T17:19:51.519639", "image_code": "vec3 convertToBlackAndWhite(vec4 texColor)\n{\n   \n     if (texColor.r >= 0.5 && texColor.g >= 0.5 && texColor.b >= 0.5)\n      {\n          return vec3(1.0, 1.0, 1.0);\n      }\n      else\n      {\n         return vec3(0.0, 0.0, 0.0);\n      }\n}\n\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\n    vec4 texColor = texture(iChannel0, xy);\n    \n \n    vec3 result = convertToBlackAndWhite(texColor);\n    \n\n  \n\n    fragColor = vec4( result.rgb ,1.0);\n\n\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 238], [241, 241, 296, 296, 499]], "test": "untested"}
{"id": "dtcBRB", "name": "nimitz's fast gyroid fBm", "author": "FabriceNeyret2", "description": "nimitz's fast gyroid fBm, as an alternative to Perlin noise ( I'm not really sure it is faster or easier to control ).\nBasically, replaces Perlin noise base function with gyroid + cumulated domain distortion (top).\nTurbulence: right: abs   left: 1-abs", "tags": ["noise", "perlinnoise", "gyroid"], "likes": 28, "viewed": 335, "published": 3, "date": "1701351018", "time_retrieved": "2024-07-30T17:19:52.346428", "image_code": "// fast gyroid fBm from nimitz's Protean clouds: https://www.shadertoy.com/view/3l23Rh\n// ( extracted from \"Volumetric Fire\" by myth0genesis. https://shadertoy.com/view/NttBWj )\n\nbool disto;\n\nmat3 m3 = mat3( .3338,  .56034, -.71817,\n               -.87887, .32651, -.15323,\n                .15162, .69596,  .61339) * 1.93;\n\nfloat gyroidFBM3D(vec3 p) { // adapted from nimitz's fast gyroid fBm\n                            // replaces Perlin noise base function with gyroid + cumulated domain distortion\n    float d, z = 1., trk = 1.5;\n  \n    for(int i; i < 5; i++, z *= .7, trk *= 1.4, p *= m3  ) // --- fractal loop, like Perlin noise\n        disto ? p += sin( p.yzx * trk ) * .1 : p,          // scale p ~ 2^i , + *.1 distortion at scale 1.4^i\n        d += abs( dot(cos(p), sin(p.zxy)) ) * z ;          // abs(gyroïd) / 1.43^i , instead of base Perlin noise function\n                                                           // abs() = Perlin turbulence. try without.\n    return d/3.;                                           // 3 = max of dot(cos,sin)\n}\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;                            // normalized coordinates\n    \n    disto = U.y>0.;                                        // applies nimitz noise distortion only on top\n    float n = gyroidFBM3D( vec3( 2.*U, .1*iTime ) );\n\n    O = pow( vec4(max(n,0.)) , vec4(1.1,1,.9,1) );         // right: abs() cloud-like turbulence\n    if ( U.x < 0. ) O = 1.-O;                              // left: 1-abs() fire-like turbulence\n // O = abs(O);\n // O /= fwidth(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 351, 501, 1058], [1060, 1060, 1098, 1098, 1609]], "test": "untested"}
{"id": "DtcBRS", "name": "Cosmic Aurora", "author": "space928", "description": "I was fiddling with the parameters of my latest and found it makes nice-ish auroras.", "tags": ["2d", "abstract", "bloom", "green"], "likes": 11, "viewed": 424, "published": 3, "date": "1701330339", "time_retrieved": "2024-07-30T17:19:53.277937", "image_code": "// An abstract shader by Thomas M.\n// The bulk of the shader is in Buffer A so that temporal accumulation can be done.\n// This pass does the post processing (bloom, vignette, and dither)\n\n// Reduces blinear interpolation artifacts, and I think it looks nice\nconst float bloomNoise = 0.1;\n// Set to 1. if you want animated noise.\nconst float animateDither = 0.;\n\n#define rnd_off(o) (((hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)))*2.-1.)+(hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)+0.5798765))*2.-1.0))/iResolution.xy*pow(2.,o)*bloomNoise)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    // Bloom based on mipmaps\n    vec3 bloom = vec3(0.);\n    bloom += textureLod(iChannel0, uv+rnd_off(1.), 1.).rgb*0.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(2.), 2.).rgb*0.75;\n    bloom += textureLod(iChannel0, uv+rnd_off(3.), 3.).rgb*1.0;\n    bloom += textureLod(iChannel0, uv+rnd_off(4.), 4.).rgb*1.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(5.), 5.).rgb*2.;\n    bloom += textureLod(iChannel0, uv+rnd_off(6.), 6.).rgb*2.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(7.), 7.).rgb*3.0;\n    col += tanh(pow(bloom*0.5, vec3(2.)))*0.25;\n    \n    // Vignette inspired by: https://www.shadertoy.com/view/lsKSWR\n    vec2 u = uv*(1.-uv.yx);\n    float vignette = tanh(u.x*u.y*25.+0.05)*1.2;\n    col = pow(vignette*pow(col, vec3(2.)), vec3(1./2.));\n    \n    // Dither at the end\n    float dither = (hash12(fragCoord+fract(iTime*animateDither*0.733)) + hash12(fragCoord + 0.59374+fract(iTime*animateDither*0.733)) - 0.5)/255.;\n    col += dither;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float dist = 200.; // Maximum blur distance\nconst vec2 dir = vec2(0.2, -1.); // Direction to blur in\nconst float gamma = 0.2; // Gamma to apply while blurring. (accentuates the highlights)\nconst float thresh = 0.6; // Highlight threshold (used as the stopping point for the blur)\nconst vec3 jitter = vec3(0.1, 0.0, 0.3); // Amount of jitter applied to the motion blur in x and y; the z component jitters the threshold\nconst vec3 loss = vec3(0.004, 0.004, 0.001); // Subtract a bit from each iteration of the blur to darken trails\nconst float frameBlending = 100.; // Set this really long for nothern-lights-esque graphics\nconst float speed = 0.01; // How fast the secondary texture scrolls\n\nvec3 colMap(vec3 col)\n{\n    float lum = dot(col, vec3(0.3, 0.6, 0.1));\n    const vec3 dark = vec3(0.03, 0.001, 0.06);\n    const vec3 mid2 = vec3(0.15, 0.45, 0.35);\n    const vec3 mid1 = vec3(0.45, 0.15, 0.35);\n    const vec3 light2 = vec3(0.3, 1.0, 0.55);\n    const vec3 light1 = vec3(1.0, 0.3, 0.55);\n    float t = sin((col.r/col.b)*5.+iTime*speed*10.)*0.5+0.5;\n    vec3 mid = mix(mid1, mid2, t);\n    vec3 light = mix(light1, light2, t);\n    return (mix(dark, mix(mid, light, clamp(lum*3.-1., 0., 1.)), clamp(lum*3., 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Vertical blur of the image\n    vec3 col = pow(texture(iChannel0, uv).rgb, vec3(gamma));\n    float sum = 1.;\n    for(float i = 0.; i < dist; i += 1.)\n    {\n        vec2 rnd = (hash23(vec3(uv+iTime*vec2(3., 1.67), i+fract(iTime)))*2.-1.)*jitter.xy;\n        vec2 suv = uv + (dir+rnd) * i / iResolution.xy;\n        vec3 samp = pow(texture(iChannel0, suv).rgb, vec3(gamma));\n        vec3 sampb = pow(texture(iChannel1, suv-dir*iTime*speed).rgb, vec3(gamma)).rgb;\n        samp = (samp+sampb)/2.;\n        // Stop when we reach a highlight, this gives the highlights nice long trails\n        if(dot(samp, vec3(0.3, 0.6, 0.1)) > pow(thresh+jitter.z*rnd.x, gamma))\n            break;\n        col += samp * (1.-loss * i)*0.95;\n        sum += 1.;\n    }\n    col /= sum;\n    // We blur with gamma to accentuate the highlights, we  undo the gamma here\n    col = pow(col, vec3(1./gamma));\n    \n    // Pretty colours\n    col = colMap(col);\n    \n    // Temporal accumulation\n    vec4 prev = texture(iChannel3, fragCoord/iResolution.xy);\n    vec2 prevRes = texelFetch(iChannel3, ivec2(0), 0).xy;\n    if(abs(dot(prevRes - 1./iResolution.xy, vec2(1.))) < 0.0005)\n    {\n        //float dither = (hash12(fragCoord) + hash12(fragCoord + 0.59374) - 0.5)/255.;\n        col = mix(prev.xyz, col, 1./frameBlending);\n    }\n    if (fragCoord-0.5 == vec2(0.0))\n        col = vec3(1./iResolution.xy, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash functions taken from:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 583, 640, 690, 1795]], "test": "untested"}
{"id": "ct3BRS", "name": "提出課題", "author": "tadatakaki", "description": "授業で使ったものに背景を変え円に目が行くように工夫しました。", "tags": ["kadai"], "likes": 1, "viewed": 144, "published": 3, "date": "1701330117", "time_retrieved": "2024-07-30T17:19:54.108716", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    uv -= vec2(0.5, 0.5) * iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5+0.5*cos(iTime+uv . xyx + vec3(1, 1, 1));\n\n    float r = 100.0;\n    if(uv.x * uv.x + uv.y * uv.y <r * r){\n        float z = sqrt(r * r - uv.x*uv.x -uv.y * uv.y);\n        vec3 normal = normalize(vec3(uv.x, uv.y, z));\n        col  = normal * 0.5 + 0.5;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3BRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 561]], "test": "untested"}
{"id": "mttBD7", "name": "Exponential Mapping for Rotation", "author": "toomuchvoltage", "description": "A live demonstration of the usefulness of exponential mapping for mixing rotations.\nA full explanation is given here: https://thenumb.at/Exponential-Rotations/", "tags": ["mapping", "rotation", "exponential", "matrices", "quaternions"], "likes": 2, "viewed": 252, "published": 3, "date": "1701327200", "time_retrieved": "2024-07-30T17:19:55.163895", "image_code": "/***********************************************************\n\n   A re-work of https://www.shadertoy.com/view/dlBGRc to demonstrate the usefulness\n   of exponential mapping for interpolating rotations.\n   Full explanation found here: https://thenumb.at/Exponential-Rotations/\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n//#define HIRES\n\nbool rayBoxIntersectTime (vec3 l1,vec3 invm,vec3 bmin,vec3 bmax, out float tMin, out float tMax)\n{\n\tvec3 bmin_l1 = (bmin - l1)*invm;\n\tvec3 bmax_l1 = (bmax - l1)*invm;\n\tvec3 minVec = min (bmin_l1, bmax_l1);\n\tvec3 maxVec = max (bmin_l1, bmax_l1);\n\n\tfloat tmin = max(max(minVec.x, minVec.y), minVec.z);\n\tfloat tmax = min(min(maxVec.x, maxVec.y), maxVec.z);\n\n\tbool retVal = ((tmax >= tmin) && (tmin < 1.0) && (tmax > 0.0));\n\ttMin = tmin;\n\ttMax = tmax;\n\treturn retVal;\n}\n\nuint countSetBits(uint n)\n{\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nuint countSetBitsBefore(uint n, uint comp)\n{\n    uint beforeMask = comp ^ (comp - 1u); // See: https://realtimecollisiondetection.net/blog/?p=78\n    n &= (~beforeMask);\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\n#ifdef HIRES\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[480] = uint[](128u,2210513095u,3479298144u,1206382640u,2955944416u,2948644703u,3759157328u,4287565583u,3759675512u,2139587772u,802340674u,3188982804u,141045714u,2138838076u,868254667u,3286638110u,504914401u,2400088239u,4111435140u,25231882u,717225475u,1058011896u,3229678206u,2130212960u,2131742716u,1009857343u,2275802654u,3097205408u,547535824u,2192417534u,3288236371u,3896412222u,505289727u,4279177016u,4043288476u,2021159043u,2386045908u,708321408u,3052425285u,4261731647u,2600436334u,1905893279u,4231802947u,3476757529u,3877378112u,1105215936u,34434u,4289098691u,3288284978u,4058111969u,1368453360u,4030781552u,2018533408u,540094515u,863606808u,301587464u,2349928471u,3958414079u,1086318151u,2701128451u,61471098u,2156002367u,62979548u,3180696977u,2123695444u,358083563u,1106362448u,272611232u,1587628053u,2095138053u,3746421117u,802705685u,17108991u,944109840u,2236852288u,1090600768u,3208819995u,1789041304u,2577271807u,4244787370u,4078985120u,265989392u,626174633u,277056386u,2952430954u,532654112u,573780048u,4286382072u,404256888u,2308730983u,4027342703u,3436158974u,2146558435u,2551187007u,867382067u,865704345u,2576993484u,3704409341u,3258775938u,3176781832u,2297956543u,3808397308u,71073779u,4062383231u,4001299939u,3858923261u,4294504910u,2281914348u,3370546118u,1063543298u,537132546u,4261943487u,4271477196u,4224646856u,3292938240u,272650234u,4016187103u,4133678343u,4080218316u,3476239359u,3120287513u,2441110503u,4294757583u,4090285104u,553641598u,4193511022u,2294243840u,2818752010u,1848374463u,3254062863u,2127319104u,2682678906u,2545967183u,3435708155u,4231000385u,432095607u,285339157u,284091511u,1148523596u,1145953754u,626850341u,3632174440u,359142741u,1118551722u,2863275440u,1521198420u,1252047863u,717509418u,3288667447u,1947428677u,3120952896u,1094996991u,1600391359u,1428034056u,16427093u,542637738u,1119939523u,3764511729u,4050662903u,4002366143u,130351256u,410541068u,1010581182u,515774602u,737923627u,3004883152u,1509530008u,2144597893u,4231843327u,3263414787u,1106579704u,410548344u,2084322364u,809377310u,403708943u,235416312u,1731735602u,3482858001u,3677724u,166411u,4256956382u,4232957900u,3451073271u,1986419065u,4052775731u,858829601u,2441190596u,1288490207u,4268161167u,1449650319u,1009265720u,1162105604u,4116665695u,4114841579u,3926179344u,2856591392u,4126637728u,938539692u,67170282u,357892821u,39127072u,1874417153u,2105410472u,717184855u,1470217045u,1428347733u,571195218u,3158670264u,1079326545u,1072002912u,1604612128u,680036493u,3712343713u,1440621329u,286263846u,1713861618u,4144182067u,4169136513u,2174327168u,4026721826u,601629663u,4084412932u,4208664577u,85018111u,2945462233u,4110471175u,4286675613u,3793592382u,2151743801u,2155977084u,4169173120u,717083454u,3154037963u,3003960254u,1637456281u,2670775436u,3436157319u,3060164556u,4088607539u,3996247560u,434274295u,717079091u,1787128459u,4164421880u,257162247u,3278619619u,3275833600u,1052572127u,3781082648u,2693315316u,341137392u,804388289u,3519082624u,262318170u,99517628u,787753794u,2906981461u,83750360u,653103197u,2554865794u,2750130721u,3876522510u,4117868073u,2155911579u,2880295434u,2916137919u,2831494024u,3577881349u,871633902u,1738041274u,1731343139u,848857241u,2564676733u,3808693497u,2974916321u,7540787u,858995097u,2417596816u,2155881986u,645005824u,359751649u,823902198u,1639497159u,4292310531u,2818932589u,830078335u,4294246389u,2635153856u,44739310u,552586956u,3186548104u,3860437401u,2582842572u,3436181894u,1718085244u,3274912563u,1047109219u,3059754667u,2113579688u,4146775159u,684012417u,3185398955u,1420475220u,1414874165u,1363219957u,1079339767u,2102744389u,1413815632u,366826968u,357914485u,1467193481u,2592717738u,2732401341u,179015024u,2411672478u,568205431u,1362022673u,785458779u,1717003460u,1103939548u,3809811491u,1440483938u,1646683955u,926936271u,2579996262u,1741474824u,4002152450u,570564978u,863502128u,3493413888u,2855251616u,2050484286u,536879654u,1648291565u,3366878410u,2925648319u,3882300403u,858915737u,2583200137u,3426431964u,4243502958u,2724621994u,3903335624u,2343400104u,1463636000u,2157835338u,2847797764u,1512267499u,1587762346u,335902077u,1410509800u,3755666049u,706029661u,2170508670u,33166762u,948444056u,2595470683u,3041042603u,2297890824u,4151451042u,998733074u,3977315069u,306673526u,1145324621u,4248974685u,3405070562u,40265331u,785182542u,4186334822u,1727842172u,3471343616u,499u,1357113102u,284424167u,3884189752u,4056380211u,590590777u,2156501401u,2631716047u,993058526u,2107101574u,3707808442u,4203227235u,3812451259u,3256942850u,2677709668u,163029666u,4196412085u,4155116048u,2868572290u,2947481239u,3356977160u,747284398u,2726734856u,2864641032u,547417086u,2776108975u,2852240829u,1153389611u,3716223248u,270268584u,2943355891u,4228260522u,5584208u,272098427u,2272765032u,462565435u,3287848969u,4194171908u,1308099677u,4087566845u,290458114u,118698865u,59898265u,2172700672u,11u,2290648947u,3208630076u,3234740275u,2678056550u,1712855483u,860142112u,3450012993u,1138225127u,337383764u,3791279575u,3244245119u,3059112932u,67235856u,2941298647u,2231728215u,4161258114u,3286278176u,2431680288u,4289712893u,41780485u,8213547u,3492795408u,635461281u,4272287920u,2968533048u,947420220u,1072201707u,4095726655u,1363230741u,218369513u,2112387719u,2919545868u,3158299634u,1040326207u,4192304903u,125730528u,4034981951u,1078985600u,2180641853u,1069596736u,4229930976u,1616934975u,941621248u,0u,2282245244u,4039911032u,2036729363u,187826218u,3170083338u,418434846u,1045493886u,2123921535u,3912681479u,2865489930u,36173420u,2302931796u,3205692963u,4193787455u,2575403127u,4160876624u,4030787824u,2021154816u,0u,0u);\n#else\nconst vec3 grid0Min = vec3 (-4.00, -4.00, -4.00);\nconst vec3 grid0Max = vec3 (4.00, 4.00, 4.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[304] = uint[](1052696u,404241420u,202117616u,270000383u,2414872600u,2021648262u,116657212u,1070856002u,509478378u,336916560u,4280307135u,2423814248u,2106053692u,1010579521u,3256871445u,4269151568u,274069423u,3237995263u,2265437170u,4089692931u,4194171361u,3783360943u,732929282u,1420431477u,4030070746u,2140676349u,126945219u,3285173239u,3888111390u,471918478u,242322062u,1086341601u,3768705505u,4042322160u,3230294630u,2141139762u,818925336u,295506050u,2206614275u,3282108800u,366276676u,1609359359u,4286079078u,1726373503u,1009259519u,4196479902u,504756729u,2677869226u,135491603u,4048780943u,4027064294u,1643764743u,4094430195u,4107046674u,1719010746u,1143644200u,2867592847u,3892979843u,2880002027u,3129551370u,44705952u,2884287275u,2914126370u,2884336802u,4010322464u,2157966426u,538619314u,4891290u,2550920895u,4207911431u,2863722564u,73819750u,1644566394u,2951383799u,265818130u,3188338223u,4037010920u,2139155072u,4286622599u,2944931960u,2021654463u,1010326588u,1010581502u,504391422u,505290271u,3893575404u,3473886222u,1905892825u,2556899532u,3435978648u,4019256576u,4279238054u,1719171168u,2066742048u,808466457u,2415929824u,3154083993u,3220044996u,1538252029u,3202770531u,2254727123u,51634113u,872126872u,1659738554u,4020808328u,2854232639u,2707392488u,89844230u,117666755u,3947500937u,1467984426u,2935312125u,1476952746u,2852825771u,2720180906u,716528565u,1474472490u,4004183432u,2852661384u,2291907492u,3409624131u,3105362329u,2622233807u,3153899344u,3208703760u,269819205u,286259576u,2105080326u,26281968u,1023407043u,33800689u,20977141u,4126220005u,4195350787u,4290527981u,318506755u,3280142592u,348144860u,4232070768u,1071504313u,3061709759u,3737858867u,590560867u,507091359u,859783118u,3485177740u,3865494625u,4294773487u,147630711u,2286239813u,4290724067u,3825179920u,437234178u,2876635105u,2702159618u,4245312835u,3286937278u,522066804u,44612266u,2175732527u,4039069943u,1091779497u,3042409316u,1466081826u,4008414890u,3884746792u,2290654139u,3025128244u,1306106329u,2644090060u,3752972223u,3706654992u,3810334720u,572531263u,4045291239u,1896038398u,3981809473u,67120096u,2692759520u,3154115583u,4106801122u,262671365u,4457597u,3401293258u,3114130627u,3007034174u,1637456379u,3878735054u,4109342822u,3429292539u,3718282626u,4208796245u,1575720317u,1628504533u,1353428923u,1432185488u,715910081u,1440044373u,1431385973u,1067869248u,2538038357u,1646438955u,3996380810u,871279144u,2308684723u,617329196u,3275329945u,2165621956u,3435654689u,3486257390u,4010806880u,644245095u,842015539u,807536243u,254279742u,251649983u,403177532u,3927826174u,3929398511u,3486317792u,2389075462u,1615278867u,4046664602u,2140772798u,2881137375u,581089876u,68515157u,1365112289u,3741629023u,3751829410u,1410684277u,1094800887u,2707382111u,95049128u,1343241143u,2757229205u,1538269218u,581857262u,937986175u,2156406922u,2820403756u,3283857452u,1339627793u,3650899020u,3439320067u,4243467093u,3624822374u,1644562227u,857932288u,8718u,1062274844u,2028019454u,1719034782u,2134324087u,1858868213u,3831503860u,1098268330u,350885346u,169406671u,448688354u,3200134079u,1075836320u,2695904938u,99227114u,168885872u,2733671102u,168435700u,536191226u,4197095352u,2283466923u,3218128203u,3625547900u,471612670u,4264431580u,3218206977u,2699591709u,1296301069u,266344478u,3890718695u,4027342835u,3019105232u,4244701440u,17u,391188377u,2174644323u,2409614536u,2167619532u,3393283093u,1542931716u,159243640u,2112454140u,273013823u,1820195669u,3578872064u,353308431u,3886415751u,2181457907u,4226008003u,839074113u,1075055887u,2273805830u,126075843u,50397184u,0u);\n#endif\nuint readBitsSVO0 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject0[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject0[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject0[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO0 (vec3 samplePos, vec3 sampleDir, out vec3 skipPos) {\n    skipPos = vec3 (10000.0);\n    if ( any(lessThan(samplePos, grid0Min)) || any(greaterThan(samplePos, grid0Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid0Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO0 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO0 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO0 (streamReadPos, 1u);\n    if (topBrick == 0u) {\n        vec3 topBrickMin = grid0Min + vec3 (topBrickPos);\n        vec3 topBrickMax = topBrickMin + vec3 (1.0);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, topBrickMin, topBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO0 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid0Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) {\n        vec3 midBrickMin = grid0Min + vec3 (topBrickPos) + midBrickPos;\n        vec3 midBrickMax = midBrickMin + vec3 (0.5);\n        vec3 p1 = samplePos;\n        vec3 p2 = p1 + sampleDir * 2.0;\n        vec3 m = p2 - p1;\n        float tMin, tMax;\n        rayBoxIntersectTime (p1, vec3(1.0)/m, midBrickMin, midBrickMax, tMin, tMax);\n        skipPos = p1 + m * (tMax + 0.01);\n        return false;\n    }\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO0 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n    checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    skipPos = samplePos + sampleDir * 0.25;\n    return false;\n}\n\nbool traceRaySVO0(vec3 p1, vec3 p2, out vec3 hitPos) {\n    vec3 m = p2 - p1;\n    float hitMin, hitMax;\n    if ( !rayBoxIntersectTime (p1, vec3(1.0)/m, grid0Min, grid0Max, hitMin, hitMax) ) {\n        hitPos = vec3 (-1.0);\n        return false;\n    }\n    \n    hitMin += 0.00001;\n    hitMax -= 0.00001;\n    vec3 curPos = p1 + hitMin * m;\n    vec3 curDir = normalize (m);\n    vec3 skipPos = vec3 (0.0);\n    for (int i = 0; i != 100; i++) {\n        if (readLeafSVO0 (curPos, curDir, skipPos)) {\n            hitPos = curPos;\n            return true;\n        }\n        if ( skipPos == vec3(10000.0) ) break;\n        curPos = skipPos;\n    }\n    return false;\n}\n\n// ===================== HELPER UTILS =====================\n\n#define M_PI 3.1415926535\n\nvoid toLog (mat3 mat, out vec3 axis, out float angle)\n{\n    float matTrace = mat[0][0] + mat[1][1] + mat[2][2];\n    angle = acos ((matTrace - 1.0) / 2.0);\n    float sinAngle = sin(angle);\n    if ( abs(sinAngle) < 0.0001 )\n        if (sinAngle < 0.0)\n            sinAngle = -0.0001;\n        else\n            sinAngle = 0.0001;\n    axis = (1.0 / (2.0 * sinAngle)) * vec3 (mat[1][2] - mat[2][1], mat[2][0] - mat[0][2], mat[0][1] - mat[1][0]); // Column major\n}\n\nvoid toExp (vec3 axis, float angle, out mat3 mat)\n{\n    mat3 ident = mat3(1.0), crossMat, crossMat2;\n    crossMat[0] = vec3 (0.0, axis.z, -axis.y);\n    crossMat[1] = vec3 (-axis.z, 0.0, axis.x);\n    crossMat[2] = vec3 (axis.y, -axis.x, 0.0);\n    crossMat2 = crossMat * crossMat;\n    mat = ident + sin(angle) * crossMat + (1.0 - cos(angle)) * crossMat2;\n    mat[0] = normalize (mat[0]);\n    mat[1] = normalize (mat[1]);\n    mat[2] = normalize (mat[2]);\n}\n\nvoid slerp(float startAngle, vec3 startAxis, float endAngle, vec3 endAxis, float t, out float curAngle, out vec3 curAxis) {\n\t// Calculate angle between them.\n\tfloat cosHalfTheta = startAngle * endAngle + dot (startAxis, endAxis);\n\t// if qa=qb or qa=-qb then theta = 0 and we can return qa\n\tif (abs(cosHalfTheta) >= 1.0){\n\t\tcurAngle = startAngle;\n        curAxis = startAxis;\n\t\treturn ;\n\t}\n\t// Calculate temporary values.\n\tfloat halfTheta = acos(cosHalfTheta);\n\tfloat sinHalfTheta = sqrt(1.0 - cosHalfTheta*cosHalfTheta);\n\t// if theta = 180 degrees then result is not fully defined\n\t// we could rotate around any axis normal to qa or qb\n\tif (abs(sinHalfTheta) < 0.001){ // fabs is floating point absolute\n\t\tcurAngle = (startAngle * 0.5 + endAngle * 0.5);\n\t\tcurAxis = (startAxis + endAxis) * 0.5;\n\t\treturn ;\n\t}\n\tfloat ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n\tfloat ratioB = sin(t * halfTheta) / sinHalfTheta; \n\t//calculate Quaternion.\n\tcurAngle = (startAngle * ratioA + endAngle * ratioB);\n\tcurAxis.x = (startAxis.x * ratioA + endAxis.x * ratioB);\n\tcurAxis.y = (startAxis.y * ratioA + endAxis.y * ratioB);\n\tcurAxis.z = (startAxis.z * ratioA + endAxis.z * ratioB);\n}\n\nvoid fromQuat (vec3 axis, float angle, out mat3 mat)\n{\n\tmat[0] = normalize (vec3(1.0 - 2.0 * (axis.y * axis.y + axis.z * axis.z), 2.0 * (axis.x * axis.y + axis.z * angle), 2.0 * (axis.x * axis.z - axis.y * angle)));\n\tmat[1] = normalize (vec3(2.0 * (axis.x * axis.y - axis.z * angle), 1.0 - 2.0 * (axis.x * axis.x + axis.z * axis.z), 2.0 * (axis.y * axis.z + axis.x * angle)));\n\tmat[2] = normalize (vec3(2.0 * (axis.x * axis.z + axis.y * angle), 2.0 * (axis.y * axis.z - axis.x * angle), 1.0 - 2.0 * (axis.x * axis.x + axis.y * axis.y)));\n}\n\nvoid toQuat (mat3 mat, out vec3 axis, out float angle)\n{\n    float tr = mat[0][0] + mat[1][1] + mat[2][2];\n    if (tr > 0.0) { \n        float S = sqrt(tr+1.0) * 2.0; // S=4*qw \n        angle = 0.25 * S;\n        axis.x = (mat[1][2] - mat[2][1]) / S;\n        axis.y = (mat[2][0] - mat[0][2]) / S; \n        axis.z = (mat[0][1] - mat[1][0]) / S; \n    } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) { \n        float S = sqrt(1.0 + mat[0][0] - mat[1][1] -  mat[2][2]) * 2.0; // S=4*qx \n        angle = (mat[1][2] - mat[2][1]) / S;\n        axis.x = 0.25 * S;\n        axis.y = (mat[1][0] + mat[0][1]) / S; \n        axis.z = (mat[2][0] + mat[0][2]) / S; \n    } else if (mat[1][1] > mat[2][2]) { \n        float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0; // S=4*qy\n        angle = (mat[2][0] - mat[0][2]) / S;\n        axis.x = (mat[1][0] + mat[0][1]) / S; \n        axis.y = 0.25 * S;\n        axis.z = (mat[2][1] + mat[1][2]) / S; \n    } else { \n        float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0; // S=4*qz\n        angle = (mat[0][1] - mat[1][0]) / S;\n        axis.x = (mat[2][0] + mat[0][2]) / S;\n        axis.y = (mat[2][1] + mat[1][2]) / S;\n        axis.z = 0.25 * S;\n    }\n}\n\n#define SINE_DIVIDER ((sin(iTime) + 1.0) * 0.5)\n#define USE_QUAT_SLERP (fetchUV.x > SINE_DIVIDER)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fetchUV = fragCoord.xy / iResolution.xy;\n    vec2 uvDenorm =(fetchUV - vec2 (0.5)) * 2.0;\n    vec3 curEye = vec3 (0.0, 3.0, 20.0);\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (vec3 (0.0, 1.0, 0.0), curLook));\n    vec3 curUp = cross (curLook, curSide) * (iResolution.y / iResolution.x);\n    vec3 curDir = curLook + curSide * uvDenorm.x + curUp * uvDenorm.y;\n    vec3 curEndSight = curEye + curDir * 1000.0;\n    vec3 curSightSeg = curEndSight - curEye;\n    \n    mat3 startMat, endMat, curMat;\n    startMat[0] = normalize (vec3 (103.0, 25.0, 905.0));\n    startMat[1] = normalize (cross (normalize (startMat[0] + vec3 (30.0, 200.0, 0.45)), startMat[0]));\n    startMat[2] = cross (startMat[1], startMat[0]);\n    endMat[0] = normalize (vec3 (13.0, -555.0, 15.0));\n    endMat[1] = normalize (cross (normalize (endMat[0] + vec3 (-1000.0, 2.0, 0.45)), endMat[0]));\n    endMat[2] = cross (endMat[1], endMat[0]);\n    vec3 startAxis, endAxis, curAxis;\n    float startAngle, endAngle, curAngle;\n    \n    if (fetchUV.x > SINE_DIVIDER - 0.002 && fetchUV.x < SINE_DIVIDER + 0.002)\n    {\n        fragColor = vec4 (1.0, 1.0, 0.0, 1.0);\n        return ;\n    }\n    else if (USE_QUAT_SLERP)\n    {\n        toQuat (mat3(1.0), startAxis, startAngle);\n        toQuat (endMat * inverse(startMat), endAxis, endAngle);\n\n        slerp (startAngle, startAxis, endAngle, endAxis, max (iTime, 0.0001), curAngle, curAxis);\n\n        fromQuat (curAxis, curAngle, curMat);\n    }\n    else\n    {\n        toLog (endMat * inverse(startMat), curAxis, curAngle);\n        curAngle *= max (iTime, 0.0001);\n        toExp (curAxis, curAngle, curMat);\n    }\n    curMat *= startMat;\n\n    curEye = inverse(curMat) * curEye;\n    curSightSeg = inverse(curMat) * curSightSeg;\n    \n    vec3 hitPos = vec3(0.0);\n    bool rt;\n    rt = traceRaySVO0(curEye, curSightSeg, hitPos);\n    if ( !rt ) {\n        if ( hitPos == vec3 (-1.0) ) fragColor = vec4 (0.5, 0.5, 0.5, 1.0);\n        else fragColor = vec4(0.0);\n     }\n    else fragColor = vec4 (length(curMat * (hitPos - curEye)) * (USE_QUAT_SLERP ? vec4 (0.05, 0.0, 0.0, 1.0) : vec4 (0.0, 0.0, 0.05, 1.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttBD7.jpg", "access": "api", "license": "mit", "functions": [[1679, 1679, 1777, 1777, 2144], [2146, 2146, 2173, 2173, 2263], [2265, 2265, 2309, 2309, 2523], [11977, 11977, 12024, 12024, 12901], [12903, 12903, 12973, 12973, 15980], [15982, 15982, 16036, 16036, 16634], [16724, 16724, 16779, 16779, 17181], [17183, 17183, 17234, 17234, 17636], [17638, 17638, 17761, 17795, 18813], [18815, 18815, 18869, 18869, 19354], [19356, 19356, 19412, 19412, 20570], [20671, 20671, 20728, 20728, 22871]], "test": "ok"}
{"id": "dttBDM", "name": "Cosmic Stepping Stones", "author": "space928", "description": "Wander through the cosmos, but watch your step.", "tags": ["2d", "abstract", "bloom", "purple"], "likes": 7, "viewed": 340, "published": 3, "date": "1701316794", "time_retrieved": "2024-07-30T17:19:55.964755", "image_code": "// An abstract shader by Thomas M.\n// The bulk of the shader is in Buffer A so that temporal accumulation can be done.\n// This pass does the post processing (bloom, vignette, and dither)\n\n// Reduces blinear interpolation artifacts, and I think it looks nice\nconst float bloomNoise = 0.25;\n// Set to 1. if you want animated noise.\nconst float animateDither = 0.;\n\n#define rnd_off(o) (((hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)))*2.-1.)+(hash23(vec3(fragCoord.x, fragCoord.y, fract(iTime*animateDither)+0.5798765))*2.-1.0))/iResolution.xy*pow(2.,o)*bloomNoise)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    // Bloom based on mipmaps\n    vec3 bloom = vec3(0.);\n    bloom += textureLod(iChannel0, uv+rnd_off(1.), 1.).rgb*0.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(2.), 2.).rgb*0.75;\n    bloom += textureLod(iChannel0, uv+rnd_off(3.), 3.).rgb*1.0;\n    bloom += textureLod(iChannel0, uv+rnd_off(4.), 4.).rgb*1.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(5.), 5.).rgb*2.;\n    bloom += textureLod(iChannel0, uv+rnd_off(6.), 6.).rgb*2.5;\n    bloom += textureLod(iChannel0, uv+rnd_off(7.), 7.).rgb*3.0;\n    col += tanh(pow(bloom*0.5, vec3(2.)))*0.25;\n    \n    // Vignette inspired by: https://www.shadertoy.com/view/lsKSWR\n    vec2 u = uv*(1.-uv.yx);\n    float vignette = tanh(u.x*u.y*25.+0.05)*1.2;\n    col = pow(vignette*pow(col, vec3(2.)), vec3(1./2.));\n    \n    // Dither at the end\n    float dither = (hash12(fragCoord+fract(iTime*animateDither*0.733)) + hash12(fragCoord + 0.59374+fract(iTime*animateDither*0.733)) - 0.5)/255.;\n    col += dither;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float dist = 200.; // Maximum blur distance\nconst vec2 dir = vec2(0., 1.); // Direction to blur in\nconst float gamma = 0.2; // Gamma to apply while blurring. (accentuates the highlights)\nconst float thresh = 0.6; // Highlight threshold (used as the stopping point for the blur)\nconst vec3 jitter = vec3(0.1, 0.0, 0.3); // Amount of jitter applied to the motion blur in x and y; the z component jitters the threshold\nconst vec3 loss = vec3(0.004, 0.003, 0.001); // Subtract a bit from each iteration of the blur to darken trails\nconst float frameBlending = 10.; // Set this really long for nothern-lights-esque graphics\nconst float speed = 0.01; // How fast the secondary texture scrolls\n\nvec3 colMap(vec3 col)\n{\n    float lum = dot(col, vec3(0.3, 0.6, 0.1));\n    const vec3 dark = vec3(0., 0.001, 0.002);\n    const vec3 mid = vec3(0.4, 0.3, 0.6);\n    const vec3 light = vec3(1., 0.4, 0.7);\n    return (mix(dark, mix(mid, light, clamp(lum*3.-1., 0., 1.)), clamp(lum*3., 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Vertical blur of the image\n    vec3 col = pow(texture(iChannel0, uv).rgb, vec3(gamma));\n    float sum = 1.;\n    for(float i = 0.; i < dist; i += 1.)\n    {\n        vec2 rnd = (hash23(vec3(uv+iTime*vec2(3., 1.67), i+fract(iTime)))*2.-1.)*jitter.xy;\n        vec2 suv = uv + (dir+rnd) * i / iResolution.xy;\n        vec3 samp = pow(texture(iChannel0, suv).rgb, vec3(gamma));\n        vec3 sampb = pow(texture(iChannel1, suv-dir*iTime*speed).rgb, vec3(gamma)).rgb;\n        samp = (samp+sampb)/2.;\n        // Stop when we reach a highlight, this gives the highlights nice long trails\n        if(dot(samp, vec3(0.3, 0.6, 0.1)) > pow(thresh+jitter.z*rnd.x, gamma))\n            break;\n        col += samp * (1.-loss * i)*0.95;\n        sum += 1.;\n    }\n    col /= sum;\n    // We blur with gamma to accentuate the highlights, we  undo the gamma here\n    col = pow(col, vec3(1./gamma));\n    \n    // Pretty colours\n    col = colMap(col);\n    \n    // Temporal accumulation\n    vec4 prev = texture(iChannel3, fragCoord/iResolution.xy);\n    vec2 prevRes = texelFetch(iChannel3, ivec2(0), 0).xy;\n    if(abs(dot(prevRes - 1./iResolution.xy, vec2(1.))) < 0.0005)\n    {\n        //float dither = (hash12(fragCoord) + hash12(fragCoord + 0.59374) - 0.5)/255.;\n        col = mix(prev.xyz, col, 1./frameBlending);\n    }\n    if (fragCoord-0.5 == vec2(0.0))\n        col = vec3(1./iResolution.xy, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash functions taken from:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 641, 691, 1796]], "test": "untested"}
{"id": "cldfD7", "name": "第9回  課題", "author": "takaaki", "description": "a", "tags": ["a"], "likes": 0, "viewed": 152, "published": 3, "date": "1701310438", "time_retrieved": "2024-07-30T17:19:56.727714", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n    vec2 center = vec2(0.5, 0.5);\n\n    vec2 size = vec2(0.1, 0.1);\n\n    vec2 velocity = vec2(0.3, 0.2);\n\n\n    vec2 newPosition = center + velocity * iTime;\n\n \n    newPosition = newPosition * vec2(800.0 / 450.0, 1.0);\n    newPosition = mod(newPosition, vec2(1.0, 1.0));\n\n    if (uv.x > newPosition.x - size.x / 2.0 && uv.x < newPosition.x + size.x / 2.0 &&\n        uv.y > newPosition.y - size.y / 2.0 && uv.y < newPosition.y + size.y / 2.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0); \n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 659]], "test": "untested"}
{"id": "cldfWM", "name": "SDF quality w Bounds operators", "author": "elenzil", "description": "Taking a closer look at the quality of SDF with the Subtract and Intersect CSG operations.\nThe shape is formed by Intersecting two half-planes and then Subtracting a circle.\nFollowing up on discussion in https://www.shadertoy.com/view/dldfW8 .", "tags": ["sdf", "intersection", "subtraction", "continuity"], "likes": 10, "viewed": 191, "published": 3, "date": "1701302861", "time_retrieved": "2024-07-30T17:19:57.494663", "image_code": "/*\n\nFollowing up on discussion in https://www.shadertoy.com/view/dldfW8 .\n\n*/\n\nfloat zoom = 1.0;  // smaller = zoomed in\n\nfloat map(in vec2 p) {\n\n    float circleRad     = 100.0;\n    vec2  circleCen     = vec2(-(circleRad + 1.0), 0.0);\n    \n    float sdHalfPlane1  = p.x;\n    float sdHalfPlane2  = p.y;\n    float sdCircle      = length(p - circleCen) - circleRad;\n    \n    float sdIntersected = max(sdHalfPlane1 ,  sdHalfPlane2);\n    float sdSubtracted  = max(sdIntersected, -sdCircle);\n    \n    return sdSubtracted;\n}\n\nvoid drawCircle(inout vec3 rgb, in vec2 p, in vec2 c, float r) {\n    float d = length(p - c) - r;\n    float f = abs(d) - zoom;\n    vec3  q = vec3(0.8, 1.0, 0.0);\n    // interior\n    rgb = mix(rgb, q, 0.1 * smoothstep(1.0, 0.0, d));\n    // edge\n    rgb = mix(rgb, q,       smoothstep(1.0, 0.0, f));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2  p = XY        - iResolution.xy / 2.0;\n    vec2  m = iMouse.xy - iResolution.xy / 2.0;\n    if (length(iMouse.xy) < 100.0) {\n        m.x = cos(iTime * 0.3);\n        m.y = sin(iTime * 0.3);\n        m *= iResolution.xy * 0.4;\n    }\n    \n    p *= zoom;\n    m *= zoom;\n    \n    float d = map(p);\n    \n    vec3 c    = vec3(1e9, 0.0, 1e9);\n    vec3 cIn  = vec3(0.3, 0.5, 0.8);\n    vec3 cOut = vec3(0.7, 0.4, 0.2);\n    vec3 cBrd = vec3(1.0);\n    \n    // there's probably a cleaner way to get contour lines\n    // of sort-of-constant width w/r/t zoom,\n    // but I don't think I'm invalidating the SDF here.\n    \n    bool wideBands = bool((int(iTime) / 5) % 2);\n    \n    float distanceScaleForBands = 0.6;\n    float f                     = mix(0.6, 1.0, 1.0 - zoom);\n   \n    if (wideBands) {\n        distanceScaleForBands = 0.05;\n        f                     = -1.0;\n    }\n    \n    float sinD = sin(d * distanceScaleForBands - iTime * 3.0);\n    \n    // inside the SDF\n    c = mix(c, cIn , smoothstep( 0.0, zoom, -d));\n    \n    // outside the SDF\n    c = mix(c, cOut, smoothstep( 0.0, zoom,  d));\n    \n    // isolines\n    c *= 0.5 + 0.5 * smoothstep( f, 1.0, sinD);\n    \n    // boundary of the SDF\n    c = mix(c, cBrd, smoothstep( zoom, 0.0,  abs(d) - zoom));\n    \n    // draw the distance at the mouse point,\n    drawCircle(c, p, m, abs(map(m)));\n    drawCircle(c, p, m, 2.0 * zoom);\n    \n    RGBA.rgb = c;\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 144, 144, 518], [520, 520, 584, 584, 819]], "test": "untested"}
{"id": "mt3BD7", "name": "Fast & Short Reaction Diffusion5", "author": "benoitM", "description": "Fast Reaction Diffusion using mipmaps \nPart of some private exploration in 2021 never released. I changed my mind\nTry it fullscreen", "tags": ["mipmap", "diffusion", "highpass", "reaction", "golfed", "cineshader"], "likes": 7, "viewed": 619, "published": 3, "date": "1701294847", "time_retrieved": "2024-07-30T17:19:58.502967", "image_code": "/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n//     Fast & Simple Reaction Diffusion Pattern V5                     //\n//                                                                     //\n//             by Benoit Marini - 16/11/2021                           //\n//                                                                     //\n/////////////////////////////////////////////////////////////////////////\n//                                                                     //\n// from \"Fast & Simple & Dirty Reaction Diffusion Pattern\"             //\n// Only using mimaps for convolutions                                  //\n// More info here https://www.shadertoy.com/view/flGGzR                //\n//                                                                     //\n// Modified version with :                                             //\n//   * nicer forms                                                     //\n//   * color                                                           //\n//   * interactivity                                                   //\n//   * auto reset                                                      //\n// Lot of tricks used                                                  //\n//                                                                     //        \n/////////////////////////////////////////////////////////////////////////  \n\nM\n    T(-f*float(2*iFrame),0.);                              // FORM (stored on alpha channel)\n    o.rgb = smoothstep  (.4,.5,o.a) *cos(o.r*vec3(1,2,4)); // COLOR from red channel (multiplied by Form)\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M\n   \n   step (.01,T(f,0.)-T(f,S+G )) ;   // FORM o = step (.01,T(f ..... \n   o.r = (o.a>.5)? T(f,0.).r : -.5; //COLOR\n   if( T(f,S+G).r <.01 ) o.r+=.1;   //COLOR\n \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// FORM (alpha channel) : high pass filter & threshold of Buffer B \n//                                                                 \n//////////////////////////////////////////////////////////////////////////////////\n// COLOR (red channel storing color index) :\n//\n//  if(o.a>.5) // WHITE pixel (form)\n//  {\n//      if(T(f,3.5).r <0.2)         // Get blurry image of color index to split between border and inner             \n//      {\n//          o.r = T(f,1.).r + 0.06; // Border case : add offset color index                               \n//      }\n//      else\n//      {\n//          o.r = T(f,3.).r;        // Inner case : keep color it but average it                                     \n//      }\n//  }\n//  else // BLACK Pixel (no form)\n//  {\n//      o.r = -.5;                  // set color index = -0.5; will influence blurry image of color index                           \n//  }\n//  \n///////////////////////////////////////////////////////////////////////////////////\n\n\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "M\n     T(f,S) + exp(-i.x-i.y);    // FORM on .a chanel  // o = T(f,2.5) + ......\n     o.r = T(f,1.).r ;            // COLOR on .r chanel   \n     if ( T(f,99.).a > .45 && o.r <0.95 ) o-=o; // RESET if form cover more than ~45% of the screen, work with 2^99 screens resolutions ;)\n\n\n}\n\n//////////////////////////////////////////////////////\n// FORM : blur buffer A + add small perturbation    //\n//////////////////////////////////////////////////////\n// COLOR : blur buffer A                            //\n//////////////////////////////////////////////////////\n// RESET : use mipmap to know average coverage      //\n//////////////////////////////////////////////////////\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 o, vec2 i ) { o=\n#define f vec2(1.1)\n#define S 2.5 + fract(iTime/3.5)\n#define G 0.8*cos(8.*i.x/iResolution.x)\n#define T(d,l) texture(iChannel0, (i+d)/iResolution.xy ,l)", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3BD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cl3fD7", "name": "Gradient Circles Spiral Distort", "author": "Peace", "description": "I", "tags": ["distortion", "spiral", "gradient", "circl"], "likes": 1, "viewed": 72, "published": 3, "date": "1701283074", "time_retrieved": "2024-07-30T17:19:59.404557", "image_code": "const float OPACITY = 0.2;\nconst vec3 HALO_COL = vec3(0.2, 0.6, 1.0);\nconst vec3 EDGE1_COL = vec3(1.0, 0.68, 0.66);\nconst vec3 EDGE2_COL = vec3(1.0, 0.3, 0.2);\nconst vec3 BACKGROUND_COL = vec3(0.2);\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat rand1d(float n) { return fract(sin(n) * 43758.5453123); }\n\nvec3 hueShift(vec3 col, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosa = cos(hue);\n    return vec3(col * cosa + cross(k, col) * sin(hue) + k * dot(k, col) * (1.0 - cosa));\n}\n\nvec2 rot(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 circle(vec2 uv, float off) \n{\n    vec3 col = HALO_COL;\n    float t = iTime * 0.5 + off;\n    float f = 0.0001;\n    uv = rot(uv, 6.2831853 * rand1d(off));\n    float n = noise(vec3(uv * 1.2, t)) * 0.2 + noise(vec3(-uv * 1.7, t)) * 0.15 + noise(vec3(uv * 2.2, t)) * 0.1;\n    \n    float l = length(uv) * 5.0 - iTime;\n    float d = distance(uv, vec2(sin(l), cos(l)));\n    \n    float hd = d + n;\n    float shd = smoothstep(1.0, 1.0 - f, hd);\n    col = pow(vec3(hd), vec3(3.5, 3.5, 2.0)) * HALO_COL * shd;\n    float cd = d * hd * hd * shd * 1.25;\n    col += cd * cd * mix(EDGE1_COL, EDGE2_COL, pow(hd, 8.0)) - (cd * cd * cd) * col;\n    vec3 color = BACKGROUND_COL * 0.5 + col * shd;\n    float glow = smoothstep(1.5, 1.0, hd) * (1.0 - shd * 1.25);\n    col = color + color * glow;\n    col += EDGE2_COL * glow * glow * glow * glow * glow * glow * glow * 0.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.1;\n    \n    vec3 col = mix(mix(mix(mix(\n    circle(uv, 0.0), \n    circle(uv, 1000.0), OPACITY), \n    circle(uv, 2000.0), OPACITY), \n    circle(uv, 3000.0), OPACITY), \n    circle(uv, 4000.0), OPACITY);\n    col = 1.0 - col;\n    col = hueShift(col, 3.1415);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3fD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 223, 223, 270], [271, 271, 292, 292, 339], [340, 340, 359, 359, 400], [402, 402, 423, 423, 914], [916, 916, 939, 939, 979], [981, 981, 1017, 1017, 1187], [1189, 1189, 1217, 1217, 1301], [1303, 1303, 1337, 1337, 2173], [2175, 2175, 2232, 2232, 2639]], "test": "untested"}
{"id": "dtcfWn", "name": "Fire FG (Tabyltop)", "author": "DrieStone", "description": "Adjusted to allow for the flames to appear on top of a webcam image.", "tags": ["flame", "fire", "blaze"], "likes": 7, "viewed": 523, "published": 3, "date": "1701279914", "time_retrieved": "2024-07-30T17:20:00.477758", "image_code": "// Took 301's last remix and added the webcam behind\n// Remix 3 here: https://www.shadertoy.com/view/4ttGWM\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\n\n\nfloat baseVerticalPosition = 185.0; // Adjust this for your base resolution\nfloat flameHeightFactor = 3.5; // Increase for higher flames\nfloat flameIntensityFactor = 2.2; // Increase for more intense flames\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n   float flameVerticalPosition = baseVerticalPosition * iResolution.y / 720.0;\n\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord.xy + vec2(0.0, flameVerticalPosition)) * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    \n    vec3 fireColor = vec3(color.x, color.y, color.z) * flameIntensityFactor;\n\n    // Get webcam input\n    vec4 webcamColor = texture(iChannel0, uv);\n\n    // Calculate the luminance of the fire color\n    float fireLuminance = dot(fireColor, vec3(0.299, 0.587, 0.114));\n\n    // Blend the webcam image and the fire based on fire luminance\n    vec3 blendedColor = mix(webcamColor.rgb, fireColor, clamp(fireLuminance * flameHeightFactor, 0.0, 1.0));\n\n    fragColor = vec4(blendedColor, 1.0);\n\n    \n    \n    \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 485, 505, 505, 579], [581, 581, 602, 602, 808], [810, 810, 829, 829, 1014], [1017, 1017, 1074, 1074, 3175]], "test": "untested"}
{"id": "cl3BWM", "name": "Flashing Streaks [319 Chars]", "author": "SnoopethDuckDuck", "description": "its a shader", "tags": ["lines", "stuff", "cool", "thing", "techno", "golf"], "likes": 22, "viewed": 226, "published": 3, "date": "1701272529", "time_retrieved": "2024-07-30T17:20:01.525885", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    // Replace u*4. with iResolution.y to get a sphere\n    vec3 p = normalize(vec3(u+u-iResolution.xy, u*4.));\n    \n    // Use m = .5 to keep starting state\n    float t = .2 * iTime,\n          d = fract(t),\n          m = .5+t-d+smoothstep(.4,.6,d),\n          i;\n\n    mat2 M = mat2(cos(t-vec4(0,11,33,0)));\n    p.yx *= M;\n    p.zx *= M;\n    \n    for (o *= 0.; \n         i++ < 12.; \n         o += (1.+cos(1e2*m+vec4(8,7,6,0)))*d*d/15.)\n        m *= .85,  \n        d = 1.+cos(20.*p.y+t+t)-length(p=1.3*(abs(p-m/4.)-m))/m;\n        \n    o *= o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3BWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 93, 580]], "test": "untested"}
{"id": "dtdfD4", "name": "diamboy's amogus cake", "author": "Diamboy", "description": "amogus\ndoesn't really look like a cake but amogus funny\nadded sus music", "tags": ["raytracing", "amongus"], "likes": 2, "viewed": 176, "published": 3, "date": "1701269651", "time_retrieved": "2024-07-30T17:20:02.408525", "image_code": "struct intersect_info\n{\n    float t;\n    bool i;\n    vec2 uv;\n};\n\nvoid update(inout intersect_info a, intersect_info b)\n{\n    if (b.i && (!a.i || a.t > b.t)) a = b;\n}\n\n// the parallelogram is ABDC\nintersect_info ray_parallelogram(vec3 ro, vec3 rd, vec3 a, vec3 b, vec3 c)\n{\n    intersect_info ii;\n    ii.i = false;\n\n    ro -= a;\n    b -= a;\n    c -= a;\n    vec3 n = cross(b, c);\n    mat3 m = transpose(inverse(mat3(b, c, n)));\n    ro *= m;\n    rd *= m;\n    float t = -ro.z / rd.z;\n    if (t < 0.0) return ii;\n    vec2 uv = ro.xy + rd.xy * t;\n    if (uv.x < 0.0 || uv.x >= 1.0 || uv.y < 0.0 || uv.y >= 1.0) return ii;\n    ii.t = t;\n    ii.uv = uv;\n    ii.i = true;\n    return ii;\n}\n\nintersect_info ray_world(vec3 ro, vec3 rd)\n{\n    vec3[] buf = vec3[]( vec3(-1,-1,0), vec3(1,-1,-0.4), vec3(1,-1,0.4), vec3(1,1,-0.4), vec3(-1,1,0) );\n    float c = cos(iTime);\n    float s = sin(iTime);\n    for (int i = 0; i < 5; i++)\n        buf[i].xz *= mat2(c,s,-s,c);\n    intersect_info r = ray_parallelogram(ro, rd, buf[0], buf[1], buf[4]);\n    update(r, ray_parallelogram(ro, rd, buf[0], buf[2], buf[4]));\n    update(r, ray_parallelogram(ro, rd, buf[1], buf[2], buf[3]));\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 2.0));\n    intersect_info ii = ray_world(ro, rd);\n    if (ii.i) fragColor = texture(iChannel0, ii.uv);\n    else fragColor = vec4(0.1, 0.2, 0.3, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float line(vec2 p, vec2 a, vec2 b)\n{\n    b -= a;\n    vec2 proj = a + b * clamp(dot(p - a, b) / dot(b, b), 0.0, 1.0);\n    return length(proj - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 4.0;\n    uv.y -= floor(uv.y);\n    float cake_opacity = smoothstep(0.88, sin(uv.x * 6.0) * 0.12 + 0.64, uv.y);\n    vec3 col = texture(iChannel0, uv).rgb;\n    uv.x -= floor(uv.x);\n    float body = min(\n        line(abs(uv - vec2(0.5, 0)), vec2(0.16, 0.15), vec2(0.16, 0.5)) - 0.14,\n        line(uv, vec2(0.5, 0.5), vec2(0.5, 0.6)) - 0.3\n    );\n    float back = line(uv, vec2(0.2, 0.35), vec2(0.2, 0.55)) - 0.15;\n    float goggles = line(uv, vec2(0.5, 0.6), vec2(0.7, 0.6)) - 0.15;\n    if (back <= 0.0) col = vec3(0.5, 0.5, 0.5);\n    if (body <= 0.0) col = vec3(1, 0, 0);\n    if (goggles <= 0.0) col = vec3(0, 1, 1);\n    \n    \n    col = col * cake_opacity + vec3(1.0 - cake_opacity);\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define C(n) float(-57+(n)*12)\n//#define Db(n) float(-56+(n)*12)\n#define D(n) float(-55+(n)*12)\n#define Eb(n) float(-54+(n)*12)\n//#define E(n) float(-53+(n)*12)\n#define F(n) float(-52+(n)*12)\n#define Gb(n) float(-51+(n)*12)\n#define G(n) float(-50+(n)*12)\n//#define Ab(n) float(-49+(n)*12)\n//#define A(n) float(-48+(n)*12)\n#define Bb(n) float(-47+(n)*12)\n//#define B(n) float(-46+(n)*12)\n#define S (-127.0)\n\nvec2 mainSound( int samp, float time )\n{\n    const float tick_length = 1.0 / 18.0;\n    const int tick_amt = 192;\n    const float[] sine = float[](\n        C(2),  S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        C(4),  S, S,  S, S,    S,  Eb(4), S, S,     S,    S, S,\n        F(4),  S, S,  S, S,    S,  Gb(4), S, S,     S,    S, S,\n        F(4),  S, S,  S, S,    S,  Eb(4), S, S,     S,    S, S,\n        C(4),  S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        S,     S, S,  S, S,    S,  Bb(3), S, S,     D(4), S, S,\n        C(4),  S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        S,     S, S,  S, S,    S,  G(2),  S, S,     S,    S, S,\n        C(2),  S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        C(4),  S, S,  S, S,    S,  Eb(4), S, S,     S,    S, S,\n        F(4),  S, S,  S, S,    S,  Gb(4), S, S,     S,    S, S,\n        F(4),  S, S,  S, S,    S,  Eb(4), S, S,     S,    S, S,\n        Gb(4), S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        S    , S, S,  S, S,    S,  S,     S, S,     S,    S, S,\n        Gb(4), S, S,  S, F(4), S,  S,     S, Eb(4), S,    S, S,\n        Gb(4), S, S,  S, F(4), S,  S,     S, Eb(4), S,    S, S\n    );\n    \n    float amp = 0.0;\n    int idx = int(time / tick_length);\n    while (idx != 0 && sine[idx % tick_amt] <= -127.0) idx--;\n    float t = time - float(idx) * tick_length;\n    float envt = min(1.0, (time / tick_length - float(idx)) / 3.0);\n    float sine_env = min(20.0 * envt, 0.25 * envt * envt - 0.5 * envt + 0.25);\n    float sine_amp = sine_env * clamp(sin(6.2831853 * 440.0 * pow(2.0, sine[idx % tick_amt] / 12.0) * t) * 4.0, -1.0, 1.0);\n    return vec2(sine_amp);\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 121, 121, 166], [168, 197, 273, 273, 680], [1176, 1176, 1233, 1233, 1514]], "test": "untested"}
{"id": "ctdBRM", "name": "Arc Cone Face", "author": "Dain", "description": "A cone with an arc, also the top is a weird face thing\nIf you want just the arc cone with no face set SHOW_FACE to 0\nFace uses smooth xor but if not for that I think it would be exact\n\n2d arc cone:  https://www.shadertoy.com/view/DtdBz7\nface use jt's xor", "tags": ["cone", "xor", "arc"], "likes": 12, "viewed": 171, "published": 3, "date": "1701267356", "time_retrieved": "2024-07-30T17:20:03.602333", "image_code": "\n//see to 0 remove face\n#define SHOW_FACE 1\n\n//The floor shows the internal distance/gradient\n//Norm is scaled into 0-1 range for visualization to verify signs\n\n//Set to 1 to show numeric gradient to verify that it matches analytic\n#define SHOW_NUMERIC_GRADIENT 1//ignore this, this doesn't have analytic gradients\n\n//if 1 it scales norm into 0-1, if 0 it takes abs\n#define SHOW_FULL_NORM_RANGE 1\n\n\nconst float gFlowerR = 1.8;\n\nvec2 sabs(vec2 x, float softness){\n    return sqrt(x*x + softness*softness)-softness;\n    }\n    \nconst float smooth_r = .1;//smooth xor radius(0 is invalid)\n\n//smin attempt:  adjusted for smooth xor so that it transitions between + and - space smoothly\n//the problem is smin with a and b both being 0 does not return 0\n//a and b need to be positive\nfloat smin_xor(float a, float b, float r) {\n//return min(a,b);\n    float e = max(r - abs(a - b),0.0);\n    \n    //a fade so we get smooth transition for sxor between + and - space\n    //..this might cause rate of change to be > 1-- oh well for now.. at least it is very close to surface\n    float f = min(min(a,b)/r,1.0);\n\n   //slow down the transition to hard \n   f = f+f - f*f;\n\n    return min(a, b)- e*e* (1.0/(r*4.0)) *f;\n\n}\n//has some issues when xor goes from + to - space--the distance value jumps--this is because \n//we don't get 0 when and a and b are both 0\nfloat smin(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    return min(a, b)- e*e* (1.0/(r*4.0));\n\n}\n\nfloat sgn(float a){\n    return a >=0.0 ? 1.0 : -1.0;\n}\n//smooth xor\n//radius of 0 is invalid\nfloat sxor(float a, float b, float r){\n    //see IQ article: https://iquilezles.org/articles/sdfxor/\n    //where he shows it can be written this way\n     return sgn(a)*sgn(b)*smin_xor(abs(a), abs(b),r );\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) // https://iquilezles.org/articles/distfunctions\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n//TheTurks flower function https://www.shadertoy.com/view/ctBfWz\nfloat flower(vec2 position, float radius) {\n    position = abs(position);\n   // position = sabs(position, .1);\n    position -= min(position.y - sqrt(3.0) * position.x, 0.0) * vec2(-sqrt(3.0) * 0.5, 0.5);\n    position.y -= radius * 0.5;\n    position = abs(position);\n    //  position = sabs(position, .1);\n   \n    if (position.x + sqrt(3.0) * 0.5 * radius < position.y * sqrt(3.0)) {\n   \n        return length(position - vec2(0.0, 0.5 * radius));\n    }\n    return length(position - vec2(-sqrt(3.0) * 0.5 * radius, 0.0)) - radius;\n}\n\n\nfloat sdCircle( vec2 p, float r ) // https://iquilezles.org/articles/distfunctions\n{\n//    return abs(flower(p,r))-.3;//too much?\n    //return flower(p,r);\n//return length(p)-r;\n    return abs(length(p) - r)-.3;\n}\n\n\n\n// It seems like xor does not have the problems explained in https://www.shadertoy.com/view/3t33WH Interior Distance by iq\n// Confirmed in this new article https://iquilezles.org/articles/sdfxor/ by iq\nfloat xor(float a, float b)\n{\n    // NOTE: XOR can be implemented via sign but sign is buggy on some platforms as spalmer found out.\n    return max(min(a, b), -max(a, b));\n}\n\nfloat XorThing(vec2 p, float r)\n{\n\n    \n    float m = abs(sin(iTime));\n\t//float a = sdBox(p-vec2(m,0), vec2(0.5));\n    float b = sdCircle(p+vec2(m,0), r);\n    float a=  sdCircle(p-vec2(m,0), r);\n    \n    float d = sxor(a, b,smooth_r); \n\n    float n = abs(cos(iTime*.9));\n    float c = sdCircle(p+vec2(0.0,n),r);\n    float e = sdCircle(p-vec2(0.,n), r);\n    \n    float f = sxor(c, e,smooth_r);\n    \n    d = sxor(d, f,smooth_r);\n\n    return abs(d)-.1;\n   // return d-.01;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n//Cone with circular arc edge rather than straight edge\n//width is relative to height and must not be > 1, also fails if w ==0\n//started from iq's CircleCross https://www.shadertoy.com/view/NslXDM\n//Here is 2D version: https://www.shadertoy.com/view/DtdBz7\nfloat sdArcCone( in vec2 p, in float height, float w){\n\n    //Center and flip it(optional)\n   // w = 1.0;\n    p.y += height*.5;\n    p = p.yx;\n    \n    //these are contants and can be pre-computed\n    float k = 0.5*(w+1.0/w);           \n    float kw =k-w;// max(k-w,0.0); \n    k = k*height;\n    w= w*height;\n  \n   \n    p.y = abs(p.y);\n    \n    bool needBot = abs(p.y) < w;\n\n    float px = p.x;\n    \n    p.x = needBot ? abs(p.x):p.x;\n   \n    bool wantArc = ( (p.x)<height && p.y<(p.x*kw+w) ) ;\n    \n    float d= dot2(p-vec2(height,wantArc ? k:0.0));//circule arc or top corner\n    \n    if(!wantArc){\n         d= min(dot2(p-vec2(0,w)),     // right corner\n                                      d);;// top corner \n    }\n\n     d = sqrt(d);\n     d = wantArc ? (k-d):d;\n \n    //bottom\n    d = needBot? max(d,-px):d;\n\n    return d;\n}\nfloat sdRing( in vec2 p, in vec2 n, in float r, in float th )\n{\n    p.x = abs(p.x);\n    \n    p = mat2(n.x,n.y,-n.y,n.x)*p;\n\n    return max( abs(length(p)-r)-th*0.5,\n                length(vec2(p.x,max(0.0,abs(r-p.y)-th*0.5)))*sign(p.x) );\n}\n\n//arc cone to 3D here.\n//Ignore the norm thats from previous shader and not used here\nfloat sdgCylinder(vec3 p, vec2 rh,  out vec3 norm) {\n    p =p.xzy;\n    \n#if SHOW_FACE ==1\n   // float x = flower(p.xz,abs(sin(iTime*.33))*gFlowerR+0.01);\n    float x = XorThing(p.xz,abs(sin(iTime*.33))*gFlowerR+0.01);\n #else\n   float x = length(p.xz);\n #endif\n// x = sdRing(p.zx, normalize(vec2(0.7,.5)), 1.50, 0.0);\n     //x =  abs(length(p.xz)-1.0);//-.1;\n    // x =  length(max(abs(p.xz)-1.0,0.0));\n   // x = max(abs(p.x), abs(p.z));\n    float width = abs(sin(iTime*.5))*1.0;//width at the bottom\n    width = max(width,0.01);//can't be 0\n    float height =  2.0 + abs(cos(iTime*.8))*4.0;//rh.x;\n\tfloat d= sdArcCone(vec2(x, p.y),height,width );\n    return d;\n}\n\n\n            \n//Rest of code by mostly by paniq\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nvec2 doModelWithNorm( vec3 p, out vec3 norm) {\n\n    float Size = 1.5;\n   // float d = Tetrahedron(p, Size, 0.0);\n   float round = .8*abs(sin(iTime*.3));\n\n   round=round*round*round;\n   //   round = max(round,0.01);\n   float rd = abs(cos(iTime*.1))*.5 + 1.0;//,norm;\n   vec2 rad = vec2(rd*.5, rd);\n    float d = sdgCylinder(p, rad, norm )-round;\n    \n#if SHOW_NUMERIC_GRADIENT == 1\n//  if(iMouse.z<=0.0){//show  numeric gradients when left mouse is held\n\n     const float eps = 0.01;\n     const vec3 e = vec3(eps,0.0, 0.0);\n     norm = normalize(vec3(sdgCylinder( p +e.xyz, rad, norm )- sdgCylinder( p -e.xyz, rad, norm ),\n                      sdgCylinder( p +e.yxz, rad, norm )- sdgCylinder( p -e.yxz, rad, norm ),\n                      sdgCylinder( p +e.yzx, rad, norm )- sdgCylinder( p -e.yzx, rad, norm )));\n  //   }\n#endif\n#if SHOW_FULL_NORM_RANGE == 1\n    norm = norm*.5 + .5;\n #else\n    norm = abs(norm);\n#endif\n                             \n\t// d = min(d,length(p)-Size);//use to verify sphere size and tet match up\n    vec2 rr = add_plane(p, vec2(d,0.0));\n \n    return rr;\n}\nvec2 doModel( vec3 p) {\nvec3 norm;\n    return doModelWithNorm(p, norm);\n}\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 norm,norm2;\n    float k = doModelWithNorm(pos,norm).y;\n    float d = doModelWithNorm(vec3(pos.x,0.0,pos.z),norm2).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    vec4 objCOlor = vec4(0.1,.01,1.0,0.1);\n    objCOlor.xyz = norm;\n    return mix(objCOlor, //nor * 0.5 + 0.5,\n               vec4(norm2,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n //   col += mal.w*Texture2D(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n#if 0\n    vec3 norm;\n    doModelWithNorm(pos, norm);\n#if SHOW_FULL_NORM_RANGE ==1\n    norm = norm*2.0 -1.0;\n#endif\n    return (norm);\n    \n#else//for lighting we want the ground plane etc, so do it numerically\n        const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n    vec3 norm;\n#endif\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 5.31 + 0.05*(iTime-10.0) - 7.0*m.x+1.0;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an))*1.5;\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 428, 462, 462, 519], [586, 777, 820, 839, 1204], [1205, 1344, 1383, 1383, 1472], [1474, 1474, 1493, 1493, 1528], [1529, 1567, 1605, 1715, 1772], [1774, 1774, 1860, 1860, 1942], [1943, 2008, 2051, 2051, 2538], [2541, 2541, 2625, 2718, 2754], [2758, 2960, 2989, 3092, 3133], [3135, 3135, 3168, 3168, 3606], [3609, 3609, 3634, 3634, 3653], [3655, 3912, 3966, 4017, 4737], [4738, 4738, 4801, 4801, 4978], [4980, 5066, 5118, 5118, 5728], [5744, 5778, 5861, 5861, 5984], [5986, 5986, 6013, 6013, 6048], [6050, 6050, 6077, 6077, 6108], [6110, 6110, 6137, 6137, 6167], [6170, 6170, 6191, 6191, 6223], [6225, 6225, 6257, 6257, 6288], [6290, 6290, 6336, 6336, 7373], [7374, 7374, 7397, 7397, 7447], [7448, 7801, 7846, 7846, 8208], [8421, 8421, 8505, 8505, 9146], [9148, 9148, 9198, 9198, 9626], [9628, 9628, 9660, 9660, 10317], [10319, 10319, 10367, 10367, 10946], [10948, 10948, 11012, 11012, 11190], [11192, 11192, 11228, 11228, 11322], [11324, 11324, 11381, 11381, 13110]], "test": "untested"}
{"id": "mt3BDN", "name": "kadai9", "author": "hal", "description": "グラデーション変化する背景、グラデーション変化する動かない円、大きさが一定の範囲で変化し、変化速度が周期変化する黒い円を作った。", "tags": ["trial"], "likes": 0, "viewed": 105, "published": 3, "date": "1701242903", "time_retrieved": "2024-07-30T17:20:04.543816", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    // Time varying pixel color\n    vec3 col = 1.0 + cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float r = 0.5;\n    if(uv.x * uv.x + uv.y * uv.y < r * r){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(4,2,0));\n    }\n    \n    float rr =0.65 +0.65*sin(10.0+10.0*sin(iTime));\n    if(uv.x * uv.x + uv.y * uv.y < rr * rr){\n        col = vec3(0,0,0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.1);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3BDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 564]], "test": "untested"}
{"id": "ml3fD4", "name": "periodic asr split-output", "author": "LydianLights", "description": "Periodic attack-sustain-release control functions. See https://www.shadertoy.com/view/dtcBW4. This version separates the attack and release values and returns a vec2, to allow for separate smoothing functions to be applied to the attack and release.", "tags": ["animation", "tween", "timing"], "likes": 3, "viewed": 165, "published": 3, "date": "1701232654", "time_retrieved": "2024-07-30T17:20:05.463357", "image_code": "float f1(float x) {\n    vec2 v = pasr(x, 1.0, 1.0, 1.0, 1.0);\n    return v.x + v.y;\n}\n\nfloat f2(float x) {\n    vec2 v = pasr(x, 1.0, 1.0, 1.0, 1.0);\n    return easeIn(v.x, 3.0) + easeOut(v.y, 3.0);\n}\n\nfloat f3(float x) {\n    vec2 v = pasr(x, 0.2, 0.4, 0.6, 0.8);\n    return v.x + easeIn(v.y, 3.0);\n}\n\nfloat f4(float x) {\n    vec2 v = pasr(x, 0.5, 0.2, 0.5, 1.0);\n    return easeInOut(v.x, 3.0) + easeInOut(v.y, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // set up uvs\n    vec2 uv0 = fragCoord / iResolution.y;\n    float maxX = iResolution.x / iResolution.y;\n    \n    vec2 uv = uv0;\n    float id = floor(uv.y / 0.25);\n    uv.y = mod(uv.y, 0.25);\n    uv *= 4.0;\n    \n    vec2 uvAnim = uv;\n    uvAnim.x -= 4.0 * maxX - 1.0;\n    uvAnim = 2.0 * uvAnim - 1.0;\n    \n    uv.x -= 1.0;\n    uv *= 1.5;\n    \n    vec3 color = vec3(0.1);\n    \n    // grid\n    float gt = 0.01;\n    if (abs(uv.x) < 2.0 * gt) {\n        color = vec3(0.7);\n    } else if (mod(uv.x, 1.0) < gt || abs(uv.y) < gt) {\n        color = vec3(0.3);\n    }\n    \n    // curves\n    float t = 0.5 * iTime;\n    float x = uv.x + t;\n    \n    float valX;\n    float valT;\n    vec3 funcColor;\n    if (id == 3.0) {\n        valX = f1(x);\n        valT = f1(t);\n        funcColor = vec3(1.0, 1.0, 0.3);\n    }\n    else if (id == 2.0) {\n        valX = f2(x);\n        valT = f2(t);\n        funcColor = vec3(0.3, 0.5, 1.0);\n    }\n    else if (id == 1.0) {\n        valX = f3(x);\n        valT = f3(t);\n        funcColor = vec3(0.6, 1.0, 0.6);\n    }\n    else if (id == 0.0) {\n        valX = f4(x);\n        valT = f4(t);\n        funcColor = vec3(1.0, 0.3, 0.3);\n    }\n    \n    \n    if (uvAnim.x > -1.0) {\n        // draw circles\n        float r = 0.1 + 0.7 * valT;\n        float d = step(length(uvAnim), r);\n        if (d > 0.0) {\n            color = vec3(d) * funcColor;\n        } else {\n            color = vec3(0.1);\n        }\n    } else {\n        // draw curves\n        float d = 1.0 - step(0.03, abs(uv.y - valX));\n        if (d > 0.0) {\n            color = d * funcColor;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// periodic attack-sustain-release curve\n// x = input value\n// t1 = attack time\n// t2 = sustain time\n// t3 = release time\n// t4 = reset time\nvec2 pasr(float x, float t1, float t2, float t3, float t4) {\n    float t = mod(x, t1 + t2 + t3 + t4);\n    vec2 value = vec2(0.0);\n    if (t < t1) {\n        value.x = t / t1;\n    } else if (t < t1 + t2) {\n        value.x = 1.0;\n    } else if (t < t1 + t2 + t3) {\n        value.y = 1.0 - (t - t1 - t2) / t3;\n    }\n    return value;\n}\n\nfloat easeIn(float x, float q) {\n    return pow(x, q);\n}\n\nfloat easeOut(float x, float q) {\n    return 1.0 - pow(1.0 - x, q);\n}\n\nfloat easeInOut(float x, float q) {\n    return x < 0.5\n        ? pow(2.0 * x, q) / 2.0\n        : 1.0 - pow(2.0 * (1.0 - x), q) / 2.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3fD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 106, 106, 199], [201, 201, 220, 220, 299], [301, 301, 320, 320, 418], [420, 420, 475, 493, 2092]], "test": "untested"}
{"id": "dtcBW4", "name": "periodic attack-sustain-release", "author": "LydianLights", "description": "Check the common tab. Useful for detailed control of cyclic animations/tweens/etc. You can define an attack time, a sustain time, a release time, and a reset time. Surely has been done before, but I haven't run across it.", "tags": ["animation", "tween", "timing"], "likes": 4, "viewed": 173, "published": 3, "date": "1701226342", "time_retrieved": "2024-07-30T17:20:06.328045", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // set up uvs\n    vec2 uv0 = fragCoord / iResolution.y;\n    float maxX = iResolution.x / iResolution.y;\n    \n    vec2 uv = uv0;\n    float id = floor(uv.y / 0.25);\n    uv.y = mod(uv.y, 0.25);\n    uv *= 4.0;\n    \n    vec2 uvAnim = uv;\n    uvAnim.x -= 4.0 * maxX - 1.0;\n    uvAnim = 2.0 * uvAnim - 1.0;\n    \n    uv.x -= 1.0;\n    uv *= 1.5;\n    \n    vec3 color = vec3(0.1);\n    \n    // grid\n    float gt = 0.01;\n    if (abs(uv.x) < 2.0 * gt) {\n        color = vec3(0.7);\n    } else if (mod(uv.x, 1.0) < gt || abs(uv.y) < gt) {\n        color = vec3(0.3);\n    }\n    \n    // curves\n    float t = 0.5 * iTime;\n    float x = uv.x + t;\n    \n    float valX;\n    float valT;\n    vec3 funcColor;\n    if (id == 3.0) {\n        valX = pasr(x, 1.0, 1.0, 1.0, 1.0);\n        valT = pasr(t, 1.0, 1.0, 1.0, 1.0);\n        funcColor = vec3(1.0, 1.0, 0.3);\n    }\n    else if (id == 2.0) {\n        valX = pasr(x, 0.2, 0.4, 0.6, 0.8);\n        valT = pasr(t, 0.2, 0.4, 0.6, 0.8);\n        funcColor = vec3(0.3, 0.5, 1.0);\n    }\n    else if (id == 1.0) {\n        valX = pasr(x, 0.3, 1.0, 0.3, 0.0);\n        valT = pasr(t, 0.3, 1.0, 0.3, 0.0);\n        funcColor = vec3(0.6, 1.0, 0.6);\n    }\n    else if (id == 0.0) {\n        valX = pasr(x, 1.0, 1.0, 1.0, 1.0);\n        valX = valX * valX * valX;\n        valT = pasr(t, 1.0, 1.0, 1.0, 1.0);\n        valT = valT * valT * valT;\n        funcColor = vec3(1.0, 0.3, 0.3);\n    }\n    \n    \n    if (uvAnim.x > -1.0) {\n        // draw circles\n        float r = 0.1 + 0.7 * valT;\n        float d = step(length(uvAnim), r);\n        if (d > 0.0) {\n            color = vec3(d) * funcColor;\n        } else {\n            color = vec3(0.1);\n        }\n    } else {\n        // draw curves\n        float d = 1.0 - step(0.03, abs(uv.y - valX));\n        if (d > 0.0) {\n            color = d * funcColor;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// see https://www.shadertoy.com/view/ml3fD4 for a version with separate attack and release return values,\n// allowing separate smoothing functions to be applied to each\n\n// periodic attack-sustain-release curve\n// x = input value\n// t1 = attack time\n// t2 = sustain time\n// t3 = release time\n// t4 = reset time\nfloat pasr(float x, float t1, float t2, float t3, float t4) {\n    float t = mod(x, t1 + t2 + t3 + t4);\n    if (t < t1) {\n        return t / t1;\n    } else if (t < t1 + t2) {\n        return 1.0;\n    } else if (t < t1 + t2 + t3) {\n        return 1.0 - (t - t1 - t2) / t3;\n    } else {\n        return 0.0;\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 73, 1918]], "test": "untested"}
{"id": "DtcfWN", "name": "Dancing Vaporwave Fern", "author": "Xibanya", "description": "It's as simple as pushing squares", "tags": ["bezier", "fern", "90s", "plant", "vaporwave"], "likes": 8, "viewed": 208, "published": 3, "date": "1701216651", "time_retrieved": "2024-07-30T17:20:07.093997", "image_code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00175;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.9), vec4(blur, 1.)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.025;\n    col.rgb -= scanline;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I was inspired by 4rknova's shader to see if I \n// could animate objects as if they were anchored to\n// a point in on a curve. Most of the curve-drawing\n// code is adapted from https://www.shadertoy.com/view/ll23Wt\n// ------------------------------------------\n\n// colors used to draw the plant\n#define LEAF vec3(0.5, 0.6, 0.5)\n#define LEAF_TIP vec3(0.68, .7, 0.97)\n#define LEAF_OUTLINE vec3(0.7, .75, 0.95)\n// if progress along curve is less than this\n// then the plant should be drawn even if\n// outside the triangle\n#define THRESH 0.5\n\n// ------------------------------------------------\n// bezier functions from \n// Interpolation: Bezier, Cubic\n// by 4rknova\n// https://www.shadertoy.com/view/ll23Wt\n#define STEPS  25.\n#define STROKE .9\n#define LEAF_COUNT 19.\n#define EPS    .01\n\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n// ----------------------------------------------------\n\n// all sdf functions from iq\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nvec2 opRep(vec2 p, vec2 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb)\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n//https://iquilezles.org/articles/functions\nfloat polyImpulse( float k, float n, float x )\n{\n    return (n/(n-1.0))*pow((n-1.0)*k,1.0/n)*x/(1.0+k*pow(x,n));\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        (8000. / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\n\n\nfloat Audio(float x)\n{\n    return texture(iChannel0, vec2(x, 0.0)).r;\n}\n\n/////////////////////////\n\nfloat Leaf(vec2 uv, float radius, float tip, float pos)\n{\n    vec2 size = mix(vec2(4.), vec2(.75, 0.7), polyImpulse(1.75, 1.75, pos));\n    vec2 p = uv * size;\n    p += vec2(0., tip * 0.5);\n    float leaf = sdEgg(p, radius, tip);\n    leaf = min(leaf, sdEgg(-p, radius, tip));\n    return leaf;\n}\nfloat Margin(float sdf)\n{\n    return clamp(1. - smoothstep(0.005, 0.01, abs(sdf)), 0.0, 1.0);\n}\nfloat AStep(float d)\n{\n    return smoothstep(0.9, 1.01, d);\n}\nfloat MStep(float d)\n{\n    return 1. - clamp(smoothstep(-0.005, 0.0, d), 0., 1.);\n}\nvec2 Rotate2D( vec2 p, float theta )\n{\n    float co = cos( theta );\n    float si = sin( theta );\n    return vec2( co * p.x + si * p.y,\n                -si * p.x + co * p.y );\n}\nfloat LeafTier(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d, \n    float pos, out vec4 col)\n{\n\n    float bass = smoothstep(0.25, 1., Audio(0.1));\n    float mid = smoothstep(0.5, 0.7, Audio(0.5));\n    \n    vec2 end1 = interpolate(a, b, c, d, 0.);\n    vec2 p = interpolate(a, b, c, d, pos);\n    float radius = 0.04;\n    float tip = -0.45;\n    vec2 leafPos = uv - p;\n    float r = dot(leafPos, end1);\n    leafPos = Rotate2D(leafPos, -1. + r / max(0.2, pos));\n    float leaf = Leaf(leafPos, radius, tip, pos);\n    leafPos = Rotate2D(\n        leafPos, 2. - (cos(iTime * 0.5) * r / max(0.2, pos)));\n    leaf = min(leaf, Leaf(leafPos, radius, tip, pos));\n    float maxDist = .4 - min(.4, mid);\n    float dist = distance(uv, p);\n    dist = clamp(dist/maxDist, 0., 1.);\n    vec3 tipCol =  pow(pow(LEAF_TIP, vec3(1. - bass)), vec3(1. + mid));\n    col.rgb = mix(LEAF, tipCol, dist);\n    col.rgb = mix(col.rgb, LEAF_OUTLINE, Margin(leaf) * dist);\n    col.a = step(pos, THRESH);\n    return sharpen(leaf, EPS * 1.);\n}\n// leafCol.a used to determine if color should be \n// drawn outside the triangle container\nfloat Branch(in vec2 uv, out vec4 leafCol)\n{\n    float bass = smoothstep(0.25, 0.9, Audio(0.1));\n    float treb = smoothstep(0.4, 0.8, Audio(0.9));\n    \n    vec2 a = vec2(-.5 * (1. + treb * 0.5), .2 * (1. + bass * 0.2)) * 1. + (cos(-iTime * 0.5 + bass * 0.1) * 0.25);\n    vec2 b = vec2( .00, .75) * (cos(-iTime * 0.2 * (1. + bass * 0.05)) * 0.5 + 0.5);\n    vec2 c = vec2( .75,-.75 + treb * 1.); \n    vec2 d = vec2( .0, -1.);\n\n    float leaf = 0.;\n    float stem = 0.;\n    leafCol.a = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        // if the stem is higher than the threshold, want\n        // to draw it even if it is outside the triangle\n        leafCol.a = stem > l? leafCol.a : step(i / STEPS, THRESH);\n        stem = max(stem, l);\n    }   \n    leaf = stem;\n    leafCol.rgb = LEAF * 0.9 * stem;\n    for (float i = 0.1; i < LEAF_COUNT; i++)\n    {\n        vec4 nextCol;\n        float nextLeaf = LeafTier(uv, a, b, c, d, 0.05 * i, nextCol);\n        leafCol = mix(leafCol, nextCol, nextLeaf);\n        leaf = max(leaf, nextLeaf);\n    }\n    return leaf;\n}\nfloat IsBlack(vec3 col)\n{\n    return step(abs(col.r + col.g + col.b), 0.);\n}\nfloat IsWhite(vec3 col)\n{\n    return step(1., (col.r + col.g + col.b) / 3.);\n}\nvec3 Dodge(vec3 col, vec3 effect)\n{\n    float isBlack = IsBlack(effect);\n\tvec3 inverted = (1. - effect) * (1. - isBlack) + isBlack;\n\tfloat anyWhite = min(IsWhite(effect) + IsWhite(col), 1.);\n\treturn clamp(col / inverted, 0., 1.) * (1. - anyWhite) + anyWhite;\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\n\nfloat Stars(vec2 uv, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y));\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / 8000.0);\n        m = m + sparkle * (sin((8000.0 + p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 0.8 + vec2(0.0, -0.1);\n\n    vec2 checkUV = opRepLim(uv * 10., vec2(2., 0.), \n        vec2(-10., 0.), vec2(10., 1.));\n    float check = sdBox(checkUV, vec2(0.5));\n    checkUV = opRepLim(uv * 10. + vec2(1., 1.), \n        vec2(2., 0.), vec2(-10., 0.), vec2(10., 1.));\n    check = min(check, sdBox(checkUV, vec2(0.5)));\n    float notChat = uv.x < 0.75? 1. : 0.;\n    vec3 bg = vec3(0.);\n    \n    float bass = smoothstep(0.4, 0.9, Audio(0.2));\n    float specks = smoothstep(0.05, 0.1, (Stars(uv * 0.5 / (1. - bass * 0.2), 50.)));\n    vec3 specCol = mix(vec3(1.), vec3(0.89, 0.435, 0.9), bass);\n    bg = clamp(bg + specCol * specks, 0., 1.);\n\n    //uv.x -= 0.15;\n    vec3 low = vec3(.8, .035, .96);\n    vec3 high = vec3(.39, .69, .94);\n    vec3 col = mix(low, high, clamp(uv.y + 1., 0., 1.));\n    vec4 leafCol = vec4(col, 0.);\n    float branch = AStep(Branch(uv, leafCol));\n    col = mix(col, leafCol.rgb, branch);\n    \n    \n    vec2 triUV = uv * 1.5 + vec2(0., 0.2);\n    triUV = Rotate2D(triUV, -iTime * 0.05);\n    float fullTri = sdEquilateralTriangle(triUV);\n    float tri = abs(fullTri) - 0.02;\n    vec3 dodge = Dodge(col, col);\n    col = mix(col, dodge, MStep(tri));\n    col = mix(col, bg, 1. - MStep(fullTri));\n    col = mix(col, leafCol.rgb, clamp(branch * leafCol.a, 0., 1.));\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [{"id": 35404, "src": "https://soundcloud.com/blankbanshee/wavestep?si=00eefcdf8412495e805a7e4d25f111c9", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 129], [130, 130, 166, 166, 361], [362, 362, 419, 419, 1575]], "test": "untested"}
{"id": "cl3BD4", "name": "Shadermine222", "author": "hcnery08", "description": "daewd", "tags": ["radnnom"], "likes": 3, "viewed": 147, "published": 3, "date": "1701208263", "time_retrieved": "2024-07-30T17:20:07.871918", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0., 0., 0.);\n    vec3 b = vec3(1., 1., 1.);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.,0.,0.);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * sin(iTime*0.5)*1.2) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 8.);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3BD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 194], [196, 196, 253, 253, 753]], "test": "untested"}
{"id": "dldBDH", "name": "Fork experiment mds2 989", "author": "mds2", "description": "experiment inspired by the las vegas sphere. I wanted to see what it would look like if I rendered a scene from the *inside* of a sphere and wrapped it as a texture on the outside of a sphere.\n\nIt's not half bad. Works ok from near-ground viewpoints.", "tags": ["raycast", "experiment", "projection"], "likes": 2, "viewed": 168, "published": 3, "date": "1701204973", "time_retrieved": "2024-07-30T17:20:08.914131", "image_code": "#define MAXDIST 40.0\n\nfloat sdf(in vec3 p) {\n  return length(p) - 1.;\n}\n\nvec3 surfnorm(in vec3 p) {\n  return normalize(p);\n}\n\nfloat raycast(in vec3 orig, in vec3 dir) {\n  float accum = 0.0;\n  for (int i = 0; i < 50; ++i) {\n    vec3 p = orig + accum * dir;\n    float dist = sdf(p);\n    if (abs(dist) < 1.0e-4) {\n      return accum;\n    }\n    accum += 0.95 * dist;\n    if (accum > MAXDIST) {\n      return accum;\n    }\n  }\n  return MAXDIST + 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/min(iResolution.y, iResolution.x);\n    \n    vec3 orig = vec3(0.0, 0.0, -2.0);\n    vec3 dir = normalize(vec3(uv, 1.2));\n\n    float yawAngle = 3.0 * 3.141592654 * iMouse.x/iResolution.x;\n    float pitchAngle = 0.5 * 3.141592654 * (iMouse.y / iResolution.y - 0.5);\n    \n    float ct = cos(yawAngle);\n    float st = sin(yawAngle);\n    \n    mat3 yaw = mat3(ct, 0.0, st, 0.0, 1.0, 0.0, -st, 0.0, ct);\n    \n    ct = cos(pitchAngle);\n    st = sin(pitchAngle);\n    \n    mat3 pitch = mat3(1.0, 0.0, 0.0, 0.0, ct, st, 0.0, -st, ct);\n    \n    orig = yaw * pitch * orig;\n    dir = yaw * pitch * dir;\n\n    float dist = raycast(orig, dir);\n    \n    vec3 col = texture(iChannel1, dir).rgb;\n    \n    if (dist < MAXDIST) {\n      col = vec3(0.0);\n      vec3 p = orig + dist * dir;\n      vec3 n = surfnorm(p);\n      vec3 bounce = normalize(reflect(dir, n));\n      col += 0.25 * texture(iChannel2, bounce).rgb;\n      \n      \n      const float pi = 3.141592654;\n      // float cy = sqrt(1.0 - min(1.0, 4.0 * uv.y * uv.y));\n      vec3 lookup = n.zxy;\n      float cy = sqrt(1.0 - min(1.0, lookup.z*lookup.z));\n      vec2 tex_uv = vec2(atan(lookup.y/cy, lookup.x/cy)/(2.0*pi), 0.5 * lookup.z);\n      tex_uv = 0.5 + tex_uv;\n      col += 0.8 * texture(iChannel0, tex_uv).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define INTENSE_FLASH 1\n\n#define MAX_DIST 8.0\n\n#define SKY_BRITE 0.6\n\n#define CRINKLY_SHIP 0 // set to 1 to give the ship some texture\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat falloff(in float x, in float range) {\n    float h = smoothstep(range, 0.0, 1.0/x);\n    return h * 0.1 * range / s_max(0.1 * range, 1.0/x, 0.05 * range);\n}\n\nvec3 perturb2(in vec3 loc) {\n    return loc;\n}\n\nfloat vehicle_sdf2(in vec3 loc) {\n    float ball1 = length(loc - vec3(0.0, -1.8, 0.0)) - 2.0;\n    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.07, 0.0)) - 0.2;\n    float result = s_min(disc, max(ball3, -loc.y), 0.1);\n    float mult = 1.0; // texture(iChannel1, loc).r;\n#if CRINKLY_SHIP    \n    mult = 1.0 + 0.95 * mult;\n#else\n    mult = 1.0 + 0.95 * mult * smoothstep(0.025, 0.05, result);    \n#endif\n    return result * mult;\n}\n\nvec3 vehicle_sdf2_grad(in vec3 loc) {\n    float dist = vehicle_sdf2(perturb2(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle2(in vec3 orig, in vec3 dir, out float sumdist) {\n    vec3 p = orig;\n    float accum = 0.0;\n    sumdist = 0.0;\n    for (int i = 0; i < 256; ++i) {\n        float dist = vehicle_sdf2(p);\n        // mindist = min(dist, mindist);\n    \tfloat remaining = 0.2 * dist;\n        sumdist += remaining / max(1.0e-3, abs(dist));\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb2(p);\n        if (remaining < 1.0e-3) {\n            return accum;\n        }\n        if (accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce2(in vec3 pt, in vec3 dir, out float edge_term) {\n    vec3 norm = normalize(vehicle_sdf2_grad(pt));\n    edge_term = smoothstep(0.7, 0.3, abs(dot(normalize(dir), norm)));\n    return normalize(reflect(dir, norm));\n}\n\n\nvec3 skyColor(in vec3 dir) {\n  return vec3(1.0); // TODO : fix\n  }\n\n", "buffer_a_code": "#define BLOCKSIZE 0.7\n\n#define EXTENT 15.0\n\n#define MULTI_SAMPLE 2 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nfloat waffle_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n    float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.173, 0.131)), 1.0);\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - vec3(0.05, 0.1 + 1.0 * samp, 0.05));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.5 - samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\n\nvec4 getBackground(in vec3 ray_orig, in vec3 ray_dir) {\n\n    vec4 color_mul = vec4(1.0);\n\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    \n    return vec4(subsurface, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n\nvec4 castRayUFO(in vec3 ray_orig, in vec3 ray_dir, in float time) {\n    \n    float wiggle = abs(mod(0.2 * time, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    // ray_dir = twist * ray_dir;\n    // ray_orig = twist * ray_orig;\n    wiggle = 0.1 * sin(time);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist = mat3(ct, st, 0.0,\n                 -st, ct, 0.0,\n                 0.0, 0.0, 1.0) * twist;\n    wiggle = 0.1 * sin(0.71 *time + 1.3);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist *= mat3(1.0, 0.0, 0.0,\n                  0.0, ct, st,\n                 0.0, -st, ct) * twist;\n\n    // ray_dir = twist * ray_dir;\n    // ray_orig = twist * ray_orig;\n    \n    vec3 orig_offset = vec3(0.0, 0.2, 1.5) -\n        sin(vec3(4.2, 1.2, 3.4) * time) * vec3(0.5, 0.1, 0.2);\n    float closeness = MAX_DIST;\n    float d = cast_to_vehicle2(twist * (ray_orig - camera) - orig_offset, twist * ray_dir, closeness);\n    \n    vec3 ray_mul = vec3(1.0);\n    \n    if (d > MAX_DIST) {\n        orig_offset = vec3(0.0, 0.2, -2.1) -\n            sin(vec3(4.2, 1.2, 3.4) * time) * vec3(0.5, 0.1, 0.2);\n        float closeness2 = MAX_DIST;\n        d = cast_to_vehicle2(twist * (ray_orig - camera) - orig_offset, twist * ray_dir, closeness2);\n        closeness += closeness2;\n    }\n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        float edginess = 0.0;\n        ray_dir = transpose(twist) * get_bounce2(twist * (pt - camera) - orig_offset, twist * ray_dir, edginess);\n        ray_mul = mix(vec3(1.0, 0.9, 0.85), ray_mul, 1.0); // edginess);\n        ray_orig = pt;\n    }\n\n    vec3 thump = 0.5 + 0.5 * sin(vec3(0.1, 0.21, 0.33) * time);\n    thump = smoothstep(0.5, 1.0, thump);\n#if INTENSE_FLASH\n    thump *= 0.5 + 0.75 * smoothstep(vec3(0.0), vec3(1.0), thump);\n#else\n    thump *= 0.85 + 0.15 * smoothstep(vec3(0.0), vec3(1.0), thump);\n#endif\n    float darken = 0.15 * (1.0 + 3.0 * smoothstep(1.5, 0.5, dot(thump, vec3(1.0))));\n    return vec4(1.0 * darken * ray_mul * getBackground(ray_orig, ray_dir).rgb +\n                (0.25 + 1.75 * smoothstep(0.05, 0.8, thump))\n                * falloff(closeness, 0.5), 1.0);\n}\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy;\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    \n    const float pi = 3.141592654;\n    float cy = sqrt(1.0 - min(1.0, 4.0 * uv.y * uv.y));\n    vec3 ray_dir = vec3(cos(2.0 * pi * uv.x) * cy,\n        sin(2.0 * pi * uv.x) * cy,\n        2.0 * uv.y);\n    ray_dir = ray_dir.yzx;\n    ray_dir = dir_mat * ray_dir;\n    return castRayUFO(ray_orig, ray_dir, iTime); // getBackground(ray_orig, ray_dir);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.025 * iTime);\n    float s_theta = sin(0.025 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 71], [73, 73, 99, 99, 124], [126, 126, 168, 168, 445], [448, 448, 505, 555, 1917]], "test": "untested"}
{"id": "mltBWH", "name": "Reaction Diffusion asteriskman2", "author": "asteriskman", "description": "Simple Gray-Scott reaction diffusion simulation.", "tags": ["simplediffusion"], "likes": 2, "viewed": 157, "published": 3, "date": "1701202976", "time_retrieved": "2024-07-30T17:20:09.767848", "image_code": "//Simple color mapping of chemical b density\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n    \n    //colors to interpolate between assuming b density doesn't get much above 0.5\n    vec4 c0 = vec4(0.2, 0., 0.2, 1.);\n    vec4 c1 = vec4(0., 1.9, 0.1, 1.);\n    \n    //draw chemical b density\n    fragColor = (1. - fragColor.g) * c0 + fragColor.g * c1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n  Simulate reaction diffusion based on https://www.karlsims.com/rd.html.\n  Value of chemical A is in r channel and chemical B is in g channel.\n  Initial value is a small, slightly random, circle of B in the center.\n*/\n//reaction diffusion constants\n#define DA 1.0\n#define DB 0.5\n#define F 0.055\n#define K 0.062\n#define CONVC -1.\n#define CONVA 0.2\n#define CONVD 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //uv to use with the buffer\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0, uv);\n    \n    //uv distance to the \"next pixel\"\n    float diffx = 1. / iResolution.x;\n    float diffy = 1. / iResolution.y;\n    \n    if (iTime < 0.2) {\n      //initialize with some slightly rnd data in the middle\n      vec4 v = texture(iChannel1, vec2(mod((mod(fragCoord.x,  64.)) / 64. + iDate.w, 1.), mod(mod(fragCoord.y, 64.) / 64. + iDate.z, 1.)));\n      float dx = fragCoord.x - iResolution.x * 0.5;\n      float dy = fragCoord.y - iResolution.y * 0.5;\n      float d = sqrt(dx * dx + dy * dy);\n      fragColor = vec4(1., d < 10. ? (v.r / 2.) : 0., 0., 1.0);\n    } else {\n      //take reaction diffusion step based on https://www.karlsims.com/rd.html\n      //chemical A is in r channel and chemical B is in b channel\n      float a = draw.r;\n      float b = draw.g;\n      //unroll convolution with \n      /*\n        | convD, convA, convD |\n        | convA, convC, convA |\n        | convD, convA, convD |\n      */\n      //assuming adjacent pixels are diff uv away\n      float la = CONVC * a +\n        CONVA * texture(iChannel0, uv + vec2(-diffx,     0.)).r +\n        CONVA * texture(iChannel0, uv + vec2(+diffx,     0.)).r +\n        CONVA * texture(iChannel0, uv + vec2(0.    , -diffy)).r +\n        CONVA * texture(iChannel0, uv + vec2(0.    , +diffy)).r +\n        CONVD * texture(iChannel0, uv + vec2(-diffx, -diffy)).r +\n        CONVD * texture(iChannel0, uv + vec2(+diffx, +diffy)).r +\n        CONVD * texture(iChannel0, uv + vec2(-diffx, +diffy)).r +\n        CONVD * texture(iChannel0, uv + vec2(+diffx, -diffy)).r;        \n      float lb = CONVC * b +\n        CONVA * texture(iChannel0, uv + vec2(-diffx,     0.)).g +\n        CONVA * texture(iChannel0, uv + vec2(+diffx,     0.)).g +\n        CONVA * texture(iChannel0, uv + vec2(0.    , -diffy)).g +\n        CONVA * texture(iChannel0, uv + vec2(0.    , +diffy)).g +\n        CONVD * texture(iChannel0, uv + vec2(-diffx, -diffy)).g +\n        CONVD * texture(iChannel0, uv + vec2(+diffx, +diffy)).g +\n        CONVD * texture(iChannel0, uv + vec2(-diffx, +diffy)).g +\n        CONVD * texture(iChannel0, uv + vec2(+diffx, -diffy)).g;\n      float abb = a * b * b;\n      float da = DA * la - abb + F * (1. -a);\n      float db = DB * lb + abb - (K + F) * b;\n      fragColor.r = a + da;\n      fragColor.g = b + db;\n      fragColor.b = 0.;\n    }\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 102, 102, 448]], "test": "untested"}
{"id": "ctdfDH", "name": "Fork Mandelbulb Nov2023", "author": "amaxwell", "description": "Learning how mandelbulb works.", "tags": ["mandelbrot", "sdf", "mandelbulb"], "likes": 0, "viewed": 166, "published": 3, "date": "1701200662", "time_retrieved": "2024-07-30T17:20:10.628547", "image_code": "// refactored from https://www.shadertoy.com/view/dltBzM\n\nconst int bulbIterations = 4;\n\nfloat mandelbulbSDF(vec3 position) {\n    float bulbPower = 4.0 + iTime / 100.0;\n    vec3 z = position;\n    float dr = 1.0;\n    float radius = 0.0;\n\n    for (int i = 0; i < bulbIterations; i++) {\n        radius = length(z);\n        if (radius > 2.0) break;\n\n        float theta = acos(z.z / radius) * bulbPower;\n        float phi = atan(z.y, z.x) * bulbPower;\n        dr = pow(radius, bulbPower - 1.0) * bulbPower * dr + 1.0;\n        z = position + pow(radius, bulbPower) * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    }\n    return 0.5 * log(radius) * radius / dr;\n}\n\nvec3 rotate(vec3 vector, vec2 angle) {\n    vector.yz = cos(angle.y) * vector.yz + sin(angle.y) * vec2(-1, 1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz + sin(angle.x) * vec2(-1, 1) * vector.zx;\n    return vector;\n}\n\nvec3 rayMarch(vec2 fragCoord, vec2 angle) {\n    vec3 rayDirection = rotate(normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.x, 1)), angle);\n    vec3 startPosition = rotate(vec3(0, 0, -3), angle);\n    for (int i = 0; i < 128; i++) {\n        float distance = mandelbulbSDF(startPosition);\n        if (distance < 0.001) break;\n        startPosition += rayDirection * distance;\n    }\n    return startPosition;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 angle = (0.5 - iMouse.xy / iResolution.xy) * 5.0;\n    vec3 position = rayMarch(fragCoord, angle);\n\n    const vec2 ep = vec2(1, -1) * 0.000001;\n    vec3 normal = normalize(ep.xyy * mandelbulbSDF(position + ep.xyy) + \n                            ep.yyx * mandelbulbSDF(position + ep.yyx) + \n                            ep.yxy * mandelbulbSDF(position + ep.yxy) + \n                            ep.xxx * mandelbulbSDF(position + ep.xxx));\n\n    vec3 ambientLight = vec3(sin(normal.x), sin(normal.y), sin(normal.z));\n    vec3 lightDirection = normalize(rotate(vec3(0, 0, -3), angle) - position);\n    float lightIntensity = max(dot(normal, -lightDirection), dot(normal, lightDirection));\n\n    fragColor.rgb = 0.7 * lightIntensity + pow(lightIntensity, 128.0) + ambientLight * 0.3;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 125, 125, 677], [679, 679, 717, 717, 904], [906, 906, 949, 949, 1328], [1330, 1330, 1385, 1385, 2169]], "test": "untested"}
{"id": "mldBD8", "name": "basic polka dots template", "author": "elenzil", "description": "utility shader for polka dots. feel free to customize or tweak parameters to get different polka dots. sorry for messy code!        :D", "tags": ["polkadots"], "likes": 3, "viewed": 202, "published": 3, "date": "1701194802", "time_retrieved": "2024-07-30T17:20:11.471294", "image_code": "void mainImage_spinners( out vec4 O, vec2 U )\n{\n    float r = 20.,\n          p =  6.,\n          c = r + p,\n          t = 2.*iTime;\n    vec2 I = floor(U/c/2.);\n    if ( I == floor( vec2(13,7)*fract(1e4*sin(vec2(71,-97)*floor(t)))))\n        U += 6.*cos(6.283*2.*t+vec2(0,11)) * (.5-.5*cos(6.283*t));\n    O = vec4( 1. - ( length( mod(U , c+c ) - c ) - r ) /2. ); \n}\n\nvoid mainImage_flashers( out vec4 O, vec2 U )\n{\n    float r = 20.,\n          p =  6.,\n          c = r + p,\n          t = 3.*iTime;\n    vec2 I = floor(U/c/2.);\n    if ( I == floor( vec2(13,7)*fract(1e4*sin(vec2(71,-97)*floor(t)))))\n        r += 3.-3.*cos(6.283*t);\n    O = vec4( 1. - ( length( mod(U , c+c ) - c ) - r ) /2. ); \n}\n\nvoid mainImage_plain( out vec4 RGBA, in vec2 XY )\n{\n    float radius  = 20.0;\n    float padding =  5.0;\n    float cell    = (radius + padding) * 2.0;\n    float eps     = 2.0;\n\n    vec2  xy   = mod(XY - iResolution.xy / 2.0 + cell / 2.0, vec2(cell)) - cell / 2.0;\n    float dist = length(xy) - radius;\n    float c    = smoothstep(eps, 0.0, dist);\n    \n    RGBA       = vec4(c);\n    \n}\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    switch ((int(iTime) / 10) % 3) {\n        default:\n            mainImage_plain(RGBA, XY);\n            break;\n        case 1:\n            mainImage_flashers(RGBA, XY);\n            break;\n        case 2:\n            mainImage_spinners(RGBA, XY);\n            break;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 362], [364, 364, 411, 411, 692], [694, 694, 745, 745, 1077]], "test": "untested"}
{"id": "dldfW8", "name": "back off, normals - 2", "author": "elenzil", "description": "TL: No normal adjustment\nTR: spalmer's reflection approach\nBL: FrontFacing Adjustment\nBR: Normal Backoff\n\nextension of [url]https://www.shadertoy.com/view/mlVcWV[/url] .", "tags": ["raymarching", "normals", "artifacts"], "likes": 9, "viewed": 204, "published": 3, "date": "1701192709", "time_retrieved": "2024-07-30T17:20:12.290105", "image_code": "// Fork of \"back off, normals.\" by elenzil. https://shadertoy.com/view/mlVcWV\n// 2023-11-28 17:12:59\n\n/*\n\n    back off, normals\n    -----------------\n    \n    A simple technique which improves the glittery pop on some sharp edges.\n    The idea is that when choosing a point at which to sample the normal\n    of the SDF, back up a little along the ray instead of using the\n    march point closest to the surface.\n    \"A little\" is on the order of your \"close enough\" epsilon for marching.\n    \n    This doesn't eliminate all 'popping' for me,\n    but it's a trivial change and it eliminates some of it.\n    \n    Theory: IANARME˟, but the thought I had was that right at these\n    surface boundaries the gradient is discontinuous,\n    so sample it 'farther away' from the surface.\n    Going 'farther away' by moving backwards along the ray seems like\n    a safe direction to move in, because we just raymarched along the ray,\n    so we know the SDF is getting larger in that direction.\n    \n    Orion Elenzil 20231122\n    \n    \n    ˟ i am not a ray marching expert\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gSceneCenterY  = 3.0;\nconst float gFOVFac        = 0.3;\n\nconst uint  gMarchMaxSteps = 150u;\nconst float gMarchEps      =   0.002;\nconst float gNormEps       = gMarchEps * 0.1;\n      float gNormBackoff   = gMarchEps * 1.0;\n      bool  gIsUpperHalf;\n      bool  gIsRightHalf;\n\nconst vec3  gLightDir      = normalize(vec3(3.0, 0.1, 4.0));\nconst vec3  gAmbient       = v1 * 0.05;\nconst float reflectAmt     = 0.05;\n      float gT;\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    return mix(vec3(1.0, 0.9, 0.8), vZ * 0.5, pow(rd.y, 0.3));\n}\n\nvec3 albedo(in vec3 p) {\n    if (p.y < gMarchEps) {\n        return v1;\n    }\n    if (p.x > 0.0) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else {\n        return vec3(0.0, 1.0, 1.0);\n    }\n}\n\nfloat sdScene(in vec3 p) {\n    float d = 1e9;\n    \n    float rad = gSceneCenterY;\n    \n    p.xz *= rot2(gT);\n    \n    vec3 q = p - vY * rad;\n    opUnn(d, sdCyl   (q.zy, rad));\n    opSub(d, sdCyl   (q.zy, rad * 0.8));\n    opInt(d, sdSphere(q   , rad * 2.5));\n    opSub(d, sdShell (q   , rad * 2.0, 1.0));\n    opSub(d, sdShell (q   , rad * 1.5, 1.0));\n    opSub(d, sdShell (q   , rad * 1.0, 1.0));\n    \n    return d;\n}\n\n// ∇(sdScene())\nvec3 gradScene(in vec3 p) {\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * gNormEps) - d,\n        sdScene(p + vY * gNormEps) - d,\n        sdScene(p + vZ * gNormEps) - d\n    );\n}\n\nvec3 normScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    \n    float t = 0.0;\n    for (uint n = 0u; n < gMarchMaxSteps; ++n) {\n        vec3  p = ro + rd * t;\n        float d = sdScene(p);\n        if (d < gMarchEps) {\n            // a hit\n            return t;\n        }\n        t += d;\n        if (t > 1e2) {\n            // too far away\n            return 1e9;\n        }\n    }\n    \n    return 1e9;\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd) {\n    float t = 1e9;\n    opUnn(t, march(ro, rd));\n    opUnn(t, rayVsPlane(ro, rd, vY, 0.0));\n    return t;\n}\n\nvec3 runRaySegment(in vec3 ro, in vec3 rd, out vec3 p, out vec3 n) {\n    float t = rayVsScene(ro, rd);\n    \n    if (t > 1e4) {\n        p = v1 * 1e9;\n        return sky(ro, rd);\n    }\n    \n    vec3 rgb = v0;\n    \n    p        = ro + rd * t;\n    // floor is not part of SDF, so we cheat\n    if (p.y < gMarchEps) {\n        n = vY;\n    }\n    else {\n    \n    \n    \n    \n    \n    \n    \n    \n        ////////////////////////////////////////////////////////////////\n        // NORMAL CORRECTION HERE.\n        //\n        //\n        bool useFrontFacingNormal = !gIsUpperHalf && !gIsRightHalf;\n        bool useNormalBackoff     = !gIsUpperHalf &&  gIsRightHalf;\n        bool useNormalReflection  =  gIsUpperHalf &&  gIsRightHalf;\n        \n        vec3 normalSamplePoint = p;\n        \n        if (useNormalBackoff) {\n            normalSamplePoint -= rd * gNormBackoff;\n        }\n        \n        n = normScene(normalSamplePoint);\n        \n        if (useFrontFacingNormal) {\n            n *= sign(dot(n,-rd));\n        }\n        \n        if (useNormalReflection) {\n            // spalmer's suggestion from https://shadertoy.com/view/mlVcWV\n            if (dot(n, rd) > 0.) {\n                n = reflect(n, rd);\n            }\n        }\n        //\n        //\n        ////////////////////////////////////////////////////////////////\n        \n        \n        \n    }\n    vec3 alb = albedo(p);\n    \n    rgb += gAmbient * alb;\n    float diffuseAmt = max(0.0, dot(n, gLightDir));\n    if (diffuseAmt > 0.0) {\n        float tShadow = rayVsScene(p + n * gMarchEps * 2.0, gLightDir);\n        if (tShadow > 1e4) {\n            rgb += alb * diffuseAmt;\n        }\n    }\n    \n    return rgb;\n}\n\nvec3 runRay(in vec3 ro, in vec3 rd) {\n    uint bouncesLeft = 4u;\n    \n    float rayAmt = 1.0;\n    \n    vec3 rgb = v0;\n    \n    while (bouncesLeft > 0u) {\n        vec3 p, n;\n        \n        vec3 c = runRaySegment(ro, rd, p, n);\n        \n        if (p.x < 1e8) {\n\n            rgb += c * rayAmt * (1.0 - reflectAmt);\n\n            // no fresnel\n            rayAmt *= reflectAmt;\n            ro = p + n * gMarchEps * 2.0;\n            rd = reflect(rd, n);\n\n            bouncesLeft -= 1u;\n        }\n        else {\n            rgb += c * rayAmt;\n            bouncesLeft = 0u;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gIsUpperHalf = XY.y * 2.0 > RES.y;\n    gIsRightHalf = XY.x * 2.0 > RES.x;\n    \n    vec2 xy = XY;\n    // split into four copies\n    vec2 halves = vec2(bvec2(gIsRightHalf, gIsUpperHalf));\n    xy = xy * 2.0 - RES * halves;\n    \n    \n    if (false) {\n        const float pixelate = 5.0;\n        xy = round(XY / pixelate) * pixelate;\n    }\n\n    gT     = iTime * pi / 30.0;\n    const float zoom = 1.0;\n    vec2 p = (xy        * 2.0 - RES) / MINRES / zoom;\n    vec2 m = (iMouse.xy * 2.0 - RES) / MINRES / zoom;\n    if (iMouse.x < 20.0) {\n        m = vec2(-0.8, 0.5);\n    }\n    \n    // compose ray\n    vec3 lf = vec3(0.0, 5.0, 20.0);\n    lf.yz  *= rot2(smoothstep(1.0, -1.0, m.y) - 0.2);\n    lf.xz  *= rot2(smoothstep(1.0, -1.0, m.x) * pi * 3.0);\n    vec3 lt = vY * gSceneCenterY;\n    vec3 fw = normalize(lt - lf);\n    vec3 rt = normalize(cross(fw, vY));\n    vec3 up = cross(rt, fw);\n    vec3 ro = lf;\n    vec3 rd = normalize(fw + (rt * p.x + up * p.y) * gFOVFac);\n    \n    vec3 rgb = runRay(ro, rd);\n    \n    float splitsD = 1e9;\n    opUnn(splitsD, abs(RES.y / 2.0 - XY.y));\n    opUnn(splitsD, abs(RES.x / 2.0 - XY.x));\n    rgb = mix(rgb, vY * 0.0, smoothstep(3.0, 2.0, splitsD));\n    \n    RGBA.rgb = pow(rgb, vec3(1.0 / 1.8));\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "const vec3  vX = vec3(1, 0 ,0);\nconst vec3  vY = vX.yxy;\nconst vec3  vZ = vX.yyx;\nconst vec3  v0 = vX.yyy;\nconst vec3  v1 = vX.xxx;\n\nconst float pi = 3.14159265359;\n\n//--------------------------------------------------------------------------------\n\n// A = ∪(A, B)\nvoid opUnn(inout float A, in float B) {\n    A = min(A, B);\n}\n\n// A = A - B\nvoid opSub(inout float A, in float B) {\n    A = max(A, -B);\n}\n\n// A = ∩(A, B)\nvoid opInt(inout float A, in float B) {\n    A = max(A, B);\n}\n\n//--------------------------------------------------------------------------------\n\nmat2  rot2    (float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\n//--------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\nfloat sdCyl   (in vec2 p, in float r) { return length(p) - r; }\nfloat sdShell (in vec3 p, in float r, in float t) {\n    float d  = length(p);\n    float d1 = d - (r + t / 2.0);\n    float d2 = d - (r - t / 2.0);\n    opSub(d1, d2);\n    return d1;\n}\n\n\n//--------------------------------------------------------------------------------\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) { float t = -(dot(ro, n) + d) / (dot(rd, n)); if (t < 0.0) { t = 1e9; } return t; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1577, 1577, 1611, 1611, 1676], [1678, 1678, 1702, 1702, 1872], [1874, 1874, 1900, 1900, 2290], [2292, 2310, 2337, 2337, 2508], [2510, 2510, 2537, 2537, 2575], [2577, 2577, 2614, 2614, 2960], [2962, 2962, 3004, 3004, 3111], [3113, 3113, 3181, 3181, 4777], [4779, 4779, 4816, 4816, 5386], [5388, 5388, 5431, 5431, 6678]], "test": "untested"}
{"id": "dldBW8", "name": "Shader created for Voyado meet ", "author": "mrange", "description": "Voyado meetup shader\n\nCoded for the Voyado meetup.\nSee the code for some useful links to help you get started.\n", "tags": ["2d"], "likes": 9, "viewed": 286, "published": 3, "date": "1701191035", "time_retrieved": "2024-07-30T17:20:13.052067", "image_code": "// CC0: Voyado meetup shader\n\n// Coded for the Voyado meetup.\n\n// Here are some useful links to help you get started.\n\n// ShaderToy - A great place to code and learn together with a great\n//  community - You are here!\n\n// IQ Articles - A great resource by the great IQ, I visit this very often\n//  - https://iquilezles.org/articles\n\n// The Art of Code - A great YT channel by the great BigWings that \n//  helps you get started with very basics of shader programming\n//  - https://www.youtube.com/@TheArtofCodeIsCool\n\n// An Introduction Shader Art Coding - By the great kishimisu\n//  - https://www.youtube.com/@kishimisu\n\n// Windows Terminal Shader Gallery - You know you want shaders \n//  in windows terminal by me\n//   - https://github.com/mrange/windows-terminal-shader-gallery\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nconst float pi = acos(-1.0), tau=2.0*pi;\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat star5(in vec2 p, in float r, in float rf){\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 palette(float a) {\n  return 0.5 + 0.5*sin(vec3(0., 1., 2.) + a);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  \n\n  vec3 col = vec3(0.);\n\n\n  for (int i = 0; i < 5; ++i ){\n    float itime = iTime+0.2*float(i);\n    float dr = abs(sin(p.y*p.x+iTime)+p.y+0.5*sin(itime))-0.1;\n    if (dr < 0.0) {\n      col = (palette(iTime+float(i))+3.0*(-dr));\n      col *= col;\n      col *= sqrt(smoothstep(0.0, 0.1, -dr));\n    }\n  }\n\n\n  for (int i = 0; i < 5; ++i) {\n  float itime = iTime + sqrt(0.5)*float(i);\n    float h = hash(float(i)+0.5);  \n  vec2 p0 = p;\n  p0.x += sin(itime);\n  \n  float b = itime;\n  b = fract(b)-0.5;\n  b *= b;\n  b *= 2.0;\n  p0.y += b;\n  \n  p0 *= ROT(4.0*cos(itime));\n  \n  float d = h > 0.5 ? circle(p0,0.3) : star5(p0, 0.5, 0.4);\n  float od = abs(d)-0.02;\n  \n  if (d < 0.) {\n    col = palette(d*8.-2.0*itime);\n  }\n  \n  if (od < 0.) {\n    col = vec3(1.0);\n  }\n  }\n//  col.x += sin(40.0*d);\n  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 883, 914, 914, 940], [942, 1060, 1108, 1108, 1486], [1488, 1488, 1511, 1511, 1559], [1561, 1621, 1643, 1643, 1691], [1694, 1694, 1751, 1751, 2695]], "test": "untested"}
{"id": "ctdBDH", "name": "hexasticks ", "author": "FabriceNeyret2", "description": "ref: https://en.wikipedia.org/wiki/Hexastix\ninspired by jt https://www.shadertoy.com/view/cl3fWn", "tags": ["3d", "raymarching", "short"], "likes": 24, "viewed": 330, "published": 3, "date": "1701190651", "time_retrieved": "2024-07-30T17:20:13.919748", "image_code": "// inspired by jt https://www.shadertoy.com/view/cl3fWn\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))              // rotation\n\n                                                              // --- draw a beam of 6+1 bars\n#define B t = min(t, max( min(  l = length( v = q.yz )                                                      /* central bar   */ \\\n                              , length(l* cos( mod(atan(q.z,q.y)+a/2.,a) -a/2. + vec2(0,11) ) - vec2(1,0) ) /* 6 bars around */ \\\n                             ) - .1                                                                         /* bar radius    */ \\\n                         , abs(q.x) - 3.                                                                    /* bar length    */ \\\n                 )      )\n                                                              // --- turn + draw a tilted beam\n#define b q.yz *= rot(a+a),  A = q,                           /* rotate by pi/3, then push frame */ \\\n          q.z -= .2, q.xy *= rot(a), B,                       /* offset, tilt, then draw beam    */ \\\n          q = A                                               /* pop frame                       */\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., a = 6.283/6., l, i;\n    vec3  R = iResolution, A,\n          D = normalize(vec3(U+U, -4.*R.y) - R),              // ray direction\n          p = vec3(0,0,15), q,                                // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    vec2 v;\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )            // march scene\n        q = p, \n        q.yz *= rot(-C.y), \n        q.xz *= rot(-C.x-1.57),   \n        B,  i=t,                                              // draw a beam of 6+1 in the main axis\n        b,b,b,                                                // 3x turn + draw a tilted beam\n        p += .5*t*D;                                          // step forward = dist to obj    \n    \n    O *= O*O*O*2.;                                            // color scheme\n // if (i==t) O.gb*=0.;                                       // debug: main axis in red\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1172, 1172, 1208, 1208, 2232]], "test": "untested"}
{"id": "cttfWH", "name": "RE-Decorated Christmas Spiral", "author": "timmaffett", "description": "All credit to @sylvain69780  - I just added candy cane wrap, colored lights and some faux foil effect-tmm\nIt's Christmas time for Math's lovers !\n[url=https://www.shadertoy.com/view/stB3WK]SDF for Archimedean Spiral[/url]", "tags": ["christmas", "spiral", "archimed"], "likes": 11, "viewed": 243, "published": 3, "date": "1701186972", "time_retrieved": "2024-07-30T17:20:14.863225", "image_code": "// Fork of \"Decorated Christmas Spiral\" by sylvain69780. https://shadertoy.com/view/3dVfDc\n// 2023-11-28 15:55:53\n\n/*\n    Decorated Christmas Spiral\n    --------------------------\n\n    Happy Christmas to you all the great Shadertoy community !\n    \n    It seems that the archimedian spiral can be used as a distance field with coordinates\n    a quite neat way to create a repetition domain where you can put blinking balls and ribbons.\n\n    Spirals are commonly use in art, and we may find this figure frequently in the nature.\n    Of course there is several kinds of spirals. For example, the Logarithmic Spiral that IQ  \n    used in his awesome Snail shader and the ones built using arc of circles (multiple center spirals).\n    \n    Related references:    \n\n    Nyarchimedes Spiral - kibble\n    https://www.shadertoy.com/view/lsS3WV\n    \n    Quick Lighting Tech - blackle \n    https://www.shadertoy.com/view/ttGfz1\n    \n    soft shadows in raymarched SDFs - IQ\n    https://iquilezles.org/articles/rmshadows\n    \n    outdoors lighting- IQ\n    https://iquilezles.org/articles/outdoorslighting\n    \n    Cubic Truchet Pattern - Shane\n    https://www.shadertoy.com/view/4lfcRl\n    \n*/\n\n#define COLOR_RANGE 360.\n\n// SNOW background from @g1mishr's \"Snow Simple \" https://www.shadertoy.com/view/DlGczD\n#define TILES 10.0\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\n\nvec4 snowBackground( vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    uv.y -= 0.3;\n    \n    //uv.x -= 0.6;\n\n    \n    vec3 col = mix(vec3(0.0, 0.45, 0.85), vec3(1), -0.3-uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //if(curid.y > 10.0)\n    {\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n    \n    fragColor = smoothstep(0.0, 3.0, iTime)*fragColor;\n    }\n    return fragColor;\n}\n\n// END Snow Simple https://www.shadertoy.com/view/DlGczD\n\n\n\n// remember our ball color for later glowing\nvec3 ballColor = vec3(1.0);\n\n\n// #define AA\n\n#define MAX_STEPS 256\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define TAU 6.283185\n\n#define S smoothstep\n#define T (iTime)\n#define PI 3.14159265\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float r, float h )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat braids(vec3 p,float l,out float id) {\n    p.yz*=rot(p.x*3.14159*.5);\n    p.yz = abs(p.yz)-0.25; // 4 for the price of one\n    p.yz = (p.yz + vec2(p.z, -p.y))*sqrt(0.5); // Shortcut for 45-degrees rotation https://www.shadertoy.com/view/WsGyWR\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    p.yz = abs(p.yz)-0.05;\n    p.yz*=rot(p.x*3.14159*4.0);\n    p.yz = abs(p.yz)-0.02;\n    float d = sdVerticalCapsule(p,0.02,l);\n    return(d);\n}\n\nfloat carvings(vec3 p,float l, out float id) {\n    p.x-=.03;\n    float n = round(l);\n    id = clamp(round(p.x*2.0),1.0,n*2.0-1.0);\n    p.x-=id*.5;\n    p.zy*=rot(id*3.1415*.25); \n    return min(sdHexagram(p.xy,0.045),(sdBox(abs(p.xz)-0.033,vec2(0.022)+.006)));\n}\n\nfloat balls(vec3 p,float l, out float id) {\n    float rank = round(p.x);\n    p.yz*=rot((rank+0.25)*3.14159*.5);\n    p.x -= clamp(rank,0.0,l);\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    float r = .05*(1.0+id*.2);\n    p.yz = abs(p.yz);\n    p.yz -= vec2(.25,.25);\n    id += 4.0*rank;\n    return length(p)-r;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat decoratedStick(vec3 p,out float m,out float glowDist) {\n    float l = 40.0;   // lenght of the stick\n    float d = 1e10; // distance\n    // materials : 1.0=spiral 2.x=tubes 3.x=stars and squares 4.0=inside spiral 5.0 Balls\n    m = 1.0;    // materials\n    glowDist = 1e10;\n    float core = length(vec3(p.x-clamp(p.x,0.0,l),p.y,p.z));\n    float outer = core-.25;\n    float inner = core-.22;\n    // Stars and Littles windows carvings, change sign to have holes or bumps\n    float id;\n    float carvings = -carvings(p,l,id);\n    d = smax(outer,carvings,.025);\n    if ( inner    < d ) { d = inner    ; m = 4.0+id/1024.0 ; }\n    // Braids \n    float braids = braids(p,l,id);\n    if ( braids < d ) { d=braids ; m= 2.0 + id/1024.0 ; }; // packing the ID in the material\n    // Balls :-)\n    float balls = balls(p,l,id);\n    if ( balls < d ) {\n        d=balls ;\n        m= 5.0 + id/1024.0 ;\n        ballColor = hsb2rgb(vec3(fract(m)*COLOR_RANGE,1.,0.3));\n    }; // packing the ID in the material\n    \n    \n    // Some blinking\n    float blink=1.0-cos(5.0*id+2.0*T);\n    glowDist = balls+blink*.1; \n    return d; \n}\n\n// approximated !\nfloat arclength(float turn) {\n\tfloat d = turn * turn;\n\treturn d * PI;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// arc length of archimedes spiral\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\n// SDF for Archimedean Spiral\n// https://www.shadertoy.com/view/stB3WK\nfloat spiralUV2(vec2 p,float b, float a1r,float a2r, float strip, out vec2 uv) {\n    float atn = atan(p.y, p.x)/TAU; // sector from -.5 to .5\n    float a1n = a1r/TAU, a2n = a2r/TAU; // predivide allows to use fract for modulo TAU computations\n    float w = b*TAU;\n    float r = length(p)/w;\n\tfloat grad = r - atn; // radial distance gradien used for domain repetition using \"round\"\n    float d = 1e9;\n    if (a2n-a1n >= fract(atn-a1n)) // opened sector case test\n    {\n        uv.y = w*(grad-round(clamp(r,a1n+.5,a2n-.5)-atn));\n        d=abs(uv.y)-.5*strip;\n    }\n    // inner end\n    vec2 q = p*rot(a1r);\n    q.x -= a1n*w;\n    q.x -= clamp(q.x,-strip*.5,strip*.5);\n    float db = length(q);\n    // outer end\n    q = p*rot(a2r);\n    q.x -= a2n*w;\n    q.x -= clamp(q.x,-strip*.5,strip*.5);\n    db = min(db,length(q));\n    // interior / exterieur distance to ends\n    d = d > 0.0 ? min(d,db) : max(d,-db);        \n    // UV calculations\n    float turn = round(grad); \n    float an = TAU*(turn + atn); \n    uv.x = spiralLength(b,an)-spiralLength(b,a1r);\n\treturn d;\n}\n\nfloat GetDist(vec3 p,out float objID, out float glowDist, out float dC ) {\n    p.xz *= rot(T*.1);\n    p.xy *= rot(-sin(T*.1)*.5);\n    glowDist = 1e10;\n    objID = 1.0;\n    float tmin = 0.0, tmax = 2.0;\n    vec2 uv;\n    float d = 1e10;\n    dC = abs(p.y)-0.5;\n    if ( dC < SURF_DIST ) {\n        float dSpiral = spiralUV2(p.xz,1.0/TAU,(tmin+1.0)*TAU,(tmax+2.0)*TAU,1.0,uv);\n        dC = abs(dSpiral);\n        if ( dSpiral < SURF_DIST-.02 ) {\n            vec3 q = vec3(uv.x, p.y, uv.y ); // spiral UV space\n            d = decoratedStick(q-vec3(.5,0.,0.),objID,glowDist);\n        } \n    }\n    return d;\n}\n\nfloat GetDist(vec3 p,out float glowDist,out float dC) {\n    float objID;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetDist(vec3 p) {\n    float glowDist,objID,dC;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetMat(vec3 p) {\n    float glowDist,objID,dC;\n    float d = GetDist(p,objID,glowDist,dC);\n    return objID;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd,out float glowCumul) {\n\tfloat dO=0.0;  \n    float dS;\n    float dC; // distance to cell boundaries\n    float glowDist;\n    glowCumul=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p,glowDist,dC);\n        dO += min(dS*.9,dC+0.05); \n        float at = 1.0 / (1. + pow(glowDist*20.,3.0) );\n        glowCumul+=at;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col = vec3(0);    \n    vec3 tcol = vec3(0);\n    vec3 target = vec3(0,-0.7,0);\n    vec3 ro = vec3(0, 0.7, 3.3);\n    vec2 m = iMouse.xy / iResolution.xy-.5;\n    float time=mod(T+10.0,20.0);\n    float atime=1.0;\n    if ( iMouse.x > 0.0 ) {\n        target = vec3(0,-0.8,0.0);\n        ro = vec3(0, 0.5, 2.0)*2.4;\n        ro.yz *= rot(m.y*3.14*.5);\n        ro.xz *= rot(-m.x*6.2831*2.0);\n    } else  \n        ro.y+=S(0.0,10.0,time)-S(10.0,20.0,time);\n     \n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    \n    vec3 rd = GetRayDir(uv, ro, target, 1.);\n\n    vec3 bgcol = vec3(0.10,0.28,0.10)*(1.-abs(rd.y)); // fast gradient - \"the sky will be blue\" - https://youtu.be/Cfe5UQ-1L9Q?t=2795\n    // default ball color, changed if there is a colored ball\n    ballColor = vec3(0.1,0.1,0.01); //vec3(1.);//\n    //SNOW//\n    vec3 snowBgcol = snowBackground( fragCoord ).rgb;\n    \n    float glowCumul;\n    float d = RayMarch(ro, rd,glowCumul);\n    if(d<MAX_DIST) {\n    \tvec3 pos = ro + rd * d;\n        float m = GetMat(pos);\n    \tvec3 nor = GetNormal(pos);\n        vec3 ref = reflect(rd, nor); \n        vec3 c=vec3(0);\n        float ks = 1.0; \n        float occ = calcOcclusion( pos, nor );\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos+0.01*nor, sun_lig, 0.01, 0.25 );\n        float sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\t\tvec3 lin = vec3(0.0);\n        // materials  \n        if ( m >=5.0 ) {            // Balls\n            float ballID = fract(m)*1024.0;\n            //ORIGc = fract(ballID*.5) > 0.0 ? vec3(1.0,0.1,0.01) : vec3(0.6,0.6,0.2)*.5;\n            \n            c = hsb2rgb(vec3(fract(m)*COLOR_RANGE,0.9,0.6));\n            \n            \n            float directionality=0.75;\n            float sharpness=0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            float blink=1.0+cos(5.0*ballID+2.0*T);\n            lin = vec3(blink)*3.3;\n            \n            c = spec * c;  \n        } else if ( m >=4.0 ) {     // bright inside spiral\n            float starID=fract(m)*1024.0;\n            float blink=1.0+cos(5.0*starID+3.15*T);\n            //COLOR// c = vec3(0.7,0.7,0.1)*.3;\n            \n            c = hsb2rgb(vec3(fract(m)*COLOR_RANGE,0.8,0.4));\n           \n            \n            lin = vec3(blink)*3.0;\n            float directionality=0.75;\n            float sharpness=0.3; //ORIG// 0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            c = spec * c;  \n        } else if ( m >=3.0 ) {    \n            // Material Not used  c = vec3(0.3,0.1,0.01);\n        } else if ( m >=2.0 ) {     // tubes \n            float ropeID=fract(m)*1024.0;\n            \n            c = vec3(1.0);\n            \n            //ORIG//c = ropeID>2.0 ? c*vec3(0.5,0.5,0.01)*.25 : c*vec3(0.01,0.6,0.01)*.1;\n            \n            //candy cane\n            c = ropeID>2.0 ? c*vec3(0.9,0.01,0.01)*.25 : c*vec3(1.0,1.0,1.0)*.2;\n\n            \n            \n        } else if ( m >=1.0 ) {     \n            // spiral core\n            // https://www.shadertoy.com/view/tlscDB\n            //ORIG\n            c = vec3(0.28,0.2,0.02);\n            //blue//c = vec3(0.02,0.02,0.28);\n            \n            float directionality=0.75;\n            float sharpness=0.7;\n            float spec = length(sin(ref * 4.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            \n            // give some'foil' reflection quality to core\n//#define NO_GLOW_ON_FOIL\n#ifdef NO_GLOW_ON_FOIL\n            c = hsb2rgb(vec3(spec*PI,0.8,0.9)) * c;  // glow does not effect foil\n#else       \n            c = ((hsb2rgb(vec3(spec*PI,0.8,0.9)) * c) + (hsb2rgb(vec3(glowCumul*spec*PI,0.8,0.9)) * c));\n#endif\n            c =  spec * c * (.3+.7*sun_sha);  \n        }\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha*.5;\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0;\n\t\tcol = c*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        // fog\n        float fog=S(12.0,5.0,d);\n        col = mix(bgcol, col, fog);\n        \n    } else {\n        col = snowBgcol;\n    }\n    col += ballColor*(glowCumul*0.75);\n    //ORIG yellow glow// col += vec3(0.1,0.1,0.01)*glowCumul;\n    col = sqrt(col);\t// gamma correction    \n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    \n    fragColor = vec4(tcol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1318, 1373, 1397, 1397, 1462], [1464, 1464, 1534, 1534, 2647], [2650, 2650, 2689, 2689, 4159], [4462, 4462, 4489, 4489, 4724], [4729, 4729, 4751, 4751, 4815], [4818, 4818, 4840, 4840, 4934], [4936, 4936, 4989, 4989, 5048], [5050, 5050, 5079, 5079, 5160], [5162, 5162, 5205, 5205, 5449], [5451, 5451, 5488, 5488, 5568], [5570, 5570, 5613, 5613, 6033], [6035, 6035, 6081, 6081, 6296], [6298, 6298, 6341, 6341, 6634], [6636, 6636, 6677, 6677, 6749], [6751, 6751, 6812, 6812, 7863], [7865, 7883, 7912, 7912, 7954], [7956, 7956, 8008, 8008, 8127], [8129, 8164, 8202, 8256, 8313], [8315, 8386, 8466, 8466, 9449], [9451, 9451, 9525, 9525, 10052], [10054, 10054, 10109, 10109, 10169], [10171, 10171, 10194, 10194, 10266], [10268, 10268, 10290, 10290, 10383], [10385, 10385, 10439, 10439, 10847], [10849, 10849, 10873, 10873, 11063], [11065, 11065, 11115, 11115, 11306], [11308, 11353, 11431, 11431, 11747], [11749, 11749, 11798, 11798, 12084]], "test": "untested"}
{"id": "mt3BDH", "name": "My Cubic Interpolation", "author": "Timmyswdswd", "description": "My Cubic Interpolation", "tags": ["effects"], "likes": 0, "viewed": 104, "published": 3, "date": "1701179542", "time_retrieved": "2024-07-30T17:20:15.635161", "image_code": "float Lerp(float x, float q1, float q2)\n{\n    float q = q1 + x*(q2-q1);\n    return q;\n}\n\nvec3 Rainbow(float h)\n{\n    const float PI = 3.14159265359;\n    h *= PI;\n    \n    float r = (sin(h+PI/2.0+PI)+1.0)/2.0;\n    float g = (sin(clamp(h, 0.5*PI, PI)+PI/2.0)+1.0)/2.0;\n    float b = (sin(clamp(h, 0.0, 0.5*PI)+PI/2.0)+1.0)/2.0;\n    \n    vec3 col = round(vec3(r, g, b)*20.0)/20.0;\n    \n    return col;\n}\n\nfloat Cubp(float q0, float q1, float q2, float q3, float x) {\n    float P = (q3 - q2) - (q0 - q1);\n    float Q = (q0 - q1) - P;\n    float R = q2 - q0;\n    float S = q1;\n\n    return P * x * x * x + Q * x * x + R * x + S;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    col = Rainbow(Cubp(-9.0, 0.0, 0.0, 9.0, uv.x));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3BDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 87], [89, 89, 112, 112, 400], [402, 402, 463, 463, 623], [626, 626, 683, 733, 906]], "test": "untested"}
{"id": "dtcfW8", "name": "K2-18b", "author": "ENDESGA", "description": "the hycean planet\n-\njust a small golfed shader I've been picking at over the past weeks.\nfeel free to golf it down further~", "tags": ["exoplanet", "hycean"], "likes": 2, "viewed": 191, "published": 3, "date": "1701175676", "time_retrieved": "2024-07-30T17:20:16.408094", "image_code": "//*/\n\n// 260 chars by @Xor, then 255 via some visual tweaks\nvoid mainImage(out vec4 f, vec2 c)\n{\n    vec2 r = iResolution.xy,\n         u = (c+c - r) / r.y;\n    vec3 l = cos(iTime) * vec3(1, .4, tan(iTime)),\n         n = vec3(u, sqrt(1. - dot(u, u))),\n         d = max(dot(n, l), 0.) * vec3(0, 2, 4);\n    f.rgb = 1. - exp(-(d*d + vec3(8, 2, 1) *\n            pow(reflect(-l, n).z, 3.)) *\n            smoothstep(.9,.5, length(u)));\n}\n\n/* /\n\n// original\nvoid mainImage(out vec4 f, in vec2 c) {\n    vec2 u = (c - iResolution.xy * .5) / iResolution.y;\n    vec3 l = normalize(vec3(cos(iTime), .2 * cos(iTime), sin(iTime))),\n        n = normalize(vec3(u, sqrt(.2 - dot(u, u))));\n    f = vec4(\n        1. - exp(-(pow(max(dot(n, l), 0.) * vec3(0, 1, 2), vec3(2)) + vec3(2, .5, .2) *\n            pow(max(dot(vec3(0, 0, 1), reflect(-l, n)), 0.), 3.)) *\n            4. * (1. - smoothstep(.2, .4, length(u)))\n        ), 1);\n}\n\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 60, 96, 96, 430]], "test": "untested"}
{"id": "ctcfWH", "name": "PARADICE", "author": "samuelotherion", "description": "One real paradice. ;O)\nUse your mouse to rotate the dice!", "tags": ["raytracing", "dice", "transparancy"], "likes": 1, "viewed": 113, "published": 3, "date": "1701172679", "time_retrieved": "2024-07-30T17:20:17.219924", "image_code": "// global integer input\nI2\nI;\n\n// read vec4 from ram wia ivec2 address\nF4\nrd(I2 a) {\n\n    RE texelFetch(iChannel0, a, 0);\n}\n\n// read vec4 from ram via integer address\nF4\nrd(I1 a) {\n    \n    RE rd(I1toI2(a));\n}\n\n// some useful structurs\nstruct Cuboid {F3 pos, ext; M3 dir;};\nstruct Hit {I1 id; F1 dist; F2 uv; F3 norm;};\nstruct Camera {F3 pos, ray; M3 dir;};\n\nF3\ncol = F3(.41,.43,.41);\n\nB1\nhitCuboid(Camera cam, Cuboid cub, inout Hit f, inout Hit b) {\n    \n    \n    F3\n    ray = normalize(cam.dir * cam.ray),\n    dst = cam.pos - cub.pos;\n    \n    // check whether ray hits bounding spheroid\n    F1\n    rd = dot(ray, dst);\n\n    if(dot(cub.ext, cub.ext) - dot(dst, dst) + rd * rd < 0.) RF\n\n    Hit[2]\n    hit = Hit[2](\n        Hit(-1, 1e7, _.yy, _.yyy),\n        Hit(-1, 1e7, _.yy, _.yyy));\n\n    I1\n    i = -1;\n    \n    M3\n    xyz = M3(cub.dir[X] * cub.ext.x, cub.dir[Y] * cub.ext.y, cub.dir[Z] * cub.ext.z),\n    xyz_,\n    _zyx;\n\n    F3\n    sol;\n    \n    F2\n    sol_uv;\n    \n    for(I1 dim = 0; dim < 3; ++ dim) {\n    \n        for(F1 sol_f = -1.; sol_f < 2.; sol_f += 2.) { \n    \n            xyz_      = xyz;\n            xyz_[dim] = -ray;\n            _zyx      = inverse(xyz_);\n    \n            sol       = _zyx * (dst + sol_f * xyz[dim]);\n            sol_uv    = F2(sol[(dim + 1) % 3], sol[(dim + 2) % 3]);\n            \n            if(i < 1 && 0. < sol[dim] && all(lessThanEqual(abs(sol_uv), _.ww))) {\n\n                ++ i;\n                hit[i].id   = 2 * dim + I1(.5 + .5 * sol_f);\n                hit[i].dist = sol[dim];\n                hit[i].uv   = sol_uv;\n                hit[i].norm = -sol_f * cub.dir[dim];\n            }\n        }\n    }\n    \n    if(hit[0].dist < hit[1].dist) {\n        \n        f = hit[0];\n        b  = hit[1];\n    } else {\n        \n        f = hit[1];\n        b  = hit[0];\n    }\n    \n    RE 1 == i;\n}\n\nVO\nmainImage(out F4 o, F2 xy) {\n\n    F2\n    R  = 1. / iResolution.xy,\n    uv = 2. * (xy * R - .5) * F2(iResolution.x * R.y, 1.);\n    \n    Camera\n    //           position         ray                    coord system\n    cam = Camera(F3(0., 0., 50.), normalize(F3(uv, -3)), ID);\n    \n    // Cuboid local coordinate system rotating around a rotating vector red from Buffer A at Address DIR\n    M3\n    cs = M3(\n        rd(DIR + 0).xyz,\n        rd(DIR + 1).xyz,\n        rd(DIR + 2).xyz);\n    \n    Cuboid\n    //          position      extents             coord system    \n    c0 = Cuboid(F3(0, 0, 5), F3( +9., +9., +9.), cs);\n    \n    // background color\n    o = F4(.02, .03, .05, 1);\n    \n    Hit\n    f,\n    b;\n    \n    if(hitCuboid(cam, c0, f, b)) {\n    \n        F1\n        fac = .2;\n\n        if((\n            (f.id == 0 && \n             (.05 < dot(F2(.00) - f.uv, F2(.00) - f.uv))) ||\n            (f.id == 2 && \n             (.05 < dot(F2(.50) - f.uv, F2(.50) - f.uv) &&\n              .05 < dot(F2(-.50) - f.uv, F2(-.50) - f.uv))) ||\n            (f.id == 4 && \n             (.05 < dot(F2(-.50) - f.uv, F2(-.50) - f.uv)) &&\n              .05 < dot(F2(0.00) - f.uv, F2(0.00) - f.uv) &&\n              .05 < dot(F2(+.50) - f.uv, F2(+.50) - f.uv)) ||\n            (f.id == 5 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv)) ||\n            (f.id == 3 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv) &&\n              .05 < dot(F2(+.0,+.0) - f.uv, F2(+.0,+.0) - f.uv)) ||\n            (f.id == 1 && \n             (.05 < dot(F2(-.5,-.5) - f.uv, F2(-.5,-.5) - f.uv)) &&\n              .05 < dot(F2(-.5,+.5) - f.uv, F2(-.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,+.5) - f.uv, F2(+.5,+.5) - f.uv) &&\n              .05 < dot(F2(+.5,-.5) - f.uv, F2(+.5,-.5) - f.uv) &&\n              .05 < dot(F2(-.5,+.0) - f.uv, F2(-.5,+.0) - f.uv) &&\n              .05 < dot(F2(+.5,+.0) - f.uv, F2(+.5,+.0) - f.uv))\n        ))\n        \n            if(!(\n                (f.id == 0 && \n                 (.05 < dot(F2(.00) - b.uv, F2(.00) - b.uv))) ||\n                (f.id == 2 && \n                 (.05 < dot(F2(.50) - b.uv, F2(.50) - b.uv) &&\n                  .05 < dot(F2(-.50) - b.uv, F2(-.50) - b.uv))) ||\n                (f.id == 4 && \n                 (.05 < dot(F2(-.50) - b.uv, F2(-.50) - b.uv)) &&\n                  .05 < dot(F2(0.00) - b.uv, F2(0.00) - b.uv) &&\n                  .05 < dot(F2(+.50) - b.uv, F2(+.50) - b.uv)) ||\n                (f.id == 5 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv)) ||\n                (f.id == 3 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv) &&\n                  .05 < dot(F2(+.0,+.0) - b.uv, F2(+.0,+.0) - b.uv)) ||\n                (f.id == 1 && \n                 (.05 < dot(F2(-.5,-.5) - b.uv, F2(-.5,-.5) - b.uv)) &&\n                  .05 < dot(F2(-.5,+.5) - b.uv, F2(-.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,+.5) - b.uv, F2(+.5,+.5) - b.uv) &&\n                  .05 < dot(F2(+.5,-.5) - b.uv, F2(+.5,-.5) - b.uv) &&\n                  .05 < dot(F2(-.5,+.0) - b.uv, F2(-.5,+.0) - b.uv) &&\n                  .05 < dot(F2(+.5,+.0) - b.uv, F2(+.5,+.0) - b.uv))\n            ))\n\n            o = \n                  .75 * F4(col * (fac        * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)), 1.) + \n                  .75 * F4(col * ((1. - fac) * clamp(dot(b.norm, F3(0, 0, -1)), 0., 1.)), 1.);\n\n            else o = \n                  .75 * F4(col * (fac        * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)), 1.) + \n                  .35 * F4(col * ((1. - fac) * clamp(dot(b.norm,  F3(0, 0, -1)), 0., 1.)), 1.);\n\n        else o = F4(col,1.)*((1. - fac) * clamp(dot(f.norm, F3(0, 0, +1)), 0., 1.)); \n    } \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VO void\n#define B1 bool\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n#define I1 int\n#define I2 ivec2\n\n#define M3 mat3x3\n\n#define X  0\n#define Y  1\n#define Z  2\n\n#define RE return\n#define RF RE false;\n#define RT RE true;\n\n#define I1toI2(S) I2(S & 0xf, (S >> 4) & 0xf)\n#define I2toI1(V) (V.x + (V.y << 4))\n\n// addresses in Buffer A accessable via rd(DIR + {0,1,2}) \n#define MOUSE 0 \n#define DIR   1 \n#define END   4 \n\nconst F4\n_ = F4(-1., 0., .5, 1.);\n\nconst M3\nID = M3(_.wyy, _.ywy, _.yyw);\n\n// rotate vector u around vector axe by angle alpha\nF3\nrot(F3 u, F1 alpha, F3 axe) {\n\n    axe = normalize(axe);\n    \n    F3\n    z = dot(u, axe) * axe,\n    x = u - z,\n    y = cross(axe, x);\n    \n    RE cos(alpha) * x + sin(alpha) * y + z;\n}\n\n// rotate coordinate system xyz around vector axe by angle alpha\nM3\nrot(M3 xyz, F1 alpha, F3 axe) {\n\n    axe = normalize(axe);\n    \n    xyz[X] = rot(xyz[X], alpha, axe);\n    xyz[Y] = rot(xyz[Y], alpha, axe);\n    xyz[Z] = rot(xyz[Z], alpha, axe);\n    \n    RE xyz;\n}\n", "buffer_a_code": "// global Output \nF4\nO;\n\n//global Integer Input\nI2\nI;\n\n// read from ivec2 address a\nF4\nrd(I2 a) {\n\n    RE texelFetch(iChannel0, a, 0);\n}\n\n\n// read from int address a\nF4\nrd(I1 a) {\n    \n    RE rd(I1toI2(a));\n}\n\n// write to ivec2 address a the vec4 value v\nB1\nwt(I2 a, F4 v) {\n    \n    if(a.x == I.x && a.y == I.y) {\n    \n        O = v;\n        \n        RT\n    }\n    \n    RF\n}\n\n// write to int address a the vec4 value v\nB1\nwt(I1 a, F4 v) {\n    \n    RE wt(I1toI2(a), v);\n}\n\n\nVO\nmainImage(out F4 o, F2 f) {\n\n    // set globel input I\n    I = I2(f);\n    \n    // read color from Buffer A and store to globel output O\n    O = rd(I);\n    \n    // use first 16 pixel of the first row of Buffer A as RAM\n    // that means if where not inside the RAM coords, we are done here and return fragmentColor o = O.\n    if(15 < I.x || 0 < I.y) {\n    \n        o = O;\n    \n        RE;\n    }\n    \n    // if the first frame is rendered\n    // Buffer A is undefined - RAM is not set\n    // init RAM\n    if(iFrame < 1) {\n        \n        // init RAM and return o = O\n        wt(MOUSE,   F4(-1));\n        wt(DIR + 0, F4(ID[X], 0));\n        wt(DIR + 1, F4(ID[Y], 0));\n        wt(DIR + 2, F4(ID[Z], 0));\n        \n        o = O;\n        \n        RE;\n    }\n\n    // if mouse button is not pressed\n    // write -1,-1,-1,-1 to RAM at address MOUSE and return o = O\n    if(iMouse.z <= 0.) {\n    \n        wt(MOUSE, F4(-1));\n        \n        o = O;\n        \n        RE;\n    }\n    \n    // read iMouse from Buffer A at address MOUSE and store it in m\n    F4\n    m = rd(MOUSE);\n    \n    // if mouse button is pressed and one of the coords has changed\n    if(m.z == iMouse.z && (iMouse.y != m.y || iMouse.x != m.x)) {\n\n        // create from mouse coord difference a rotation axis\n        F4\n        axis = F4(normalize(F3(m.y - iMouse.y, iMouse.x - m.x, 0)),  .01 * length(iMouse.yx - m.yx));\n\n        // read the coords system of the cube\n        M3\n        dir = M3(\n            rd(DIR + X).xyz,\n            rd(DIR + Y).xyz,\n            rd(DIR + Z).xyz\n        );\n\n        // rotate the cubes coords system by angle axis.w around axis.xyz\n        dir = rot(dir, axis.w, axis.xyz);\n\n        // write new cubes 3d coords to RAM as 3 x vec4\n        wt(DIR + X, F4(dir[X], 0));\n        wt(DIR + Y, F4(dir[Y], 0));\n        wt(DIR + Z, F4(dir[Z], 0));\n    }\n    \n    // write current mouse state to RAM at address MOUSE\n    wt(MOUSE, iMouse);\n\n    // return o = O\n    o = O;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 167, 180, 180, 209], [1827, 1827, 1858, 1858, 6379]], "test": "untested"}
{"id": "ctcfD8", "name": "Two of the most beautiful balls ", "author": "Yusparkle", "description": "To distinguish the two spheres, I applied a different color to each sphere. The red ball uses red (vec3(1.0, 0.0, 0.0)), while the green ball uses green (vec3(0.0, 1.0, 0.0)).", "tags": ["3d", "beginner", "balls", "nothingspecial"], "likes": 0, "viewed": 138, "published": 3, "date": "1701169922", "time_retrieved": "2024-07-30T17:20:17.980889", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n\n    vec3 lightPos = normalize(vec3(0.5, 0.5, 1.0));\n    vec3 lightIntensity = vec3(1.0);\n\n\n    vec3 redBallPos = vec3(-0.3, 0.0, 0.25);\n    vec3 greenBallPos = vec3(0.3, 0.0, 0.25);\n    float radius = 0.15;\n\n \n    vec3 color = vec3(0.0);\n\n\n    float redZ = radius * radius - (uv.x - redBallPos.x) * (uv.x - redBallPos.x) - (uv.y - redBallPos.y) * (uv.y - redBallPos.y);\n    float greenZ = radius * radius - (uv.x - greenBallPos.x) * (uv.x - greenBallPos.x) - (uv.y - greenBallPos.y) * (uv.y - greenBallPos.y);\n\n \n    if (redZ > 0.0) {\n        redZ = sqrt(redZ);\n        vec3 normal = normalize(vec3(uv.x - redBallPos.x, uv.y - redBallPos.y, redZ));\n        float diff = max(dot(normal, lightPos), 0.0);\n        float spec = pow(max(dot(reflect(-lightPos, normal), normal), 0.0), 64.0);\n        color = diff * vec3(1.0, 0.0, 0.0) + spec * lightIntensity;\n    }\n\n\n    if (greenZ > 0.0) {\n        greenZ = sqrt(greenZ);\n        vec3 normal = normalize(vec3(uv.x - greenBallPos.x, uv.y - greenBallPos.y, greenZ));\n        float diff = max(dot(normal, lightPos), 0.0);\n        float spec = pow(max(dot(reflect(-lightPos, normal), normal), 0.0), 64.0);\n        color = diff * vec3(0.0, 1.0, 0.0) + spec * lightIntensity;\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 1458]], "test": "untested"}
{"id": "dltBDr", "name": "Winding Numbers: Stokes' Theorem", "author": "cmarangu", "description": "Entirely inspired by Keenan Crane et al. ACM SIGGRAPH paper \"Winding Numbers on Discrete Surfaces\"\n\nI know my implementation is buggy. I wrote it in 1 night.\n\n[url]https://www.youtube.com/watch?v=3undxB8rcvE[/url]", "tags": ["windingnumber", "swn", "stokestheorem"], "likes": 4, "viewed": 179, "published": 3, "date": "1701163286", "time_retrieved": "2024-07-30T17:20:18.754820", "image_code": "// Winding Numbers: Stokes' Theorem\n// Chase Marangu 2023 11 28 2:41am ET\n//    Updated to try to include subtended angle algorithm which turned out to not work 2023 12 03 9:03pm ET\n// The program computes the \"winding number\" of the path g around each point in the shader\n//\n// Made for algorithms class final assignment\n// It's a long story, but the Generalized Stokes' Theorem (more rightfully\n// called the Fundamental Theorem of Multivariable Calculus (FTMC)) shows up\n// in so many fields from topology to multivariable calc to physics and engineering\n// where it solves everything from magnetic field of a wire to division by zero in complex analysis\n//\n//\n// This was entirely inspired by Keenan Crane et al. ACM SIGGRAPH paper \"Winding Numbers on Discrete Surfaces\"\n// - https://doi.org/10.1145/3592401\n// - https://dl.acm.org/doi/10.1145/3592401\n// - https://dl.acm.org/doi/pdf/10.1145/3592401\n// - \n// - https://www.youtube.com/watch?v=3undxB8rcvE\n// //\n// Specifically, Figure \n//\n//\n// Some Abbreviations / Acronyms: Surface Winding Numbers (SWN), Generalized Winding Numbers (GWN)\n// \n//\n// anyways, down to coding.\n\n\n\n// Physical constants. Pi is more a mathematical constant but I don't care\n#define PI 3.14159265358979323\n\n// Mode - added 2023 December 3rd\n// 0 - uses line integral in magnetic B-field divided by current in wire\n// 1 - uses subtended angle\n#define mode 0\n// 0 - counter clockwise (CCW) / anticlockwise circle\n// 1 - figure eight\n// 2 - triple figure eight thing\n#define whichcurve 1\n// n is the number of iterations for Euler Integration throughout this program\n#define n 100.\n\n\nvec3 B (vec3 s) {\n    return (1./length(s))*cross(vec3(0., 0., 1.), normalize(s) );\n}\n\n// g:R -> R^2 is our path that gets \"doodled\" to the screen.\nvec2 g2 (float t) {\n    // adding animation using iTime uniform\n    t *= .505 - .495*sin( (iTime+.5) *PI*.2);\n    // make t spend extra time at 1\n    //t = clamp(t*2.2, 0., 1.);\n    t *= 2.*PI;\n    #if whichcurve == 0\n    return vec2( cos(t), sin(t) );\n    #elif whichcurve == 1\n    return vec2( cos(t*2.+PI*.5), sin(t) )*.8;\n    #else\n    return vec2( cos(t*3.), sin(t) )*.8;\n    #endif\n}\n\nvec3 g (float t) {\n    // I know the redundant calling g(t) is inefficient but I don't care, this still runs 60FPS\n    // for this project, code readability > efficiency (since it still runs 60FPS)\n    return vec3(g2(t).x, g2(t).y, 0.);\n}\n\n\nfloat SDF (vec3 p) {\n    // start at infinity\n    float SDFi = 1e9; // SDFi because like subscript i indicates it's index i in our minimizing algorithm, not the final value\n    // calculate n-ary minimum. This inspired by\n    // \"Parametric SDF L1, L2, Linf\" by @Envy24\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        vec3 s = g(t);\n        SDFi = min( SDFi, length(s-p) );\n    }\n    return SDFi;\n}\n\n#if mode == 0\nfloat windingNum (vec3 p) {\n    // given a point p on the screen,\n    // outputs the winding number of the path g(t):[0,1)->R^3 around an \"upwards\" line through s.\n    // equivalently, the winding number of g2(t):[0,1)->R^2 around the point (s.x, s.y) in R^2\n    // Clockwise is positive to match\n    // with conventions in Stokes' Theorem and numerous other places where x=cos(t) y=sin(t) t>=0 etc.\n    float w = 0.;\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        float deltaT = 1./n;\n        vec3 s = g(t); // g:R->R^3 is a function. s is a point in R^3. R^n is the nth Cartesian Power of R.\n        vec3 deltaS = g(t + deltaT)-g(t); // delta is the unicode U+2206 Increment Operator.\n                                          // Related to Generalized Stokes' Theorem.\n        w += dot( B(s - p), deltaS );\n    }\n    return w/(2.*PI);\n}\n#else\nfloat windingNum (vec3 p) {\n    vec2 p2 = p.xy;\n    float w = 0.;\n    for (float i=0.; i<n; ++i) {\n        float t = i/n;\n        float t2 = (i+1.)/n;\n        vec2 s = g2(t);\n        vec2 s2 = g2(t2);\n        float theta = atan(s.y-p.y,s.x-p.x);\n        float theta2 = atan(s2.y-p.y, s2.x-p.x);\n        //w += mod(PI*2.*900. + theta2-theta, PI*2.);\n        float theSign = 1.;\n        if (theta2 - theta < 0.) { theSign = -1.; }\n        w += length(normalize(s2 - p2) - normalize(s - p2)) * theSign;\n    }\n    return w/(2.*PI);\n}\n#endif\n\n\n// lerp = abbreviation of \"linear interpolation\"\n// used for the colorFunction to make it look nice\nvec3 lerp (vec3 a, vec3 b, float t) { return a + (b-a)*t; }\n\n// color function\n// inputs: w = winding number of g(t):[0,1)->R^3 around h\nvec3 colorFunction (float w) {\n    // help from https://www.shadertoy.com/view/MsjyWR to learn how to use arrays\n    // ncs is the number of colors\n    #if 1\n    #define ncs 3.\n    vec3 cs[int(ncs)];\n    cs[0] = vec3(0., 0., 0.);\n    cs[1] = vec3(0., 0., 1.);\n    cs[2] = vec3(0., 1., 1.);\n    #else\n    // make it go in increments of 0.5 instead of 1\n    w *= 2.;\n    #define ncs 6.\n    vec3 cs[int(ncs)];\n    cs[0] = vec3(0., 0., 0.);\n    cs[1] = vec3(0., 1., 0.); // wont get shown if w is whole number\n    cs[2] = vec3(0., 1., 1.);\n    cs[3] = vec3(1., 0., 0.); // wont get shown if w is whole number\n    cs[4] = vec3(0., 0., 1.);\n    cs[5] = vec3(1., 0., 1.); // wont get shown if w is whole number\n    #endif\n    float i = floor(w);\n    // the +ncs*999 is a hack to make sure it works with negative values of w as well\n    vec3 c1 = cs[int(mod(i+ncs*999., ncs))];\n    vec3 c2 = cs[int(mod(i+1.+ncs*999., ncs))];\n    //c1 = vec3(0.); c2 = vec3(1., 0., 0.);\n    //\n    return lerp( c1, c2, mod(w+999., 1.) );\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 p = vec3(\n        fragCoord.x-iResolution.x/2.,\n        fragCoord.y-iResolution.y/2.,\n        0.\n    )/min(iResolution.x, iResolution.y)*2.;\n    fragColor.rgb = vec3(.0);\n    //fragColor.r = windingNum(p);\n    fragColor.rgb = colorFunction(windingNum(p));\n    // fragColor.r = sin( length(B(p)) );\n    //fragColor.rgb = B(p);\n    //fragColor.rgb = p;\n    //if (length(p.xy)>1.) {fragColor.g = .5; } else { fragColor.g = 0.; }\n    //if (p.x>.0) {fragColor.r = 1.; } else { fragColor.r = 0.; }\n    //if (p.y>.0) {fragColor.b = 1.; } else { fragColor.b = 0.; }\n    //\n    //if (SDF(p) < .05) { fragColor.rgb *= .8; }\n    //\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1614, 1614, 1631, 1631, 1699], [1701, 1762, 1781, 1825, 2151], [2153, 2153, 2171, 2350, 2391], [2394, 2394, 2414, 2439, 2808], [4226, 4326, 4363, 4363, 4385], [4387, 4463, 4493, 4610, 5477], [5480, 5480, 5536, 5536, 6190]], "test": "untested"}
{"id": "DtdfDr", "name": "classmates sketchbook CINESHADER", "author": "chenxianming", "description": "make this prints for the glass drag gate pasting.\nframebuffer compressed ver see.\nhttps://www.shadertoy.com/view/dldBRn", "tags": ["retro", "cineshader", "carton"], "likes": 8, "viewed": 686, "published": 3, "date": "1701157280", "time_retrieved": "2024-07-30T17:20:19.523764", "image_code": "#define I iResolution\n#define T iTime\n#define PI 3.1415\n#define TAU PI * 2.\n#define rr( a ) mat2( cos(a), sin(a), -sin(a), cos(a) )\n#define S smoothstep\n\n// V IQ V\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat rep(inout vec2 p, float rep) \n{\n\n    float an = TAU/rep;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    \n    if( p.y < 0. ){\n        sym = 0.;\n    }\n    \n    p *= rr(sym);\n\n    return ia;\n}\n\nfloat ligBubble( vec2 u ){\n    return min(\n        smin(\n            length( u + vec2( 0., -.15 ) ) - .2,\n            max(\n                abs( u.x ) - .1, abs( u.y ) - .2\n            ),\n            .08\n        ),\n        length( u + vec2( 0., .2 ) ) - .1\n    );\n}\n\nfloat lig( vec2 u ){\n    \n    u.y -= .15;\n    \n    u *= rr( PI * .08 );\n    \n    float i = rep( u, 11. );\n    u.x -= .4;\n    u.x += cos( T * ( i - 9. ) ) * .01;\n    u *= rr( PI * .5 );\n   \n    return max(\n        abs( u.x ) - .05 * abs( u.y - .5 ),\n        abs( u.y ) - .1\n    );\n}\n\nfloat mainVisual( vec2 u ){\n    u.x += .1;\n    u.y -= .1;\n    \n    u *= rr( cos( T ) * .1 );\n    \n    return abs(\n        min(\n            ligBubble( u ),\n            lig( u )\n        )\n    );\n}\n\nfloat paperPlane1( vec3 p ){\n    p.x = abs( p.x ) - .01;\n    p.y -= .4;\n    p.xy *= rr( PI * .03 );\n    p.y += .4;\n    \n    p.yz *= rr( PI * .01 );\n    \n    return max(\n        sdTriangle( p.xy, vec2( 0., .5 ), vec2( .25, 0. ), vec2( 0., 0. ) ),\n        abs( p.z ) - .001\n    );\n}\n\nfloat paperPlane2( vec3 p ){\n    p.z -= .15;\n    p.x = abs( p.x ) - .0;\n    \n    p.yz *= rr( PI * -.08 );\n    \n    p.y -= .4;\n    p.xz *= rr( PI * -.45 );\n    \n    p.y += .4;\n    \n    return max(\n        sdTriangle( p.xy, vec2( 0., .5 ), vec2( .15, 0. ), vec2( 0., 0. ) ),\n        abs( p.z ) - .001\n    );\n}\n\nvec3 update( vec3 p, float T ){\n    p.z -= .5;\n    p.y += cos( T * 1.5 ) * .2;\n    p.x -= cos( T ) * 4.;\n    p.z -= sin( T ) * 1.5;\n\n    return p;\n}\n\nfloat paperPlane( vec3 p ){\n\n    // trians\n    p = update( p, T );\n    p.xz *= rr( atan( cos(T) * .2, sin(T) ) );\n    p.yz *= rr( cos( T * -3. ) * .2 + .5 );\n    \n    \n    // pose\n    p.yz *= rr( PI * .25 );\n    p.xy *= rr( PI * .5 );\n    \n    return min(\n        paperPlane1( p ),\n        paperPlane2( p )\n    );\n}\n\nfloat rule1( vec2 u ){\n    u.x -= .5;\n    u.y += .8;\n    u *= rr( PI * .2 );\n    return abs( sdTriangle( u, vec2( 0., .5 ), vec2( .25, 0. ), vec2( 0., 0. ) ) );\n}\n\n\nfloat lo( vec2 u ){\n    \n    u.x += .7;\n    u.y += .5;\n\n    return abs( \n        sin( atan( u.x, u.y ) - length(u) * 80. + T * .5 )\n    );\n}\n\nfloat lo_1( vec2 u ){\n    u.x += .7;\n    u.y += .5;\n    \n    return length( u ) - .2;\n}\n\nfloat lo2( vec2 u ){\n    u.x += .7;\n    u.y += .5;\n    \n    u *= rr( PI * -.1 );\n    \n    return abs( \n        min(\n            length( u ) - .22,\n            max(\n                abs( u.x ) - .015,\n                abs( u.y + .3 ) - .2\n            )\n        )\n    );\n}\n\nfloat rule2( vec2 u ){\n    u.x -= .8;\n    u.y += .5;\n    u *= rr( PI * -1.3 );\n    return abs( \n        max(\n            max(\n                length( u ) - .2,\n                u.y - .035\n            ),\n            -(\n                max(\n                    length( u ) - .13,\n                    u.y + .02\n                )\n            )\n        )\n    );\n}\n\nfloat pen( vec3 p ){\n    \n    p.x += .2;\n    p.y += .6;\n    \n    p.xz *= rr( T );\n    p.yz *= rr( T );\n    \n    return max(\n        length( p.xz ) - .03 * ( abs( p.y - .6 ) + .2 ),\n        abs( p.y ) - .2\n    );\n}\n\n\nfloat pt( vec2 u ){\n    \n    u.x -= .52;\n    u.y += .3;\n    \n    float py = u.y;\n    \n    py = pow( abs( py - .3 ), 2. ) + .1;\n    \n    py *= ( u.y / 2. + .5 ) / .1;\n    \n    return abs(\n        smax(\n            length( u.x ) - .1 * py,\n            abs( u.y ) - .3,\n            .1 * abs( u.y - .5 )\n        )\n    );\n}\n\n\nfloat pt2( vec2 u, float a ){\n    \n    u.x -= .5;\n    u.y -= .04;\n    \n    u.y -= fract( a ) * .3;\n    u.x += cos( a * 3. ) / 30.;\n\n    return abs(\n        length( u ) - .03 * ( 1. - fract( a ) * .3 )\n    );\n}\n\n\nfloat cu( vec3 p, float T ){\n    \n    p = update( p, T );\n    p.yz *= rr( cos( T ) * .2 );\n    p.yz *= rr( atan( sin(T), cos(T) ) );\n    \n    \n    return max(\n        max(\n            abs( p.y ) - .005,\n            abs( p.z ) - .005\n        ),\n        abs( p.x ) - .03\n    );\n}\n\nfloat trail( vec3 p ){\n    float d = .5;\n    \n    for( float i = 50.; i > 0.; i-- ){\n        d = min(\n            d,\n            cu( p, (T-.01) - i / ( 45. + round( cos(-T*2.) * 15. ) ) )\n        );\n    }\n    \n    return d;\n}\n\nfloat Tl;\n\nfloat df( vec3 p ){\n    float d = .1;\n    \n    d = min(\n        d,\n        paperPlane( p )\n    );\n    \n    d = min(\n        d,\n        pen( p )\n    );\n    \n\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float A = min( I.x, I.y );\n    vec2 u = ( V * 2. - I.xy ) / A;\n    \n    vec3 c = vec3(.47, .51, .52), m = c, p, o = vec3( 0., 0., -3. ), r = vec3( u * .4, 1. );\n    \n    c = mix(\n        c,\n        m * 1.2,\n        S(\n            2. / A,\n            0.,\n            abs(\n                mod( u.x + .1, .2 ) - .1\n            )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 1.2,\n        S(\n            2. / A,\n            0.,\n            abs(\n                mod( u.y + .1, .2 ) - .1\n            )\n        )\n    );\n    \n    float t, d, i, e = 0., w = 5. / A, l = 9e9;\n    \n    for( ; i < 80.; i++ ){\n        p = o + r * t,\n        d = df( p );\n        \n        if( l < w && d > l + 1e-5 && p.z > 0.){\n            e =  1.;\n        }\n        \n        t += d * .8889;\n        \n        if( d < l && d != Tl ) l = d;\n        \n    }\n    \n    i = 0.,\n    t = 0.;\n    \n    for( ; i < 16.; i++ ){\n        p = o + r * t,\n        d = trail( p );\n        \n        t += d;\n    }\n    \n    t = clamp( t, 0., 1. );\n    \n    if( d < 1e-3 ){\n        c = mix(\n            c,\n            m * 1.4,\n            t\n        );\n    }\n\n    c = mix(\n        c,\n        m * 1.8,\n        e\n    );\n    \n    c = mix(\n        c,\n        m * 1.8,\n        S(\n            4. / A,\n            0.,\n            mainVisual( u )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 1.8,\n        S(\n            4. / A,\n            0.,\n            pt( u )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 2. - ( fract( T ) * .5 ),\n        S(\n            5. / A,\n            0.,\n            pt2( u, T )\n        )\n    );\n    \n    \n    c = mix(\n        c,\n        m * 2. - ( fract( T + .5 ) * .5 ),\n        S(\n            5. / A,\n            0.,\n            pt2( u, T + .5 )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 2. - ( fract( T + .8 ) * .5 ),\n        S(\n            5. / A,\n            0.,\n            pt2( u, T + .8 )\n        )\n    );\n\n    \n    c = mix(\n        c,\n        m * 2.,\n        S(\n            4. / A,\n            0.,\n            rule1( u )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 2.,\n        S(\n            4. / A,\n            0.,\n            rule2( u )\n        )\n    );\n    \n    c = mix(\n        c,\n        m * 1.8,\n        S(\n            300. / A,\n            0.,\n            lo( u )\n        ) * step( lo_1( u ), 0. )\n    );\n    \n    c = mix(\n        c,\n        m * 2.,\n        S(\n            5. / A,\n            0.,\n            lo2( u )\n        )\n    );\n    \n\n\n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 232, 232, 797], [799, 799, 839, 839, 921], [923, 923, 962, 962, 993], [995, 995, 1032, 1032, 1250], [1252, 1252, 1278, 1278, 1516], [1518, 1518, 1538, 1538, 1799], [1801, 1801, 1828, 1828, 1995], [1997, 1997, 2025, 2025, 2277], [2279, 2279, 2307, 2307, 2586], [2588, 2588, 2619, 2619, 2736], [2738, 2738, 2765, 2780, 3053], [3055, 3055, 3077, 3077, 3217], [3220, 3220, 3239, 3239, 3360], [3362, 3362, 3383, 3383, 3449], [3451, 3451, 3471, 3471, 3719], [3721, 3721, 3743, 3743, 4078], [4080, 4080, 4100, 4100, 4293], [4296, 4296, 4315, 4315, 4614], [4617, 4617, 4646, 4646, 4826], [4829, 4829, 4857, 4857, 5106], [5108, 5108, 5130, 5130, 5333], [5346, 5346, 5365, 5365, 5523], [5526, 5526, 5567, 5617, 8161]], "test": "untested"}
{"id": "DdVXzR", "name": "Pathtracer 2 spheres", "author": "dankcatlord", "description": " ", "tags": ["raytracing"], "likes": 4, "viewed": 198, "published": 3, "date": "1701156070", "time_retrieved": "2024-07-30T17:20:20.307668", "image_code": "// https://github.com/dmnsgn/glsl-tone-map/blob/main/aces.glsl\n// https://github.com/dmnsgn/glsl-tone-map/blob/main/LICENSE.MD\nvec3 aces(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(pow(aces(texture(iChannel0, fragCoord / iResolution.xy).rgb * .65), vec3(1.0 / 2.2)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\n\nfloat floatConstruct(uint a) {\n\treturn uintBitsToFloat(0x3F800000u | (a >> 9)) - 1.0;\n}\n\n// Bob Jenkins' One-At-A-Time hashing algorithm https://stackoverflow.com/a/17479300\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// xoroshiro 128+ https://prng.di.unimi.it\nuint rotl(const uint x, int k) {\n\treturn (x << k) | (x >> (32 - k));\n}\n\nfloat rand(inout uint s[4]) {\n\tuint result = s[0] + s[3];\n\n\tuint t = s[1] << 9;\n\n\ts[2] ^= s[0];\n\ts[3] ^= s[1];\n\ts[1] ^= s[2];\n\ts[0] ^= s[3];\n\n\ts[2] ^= t;\n\n\ts[3] = rotl(s[3], 11);\n\n\treturn floatConstruct(result);\n}\nvec2 rand2(inout uint s[4]) { return vec2(rand(s), rand(s)); }\nvec3 rand3(inout uint s[4]) { return vec3(rand(s), rand(s), rand(s)); }\nvec4 rand4(inout uint s[4]) { return vec4(rand(s), rand(s), rand(s), rand(s)); }\n\nvoid genState(out uint s[4], ivec2 coord, int frame) {\n   s[0] = hash(uint(frame) ^ hash(uint(coord.y) ^ hash(uint(coord.x))));\n   s[1] = hash(s[0]);\n   s[2] = hash(s[1]);\n   s[3] = hash(s[2]);\n   rand(s);\n   rand(s);\n}\n\nfloat fresnel(vec3 dir, vec3 norm, float ior) {\n    float c = -dot(dir, norm);\n    float s = sqrt(1.0 - c * c);\n    float v = sqrt(max(0.0, 1.0 - (ior * ior) * (1.0 - c * c)));\n    float rs = (ior * c - v) / (ior * c + v);\n    float rp = (ior * v - c) / (ior * v + c);\n    return (rs * rs + rp * rp) / 2.0;\n}", "buffer_a_code": "struct MatData {\n    vec3 dir;\n    vec3 albedo;\n    vec3 emmission;\n};\n\nstruct TraceData {\n    float dist;\n    vec3 pos;\n    vec3 norm;\n    MatData matData;\n};\n\nfloat intFloor(vec3 pos, vec3 dir, float dist) {\n    float a = pos.y - dist;\n    if (a <= 0.0 || dir.y >= 0.0) return 1.0 / 0.0;\n    float b = sqrt((dir.x * dir.x + dir.z * dir.z) / (dir.y * dir.y) + 1.0) * a;\n//    if (b < 0.001) return 1.0 / 0.0;\n    return b;\n}\n\nfloat intSphere(vec3 pos, vec3 dir, vec3 sph, float rad) {\n    vec3 a = pos - sph;\n    float b = dot(a,dir);\n    float c = dot(a,a) - rad * rad;\n    float d = b * b - c;\n    if (d < 0.0) return 1.0 / 0.0;\n    float e = -b - sqrt(d);\n    if (e < 0.01) {\n        e = -b + sqrt(d);\n        if (e < 0.01) return 1.0 / 0.0;\n    }\n    return e;\n}\n\nvec3 randVec(inout uint s[4]) {\n    vec3 dir = rand3(s) * 2.0 - 1.0;\n    dir /= cos(dir);\n    dir = normalize(dir);\n    return dir;\n}\n\nMatData matDiffuse(inout uint s[4], vec3 dir, vec3 norm, vec3 albedo) {\n    MatData matData;\n    matData.dir = normalize(randVec(s) + norm);\n    matData.albedo = albedo;\n    return matData;\n}\n\nMatData matSpecular(inout uint s[4], vec3 dir, vec3 norm, vec3 albedo, float ior, float roughness, float metallic) {\n    MatData matData;\n    float fresnel = fresnel(dir, norm, ior);\n    if (rand(s) > fresnel * (1.0 - metallic) + metallic) matData = matDiffuse(s, dir, norm, albedo);\n    else {\n        matData.dir = normalize(reflect(dir, norm) + randVec(s) * roughness);\n        matData.albedo = (albedo * (1.0 - fresnel) + fresnel) * metallic + (1.0 - metallic);\n    }\n    return matData;\n}\n\nTraceData trace(inout uint s[4], vec3 pos, vec3 dir) {\n    float dists[] = float[](\n        intFloor(pos, dir, 0.0),\n        intSphere(pos, dir, vec3(-1.5, 1.0, 0.0), 1.0),\n        intSphere(pos, dir, vec3(1.5, 1.0, 0.0), 1.0)\n    );\n    float dist = 1.0 / 0.0;\n    int nearest = 1024;\n    for (int i = 0; i < 3; i++) {if (dists[i] < dist) {dist = dists[i]; nearest = i;}}\n    pos += dir * dist;\n    TraceData traceData;\n    traceData.dist = dist;\n    traceData.pos = pos;\n    switch (nearest) {\n        case 0:\n            traceData.norm = vec3(0.0, 1.0, 0.0);\n            bool a = mod(pos.x, 2.0) >= 1.0 ^^ mod(pos.z, 2.0) >= 1.0;\n            traceData.matData = matSpecular(s, dir, traceData.norm, a ? vec3(1.0) : vec3(0.25), 0.9, 0.0, 0.0);\n            break;\n        case 1:\n            traceData.norm = pos - vec3(-1.5, 1.0, 0.0);\n            traceData.matData = matSpecular(s, dir, traceData.norm, vec3(0.2, 0.7, 0.0), 0.8, 0.3, 0.0);\n            break;\n        case 2:\n            traceData.norm = pos - vec3(1.5, 1.0, 0.0);\n            traceData.matData = matSpecular(s, dir, traceData.norm, vec3(1.0, 0.4, 0.0), 0.8, 0.0, 1.0);\n            break;\n        case 1024:\n            traceData.matData.emmission = vec3(0.2, 0.3, 0.0) * pow(1.0 - max(0.0, dir.y), 2.0) + vec3(0.1, 0.2, 1.0);\n            if (dot(dir, normalize(vec3(-1.0, 3.0, -2.0))) > 0.99) traceData.matData.emmission = vec3(80.0);\n            break;\n    }\n    return traceData;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint[4] s;\n    genState(s, ivec2(fragCoord), iFrame);\n    \n    vec3 pos = vec3(0.0, 1.0, -6.0);\n    vec2 npos;\n    for (int i = 0; i < 4; i++) {\n        npos = rand2(s) * 2.0 - 1.0;\n        if (dot(npos,npos) < 1.0) break;\n    }\n    npos *= 0.03;\n    pos.xy += npos;\n    vec3 dir = normalize(vec3((fragCoord * 2.0 - iResolution.xy + rand2(s) * 2.0 - 1.0) / iResolution.x - npos / 3.0, 2.0));\n    \n    vec3 col;\n    {\n        TraceData traceData;\n        traceData.pos = pos;\n        traceData.matData.dir = dir;\n        vec3 alb = vec3(1.0);\n        for (int j = 0; j < 4; j++) {\n            traceData = trace(s, traceData.pos, traceData.matData.dir);\n            col += traceData.matData.emmission * alb;\n            alb *= traceData.matData.albedo;\n        }\n    }\n\n    fragColor = mix(\n        texture(iChannel0, fragCoord / iResolution.xy),\n        vec4(col, 1.0),\n        1.0 / float(iFrame + 1)\n    );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 146, 146, 332], [334, 334, 391, 391, 506]], "test": "untested"}
{"id": "DttfWr", "name": "experiment inspired by the spher", "author": "mds2", "description": "experiment inspired by the las vegas sphere. I wanted to see what it would look like if I rendered a scene from the *inside* of a sphere and wrapped it as a texture on the outside of a sphere.\n\nIt's not half bad. Works ok from near-ground viewpoints.", "tags": ["raycast", "experiment", "projection"], "likes": 1, "viewed": 92, "published": 3, "date": "1701154733", "time_retrieved": "2024-07-30T17:20:21.075615", "image_code": "#define MAXDIST 40.0\n\nfloat sdf(in vec3 p) {\n  return length(p) - 0.75;\n}\n\nvec3 surfnorm(in vec3 p) {\n  return normalize(p);\n}\n\nfloat raycast(in vec3 orig, in vec3 dir) {\n  float accum = 0.0;\n  for (int i = 0; i < 50; ++i) {\n    vec3 p = orig + accum * dir;\n    float dist = sdf(p);\n    if (abs(dist) < 1.0e-4) {\n      return accum;\n    }\n    accum += 0.95 * dist;\n    if (accum > MAXDIST) {\n      return accum;\n    }\n  }\n  return MAXDIST + 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/min(iResolution.y, iResolution.x);\n    \n    vec3 orig = vec3(0.0, 0.0, -2.0);\n    vec3 dir = normalize(vec3(uv, 1.2));\n\n    float yawAngle = 3.0 * 3.141592654 * iMouse.x/iResolution.x;\n    float pitchAngle = 0.5 * 3.141592654 * (iMouse.y / iResolution.y - 0.5);\n    \n    float ct = cos(yawAngle);\n    float st = sin(yawAngle);\n    \n    mat3 yaw = mat3(ct, 0.0, st, 0.0, 1.0, 0.0, -st, 0.0, ct);\n    \n    ct = cos(pitchAngle);\n    st = sin(pitchAngle);\n    \n    mat3 pitch = mat3(1.0, 0.0, 0.0, 0.0, ct, st, 0.0, -st, ct);\n    \n    orig = yaw * pitch * orig;\n    dir = yaw * pitch * dir;\n\n    float dist = raycast(orig, dir);\n    \n    vec3 col = texture(iChannel1, dir).rgb;\n    \n    if (dist < MAXDIST) {\n      col = vec3(0.0);\n      vec3 p = orig + dist * dir;\n      vec3 n = surfnorm(p);\n      vec3 bounce = normalize(reflect(dir, n));\n      col += 0.25 * texture(iChannel2, bounce).rgb;\n      col += 0.8 * texture(iChannel0, n).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 73], [75, 75, 101, 101, 126], [128, 128, 170, 170, 447], [450, 450, 507, 557, 1606]], "test": "untested"}
{"id": "ct3BDr", "name": "Rocky Pudd caustics", "author": "ilia87", "description": "A puddle in a rocky terrain with rain falling onto it. Use the mouse to create small water-bug like movement on the water.\nIMPORTANT: Works best with resolution of at least 800x400\nPress: L to move the light.\nC to rotate camera.\nP to see wave simulation.", "tags": ["raymarching", "waves", "rain", "rocks"], "likes": 13, "viewed": 350, "published": 3, "date": "1701120233", "time_retrieved": "2024-07-30T17:20:22.029065", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.1415927\n\n#define CLOUDS 0\n#define NO_SUN_BLOCKAGE 0\n#define GOO 0\n#define MURKY 1\n#define eta 0.5\n\nvec3 light = normalize(vec3(.4,-1.0,.75));\n\nfloat WaveHeight(vec2 p)\n{\n     return texture(iChannel2, WaterBuffPixelForXY(p.xy,iResolution.xy) / iResolution.xy).z * waterWaveHeight;\n}\n\nvec3 WaterNormal_fine(vec2 p)\n{\n    if ( any(greaterThan(abs(p.xy-waterSimCenter),waterSimSize*.5 )))\n        return vec3(0,0,-1);\n    vec4 data = texture(iChannel2, WaterBuffPixelForXY(p.xy,iResolution.xy) / iResolution.xy);\n    vec2 dh = data.xy * waterWaveHeight;\n    //return vec3(dh*1000.,-1.);\n    vec2 dxy = GetWaterDXYForPixel(iResolution.xy);\n    return normalize(-cross(vec3(dxy.x,0.,dh.x),vec3(0.,dxy.y,dh.y))); //minus sign because system is left-handed\n}\n\nfloat CloudsFBM(vec3 uvw)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<6;++i)\n    {\n        vec3 ijk = floor(uvw);\n        float a = noise(ijk);\n        float b = noise(ijk+vec3(1.,0.,0.));\n        float c = noise(ijk+vec3(0.,1.,0.));\n        float d = noise(ijk+vec3(1.,1.,0.));\n        \n        float az = noise(ijk+vec3(0.,0.,1.));\n        float bz = noise(ijk+vec3(1.,0.,1.));\n        float cz = noise(ijk+vec3(0.,1.,1.));\n        float dz = noise(ijk+vec3(1.,1.,1.));\n        \n        float sx = smoothstep(0.,1.,fract(uvw.x));\n        float sy = smoothstep(0.,1.,fract(uvw.y));\n        float sz = smoothstep(0.,1.,fract(uvw.z));\n        \n        \n        \n        float v =\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy;\n        float vz =\n            az\n            + (bz-az)*sx\n            + (cz-az)*sy\n            + (az-bz-cz+dz)*sx*sy;\n        x+= factor * (v + (vz-v)*sz);\n            \n        factor *=.59;\n        uvw += vec3(5.3241634,6.35134134,7.7654352);\n        uvw *= 2.2;\n        uvw.z*=1.02113;\n        uvw.xy*=m2;\n        //uvw *= m3;\n        //uvw = uvw.yzx;\n    }\n    return x;\n}\n\nvec3 Sky(vec3 ro, vec3 rd, out float sunBlockage)\n{\n    vec3 c0 = vec3(.6,.6,1.);\n    vec3 col=c0;\n    float v = 0.;\n#if CLOUDS\n    const float skyHeight = -1000.;\n    float dist = (skyHeight - ro.z)/rd.z; \n    const vec2 speed = vec2(0.,30.);\n    const float morphSpeed = 10.;\n    vec3 p = vec3(ro.xy + rd.xy * dist + iTime*speed,iTime*morphSpeed);\n    v = 1.-smoothstep(-.9,0.5,CloudsFBM(p*.001));\n    //for ( int j=0;j<1;++j)\n    //{\n    //    v *= 1.-smoothstep(-.9,0.5,CloudsFBM((p+rd*100.*float(j))*.001));\n    //}\n    v = smoothstep(0.,1.,sqrt(v))*2.-1.;\n    \n    vec3 c1 = vec3(1.5);\n    vec3 c2 = vec3(1.2);\n    vec3 c3 = vec3(.6);\n    col = mix(col,c1,smoothstep(-.8,1.,v));\n#endif\n    //col = mix(col,c2,smoothstep(-.2,.4,v));\n    //col = mix(col,c3,smoothstep(0.,1.,v));\n    vec3 L = light;\n    float cosSunAngle = dot(-L,rd);\n    //float sunRadius = radians(.25);\n    float sunRadius = radians(1.);\n    float sunFactor = (cosSunAngle > cos(sunRadius))? 1.0 : 0.0;;\n    float sunHalo = 1.-smoothstep(cos(sunRadius),cos(sunRadius*4.),cosSunAngle);\n    sunHalo = pow(sunHalo,2.5);\n    vec3 sun = (sunFactor*4. + sunHalo*2.)*vec3(1.,1.,.4);\n#if NO_SUN_BLOCKAGE\n    sunBlockage = 0.;\n#else\n    sunBlockage = smoothstep(-.4,1.,v);\n    sunBlockage*=sunBlockage;\n    sunBlockage*=.5;\n#endif\n    col += sun * (1.-sunBlockage);\n    return col*1.5;\n}\n\n\nfloat DX[9] = float[9](\n            -.25,0.,.25,\n            -.5,0.,.5,\n            -.25,0.,.25);\n\nvec3 RocksNormal(vec2 xy)\n{\n    const float d = 0.03;\n    float h = RocksTotal(xy, iChannel0, iChannel1);\n    float dh_dx = 0., dh_dy = 0.;\n    //float dh_dx = RocksHeight(xy + vec2(d,0.)) - h;\n    //float dh_dy = RocksHeight(xy + vec2(0.,d)) - h;\n    for ( int i=0;i<3;++i)\n    {\n        for ( int j=0;j<3;++j)\n        {\n            float dx = d*float(i-1);\n            float dy = d*float(j-1);\n            float v = RocksTotal(xy + vec2(dx,dy), iChannel0, iChannel1);\n            dh_dx += v * DX[j*3+i];\n            dh_dy += v * DX[i*3+j];\n        }\n    }\n    return -normalize(cross(vec3(d,0.,-dh_dx),vec3(0.,d,-dh_dy))); //minus sign because system is left handed\n}\n\nbool MarchTerrain(vec3 ro, vec3 rd, out vec3 p)\n{\n    p = ro;\n    float totalDist = 0.;\n    //float prevDE = 0.;\n    for ( int iStep = 0;iStep < MAX_STEPS;++iStep)\n    {\n        float h = -RocksTotal(p.xy, iChannel0, iChannel1);\n        float de = (h-p.z);\n        if (abs(de) < SURFACE_DIST)\n            return true;\n        //if (de < 0.)\n        //{\n        //    de=prevDE*-.5;\n        //    prevDE *= .5;\n        //}\n        //else\n        //{\n        //    prevDE = de;\n        //}\n        totalDist += .5*de;\n        p = ro + totalDist * rd;\n        if (totalDist > MAX_DIST)\n            return false;\n    }\n    return false;\n}\n\nmat3 MouseToRot()\n{\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.xy;\n    float phi = mouse.x*PI;\n    float theta = (1.+mouse.y)*PI*.5;\n    float cp = cos(phi);\n    float sp = sin(phi);\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat3 Mp = mat3(\n        cp,-sp,0.,\n        sp,cp,0.,\n        0.,0.,1.);\n    mat3 Mt = mat3(\n        1.,0.,0.,\n        0.,ct,-st,\n        0.,st,ct);\n    return Mp*Mt;\n}\n\nfloat Shadow(vec3 dest, vec3 lightSrc)\n{\n    vec3 L = normalize(dest - lightSrc);\n    vec3 p = lightSrc;\n    float closestDist = MAX_DIST;\n    const float shadowMinDist = 0.1;\n    for ( int iStep = 0;iStep < 50;++iStep)\n    {\n        float h = -RocksTotal_ld(p.xy, iChannel0, iChannel1);\n        float de = (h-p.z);\n        closestDist = min(closestDist,de);\n        if (de < SURFACE_DIST)\n            return 0.;\n        if (abs(de) > MAX_DIST)\n            return 1.;\n        p += (.5*de) * L;\n        if ( dot(dest-p,L)<shadowMinDist )\n        {\n            return smoothstep(0.,0.1,closestDist);\n            return 1.0;\n        }\n        //prevDist = de;\n    }\n    return 0.;//smoothstep(0.,0.05,closestDist);\n}\n\nconst float shadowCheckDist = 100.;\n\nfloat FBM_goo(vec2 uv)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<8;++i)\n    {\n        vec2 ij = floor(uv);\n        float a = noise(ij);\n        float b = noise(ij+vec2(1.,0.));\n        float c = noise(ij+vec2(0.,1.));\n        float d = noise(ij+vec2(1.,1.));\n        float sx = smoothstep(0.,1.,fract(uv.x));\n        float sy = smoothstep(0.,1.,fract(uv.y));\n        x+= factor*(\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy);\n        factor *=.7;\n        uv *= 2.5;\n        uv *= m2;\n    }\n    return x;\n}\n\nvoid GetTerrainColor(vec3 p, vec3 light, out vec3 diffuse, out vec3 ambient)\n{\n    vec3 N = RocksNormal(p.xy);\n#if GOO\n    float goo = FBM_goo((p.xy-vec2(12.5,-3.))*.1);\n    goo = smoothstep(-1.,1.,goo)*.8;\n    goo *= smoothstep(-2.,-.5,p.z - waterLevel);\n#endif\n    if ( abs(p.z + Rocks1(p.xy, iChannel1)+Floor(p.xy)) < .05 )\n    {\n        diffuse = mix(texture(iChannel1,p.xy*.1).xyz,vec3(1.,1.,1.),.5);\n        ambient = diffuse;\n        diffuse *= vec3(1.,.8,.6);\n        ambient *= vec3(.8,.7,.5);\n#if GOO\n        diffuse = mix(diffuse,vec3(0.1,.2,.15),goo);\n        ambient = mix(ambient,vec3(0.2,.35,.3),goo);\n#endif\n    }\n    else\n    {\n        diffuse = mix(texture(iChannel1,p.xy*.2).xyz,vec3(1.,1.,1.),.5);\n        ambient = diffuse;\n        diffuse *= vec3(1.,.9,.8);\n        ambient *= vec3(.8,.75,.7);\n#if GOO\n        diffuse = mix(diffuse,vec3(0.1,.2,.15),goo*goo);\n        ambient = mix(ambient,vec3(0.2,.35,.3),goo*goo);\n#endif\n    }\n    diffuse *=  vec3(.6*sqrt(max(dot(light,-N),0.)))*1.5;\n    ambient *= .9;\n    diffuse *= .8;\n}\n\nvec3 MarchReflection(vec3 ro, vec3 rd)\n{\n    vec3 p;\n    MarchTerrain(ro,rd,p);\n    if ( dot(p-ro,p-ro) > 10000. )\n    {\n        float sunBlockage;\n        return Sky(ro,rd,sunBlockage);\n    }\n    float shadow = Shadow(p,p - light * shadowCheckDist);\n    float sunBlockage;\n    Sky(p,-light,sunBlockage);\n    shadow *= 1.-sunBlockage;\n    \n    vec3 diffuse,ambient;\n    GetTerrainColor(p,light,diffuse,ambient);\n    diffuse *= shadow;\n    return diffuse + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = texelFetch(iChannel2,ivec2(fragCoord),0)*.5+.5;\n    //return;\n    mat3 mouseRot = MouseToRot();\n    if ( texelFetch(iChannel3,ivec2(76,0),0).x >0.)\n    {\n        light = mouseRot * vec3(0.,0.,-1.);\n    }\n    vec3 rd = vec3((2.*fragCoord-iResolution.xy) / iResolution.x,1.);\n    if ( texelFetch(iChannel3,ivec2(67,0),0).x >0.)\n    {\n        rd = mouseRot * rd;\n    }\n    else\n    {\n        rd = PixelToRay(fragCoord,iResolution.xy);\n    }\n    \n    vec3 ro = camPos + rd;\n    rd = normalize(rd);\n    //fragColor.xyz = Sky(camPos,rd);\n    //return;\n    //fragColor.xyz = TerrainNormal(ro.xy)*.5+.5;\n    //return;\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 p;\n    if ( !MarchTerrain(ro,rd,p) )\n    {\n        //fragColor = vec4(0.,0.,1.,1.);\n        //return;\n    }\n\n    if (texelFetch(iChannel3,ivec2(80,0),0).x!=0.)\n    {\n        vec2 waterXY = p.xy-rd.xy*(p.z-waterLevel)/rd.z;\n        if ( all(lessThan(abs(waterXY - waterSimCenter),waterSimSize*.5 )) )\n        {\n            fragColor = texture(iChannel2, WaterBuffPixelForXY(waterXY,iResolution.xy) / iResolution.xy);\n            return;\n        }\n    }\n    \n    //\n    \n    float shadow = 1.;\n    vec3 lightEntryPoint = p;\n    float waterReflectionCoeff = 0.;\n    float waterReflectionLightCoeff=0.;\n    bool belowWater = p.z > waterLevel;\n    vec3 lightRefracted = light;\n    float shadowInsideWater = 1.0;\n    float caustics = 0.0;\n    vec3 reflectedLight = vec3(0.);\n    float depth = 0.;\n    if ( belowWater)\n    {\n        float waterDist = (waterLevel - ro.z)/rd.z;\n        vec3 waterPos = ro + waterDist*rd;\n        depth = p.z - (waterLevel + waterWaveHeight*2. + WaveHeight(waterPos.xy)*15.);\n        if ( depth < 0.)\n        {\n            belowWater = false;\n        }\n        else\n        {\n            vec3 waterNormal = WaterNormal_fine(waterPos.xy);\n            vec3 rd_t;\n            float rs,rp;\n            Fresnel(rd,rd_t,waterNormal,eta,rs,rp);\n            vec3 rd_r = reflect(rd,waterNormal);\n            waterReflectionCoeff = .5*(rp+rs);\n            reflectedLight = MarchReflection(waterPos,rd_r) * waterReflectionCoeff;\n            MarchTerrain(waterPos,rd_t,p);\n            rd = rd_t;\n\n            float rsl,rpl;\n            Fresnel(light,lightRefracted,waterNormal,eta,rsl,rpl);\n            waterReflectionLightCoeff = .5*(rsl+rpl);\n            float lightDistInsideWater = depth / lightRefracted.z;\n            lightEntryPoint = p - lightRefracted*lightDistInsideWater;\n            shadowInsideWater = Shadow(p,lightEntryPoint);\n            caustics = texture(iChannel2, WaterBuffPixelForXY(lightEntryPoint.xy,iResolution.xy) / iResolution.xy).w;\n        }\n    }\n    shadow = Shadow(lightEntryPoint,lightEntryPoint - light * shadowCheckDist);\n    float sunBlockage;\n    Sky(lightEntryPoint,-light,sunBlockage);\n    shadow *= 1.-sunBlockage;\n    //reflectedLight *= shadow;\n    shadow *= shadowInsideWater;\n    \n    //vec3 V = camPos - p;\n    vec3 diffuse;\n    vec3 ambient;\n\n    GetTerrainColor(p,lightRefracted,diffuse,ambient);\n    diffuse *= shadow;\n    diffuse *= 1.+max(-0.5, caustics*15.);\n\n\n    //fragColor.xyz *= 1.-.2*smoothstep(.02,3.5,L*.55);\n    //if ( p.z >2.)\n    //{\n    //p.z = max(p.z,2.)-2.;\n    //fragColor.xyz *= exp(-p.z*p.z*vec3(.05,.046,.036)*1.2)*8.;\n    if ( belowWater)\n    {\n#if MURKY\n        float waterDist = depth/rd.z;\n        \n        float depthFactor = clamp(1.-exp(-waterDist*.1)+.4,0.,1.);\n        diffuse = mix(diffuse,vec3(.2,.3,.1),depthFactor);\n        ambient = mix(ambient,vec3(.2,.3,.1),depthFactor);\n        ambient *= pow(abs(1.-depthFactor),0.3);\n#endif   \n        diffuse *= (1.-waterReflectionLightCoeff);\n        //ambient *= (1.-waterReflectionLightCoeff);\n    }\n    \n    fragColor.xyz += (1.-waterReflectionCoeff)*(diffuse + ambient);\n    fragColor.xyz += reflectedLight;\n    //fragColor.xyz = p*.1+.5;\n    //}\n    //else\n    //{\n    //    fragColor.xyz *= 6.;\n    //}\n    //fragColor.xyz = vec3(L*50.);\n\n    //fragColor = vec4(texture(iChannel0,uv).x);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define KEY_SPACE 32\nconst vec3 camPos = vec3(0.,-12.,-7.);\n\nconst vec2 puddleCenter = vec2(0.,0.);\nconst float waterLevel = 2.3;\nconst float waterWaveHeight = .01;\nconst vec2 waterSimCenter = vec2(2.,-8.5);\nconst vec2 waterSimSize = vec2(20.,40.);\nconst vec2 waterBufferIdealSize = vec2(800.,400.);\n\n//const mat2 m2 = mat2(5./13.,12./13.,-12./13.,5./13.);\nconst mat2 m2 = mat2(.6,.8,-.8,.6);\n//const mat3 m3 = mat3(\n//                .6,  0.,  .8,\n//                0.,  1., 0.,\n//                -.8, 0., -.6) \n//                * mat3(\n//                1.,0.,0.,\n//                0.,5./13.,12./13.,\n//                0.,-12./13.,5./13.)*mat3(\n//                .6,  0.,  .8,\n//                0.,  1., 0.,\n//                -.8, 0., -.6) ;\n\nvoid Fresnel(\n    vec3 i,       //incoming ray\n    out vec3 t,   //transmitted ray\n    vec3 n,       //normal\n    float eta,    //ratio of refractive indices (n1/n2)\n    out float rs, //reflection coefficient for s polarization\n    out float rp  //reflection coefficient for p polarization\n)\n{\n    float ci = -dot(i,n);\n    float si = sqrt(1.-ci*ci);\n    float st = si*eta;\n    float ct = sqrt(1.-st*st);\n    t = (eta*ci - ct) * n + eta * i;\n    //t = refract(i,n,eta);\n    rs = (eta * ci - ct)/(eta*ci + ct);\n    rs = rs*rs;\n    rp = (eta * ct - ci)/(eta*ct + ci);\n    rp = rp*rp;\n}\n\n/////////////////////////////////////////////\n\nconst float LaplacianSquaredKernel[25] = float[25](0.02777778,  0.22222222,   0.5,  0.22222222, 0.02777778,\n    0.22222222, -0.22222222,  -4. , -0.22222222, 0.22222222,\n    0.5       , -4.        ,  13. , -4.        , 0.5       ,\n    0.22222222, -0.22222222,  -4. , -0.22222222, 0.22222222,\n    0.02777778,  0.22222222,   0.5,  0.22222222, 0.02777778);\n\n\nconst int LaplacianKernelDeg = 5;\nconst int LaplacianKernelHalfDeg = 2;\n\nconst float LaplacianKernel[25] = float[25]\n(-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.06666667,  1.06666667, -4.5       ,  1.06666667, -0.06666667,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333);\n\n/////////////////////////////\n\nfloat noise(float i)\n{\n    float x = fract(i*3.453462472+.45623426)*50.;\n    return 2.*fract(x*x)-1.;\n}\n\n\nfloat noise(vec2 ij)\n{\n    vec2 xy = fract(ij*vec2(3.453462472,6.76235421)+vec2(.45623426,.57422783))*50.;\n    return 2.*fract(xy.x*xy.y*(xy.x+xy.y))-1.;\n}\n\nfloat noise(vec3 ijk)\n{\n    vec3 xyz = fract(ijk*vec3(3.453462472,6.76235421,1.2452341)+vec3(.45623426,.57422783,.7552213513))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x)*(xyz.x+xyz.y+xyz.z))-1.;\n}\n\n\nfloat FloorFBM(vec2 uv)\n{\n    float x = 0.;\n    float factor=1.;\n    for ( int i=0;i<5;++i)\n    {\n        vec2 ij = floor(uv);\n        float a = noise(ij);\n        float b = noise(ij+vec2(1.,0.));\n        float c = noise(ij+vec2(0.,1.));\n        float d = noise(ij+vec2(1.,1.));\n        float sx = smoothstep(0.,1.,fract(uv.x));\n        float sy = smoothstep(0.,1.,fract(uv.y));\n        x+= factor*(\n            a\n            + (b-a)*sx\n            + (c-a)*sy\n            + (a-b-c+d)*sx*sy);\n        factor *=.4;\n        uv *= 1.8;\n        uv *= m2;\n    }\n    return x;\n}\n\nfloat Floor(vec2 p)\n{\n    float h =0.;\n    vec2 q = p-puddleCenter;\n    float lq2 = q.x*q.x + q.y*q.y;\n    const float r = 1./11.5;\n    h += -6./(1. + lq2*r*r);\n    float h_fbm = FloorFBM((q.xy+vec2(2.23523,6.75676))*0.1)*3.5;\n    //h_fbm += 1.;\n    h_fbm = pow(abs(h_fbm),2.2)*.4;\n    h_fbm = 1.-h_fbm;\n    h+=h_fbm*1.5;\n    //if ( h < -5.)\n        //h*=1.+pow((-5.-h)*.42,6.);// /pow(q.x*q.x+.4,2.);\n    h += 1.1;\n    //h += texture(iChannel0,(p.xy+vec2(5.8234,.67756))*0.04).x*3.;\n    //h += texture(iChannel0,m2*(p.xy+vec2(1.6246,3.68567))*0.02).x*3.;\n    return h;\n}\n\nfloat Rocks1(vec2 p, sampler2D channel1)\n{\n    float h2 = texture(channel1,(p.xy+vec2(6.23235,3.576588))*.02).x*.05;\n    h2 -= texture(channel1,(p.xy+vec2(8.23235,2.576588))*.04).x*.02;\n    //h2 *= 1.-smoothstep(4.0,10.0,distFromCenter);\n    h2 *= 2.;\n\n    return h2;\n}\n\n\nfloat Rocks2(vec2 p, sampler2D channel0)\n{\n    //float distFromCenter = length(p - puddleCenter);\n    float h = texture(channel0,(p.xy+vec2(-1.53242,5.65252))*0.04).x;\n    //h += texture(iChannel1,m2*(p.xy+vec2(.23235,4.576588))*.015).x*.05;\n    //h *= 1.-smoothstep(15.,100.0,distFromCenter);\n    \n    //h -= .5;\n    //h=max(h,0.);\n    //float h0 = .2;\n    //if ( h>h0)\n    //    h = h0 + pow(h-h0,.6); \n    h = smoothstep(0.5,1.,h*1.0);\n    h *= 3.5;\n        \n    return h;\n}\n\nfloat Rocks3(vec2 p, sampler2D channel0)\n{\n    //float distFromCenter = length(p - puddleCenter);\n    float h2 = texture(channel0,(p.xy+vec2(0.543521,.2766367))*0.16).x;\n    //h += texture(iChannel1,(p.xy+vec2(.23235,.576588)*.02)).x*.02;\n    //h2 *= 1.-smoothstep(15.,100.0,distFromCenter);\n    \n    //h -= .5;\n    //h=max(h,0.);\n    //float h0 = .2;\n    //if ( h>h0)\n    //    h = h0 + pow(h-h0,.6); \n    h2 = smoothstep(0.5,1.,h2*1.0);\n    h2 *= .3;\n    return h2;\n}\n\nfloat RocksTotal(vec2 p, sampler2D channel0, sampler2D channel1)\n{\n    return max(max(Rocks1(p,channel1),Rocks2(p,channel0)),Rocks3(p,channel0)) + Floor(p);\n}\n\nfloat RocksTotal_ld(vec2 p, sampler2D channel0, sampler2D channel1)\n{\n    return max(Rocks2(p,channel0),Rocks3(p,channel0)) + Floor(p);\n}\n\n////////////////////////////////////////\n\nvec2 GetWaterBufferSize(vec2 resolution)\n{\n    float ar = waterSimSize.y/waterSimSize.x;\n    float y = min(waterBufferIdealSize.y,resolution.y);\n    float x = min(y*ar,resolution.x);\n    y = min(y,x/ar);\n    return vec2(x,y);\n}\n\nvec2 GetWaterDXYForPixel(vec2 resolution)\n{\n    return waterSimSize.yx/GetWaterBufferSize(resolution);\n}\n\nvec2 WaterBuffPixelForXY(vec2 xy, vec2 resolution)\n{\n    return clamp(((xy-waterSimCenter) / waterSimSize + 0.5),0.,1.).yx * GetWaterBufferSize(resolution);\n}\n\nvec2 WaterBuffPixelToXY(vec2 pixelCoords, vec2 resolution)\n{\n    return (pixelCoords / GetWaterBufferSize(resolution) - 0.5).yx*waterSimSize + waterSimCenter;\n}\n\n\n\n\n////////////////////////////////////////\n\nvec3 PixelToRay(vec2 pixel,vec2 resolution)\n{\n    vec3 rd = vec3((2.*pixel-resolution) / resolution.x,1.);\n    float a = radians(45.);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 M = mat2(c,-s,s,c);\n    rd.yz = M*rd.yz;\n    return rd;\n}\n", "buffer_a_code": "\nvoid Rain(out vec4 fragColor, in vec2 fragCoord )\n{\n    const float freq = 2.;\n    float t = iTime;\n    float x = fract(t*freq);\n    float fallOff = 30.;\n    vec2 k = vec2(exp(-x*fallOff), -freq*fallOff*exp(-x*fallOff));\n    float i = floor(t*freq);\n    float u = noise(i)*.5+.5;\n    float v = noise(i*7.52341+.57424)*.5+.5;\n    vec2 uv = vec2(u,v);\n    vec2 d = fract(vec2(7.52624514,6.2365432)*texture(iChannel1,uv).xy - texture(iChannel1,fract((uv+vec2(.362456,.678562))*52.16572788)).xy);\n    vec2 waveSrc = d * GetWaterBufferSize(iResolution.xy);\n    float waveSrcSize = 3.0;\n    float srcStrength = .5+.5*u;\n    float d2 = dot(fragCoord - waveSrc,fragCoord-waveSrc);\n    fragColor.xy += srcStrength * exp(-d2/(waveSrcSize*waveSrcSize)) * k;\n}\n\nvec2 SineSrc(float t, float freq)\n{\n    //freq*=2.;\n    return vec2(sin(6.2831853*freq*iTime),6.2831853*freq*cos(6.2831853*freq*iTime));\n}\n\nvec2 KickSrc(float t,float freq)\n{\n    float x = fract(t*freq);\n    float fallOff = 30.;\n    return vec2(exp(-x*fallOff), -freq*fallOff*exp(-x*fallOff));\n}\n\nvec2 MixedSrc(float t,float freq)\n{\n    return SineSrc(t,freq) + KickSrc(t,freq);\n}\n\n//#define SrcFunc SineSrc\n//#define SrcFunc MixedSrc\n#define SrcFunc KickSrc\n\nvec2 waterBufferSize;\n\nvoid AddSource( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waveSrc = iMouse.xy;\n    //if ( waveSrc.x == 0. && waveSrc.y == 0.)\n        waveSrc =  waterBufferSize * .5;\n    float waveSrcSize = 2.0;\n    float waveSrcFreq = .2;\n    float d2 = dot(fragCoord - waveSrc,fragCoord-waveSrc);\n    fragColor.xy += exp(-d2/(waveSrcSize*waveSrcSize)) * SrcFunc(iTime,waveSrcFreq);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n    || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    vec2 p = WaterBuffPixelToXY(fragCoord, iResolution.xy);\n    float depth = RocksTotal_ld(p,iChannel0,iChannel1) + waterLevel;\n    if ( depth > 0. )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    float timeDelta = min(iTimeDelta,0.01);\n\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    //float waveLength = 2.;\n    float waveSpeed = 50. - 15.*smoothstep(-.2,.0,depth);\n    //float waveSpeed = 50.;\n    //float dampRate = .5 + 2.5 * smoothstep(-.1,.0,depth);//waveSpeed * 100.;\n    float dampRate = .5;\n    //float diffusionRate = .1;\n    float k4thOrder = 1.;\n    float k2ndOrder = 1.;\n        \n    \n    //AddSource(fragColor,fragCoord);\n    Rain(fragColor,fragCoord);\n    \n    if ( iMouse.z >0.)\n    {\n        vec3 rd = PixelToRay(iMouse.xy,iResolution.xy);\n        rd = normalize(rd);\n        vec2 srcPos = WaterBuffPixelForXY(camPos.xy + rd.xy * (waterLevel-camPos.z)/rd.z, iResolution.xy);\n        fragColor.x = -.9*exp(-dot(fragCoord - srcPos,fragCoord - srcPos)/4.0);\n    }\n    \n    \n    vec4 prevPixel = texelFetch(iChannel3,ivec2(fragCoord),0);\n    float h = prevPixel.x;\n    float dh_dt = prevPixel.y;\n    \n    \n    //float L = 0.;\n    //float L2 = 0.;\n    //for ( int i=0;i<5;++i)\n    //{\n    //\tfor ( int j=0;j<5;++j)\n    //\t{\n    //\t\tfloat v = texelFetch(iChannel3,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    //\t\tL -= v;\n    //\t\tL2 += L2kernel[i*5+j] * v;\n    //\t}\n    //}\n    //L += 25.*h;\n    float L = 0.;\n    for ( int i=0;i<LaplacianKernelDeg;++i)\n    {\n        for ( int j=0;j<LaplacianKernelDeg;++j)\n        {\n            L -= LaplacianKernel[i*LaplacianKernelDeg+j] * texelFetch(iChannel2,ivec2(int(fragCoord.x)+i-LaplacianKernelHalfDeg,int(fragCoord.y)+j-LaplacianKernelHalfDeg),0).x;\n        }\n    }\n    float L2 = 0.;\n    for ( int i=0;i<5;++i)\n    {\n    \tfor ( int j=0;j<5;++j)\n    \t{\n    \t\tfloat v = texelFetch(iChannel2,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    \t\tL2 += LaplacianSquaredKernel[i*5+j] * v;\n    \t}\n    }\n    \n    float d2h_dt2 = (-L*k2ndOrder-L2*k4thOrder) *(waveSpeed*waveSpeed);\n    dh_dt += d2h_dt2 * timeDelta;\n    h += dh_dt * timeDelta;\n    \n    h *= exp(-timeDelta*dampRate);\n    \n    fragColor.x += h;\n    fragColor.y += dh_dt;\n    fragColor.z = L;\n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float G[25] = float[25]\n(0.00048091, 0.00501119, 0.01094545, 0.00501119, 0.00048091,\n0.00501119, 0.0522178 , 0.11405416, 0.0522178 , 0.00501119,\n0.01094545, 0.11405416, 0.2491172 , 0.11405416, 0.01094545,\n0.00501119, 0.0522178 , 0.11405416, 0.0522178 , 0.00501119,\n0.00048091, 0.00501119, 0.01094545, 0.00501119, 0.00048091);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n        || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    //Apply gaussian kernel\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    for ( int i=0;i<5;++i)\n        for ( int j=0;j<5;++j)\n            fragColor.x += G[i*5+j] * texelFetch(iChannel0,ivec2(int(fragCoord.x)+i-2,int(fragCoord.y)+j-2),0).x;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float D[9] = float[9]\n(-.5,0.,.5,\n -1.,0.,1.,\n -.5,0.,.5);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 waterBufferSize = GetWaterBufferSize(iResolution.xy);\n    if ( iFrame < 5 \n        || fragCoord.x >= waterBufferSize.x || fragCoord.y >= waterBufferSize.y )\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    //Differentiate by x,y\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    for ( int i=0;i<3;++i)\n        for ( int j=0;j<3;++j)\n        {\n            float v = texelFetch(iChannel0,ivec2(int(fragCoord.x)+i-1,int(fragCoord.y)+j-1),0).x;\n            fragColor.x += D[i*3+j] * v;\n            fragColor.y += D[j*3+i] * v;\n        }\n    fragColor.z = texelFetch(iChannel0,ivec2(fragCoord),0).x;\n    fragColor.w = texelFetch(iChannel1,ivec2(fragCoord),0).z;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3BDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 252, 252, 365], [367, 367, 398, 398, 834], [836, 836, 863, 863, 1999], [2001, 2001, 2052, 2052, 3353], [3455, 3455, 3482, 3482, 4124], [4126, 4126, 4175, 4175, 4760], [4762, 4762, 4781, 4781, 5188], [5190, 5190, 5230, 5230, 5903], [5942, 5942, 5966, 5966, 6512], [6514, 6514, 6592, 6592, 7562], [7564, 7564, 7604, 7604, 8030], [8032, 8032, 8089, 8169, 12098]], "test": "untested"}
{"id": "dl3BWn", "name": "Sketch (Tabyltop)", "author": "DrieStone", "description": "hand draw effect original idea by  flockaroo see https://www.shadertoy.com/view/XtVGD1", "tags": ["effect", "postprocess", "sketch", "pencil", "drawing", "hand"], "likes": 3, "viewed": 317, "published": 3, "date": "1701119619", "time_retrieved": "2024-07-30T17:20:22.793023", "image_code": "// created by sofiene71 - 2017\n//original idea by  flockaroo see https://www.shadertoy.com/view/XtVGD1\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some hand drawing style\n\n\n#define SHADERTOY\n#ifdef SHADERTOY\n#define Res0 iChannelResolution[0].xy\n#define Res1 iChannelResolution[1].xy\n#else\n#define Res0 textureSize(iChannel0,0)\n#define Res1 textureSize(iChannel1,0)\n#define iResolution Res0\n#endif\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n\n\nvec4 getCol(vec2 pos)\n{\n    // take aspect ratio into account\n    vec2 uv=pos/Res.xy;\n    vec4 c1=texture(iChannel0,uv);\n    vec4 e=smoothstep(vec4(-0.05),vec4(-0.0),vec4(uv,vec2(1)-uv));\n    c1=mix(vec4(1,1,1,0),c1,e.x*e.y*e.z*e.w);\n    float d=clamp(dot(c1.xyz,vec3(-.5,1.,-.5)),0.0,1.0);\n    vec4 c2=vec4(.7);\n    return min(mix(c1,c2,1.8*d),.7);\n}\n\nvec4 getColHT(vec2 pos)\n{\n \treturn smoothstep(0.795,1.05,getCol(pos)*.8+.2+1.0);\n}\n\nfloat getVal(vec2 pos)\n{\n    vec4 c=getCol(pos);\n \treturn pow(dot(c.xyz,vec3(.333)),1.)*1.;\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n   \tvec2 d=vec2(eps,0.);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n    )/eps/2.;\n}\n\n\n  float lum( vec3 c) {\n              return dot(c, vec3(0.3, 0.59, 0.11));\n             }\n\n\n vec3 clipcolor( vec3 c) {\n                  float l = lum(c);\n                  float n = min(min(c.r, c.g), c.b);\n                  float x = max(max(c.r, c.g), c.b);\n                \n                 if (n < 0.0) {\n                     c.r = l + ((c.r - l) * l) / (l - n);\n                     c.g = l + ((c.g - l) * l) / (l - n);\n                     c.b = l + ((c.b - l) * l) / (l - n);\n                 }\n                 if (x > 1.25) {\n                     c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                     c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                     c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n                 }\n                 return c;\n             }\n\n vec3 setlum( vec3 c,  float l) {\n                 float d = l - lum(c);\n                 c = c + vec3(d);\n                 return clipcolor(0.85*c);\n }\n\n#define AngleNum 3\n\n#define SampNum 9\n\n#define PI2 6.28318530717959\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float sum=0.;\n    \n    for(int i=0;i<AngleNum;i++)\n    {\n        float ang=PI2/float(AngleNum)*(float(i)+0.8);\n        vec2 v=vec2(cos(ang),sin(ang));\n        for(int j=0;j<SampNum;j++)\n        {\n            vec2 dpos  = v.yx*vec2(1,-1)*float(j)*iResolution.y/920.;\n            vec2 dpos2 = 5.0*( v.xy*float(j*j)/float(SampNum)*.5*iResolution.y/920.);\n\t        vec2 g;\n            float fact;\n            float fact2;\n            float s=3.5;\n\n          \n            \n                vec2 pos2=pos+s*dpos+dpos2;\n                \n            \tg=getGrad(pos2,0.08);\n            \tfact=dot(g,v)-.5*abs(dot(g,v.yx*vec2(1,-1)));\n            \tfact2=dot(normalize(g+vec2(.0001)),v.yx*vec2(1,-1));\n                \n                fact=clamp(fact,0.,.05);\n                fact2=abs(fact2);\n                \n                fact*=1.-float(j)/float(SampNum);\n            \tcol += fact;\n            \tcol2 += fact2;\n            \tsum+=fact2;\n            \n        }\n    }\n    col/=float(SampNum*AngleNum)*0.65/sqrt(iResolution.y);\n    col2/=sum;\n    col.x*=1.6;\n    col.x=1.-col.x;\n    col.x*=col.x*col.x;\n\n    vec2 s=sin(pos.xy*.1/sqrt(iResolution.y/720.));\n    vec3 karo=vec3(1);\n    karo-=.75755*vec3(.25,.1,.1)*dot(exp(-s*s*80.),vec2(1.));\n    float r=length(pos-iResolution.xy*.5)/iResolution.x;\n    float vign=1.-r*r*r;\n\tfragColor = vec4(vec3(col.x*col2*karo*vign ),1);\n    vec4 origCol = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    vec4 overlayColor = vec4(0.3755,0.05,0.,0.0)*origCol;\n           \n    fragColor = vec4( setlum(1.25*overlayColor.rgb, lum(fragColor.rgb)) * 1.0, 0.);\n    fragColor.rgb -= 0.75- clamp (origCol.r + origCol.g + origCol.b , 0.0 , 0.75);\n    //fragColor += 0.077;\n    //fragColor = min(fragColor , 5.5*texture (iChannel0 , fragCoord/iResolution.xy));\n    \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3BWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[551, 551, 574, 612, 902], [904, 904, 929, 929, 986], [988, 988, 1012, 1012, 1081], [1083, 1083, 1118, 1118, 1261], [1266, 1266, 1286, 1286, 1353], [1357, 1357, 1382, 1382, 2058], [2061, 2061, 2093, 2093, 2212]], "test": "untested"}
{"id": "cl3fDr", "name": "Halftone (Tabyltop)", "author": "DrieStone", "description": "imitates the halftone effect used in older magazine printing.\nsubdivides and rotates the space differently for each channel, then threshold with image.\nsee also:[url=https://www.shadertoy.com/view/Dsy3Dz]cubemap version[/url]", "tags": ["halftone", "npr"], "likes": 4, "viewed": 223, "published": 3, "date": "1701119116", "time_retrieved": "2024-07-30T17:20:23.566954", "image_code": "#define PI 3.1415927\n\n//#define HT_SIZE 5.\n\n#define ANIM_SPEED 0.7\n\n#define BLUR .15\n\n#define LOW .12\n#define HIGH .85\n\n#define SPREAD .085\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec2 rotVec(vec2 v, float f){\n    float c=cos(f), s=sin(f);\n    return v*mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //randomly offsetted to avoid moire.\n    float baseSize = 5.0; // Base value for HT_SIZE\n    float HT_SIZE = baseSize * iResolution.y / 400.0; // Scale based on screen height\n\n    float randSeed=1.;\n    float angleR=PI*hash11(randSeed);\n    float angleG=angleR+PI*mix(.25, .33, hash11(randSeed+10.));\n    float angleB=angleG+PI*mix(.25, .33, hash11(randSeed+20.));\n    \n    //rotate, shrink, repeat, normal. radial gradients\n    vec2 coord=iResolution.xy*.5-fragCoord;\n    vec3 dist=vec3(\n        length(.5-fract(rotVec(coord, angleR)/HT_SIZE)),\n        length(.5-fract(rotVec(coord, angleG)/HT_SIZE)),\n        length(.5-fract(rotVec(coord, angleB)/HT_SIZE))\n    );\n    \n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=texture(iChannel0, uv).rgb*.7;\n    \n    fragColor.rgb=smoothstep(BLUR, -BLUR, dist-col);\n    fragColor=mix(vec4(LOW), vec4(HIGH), fragColor);\n    fragColor.rgb+=(hash32(fragCoord)-.5)*SPREAD;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3fDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 181, 203, 203, 288], [290, 290, 311, 311, 447], [449, 449, 478, 478, 542], [544, 544, 598, 639, 1518]], "test": "untested"}
{"id": "ct3fDr", "name": "Snow FG (Tabyltop)", "author": "DrieStone", "description": "Rainy day on the webcam", "tags": ["webcam", "snow"], "likes": 0, "viewed": 179, "published": 3, "date": "1701118335", "time_retrieved": "2024-07-30T17:20:24.336895", "image_code": "// Parameters for Rain and Wind\nfloat baseRainSpeed = -0.3; // Base speed of falling rain\nint rainCount = 20; // Number of raindrops\nfloat windStrength = 0.2; // Strength of the wind effect\nfloat flakeSize = 0.01;\n\nuniform int amount;\nuniform float size;\nuniform float wind;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    baseRainSpeed -= (wind / 75.);\n    rainCount += amount;\n    flakeSize *= (size / 50.);\n    \n\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Webcam input\n    vec4 webcamColor = texture(iChannel0, uv);\n\n    // Initialize rain effect\n    float rainEffect = 0.0;\n\n    // Create individual raindrops\n    for (int i = 0; i < rainCount; ++i) {\n        // Randomize the horizontal position of each raindrop\n        float randX = fract(sin(float(i) * 43758.5453123) * 12345.6789);\n\n        // Generate a constant seed for varying the raindrop's speed, opacity, and wind effect\n        float speedVariation = mix(1.2, 2.0, fract(sin(float(i) * 12345.6789) * 54321.1234)); // Wider range of speed variation\n\n        // Calculate the vertical position of the raindrop, including speed variation\n        float adjustedSpeed = baseRainSpeed * speedVariation;\n        float rainDropY = fract(iTime * adjustedSpeed + float(i) / float(rainCount));\n\n        // Apply wind effect\n        float windOffset = windStrength * sin(iTime * 0.5 + float(i)) * speedVariation;\n\n        // Calculate opacity based on speed (slower drops are more transparent)\n        float dropOpacity = 0.3 * speedVariation;\n        if (dropOpacity > 1.0){dropOpacity = 1.0 - dropOpacity;}\n\n        // Create a raindrop as a vertical streak with wind effect\n        float dropWidth = 0.01 * speedVariation;; // Width of the raindrop\n        float dropHeight = 0.01 * speedVariation; // Height of the raindrop\n        vec2 rainDropPos = vec2(randX + windOffset, rainDropY);\n\n        // Calculate the alpha value of the raindrop based on distance to its center\n        float dropAlpha = smoothstep(dropWidth, 0.0, abs(uv.x - rainDropPos.x)) * smoothstep(dropHeight, 0.0, abs(rainDropY - uv.y)) * dropOpacity;\n        rainEffect = max(rainEffect, dropAlpha);\n    }\n\n    // Apply rain effect over webcam image\n    vec3 finalColor = mix(webcamColor.rgb, vec3(1.0, 1.0, 1.0), rainEffect);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3fDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 331, 331, 2355]], "test": "untested"}
{"id": "DtcfWr", "name": "Strange glyphs", "author": "jarble", "description": "A fractal pattern that looks like a writing system or musical notation.\nClick and drag to move around.", "tags": ["glyphs"], "likes": 4, "viewed": 148, "published": 3, "date": "1701117131", "time_retrieved": "2024-07-30T17:20:25.100853", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract(.5+(a1)*(a2.x+a2.y))-.5)-.5\n    ;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    uv *= 32.*4.;\n    for(int k = 0; k < 6; k++){\n        uv =\n            min(\n            max(triangle_wave(uv/32./2.),triangle_wave(uv.yx/8./2.)),\n            max(triangle_wave(uv.yx/32./2./2.),triangle_wave(uv/16./2.)).yx\n            )\n        ;\n        uv = floor(uv*32.).yx;\n\n        col =\n            abs(col-sign(uv.x-uv.y))\n            //abs(vec3(col.zx,max((-uv.x-uv.y)/32.,0.)))\n        ;\n\n        }\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    vec2 t2 = vec2(0.);\n    vec3 col = fractal(uv);\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 148], [150, 150, 172, 172, 630], [632, 632, 687, 687, 1020]], "test": "untested"}
{"id": "DtycWz", "name": "3D IK by quaternion", "author": "iY0Yi", "description": "3d ik by quaternion functions.\ni also added the pole to control the elbow position.\nan explanation video for the pole vector:\n[url]https://vimeo.com/66015036[/url]", "tags": ["ik", "maptoy", "armature"], "likes": 18, "viewed": 253, "published": 3, "date": "1701110836", "time_retrieved": "2024-07-30T17:20:26.050314", "image_code": "// quaternion functions\nvec4 invQuat = vec4(1,1,1,-1);\n\nvec4 getQuat(vec3 ax, float a) {\n    return vec4(normalize(ax)*sin(a*.5), cos(a*.5));\n}\n\nvec4 getQuat(vec3 curDir, vec3 trgtDir) {\n    curDir = normalize(curDir);\n    trgtDir = normalize(trgtDir);\n    vec3 ax = cross(trgtDir, curDir);\n    float a = acos(dot(curDir, trgtDir));\n    return getQuat(ax, a);\n}\n\nvec4 mulQuat(vec4 q1, vec4 q2) {\n    vec3 ax = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz,q2.xyz);\n    float a = q1.w*q2.w - dot(q1.xyz,q2.xyz);\n    return vec4(ax, a);\n}\n\nvoid pRotQuat(inout vec3 p, vec4 quat){\n    p = p + 2.*cross(quat.xyz, cross(quat.xyz,p)-quat.w*p);\n}\n\n// IK structs and functions\nstruct IKBone{\n    vec3 tail;\n    float len;\n    vec4 quat;\n};\n\nstruct IKArmature{\n    IKBone[3] bon;\n    vec3 pole;\n};\n\nvoid calcIK(inout IKArmature ika){\n\n    vec3 C = ika.bon[2].tail-ika.bon[0].tail;    \n    float lenC = length(C);\n    \n    // projection quaternion (2d to 3d)\n    vec4 prjQuat = getQuat(AXIS_Y, C);\n    \n    // rotate the pole into the 2d space\n    vec3 pol = ika.pole-ika.bon[0].tail;\n    pRotQuat(pol, prjQuat*invQuat);\n    \n    // add roll rotation\n    prjQuat = mulQuat(prjQuat, getQuat(C, PI-atan(pol.x,pol.z)));\n    \n    // calc ik in projected 2d space\n    // ref about 2d ik:\"Foundation ActionScript 3.0 Animation\" P.367\n    float lenA = ika.bon[1].len,\n          lenB = ika.bon[2].len;\n          lenC = min(lenA+lenB, lenC);\n    float lenA2 = lenA*lenA,\n          lenB2 = lenB*lenB,\n          lenC2 = lenC*lenC;\n    float angB = acos((lenB2-lenA2-lenC2)/(-2.*lenA*lenC)),\n          angC = acos((lenC2-lenA2-lenB2)/(-2.*lenA*lenB)),\n          angD = PI*.5,// == atan(lenC,0.),\n          angD_B = angD+angB,\n          angE = angB+angC-PI*.5;\n    ika.bon[1].tail = vec3(0,sin(angD_B),cos(angD_B))*lenA;\n\n    // convert 2d bon[1].tail into original 3d space\n    pRotQuat(ika.bon[1].tail, prjQuat);\n    ika.bon[1].tail+=ika.bon[0].tail;\n    \n    // store quaternions\n    ika.bon[1].quat = mulQuat(getQuat(AXIS_X,angD_B), prjQuat);\n    ika.bon[2].quat = mulQuat(getQuat(AXIS_X,angE), prjQuat);\n\n}\n\n// sdf functions from iq\nfloat sdSphere(vec3 p,float s){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb ){\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// 3d arrow for debugging\nfloat sdArrow(vec3 p, vec3 a, vec3 b, float r){\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n  float l = length(pa-ba*h);\n  return min(l, max(-h+.9,l-(1.-h)*PI*.05))-r;\n}\n\nfloat map(vec3 p){\n    \n    p*=.5;\n    p.y+=.2;\n    \n    float t = iTime*2.;\n    \n    \n    // --- IK ---\n    \n    // init IK Armature(Bones)\n    IKArmature ika;\n    \n    ika.bon[0].len = 0.;\n    ika.bon[1].len = .4;\n    ika.bon[2].len = .5;\n\n    ika.bon[0].tail = vec3(0,.2,0);\n    \n    float radC = .3;\n    ika.bon[2].tail = vec3(sin(t*.5+1.)*radC, cos(t+2.)*radC+radC, cos(t*.5+1.)*radC);\n    //ika.bon[2].tail = vec3(.1, cos(t+2.)*radC+radC, radC);\n    \n    ika.pole = vec3(sin(t),sin(t*.2)*.5+1.,cos(t))*.5;\n    ika.pole.y+=ika.bon[2].tail.y;\n    \n    // calc ik\n    calcIK(ika);\n    \n    // --- draw rigged primitives ---\n    \n    // segment0\n    vec3 p0 = p-ika.bon[0].tail;\n    float d=sdBox(p0+vec2(0,.1).xyx, vec2(.01,.1).xyx);\n\n    // segment1\n    vec3 p1 = p-ika.bon[1].tail;\n    pRotQuat(p1, ika.bon[1].quat*invQuat);\n    float ds0 = sdBox(p1+vec2(0,ika.bon[1].len*.5).xxy, vec2(.02, ika.bon[1].len).xxy*.5);\n          ds0 = min(ds0, max(length(p1.yz)-.025, abs(p1.x)-.025));\n          ds0 = min(ds0, length(p0)-.025);\n    d = min(d, ds0);\n\n    // segment2\n    vec3 p2 = p-ika.bon[2].tail;\n    pRotQuat(p2, ika.bon[2].quat*invQuat);\n    float hr = .1;\n    float ds1 = sdBox(p2+vec2(0,ika.bon[2].len*.5+hr*.5).xxy, vec2(.02, ika.bon[2].len-hr).xxy*.5);\n          ds1 = min(ds1, max(length(p2.xz+vec2(0,hr))-.025, abs(p2.y)-.025));\n    d = min(d, ds1);\n\n    // debug: arrow\n    float ad0 = sdArrow(p, ika.bon[0].tail, ika.pole-normalize(ika.pole-ika.bon[0].tail)*.0125, .0025);\n    float ad1 = sdArrow(p, ika.bon[0].tail, ika.bon[2].tail-normalize(ika.bon[2].tail-ika.bon[0].tail)*.0125, .0025);\n          ad0 = min(ad0, ad1);\n    BLACK(ad0);\n    d = min(d, ad0);\n\n    // debug: the pole plane\n    float cpd0 = udTriangle(p, ika.bon[0].tail, ika.bon[2].tail, ika.pole)-DIST_MIN;\n          cpd0 = max(cpd0, DIST_MAX*float(int(gFragCoord.x+gFragCoord.y)%2)); // fake transparency\n    ORANGE(cpd0);\n    d = min(d, cpd0);\n\n    // debug: pole\n    float pt = length(p-ika.pole)-.0125;\n    BLUE(pt);\n    d=min(d, pt);\n\n    // debug: target\n    float dt = length(p-ika.bon[2].tail)-.0125;\n    RED(dt);\n    d=min(d, dt);\n\n    // head\n    float an = -2.7+floor(sin(t*1.)*20.)*.05;\n    vec2 c = vec2(sin(an),cos(an));\n    d=min(d, max(sdArc(p2.xz+vec2(0,hr*.5), c, hr*.5, .01), abs(p2.y)-.01));\n    \n    // stage\n    d=min(d, max(length(p.xz)-.1, abs(p.y+.0125)-.0125));\n        \n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uniform vec3 iWheel;\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\n#define AXIS_X vec3(1,0,0)\n#define AXIS_Y vec3(0,1,0)\n#define AXIS_Z vec3(0,0,1)\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\nfloat opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y=abs(p.y);\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define tTHR 8.\n#define RED(v) tRED = step(DIST_MIN*tTHR, v)\n#define GREEN(v) tGREEN = step(DIST_MIN*tTHR, v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*tTHR, v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*tTHR, v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*tTHR, v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*tTHR, v)\n#define BLUE(v) tBLUE = step(DIST_MIN*tTHR, v)\n#define BLACK(v) tBLACK = step(DIST_MIN*tTHR, v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*2.\n#define CAM_DIST 2.\n#define CAM_INIT_SCALE 1.\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\nvec2 gFragCoord;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = true;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED+PI*.25), 1, cos(iTime*TURN_TABLE_SPEED+PI*.25))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST+iWheel.y*.0005;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    gFragCoord = fragCoord;\\\n    isTurntable = !(fetch(C_TURN_TABLE).x<.5);\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtycWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 88, 88, 143], [145, 145, 186, 186, 361], [363, 363, 395, 395, 531], [533, 533, 572, 572, 634], [785, 785, 819, 819, 2083], [2085, 2110, 2141, 2141, 2167], [2169, 2169, 2199, 2199, 2286], [2288, 2288, 2348, 2348, 2482], [2484, 2484, 2509, 2509, 2528], [2530, 2530, 2582, 2582, 3079], [3081, 3107, 3154, 3154, 3307], [3309, 3309, 3327, 3327, 5703]], "test": "untested"}
{"id": "mtdBz7", "name": "Cocentric Wave Rainbow", "author": "sguzman", "description": "A variant of the shader tutorial found at https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["circlesinrainbow"], "likes": 1, "viewed": 134, "published": 3, "date": "1701106838", "time_retrieved": "2024-07-30T17:20:26.811279", "image_code": "// If the shader is being compiled for OpenGL ES\n#ifdef GL_ES \nprecision mediump float;\n#endif\n// Set the precision of floating point numbers to medium\n\n// Declare a 2D vector uniform for the mouse position\nuniform vec2 u_mouse;\n// Declare a 2D vector uniform for the screen resolution\nuniform vec2 u_resolution;\n// Declare a float uniform for the elapsed time\nuniform float u_time;\n\n// Palette function\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Main function, the entry point of the shader\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord ) {\n    vec2 uv = FragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= u_resolution.x / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    uv += 2.0;\n    uv = fract(uv);\n    uv -= 0.5;\n\n    float d = length(uv);\n\n    vec3 col = palette(length(uv0) + iTime);\n\n    d = sin(d * 8.0 + u_time) / 8.0;\n    d = abs(d);\n    d = 0.02 / d;\n\n    finalColor = col * d;\n\n    FragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 404, 427, 427, 619], [621, 669, 726, 726, 1137]], "test": "untested"}
{"id": "ctcBz7", "name": "Snow BG (Tabyltop)", "author": "DrieStone", "description": "Rainy day on the webcam", "tags": ["webcam", "snow"], "likes": 0, "viewed": 168, "published": 3, "date": "1701104465", "time_retrieved": "2024-07-30T17:20:27.585210", "image_code": "// Parameters for Rain and Wind\nfloat baseRainSpeed = -0.3; // Base speed of falling rain\nint rainCount = 250; // Number of raindrops\nfloat windStrength = 0.4; // Strength of the wind effect\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Webcam input\n    vec4 webcamColor = texture(iChannel0, uv);\n\n    // Initialize rain effect\n    float rainEffect = 0.0;\n\n    // Create individual raindrops\n    for (int i = 0; i < rainCount; ++i) {\n        // Randomize the horizontal position of each raindrop\n        float randX = fract(sin(float(i) * 43758.5453123) * 12345.6789);\n\n        // Generate a constant seed for varying the raindrop's speed, opacity, and wind effect\n        float speedVariation = mix(0.3, 1.2, fract(sin(float(i) * 12345.6789) * 54321.1234)); // Wider range of speed variation\n\n        // Calculate the vertical position of the raindrop, including speed variation\n        float adjustedSpeed = baseRainSpeed * speedVariation;\n        float rainDropY = fract(iTime * adjustedSpeed + float(i) / float(rainCount));\n\n        // Apply wind effect\n        float windOffset = windStrength * sin(iTime * 0.5 + float(i)) * speedVariation;\n\n        // Calculate opacity based on speed (slower drops are more transparent)\n        float dropOpacity = 0.5 * speedVariation;\n        if (dropOpacity > 1.0){dropOpacity = 1.0 - dropOpacity;}\n\n        // Create a raindrop as a vertical streak with wind effect\n        float dropWidth = 0.01 * speedVariation;; // Width of the raindrop\n        float dropHeight = 0.01 * speedVariation; // Height of the raindrop\n        vec2 rainDropPos = vec2(randX + windOffset, rainDropY);\n\n        // Calculate the alpha value of the raindrop based on distance to its center\n        float dropAlpha = smoothstep(dropWidth, 0.0, abs(uv.x - rainDropPos.x)) * smoothstep(dropHeight, 0.0, abs(rainDropY - uv.y)) * dropOpacity;\n        rainEffect = max(rainEffect, dropAlpha);\n    }\n\n    // Apply rain effect over webcam image\n    vec3 finalColor = mix(webcamColor.rgb, vec3(1.0, 1.0, 1.0), rainEffect);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 247, 283, 2173]], "test": "untested"}
{"id": "DlcfR7", "name": "Raindrops (Tabyltop)", "author": "DrieStone", "description": "Rainy day on the webcam", "tags": ["rain", "webcam"], "likes": 1, "viewed": 293, "published": 3, "date": "1701104362", "time_retrieved": "2024-07-30T17:20:28.352159", "image_code": "// Parameters for Rain and Wind\nfloat baseRainSpeed = -2.0; // Base speed of falling rain\nint rainCount = 250; // Number of raindrops\nfloat windStrength = 0.1; // Strength of the wind effect\n\nint amount = 25;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Webcam input\n    vec4 webcamColor = texture(iChannel0, uv);\n\n    // Initialize rain effect\n    float rainEffect = 0.0;\n\n    // Calculate uniform wind effect\n    float windOffset = windStrength * sin(iTime * 0.5);\n    \n    float opacityAdjustment = 1.0;\n    float sizeAdjustment = 1.0;\n    \n    opacityAdjustment = 1.0 + (float(amount) - 20.) / 150.;\n    sizeAdjustment = 1.0 + (float(amount) - 20.) / 70.;\n\n    rainCount += (amount * 8 - 200);\n\n    // Create individual raindrops, extending the spawn area\n    for (int i = 0; i < rainCount; ++i) {\n        // Randomize the horizontal position of each raindrop, extending 25% on each side\n        float extendedArea = 1.5; // 25% extended on each side\n        float randX = fract(sin(float(i) * 43758.5453123) * 12345.6789) * extendedArea - 0.25; // Adjusted for extended area\n\n        // Generate a constant seed for varying the raindrop's speed and opacity\n        float speedVariation = mix(1.0, 2.0, fract(sin(float(i) * 12345.6789) * 54321.1234));\n\n        // Calculate the vertical position of the raindrop, including speed variation\n        float adjustedSpeed = baseRainSpeed * speedVariation ;\n        float rainDropY = fract(iTime * adjustedSpeed + float(i) / float(rainCount));\n\n        // Calculate opacity based on speed\n        float dropOpacity = 0.2 * speedVariation * opacityAdjustment; // Inverse relation to speed\n\n        // Create a raindrop as a vertical streak with uniform wind effect\n        float dropWidth = 0.02 * (dropOpacity/4.0) * sizeAdjustment; // Width of the raindrop\n        float dropHeight = 0.05 * (speedVariation) * (sizeAdjustment / 2.); // Height of the raindrop\n        vec2 rainDropPos = vec2(randX + windOffset, rainDropY);\n\n        // Calculate the alpha value of the raindrop based on distance to its center\n        float dropAlpha = smoothstep(dropWidth, 0.0, abs(uv.x - rainDropPos.x)) * smoothstep(dropHeight, 0.0, abs(rainDropY - uv.y)) * dropOpacity;\n        rainEffect = max(rainEffect, dropAlpha);\n    }\n\n    // Apply rain effect over webcam image\n    vec3 finalColor = mix(webcamColor.rgb, vec3(0.9, 0.95, 1.0), rainEffect);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dtdfR7", "name": "Cryptic Design Sketches", "author": "dr2", "description": "Lots of domes, arches, buttresses, columns, bridges, reflections, ogives.", "tags": ["architecture"], "likes": 22, "viewed": 224, "published": 3, "date": "1701104097", "time_retrieved": "2024-07-30T17:20:29.299626", "image_code": "#define O441 min(O232,0)\n#define O341(x)(sin((x)+vec2(0.5*O511,0.)))\n#define O558(O054){if(O434<O527){O527=O434; O426=O054; O604=O573;}}\n#define O023(x)if(O186>=x)\n\nvec4 O069,O798;vec3 O255,O604,O403,O596,O534;float O348,O713,O658,O689,O627,O155,O759,O945[3],O418[3];int O232,O186,O426;bool O860;const int O116=1,O333=2,O364=3,O736=4,O767=5,O240=6,O271=7,O178=8,O705=9,O674=10,O519=11,O550=12,O581=13,O612=14,O457=15,O643=16,O209=17,O302=18,O395=19,O147=20,O488=21,O085=22;const float O511=3.1415927;float O139(vec2 O480){return min(O480.x,O480.y);}float O077(vec2 O480){return max(O480.x,O480.y);}float O108(vec3 O480){return max(O480.x,max(O480.y,O480.z));}float O162(float O015,float O992,float w,float x){return(1.-smoothstep(O992-w,O992+w,x))*smoothstep(O015-w,O015+w,x);}mat3 O224(float O899,float O093){vec2 O449,O217,O038;O449=vec2(O899,O093);O217=cos(O449);O038=sin(O449);return mat3(O217.y,0.,-O038.y,0.,1.,0.,O038.y,0.,O217.y)*mat3(1.,0.,0.,0.,O217.x,-O038.x,0.,O038.x,O217.x);}vec2 O914(vec2 O573,float a){vec2 O372;O372=sin(a+vec2(0.5*O511,0.));return vec2(dot(O573,vec2(O372.x,-O372.y)),dot(O573.yx,O372));}vec2 O883(vec2 O573,vec2 O372){return vec2(dot(O573,O372*vec2(1.,-1.)),dot(O573.yx,O372));}\nfloat O294(vec3 O480){vec3 O573,O635,O666,O697,O728;float O527,O434,O821,O031,O976,O720,O193,O651,O806,O387,O542,O837,O620,O589;O387=0.07*O658;O527=O713;O821=length(O480.xz);O542=O480.y;O031=(O821>0.)?atan(O480.z,-O480.x)/(2.*O511):0.;O635=O480;O635.xz=O914(O635.xz,2.*O511*(floor(6.*O031)+0.5)/6.);O666=O635;O666.xz=O914(vec2(O666.x,abs(O666.z)),O511/12.);O697=O666;O697.xz=O914(vec2(O697.x,abs(O697.z)),O511/12.);O728=O635;O728.xz=O914(vec2(O728.x,abs(O728.z)),O511/6.);O720=1.5;O193=sqrt(O720*O720-1.);O069.xy=vec2(0.45*O658,0.5*O627);O069.zw=vec2(O069.y-O193*O069.x,O720*O069.x);O620=O720*O658;O589=O627-O193*O658;O806=length(vec2(O821,O542-O589))-O620;O798.z=length(vec2(abs(O635.z)+0.15,max(O542-0.3,0.)))-0.3;O573=O635;O573.x+=O658;O976=length(O573.xz);O798.x=max(O976-O069.x,length(vec2(O976,O542-O069.z))-O069.w);O434=max(max(abs(O798.x)-O689,-max(O821-O658,length(vec2(O821,O542-O589))-O620)-O689+0.001),-O798.z);O434=max(O434,-max(length(vec2(abs(O914(vec2(O573.x,abs(O573.z)),O511/24.).y)+0.13,max(O542-0.75,0.)))-0.2,0.65-O542));O434=max(max(O434,-max(length(vec2(abs(O573.x)+0.12,max(O542-0.7,0.)))-0.2,0.6-O542)),0.02-O542);O023(20)O558(O736);O434=max(max(max(abs(O798.z)-0.018,abs(O821-1.35*O658)-0.35*O658),O069.x-O976-O689),0.02-O542);O023(22)O558(O240);O573=O697;O573.xy-=vec2(0.15-O658,1.43);O434=length(O573)-0.04;O023(18)O558(O302);O573=O480;O798.y=max(O821-O658,O806);O837=max(max(-O798.x-O689,O387+0.01-O821),0.02-O542);O434=max(max(abs(O798.y)-O689,-max(length(vec2(abs(O666.z)+0.1,max(O542-O627+0.25,0.)))-0.2,O627-0.4-O542)),O837);O023(23)O558(O333);O434=max(length(vec2(abs(max(O821-O658,O806))-O689,O697.z))-0.03,O837);O023(21)O558(O364);O434=min(max(min(O821-O658,O976-O069.x),abs(O542-0.04)-0.02),max(max(O821-1.69*O658,abs(O635.z)-0.15),abs(O542-0.025)-0.015));O023(2)O558(O271);O573=O480;O434=max(O821-0.04,abs(O542-0.5*O759)-0.5*O759);O023(3)O558(O488);O573.y=O542-O759;O434=length(O573)-0.1;O023(19)O558(O085);O573=O635;O573.y=O542-O589-O620+0.13;O798.w=length(vec2(O821+0.1,max(O573.y-0.43,0.)))-O387-0.12;O434=max(max(abs(O798.w)-0.02,-O573.y),-max(length(vec2(abs(O573.z)+0.1,max(O573.y-0.48,0.)))-0.15,0.28-O573.y));O023(17)O558(O767);O573.xz=O480.xz;O573.y-=0.58;O434=length(O573)-0.05;O023(18)O558(O302);O573=O728;O434=max(abs(abs(O573.z)-0.08)-0.03,max(O573.x+O658,0.01-O542));O573.xy-=vec2(0.5-O658,-0.2);O434=max(O434,abs(length(O573.xy)-O627-0.12)-0.08);O023(16)O558(O209);O573=O728;O434=max(abs(abs(O573.z)-0.05)-0.015,max(O387+0.02-O821,1.3-O573.y));O573.xy-=vec2(0.15,0.75);O434=max(O434,abs(length(O573.xy)-1.95)-0.04);O023(15)O558(O178);O573=O728;O573.xy-=vec2(-O945[1],2.22);O434=length(O573)-0.05;O023(18)O558(O302);O573=O666;O651=abs(O821-O945[0])-0.06;O434=max(O651,abs(O542-1.39)-0.2);O573.y=O542-1.2;O434=max(O434,0.3-length(O573.yz));O023(10)O558(O705);O573.xz=O480.xz;O434=max(O651-0.01,abs(O542-1.6)-0.01);O023(11)O558(O674);O573=O666;O651=abs(O821-O945[0]-0.02)-0.03;O573.yz=vec2(O542-1.6,abs(O666.z)+0.2);O434=max(O651,max(abs(length(O573.yz)-O418[0])-0.03,-O573.y));O023(13)O558(O519);O573.xz=O480.xz;O434=max(O651-0.01,max(O806,2.17-O542));O023(14)O558(O674);O434=max(length(vec2(O542-1.5,O697.z))-0.05,max(O821-O658,O945[0]+0.02-O821));O573.y=O542-0.08;O434=min(O434,max(O821-0.12,abs(O573.y)-0.03));O023(15)O558(O643);O573=O697;O573.x+=O945[2];O434=max(length(O573.xz)-0.02,abs(O542-0.46)-0.38);O023(4)O558(O457);O651=abs(O821-O945[2])-0.02;O573.y=O542-0.46;O434=max(O651,abs(abs(O573.y)-0.385))-0.01;O023(5)O558(O643);O573.yz=vec2(O542-0.86,abs(O666.z)+0.06);O434=max(abs(O821-O945[2])-0.03,max(abs(length(O573.yz)-O418[2])-0.015,-O573.y));O023(6)O558(O581);O573.xz=O480.xz;O434=max(O651-0.01,abs(O573.y-0.14)-0.01);O023(8)O558(O674);O573=O697;O573.x+=O945[1];O434=max(length(O573.xz)-0.025,abs(O542-0.66)-0.58);O023(4)O558(O457);O651=abs(O821-O945[1])-0.025;O573.y=O542-0.66;O434=max(O651,abs(abs(O573.y)-0.585))-0.01;O023(5)O558(O643);O573.yz=vec2(O542-1.26,abs(O666.z)+0.1);O434=max(abs(O821-O945[1])-0.04,max(abs(length(O573.yz)-O418[1])-0.018,-O573.y));O023(6)O558(O550);O573.xz=O480.xz;O434=max(O651-0.01,abs(O573.y-0.33)-0.013);O023(9)O558(O674);O573=O697;O573.x+=O945[0];O573.xz=abs(O573.xz)-0.04;O434=max(length(O573.xz)-0.025,abs(O542-0.63)-0.55);O023(4)O558(O457);O573.y=O542-0.63;O434=max(abs(O821-O945[0])-0.07,abs(abs(O573.y)-0.56)-0.02);O023(5)O558(O643);O573=O697;O573.xy-=vec2(-O945[1],0.64);O434=max(max(abs(length(O573.xy)-0.6)-0.012,abs(O573.z)-0.025),max(0.195-O573.y,-O573.x));O023(7)O558(O612);O573=O697;O573.xy-=vec2(-O945[0],0.75);O434=max(max(abs(length(O573.xy)-0.83)-0.02,abs(O573.z)-0.03),max(0.485-O573.y,-O573.x));O023(12)O558(O612);O573=O666;O573.x+=2.2*O658;O976=length(O573.xz);O434=abs(length(vec2(O976+0.1,max(O542-1.2*O627,0.))))-0.09*O658;O434=min(O434,max(O976-0.07*O658,abs(O542-O627)-0.1));O434=min(O434,max(O976-0.12*O658,abs(O542-0.03)-0.03));O434=max(O434,0.01-O542);O023(24)O558(O395);O573=O480;O434=max(min(min(O821-2.*O658,O976-0.3*O658),abs(O821-3.05*O658)-0.13*O658),abs(O542-0.01)-0.01);O023(1)O558(O116);O573=O635;O573.x+=O155;O976=length(vec2(O573.x,O573.y+2.3))-2.5;O434=min(max(abs(O976)-0.03,abs(O573.z)-0.2),length(vec2(O976-0.2,abs(O573.z)-0.18))-0.01);O434=max(min(O434,max(length(vec2(0.1*(fract(O573.x/0.1+0.5)-0.5),abs(O573.z)-0.18))-0.008,abs(O976-0.1)-0.1)),-O542);O434=max(O434,abs(O573.x)-1.05);O023(25)O558(O147);return O527;}\nfloat O356(vec3 O852,vec3 O790){float O496,O434;O496=0.;for(int O953=O441;O953<120;O953++){O434=O294(O852+O496*O790);if(O434<0.0002||O496>O713)break;O496+=O434;}return O496;}vec3 O325(vec3 O480){vec4 O410;vec2 O868;O868=1e-4*vec2(1.,-1.);for(int O953=O441;O953<4;O953++){O410[O953]=O294(O480+((O953<2)?((O953==0)?O868.xxx:O868.xyy):((O953==2)?O868.yxy:O868.yyx)));}O410.x=-O410.x;return normalize(2.*O410.yzw-dot(O410,vec4(1.)));}vec4 O263(out vec2 O472){vec4 O310;vec2 O062,O317;float O031,O976,O007,O286;O310=vec4(0.);O472=vec2(0.);O062=vec2(0.);if(O426==O271||O426==O116){O976=length(O604.xz);O062=O604.zx;}else if(O426==O705||O426==O519||O426==O581||O426==O550){O062=O604.yz;}else if(O426==O612||O426==O178||O426==O209){O062=O604.yx;}else if(O426==O333||O426==O736||O426==O674){O062=O604.zx;}if(O062!=vec2(0.))O031=atan(O062.x,-O062.y)/(2.*O511);if(O426==O333||O426==O736||O426==O240)O286=0.5*step(0.5,fract(4.*O604.y+0.25));if(O426<=O271){if(O426==O116){O310=vec4(0.5,0.5,0.5,0.);}else if(O426==O333){if(O798.y>0.){if(O604.y>O627+0.01){O310=vec4(0.8,0.8,0.6,0.05);}else{O310=vec4(0.8,0.8,0.9,0.05);}}else{O310=(O604.y>O627+0.01)?vec4(0.1,0.1,1.,0.):vec4(0.8,0.8,0.8,0.);}}else if(O426==O364){O310=vec4(0.9,0.9,0.9,0.05);}else if(O426==O736){if(O798.x>0.){if(O604.y>O069.y+0.01){O310=vec4(0.8,0.8,0.6,0.05);}else{O310=vec4(0.8,0.9,0.8,0.05);}}else{O310=(O604.y<O069.y-0.02)?vec4(0.8,0.8,0.8,0.):vec4(0.1,0.1,1.,0.);}}else if(O426==O767){if(O798.w>0.&&O604.y>0.1)O310=vec4(0.8,0.4,0.2,0.2);else O310=vec4(0.8,0.8,0.8,0.);}else if(O426==O240){if(O798.z<0.&&length(O604.xz)<1.39){O310=vec4(0.8,0.8,0.8,0.)*(0.93+0.07*smoothstep(0.03,0.035,abs(fract(16.*O604.x+0.5))));}else{O317=abs(fract(vec2(8.*O604.y+0.5,8.*O604.x+O286)));O310=vec4(0.8,0.9,0.8,0.05)*(0.93+0.07*smoothstep(0.01,0.05,O139(O317)));}}else if(O426==O271){O310=vec4(0.5,0.7,0.9,0.1);}}else if(O426<=O457){if(O426==O178){O310=vec4(0.8,0.7,0.8,0.1)*(0.8+0.2*step(0.1,fract(128.*O031)));}else if(O426==O705){O310=vec4(0.7,0.8,0.6,0.1);if(length(O604.yz)<0.35)O310*=0.6+0.4*step(0.5,fract(31.*O031));}else if(O426==O674){O310=vec4(0.8,0.7,0.6,0.1)*(0.6+0.4*step(0.5,fract(128.*O031)));}else if(O426==O519){O007=length(O604.yz)-O418[0];O310=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O007))*step(0.5,fract(63.*O031+0.25*sign(O007))));}else if(O426==O550){O007=length(O604.yz)-O418[1];O310=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O007))*step(0.5,fract(47.*O031+0.25*sign(O007))));}else if(O426==O581){O007=length(O604.yz)-O418[2];O310=vec4(0.8,0.7,0.6,0.1)*(1.-0.4*step(0.001,abs(O007))*step(0.5,fract(31.*O031+0.25*sign(O007))));}else if(O426==O612){O310=vec4(0.8,0.7,0.6,0.1)*(0.6+0.4*step(0.5,fract(128.*O031)));}else if(O426==O457){O310=vec4(0.6,0.6,0.7,0.1);}}else{if(O426==O643){O310=(O604.y>0.)?vec4(0.6,0.6,0.7,0.1):vec4(0.4,0.6,0.8,0.1);}else if(O426==O209){O310=vec4(0.8,0.7,0.8,0.1)*(0.8+0.2*step(0.1,fract(128.*O031)));}else if(O426==O302){O310=vec4(0.9,0.9,0.7,-1.);}else if(O426==O488){O310=vec4(0.2,0.4,0.2,-1.);}else if(O426==O085){O310=vec4(1.,0.7,0.7,-1.);}else if(O426==O395){O310=vec4(0.8,0.7,0.6,0.1);}else if(O426==O147){O310=vec4(0.5,0.3,0.1,0.);}}return O310;}vec4 O124(vec3 O852,vec3 O790,vec3 O480,float O976){vec3 O410,O503;float b,O434,O007;O410=O852-O480;b=dot(O790,O410);O007=b*b+O976*O976-dot(O410,O410);O434=O713;if(O007>0.){O434=-b-sqrt(O007);O503=(O410+O434*O790)/O976;}return vec4(O434,O503);}vec3 O131(vec3 O852,vec3 O790){vec4 O310,O465;vec3 O046,O279,O503,O007;vec2 O472;float O775,O744,O682,O031,b,O201;bool O829,O922,O891;O744=O713;O829=false;O922=false;if(!O860)O465=O124(O852,O790,vec3(0.,O759,0.),0.15);O682=O713;for(int O984=O441;O984<2;O984++){O775=O356(O852,O790);if(!O860){if(O984==0){if(O682<min(O775,O713)){O852+=O682*O790;O503=O465.yzw;O922=true;}else if(O775>=O713&&O790.y<0.){O007=O852+(-O852.y/O790.y)*O790;b=length(O007.xz);if(b<3.*O658){O852=O007;O503=normalize(vec3(0.01*O914(O852.xz/b,O511*(0.5+0.2*fract(4.*b-O348))),1.)).xzy;O922=true;}}if(O922){O790=reflect(O790,O503);O852+=0.01*O790;}}if(!O922)break;}else break;}if(O775<O713){O852+=O775*O790;O503=O325(O852);O310=O263(O472);if(O426==O271&&O503.y<0.99)O310.rgb*=0.6;if(O426==O457||O426==O488||O426==O395){O031=fract(16.*(atan(O604.z,-O604.x)/(2.*O511)+0.5));O503.xz=O914(O503.xz,-0.15*O511*sin(O511*O031*O031));}}else{O279=vec3(0.7,0.7,0.75);O829=true;}if(O860){O279=vec3(1.)*pow(O108(O310.rgb),0.7);O891=false;if(O186<=8){if(O186==1) O891=(O426==O116);if(O186==2) O891=(O426==O271);if(O186==3) O891=(O426==O488);if(O186==4) O891=(O426==O457);if(O186==5) O891=(O426==O643);if(O186==6) O891=(O426==O550||O426==O581);if(O186==7) O891=(O426==O612);if(O186==8) O891=(O426==O674);}else if(O186<=16){if(O186==9) O891=(O426==O674);if(O186==10)O891=(O426==O705);if(O186==11)O891=(O426==O674);if(O186==12)O891=(O426==O612);if(O186==13)O891=(O426==O519);if(O186==14)O891=(O426==O674);if(O186==15)O891=(O426==O178||O426==O643);if(O186==16)O891=(O426==O209);}else{if(O186==17)O891=(O426==O767);if(O186==18)O891=(O426==O302);if(O186==19)O891=(O426==O085);if(O186==20)O891=(O426==O736);if(O186==21)O891=(O426==O364);if(O186==22)O891=(O426==O240);if(O186==23)O891=(O426==O333);if(O186==24)O891=(O426==O395);if(O186==25)O891=(O426==O147);}if(O891){O279.r=sqrt(O279.g);O279.rb*=0.2;}O279*=0.3+0.7*max(dot(O503,O255),0.);if(O829)O279=vec3(0.7,0.7,0.75);}else{if(!O829){if(O310.a>=0.){O279=O310.rgb*(0.2+0.2*max(-dot(O503,O255),0.)+0.8*max(dot(O503,O255),0.))+O310.a*pow(max(dot(reflect(O255,O503),O790),0.),32.);}else{O279=O310.rgb*(0.55-0.45*dot(O790,O503));}}if(O922)O279*=0.9;}return clamp(O279,0.,1.);}\nvoid O100(){O689=0.03;O658=2.;O627=2.;O945[0]=0.85*O658;O945[1]=0.5*O658;O945[2]=0.2*O658;O155=2.46*O658;O418[0]=0.6;O418[1]=0.33;O418[2]=0.14;}void mainImage(out vec4 O930,in vec2 O961){mat3 O565;vec4 O170;vec3 O852,O790,O279;vec2 O248,O379;float O093,O899,O751;\nO232=iFrame;O248=iResolution.xy;O379=2.*O961.xy/O248-1.;O379.x*=O248.x/O248.y;O348=iTime;O170=iMouse;O170.xy=O170.xy/O248-0.5;O170.y*=-1.;\nO100();O093=0.05*O511;O899=-0.1*O511;O751=4.5;if(O170.z>0.){O093+=2.*O511*O170.x;O899+=O511*O170.y;O751+=abs(O093);}else{O093+=O511*sin(0.01*O511*O348);}O899=clamp(O899,-0.4*O511,-0.05*O511);O759=0.7+0.4*sin(0.3*O348);O852=vec3(0.,0.5,-20.);O565=O224(O899,O093);O852=O565*O852;O255=O565*normalize(vec3(1.,1.,-1.));O713=80.;O790=O565*normalize(vec3(O379,O751));O186=int(30.-abs(floor(mod(2.*O348,60.))-30.));O860=(O186<=27);O279=O131(O852,O790);O930=vec4(O279,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 522, 522, 549], [549, 549, 571, 571, 598], [598, 598, 620, 620, 659], [659, 659, 709, 709, 777], [777, 777, 810, 810, 989], [989, 989, 1018, 1018, 1121], [1121, 1121, 1152, 1152, 1212], [6572, 6572, 6604, 6604, 6746], [6746, 6746, 6767, 6767, 7002], [7002, 7002, 7027, 7027, 9723], [9723, 9723, 9775, 9775, 9967], [9967, 9967, 9998, 9998, 12139], [12140, 12140, 12152, 12152, 12284], [12284, 12284, 12327, 12327, 13007]], "test": "untested"}
{"id": "DtdBRN", "name": "xoreoghaphy", "author": "sleeping", "description": "animated bit-wise xor patterns", "tags": ["animation"], "likes": 4, "viewed": 143, "published": 3, "date": "1701101542", "time_retrieved": "2024-07-30T17:20:30.170298", "image_code": "void mainImage( out vec4 C, vec2 U )\n{\n    U /= 25.;\n    U += iTime;\n    C.x = sin(iTime+float(int(ceil(U.y))^int(ceil(U.x))))+.2;\n    U = abs(fract(U)-.5);\n    U = step(fract(U - sin(iTime*2.)*.4 + ceil(U.x-.2)*.4), C.xx);\n    \n    C = vec4(U.xyxx*U.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 256]], "test": "untested"}
{"id": "ctdfRM", "name": "Interlocked Mobius Strip", "author": "Shane", "description": "An interlocked Mobius strip.", "tags": ["raymarch", "mobius", "strip", "twist", "interlock"], "likes": 88, "viewed": 680, "published": 3, "date": "1701092482", "time_retrieved": "2024-07-30T17:20:31.197552", "image_code": "/*\n\n    Interlocked Mobius Strip\n    ------------------------\n    \n    Interlocked Mobius strips are a pretty common object amongst the 3D geometric\n    art crowd, and on the internet in general, so I was surprised not to find one on \n    Shadertoy... Well, it's possible that someone like Dr2, Fabrice, etc., has one \n    hidden away on here somewhere, but I wasn't able to track one down.\n\n    Either way, they're pretty easy to make: Produce two toroidal strips running\n    perpendicular to one another, each with some repeat holes in them. Offset one \n    set of holes by an angle that allows them to interweave, which will give you two \n    interlaced toroidal objects. The final step is to twist each along the toroidal \n    axis (the long circular one) by half a turn. This will, in effect, cause the two \n    separate toroidal objects to fuse into one continuous band, which I've always \n    thought looked pretty cool... but I'm easily amused, so it's probably not that \n    great. :D\n\n    I've had various incarnations of these objects sitting around for ages, so I \n    thought I'd dust one off and make it presentable. It originally featured some\n    rolling bearings running around the object, but I felt they were too distacting.\n    There are so many variations possible. I went for the single twist version with \n    bands around the edges because I thought it suited the background more. I happen \n    to prefer the more elegant ceramic or metallic versions sitting on a matte plane, \n    so I'll post one of those at some stage.\n    \n    \n\n\tRelated examples:\n    \n    // Essentially the same thing, but without the interlocking component.\n    // Dr2 has a heap of Mobius related material that's worth the look.\n    Twisted Ladder 2 - Dr2\n    https://www.shadertoy.com/view/Xsdczl\n    \n    // Stylish and mind bending at the same time.\n    Eternal Commute - tdhooper\n    https://www.shadertoy.com/view/ldKBRt\n    \n    \n*/\n\n\n// Attempting not to unroll loops.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .1, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// Texture sample.\nvec3 getTex(sampler2D iCh, vec2 p){\n\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(sampler2D iCh, in vec2 p){ return dot(getTex(iCh, p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    //vec2 w = vec2( sdf, abs(pz) - h );\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n    \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .028;\n    vec2 w = vec2( sdf, abs(pz) - h ) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n// IQ's box routine.\nfloat sBoxS(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n// Object rotation, with some optional mouse movement.\nvec3 objRot(vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    p.xy = rot2(3.14159/5.)*p.xy;\n    p.yz = rot2(-3.14159/5.)*p.yz;\n    p.xz = rot2(iTime/2.)*p.xz;  //iTime/4. \n    return p;\n\n}\n \n// Global scale for the background grid. \nvec2 fSc = vec2(1)/2.;\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n\n    const float offDst = .5; \n    \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }    \n    /*\n    if(mod(floor(p.x/sc.x), 2.)<.5){\n        p.y -= sc.y*offDst; // Column offset.\n        ipOffs.y += offDst;\n    }\n    */\n    /*\n    float ii = floor(p.y/sc.y);\n    float offDst = mod(ii, 4.)/4.; \n    p.x -= sc.x*offDst; // Row offset.\n    ipOffs.x += offDst;\n    */\n    \n         \n    // Current block ID.\n    vec2 ip = floor(p/sc) + .5;\n    \n    #define SUBDIV\n    #ifdef SUBDIV\n    // Random subdivision.\n\n    // Rectangle partitioning.\n    if(hash21(ip + .14)<.5){\n       sc.x /= 2.;\n       ip.x = floor(p.x/sc.x) + .5;\n    \n    }\n    if(hash21(ip + .42)<.5){\n       sc.y /= 2.;\n       ip.y = floor(p.y/sc.y) + .5;\n    \n    }\n    \n    /*\n    // Use this for squares only.\n    if(hash21(ip + .253)<.5){\n       sc /= 2.;\n       ip = floor(p/sc) + .5; \n    }\n    */\n    #endif\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n\n\n// Back wall unit direction ray.\n// We need the direction itself for the standard cube\n// traversal trickery.\nvec3 gDir;\nvec3 gRd;\nfloat gCD;\n\n// The block pattern on the back wall.\nfloat getSurf(vec3 q3){\n\n    \n    vec2 sc = fSc; // Surface scale.\n    vec4 p4 = getGrid(q3.xy, sc); // Grid.\n    vec2 p = p4.xy, ip = p4.zw; // Local coordinates and cell ID.\n   \n    \n    vec3 p3 = vec3(p.xy, q3.z - 2.); // 3D position. \n    \n    float h = hash21(ip + .31)*.05; // Cell height.\n\n    float sq = sBoxS(p3.xy, sc/2., min(sc.y, sc.x)*.1); // Rounded square.\n    \n    float d2 = sq; // 2D distance.\n     \n    // Bore out some random holes.\n    if(hash21(ip + .21)<.5){\n    //if(mod(ip.x + ip.y, 2.)<.5){\n        //d2 = sBoxS(p3.xy, sc/2. - fSc.y/5., min(sc.y, sc.x)*.07);\n        float d2B = length(p3.xy) - (min(sc.y, sc.x)/2. - fSc.y/5.);\n        //float d2B = opExtrusion(d2, p3.z + (h + .2)*2., .5);\n        d2 = smax(d2, -d2B, fSc.y*.06);\n       \n    } \n    \n    // Extrude the 2D field above.\n    float d = opExtrusion(d2, p3.z + (h + .2), h + .2);\n    \n\n    \n    // Face curvature.\n    float fSph = length(p3 - vec3(0, 0, -(h + .2 -  max(sc.y, sc.x)/6.)*2.)) - sc.y/2.;\n    d += fSph*.1;\n    // Edge smoothing.\n    //d = smax(d, -abs(sq), fSc.y*.06); \n    \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*sc - p4.xy)/gRd.xy; // For 2D, this will work too.\n\n    // Minimum of all distances, plus not allowing negative distances.\n    // Adding a touch to advance to the next cell.\n    gCD = max(min(rC.x, rC.y), 0.) + .001; \n   \n    // Return the surface distance.\n    return d;\n\n\n}\n\n \n\n\n\n// Texture coordinates. It's easier to save them in the distance field and\n// reuse them later, rather than recalculate them all over again. The downside\n// is expense, but it's not really noticeable here.\nvec3 txCoord;\n \n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    float fl = getSurf(p);\n    \n\n    \n    // Rotate the object.\n    vec3 rP = objRot(p);\n    \n    // Number of toroidal twists: Only whole numbers work.\n    // Odd numbers will produce a continous strip, and even numbers\n    // will produce more than one.\n    float twists = 1.;\n \n    \n    // Toroidal strip dimensions.\n    vec2 dim = vec2(.1, .02);\n    float r = .38; // Toroidal radius.\n    \n    // Disc coordinates.\n    vec3 q = rP; \n    vec2 tc = vec2(length(q.xz) - r, rP.y);\n    \n    \n    // Disc holes.\n    vec3 q2 = rP;\n    float aN = 14.;\n    float a = mod(atan(q2.z, q2.x), 6.2831);\n    float na = (floor(a*aN/6.2831) + .5)/aN;\n    \n    // Rotate the repeat cells into position and move them out by the radius.\n    q2.xz *= rot2(-na*6.2831);\n    q2.x -= r;\n\n    q2.xy *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane objects.\n    // Producing the holes.\n    //float hole = sBoxS(q2.xz, vec2(1., 1)*r*6.2831/aN/2.*.65, .05); // X-axis holes.\n    float hole = length(q2.xz) - r*6.2831/aN/2.*.7; // X-axis holes.\n     \n    \n    tc *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane itself.\n    float taper = smoothstep(0., 1., abs(tc.x)/dim.x)*.5 + .5; // Holowing out the center.\n    float tor = sBoxS(tc, dim*vec2(1, taper), .01); // Creating the central strip.\n\n    // Outer band coordinates.\n    vec2 btc = tc; btc.x = abs(btc.x) - dim.x - dim.y;\n    float bands = sBoxS(btc, vec2(1, 1.5)*dim.y, .01);\n    tor = smax(tor, -hole, .01); // Boring out the wholes.\n    \n    // Band ridges... Interesting, but not for this example.\n    //bands += smoothstep(0., 1., sin(a*aN*6.))*.001;\n    \n    // Saving some coordinates to use for texturing.\n    txCoord = vec3(tc.xy, a/6.2831);\n    \n    \n    // Doing the same as above, but for a second object running\n    // perpendicular to the first. By twisting each object by a \n    // half turn, they fuse into one another giving the impression\n    // of one continous band.\n    q2 = rP;\n    q2.xz *= rot2(3.14159/aN);\n    a = atan(q2.z, q2.x);\n    na = (floor(a*aN/6.2831) + .5)/aN;\n    q2.xz *= rot2(-na*6.2831);\n    q2.x -= r;\n\n\n    q2.xy *= rot2(a*twists/2. - iTime*.5); // Twisting the toroidal plane objects.\n    //hole = sBoxS(q2.yz, vec2(1., 1)*r*6.2831/aN/2.*.65, .05); // Square holes.\n    hole = length(q2.yz) - r*6.2831/aN/2.*.7; // Z-axis holes.\n    \n    // Rendering the same as the torus object above, but out of \n    // sync by 90 degrees.\n    taper = smoothstep(0., 1., abs(tc.y)/dim.x)*.5 + .5; // Holowing out in the center.\n    float tor2 = sBoxS(tc, dim.yx*vec2(taper, 1), .01);\n    btc = tc; btc.y = abs(btc.y) - dim.x - dim.y;\n    float bands2 = sBoxS(btc, vec2(1, 1.5).yx*dim.y, .01);\n    //bands2 += smoothstep(0., 1., sin(a*aN*6.))*.001; // Second band ridges.\n    \n    // Second strip and second strip coordinates.\n    tor2 = smax(tor2, -hole, .02);\n    if(min(tor2, bands2)<min(tor, bands)) txCoord = vec3(tc.yx, a/6.2831);\n   \n   \n    // Combine the central strips and the outer bands. With odd turn numbers, they'll\n    // fuse together as one, and even numbers will produce separate objects.\n    tor = min(tor, tor2);\n    bands = min(bands, bands2);\n\n\n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(fl, bands, 1e5, tor);\n    \n    // Shortest distance.\n    return  min(min(tor, fl), bands);\n \n}\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    // Back wall unit direction ray. \n    // We need the direction itself for the standard cube\n    // traversal trickery.\n    gDir = step(0., rd) - .5;\n    gRd = rd;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += min(d*.9, gCD); \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = ZERO; i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable.\n    const int maxIter = 32; \n    \n    // Bumping the ray off the surface to avoid self collisions.\n    // The constant coincides with the hit condition in the \"trace\" function. \n    ro += n*.0015; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.; // Initial shadow value.\n    float t = 0.; // Initial distance.\n    float end = max(length(rd), 0.0001); // Distance from the jump point to the light.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Return the shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break; // Faux exit.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, -.1, 0); // \"Look At\" position.\n    vec3 ro = lk + vec3(cos(iTime/2.)*.05, .2, -1.25); // Camera position.\n \tvec3 lp = ro + vec3(-1, 1, -.5); // Light position.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n   \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the texture coordinates.\n    vec3 svTxCoord = txCoord;\n    \n\n    // Obtain the object ID.\n    objID = 0;\n    float obD = vID[0];\n    \n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n\n        // Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring. \n        \n        if(objID==0){ // Background.\n            \n            // The dark subdivide wall.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            txP.yz *= rot2(3.14159/5.);\n            vec4 p4 = getGrid(sp.xy, fSc);\n           \n            \n            vec3 tx = tex3D(iChannel1, txP*2. + .5, txN);\n            //vec3 tx = texture(iChannel1, txP.xz/3. + .4).xyz; tx *= tx;\n            //tx = smoothstep(0., 1., tx);\n            \n           \n            texCol = vec3(.4)*(hash21(p4.zw + .1)*.5 + .5);\n            texCol *= tx*2. + .1;\n            \n \n        }\n        else if(objID==1){ //  Bands.\n        \n            // Using the saved coordinates from the distance function \n            // to texture the outer bands. The sides aren't technically\n            // correct, but no one will notice.\n            \n            vec3 tx = getTex(iChannel0, svTxCoord.yz*vec2(4, 4)); \n            //vec3 tx2 = getTex(iChannel1, svTxCoord.yz*vec2(4, 4));\n            //tx = mix(tx, tx2, .5);         \n            \n            // Gold.\n            texCol = vec3(.6, .35, .15)*(tx*2. + .05);\n            // Silver -- I almost went with this but decided on gold at \n            // the last minute.\n            //texCol = vec3(.35)*(tx*2. + .05);\n            \n            // Ramping up the diffuse for a more metallic look.\n            diff = pow(diff, 8.)*2.; \n       \n            \n        }\n        else { // Strip.\n         \n            // Using the saved coordinates from the distance function \n            // to texture the central strip with holes.\n            \n            vec3 tx = getTex(iChannel0, svTxCoord.xz*vec2(2, 4));      \n             \n            // Coloring the individual blocks with the saved ID.\n            texCol = tx*.25 + .875; \n            \n            \n            //diff = pow(diff, 4.)*2.; // Diffuse ramping.\n            \n             \n        }\n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(ld - rd); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel2, ref).xyz; refTx *= refTx;\n        refTx = (texCol*.75 + .25)*refTx;//smoothstep(0., .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        float rf = objID == 0? .25 : 1.;\n        //\n        // Adding the specular reflection and glow for the inner light.\n        texCol += spRef*refTx*rf*8.;//vec3(1.4, 1, .4)*\n        \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .25 + vec3(1, .97, .92)*spec*1.*sh);\n        \n\n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Fog -- A bit redundant here, but it does have a minor effect.\n    vec3 fog = vec3(1, .925, .85)*.01;\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n           \n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2133, 2166, 2188, 2188, 2246], [2249, 2332, 2353, 2518, 2651], [2999, 3222, 3260, 3260, 3341], [3345, 3425, 3471, 3471, 4036], [4038, 4057, 4092, 4092, 4184], [4187, 4251, 4286, 4286, 4340], [4342, 4369, 4426, 4586, 4724], [4726, 4747, 4790, 4790, 4878], [4880, 4935, 4955, 4979, 5293], [5363, 5393, 5429, 5456, 6645], [6792, 6831, 6854, 6854, 8272], [8502, 8530, 8548, 8578, 11913], [11916, 11937, 11973, 12022, 12443], [12446, 12537, 12572, 12944, 13206], [13210, 13405, 13457, 13535, 14778], [14781, 14933, 14969, 14969, 15264], [15269, 15269, 15325, 15358, 20288]], "test": "untested"}
{"id": "dtcBz7", "name": "Colored speed lines", "author": "michael_dll", "description": "From https://www.shadertoy.com/view/ctdfzN", "tags": ["speed"], "likes": 2, "viewed": 286, "published": 3, "date": "1701082564", "time_retrieved": "2024-07-30T17:20:31.960512", "image_code": "// Modified fork of \"Speed lines\" by \"Hadyn\": https://www.shadertoy.com/view/4dSyWK\n\n#define RADIUS 12.0\n#define EDGE 0.3\n\nconst vec3 COLOR = vec3(1., 1., 0.);\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(0.3333333)));\n\t vec3 x = p - s + dot(s, vec3(0.1666667));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + 0.1666667;\n\t vec3 x2 = x - i2 + 2.0*0.1666667;\n\t vec3 x3 = x - 1.0 + 3.0*0.1666667;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 2.;\n    float scale = 50.0;\n    vec2 uv = (fragCoord.xy*2. - iResolution.xy) / iResolution.y * 0.5;\n    vec2 p = vec2(0.5*iResolution.x/iResolution.y, 0.5) + normalize(uv) * min(length(uv), 0.05);\n    vec3 p3 = scale*0.25*vec3(p.xy, 0) + vec3(0, 0, time*0.025);\n    float noise = simplex3d(p3 * 32.0) * 0.5 + 0.5;\n    float dist = abs(clamp(length(uv)/RADIUS, 0.0, 1.0)*noise*2.-1.);\n    float stepped = smoothstep(EDGE-.5,EDGE+.5, noise * (1.0-pow(dist, 4.0)));\n    float final = smoothstep(EDGE - 0.05, EDGE + 0.05, noise*stepped);\n    \n    \n\tfragColor = vec4(COLOR * final,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 183, 356], [358, 358, 383, 383, 994], [996, 996, 1053, 1053, 1662]], "test": "untested"}
{"id": "clcfz7", "name": "Roguelike tunnels", "author": "jarble", "description": "A fractal pattern that looks like a roguelike dungeon map.\nClick and drag to move around.", "tags": ["roguelike"], "likes": 11, "viewed": 172, "published": 3, "date": "1701067826", "time_retrieved": "2024-07-30T17:20:32.760373", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract(.5+(a1)*(a2.x+a2.y))-.5)-.5\n    ;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    uv *= 32.*4.;\n    for(int k = 0; k < 4; k++){\n        uv =\n            min(\n            max(triangle_wave(uv/64./2.),triangle_wave(uv.yx/8./2.)),\n            max(triangle_wave(uv.yx/32./2.),triangle_wave(uv/16./2.)).yx\n            )\n        ;\n        uv = floor(uv*64.).yx;\n        //uv = floor(uv*16.).yx/2.;\n\n        col =\n            abs(col-sign(uv.x-uv.y))\n            //abs(vec3(col.yz,max((uv.x-uv.y)/64.,0.))-col)\n        ;\n\n        }\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    vec3 col = fractal(uv);\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 148], [150, 150, 172, 172, 666], [668, 668, 723, 723, 1032]], "test": "untested"}
{"id": "DtcfRM", "name": "Fluid Bubble Stream [218 Chars]", "author": "SnoopethDuckDuck", "description": "golfing welcome, i havent tried golfing it much", "tags": ["fluid", "weird", "layers", "golf"], "likes": 17, "viewed": 212, "published": 3, "date": "1701054260", "time_retrieved": "2024-07-30T17:20:33.520341", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    vec4 v = 16. * u.yxxy / iResolution.y, i;\n    \n    for( o = i ; \n        i++.x < 17.; \n         v += o*i/20. -.04*(iTime+60.)*vec4(1,2,3,2) - v.yzwx/16.\n       ) \n        o += atan(i+i*cos(i*i+length(.1*v.y+cos(i+v))))/19.;   \n      \n    o = 1./cosh(o*o*o*o - sin(v)/5.) ;\n}\n\n\n// Original [228]\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    o *= 0.;\n\n    vec4 v = 16. * u.yxxy / iResolution.y;\n    \n    for(float i; i++ < 17.; v+= o*i/402.-.04*(iTime+60.)*vec4(1,2,3,2)-v.yzwx/16.) \n        o += atan(i+i*cos(i*i+length(.1*v.y+cos(i+v))));   \n      \n    o = 1./cosh(-o*o*o*o/1.3e5+sin(v)/5.);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 317]], "test": "untested"}
{"id": "dttfz4", "name": "GLSL: non-monotonic sin", "author": "FordPerfect", "description": "If the screen flashes white dots this means your implementation of sin() is not monotonic on (0;/pi/2).", "tags": ["sin", "glsl", "ieee754"], "likes": 2, "viewed": 155, "published": 3, "date": "1701035735", "time_retrieved": "2024-07-30T17:20:34.291280", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Visually detect non-monotonicity of sin().\n// By default only [1.0;1.5+eps] is tested.\n// White dots mean non-monotonic.\n\n// See also https://www.shadertoy.com/view/dttczs for\n// more GLSL math funkiness.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float c=exp2(-23.0);\n    float lo=1.25+0.25*sin(0.1*iTime);\n    lo=floor(lo/c/iResolution.y)*c*iResolution.y;\n    float hi=lo+c*iResolution.x*iResolution.y;\n    float id=dot(floor(fragCoord),vec2(iResolution.y,1));\n    float x=lo+c*id;\n    vec3 col=(sin(x)>sin(x+c)?vec3(1):vec3(0.25));\n    if(fragCoord.y<16.0)\n    {\n        float t=2.0*fragCoord.x/iResolution.x;\n        if(t<lo) col.z+=0.25;\n        if(t>=lo&&t<hi) col.y+=0.25;\n        col.x+=exp(-4e2*abs(t-0.5*3.14159265358979));\n        if(fragCoord.y<8.0) col.x+=exp(-50.0*fract(10.0*t)*(1.0-fract(10.0*t)));\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttfz4.jpg", "access": "api", "license": "public-domain", "functions": [[277, 277, 331, 331, 939]], "test": "untested"}
{"id": "ctdfzN", "name": "Sharp Speed Lines", "author": "Peace", "description": "Sharp Speed Lines", "tags": ["lines", "speed"], "likes": 4, "viewed": 266, "published": 3, "date": "1701032388", "time_retrieved": "2024-07-30T17:20:35.053243", "image_code": "// The MIT License\n// Copyright © 2024 Giorgi Azmaipharashvili\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// From David Hoskins (MIT licensed): https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx) - 0.5;\n}\n\n// From Nikita Miropolskiy (MIT licensed): https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(1.0 / 3.0)));\n\t vec3 x = p - s + dot(s, vec3(1.0 / 6.0));\n\t vec3 e = step(vec3(0), x - x.yzx);\n\t vec3 i1 = e * (1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\t vec3 x1 = x - i1 + 1.0 / 6.0;\n\t vec3 x2 = x - i2 + 1.0 / 3.0;\n\t vec3 x3 = x - 0.5;\n\t vec4 w = max(0.6 - vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n\t w *= w;\n\t return dot(vec4(dot(hash33(s), x), \n                     dot(hash33(s + i1), x1), \n                     dot(hash33(s + i2), x2),  \n                     dot(hash33(s + 1.0), x3)) * w * w, vec4(52));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    float time = iTime * 2.0;\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / mr * 0.5;\n    vec2 p = vec2(0.5) + normalize(uv) * min(length(uv), 0.05);\n    vec3 p3 = 13.0 * vec3(p.xy, 0) + vec3(0, 0, time * 0.025);\n    float noise = simplex3d(p3 * 32.0) * 0.5 + 0.5;\n    float dist = abs(clamp(length(uv) / 12.0, 0.0, 1.0) * noise * 2.0 - 1.0);\n    const float e = 0.3;\n    float stepped = smoothstep(e - 0.5, e + 0.5, noise * (1.0 - pow(dist, 4.0)));\n    float final = smoothstep(e - 0.05, e + 0.05, noise * stepped);\n\tfragColor = vec4(vec3(final),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdfzN.jpg", "access": "api", "license": "mit", "functions": [[1090, 1166, 1188, 1188, 1325], [1327, 1408, 1433, 1433, 2009], [2011, 2011, 2064, 2064, 2677]], "test": "ok"}
{"id": "ctdBRN", "name": "New Comic", "author": "DrieStone", "description": "New comic shader. (work in progress)", "tags": ["webcam", "comic"], "likes": 0, "viewed": 231, "published": 3, "date": "1701026179", "time_retrieved": "2024-07-30T17:20:35.825179", "image_code": "// Parameters\nfloat edgeThreshold = 0.4; // Adjust for edge sensitivity\nfloat brightness = 0.2;    // Adjust for brightness\nfloat contrast = 2.5;\n\n// Helper function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Function to increase saturation\nvec3 boostSaturation(vec3 color, float amount)\n{\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= amount; // Increase saturation\n    return hsv2rgb(hsv);\n}\n\n// Modified Gaussian Blur Function for low saturation areas\nvec3 selectiveGaussianBlur(vec2 uv, vec3 color, float saturationThreshold, float blurAmount)\n{\n    vec3 blurredColor = vec3(0.0);\n    vec2 blurSize = vec2(blurAmount) / iResolution.xy; // Adjust blur size as needed\n\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(float(x), float(y)) * blurSize;\n            vec3 neighborColor = texture(iChannel0, uv + offset).rgb;\n\n            // Check if the color is of low saturation\n            if (rgb2hsv(neighborColor).y < saturationThreshold)\n            {\n                blurredColor += neighborColor;\n            }\n            else\n            {\n                blurredColor += color; // Keep original color if saturation is high\n            }\n        }\n    }\n\n    return blurredColor / 9.0; // Average of 3x3 kernel\n}\n\n// Function to adjust brightness\nvec3 adjustBrightness(vec3 color)\n{\n    return color + brightness;\n}\n\n// Function to adjust contrast\nvec3 adjustContrast(vec3 color)\n{\n    return (color - 0.5) * contrast + 0.5;\n}\n\n// Edge Detection Function with Adjusted Scale Factor\nfloat edgeDetection(vec2 uv)\n{\n    vec3 edgeColor = vec3(0.0);\n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    // Adjust this scale factor to control edge detection sensitivity\n    float scaleFactor = 1.5; // This value may need tweaking\n\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offset = scaleFactor * vec2(x, y) * texelSize;\n            vec3 neighborColor = texture(iChannel0, uv + offset).rgb;\n            edgeColor += abs(neighborColor - texture(iChannel0, uv).rgb);\n        }\n    }\n\n    float edgeStrength = length(edgeColor);\n    return edgeStrength > edgeThreshold ? 1.0 : 0.0;\n}\n\n\n// Color Quantization Function\nvec3 quantizeColor(vec3 color)\n{\n    int numColors = 3; // Adjust for color quantization level\n    vec3 quantized = floor(color * float(numColors)) / float(numColors);\n    return quantized;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 webcamColor = texture(iChannel0, uv);\n\n    // Boost saturation\n    vec3 adjustedColor = adjustBrightness(webcamColor.rgb);\n    adjustedColor = adjustContrast(adjustedColor);\n    adjustedColor = boostSaturation(adjustedColor, 1.1); // Adjust the factor as needed\n\n    // Selective blur on low saturation areas\n    float saturationThreshold = 0.2; // Adjust as needed\n    float blurAmount = 4.0; // Adjust blur amount\n    vec3 colorAfterBlur = selectiveGaussianBlur(uv, adjustedColor, saturationThreshold, blurAmount);\n\n    // Apply edge detection on the color after blur\n    float edgeStrength = edgeDetection(uv);\n\n    // Color quantization on color after blur and vibrancy adjustments\n    vec3 quantizedColor = quantizeColor(colorAfterBlur);\n\n    // Mix based on edge presence\n    vec3 finalColor = mix(quantizedColor, vec3(0.0), 0.5 * edgeStrength);\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 188, 210, 210, 541], [543, 584, 606, 606, 775], [777, 812, 860, 860, 962], [964, 1024, 1118, 1118, 1859], [1861, 1894, 1929, 1929, 1962], [1964, 1995, 2028, 2028, 2073], [2075, 2129, 2159, 2159, 2779], [2782, 2813, 2845, 2845, 3004], [3008, 3008, 3065, 3065, 4010]], "test": "untested"}
{"id": "cl3fz4", "name": "Graphic Design Experiment 11", "author": "yasuo", "description": "Graphic Design Experiment 11. `The brain hack` inspired.", "tags": ["graphicdesign", "cineshader"], "likes": 16, "viewed": 767, "published": 3, "date": "1700988747", "time_retrieved": "2024-07-30T17:20:36.632021", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),-antialiasing(1.5),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n\nvec2 twist(vec2 p, float k){\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = m*p;    \n    return q;\n}\n\nfloat graphicItem0(vec2 p){\n    p*=SkewY(radians(45.));\n    vec2 prevP = p;\n    \n    p.x*=3.;\n    float d = length(p)-0.3;\n    p = prevP;\n    \n    p.y-=0.07;\n    p.x*=2.7;\n    p.y = abs(p.y)-0.22;\n    float d2 = length(p)-0.2;\n    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p.y-=iTime*0.05;\n    p = mod(p,0.02)-0.01;\n    d = max(-(abs(p.x)-0.002),d);\n    d = max(-(abs(p.y)-0.002),d);\n    \n    return d;\n}\n\nfloat graphicItem1(vec2 p){\n    vec2 prevP = p;\n    p.y*=0.5;\n    float d = B(p,vec2(0.1));\n    \n    p = abs(p)-0.095;\n    p.y+=0.01;\n    d = max(-(length(p)-0.1),d);\n    d = abs(d)-0.004;\n    p = prevP;\n    d = max(abs(p.y)-0.17,d);\n    return d;\n}\n\nfloat graphicItem2(vec2 p){\n    vec2 prevP = p;\n    p.x*=2.2;\n    p.y-=iTime*0.3;\n    \n    p.y = mod(p.y,0.12)-0.06;\n    p.y-=0.05;\n\n    float d = Tri(p,vec2(0.09));\n    p.y+=0.06;\n    p.x*=0.3;\n    d = max(-Tri(p,vec2(0.09)),d);\n    return d;\n}\n\nfloat graphicItem3_1(vec2 p){\n    p.y*=0.9;\n    p*=SkewY(radians(-50.));\n    vec2 prevP = p;\n    p.x-=0.006;\n    p.y+=0.035;\n    float d = B(p,vec2(0.011,0.09));\n    float a = radians(25.);\n    p.y = abs(p.y)-0.06;\n    p.x+=0.005;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x+=0.006;\n    p.y-=0.035;\n    float d2 = B(p,vec2(0.011,0.09));\n    a = radians(-25.);\n    p.y = abs(p.y)-0.06;\n    p.x-=0.005;\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat graphicItem3(vec2 p){\n    vec2 prevP = p;\n    p.y-=iTime*0.3;\n    p.y = mod(p.y,0.3)-0.15;\n    float d = graphicItem3_1(p);\n    \n    return d;\n}\n\nfloat graphicItem4(vec2 p){\n    vec2 prevP = p;\n    p.y-=iTime*0.3;\n    p.y = mod(p.y,0.24)-0.12;\n    float d = B(p,vec2(0.05,0.1));\n    float d2 = B(p-vec2(0.,0.045),vec2(0.05,0.1));\n    float a = radians(-5.);\n    p.x = abs(p.x)-0.04;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-15.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = max(-d2,d);\n    \n    a = radians(-12.);\n    p.x-=0.02;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    return d;\n}\n\n\nfloat graphicItem5(vec2 p){\n    p.y-=iTime*0.3;\n    p.y = mod(p.y,0.42)-0.21;\n    p.y+=0.01;\n    vec2 prevP = p;\n    p.x-=0.01;\n    p.x*=2.;\n    p.y*=0.7;\n    p.y-=0.09;\n    p *= SkewY(radians(-10.));\n    float d = max(p.x,Tri(p,vec2(0.1)));\n    \n    p =prevP;\n    p.x+=0.01;\n    p.x*=2.;\n    p.y*=-1.0;\n    p.y*=0.7;\n    p.y-=0.09;\n    p *= SkewY(radians(10.));\n    float d2 = max(-p.x,Tri(p,vec2(0.1)));\n    d = min(d,d2);\n    \n    p =prevP;\n    p.x-=0.03;\n    p.y-=0.08;\n    p*=Rot(radians(-5.));\n    p.x*=1.2;\n    p.y*=0.7;\n    p.y-=0.095;\n    p *= SkewY(radians(-20.));\n    d2 = max(p.x,Tri(p,vec2(0.1)));\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat pattern0(vec2 p){\n    vec2 prevP = p;\n    \n    p = DF(p,3.);\n    p-=0.2;\n    p*=Rot(radians(45.));\n    \n    vec2  q = twist(p,-0.3);    \n    \n    float d = graphicItem2(p);\n    return d;\n}\n\nfloat pattern1(vec2 p){\n    vec2 prevP = p;\n    \n    p = DF(p,3.);\n    p-=0.2;\n    p*=Rot(radians(45.));\n    \n    float d = graphicItem3(p);\n    return d;\n}\n\n\nfloat pattern2(vec2 p){\n    vec2 prevP = p;\n    \n    p = DF(p,3.);\n    p-=0.4;\n    p*=Rot(radians(45.));\n    \n    float d = graphicItem4(p);\n    return d;\n}\n\n\nfloat pattern3(vec2 p){\n    vec2 prevP = p;\n    \n    p = DF(p,3.);\n    p-=0.2;\n    p*=Rot(radians(45.));\n    \n    float d = graphicItem5(p);\n    return d;\n}\n\nfloat centerItem0(vec2 p){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-45.*iTime));\n    \n    float d = length(p)-0.17;\n    \n    p = DF(p,0.75);\n    p-=0.11;\n    p.y+=0.02;\n    p.x*=0.75;\n    p.y*=1.2;\n    d = max(-(length(p)-0.1),d);\n    \n    return d;\n}\n\nfloat centerItem_line(vec2 p, float dir){\n    vec2 prevP = p;\n    p.x+=iTime*0.1*dir;\n    p.x = mod(p.x,0.12)-0.06;\n    p*=SkewX(radians(-60.));\n    float d = B(p,vec2(0.05,0.01));\n    p = prevP;\n    \n    p*=SkewX(radians(-60.));\n    d = max((abs(p.x)-0.17),d);\n    return d;\n}\n\nfloat centerItem1(vec2 p){\n    p*=1.2;\n    vec2 prevP = p;\n    \n    float size = 0.17;\n    p.x*=1.5;\n    p.y*=-1.;\n    p.y-=size*0.5;\n    float d = abs(Tri(p,vec2(size)))-0.01;\n    p = prevP;\n    p*=Rot(radians(30.*iTime+15.));\n    d = max(-(abs(p.x)-0.03),d);\n    \n    p = prevP;\n    p.x-=0.055;\n    p.y-=size*0.5+0.03;\n    float d2 = centerItem_line(p,1.);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x+=0.115;\n    p.y-=0.035;\n    p*=Rot(radians(57.));\n    d2 = centerItem_line(p,-1.);\n    d = min(d,d2);\n    p = prevP;\n\n    p.x-=0.05;\n    p.y+=0.07;\n    p*=Rot(radians(-57.));\n    d2 = centerItem_line(p,-1.);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat centerItem2(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-35.*iTime));\n    p = DF(p,3.);\n    p-=0.08; \n    \n    float d = centerItem_line(p,0.5);\n    return d;\n}\n\nfloat centerItem3(vec2 p){\n    p*=Rot(radians(-35.*iTime));\n    vec2 prevP = p;\n\n    float d = abs(B(p,vec2(0.1)))-0.01;\n    p*=Rot(radians(-25.*iTime+45.));\n    d = max(-(abs(p.x)-0.03),d);\n    \n    p = prevP;\n    p*=Rot(radians(-45.));\n    float d2 = abs(B(p,vec2(0.1)))-0.01;\n    p = prevP;\n    p*=Rot(radians(25.*iTime+45.));\n    d2 = max(-(abs(p.x)-0.03),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat centerItem4(vec2 p){\n    p.x*=0.8;\n    p.y*=1.2;\n    vec2 prevP = p;\n    \n    p*=SkewY(radians(-40.));\n    float d = abs(length(p)-0.1)-0.01;\n    p*=Rot(radians(-55.*iTime-45.));\n    d = max(-(abs(p.x)-0.03),d);\n    \n    p = prevP;\n    p*=SkewY(radians(40.));\n    float d2 = abs(length(p)-0.1)-0.01;\n    p*=Rot(radians(55.*iTime+45.));\n    d2 = max(-(abs(p.y)-0.03),d2);    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat mainGraphic(vec2 p){\n    vec2 prevP = p;\n    float d  = pattern0(p);\n    float t = mod(iTime*1.,4.);\n    if(t<1.){\n        d  = pattern3(p);\n    } else if (t>=1. && t<2.){\n        d  = pattern1(p);\n    } else if (t>=2. && t<3.){\n        d  = pattern2(p);\n    } else if (t>=3. && t<4.){\n        d  = pattern0(p);\n    }\n    \n    p*=Rot(radians(45.));\n    p = DF(p,3.);\n    p-=0.3;\n    p*=Rot(radians(45.));\n    \n    vec2 prevP2 = p;\n    \n    p.y-=iTime*0.3;\n    p.y = mod(p.y,0.2)-0.1;\n    float d2 = length(p)-0.01;\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.y-=iTime*0.3;\n    p.y-=0.11;\n    p.y = mod(p.y,0.2)-0.1;\n    p.x*=1.5;\n    d2 = Tri(p,vec2(0.02));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat centerGraphic(vec2 p){\n    vec2 prevP = p;\n    float d = centerItem4(p);\n    \n    float t = mod(iTime*3.,5.);\n    if(t<1.){\n        d  = centerItem0(p);\n    } else if (t>=1. && t<2.){\n        d  = centerItem1(p);\n    } else if (t>=2. && t<3.){\n        d  = centerItem2(p);\n    } else if (t>=3. && t<4.){\n        d  = centerItem3(p);\n    } else if (t>=4. && t<5.){\n        d  = centerItem4(p);\n    }\n\n    return d;\n}\n\nfloat otherGraphicElements(vec2 p){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.55;\n    p.y = abs(p.y)-0.35;\n    p*=Rot(radians(-105.));\n    float d = graphicItem0(p);\n    p = prevP;\n    \n    p.x = abs(p.x)-0.7;\n    float d2 = graphicItem1(p);\n    d = min(d,d2);\n    p = prevP;\n    p.x = abs(p.x)-0.3;\n    p.y = abs(p.y)-0.4;\n    p*=Rot(radians(40.));\n    p*=2.;\n    d2 = graphicItem1(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat bg(vec2 p){\n    p = mod(p,0.05)-0.025;\n    float d = length(p)-0.0015;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    float d = bg(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    d = mainGraphic(p);\n    col = mix(col,vec3(1.),S(d,0.001));\n    col*=length(p)-0.1;\n    col*= 0.6-(length(p)-0.3);\n\n    d = centerGraphic(p);    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = otherGraphicElements(p);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3fz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 606, 606, 727], [729, 729, 756, 756, 1136], [1138, 1138, 1165, 1165, 1387], [1389, 1389, 1416, 1416, 1634], [1636, 1636, 1665, 1665, 2154], [2156, 2156, 2183, 2183, 2306], [2308, 2308, 2335, 2335, 2789], [2792, 2792, 2819, 2819, 3438], [3440, 3440, 3463, 3463, 3634], [3636, 3636, 3659, 3659, 3792], [3795, 3795, 3818, 3818, 3951], [3954, 3954, 3977, 3977, 4110], [4112, 4112, 4138, 4138, 4367], [4369, 4369, 4410, 4410, 4646], [4648, 4648, 4674, 4674, 5301], [5303, 5303, 5329, 5329, 5473], [5475, 5475, 5501, 5501, 5884], [5886, 5886, 5912, 5912, 6306], [6308, 6308, 6334, 6334, 7013], [7015, 7015, 7043, 7043, 7436], [7438, 7438, 7473, 7473, 7858], [7860, 7860, 7877, 7877, 7952], [7954, 7954, 8011, 8011, 8468]], "test": "untested"}
{"id": "DtcfR4", "name": "3D wave expansion comparison", "author": "lomateron", "description": "showing 3 methods side by side to show if math is right\nlooks it is, only the wave ring at the center counts, ignore the rest\nVERY SLOW CODE remove \"discard\" code line to explore more with mouse", "tags": ["physics"], "likes": 2, "viewed": 230, "published": 3, "date": "1700985050", "time_retrieved": "2024-07-30T17:20:37.399968", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame!=0){discard;}\n    float zoom = 9.;\n    vec2 u = zoom*(fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m = zoom*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    float t = m.x; //if(iMouse.z<.5){t = iTime*.3;} //how expanded is the wave\n          t = 2.;  \n    float res = 33.;                               //wave resolution\n    float wid = 11.;//66.*m.y;                     //wave width\n    float amp = .1;                                //wave amplitude\n    float pi  = 3.14159265358;\n    float l   = length(u);\n    float o   = 0.;\n    if(u.y>=0.)            //O(1) method, top half, exact solution, does not depend on \"res\"\n    {\n        float c = 1./wid;\n        o = sqrt(pi)/(8.*c*c*c*l)*(-(t - l)*exp(-pow(t - l,2.)/(4.*c*c))\n                                   +(t + l)*exp(-pow(t + l,2.)/(4.*c*c)));\n    }\n    if(u.x<0.&&u.y<0.)     //O(n) method, bottom left\n    {\n        float sum = 0.;\n        for(float a=1.; a<res; a++){\n            float an1 = a*l;\n            float an2 = a*t;\n            sum += a*a*cos(an2)*sin(an1)/an1/exp(a*a/wid/wid);\n        }\n        o = sum;\n    }\n    if(u.x>=0.&&u.y<0.)    //O(n^3) method, bottom right\n    {\n        float sum = 0.;\n        for(float c=-res; c<=res; c++){\n        for(float b=-res; b<=res; b++){\n        for(float a=-res; a<=res; a++){\n            float ang = (u.x*a + u.y*b) + sqrt(a*a+b*b+c*c)*t;\n            sum += cos(ang)/exp((a*a+b*b+c*c)/wid/wid);\n        }}}\n        o = sum/pi/4.;\n    }\n    fragColor = vec4(o*amp*amp+.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1569]], "test": "untested"}
{"id": "XtXcW7", "name": "JhericoMandelbrotTest", "author": "jherico", "description": "Teaching my son about fractals", "tags": ["fractal"], "likes": 0, "viewed": 113, "published": 3, "date": "1700957757", "time_retrieved": "2024-07-30T17:20:38.228752", "image_code": "const float B = 2.0;\nconst float iterations = 400.0;\n\nvec2 madelbrot(vec2 z, vec2 c) {\n\treturn vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n}\n\nfloat d2(vec2 a, vec2 b) {\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //fragColor = abs(vec4(pixelToDevice(fragCoord, iResolution.xy), 0.0, 1.0));\n    //return;\n    vec4 offsetAndZoom = texelFetch( iChannel0, ivec2(0, 0), 0);\n    vec2 offset = offsetAndZoom.xy;\n    float zoom = offsetAndZoom.z;\n    vec2 pixelCoords = pixelToDevice(fragCoord.xy, iResolution.xy);\n    vec2 c = pixelCoords / zoom;\n    c += offset;\n    vec2 z = vec2(0.0);\n\n    float count = 0.0;\n    for (float i = iterations; i > 0.0; i -= 1.0) {\n        z = madelbrot(z, c);\n        if( dot(z,z)>(B*B) ) {\n        \tcount = i;\n            break;\n        }\n    }\n    \n\n    if ( count == 0.0) {\n//\t\tfragColor = vec4(vec2(count / iterations),0.5+0.5*sin(iTime),1.0);\n        fragColor = vec4(vec2(0.0), offsetAndZoom.x, 1.0);\n    } else {\n        vec3 color = hue2rgb(count / iterations);\n\t\tfragColor = vec4(color,1.0);\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec4 offsetAndZoom = texelFetch( iChannel0, ivec2(0, 0), 0).xyzw;\n    if (offsetAndZoom.z == 0.0) {\n        fragColor = vec4(0, 0, 0.4, 0);\n    } else {\n        vec2 muv = pixelToDevice(iMouse.xy, iResolution.xy);\n        float zoom = offsetAndZoom.z;\n        vec2 pos = offsetAndZoom.xy;\n\n        if (iMouse.w > 0.01) {\n            offsetAndZoom.xy += (muv * 0.5) / zoom;\n            offsetAndZoom.z *= 1.1;\n        }\n\n\n     \n        offsetAndZoom.w = abs(muv.x);\n\n        // Pass in the offset of the last frame and return a new offset based on keyboard input\n        // offset = handleKeyboard(offset);\n        fragColor = offsetAndZoom;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 pixelToDevice( vec2 a, vec2 resolution )\n{\n    vec2 muv = a / resolution.xy;\n    float ratio = resolution.x / resolution.y;\n    muv -= 0.5;\n    muv *= 2.0;\n    muv.x *= ratio;\n    return muv;\n}\n\n\n//Hue to RGB (red, green, blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 86, 86, 140], [142, 142, 168, 168, 186], [189, 189, 246, 341, 1072]], "test": "untested"}
{"id": "dttfR8", "name": "conway-life", "author": "LydianLights", "description": "Click to re-seed with noise. You can change SCALE and REFRESH_RATE in the common tab to modify the simulation.\nI mostly did this as a \"hello world\" experiment in doing compute-buffer-style stuff with shadertoy's buffers.", "tags": ["life", "cellularautomata"], "likes": 3, "viewed": 118, "published": 3, "date": "1700955732", "time_retrieved": "2024-07-30T17:20:39.048560", "image_code": "vec3 gamma(in vec3 color) {\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = fragCoord / SCALE;\n    vec4 data = texelFetch(iChannel0, ivec2(coord), 0);\n    \n    vec3 color;\n    if (data.x == 1.0) {\n        float t = min(data.z / 15.0, 1.0);\n        color = palette(t);\n    } else {\n        float t = 1.0 - min(data.z / 30.0, 1.0);\n        color = 0.2 * t * palette(1.0);\n    }\n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x > iResolution.x / SCALE || fragCoord.y > iResolution.y / SCALE) return;\n    \n    // x = alive/dead\n    // y = neighbor count\n    // z = age\n    vec4 data;\n    \n    if (iFrame == 0 || iMouse.w > 0.0) {\n        float t = iDate.x + iDate.y + iDate.z + iDate.w;\n        data.x = step(0.5, hash13(vec3(fragCoord.xy, t)));\n        fragColor = data;\n        return;\n    }\n    \n    data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (mod(float(iFrame), REFRESH_RATE) != 0.0) {\n        fragColor = data;\n        return;\n    }\n    \n    float neighborCount;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            if (x == 0.0 && y == 0.0) {\n                continue;\n            }\n            vec2 offset = vec2(x, y);\n            vec2 coord = mod(fragCoord + offset, iResolution.xy / SCALE);\n            neighborCount += texelFetch(iChannel0, ivec2(coord), 0).x;\n        }\n    }\n    \n    data.y = neighborCount;\n    data.z++;\n    \n    if (data.x == 0.0) {\n        if (neighborCount == 3.0) {\n            data.x = 1.0;\n            data.z = 0.0;\n        }\n    } else {\n        if (neighborCount != 2.0 && neighborCount != 3.0) {\n            data.x = 0.0;\n            data.z = 0.0;\n        }\n    }\n    \n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float SCALE = 3.0;\nconst float REFRESH_RATE = 2.0;\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(0.5, 0.5, 0.5);\n    vec3 d = vec3(0.1, 0.3, 0.8) - 0.2;\n    return a + b * cos(6.28318 * (c * t + d));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 79], [81, 81, 136, 136, 516]], "test": "untested"}
{"id": "ltc3Dr", "name": "HexDebug", "author": "jherico", "description": "debugging hexagon functions, still buggy", "tags": ["hexagon", "debug"], "likes": 2, "viewed": 125, "published": 3, "date": "1700954419", "time_retrieved": "2024-07-30T17:20:39.890310", "image_code": "\n\nconst vec3 DARKGREY = vec3(0.1);\nconst vec3 LIGHTGREY = vec3(0.2);\nconst vec3 WHITE = vec3(1);\nconst vec3 AMBER = vec3(1, 0.49, 0);\nconst vec3 TRON_BLUE = vec3(0.1, 0.5, 0.8);\n\nconst vec3 HEX_BORDER = LIGHTGREY;\nconst vec3 HEX_BODY = DARKGREY;\nconst vec3 HAZE = LIGHTGREY;\nconst float HEX_SIZE = 18.0;\n\nivec3 cube_round(vec3 h) {\n    vec3 r = floor(h + 0.5);\n    vec3 diff = abs(r - h);\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -r.y - r.z;\n    } else if (diff.y > diff.z) {\n        r.y = -r.x - r.z;\n    } else {\n        r.z = -r.x - r.y;\n    }\n    return ivec3(int(r.x), int(r.y), int(r.z));\n}\n\nfloat cube_distance(ivec3 a, ivec3 b) {\n    vec3 ab = abs(vec3(a) - vec3(b));\n    \n    return max(max(ab.x, ab.y), ab.z);\n}\n        \nivec2 cube_to_hex(ivec3 c) {\n    return c.xy;\n}\n\nivec3 hex_to_cube(ivec2 h) {\n    return ivec3(h.x, h.y, -h.x - h.y);\n}\n\nvec3 hex_to_cube(vec2 h) {\n    return vec3(h.x, h.y, -h.x - h.y);\n}\n\nivec2 hex_round(vec2 h) {\n    return cube_to_hex(cube_round(hex_to_cube(h)));\n}\n\nivec2 pixel_to_hex(in vec2 pixel) {\n    const vec2 PIXEL_TO_HEX_CONST = vec2(sqrt(3.0), 2.0) / 3.0;\n    vec2 result = PIXEL_TO_HEX_CONST * pixel;\n    result.x -= pixel.y / 3.0;\n    \n    return hex_round(result);\n}\n\nvec2 hex_to_pixel(in ivec2 hex2)  {\n    vec2 hex = vec2(hex2);\n    return vec2(sqrt(3.0) * (hex.x + hex.y/2.0), 1.5 * hex.y);\n}\n\nvec2 hex_center(in vec2 pixel) {\n    return hex_to_pixel(pixel_to_hex(pixel));\n}\n\nfloat point_line_distance(vec2 slope, vec2 p)\n{\n  vec2 normal = vec2(-slope.y, slope.x);\n  return abs(dot(normalize(normal), p));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = DARKGREY;\n\n    vec2 xy = 1.0 - 2.0 * fragCoord.xy/iResolution.xy;\n    xy *= HEX_SIZE;\n    xy.y /= iResolution.x / iResolution.y;\n    vec2 mousexy = 1.0 - 2.0 * iMouse.xy/iResolution.xy;\n    mousexy.y /=  iResolution.x / iResolution.y;\n    mousexy *= HEX_SIZE;\n\n    \n    float lineDist = point_line_distance(mousexy, xy);\n    if (lineDist < 0.03) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(0.05, 0.03, lineDist));\n    \n    ivec2 hex = pixel_to_hex(xy);\n    vec2 hexCenter = hex_to_pixel(hex);\n    \n    \n    ivec2 origin = ivec2(0);\n    if (hex == origin) {\n        fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n        return;\n    }\n\n    ivec2 mousehex = pixel_to_hex(mousexy);\n    ivec3 cur = hex_to_cube(hex);\n    ivec3 a = hex_to_cube(origin);\n    ivec3 b = hex_to_cube(mousehex);\n\n    if (cur == b) {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    \n    float cubedist = floor(cube_distance(a, b));\n    for (float i = 0.0; i < 10000.0; i += 0.01) {\n        if (i > cubedist) {\n            break;\n        }\n        float mixAmount = i / cubedist;\n        ivec3 testCube = cube_round(mix(vec3(a), vec3(b), mixAmount));\n        ivec2 testHex = cube_to_hex(testCube);\n        if (hex == testHex) {\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n    }\n\n    vec2 hexPos = hex_to_pixel(hex.xy);\n    float dist = length(xy - hexPos);\n    if (dist < 0.3) {\n        col = vec3(1.0, 0.0, 1.0);\n    }\n    // gamma\n\t//col = pow(col,vec3(0.4545));\n\n    // vignetting\t\n\t//col *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\t\n    #ifdef STEREO\t\n    //col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltc3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 331, 331, 615], [617, 617, 656, 656, 740], [750, 750, 778, 778, 797], [799, 799, 827, 827, 869], [871, 871, 897, 897, 938], [940, 940, 965, 965, 1019], [1021, 1021, 1056, 1056, 1234], [1236, 1236, 1271, 1271, 1363], [1365, 1365, 1397, 1397, 1445], [1447, 1447, 1494, 1494, 1578], [1581, 1581, 1638, 1638, 3437]], "test": "untested"}
{"id": "ml3fRH", "name": "black_white window", "author": "jathomaz", "description": "simple. tests frag coord on x axis for > .5 white if true", "tags": ["whiteblack"], "likes": 0, "viewed": 108, "published": 3, "date": "1700935644", "time_retrieved": "2024-07-30T17:20:40.649281", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);  //start black\n \n    // Output to screen\n   \n    if (uv.x > 0.5) col = vec3(1.0);\n     fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3fRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 320]], "test": "untested"}
{"id": "dtcBRH", "name": "These mist covered mountains...", "author": "mrange", "description": "CC0: These mist covered mountains...\n Tinkering around with a terrain marcher.\n Thought I share it and explain a bit what's going on\n  The name of the game is fine tuning!\n\n", "tags": ["fbm"], "likes": 25, "viewed": 354, "published": 3, "date": "1700934243", "time_retrieved": "2024-07-30T17:20:41.582785", "image_code": "// CC0: These mist covered mountains...\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n// Uncomment if you are on mobile devices and the screen goes dark\n// \"Might\" help\n#define APPLY_FXAA\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  // Apply FXAA (full screen anti aliasing) to reduce some aliasing effects caused\n  // by specular lighting\n#ifdef APPLY_FXAA  \n  vec3 col = fxaa(iChannel0, q, 1.0/RESOLUTION.xy).xyz;\n#else\n  vec3 col = texture(iChannel0, q).xyz;\n#endif\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35351, "src": "https://soundcloud.com/progressive-rock/mark-knopfler-brothers-in-arms?si=8949302be68844bab8502540f5a6a5c8&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// CC0: These mist covered mountains...\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float \n  pi        = acos(-1.0)\n, tau       = 2.*pi\n;\nconst vec2 U = vec2(0., 1.);\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash1(vec2 co) {\n  // Creates a pseudo random number from a 2D coord\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  // Creates two pseudo random number from a 2D coord\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat vnoise(vec2 p) {\n // Value noise (vnoise) to my understanding is basically generating a white noise (using hash)\n // samples in a grid and interpolating using smoothstep to create \"smoother\" noise\n // which is more suited to generate terrains\n // Another common approach is perlin noise\n vec2 i = floor(p);\n vec2 f = fract(p);\n    \n vec2 u = f*f*(3.0-2.0*f);\n\n float a = hash1(i);\n float b = hash1(i+U.yx);\n float c = hash1(i+U.xy);\n float d = hash1(i+U.yy);\n   \n float m0 = mix(a, b, u.x);\n float m1 = mix(c, d, u.x);\n float m2 = mix(m0, m1, u.y);\n    \n return m2;\n}\n\n// https://iquilezles.org/articles/fbm/\nvec3 terrain(vec2 p, int n) {\n  vec2 np = p;\n  vec2 cp = p;\n  float nh = 0.0;\n  float na = 1.0;\n  float ns = 0.0;\n  const mat2 nr = 2.11*ROT(radians(57.0));\n\n  // Terrain generated by applying vnoise function multiple times\n  //  Each time halving the amplitude and roughly doubling the frequency.\n\n  // This generating a height field that looks like mountains\n\n  for (int i = 0; i < n; ++i) {\n    nh += na*vnoise(np);\n    np += 123.4;\n    np *= nr;\n    ns += na;\n    na *= 0.5;\n  }\n  \n  \n  // Subtracting cone shaped objects to create more dramatic terrain\n  nh /= ns;\n  cp *= 0.05*nr;\n  vec2 cn = floor(cp);\n  cp = fract(cp);\n  cp *= pi;\n  float ch = 0.5*((sin(cp.x)*sin(cp.y)));\n  float h = hash1(cn);\n  nh -= 2.0*ch*h*h*h;\n  \n  vec3 col = vec3(nh);\n  return col;\n}\n\n\n// From Shane's excellent shader: Perspex Web Lattice\n//  https://www.shadertoy.com/view/Mld3Rn\n//  Adopted slightly\nvec3 voronoi(vec2 p) {\n  // Voronoi patterns look somewhat organic and is used here to create tree a like texture\n  p*= 20.0;\n  vec2 g = floor(p);\n  vec2 o;\n  p -= g;\n  \n  float dx = 8.0;\n  float dy = 8.0;\n  float dz = 8.0;\n  vec2 c = vec2(0.01);\n  for(int y = -1; y <= 1; y++) {\n    for(int x = -1; x <= 1; x++) {\n      o = vec2(x, y);\n      vec2 h = hash2(g + o); \n      o += h - p;\n      dz = dot(o, o); \n      dy = max(dx, min(dy, dz));\n      if (dz < dx) {\n        dx = dz;\n        c = h;\n      }\n    }\n  }\n  \n  return vec3(max(dy/1.2 - dx, 0.)/1.2, fract(c.x+c.y), 0.);\n}\n\n\n\n", "buffer_a_code": "// CC0: These mist covered mountains...\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n// Generating a high detailed terrain texture used during raymarching\n//  and to generate the mountain normal\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  fragColor = vec4(terrain(p, 10), 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// CC0: These mist covered mountains...\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n// Generating a low detailed terrain texture used during to generate the snow normal\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  fragColor = vec4(terrain(p, 5), 1.0);\n}", "buffer_b_inputs": [], "buffer_c_code": "// CC0: These mist covered mountains...\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n// Generating the voronoi texture used to generate the trees\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  fragColor = vec4(voronoi(p), 1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": "// CC0: Mountains and beaches\n//  Tinkering around with a terrain marcher.\n//  Thought I share it and explain a bit what's going on\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// HSV2RGB let's us define a color using hue saturation and brightness\n//  I find it an easier way to experiment with getting the colors right\n//  All of these colors have been fine tuned through lots of experiments\nconst vec3 \n  skyCol     = HSV2RGB(vec3(0.57, 0.7 , 0.25))\n, sunCol     = HSV2RGB(vec3(0.07, 0.66, 25E-4))\n, glowCol    = HSV2RGB(vec3(0.98, 0.66, 25E-4))\n, groundCol0 = HSV2RGB(vec3(0.04, 0.9 , 0.1))\n, groundCol1 = HSV2RGB(vec3(0.06, 0.45, 0.5))\n, groundCol2 = HSV2RGB(vec3(0.05, 0.6 , 1.0))\n, treeCol0   = HSV2RGB(vec3(0.35, 0.8 , 0.4))\n, treeCol1   = HSV2RGB(vec3(0.12, 0.95, 0.8))\n, mistCol    = HSV2RGB(vec3(0.55, 0.13, 1.0))\n, sandCol    = HSV2RGB(vec3(0.087, 0.35, 0.5))\n// An approximate direction of the sky\n//  Used to cheat illumination from the sky\n, skyDir     = normalize(vec3(0.5, 0.25, 1.0)) \n, sunDir     = normalize(vec3(0.0, 0.1, -1.0))\n;\n\nconst float \n, max_dist  = 14.0\n, tolerance = 1E-3\n, norm_off  = 1E-2\n// Controls the path of the camera\n, path_a    = 0.20123\n, path_b    = 3.0\n, path_c    = 0.123\n, minh      = 0.5\n, maxh      = 2.5\n, waterLevel= 0.3\n, beachLevel= waterLevel+0.01\n, treeLevel = waterLevel+0.4\n, cloudLevel= waterLevel+0.125\n;\nconst int\n  max_iter = 80\n  ;\n\n// The camera path or the current eye position\nvec3 cam_path(float z) {\n  return vec3(sin(z*path_a)*path_b, 1.25+0.5*sin(z*path_c), -z);\n}\n\n// The derivate of the camera path, will be used to generate the direction we are looking at\nvec3 dcam_path(float z) {\n  return vec3(path_a*path_b*cos(path_a*z), path_c*0.5*cos(z*path_c), -1.0);\n}\n\n// The derivate of the derivate, used to to tilt the camera to increase the feeling\n// of us being in an airplane\nvec3 ddcam_path(float z) {\n  return vec3(-path_a*path_a*path_b*sin(path_a*z), -path_c*path_c*0.5*sin(z*path_c), 0.0);\n}\n\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  // We create colors in 0,inf range but the final result must be clamp to 0,1\n  //  Just a normal clamp will create significant glare around the sun\n  //  This function maps 0,inf to 0,1\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat hf(sampler2D fbm, vec2 p) {\n  // Samples the height texture \n  \n  // Computes a global height function around the cam path, \n  //  Because we use a height texture this makes the texture repeat\n  //  The global height function makes that less apparant\n  vec3 cam = cam_path(p.y);\n  float g =  mix(minh, maxh*(0.5-0.5*cos(0.124*p.y)), smoothstep(0.25, 2.0-0.5*sin(0.124*p.y), max(abs(cam.x+p.x), 0.0)));\n\n  p *= 0.125;\n  p += 0.5;\n\n  // Performs a reflection of the texture to lessen the artefacts at the border of the texture\n  vec2 n = fract(0.5*floor(p));\n  p = fract(p);\n  p.x = n.x == 0.0 ? p.x : 1.-p.x;\n  p.y = n.y == 0.0 ? p.y : 1.-p.y;\n  \n  \n  return g*texture(fbm, p).x;\n}\n\nfloat hihf(vec2 p) {\n  return hf(iChannel0 ,p);\n}\n\nfloat lohf(vec2 p) {\n  return hf(iChannel1 ,p);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float initt, float minstep) {\n  // Marches the height field until we hit the ground\n\n  float t = initt;\n  \n  float stp = 0.9;\n  int i;\n  float lastt;\n  for (i = 0; i < max_iter; ++i) {\n    if (t > max_dist) {\n      break;\n    }\n    vec3 p = ro+rd*t;\n    // Compute the height of the terrain at the current position\n    float h = hihf(p.xz);\n    // The height is an approximate distance, \n    // If the mountain is rising rapidly it's possible to travel through it\n    //  or hit the inside\n    \n    float d = p.y - h;\n    \n    if (d < tolerance) {\n      // Because of the approximate nature of the distance\n      //  when we hit the surface we attempt a back track and reduce the stp size\n      \n      if (stp >= 0.1) {\n        stp /= 3.0;\n        t = lastt;\n      } else {\n        break;\n      }\n    }\n    \n    lastt = t;\n    // Step forward\n    t += max(stp*d, minstep);\n  }\n\n  return t;\n}\n\nvec3 hinormal(vec2 p, float e) {\n  // Compute a high resolution normal\n  //  Used to compute the color of the mountain sides\n  vec2 eps = vec2(e, 0.0);\n  return normalize(vec3(\n    hihf(p - eps.xy) - hihf(p + eps.xy)\n  , 2.0*eps.x\n  , hihf(p - eps.yx) - hihf(p + eps.yx)\n  ));\n}\n\nvec3 lonormal(vec2 p, float e) {\n  // Compute a low resolution normal\n  //  Used to compute the color of the snow\n  vec2 eps = vec2(e, 0.0);\n  return normalize(vec3(\n    lohf(p - eps.xy) - lohf(p + eps.xy)\n  , 2.0*eps.x\n  , lohf(p - eps.yx) - lohf(p + eps.yx)\n  ));\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  // The sky color\n  vec3 col = vec3(0.0);\n  // The primary sun color\n  col += sunCol/max((1.0-dot(rd, sunDir)), 0.001);\n  // A reddish glow around the horizon and rising around the sun\n  col += glowCol/max(0.05*abs(rd.y)+0.25*rd.x*rd.x, 0.005);\n  // The sky color that fades out upwards\n  col += skyCol*(1.125-tanh_approx(17.0*(rd.y*rd.y)));\n  return col;\n}\n\n\nvec2 sampleVoronoi(vec2 p) {\n  // Sampling the voronoi height feild\n  p *= 3.0;\n\n  // Reflect again to avoid artefacts around borders\n  vec2 n = fract(0.5*floor(p));\n  p = fract(p);\n  \n  p.x = n.x == 0.0 ? p.x : 1.-p.x;\n  p.y = n.y == 0.0 ? p.y : 1.-p.y;\n  return texture(iChannel2, p).xy;\n}\n\nfloat treehf(vec2 p, out float vc, out float vh) {\n  // Tree height function, using the height of the terrain and adds the voronoi pattern\n  vec2 vp = sampleVoronoi(p);\n  vh = vp.x;\n  vc = vp.y;\n  return lohf(p)+vp.x*.075;\n}\n\nfloat treehf(vec2 p) {\n  float vc;\n  float vh;\n  return treehf(p, vc, vh);\n}\n\nvec3 treenormal(vec2 p, float e, out float vc, out float vh) {\n  // Tree height normal\n  //  To give a normal that is adjusted by the voronoi pattern as\n  //  well as to extract what color should be used for this tree cell\n  vec2 eps = vec2(e, 0.0);\n  float h0 = treehf(p, vc, vh);\n  return normalize(vec3(\n    treehf(p - eps.xy) - h0\n  , eps.x\n  , treehf(p - eps.yx) - h0\n  ));\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  // The main renderer of mountains, beaches, trees and such\n  \n  // There is lot of fine tuning here from lots of experiments\n  \n  vec3 sky = render0(ro, rd);\n\n  // The distance to the water\n  float watert   = -(ro.y-waterLevel)/rd.y;\n  // The distance to the terrain\n  float terraint = rayMarch(ro, rd, 0.01, tolerance);\n  // The distance to the cloud layer\n  float cloudt   = -(ro.y-cloudLevel)/rd.y;\n\n  vec3 col = vec3(0.0);\n\n  vec3 cp = ro+rd*cloudt;\n  // Sample the height at the cloud intersection, this will be used later to modify\n  // the cloud transparency\n  float ch = lohf(cp.xz);\n  \n  // Compute the fade out factor\n  const float near_dist = 10.0;\n  float ft = max(terraint-near_dist, 0.0)/(max_dist-near_dist);\n  const float fof = log(20.0);\n  float fm = exp(-ft*fof);\n\n  vec3 gp   = ro+rd*terraint;\n  vec3 hin  = hinormal(gp.xz, norm_off);\n  vec3 lon  = lonormal(gp.xz, norm_off);\n  // Compute diffuse light for various aspects  \n  float gdif = max(dot(hin, sunDir), 0.0);\n  float bdif = max(dot(hin, skyDir), 0.0);\n  float sdif = max(dot(lon, sunDir), 0.0);\n  float sbdif = max(dot(lon, skyDir), 0.0);\n  \n  // Raymarch toward the sun to detect if the point is in shadow\n  float gst = rayMarch(gp, sunDir, 0.05, 0.05); \n  // Makes the shadow softer depending if the intersection\n  // to the terrain was close or far away\n  float sf = mix(0.1, 0.5, tanh_approx(0.1*(gst)));\n  float sdifu = sdif;\n  if (gst < max_dist) {\n    gdif *= sf;\n    sdif *= sf;\n  }\n\n  vec3 pp = ro+watert*rd;\n  \n  if (watert > 0.0 && watert < terraint) {\n    // Water effect\n    // Fake water wave effect\n    // Waves are also not moving but that is not visible because camera is moving\n    vec3 pn = normalize(vec3(0.005*sin(67.0*pp.x), 1.0, 0.0));\n    vec3 pr = reflect(rd, pn);\n    // Compute fresnel effect, which is that the more steep we hit the water\n    // surface the more it reflects\n    // Inspired by real life but not using \"proper\" math\n    float pfre = 1.0+dot(rd, pn);\n    pfre *= pfre;\n    // Do we hit the sky without intercepting the terrain?\n    float pgt = rayMarch(pp, pr, 0.05, 0.05); \n\n    // We sample the height of the terrain at this point to later determine if we should render a boat\n    float sh = lohf(pp.xz);\n\n    if (pgt < max_dist) {\n      // We hit something but we smooth the amount we absorb the reflection\n      // by the distance. It's not realistic but it looks somewhat better to me.\n      pfre *= 0.125*smoothstep(2., 4., pgt);\n    }\n    \n    float fdif = max(dot(pn, sunDir), 0.0);\n    // The reflected sky adjusted for the fresnel effect\n    col = render0(pp, pr)*pfre;\n    col += fdif*skyCol*sf;  // The diffuse color\n\n    // The water absorbation factor which fades out the sand color    \n    vec3 wfo = exp(-8.0*vec3(2.0, 1.5, 2.0)*(terraint-watert));\n\n    // Compute repeating boat coordinates\n    float sz = pp.z;\n    sz *= 0.5;\n    float sn = floor(sz);\n    sz = fract(sz);\n    float sf = smoothstep(0.5, 0.0, sz);\n    // Adjust the distance to the boat path depending on the cam path\n    // to make them follow the path\n    float sd = abs(0.4*sin(1234.5*sn)+pp.x+cam_path(pp.z).x);\n\n    // The depth factor ensures we don't see both when water too shallow\n    // Fine tuned value\n    float df = smoothstep(0.2, 0.18, sh);\n\n    // Center boat foam\n    col += sf*5E-7*df/max(sd*sd, 1E-6);\n    // Spreading boat foam\n    col += sf*mix(1E-4, 1E-7, sf)*df/max(sd*sd, mix(5E-4, 1E-6, sf));\n\n    // Undersea sand col adjusted for sun\n    col += wfo*sandCol*sdif;\n    // Undersea sand adjusted for sky\n    col += wfo*sandCol*sbdif;\n\n  } else if (terraint < max_dist) {\n    // Reflect both hi and lo rest normal\n    vec3 hir = reflect(rd, hin);\n    vec3 lor = reflect(rd, lon);\n    \n    // Compute fresnel effect, which is that the more steep we hit the ground\n    // surface the more it reflects\n    // Inspired by real life but not using \"proper\" math\n    // Ground is not very reflective so we multiple gfre by itself a few times\n    // fine-tuned\n    float gfre = 1.0+dot(rd, hin);\n    gfre *= gfre;\n    gfre *= gfre;\n    gfre *= gfre;\n\n    // Snow fresnel effect, snow is more reflective\n    float sfre = 1.0+dot(rd, lon);\n    sfre *= sfre;\n\n    // Specular light for ground and snow\n    //  Pow by 40 spreads light more than 100\n    float gspe = pow(max(dot(sunDir, hir), 0.0), 100.0);\n    float sspe = pow(max(dot(sunDir, lor), 0.0), 40.0);\n\n    if (gp.y > mix(0.25, 0.55, 0.5+0.5*sin(gp.z+1.23*gp.x))+0.6/max(sqrt(hin.y), 0.1)) {\n      // Snow\n      // The complicated if expression allow lets snow layer wave up and down and adjust\n      // the snow height for the normal. More steep terain means less snow\n      \n      // Diffuse light\n      col += sdif;\n      // Add the sky col\n      col += 1.75*sqrt(skyCol);\n      // And the specular light\n      col += sfre*sspe*10.0*sqrt(sunCol);\n      // Then some hack to make snow seem more bluish and interesting\n      col += -0.25*abs(lon.x*lon.y);\n    } else if (gp.y < beachLevel) {\n      // The beach adjusted for sun and sky diffuse light\n      col += 2.0*sandCol*sdif;\n      col += 2.0*sandCol*sbdif;\n    } else {\n      // Finally the mountain color\n      // What follows is a hack to hilight colors to the mountain colors \n      // to make it more interesting\n      vec3 hp = gp;\n      // Compute cell id\n      vec3 hn = floor(hp);\n      // Compute a random number per cell\n      float hh = hash1(hn.xz);\n      // Create cell coordinate\n      hp = fract(hp);\n      hp *= pi;\n      // Create cell height \n      float gh = sin(hp.x)*sin(hp.y)*sin(hp.z);\n      gh *= gh;\n      // Use cell random number to modify it's amplitude\n      hh *= hh;\n      hh *= hh;\n      float lh = 0.5+0.5*sin(3.0*gp.x)*sin(7.0*gp.y)*cos(11.0*gp.z);\n      // Let ground color change slowly depending the position\n      vec3 gcol = mix(groundCol0, groundCol1, lh);\n      // Add random hilights      \n      gcol = mix(gcol, groundCol2, tanh_approx(40.0*hh*gh*sf));\n      // Compute mineral lines\n      // All off this is fine tuned and experimented until good enough to click publish\n      float gb0 = gp.y+0.3*gp.x+0.2*gp.z;\n      gb0 *= 10.0;\n      // Sine ways combined gives a pretty decent pseudo random distribution\n      float gb1 = 0.5+0.5*sin(11.1*gb0)*sin(23.3*gb0)*sin(43.5*gb0);\n      gb1 *= gb1;\n      // Finally adjust lightness depending on the mineral line factor\n      gcol *= 1.+gb1;\n      \n      // Diffuse color\n      col += gdif*gcol;\n      // and diffuse color from sky\n      col += 0.2*bdif*gcol;\n      // And some speculare light\n      col += gfre*gspe;\n    }\n\n    // Compute tree line, the flatter the surface the height the tree line\n    float tline = mix(beachLevel, treeLevel, lon.y*lon.y*lon.y); \n\n    if (gp.y < tline && gp.y > waterLevel) {\n      float vc;\n      float vh;\n      // Compute the tree normal which is based on voronoi pattern\n      vec3 vn = treenormal(gp.xz, 3.0*norm_off, vc, vh);\n      // Use the cell factor to determine tree col\n      // Most cells are green but some are yellowish\n      // TBH I don't think I succeed here but in the \"morning light\" it looks good enough for now\n      vec3 treeCol = mix(treeCol0, treeCol1, step(vc, 0.125))*mix(0.125, 1.0, vh);\n      // Diffuse coloring\n      vec3 tcol = max(dot(sunDir, vn), 0.0)*treeCol*sf;\n      tcol += 0.5*max(dot(skyDir, vn), 0.0)*treeCol*skyCol;\n      // Fade out the tree line both to the beach line and tree line\n      col = mix(col, tcol, smoothstep(tline, tline-0.05, gp.y)*smoothstep(beachLevel-0.0033, beachLevel, gp.y));\n    }\n    \n  } else {\n    col = sky;\n  }\n  \n  if(cloudt > 0.0 && cloudt < terraint) {\n    // applies fake fog. Uses the terrain height at the point of interception off the\n    // cloud layer to determine how much fog. Fine tuned and tinkered with\n    col = mix(mistCol, col, exp(-2.0*max(ch-minh*0.3, 0.0)*(terraint-cloudt)));\n  }\n\n  col = mix(sky, col, fm);\n\ncol *= smoothstep(0.5, 10., TIME-10.0*(1.0-dot(sunDir, rd)));\n  \n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const mat2 rot = ROT(radians(-20.0));\n\n  float t = TIME*0.5;\n  // The eye position\n  vec3 ro   = cam_path(t);\n  // This will be the direction we look\n  vec3 dro  = dcam_path(t);\n  // And this will adjust the camera tilt, fine-tuned again\n  vec3 ddro = ddcam_path(t);\n  // Look down \n  dro.zy *= rot;\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+2.0*ddro, ww));\n  vec3 vv = (cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = render1(ro, rd);\n  col -= 5E-3*vec3(1.0, 2.0, 1.0)*(dot(p, p)+0.25);\n  // To saturate the image a bit\n  col = aces_approx(col);\n  // So aces_approx remove glare. But I do want some glare in the\n  // sun so multiple by 1.33. Fine tuned again!\n  col *= 1.33;\n  // Fake sRGB conversion\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0+2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 325, 374, 473, 2516], [2518, 2518, 2573, 2573, 2879]], "test": "untested"}
{"id": "mldBRr", "name": "Tetrahedron from x-coordinates", "author": "mla", "description": "Any four numbers are the x-coordinates of a regular tetrahedron:\nAkiva Weinberger on Twitter: [url]https://x.com/akivaw/status/1727824794266251606?s=20[/url]\n\nMouse sets two of the x-coordinates (shader assumes the numbers add to zero).\n", "tags": ["projection", "tetrahedron"], "likes": 21, "viewed": 275, "published": 3, "date": "1700904078", "time_retrieved": "2024-07-30T17:20:42.339761", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tetrahedron from x-coordinates, mla, 2023\n//\n// Any four numbers are the x-coordinates of a regular tetrahedron:\n// Akiva Weinberger on Twitter: https://x.com/akivaw/status/1727824794266251606?s=20\n//\n// Or, any four numbers are the x-coordinates of the orthogonal projection, possibly\n// combined with scaling, of a regular tetrahedron.\n//\n// This shader makes the simplifying assumption that the four numbers (x,y,z,w) add to\n// zero - adding in an extra translation is an exercise left for reader.\n//\n// Mouse sets two of the coordinates.\n\n// In 4-space, the standard tetrahedron has vertices (1,0,0,0), (0,1,0,0), (0,0,1,0)\n// and (0,0,0,1), living in the affine subspace x+y+z+w = 1. Given two\n// orthogonal vectors q,r in the parallel subspace through origin we can project\n// any point s in the affine subspace to the 2-d point (s·q,s·r), so eg. the\n// projection of (1,0,0,0) has x-coordinate q.x, so using axis vector q = (x,y,z,w) \n// (the desired x-coordinates) gives the desired projection (with scaling, since\n// |q| may not be 1), just needing a y-vector r for the full projection,\n// which must be orthogonal to q and of the same length.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float lwidth0 = 0.002, lwidth1 = 0.01;\n  float scale = 2.0;\n  vec2 z = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float px = fwidth(z.x);\n\n  vec4 T = vec4(0.1,-1,0.5,0); // The required x-coords. Also the x-vector for projection.\n  if (iMouse.x > 0.0) T.xy = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  T.w -= dot(T,vec4(1));\n\n  // We need an orthonormal basis for subspace, this will do nicely:\n  mat3x4 XYZ = 0.5*mat3x4( 1,-1, 1, -1,\n                          -1, 1, 1, -1,\n                           1, 1,-1, -1);\n  // And now an orthogonal basis with transformed T as x-vector\n  vec3 P = T*XYZ;  // Convert to XYZ coords\n  vec3 Q = normalize(cross(P,vec3(1,0,0))); // Let's hope q3 != (1,0,0)\n  vec3 R = normalize(cross(P,Q));\n  mat2x3 QR = mat2x3(Q,R);\n  vec2 rot = expi(iTime);\n  vec3 Q1 = QR*rot; // Rotate\n  vec3 R1 = QR*mat2(0,1,-1,0)*rot;\n  mat3 PQR = mat3(P,length(P)*Q1,length(P)*R1); // Basis vectors should be equal length\n  // Transform basis PQR back to R4.\n  // Transpose is coordinates of the desired tetrahedron.\n  mat4x3 ABCD = transpose(XYZ*PQR); // Row 0 is just T, so could simplify\n  // #define xy xz // For the other view\n  vec2 A = ABCD[0].xy, B = ABCD[1].xy, C = ABCD[2].xy, D = ABCD[3].xy;\n  \n  vec3 col = vec3(0);\n\n  float d = 1e8;\n  // The lines for the x-coordinates\n  d = min(d,abs(z.x-T.x));\n  d = min(d,abs(z.x-T.y));\n  d = min(d,abs(z.x-T.z));\n  d = min(d,abs(z.x-T.w));\n  col = mix(vec3(1),col,0.8+0.2*smoothstep(0.0,px,d-lwidth0));\n\n  // The tetrahedron\n  d = 1e8;\n  d = min(d,segment(z,A,B));\n  d = min(d,segment(z,A,C));\n  d = min(d,segment(z,A,D));\n  d = min(d,segment(z,B,C));\n  d = min(d,segment(z,B,D));\n  d = min(d,segment(z,C,D));\n  col = mix(vec3(1,0.75,0),col,smoothstep(0.0,px,d-lwidth1));\n\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec2 expi(float t) {\n  return vec2(cos(t),sin(t));\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1327, 1327, 1384, 1384, 3238]], "test": "untested"}
{"id": "cltfRn", "name": "naga panic:index out of bounds", "author": "jakel101", "description": "investigating a naga panic during validation. In combination with macros, constants and maybe Swizzles and end up with an index out of bounds error", "tags": ["test", "error"], "likes": 0, "viewed": 117, "published": 3, "date": "1700872767", "time_retrieved": "2024-07-30T17:20:43.094742", "image_code": "#define MIX2(c) mix(c, c, 0.5)\n\nconst vec2 blank = MIX2(vec2(0.0,1.0));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 col = MIX2(uv);\n    \n    fragColor = vec4(col,0.5,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 241]], "test": "untested"}
{"id": "mtGyDt", "name": "Feedback wanted: sprite UVs", "author": "jeremyabel", "description": "Can this be done without a branch? My gut says no but maybe? The only qualification I have is that the area outside the sprite bounds is some value outside [0..1]", "tags": ["raining", "jeanclaude", "imagesprites"], "likes": 1, "viewed": 141, "published": 3, "date": "1700856587", "time_retrieved": "2024-07-30T17:20:43.854710", "image_code": "// Fork of \"Its Raining Jean Cloude!\" by oneshade. https://shadertoy.com/view/3tVyW1\n// 2023-11-24 00:02:40\n\nvoid ImageSprite(inout vec2 uv, in vec2 p, in vec2 pos, in vec2 size) \n{\n    p = (p - pos) / size + 0.5;\n    vec2 corner = abs(p - 0.5) - 0.5;\n    float bbox = max(corner.x, corner.y);\n    if (bbox < 0.) {\n        uv = p;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 modUV = vec2(0.);\n    \n    ImageSprite(modUV, uv, vec2( 0.0,  0.3), vec2(0.3));\n    ImageSprite(modUV, uv, vec2( 0.4,  0.0), vec2(0.3));\n    ImageSprite(modUV, uv, vec2(-0.4,  0.0), vec2(0.3));\n    ImageSprite(modUV, uv, vec2( 0.0, -0.3), vec2(0.3));\n\n    fragColor = vec4(vec3(modUV, 0.), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 181, 181, 338], [340, 340, 396, 396, 769]], "test": "untested"}
{"id": "mt3fRn", "name": "Fortnite big bang fractal", "author": "_90_", "description": "fortnite mmm", "tags": ["raymarching", "fractal", "fortnite"], "likes": 2, "viewed": 107, "published": 3, "date": "1700855349", "time_retrieved": "2024-07-30T17:20:44.610689", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 1.5\n#define SURF_DIST .00025\n#define PI 3.141592\n#define T iTime/2.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 pos) {\n    float power = 11.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 5 ; i++) {\n\t\tr = length(z);\n\t\tif (r>10.0) break;\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power - T*2.0;\n\t\tphi = phi*power;\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    int ix=0;\n    for(int i=0;i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) {\n            ix = i;\n            break;\n        }\n    }\n    return vec2(dO,ix);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 1.5, 0.0);\n    ro.yz *= Rot((PI/2.0)-(sin(T)/5.0));\n    ro.xz *= Rot((cos(T)/5.0));\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,1.0), 1.0);\n    vec3 col = vec3(-0.5);\n    vec2 rm = RayMarch(ro, rd);\n    if(rm.x<MAX_DIST) {\n        vec3 p = ro + rd * rm.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(0.0,0.03,0.2);\n    }\n    col += vec3((rm.y/pow(float(MAX_STEPS),0.55))-0.2) * vec3(0.87,0.95,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3fRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 127, 127, 189], [191, 191, 216, 216, 646], [648, 648, 681, 681, 948], [950, 950, 974, 974, 1123], [1125, 1125, 1175, 1175, 1360], [1362, 1362, 1419, 1419, 2027]], "test": "untested"}
{"id": "dtKcDd", "name": "My Bilinear Interpolation", "author": "Timmyswdswd", "description": "Bilinear interpolation", "tags": ["filter"], "likes": 0, "viewed": 184, "published": 3, "date": "1700832320", "time_retrieved": "2024-07-30T17:20:45.361681", "image_code": "//Made as in https://upload.wikimedia.org/wikipedia/commons/c/c6/Bilininterp.png\n\nfloat Lerp(float x, float q1, float q2)\n{\n    float q = q1 + x*(q2-q1);\n    return q;\n}\n\nvec3 Rainbow(float h)\n{\n    const float PI = 3.14159265359;\n    h = clamp(h, 0.0, 1.0);\n    h *= 2.0/3.0;\n    \n    float r = (sin((h+1.0/3.0)*2.0*PI + PI/2.0)+1.0)/2.0;\n    float g = (sin((h+2.0/3.0)*2.0*PI + PI/2.0)+1.0)/2.0;\n    float b = (sin(h*2.0*PI + PI/2.0)+1.0)/2.0;\n    \n    vec3 col = vec3(r, g, b);\n    col = round(col*20.0)/20.0;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n     \n    float q1 = 0.0;\n    float q2 = 1.2;\n    float q3 = 1.2;\n    float q4 = 0.5;\n    \n    float heigh1 = Lerp(uv.x, q1, q2);\n    float heigh2 = Lerp(uv.x, q3, q4);\n    float heigh = Lerp(uv.y, heigh1, heigh2);\n    \n    col = Rainbow(heigh);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 123, 123, 169], [171, 171, 194, 194, 535], [537, 537, 594, 644, 1028]], "test": "untested"}
{"id": "dlVyDd", "name": "RuleMaPool Demo", "author": "benkuper", "description": "Shader from Introduction to Shader Art, used as demo for RuleMaPool mapping software", "tags": ["fractal", "mouse", "interactive", "demo", "bloom", "glow", "art"], "likes": 2, "viewed": 243, "published": 3, "date": "1700832036", "time_retrieved": "2024-07-30T17:20:46.110678", "image_code": "/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \nfloat time = iMouse.z > 0. ? (iMouse.x/iResolution.x) * (iMouse.y*20./iResolution.y):iTime;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + time*.4);\n\n        d = sin(d*8. + time)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 394, 419, 419, 603], [605, 645, 702, 702, 1283]], "test": "untested"}
{"id": "dtVyDd", "name": "tetragonal hexahedron slides", "author": "cyperus", "description": "truchet3d toroidal  tetragonal tiled spherical hexahedron slides", "tags": ["3d", "grid", "sdf", "tiling", "hexahedron", "schwarzchristoffel"], "likes": 3, "viewed": 197, "published": 3, "date": "1700831512", "time_retrieved": "2024-07-30T17:20:47.150897", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"tetragonal hexahedron slides\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n////////////////////////////////////////////////////////////////////////////////\n// ray casting bounding shape\nconst float CAM_DIST = 5.; \nconst float CAM_FLE  = 2.;\nconst float BB_DIST  = 5.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 310;\nconst float RAY_STEP_FACTOR = 0.06676;\nconst float RAY_PRECISION = 1.;\n\n// data from sdf\nvec3 mat_to = vec3(0);\nvec4 mat_tc = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0;\n    vec2 z = vec2(0.);\n\n    /// platonic sphere\n    float ps_id = 0., sr = 0.;\n    // normalize spherical radius\n    vec3 pn = normalize(p);\n\n    // projection from n cells to 1 cell.\n    pn = hexa_cells(pn, ps_id, sr);\n\n    // inverse stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cHexaPolyArc2disk(z);\n\n    // r-polygon-distribution\n    float e_y = 0.4 + 0.1 *cos(4.*atan(z.y, z.x));\n    float en = 1.-e_y *smoothstep(1.,5., abs(12.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(length(z), en) * z/r;     \n\n    // stereograpic projection\n    float zz = dot(z,z); pn = vec3(2.*z.x, 2.*z.y, -1.+ zz); pn /= 1.+zz;\n\n    // unnormalize spherical radius\n    p = length(p) * pn;\n\n    /// regular polygon tiles\n    vec3 rpt_id = vec3(1.);  float rpt_sr;\n\n    z = recgrid2rec(p.xy, rpt_id.xy, rpt_sr);\n    \n    // Schwarz-Christoffle\n    z = inversesc(z,4);\n    p.xy = z;\n\n    /// (torus,sphere,2spheres)  \n    rxy = length(p.xy); au = atan(p.y, p.x);\n    z = ccos(PI*vec2(rxy,p.z))/0.5; z.x -= -1.28;   \n        \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    vec2 to_uv = p.yz; float to_d = log(length(z)+0.8);   \n\n    // truchet grid\n    float TC3D_nu = 16.;\n    float TC3D_nv = 8.;\n    float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.);\n    ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // random\n    float rnd = hash21(tc_id.xz);  \n\n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n\n    // sdf\n    float d;\n    if(fract(rnd*77.57+iTime/10.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,0.0625) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, 0.0625 ), sdCylinder( q.xzy,0.0625 ), 0.05 );\n    }\n\n    /// return\n    mat_to = vec3(to_uv,to_d); // torus: surface uv, distance function\n    mat_tc = vec4(q,rnd);      // truchet: local cell coords, random cell id\n    return min(d,to_d);\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/12.);\n    p.zx = crot(p.zx,-2.*PI*2.*time/12.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float r, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf); float a = smoothstep(px+0.1,-px-0.1,sdf+0.2);    \n    vec4 C = r<0.5 ? vec4( h2rgb(sdf -2./6.),a ) : vec4(0.);\n    return C;\n}\n\nvec4 truchet3D(in vec3 p, in float rnd ,in float time) {\n    float sdf = sdBox( p, vec3(0.5*0.9));\n    float px = fwidth(sdf); float a = smoothstep(px,-px,sdf);\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n//\nvoid mainImage(out vec4 O, in vec2 fragCoord) {   \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime/60.);\n             rd = normalize(transform(rd,iTime/60.));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = rd*.2+.8;\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n                \n            // draw texture\n            O = vec4(0);\n\n            if(O.a<1.) {             \n                C = ribbon( 12.* mat_to.x, mat_to.z, 6.*iTime/60.); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2);\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            if(O.a<1.) {            \n                C = truchet3D(mat_tc.xyz, mat_tc.w, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime/60.); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            //O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-8.E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float \n    PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){ \n    const float PI_4 = PI/4.;\n    const float SQRT2 = sqrt(2.);\n    const float SQRT_2 = 1./SQRT2;\n    Z = crot(Z,PI_4);\n    Z/= SQRT_2;\n    Z_id = 2.*floor(Z*.5+0.5);\n    vec2 Z_lo = Z-Z_id;\n    Z = Z_lo;\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));   \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));\n    Z.x *= Z_id.x;\n    Z.y *= Z_id.y;\n    Z *= SQRT_2;\n    return crot(Z,-PI_4);\n}\n\n// platonics polynomial barycentric approximation\nvec2 cHexaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2( 0.7072, -0.7070)\n    ,vec2(-0.7070,  0.7072)\n    ,vec2(-0.0377, -0.9993)\n    ,vec2( 0.7072,  0.7070)\n    ,vec2(-0.7072, -0.7070)\n    ,vec2(-0.0377,  0.9993)\n    ,vec2( 0.5452, -0.8383)\n    ,vec2( 0.9936,  0.1126)\n    ,vec2(-0.9936,  0.1126)\n    ,vec2(-0.7983, -0.6022)\n    ,vec2(-0.7563,  0.6542)\n    ,vec2( 0.6542,  0.7563)\n    ,vec2( 0.7563, -0.6542)\n    ,vec2(-0.6235,  0.7818)\n    ,vec2(-0.7167, -0.6974)\n    ,vec2(-0.6542, -0.7563)\n    ,vec2( 0.7342,  0.6790)\n    ,vec2( 0.7025, -0.7117));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2( 0.0135,  0.0   )\n    ,vec2( 0.0008,  0.0001)\n    ,vec2(-0.5762,  0.1282)\n    ,vec2( 0.0013,  0.0002)\n    ,vec2(-0.0135, -0.0085)\n    ,vec2( 0.1239, -0.0601)\n    ,vec2(-0.2162, -0.3769)\n    ,vec2( 0.1197, -0.1327)\n    ,vec2( 0.2544,  0.0708)\n    ,vec2( 0.3228,  0.3050)\n    ,vec2( 0.0377, -0.0056)\n    ,vec2( 0.0362, -0.0135)\n    ,vec2( 0.1439, -0.0871)\n    ,vec2( 0.0551,  0.0066)\n    ,vec2(-0.0935,  0.1492)\n    ,vec2(-0.2397,  0.1216)\n    ,vec2( 0.0218, -0.0211)\n    ,vec2( 0.0077, -0.0763));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2( 0.366242, -0.365216)\n    ,vec2(-0.365216,  0.366242)\n    ,vec2(-0.012767, -0.414156)\n    ,vec2( 0.366242,  0.365216)\n    ,vec2(-0.366242, -0.365216)\n    ,vec2(-0.012767,  0.414156)\n    ,vec2( 0.216186, -0.397592)\n    ,vec2( 0.413695,  0.038296)\n    ,vec2(-0.413695,  0.038296)\n    ,vec2(-0.391705, -0.251311)\n    ,vec2(-0.383838,  0.291533)\n    ,vec2( 0.291533,  0.383838)\n    ,vec2( 0.383838, -0.291533)\n    ,vec2(-0.266502,  0.388876)\n    ,vec2(-0.372411, -0.341303)\n    ,vec2(-0.291533, -0.383838)\n    ,vec2( 0.378349,  0.316470)\n    ,vec2( 0.350877, -0.369995));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++) {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zn += cmul(rf[j], zj); // sum nominator\n        zd += zj;              // sum denominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec3 hexa_cells(in vec3 p, out float cell_id, out float sr){\n\t//// hexagon\n    // cells +X, -X, +Y, -Y,+Z, -Z\n    // cell walls defined by the face_normals\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    // map (+X, -X, +Y, -Y,+Z, -Z)-cells to (-Z)-cell by rotation\n    // rotation angles\n    const float a90 = PI/2.; // a = 90°       \n    const vec2 ei_a0   = vec2(1., 0.);             // a = 0° \n    const vec2 ei_a90  = vec2(cos(a90), sin(a90)); // a = 90°\n    \n    vec2 ei_y; vec2 ei_x;\n\t//inside cell +X: +X --> -Z\n\tif(nBA && nDA && !nCB && nDC) {\n\t\tcell_id = 0.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -X: -X --> -Z\n\telse if(!nBA && !nDA && nCB && !nDC) {\n\t\tcell_id = 1.;\n\t\tei_y = -ei_a90;\n\t\tei_x = ei_a0;\n\t}\n    //inside cell +Y: +Y --> -Z\n\telse if(nCA && nDA && nCB && nDB) {\n\t\tcell_id = 2.;\n\t\tei_y = -ei_a90;\n\t\tei_x = -ei_a90;\n\t}\n\t//inside cell -Y: -Y --> -Z\n\telse if(!nCA && !nDA && !nCB && !nDB ) {\n\t\tcell_id = 3.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a90;\n\t}\n\t//inside cell +Z: +Z --> -Z\n\telse if(!nBA && !nCA && nDB && nDC) {\n\t\tcell_id = 4.;\n\t\tei_y = -ei_a0; // 180°\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -Z: -Z --> -Z\n\telse if(nBA && nCA && !nDB && !nDC) {\n\t\tcell_id = 5.;\n\t\tei_y = ei_a0;\n\t\tei_x = ei_a0;\n\t}        \n\t// cell orientation\n\tp.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tp.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\t// non cyclic\n\tsr = 4.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = z/r;\n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    //    float e2 = e.x + d0 * 2. * smoothstep(-1., 1., -sh_a);\n    return dist(r, e2) * z;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s);\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVyDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1243, 1243, 1265, 1265, 3564], [3566, 3579, 3633, 3633, 4219], [4221, 4221, 4266, 4266, 4428], [4430, 4430, 4472, 4472, 4721], [4723, 4735, 4790, 4790, 5016], [5018, 5018, 5074, 5074, 5256], [5258, 5261, 5308, 5350, 7968]], "test": "untested"}
{"id": "ctVyDt", "name": "Book of Light(life)", "author": "ElSolem", "description": "folding horizons :: looks better in 3D :: https://cineshader.com/view/ctVyDt :: after most recent change you really can't see on here, but this is the basic effect I wanted. Follow the cineshader link for full effect :: Sidis' Checkerboard", "tags": ["magic", "horizon", "simplicity"], "likes": 1, "viewed": 880, "published": 3, "date": "1700805005", "time_retrieved": "2024-07-30T17:20:47.902887", "image_code": "bool Alakazan(float value1, float value2)\n{\n    return (value1 == value2) || (value1 != value2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float cosX = cos(uv.x + iTime);\n    float sinY = sin(uv.y + iTime);\n    float tan1_1 = tan(1.1 * cosX / sinY);\n    float tan9_9 = tan(9.9 * cosX * sinY);\n    float tan0_0 = tan(0.0 * cosX + sinY);\n\n    bool caseCraz = (tan1_1 <= tan9_9 || (tan1_1 * tan9_9 <= tan0_0));\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(cosX, sinY);\n\n    // change equality to change look\n    if (caseCraz && alakazanResult)\n    {\n        // Output to screen\n        fragColor = vec4(cosX, sinY, tan1_1, 1.); // Adjusted layout\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 98], [100, 100, 155, 205, 778]], "test": "untested"}
{"id": "DlycDd", "name": "cute pattern", "author": "shibe", "description": ",,", "tags": ["blackandwhite"], "likes": 3, "viewed": 98, "published": 3, "date": "1700801293", "time_retrieved": "2024-07-30T17:20:48.666844", "image_code": "float pee(vec2 uv)\n{\n    float round_amount = (sin((iTime + 2000.) / 5000.) + 1.) / 50.;\n    uv = vec2(round(uv.x / round_amount) * round_amount, round(uv.y / round_amount) * round_amount);\n    float one = sin(uv.x * 115544.);\n    float two = sin(uv.y * 115544.1);\n    return step(one, two);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(pee(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 293], [295, 295, 352, 352, 425]], "test": "untested"}
{"id": "ctKyRW", "name": "Snake Galaxy", "author": "martymarty", "description": "Creates many random snakes and animates them rotating around a circle. Neat when the number of snakes gets pushed into the 1000s. Lots of parameters in common to create different styles. ", "tags": ["2d", "random", "animated"], "likes": 3, "viewed": 226, "published": 3, "date": "1700799945", "time_retrieved": "2024-07-30T17:20:49.600348", "image_code": "//The buffers didn't work on the iPad mini I have.\n//This sets the use of the buffers.\n//The buffer really improves performance though.\n//Comment out for iOS use.\n#define BUFFER\n\nvec3 drawGalaxy(vec2 uv){\n\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n    vec2 tile = floor(uv*GRID);\n    bool needPalette = true;\n    float size, totalsnakes, area, offset, bright, glow, top, start, dir, ringamt;\n    float rndstart, rndnext, tribright, speed, snakelength, snake, relTime, bgtime;\n    totalsnakes = 1.0;\n    tribright = 1.0;\n    vec2 pt, pttop, randpt, relTile, bgRelTile, refpt, current;\n    vec3 pal, col, glowcol;\n    vec4 ptSizeRnd;\n    \n    current = vec2(0.1*(ELLIPSESPEED)+0.025,0.125);\n   \n    top = floor(iTime*SQUARESPEED)+NUMSQUARES;\n\n    start = top < NUMSQUARES ? 0.0 : top-NUMSQUARES;\n    \n    current *= (iTime*ROTATESPEED+0.5*ROTATEPULSE*sin(iTime*ROTATESPEED*PI/8.0));\n    \n    for(float i = top-1.0; i >= start ;i--){\n        \n        ptSizeRnd = squareGenerator(i);\n        rndnext = ptSizeRnd.z;\n        pt = ptSizeRnd.xy;\n      \n        pt = RING*pt+RADIUS*vec2(cos(rndnext*TAU*30.75-current.x),sin(rndnext*TAU*30.75-current.y));\n        rndnext = inSquareRandom(rndnext);\n\n        pt += vec2(0.5)*ar;\n\n\n        size = floor(ptSizeRnd.w);\n        \n        pt = floor(pt*GRID);\n        pt -= 0.5*size;\n        \n        pttop += size;\n        relTile = floor(tile-pt);\n      \n        needPalette = true;\n        if(all(greaterThanEqual(relTile, vec2(0.0))) && all(lessThanEqual(relTile,vec2(size)))){ \n            pal = palette(rndnext*COLORVARIETY+iTime*COLORSPEED, pala,palb,palc,pald); \n            rndnext = inSquareRandom(rndnext);\n            tribright = triangle((i-start)/NUMSQUARES);\n            needPalette = false;\n            dir = sign(rndnext*RNDDIR-0.5); rndnext = inSquareRandom(rndnext);\n            speed = mix(SNAKESLOWSPEED,SNAKEFASTSPEED,rndnext)*GRID+0.0;rndnext = inSquareRandom(rndnext);\n            area = size*size-1.0;\n\n            offset = floor(rndnext*area)*OFFSET;rndnext = inSquareRandom(rndnext);\n            snakelength = floor(mix(SNAKEMIN,SNAKEMAX,rndnext)); rndnext = inSquareRandom(rndnext);\n            snake = superLogicSnake(relTile,size);\n            snake = mod(snake*MULTISNAKE,area+1.0);\n            relTime = mod(iTime*speed*dir+offset, area);\n\n            bright = smoothstep(snake-snakelength*MULTISNAKE,snake, relTime)-step(snake,relTime);\n\n            if(bright > TAIL){\n                totalsnakes++;\n                col = OPAQUE ? bright*pal*tribright : col+bright*pal*tribright;\n            }\n\n        }\n        if(all(greaterThanEqual(relTile,-BGSIZE*vec2(size))) && all(lessThanEqual(relTile, (1.0+BGSIZE)*vec2(size)))){\n            if(needPalette){\n                pal = palette(rndnext*COLORVARIETY+iTime*COLORSPEED, pala,palb,palc,pald);\n                rndnext = inSquareRandom(rndnext);\n                tribright = triangle((i-start)/NUMSQUARES);\n            }\n\n            bgRelTile = floor(tile-(pt-BGSIZE*size));\n            size = floor((1.0+2.0*BGSIZE)*size);\n            ringamt = superLogicSnake(bgRelTile,size)/(size*size+1.0);\n            glow = ringamt*tribright*GRID/sqrt(NUMSQUARES);\n            glowcol += glow*pal;\n        }\n    }\n\n    bgtime = (triangle(iTime*BGCYCLESPEED))*BGCYCLE+1.0;\n    col /= OPAQUE ? 1.0 : totalsnakes;\n    glowcol = -glowcol*bgtime;\n    col = mix(col,1.0-exp2(glowcol)*(1.01+1.0*BGSIZE),BGAMT);\n    //col = texelFetch(iChannel0,ivec2(mod(i,GRID),mod(floor(i/GRID),GRID)),0).z;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n\n    vec3 col = vec3(0.0);\n    #ifdef BUFFER\n    col = texelFetch(iChannel0,ivec2(uv*GRID),0).rgb;\n    #else\n    col = drawGalaxy(uv);\n    #endif\n    col *= BRIGHTSCALE;\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Buffer used to improve performance.\n//Renders the image with exact number of pixels for the grid.\n//The main image then expands this..\n//On the M1 MacBook Air, without the buffer I could only get 400 to 500 squares 60fps.\n//With the buffers, and small grid sizes around ~100 to 200, I easily get that up to 1000s.\n//The MULTISNAKE value is also there to improve perfomance. \n//It divides the spiral do get more than 1 snake per square.\n\n\nvec3 drawGalaxy(vec2 uv){\n\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n    vec2 tile = floor(uv*GRID);\n    bool needPalette = true;\n    float size, totalsnakes, area, offset, bright, glow, top, start, dir, ringamt;\n    float rndstart, rndnext, tribright, speed, snakelength, snake, relTime, bgtime;\n    totalsnakes = 1.0;\n    tribright = 1.0;\n    vec2 pt, pttop, randpt, relTile, bgRelTile, refpt, current;\n    vec3 pal, col, glowcol;\n    vec4 ptSizeRnd;\n    \n    current = vec2(0.1*(ELLIPSESPEED)+0.025,0.125);\n   \n    top = floor(iTime*SQUARESPEED)+NUMSQUARES;\n\n    start = top < NUMSQUARES ? 0.0 : top-NUMSQUARES;\n    \n    current *= (iTime*ROTATESPEED+0.5*ROTATEPULSE*sin(iTime*ROTATESPEED*PI/8.0));\n    \n    for(float i = top-1.0; i >= start ;i--){\n        //ptSizeRnd = squareGenerator(i);\n\n        ptSizeRnd = texelFetch(iChannel0,ivec2(mod(i,GRID),mod(floor(i/GRID),GRID)),0);\n        rndnext = ptSizeRnd.z;\n        pt = ptSizeRnd.xy;\n      \n        pt = RING*pt+RADIUS*vec2(cos(rndnext*TAU*30.75-current.x),sin(rndnext*TAU*30.75-current.y));\n        rndnext = inSquareRandom(rndnext);\n\n        pt += vec2(0.5)*ar;\n\n\n        size = floor(ptSizeRnd.w);\n        \n        pt = floor(pt*GRID);\n        pt -= 0.5*size;\n        \n        pttop += size;\n        relTile = floor(tile-pt);\n      \n        needPalette = true;\n        if(all(greaterThanEqual(relTile, vec2(0.0))) && all(lessThanEqual(relTile,vec2(size)))){ \n            pal = palette(rndnext*COLORVARIETY+iTime*COLORSPEED, pala,palb,palc,pald); \n            rndnext = inSquareRandom(rndnext);\n            tribright = triangle((i-start)/NUMSQUARES);\n            needPalette = false;\n            dir = sign(rndnext*RNDDIR-0.5); rndnext = inSquareRandom(rndnext);\n            speed = mix(SNAKESLOWSPEED,SNAKEFASTSPEED,rndnext)*GRID+0.0;rndnext = inSquareRandom(rndnext);\n            area = size*size-1.0;\n\n            offset = floor(rndnext*area)*OFFSET;rndnext = inSquareRandom(rndnext);\n            snakelength = floor(mix(SNAKEMIN,SNAKEMAX,rndnext)); rndnext = inSquareRandom(rndnext);\n            snake = superLogicSnake(relTile,size);\n            snake = mod(snake*MULTISNAKE,area+1.0);\n            relTime = mod(iTime*speed*dir+offset, area);\n\n            bright = smoothstep(snake-snakelength*MULTISNAKE,snake, relTime)-step(snake,relTime);\n\n            if(bright > TAIL){\n                totalsnakes++;\n                col = OPAQUE ? bright*pal*tribright : col+bright*pal*tribright;\n            }\n\n        }\n        if(all(greaterThanEqual(relTile,-BGSIZE*vec2(size))) && all(lessThanEqual(relTile, (1.0+BGSIZE)*vec2(size)))){\n            if(needPalette){\n                pal = palette(rndnext*COLORVARIETY+iTime*COLORSPEED, pala,palb,palc,pald);\n                rndnext = inSquareRandom(rndnext);\n                tribright = triangle((i-start)/NUMSQUARES);\n            }\n\n            bgRelTile = floor(tile-(pt-BGSIZE*size));\n            size = floor((1.0+2.0*BGSIZE)*size);\n            ringamt = superLogicSnake(bgRelTile,size)/(size*size+1.0);\n            ringamt *= 0.003;\n            glow = ringamt*tribright*GRID/sqrt(NUMSQUARES);\n            glowcol += glow*pal;\n        }\n    }\n\n    bgtime = (triangle(iTime*BGCYCLESPEED))*BGCYCLE+1.0;\n    col /= OPAQUE ? 1.0 : totalsnakes;\n    glowcol = -glowcol*bgtime;\n    col = mix(col,1.0-exp2(glowcol)*(1.01+1.0*BGSIZE),BGAMT);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n   \n    if(all(lessThan(fragCoord, vec2(GRID)*ar))){\n        col = drawGalaxy(floor(fragCoord)/(GRID));\n    }\n\n    fragColor = vec4(col,1.0);\n    \n}\n", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//CONSTANTS\n#define PI 3.141592653589793\n#define TAU 6.28318530718\n\n//GENERAL\n#define GRID 200.0  \n#define NUMSQUARES 1800.0\n#define MULTISNAKE 2.0\n#define BRIGHT 4.25 //Extra multiplier at the end. Some setups can be a bit dark.\n\n//RING\n#define RINGPCT 0.3    // 0.0 to 0.5\n#define RADIUSPCT  1.0 // 0.0 to 1.0\n\n//ROTATION\n#define ELLIPSESPEED 1.02 // 1.0 circle \n#define ROTATESPEED 0.8  // 0.0 to 10.0\n#define ROTATEPULSE 0.1  // 0.0 to 1.0\n\n//SQUARE \n#define SQUARESPEED 200.00 // 10 to 400.0\n#define SQUAREMINPCT 0.11  // 0.0 to 1.0\n#define SQUAREMAXPCT 0.15  // 0.0 to 1.0\n\n//SNAKE\n#define SNAKEMINPCT 0.05     // 0.05 to 0.5 \n#define SNAKEMAXPCT 0.2     // 0.05 to 0.5\n#define TAIL  0.93           // 0.9 to 0.99\n#define SNAKESLOWSPEED 0.1   // 0.01 to 0.3\n#define SNAKEFASTSPEED 0.25  // 0.01 to 0.3\n\n//FLAGS\n#define OFFSET 1.0  // Flag for random snake starting positions\n#define RNDDIR 1.0  // Flag for random directions, 0.0 clockwise 1.0 random 2.0 ccw\n#define OPAQUE true // Flag opaque snakes are much brighter. \n\n//COLOR\n#define COLORVARIETY 0.9 //0.3 is nice, 1.0 is full random\n#define COLORSPEED 0.0 // 0.01 to 0.3 \n\n//BACKGROUNG\n#define BGAMT 0.3      // 0.0 off 1.0 no snakes off improves performance\n#define BGSIZE 0.5        // 0.0 to 1.0\n#define BGCYCLESPEED 0.1  // 0.0 to 0.5  \n#define BGCYCLE 0.5      // 0.0 to 1.0\n\n\n//HELPERS\n#define RING 0.6*RINGPCT\n#define RADIUS 0.4*RADIUSPCT\n#define SNAKEMIN SNAKEMINPCT*GRID\n#define SNAKEMAX SNAKEMAXPCT*GRID\n#define SQUAREMIN SQUAREMINPCT*GRID\n#define SQUAREMAX SQUAREMAXPCT*GRID\n#define AVEAREA (2.0+BGSIZE)*(2.0+BGSIZE)*(SQUAREMIN*SQUAREMIN+SQUAREMAX*SQUAREMAX)\n#define GRIDSQR GRID*GRID\n#define BRIGHTSCALE BRIGHT*(1.0+0.5*BGAMT)*(1.0+0.5*BGAMT)\n\n//PALETTE\n#define pala vec3(0.0, 0.028, 0.0)\n#define palb vec3(1.628, .998, 0.0\t)\n#define palc vec3(0.808, 0.468, 1.0)\n#define pald vec3(-0.881, 0.673, -.231)\n\n/*\nAmeoba Colors\na = 0.518, 0.828, 0.868\nb = 0.078, 0.233, 0.151\nc = 2.329, -0.681, -0.388\nd = -1.935, -0.965, -1.055\n*/\n\n/*\nRainbow Colors\na = 0.5, 0.5, 0.5\t\nb = 0.5, 0.5, 0.5\t\nc = 1.0, 1.0, 1.0\t\nd = 0.00, 0.33, 0.67\n*/\n\n/*\nChristmas Colors\na = 0.5, 0.5, 0.0\t\nb = 1.028, 0.588, 0.0\t\nc = 0.888, 1.178, 1.0\t\nd = 0.00, 0.483, 0.0\n*/\n\n/*\nChristmas Colors 2\na = -0.601, 0.028, 0.0\t\nb = 1.728, 0.998, 0.0\t\nc = 0.958, 0.468, 1.0\t\nd = -0.061, 0.718, -.231\n*/\n//Inigo Quilez's palette formula.\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( TAU*(c*t+d) );\n}\n\n\nfloat superLogicSnake(vec2 p, float s){\n    float r = min(min(p.x,p.y),min(s-p.x-1.0,s-p.y-1.0));\n    float h = float(p.y>p.x);\n    float l = 4.0*(r+h)*(s-r-h);\n    l += sign(0.5-h)*(p.x+p.y-2.0*r);\n    return l;\n}\n\n\nfloat triangle(float x){\n    return abs(2.0*fract(x-0.5)-1.0);\n}\n\nfloat squareRandom(float x ){\n\n\n    for(float i = 0.0; i < 2.0; i++){\n        x = mod(x*76001.0+0.74411,1.00003);\n\n    }\n    return x;\n}\n\n\n\nfloat inSquareRandom(float x){\n    return mod(x*100057.0+0.64661,0.99991);\n}\n\nvec4 squareGenerator(float seed){\n    vec2 pt, randpt;\n    float rnd = squareRandom(seed);\n    float rndnext = inSquareRandom(rnd);\n    vec4 ptRndSize;\n    ptRndSize.z = rndnext;\n    randpt.x = rndnext; rndnext = inSquareRandom(rndnext);\n    randpt.y = rndnext; rndnext = inSquareRandom(rndnext);\n    pt = vec2(0.5)-randpt;\n    float size = rndnext*(SQUAREMAX-SQUAREMIN)+SQUAREMIN; rndnext = inSquareRandom(rndnext);\n        \n    ptRndSize.xy = pt;\n    ptRndSize.z = rndnext;\n    ptRndSize.w = size;\n    return ptRndSize;\n}\n", "buffer_b_code": "//Buffer to create data for the squares. \n//The squares random position relative to the circle is stored in x,y.\n//The initial seed random number is in z.\n//Add the squares size is in w.\n//Only the top square gets calculated. \n//This change got a few fps when there are lots of squares. \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n           \n    float num = floor(fragCoord.y*GRID+fragCoord.x);\n    float top = floor(iTime*SQUARESPEED)+NUMSQUARES;\n    \n    if( num - 3.0  == mod(top,3.0)  )\n        fragColor = squareGenerator(top);\n    \n    else\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n     \n    \n    if(iFrame == 0) \n        fragColor = squareGenerator(num);\n    \n    \n}\n\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 204, 204, 3519], [3522, 3522, 3579, 3579, 3884]], "test": "untested"}
{"id": "DtKcWt", "name": "Curl Noise ( Text )", "author": "0xBAMA", "description": "combining the text renderer with some older code", "tags": ["text", "font", "lut"], "likes": 2, "viewed": 228, "published": 3, "date": "1700799511", "time_retrieved": "2024-07-30T17:20:50.531858", "image_code": "const uint loremIpsum[ 500 ] = uint[]( 76u, 111u, 114u, 101u, 109u, 32u, 105u, 112u, 115u, 117u, 109u,\n 32u, 100u, 111u, 108u, 111u, 114u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u, 44u, 32u, 99u,\n 111u, 110u, 115u, 101u, 99u, 116u, 101u, 116u, 117u, 114u, 32u, 97u, 100u, 105u, 112u, 105u, 115u, 99u,\n 105u, 110u, 103u, 32u, 101u, 108u, 105u, 116u, 46u, 32u, 80u, 104u, 97u, 115u, 101u, 108u, 108u, 117u,\n 115u, 32u, 112u, 104u, 97u, 114u, 101u, 116u, 114u, 97u, 32u, 102u, 114u, 105u, 110u, 103u, 105u, 108u,\n 108u, 97u, 32u, 114u, 105u, 115u, 117u, 115u, 44u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u,\n 32u, 100u, 105u, 103u, 110u, 105u, 115u, 115u, 105u, 109u, 32u, 114u, 105u, 115u, 117u, 115u, 32u, 100u,\n 105u, 99u, 116u, 117u, 109u, 32u, 101u, 103u, 101u, 116u, 46u, 32u, 78u, 117u, 108u, 108u, 97u, 109u,\n 32u, 114u, 117u, 116u, 114u, 117u, 109u, 32u, 118u, 117u, 108u, 112u, 117u, 116u, 97u, 116u, 101u, 32u,\n 109u, 97u, 115u, 115u, 97u, 32u, 101u, 103u, 101u, 116u, 32u, 112u, 117u, 108u, 118u, 105u, 110u, 97u,\n 114u, 46u, 32u, 73u, 110u, 32u, 101u, 103u, 101u, 116u, 32u, 100u, 105u, 99u, 116u, 117u, 109u, 32u,\n 97u, 110u, 116u, 101u, 46u, 32u, 78u, 117u, 110u, 99u, 32u, 97u, 108u, 105u, 113u, 117u, 97u, 109u,\n 32u, 113u, 117u, 105u, 115u, 32u, 97u, 117u, 103u, 117u, 101u, 32u, 97u, 99u, 32u, 111u, 114u, 110u,\n 97u, 114u, 101u, 46u, 32u, 80u, 101u, 108u, 108u, 101u, 110u, 116u, 101u, 115u, 113u, 117u, 101u, 32u,\n 108u, 117u, 99u, 116u, 117u, 115u, 32u, 112u, 114u, 101u, 116u, 105u, 117u, 109u, 32u, 108u, 105u, 98u,\n 101u, 114u, 111u, 32u, 117u, 116u, 32u, 99u, 111u, 110u, 115u, 101u, 99u, 116u, 101u, 116u, 117u, 114u,\n 46u, 32u, 78u, 117u, 108u, 108u, 97u, 32u, 97u, 32u, 111u, 100u, 105u, 111u, 32u, 97u, 99u, 32u, 111u,\n 114u, 99u, 105u, 32u, 109u, 111u, 108u, 101u, 115u, 116u, 105u, 101u, 32u, 105u, 109u, 112u, 101u, \n 114u, 100u, 105u, 101u, 116u, 32u, 97u, 32u, 105u, 110u, 32u, 108u, 101u, 111u, 46u, 32u, 83u, 101u,\n 100u, 32u, 101u, 117u, 32u, 105u, 110u, 116u, 101u, 114u, 100u, 117u, 109u, 32u, 108u, 101u, 111u,\n 46u, 32u, 67u, 117u, 114u, 97u, 98u, 105u, 116u, 117u, 114u, 32u, 102u, 114u, 105u, 110u, 103u, 105u,\n 108u, 108u, 97u, 32u, 101u, 103u, 101u, 116u, 32u, 106u, 117u, 115u, 116u, 111u, 32u, 101u, 103u, 101u,\n 116u, 32u, 116u, 105u, 110u, 99u, 105u, 100u, 117u, 110u, 116u, 46u, 32u, 77u, 111u, 114u, 98u, 105u,\n 32u, 112u, 111u, 115u, 117u, 101u, 114u, 101u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u, 32u,\n 100u, 117u, 105u, 32u, 105u, 110u, 32u, 118u, 117u, 108u, 112u, 117u, 116u, 97u, 116u, 101u, 46u, 32u,\n 80u, 104u, 97u, 115u, 101u, 108u, 108u, 117u, 115u, 32u, 105u, 109u, 112u, 101u, 114u, 100u, 105u, 101u,\n 116u, 32u, 113u, 117u, 97u, 109u, 32u, 97u, 116u, 32u, 114u, 105u, 115u, 117u, 115u, 32u, 108u, 97u,\n 99u, 105u, 110u, 105u, 97u, 32u, 97u, 99u, 99u, 117u, 109u, 115u, 97u, 110u, 46u, 32u, 86u, 101u, 115u,\n 116u, 105u, 98u );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scale = 0.8f;\n    float timeScale = 0.01f;\n    fragCoord.xy = scale * fragCoord.xy;\n    ivec2 bin = ivec2( floor( fragCoord.xy / vec2( 8, 16 ) ) );\n    ivec2 offset = ( bin * ivec2( 8, 16 ) - ivec2( floor( fragCoord.xy ) ) ) % ivec2( 8, 16 );\n\n    vec3 curlNoise = curlResult( vec3( vec2( bin ) / vec2( 200.0f, 130.0f ), iTime * timeScale ) + vec3( iTime * timeScale, 0.0f, 0.0f ) );\n\n    int onGlyph = fontRef( loremIpsum[ int( sin( curlNoise.r ) * 10.0f ) ], offset );\n    vec3 col = vec3( 0.0f );\n    switch ( onGlyph ) {\n        case -1: col = vec3( 0.1618f ); break; // out of bounds\n        case  0: col = vec3( 0.0f );    break; // \"off\" pixel\n        case  1: col = curlNoise;  break; // \"on\" pixel\n    }\n\n    // Output to screen\n    fragColor = vec4( col, 1.0f );\n}", "image_inputs": [], "common_code": "// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33( vec3 p ) {\n\tuvec3 q = uvec3( ivec3( p ) ) * UI3;\n\tq = ( q.x ^ q.y ^ q.z )*UI3;\n\treturn -1.0 + 2.0 * vec3( q ) * UIF;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise( vec3 x, float freq ) {\n    // grid\n    vec3 p = floor( x );\n    vec3 w = fract( x );\n    \n    // quintic interpolant\n    vec3 u = w * w * w * ( w * ( w * 6.0 - 15.0 ) + 10.0 );\n\n    // gradients\n    vec3 ga = hash33( mod( p + vec3( 0.0, 0.0, 0.0 ), freq ) );\n    vec3 gb = hash33( mod( p + vec3( 1.0, 0.0, 0.0 ), freq ) );\n    vec3 gc = hash33( mod( p + vec3( 0.0, 1.0, 0.0 ), freq ) );\n    vec3 gd = hash33( mod( p + vec3( 1.0, 1.0, 0.0 ), freq ) );\n    vec3 ge = hash33( mod( p + vec3( 0.0, 0.0, 1.0 ), freq ) );\n    vec3 gf = hash33( mod( p + vec3( 1.0, 0.0, 1.0 ), freq ) );\n    vec3 gg = hash33( mod( p + vec3( 0.0, 1.0, 1.0 ), freq ) );\n    vec3 gh = hash33( mod( p + vec3( 1.0, 1.0, 1.0 ), freq ) );\n    \n    // projections\n    float va = dot( ga, w - vec3( 0.0, 0.0, 0.0 ) );\n    float vb = dot( gb, w - vec3( 1.0, 0.0, 0.0 ) );\n    float vc = dot( gc, w - vec3( 0.0, 1.0, 0.0 ) );\n    float vd = dot( gd, w - vec3( 1.0, 1.0, 0.0 ) );\n    float ve = dot( ge, w - vec3( 0.0, 0.0, 1.0 ) );\n    float vf = dot( gf, w - vec3( 1.0, 0.0, 1.0 ) );\n    float vg = dot( gg, w - vec3( 0.0, 1.0, 1.0 ) );\n    float vh = dot( gh, w - vec3( 1.0, 1.0, 1.0 ) );\n\t\n    // interpolation\n    return va + \n           u.x * ( vb - va ) + \n           u.y * ( vc - va ) + \n           u.z * ( ve - va ) + \n           u.x * u.y * ( va - vb - vc + vd ) + \n           u.y * u.z * ( va - vc - ve + vg ) + \n           u.z * u.x * ( va - vb - ve + vf ) + \n           u.x * u.y * u.z * ( -va + vb + vc - vd + ve - vf - vg + vh );\n}\n\nfloat perlinfbm( vec3 p, float freq, int octaves ) {\n    float G = exp2( -0.85 );\n    float amp = 1.0;\n    float noise = 0.0;\n    for ( int i = 0; i < octaves; ++i ) {\n        noise += amp * gradientNoise( p * freq, freq );\n        freq *= 2.0;\n        amp *= G;\n    }\n    return noise;\n}\n\nfloat freq = 19.0;\nconst int octaves = 2;\nfloat noise( vec3 p ) {\n    return perlinfbm( p, freq, octaves );\n}\n\nvec3 curlResult( vec3 uv ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec3 uv = vec3( vec2( ( ( fragCoord + 3. ) / 4. ) / iResolution.y ) * 1.0, iTime / 100.0 );\n    vec3 col;\n    \n    // general structure from: https://al-ro.github.io/projects/embers/\n    float n1, n2, a, b;\n    vec2 epsilon = vec2( 0.1, 0.0 );\n    n1 = noise( uv + epsilon.yxy );\n    n2 = noise( uv - epsilon.yxy );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.yyx );\n    n2 = noise( uv - epsilon.yyx );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.x = a - b;\n    \n    n1 = noise( uv + epsilon.yyx );\n    n2 = noise( uv - epsilon.yyx );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.xyy );\n    n2 = noise( uv - epsilon.xyy );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.y = b - a;\n\n    n1 = noise( uv + epsilon.xyy );\n    n2 = noise( uv - epsilon.xyy );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.yxy );\n    n2 = noise( uv - epsilon.yxy );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.z = a - b;\n\n    // Output to screen\n    return normalize( col );\n}\n\n// referencing a pixel, for an extended ASCII character in Code Page 37\n//    expected ranges of char are 0-255\n//    expected ranges of offset are within the 8x16 neighborhood\n//    inverting on either axis will let you orient as desired\nconst uint data[ 1024 ] = uint[ 1024 ]( 0u, 0u, 4278255360u, 0u, 0u, 0u, 4278255360u, 0u, 0u, 0u,\n4278255360u, 0u, 8289792u, 1579008u, 4278255390u, 1010794240u, 8519532u, 272382976u, 4278255374u,\n1714643736u, 10869758u, 943488512u, 4282172186u, 1715437336u, 8519678u, 2095578904u, 3882260786u,\n1714447323u, 8519678u, 4276617020u, 3275931000u, 1714447164u, 12436478u, 2095545916u, 3275931084u,\n1009804263u, 10086268u, 941103128u, 3882260940u, 405824316u, 8519480u, 270014464u, 4282172364u,\n2121295835u, 8519440u, 3947520u, 4278255564u, 418440984u, 8289792u, 0u, 4278255480u, 417392152u,\n0u, 0u, 4278255360u, 49152u, 0u, 0u, 4278255360u, 0u, 0u, 0u, 4278255360u, 0u, 0u, 0u, 0u, 0u, 0u,\n0u, 0u, 0u, 2147614720u, 8126464u, 0u, 0u, 3221624934u, 2143682584u, 404226048u, 0u, 3759029350u,\n3680501820u, 1008205824u, 0u, 4028530278u, 3677880446u, 2115502080u, 4350u, 4164819046u, 3681288216u,\n404232240u, 2636030u, 4278065254u, 2076573720u, 404229216u, 3228317820u, 4164819046u, 465960984u,\n404291326u, 3237903484u, 4028530278u, 460127870u, 404229216u, 3228335160u, 3759029248u, 456719932u,\n410916912u, 4264099384u, 3221624934u, 453836312u, 406585344u, 65040u, 2147614822u, 466026110u,\n404226048u, 0u, 0u, 8126464u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 402653184u,\n0u, 0u, 26112u, 402653232u, 0u, 0u, 1598976u, 2080389168u, 204472320u, 0u, 3958380u, 3321916464u,\n404226048u, 0u, 3941484u, 3267521632u, 806092800u, 2u, 3932414u, 3234215936u, 806118936u, 6u, 1572972u,\n2081191424u, 806108184u, 12u, 1572972u, 102292480u, 806158206u, 16646168u, 1572972u, 103861248u,\n806108184u, 48u, 254u, 2254490624u, 806118936u, 402653280u, 1572972u, 3334917120u, 404226048u, \n402659520u, 1572972u, 2089186816u, 204472320u, 402659456u, 0u, 402653184u, 0u, 805306368u, 0u,\n402653184u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 941128828u, \n217987326u, 2088501248u, 124u, 1815660230u, 482369734u, 3334864896u, 100688070u, 3329754630u, \n1019265030u, 3334871064u, 201339078u, 3323464710u, 1824571398u, 3334871064u, 410916876u, 3591903292u, \n3439131660u, 2088632320u, 805309464u, 3591909382u, 4261856792u, 3322281984u, 1610614296u, 3323486214u, \n201770544u, 3322281984u, 813567000u, 3323510790u, 201770544u, 3322288152u, 402659328u, 1813563078u, \n214353456u, 3322681368u, 201338904u, 947846780u, 511474736u, 2088239152u, 100687896u, 0u, 0u, 0u, 0u, \n0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1113148u, 4177460796u, \n3325828838u, 4039558780u, 2084071014u, 1818650214u, 3323464806u, 1626269382u, 3328992962u, 1717723842u,\n3323464806u, 1627322054u, 3334891200u, 1718118592u, 3323464812u, 1627324102u, 3737550016u, 1719171264u,\n4262988920u, 1624694470u, 3741214400u, 1718118622u, 3323464824u, 1623641798u, 3737544384u, 1717592262u,\n3323513964u, 1623639750u, 3703989954u, 1717723334u, 3323513958u, 1657194182u, 3234227814u, 1818648678u,\n3323513958u, 1724303046u, 2093415484u, 4177457210u, 3325851878u, 4274439804u, 0u, 0u, 0u, 0u, 0u, 0u, \n0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 4096u, 0u, 0u, 0u, 14336u, 4236049532u, 2126956230u,\n3328638524u, 3959808u, 1724278470u, 2126956230u, 3328624176u, 2148320768u, 1724278470u, 1522976454u, \n1818658352u, 3222011904u, 1724278368u, 415680198u, 2087062576u, 3758882816u, 2093382712u, 415680214u,\n943462448u, 1879834624u, 1623616524u, 415680214u, 941109296u, 940310528u, 1623614982u, 415680214u,\n2081972272u, 470548480u, 1624663750u, 415657214u, 1813561904u, 235667456u, 1625188038u, 415643886u,\n3323512368u, 101449728u, 4034717308u, 1014763628u, 3325886012u, 37486592u, 786432u, 0u, 0u, 0u, 917504u,\n0u, 0u, 255u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 805306368u, 0u, 0u, 0u, 805306368u, 0u, 0u, 0u, 402710528u,\n469776384u, 3759671008u, 939524096u, 24576u, 201354240u, 1612187232u, 402653184u, 24576u, 201352192u,\n1610612832u, 402653184u, 7895164u, 1014784118u, 1815613030u, 418176124u, 814278u, 1824977100u,\n1981285996u, 419325638u, 8152768u, 3439222988u, 1712850552u, 416704198u, 13395648u, 3435159756u,\n1712850552u, 416704198u, 13395648u, 3435159756u, 1712850540u, 416704198u, 13395654u, 3435552972u,\n1712850534u, 416704198u, 7765116u, 1987899516u, 3862693606u, 1019635324u, 0u, 12u, 26112u, 0u, 0u, 204u,\n26112u, 0u, 0u, 120u, 15360u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 268435456u, 7u, \n205011712u, 0u, 805306368u, 12u, 202141184u, 0u, 805306368u, 12u, 202113032u, 3698777212u, 4234556259u,\n1667464972u, 202113052u, 1724675782u, 812004195u, 912483896u, 458806u, 1724671584u, 812004203u, \n476253196u, 202113123u, 1724670008u, 812004203u, 476256268u, 202113123u, 1724669964u, 812004203u, \n476262412u, 202113123u, 1724670150u, 912662143u, 912483084u, 202113151u, 2088562812u, 473631798u, \n1665105671u, 204996608u, 1611399168u, 0u, 196608u, 0u, 1611399168u, 0u, 393216u, 0u, 4028497920u, 0u, \n8126464u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 56u, 3088u, 6305792u, 268460032u, 408995436u, 1020008504u, \n3425725440u, 952512614u, 1009778744u, 1711288428u, 1587200u, 1811945472u, 1712852992u, 3254779904u, 60u,\n0u, 14392u, 3234626680u, 2021161062u, 2088533048u, 943221868u, 3234645516u, 202116192u, 3334915608u,\n404276934u, 3234659964u, 2088533088u, 4278124056u, 404276934u, 3268198604u, 3435973734u, 3233857560u, \n404291326u, 1724694732u, 3435973692u, 3233857560u, 404276934u, 1020053196u, 3435973644u, 3334915608u,\n404276934u, 209091702u, 1987474950u, 2088533052u, 1010616006u, 100663296u, 60u, 0u, 0u, 2080374784u, \n0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 402653184u, 0u, 0u, 0u, 805306384u, 6303840u, 13026840u,\n939587598u, 1610628664u, 3325065264u, 3321888792u, 1818676251u, 27756u, 1625112u, 8177212u, 1684458520u,\n4261465088u, 0u, 13026918u, 1614608408u, 1724697724u, 2088553676u, 3334915680u, 4028154904u, 1618411206u,\n3334917324u, 3334915680u, 1618922622u, 2083966150u, 3334917324u, 3334915680u, 1612242456u, 1618922694u,\n3334917324u, 3334915686u, 1618922520u, 1624820934u, 3334917324u, 3334915644u, 1612237848u, 1725484230u,\n3334917324u, 3334915608u, 3860384792u, 4268674684u, 2088531574u, 2122087448u, 4229482008u, 0u, 0u,\n100663296u, 216u, 0u, 0u, 201326592u, 112u, 0u, 0u, 2013265920u, 0u, 0u, 0u, 0u, 0u, 0u, 7733248u,\n0u, 0u, 403445784u, 14433336u, 192u, 3221225472u, 806891568u, 1979739244u, 805306560u, 3222798336u,\n1613783136u, 3703991404u, 805306562u, 3256352768u, 0u, 15089208u, 198u, 3321888768u, 2016967884u,\n3707109376u, 805306572u, 3424138968u, 202950348u, 1727954556u, 822017560u, 404253804u, 2081998540u,\n1725825024u, 1623197232u, 806934582u, 3424175820u, 1724776448u, 3233810016u, 1715235948u, 3424175820u,\n1724252160u, 3334473436u, 3460052696u, 3424175820u, 1724252160u, 3334473350u, 2654732288u, 1983675510u,\n1724252160u, 2080374796u, 1041760256u, 0u, 0u, 24u, 100663296u, 0u, 0u, 62u, 100663296u, 0u, 0u, 0u,\n0u, 290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 404239872u, 3552768u, 909514752u,\n290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 404239872u, 3552768u, 909514752u,\n290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 418919936u, 4176885502u, 4130797568u,\n290839832u, 404239872u, 403060230u, 104208384u, 1152022296u, 4177065726u, 4176885494u, 4278122744u,\n290839832u, 404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u,\n404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u, 404239926u,\n406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u, 404239926u, 406206006u,\n24u, 1152022296u, 404239926u, 406206006u, 24u, 404226072u, 1579062u, 905983488u, 905983512u,\n404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u,\n404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u,\n1580854u, 926939135u, 939522047u, 404226072u, 1579062u, 808452096u, 805306368u, 536870687u, 4294909751u,\n1060634615u, 939522047u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u,\n6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u,\n905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u,\n1579062u, 3538998u, 905983488u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u,\n404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u,\n404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 922681398u, 522125366u,\n4279763199u, 15732735u, 905969718u, 404226102u, 404226303u, 15732735u, 4294967103u, 522141695u,\n4294451199u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u,\n4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u,\n1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u,\n1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 0u, 0u, 0u, 0u, 0u, 0u,\n0u, 0u, 0u, 0u, 0u, 0u, 7929344u, 0u, 14366u, 7168u, 13420032u, 4261412864u, 2117626928u, 209020u, \n13420286u, 3321914998u, 409781784u, 417990u, 1993130092u, 1618896604u, 1019659788u, 2122211526u, \n3705192556u, 819488280u, 1724302910u, 3688594630u, 3637297260u, 416835096u, 1727949926u, 3688587462u, \n3636904044u, 819488280u, 1724279910u, 3690160326u, 3636904044u, 1624800280u, 1019636838u, 2122211526u,\n3704012908u, 3336069144u, 409758822u, 6303942u, 1993130092u, 4268777496u, 2117660220u, 12590278u, 0u,\n49152u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1572864u, 0u, 0u, 0u, 1572864u, 0u, 0u, 0u,\n1572864u, 939524111u, 3631218688u, 0u, 236453888u, 1811939340u, 1826095104u, 12300u, 454557696u,\n1811939340u, 1815085056u, 4262991896u, 454563840u, 939524108u, 1818262528u, 1575984u, 404232310u,\n12u, 1825078272u, 8259168u, 404226268u, 12u, 1828224000u, 4262988848u, 404258304u, 1573100u, 31744u,\n1579032u, 416809078u, 1579116u, 31744u, 12300u, 416815324u, 108u, 31744u, 4261412864u, 416815104u,\n60u, 31744u, 16744062u, 409993216u, 28u, 0u, 0u, 402653184u, 0u, 0u, 0u, 402653184u, 0u, 0u, 0u,\n402653184u, 0u, 0u );\n\n\nint fontRef( in uint ch, in ivec2 offset, in bvec2 invert ) {\n    if ( invert.x ) {\n        offset.x = 7 - offset.x;\n    }\n    if ( invert.y ) {\n        offset.y = 15 - offset.y;\n    }\n    bool offsetOOB = any( lessThan(         offset, ivec2( 0,  0 ) ) ) ||\n                     any( greaterThanEqual( offset, ivec2( 8, 16 ) ) );\n    bool charOOB = bool( clamp( ch, 0u, 255u ) != ch );\n    if ( offsetOOB || charOOB ) {\n        return -1; // oob\n    }\n    uvec2 sampleLoc = uvec2( ch % 16u, ch / 16u ) * uvec2( 8u, 16u ) + uvec2( offset );\n    uint idx = ( sampleLoc.x + sampleLoc.y * 128u ) / 32u;\n    uint packedData = data[ idx ];\n    uint bitMask = 1u << ( 31u - sampleLoc.x % 32u );\n    return int( ( packedData & bitMask ) != 0u );\n}\n\nint fontRef( in uint ch, ivec2 offset ) {\n    return fontRef( ch, offset, bvec2( true, false ) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2919, 2919, 2976, 2976, 3762]], "test": "untested"}
{"id": "DlVyWt", "name": "Lorem Ipsum Text Rendering", "author": "0xBAMA", "description": "using code page 37 font atlas LUT to write text", "tags": ["text", "font", "lut"], "likes": 2, "viewed": 152, "published": 3, "date": "1700798291", "time_retrieved": "2024-07-30T17:20:51.458380", "image_code": "// referencing a pixel, for an extended ASCII character in Code Page 37\n//    expected ranges of char are 0-255\n//    expected ranges of offset are within the 8x16 neighborhood\n//    inverting on either axis will let you orient as desired\nconst uint data[ 1024 ] = uint[ 1024 ]( 0u, 0u, 4278255360u, 0u, 0u, 0u, 4278255360u, 0u, 0u, 0u, 4278255360u, 0u, 8289792u, 1579008u, 4278255390u, 1010794240u, 8519532u, 272382976u, 4278255374u, 1714643736u, 10869758u, 943488512u, 4282172186u, 1715437336u, 8519678u, 2095578904u, 3882260786u, 1714447323u, 8519678u, 4276617020u, 3275931000u, 1714447164u, 12436478u, 2095545916u, 3275931084u, 1009804263u, 10086268u, 941103128u, 3882260940u, 405824316u, 8519480u, 270014464u, 4282172364u, 2121295835u, 8519440u, 3947520u, 4278255564u, 418440984u, 8289792u, 0u, 4278255480u, 417392152u, 0u, 0u, 4278255360u, 49152u, 0u, 0u, 4278255360u, 0u, 0u, 0u, 4278255360u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 2147614720u, 8126464u, 0u, 0u, 3221624934u, 2143682584u, 404226048u, 0u, 3759029350u, 3680501820u, 1008205824u, 0u, 4028530278u, 3677880446u, 2115502080u, 4350u, 4164819046u, 3681288216u, 404232240u, 2636030u, 4278065254u, 2076573720u, 404229216u, 3228317820u, 4164819046u, 465960984u, 404291326u, 3237903484u, 4028530278u, 460127870u, 404229216u, 3228335160u, 3759029248u, 456719932u, 410916912u, 4264099384u, 3221624934u, 453836312u, 406585344u, 65040u, 2147614822u, 466026110u, 404226048u, 0u, 0u, 8126464u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 402653184u, 0u, 0u, 26112u, 402653232u, 0u, 0u, 1598976u, 2080389168u, 204472320u, 0u, 3958380u, 3321916464u, 404226048u, 0u, 3941484u, 3267521632u, 806092800u, 2u, 3932414u, 3234215936u, 806118936u, 6u, 1572972u, 2081191424u, 806108184u, 12u, 1572972u, 102292480u, 806158206u, 16646168u, 1572972u, 103861248u, 806108184u, 48u, 254u, 2254490624u, 806118936u, 402653280u, 1572972u, 3334917120u, 404226048u, 402659520u, 1572972u, 2089186816u, 204472320u, 402659456u, 0u, 402653184u, 0u, 805306368u, 0u, 402653184u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 941128828u, 217987326u, 2088501248u, 124u, 1815660230u, 482369734u, 3334864896u, 100688070u, 3329754630u, 1019265030u, 3334871064u, 201339078u, 3323464710u, 1824571398u, 3334871064u, 410916876u, 3591903292u, 3439131660u, 2088632320u, 805309464u, 3591909382u, 4261856792u, 3322281984u, 1610614296u, 3323486214u, 201770544u, 3322281984u, 813567000u, 3323510790u, 201770544u, 3322288152u, 402659328u, 1813563078u, 214353456u, 3322681368u, 201338904u, 947846780u, 511474736u, 2088239152u, 100687896u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1113148u, 4177460796u, 3325828838u, 4039558780u, 2084071014u, 1818650214u, 3323464806u, 1626269382u, 3328992962u, 1717723842u, 3323464806u, 1627322054u, 3334891200u, 1718118592u, 3323464812u, 1627324102u, 3737550016u, 1719171264u, 4262988920u, 1624694470u, 3741214400u, 1718118622u, 3323464824u, 1623641798u, 3737544384u, 1717592262u, 3323513964u, 1623639750u, 3703989954u, 1717723334u, 3323513958u, 1657194182u, 3234227814u, 1818648678u, 3323513958u, 1724303046u, 2093415484u, 4177457210u, 3325851878u, 4274439804u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 4096u, 0u, 0u, 0u, 14336u, 4236049532u, 2126956230u, 3328638524u, 3959808u, 1724278470u, 2126956230u, 3328624176u, 2148320768u, 1724278470u, 1522976454u, 1818658352u, 3222011904u, 1724278368u, 415680198u, 2087062576u, 3758882816u, 2093382712u, 415680214u, 943462448u, 1879834624u, 1623616524u, 415680214u, 941109296u, 940310528u, 1623614982u, 415680214u, 2081972272u, 470548480u, 1624663750u, 415657214u, 1813561904u, 235667456u, 1625188038u, 415643886u, 3323512368u, 101449728u, 4034717308u, 1014763628u, 3325886012u, 37486592u, 786432u, 0u, 0u, 0u, 917504u, 0u, 0u, 255u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 805306368u, 0u, 0u, 0u, 805306368u, 0u, 0u, 0u, 402710528u, 469776384u, 3759671008u, 939524096u, 24576u, 201354240u, 1612187232u, 402653184u, 24576u, 201352192u, 1610612832u, 402653184u, 7895164u, 1014784118u, 1815613030u, 418176124u, 814278u, 1824977100u, 1981285996u, 419325638u, 8152768u, 3439222988u, 1712850552u, 416704198u, 13395648u, 3435159756u, 1712850552u, 416704198u, 13395648u, 3435159756u, 1712850540u, 416704198u, 13395654u, 3435552972u, 1712850534u, 416704198u, 7765116u, 1987899516u, 3862693606u, 1019635324u, 0u, 12u, 26112u, 0u, 0u, 204u, 26112u, 0u, 0u, 120u, 15360u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 268435456u, 7u, 205011712u, 0u, 805306368u, 12u, 202141184u, 0u, 805306368u, 12u, 202113032u, 3698777212u, 4234556259u, 1667464972u, 202113052u, 1724675782u, 812004195u, 912483896u, 458806u, 1724671584u, 812004203u, 476253196u, 202113123u, 1724670008u, 812004203u, 476256268u, 202113123u, 1724669964u, 812004203u, 476262412u, 202113123u, 1724670150u, 912662143u, 912483084u, 202113151u, 2088562812u, 473631798u, 1665105671u, 204996608u, 1611399168u, 0u, 196608u, 0u, 1611399168u, 0u, 393216u, 0u, 4028497920u, 0u, 8126464u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 56u, 3088u, 6305792u, 268460032u, 408995436u, 1020008504u, 3425725440u, 952512614u, 1009778744u, 1711288428u, 1587200u, 1811945472u, 1712852992u, 3254779904u, 60u, 0u, 14392u, 3234626680u, 2021161062u, 2088533048u, 943221868u, 3234645516u, 202116192u, 3334915608u, 404276934u, 3234659964u, 2088533088u, 4278124056u, 404276934u, 3268198604u, 3435973734u, 3233857560u, 404291326u, 1724694732u, 3435973692u, 3233857560u, 404276934u, 1020053196u, 3435973644u, 3334915608u, 404276934u, 209091702u, 1987474950u, 2088533052u, 1010616006u, 100663296u, 60u, 0u, 0u, 2080374784u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 402653184u, 0u, 0u, 0u, 805306384u, 6303840u, 13026840u, 939587598u, 1610628664u, 3325065264u, 3321888792u, 1818676251u, 27756u, 1625112u, 8177212u, 1684458520u, 4261465088u, 0u, 13026918u, 1614608408u, 1724697724u, 2088553676u, 3334915680u, 4028154904u, 1618411206u, 3334917324u, 3334915680u, 1618922622u, 2083966150u, 3334917324u, 3334915680u, 1612242456u, 1618922694u, 3334917324u, 3334915686u, 1618922520u, 1624820934u, 3334917324u, 3334915644u, 1612237848u, 1725484230u, 3334917324u, 3334915608u, 3860384792u, 4268674684u, 2088531574u, 2122087448u, 4229482008u, 0u, 0u, 100663296u, 216u, 0u, 0u, 201326592u, 112u, 0u, 0u, 2013265920u, 0u, 0u, 0u, 0u, 0u, 0u, 7733248u, 0u, 0u, 403445784u, 14433336u, 192u, 3221225472u, 806891568u, 1979739244u, 805306560u, 3222798336u, 1613783136u, 3703991404u, 805306562u, 3256352768u, 0u, 15089208u, 198u, 3321888768u, 2016967884u, 3707109376u, 805306572u, 3424138968u, 202950348u, 1727954556u, 822017560u, 404253804u, 2081998540u, 1725825024u, 1623197232u, 806934582u, 3424175820u, 1724776448u, 3233810016u, 1715235948u, 3424175820u, 1724252160u, 3334473436u, 3460052696u, 3424175820u, 1724252160u, 3334473350u, 2654732288u, 1983675510u, 1724252160u, 2080374796u, 1041760256u, 0u, 0u, 24u, 100663296u, 0u, 0u, 62u, 100663296u, 0u, 0u, 0u, 0u, 290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 404239872u, 3552768u, 909514752u, 290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 404239872u, 3552768u, 909514752u, 290839832u, 404239872u, 3552768u, 909514752u, 1152022296u, 418919936u, 4176885502u, 4130797568u, 290839832u, 404239872u, 403060230u, 104208384u, 1152022296u, 4177065726u, 4176885494u, 4278122744u, 290839832u, 404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u, 404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u, 404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 290839832u, 404239926u, 406206006u, 24u, 1152022296u, 404239926u, 406206006u, 24u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1579062u, 905983488u, 905983512u, 404226072u, 1580854u, 926939135u, 939522047u, 404226072u, 1579062u, 808452096u, 805306368u, 536870687u, 4294909751u, 1060634615u, 939522047u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 6168u, 1579062u, 3538998u, 905983488u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 905969718u, 402653238u, 404226303u, 15732735u, 922681398u, 522125366u, 4279763199u, 15732735u, 905969718u, 404226102u, 404226303u, 15732735u, 4294967103u, 522141695u, 4294451199u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 1586688u, 1586742u, 402659583u, 4293922560u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 7929344u, 0u, 14366u, 7168u, 13420032u, 4261412864u, 2117626928u, 209020u, 13420286u, 3321914998u, 409781784u, 417990u, 1993130092u, 1618896604u, 1019659788u, 2122211526u, 3705192556u, 819488280u, 1724302910u, 3688594630u, 3637297260u, 416835096u, 1727949926u, 3688587462u, 3636904044u, 819488280u, 1724279910u, 3690160326u, 3636904044u, 1624800280u, 1019636838u, 2122211526u, 3704012908u, 3336069144u, 409758822u, 6303942u, 1993130092u, 4268777496u, 2117660220u, 12590278u, 0u, 49152u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1572864u, 0u, 0u, 0u, 1572864u, 0u, 0u, 0u, 1572864u, 939524111u, 3631218688u, 0u, 236453888u, 1811939340u, 1826095104u, 12300u, 454557696u, 1811939340u, 1815085056u, 4262991896u, 454563840u, 939524108u, 1818262528u, 1575984u, 404232310u, 12u, 1825078272u, 8259168u, 404226268u, 12u, 1828224000u, 4262988848u, 404258304u, 1573100u, 31744u, 1579032u, 416809078u, 1579116u, 31744u, 12300u, 416815324u, 108u, 31744u, 4261412864u, 416815104u, 60u, 31744u, 16744062u, 409993216u, 28u, 0u, 0u, 402653184u, 0u, 0u, 0u, 402653184u, 0u, 0u, 0u, 402653184u, 0u, 0u );\nint fontRef( in uint ch, in ivec2 offset, in bvec2 invert ) {\n    if ( invert.x ) offset.x = 7 - offset.x;\n    if ( invert.y ) offset.y = 15 - offset.y;\n    bool offsetOOB = any( lessThan(         offset, ivec2( 0,  0 ) ) ) ||\n                     any( greaterThanEqual( offset, ivec2( 8, 16 ) ) );\n    bool charOOB = bool( clamp( ch, 0u, 255u ) != ch );\n    if ( offsetOOB || charOOB ) {\n        return -1; // oob\n    }\n    uvec2 sampleLoc = uvec2( ch % 16u, ch / 16u ) * uvec2( 8u, 16u ) + uvec2( offset );\n    uint idx = ( sampleLoc.x + sampleLoc.y * 128u ) / 32u;\n    uint packedData = data[ idx ];\n    uint bitMask = 1u << ( 31u - sampleLoc.x % 32u );\n    return int( ( packedData & bitMask ) != 0u );\n}\n\nint fontRef( in uint ch, ivec2 offset ) {\n    return fontRef( ch, offset, bvec2( true, false ) );\n}\n\nconst uint loremIpsum[ 500 ] = uint[ 500 ]( 76u, 111u, 114u, 101u, 109u, 32u, 105u, 112u, 115u, 117u, 109u, 32u, 100u, 111u, 108u, 111u, 114u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u, 44u, 32u, 99u, 111u, 110u, 115u, 101u, 99u, 116u, 101u, 116u, 117u, 114u, 32u, 97u, 100u, 105u, 112u, 105u, 115u, 99u, 105u, 110u, 103u, 32u, 101u, 108u, 105u, 116u, 46u, 32u, 80u, 104u, 97u, 115u, 101u, 108u, 108u, 117u, 115u, 32u, 112u, 104u, 97u, 114u, 101u, 116u, 114u, 97u, 32u, 102u, 114u, 105u, 110u, 103u, 105u, 108u, 108u, 97u, 32u, 114u, 105u, 115u, 117u, 115u, 44u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u, 32u, 100u, 105u, 103u, 110u, 105u, 115u, 115u, 105u, 109u, 32u, 114u, 105u, 115u, 117u, 115u, 32u, 100u, 105u, 99u, 116u, 117u, 109u, 32u, 101u, 103u, 101u, 116u, 46u, 32u, 78u, 117u, 108u, 108u, 97u, 109u, 32u, 114u, 117u, 116u, 114u, 117u, 109u, 32u, 118u, 117u, 108u, 112u, 117u, 116u, 97u, 116u, 101u, 32u, 109u, 97u, 115u, 115u, 97u, 32u, 101u, 103u, 101u, 116u, 32u, 112u, 117u, 108u, 118u, 105u, 110u, 97u, 114u, 46u, 32u, 73u, 110u, 32u, 101u, 103u, 101u, 116u, 32u, 100u, 105u, 99u, 116u, 117u, 109u, 32u, 97u, 110u, 116u, 101u, 46u, 32u, 78u, 117u, 110u, 99u, 32u, 97u, 108u, 105u, 113u, 117u, 97u, 109u, 32u, 113u, 117u, 105u, 115u, 32u, 97u, 117u, 103u, 117u, 101u, 32u, 97u, 99u, 32u, 111u, 114u, 110u, 97u, 114u, 101u, 46u, 32u, 80u, 101u, 108u, 108u, 101u, 110u, 116u, 101u, 115u, 113u, 117u, 101u, 32u, 108u, 117u, 99u, 116u, 117u, 115u, 32u, 112u, 114u, 101u, 116u, 105u, 117u, 109u, 32u, 108u, 105u, 98u, 101u, 114u, 111u, 32u, 117u, 116u, 32u, 99u, 111u, 110u, 115u, 101u, 99u, 116u, 101u, 116u, 117u, 114u, 46u, 32u, 78u, 117u, 108u, 108u, 97u, 32u, 97u, 32u, 111u, 100u, 105u, 111u, 32u, 97u, 99u, 32u, 111u, 114u, 99u, 105u, 32u, 109u, 111u, 108u, 101u, 115u, 116u, 105u, 101u, 32u, 105u, 109u, 112u, 101u, 114u, 100u, 105u, 101u, 116u, 32u, 97u, 32u, 105u, 110u, 32u, 108u, 101u, 111u, 46u, 32u, 83u, 101u, 100u, 32u, 101u, 117u, 32u, 105u, 110u, 116u, 101u, 114u, 100u, 117u, 109u, 32u, 108u, 101u, 111u, 46u, 32u, 67u, 117u, 114u, 97u, 98u, 105u, 116u, 117u, 114u, 32u, 102u, 114u, 105u, 110u, 103u, 105u, 108u, 108u, 97u, 32u, 101u, 103u, 101u, 116u, 32u, 106u, 117u, 115u, 116u, 111u, 32u, 101u, 103u, 101u, 116u, 32u, 116u, 105u, 110u, 99u, 105u, 100u, 117u, 110u, 116u, 46u, 32u, 77u, 111u, 114u, 98u, 105u, 32u, 112u, 111u, 115u, 117u, 101u, 114u, 101u, 32u, 115u, 105u, 116u, 32u, 97u, 109u, 101u, 116u, 32u, 100u, 117u, 105u, 32u, 105u, 110u, 32u, 118u, 117u, 108u, 112u, 117u, 116u, 97u, 116u, 101u, 46u, 32u, 80u, 104u, 97u, 115u, 101u, 108u, 108u, 117u, 115u, 32u, 105u, 109u, 112u, 101u, 114u, 100u, 105u, 101u, 116u, 32u, 113u, 117u, 97u, 109u, 32u, 97u, 116u, 32u, 114u, 105u, 115u, 117u, 115u, 32u, 108u, 97u, 99u, 105u, 110u, 105u, 97u, 32u, 97u, 99u, 99u, 117u, 109u, 115u, 97u, 110u, 46u, 32u, 86u, 101u, 115u, 116u, 105u, 98u );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scale = 1.0f;\n    fragCoord.xy = scale * fragCoord.xy;\n    ivec2 bin = ivec2( floor( fragCoord.xy / vec2( 8, 16 ) ) );\n    // ivec2 offset = ivec2( vec2( bin * ivec2( 8, 16 ) ) / scale ) - ivec2( fragCoord.xy * scale );\n    ivec2 offset = clamp( ( bin * ivec2( 8, 16 ) - ivec2( floor( fragCoord.xy ) ) ) % ivec2( 8, 16 ), ivec2( 0, 0 ), ivec2( 8, 16 ) );\n    int charsPerRow = 150;\n    int indexOfNearest = bin.x % charsPerRow + bin.y * charsPerRow;\n\n    int onGlyph = fontRef( loremIpsum[ indexOfNearest ], offset );\n    vec3 col = vec3( 0.0f );\n    switch ( onGlyph ) {\n        case -1: col = vec3( 0.1618f ); break; // out of bounds\n        case  0: col = vec3( 0.0f );    break; // \"off\" pixel\n        case  1: col = vec3( 0.618f );  break; // \"on\" pixel\n    }\n\n    // Output to screen\n    // fragColor = vec4( vec3( offset.xyy ) / 4000.0f * float( ( bin.x - 1 ) % 2 ) * float( bin.y % 2 ), 1.0f );\n    fragColor = vec4( col, 1.0f );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10258, 10258, 10319, 10319, 10966], [10968, 10968, 11009, 11009, 11067], [13963, 13963, 14020, 14020, 14971]], "test": "untested"}
{"id": "mtGcWd", "name": "Code Page 437 Font LUT", "author": "0xBAMA", "description": "for a texture-constrained environment, baked out to the bits of a uint array", "tags": ["text", "font", "lut"], "likes": 1, "viewed": 239, "published": 3, "date": "1700792650", "time_retrieved": "2024-07-30T17:20:52.392882", "image_code": "uint data[ 1024 ] = uint[](\n        0u, 0u, 4278255360u, 0u, \n        0u, 0u, 4278255360u, 0u, \n        0u, 0u, 4278255360u, 0u, \n        8289792u, 1579008u, 4278255390u, 1010794240u, \n        8519532u, 272382976u, 4278255374u, 1714643736u, \n        10869758u, 943488512u, 4282172186u, 1715437336u, \n        8519678u, 2095578904u, 3882260786u, 1714447323u, \n        8519678u, 4276617020u, 3275931000u, 1714447164u, \n        12436478u, 2095545916u, 3275931084u, 1009804263u, \n        10086268u, 941103128u, 3882260940u, 405824316u, \n        8519480u, 270014464u, 4282172364u, 2121295835u, \n        8519440u, 3947520u, 4278255564u, 418440984u, \n        8289792u, 0u, 4278255480u, 417392152u, \n        0u, 0u, 4278255360u, 49152u, \n        0u, 0u, 4278255360u, 0u, \n        0u, 0u, 4278255360u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        2147614720u, 8126464u, 0u, 0u, \n        3221624934u, 2143682584u, 404226048u, 0u, \n        3759029350u, 3680501820u, 1008205824u, 0u, \n        4028530278u, 3677880446u, 2115502080u, 4350u, \n        4164819046u, 3681288216u, 404232240u, 2636030u, \n        4278065254u, 2076573720u, 404229216u, 3228317820u, \n        4164819046u, 465960984u, 404291326u, 3237903484u, \n        4028530278u, 460127870u, 404229216u, 3228335160u, \n        3759029248u, 456719932u, 410916912u, 4264099384u, \n        3221624934u, 453836312u, 406585344u, 65040u, \n        2147614822u, 466026110u, 404226048u, 0u, \n        0u, 8126464u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 402653184u, 0u, 0u, \n        26112u, 402653232u, 0u, 0u, \n        1598976u, 2080389168u, 204472320u, 0u, \n        3958380u, 3321916464u, 404226048u, 0u, \n        3941484u, 3267521632u, 806092800u, 2u, \n        3932414u, 3234215936u, 806118936u, 6u, \n        1572972u, 2081191424u, 806108184u, 12u, \n        1572972u, 102292480u, 806158206u, 16646168u, \n        1572972u, 103861248u, 806108184u, 48u, \n        254u, 2254490624u, 806118936u, 402653280u, \n        1572972u, 3334917120u, 404226048u, 402659520u, \n        1572972u, 2089186816u, 204472320u, 402659456u, \n        0u, 402653184u, 0u, 805306368u, \n        0u, 402653184u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        941128828u, 217987326u, 2088501248u, 124u, \n        1815660230u, 482369734u, 3334864896u, 100688070u, \n        3329754630u, 1019265030u, 3334871064u, 201339078u, \n        3323464710u, 1824571398u, 3334871064u, 410916876u, \n        3591903292u, 3439131660u, 2088632320u, 805309464u, \n        3591909382u, 4261856792u, 3322281984u, 1610614296u, \n        3323486214u, 201770544u, 3322281984u, 813567000u, \n        3323510790u, 201770544u, 3322288152u, 402659328u, \n        1813563078u, 214353456u, 3322681368u, 201338904u, \n        947846780u, 511474736u, 2088239152u, 100687896u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        1113148u, 4177460796u, 3325828838u, 4039558780u, \n        2084071014u, 1818650214u, 3323464806u, 1626269382u, \n        3328992962u, 1717723842u, 3323464806u, 1627322054u, \n        3334891200u, 1718118592u, 3323464812u, 1627324102u, \n        3737550016u, 1719171264u, 4262988920u, 1624694470u, \n        3741214400u, 1718118622u, 3323464824u, 1623641798u, \n        3737544384u, 1717592262u, 3323513964u, 1623639750u, \n        3703989954u, 1717723334u, 3323513958u, 1657194182u, \n        3234227814u, 1818648678u, 3323513958u, 1724303046u, \n        2093415484u, 4177457210u, 3325851878u, 4274439804u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 4096u, \n        0u, 0u, 0u, 14336u, \n        4236049532u, 2126956230u, 3328638524u, 3959808u, \n        1724278470u, 2126956230u, 3328624176u, 2148320768u, \n        1724278470u, 1522976454u, 1818658352u, 3222011904u, \n        1724278368u, 415680198u, 2087062576u, 3758882816u, \n        2093382712u, 415680214u, 943462448u, 1879834624u, \n        1623616524u, 415680214u, 941109296u, 940310528u, \n        1623614982u, 415680214u, 2081972272u, 470548480u, \n        1624663750u, 415657214u, 1813561904u, 235667456u, \n        1625188038u, 415643886u, 3323512368u, 101449728u, \n        4034717308u, 1014763628u, 3325886012u, 37486592u, \n        786432u, 0u, 0u, 0u, \n        917504u, 0u, 0u, 255u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        805306368u, 0u, 0u, 0u, \n        805306368u, 0u, 0u, 0u, \n        402710528u, 469776384u, 3759671008u, 939524096u, \n        24576u, 201354240u, 1612187232u, 402653184u, \n        24576u, 201352192u, 1610612832u, 402653184u, \n        7895164u, 1014784118u, 1815613030u, 418176124u, \n        814278u, 1824977100u, 1981285996u, 419325638u, \n        8152768u, 3439222988u, 1712850552u, 416704198u, \n        13395648u, 3435159756u, 1712850552u, 416704198u, \n        13395648u, 3435159756u, 1712850540u, 416704198u, \n        13395654u, 3435552972u, 1712850534u, 416704198u, \n        7765116u, 1987899516u, 3862693606u, 1019635324u, \n        0u, 12u, 26112u, 0u, \n        0u, 204u, 26112u, 0u, \n        0u, 120u, 15360u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 268435456u, 7u, 205011712u, \n        0u, 805306368u, 12u, 202141184u, \n        0u, 805306368u, 12u, 202113032u, \n        3698777212u, 4234556259u, 1667464972u, 202113052u, \n        1724675782u, 812004195u, 912483896u, 458806u, \n        1724671584u, 812004203u, 476253196u, 202113123u, \n        1724670008u, 812004203u, 476256268u, 202113123u, \n        1724669964u, 812004203u, 476262412u, 202113123u, \n        1724670150u, 912662143u, 912483084u, 202113151u, \n        2088562812u, 473631798u, 1665105671u, 204996608u, \n        1611399168u, 0u, 196608u, 0u, \n        1611399168u, 0u, 393216u, 0u, \n        4028497920u, 0u, 8126464u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 56u, \n        3088u, 6305792u, 268460032u, 408995436u, \n        1020008504u, 3425725440u, 952512614u, 1009778744u, \n        1711288428u, 1587200u, 1811945472u, 1712852992u, \n        3254779904u, 60u, 0u, 14392u, \n        3234626680u, 2021161062u, 2088533048u, 943221868u, \n        3234645516u, 202116192u, 3334915608u, 404276934u, \n        3234659964u, 2088533088u, 4278124056u, 404276934u, \n        3268198604u, 3435973734u, 3233857560u, 404291326u, \n        1724694732u, 3435973692u, 3233857560u, 404276934u, \n        1020053196u, 3435973644u, 3334915608u, 404276934u, \n        209091702u, 1987474950u, 2088533052u, 1010616006u, \n        100663296u, 60u, 0u, 0u, \n        2080374784u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        402653184u, 0u, 0u, 0u, \n        805306384u, 6303840u, 13026840u, 939587598u, \n        1610628664u, 3325065264u, 3321888792u, 1818676251u, \n        27756u, 1625112u, 8177212u, 1684458520u, \n        4261465088u, 0u, 13026918u, 1614608408u, \n        1724697724u, 2088553676u, 3334915680u, 4028154904u, \n        1618411206u, 3334917324u, 3334915680u, 1618922622u, \n        2083966150u, 3334917324u, 3334915680u, 1612242456u, \n        1618922694u, 3334917324u, 3334915686u, 1618922520u, \n        1624820934u, 3334917324u, 3334915644u, 1612237848u, \n        1725484230u, 3334917324u, 3334915608u, 3860384792u, \n        4268674684u, 2088531574u, 2122087448u, 4229482008u, \n        0u, 0u, 100663296u, 216u, \n        0u, 0u, 201326592u, 112u, \n        0u, 0u, 2013265920u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 7733248u, 0u, 0u, \n        403445784u, 14433336u, 192u, 3221225472u, \n        806891568u, 1979739244u, 805306560u, 3222798336u, \n        1613783136u, 3703991404u, 805306562u, 3256352768u, \n        0u, 15089208u, 198u, 3321888768u, \n        2016967884u, 3707109376u, 805306572u, 3424138968u, \n        202950348u, 1727954556u, 822017560u, 404253804u, \n        2081998540u, 1725825024u, 1623197232u, 806934582u, \n        3424175820u, 1724776448u, 3233810016u, 1715235948u, \n        3424175820u, 1724252160u, 3334473436u, 3460052696u, \n        3424175820u, 1724252160u, 3334473350u, 2654732288u, \n        1983675510u, 1724252160u, 2080374796u, 1041760256u, \n        0u, 0u, 24u, 100663296u, \n        0u, 0u, 62u, 100663296u, \n        0u, 0u, 0u, 0u, \n        290839832u, 404239872u, 3552768u, 909514752u, \n        1152022296u, 404239872u, 3552768u, 909514752u, \n        290839832u, 404239872u, 3552768u, 909514752u, \n        1152022296u, 404239872u, 3552768u, 909514752u, \n        290839832u, 404239872u, 3552768u, 909514752u, \n        1152022296u, 418919936u, 4176885502u, 4130797568u, \n        290839832u, 404239872u, 403060230u, 104208384u, \n        1152022296u, 4177065726u, 4176885494u, 4278122744u, \n        290839832u, 404239926u, 406206006u, 24u, \n        1152022296u, 404239926u, 406206006u, 24u, \n        290839832u, 404239926u, 406206006u, 24u, \n        1152022296u, 404239926u, 406206006u, 24u, \n        290839832u, 404239926u, 406206006u, 24u, \n        1152022296u, 404239926u, 406206006u, 24u, \n        290839832u, 404239926u, 406206006u, 24u, \n        1152022296u, 404239926u, 406206006u, 24u, \n        404226072u, 1579062u, 905983488u, 905983512u, \n        404226072u, 1579062u, 905983488u, 905983512u, \n        404226072u, 1579062u, 905983488u, 905983512u, \n        404226072u, 1579062u, 905983488u, 905983512u, \n        404226072u, 1579062u, 905983488u, 905983512u, \n        404226072u, 1580854u, 926939135u, 939522047u, \n        404226072u, 1579062u, 808452096u, 805306368u, \n        536870687u, 4294909751u, 1060634615u, 939522047u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        6168u, 1579062u, 3538998u, 905983488u, \n        905969718u, 402653238u, 404226303u, 15732735u, \n        905969718u, 402653238u, 404226303u, 15732735u, \n        905969718u, 402653238u, 404226303u, 15732735u, \n        905969718u, 402653238u, 404226303u, 15732735u, \n        905969718u, 402653238u, 404226303u, 15732735u, \n        922681398u, 522125366u, 4279763199u, 15732735u, \n        905969718u, 404226102u, 404226303u, 15732735u, \n        4294967103u, 522141695u, 4294451199u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        1586688u, 1586742u, 402659583u, 4293922560u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        7929344u, 0u, 14366u, 7168u, \n        13420032u, 4261412864u, 2117626928u, 209020u, \n        13420286u, 3321914998u, 409781784u, 417990u, \n        1993130092u, 1618896604u, 1019659788u, 2122211526u, \n        3705192556u, 819488280u, 1724302910u, 3688594630u, \n        3637297260u, 416835096u, 1727949926u, 3688587462u, \n        3636904044u, 819488280u, 1724279910u, 3690160326u, \n        3636904044u, 1624800280u, 1019636838u, 2122211526u, \n        3704012908u, 3336069144u, 409758822u, 6303942u, \n        1993130092u, 4268777496u, 2117660220u, 12590278u, \n        0u, 49152u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 0u, 0u, 0u, \n        0u, 1572864u, 0u, 0u, \n        0u, 1572864u, 0u, 0u, \n        0u, 1572864u, 939524111u, 3631218688u, \n        0u, 236453888u, 1811939340u, 1826095104u, \n        12300u, 454557696u, 1811939340u, 1815085056u, \n        4262991896u, 454563840u, 939524108u, 1818262528u, \n        1575984u, 404232310u, 12u, 1825078272u, \n        8259168u, 404226268u, 12u, 1828224000u, \n        4262988848u, 404258304u, 1573100u, 31744u, \n        1579032u, 416809078u, 1579116u, 31744u, \n        12300u, 416815324u, 108u, 31744u, \n        4261412864u, 416815104u, 60u, 31744u, \n        16744062u, 409993216u, 28u, 0u, \n        0u, 402653184u, 0u, 0u, \n        0u, 402653184u, 0u, 0u, \n        0u, 402653184u, 0u, 0u\n);\n\n// referencing a pixel, for an extended ASCII character in Code Page 37\n//    expected ranges of char are 0-255\n//    expected ranges of offset are within the 8x16 neighborhood\nint fontRef( uint char, ivec2 offset ) {\n    bool offsetOOB = any( lessThan(         offset, ivec2( 0,  0 ) ) ) ||\n                     any( greaterThanEqual( offset, ivec2( 8, 16 ) ) );\n    bool charOOB = bool( clamp( char, 0u, 255u ) != char );\n    if ( offsetOOB || charOOB ) {\n        return -1; // oob\n    }\n    uvec2 sampleLoc = uvec2( char % 16u, char / 16u ) * uvec2( 8u, 16u ) + uvec2( offset );\n    uint idx = ( sampleLoc.x + sampleLoc.y * 128u ) / 32u;\n    uint packedData = data[ idx ];\n    uint bitMask = 1u << ( 31u - sampleLoc.x % 32u );\n    return int( ( packedData & bitMask ) != 0u );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    int onGlyph = fontRef( uint( iTime ) % 255u, ivec2( fragCoord.xy ) / ivec2( 8, -16 ) + ivec2( -20, 20 ) );\n    vec3 col = vec3( 0.0f );\n    switch ( onGlyph ) {\n        case -1: col = vec3( 0.1618f ); break; // out of bounds\n        case  0: col = vec3( 0.0f );    break; // \"off\" pixel\n        case  1: col = vec3( 0.618f );  break; // \"on\" pixel\n    }\n\n    // Output to screen\n    fragColor = vec4( col, 1.0f );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12311, 12488, 12528, 12528, 13092], [13094, 13094, 13151, 13151, 13572]], "test": "untested"}
{"id": "mtGyWd", "name": "discrete fourier expanding wave", "author": "lomateron", "description": "control with mouse\nfaster method https://www.shadertoy.com/view/DttfzH", "tags": ["physics"], "likes": 4, "viewed": 142, "published": 3, "date": "1700789272", "time_retrieved": "2024-07-30T17:20:53.150855", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if(iMouse.z<.5){m.x = iTime*.2;\n                    m.y = .3;}\n    float w = 32.;//space resolution\n    u = floor(u*w);\n    float sum = 0.;\n    for(float b=-w; b<=w; b++){\n    for(float a=-w; a<=w; a++){\n        float ang = 3.141592/w*(u.x*a + u.y*b) + m.x*11.*sqrt(a*a+b*b);\n        sum += cos(ang)/exp((a*a+b*b)/w/w*m.y*33.);\n    }}\n    fragColor = vec4(sum/w*.2+.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 530]], "test": "untested"}
{"id": "dlycDt", "name": "Dutch Windmill [173 Chars]", "author": "SnoopethDuckDuck", "description": "just fiddling without thinking, golfing always welcome :)", "tags": ["golf", "dutchcolors"], "likes": 55, "viewed": 445, "published": 3, "date": "1700788814", "time_retrieved": "2024-07-30T17:20:53.900850", "image_code": "// -3 by xor! [173] 🐠\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= 4. / iResolution.y;\n    for(float i; i++<9.; o = tan(.1*(i+u--.yxxx+u.yyxx)))\n        u += tanh(13./i*sin(i*u.yx-iTime-19.*atan(u.x,u.y)))/i;    \n    o = exp(-++o*o*o);\n}\n\n\n// Honorable mention: [163] Myth0genesis 🐠 and shadertoyjiang 🐠\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u *= 4. / iResolution.y;\n    for(float i; i++<9.; o = 1.+tan(1.8-.08*(u--.yxxx+u.yyxx)))\n        u += tanh(13./i*sin(i*u.yx-iTime-19.*atan(u.x,u.y)))/i\n           ;\n}\n//*/\n\n// Original [176]\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u *= 4. / iResolution.y;\n    for(float i; i++<9.; o = 1.+tan(1.+.1*(u.yxxx+u.yyxx)))\n        u += tanh(13./i*sin(i*u.yx-iTime-19.*atan(u.x,u.y)))/i\n           -1.;    \n    o = exp(-o*o*o);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlycDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 61, 61, 241]], "test": "untested"}
{"id": "ctGcWd", "name": "Mercator Earth Sphere Projection", "author": "Peace", "description": "Projected a Mercator earth map on sphere", "tags": ["sphere", "earth", "map", "projection", "mercator"], "likes": 0, "viewed": 159, "published": 3, "date": "1700773737", "time_retrieved": "2024-07-30T17:20:54.645858", "image_code": "// Note: you can use actual world map SDF texture\n\nconst float PI = 3.14159265358;\n\nvec2 getCoord(vec2 uv, float z) {\n    vec2 coord = vec2(atan(z, uv.x) * 0.5, acos(-uv.y)) / PI;\n    coord.x += iTime * 0.1;\n    return coord;\n}\n\nvec3 sampleTex(vec2 uv, vec3 norm, float mr) {\n    const vec3 OUTLINE_COLOR = vec3(0.5, 0.4, 0.25);\n    const vec3 LAND_COLOR = vec3(0.7, 1, 0.6);\n    const vec3 DOT_COLOR = vec3(1);\n    const vec3 OCEAN_COLOR = vec3(0.3, 0.5, 1.0);\n    const vec3 FRESNEL_COLOR = vec3(0.15, 0.2, 0.5) * 0.5;\n    const float FRESNEL_POWER = 3.;\n    const float GRID = 128.;\n\n    float d = texture(iChannel0, uv).r;\n    vec3 col = vec3(0);\n    \n    // Outline\n    const float w = 0.05;\n    col += smoothstep(w, max(0.0, w - 16. / mr), abs(d - 0.5)) * OUTLINE_COLOR; \n    \n    // Land\n    col += smoothstep(0.5, 0.6, d) * 0.2 * LAND_COLOR;\n    \n    // Dots\n    float gd = texture(iChannel0, vec2(ivec2(uv * GRID)) / GRID + .5 / GRID).r;\n    vec2 guv = fract(uv * GRID) * 2. - 1.;\n    float dots = max(0.0, smoothstep(0.7, 0.3, length(guv * vec2(iResolution.x / iResolution.y, 1)))) * 0.3;\n    dots *= gd > 0.6 ? 1.0 : 0.0;\n    col += dots * DOT_COLOR;\n    \n    // Oceans\n    col += smoothstep(0.6, 0.5, d) * 0.08 * OCEAN_COLOR;\n\n    // Fresnel\n    float fresnel = pow(max(0.0, dot(norm.xy, norm.xy) - norm.z * norm.z), FRESNEL_POWER);\n    col = mix(col, FRESNEL_COLOR + fresnel * fresnel * length(FRESNEL_COLOR) * 0.3, fresnel);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr * 1.2;\n    vec3 col = vec3(0);\n\tfragColor = vec4(col, 1.0);\n    \n    float l = dot(uv, uv);\n    if (l > 1.0) \n        discard;\n\n    float z = -sqrt(1.0 - l);\n    \n    vec3 front = sampleTex(getCoord(uv, z), vec3(uv, z), mr).rgb;\n    vec3 back = sampleTex(getCoord(uv, -z), vec3(uv, -z), mr).rgb;\n    \n    float s = smoothstep(1.0, 1.0 - length(fwidth(uv)), sqrt(l));\n    col = (front * 0.7 + 0.3 * back) * s;\n \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 117, 117, 227], [229, 229, 275, 275, 1456], [1458, 1458, 1515, 1515, 2061]], "test": "untested"}
{"id": "clGcW3", "name": "weird-projection", "author": "LydianLights", "description": "just a test. was trying to calculate perspective projection and made a wrong assumption, but it turned out kinda weird. the horizontal lines are evenly spaced instead of getting closer toward the horizon.", "tags": ["projection"], "likes": 1, "viewed": 118, "published": 3, "date": "1700770177", "time_retrieved": "2024-07-30T17:20:55.394855", "image_code": "vec3 gamma(in vec3 color)\n{\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv0 = vec2(\n        (fragCoord.x - 0.5 * iResolution.x) / iResolution.y,\n        fragCoord.y / iResolution.y\n    );\n    \n    float t = -0.05 * iTime;\n    float h = 0.5;\n    \n    vec2 xy = vec2(\n        uv0.x * (h / (h - uv0.y)),\n        uv0.y + t\n    );\n    \n    vec2 grid = fract(5.0 * xy);\n    vec3 color = vec3(grid.xy, 0.0);\n    if (grid.x < 0.05 || grid.y < 0.05) {\n        color = vec3(1.0);\n    } else if (abs(grid.x - grid.y) < 0.05) {\n        color = vec3(1.0);\n    }\n    \n    \n    color = gamma(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 79], [81, 81, 136, 136, 695]], "test": "untested"}
{"id": "DtyyWt", "name": "Graphic", "author": "Gerych", "description": "gg", "tags": ["g"], "likes": 0, "viewed": 184, "published": 3, "date": "1700761058", "time_retrieved": "2024-07-30T17:20:56.140861", "image_code": "\nfloat plot(vec2 st, float pct)\n{\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\nfloat line(float x,float t)\n{\n    float value = mix(0.5,3.5,t);\n    \n    return 1.0 - pow(abs(x),value);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n\n    float t = (cos(iTime) + 1.0) * 0.5;\n  \n    float y = line(uv.x,1.0-t);\n    \n    uv.y = fragCoord.y/iResolution.y;\n     \n    float pct = plot(uv,y);\n \n    fragColor = vec4(vec3(pct),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 33, 33, 124], [125, 125, 154, 154, 231], [232, 232, 289, 289, 536]], "test": "untested"}
{"id": "dlyyD3", "name": "Multiscale neonTruchet w/paramUI", "author": "timmaffett", "description": "Fork of @jarble's A multiscale truchet weave pattern using triangle waves instead of trigonometric functions.\nSliders control paramters\nHorizontal controlVector x,y and z\nVertical controls logic of triangle wave (0-8)", "tags": ["font", "keyboard", "digits", "sliders", "widgets", "util"], "likes": 4, "viewed": 188, "published": 3, "date": "1700730508", "time_retrieved": "2024-07-30T17:20:57.074365", "image_code": "// Fork of \"Multiscale neon truchet\" by jarble. https://shadertoy.com/view/DtycDc\n// 2023-11-23 08:20:15\n\n\n#define triwave(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\n\nvec4 controlV;\n\nvec4 t1(vec2 c, vec2 p){\n    return triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )) * controlV);// vec4(13,31,7,3)); //vec4(22,7,5,0));\n}\n\nbool logicControl(int logic, vec4 t_, vec4 t1_, vec4 t3_) {\n //Lots of interesting patterns here!\n switch(logic) {\n    case 0:\n       return t3_.y>t1_.y;\n    case 1:\n       return t_.y>t_.x;   //good\n    case 2:\n       return t1_.y>t1_.z;\n    case 3:\n       return 1.-t_.z>t1_.y||1.-t_.y>t1_.x||1.-t_.x>t1_.z;  //good\n    case 4:\n      return t1_.y>t_.y||t1_.z>t_.z||t1_.x>t_.x;\n    case 5:\n      return t_.y<t1_.y;\n    case 6:\n      return t_.x>t1_.x&&t_.y<t1_.x;   //good v2 also\n    case 7:\n      return t_.z>.5||t_.y>.5||t_.z>.5;\n   }\n   // default:\n   // case 8:\n      return t1_.z>t_.z||t1_.y>t_.y||t1_.z>t_.z;  //good\n   \n}\n\nvec4 triangleWave(int iterations, vec2 I)\n{\n    vec2 p = (I/1e2+iTime);\n    vec4 t_ = t1(ceil(p),p);\n    vec4 t1_ = vec4(0.),\n    t3_ = vec4(0.);\n    float scale = 1.;\n    \n    for(int i = 0; i < iterations;i++){\n        t1_ = t1(ceil(p/scale),p/scale);\n        scale *= 2.;\n        t3_ = 1.-min(t_,t1_);\n        if(logicControl(int(controlV.a), t_, t1_, t3_ ) ) {\n          t_ = 1.-t1_;\n        }\n    }\n    return t3_;\n}    \n\n\n\n\n\n\n\n\n// Fork of \"digits/sliders/kbd widgets - 2\" by FabriceNeyret2. https://shadertoy.com/view/MdKGRw\n// 2023-11-23 08:06:54\n\n// ---- digits/sliders/kbd widgets utilities ----------------------------\n// if you use it, please let a link to this shader in comments\n// for others can get the full set (possibly updated and expended).\n\n// updated version of old  https://www.shadertoy.com/view/lsXXzN\n// ----------------------------------------------------------------------\n\n// define your sliders in BufA.  value [0,1]  = UI(i).a    , i=1..16\n// define your buttons in BufA.  value {-1,1} = UI(i+16).a , i=1..16\n// get mouse position enriched by demo-mode in UI(33)\n// get prev mouse position in UI(34) (e.g.: detect move, get velocity, direction...)\n\n// see below functions for\n// - reading the keyboard\n// - drawing sliders and buttons\n// - drawing floats and digits\n// - demoing the mouse states\n\n\n// --- keyboard -----------------------------------------------------\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\nbool keyClick(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\n\n\n// --- Digit display ----------------------------------------------------\n\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) { // dot: bit 0 = bottom dot; bit 1 = top dot\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nfloat display_digit(vec2 uv, float scale, float offset, int number, int dot) { // dot: draw separator\n\n\tuv = (uv-0.)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\n\t_offset = offset;\n\treturn seg;\n}\n\n// 2.2 float + sign\nfloat display_float(vec2 pos, float scale, float offset, float val) { // dot: draw separator\n\tif (display_digit( pos, scale, 0., int(val), 1)>0.) return 1.;\n    if (display_digit( pos, scale, _offset, int(fract(abs(val))*100.), 0)>0.) return 1.;\n\treturn 0.;\n}\n\n\n\n// --- sliders and mouse widgets -------------------------------------------\n\nvec2 R;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n\n// --------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = iResolution.xy;\n\tvec2 uv = fragCoord.xy/R.y;\n    vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float b = aff_buttons(uv); if (b>0.) { fragColor = b*vec4(0,0,1,1);  return;}}\n\n\t\n\t// display counters\n\tvec2 pos ; \n\tfloat scale = 0.04;\n\t\n    \n        \n    int param1 = int(UI(1).a*PARAM1_SCALE);\n    int param2 = int(UI(2).a*PARAM2_SCALE);\n    int param3 = int(UI(3).a*PARAM3_SCALE);\n    int param4 = int(UI(4).a*PARAM4_SCALE);\n \n    int param5 = int(UI(5).a*PARAM5_SCALE);\n    \n\tpos = vec2(.7,.25);    if (display_digit( uv-pos, scale, 0., param1, 0)>0.) { fragColor=vec4(1); return;}\n\tpos.y -= STEPY*scale*2.; if (display_digit( uv-pos, scale, 0., param2, 0)>0.) { fragColor=vec4(1); return;} \n\tpos.y -= STEPY*scale*2.; if (display_digit( uv-pos, scale, 0., param3, 0)>0.) { fragColor=vec4(1); return;}\n    \n    pos = vec2(.05, .64);\n    if (display_digit( uv-pos, scale, 0., param4, 0)>0.) { fragColor=vec4(1); return;} \n\n    pos = vec2(.12, .64);\n    if (display_digit( uv-pos, scale, 0., param5, 0)>0.) { fragColor=vec4(1); return;} \n\t //pos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., mod(iTime,60.))>0.) { fragColor=vec4(1); return;} \n\n  //  // display mouse states\n  //  fragColor = affMouse(uv); if (fragColor!=vec4(0)) return; \n\t \t\n        \n   controlV = vec4( param1, param2, param3, param4); //iMouse.x/10.0, iMouse.y/10.0, iMouse.x/100.0, iMouse.y/100.0 );\n    \n        \n    fragColor= triangleWave(param5, fragCoord.xy); \n    \n    \n    \n    \n    \n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 0 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.15,.25,HORIZ, .5, PARAM1_INITIAL_VALUE/PARAM1_SCALE); // --- define your sliders here ---\n        add_slider (.15,.15,HORIZ, .5, PARAM2_INITIAL_VALUE/PARAM2_SCALE); // read value [0,1] in UI(i).a  , i=1..16\n        add_slider (.15,.05,HORIZ, .5, PARAM3_INITIAL_VALUE/PARAM3_SCALE); // read value [0,1] in UI(i).a  , i=1..16\n\n        add_slider (.05,.15,VERTIC,.5,PARAM4_INITIAL_VALUE/PARAM4_SCALE);\n        add_slider (.10,.15,VERTIC,.5,PARAM5_INITIAL_VALUE/PARAM5_SCALE);\n        \n     //   add_button ( .8  ,.1,  1.);          // --- define your buttons here ---\n     //   add_button ( .9  ,.1, -1.);          // read value {-1,1} in UI(i+16).a , i=1..16\n    //    add_button ( 1.  ,.1, -1.);          \n    //    add_button ( 1.1 ,.1, -1.);       /   \n        \n        if (U==vec2(0,0)) O.xy = vec2(nbS, nbB);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)<10. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l/2.)<l/2. ) O.a = (M.x-S.x)/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l/2.)<l/2. ) O.a = (M.y-S.y)/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PARAM1_INITIAL_VALUE  22.0\n#define PARAM2_INITIAL_VALUE   7.0\n#define PARAM3_INITIAL_VALUE   5.0\n\n#define PARAM4_INITIAL_VALUE   0.0   //Logic 0-8\n#define PARAM5_INITIAL_VALUE   3.0   //Iterations\n\n\n#define PARAM1_SCALE  100.0        \n#define PARAM2_SCALE  100.0        \n#define PARAM3_SCALE  100.0        \n#define PARAM4_SCALE  9.0    \n#define PARAM5_SCALE  6.0    \n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 261, 261, 398], [400, 400, 459, 497, 1030], [1032, 1032, 1075, 1075, 1453], [2519, 2519, 2546, 2546, 2619], [2620, 2620, 2646, 2646, 2719], [2973, 2973, 3006, 3006, 3165], [3167, 3167, 3197, 3197, 3840], [3842, 3842, 3888, 3939, 4279], [4281, 4281, 4311, 4355, 4623], [4779, 4800, 4878, 4901, 5149], [5151, 5171, 5240, 5263, 5430], [5652, 5652, 5677, 5711, 6280], [6283, 6283, 6310, 6349, 6806], [6808, 6808, 6835, 6874, 7143], [7209, 7209, 7266, 7266, 8855]], "test": "untested"}
{"id": "mtyyWc", "name": "texture split rotation", "author": "jarkob", "description": "it's mouse reactive :-)", "tags": ["texture"], "likes": 4, "viewed": 210, "published": 3, "date": "1700728874", "time_retrieved": "2024-07-30T17:20:57.820370", "image_code": "// taken from https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centerCoord = vec2(0.5) * iResolution.xy;\n    \n    float dist = max(0.0, iResolution.y - distance(fragCoord, centerCoord));\n    \n    float rotation = round(dist * 0.02);\n    \n    float strength = distance(centerCoord, iMouse.xy) * (1.0 / iResolution.x);\n    \n    vec2 ruv = rotateUV(uv, rotation * strength, vec2(0.5,0.5));\n    \n    fragColor = texture(iChannel0, ruv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 130, 130, 313], [315, 315, 372, 372, 799]], "test": "untested"}
{"id": "DtycDc", "name": "Multiscale neon truchet (music)", "author": "jarble", "description": "A multiscale truchet weave pattern using triangle waves instead of trigonometric functions.", "tags": ["music", "truchet", "multiscale", "weave"], "likes": 5, "viewed": 363, "published": 3, "date": "1700714720", "time_retrieved": "2024-07-30T17:20:58.762850", "image_code": "const vec3 scales = vec3(\n   4.,4.,8.\n   //2.,2.,8.\n   //4.,2.,8.\n   //2.,2.,4.\n);\n\n#define triwave(p) abs(fract(.5+p/scales[0])-.5)*2.\n#define triwave1(p) (abs(fract(p/scales[1])-.5)-abs(fract(p/scales[2])-.5)/2.)\n\nvec4 t1(vec2 c, vec2 p){\n    return triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )) * vec4(22,7,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 p = (I/1e2+iTime);\n    vec4 t_ = t1(ceil(p),p);\n    vec4 t1_ = vec4(0.),\n    t3_ = vec4(0.);\n    float scale = 2.;\n    \n    for(int i = 0; i < 3;i++){\n        //p += mod((p+4.),8.);\n        t1_ = t1(ceil(p/scale),p/scale);\n        \n        //crazy psychedelic animation\n        //t1_ += triwave(iTime/8.+t3_);\n\n        scale *= 2.;\n        t3_ =\n            1.-min(t_,t1_);\n            //1.-min(t_.yzxw,t1_)\n        \n            //crazy psychedelic animation\n            //1.-min(t3_,t1(ceil(p/(scale)+t1_.y),p/(scale)+t1_.y-iTime));\n            //1.-min(t_,t1(ceil(p/(scale)+t1_.y-iTime),p/(scale)+t1_.y-iTime));\n        ;\n        \n\n        if(\n            //Lots of interesting patterns here!\n            t3_.y>t1_.y\n            //t3_.y-triwave1(iTime-p.x)>t1_.y-triwave1(iTime-p.y)\n            //t_.y>t_.x\n            //t1_.y>t1_.z\n            //1.-t_.z>t1_.y||1.-t_.y>t1_.x||1.-t_.x>t1_.z\n\n            //t1_.y>t_.y||t1_.z>t_.z||t1_.x>t_.x\n            //t_.y<t1_.y\n\n            //t_.x>t1_.x&&t_.y<t1_.x\n            //t_.z>.5||t_.y>.5||t_.z>.5\n            //t1_.z>t_.z||t1_.y>t_.y||t1_.z>t_.z\n        ) t_ =\n            1.-t1_\n            //t1_.yzxw\n        ;\n    }\n    O = t3_;\n}", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nfloat fibonacci(float nthNumber_) {\n        int nthNumber = int(nthNumber_);\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\n        for (int i = 1; i < nthNumber ; i++) {\n\n            previouspreviousNumber = previousNumber;\n\n            previousNumber = currentNumber;\n\n            currentNumber = previouspreviousNumber + previousNumber;\n\n        }\n        return float(currentNumber);\n}\n\nfloat m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/8.),8.); i++){\n        a += mod(floor(a/8.),b)*i;\n    }\n    */\n    return\n        mod(a,b)\n        //mod(a+floor((a/2.-b)/2.),b)\n        //mod(a+floor(a/2.),b)\n        //mod(a+floor(b*13./7.),b)\n        //floor(mod(floor(a+floor(a)/8.),b))\n        //mod(a-fibonacci(a/32.),b)\n        //mod(a+mod(a-mod(a,3.),5.)+mod(a+mod(a,5.),3.),b)\n        //mod(a-mod(a-mod(a,5.),3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n\n    //a = (a/2. + floor(a))/4.;\n    \n    //a -= fibonacci(a/64.);\n    \n    //a += float(int(a)>>int(b));\n    //a += floor(a/4.);\n    //a += fibonacci(mod(a,8.));\n    //a += m1(a,1.+b*b,4.);\n    //a += m1(a,5.+b,3.+b);\n    //a += float(fibonacci(int(mod(a,8.))));\n\n    //a += abs(mod((a),3.)-mod((a),5.));\n    //a += 2.*floor(1.+mod(floor(a/2.),2.))/(1.+mod(floor(a/4.),2.));\n    //a -= mod(floor(a/2.)/2.,2.)*2.;\n    float m1 = floor(mod1(b/2.,2.));\n    \n    a +=\n        //floor(mod(b/2.,2.))+mod(floor(a+3.),4.-b)\n        m1\n        //floor(mod(b/2.,2.))\n        //mod(b/2.+binary_digit(int(a),1),2.)\n        //mod((b/2.+floor(a/4.)),4.)\n    ;\n    float\n    a2 = mod1(floor(a),b),\n    a3 =\n        mod1(floor(a/(b)),b)\n        //mod1(floor(a/4.),b)\n        //mod1(floor((a+floor((b*3.+m1)/4.))/(b)),b)\n        //mod1(floor(floor(a/4.)*b/4.+(a2)/(b)),b)\n    ;\n    \n    //a -= mod(floor(a+b),3.);\n    //a += m1(a,5.+b,3.+b);\n    \n    //a += m1(a,3.,7.);\n    \n    //a += mod(-a*2.,2.)/2.;\n    return\n        //mod1(a2*a3,b)\n        mod1(a2*(a3+floor(a/4.*sign(a2-a3))),b)\n        //mod(floor((1.+a3)/(1.+a2)),b)\n        //mod(-mod(-floor(a),b)*mod(-floor((a)/b),b),b)\n        //mod(floor(a-mod(a,3.)),b)\n        //floor(mod(a/floor(1.+mod(-a/2.+b,2.)),b))\n        //floor(mod(mod(floor(a)/(1.+mod(floor(-a/2.),2.)),b)*mod(floor((a)/b),b),b))\n        //floor(mod((a/(1.+mod(floor(-a/2.),2.))),b))\n        //floor(mod(mod(floor(a),b)*mod(a/b,b),b))\n        //floor(mod(mod(floor(a),2.)+mod(a/2.,6.),b))\n        //mod(floor(mod(a,8./b))*3.,b)\n        //floor(mod(mod(a,1.+abs(mod(a,5.)-mod(a,3.))),b))\n        //mod(floor(floor(a)/1.5)+floor(floor(a)/2.),b)\n        //floor(mod(mod(floor(a/2.)*3.,b)*mod(floor(a/2.)*5.,b),b))\n        //floor(mod(mod(floor(a)*3.,b/3.+3.)*mod(floor(a)*5.,b/5.+5.),b))\n        //mod(mod(floor(a)+2.,b)*mod(floor((a/2.)/b),b)+2.,b)\n        //floor(mod(mod(floor(a)/b,b)*mod(floor((a)/b)+2.,b)+2.,b))\n        //floor(mod((mod(floor(a),b))*mod(floor(a/b*2.)/2.,b),8.))\n    ;\n}\n\n\nfloat prime_rhythm(float time){\n    \n    //time += mod(time/8.,5.) - mod(time/8.,3.);\n    \n    //time = (time/2. + floor(time))/4.;\n    \n    //time += fibonacci(mod(time/8.,8.));\n    \n    return\n        (1.+fmod(time/5.,2.))/(1.+fmod(time/3.,2.))\n        //(1.+fmod(time/8.,2.))/(1.+fmod(time/4.,2.))\n        //(1.+fmod(time/5.,2.))/(1.+fmod(-time/3.,2.))\n    ;\n    //return (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))/(1.+fmod(time/5.,2.))/(1.+fmod(time/7.,2.))*(1.+fmod(time/11.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //change the notes without changing the rhythm\n    //a += mod(-b/2.,2.);\n    //a += prime_rhythm(a);\n    return\n        fmod(a,b)\n        //fmod(a,b-fmod(a/2.,2.))\n        //fmod(floor(a)*5.,b+fmod(floor(a/8.)*3.,b))\n    ;\n}\n\n//#define fract1(a) pow(fract(a),2.)\n//#define fract1(a) pow(fract(a),1.+fract(a))\n#define fract1(a) (1.-fract(-a)*fract(-a))\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),3.)\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 flute(vec2 a, vec2 nb){\nreturn a*a/16./4.*((.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +((1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 note1(vec2 rhythm,float attack,float duration){\nreturn vec2(\n      //(-log(attack+.5/duration*fract1(rhythm.x))),(-log(attack+.5/duration*fract1(rhythm.y)))\n      //-log(attack+.25*fract1(rhythm.y))*duration/2.\n      -log(attack+.25/duration*fract1(rhythm.y))\n  );\n}\n\nvec2 sitar0(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 instrument1(vec2 a,vec2 nb,int instrument){ \n  vec2 sitar = \n  sitar0(a,nb)\n  //a/16./2.*abs(log(1./4.+a*abs(1./4.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  //-log(1./4.+a*abs(abs(vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,\n  \n  gamelan =\n      flute(a,nb)\n      //sitar3(a,nb)\n  //    a/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  //+.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,\n  \n  steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  \n  ,oud = a/16./8.*abs(log(1./4.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n\n  ,banjo = a/16./8.*abs(log(1./2.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  -log(1./2.+a*abs(abs(1./2.-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n\n  ,harp = a/16./2.*abs(log(1./8.+a*abs(1./4.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./8.+a*abs(abs(1./4.-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.))) \n\n  \n  \n  ;\n  //instrument = 1+int(fmod(time/4.+float(instrument),2.));\n  switch(instrument){\n  case 1: return gamelan;\n  case 2: return oud;\n  case 3: return steel_drum;\n  case 4: return sitar;\n  case 5: return harp;\n  case 6: return banjo;\n  default:\n  return\n      //gamelan\n      oud\n      //steel_drum\n      //sitar\n      //hurdy-gurdy\n      //(abs(log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n\n      //log(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a)\n      \n      //abs(log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      //abs(1.+log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      \n      //log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.)))))\n  ;\n}\n}\n\nvec2 instrument2(vec2 a,vec2 nb,int instrument){\n      return\n      //instrument1(a,nb,instrument)\n      instrument1(a,nb,instrument) - instrument1(a,nb/2.,instrument)/2.\n      //instrument1(a,nb,instrument)+instrument1(a,nb/2.,4)\n      ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument,float duration){\n  \n  //duration /= (1.+fmod(time,2.));\n  float s1 =\n      8.,\n  tempo1 =\n      //1.\n      //divide by prime numbers to get an interesting rhythm\n      prime_rhythm(time)\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6+mod(t6/8.,3.)-mod(t6/8.,2.),s1/2.)/2.),\n      //floor(fmod(t6+floor(t6/8.),s1/2.)/2.),\n      //floor(2.*fmod(floor(t6)*3.,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.)\n  ,attack=1./64.*8.;\n  vec2\n  rhythm=\n      //t*vec2(1./2./prime_rhythm(time+14.),1./prime_rhythm(time+7.))\n      t*vec2(1./prime_rhythm(time+7.))\n  ,a=\n      note1(rhythm,attack,duration)\n      //(note1(rhythm,attack,duration)-note1(rhythm,attack/2.,duration*2.)/4.)\n      //note1(rhythm/2.,attack,duration)\n  ,\n  nb = vec2(\n      t*pow(2.,(m3+m2-t1*4.)/7.+scale)*tempo1\n      //t*pow(2.,(m3-m2*2.+t1)/7.+6.5)*tempo1\n      \n      //airhorn remix\n      //abs(t*(pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/2.)-a/16.)*2.\n  ),\n  nb1 = vec2(t*pow(2.,(4.+t1*4.)/7.+scale))*tempo1\n  ;\n  \n  return\n      //gamelan\n      //instrument1(a,nb,instrument)-instrument1(a,nb*2.,instrument)\n      \n      //gamelan\n      //4.*(instrument2(a,nb,instrument)-instrument2(a,nb/2.,instrument)/2.)\n      instrument2(a*a,nb,instrument)-instrument2(a*a,nb/2.,instrument)/2.\n\n      \n      //sitar\n      //(instrument2(a,nb,instrument)+instrument2(a,nb/2.,4))\n      \n      \n      //instrument1(a,nb,instrument)+instrument1(a,nb/2.,instrument)\n      //instrument1(a,nb,instrument)-instrument1(a/2.,nb*2.,1)\n      //instrument1(a,nb,instrument)+instrument1(note1(rhythm/2.,attack*2.,duration/4.),nb1*2.,1)\n  ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument){\n    return mainSound1(samp, time,scale,instrument,2.);\n}\n\nvec2 mainSound(int a,float b){\n    //b += mainSound1(a,b,5.5,1,2.).x/128.;\n    return\n        //sitar\n        //2.*(mainSound1(a,b,6.-3./7.,1,2.)-mainSound1(a,b,7.-3./7.,4,1.)*2.)\n        \n        //gamelan\n        //2.*(mainSound1(a,b,6.5,1)+mainSound1(a,b+8.,5.5,1)/2.+mainSound1(a,b+16.,4.5,1)/4.)\n        (2.*mainSound1(a,b,6.5,1,2.)-mainSound1(a,b,5.5,1,1.))\n                \n\n        //drum\n        //8.*mainSound1(a,b,3.,4,8.)*mainSound1(a,b,3.,1,8.)\n        \n        //mainSound1(a,b,6.,6)\n        \n        //sounds like a tabla drum\n        //mainSound1(a,b,5.5,1,1.)/2.\n        \n        //(mainSound1(a,b,5.5,4,1.)-mainSound1(a,b,6.5,4,2.)/4.)\n        //((mainSound1(a,b,5.5,4,1.))-(mainSound1(a,b,6.5,4,2.)))\n        \n        //mainSound1(a,b,5.,4,1.) - mainSound1(a,b,6.,4,2.) - mainSound1(a,b,6.,4,1.)/2.\n                \n        //mainSound1(a,b,6.,4,2.)-mainSound1(a,b,5.,1,1.)\n        \n        //(mainSound1(a,b,6.5,4,1.)/2.-mainSound1(a,b,5.5,4,2.))\n        //(mainSound1(a,b,6.5,4,2.)-mainSound1(a,b,5.5,4,2.)/2.-mainSound1(a,b,4.5,4,2.)/4.)\n        //(mainSound1(a,b,5.5,4,1.)/2.-mainSound1(a,b,5.5,4,2.))\n        //2.*(mainSound1(a,b,5.5,4,1./2.)/2.-mainSound1(a,b,5.5,4,1.))\n        \n\n        \n        //8.*(mainSound1(a,b,5.5,1,4./3.)-mainSound1(a,b,6.5,1,4./3.))\n        //((mainSound1(a,b,6.5,4,1.))/2.+(mainSound1(a,b,5.5,4,1.)))\n\n        //(mainSound1(a,b/2.,8.)+mainSound1(a,b,7.)/2.+mainSound1(a,b*2.,6.)/4.+mainSound1(a,b*4.,5.)/8.)\n        //(mainSound1(a,b,6.5)+mainSound1(a,b/2.,7.5)+mainSound1(a,b/4.,8.5))\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtycDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 240, 240, 344], [346, 346, 382, 382, 1574]], "test": "untested"}
{"id": "mlVcWV", "name": "back off, normals.", "author": "elenzil", "description": "A simple change which improves normal 'pop' along sharp edges of the SDF.\ntop: Ordinary\nbot: With \"Normal BackOff\"\nright: pixelated\n", "tags": ["raymarching", "normals", "artifacts"], "likes": 11, "viewed": 269, "published": 3, "date": "1700709880", "time_retrieved": "2024-07-30T17:20:59.516834", "image_code": "/*\n\n    back off, normals\n    -----------------\n    \n    A simple technique which improves the glittery pop on some sharp edges.\n    The idea is that when choosing a point at which to sample the normal\n    of the SDF, back up a little but along the ray instead of using the\n    march point closest to the surface.\n    \"A little\" is on the order of your \"close enough\" epsilon for marching.\n    \n    This doesn't eliminate all 'popping' for me,\n    but it's a trivial change and it eliminates some of it.\n    \n    Theory: IANARME˟, but the thought I had was that right at these\n    surface boundaries the gradient is discontinuous,\n    so sample it 'farther away' from the surface.\n    Going 'farther away' by moving backwards along the ray seems like\n    a safe direction to move in, because we just raymarched along the ray,\n    so we know the SDF is getting larger in that direction.\n    \n    Orion Elenzil 20231122\n    \n    \n    ˟ i am not a ray marching expert\n*/\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gSceneCenterY  = 3.0;\nconst float gFOVFac        = 0.3;\n\nconst uint  gMarchMaxSteps = 150u;\nconst float gMarchEps      =   0.002;\nconst float gNormEps       = gMarchEps * 0.1;\n      float gNormBackoff   = gMarchEps * 1.0;\n\nconst vec3  gLightDir      = normalize(vec3(3.0, 0.1, 4.0));\nconst vec3  gAmbient       = v1 * 0.05;\nconst float reflectAmt     = 0.05;\n      float gT;\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    return mix(vec3(1.0, 0.9, 0.8), vZ * 0.5, pow(rd.y, 0.3));\n}\n\nvec3 albedo(in vec3 p) {\n    if (p.y < gMarchEps) {\n        return v1;\n    }\n    if (p.x > 0.0) {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else {\n        return vec3(0.0, 1.0, 1.0);\n    }\n}\n\nfloat sdScene(in vec3 p) {\n    float d = 1e9;\n    \n    float rad = gSceneCenterY;\n    \n    p.xz *= rot2(gT);\n    \n    vec3 q = p - vY * rad;\n    opUnn(d, sdCyl   (q.zy, rad));\n    opSub(d, sdCyl   (q.zy, rad * 0.8));\n    opInt(d, sdSphere(q   , rad * 2.5));\n    opSub(d, sdShell (q   , rad * 2.0, 1.0));\n    opSub(d, sdShell (q   , rad * 1.5, 1.0));\n    opSub(d, sdShell (q   , rad * 1.0, 1.0));\n    \n    return d;\n}\n\n// ∇(sdScene())\nvec3 gradScene(in vec3 p) {\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * gNormEps) - d,\n        sdScene(p + vY * gNormEps) - d,\n        sdScene(p + vZ * gNormEps) - d\n    );\n}\n\nvec3 normScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    \n    float t = 0.0;\n    for (uint n = 0u; n < gMarchMaxSteps; ++n) {\n        vec3  p = ro + rd * t;\n        float d = sdScene(p);\n        if (d < gMarchEps) {\n            // a hit\n            return t;\n        }\n        t += d;\n        if (t > 1e2) {\n            // too far away\n            return 1e9;\n        }\n    }\n    \n    return 1e9;\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd) {\n    float t = 1e9;\n    opUnn(t, march(ro, rd));\n    opUnn(t, rayVsPlane(ro, rd, vY, 0.0));\n    return t;\n}\n\nvec3 runRaySegment(in vec3 ro, in vec3 rd, out vec3 p, out vec3 n) {\n    float t = rayVsScene(ro, rd);\n    \n    if (t > 1e4) {\n        p = v1 * 1e9;\n        return sky(ro, rd);\n    }\n    \n    vec3 rgb = v0;\n    \n    p        = ro + rd * t;\n    // floor is not part of SDF, so we cheat\n    if (p.y < gMarchEps) {\n        n = vY;\n    }\n    else {\n        n        = normScene(p - rd * gNormBackoff);\n    }\n    vec3 alb = albedo(p);\n    \n    rgb += gAmbient * alb;\n    float diffuseAmt = max(0.0, dot(n, gLightDir));\n    if (diffuseAmt > 0.0) {\n        float tShadow = rayVsScene(p + n * gMarchEps * 2.0, gLightDir);\n        if (tShadow > 1e4) {\n            rgb += alb * diffuseAmt;\n        }\n    }\n    \n    return rgb;\n}\n\nvec3 runRay(in vec3 ro, in vec3 rd) {\n    uint bouncesLeft = 4u;\n    \n    float rayAmt = 1.0;\n    \n    vec3 rgb = v0;\n    \n    while (bouncesLeft > 0u) {\n        vec3 p, n;\n        \n        vec3 c = runRaySegment(ro, rd, p, n);\n        \n        if (p.x < 1e8) {\n\n            rgb += c * rayAmt * (1.0 - reflectAmt);\n\n            // no fresnel\n            rayAmt *= reflectAmt;\n            ro = p + n * gMarchEps * 2.0;\n            rd = reflect(rd, n);\n\n            bouncesLeft -= 1u;\n        }\n        else {\n            rgb += c * rayAmt;\n            bouncesLeft = 0u;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    bool isUpperHalf = XY.y * 2.0 > RES.y;\n    if (isUpperHalf) {\n        gNormBackoff = 0.0;\n    }\n    bool isRightHalf = XY.x * 2.0 > RES.x;\n    vec2 xy = XY;\n    if (isRightHalf) {\n        const float pixelate = 5.0;\n        xy = round(XY / pixelate) * pixelate;\n    }\n\n    gT     = iTime * pi / 30.0;\n    const float zoom = 1.0;\n    vec2 p = (xy        * 2.0 - RES) / MINRES / zoom;\n    vec2 m = (iMouse.xy * 2.0 - RES) / MINRES / zoom;\n    if (iMouse.x < 20.0) {\n        m = vec2(-0.8, 0.5);\n    }\n    \n    // compose ray\n    vec3 lf = vec3(0.0, 5.0, 20.0);\n    lf.yz  *= rot2(smoothstep(1.0, -1.0, m.y) - 0.2);\n    lf.xz  *= rot2(smoothstep(1.0, -1.0, m.x) * pi * 3.0);\n    vec3 lt = vY * gSceneCenterY;\n    vec3 fw = normalize(lt - lf);\n    vec3 rt = normalize(cross(fw, vY));\n    vec3 up = cross(rt, fw);\n    vec3 ro = lf;\n    vec3 rd = normalize(fw + (rt * p.x + up * p.y) * gFOVFac);\n    \n    vec3 rgb = runRay(ro, rd);\n    \n    float splitsD = 1e9;\n    opUnn(splitsD, abs(RES.y / 2.0 - XY.y));\n    opUnn(splitsD, abs(RES.x / 2.0 - XY.x));\n    rgb = mix(rgb, vY * 0.4, smoothstep(2.0, 0.0, splitsD));\n    \n    RGBA.rgb = pow(rgb, vec3(1.0 / 1.8));\n    RGBA.a   = 1.0;\n}", "image_inputs": [], "common_code": "const vec3  vX = vec3(1, 0 ,0);\nconst vec3  vY = vX.yxy;\nconst vec3  vZ = vX.yyx;\nconst vec3  v0 = vX.yyy;\nconst vec3  v1 = vX.xxx;\n\nconst float pi = 3.14159265359;\n\n//--------------------------------------------------------------------------------\n\n// A = ∪(A, B)\nvoid opUnn(inout float A, in float B) {\n    A = min(A, B);\n}\n\n// A = A - B\nvoid opSub(inout float A, in float B) {\n    A = max(A, -B);\n}\n\n// A = ∩(A, B)\nvoid opInt(inout float A, in float B) {\n    A = max(A, B);\n}\n\n//--------------------------------------------------------------------------------\n\nmat2  rot2    (float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\n//--------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 p, in float r) { return length(p) - r; }\nfloat sdCyl   (in vec2 p, in float r) { return length(p) - r; }\nfloat sdShell (in vec3 p, in float r, in float t) {\n    float d  = length(p);\n    float d1 = d - (r + t / 2.0);\n    float d2 = d - (r - t / 2.0);\n    opSub(d1, d2);\n    return d1;\n}\n\n\n//--------------------------------------------------------------------------------\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) { float t = -(dot(ro, n) + d) / (dot(rd, n)); if (t < 0.0) { t = 1e9; } return t; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1427, 1427, 1461, 1461, 1526], [1528, 1528, 1552, 1552, 1722], [1724, 1724, 1750, 1750, 2140], [2142, 2160, 2187, 2187, 2358], [2360, 2360, 2387, 2387, 2425], [2427, 2427, 2464, 2464, 2810], [2812, 2812, 2854, 2854, 2961], [2963, 2963, 3031, 3031, 3681], [3683, 3683, 3720, 3720, 4290], [4292, 4292, 4335, 4335, 5515]], "test": "untested"}
{"id": "clGyWc", "name": "CIRCLES CIRCLES CIRCLES CIRCLES", "author": "roff", "description": " ", "tags": ["drugs"], "likes": 1, "viewed": 169, "published": 3, "date": "1700707144", "time_retrieved": "2024-07-30T17:21:00.269821", "image_code": "vec3 rgb( in vec3 vec )\n{\n    return vec3(vec.x / 255.0, vec.y / 255.0, vec.z / 255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = cos(length(uv)) * iTime * 10.0;\n    dist = sin(dist * 10.0 + iTime) / 10.0;\n    dist = (pow(abs(sin(iTime)), 4.0) * 0.1 + .05) / dist;\n\n    fragColor = vec4(dist, dist * abs(cos(iTime * 0.25)), abs(sin(iTime * 0.5)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 89], [91, 91, 148, 148, 505]], "test": "untested"}
{"id": "DlycD3", "name": "Mitchell-Netravali <-> Bezier", "author": "FordPerfect", "description": "Conversions between control points.\n\nMitchell-Netravali in blue.\nBezier in red.", "tags": ["bezier", "mitchell"], "likes": 3, "viewed": 195, "published": 3, "date": "1700706918", "time_retrieved": "2024-07-30T17:21:01.066690", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// It is moderately well-known that there is a simple way to convert\n// the control points  between Bezier and Catmull-Rom cubic splines:\n//     Bezier3   (P0,P1,P2,P3,t)=CatmullRom(P3-6*(P1-P0),P0,P3,P0+6*(P3-P2),t)\n//     CatmullRom(P0,P1,P2,P3,t)=Bezier3   (P1,P1+(P2-P0)/6,P2-(P3-P1)/6,P2,t)\n// Here, this result is extended to arbitrary (provided (2*B-3)*(B+2*C)!=0)\n// Mitchell-Netravali splines.\n// Only uniform (equally-spaced) splines are considered. Extension to non-uniform\n// splines is left as an exercise to the reader.\n\n// NOTE: the example is 1-dimensional, and x-coordinate corresponds to the\n// interpolation parameter. As such, x-position of control points is somewhat arbitrary,\n// and can be misleading. The positions are:\n//     Control point    Mitchell-Netravali     Bezier\n//     P0                -1                     0\n//     P1                 0                     1/3\n//     P2                 1                     2/3\n//     P3                 2                     1\n\n// See also:\n//     https://splines.readthedocs.io/en/latest/euclidean/\n//         https://splines.readthedocs.io/en/latest/euclidean/catmull-rom-uniform.html#Using-B%C3%A9zier-Segments\n//         https://splines.readthedocs.io/en/latest/euclidean/bezier-de-casteljau.html#Cubic-B%C3%A9zier-to-Hermite-Segments\n//     https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf\n//     https://0xef.wordpress.com/2013/01/12/third-order-texture-filtering-using-linear-interpolation/\n\n#define Point float // 1D example, but can be any dimension.\n\nPoint spline3_Mitchell_Netravali(float B,float C,Point P[4],float t)\n{\n    // See https://www.shadertoy.com/view/Dlc3Rn\n    vec4 w=mat4( // NOTE: column-major.\n\t\tB/6.0      , 1.0-B/3.0   , B/6.0           , 0.0    ,\n\t\t-C-0.5*B   , 0.0         , C+0.5*B         , 0.0    ,\n\t\t2.0*C+0.5*B, C+2.0*B-3.0 , -2.0*C-2.5*B+3.0, -C     ,\n\t\t-C-B/6.0   , -C-1.5*B+2.0, C+1.5*B-2.0     , C+B/6.0)*vec4(1.0,t,t*t,t*t*t);\n    return\n        w[0]*P[0]+\n        w[1]*P[1]+\n        w[2]*P[2]+\n        w[3]*P[3];\n}\n\nPoint spline3_Bezier(Point P[4],float t)\n{\n    // See https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n    Point Q0=mix(P[0],P[1],t);\n    Point Q1=mix(P[1],P[2],t);\n    Point Q2=mix(P[2],P[3],t);\n    Point R0=mix(Q0,Q1,t);\n    Point R1=mix(Q1,Q2,t);\n    return mix(R0,R1,t);\n}\n\n// Bezier -> Catmull-Rom conversion.\n// NOTE: same as b2mn(0.0,0.5,P,Q).\nvoid b2cr(float B,float C,in Point P[4],out Point Q[4])\n{\n    Q[0]=P[3]-6.0*(P[1]-P[0]);\n    Q[1]=P[0];\n    Q[2]=P[3];\n    Q[3]=P[0]+6.0*(P[3]-P[2]);\n}\n\n// Catmull-Rom -> Bezier conversion.\n// NOTE: same as mn2b(0.0,0.5,P,Q).\nvoid cr2b(float B,float C,in Point P[4],out Point Q[4])\n{\n    Q[0]=P[1];\n    Q[1]=P[1]+(P[2]-P[0])/6.0;\n    Q[2]=P[2]-(P[3]-P[1])/6.0;\n    Q[3]=P[2];\n}\n\n// Bezier -> Mitchell-Netravali conversion.\n// NOTE: suffers from division by zero, when B=1.5, or C=-B/2,\n// both of which are uncommon.\nvoid b2mn(float B,float C,in Point P[4],out Point Q[4])\n{\n    float D=1.0/((2.0*B-3.0)*(B+2.0*C));\n    Q[0]=D*(B*(2.0*C*P[3]-3.0*P[2]-12.0*P[1])-6.0*C*P[3]+B*B*(P[2]+P[1])+18.0*P[1]+(B*(2.0*C+12.0)-18.0)*P[0]);\n    Q[1]=D*(B*(2.0*C*P[3]-3.0*P[1])+B*B*(P[2]+P[1])+(2.0*B*C-6.0*C)*P[0]);\n    Q[2]=D*(B*(2.0*C*P[3]-3.0*P[2])-6.0*C*P[3]+B*B*(P[2]+P[1])+2.0*B*C*P[0]);\n    Q[3]=D*(B*(2.0*C*P[3]+12.0*P[3]-12.0*P[2]-3.0*P[1])-18.0*P[3]+B*B*(P[2]+P[1])+18.0*P[2]+(2.0*B*C-6.0*C)*P[0]);\n}\n\n// Mitchell-Netravali -> Bezier conversion.\nvoid mn2b(float B,float C,in Point P[4],out Point Q[4])\n{\n    Q[0]=(B/6.0)*P[0]+(1.0-B/3.0)*P[1]+(B/6.0)*P[2];\n    Q[1]=(B/6.0)*P[0]+(1.0-B/3.0)*P[1]+(B/6.0)*P[2]+((B+2.0*C)/6.0)*(P[2]-P[0]);\n    Q[2]=(B/6.0)*P[1]+(1.0-B/3.0)*P[2]+(B/6.0)*P[3]-((B+2.0*C)/6.0)*(P[3]-P[1]);\n    Q[3]=(B/6.0)*P[1]+(1.0-B/3.0)*P[2]+(B/6.0)*P[3];\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float t=0.1*iTime;\n    float B=0.5+0.5*sin(0.1*t),C=0.5+0.5*cos(0.17*t);\n    Point P[4],Q[4],R[4];\n    P[0]=Point(0.25*sin(1.3*t+0.0));\n    P[1]=Point(0.25*sin(1.1*t+1.0));\n    P[2]=Point(0.25*sin(1.7*t+2.0));\n    P[3]=Point(0.25*sin(1.5*t+3.0));\n    // Convert to Bezier.\n    mn2b(B,C,P,Q);\n    /// And back.\n    b2mn(B,C,Q,R);\n    vec3 col=vec3(0.125);\n    // Show control points.\n    col+=vec3(0.25,0.5,0.25)*smoothstep(0.03,0.02,length(xy-vec2(-1.5,P[0])));\n    col+=vec3(0.25,0.5,0.25)*smoothstep(0.03,0.02,length(xy-vec2(-0.5,P[1])));\n    col+=vec3(0.25,0.5,0.25)*smoothstep(0.03,0.02,length(xy-vec2(+0.5,P[2])));\n    col+=vec3(0.25,0.5,0.25)*smoothstep(0.03,0.02,length(xy-vec2(+1.5,P[3])));\n    col+=vec3(0.5,0.25,0.25)*smoothstep(0.03,0.02,length(xy-vec2(-0.5,Q[0])));\n    col+=vec3(0.5,0.25,0.25)*smoothstep(0.03,0.02,length(xy-vec2(-1.0/6.0,Q[1])));\n    col+=vec3(0.5,0.25,0.25)*smoothstep(0.03,0.02,length(xy-vec2(+1.0/6.0,Q[2])));\n    col+=vec3(0.5,0.25,0.25)*smoothstep(0.03,0.02,length(xy-vec2(+0.5,Q[3])));\n    col+=vec3(0.25,0.25,0.5)*smoothstep(0.03,0.02,length(xy-vec2(-1.5,R[0])));\n    col+=vec3(0.25,0.25,0.5)*smoothstep(0.03,0.02,length(xy-vec2(-0.5,R[1])));\n    col+=vec3(0.25,0.25,0.5)*smoothstep(0.03,0.02,length(xy-vec2(+0.5,R[2])));\n    col+=vec3(0.25,0.25,0.5)*smoothstep(0.03,0.02,length(xy-vec2(+1.5,R[3])));\n    // Show splines.\n    float c=0.25+0.5*step(abs(xy.x),0.5);\n    float d=xy.y-spline3_Mitchell_Netravali(B,C,P,xy.x+0.5);\n    col+=c*vec3(0.25,0.5,0.25)*exp(-1e4*d*d);\n    d=xy.y-spline3_Bezier(Q,xy.x+0.5);\n    col+=c*vec3(0.5,0.25,0.25)*exp(-1e4*d*d);\n    d=xy.y-spline3_Mitchell_Netravali(B,C,R,xy.x+0.5);\n    col+=c*vec3(0.25,0.25,0.5)*exp(-1e4*d*d);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycD3.jpg", "access": "api", "license": "public-domain", "functions": [[1645, 1645, 1715, 1764, 2140], [2142, 2142, 2184, 2252, 2426], [2428, 2501, 2558, 2558, 2652], [2654, 2727, 2784, 2784, 2878], [2880, 3018, 3075, 3075, 3498], [3500, 3544, 3601, 3601, 3871], [3873, 3873, 3927, 3927, 5802]], "test": "untested"}
{"id": "mlVyDK", "name": "VNoise Xor Cells", "author": "Dain", "description": "Xor's 4 value noises to create a cell like \nxor from jt's:  https://www.shadertoy.com/view/ssG3WK#\nTook my shader  and replaced geometric average with xor 4:  https://www.shadertoy.com/view/WtfSDS \n\nleft: 1 sample\nright: 4 octaves fbm", "tags": ["2d", "noise", "xor", "cellular"], "likes": 3, "viewed": 129, "published": 3, "date": "1700702182", "time_retrieved": "2024-07-30T17:21:01.906446", "image_code": "/*\nXor's 4 value noises to create a cell like structure --by exploiting the 4 texture channels available to get 4 value noises and convert to something vaguely cell-like\n\nxor from jt's https://www.shadertoy.com/view/ssG3WK#\n\nTook my old shader  https://www.shadertoy.com/view/WtfSDS and replaced geometric average with xor 4\n\nXor should produce a better distance field than geo avg(as long as not too much smooth xor )\n\nIf you turn off the smoothing it looks fairly similiar to goe avg shader--although darker since xor always picks the value closer to 0\n\n*/\n\n//use fade curve? Makes it rounder but I don't like the look as much for fbm\n#define SMOOTH_CELL\n\n//uncomment to use smoth xor rather than hard xor\n#define USE_SMOOTH_XOR \n\n//Offset position by prior octave to get some flow\n#define FLOW_STRENGTH 2.0\n\n\n//smin attempt:  adjusted for smooth xor so that it transitions between + and - space smoothly\n//the problem is smin with a and b both being 0 does not return 0\n//a and b need to be positive\nfloat smin_xor(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    //a fade so we get smooth transition for sxor between + and - space\n    //..this might cause rate of change to be > 1-- oh well for now.. at least it is very close to surface\n    float f = min(min(a,b)/r,1.0);\n\n   //slow down the transition to hard \n   f = (f+f)-f*f;\n   \n    return min(a, b)- e*e* (1.0/(r*4.0)) *f;\n}\n\nfloat sgn(float a){\n    return a >=0.0 ? 1.0 : -1.0;\n}\n//smooth xor https://www.shadertoy.com/view/ctyyzd\n//radius of 0 is invalid\nfloat sxor(float a, float b, float r){\n    //see IQ article: https://iquilezles.org/articles/sdfxor/\n    //where he shows it can be written this way\n     return sgn(a)*sgn(b)*smin_xor(abs(a), abs(b),r );\n}\n\n//jt's https://www.shadertoy.com/view/ssG3WK#\nfloat xor(float a, float b)\n{\n    return max(min(a, b), -max(a, b));\n}\n\nfloat xor4(vec4 a){\n float x = xor(a.x, a.y);\n float y = xor(a.z, a.w);\n return xor(x,y);\n}\n\nfloat sxor4(vec4 a, float r){\n float x = sxor(a.x, a.y, r);\n float y = sxor(a.z, a.w, r);\n return sxor(x,y,r);\n}\n\nfloat sqr(float a){return a*a;}\n\n\nfloat VNoiseCell( in vec2 p )\n{\n#ifndef SMOOTH_CELL\n    vec2 uv = p;\n#else\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    vec2 uv = i + u+.5;\n#endif\n    \n    //Fetch 4 value noises--\n    vec4 r = texture(iChannel0, uv*(1.0/256.0)).rgba*2.0-1.0;\n    \n#ifdef USE_SMOOTH_XOR\n   float d =sxor4(r, 0.25);\n#else\n  float  d = xor4(r);\n#endif\n\n    //better distance field, but since xor tends toward 0 this looks rather too dark for display reasons\n    //but this is probably what you would use if you wanted an sdf\n   // return abs(d)*2.0-1.0;\n\n   d = abs(d);\n   d = (d+d)-d*d;//fade up to make it brighter\n   return d*2.0-1.0;\n\n}\n\n// -----------------------------------------------\n//Render code taken from IQ value noise https://www.shadertoy.com/view/lsf3WH\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\n    float split = .4;\n    // left: value noise\t\n\tif( p.x<split )\n\t{\n\t\tf = VNoiseCell( 8.0*uv );\n\t}\n    // right: fbm - fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= (6.0 + sin(iTime*.25+9.0)*4.0);\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        float flow = sin(iTime*0.1+5.0)*1.0 + FLOW_STRENGTH;\n        #if 0\n\t\tf  = 0.5000*VNoiseCell( uv ); uv = m*uv;\n\t\tf += 0.2500*VNoiseCell( uv +f*flow); uv = m*uv;\n\t\tf += 0.1250*VNoiseCell( uv +f*flow); uv = m*uv;\n\t\tf += 0.0625*VNoiseCell( uv +f*flow); uv = m*uv;\n        #else\n        \n       \tfloat f1  = VNoiseCell( uv ); uv = m*uv;\n\t\tfloat f2 = VNoiseCell( uv +f1*flow); uv = m*uv;\n\t\tfloat f3= VNoiseCell( uv +f2*flow); uv = m*uv;\n\t\tfloat f4 = VNoiseCell( uv +f3*flow); uv = m*uv;\n        \n        f = f1 *.5 + f2*.25 + f3*.125 + f4*0.0625;\n        #endif\n        \n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-split) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[812, 1003, 1046, 1046, 1413], [1415, 1415, 1434, 1434, 1469], [1470, 1546, 1584, 1694, 1751], [1753, 1799, 1828, 1828, 1869], [1871, 1871, 1890, 1890, 1962], [1964, 1964, 1993, 1993, 2076], [2078, 2078, 2097, 2097, 2109], [2112, 2112, 2143, 2143, 2771], [2773, 2902, 2959, 2959, 4009]], "test": "untested"}
{"id": "ml3cDl", "name": "Sparkly Winter Wonderland", "author": "fenix", "description": "A frozen sparkly miniature landscape with soft shadows and a tilt-shift lens effect.\n\n*mouse controls camera*", "tags": ["dof", "trees", "tiltshift", "glints", "winter", "sparkle", "glitter"], "likes": 28, "viewed": 363, "published": 3, "date": "1700696008", "time_retrieved": "2024-07-30T17:21:02.917741", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  A frozen sparkly miniature landscape with soft shadows and a tilt-shift lens effect.\n//\n//  I've always been fascinated with glittery effects, and I've borrowed glitter code\n//  for previous shaders from wnu's:\n//\n//    sparkle commented               https://www.shadertoy.com/view/Ndlczs\n//\n//  I tried to use it again here, but I didn't get the results I wanted so I decided to\n//  write a glitter function myself.  A design goal was for the glints to be able to span\n//  multiple pixels, to combat aliasing.  The way it works, the world is divided into an\n//  XZ grid. Within each grid cell, N points are selected randomly within the cell by XZ,\n//  and then their Y position is determined by the ground height. These points are rendered\n//  in screen space with randomized normals.\n//\n//  I've used the tilt-shift lens effect before in other shaders like\n//\n//    Dynamic Editable Terrain        https://www.shadertoy.com/view/NlyBWm\n//\n//  I was hoping the sparkles would look even better with some blur on top, and I was\n//  happy with the result.\n//\n//  Otherwise this is a straightforward application of typical SDF rendering with marched\n//  soft shadows.  The trees use a bounding sphere approximation in the SDF until you get\n//  close, to avoid the more costly tree SDF until necessary. This does complicate the\n//  soft shadows, since they can \"see\" this bounding sphere if everything isn't tuned\n//  correctly, but I think I've got it dialed in without very many artifacts.\n//\n//  The trees are randomized using the same basic idea as the sparkles, but there is only\n//  one tree per sector. It's necessary to check multiple sectors when marching, and I\n//  use that trick where I search in the marching direction to reduce the cost.\n//\n//  Buffer A: Main render\n//  Image: Tilt-shift lens blur\n// ---------------------------------------------------------------------------------------\n\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  11;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = textureLod(iChannel0, vec2(.5, .6), 4.).w; // mip sample here softens focal length changes\n    float depth = textureLod(iChannel0, u / R.xy, 4.).w; // mip sample here protects against \"halos\" where different depths meet\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = abs(depth-centerDepth) * .0005;\n    \n    if (w > 0.001)\n    {\n        init\n\n        O = convol2D(u / R.y);\n    }\n    else\n    {\n        O = texture(iChannel0, u/R.xy);\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u / R;\n    uv *=  1. - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .25); // change pow for modifying the extend of the  vignette\n    O *= vig;\n    \n    O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//  Main render (outputs RGB, t)\n// ---------------------------------------------------------------------------------------\n\nmat2 rot2(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nvoid getCamera(out vec3 ro, out vec3 cd)\n{\n    float t = iTime;\n    ro = vec3(0, 1, 1) * 40.;\n    vec2 m = (iMouse.z > 0.) ? 3.*(iMouse.xy - .5 * iResolution.xy) / iResolution.y : vec2(0);\n    ro.xz *= rot2(-m.x);\n    ro.xz *= rot2(t * .15);\n    cd = normalize(-ro);\n    ro.y += sin(t * .2) * 10. - 5. - 10. * m.y;\n    ro.x += sin(t * .05) * 100.;\n    ro.z += cos(t * .05) * 100.;\n}\n\nvec3 getRay(vec3 cd, vec2 u, inout vec3 lf, inout vec3 up)\n{\n    lf = normalize(cross(cd, vec3(0, 1, 0)));\n    up = normalize(cross(lf, cd));\n    return normalize(cd + u.x * lf + u.y * up);\n}\n\nmat4 cameraMat(vec3 lf, vec3 up, vec3 cd, vec3 ro)\n{\n    return mat4(vec4(lf, 0),\n                vec4(up, 0),\n                vec4(cd, 0),\n                vec4(ro, 1));\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( vec3 z )\n{\n    uvec3 x = uvec3(ivec3(z));\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// simple 3 layer sine field for terrain\nfloat snowHeight(vec2 p)\n{\n    p *= .08;\n    float h = sin(p.x) * sin(p.y) * .4;\n    p *= 1.6;\n    p += 1.;\n    p *= rot2(.5);\n    h += sin(p.x) * sin(p.y) * .3;\n    p *= 1.6;\n    p += 1.;\n    p *= rot2(.5);\n    h += sin(p.x) * sin(p.y) * .2;\n    return h * 15.;\n}\n\n// (approximate) SDF of terrain\nfloat mapSnow(vec3 p) { return p.y - snowHeight(p.xz); }\n\n// calculate terrain normal\nvec3 normSnow(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(vec3(mapSnow(p + e.xyy) - mapSnow(p - e.xyy),\n                          mapSnow(p + e.yxy) - mapSnow(p - e.yxy),\n                          mapSnow(p + e.yyx) - mapSnow(p - e.yyx)));\n}\n\n// Tree modelled via my Polygon SDF Modelling Tool\n// https://www.shadertoy.com/view/dtBSDw\nconst vec2 VERTS[] = vec2[](vec2(.0, 3.2),\n                            vec2(0, 0),\n                            vec2(2, 0),\n                            vec2(1.16, .84),\n                            vec2(1.44, .84),\n                            vec2(.76, 1.72),\n                            vec2(1.12, 1.72),\n                            vec2(.48, 2.52),\n                            vec2(.76, 2.52));\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPolygon(int num, vec2 p)\n{\n    p.x = abs(p.x);\n    float d = dot(p-VERTS[0],p-VERTS[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = VERTS[j] - VERTS[i];\n        vec2 w = p - VERTS[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=VERTS[i].y, \n                            p.y <VERTS[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opRevolution(vec3 p)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    return sdPolygon(9, q);\n}\n\n// SDF for a single tree, whose sector center is in ct\nfloat sdTree(vec3 p, vec2 ct)\n{\n    // compute tree position within this sector\n    vec3 h = hash3(ct.xyy) - .5;\n    vec2 off = h.xy * 14.;\n    vec3 tp;\n    tp.xz = ct + off;\n    tp.y = snowHeight(tp.xz);\n    float s = (h.z + 1.); // size;\n    \n    p -= tp;\n    p *= s;\n\n    // compute center of bounding sphere\n    vec3 c = p;\n    c.y -= 1.;\n    \n    float d2 = dot(c, c);\n    float RADIUS = 5.; // treat as sphere beyond this radius (optimization)\n    //return (sqrt(d2) - RADIUS) / s; // render as spheres to check bounding sphere size/position\n    float d = (d2 > RADIUS * RADIUS) ? sqrt(d2) - RADIUS * .5 : opRevolution(p);\n    return d / s;\n}\n\nconst float TREE_REPEAT = 20.;\n\n// get the center of the current tree sector\nvec2 treeSectorCenter(vec3 p)\n{\n    return p.xz - mod(p.xz, TREE_REPEAT) + TREE_REPEAT * .5;\n}\n\n// SDF of the entire forest\nfloat mapTrees(vec3 p, vec3 rd)\n{\n    vec2 ct = treeSectorCenter(p);\n    vec2 s = sign(rd.xz); // search extra cells in the direction we're marching\n    \n    float d = 1e6;\n    for(int x = 0; x <= 1; ++x)\n    for(int y = 0; y <= 1; ++y)\n    {\n        float td = sdTree(p, ct + vec2(x, y) * s * TREE_REPEAT);\n        d = min(d, td);\n    }\n    \n    return d;\n}\n\n// material types\nconst float SNOW = 0.;\nconst float TREE = 1.;\nconst float SKY = 2.;\n\n// combined SDF of snow and trees, returning d, material\nvec2 scene(vec3 p, vec3 rd)\n{\n    float d1 = mapSnow(p);\n    float d2 = mapTrees(p, rd);\n    if (d1 < d2)\n        return vec2(d1, SNOW);\n    else\n        return vec2(d2, TREE);\n}\n\n// ray march against entire scene, returning t, material\nvec2 marchScene(inout vec3 p, vec3 rd)\n{\n    float t = 0.;\n    float m = 0.;\n    for (int i = 0; i < 48; ++i)\n    {\n        vec2 d = scene(p, rd);\n        m = d.y;\n        \n        if (abs(d.x) < .01) break;\n        \n        p += d.x * rd;\n        t += d.x;\n    }\n    \n    return vec2(t, m);\n}\n\n// compute normal for trees\nvec3 normTrees(vec3 p)\n{\n    const vec2 e = vec2(.01, 0);\n    vec2 ct = treeSectorCenter(p);\n    \n    return normalize(vec3(sdTree(p + e.xyy, ct) - sdTree(p - e.xyy, ct),\n                          sdTree(p + e.yxy, ct) - sdTree(p - e.yxy, ct),\n                          sdTree(p + e.yyx, ct) - sdTree(p - e.yyx, ct)));\n}\n\n// From iq's Soft Shadow Variation\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<48; i++ )\n    {\n\t\tfloat h = scene(ro + rd*t, rd).x;\n\n        res = min( res, 10.*h/t );\n        t += h;\n        \n        if( res<.0001 || t>tmax ) break;\n    }\n    \n    res = clamp( res, 0., 1. );\n    return res*res*(3.-2.*res);\n}\n\nconst vec3 LDIR = normalize(vec3(-.5, .5, 1));\n\nfloat renderGlint(vec2 id, int i, mat4 m, vec2 u, vec3 n, vec3 rd, float sh)\n{\n    // compute glint position\n    vec2 off = hash3(vec3(id.xy, i)).xy;\n    vec3 sp;\n    sp.xz = id + off;\n    sp.y = snowHeight(sp.xz);\n\n    // glint position in screen space\n    vec3 sc = (m * vec4(sp, 1)).xyz;\n    sc.xy = sc.xy / sc.z;\n    float d = distance(sc.xy, u);\n    float c = smoothstep(3./iResolution.y, 0., d); // glint shape\n\n    vec3 gn = normalize(hash3(vec3(i, id.yx)) - .5 + 1.1 * n); // glint normal\n    vec3 re = reflect(LDIR, gn); // reflected\n    float spec = pow(max(0., dot(rd, re)), 200.); // specular\n    return spec * c * sh * iResolution.y / 10. / sc.z; // dim at lower resolutions to keep similar brightness\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy;\n    u = (u - .5 * R) / R.y;\n    \n    vec3 ro, cd, lft, up;\n    getCamera(ro, cd);\n    \n    vec3 rd = getRay(cd, u, lft, up);\n    vec3 p = ro;\n\n    vec2 r = marchScene(p, rd);  \n    O.a = r.x; // t\n    float m = r.y; // material\n\n    vec3 n = m == SNOW ? normSnow(p) : normTrees(p);\n    vec3 c = m == SNOW ? vec3(.5) : vec3(.1, .2, .01);\n    \n    vec3 df = max(0., dot(n, LDIR)) * c;\n    \n    float sh = calcSoftshadow(p + n * .1, LDIR, .5, 35.);\n    O.rgb = df * sh * .95 + vec3(0, 0, .05);\n    \n    if (m == SNOW && sh > 0.)\n    {\n        vec2 id = floor(p.xz);\n        mat4 m = inverse(cameraMat(lft, up, cd, ro));\n\n        const int NUM_GLINTS = 20;\n        for (int i = 0; i < NUM_GLINTS; ++i)\n            O.rgb += renderGlint(id, i, m, u, n, rd, sh);\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3cDl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2570, 2570, 2593, 2593, 3199], [3207, 3291, 3314, 3314, 3474], [3476, 3476, 3514, 3514, 4502]], "test": "untested"}
{"id": "clKcDK", "name": "Sun, earth and moon", "author": "vortmax", "description": "solar system in nutshell", "tags": ["light", "ball", "orbit", "smooth", "movement", "solarsystem"], "likes": 1, "viewed": 135, "published": 3, "date": "1700688349", "time_retrieved": "2024-07-30T17:21:03.784424", "image_code": "struct ellipse\n{\n    vec2 position;\n    vec2 semi_axis;\n};\n\nstruct polar\n{\n    float fi;\n    float dist;\n};\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes);\nvec2 getAbsPosition(ellipse e, vec2 norm, float dist);\nvec2 getAbsPosition(ellipse e, polar point);\nvec2 getMovement(float fi);\nbool contains(ellipse e, vec2 point);\nbool contains(ellipse e, vec2 point, float scale);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord );\n\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return 2.0 * (glCoord.xy - 0.5 * glRes.xy) / glRes.y; \n}\n\nvec2 getAbsPosition(ellipse e, vec2 norm, float dist)\n{\n    return norm \n        * dist \n        * e.semi_axis\n        + e.position;\n}\n\nvec2 getAbsPosition(ellipse e, polar point)\n{\n    return getAbsPosition(e, vec2(cos(point.fi), sin(point.fi)), point.dist);\n}\n\nvec2 getMovement(float fi)\n{\n    return vec2(cos(fi), sin(fi));\n}\n\n\nfloat getIntensity(ellipse e, vec2 point)\n{   \n    vec2 pos = point - e.position;\n    vec2 norm = normalize(pos);\n    \n    return length(pos) / length(norm * e.semi_axis);\n}\n\nbool contains(ellipse e, vec2 point)\n{\n    return contains(e, point, 1.0);\n}\n\nbool contains(ellipse e, vec2 point, float scale)\n{\n    vec2 res = (point - e.position) / e.semi_axis;\n    return pow(res.x, 2.0) + pow(res.y, 2.0) <= pow(scale, 2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvFrag = screen2uv(fragCoord.xy, iResolution.xy);\n    vec2 uvMouse = screen2uv(iMouse.xy, iResolution.xy);\n    vec2 uvBounds = screen2uv(iResolution.xy, iResolution.xy);\n    \n    float currTime = iTime * 0.2;\n\n   \n    ellipse sun = ellipse(uvMouse, vec2(0.3));\n\n    ellipse earth = ellipse(sun.position, vec2(0.1));\n    earth.position += getMovement(currTime) * (uvBounds);\n            \n        \n    ellipse moon = ellipse(earth.position, vec2(0.06));\n    moon.position += getMovement(currTime * 6.0) * (vec2(0.6, 0.4)) ;\n    \n    \n    vec3 earthColor = vec3(74, 111, 228) / 255.0;\n    vec3 sunColor = vec3(255, 217, 46) / 255.0;\n    vec3 moonColor = vec3(192, 183, 167) / 255.0;\n    vec3 backgroundColor = vec3(40, 39, 39) / 255.0;\n    \n    \n    fragColor.rgb = backgroundColor;\n    fragColor.a = 1.0;\n\n    if(contains(earth, uvFrag))\n    {\n        float intensity = getIntensity(earth, uvFrag); \n        fragColor.rgb = mix(earthColor, backgroundColor, pow(intensity, 8.0));\n        fragColor.g = tanh(1.0 - intensity);\n    }\n    \n    if(contains(moon, uvFrag))\n    {\n        float intensity = getIntensity(moon, uvFrag); \n        fragColor.rgb = mix(sinh(moonColor), backgroundColor, pow(intensity, 8.0));\n    }\n    \n    if(contains(sun, uvFrag))\n    {\n        float intensity = getIntensity(sun, uvFrag); \n        fragColor.rgb = mix(sunColor, backgroundColor, pow(intensity, 4.0));\n        fragColor.g = sinh(1.0 - intensity);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 469, 469, 530], [532, 532, 587, 587, 666], [668, 668, 713, 713, 793], [795, 795, 823, 823, 860], [863, 863, 906, 906, 1036], [1038, 1038, 1076, 1076, 1114], [1116, 1116, 1167, 1167, 1285], [1288, 1288, 1345, 1345, 2794]], "test": "untested"}
{"id": "ctyczK", "name": "My Sinusoid", "author": "Timmyswdswd", "description": "Sinusoid", "tags": ["sin"], "likes": 0, "viewed": 122, "published": 3, "date": "1700681858", "time_retrieved": "2024-07-30T17:21:04.540403", "image_code": "struct MathFunction\n{\n    float localScale;\n    float x;\n    float y;\n};\n\nvec3 defineFunction(MathFunction fn, vec3 col, vec2 fragCoord)\n{\n    fn.y = round(fn.y);\n    if(fragCoord.y == fn.y){\n        if(col != vec3(1.0, 0.0, 0.0))\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            col = vec3(col.r/1.5, 0.0, 0.0);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    fragCoord -= iResolution.xy/2.0;\n    fragCoord = round(fragCoord);\n    \n    //Axis\n    if(fragCoord.x == 0.0 || fragCoord.y == 0.0){\n        col = vec3(0.5, 0.5, 0.5); \n    }\n    \n    //Loyout\n    float scale = 100.0;\n    \n    MathFunction fn_1;\n    fn_1.x = fragCoord.x;\n    fn_1.y = sin(fn_1.x/scale+iTime)*scale;\n    \n    MathFunction fn_2;\n    fn_2.x = fragCoord.x;\n    //fn_2.y = -sqrt(pow(scale, 2.0) - pow(fn_2.x, 2.0));\n    \n    //Printing\n    col = defineFunction(fn_1, col, fragCoord);\n    //col = defineFunction(fn_2, col, fragCoord);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 138, 138, 396], [398, 398, 455, 455, 1148]], "test": "untested"}
{"id": "dtGyRK", "name": "AntyGreen", "author": "Timmyswdswd", "description": "AntyGreen", "tags": ["effects"], "likes": 0, "viewed": 119, "published": 3, "date": "1700681849", "time_retrieved": "2024-07-30T17:21:05.395118", "image_code": "float getGray(vec4 col)\n{\n    return (col.r + col.g + col.b + col.a)/4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv;\n    vec4 col;\n    \n    col = texture(iChannel0, uv);\n    \n    float alpha = 0.07;\n    if(col.g > col.r+alpha && col.g > col.b+alpha ){\n        col = texture(iChannel1, uv);\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 75], [77, 77, 134, 184, 464]], "test": "untested"}
{"id": "dlGczV", "name": "4 styles", "author": "Timmyswdswd", "description": "4 stiles", "tags": ["effects"], "likes": 1, "viewed": 135, "published": 3, "date": "1700681838", "time_retrieved": "2024-07-30T17:21:06.141123", "image_code": "float getGray(vec4 col)\n{\n    return (col.r + col.g + col.b)/3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    vec4 col;\n    \n    if(uv.x > 1.0 && uv.y > 1.0){\n        uv -= vec2(1.0, 1.0);\n        col = texture(iChannel0, uv);\n        col.g = (col.b + uv.x)/2.0; \n    }\n    else if(uv.x > 1.0){\n        uv -= vec2(1.0, 0.0);\n        col = texture(iChannel0, uv);\n        float gray = getGray(col);\n        col = vec4(gray, gray, gray, gray);\n    }\n    else if(uv.y > 1.0){\n        uv -= vec2(0.0, 1.0);\n        col = texture(iChannel0, uv);\n        col.r = (col.b + uv.x)/2.0; \n    }\n    else{\n        col = texture(iChannel0, uv);\n        col.b = (col.r + col.g + uv.x)/3.0; \n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 67], [69, 69, 126, 176, 856]], "test": "untested"}
{"id": "clKcWK", "name": "Complex Plot 3D", "author": "domrally", "description": "A 3D plot of complex numbers to test the ITP root solver. This solver takes the best parts of bisection & secant but makes something more.\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["projection", "solver", "iteration", "bisection", "project", "root", "bisect", "bracket", "iterate", "method", "finder", "truncation", "itp", "truncate"], "likes": 41, "viewed": 420, "published": 3, "date": "1700677142", "time_retrieved": "2024-07-30T17:21:06.989854", "image_code": "/*\nby Dom Mandy in 2023\n*/\n\n\n/*\nLightness & Gamma\nhttps://www.shadertoy.com/view/DsyfDcx\n*/\nvec3 rgb(vec4 srgb) { return mix(srgb / 12.92, pow((srgb + .055) / 1.055, vec4(2.4)), step(.04045, srgb)).rgb; }\nvec4 gamma(vec3 rgb) { return vec4(pow(rgb, vec3(1) / 2.2), 1); }\nfloat lightness(vec3 rgb) { return pow(dot(rgb, vec3(.2126, .7152, .0722)), .59 * (1.48 + sqrt(.2))); }\n\n\n/*\nColor Palette\nhttps://www.shadertoy.com/view/mltyRN\n*/\nvec3 palette(float l, float c, float h) { return l + c * l * vec3(8, 3, 9) * cos(h - vec3(0, 2, 4)); }\n\n\n/*\nComplex Functions\n*/\nvec2 M(vec2 w, vec2 z) { return vec2(w.x * z.x - w.y * z.y, w.x * z.y + w.y * z.x); }\nvec2 D(vec2 w, vec2 z) { return vec2(dot(z, w), z.x * w.y - z.y * w.x) / dot(z, z); }\nvec2 F(vec2 z) { const vec2 v = vec2(1, 0); z = M(M(z, z), z); return D(z + v, z - v); }\n\n\n/*\nTerrain marching based on iq with adaptive error\n*/\nmat2x3 March(vec3 eye, vec3 ray) {\n    vec3 near, far;\n    for (float k, t = 6.; k++ < 89.; t *= 1.01, near = far) {\n        far = eye + ray * t;\n        vec2 f = F(far.xz);\n\n        // return when you have a positive and negative side of the hit\n        if (far.y * far.y < dot(f, f)) break;\n    }\n    return mat2x3(near, far);\n}\nvec3 Normal(vec3 p) {\n    const float e = 1e-5;\n    return normalize(vec3(\n        length(F(vec2(p.x - e, p.z))) - length(F(vec2(p.x + e, p.z))),\n        2. * e,\n        length(F(vec2(p.x, p.z - e))) - length(F(vec2(p.x, p.z + e)))\n    ));\n}\n\n\n/*\n1st root finder with superlinear convergence\nand minmax optimal worst case performance.\n*/\nvec3 Root(vec3 near, vec3 far, vec3 ray, vec3 eye) {\n    float k, \n          e = 1e-10, \n          p = 1. + ceil(log2(distance(near, far) / 2. / e)),\n          n = near.y - length(F(near.xz)),\n          f = far.y - length(F(far.xz));\n\n    for (; k < 9.; k++) {\n        // interpolate\n        vec3 bisect = (near + far) / 2.,\n             falsi = (n * far - f * near) / (n - f);\n\n        // truncate\n        float l = distance(near, far),\n              d = .1 * pow(l, 2.),\n              s = sign(distance(bisect, eye) - distance(falsi, eye));\n        vec3 trunk = d > distance(bisect, falsi)\n            ? bisect\n            : falsi + s * d * ray;\n\n        // project\n        float r = e * pow(2., p - k) - l / 2.;\n        vec3 project = r < distance(trunk, bisect)\n            ? bisect - s * r * ray\n            : trunk;\n        \n        // update\n        float update = project.y - length(F(project.xz));\n        if (update < 0.) {\n            far = project;\n            f = update;\n        } else if (update > 0.) {\n            near = project;\n            n = update;\n        } else {\n            return project;\n        }\n    }\n    \n    return (near + far) / 2.;\n}\n\n\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    // coordinates\n    vec2 R = iResolution.xy;\n    uv = 4. * (uv + uv - R) / max(R.x, R.y);\n    uv += vec2(.6, 7.8);\n    vec3 eye = vec3(uv, -9),\n         ray = normalize(vec3(0, -1, 1)),\n         sun = normalize(vec3(2, 3, -1));\n    \n    // animation\n    float t = mix(iTime, iMouse.x / 200., max(0., sign(iMouse.z))),\n          r = atan(ray.z, ray.x) - t,\n          e = atan(eye.z, eye.x) - t,\n          l = atan(sun.z, sun.x) - t;\n    ray.xz = vec2(cos(r), sin(r));\n    eye.xz = vec2(cos(e), sin(e)) * length(eye.xz);\n    sun.xz = vec2(cos(l), sin(l)) * .7;\n\n    // ray casting\n    mat2x3 hit = March(eye, ray);\n    vec3 root = Root(hit[0], hit[1], ray, eye),\n         normal = Normal(root);\n\n    // lighting\n    vec2 result = F(root.xz);\n    vec3 g = pow(.5 + .5 * sin((9. * root)), vec3(.1));\n    float shine = lightness(rgb(texture(iChannel0, reflect(ray, normal)))),\n          glow = 2. * lightness(rgb(texture(iChannel1, refract(ray, normal, .67)))),\n          hue = 2. + atan(result.y, result.x),\n          diffuse = .1 * max(0., dot(sun, normal)),\n          specular = .3 * shine * max(0., dot(reflect(sun, normal), ray)),\n          grid = g.x * g.y * g.z;\n\n    vec3 color = diffuse + specular + palette(glow, .2, hue);\n\n    pixel = gamma(grid * color);\n}\n\n\n/*\nthanks to Real_NC for discussion pre listing\nhttps://www.shadertoy.com/user/Real_NC\n\nSEE ALSO\n\nby harry7557558 in 2021\nhttps://www.shadertoy.com/view/sljSzD\n\nby Ivo Oliveira & Ricardo Takahashi in 2020\nhttps://en.wikipedia.org/wiki/ITP_method#The_algorithm\n\nby djmkultra in 2015\nhttps://www.shadertoy.com/view/ltsXD7\n\nby Inigo Quilez in 2002\nhttps://iquilezles.org/articles/terrainmarching\n\nby Jahnke and Emde in 1909\nhttps://www.dbraulibrary.org.in/RareBooks/Tables%20of%20Function%20with%20formula%20and%20Curves.pdf\n\nby wolfram\nhttps://reference.wolfram.com/language/ref/ComplexPlot3D.html\n\nby maple\nhttps://www.maplesoft.com/support/help/maple/view.aspx?path=plots%2Fcomplexplot3d\n*/\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 92, 113, 113, 204], [205, 205, 227, 227, 270], [271, 271, 298, 298, 374], [377, 435, 476, 476, 537], [540, 564, 588, 588, 649], [650, 650, 674, 674, 735], [736, 736, 752, 752, 824], [827, 882, 916, 916, 1212], [1213, 1213, 1234, 1234, 1454], [1457, 1551, 1603, 1603, 2719], [2722, 2722, 2763, 2782, 4030]], "test": "untested"}
{"id": "mlKcWy", "name": "Ball with flare", "author": "vortmax", "description": "very smooth yellow ball rotating around the center of screen", "tags": ["light", "ball", "orbit", "smooth", "movement"], "likes": 1, "viewed": 114, "published": 3, "date": "1700675666", "time_retrieved": "2024-07-30T17:21:07.735859", "image_code": "struct ellipse\n{\n    vec2 position;\n    vec2 semi_axis;\n};\n\nstruct polar\n{\n    float fi;\n    float dist;\n};\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes);\nvec2 getAbsPosition(ellipse e, polar point);\nbool contains(ellipse e, vec2 point);\nbool contains(ellipse e, vec2 point, float scale);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord );\n\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return 2.0 * (glCoord.xy - 0.5 * glRes.xy) / glRes.y; \n}\n\nvec2 getAbsPosition(ellipse e, vec2 norm, float dist)\n{\n    return norm \n        * dist \n        * e.semi_axis\n        + e.position;\n}\n\nvec2 getAbsPosition(ellipse e, polar point)\n{\n    return getAbsPosition(e, vec2(cos(point.fi), sin(point.fi)), point.dist);\n}\n\n\nfloat getIntensity(ellipse e, vec2 point)\n{   \n    vec2 pos = point - e.position;\n    vec2 norm = normalize(pos);\n    \n    return length(pos) / length(norm * e.semi_axis);\n}\n\nbool contains(ellipse e, vec2 point)\n{\n    return contains(e, point, 1.0);\n}\n\nbool contains(ellipse e, vec2 point, float scale)\n{\n    return pow((point.x - e.position.x) / e.semi_axis.x, 2.0) +\n           pow((point.y - e.position.y) / e.semi_axis.y, 2.0) <= pow(scale, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvFrag = screen2uv(fragCoord.xy, iResolution.xy);\n    vec2 uvMouse = screen2uv(iMouse.xy, iResolution.xy);\n    vec2 uvBounds = screen2uv(iResolution.xy, iResolution.xy);\n    \n    vec2 rtPos = vec2(cos(iTime), sin(iTime));       \n   \n    ellipse ball = ellipse(rtPos, vec2(0.3));\n    ball.position *= (uvBounds - ball.semi_axis);\n    \n    ellipse ballFlare = ellipse(\n        getAbsPosition(ball, -rtPos, 0.5), \n        vec2(0.3)\n    );\n    \n    vec3 flareColor = vec3(1.0);\n    vec3 ballColor = vec3(255, 217, 46) / 255.0;\n    vec3 backgroundColor = vec3(40, 39, 39) / 255.0;\n    \n    \n    fragColor.rgb = backgroundColor;\n    fragColor.a = 1.0;\n\n    if(contains(ball, uvFrag))\n    {\n        float ballIntensity = getIntensity(ball, uvFrag); \n        fragColor.rgb = mix(ballColor, fragColor.rgb, pow(ballIntensity, 8.0));\n        \n        if(contains(ballFlare, uvFrag))\n        {\n            float flareIntensity = getIntensity(ballFlare, uvFrag);\n            fragColor.rgb = mix(flareColor, fragColor.rgb, pow(flareIntensity, 0.33));\n        }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 386, 386, 447], [449, 449, 504, 504, 583], [585, 585, 630, 630, 710], [713, 713, 756, 756, 886], [888, 888, 926, 926, 964], [966, 966, 1017, 1017, 1165], [1167, 1167, 1224, 1224, 2293]], "test": "untested"}
{"id": "DlVyWK", "name": "cowboy remarks", "author": "chenxianming", "description": "make this prints for the glass drag gate pasting.", "tags": ["simple", "painting", "cineshader", "xcute"], "likes": 18, "viewed": 748, "published": 3, "date": "1700672680", "time_retrieved": "2024-07-30T17:21:08.502808", "image_code": "\n/*\n ____                         __                          ____                                        __                \n/\\  _`\\                      /\\ \\                        /\\  _`\\                                     /\\ \\               \n\\ \\ \\/\\_\\    ___   __  __  __\\ \\ \\____    ___   __  __   \\ \\ \\L\\ \\     __    ___ ___      __     _ __\\ \\ \\/'\\     ____  \n \\ \\ \\/_/_  / __`\\/\\ \\/\\ \\/\\ \\\\ \\ '__`\\  / __`\\/\\ \\/\\ \\   \\ \\ ,  /   /'__`\\/' __` __`\\  /'__`\\  /\\`'__\\ \\ , <    /',__\\ \n  \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\_/ \\_/ \\\\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\_\\ \\   \\ \\ \\\\ \\ /\\  __//\\ \\/\\ \\/\\ \\/\\ \\L\\.\\_\\ \\ \\/ \\ \\ \\\\`\\ /\\__, `\\\n   \\ \\____/\\ \\____/\\ \\___x___/' \\ \\_,__/\\ \\____/\\/`____ \\   \\ \\_\\ \\_\\ \\____\\ \\_\\ \\_\\ \\_\\ \\__/.\\_\\\\ \\_\\  \\ \\_\\ \\_\\/\\____/\n    \\/___/  \\/___/  \\/__//__/    \\/___/  \\/___/  `/___/> \\   \\/_/\\/ /\\/____/\\/_/\\/_/\\/_/\\/__/\\/_/ \\/_/   \\/_/\\/_/\\/___/ \n                                                    /\\___/                                                              \n                                                    \\/__/                                                               \n\n    By chenxianming\n\n*/\n#define cine ( abs( h.x - h.y ) < 20. ) // for cinshader resolution\n#define h iResolution.xy\n\nfloat f(float a, float b, float c) { return smoothstep(a, b, c); }\nfloat q(float a) {\n  float b = a - floor(a);\n  b = b > .5 ? 1. : 0.;\n  return floor(a) + b;\n}\nvec2 k(vec2 a) { return vec2(q(a.x), q(a.y)); }\n\nfloat l(vec2 a) { return dot(a, a); }\nmat2 e(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nfloat A(float a) { return clamp(a, 0., 1.); }\nfloat r(vec2 a, vec2 b) { return l(a - b); }\nfloat m(vec2 c, vec2 a, vec2 d) {\n  vec2 g = c - a, b = d - a;\n  return l(g - b * A(dot(g, b) / l(b)));\n}\nfloat s(inout vec2 b, float d) {\n  float a = 6.28 / d, g = (atan(b.y, b.x) + a * .5) / a, c = floor(g),\n        i = a * c;\n  b *= e(i);\n  return c;\n}\nvec2 t(inout vec2 a, vec2 b) {\n  vec2 c = b * .5, d = floor((a + c) / b);\n  a.y -= mod(d.x, 2.) * .05, a = mod(a + c, b) - c;\n  return d;\n}\nvec2 B(inout vec2 a, vec2 b, float c) {\n  vec2 d = k(a / -b);\n  a = a - b * clamp(k(a / b), -c, c);\n  return d;\n}\nfloat j(vec2 a, int b) {\n  a *= e(.094245);\n  vec2 c = t(a, vec2(b == 0 ? .065 : .08));\n  return b == 0 ? r(a, vec2(0)) : c.y > 3. ? r(a, vec2(0)) : 1.;\n}\nfloat Z( vec2 u ){\n    u.x += .1, u.y -= .58, u *= e(.094245);\n    return max( \n        abs( u.x ) - 2.1,\n        abs( u.y ) - .84\n    );\n}\nfloat n(vec2 a) {\n  float d = .1;\n  a.y -= .3, a.x += 2.6;\n  for (float b = 0.; b < 10.; b++) {\n    a.x -= .8, a.y += cos(b) * .2;\n    if( b==2. )\n        a.y += .1;\n    if( b==3. )\n        a.y -= .1;\n    vec2 c = a;\n    c *= e(.785375), c *= e(b / 20.),\n        d = min(d, max(abs(c.x) - .4, abs(c.y) - .5));\n  }\n  \n  return d;\n}\nfloat C(vec2 a) { return max( abs(n(a)), Z( a ) ); }\nfloat D(vec2 a, float b, float E) {\n  float d = .3, c = .1;\n  a.y += .8, a *= e(cos(iTime) * .1 / b), a.y -= cine ? .25 : .8;\n\n  for (float g = 0.; g < b; g++) {\n    a.y -= .17;\n    for (float i = 1.; i < E; i++)\n      a.x = abs(a.x) - .01 - d * .01, a *= e(-.2), a *= e(cos(iTime) * .1 / b),\n      d /= .95;\n    c = min(c, m(a, vec2(0, -.2), vec2(0, .1)));\n  }\n  return c;\n}\nfloat F(vec2 a) {\n  a.x += .3, a.y -= .7, a *= e(iTime * .1), s(a, 25.), a.x -= .5,\n      a *= e(1.57075), B(a, vec2(.2, .6), 1.);\n  return abs(max(max(abs(a.x) - .3 * abs(abs(a.y) - .3) + .01, abs(a.y) - .3),\n                 mod(a.y + .025, .05) - .025));\n}\nfloat G(vec2 a) {\n  a.y += .58, a *= e(.094245);\n  return abs(max(max(abs(a.x) - 2.1, abs(a.y) - .84),\n                 mod(a.y + cos(a.x * 1.2) * .5, .1) - .05));\n}\nfloat H(vec2 a) {\n  a.x -= 1., a.y += .15;\n  return abs(min(min(max(abs(a.x) - .78 * -(a.y - .35), abs(a.y - .35) - .3),\n                     max(abs(a.x) - .15, abs(a.y) - .15)),\n                 max(abs(a.x - .12) - .02, abs(a.y - .2) - .1)));\n}\nfloat I(vec2 a) {\n  a.x -= 1., a.y += .13;\n  return abs(max(abs(a.x) - .05, abs(a.y) - .05));\n}\nfloat J(vec2 a) {\n  a.x -= 1., a.y += .15;\n  return max(abs(a.x) - .78 * -(a.y - .35), abs(a.y - .35) - .25);\n}\nfloat K(vec2 a) {\n  a *= e(1.50792);\n  return abs(mod(a.x + .028, .047) - .013);\n}\nvec2 u(vec2 a, float b) {\n  a.x += cos(a.y * 90. + b) / 90.;\n  return a;\n}\nfloat L(vec2 a) {\n  a.x -= 1.13, a.y -= .24;\n  return abs(min(m(u(a, iTime * 2.), vec2(-.02, -.06), vec2(-.02, .06)),\n                 m(u(a, iTime * 2. + 5.5), vec2(.02, -.06), vec2(.02, .06))));\n}\nfloat v(vec2 a) {\n  a.x += cine ? .5 : .7, a.y += cine ? .8 : .5;\n  return max(abs(a.x) - .2 * abs(1. - (a.y / 2. + .5)), abs(a.y) - .4);\n}\nfloat M(vec2 a) { return abs(v(a)); }\nfloat o(vec2 b) {\n  float a = b.y;\n  a = abs(a) - .3, a = clamp(a, -.3, 1.), a = abs(a) - .01;\n  return max(abs(b.x) - .35 * a, abs(b.y) - .08);\n}\nfloat p(vec2 b, int c) {\n  float a = b.y, d = c == 0 ? .35 : .5, g = c == 0 ? .12 : .18;\n  a = abs(a) - d, a = clamp(a, -d, 1.), a = abs(a) - .01;\n  return max(abs(b.x) - .4 * a, abs(b.y) - g);\n}\nfloat N(vec2 a) {\n  a.x -= .1, a.y += .28, a *= e(1.099525);\n  return p(a, 1);\n}\nfloat w(vec2 a) {\n  a.x -= .83, a.y += cine ? 1.45 : .98, a *= e(.157075);\n  return p(a, 1);\n}\nfloat x(vec2 a) {\n  vec2 b = a;\n  a.x += cine ? .95 : 1.15, a.y += cine ? .95 : .45, a *= e(.785375);\n  return min(N(b), p(a, 0));\n}\nfloat O(vec2 a) { return abs(x(a)); }\nfloat y(vec2 a) {\n  a.x += .2, a.y += .2, a *= e(.785375), a.x -= .3, a.y += .7;\n  float c = .05;\n  for (float b = 0.; b < 3.; b++)\n    a.x = abs(a.x) - c * 1.5, c *= .1, a *= e(b), a.y += cos(b - 3.) * .4,\n    a = abs(a) + c * .1;\n  return min(o(a), o(a * e(.785375) + vec2(.2, -.1)));\n}\nfloat P(vec2 a) { return min(y(a), y(a * e(.785375) + vec2(.2, -.1))); }\nfloat z(vec2 a) {\n  vec2 d = a;\n  a.x += cine ? 1. : 1.2, a.y += cine ? .9 : .4;\n  float c = .2;\n  for (float b = 1.; b < 3.; b++)\n    a.x = abs(a.x) - c / b * .5, c *= 1.1, a *= e(cos(3. - b));\n  return min(o(a), P(d));\n}\nfloat Q(vec2 a) { return abs(z(a)); }\nfloat R(vec2 a) {\n  a.x += cine ? .5 : .7, a.y += cine ? .4 : .1, a *= e(.471225 - iTime * .5 + .5);\n  vec2 c = a, d = a * e(.785375), b = a;\n  b = mod(b, .1) - .05, s(a, 4.), a.x -= .4, a *= e(1.57075);\n  return min(\n      max(max(abs(a.x) - .115 * abs(1. - (a.y / 2. + .5)), abs(a.y) - .3),\n          max(abs(b.x) - .03, abs(b.y) - .03)),\n      max(max(abs(c.x) - .1, abs(c.y) - .1),\n          -max(abs(d.x) - .05, abs(d.y) - .05)));\n}\nfloat S(vec2 a) { return abs(R(a)); }\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n      float c = min(h.x, h.y);\n      \n      vec2 b = cine ? (V * 3. - h.xy * 1.5) / c : (V * 2. - h.xy) / c;\n      \n      vec3 d = vec3(.47, .51, .52), a = d;\n      a = mix(a, d * 1.7,\n              f(4. / c, 0., F(b)) * (1. - step(n(b), 0.)) * step(0., b.y)),\n      a = mix(a, d * 1.6,\n              f(4. / c, 0., C(b)) * step(sin(atan(b.x, b.y - .29) - 1.44509), 0.)),\n      a = mix(a, d * 1.6, step(n(b), 0.) * f(.05 / c, 0., j(b, 1)) * step(Z(b), 0.) ),\n      a = mix(a, d * 1.1, f(4. / c, 0., G(b))),\n      a = mix(a, d * 1.4, f(4. / c, 0., Q(b))),\n      a = mix(a, d * 1.4, f(.05 / c, 0., j(b, 0)) * step(z(b), 0.)),\n      a = mix(a, d * 1.6, f(4. / c, 0., O(b))),\n      a = mix(a, d * 1.6, f(.05 / c, 0., j(b, 0)) * step(x(b), 0.)),\n      a = mix(a, d * 1.6, f(4. / c, 0., H(b))),\n      a = mix(a, d * 1.6, step(J(b), 0.) * f(4. / c, 0., K(b))),\n      a = mix(a, d * 1.6, f(4. / c, 0., I(b))),\n      a = mix(a, d * 1.6, f(.02 / c, 0., L(b))),\n      a = mix(a, d * 1.8, f(4. / c, 0., M(b))),\n      a = mix(a, d * 1.8, f(4. / c, 0., S(b))),\n      a = mix(a, d * 1.8,\n              f(4. / c, 0., abs(mod(b.y + .025, .05) - .025)) * step(v(b), 0.)),\n      a = mix(a, d * 1.7, f( (cine ? .02 : .015) / c, 0., D(b + vec2(-.4, 1.15), 4., 3.))),\n      a = mix(a, d * 1.7, f(4. / c, 0., abs(w(b)))),\n      a = mix(a, d * 1.7, f(.05 / c, 0., j(b, 0)) * step(w(b), 0.));\n    \n    // Output to screen\n    U = vec4(a, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1212, 1212, 1248, 1248, 1278], [1279, 1279, 1297, 1297, 1372], [1373, 1373, 1389, 1389, 1420], [1422, 1422, 1439, 1439, 1459], [1460, 1460, 1477, 1477, 1525], [1526, 1526, 1544, 1544, 1571], [1572, 1572, 1597, 1597, 1616], [1617, 1617, 1650, 1650, 1722], [1723, 1723, 1755, 1755, 1872], [1873, 1873, 1903, 1903, 2012], [2013, 2013, 2052, 2052, 2126], [2127, 2127, 2151, 2151, 2281], [2282, 2282, 2300, 2300, 2421], [2422, 2422, 2439, 2439, 2752], [2753, 2753, 2770, 2770, 2805], [2806, 2806, 2841, 2841, 3181], [3182, 3182, 3199, 3199, 3441], [3442, 3442, 3459, 3459, 3607], [3608, 3608, 3625, 3625, 3855], [3856, 3856, 3873, 3873, 3951], [3952, 3952, 3969, 3969, 4063], [4064, 4064, 4081, 4081, 4146], [4147, 4147, 4172, 4172, 4221], [4222, 4222, 4239, 4239, 4420], [4421, 4421, 4438, 4438, 4560], [4561, 4561, 4578, 4578, 4598], [4599, 4599, 4616, 4616, 4745], [4746, 4746, 4770, 4770, 4941], [4942, 4942, 4959, 4959, 5022], [5023, 5023, 5040, 5040, 5117], [5118, 5118, 5135, 5135, 5250], [5251, 5251, 5268, 5268, 5288], [5289, 5289, 5306, 5306, 5577], [5578, 5578, 5595, 5595, 5650], [5651, 5651, 5668, 5668, 5873], [5874, 5874, 5891, 5891, 5911], [5912, 5912, 5929, 5929, 6349], [6350, 6350, 6367, 6367, 6387], [6390, 6390, 6431, 6481, 7904]], "test": "untested"}
{"id": "ctGyWV", "name": "Bubbly Chaos", "author": "pajunen", "description": "You can move the third attractor with your mouse. Adjusting the parameters lets you discover a variety of unique patterns.\n\n\n\n\n\n", "tags": ["fractal", "simulation", "gravity"], "likes": 17, "viewed": 346, "published": 3, "date": "1700644420", "time_retrieved": "2024-07-30T17:21:09.257790", "image_code": "// Bubbly Chaos\n//\n// This program simulates the motion of a small-mass body released\n// at the \"fragCoord\" position. The body's position is updated iteratively\n// based on the gravitational pull of three attractors. In each iteration,\n// we determine the closest attractor and retrieve its associated color.\n// The final pixel color is then calculated by taking the weighted average\n// of the attractor colors along the path of the moving body.\n//\n// Inspired by this video:\n// The relationship between chaos, fractal and physics:\n// https://www.youtube.com/watch?v=C5Jkgvw-Z6E&t=336s\n\nconst float EPSILON    = 1.e-3;\nconst float G          = 1.e3;                 // Gravity strength\nconst float M_BODY     = 1.;                   // Mass of the simulated body\nconst float M_A1       = 1.;                   // Mass of attractor 1\nconst float M_A2       = 1.;                   // Mass of attractor 2\nconst float M_A3       = 1.;                   // Mass of attractor 3\nconst vec3  C1         = vec3(0.5, 0.2, 0.25); // Color of attractor 1\nconst vec3  C2         = vec3(0.2, 0.3, 0.8);  // Color of attractor 2\nconst vec3  C3         = vec3(1.0, 0.3, 0.1);  // Color of attractor 3\nconst float SPEED      = 5.e-2;                // Controls the speed of the attractors\nconst float SCALE      = 5.0;                  // Controls how zoomed in the view is\nconst float EXPOSURE   = 40.0;                 // Controls the brightness\nconst float Z_DISTANCE = 1.0;                  // Min distance between any attractor and body\nconst float DURATION   = 1000.0;               // Simulation duration\nconst float TS_FACTOR  = 8.0;                  // Scale for adaptive time step\n// #define SHOW_ATTRACTORS                     // Toggle attractor positions\n\nvec2 A1;\nvec2 A2;\nvec2 A3;\n\nfloat d2(vec2 A, vec2 B) {\n  vec2 C = A - B;\n  return dot(C, C);\n}\n\nfloat d2(vec3 A, vec3 B) {\n  vec3 C = A - B;\n  return dot(C, C);\n}\n\nvec2 get_acceleration(vec2 s) {\n    vec3  d_1      = vec3(A1 - s, Z_DISTANCE);\n    float r2_1     = dot(d_1,d_1);\n    vec2  u_proj_1 = (d_1 / sqrt(r2_1)).xy;\n    \n    vec3  d_2      = vec3(A2 - s, Z_DISTANCE);\n    float r2_2     = dot(d_2,d_2);\n    vec2  u_proj_2 = (d_2 / sqrt(r2_2)).xy;\n    \n    vec3  d_3      = vec3(A3 - s, Z_DISTANCE);\n    float r2_3     = dot(d_3,d_3);\n    vec2  u_proj_3 = (d_3 / sqrt(r2_3)).xy;\n    \n    vec2 a = vec2(0.);\n    a += u_proj_1 * M_A1 / r2_1;\n    a += u_proj_2 * M_A2 / r2_2;\n    a += u_proj_3 * M_A3 / r2_3;\n    \n    return G * a;\n}\n\n// Set of differential equations defining\n// the motion of the simulated body\nvoid body_ode(in vec2[2] y, out vec2[2] dydt) {\n  dydt[0] = y[1]; \n  dydt[1] = get_acceleration(y[0]);\n}\n\n// 4th order runge kutta solver\nvoid rk4(float h, inout vec2[2] y1) {\n  vec2[2] k1, k2, k3, k4;\n  body_ode(y1, k1);\n  vec2[2] y2;\n  y2[0] = y1[0] + .5 * h * k1[0];\n  y2[1] = y1[1] + .5 * h * k1[1];\n  body_ode(y2, k2);\n  vec2[2] y3;\n  y3[0] = y1[0] + .5 * h * k2[0];\n  y3[1] = y1[1] + .5 * h * k2[1];\n  body_ode(y3, k3);\n  vec2[2] y4;\n  y4[0] = y1[0] + .5 * h * k3[0];\n  y4[1] = y1[1] + .5 * h * k3[1];\n  body_ode(y4, k4);\n  y1[0] += 0.1666 * h * (k1[0] + 2. * k1[0] + 2. * k2[0] + k3[0]);\n  y1[1] += 0.1666 * h * (k1[1] + 2. * k1[1] + 2. * k2[1] + k3[1]);\n}\n\nvec3 get_closest_attractor_color(vec2 pos) {\n  float d2_A1 = d2(pos, A1);\n  float d2_A2 = d2(pos, A2);\n  float d2_A3 = d2(pos, A3);\n\n  if(d2_A1 < d2_A2 && d2_A1 < d2_A3)\n    return C1 / (d2_A1 * d2_A1 + EPSILON);\n\n  if(d2_A2 < d2_A3)\n    return C2 / (d2_A2 * d2_A2 + EPSILON);\n\n  return C3 / (d2_A3 * d2_A3 + EPSILON);\n}\n\n// Adhoc adaptive time step loosely\n// based on gravitational potential.\nfloat compute_h(vec2 pos) {\n  vec3 pos3d = vec3(pos, 0);\n\n  float t1 = M_A1 / d2(pos3d, vec3(A1, Z_DISTANCE));\n  float t2 = M_A2 / d2(pos3d, vec3(A2, Z_DISTANCE));\n  float t3 = M_A3 / d2(pos3d, vec3(A3, Z_DISTANCE));\n  \n  float V = (G * (t1 + t2 + t3)); // gravitational potential ish...\n\n  return TS_FACTOR / V;\n}\n\nvec3 get_color(vec2 initial_pos) {\n  vec2[2] y;\n  y[0] = initial_pos;\n  y[1] = vec2(0., 0.0);\n\n  vec3 color = vec3(0);\n\n  float t = 0.;\n  while(t < DURATION) {\n    float h = compute_h(y[0]);\n    rk4(h, y);\n    color += h * get_closest_attractor_color(y[0]);\n    t += h;\n  }\n  \n  return color / DURATION;\n}\n\nvec2 unit_vec(float angle) {\n  return vec2(cos(angle), sin(angle));\n}\n\nvec3 normalize_color(vec3 raw) {\n  return 2.0 / (exp(-EXPOSURE * raw) + 1.0) - 1.0;\n}\n\nvec2 normalize_fragcoord(vec2 frag_coord) {\n  return ((frag_coord / iResolution.x) - 0.5 * vec2(1.0, iResolution.y / iResolution.x)) * SCALE;\n}\n\nvoid init_attractors() {\n  A1 = sin(-iTime * SPEED * 3.0) * unit_vec(-iTime * SPEED * 11.0);\n  A2 = 1.2 * unit_vec(iTime * SPEED * 5.0);\n  A3 = normalize_fragcoord(iMouse.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n  init_attractors();\n\n  vec2 pos = normalize_fragcoord(fragCoord);\n\n  vec3 col = get_color(pos);\n  col = normalize_color(col);\n\n  #ifdef SHOW_ATTRACTORS\n    if(d2(A1, pos) < 0.0025)\n      col = C1;\n    if(d2(A2, pos) < 0.0025)\n      col = C2;\n    if(d2(A3, pos) < 0.0025)\n      col = C3;\n  #endif\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1781, 1781, 1807, 1807, 1847], [1849, 1849, 1875, 1875, 1915], [1917, 1917, 1948, 1948, 2488], [3233, 3233, 3277, 3277, 3553], [3555, 3628, 3655, 3655, 3942], [4251, 4251, 4279, 4279, 4320], [4322, 4322, 4354, 4354, 4407], [4409, 4409, 4452, 4452, 4552], [4554, 4554, 4578, 4578, 4731], [4733, 4733, 4788, 4788, 5122]], "test": "untested"}
{"id": "DtyyWK", "name": "spqr hilbert satelite", "author": "spqr", "description": "a", "tags": ["a"], "likes": 10, "viewed": 195, "published": 3, "date": "1700639362", "time_retrieved": "2024-07-30T17:21:10.006787", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\n\n\n\n\n\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  r = smoothstep(0.,1.,r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\n\n\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    //return max(max(q.x,q.y),q.z);\n   return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\n\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n\n\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(sin((p3.x + p3.y) * p3.z)*3523.252);\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\n\n\nfloat confine(vec3 p, vec3 r, vec3 d) {\n \n    vec3 bot = (-d * 0.5 - p)/r;\n    vec3 top =  (d * 0.5 - p)/r;\n\n    vec3 min = min(top, bot);\n\n    float t = max(max(min.x, min.y), min.z);\n\n    return max(t, 0.0); \n}\n\n\n\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise_fast(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\n\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat noise_trig(vec3 p) {\n    \n    vec3 u = vec3(0.);\n    u += sin(p.x) + cos(p.y/2.42) + sin(p.z/5.151);\n    return length(u);\n    \n\n}\nfloat fbm_fast( vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise_trig(freq * p);\n        //res += amp * noise(freq * p);\n      \n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n \nfloat fbm( vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 2; ++i)\n    {\n        //res += amp * noise_fast(freq * p);\n        res += amp * noise(freq * p);\n      \n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat field ( vec3 p , vec3 r) {\n\n   \n  \n  \n\n\n    vec3 dom = vec3(2.);\n    vec2 id = floor(p.xz/dom.xz-0.5);\n    p.xz = (fract(p.xz/dom.xz-0.5)-0.5)*dom.xz;\n   \n    vec3 size = hash33(vec3(id,9.324));\n    float prob = hash21(id);\n    \n    //float lim = .3;\n    \n    //lim += sin(id.x*17.41 + id.y * 21.31)/1.;\n    \n    if ( prob > (sin(tick(iTime*.41))*.5+.5 )*.5 + .5) { \n        size *= -1.;\n    }\n\n \n   \n  \n    float b1 = box(p, size);\n    float bound = confine(p, r, dom)+.2;\n    b1 = min(b1,bound);\n    \n    return b1;\n     \n\n}\n\nfloat map(vec3 p, vec3 r) {\n\n\n\n\n    // geo\n    \n    \n    // cylinder map\n    //vec3 q1  = -vec3(atan(p.y,p.x)*3., length(p.xy)-10.,p.z);\n    \n    // sphere map\n    p  =  vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\n   \n  \n\n    float z = 1e4;\n    float f = 1.;\n    \n    for ( float i = 0.; i < 4.; i++) {\n        p *= f;\n        p += vec3(12.341,0.,41.343)* i;\n        f *= 1.4;\n        float u = field(p,r)/f;\n        z = min(z,u);\n    \n    }\n    return z;\n    \n   \n}\n\n\n\n\n\n\nvec3 norm(vec3 p,vec2 d, vec3 r)\n{\n  return normalize(vec3(\n    map(p+d.yxx,r)-map(p-d.yxx,r),\n    map(p+d.xyx,r)-map(p-d.xyx,r),\n    map(p+d.xxy,r)-map(p-d.xxy,r)\n  ));\n}\n\n\nvec3 norm3(vec3 p,vec3 r) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p,r)-vec3(map(p-off.xyy,r), map(p-off.yxy,r), map(p-off.yyx,r))+0.000001);\n}\nfloat hash( float p )\n{\n\tfloat h = dot(p,127.1);\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13( float p )\n{\n\treturn vec3( hash(p), hash(p+653.13), hash(p+211.22) );\n    \n}\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\nvec3 norm(vec3 p, vec3 r) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p,r)-vec3(map(p-off.xyy,r), map(p-off.yxy,r), map(p-off.yyx,r))+0.000001);\n}\nfloat sinz(float t){ \n    t *= .6;\n    return \n        sin(t) + \n        cos((t+22.5)*2.1)/2.3 + \n        sin((t+40.11)*5.15)/6.1 + \n        cos((t+333.2)*11.)/10.1\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n // nav\n \n float tt = iTime;\n \n  vec3 s = vec3(0,0,-20);\n  vec3 t = vec3(0);\n\n  \n  s.xz *= rot(tick(iTime*.4));\n  s.yz *= rot(cos(tick(iTime*.31)));\n \n  \n  //s.z += sinz(tt*1.)*1.;\n  //t.y += sinz((tt+.1)*4.)*.2;\n  \n \n \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(vec3(0,1,0),cz));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz -= dot(uv,uv)/10.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // mar\n \n  for(float z=0.;z<500.;z++){ \n    //p += (fbm(p))/100.;\n    i = z;\n    d = map(p,r);\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 100.) {\n        break;\n    }\n    dd += d;\n    p += r * d;\n    \n    \n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(0);\n\n\n\n  \n  \n     vec3 n = norm(p,r);\n     vec3 l1 = normalize(vec3(-1,-4,-1));\n     l1.xz *= rot(tt);\n     \n     \n\n   \n     \n        \n     if ( dot(n,l1) < 0.) {\n              l1 = -l1;\n     }\n\n     vec3 h1 = normalize(l1-r);\n     \n     \n     float spec1 =( 0.4 + pow(max(0., dot(n,h1)),41.));\n    \n     float diff = max(0., dot(n,l1));\n     \n     col += diff * (spec1*2.);\n     \n\n\n     if (!hit) {\n        col =  mix( vec3(.2,.3,.5)*2., vec3(.1,.2,.3), pow(dot(vec3(0,0,1), r)*.5+.5, 3.)    );\n    \n     }\n  \n \n     fragColor = vec4(col, 1.0);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 208, 208, 311], [312, 312, 334, 334, 542], [544, 544, 567, 567, 746], [748, 748, 802, 857, 1081], [1083, 1083, 1107, 1107, 1309], [1313, 1313, 1342, 1342, 1407], [1408, 1408, 1450, 1450, 1557], [1559, 1559, 1582, 1582, 1690], [1700, 1700, 1721, 1721, 1770], [1771, 1771, 1791, 1791, 1840], [1842, 1842, 1863, 1863, 1910], [1911, 1911, 1930, 1930, 1999], [2001, 2001, 2026, 2026, 2495], [2497, 2497, 2520, 2520, 2637], [2638, 2638, 2658, 2658, 2842], [2846, 2846, 2875, 2875, 2904], [2908, 2908, 2933, 2933, 2973], [2978, 2978, 2992, 2992, 3032], [3035, 3035, 3071, 3071, 3124], [3151, 3151, 3179, 3179, 3305], [3309, 3309, 3348, 3348, 3425], [3428, 3428, 3458, 3458, 3484], [3489, 3489, 3516, 3516, 3542], [3544, 3544, 3572, 3572, 3603], [3606, 3606, 3629, 3629, 3724], [3725, 3725, 3748, 3748, 3865], [3866, 3866, 3888, 3888, 4054], [4057, 4057, 4096, 4096, 4269], [4274, 4274, 4296, 4296, 4386], [4438, 4438, 4464, 4464, 4758], [4760, 4760, 4786, 4786, 5077], [5081, 5081, 5105, 5105, 5652], [5654, 5654, 5680, 5680, 5790], [5791, 5791, 5816, 5816, 6076], [6079, 6079, 6099, 6099, 6359], [6361, 6361, 6393, 6393, 6893], [6895, 6895, 6922, 7054, 7404], [7411, 7411, 7445, 7445, 7582], [7585, 7585, 7612, 7612, 7739], [7740, 7740, 7763, 7763, 7841], [7843, 7843, 7867, 7867, 7931], [7934, 7934, 7955, 7955, 7978], [7981, 7981, 8008, 8008, 8135], [8136, 8136, 8156, 8156, 8308], [8310, 8310, 8367, 8367, 9874]], "test": "untested"}
{"id": "dlVcWh", "name": "013 - Box spill at the sea", "author": "PiGIon", "description": "Practicing functions and discovering \"ways to do stuff\".\n\nThe challenging part here was discover how to find the origin of all squares based on the sineHalf function.", "tags": ["sea", "square"], "likes": 2, "viewed": 136, "published": 3, "date": "1700627274", "time_retrieved": "2024-07-30T17:21:10.886435", "image_code": "#define rgb(r, g, b) vec3(r/255., g/255., b/255.)\n#define rgba(r, g, b, a) vec4(r/255., g/255., b/255., a)\n\n// y = sin(x)\n// 0 = sin(x) - y\nfloat sineHalf(vec2 uv, float freq, vec2 offset) {\n    return smoothstep(0., 0.05, sin(uv.x*freq - offset.x) - 10.*uv.y + offset.y);\n}\n\nvec3 black;\nvec3 white = vec3(1., 1., 1.);\nvec3 sky = rgb(113., 188., 225.);\n\nfloat square(vec2 uv, vec2 origin, float size, float ang) {\n    vec2 o = (uv - origin) * rot2D(ang);\n    float antiAlias = 1.5/iResolution.y;\n    \n    vec2 range = vec2(size + antiAlias, size - antiAlias);\n    \n    return smoothstep(range.x, range.y, abs(o.x)) * smoothstep(range.x, range.y, abs(o.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord, iFrame);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    float t = iTime * 1.23;\n    float aa = 1.5/iResolution.y;\n    vec4 O = fragColor;\n    // debug\n    //t = (iMouse.x/iResolution.x) * 10.;\n    \n    vec3 col = sky;\n    vec2 off = vec2(t*1.333, -2. - cycle(0.2, t)*-1.);\n    float sine = sineHalf(uv, 1., off);\n    O = vec4(sky, 1.);\n    \n    \n    // this creates an arrow shape, interesting\n    //float s = square(uv, vec2(0., abs(sin(uv.x))), .2, 0.);\n\n    // 0 = sin(uv.x*freq - offset.x) - 10.*uv.y + offset.y\n    // 10.*uv.y = sin(uv.x*freq - offset.x) + offset.y\n    // uv.y = (sin(uv.x*freq - offset.x) + offset.y)/10.\n    for (float i = -ratio; i <= ratio; i += ratio*0.1) {\n        float of = i+0.2*cycle(0.01, t);\n        float s = square(uv, vec2(of, (sin(of - off.x) + off.y)/10.), .02, 0.);\n        O = mix(O, rgba(128., 81., 0., 1.), s);\n\n        s = square(uv, vec2(i+0.01, (sin(i+0.01 - off.x) + off.y)/10.), .03, 0.);\n        O = mix(O, rgba(196., 119., 2., 1.), s);\n    }\n    \n\n    O = mix(O, rgba(45., 148., 185., 1.), sine);\n\n    // Output to screen\n    \n    fragColor = O;\n}", "image_inputs": [], "common_code": "// Util functions created while I study\n// ~ PiGIon\n\n#define PI 3.14159265\n\n// matrix functions\nmat2 rot2D(float ang);\n\n// time cycling functions\nfloat cycle(float perSecond);\nfloat rangeCycle(float size, float perSec);\n\n// shape functions\nfloat circle(vec2 uv, vec2 origin, float size);\nfloat square(vec2 uv, vec2 origin, float size, float ang);\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond, float t) {\n    float d = fract(t * perSecond);\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec, float t) {\n    return mod(t*perSec - size, size) - .5*size;\n}\n\n// matrix rot2D based on pi\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 140, 190, 190, 274], [354, 354, 413, 413, 658], [660, 660, 717, 717, 1917]], "test": "untested"}
{"id": "mtVcWy", "name": "SEIZURE SHADERR AAAAAAAAAHHHHH", "author": "roff", "description": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", "tags": ["seizure"], "likes": 1, "viewed": 142, "published": 3, "date": "1700626406", "time_retrieved": "2024-07-30T17:21:11.704249", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(fract(uv.xy * 10.0 + (-uv.x + iTime) * sin(iTime * 3.0) * 10.0), fract(iTime * 10.0));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 244]], "test": "untested"}
{"id": "mlGyRt", "name": "Fractal Flashing w/ Noise", "author": "itsrelane", "description": "Simple fractal light flashing animation w/ some noise", "tags": ["noise", "abstract", "bright"], "likes": 0, "viewed": 104, "published": 3, "date": "1700624367", "time_retrieved": "2024-07-30T17:21:12.450254", "image_code": "float rand( in float t ) {\n    return fract(sin(t) * 10000.0);\n}\n\nvec3 palette( in float t ) {\n    vec3 a = vec3(rand(t) / 2.0);\n    vec3 b = vec3(rand(t));\n    vec3 c = vec3(1.0, 0.7, 0.4);\n    vec3 d = vec3(0.0, 0.15, 0.2);\n\n    return a + b * cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalise\n    vec2 uv = (fragCoord * 2.0 - 1.0 / iResolution.xy) / iResolution.y;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for (int i = 0; i < 2; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n    \n        float d = length(uv);\n        vec3 col = palette(d + iTime);\n        \n        d = tan(atan(d + iTime) * d);\n\n        d = sin((d * 2.) + (iTime / 2.));\n        d = abs(d);\n\n        d = abs(sin(d)) / 6.;\n\n        d = 0.005 / d;\n\n        finalColor += col * d;\n    }\n    \n    finalColor *= 0.8;\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 64], [66, 66, 94, 94, 271], [273, 273, 330, 347, 883]], "test": "untested"}
{"id": "ctVczG", "name": "Year of Truchets #061", "author": "byt3_m3chanic", "description": "To sync audio - stop/rewind/ then play\nHas a few changes and some flashing \n\nAll year long I'm going to just focus on truchet tiles and the likes!", "tags": ["truchet", "twist", "neonblade"], "likes": 22, "viewed": 296, "published": 3, "date": "1700613570", "time_retrieved": "2024-07-30T17:21:13.214212", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #061\n    11/21/2023  @byt3_m3chanic\n    \n    Audio : MoonDeity - NEON BLADE \n*/\n\n#define PI  3.14159265359\nvec2 curvature = vec2(8.,12.);\n\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.275);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*1.25, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*1.25, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = vec4(baseColor.rgb,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35299, "src": "https://soundcloud.com/satosuguangst/neon-blade", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #060\n    11/18/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n\n    truchet pattern https://www.shadertoy.com/view/ddXyzH\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nmat2 r45,r1,r2;\nvec3 hit,hitPoint;\nfloat tmod=0.,tspeed=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.323); }\nfloat box(vec3 p, vec3 b) {vec3 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e-b), 0., 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq extrude & twist\nfloat opx(in float d, in float p, in float h){\n    vec2 w = vec2(d,abs(p)-h);\n  \treturn min(max(w.x, w.y),0.)+length(max(w,0.));\n}\nvec3 twist( in vec3 p ){\n    float fx = mix(0.,.065,ga1);\n    return vec3(rot((-fx)*p.z)*p.xy,p.z)/1.5;\n}\nvec2 ptile(vec2 uv, float wdx) {\n    vec4 uv1 = vec4(floor(uv),fract(uv)-.5);\n    vec2 id = uv1.xy, q = uv1.zw;\n    \n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    float hs = hash21(id);\n    float wd = .125+.115*sin(uv.y*.25);\n\n    if(hs>.5) q *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    vec2 p = length(q-.5)<length(q+.5)? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    // alt patterns\n    if (hs>.85) d = c;\n    // accents\n    float b = length(abs(q)-.5)-.125;\n\n    return vec2(d,b);\n }\n\nvec2 map(vec3 pos){\n\n    vec2 res = vec2(1e5,0);\n\n    pos = twist(pos);\n    pos.z -= T*5.;\n\n    vec2 k = ptile(pos.xz*.5,.1);\n    float b = opx(k.x,abs(pos.y)-10., 5.)-.02;\n\n    if(b<res.x) {\n        res = vec2(b,2.);\n        hit = pos;\n    }\n\n    float ff = .5+.5*cos(pos.z*.3+T);\n          ff += .75+.75*sin(pos.x*.2+T*2.);\n          float fx = clamp((-.01)+(T*.04),.0,ff);\n    float c = opx(abs(k.y)-.005,abs(pos.y)-5.5, .12+fx)-.02;\n\n    if(c<res.x) {\n        res = vec2(c,3.);\n        hit = pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd){\n\tfloat d = 0.,m = 0.;\n    for(int i=0;i<180;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<42?ray.x*.4:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 mclr1 = vec3(.9);\nvec3 mclr2 = vec3(.01);\nvec3 fog = vec3(.75);\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r45 = rot(.7853981634);\n \n    tmod = mod(T,92.);\n    float t1 = lsp(10.0, 11.0, tmod);\n    float t2 = lsp(85.0, 86.0, tmod);\n    float t3 = lsp(66.0, 67.0, tmod);\n    float t4 = lsp(90.0, 91.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n\n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,2.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    //camera\n    float x = M.xy==vec2(0) || M.z<0. ? .0 : (M.y / R.y * 2.2 - 1.1) * PI;\n    float y = M.xy==vec2(0) || M.z<0. ? .0 : (M.x / R.x * 2.2 - 1.1) * PI;\n    mat2 rx = rot(x), ry = rot(y);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n\n    vec3 C = vec3(0);\n\n    vec2 ray = marcher(ro,rd);\n    float m = ray.y;\n    float d = ray.x;\n    hitPoint = hit;\n\n\n    mclr1=mix(vec3(.9),vec3(.95,0,0),ga2);\n    mclr2=mix(vec3(.95,0,0),vec3(.04),ga1);\n    \n    if(tmod>66.&&tmod<86.) {\n        fog = mod(T*1.5,1.) <.5? vec3(.1) : vec3(.95,0,0);\n    }else if(tmod>86.&&tmod<92.){\n        fog = mod(T*1.,1.) <.5? vec3(.95,0,0) : vec3(.95);\n    }else{\n        float ff = clamp((-.5)+(T*.04),.1,.95);\n        fog = mod(T*5.5,1.) <.5? vec3(.1) : vec3(ff);\n    }\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d,\n             n = normal(p,d);\n        vec3 lpos =vec3(-.5,.75,-15.),\n             l = normalize(lpos-p),\n             h = vec3(.5);\n        \n        float shdw = 1.,\n              diff = clamp(dot(n,l),0.,1.);\n              \n        for( float t=.1; t < 8.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>8. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        if(m==2.) h = mclr1;\n        if(m==3.) h = mclr2;\n\n        C = diff * h;\n    } \n    \n    float fde = clamp((-.1)+(T*.05),.0,1.);\n    C = mix(C,fog,1.-exp(-.000003*d*d*d));\n    C = pow(C*fde, vec3(.4545));\n    O = vec4(C,1.);\n}\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVczG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[259, 259, 282, 282, 443], [445, 445, 503, 503, 665], [667, 667, 723, 723, 878], [916, 916, 973, 973, 1486]], "test": "untested"}
{"id": "dtKyDG", "name": "angle fractals", "author": "makscee", "description": "a fractal looking kind of thing", "tags": ["fractal"], "likes": 6, "viewed": 129, "published": 3, "date": "1700612004", "time_retrieved": "2024-07-30T17:21:13.971188", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv *= .5;\n    float t = 0. + iTime * .4 + sin(iTime + uv.x * 5.) * .1 + cos(iTime + sin(uv.y * 1.) * 10.) * .15;\n    vec2 v = sin(uv * .1 + t * .1);\n    uv *= 2.5 + sin(t * .5) * .3;\n    float angle = t * .03 ;\n    for (int i = 0; i < 100; i++)\n    {\n        uv = (abs(uv) - 1.3) * 1.1;\n        uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    }\n\n    fragColor = vec4(abs(cos(floor((uv.y * 4.2))* 6.)), abs(cos(uv.x + 10.)), abs(sin(floor(uv.y * 1.0))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 591]], "test": "untested"}
{"id": "ctVyDy", "name": "CC0: Simplistic skyline", "author": "mrange", "description": "CC0: Simplistic skyline\nor my own secret purposes created this simple city skyline\n\n", "tags": ["2d", "city"], "likes": 14, "viewed": 260, "published": 3, "date": "1700604956", "time_retrieved": "2024-07-30T17:21:14.722180", "image_code": "// CC0: Simplistic skyline\n// For my own secret purposes created this simple city skyline\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat hash1(float co) {\n  co += 123.4;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(1.0-q.y);\n  float t = 1.0;\n  for (float i = 0.; i < 4.; ++i) {\n    vec2 cp = p;\n    cp /= 10.0/(10.0+i);\n    float cn = mod1(cp.x, 0.05);\n    float ch = hash1(cn+123.4*float(i))*smoothstep(32.0, 4.0, abs(cn))*step(1.0, abs(cn));\n    t = min(t,mix(i*0.125, 1.0, step(0.7*ch, p.y)));\n  }\n  col *= t;\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 189, 189, 313], [315, 315, 338, 338, 401], [403, 403, 460, 460, 927]], "test": "untested"}
{"id": "ctVcWy", "name": "Barnsley Fern Fossil", "author": "Real_NC", "description": "Naive Barnsley Fern stylized to look a bit like a limestone fossil.", "tags": ["fractal", "barnsley", "fern", "fossil"], "likes": 11, "viewed": 205, "published": 3, "date": "1700604249", "time_retrieved": "2024-07-30T17:21:15.526030", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = 0.5*(0.9 + 0.1*texture(iChannel1,fragCoord/iResolution.xy))/(0.5+texelFetch(iChannel0, ivec2(fragCoord), 0));\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    if(max(fc.x,fc.y) > SPEED) discard;\n    \n    \n    if(iFrame == 0) fragColor = vec4(0);\n    else\n    {\n        float f = hash(vec3(fragCoord,iFrame));\n        fragColor = texelFetch(iChannel0, fc, 0);\n        int n = 1; // 85%\n        if(f <= 0.01) n = 0; // 1%\n        else if(f <= 0.08) n = 2; // 7%\n        else if(f <= 0.15) n = 3; // 7%\n        \n        fragColor.xy = fragColor.xy*acbd[n] + ef[n];\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 11.;\n    uv.y += 5.;\n    \n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0) * 0.997;\n    if(iFrame == 0) fragColor = vec4(0);\n    \n    for(ivec2 p = ivec2(0,0); p.x <= SPEED; p.x++)\n    {\n        for(p; p.y <= SPEED; p.y++)\n        {\n            float d = distance(uv, texelFetch(iChannel0, p, 0).xy);\n            fragColor += 0.00004/(0.00004+d*d);\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 24\n\n// Constants for the \"Black Spleenwort\" fern. (Matrix is in a different order than GLSL takes)\nconst mat2[4] acbd = mat2[](\nmat2(0, 0, 0, 0.16),           /*f1*/\nmat2(0.85, -0.04, 0.04, 0.85), /*f2*/\nmat2(0.20, 0.23, -0.26, 0.22), /*f3*/\nmat2(-0.15, -0.26, -0.28, 0.24)  /*f4*/\n);\n\nconst vec2[4] ef   = vec2[](\nvec2(0, 0),   /*f1*/\nvec2(0, 1.6), /*f2*/\nvec2(0, 1.6), /*f3*/\nvec2(0, 0.44) /*f4*/\n);\n//////////////////////////////////////\n// Hash by Dave Hoskins\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 185]], "test": "untested"}
{"id": "clKyWy", "name": "Small mouse drag code", "author": "fishy", "description": "Small utility to use in your projects!", "tags": ["mouse", "scroll", "infinite", "drag", "scrolling"], "likes": 1, "viewed": 142, "published": 3, "date": "1700600768", "time_retrieved": "2024-07-30T17:21:16.370772", "image_code": "// Not trying to make this bit small,\n// but I am trying to make the contents of Buf. A small\n\n#define mouseDrag (texelFetch(iChannel0, ivec2(0, 0), 0).xy)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo = (mouseDrag * 2.0 - iResolution.xy) / iResolution.y;\n\n    fragColor = texture(iChannel1, (uv - mo));\n    fragColor += vec2(smoothstep(0.1, 0.05, length(uv - mo)), 1).xxxy;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Can it get smaller?\n\n// -2 by MysteryPancake:\n//  -1 d.xy = iFrame > 0 ? r(p.x) : vec2(0);\n//  -1 by removing trailing zeroes if(iMouse.w > 0.)\n\n#define r(i) texelFetch(iChannel0, ivec2(i, 0), 0).xy\n#define w(i, t) if (i == p.x) d.rg = t;\n\nvoid mainImage(out vec4 d, vec2 c)\n{\n    ivec2 p = ivec2(c);\n    d.xy = iFrame > 0? r(p.x) : vec2(0);\n    \n    if(iMouse.w > 0.)\n    {\n        w(1, r(0));\n    }\n    else\n        w(0, r(1) + iMouse.xy - abs(iMouse.zw));\n}\n\n/*\nOriginal (232 chars)\n\n\n#define r(i) texelFetch(iChannel0, ivec2(i, 0), 0).xy\n#define w(i, t) if (i == p.x) d.rg = t;\n\nvoid mainImage(out vec4 d, vec2 c)\n{\n    ivec2 p = ivec2(c);\n    d.xy = iFrame == 0? vec2(0) : r(p.x);\n    \n    if(iMouse.w > 0.0)\n    {\n        w(1, r(0));\n    }\n    else\n        w(0, r(1) + iMouse.xy - abs(iMouse.zw));\n}\n\n*/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 214, 214, 467]], "test": "untested"}
{"id": "mlGyDy", "name": "Coffee Cup For You", "author": "kp1197", "description": "A morning cup of coffee just for you, #1 Coder!  Or night cup if you're in a crunch.  My first attempt at a more realistic lighting model.  I think the AA looks ugly, wondering how I can improve the quality. Happy to receive feedback!", "tags": ["fun", "realistic"], "likes": 13, "viewed": 221, "published": 3, "date": "1700591756", "time_retrieved": "2024-07-30T17:21:17.304276", "image_code": "#define PI 3.14159\n#define TAU 2.*PI\n#define SQRT_3 pow(3.,0.5)\n#define AAMIP 3.\n#define AASTEP vec2(pow(2.,AAMIP)/iResolution.x,0.)\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 e = vec2(1./iResolution.x,0.);\n    vec2 coords = fragCoord.xy / iResolution.xy;\n    vec3 oImg = texture(iChannel0, coords, 0.).xyz;\n    // apply a box filter to a lower mip to reduce blockiness of the mip\n    vec3 filteredImg = (texture(iChannel0, coords + AASTEP.xy, AAMIP).xyz + \n                        texture(iChannel0, coords + AASTEP.xx, AAMIP).xyz +\n                        texture(iChannel0, coords + AASTEP.yx, AAMIP).xyz +\n                        texture(iChannel0, coords - AASTEP.xy, AAMIP).xyz + \n                        texture(iChannel0, coords - AASTEP.xx, AAMIP).xyz +\n                        texture(iChannel0, coords - AASTEP.yx, AAMIP).xyz)/6.;\n    // compare saturation and value between filtered and base image to determine when to blend in filtered img\n    float aaMixSignal = max(2. * abs(hsv(oImg).z - hsv(filteredImg).z), abs(hsv(oImg).y - hsv(filteredImg).y)/TAU);\n    //fragColor.xyz = vec3(aaMixSignal) * filteredImg;\n    fragColor = vec4(mix(oImg, filteredImg, aaMixSignal),1.);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Usual incompatibility suspects: https://www.shadertoy.com/view/lstfD2\n/* Various functions from IQ articles */\n\nfloat dSphere(vec4 p, float r) {\n    return length(p.xyz) - r;\n}\n\nfloat dPlane(vec4 p) {\n    return p.z;\n}\n\nfloat dRoundedCylinder( vec4 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat dCappedTorus( vec4 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p.xyz,p.xyz) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat dCappedCylinder( vec4 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2(vec2 x) {\n    return dot(x,x);\n}\n\nfloat dHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    //outNormal = (tN>0.0) ? step(vec3(tN),t1)) : // ro ouside the box\n    //                       step(t2,vec3(tF)));  // ro inside the box\n    //outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n// intrinsic rotation about x-axis, y-axis, z-axis respectively, followed by translation \nmat4 transform(in vec3 rot, in vec3 tx) {\n\n    float cos_alpha = cos(rot.z);\n    float sin_alpha = sin(rot.z);\n    float cos_beta = cos(rot.y);\n    float sin_beta = sin(rot.y);\n    float cos_gamma = cos(rot.x);\n    float sin_gamma = sin(rot.x);\n\n    return mat4( cos_alpha * cos_beta,  \\\n        cos_alpha * sin_beta * sin_gamma - sin_alpha * cos_gamma,\\\n        cos_alpha * sin_beta * cos_gamma + sin_alpha * sin_gamma,\\\n        0.,\\\n        sin_alpha * cos_beta,\\\n        sin_alpha * sin_beta * sin_gamma + cos_alpha * cos_gamma, \\\n        sin_alpha * sin_beta * cos_gamma - cos_alpha * sin_gamma, \\\n        0.,\\\n        -sin_beta, \\\n        cos_beta * sin_gamma, \\\n        cos_beta * cos_gamma,\\\n        0.,\\\n        tx.x,tx.y,tx.z,1.);\n}\n\n// https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n}\n\n\n", "buffer_a_code": "#define MAX_D 50.\n#define MAX_STEPS 300\n#define EPS 1e-5\n#define PI 3.14159\n#define TABLE_MATERIAL_ID 1.\n#define CUP_MATERIAL_ID 2.\n#define TABLE_BEAM_MATERIAL_ID 3.\n#define IDENTITY mat4(1.,0.,0.,0.,  0.,1.,0.,0., 0.,0.,1.,0., 0.,0.,0.,1.)\n#define STEAM_VOLUME_ARGS 1.1, 0.8\n#define VOLUME_STEP 0.1\n\n#define DEBUGGING 1\n#define CHARACTERS iChannel3\n#define WRITE_START vec2 text_uv = fragCoord.xy / iResolution.y; vec2 U = ( text_uv - vec2(.5,.8) ) * 8.; int char_id = -1; vec2 char_pos, dfdx, dfdy; vec2 R = iResolution.xy; vec2 debug_uv = fragCoord.xy / R.y;\n#define TEXT_ARGS char_id, char_pos, dfdx, dfdy\n#define WRITE_FLOAT fragColor += pFloat(U, \n#define CARRIAGE_RETURN , TEXT_ARGS); U.y += 0.8; \n#define WRITE_END fragColor += draw_char(TEXT_ARGS).xxxx;\n\n\nconst vec3 SKY_COLOR      = vec3(1.64,1.27,0.99);\nconst vec3 KEY_COLOR      = vec3(1.64,1.27,0.99);\nconst vec3 INDIRECT_COLOR = vec3(1.,0.6,0.);\nconst vec3 SKY_LIGHT_DIR = normalize(vec3(0.,-0.9,1));\n\n\nconst vec2 e = vec2(10.*EPS,0.);\n\nmat4 tableTx;\nmat4 tableBeamTx;\nmat4 cupTx;\nmat4 handleTx;\nmat4 steamVolumeTx;\n\n\n\n#if DEBUGGING\nvec4 char(vec2 p, int c, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) { // thighly y-clamped to allow dense text\n        char_id = c;\n\t\tchar_pos = p;\n\t\tdfdx = dFdx;\n\t\tdfdy = dFdy;\n\t}\n    return vec4(0);\n}\nvec4 draw_char(in int char_id, in vec2 char_pos, in vec2 dfdx, in vec2 dfdy) {\n    int c = char_id; vec2 p = char_pos;\n\tvec2 charLoc = p/16.;\n\tfloat charRow = 15.-floor(float(c)/16.);\t\n\tvec2 charFract = fract( vec2(float(c), charRow) / 16. );\n\tvec2 charP = charLoc + charFract;\n    return c < 0 ? vec4(0,0,0,1e5) : textureGrad( CHARACTERS, charP, dfdx, dfdy );\n}\n\nvec4 pInt(vec2 p, float n, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec4 v = vec4(0);\n    if (n < 0.) {\n        v += char(p - vec2(-0.5,0), 45, char_id, char_pos, dfdx, dfdy);\n        n = -n;\n\t}\n    for (float i = 7.; i>=0.; i--) {\n        n /=  9.999999; // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.), char_id, char_pos, dfdx, dfdy );\n    }\n\treturn v;\n}\n\n// --- display float8.8\nvec4 pFloat(vec2 p, float n, inout int char_id, inout vec2 char_pos, inout vec2 dfdx, inout vec2 dfdy) {\n    vec4 v = vec4(0);\n    if (n < 0.) {\n\t\tv += char(p - vec2(-.5,0), 45, char_id, char_pos, dfdx, dfdy );\n\t\tn = -n;\n\t}\n    float upper = floor(n);\n    float lower = fract(n)*1e8 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e8) { lower -= 1e8; upper++; }\n    v += pInt(p,upper,char_id,char_pos,dfdx,dfdy); p.x -= 4.;\n    v += char(p, 46,char_id,char_pos,dfdx,dfdy);   p.x -= .5;\n    v += pInt(p,lower,char_id,char_pos,dfdx,dfdy);\n    return v;\n}\n#endif\n\n\n\nvoid matmin(inout float currentD, in float d, inout float currentMaterialID, in float materialID, inout vec4 currentLocalP, in vec4 localP) {\n    float signal = step(d, currentD);\n    currentMaterialID = mix(currentMaterialID, materialID, signal);\n    currentD = mix(currentD, d, signal);\n    currentLocalP = mix(currentLocalP, localP, signal);\n}\n\nfloat textMessage(vec2 surfaceCoordinates) {\n    int char_id = -1; vec2 char_pos, dfdx, dfdy;\n    vec2 p = surfaceCoordinates * vec2(-2.0,2.0) + vec2(0.75,-2.2);\n    float signal = 0.;\n    signal += char(p, 35, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.);\n    signal += char(p, 49, char_id, char_pos, dfdx, dfdy).x; p -= vec2(-1.25,-3.1);\n    signal += char(p, 67, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // C\n    signal += char(p, 79, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // O\n    signal += char(p, 68, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // D\n    signal += char(p, 69, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // E\n    signal += char(p, 82, char_id, char_pos, dfdx, dfdy).x; p -= vec2(0.5,0.); // R\n    signal += draw_char(char_id, char_pos, dfdx, dfdy).x;\n    return signal;\n}\n\nvec3 getMaterialColor(vec4 p, vec4 ray, float materialID) {\n    if (materialID < 0.5) {\n        vec4 cubeMapRay = transform(vec3(0.,0.,-1.1*PI),vec3(0.)) * ray;\n        return SKY_COLOR * pow(texture(iChannel1,cubeMapRay.xyz).xyz,vec3(0.8));//vec3(max(0.,ray.z));\n    }\n    else if (materialID < 1.5) {\n        float waterRingSignal = smoothstep(-0.1,-0.03,-abs(1.-length(p.xz-vec2(0.8,0.1)))); //step(abs(1.-length(p.xz-vec2(0.4,0.1))),0.1);\n        vec3 waterRing = mix(vec3(1.), vec3(1.4), waterRingSignal);\n        return pow(texture(iChannel0,p.xy * p.yz).xyz, vec3(waterRing));\n    }\n    else if (materialID < 2.5) {\n        vec2 surfaceCoordinates = vec2(atan(p.z,p.x)-1.5,0.55-p.y);\n        float heartSignal = dHeart(surfaceCoordinates);\n        vec3 icon = mix(vec3(0.25), vec3(0.25,0.5,0.25), step(heartSignal,0.));\n        float textSignal = textMessage(surfaceCoordinates);\n        icon = mix(icon, vec3(1.5), textSignal);\n        return pow(texture(iChannel2,p.xy * p.zz).xyz,vec3(icon));\n    }\n    else if (materialID < 3.5) {\n        return texture(iChannel2, p.xz * p.xy).xyz;\n    }\n    else {\n        return SKY_COLOR;\n    }\n}\n\nfloat map(in vec4 p, in vec4 r, inout vec4 currentLocalP, inout float currentMaterialID) {\n\n    float currentD = MAX_D;\n\n    // table surface\n    vec4 tableP = (tableTx * p);\n    float tableD = dRoundedCylinder(tableP, 2.65, 0.2, 0.1);\n    matmin(currentD, tableD, currentMaterialID, TABLE_MATERIAL_ID, currentLocalP, tableP);\n\n    // table beam\n    vec4 tableBeamP = (tableBeamTx * p);\n    float tableBeamD = dCappedCylinder(tableBeamP, 2.05, 0.312);\n    matmin(currentD, tableBeamD, currentMaterialID, TABLE_BEAM_MATERIAL_ID, currentLocalP, tableBeamP);        \n\n    // cup\n    vec4 cupP = cupTx * p;\n    float cupD = dRoundedCylinder(cupP, 0.5, 0.2, 1.);\n    //matmin(currentD, cupD, currentMaterialID, CUP_MATERIAL_ID, currentLocalP, cupP);\n\n    // handle\n    vec4 handleP = handleTx * p;\n    float handleD = dCappedTorus(handleP, vec2(1,0.0), 0.6, 0.15);\n    \n    // cup/handle smin. TODO: matsmin\n    float mugD = smin(cupD,handleD,0.05);\n    matmin(currentD, mugD, currentMaterialID, CUP_MATERIAL_ID, currentLocalP, cupP); \n    \n    return currentD;\n}\n\nstruct Scene {\n    vec4 localP;\n    vec4 objP;\n    float materialID;\n    vec3 surfaceNormal;\n};\n\n\nScene sceneQuery(in vec4 p, in vec4 r) {\n    float hit = 0.;\n    float currentMaterialID = 0.;\n    float totalD = 0.;\n    vec4 currentLocalP = p;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        float d = map(p, r, currentLocalP, currentMaterialID);\n        totalD += d;\n        \n        if (d < EPS) {\n            hit = 1.;\n            break;\n        }\n        if (totalD > MAX_D) {\n            break;\n        }\n        if (i == MAX_STEPS - 1) {\n            // you tried, raymarcher.  You get an 'A' for effort.\n            hit = 1.;\n        }\n        \n        p += vec4(d * r.xyz, 0.);\n    }\n    currentMaterialID *= hit;\n    vec3 surfaceNormal;\n    if (hit > 0.) {\n        vec4 _p = vec4(0.); float _f = 0.;\n        surfaceNormal = normalize(vec3(\\\n            map(p+e.xyyy,r,_p,_f) - map(p-e.xyyy,r,_p,_f),\n            map(p+e.yxyy,r,_p,_f) - map(p-e.yxyy,r,_p,_f),\n            map(p+e.yyxy,r,_p,_f) - map(p-e.yyxy,r,_p,_f)) / (2.*e.x));\n    }\n    else {\n        surfaceNormal = vec3(0.);\n    }\n    return Scene(currentLocalP, p, currentMaterialID, surfaceNormal);\n}\n\nfloat steamDensity(vec3 steamP) {\n    float density = simplex3d(steamP.xyz - vec3(0.,0.,0.5*iTime));\n    float radialDistance = length(steamP.xy);\n    float verticalDistance = 1.;//abs(steamP.z);\n    float attenuation = pow(max(0.,0.8 - radialDistance)/0.8,1.5);// * pow(max(0.,3.-verticalDistance)/3.,2.);\n    return max(0.,density * attenuation);\n}\n\nvec4 steamInfo(vec3 steamP) {\n    // TODO: directional derivative\n    float density = steamDensity(steamP);\n    const float K = 50.;\n    float dx = steamDensity(steamP + K * e.xyy) - steamDensity(steamP - K * e.xyy);\n    float dy = steamDensity(steamP + K * e.yxy) - steamDensity(steamP - K * e.yxy);\n    float dz = steamDensity(steamP + K * e.yyx) - steamDensity(steamP - K * e.yyx);\n    return vec4(normalize(vec3(dx,dy,dz)/(2.*e.x)), density);\n}\n\n\nvec2 steamVolumeIntersectionD(in vec4 p, in vec4 r) {\n    vec3 steamP = (steamVolumeTx * p).xyz;\n    vec3 steamR = r.xyz; // i'm not rotating the volume in any way, so no need\n    return boxIntersection( steamP, steamR, vec3(1.,1.,2.) );\n}\n\n// i'll leave self shadowing to another exercise\nvec2 steamQuery(in vec4 p, in vec4 r, in vec4 sceneIntersectPos, in vec4 lightPos) {\n    float dSceneIntersection = length(p.xyz - sceneIntersectPos.xyz);\n    vec2 dSteamVolume = max(vec2(0.), steamVolumeIntersectionD(p, r));\n    vec2 dMarchBounds = vec2(min(dSteamVolume.x, dSceneIntersection), min(dSteamVolume.y, dSceneIntersection));\n    float lighting = 0.;\n    float occlusion = 0.;\n    float dSpan = dMarchBounds.y - dMarchBounds.x;\n    float dIncr = VOLUME_STEP/dSpan;\n    for (float dFrac = 0.; dFrac < 1.; dFrac += 0.2) {\n        float d = dMarchBounds.x + dFrac * dSpan;\n        vec3 steamP = (steamVolumeTx * vec4(p.xyz + d * r.xyz,1.)).xyz;\n        vec4 s = steamInfo(steamP.xyz);\n        vec3 steamVolumeNormal = s.xyz;\n        vec3 keyLightDir = normalize(p.xyz - lightPos.xyz);  \n        float density = s.w;\n        lighting += density * VOLUME_STEP * clamp(dot(steamVolumeNormal, keyLightDir), 0., 1.);\n        occlusion += density * VOLUME_STEP;\n    }\n    return vec2(lighting, 5. * occlusion); // i bumped up the occlusion just to make the smoke occlusion more obvious in shadows\n}\n\n// 0.0 -> occluded.  1.0 -> illuminated;\nfloat occlusionQuery(in Scene result, in vec4 lightPos) {\n    vec4 objPos = result.objP;\n    float d = MAX_D;\n    float totalD = 0.;\n    vec4 currentLocalP = lightPos;\n    vec4 lightRay = vec4(normalize(objPos.xyz - lightPos.xyz),1.);\n    float currentMaterialID = 0.;\n    float penumbra = 1.0;\n    vec4 currentPos = lightPos;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(currentPos, lightRay, currentLocalP, currentMaterialID);\n        totalD += d;\n        float distanceFromObj = length(objPos.xyz - currentPos.xyz);\n        penumbra = min(penumbra, 15. * (d + EPS)/ (distanceFromObj+EPS));\n        if (d < EPS) {\n            // if the object the lightray intersects with is not at objPos, the ray was blocked.\n            float unoccluded = step(length(currentPos.xyz - objPos.xyz), 100.*EPS);\n            float softShadow = penumbra * unoccluded;\n            float steamOcclusion = steamQuery(lightPos, lightRay, objPos, vec4(0.)).y;\n            softShadow -= (softShadow) * steamOcclusion * unoccluded;\n            return softShadow;\n        }\n        if (totalD > MAX_D) {\n            break;\n        }\n        currentPos += vec4(d * lightRay.xyz,0.);\n    }\n    return 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // for debugging / tweaking by mouse\n    float controlSignal1 = (iMouse.x/iResolution.x * 10.);\n    float controlSignal2 = iMouse.y/iResolution.y * 0.1;\n\n    // cam setup\n    vec4 p = vec4(fragCoord/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x), -1, 1.).xzyw;\n    vec4 r = vec4(normalize(p.xyz),1.);    \n    float t = 0.1 * iTime + (1.-sign(iMouse.z));\n    float rotateT =  0.25 * sin(t);\n    float viewDistance = 6. + 0.1 * controlSignal1;    \n    vec3 camRx = (vec3(0.,0.,rotateT));\n    p = vec4(vec3(0.,-10.,0.) + (viewDistance) * vec3(sin(rotateT), cos(rotateT), 0.05 - controlSignal2),1.);    \n    r = transform(camRx, vec3(0.)) * r;\n    \n    // pre-calculate rotation matrices\n    // I tweaked all of these by wiring up controlSignal and then copying the value written out to screen\n    tableTx  = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-1.49)));\n    tableBeamTx = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-3.8)));\n    cupTx    = inverse(transform(vec3(PI/2.,0.,0.), vec3(0.,-10.,-0.01))); \n    handleTx = inverse(transform(vec3(PI/2.,0.,-PI/2.), vec3(-1.,-10.,0.)));\n    steamVolumeTx = inverse(transform(vec3(0.,0.,0.), vec3(0.,-10.,2.2)));\n       \n    // raymarch\n    Scene scene = sceneQuery(p,r);\n    \n    // lighting setup\n    vec4 keyLightPos = vec4(8., -4.87,10.,1.);\n    vec3 keyLightDir = normalize(keyLightPos.xyz - scene.objP.xyz);//normalize((transform(vec3(0.616,0.369,0.),vec3(0.)) * vec4(0.,0.,1.,1.)).xyz);\n    vec3 skyLightDir = SKY_LIGHT_DIR; //normalize((transform(vec3(0.,1.42,0.),vec3(0.)) * vec4(0.,0.,1.,1.)).xyz);\n    \n    vec3 keyLightH = normalize(-r.xyz + keyLightDir.xyz);\n    vec3 skyLightH = normalize(-r.xyz + skyLightDir.xyz);\n    \n    // occlusion queries\n    float skyLightOcc = occlusionQuery(scene,  scene.objP + vec4(10.*skyLightDir,0.));\n    float keyLightOcc = occlusionQuery(scene,  keyLightPos);\n    float fakeIndOcc  = occlusionQuery(scene,  scene.objP + vec4(0.,0.,-0.00375,0.)) * float(scene.materialID != TABLE_MATERIAL_ID);\n    \n    vec3 materialColor = getMaterialColor(scene.localP, r, scene.materialID);\n    vec2 steamInfo     = steamQuery(p, r, scene.objP, keyLightPos);\n    \n    vec3 lin = vec3(0.);\n    if (scene.materialID > 0.5) {\n        lin     += 0.16 * vec3(1.); // ambient\n        lin     += 0.55 * skyLightOcc * clamp(dot(skyLightDir,scene.surfaceNormal), 0., 1.) * SKY_COLOR; // sky\n        lin     += 0.25 * keyLightOcc * clamp(dot(keyLightDir,scene.surfaceNormal), 0., 1.) * KEY_COLOR; // key\n        lin     += 0.05 * fakeIndOcc  * clamp(dot(vec3(0.,0.,-1.),scene.surfaceNormal), 0., 1.) * INDIRECT_COLOR; // indirect\n        lin     += 0.15 * keyLightOcc * pow(max(dot(keyLightH, scene.surfaceNormal), 0.), 8.) * SKY_COLOR;\n        lin     += 0.85 * skyLightH   * pow(max(dot(skyLightH, scene.surfaceNormal), 0.), 8.) * KEY_COLOR;\n    }\n    else {\n        lin += 0.3;\n    }\n    lin     += (0.80) * steamInfo.x * KEY_COLOR;\n    \n    vec3 color = pow(abs(materialColor * lin), vec3(1.0/2.2));\n    fragColor = vec4(clamp(color, vec3(0.), vec3(1.)),1.);\n    \n    //fragColor.xyz = vec3(steamInfo.x);\n    \n    /*\n    #if DEBUGGING\n\tWRITE_START\n    WRITE_FLOAT controlSignal1 CARRIAGE_RETURN\n    WRITE_FLOAT controlSignal2 CARRIAGE_RETURN\n    WRITE_END \n    #endif\n    */\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 193, 193, 1218]], "test": "untested"}
{"id": "ctGyWy", "name": "light_and_ball", "author": "vortmax", "description": "simple flare simulation", "tags": ["light", "ball", "flare"], "likes": 0, "viewed": 86, "published": 3, "date": "1700591631", "time_retrieved": "2024-07-30T17:21:18.060255", "image_code": "struct ellipse\n{\n    vec2 position;\n    vec2 radius;\n};\n\nstruct radial\n{\n    float fi;\n    float dist;\n};\n\nvec2 screen2uv(vec2 glCoord, vec2 glRes)\n{\n    return (glCoord.xy - 0.5 * glRes.xy) / glRes.y; \n}\n\nvec2 getAbsPosition(ellipse e, radial point)\n{\n    return vec2(cos(point.fi), sin(point.fi)) \n        * point.dist \n        * e.radius\n        + e.position;\n}\n\nbool contains(ellipse e, vec2 point)\n{\n    return length(e.position - point) <= e.radius.x * e.radius.y;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ellipse ball = ellipse(vec2(0.0, 0.0), vec2(0.7));\n    //radial flare = radial(radians(180.0), 0.4);\n\n    vec2 uvFrag = screen2uv(fragCoord.xy, iResolution.xy);\n    vec2 uvMouse = screen2uv(iMouse.xy, iResolution.xy);\n    \n    vec3 color = vec3(0.0);\n    float intensity = length(uvFrag - uvMouse);\n\n    if(contains(ball, uvFrag))\n    {\n        //vec2 uvFlare = getAbsPosition(ball, flare);\n        //float intensity = length(uvFrag - uvFlare);\n\n        color = vec3(1.0, 1.0 - intensity, intensity);\n    }\n    else\n    {\n        color = vec3(1.0 - intensity);\n    }\n    \n    \n\n \n        \n    fragColor = vec4(color,1.0);\n}\n\n\n//vec3 col = 0.5 + 0.5 * sin(64.0 * (iTime + uv.xyx + vec3(0,1,2)));\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 149, 149, 204], [206, 206, 252, 252, 364], [366, 366, 404, 404, 472], [476, 476, 533, 533, 1161]], "test": "untested"}
{"id": "ctycRG", "name": "electricity", "author": "mippolito", "description": "videobingo electricity", "tags": ["electricity"], "likes": 0, "viewed": 128, "published": 3, "date": "1700585323", "time_retrieved": "2024-07-30T17:21:18.807257", "image_code": "#define TWO_PI 3.1415926535\n\nfloat rand(float n){return fract( sin(n) * 43758.5453123);}\nfloat rand2(float n){return fract(cos(n) * 999742.235690);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise2(float p){\n\tfloat fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand2(fl), rand2(fl + 1.0), fc);\n}\n\nfloat rect(float x){\n    float d = 0.1;\n    if(x < d){\n       return x/d;\n    }\n    if(x < 1.-d){\n        return 1.;\n    }\n    \n    return (1.-x)/d;\n}\n\nfloat line(vec2 point, float t){\n    float z = point.x*50. + t*10.;\n    float k = rand(t) * rand(t*0.5);\n    //float k = rand(rand2(iTime + point.x) * point.x * 0.1);\n    float y = 0.5 + 0.25*(noise2(z*k)-noise(z*k))*rect(point.x);//0.5+0.3*sin(20.*TWO_PI*point.x);\n    float r = length(point - vec2(point.x,y));\n    return 0.025/r;\n}\n\n\n\nfloat line2(vec2 point, float t){\n    float z = point.x*50.;\n    float y =0.5 + 0.25*(noise2(z)-noise(z))*rect(point.x);\n    float r = length(point - vec2(point.x,y));\n    return 0.025/r;\n}\n\nfloat line3(vec2 point, float t){\n    float z = noise(7.*point.x + t*20.)-noise(50.*point.x - t*25.);\n    float k = 1.;//noise(200.*point.x + t*0.1);\n    float y = 0.5;\n    float y2 = 0.5  + 0.3*(noise2(z*k)-noise(z*k));\n    float r  = length(point - vec2(point.x+0.01,y));\n    float r2 = length(point - vec2(point.x-0.03,y2));\n    return 0.01/(r * r2) + 0.1/r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.45,0.15,0.55)*vec3(line3(uv,iTime));//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctycRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 49, 49, 88], [89, 89, 110, 110, 148], [150, 150, 171, 171, 263], [265, 265, 287, 287, 381], [383, 383, 403, 403, 533], [535, 535, 567, 567, 869], [873, 873, 906, 906, 1062], [1064, 1064, 1097, 1097, 1427], [1430, 1430, 1487, 1537, 1769]], "test": "untested"}
{"id": "dtycWG", "name": "perception of blue til.w.transf2", "author": "FabriceNeyret2", "description": "exact tiling of random points is easily perceived,\nwhile random tile orientation (among 2) masks it.\nbluenoise rotation only ( to avoid mirroring in edges )version of https://shadertoy.com/view/DlycDy\nClick to see tiles.", "tags": ["tiling"], "likes": 5, "viewed": 248, "published": 3, "date": "1700584502", "time_retrieved": "2024-07-30T17:21:19.561241", "image_code": "// rotation only variant of https://shadertoy.com/view/DlycDy\n// variant of https://shadertoy.com/view/mlKczd\n// using tilable bluenoise of https://www.shadertoy.com/view/4dSyDR\n// variant of https://shadertoy.com/view/dtKczd\n\nfloat hash( uint n ) { // from https://www.shadertoy.com/view/llGSzw  Base: Hugo Elias. ToFloat: https://iquilezles.org/articles/sfrand\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.;\n}\nvec2 M = vec2(128.);\nvec4 noise(vec2 U) {\n    U = mod(U,M.x) + M.y; // avoids grid glitch by doing modulo here\n    U-=.5; return vec4( hash(uint(U.x+iResolution.x*U.y)) );\n}\n\nvec4 H(vec2 U) {\n#define V(i,j)  noise(U+vec2(i,j))\n  //U=floor(U/8.); \n    vec4 N = 8./9.* noise( U ) \n           - 1./9.*( V(-1,-1)+V(0,-1)+V(1,-1) +V(-1,0)+V(1,0) +V(-1,1)+V(0,1)+V(1,1) );  \n    return N*2. + .5;   // or *1 to avoid saturation at the price of low contrast\n}\n\n//#define H(v)     fract(1e3*sin(dot(v,vec2(73,91))))        // hash\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= 128.;\n    int  h = iFrame/180 % 2 > 0 ? int(4.*H(floor(u))) : 0;   // rand in {0,...3}\n    vec2 U = fract(u);                                       // local frame\n    O *= 0.;\n    if ( iMouse.z>0. && min(U.x,U.y)<2./128. ) O.r++;        // if click draw tiles borders\n    if ( h/2%2 > 0 ) U = 1.-U;                               // rand bit2: rot Pi\n    if ( h%2   > 0 ) U = vec2(1.-U.y,U);                     // rand bit1: rot Pi/2\n    O += vec4( H(U*128.).x  );                               // draw random dots (same in each tile)\n  }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtycWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 249, 362, 497], [519, 519, 539, 539, 671], [673, 673, 689, 689, 950], [1022, 1022, 1060, 1060, 1608]], "test": "untested"}
{"id": "DlycDy", "name": "perception of blue til. w.transf", "author": "FabriceNeyret2", "description": "exact tiling of random points is easily perceived,\nwhile random tile orientation (among 2) masks it.\nbluenoise version of https://shadertoy.com/view/mlKczd\nClick to see tiles.", "tags": ["tiling"], "likes": 4, "viewed": 192, "published": 3, "date": "1700582715", "time_retrieved": "2024-07-30T17:21:20.394015", "image_code": "// variant of https://shadertoy.com/view/mlKczd\n// using tilable bluenoise of https://www.shadertoy.com/view/4dSyDR\n// variant of https://shadertoy.com/view/dtKczd\n\nfloat hash( uint n ) { // from https://www.shadertoy.com/view/llGSzw  Base: Hugo Elias. ToFloat: https://iquilezles.org/articles/sfrand\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.;\n}\nvec2 M = vec2(128.);\nvec4 noise(vec2 U) {\n    U = mod(U,M.x) + M.y; // avoids grid glitch by doing modulo here\n    U-=.5; return vec4( hash(uint(U.x+iResolution.x*U.y)) );\n}\n\nvec4 H(vec2 U) {\n#define V(i,j)  noise(U+vec2(i,j))\n  //U=floor(U/8.); \n    vec4 N = 8./9.* noise( U ) \n           - 1./9.*( V(-1,-1)+V(0,-1)+V(1,-1) +V(-1,0)+V(1,0) +V(-1,1)+V(0,1)+V(1,1) );  \n    return N*2. + .5;   // or *1 to avoid saturation at the price of low contrast\n}\n\n//#define H(v)     fract(1e3*sin(dot(v,vec2(73,91))))          // hash\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= 128.;\n    int  h = iFrame/180 % 2 > 0 ? int(8.*H(floor(u))) : 0;   // rand in {0,...7}\n    vec2 U = fract(u);                                       // local frame\n    O *= 0.;\n    if ( iMouse.z>0. && min(U.x,U.y)<2./128. ) O.r++;        // if click draw tiles borders\n    if ( h/4   > 0 ) U = U.yx;                               // rand bit3: symmetry\n    if ( h/2%2 > 0 ) U = 1.-U;                               // rand bit2: rot Pi\n    if ( h%2   > 0 ) U = vec2(1.-U.y,U);                     // rand bit1: rot Pi/2\n    O += vec4( H(U*128.).x  );                                 // draw random dots (same in each tile)\n  }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 187, 300, 435], [457, 457, 477, 477, 609], [611, 611, 627, 627, 888], [962, 962, 1000, 1000, 1634]], "test": "untested"}
{"id": "clGcDy", "name": "Dynamic Geometric Color mousable", "author": "timmaffett", "description": "Bounce time over TIME_FRAME_OF_BOUNCE period, alllow mouse to interact X rotates, Y zooms", "tags": ["lmage"], "likes": 4, "viewed": 250, "published": 3, "date": "1700582419", "time_retrieved": "2024-07-30T17:21:21.153983", "image_code": "// Fork of \"Dynamic Geometric Color Flow\" by wwwww. https://shadertoy.com/view/DldyDX\n// 2023-11-21 14:11:55\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define TIME_FRAME_OF_BOUNCE  100.0     // after 100 seconds it get's too chaotic so I bounce backwards \n\n// floating point only version\nfloat recomputeTimeIntoSeeSawOfTimeframe(float theTime) {\n   float timeSlice = theTime/TIME_FRAME_OF_BOUNCE;\n   float numIterations = floor( timeSlice );\n   float posInSlice = fract(timeSlice);\n   \n   // is this a even or odd slice, even slices go backwards..\n   if( fract(numIterations/2.0) == 0.0) {\n       // even slice, go forwards through slice\n       return TIME_FRAME_OF_BOUNCE*posInSlice;\n   } else {\n       // backwards through Time Slice\n       return TIME_FRAME_OF_BOUNCE*(1.0-posInSlice);\n   }\n}\n\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.1) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 finalColor = vec3(0.0);\n\n    // make time bounce back and forth over TIME_FRAME_OF_BOUNCE period\n    float theTime = recomputeTimeIntoSeeSawOfTimeframe( iTime);\n    \n    // allow mouse to rotate/zoom\n    uv = mouseRotZoom(uv);\n\n    vec2 uv0 = uv;\n    \n    float time = theTime * 0.2;\n    \n\n    for (float i = 0.0; i < 4.0; i++) {\n        // 特定の時間に基づいて変化する幾何学的変換\n        //Geometric transformation that changes based on a specific time\n        /*TMM\n        if (iTime > 5.0) {\n        TMM*/\n        \n        \n            uv = uv + vec2(sin(uv.y * time), cos(uv.x * time));\n        /*TMM\n        } else {\n            uv = fract(uv * 1.5) - 0.5;\n        }\n        TMM*/\n        \n        float d = length(uv) * exp(-length(uv0));\n\n        // カラーパターンの多様化\n        //Diversification of color patterns\n        vec3 col = palette(length(uv0) + i * .4 + theTime/*iTime*/ * .4);\n        vec3 newCol = vec3(sin(time), cos(time), sin(time) * cos(time));\n        col = mix(col, newCol, 0.5); // 新しい色と既存の色をミックス //Mix new and existing colors\n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 135, 135, 319], [427, 458, 515, 515, 965], [1038, 1038, 1057, 1057, 1106], [1108, 1108, 1136, 1175, 1344], [1346, 1346, 1401, 1401, 2765]], "test": "untested"}
{"id": "DlyyDy", "name": "resizing ellipse", "author": "adiseagle", "description": "simple ellipse, resizing and changing colour", "tags": ["2d", "ellipse"], "likes": 1, "viewed": 102, "published": 3, "date": "1700581978", "time_retrieved": "2024-07-30T17:21:21.929908", "image_code": "float rad = 100.0;\nfloat fociDist = 150.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rad *= (2.0 + sin(iTime));\n    fociDist *= (2.0 + sin(iTime));\n    vec2 centre = iResolution.xy * 0.5;\n    vec2 leftF = centre - vec2(fociDist * 0.5, 0);\n    vec2 rightF = centre + vec2(fociDist * 0.5, 0);\n    float d = ((length(leftF - fragCoord) + length(rightF - fragCoord)) * 0.5) - rad;\n    d = clamp(d, 0.0, 1.0);\n    float t = 1.0 - d;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col * t, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 584]], "test": "untested"}
{"id": "DlycDG", "name": "rt_sky", "author": "vortmax", "description": "looks like a sky during the day and night", "tags": ["sky", "realtime"], "likes": 0, "viewed": 96, "published": 3, "date": "1700578524", "time_retrieved": "2024-07-30T17:21:22.695860", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //vec3 col = 0.5 + 0.5 * sin(64.0 * (iTime + uv.xyx + vec3(0,1,2)));\n    \n    \n    \n    \n    \n    vec3 col = 0.5 + 0.5 * cos(0.75 * (iTime + uv.xyx + vec3(0,1,2)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 332]], "test": "untested"}
{"id": "DlyyWG", "name": "perception of Hextiling w transf", "author": "FabriceNeyret2", "description": "exact tiling of random points is easily perceived,\nwhile random tile orientation (among 2) masks it.\nhere, ~hexa variant of https://shadertoy.com/view/mlKczd\nClick to see tiles.", "tags": ["tiling"], "likes": 7, "viewed": 194, "published": 3, "date": "1700574834", "time_retrieved": "2024-07-30T17:21:23.450842", "image_code": "// variant of https://shadertoy.com/view/mlKczd\n// variant of https://shadertoy.com/view/dtKczd\n\n#define H(v)     fract(1e3*sin(dot(v,vec2(73,91))))          // hash\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= 128.;\n    if ( int(u.y)%2 > 0 ) u.x +=.5;                          // ~hexa: shift odd lines by 1/2\n    vec2 U = fract(u);                                       // local frame\n    int  h = iFrame/180 % 2 > 0 ? int(8.*H(floor(u))) : 0;   // rand in {0,...7}\n    O *= 0.;\n    if ( iMouse.z>0. && min(U.x,U.y)<2./128. ) O.r++;        // if click draw tiles borders\n    if ( h/4   > 0 ) U = U.yx;                               // rand bit3: symmetry\n    if ( h/2%2 > 0 ) U = 1.-U;                               // rand bit2: rot Pi\n    if ( h%2   > 0 ) U = vec2(1.-U.y,U);                     // rand bit1: rot Pi/2\n    O += vec4( H(U) > .99 );                                 // draw random dots (same in each tile)\n  }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 205, 205, 931]], "test": "untested"}
{"id": "dsGcDz", "name": "Extruded Tron Circuit", "author": "Shane", "description": "Extruded Tron circuit, otherwise known as a multipoint nonintersecting random walk. Tap the screen to reset and produce another pattern.", "tags": ["raymarch", "tron", "random", "snake", "path", "walk", "circuit", "finding"], "likes": 98, "viewed": 995, "published": 3, "date": "1700573703", "time_retrieved": "2024-07-30T17:21:24.376367", "image_code": "/*\n\n    Extruded Tron Circuit\n    ---------------------\n    \n    I guess you'd call this a muli-path non-intersecting random walk example, \n    but for anyone old enough to remember, it's a glorified Windows screen saver. :)\n    \n    A few months ago, Shadertoy user, Gunthern, posted a rough 2D version of the \n    Windows pipe screensaver. He must have posted it at a weird time, because it \n    didn't receive a great deal of attention, but I thought it was awesome and \n    wanted to make my own one. Gunthern's was created using brute force array \n    methods, which worked great, but I wanted to use neighboring cell techniques. \n    I hacked away and got there in the end, but the non-intersecting random walk \n    code needs a logical overhaul. At some stage, I'll rewrite it, but for now it \n    works, so I'll leave it alone. By the way, if someone wants to write a nicer \n    cleaner version, I'd welcome that. :)\n    \n    The display code is pretty standard, so there's not much to garnish from that. \n    I took a while to post this because I didn't like the original result. However, \n    I got bored a week ago and added some blinking lights which added the extra \n    detail that I felt was lacking, so here it is. :) The comments have been\n    rushed, so if some of them don't make sense, it's probably because they don't. :)\n    However, I'll tidy them up in due course. I intend to write a 3D version at \n    some stage. Gunthern has one of those too. The link is below.\n    \n    \n    \n    Inspired by:\n    \n    // 2D Windows pipes.\n    Windows Pipe Dream 2D - Gunthern\n    https://www.shadertoy.com/view/mdGGRw\n    \n    // The 3D version.\n    Windows Pipe Dream 3D - Gunthern\n    https://www.shadertoy.com/view/dsGGRw\n\n*/\n \n \n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n    \n// Height map value.\nfloat hm(in vec2 p, float id){ \n\n    float h = .1;\n    if(id>0.) h = .15; // + id/4.;\n    return h;\n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\n\n/////////\n\n// IQ's unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Wrapped texture lookup.\nvec4 aTx(vec2 uv){ \n    uv = mod(uv, SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\n//////////\n \n\n// Global scale.\nfloat gScale = 1./4.;\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n \n// Global cell ID. \nvec2 gIP;\n\n// Constructing the Tron (random walk) pattern.\nvoid tr(inout vec2 oP, inout vec4 d, inout vec2 id){\n\n\n    vec2 p = oP; \n \n   \n    // Positional cell ID and local coordinates. If you didn't want to shift\n    // rows and columns, you wouldn't need any of the code above, nor would you\n    // need the three lines below.\n    vec2 ip = floor(p/gScale);\n    p -= (ip + .5)*gScale;\n    \n    \n    gIP = ip; // Record the ID for usage elsewhere.\n    oP = p; // Record the local position.\n    \n \n\n    \n    // Three distances and IDs, to represent up to three shapes per cell.\n    d = vec4(1e5);\n    \n\n\n/////////\n         \n    \n    // Cell border, border width and line width.\n    float bw = .03;\n    float lw = .325*gScale;\n    vec2 q = abs(p);\n    float sq = max(q.x, q.y) - (.5 - bw)*gScale; // Square boundary.\n\n\n    // Read in from the buffer.\n    vec4 bufA = aTx(ip);\n    // Bit value, telling us which line directions to draw.\n    int iVal = int(bufA.x);\n\n    // Neighboring directions.\n    mat4x2 dir = mat4x2(vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n \n    // Neighboring values.\n    vec4 mDir = vec4(aTx(ip + vec2(-1, 0)).x,  // Left\n                     aTx(ip + vec2(0, 1)).x,   // Up.\n                     aTx(ip + vec2(1, 0)).x,   // Right.\n                     aTx(ip + vec2(0, -1)).x); // Down.\n\n    // Left, up, right, down bits.\n    ivec4 bit = ivec4(1, 2, 4, 8);\n    bit = bit.zwxy; // Left pixel needs a right connection, up pixel needs a down one, etc.\n\n    // Connection values.\n    int cnct = 0;\n    int cnct4 = 0;\n\n    \n    // Debug: Active connections.\n    // int activeCon = 0;\n\n    // Line value.\n    float ln = 1e5;\n\n    // Render the four lines eminating from the cell center.\n    q = p;\n\n    for(int i = 0; i<4; i++){\n\n        //vec2 q2 = rot2(3.14159265/2.*float(i))*(q - dir[i]*.5);\n        \n        // If the direction bit is set, render the line.\n        if((iVal&(1<<i))>0){\n\n           if((int(mDir[i])&bit[i])>0){ // If the neighboring connection exists.\n               \n               // Line.\n               ln = min(ln, distLine(q, vec2(0), dir[i]*gScale*(.5)) - lw);\n               //ln = min(ln, sBoxS(q2, vec2(.5 + lw, lw), 0.));//(.5 + lw\n               cnct++;\n\n               cnct4 += 1<<i;\n\n           }\n           //else activeCon = 1;\n        }\n\n\n    }\n\n////////\n    \n    // Rounded curves. Commenting this out will result in sharp corners.\n    #define CURVES\n\n    #ifdef CURVES\n\n    float sm = .2*gScale;\n    vec2 sz = vec2(.5)*gScale;\n    if(cnct4==3 && iVal == 3) ln = abs(sBoxS(q - vec2(-1, 1)*sz, sz, sm)) - lw;\n    if(cnct4==6 && iVal == 6) ln = abs(sBoxS(q - vec2(1, 1)*sz, sz, sm)) - lw;\n    if(cnct4==12 && iVal == 12) ln = abs(sBoxS(q - vec2(1, -1)*sz, sz, sm)) - lw;\n    if(cnct4==9 && iVal == 9) ln = abs(sBoxS(q - vec2(-1, -1)*sz, sz, sm)) - lw;\n\n \n    #endif  \n\n    // Single square override.\n    // q = abs(fract(p) - .5);\n    \n    // If there are no connections in the cell, render a single nodule. This\n    // was an aesthetic choice, but it's not necessary.\n    if(iVal==0){\n       //ln = sBoxS(q, vec2(.25*gScale), .1*gScale);\n       ln = length(q) - .325*gScale;\n    }\n\n    // If there is just one connecting line, render round circle in the center.\n    // This is another nonfunctional aesthetic choice.\n    if(cnct==1){\n        ln = min(ln, length(q) -.4*gScale);\n        //ln = max(ln, -(length(q) -.05*gScale));\n    }\n\n    \n    // ID.\n    id = ip;\n\n    // Saving some values for later usage.\n    //d.x = max(ln, sq - gScale*.25*.5);\n    d.x = ln; //sq;\n    d.y = bufA.y>-1e-5? hash21(vec2(6, bufA.y)) : bufA.y;\n    d.z = sq;\n    d.w = float(iVal);\n \n}\n\n\n// Glow variable.\nvec3 glow;\n\n  \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    vec4 d; vec2 id;\n    vec2 gP = p.xy;\n    tr(gP, d, id);\n \n    // Extrude the 2D field object along the Z-plane.\n    // A bit of face beveling to reflect the light a little more.\n    float bev = min(-d.x/gScale*2., .2)*.05; // 03;\n    float h2 = hash21(gIP + .04);\n    float h = hm(gIP, d.y);// + d.y*.25; // Cell ID, and individual curve ID.\n    float blockH = .05 + max(d.y*.25, 0.);\n    float obj = opExtrusion(d.x, p.z + blockH + h/2., h/2., .0)  - bev; \n    \n    \n    // Beveling and extruded block.\n    bev = min(-d.z/gScale*2., .2)*.025;\n    float block = opExtrusion(d.z, p.z + blockH/2., blockH/2., .0) - bev;\n    fl = min(fl, block); \n    fl -= smoothstep(0., .125, (abs(fract(d.x*32.) - .5) - .25)/32.)*.25;\n    \n    // Directional ray collision with the square cell boundaries.\n    vec2 rC = (gDir.xy*gScale - gP)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n \n \n    // Last minute glow code.\n    float rW = .05*gScale;\n    if(obj<fl && d.y>-1e-5){//\n    \n        // Color.\n        float id2 = hash21(vec2(d.y, 8));\n        vec3 sCol = .5 + .45*cos(6.72831589*id2/4. + vec3(0, 1, 2.)*1.5);\n        if(hash21(vec2(2, d.y))<.5) sCol = mix(sCol ,sCol.yxz, .9);\n \n        \n        d.x = min(d.x, gCD);\n        float rnd = hash21(gIP + .01);\n        rnd = smoothstep(.8, .95, sin(6.2831589*rnd + iTime*2.))*2. + .25;\n        \n        // Add the glow.\n        glow += sCol*rnd*64./(1. + obj*obj*32.)*smoothstep(0., .35, -(d.x + rW));\n    \n    }\n    \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.7, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(iTime/2., 0, -3), l = o + vec3(.5, 1, 1.5);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(-.2)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n    \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash31(o + r + fract(iTime))*.25;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(r)*.5;\n    gRd = r; \n\n    // Glow initialization.\n    glow = vec3(0);\n    \n    // Raymarch.\n    for(int i = min(iFrame, 0); i<96; i++){ \n        \n        vec3 p = o + r*t;\n        d = m(p); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += min(d*.9, gCD);  // Advance the overall distance closer to the surface.\n         \n    }\n    \n    \n    vec3 svGlow = glow;\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n \n \n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    \n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    /*\n    // Old diffuse and specular calculations.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    float fr = pow(max(1. + dot(r, n), 0.), 2.); // Fresnel.\n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    */\n    \n    // 2D pattern face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec4 d4; vec2 vID;\n    vec2 p2 = p.xy;\n    tr(p2, d4, vID);\n    \n    // Minimum tile object index.\n    int index = 0;//(d4.x<d4.y && d4.x<d4.z)? 0 : d4.y<d4.z? 1 : 2;\n    // 2D object face distance and ID.\n    float obj2D = d4[index];\n    vec2 id = vID*scale;\n    \n    // Object heights.\n    float h2 = hash21(gIP + .04);\n    float blockH = .05 + max(d4.y*.25, 0.);\n    float h = hm(gIP, d4.y) + blockH;// + h2*.125;\n \n \n    // Texture position.\n    vec3 txP = vec3(p2, p.z);\n    vec3 txN = n;\n    vec3 tx = tex3D(iChannel1, txP/2., txN); \n\n     \n\n  \n    // Standard material properties: Roughness, matType and reflectance.\n    //\n    float roughness = .2; // Lower roughness reflects more light, as expected.\n    float matType = 0.; // Dielectric (non conducting): 0, or metallic: 1.\n    float reflectance = .5; // Reflective strength.\n    \n    \n    // Object color.\n    vec3 oCol = vec3(0);\n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along.\n    //\n    if(gObjID == 0){\n    \n    \n       // Floor, or wall, depending on perspective.\n       oCol = vec3(.125);\n       matType = 1.; // Metallic material.\n       roughness = .5;\n       \n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Tron pattern:\n\n        // Noise texture, used for a hacky scratched surface look.\n        // Usually, you'd tailor this to specific material needs.\n        vec3 txR = txP;\n        txR.xy *= rot2(-3.14159/6.);\n        vec3 rTx = tex3D(iChannel2, txR*vec3(.5, 3, .5), txN);\n        float rGr = dot(rTx, vec3(.299, .587, .114));\n \n        \n        // The tile base color.\n         \n        ////////////////    \n\n        float rW = .125*gScale; // Rim width.\n        float sf = .007; // Smoothing factor.\n        float ew = .02; // Edge width.\n\n\n        \n \n        // Face rim and face distance values for edge rendering. \n        float b = abs(obj2D) - .01;\n        float pH = p.z + h - .04;\n        b = max(b, (p.z + h - .02));\n        \n\n        // Object color.\n        vec3 sCol = vec3(.25);\n         \n        \n        \n        // Applying edges to the light color.   \n        vec3 lgtCol = mix(min(sCol*1.4, 1.), vec3(1), .2);\n        lgtCol = mix(lgtCol, oCol*.15, (1. - smoothstep(0., sf, -d4.z)));\n\n\n        // Applying face color patterns, edges, etc..\n        oCol = sCol*.5;\n        oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, pH)));\n        oCol = mix(oCol, sCol, (1. - smoothstep(0., sf, pH + ew)));\n        oCol = mix(oCol, oCol*.15, (1. - smoothstep(0., sf, obj2D + rW)));\n\n        // Mixing in the light color.\n        oCol = mix(oCol, lgtCol, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        //roughness = mix(.6,.2, (1. - smoothstep(0., sf, obj2D + rW + ew)));\n        oCol *= tx*.6 + .9;\n\n        // Dielectic material roughness.\n\n        roughness = .3;\n        roughness *= (rGr*.4 + .6);\n       \n\n        \n    }\n    \n    \n    \n    // More last minute dark texturing and glow.\n    tx = tex3D(iChannel2, p/3., n);\n    oCol *= tx*2. + .2;\n    oCol = oCol + oCol*svGlow;  \n    \n\n    /*\n    // Shiny... Doesn't really work here. Perhaps with extra tweaking.\n    // Requires \"Forest\" cube map loaded into \"iChannel3\".\n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel3, -ref.yzx, 1.); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n    float rf = (matType < .5)? 8. : 1.;//mix(.25, 4., 1. - smoothstep(0., .01, d + .05));\n    oCol += oCol*reflectance*spRef*refTx.zyx*rf; //smoothstep(.03, 1., spRef) \n    */ \n\n\n    // I wanted to use a little more than a constant for ambient light this \n    // time around, but without having to resort to sophisticated methods, then I\n    // remembered Blackle's example, here:\n    // Quick Lighting Tech - blackle\n    // https://www.shadertoy.com/view/ttGfz1\n    float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; // Studio.\n    //float am = length(sin(n*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -n.z); // Outdoor.\n \n    // Cook-Torrance based lighting.\n    vec3 ct = BRDF(oCol, n, ld, -r, matType, roughness, reflectance);\n        \n    // Combining the ambient and microfaceted terms to form the final color:\n    // None of it is technically correct, but it does the job. Note the hacky \n    // ambient shadow term. Shadows on the microfaceted metal doesn't look \n    // right without it... If an expert out there knows of simple ways to \n    // improve this, feel free to let me know. :)\n    c.xyz = (oCol*am*(sh*.5 + .5) + ct*(sh))*ao*at;\n     \n \n    // Save the linear color to the backbuffer.\n    c = pow(max(c, 0.), vec4(1./2.2)); \n\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float SIZE = 36.;\nconst float scale = 1./SIZE;\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, 1.);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n// Hacked together from IQ, Nimitz and Fabrice's hash functions.\nvec3 hash23(in vec2 f){\n     \n    uvec2 p = floatBitsToUint(f);\n    uint  n = 1103515245U*((p.x)^(p.y>>3U));\n    // Converting a uint to a uvec3:\n    // These numbers came from here:\n    // Quality hashes collection WebGL2 - Nimitz.\n    // https://www.shadertoy.com/view/Xt3cDn\n    uvec3 u3 = uvec3(1, 16807U, 48271U);\n    return vec3(((u3*n) >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n    \n    // Dave Hoskins's reliable hash function.\n\t//vec3 p3 = fract(f.xyx*vec3(.1031, .1030, .0973));\n    //p3 += dot(p3, p3.yxz + 423.123);\n    //return fract((p3.xxy+p3.yzz)*p3.zyx);\n     \n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n    vec3 h = normalize(v + l); // Half vector.\n\n    // Standard BRDF dot product calculations.\n    float nv = clamp(dot(n, v), 0., 1.);\n    float nl = clamp(dot(n, l), 0., 1.);\n    float nh = clamp(dot(n, h), 0., 1.);\n    float vh = clamp(dot(v, h), 0., 1.);  \n\n\n    // Specular microfacet (Cook- Torrance) BRDF.\n    //\n    // F0 for dielectics in range [0., .16] \n    // Default FO is (.16 * .5^2) = .04\n    // Common Fresnel values, F(0), or F0 here.\n    // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n    // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n    // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n    vec3 f0 = vec3(.16*(fresRef*fresRef)); \n    // For metals, the base color is used for F0.\n    f0 = mix(f0, col, type);\n    vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n    // Microfacet distribution... Most dominant term.\n    float D = D_GGX(nh, rough); \n    // Geometry self shadowing term.\n    float G = G_Smith(nv, nl, rough); \n    // Combining the terms above.\n    vec3 spec = F*D*G/(4.*max(nv, .001));\n\n\n    // Diffuse calculations.\n    vec3 diff = vec3(nl);\n    diff *= 1. - F; // If not specular, use as diffuse (optional).\n    diff *= (1. - type); // No diffuse for metals.\n\n\n    // Combining diffuse and specular.\n    // You could specify a specular color, multiply it by the base\n    // color, or multiply by a constant. It's up to you.\n    return (col*diff + spec*PI);\n  \n}\n////////////////////", "buffer_a_code": "\nint dr(vec2 uv){\n    \n    // Obtain a random direction.\n    uv = mod(uv, SIZE);\n    return int(1024.*hash31(vec3(uv, float(iFrame))))&3;\n     \n}\n\nvec4 tx(vec2 uv){ \n    // Wrapped texel fetch.\n    uv = mod(uv, SIZE);\n    return texelFetch(iChannel0, ivec2(uv), 0);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n\n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    if(fragCoord.x>SIZE || fragCoord.y>SIZE) discard;\n\n  \n    // Skipping a few frames to slow down the animation and faster machines.\n    float frameRate = 1./iTimeDelta;\n    int iFr = int(round(frameRate/60.));\n    if(iFrame%iFr>0){       \n       fragColor = tx(fragCoord);\n       return;        \n    }\n   \n    if(textureSize(iChannel0, 0).x<2 || iFrame==0 || iMouse.z>0.){\n        \n        // Starting conditions. The following is a bit messy, but I'm\n        // essentially spacing out some starting points on a grid.\n        \n        vec4 rVal = vec4(0, -1, 0, 0);\n        vec2 ip = floor(fragCoord);\n        #if 0\n        if(length(mod(ip, 1./scale) - .0 - floor((1./scale/2.))) < 0.01){\n          rVal.x = .5;\n          rVal.z = 1.;\n        }\n        #else\n        vec2 mIP = mod(ip, 1./scale);\n        vec2 repIp = mIP;\n        float rSc = 6.;\n        if(mod(floor(repIp.y/rSc), 2.)<.5){\n            repIp.x += floor(rSc/2.); // Offset rows.\n            mIP.x += floor(rSc/2.);\n        }\n        \n        repIp = mod(repIp, rSc);\n        mIP = mod(mIP, 1./scale);\n        \n        if(repIp.x == 0. && repIp.y == 0.){ \n            rVal.x = .5;\n            mIP = floor(mIP/rSc);\n            float colID = (mIP.x + mIP.y*rSc)/(rSc*rSc);\n            //float colID = hash21(mIP + .157);\n            rVal.y = colID;\n            rVal.z = 1.;\n        \n        }\n        #endif \n        \n        fragColor = rVal;\n \n        \n    }else{\n        \n       \n        \n        // Currect pixel value and neighboring cell pixel values.\n        vec4 a = tx(fragCoord), // Current.\n              \n        lft = tx(fragCoord + vec2(-1, 0)), // Left\n        up = tx(fragCoord + vec2(0, 1)), // Up.\n        rgt = tx(fragCoord + vec2(1, 0)), // Right.\n        dwn = tx(fragCoord + vec2(0, -1)); // Down.\n \n              \n        ////////\n        // No more than two connections allowed.\n        int cn = 0;\n        //ivec4 dCn = ivec4(0);\n        int iVal = int(a.x);\n        ivec4 iVal4 = ivec4(lft.x, up.x, rgt.x, dwn.x);\n        for(int i = 0; i<4; i++){\n            if((iVal&(1<<i))>0) cn++;\n\n        }        \n        \n        ////////\n         \n        // On the first try, don't connect from both ends.\n        int maxCons = 2; \n        \n        // For the initialized cell, only allow connections from one\n        // side... This avoids duplicates from forming.\n        if(a.z==1.) maxCons = 1; // Set the maxium connections to one.\n         \n  \n          \n        if(a.x==0.){\n        \n            // If the current cell is empty, but a neighboring cell has\n            // an existing connection.\n\n            int rnd = dr(fragCoord); // Obtain a random direction for this pixel.\n            // If the random direction of the empty cell is left and the \n            // left cell is not empty, flag left.\n\n\n            // At this point we're opening a connection to the possibility of\n            // of being activated from it's neighboring pixel. Most form, but not\n            // all, since some connections will be blocked by another worm passing\n            // by. Therefore, when equilibrium for this pass has been reached, open \n            // connections that haven't formed need to be deactivated.\n\n\n            if(cn<maxCons)if(rnd==0 && (int(lft.x)&4)>0){ a.x = 1.; a.y = lft.y; cn++; } // Flag left.\n            if(cn<maxCons)if(rnd==1 && (int(up.x)&8)>0){ a.x = 2.; a.y = up.y; cn++; }   // Flag up.\n            if(cn<maxCons)if(rnd==2 && (int(rgt.x)&1)>0){ a.x = 4.; a.y = rgt.y; cn++; } // Flag right.\n            if(cn<maxCons)if(rnd==3 &&(int(dwn.x)&2)>0){ a.x = 8.; a.y = dwn.y; cn++; } // Flag down.\n \n        }\n        else\n        {  \n        \n            // If the current cell is not empty, but a neighboring one is empty.\n \n\n            // 1 - left, 2 - up, 4 - right, 8 - down.\n  \n            if(hash31(vec3(fragCoord + .5, iTime))<1.5){\n            // If the left cell is empty and the random direction of that particular \n            // cell is right (connecting the current cell) flag the left direction.\n            if(cn<maxCons)if(lft.x==0. && dr(fragCoord + vec2(-1, 0)) == 2){ a.x += 1.; cn++;  }// Flag left.\n            if(cn<maxCons)if(up.x==0. && dr(fragCoord + vec2(0, 1)) == 3){ a.x += 2.; cn++; } // Flag up.\n            if(cn<maxCons)if(rgt.x==0. && dr(fragCoord + vec2(1, 0)) == 0){ a.x += 4.; cn++; } // Flag right.\n            if(cn<maxCons)if(dwn.x==0. && dr(fragCoord + vec2(0, -1)) == 1){ a.x += 8.; cn++; }// Flag down.\n             \n            }\n            else {\n            \n                if(cn<maxCons){\n                   if(lft.x==0. && dr(fragCoord + vec2(-1, 0)) == 2){ a.x += 1.;  }// Flag left.\n                   if(up.x==0. && dr(fragCoord + vec2(0, 1)) == 3){ a.x += 2.;  } // Flag up.\n                   if(rgt.x==0. && dr(fragCoord + vec2(1, 0)) == 0){ a.x += 4.;  } // Flag right.\n                   if(dwn.x==0. && dr(fragCoord + vec2(0, -1)) == 1){ a.x += 8.;  }// Flag down.\n                }  \n                \n            } \n        \n         \n         }  \n         \n         //if(a.w>8.) a.z = 0.;\n         \n         a.w++;\n         \n           \n         if(a.w>256.){\n         \n             // When every worm can go no further, you need to check for\n             // open connections (when another worm has blocked the path)\n             // and deactivate them.\n             if((int(lft.x)&4)==0 && (int(a.x)&1)>0) a.x -= 1.;\n             if((int(up.x)&8)==0 && (int(a.x)&2)>0) a.x -= 2.;\n             if((int(rgt.x)&1)==0 && (int(a.x)&4)>0) a.x -= 4.;\n             if((int(dwn.x)&2)==0 && (int(a.x)&8)>0) a.x -= 8.;\n              \n              \n             a.w = 0.; // Restart the counter.\n             // If it's finished in one direction, unflag the starting position. \n             // This is optional, but I like it becausse it produces a more packed \n             // and complete pattern.\n             a.z = 0.; \n             \n         \n         }\n \n          \n        \n        fragColor = a;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1823, 1856, 1878, 1878, 1936], [1939, 2093, 2141, 2443, 3352], [3359, 3380, 3410, 3410, 3482], [3484, 3511, 3581, 3634, 3739], [3754, 3816, 3855, 3855, 3956], [3958, 3985, 4003, 4003, 4078], [7979, 8152, 8168, 8192, 10260], [10262, 10453, 10505, 10596, 12045], [12048, 12200, 12235, 12235, 12630], [13437, 13437, 13472, 13538, 20481]], "test": "untested"}
{"id": "mlKczd", "name": "perception of tiling wth transfo", "author": "FabriceNeyret2", "description": "exact tiling of random points is easily perceived,\nwhile random tile orientation (among 2) masks it.\nClick to see tiles.", "tags": ["tiling"], "likes": 6, "viewed": 233, "published": 3, "date": "1700573418", "time_retrieved": "2024-07-30T17:21:25.178223", "image_code": "// variant of https://shadertoy.com/view/dtKczd\n\n#define H(v)     fract(1e3*sin(dot(v,vec2(73,91))))          // hash\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= 128.;\n    int  h = iFrame/180 % 2 > 0 ? int(8.*H(floor(u))) : 0;   // rand in {0,...7}\n    vec2 U = fract(u);                                       // local frame\n    O *= 0.;\n    if ( iMouse.z>0. && min(U.x,U.y)<2./128. ) O.r++;        // if click draw tiles borders\n    if ( h/4   > 0 ) U = U.yx;                               // rand bit3: symmetry\n    if ( h/2%2 > 0 ) U = 1.-U;                               // rand bit2: rot Pi\n    if ( h%2   > 0 ) U = vec2(1.-U.y,U);                     // rand bit1: rot Pi/2\n    O += vec4( H(U) > .99 );                                 // draw random dots (same in each tile)\n  }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 157, 157, 789]], "test": "untested"}
{"id": "dtKczd", "name": "tiling with all possible mapping", "author": "FabriceNeyret2", "description": "each tile has 8 possibilities of orientation.\n", "tags": ["tiling"], "likes": 8, "viewed": 188, "published": 3, "date": "1700572788", "time_retrieved": "2024-07-30T17:21:25.937194", "image_code": "#define H(v)     fract(1e3*sin(dot(v,vec2(73,91))))                           // hash\n#define D(C,x,y) O = mix(O, C, smoothstep( .01,0.,length(U-vec2(x,y))-.05 ) ) // dot of col C at (x,y)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= 128.; u += iTime;\n    int  h = int(8.*H(floor(u)));                            // rand in {0,...7}\n    O = .8 + .3 * cos( 6.3*float(h)/8.  + vec4(0,23,21,0));  // desaturated hue(rand)\n    vec2 U = fract(u);                                       // local frame\n    if ( h/4   > 0 ) U = U.yx;                               // rand bit3: symmetry\n    if ( h/2%2 > 0 ) U = 1.-U;                               // rand bit2: rot Pi\n    if ( h%2   > 0 ) U = vec2(1.-U.y,U);                     // rand bit1: rot Pi/2\n // O = vec4(U,0,0);                                         // draw local parameterization\n    O *= texture(iChannel0,U);                               // draw texture in tile\n    D( vec4(1,0,0,0), .9,.5 );                               // +X: red dot\n    D( vec4(0,1,0,0), .5,.9 );                               // +Y: greed dot\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 228, 228, 1081]], "test": "untested"}
{"id": "DdtfD8", "name": "mandelhub", "author": "simplexqwe", "description": "mandelhub", "tags": ["mandelhub"], "likes": 0, "viewed": 200, "published": 3, "date": "1700558295", "time_retrieved": "2024-07-30T17:21:26.777946", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define Power 4.\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n    }\n\nfloat DE(vec3 pos,float time) {\n\tvec3 z = pos;\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.)*Power*dr + 1.;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta+time)*cos(phi+time), sin(phi+time)*sin(theta+time), cos(theta+time));\n\t\tz+=pos;\n\t}\n\treturn .5*log(r)*r/dr;\n}\n\nfloat GetDist(vec3 p){\n    return DE(p,0.);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n    \n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p = ro+rd*dO;\n    float ds=GetDist(p);\n    dO+=ds;\n    if(dO>MAX_DIST || abs(ds)<SURF_DIST) {\n      break;\n    }\n  }  \n  return dO;\n}\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p);\n    vec2  e = vec2(.01,0.);\n    \n    vec3  n =d-vec3(\n    GetDist(p-e.xyy),\n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 LightPos = vec3 (0,1,-2);\n    //LightPos.xz  += vec2(sin(iTime),cos(iTime))*10.;\n    vec3 l        = normalize(LightPos-p);\n    vec3 n        = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),.5,1.);\n    float d   = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(LightPos-p))dif*=.25;\n    return dif;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro  = vec3(0,0.01,-3);\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1));\n    rd.yz*=Rot(iTime/50.);\n    ro.yz=(ro.yz)*Rot(iTime/50.);\n    \n    rd.xz*=Rot(iTime/10.);\n    ro.xz=(ro.xz)*Rot(iTime/10.);\n\n\n\n    float d = RayMarch(ro,rd);\n    vec3 p  = ro+rd*d;\n    \n    float dif =GetLight(p);\n    col = vec3(dif);\n    \n    vec3 n=vec3(length(GetNormal(p).xy));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 102, 102, 175], [177, 177, 208, 208, 743], [745, 745, 767, 767, 790], [792, 792, 824, 824, 1019], [1021, 1021, 1045, 1045, 1224], [1226, 1226, 1250, 1250, 1564], [1568, 1568, 1625, 1625, 2114]], "test": "untested"}
{"id": "DlVcRt", "name": "disk wave (unrolled)", "author": "FabriceNeyret2", "description": "partly unrolled variant of https://shadertoy.com/view/DtVyRt\n~ sqrt(N) rather than N loop\nreproducing https://twitter.com/Pixelated_Donut/status/1726602167019241671", "tags": ["illusion", "sampling", "2tweets", "short", "golf", "loopless", "reproduction"], "likes": 19, "viewed": 249, "published": 3, "date": "1700556534", "time_retrieved": "2024-07-30T17:21:27.622687", "image_code": "// partly unrolled variant of https://shadertoy.com/view/DtVyRt\n// reproducing https://twitter.com/Pixelated_Donut/status/1726602167019241671\n//             https://twitter.com/Yugemaku/status/1726559476172616047\n// cf https://www.desmos.com/calculator/zqhgc6pe9e\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    float N = 2e2, i0 = round(N*dot(U,U)),  F = 1.618, i;    \n    O *= 0.;\n    if ( i0 < N )\n    for( i = i0-5.; i++ < i0+5.; )  // F = (1+sqrt(5))/2\n        O += smoothstep( 3./R.y, 0.,       \n               length( U - cos( 6.283*(2.*F*i - pow(fract(F*i-.2*iTime),1.5)) + vec2(11,0) ) *sqrt(i/N) )\n               -.01 );\n         // * ( .6 + .6 * cos( 6.3*(fract(F*i-.2*iTime))  + vec4(0,23,21,0)  ) );   // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 303, 303, 787]], "test": "untested"}
{"id": "DtVyRt", "name": "disk wave", "author": "FabriceNeyret2", "description": "reproducing https://twitter.com/Pixelated_Donut/status/1726602167019241671", "tags": ["illusion", "sampling", "2tweets", "short", "golf", "reproduction"], "likes": 28, "viewed": 274, "published": 3, "date": "1700555008", "time_retrieved": "2024-07-30T17:21:28.471418", "image_code": "// reproducing https://twitter.com/Pixelated_Donut/status/1726602167019241671\n//             https://twitter.com/Yugemaku/status/1726559476172616047\n// cf https://www.desmos.com/calculator/zqhgc6pe9e\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    O *= 0.;\n    for( float F = 1.618,i; i++ < 2e2; )  // F = (1+sqrt(5))/2\n        O += smoothstep( 3./R.y, 0.,       \n               length( U - cos( 6.283*(2.*F*i - pow(fract(F*i-.2*iTime),1.5)) + vec2(11,0) ) *sqrt(i/2e2) )\n               -.01 );\n         // * ( .6 + .6 * cos( 6.3*(fract(F*i-.2*iTime))  + vec4(0,23,21,0)  ) );   // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 239, 239, 649]], "test": "untested"}
{"id": "mlyczd", "name": "ethereal dusk", "author": "jackjackdev", "description": "ethereal dusk", "tags": ["noise", "hash"], "likes": 1, "viewed": 85, "published": 3, "date": "1700553462", "time_retrieved": "2024-07-30T17:21:29.285242", "image_code": "// ethereal dusk\n\n#define PI 3.14159265359\n\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\n\nfloat noise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix(hash(n+0.0), hash(n+1.0),f.x),\n               mix(hash(n+57.0), hash(n+58.0),f.x),f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.x = abs(uv.x);  // Mirror effect\n\n    float time = iTime * 0.2;\n    float angle = time * 0.3;\n    uv =  uv;\n\n    // Kaleidoscopic effect\n    float r = length(uv) * 2.0;\n    float theta = atan(uv.y, uv.x);\n    theta = mod(theta, PI/6.0);\n\n    // Fractal calculations with color gradients\n    vec3 col = vec3(0.0);\n    float fractal = 0.0;\n    for (int i = 0; i < 20; i++) {\n        uv = abs(uv) / dot(uv, uv) - 0.9;\n        fractal -= exp(-abs(dot(uv, uv)));\n    }\n\n    // Color gradient based on fractal\n    col.r = 1.5  * cos(fractal + 0.0 + time);\n    col.g = 1.5  * cos(fractal + 2.0 * PI / 3.0 + time);\n    col.b = 2.9  * cos(fractal + 4.0 * PI / 3.0 + time);\n\n    // Adding sophisticated noise patterns\n    col += 1. * vec3(noise(uv * 10.0 + time));\n\n    // Convert to grayscale\n    float gray = dot(col, vec3(0.299, 0.587, 0.114));\n    vec3 grayscale = vec3(gray);\n\n    fragColor = vec4(grayscale, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 65, 65, 102], [104, 104, 125, 125, 335], [337, 337, 394, 394, 1379]], "test": "untested"}
{"id": "mtGcRd", "name": "Multiscale triangle wave truchet", "author": "jarble", "description": "A truchet weave pattern using triangle waves instead of trigonometric functions.", "tags": ["truchet", "multiscale", "weave"], "likes": 7, "viewed": 158, "published": 3, "date": "1700546693", "time_retrieved": "2024-07-30T17:21:30.140954", "image_code": "#define triwave(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\n\nvec4 t1(vec2 c, vec2 p){\n    return triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )) * vec4(22,7,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 p = (I/1e2+iTime)*2.;\n    vec4 t_ = t1(ceil(p),p);\n    vec4 t1_ = t1(ceil(p/4.),p/4.);\n    \n    if(\n        //Lots of interesting patterns here!\n        //t_.y>t_.x\n        //t1_.y>t1_.z\n        //1.-t_.z>t1_.y||1.-t_.y>t1_.x||1.-t_.x>t1_.z\n        t_.y>.5&&t_.y<t1_.y\n        //t1_.y>t_.y||t1_.z>t_.z||t1_.x>t_.x\n        //t_.y<t1_.y\n        \n        //an interesting knot pattern\n        //t_.x>t1_.x&&t_.y<t1_.x\n        //t_.z>.5||t_.y>.5||t_.z>.5\n        //t1_.z>t_.z||t1_.y>t_.y||t1_.z>t_.z\n    ) O = t_;\n    else O = t1_;\n}", "image_inputs": [], "sound_code": "float m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a,float b){\n    return \n        mod(a,b)\n        //mod(a+mod(a,3.)-mod(a,5.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    //a *= (1.+mod(floor(a/8.),2.));\n    //a += m1(a/8.,5.+b,3.+b);\n    //a += mod(b/2.,2.);\n    return\n        //mod1(mod1(8.+floor(a/8.),b*2.+floor(b*a)-floor(a/8.)),b)\n        //mod(mod(8.+floor(a/2.),8.+floor(a)),b)\n        //mod(floor(a/b-mod(a/8.,2.)+mod(a/8.,3.)),b)\n        //mod(floor(a/2.),b)*mod(floor(a/b)*floor(a/b),b/2.)\n        mod(floor(8./b+a*b/8./2.),b)\n        //mod(mod(floor(8./b+a*b/8./2.),b+floor(a/8./2.)),b)\n        //mod(mod(8.+floor(a/8.+b/8.),b*2.+floor(b*a+8./b)-floor(a/8.+8./b)),b)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 mainSound1(int samp, float time,float scale){\n  time /= 4.;\n  float s1 =\n      8.,\n  s2 = 8.,\n  t = time,\n  m1 = fmod(t*4.,s1/2.),\n  p1 = pow(2.,m1)\n  ;\n  t = \n      s1*pow(2.,fmod(t*16.+m1,2.))*t/(1.+fmod(floor(t*4.),2.))\n      //s1*pow(2.,fmod(t*8.+m1,3.))*t;\n  ;\n\n  float\n  m3 =\n      floor(fmod(time*8.*p1,s1/2.)/2.)\n  ;\n  float m2 =\n      1. + fmod(t*8.,s1/2.)\n      //1. + fmod((t+floor(t/8.))*8.,s1/2.)\n  ;\n  float a=\n      //128.*pow((1.-sqrt(fract(t)/2.))/2.,2.)\n      //pow(log(fract(t)/8.),2.)\n      \n      //gamelan\n      pow(log(.125+fract(t)/4.),2.)\n\n      \n  ;\n  float nb = time*pow(2.,(m3+m2-m1)/7.+scale);\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //gamelan\n      //a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb*4.*.998),fract1(nb*4.)))/2.))\n      //+.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb*2.*.998),fract1(nb*2.)))/2.)))   \n      \n      //sitar\n      log(.125*4.+abs(a/32.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //log(1./8.*4.+a*abs(1./8.-abs(.5-vec2(fract(nb*.998),fract(nb/2.)))))\n      \n      //log(1.+abs(a/32.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //abs(.5-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}\n\nvec2 mainSound(int a,float b){\n    //return mainSound1(a,b,8.);\n    //return (mainSound1(a,b/2.,10.)+mainSound1(a,b,10.))/2.;\n    return (mainSound1(a,b,9.)*mainSound1(a,b,10.));\n    //return mainSound1(a,b,8.)+mainSound1(a,b*2.,8.)/2.+mainSound1(a,b*4.,8.)/4.+mainSound1(a,b/8.,8.)/8.;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 138, 138, 242], [244, 244, 280, 280, 819]], "test": "untested"}
{"id": "dtXfzM", "name": "SDF & Ray Marching Template", "author": "tristanantonsen", "description": "This is a template file for my preferred way of creating a basic ray marcher. It includes a nice little lighting setup and some useful SDFs & operations.\n\nFunctions updated to feel more familiar to someone with an engineering/CAD background.", "tags": ["raymarching", "sdf", "template"], "likes": 2, "viewed": 163, "published": 3, "date": "1700532508", "time_retrieved": "2024-07-30T17:21:30.941813", "image_code": "////////////////////////////////////////////////////////////////\n// Tristan Antonsen 2023\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r)\n{\n    // Modified to account for the radius without changing the size of the box\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU);\n    p = rotX(p, m.y*PI + PI);\n    return p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n    float d=min(min(min(sdSphere(p,vec3(0.0),0.2),sdSphere(p,vec3(0.5),0.2)),sdSphere(p,vec3(-0.5),0.2)),sdRoundedBox(p-vec3(0.0,0.5,0.0),vec3(0.25),0.1));\n    vec2 res = vec2(d, 1.);\n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        if (d.y == 1.0) color = vec3(0.2,0.8,1.);\n        if (d.y == 2.0) color = vec3(0.);\n        if (d.y == 3.0) color = vec3(0.2);\n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n\n        \n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 736, 757, 757, 915], [916, 916, 943, 943, 1523], [1751, 1751, 1793, 1793, 1829], [1831, 1831, 1874, 1874, 1904], [1906, 1906, 1952, 1952, 2061], [2063, 2063, 2115, 2115, 2242], [2244, 2244, 2289, 2368, 2460], [2462, 2462, 2526, 2526, 2647], [2649, 2649, 2696, 2758, 3034], [3185, 3185, 3221, 3221, 3242], [3244, 3244, 3285, 3345, 3372], [3373, 3373, 3415, 3415, 3441], [3443, 3443, 3493, 3493, 3592], [3593, 3593, 3649, 3649, 3749], [3750, 3750, 3806, 3806, 3905], [4052, 4052, 4080, 4080, 4230], [4232, 4232, 4260, 4260, 4410], [4412, 4412, 4440, 4440, 4590], [4592, 4592, 4621, 4621, 4776], [4935, 4935, 4954, 4967, 5261], [5263, 5263, 5296, 5296, 5686], [5688, 5688, 5711, 5711, 6045], [6047, 6047, 6092, 6119, 6720], [6723, 6723, 6780, 6830, 8194]], "test": "untested"}
{"id": "ctyyzd", "name": "Xor smooth", "author": "Dain", "description": "based on jt's xor https://www.shadertoy.com/view/ssG3WK#\n\nsmooth xor attempt--just an approximate distance field now..\n\nxor is pretty cool for 2d shapes, but in 3d will make it hollow :(\n", "tags": ["sdf", "xor"], "likes": 5, "viewed": 165, "published": 3, "date": "1700531575", "time_retrieved": "2024-07-30T17:21:31.777579", "image_code": "// https://www.shadertoy.com/view/ssG3WK XOR SDF by jt\n// \n// Wrote this as a private test a while ago (found a backup from 2021-09-21)\n// switched to unlisted 2023-10-30 to ask iq about xor sdf exactness\n// made it public 2023-11-20 now that iq wrote an article about it :-)\n// Jakob Thomsen\n//\n// Related:\n//\n// The 2023-11-20 article https://iquilezles.org/articles/sdfxor/ by Inigo Quilez.\n// \n// https://www.shadertoy.com/view/3t33WH Interior Distance by iq\n// https://www.shadertoy.com/view/DdX3WH Interior Distance Detect Errors, jt\n//\n// Operators union, subtraction, intersection do NOT always give a valid sdf,\n// as iq explains in https://iquilezles.org/articles/interiordistance\n//\n// Does the symmetric difference always result in a valid signed distance field?\n// In the comments iq provided the following proof:\n// \"Yes, it is. You can see this by expanding the arithmetic of the four cases:\n//  1) a>0, b>0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  min( a, b) =  min(a,b)\n//  2) a<0, b>0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  max( a,-b) = -min(-a,b)\n//  3) a>0, b<0 --> xor(a,b) = max(min(a,b),-max(a,b)) =  max(-a, b) = -min(a,-b);\n//  4) a<0, b<0 --> xor(a,b) = max(min(a,b),-max(a,b)) = -max( a, b) =  min(-a,-b)\n// All four cases reduce to a min() of exterior distances (that is, to a min of two positive arguments),\n// which as we know is always exact. So the XOR(a,b) is exact.\"\n// Thanks! Shadertoy is a really wonderful project!\n\n// Licence: The xor function is public domain.\n\nconst float smooth_r = .1;//smooth radius(0 is invalid)\n\n//smin attempt:  adjusted for smooth xor so that it transitions between + and - space smoothly\n//the problem is smin with a and b both being 0 does not return 0\n//a and b need to be positive\n//https://www.desmos.com/calculator/udwbmuagmm\nfloat smin_xor(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    float rcp_r = 1.0/r;\n    //a fade so we get smooth transition for sxor between + and - space\n    //..this might cause rate of change to be > 1-- oh well for now.. at least it is very close to surface\n    float f = min(min(a,b)*rcp_r,1.0);\n\n   //slow down the transition to hard \n    f = f+f -f*f;\n\n\n    return min(a, b)- e*e*rcp_r*.25 *f;\n\n}\n//has some issues when xor goes from + to - space--the distance value jumps--this is because \n//we don't get 0 when and a and b are both 0\nfloat smin(float a, float b, float r) {\n    float e = max(r - abs(a - b),0.0);\n    \n    return min(a, b)- e*e* (1.0/(r*4.0));\n\n}\n\nfloat sgn(float a){\n    return a >=0.0 ? 1.0 : -1.0;\n}\n//smooth xor\n//radius of 0 is invalid\nfloat sxor(float a, float b, float r){\n    //see IQ article: https://iquilezles.org/articles/sdfxor/\n    //where he shows it can be written this way\n     return sgn(a)*sgn(b)*smin_xor(abs(a), abs(b),r );\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) // https://iquilezles.org/articles/distfunctions\n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCircle( vec2 p, float r ) // https://iquilezles.org/articles/distfunctions\n{\n    return length(p) - r;\n}\n\n\n\n// It seems like xor does not have the problems explained in https://www.shadertoy.com/view/3t33WH Interior Distance by iq\n// Confirmed in this new article https://iquilezles.org/articles/sdfxor/ by iq\nfloat xor(float a, float b)\n{\n    // NOTE: XOR can be implemented via sign but sign is buggy on some platforms as spalmer found out.\n    return max(min(a, b), -max(a, b));\n}\n\nfloat map(vec2 p)\n{\n\n    \n    float m = abs(sin(iTime));\n\t//float a = sdBox(p-vec2(m,0), vec2(0.5));\n    float b = sdCircle(p+vec2(m,0), sqrt(0.5));\n    float a=  sdCircle(p-vec2(m,0), sqrt(0.5));\n    \n    float d = sxor(a, b,smooth_r); \n\n    float n = abs(cos(iTime*.9));\n    float c = sdCircle(p+vec2(0.0,n), sqrt(0.5));\n    float e = sdCircle(p-vec2(0.,n), sqrt(0.5));\n    \n    float f = sxor(c, e,smooth_r);\n    \n    d = sxor(d, f,smooth_r);\n\n    return d-.01;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float d = map(p);\n    /*\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    */\n    // iq's sdf coloring\n    vec3 col = (d<0.0) ? vec3(0.6,0.8,1.0) : vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyyzd.jpg", "access": "api", "license": "public-domain", "functions": [[1563, 1801, 1844, 1844, 2234], [2235, 2374, 2413, 2413, 2502], [2504, 2504, 2523, 2523, 2558], [2559, 2597, 2635, 2745, 2802], [2804, 2804, 2890, 2890, 2972], [2974, 2974, 3058, 3058, 3086], [3090, 3292, 3321, 3424, 3465], [3467, 3467, 3486, 3486, 3933], [3935, 3935, 3992, 3992, 4832]], "test": "untested"}
{"id": "dlGcRc", "name": "Remedy for a crap GPU", "author": "misol101", "description": "I just wanted to see Xor's beautiful shader run fullscreen at 60fps, but my GPU couldn't even do 800x450...\n\nHere's a compromise, figured it might be useful for someone else as the zoom method should work for pretty much any shader", "tags": ["3d", "zoom", "optimization", "maze", "scale", "scaling"], "likes": 10, "viewed": 255, "published": 3, "date": "1700528302", "time_retrieved": "2024-07-30T17:21:32.664208", "buffer_a_code": "/*\n    \"Passage\" by @XorDev\n    \n    X: X.com/XorDev/status/1726396476866044130\n    Twigl: twigl.app?ol=true&ss=-Nje8mOER98sqMpHsal-\n    \n    <512 chars playlist: https://www.shadertoy.com/playlist/N3SyzR\n*/\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //setMaxResXScale();\n\tif (I.x > iResolution.x / SCALE) { O=vec4(0.); return; }\n\tif (I.y > iResolution.y / SCALE) { discard; }\n\tvec3 IR = iResolution / SCALE;    \n\n    //Clear fragcolor\n    O *= 0.;\n    \n    //Raymarch loop:\n    //iterator, step-size, raymarch distance, Tau\n    //Raymarchs 100 times adding brightness when close to a surface\n    for(float i,s,d,z,T=acos(-1.)*2.; i++<50.; O+=0.0000105/(.0004-s))\n    {\n        //Rotation matrix\n        mat2 R = mat2(8,6,-6,8)*.1;\n        //Resolution for scaling\n        vec3 r = IR,\n        //Project sample with roll rotation and distance\n        p = vec3((I+I-r.xy)/r.x*d*R, d-9.)*.7;\n        //Rotate pitch\n        p.yz *= R;\n        z = p.z;\n        //Step forward (negative for code golfing reasons)\n        d -= s = min(z, cos(dot(\n            //Compute subcell coordinates\n            modf(fract((\n            //Using polar-log coordinates\n            vec3(atan(p.y,p.x),log(s=length(p.xy)),0)/T-iTime/2e1)*\n            //Rotate 45 degrees and scale repetition\n            mat3(1,1,0,1,-1,0,p-p))*15., p),\n        //Randomly flip cells and correct for scaling\n        sign(cos(p+p.y)))*T)*s/4e1);\n    }\n}", "buffer_a_inputs": [], "image_code": "// Method to display centered 1px buffer, and fill the rest with zoomed-in version of the same buffer\n// Used for performance reasons / running fullscreen\n// by misol101\n\n#define TX(xpp,ypp,sc) texelFetch(iChannel0, ivec2(fragCoord.x/ sc + xpp, fragCoord.y/ sc + ypp), 0)\n\n#define BORDER_SIZE 0.004\n#define BORDER_COLOR vec4(0.)\n#define ZOOM_SAMPLES 4\n#define BG_COL vec4(1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //setMaxResXScale();\n\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord/ SCALE), 0); return; // simplest scale\n\n    float xsz = iResolution.x * (1./SCALE) * 0.5;\n    float ysz = iResolution.y * (1./SCALE) * 0.5;\n    float mx = max(0., iMouse.z) * 1e6;\n    float xsta = iResolution.x * 0.5 - xsz + mx, xsto = iResolution.x * 0.5 + xsz + mx;\n    float ysta = iResolution.y * 0.5 - ysz, ysto = iResolution.y * 0.5 + ysz;\n    float border = iResolution.x * BORDER_SIZE;\n\n    if (fragCoord.x > xsta && fragCoord.x < xsto && fragCoord.y > ysta && fragCoord.y < ysto) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.x - xsta, fragCoord.y-ysta), 0); \n        return;\n    } else if (fragCoord.x > xsta - border && fragCoord.x < xsto + border  && fragCoord.y > ysta -border && fragCoord.y < ysto+border) {\n        fragColor = BORDER_COLOR; \n        return;\n    }\n\n    float sc = SCALE + (SCALE+1.)/(iResolution.y*(1./SCALE)) * SCALE;\n    vec4 col = TX(0.,0.,sc);\n    switch (ZOOM_SAMPLES) {\n        case 2: col += TX(SCALE, 0., sc); break;\n        case 3: col += TX(SCALE, 0., sc) + TX(0., SCALE, sc); break;\n        case 4: col += TX(SCALE, 0., sc) + TX(0., SCALE, sc) + TX(SCALE, SCALE, sc); break;\n    }\n    fragColor = (col / (float(ZOOM_SAMPLES)) ) * BG_COL;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float SCALE = 2.0;\n\nconst float MAX_X_RES = 1000.;\n#define setMaxResXScale() SCALE = max(1.0, iResolution.x / MAX_X_RES)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dtyyzt", "name": "iDate example", "author": "jakel101", "description": "inspired by https://www.shadertoy.com/view/ldKGRR; small shader to test if iDate implementation works in wgpu-py shadertoy util ( currently months show seconds, so there is some offset)", "tags": ["test", "idate"], "likes": 0, "viewed": 80, "published": 3, "date": "1700520904", "time_retrieved": "2024-07-30T17:21:33.610677", "image_code": "float D(vec2 p, float n) {  // display digit\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn float(i-i/2*2);\n}\nfloat N(vec2 p, float v) {  // display number\n    for (float n=3.; n>=0.; n--)  // print digit 3 to 0 ( negative = fractionals )\n        if ((p.x-=4.)<3.) return D(p,floor(mod(v/pow(10.,n),10.))); \n    return 0.;\n}    \n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    \n    float years = iDate.x; // s = 2050\n    float months = iDate.y; // s = 12\n    float days = iDate.z; // s = 31\n    float hours = floor(iDate.w/3600.0); // s = 60\n    float mins = floor(mod(iDate.w/60.0, 60.0)); // s = 60\n    float seconds = floor(mod(iDate.w,60.0)); // s = 60\n    float milisecs = fract(iDate.w)*1000.0; // s = 1000\n    \n    \n   \n    \n    O = vec4(U.x < milisecs/1000.0); // bars\n    \n    O += N(vec2(U.x,mod(U.y,1./7.))*iResolution.xy/6., months) *vec4(1,-1,-1,1); //digits\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtyyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 44, 249], [250, 250, 276, 295, 464], [471, 471, 509, 509, 1036]], "test": "untested"}
{"id": "DlGcRt", "name": "Sierpinski Splat", "author": "Real_NC", "description": "this is my favorite way to define a Sierpinski triangle. Start at a vertex, and move 50% closer to a random other vertex.", "tags": ["fractal", "iterative", "sierpinski"], "likes": 3, "viewed": 176, "published": 3, "date": "1700518381", "time_retrieved": "2024-07-30T17:21:34.462400", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 0.8;\n    uv.y += 0.25;\n    \n    \n    fragColor = vec4(0);\n    \n    vec2 p;\n    for(int x = 0; x <= SPEED; x++)\n    {\n        for(int y = 0; y <= SPEED; y++)\n        {\n            p = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n            if(distance(p, uv) <= 0.9/iResolution.y)\n            {\n                fragColor = vec4(1); \n            }\n        }\n    }\n    \n    if(iFrame != 0 && fragColor.x == 0.)\n    {\n        discard;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec2[3] vertices = vec2[](\nvec2(0, 1),\nvec2(sq32, -0.5), \nvec2(-sq32, -0.5));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    if (max(fc.x, fc.y) > SPEED) discard;\n    if (iFrame == 0)\n    {\n        fragColor.xy = vec2(0,1);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, fc, 0);\n        fragColor.xy = mix(fragColor.xy, vertices[int(hash(vec3(fragCoord+iResolution.xy, iFrame))*3.)], 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 16\n#define sq32 sqrt(3.0)*0.5\n\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 573]], "test": "untested"}
{"id": "mttyDr", "name": "Fork: Blue Penta", "author": "QuantumSuper", "description": "Morphing glowing 2d shapes to beat (takes a few beats to initialize).\n\n- use with audio in iChannel0 of Buffer A -", "tags": ["2d", "glow", "25d", "pentagon"], "likes": 2, "viewed": 230, "published": 3, "date": "1700509319", "time_retrieved": "2024-07-30T17:21:35.397899", "image_code": "// Fork: Blue Penta v0.4.231120 by Quantum Super\n// forked from Blue Pentagon v0.7.231103 by QuantumSuper & Audio Analyser 0.5.230727 by QuantumSuper\n// pseudo-3d animation by morphing glowing 2d shapes to music beat\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\n#define PI 3.14159265359 \nfloat count, bpm, timeFirstBeat, aTime;\n\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nvec3 tmUnreal( vec3 c){ //tone map, source: https://www.shadertoy.com/view/llXyWr\n    return c / (c + .155) * 1.019;\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n \nfloat sdSegment( vec2 p, vec2 a, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/ \n    vec2 pa = p - a, ba = b - a; \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.); \n    return length(pa - ba*h);\n}\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b; \n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdPentagon( vec2 p, float r){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const vec3 k = vec3( .809016994, .587785252, .726542528);\n    p.x = abs(p.x);\n    p -= 2.*min( dot(vec2(-k.x,k.y),p), 0.) * vec2( -k.x, k.y);\n    p -= 2.*min( dot(k.xy,p), 0.) * k.xy;\n    p -= vec2( clamp( p.x, -r*k.z, r*k.z), r);    \n    return length(p) * sign(p.y);\n}\n\nfloat sdOctogon( in vec2 p, in float r ){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const vec3 k = vec3(-.9238795325, .3826834323, .4142135623 );\n    p = abs(p);\n    p -= 2.*min( dot(k.xy,p), 0.) * k.xy;\n    p -= 2.*min( dot(vec2(-k.x,k.y),p), 0.) * vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat glow( float sd, float amp){\n    return clamp( amp / max( amp, sd), .0 ,1.);\n}\n\nfloat myObj(vec2 p, float scale, float speed, float off){\n    float id = mod( (aTime-timeFirstBeat)/(60./bpm*16.), 3.);\n    if (id<1.)\n        return abs(sdPentagon( p/vec2(cos(aTime*speed+off),1.-sin(aTime*speed+off)*p.x/cos(aTime*speed+off)), .85/scale)) + .01;\n    else if (id<2.) \n        return abs(sdBox( p/vec2(cos(aTime*speed+off),1.-sin(aTime*speed+off)*p.x/cos(aTime*speed+off)), vec2(.85/scale))) + .01;\n    else\n        return abs(sdOctogon( p/vec2(cos(aTime*speed+off),1.-sin(aTime*speed+off)*p.x/cos(aTime*speed+off)), 1./scale)) + .01; \n}\n\nvec3 getCol(float id){ //v0.8, color definitions, for pairs\n    vec3 setCol = vec3(0);\n    id = fract(id/8.)*8.;// mod(id,8.);\n         if (id< 1.) setCol = vec3( 23,123,250); //cneon blue\n    else if (id< 2.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 3.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 4.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 5.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 6.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id< 7.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 8.) setCol = vec3(231, 15, 20); //arena red\n    return setCol/256.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Read compression values from Buffer A\n    vec4 fft, ffts;\n    for (int n=0;n<4;n++) \n        fft[n] = getDat( iChannel0, vec2( 0, n)).a,\n        ffts[n] = getDat( iChannel0, vec2( 0, n+4)).a;\n      \n    // Read analysis results from Buffer C\n    count         = getDat( iChannel2, vec2(0,0)).a; //beat count (0..15)\n    bpm           = getDat( iChannel2, vec2(0,1)).a; //bmp estimate (>90..180)\n    float frameRate     = getDat( iChannel2, vec2(0,2)).a; //frame rate average\n    float isPause       = getDat( iChannel2, vec2(0,3)).a; //is bass less high than average\n    timeFirstBeat = getDat( iChannel2, vec2(0,4)).a; //iTime at sudden bass increase\n    float isBeat        = getDat( iChannel2, vec2(0,5)).a; //is bass high\n    float isFlank       = getDat( iChannel2, vec2(0,6)).a; //is bass just getting high\n    aTime = (iTime-timeFirstBeat)/bpm*60.;\n\n\n    // Central object\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\tvec3 col = vec3(0);\n    float amp;\n    \n    float scale = 1. + .5*sin(iTime/8.) + fft.x*5.; //coordinate system scale\n    float matDiff = .33; //material brightness difference   \n    float speed = .5; //speed factor\n      \n    float off = .01; //rotation offset per slice\n    float num = 32.; //number of 2d slices\n    float totCount = aTime/128.;\n    float colId = floor(fract( totCount)*4.)*2.;\n    vec3 color1 = getCol( colId+0.);\n    vec3 color2 = getCol( colId+1.);\n    float phase = (ceil(totCount)/16.*.7 + .3*ceil(totCount/4.)/4.)*PI*2.;\n    \n    for(float n=0.;n<num;n++){\n        amp = glow( myObj( uv, scale, speed, n*off+phase), .01) //draw\n            * ((uv.x/cos(aTime*speed+n*off+phase)*scale*.5+1.5) * (1.-matDiff) + (cos(aTime*speed+PI/2.+n*off+phase)*.5+.5) * matDiff); //lighting\n        col += clamp(amp,.0,1.) * (color1*(1.-n/num)+color2*n/num)/num * (.5+ffts.xyz) * .8; //color \n        off *= 1.05 - .05*cos(aTime/PI); //iterate rotation offset\n    }\n    col *= mix( abs( cos( .06*iTime*.0 + PI/vec3(.5,2.,4.) + ffts.xyz*PI)), vec3(1), clamp(fft.x-.7,.0,.3)/.3); //color shift    \n\n    \n    // Flying segments\n    float myTime = aTime*2. - .02; //local timer\n    vec4 s1 = vec4(.7,2.3*fft.z,.7,-2.3*fft.z) * (.1+.4*(1.-fft.x)) * .5; //segment coordinates\n    float occ = smoothstep(.3,.0,max(max(col.x,col.y),col.z)); //occlusion factor\n    float numOfSeg = (isPause<1.)? 8. : 4.; //number of segments\n    \n    for (float n=.0;n<numOfSeg;n++)\n        col += glow( sdSegment( uv * rotM(hash21(vec2(ceil(myTime+n/numOfSeg),n/numOfSeg))*2.*PI-aTime) * fract(myTime+n/numOfSeg) * 2.7,  s1.xy,  s1.zw), 3e-4 * (1.+fft.x)) \n            * getCol( colId+fract(floor(n/4.)/2.)*2.+2.) //color\n            * (1.-fract(myTime+n/numOfSeg))*(1.-fract(myTime+n/numOfSeg)) //fade out\n            * (occ - step(fract(myTime+n/numOfSeg),.13*fft.x)*(occ-1.)) //occlusion\n            * ffts[int(fract(n/4.)*4.)] * (1.+2.*fract(n/4.)); //intensity\n\n      \n    // Output finalization    \n    col *= (1.+isFlank);\n    col = tmUnreal(col);\n    \n    // Tools (for full visualization see Audio Analyzer at https://www.shadertoy.com/view/ddBBWw)\n    //col = vec3(step(.0,(fragCoord.y/iResolution.y-.9))) + .7*dot( step(.0,fft-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1)) + .3*dot( step(.0,ffts-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1)); //compression amplitudes\n    //col *= .2+vec3(step(count/16.,fragCoord.y/iResolution.y)); //visualize count\n    //col += vec3(step( fragCoord.y/iResolution.y, isBeat)); //visualize isBeat  \n    //col += smoothstep(.01,.0,abs(fragCoord.y/iResolution.y-(bpm-90.)/90.)); //bpm line (>90..180)\n    \n    fragColor = vec4( col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// BUFFER A (1.0) of Audio Analyser by QuantumSuper FOR Fork: Blue Penta\n// audio spectrum by brightness of frequency by y-axis at time by x-axis (0 now; >0 historic)\n// .r: amplitude \n// .g: waveform\n// .b: average amplitude\n// .a: ( fft, ffts, timestamp, 0..0) variables\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\n#define TRACKDURATIONINFRAMES 3600.\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ [WIP]\n}\n\nfloat estMax(float p){ //estimate changing maximum over time of sound texel by weighted amplitude tracking\n    float curVal = clamp( getDat( iChannel0, vec2(p/iResolution.y*512.,0)).x, .0, 1.); //current amplitude\n    float maxVal = clamp( getDat( iChannel1, vec2(0,p)).z, .0, 1.); //latest max amp\n    \n    if (curVal >= maxVal) maxVal = 0.; //check for new max    \n    \n    if (maxVal != 0.) //avoid uninitialized state & deprecated maxVal\n        curVal *=    1./TRACKDURATIONINFRAMES,\n        maxVal *= 1.-1./TRACKDURATIONINFRAMES;\n  \n    return maxVal+curVal; //returns value between 0 and 1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    fragColor = (fragCoord.x<1.)? vec4( \n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 0)).x, //.r amplitudes\n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 1)).x, //.g waveform (does not work in VirtualDJ)\n        estMax( fragCoord.y), //.b average amplitude\n        (fragCoord.y<4.)? fft[int(fragCoord.y)] : //.a compression part 1\n        (fragCoord.y<8.)? ffts[int(fragCoord.y)-4] : //.a compression part 2\n        (fragCoord.y<9.)? iTime : //.a timestamp\n        0.) //.a empty\n        : getDat( iChannel1, fragCoord-vec2(1,0)); //history   \n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35283, "src": "https://soundcloud.com/blackworksclub/minor-dott-sueno-de-la-noche-2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// COMMON (0.0) of Audio Analyser by QuantumSuper FOR Fork: Blue Penta\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define getDat( buf, addr) texelFetch( buf, ivec2(addr), 0)\n#define getDatN( buf, addr) getDat( buf, addr).r / getDat( buf, addr).b", "buffer_b_code": "// BUFFER B (0.1) of Audio Analyser by QuantumSuper FOR Fork: Blue Penta\n// filter of audio spectrum\n// .r: beats (1D)\n// .g: 0\n// .b: 0\n// .a: 0\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    if (fragCoord.x < 1.) { //new data\n    \n        vec3 pos = 5. * vec3(0,1,2); //defines spread over frames (max beat width)      \n\n        vec3 amp = vec3(\n            (getDatN( iChannel0, vec2(pos.x,1)) + getDatN( iChannel0, vec2(pos.x,2))),\n            (getDatN( iChannel0, vec2(pos.y,1)) + getDatN( iChannel0, vec2(pos.y,2))),\n            (getDatN( iChannel0, vec2(pos.z,1)) + getDatN( iChannel0, vec2(pos.z,2)))\n            ) * .5; //normalize\n            \n        fragColor = vec4(0);\n        if (amp.y>.92 && amp.x<amp.y && amp.z<amp.y) //super simple max rise detection\n            fragColor.r = 1.;  //beat\n            \n    } else\n        fragColor = getDat( iChannel1, fragCoord-vec2(1,0)); //history \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// BUFFER C (0.91) of Audio Analyser by QuantumSuper FOR Fork: Blue Penta\n// analyse filtered beats\n// .r: bpm estimation, brightness corresponds to certainty, linear 90-180bpm\n// .g: buffer to find maximum\n// .b: -\n// .a: variables ( count (0..15), bmp estimate (>90..180), frame rate estimate, isPause (fract), timeFirstBeat, beat (bool), flank (bool), 0..0)\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\nfloat isFlank( float shift){ //simple comparison of bool-like data\n    return (getDat( iChannel1, vec2( mod(shift,iResolution.x), 0)).r > getDat( iChannel1, vec2( mod(shift+1.,iResolution.x), 0)).r)? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n         \n    // Set space for search algorithm\n    float isVert = float(iResolution.x < iResolution.y); //vertical screen orientation, bool-like\n    vec2 orient = vec2( 1.-isVert, isVert); //(1,0) horizontal/square; (0,1) vertical\n    vec2 myResolution = bool(isVert)?\n        iResolution.yx : iResolution.xy;\n    vec2 myFragCoord = bool(isVert)?\n        fragCoord.yx : fragCoord.xy; \n    \n    \n    // Estimate average frame rate\n    float estFrameRate = (iFrame < int(iResolution.x))? //buffer not yet fully filled \n        (iFrame < 1)? //initialization\n            30. : //guess frame rate\n            float(iFrame) / (iTime - getDat( iChannel0, vec2( iFrame, 8)).a) : //estimate average frame rate with less accuracy\n        iResolution.x / (iTime - getDat( iChannel0, vec2( iResolution.x-1., 8)).a); //estimate average frame rate\n    \n    \n    // Estimate BPM certainties (comb-like sum)\n    float beat = getDat( iChannel1, vec2(0)).r; //beat ongoing, bool-like\n    float flank = isFlank(0.); //rising flank of beat, bool-like\n    float amp = 0.;\n    \n    if (bool(flank)) //recalculate bpm probability if there is a new beat\n    \n        if (fragCoord.x < 1.){\n        \n            float minStep = estFrameRate / 3.; //assume max 180 bpm (3bps)\n            float stepSize = minStep * (1.+myFragCoord.y/myResolution.y); //assume min >90bpm (>1.5bps)\n            \n            for ( float n=0.; n++ < myResolution.x/stepSize; ) //go through beat history at bpm-rate steps\n                amp += isFlank( n*stepSize); //add found beat flanks\n            amp /= myResolution.x/stepSize; //normalize          \n            \n            float prevAmp = getDat( iChannel2, myFragCoord*orient.yx).r;\n            amp = (amp + prevAmp*359.) / 360.; //weight, assume stable bpm over about 2 minutes at 180bpm (or 4 min at 90bpm)\n            \n        } else \n            amp = getDat( iChannel2, myFragCoord-orient).r; //history     \n    else \n        amp = getDat( iChannel2, fragCoord).r; //copy old data (no new info) \n        \n    fragColor.r = amp;\n\n    \n    // Find BPM estimate (search algorithm)\n    vec2 compPos = (myFragCoord.x < 1.)? //is first line\n        myFragCoord.y + orient.yx : //first neighbour\n        vec2(\n            getDat( iChannel2, myFragCoord - orient).g,\n            getDat( iChannel2, myFragCoord - orient + mod( myFragCoord.x + myFragCoord.y + 1., myResolution.y) * orient.yx ).g ); //next new neighbour\n    \n    amp = (getDat( iChannel2, compPos.x*orient.yx).r < getDat( iChannel2, compPos.y*orient.yx).r)? //compare current compPos-bpm-certainties\n        compPos.y : compPos.x ; //keep only position of higher certainty\n    fragColor.g = amp;  \n    \n    float bpm = (iFrame<1)?\n        127. : //guess\n        180. / (1. + getDat( iChannel2, ceil(iResolution.y*.5)*orient).g / iResolution.y); //most certain beat-rate, range from >90 to 180 bpm\n \n    \n    // Find Beat-offset (watchdog)\n    float isPause = 1. - clamp( getDat( iChannel0, vec2(0,1)).b + getDat( iChannel0, vec2(0,2)).b, .0, 2.)/2.; //inverse average max, bool-like intent but fract usage\n    \n    float timeFirstBeat = (iFrame < 1)? 0. : //initialization\n        (isPause<.05 && getDat( iChannel2, vec2(5,3)).a > .13)? //there was a pause but is no more\n            iTime : //new first beat\n            getDat( iChannel2, vec2(0,4)).a; //old first beat\n    \n    float count = mod( (iTime-timeFirstBeat) / 60.*bpm, 16.); //count to 16 at bpm from first beat\n    \n    \n    // Save variables \n    if (fragCoord.x<1.)\n             if (fragCoord.y<1.) amp = count; //beat count (0..15) float\n        else if (fragCoord.y<2.) amp = bpm; //bmp estimate (>90..180)\n        else if (fragCoord.y<3.) amp = estFrameRate; //frame rate average\n        else if (fragCoord.y<4.) amp = isPause; //is average max-bass low\n        else if (fragCoord.y<5.) amp = timeFirstBeat; //iTime at sudden bass increase\n        else if (fragCoord.y<6.) amp = beat; //is bass high\n        else if (fragCoord.y<7.) amp = flank; //is bass beginning\n        else amp = 0.; //empty\n    else amp = getDat( iChannel2, fragCoord-vec2(1,0)).a; //history\n        \n    fragColor.a = amp;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 357, 357, 410], [433, 433, 456, 514, 551], [553, 553, 574, 644, 737], [740, 740, 781, 841, 961], [963, 963, 992, 1051, 1132], [1134, 1134, 1169, 1228, 1503], [1505, 1505, 1546, 1605, 1870], [1872, 1872, 1905, 1905, 1955], [1957, 1957, 2014, 2014, 2510], [2512, 2512, 2534, 2571, 3168], [3171, 3171, 3226, 3272, 7001]], "test": "untested"}
{"id": "mlKcR3", "name": "Triangle wave truchet weave", "author": "jarble", "description": "A truchet weave pattern using triangle waves instead of trigonometric functions.", "tags": ["truchet", "tile", "short", "golf", "sub200"], "likes": 4, "viewed": 191, "published": 3, "date": "1700507202", "time_retrieved": "2024-07-30T17:21:36.242640", "image_code": "\n#define triwave(p) abs(fract(.5+p/4.0)-.5)*2.\n//#define triwave(p) max(abs(fract(.5+p/16.0)-.5),abs(fract(p/4.0)-.5))*2.\n//#define triwave(p) abs(fract(p/4.0)-.5)*2.\n//#define triwave(p) abs(min(abs(fract(p/4.0)-.5),abs(fract(p/4.0/2.)-.5)-abs(fract(p/4.0/4.)-.5)))*2.\n//#define triwave(p) min(abs(fract(p/4.0)-.5),abs(fract(p/4.0/2.)-.5))*2.\n\n//bizarre glyphs\n//#define triwave(p) min(abs(fract(p/4.0)-.5)-2.*abs(fract(p/4.0/4.)-.5),abs(fract(p/4.0/2.)-.5))*2.\n\n//Several weave patterns\n#define triwave1(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\n//#define triwave1(p) min(abs(fract(p/4.)-.5)*2.-abs(fract(p/4.0/4.)-.5),abs(fract(p/4./2.)-.5))*2.\n//#define triwave1(p) min(abs(fract(p/4.0)-.5),abs(fract(p/4.0/4.)-.5)*2.-abs(fract(p/4.0/2.)-.5))*2.\n//#define triwave(p) 2.*(abs(fract(p/4.+.5)-.5)*2.-abs(fract(p/4./4./2./2.)-.5))\n//#define triwave1(p) min(abs(fract(p/4.0)-.5)-2.*abs(fract(p/4.0/4.)-.5),abs(fract(p/4.0/2.)-.5))*2.\n//#define triwave1(p) min(abs(fract(p/4.0)-.5),abs(fract(p/4.0/2.)-.5))*2.\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 p = I/1e2+iTime, c = ceil(p);\n    O = triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )) * vec4(22,7,5,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKcR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1017, 1017, 1053, 1053, 1193]], "test": "untested"}
{"id": "DtKcz3", "name": "Hexagon dist w/detailed flowers", "author": "timmaffett", "description": "-tmm changed flower coloring\nShader for testing random pattern distribution via hexagonal cells.\nIn a game scenario the patterns would be sampled from a texture atlas instead. (textures need to fit inside circle bounds to avoid cut off during rotation)", "tags": ["tiling", "hex"], "likes": 9, "viewed": 206, "published": 3, "date": "1700495393", "time_retrieved": "2024-07-30T17:21:37.083392", "image_code": "// Fork of \"Hexagon distribution\" by Hikagi. https://shadertoy.com/view/DlVcR3\n// 2023-11-20 15:49:31\n\nconst float PI = 3.14159265359;\n\n//Hash and Noise Functions\n\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n// customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\n\nvec2 mouseUV;\nbool mouseDown;\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 hexCoord(vec2 uv) {       \n    vec2 sc = vec2(1, 1.7320508);\n    vec2 a = uv - round(uv / sc) * sc;\n    vec2 b = uv - (round((uv - vec2(0.5, 1.0)) / sc) + 0.5) * sc;\n    \n    vec2 offset = dot(a, a) < dot(b, b) ? a : b;    \n    vec2 center = uv - offset;\n\n    // Center coordinates\n    return vec4(offset * 2.0, center);\n}\n\nfloat flower(vec2 p) {\n    float angle = atan(p.y, p.x) / (PI * 2.0);\n    float a = abs(fract(angle * 5.0) - 0.5);\n    float b = 1.0 - length(p);   \n\n    return b * (a + 0.4);\n}\n\nvec4 flowerColor(vec2 p) {\n    float angle = atan(p.y, p.x) / (PI * 2.0);\n    float a = abs(fract(angle * 5.0) - 0.5);\n    float b = 1.0 - length(p);   \n\n    return hsv2rgb( vec3(hash12(p)*b * a, b * (a + 0.4),0.9) );\n}\n\nfloat leaf(vec2 p) {\n    float a = 1.0 - abs(p.y) * 1.5;\n    float b = 1.0 - length(p) * 2.0;\n    \n    return mix(a, b, 0.5);\n}\n\nvec2 rotate (vec2 p, float angle){\t\t\t\n\tfloat sinRot = sin(angle * 2.0 * PI);\n\tfloat cosRot = cos(angle * 2.0 * PI);\n\tmat2x2 rotMat = mat2x2(cosRot, -sinRot, sinRot, cosRot);\n\t\n\treturn p * rotMat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mouseUV = iMouse.xy / iResolution.xy;\n    mouseDown = (iMouse.x!=0. && iMouse.z >= 0.);\n    vec3 mouseColor;\n    if(iMouse.xy==vec2(0.0)) {\n      mouseColor = vec3(1.0);//vec3(1.0, 0.75, 1.0);\n    } else {\n      mouseColor = hsv2rgb(vec3(mouseUV.x, mouseUV.y, 1.0)).rgb;\n    }\n    \n    vec2 uv = (fragCoord / iResolution.y) * 8.0;\n    uv.xy += iTime * 0.5;\n    \n    vec4 hex = hexCoord(uv.xy);\n\n    vec2 coord = hex.xy;    \n    float index = rand(hex.zw * 13.0);\n\n    // Primary and secondary rotation\n    float angleA = index * PI * 2.0;\n    float angleB = (iTime * 0.5 * index + index * 37.31) * 0.1 * PI * sign(index - 0.5);\n\n    vec2 dir = vec2(sin(angleA), cos(angleA));\n    \n    // Offset remap (determines scale)\n    float dist = fract(index * 3.33) * 0.4 + 0.25;\n\n    // Rotation Offset Scale\n    coord = rotate(coord, angleB);\n    coord = coord + dir * dist;\n    coord /= (1.0 - dist);\n\n    // Shape blending\n    float weight = floor(index + 0.75);\n\n    float shape = max(mix(mouseDown ? flowerColor(coord).r : flower(coord), leaf(coord), weight), 0.0);   \n    shape = floor(1.2 - shape);\n\n    vec3 flowerC = flowerColor(coord).rgb * mouseColor.rgb;\n    vec3 leafC = mix(vec3(0.75, 1.0, 0.25), vec3(0.25, 0.5, 0.5), index);\n\n    vec3 water = vec3(0.0, 0.3, 0.4);\n\n    vec3 color = mix(flowerC, leafC, weight);   \n    color = mix(color, water, shape);\n\n \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1180, 1290, 1313, 1313, 1438], [1440, 1550, 1572, 1572, 1701], [1703, 1813, 1836, 1836, 1951], [1953, 2063, 2085, 2085, 2213], [2215, 2326, 2347, 2347, 2473], [2475, 2586, 2608, 2608, 2719], [2724, 2806, 2842, 2842, 2890], [2891, 2891, 2926, 2926, 2972], [2974, 2974, 2999, 2999, 3346], [3347, 3347, 3371, 3371, 3533], [3567, 3567, 3587, 3587, 3655], [3657, 3657, 3681, 3681, 3984], [3986, 3986, 4008, 4008, 4163], [4165, 4165, 4191, 4191, 4384], [4386, 4386, 4406, 4406, 4513], [4515, 4515, 4549, 4549, 4712], [4715, 4715, 4772, 4772, 6180]], "test": "untested"}
{"id": "ctccW7", "name": "Interpolation Contrast Methods", "author": "gehtsiegarnixan", "description": "This shader shows a comparative exploration of contrast enhancement methods, featuring both Straight and Smooth Contrast techniques applied to different interpolation methods. This is also known as a top-k filter.", "tags": ["mix", "filter", "contrast", "barycentric", "lerp", "blend", "linear", "interpolation", "smooth", "bilinear", "k", "straight", "top"], "likes": 2, "viewed": 260, "published": 3, "date": "1700483389", "time_retrieved": "2024-07-30T17:21:38.025872", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader demonstrates a comparison between two methods for enhancing the \ncontrast of weights used in interpolation. A contrast function increases the \nrate of change, while meantaining normalized weights. The first is straight \ncontrast, which I may be the first to make for 3 and 4 sample interpolation, \nand the second is smooth contrast, which I have seen only a few times.\n\nSmooth interpolation operates by normalizing the weights and applying a power\nfactor to them. It is highly adaptable as it can be easily applied to any \ninterpolation technique. However, with high power values (~70+), you may start \nto encounter floating point errors.\n\nStraight contrast, on the other hand, technically modifies the coordinates. It \nworks pretty straightforwardly for linear weights. However, for higher level \ninterpolation, it becomes increasingly complex. It is faster than smooth \ncontrast and doesn't have a problem with floating point errors. \n\nThe columns, from left to right, illustrate linear interpolation with both \nStraight and Smooth Contrast, followed by barycentric interpolation with \nthe same contrasts, and finally bilinear interpolation with both contrasts \napplied.\n\nThis shader allows mouse control for the contrast on the Y-axis and enables \nyou to enlarge one of comparison pair columns by moving the X-axis to the \ncolumn center. Global constants below allow you to switch to alternate \nviews.\n\nSee a performance comparison between the contrast methods here:\nhttps://www.shadertoy.com/view/mtyyR3\n\nContrast funcitons are also known as a top-k filter:\nhttps://proceedings.mlr.press/v202/sander23a/sander23a.pdf#cite.lim2016efficient\n*/\n\n// Enable to show the weights (Alpha); disable to show textures\n#define SHOWWEIGHTS\n\n//_____________________________Straight Contrast___________________________\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// Straight Contrast to 3 Barycentric Weights, oh the pain\n// See: https://www.desmos.com/calculator/n23ntt1nys\nvec3 straightContrast(vec3 weights, float contrast) {\n    // Offset of weights to move towards the center\n    // InverseStraightContrast(0)*(1/3)\n    float offset = (contrast-1.) / (6. * contrast);\n\n    // Merge the offset with the diagonal offsets\n    float offsetA = min(offset, min(weights.y, weights.z) * 0.5);\n    float offsetB = min(offset, min(weights.x, weights.z) * 0.5);\n\n    // Apply the contrast to the merged weights\n    float contrastA = straightContrast(weights.x + offsetA, contrast);\n    float contrastB = straightContrast(weights.y + offsetB, contrast);\n    // No proper calculation needed as sum(weights)=1\n    float contrastC = clamp(1. - contrastA - contrastB, 0.,1.); // clamp prevents float errors \n        \n    // merge into vector\n    return vec3(contrastA, contrastB, contrastC);\n}\n\n// Straight Contrast for 4 Bilinear Weights \n// See: https://www.desmos.com/calculator/629sxxdp5g\nvec4 straightContrast(vec4 weights, float contrast) {\n    // recreate coordinates\n    float ab = weights.x + weights.y; // = UV.x\n    float ac = weights.x + weights.z; // = UV.y\n    \n    // apply contrast\n    ab = straightContrast(ab, contrast);\n    ac = straightContrast(ac, contrast);\n    \n    // recreate weights\n    return bilinearWeights(vec2(ab, ac));\n}\n\n//_____________________________Smooth Contrast_____________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/n23ntt1nys\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/629sxxdp5g\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//__________________________Blending Functions_____________________________\n\n// blends between two samples using different contrast methods\nvec3 linearBlend(vec2 uv, float contrast, bool straight) {\n\n    // Calculate zigzag linear weight\n    float weight = abs(fract(uv.y * 0.5) * 2.0 - 1.0);\n    \n    // alternate between contrast methods\n    if(straight) {\n        // contrast for this starts at 0, so to make it comparible\n        //contrast -= 1.;\n        \n        // a bit cheaper\n        weight = straightContrast(weight, contrast);\n    } else {\n        // prettier and easier to use\n        weight = smoothContrast(weight, contrast);\n    }\n    \n    // Debug view of weights\n    #ifdef SHOWWEIGHTS\n        // Apply a pretty colormap for visual clarity\n        return viridis(weight);\n    #endif\n    \n    // Apply arbitrary detail scale\n    uv *= 0.81;\n    \n    // Sample albedo textures\n    vec3 colorA = texture(iChannel0, uv).xyz;\n    vec3 colorB = bone(texture(iChannel1, uv).x);\n    \n    // Interpolation between the textures based on the final weight\n    return mix(colorA, colorB, weight);\n}\n\n// Barycentric interpolation between 3 samples using different contrast\nvec3 baryBlend(vec2 uv, float contrast, bool straight) {\n\n    // Calculate barycentric weights for a square pattern\n    vec3 weights = baryTiling(uv);\n           \n    if(straight) {\n        // contrast for this starts at 0, so to make it comparible\n        //contrast -= 1.;\n        \n        // Apply straight contrast on weights\n        weights = straightContrast(weights, contrast);\n    } else {\n        // Apply smooth contrast on weights\n        weights = smoothContrast(weights, contrast);\n    }\n    \n    // Debug view of weights\n    #ifdef SHOWWEIGHTS\n        // Return weights / Alpha values for debugging\n        return weights;\n    #endif\n    \n    // Apply arbitrary detail scale\n    uv *= 0.81;\n    \n    // Sample albedo textures\n    vec3 colorA = texture(iChannel0, uv).xyz;\n    vec3 colorB = bone(texture(iChannel1, uv).x);\n    vec3 colorC = texture(iChannel2, uv).xyz;\n    \n    // Interpolate between the textures based on the final weights\n    return colorA * weights.x + colorB * weights.y + colorC * weights.z;\n}\n\n// Bilinear interpolation with between 4 samples using different contrast\nvec3 bilinearBlend(vec2 uv, float contrast, bool straight) {\n\n    // Calculate vanilla bilinear weights\n    vec4 weights = bilinearTiling(uv);\n    \n    // Alternatively use smooth contrast on weights \n    if(straight) {\n        // contrast for this starts at 0, so to make it comparible\n        //contrast -= 1.;\n        \n        // Apply straight contrast on weights\n        weights = straightContrast(weights, contrast);\n        \n    } else {\n        // Apply smooth contrast on weights\n        weights = smoothContrast(weights, contrast);\n    }    \n    \n    // Debug view of weights\n    #ifdef SHOWWEIGHTS\n        // Show weights / Alpha values\n        return weights.xyz;\n    #endif\n    \n    // Apply arbitrary detail scale\n    uv *= 0.81;\n    \n    // Sample albedo textures\n    vec3 colorA = texture(iChannel0, uv).xyz;\n    vec3 colorB = bone(texture(iChannel1, uv).x);\n    vec3 colorC = texture(iChannel2, uv).xyz;\n    vec3 colorD = texture(iChannel3, uv).xyz;\n     \n    // Interpolation between the textures\n    vec3 color = colorA * weights.x + \n                 colorB * weights.y + \n                 colorC * weights.z +\n                 colorD * weights.w;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    // Calculate UVs for the x-axis of the window\n    vec2 uv = fragCoord / iResolution.x;\n    \n    // Calculate UVs for the blend grids\n    vec2 gridUV = uv * 6.0;\n    \n    // Create a float to divide into sections for comparisons\n    float comparisonX = uv.x * 6.0;\n    \n    // Enable mouse controls when clicked; otherwise, animate\n    float contrast = 1.;\n    float pointer = 0.;\n    if (iMouse.x > 0.0) {\n        // Mouse controls\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        contrast = mix(1.0, 8.0, pow(mouse.y, 2.0));\n        pointer = mouse.x * 3.0;\n    } else {\n        // Animation when no mouse input is used\n        float myTime = iTime * 1.0;\n        contrast = mix(1.0, 8.0, pow(sin(myTime) * 0.5 + 0.5, 2.0));\n    }\n    \n    // Create zigzag weights\n    float weight = abs(fract(pointer - 0.5) * 2.0 - 1.0);\n    \n    // make transitions deadzones for easier use\n    weight = straightContrast(weight, 2.);\n            \n    // Define default edge locations for the columns\n    vec2 columnEdges = vec2(2., 4.); \n    vec3 columnCenters = vec3(1., 3., 5.); \n    \n    // Mouse-controlled animations to zoom into the columns    \n    vec2 zoomColumnEdges = columnEdges;\n    vec3 zoomColumnCenters = columnCenters;\n    if (pointer <= 1.0) {\n        // Zoom into the left side        \n        zoomColumnEdges = vec2(5.2, 5.6);\n        zoomColumnCenters = vec3(2.6 ,5.4, 5.8);\n    } else if (pointer <= 2.0) {\n        // Zoom into the center column\n        zoomColumnEdges = vec2(0.4, 5.6);\n        zoomColumnCenters = vec3(0.2, 3.0, 5.8);\n    } else {\n        // Zoom into the right column\n        zoomColumnEdges = vec2(0.4, 0.8);\n        zoomColumnCenters = vec3(0.2, 0.6, 3.4);\n    }\n    \n    // Interpolate between default column edge positions and zoom\n    columnEdges = mix(columnEdges, zoomColumnEdges, weight);  \n    columnCenters = mix(columnCenters, zoomColumnCenters, weight);\n    \n    // Choose interpolation method based on the x-coordinate\n    vec3 color;\n    if (comparisonX <= columnCenters.x) {\n        // straight contrast linear interpolation\n        color = linearBlend(gridUV, contrast, true);\n           \n    } else if (comparisonX <= columnEdges.x) {\n        // smooth contrast linear interpolation\n        color = linearBlend(gridUV, contrast, false);\n    \n    } else if (comparisonX <= columnCenters.y) {\n        // straight contrast barycentric interpolation\n        color = baryBlend(gridUV, contrast, true);\n    \n    } else if (comparisonX <= columnEdges.y) {\n        // smooth contrast barycentric interpolation\n        color = baryBlend(gridUV, contrast, false);\n    \n    } else if (comparisonX <= columnCenters.z) {\n        // straight contrast bilinear interpolation\n        color = bilinearBlend(gridUV, contrast, true);\n    \n    } else {\n        // smooth contrast bilinear interpolation\n        color = bilinearBlend(gridUV, contrast, false);\n    }\n    \n    // Add lines between columns\n    float thickness = 0.005;       \n    color += step(abs(comparisonX - columnEdges.x), thickness*2.);\n    color += step(abs(comparisonX - columnEdges.y), thickness*2.);\n    color += step(abs(comparisonX - columnCenters.x), thickness);\n    color += step(abs(comparisonX - columnCenters.y), thickness);\n    color += step(abs(comparisonX - columnCenters.z), thickness);\n    \n    // Add arrows pointing at the center of columns\n    color += step(uv.y + abs(fract(comparisonX*0.5)-0.5), thickness*5.);\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Color Maps ____________________________________________________________________\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Interpolation ________________________________________________________________\n\n// Make bilinear weights\nvec4 bilinearWeights(vec2 zigZag) {\n\n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// Make tiling bilinear weights\nvec4 bilinearTiling(vec2 uv) {\n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n    \n    // Generate weights\n    return bilinearWeights(zigZag);\n}\n\n// Make square barycentric weights\nvec3 baryWeights(vec2 zigZag) {\n\n    // make individual weights for pattern\n    float weightA = min(zigZag.x, zigZag.y);\n    float weightB = min(1.-zigZag.x, 1.-zigZag.y);\n    float weightC = 1. - weightA - weightB;\n    \n    // when to alternate the 2 C samples\n    //float switchC = float(zigZag.x < zigZag.y);\n    \n    // Join weights together\n    return vec3(weightA, weightB, weightC);//, switchC);\n}\n\n// Make tiling barycentric weights\nvec3 baryTiling(vec2 uv) {\n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n    \n    // Generate weights\n    return baryWeights(zigZag);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctccW7.jpg", "access": "api", "license": "mit", "functions": [[2904, 2997, 3050, 3050, 3110], [3112, 3224, 3277, 3369, 4031], [4033, 4131, 4184, 4212, 4490], [4569, 4695, 4746, 4784, 4970], [4972, 5098, 5147, 5185, 5341], [5343, 5469, 5518, 5556, 5725], [5804, 5867, 5925, 5964, 6830], [6832, 6904, 6960, 7019, 7932], [7934, 8008, 8068, 8111, 9195], [9197, 9197, 9252, 9305, 12762]], "test": "untested"}
{"id": "dlKcWR", "name": "quad blur fx", "author": "zyc", "description": "quad blur fx", "tags": ["blur"], "likes": 0, "viewed": 157, "published": 3, "date": "1700480201", "time_retrieved": "2024-07-30T17:21:38.800801", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define progress (fract(0.4*iTime))\n#define u_Strength 0.1\n\nfloat customStep(float edge0, float edge1, float value) {\n    return clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat getScale(float p) {\n    return customStep(1.0, 0.0, p);\n}\n\nvec4 dirBlur(sampler2D inputTexture, vec2 uv, vec2 dir, float p)\n{\n    float sigma = 7.0;\n    float weight = 1.0;\n    float u_Size = 0.41;\n    float u_Bright = 3.8;\n    \n    float u_SizeScale = getScale(p);\n    \n    vec4 resColor = texture(inputTexture, uv) * weight;\n    float sumWeight = weight;\n    vec4 maxColor = resColor;\n    float curWeight = 1.0;\n    float delay = 0.9;\n    float delayWight = curWeight;\n    for (int i = 1; i <= 16; ++i)\n    {\n        weight = 1.0;\n        delayWight = delay * delayWight;\n        vec2 tmpUV = uv + dir * float(i) * u_Size * u_SizeScale;\n        vec4 a = texture(inputTexture, tmpUV) * weight;\n        tmpUV = uv - dir * float(i) * u_Size * u_SizeScale;\n        vec4 b = texture(inputTexture, tmpUV);\n        resColor += a + b;\n        vec4 c = max(a, b);\n        maxColor = max(c, maxColor);\n        sumWeight += 2.0 * weight;\n    }\n    \n    resColor /= sumWeight;\n    vec4 color = mix(resColor, maxColor, clamp(resColor * u_Bright, 0.0, 1.0));\n    resColor.rgb = color.rgb;\n    return resColor;\n}", "buffer_c_code": "#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996323\n\n#define u_Angle 45.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = u_Angle * PI / 180.0;\n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect;\n    vec4 color = dirBlur(iChannel0, uv, dir, progress);\n    fragColor = color;\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996323\n\n#define u_Angle -45.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = u_Angle * PI / 180.0;\n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect;\n    vec4 color = dirBlur(iChannel0, uv, dir, progress);\n    fragColor = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 200]], "test": "untested"}
{"id": "dtyyR3", "name": "truchet3D toroidal octahedron", "author": "cyperus", "description": "truchet3D  toroidal twisted spherical  octahedron", "tags": ["3d", "sdf", "truchet", "octahedron", "sphericalprojection"], "likes": 2, "viewed": 163, "published": 3, "date": "1700474078", "time_retrieved": "2024-07-30T17:21:39.732310", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3D toroidal octahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References & Inspiration:\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 300;\nconst float RAY_STEP_FACTOR3 = 240./450.;\nfloat RAY_STEP_FACTOR = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 1.; \n\n// platonic sphere\nconst float PS_e_f = 3.;\n\n// torus-sphere-spheres\nconst float PS_a0 = 8.;\n\n// julia\nfloat j1_to_p =12.;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    vec4 psr; float sr = 0.;\n    float rxy = 0., au = 0.0;\n    vec2 z = vec2(0.);\n    \n    /// cyclic sphere\n    vec2 e33 = vec2(.125, .75);\n    psr = spb(p, spf_F33(p, PS_a0, e33));                \n    p = psr.xyz; sr = psr.w;\n\n    /// torus-sphere-spheres\n    rxy = length(p.xy); au = atan(p.y, p.x);   \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0; z = crot(z, au + j1_to_p);\n    \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    z = p.yz;\n    \n    /// truchet 3d\n    const float TC3D_nu = PS_e_f*2.;\n    const float TC3D_nv = 4.;\n    const float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.); ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n    \n    // random\n    float rnd = hash21(tc_id.xz);  \n    \n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n    \n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n    float d;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    \n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n    \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;    \n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch   \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // mod\n    j1_to_p *= iTime/60.;\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = 0.7*(0.6+0.4*rd);\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 norm = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( float(PS_e_f)* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif            \n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, norm), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, norm), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(norm, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.003 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\n\n// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n   \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n  \nvec2 crpt(vec2 z,float a, int n, float x0) {\n    // (z*e^ia)^n-x0\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);}\n\n// stereographic & transformation\nvec3 spf_F33(vec3 p, float sh_a, vec2 e)\n{\n    // F3,3(z)\n    int k = 3, n = 3;\n    float a1 = 2. * sqrt(2.);\n    vec2 z, zk;\n\n    vec3 pn = normalize(p);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.-pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1) * zk;\n        z = cmul(z, cpow(zk - vec2(a1,   0.), k));\n        z = cdiv(z, cpow(zk + vec2(1./a1,0.), n));\n    }else          // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1)*cinv(zk);       \n        z = cmul(z, cpow(vec2(1.,0.) - zk * a1, k));\n        z = cdiv(z, cpow(vec2(1.,0.) + zk / a1, n));    \n    }\n    // sense of rotation of the polygon: sig(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {n,k}\n    float sr = float(length(z)>1.0?-n:k);    \n    z = r_poly_dist(z, e, sh_a);    \n    return vec3(z,sr);\n}\n\nvec4 spb(vec3 p, vec3 psr)\n{\n    vec2 z = psr.xy; float sr = psr.z; \n    float r = length(p);\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z));\n    if (bool(sig(sr))) {// north pole\n        p = vec3(k*z, k-1.);}\n    else { // south pol\n        z = cinv(z);\n        p = vec3(k*z, -(k-1.));\n        }\n    // back scaling    \n    p *= r;\n    return vec4(p, sr);\n}   \n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyyR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1203, 1203, 1225, 1225, 2942], [2944, 2957, 3011, 3011, 3559], [3561, 3561, 3606, 3606, 3768], [3770, 3770, 3812, 3812, 4063], [4065, 4077, 4120, 4120, 4311], [4313, 4313, 4370, 4370, 4448], [4450, 4458, 4505, 4516, 7428]], "test": "untested"}
{"id": "clGcR3", "name": "twisting block base", "author": "elenzil", "description": "just boilerplate for other things.", "tags": ["base"], "likes": 7, "viewed": 184, "published": 3, "date": "1700461612", "time_retrieved": "2024-07-30T17:21:40.513222", "image_code": "// Optional: Set iChannel0 to the keyboard for some key controls.\n//           (I keep keyboard off so it looks nice in the iOS ShaderToy app)\n//           key controls (if enabled)\n//           1 - heat map\n//           2 - shadows\n//           3 - reflections\n\n\nconst uint  march_MaxSteps  = 500u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.6;\nconst float normal_epsilon  = 0.005;\n\n// set in readKeyboard().\nbool do_Shadows;\nbool do_Reflections;\nbool do_HeatMap;\n\n\nfloat gMapCount = 0.0;\n\nfloat gT;\n\nvoid setupScene() {\n    gT = iTime * 0.3 - 10.0;\n}\n\nfloat sdScene(in vec3 p) {\n    gMapCount += 1.0;\n    \n\n    float d = 1e9;\n    \n    vec3 q = p;\n    float twist = 5.0 * smoothstep(0.0, 32.0, q.y);\n    q.xz *= rot2(twist * sin(iTime) * 0.2);\n    \n    twist *= 0.3;\n    float dBox = sdBox(q - vY * 15.0, vec3(15.0 - twist)) - twist;\n    \n    d = min(d, dBox);\n    \n    \n    d = smin(d, p.y, 1e1);\n    \n    \n    return d;\n}\n\nvec3 gradientScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradientScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 60000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 calcAlbedo(in vec3 p) {\n\n    vec3 a = v1;\n    vec3 pink = mix(v1, vX, 0.8);\n    a = mix(v1, pink, smoothstep(5.0, 30.0, p.y));\n\n    return a;\n}\n\nvec3 calcDiffuse(in vec3 p, in vec3 rd, in vec3 n, in vec3 albedo) {\n    vec3 c = albedo * (saturate(dot(n, lightDir)));\n    \n    float redness = albedo.r - albedo.g;\n    c.r += 1.0 * redness * smoothstep(1.0, 10.0, p.y) * 0.9 * (sqr((sqr(saturate(dot(n, -rd))))));\n\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 a = calcAlbedo(p);\n    vec3 c = calcDiffuse(p, rd, n, a);\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 1.5;\n    \n\n    \n    if (do_Shadows) {\n        // shadow\n        \n        // use less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        float ts = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + ts * lightDir;\n\n        if (ts < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        \n        // use even less precision for shadows\n        march_understep = mix(march_understep, 1.0, 0.5);\n        \n        const float reflectMin = 0.07;\n        const float reflectMax = 0.9;\n        float fres = mix(reflectMin, reflectMax, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        \n        if (t > 170.0) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            t = rayVsScene(ro, rd, outOfSteps);\n            if (t > 1e8) {\n                c2 = sky(ro, rd);\n            }\n            else {\n                p = ro + t * rd;\n                n = normalScene(p);\n                a = calcAlbedo(p);\n                c2 = calcDiffuse(p, rd, n, a);\n            }\n        }\n\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool keyboardNumberToggle(int number) {\n    const int k0_regular = 48;\n    const int k0_numPad  = 96;\n    \n    bool regular = bool(texelFetch(iChannel0, ivec2(k0_regular + number, 2), 0).x);\n    bool numPad  = bool(texelFetch(iChannel0, ivec2(k0_numPad  + number, 2), 0).x);\n    \n    return regular ^^ numPad;\n}\n\nvoid readKeyboard() {\n    do_HeatMap             =  keyboardNumberToggle(1);\n    do_Shadows             = !keyboardNumberToggle(2);\n    do_Reflections         = !keyboardNumberToggle(3);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.35;\n    bool isHeatMap = do_HeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    setupScene();\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += gT * 21.0;\n        M.y *= 1.5 + 0.3 * sin(iTime * 0.05);\n    }\n    \n    vec3 ro = vec3(0.0, 40.0 - 150.0 * (M.y / RES.y - 0.5), -150.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    ro.y = max(2.0, ro.y);\n    vec3 lt = vY * 26.0;\n    vec3 rd = getRayDir(xy, ro, lt, 0.3);\n    \n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/sdfrepetition/\n// fast space repetition by mirroring every other instance\n// returns (vec2 space, vec2 id)\nvec4 repeated_mirrored( vec2 p, float s )\n{\n    vec2 id = round(p/s);\n    vec2  r = p - s*id;\n    vec2  m = vec2( ((int(id.x)&1)==0) ? r.x : -r.x,\n                   ((int(id.y)&1)==0) ? r.y : -r.y );\n    return vec4(m, id);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n// SebH\n// https://www.shadertoy.com/view/ldjczd\nfloat whangHashNoise(uint u, uint v, uint s)\n{\n    uint seed = (u*1664525u + v) + s;\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\n//--------------------------------------------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGcR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 527, 546, 546, 577], [579, 579, 605, 605, 949], [951, 951, 982, 982, 1254], [1256, 1256, 1285, 1285, 1327], [1329, 1329, 1392, 1457, 1902], [1959, 1959, 1993, 1993, 2478], [2480, 2480, 2508, 2508, 2628], [2630, 2630, 2698, 2698, 2912], [2914, 2914, 2951, 2951, 4483], [4485, 4485, 4555, 4555, 4798], [5113, 5113, 5134, 5134, 5301], [5303, 5303, 5346, 5346, 6422]], "test": "untested"}
{"id": "mtVyzV", "name": "testy westy", "author": "dodi", "description": ":)", "tags": ["color"], "likes": 3, "viewed": 110, "published": 3, "date": "1700452746", "time_retrieved": "2024-07-30T17:21:41.439745", "image_code": "\nvec3 palette( float  t) {\n    vec3 a = vec3(0.5, 0.5, 0.5); \n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.253, 0.416, 0.557); \n    \n    return a + b*cos( 6.28318*(c*t*d) ); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv; \n    vec3 finalColor = vec3(0.0);\n    \n    \n    \n    \n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract(uv * 1.1) - 0.5;\n   \n   \n        float d = length(uv) * exp(-length(uv0)); \n            \n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n  \n        d = sin(d*8. + iTime)/8.;\n        d = abs(d); \n    \n        d = 0.02/ d;\n    \n        finalColor += col *= d;\n        \n        }\n \n        fragColor = vec4(finalColor, 1.0); \n    \n    \n    \n    \n \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 220], [222, 222, 279, 279, 835]], "test": "untested"}
{"id": "dtGyD1", "name": "nyan cat", "author": "aerowave", "description": "nyan", "tags": ["nyan"], "likes": 3, "viewed": 145, "published": 3, "date": "1700448759", "time_retrieved": "2024-07-30T17:21:42.214673", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalized screen coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // background color\n    fragColor = vec4(0.0, 0.2, 0.4, 1.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 pos = hash21(float(i)) + vec2(0.0, sin(iTime * 6.0)) * 0.01 - 0.01;\n        pos.x = mod(pos.x + iTime / 10.0, 1.0);\n        \n        // animation\n        int frame = int(iTime * 12.0) % 6;\n\n        vec2 nyanUv = fragCoord / iChannelResolution[0].xy;\n        nyanUv -= (pos * iResolution.xy) / iChannelResolution[0].xy; // move\n        nyanUv = clamp(nyanUv, vec2(0), vec2(40.0/256.0, 1.0)); // show only 1 frame (40px)\n        nyanUv += vec2(((float(frame) * 40.0) / 256.0), 0.0);  // animate\n\n        vec4 col = texture(iChannel0, nyanUv);\n        fragColor = mix(fragColor, vec4(col.xyz, 1.0), col.w);\n    }\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash Functions\n//\n// murmurHashNM() takes M unsigned integers and returns N hash values.\n// The returned values are unsigned integers between 0 and 2^32 - 1.\n//\n// hashNM() takes M floating point numbers and returns N hash values.\n// The returned values are floating point numbers between 0.0 and 1.0.\n\n//------------------------------------------------------------------------------\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 1 input\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 1 input\nvec2 hash21(float src) {\n    uvec2 h = murmurHash21(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 2 inputs\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 3 inputs\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash24(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 4 inputs\nvec2 hash24(vec4 src) {\n    uvec2 h = murmurHash24(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash31(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 1 input\nvec3 hash31(float src) {\n    uvec3 h = murmurHash31(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash32(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 2 inputs\nvec3 hash32(vec2 src) {\n    uvec3 h = murmurHash32(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash34(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 4 inputs\nvec3 hash34(vec4 src) {\n    uvec3 h = murmurHash34(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash41(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 1 input\nvec4 hash41(float src) {\n    uvec4 h = murmurHash41(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash42(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 2 inputs\nvec4 hash42(vec2 src) {\n    uvec4 h = murmurHash42(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash43(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 3 inputs\nvec4 hash43(vec3 src) {\n    uvec4 h = murmurHash43(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ctKyzK", "name": "Four Body Problem", "author": "causeNo", "description": "Just an experiment with \"instancing\" shapes. The shapes still being dots, fo course, since they're the only ones I know how to make so far. Definitely gonna start experimenting with other shapes soon. ", "tags": ["basic", "dot"], "likes": 1, "viewed": 133, "published": 3, "date": "1700432418", "time_retrieved": "2024-07-30T17:21:43.061409", "image_code": "void addDot(out vec3 color, in vec2 fragCoord, in vec2 uvPosition, in float uvSize) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - vec2(1.0, 1.0) + uvPosition;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    float power = uvSize / length(uv);\n\n    float white = power * 0.33 * atan(power * uvSize);\n    color = vec3(0.3 * power, 0.0, power) + vec3(white);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 composite = vec3(0.0);\n    vec3 tmp = vec3(0.0);\n\n    vec2 position = vec2(sin(iTime * 0.1), sin(iTime * 0.02));\n    addDot(tmp, fragCoord, position, 0.5);\n    composite += tmp;\n    \n    position = vec2(0.8 * sin(2.0 + iTime * 0.03), 0.6 * sin(7.2 + iTime * 0.2));\n    addDot(tmp, fragCoord, position, 0.3);\n    composite += tmp;\n    \n    position = vec2(tan(4.0 + iTime * 0.05), sin(7.2 + iTime * 0.06));\n    addDot(tmp, fragCoord, position, 0.1);\n    composite += tmp;\n    \n    position = vec2(0.5 * sin(4.0 - iTime * 0.025), 0.33 * sin(2.2 + iTime * 0.012));\n    addDot(tmp, fragCoord, position, 0.175);\n    composite += tmp;\n\n\n    fragColor = vec4(composite, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKyzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 371], [373, 373, 430, 430, 1113]], "test": "untested"}
{"id": "mtGyzV", "name": "Implementing archimedean spiral", "author": "INCHMAN1900", "description": "A new implementation of Archimedean spiral.", "tags": ["sdf", "spiral"], "likes": 3, "viewed": 128, "published": 3, "date": "1700419573", "time_retrieved": "2024-07-30T17:21:43.917121", "image_code": "#define RES iResolution.xy\n#define PI 3.1415926\n#define TAU (2.*PI)\n\nfloat w = .01;\n\nvec3 spiral(vec2 uv, float r) {\n    float a = fract((atan(uv.y, uv.x) + iTime * 10.) / TAU + .5);\n    float l = length(uv);\n    float d = l - (floor(l / r) + a) * r;\n    float c = smoothstep(w, .0, abs(d)) + smoothstep(w, .0, abs(d + r)) + smoothstep(w, .0, abs(d - r));\n    return vec3(c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - RES) / RES.y;\n    fragColor = vec4(spiral(uv, .1), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 116, 116, 377], [379, 379, 434, 434, 525]], "test": "untested"}
{"id": "mlGczK", "name": "Acrilic 3 w/ color", "author": "timmaffett", "description": "-tmm added color and mouse.x can modify iterations \n@spalmer - see where the code was changed to add color ?\nEstou testando vários tipos de raymarch's acho que este é o mais legal\nsó faltou aqui um daqueles algoritmos de vizinhança para evitar glitchs ", "tags": ["cubes", "glass", "refract", "cubos", "plastc"], "likes": 9, "viewed": 259, "published": 3, "date": "1700411187", "time_retrieved": "2024-07-30T17:21:44.702022", "image_code": "// Fork of \"Acrilic 3\" by Elsio. https://shadertoy.com/view/ctKyRy\n// 2023-11-19 16:25:19\n\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define L(q) length(max(abs(q.zx), abs(q.y)) - .2) - .01\n\n\n//Hash and Noise Functions\n\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, q, k;\n         u = (u - R.xy / 2.) / R.y;\n         o *= 0.; \n    \n    float d, ss, s, f, i, j, \n          t = iTime * .2, e = 1e-2;\n    \n    \n     vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.5) : iMouse.xy/iResolution.xy;\n    \n    float maxIter = 78.0 * mouse.x;\n    \n    while(i++ < maxIter) {\n        q = vec3(d * u, d), \n        \n        q.xz *= rot(cos(t)); \n        q.yz *= rot(t); \n        q.z -= 2.*t;\n        \n        k = floor(q) + .5;\n        q = fract(q) - .5; \n         \n        q.yz *= rot(-t); \n        q.xz *= rot(-cos(t)); \n        q.xy *= rot(cos(k.x+k.y+k.z)); \n        \n        s = L(q) - .05;\n        \n        s = abs(s);\n        \n        f = 1. - s / e, \n        \n#define cor(a)   (cos((a) * 6.3 + vec3(0, 23, 21)) * .5 + .5)\n//#define ELSIO_WHITE\n//#define ELSIO_COLOR\n//#define D_TERM_COLOR\n//#define K_TERM_HASH_COLOR\n#define ELSIO_K_TERM_HASH_COLOR\n//#define K_TERM_ALT\n\n        o +=  (f > .01) ?\n#ifdef ELSIO_WHITE\n           /* Elsio white \n              Fork of \"Acrilic 3\" by Elsio. https://shadertoy.com/view/ctKyRy\n              @spalmer made a comment asking about color - so I thought I would illustrate \n              some of infinite ways you could add color -tmm\n            */\n            //ORIG - color was always white \n           vec4(1.) * f / d * i / 210. \n#endif\n#ifdef ELSIO_COLOR\n\n            //@Elsio \n            vec4(cor(k.x+k.y+k.z) * f / d * i / 210., 1.0)\n#endif       \n#ifdef D_TERM_COLOR\n           // using d term to make color\n           hsb2rgb(vec4(3.141592653/d /*pow(d,0.2)*/,0.9,0.9,1)) * f / d * i / 210. \n#endif\n#ifdef K_TERM_HASH_COLOR          \n           // using noise to make color from k term - allows 'constant' color for each 'cube'\n           hsb2rgb(vec4(3.141592653 / hash13(k),0.9,0.9,1)) * f / d * i / 210. \n#endif\n#ifdef ELSIO_K_TERM_HASH_COLOR          \n           // using noise to make color from k term - allows 'constant' color for each 'cube'\n           hsb2rgb(vec4(3.141592653 / hash13(cor(k)),0.9,0.9,1)) * f / d * i / 210. \n#endif\n#ifdef K_TERM_ALT\n            // mix two terms to make hash - here just k.z\n           hsb2rgb(vec4(3.141592653 * hash12(vec2(k.z,k.z)),0.9,0.9,1)) * f / d * i / 210. \n#endif  \n            \n            \n           :  vec4(0);\n         \n            \n        d += max(s, e / 5.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1243, 1353, 1376, 1376, 1501], [1503, 1613, 1635, 1635, 1764], [1766, 1876, 1899, 1899, 2014], [2018, 2018, 2045, 2045, 2288]], "test": "untested"}
{"id": "dtGyzK", "name": "wave simple", "author": "zhy437488627", "description": "wave simple", "tags": ["wave"], "likes": 0, "viewed": 126, "published": 3, "date": "1700408396", "time_retrieved": "2024-07-30T17:21:45.581670", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 规范化像素坐标（从 0 到 1）\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // 将坐标中心移动到屏幕中心\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // 当前时间\n    float time = iTime;\n\n    // 使用 distance 和 sin 函数创建波纹\n    float distanceFromCenter = distance(uv, vec2(0.0, 0.0));\n    float wave = sin(distanceFromCenter * 10.0 - time * 2.0);\n\n    // 根据波纹和时间改变颜色\n    vec3 color = 0.5 + 0.5 * cos(time + uv.xyx + vec3(0, 2, 4));\n\n    // 将波纹效果融入颜色中\n    color *= wave;\n\n    // 输出最终颜色\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGyzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 101, 693]], "test": "untested"}
{"id": "ctGczV", "name": "Sine wave design", "author": "Peter226", "description": "Looking to re-create a certain animated background design using sine waves", "tags": ["sine"], "likes": 3, "viewed": 116, "published": 3, "date": "1700401571", "time_retrieved": "2024-07-30T17:21:46.482263", "image_code": "const float PI = 3.14;\n\nfloat animateSine(float pos, float freq, float speed){\n    return (sin((pos * freq -iTime * speed)) + 1.0) * 0.5;\n}\n\n\n\nfloat makeSine(vec2 uv, float offset){\n\n    uv.y += offset * 10.0;\n    float baseWave = sin(uv.x * 0.03 + offset * 0.001 * uv.x) * 20.0;\n    float animate = animateSine(uv.x, 0.003, 3.0);\n\n    float animatedCol = animate * (3.0 * animate - abs(uv.y + baseWave));\n    \n    return max(0.0,animatedCol);\n}\n\n\nfloat drawWaves(vec2 fragCoord, int numberOfWaves, float freq){\n    float waves = 0.0;\n    for(int i = 0;i < numberOfWaves;i++){\n       waves += makeSine(fragCoord, float(i) * freq);\n    }\n    return waves * 0.2;\n}\n\n\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, \n                 s,  c );\n}\n\nvec2 rotateCoord(vec2 coord, float rotation){\n    return coord * rotationMatrix(rotation);\n}\n\nvec2 transposeCoord(vec2 coord, vec2 offset, float rotation){\n    return coord * rotationMatrix(rotation) + offset;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    fragColor += drawWaves(transposeCoord(fragCoord, vec2(0,-300), -40.1), 25, 0.6);\n    fragColor += drawWaves(transposeCoord(fragCoord, vec2(0,-200), 20.0), 40, 0.4);\n        fragColor += drawWaves(transposeCoord(fragCoord, vec2(0,-200), 160.0), 20, 0.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 78, 78, 139], [143, 143, 181, 181, 445], [448, 448, 511, 511, 662], [666, 666, 700, 700, 813], [815, 815, 860, 860, 907], [909, 909, 970, 970, 1026], [1029, 1029, 1086, 1136, 1586]], "test": "untested"}
{"id": "clyyRV", "name": "a grid and some balls", "author": "immibis", "description": "Trying some basic raymarching and repeating structures.", "tags": ["raymarching", "grid", "balls", "translucency"], "likes": 2, "viewed": 113, "published": 3, "date": "1700398921", "time_retrieved": "2024-07-30T17:21:47.244225", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 dir = vec3(fragCoord/iResolution.xy*2.-1.,1.)*0.025;\n    dir.x *= float(iResolution.x)/float(iResolution.y);\n    dir=normalize(dir)*0.025;\n    \n    vec3 campos = vec3(iTime*1.-.3,iTime*.5+.17,iTime*1.);\n    vec3 pos = campos;\n    ivec3 icampos = ivec3(pos);\n    \n    fragColor=vec4(0,0,0,1);\n    \n    float remAlpha = 1.;\n    \n    const float GRID_ALPHA = 0.25;\n    \n    for(int i = 0; i < 400; i++) {\n        pos = campos+dir*float(i);\n        \n        ivec3 ipos = ivec3(pos);\n        vec3 frac1 = pos - floor(pos);\n        vec3 frac = pos - floor(pos+0.5);\n        bool a = abs(frac.x) < 0.05;\n        bool b = abs(frac.y) < 0.05;\n        bool c = abs(frac.z) < 0.05;\n        \n        vec3 ballpos = vec3(0.5+0.25*sin(iTime*5.),0.5+0.25*cos(iTime*3.),0.5);\n        float ballsize = 0.25;\n        \n        if(((ipos.x ^ ipos.y) & 1) != 0) {\n            ballpos.y = 1. - ballpos.y;\n        }\n        if((ipos.y & 1) != 0) {\n            ballpos.y = 1. - ballpos.y;\n            ballpos.x = 1. - ballpos.x;\n        }\n        ballsize = sqrt((length(campos - vec3(ipos) - vec3(0.5)) - 1.)) / 5.;\n        \n        float col = 1.-mod(pos.z - campos.z,100.)/10.;\n        if(a && b) {\n            fragColor.rgb=mix(fragColor.rgb,vec3(0,0,col),remAlpha*GRID_ALPHA);\n            remAlpha=remAlpha*(1.-GRID_ALPHA);\n        }\n        if(a && c) {\n            fragColor.rgb=mix(fragColor.rgb,vec3(0,col,0),remAlpha*GRID_ALPHA);\n            remAlpha=remAlpha*(1.-GRID_ALPHA);\n        }\n        if(b && c) {\n            fragColor.rgb=mix(fragColor.rgb,vec3(col,0,0),remAlpha*GRID_ALPHA);\n            remAlpha=remAlpha*(1.-GRID_ALPHA);\n        }\n        if(length(frac1-ballpos)<ballsize) {\n            float c = 1.-mod(pos.z - campos.z,100.)/10.;\n            c *= dot(normalize(frac1 - ballpos), vec3(-0.5,0,-0.7))*0.5+0.5;\n            \n            fragColor.rgb=mix(fragColor.rgb,vec3(c,c,c),remAlpha);\n            return;\n        }\n    }\n    fragColor.rgb=mix(fragColor.rgb,vec3(0,0,0),remAlpha);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2055]], "test": "untested"}
{"id": "mtKczy", "name": "truchet3D toroidal hexahedron", "author": "cyperus", "description": "truchet3D  toroidal spherical  hexahedron", "tags": ["3d", "sdf", "truchet", "sphericalprojection", "hexahedron"], "likes": 6, "viewed": 157, "published": 3, "date": "1700382799", "time_retrieved": "2024-07-30T17:21:48.331319", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3D toroidal hexahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References & Inspiration:\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 300;\nconst float RAY_STEP_FACTOR3 = 230./450.;\nfloat RAY_STEP_FACTOR = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 1.; \n\n// platonic sphere\nconst float PS_e_f = 4.;\n\n// torus-sphere-spheres\nfloat PS_a0 = 8.;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0;\n    float cell_id = 0., sr = 0.;\n    vec2 z = vec2(0.);\n           \n    /// platonic sphere\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell.\n    pn = hexa_cells(pn, cell_id, sr);\n    \n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cHexaPolyArc2disk(z);\n    \n    // r-polygon-distribution\n    vec2 e = vec2(3., 0.5);\n    e.y += - 0.05 *cos(PS_e_f*atan(z.y, z.x));\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;\n\n    //stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    //unnormalize\n    p = length(p) * pn;    \n\n    /// torus-sphere-spheres\n    rxy = length(p.xy); au = atan(p.y, p.x);   \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    z = p.yz;\n    \n    /// truchet 3d\n    const float TC3D_nu = PS_e_f*2.*2.;\n    const float TC3D_nv = 2.*2.;\n    const float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.); ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n    \n    // random\n    float rnd = hash21(tc_id.xz);  \n    \n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n    \n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n    float d;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    \n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n    \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;    \n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch   \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {  \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = 0.7*(0.6+0.4*rd);\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 norm = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( float(PS_e_f)*3.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif            \n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, norm), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, norm), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(norm, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.003 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float PI_2 = PI/2.;\n\n/// 1D transformations\nfloat pow2( in float x){ return x*x;}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  // (z*e^ia)^p-x0\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cHexaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2( 0.7072, -0.7070)\n    ,vec2(-0.7070,  0.7072)\n    ,vec2(-0.0377, -0.9993)\n    ,vec2( 0.7072,  0.7070)\n    ,vec2(-0.7072, -0.7070)\n    ,vec2(-0.0377,  0.9993)\n    ,vec2( 0.5452, -0.8383)\n    ,vec2( 0.9936,  0.1126)\n    ,vec2(-0.9936,  0.1126)\n    ,vec2(-0.7983, -0.6022)\n    ,vec2(-0.7563,  0.6542)\n    ,vec2( 0.6542,  0.7563)\n    ,vec2( 0.7563, -0.6542)\n    ,vec2(-0.6235,  0.7818)\n    ,vec2(-0.7167, -0.6974)\n    ,vec2(-0.6542, -0.7563)\n    ,vec2( 0.7342,  0.6790)\n    ,vec2( 0.7025, -0.7117));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2( 0.0135,  0.0   )\n    ,vec2( 0.0008,  0.0001)\n    ,vec2(-0.5762,  0.1282)\n    ,vec2( 0.0013,  0.0002)\n    ,vec2(-0.0135, -0.0085)\n    ,vec2( 0.1239, -0.0601)\n    ,vec2(-0.2162, -0.3769)\n    ,vec2( 0.1197, -0.1327)\n    ,vec2( 0.2544,  0.0708)\n    ,vec2( 0.3228,  0.3050)\n    ,vec2( 0.0377, -0.0056)\n    ,vec2( 0.0362, -0.0135)\n    ,vec2( 0.1439, -0.0871)\n    ,vec2( 0.0551,  0.0066)\n    ,vec2(-0.0935,  0.1492)\n    ,vec2(-0.2397,  0.1216)\n    ,vec2( 0.0218, -0.0211)\n    ,vec2( 0.0077, -0.0763));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2( 0.366242, -0.365216)\n    ,vec2(-0.365216,  0.366242)\n    ,vec2(-0.012767, -0.414156)\n    ,vec2( 0.366242,  0.365216)\n    ,vec2(-0.366242, -0.365216)\n    ,vec2(-0.012767,  0.414156)\n    ,vec2( 0.216186, -0.397592)\n    ,vec2( 0.413695,  0.038296)\n    ,vec2(-0.413695,  0.038296)\n    ,vec2(-0.391705, -0.251311)\n    ,vec2(-0.383838,  0.291533)\n    ,vec2( 0.291533,  0.383838)\n    ,vec2( 0.383838, -0.291533)\n    ,vec2(-0.266502,  0.388876)\n    ,vec2(-0.372411, -0.341303)\n    ,vec2(-0.291533, -0.383838)\n    ,vec2( 0.378349,  0.316470)\n    ,vec2( 0.350877, -0.369995));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++) {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zn += cmul(rf[j], zj); // sum nominator\n        zd += zj;              // sum denominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 hexa_cells(in vec3 p, out float cell_id, out float sr){\n\t//// hexagon\n    // cells +X, -X, +Y, -Y,+Z, -Z\n    // cell walls defined by the face_normals\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    // map (+X, -X, +Y, -Y,+Z, -Z)-cells to (-Z)-cell by rotation\n    // rotation angles\n    const float a90 = PI/2.; // a = 90°       \n    const vec2 ei_a0   = vec2(1., 0.);             // a = 0° \n    const vec2 ei_a90  = vec2(cos(a90), sin(a90)); // a = 90°\n    \n    vec2 ei_y; vec2 ei_x;\n\t//inside cell +X: +X --> -Z\n\tif(nBA && nDA && !nCB && nDC) {\n\t\tcell_id = 0.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -X: -X --> -Z\n\telse if(!nBA && !nDA && nCB && !nDC) {\n\t\tcell_id = 1.;\n\t\tei_y = -ei_a90;\n\t\tei_x = ei_a0;\n\t}\n    //inside cell +Y: +Y --> -Z\n\telse if(nCA && nDA && nCB && nDB) {\n\t\tcell_id = 2.;\n\t\tei_y = -ei_a90;\n\t\tei_x = -ei_a90;\n\t}\n\t//inside cell -Y: -Y --> -Z\n\telse if(!nCA && !nDA && !nCB && !nDB ) {\n\t\tcell_id = 3.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a90;\n\t}\n\t//inside cell +Z: +Z --> -Z\n\telse if(!nBA && !nCA && nDB && nDC) {\n\t\tcell_id = 4.;\n\t\tei_y = -ei_a0; // 180°\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -Z: -Z --> -Z\n\telse if(nBA && nCA && !nDB && !nDC) {\n\t\tcell_id = 5.;\n\t\tei_y = ei_a0;\n\t\tei_x = ei_a0;\n\t}        \n\t// cell orientation\n\tp.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tp.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\t// non cyclic\n\tsr = 4.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.;\n}\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n}\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKczy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1281, 1281, 1303, 1303, 3470], [3472, 3485, 3539, 3539, 4087], [4089, 4089, 4134, 4134, 4296], [4298, 4298, 4340, 4340, 4591], [4593, 4605, 4648, 4648, 4839], [4841, 4841, 4898, 4898, 4976], [4978, 4986, 5033, 5074, 7924]], "test": "untested"}
{"id": "dtKczy", "name": "truchet3D toroidal dodecahedron", "author": "cyperus", "description": "truchet3D  toroidal spherical  dodecahedron", "tags": ["3d", "sdf", "truchet", "dodecahedron", "sphericalprojection"], "likes": 3, "viewed": 125, "published": 3, "date": "1700381371", "time_retrieved": "2024-07-30T17:21:49.443345", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3D toroidal dodecahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References & Inspiration:\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 300;\nconst float RAY_STEP_FACTOR3 = 230./450.;\nfloat RAY_STEP_FACTOR = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 1.; \n\n// platonic sphere\nconst float PS_e_f = 5.;\n\n// torus-sphere-spheres\nfloat PS_a0 = 8.;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0;\n    float cell_id = 0., sr = 0.;\n    vec2 z = vec2(0.);\n           \n    /// platonic sphere\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = dodeca_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cDodecaPolyArc2disk(z);\n    \n    // r-polygon-distribution\n    vec2 e = vec2(3., 0.4);\n    e.y += - 0.05 *cos(PS_e_f*atan(z.y, z.x));\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;\n\n    //stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    //unnormalize\n    p = length(p) * pn;    \n\n    /// torus-sphere-spheres\n    rxy = length(p.xy); au = atan(p.y, p.x);   \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    z = p.yz;\n    \n    /// truchet 3d\n    const float TC3D_nu = PS_e_f*2.*2.;\n    const float TC3D_nv = 2.*2.;\n    const float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.); ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n    \n    // random\n    float rnd = hash21(tc_id.xz);  \n    \n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n    \n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n    float d;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n    \n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n    \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;    \n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0;\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0;\n\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch   \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {  \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = 0.7*(0.6+0.4*rd);\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 norm = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( float(PS_e_f)*3.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif            \n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, norm), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, norm), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(norm, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-0.003 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float PI_2 = PI/2.;\n\n/// 1D transformations\nfloat pow2( in float x){ return x*x;}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  // (z*e^ia)^p-x0\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cDodecaPolyArc2disk(vec2 z){\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 25; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-0.8260, - 0.5637)\n    ,vec2( 0.8091, + 0.5877)\n    ,vec2(-0.3090, - 0.9511)\n    ,vec2(-0.3089, - 0.9511)\n    ,vec2( 0.8089, - 0.5879)\n    ,vec2(-1.0000, + 0.0000)\n    ,vec2(-1.0000, + 0.0001)\n    ,vec2(-0.3090, + 0.9511)\n    ,vec2(-0.3089, + 0.9511)\n    ,vec2( 0.9996, - 0.0294)\n    ,vec2( 0.9103, + 0.4140)\n    ,vec2( 0.2242, + 0.9746)\n    ,vec2( 0.3369, - 0.9415)\n    ,vec2(-0.8576, + 0.5143)\n    ,vec2(-0.4307, - 0.9025)\n    ,vec2(-0.3567, + 0.9342)\n    ,vec2(-0.9988, - 0.0485)\n    ,vec2( 0.7796, + 0.6263)\n    ,vec2( 0.7796, - 0.6263)\n    ,vec2(-0.2828, - 0.9592)\n    ,vec2(-0.3161, + 0.9487)\n    ,vec2(-1.0000, + 0.0075)\n    ,vec2(-0.2187, + 0.9758)\n    ,vec2( 0.8366, - 0.5479)\n    ,vec2( 0.8134, + 0.5817));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2(-0.1213, - 0.0   )\n    ,vec2( 0.0028, + 0.0187)\n    ,vec2( 0.0000, - 0.0000)\n    ,vec2(-0.0010, + 0.0008)\n    ,vec2(-0.0017, - 0.0008)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2(-0.0041, - 0.0007)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2( 0.0219, - 0.0012)\n    ,vec2(-0.2767, - 0.2629)\n    ,vec2( 0.2548, - 0.3937)\n    ,vec2( 0.4733, + 0.0936)\n    ,vec2(-0.0954, - 0.0232)\n    ,vec2(-0.1703, + 0.0600)\n    ,vec2(-0.0347, - 0.0277)\n    ,vec2(-0.3617, + 0.0048)\n    ,vec2(-0.0493, + 0.0086)\n    ,vec2( 0.1573, + 0.1009)\n    ,vec2(-0.0406, - 0.0040)\n    ,vec2(-0.0118, - 0.0116)\n    ,vec2( 0.0485, + 0.1712)\n    ,vec2(-0.0014, + 0.0204)\n    ,vec2( 0.1498, + 0.3189)\n    ,vec2(-0.0419, - 0.0255)\n    ,vec2( 0.1042, - 0.0471));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.2339, - 0.1614)\n    ,vec2( 0.2737, + 0.1982)\n    ,vec2(-0.1045, - 0.3217)\n    ,vec2(-0.1039, - 0.3216)\n    ,vec2( 0.2731, - 0.1991)\n    ,vec2(-0.3383, + 0.0   )\n    ,vec2(-0.3379, + 0.0006)\n    ,vec2(-0.1045, + 0.3217)\n    ,vec2(-0.1039, + 0.3216)\n    ,vec2( 0.2841, - 0.0069)\n    ,vec2( 0.2810, + 0.1078)\n    ,vec2( 0.0682, + 0.2764)\n    ,vec2( 0.0943, - 0.2680)\n    ,vec2(-0.2418, + 0.1502)\n    ,vec2(-0.1496, - 0.2698)\n    ,vec2(-0.1287, + 0.2944)\n    ,vec2(-0.3202, - 0.0306)\n    ,vec2( 0.2411, + 0.2130)\n    ,vec2( 0.2411, - 0.2130)\n    ,vec2(-0.0808, - 0.3165)\n    ,vec2(-0.1114, + 0.3141)\n    ,vec2(-0.3331, + 0.0088)\n    ,vec2(-0.0510, + 0.3095)\n    ,vec2( 0.2770, - 0.1635)\n    ,vec2( 0.2747, + 0.1886));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 dodeca_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// dodecaeder\n\tconst float gr0 = (1.+sqrt(5.))/2.; const float gr1 = 1./gr0; const float gr2 = gr0-gr1;\n\t// cell-wall-face-normals\n\tbool nx = dot(vec3( 1., 0., 0.),p)>=0.;\n\tbool ny = dot(vec3( 0., 1., 0.),p)>=0.;\n\tbool nz = dot(vec3( 0., 0., 1.),p)>=0.;\n\t//\n\tbool n0A = dot(vec3( gr2,-gr0, gr1),p)>=0.;\n\tbool n0B = dot(vec3( gr1, gr2,-gr0),p)>=0.;\n\tbool n0C = dot(vec3(-gr0, gr1, gr2),p)>=0.;\n\t//\n\tbool n1A = dot(vec3(-gr2,-gr0,-gr1),p)>=0.;\n\tbool n1B = dot(vec3(-gr1, gr2, gr0),p)>=0.;\n\tbool n1C = dot(vec3( gr0, gr1,-gr2),p)>=0.;\n\t//\n\tbool n2A = dot(vec3(-gr2, gr0, gr1),p)>=0.;\n\tbool n2B = dot(vec3(-gr1,-gr2,-gr0),p)>=0.;\n\tbool n2C = dot(vec3( gr0,-gr1, gr2),p)>=0.;\n\t//\n\tbool n3A = dot(vec3( gr2, gr0,-gr1),p)>=0.;\n\tbool n3B = dot(vec3( gr1,-gr2, gr0),p)>=0.;\n\tbool n3C = dot(vec3(-gr0,-gr1,-gr2),p)>=0.;\n\n\t// cells\n    float a = PI_2-atan((sqrt(5.)-1.)/2.);\n    float b = PI/10.; // 18°\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n\t//Fpxpy\n    if(ny && !n2B && n2C && !n0C && n0B)\t\n\t{\n\t\tcell_id = 0.;\n\t\ta_y = PI_2;\n        a_x = a-PI_2;\n\t\ta_z = b;\n\t}\n\t//Fnxny\n\telse if(!ny && n2B && !n2C && n0C && !n0B)\n\t{\n\t\tcell_id = 1.;\n\t\ta_y = PI_2;\n        a_x = a+PI_2;\n\t\ta_z = b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpxny\n\telse if(ny && n1B && !n1C && n3C && !n3B)\n\t{\n\t\tcell_id = 2.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a-PI_2;\n\t\ta_z =  b;\n\t}\n\t//Fnxpy\n\telse if(!ny && !n1B && n1C && !n3C && n3B)\n\t{\n\t\tcell_id = 3.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a+PI_2;\n\t\ta_z =  b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpypz\n\telse if(!nz && n3C && !n3A && n0A && !n0C)\n\t{\n\t\tcell_id = 4.;\n\t\ta_y =  0.;\n        a_x =  a;\n\t\ta_z =  b;\n\t}\n\t//Fnynz\n\telse if(nz && !n3C && n3A && !n0A && n0C)\n\t{\n\t\tcell_id = 5.;\n\t\ta_y =  0.; \n\t\ta_x =  a+PI;\n\t\ta_z =  b;\n\t}\n\n\t// ---------------------------------------------------------------\n\t//Fpynz\n\telse if(nz && n2C && !n2A && n1A && !n1C)\n\t{\n\t\tcell_id = 6.;\n\t\ta_y =  0.;\n        a_x = -a+PI;\n\t\ta_z = -b;        \n\t}\n\t//Fnypz\n\telse if(!nz && !n2C && n2A && !n1A && n1C)\n\t{\n\t\tcell_id = 7.;\n\t\ta_y =  0.;\n        a_x = -a;\n\t\ta_z = -b;       \n\t}\n\t// ---------------------------------------------------------------\n\t//Fpzpx\n\telse if(!nx && n1A && !n1B && n0B && !n0A)\n\t{\n\t\tcell_id = 8.;\n\t\ta_y =  a-PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t//Fnznx\n\telse if( nx && !n1A && n1B && !n0B && n0A)\n\t{\n\t\tcell_id = 9.;\n\t\ta_y =  a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpznx\n\telse if(nx && n3A && !n3B && n2B && !n2A)\n\t{\n\t\tcell_id = 10.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  b+PI_2;\n\t}\n\t//Fnzpx\n\telse if(!nx && !n3A && n3B && !n2B && n2A )\n\t{\n\t\tcell_id = 11.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  PI;\n\t\ta_z =  b-PI_2;\n\t}\n\t// ---------------------------------------------------------------\n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 5.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\n// stereographic projection\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKczy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1283, 1283, 1305, 1305, 3472], [3474, 3487, 3541, 3541, 4089], [4091, 4091, 4136, 4136, 4298], [4300, 4300, 4342, 4342, 4593], [4595, 4607, 4650, 4650, 4841], [4843, 4843, 4900, 4900, 4978], [4980, 4988, 5035, 5076, 7926]], "test": "untested"}
{"id": "mtyyzG", "name": "Light Rain on Camera (Tabyltop)", "author": "DrieStone", "description": "Rainy Day (revised the Heartfelt rain to be a bit more generic)", "tags": ["rain"], "likes": 5, "viewed": 262, "published": 3, "date": "1700368220", "time_retrieved": "2024-07-30T17:21:50.523458", "image_code": "// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I revisited the rain effect I did for another shader. This one is better in multiple ways:\n// 1. The glass gets foggy.\n// 2. Drops cut trails in the fog on the glass.\n// 3. The amount of rain is adjustable (with Mouse.y)\n\n// To have full control over the rain, uncomment the HAS_HEART define \n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=uiF5Tlw22PI&feature=youtu.be\n\n// Music - Alone In The Dark - Vadim Kiselev\n// https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark\n// Rain sounds:\n// https://soundcloud.com/elirtmusic/sleeping-sound-rain-and-thunder-1-hours\n\n#define S(a, b, t) smoothstep(a, b, t)\n//#define CHEAP_NORMALS\n#define HAS_HEART\n#define USE_POST_PROCESSING\n\nuniform float amount;\n\n\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy / iResolution.xy;\n    uv = uv * 0.4;\n\n    float T = iTime;\n\n    float t = T * 0.2;\n    float rainAmount = (20.1 + amount) / 150.;\n    if (rainAmount < 0.14) { rainAmount = 0.20;}\n\n    \n\n    // Removed zoom effect\n    // uv and UV are no longer modified by a zoom factor\n\n    float staticDrops = S(-.5, 1., rainAmount) * 1.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(0., .5, rainAmount);\n\n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    // Normal calculation (keeping as is)\n    #ifdef CHEAP_NORMALS\n    vec2 n = vec2(dFdx(c.x), dFdy(c.x));\n    #else\n    vec2 e = vec2(.001, 0.);\n    float cx = Drops(uv + e, t, staticDrops, layer1, layer2).x;\n    float cy = Drops(uv + e.yx, t, staticDrops, layer1, layer2).x;\n    vec2 n = vec2(cx - c.x, cy - c.x);\n    #endif\n\n    float maxBlur = mix(1., 1.5, rainAmount);\n    float minBlur = 1.;\n    float focus = mix(maxBlur - c.y, minBlur, S(.1, .2, c.x));\n    vec3 col = textureLod(iChannel0, UV + n, focus).rgb;\n\n    // Post-processing\n    #ifdef USE_POST_PROCESSING\n    t = (T + 3.) * .5;\n    /*float colFade = sin(t * .2) * .5 + .5;*/\n    col *= vec3(.8, .9, 1.3);\n    /*float fade = S(0., 10., T);*/\n    float lightning = sin(t * sin(t * 10.));\n    lightning *= pow(max(0., sin(t + sin(t))), 10.);\n    col *= 1. + lightning;\n    col *= 1. - dot(UV -= .5, UV);\n    /*col *= fade;*/\n    #endif\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyyzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[947, 947, 966, 992, 1164], [1166, 1166, 1185, 1185, 1273], [1274, 1274, 1292, 1292, 1338], [1340, 1340, 1369, 1369, 1404], [1407, 1407, 1442, 1442, 2594], [2596, 2596, 2633, 2633, 2909], [2911, 2911, 2971, 2971, 3190], [3192, 3192, 3247, 3247, 4747]], "test": "untested"}
{"id": "DtVczG", "name": "Approx. Si(x), Ci(x), Cin(x)", "author": "FordPerfect", "description": "Approximations of Ci(x) [red], Cin(x) [green], Si(x) [blue], and their error plots.\nThe plot is log-log: x is in [1e-7;1e+2], y is in [1e-8;1e-1].\nClick at the top to select a function (leftmost=time-reel).\nHold LMB to show plot of the relative error.", "tags": ["sine", "cosine", "integral", "si", "ci", "specialfunction", "cin"], "likes": 4, "viewed": 203, "published": 3, "date": "1700353798", "time_retrieved": "2024-07-30T17:21:51.581628", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Several approximations of sine and cosine integrals, and their\n// accuracy measurements in float32.\n\n// Functions are tested exhaustively on [-inf,+inf] range of float32 values,\n// using a C++ test program on x86, in IEEE-754 binary32 (-mfpmath=sse),\n// in the default (round-nearest-ties-even) rounding direction, without FMA,\n// using \"glibc 2.31-9\" versions of math functions, and double precision\n// GSL (https://www.gnu.org/software/gsl/) versions of Si and Ci (with \n// some bugfixes) as a reference.\n//\n// NOTE: the results do depend on the floating-point environment,\n// and library math functions, so e.g. the plots here may look different\n// in different GLSL implementations (see e.g. https://www.shadertoy.com/view/dttczs).\n//\n// Both absolute (Eabs) and relative (Erel) errors (maximum, i.e. inf-norm) are\n// reported. For some of the more accurate functions, errors in ULPs\n// (units in the last place) are also presented.\n//\n// The plot is log-log: x is in [1e-7;1e+2], y is in [1e-8;1e-1].\n// Plot colors:\n//     Ci(x)  - red\n//     Cin(x) - green\n//     Si(x)  - blue\n\n// For sine integral, a function si(x)=pi/2-Si(x) is sometimes also\n// defined.\n// For cosine integral there are 2 related functions Ci(x) and Cin(x) with\n//     Cin(x)=gamma+ln(x)-Ci(x)\n// where gamma=0.57721566490153286060651209... is Euler-Mascheroni constant.\n// Real-valued Ci(x) is defined on (0;+inf) (with Ci(-x)=Ci(x)+pi*i being complex),\n// while Cin(x) is defined on (-inf;+inf) (with Cin(-x)=Cin(x)).\n//     Ci (0)=-inf, Ci (inf)= 0,\n//     Cin(0)= 0  , Cin(inf)=+inf.\n// Numerically, Ci and Cin approximations based on the same formula have\n// about the same worst absolute error, but the worst relative error of Ci\n// is basically infinite, due to Ci(x) passing through 0, unlike Cin\n// for |x|>0.\n\n// NOTE: the only open-source single precision implementation of Si(x)\n// I'm aware of (sicif.c from Cephes, https://www.netlib.org/cephes/)\n// has a bug, where it returns +pi/2 for x<-1e-9, but once you fix that,\n// it has accuracy ~4.3 ulp on the entire range.\n\n// NOTE: the GSL (double-precision) version of Ci(x) (gsl_sf_Ci) appears\n// to have a bug, returning large values for large arguments.\n// NOTE: scipi versions seem to be fine.\n\n//==============================================================================\n// Auxiliary functions (also sometimes denoted f() and g()):\n//     fi(x)=(pi/2-Si(x))*cos(x)+Ci(x)*sin(x)\n//     gi(x)=(pi/2-Si(x))*sin(x)-Ci(x)*cos(x)\n// Several approximations of these on 1<=x<inf from\n//     Hastings C.: Approximations for Digital Computers. Princeton University Press, 1955.\n// (where they are called P(x) and Q(x) respectively), which also made it into\n// Abramowitz and Stegun.\n\n// NOTE: these approximations suffer numerical problems for large arguments.\n// The safe ranges are noted below.\n\n// On [1; 50859008]\n// Eabs<1.6e-4\n// Erel<1.1e-3\nfloat fi4(float x)\n{\n    float x2=x*x;\n    return (2.463936+7.241163*x2+x2*x2)/(x*(7.157433+9.068580*x2+x2*x2));\n}\n\n// On [1; 319557]\n// Eabs<8.0e-6\n// Erel<8.6e-5\nfloat fi6(float x)\n{\n    float x2=x*x;\n    return ( 8.493336+x2*(47.411538+19.394119*x2+x2*x2))/\n        (x*(30.038277+x2*(70.376496+21.361055*x2+x2*x2)));\n}\n\n// On [1; 19112]\n// Eabs<6.8e-7\n// Erel<8.0e-6\n// Eulp<132.5\nfloat fi8(float x)\n{\n    float x2=x*x;\n    return ( 38.102495+x2*(335.677320+x2*(265.187033+38.027264*x2+x2*x2)))/\n        (x*(157.105423+x2*(570.236280+x2*(322.624911+40.021433*x2+x2*x2))));\n}\n\n// On [1; 2642245]\n// Eabs: 0.000116066195\n// Erel: 0.0048635339\n// Eulp: 81392.2198\nfloat gi4(float x)\n{\n    float x2=x*x;\n    return (1.564072+7.547478*x2+x2*x2)/(x2*(15.723606+12.723684*x2+x2*x2));\n}\n\n// On [1; 65535]\n// Eabs: 5.60678695e-06\n// Erel: 0.000540943856\n// Eulp: 9043.08217\nfloat gi6(float x)\n{\n    float x2=x*x;\n    return  ( 5.089504+x2*( 49.719775+21.383724*x2+x2*x2))/\n        (x2*(76.707878+x2*(119.918932+27.177958*x2+x2*x2)));\n}\n\n// On [1; 7131]\n// Eabs: 4.37074273e-07\n// Erel: 6.44829123e-05\n// Eulp: 1080.53846\nfloat gi8(float x)\n{\n    float x2=x*x;\n    return  ( 21.821899+x2*( 352.018498+x2*(302.757865+42.242855*x2+x2*x2)))/\n        (x2*(449.690326+x2*(1114.978885+x2*(482.485984+48.196927*x2+x2*x2))));\n}\n\n//==============================================================================\n// Asymptotic of Si and Ci for x->inf.\n\n// Approximates Si(x) for |x|>1e4.\nfloat Si_asymp(float x)\n{\n    return abs(x)>1e10?\n        sign(x)*1.5707963268:\n        sign(x)*1.5707963268-cos(x)/x-sin(x)/(x*x);\n}\n\n// Approximates Ci(|x|) for |x|>1e4.\nfloat Ci_asymp(float x)\n{\n    return abs(x)>1e10?\n        0.0:\n        sin(x)/x-cos(x)/(x*x);\n}\n\n//==============================================================================\n// Crude but concise approximation, using the observation that\n//     atan(x)<Si(x)<pi-atan(x) for x>0\n// and Si(x) comes pretty close to these bounds at extrema.\n// For the proof see:\n//     https://www.maths.lancs.ac.uk/jameson/siineqnotes.pdf\n//     https://math.stackexchange.com/questions/2879015/prove-that-int-0x-frac-sin-tt-dt-arctan-x-for-x0\n\n// NOTE: pi/2=1.5707963268...\n\n// Eabs<1.5e-2\n// Erel<2.7e-2\nfloat Si_atan(float x)\n{\n    x=clamp(x,-1e10,+1e10);\n    // NOTE: using a simpler weight of cos(x-x/(2+x^2)) yields Eabs ~1.7e-2.\n    return mix(sign(x)*1.5707963268,atan(x),cos(x-1.105832486*x/(2.166470873+x*x)));\n}\n\n// Ci/Cin versions of the above, less simple.\n// NOTE: pi/2-atan(x)=atan(1/x) is approximated by\n// 1/x, as |atan(1/x)-1/x|<5.1e-3 for |x|>4. Using\n// atan(1/x) improves Eabs to ~6.8e-3.\n\n// Eabs<9.3e-3\nfloat Ci_rcp(float x)\n{\n    float x2=x*x;\n    return x<4.0?0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.01041655488769817+\n        x2*( 0.00022988894178267946+\n        x2*(-2.6015522824519235e-06)))):\n        (x>1e10?0.0:sin(x-1.105832486*x/(2.166470873+x2))/x);\n}\n\n// Eabs<9.3e-3\n// Erel<4.0e-3\nfloat Cin_rcp(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    return x<4.0?\n        x2*( 0.25+\n        x2*(-0.01041655488769817+\n        x2*( 0.00022988894178267946+\n        x2*(-2.6015522824519235e-06)))):\n        0.57721566490153286+log(x)-(x>1e10?0.0:sin(x-1.105832486*x/(2.166470873+x2))/x);\n}\n\n//==============================================================================\n// Approximations based on the auxiliary functions above.\n// NOTE: approximations for |x|<4 may differ from those in\n// Abramowitz and Stegun.\n\n// Eabs<1.8e-4\n// Erel<1.1e-3\nfloat Si_v1(float x)\n{\n    if(abs(x)<1.0) return x*(0.999490755-x*x*0.053506832);\n    else if(abs(x)>1e4) return Si_asymp(x);\n    else return sign(x)*1.5707963268-fi4(x)*cos(x)-gi4(x)*sin(x);\n}\n\n// Eabs<1.9e-4\nfloat Ci_v1(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.010416665998427955+\n        x2*( 0.00023145206084389179+\n        x2*(-3.0754638542558933e-06+\n        x2*( 2.3540666047900717e-08)))));\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi4(x)*sin(x)-gi4(x)*cos(x);\n}\n\n// Eabs<1.9e-4\n// Erel=1 (<3.0e-4 for |x|>1e-17)\nfloat Cin_v1(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*( 0.25+\n        x2*(-0.010416665998427955+\n        x2*( 0.00023145206084389179+\n        x2*(-3.0754638542558933e-06+\n        x2*( 2.3540666047900717e-08)))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi4(x)*sin(x)-gi4(x)*cos(x));\n}\n\n// Eabs<9.4e-6\n// Erel<9.0e-6\n// Eulp<148.9\nfloat Si_v2(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x*(0.999996951+x2*(-0.055531133+x2*0.001617667));\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*(1.5707963268-fi6(y)*cos(y)-gi6(y)*sin(y));\n}\n\n// Eabs<8.9e-6\nfloat Ci_v2(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*(0.25+\n        x2*(-0.010416666665566218+\n        x2*( 0.00023148115790180699+\n        x2*(-3.0995911179634464e-06+\n        x2*( 2.7345266653265783e-08+\n        x2*(-1.506340081607385e-10))))));\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi6(x)*sin(x)-gi6(x)*cos(x);\n}\n\n// Eabs<9.1e-6\n// Erel=1 (1.7e-7 for |x|>1e-17)\n// Eulp<216.0\nfloat Cin_v2(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*(0.25+\n        x2*(-0.010416666665566218+\n        x2*( 0.00023148115790180699+\n        x2*(-3.0995911179634464e-06+\n        x2*( 2.7345266653265783e-08+\n        x2*(-1.506340081607385e-10))))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi6(x)*sin(x)-gi6(x)*cos(x));\n}\n\n// Eabs<7.9e-7\n// Erel<8.2e-7\n// Eulp<13.3\nfloat Si_v3(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x+x*x2*(-0.055555480+x2*(0.001666271+x2*-0.000027723));\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*(1.5707963268-fi8(y)*cos(y)-gi8(y)*sin(y));\n}\n\n// Eabs<5.3e-6\nfloat Ci_v3(float x)\n{\n    float x2=x*x;\n    if(x<4.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.01041666668062171+\n        x2*( 0.00023148153037431092+\n        x2*(-3.1002228983145375e-06+\n        x2*( 2.7558604375373243e-08+\n        x2*(-1.7332136767183762e-10+\n        x2*( 7.331836209074408e-13)))))));\n    else if(x>1e4) Ci_asymp(x);\n    else return fi8(x)*sin(x)-gi8(x)*cos(x);\n}\n\n// Eabs<5.3e-6\n// Erel=1 (<1.9e-6 for |x|>1e-17)\n// Eulp<27.3\nfloat Cin_v3(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<4.0) return\n        x2*( 0.25+\n        x2*(-0.01041666668062171+\n        x2*( 0.00023148153037431092+\n        x2*(-3.1002228983145375e-06+\n        x2*( 2.7558604375373243e-08+\n        x2*(-1.7332136767183762e-10+\n        x2*( 7.331836209074408e-13)))))));\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286f+log(x)-(fi8(x)*sin(x)-gi8(x)*cos(x));\n}\n\n//==============================================================================\n// What we will be using as a reference implementation.\n// Kind of lame, but it'll serve. Still, should be more accurate than Cephes.\n// Public domain.\n\nfloat fi_ref(float x)\n{\n    float x2=x*x;\n    return (1157.2813301581532\n        +x2*(918.37073823706487\n        +x2*72.91109984325341\n        +x2*x2))\n            /(x*(2136.431584513592\n        +x2*(1044.2655890141539\n        +x2*74.911060095355765\n        +x2*x2)));\n}\n\nfloat gi_ref(float x)\n{\n    float x2=x*x;\n    return (350.71198766665168\n        +x2*(52.53658071509102\n        +x2*0.99999424154191419))\n            /(677.48284555096393\n        +x2*(586.07925873667034\n        +x2*58.526231344858282\n        +x2*x2));\n}\n\n// Eabs<1.9e-7\n// Erel<1.3e-7\n// Eulp<1.6\nfloat Si_ref(float x)\n{\n    float y=abs(x),x2=x*x;\n    if(y<1.0) return x+x*x2*(-0.055555480+x2*(0.001666271+x2*-0.000027723));\n    else if(y<2.0) return x+x*(\n        x2*(-0.05555556134806966+\n        x2*( 0.00050737034650927932+\n        x2*(-5.0471110048495199e-06))))/(1.0+\n        x2*(0.020867419021527198+\n        x2*(0.00020663380200154814+\n        x2*1.0703429794815947e-06)));\n    else if(y<4.0)\n    {\n        float t=y-2.0;\n        return sign(x)*(1.605412976802699\n            +t*(+0.45464935792421\n            +t*(-0.21770668761788\n            +t*(-0.0031753140004621\n            +t*(+0.0098042389141398\n            +t*(-8.2411630085075919e-5\n            +t*(-2.7256837238253323e-4\n            +t*  2.2925266735283385e-5)))))));\n    }\n    else if(y>1e4) return Si_asymp(x);\n    else return sign(x)*1.5707963268-fi_ref(x)*cos(x)-gi_ref(x)*sin(x);\n}\n\nfloat Ci_ref(float x)\n{\n    float x2=x*x;\n    if(x<1.0) return 0.57721566490153286+log(x)-\n        x2*( 0.25+\n        x2*(-0.010416666651501689+\n        x2*( 0.00023147457042302654+\n        x2*(-3.0659183566839455e-06))));\n    else if(x<2.0)\n    {\n        float t=x-1.0;\n        return 0.3374039229+log(x)-\n            t*( 0.45969795522813789+\n            t*( 0.19088189878507705+\n            t*(-0.037177909249922987+\n            t*(-0.0072406378705534256+\n            t*( 0.0013455939055330316+\n            t*( 6.3373887776489737e-05))))));\n    }\n    else if(x<4.0)\n    {\n        float t=x-2.0;\n        return -0.27016635178+log(x)-\n            t*( 0.70807442478691229+\n            t*( 0.050294041743019074+\n            t*(-0.05139839828731807+\n            t*( 0.00025284978209454736+\n            t*( 0.0016943264375937806+\n            t*(-8.8289289884377998e-05+\n            t*(-1.2825398355628786e-05)))))));\n    }\n    else if(x>1e4) return Ci_asymp(x);\n    else return fi_ref(x)*sin(x)-gi_ref(x)*cos(x);\n}\n\n// Eabs<5.26e-6\n// Erel=1 (<1.68e-7 for |x|>1e-17)\n// Eulp<1.98\nfloat Cin_ref(float x)\n{\n    x=abs(x);\n    float x2=x*x;\n    if(x<1.0) return\n        x2*( 0.25+\n        x2*(-0.010416666651501689+\n        x2*( 0.00023147457042302654+\n        x2*(-3.0659183566839455e-06))));\n    else if(x<2.0)\n    {\n        float t=x-1.0;\n        return 0.23981174200056465+\n            t*( 0.45969795522813789+\n            t*( 0.19088189878507705+\n            t*(-0.037177909249922987+\n            t*(-0.0072406378705534256+\n            t*( 0.0013455939055330316+\n            t*( 6.3373887776489737e-05))))));\n    }\n    else if(x<4.0)\n    {\n        float t=x-2.0;\n        return 0.84738201668661306+\n            t*( 0.70807442478691229+\n            t*( 0.050294041743019074+\n            t*(-0.05139839828731807+\n            t*( 0.00025284978209454736+\n            t*( 0.0016943264375937806+\n            t*(-8.8289289884377998e-05+\n            t*(-1.2825398355628786e-05)))))));\n    }\n    else if(x>1e4) return 0.57721566490153286+log(x)-Ci_asymp(x);\n    else return 0.57721566490153286+log(x)-(fi_ref(x)*sin(x)-gi_ref(x)*cos(x));\n}\n\n//==============================================================================\n// Dispatcher.\n\nfloat f(int id,float x)\n{\n    switch(id)\n    {\n        case  0: return 0.0;\n\n        case  1: return Si_atan(x);\n\n        case  2: return Si_v1(x);\n        case  3: return Si_v2(x);\n        case  4: return Si_v3(x);\n#define T_SI 5\n        case  5: return Ci_rcp(x);\n        case  6: return Ci_v1(x);\n        case  7: return Ci_v2(x);\n        case  8: return Ci_v3(x);\n#define T_CI 9\n        case  9: return Cin_rcp(x);\n        case 10: return Cin_v1(x);\n        case 11: return Cin_v2(x);\n        case 12: return Cin_v3(x);\n#define NUM_FUNCTIONS 13\n    }\n    return 0.0;\n}\n\nfloat error(int id,float x,int rel)\n{\n    float y=f(id,x),z=(id<T_SI?Si_ref(x):(id<T_CI?Ci_ref(x):Cin_ref(x)));\n    return rel==0?y-z:(y-z)/z;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 R=iResolution.xy;\n    vec2 xy=fragCoord/R;\n    vec3 col=vec3(0.8,0.75,0.7);\n    int id=int(floor(abs(iMouse.z/R.x)*float(NUM_FUNCTIONS)));\n    int rel=(iMouse.z>=0.0?1:0);\n    if(id==0) id=int(iTime)%(NUM_FUNCTIONS-1)+1;\n    vec3 c=(id<T_SI?vec3(0.25,0.5,0.75):(id<T_CI?0.75*vec3(0.75,0.25,0.5):0.5*vec3(0.5,0.75,0.25)));\n    float lx=mix(-7.0,+2.0,xy.x),x=pow(10.0,lx);\n    float ly=mix(-7.0,-1.0,xy.y),y=pow(10.0,ly);\n    float t,p;\n    // Render grid.\n    t=fract(lx);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    t=fract(ly);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    col=mix(col,vec3(0.0,1.0,0.0),0.5*exp(-1e4*lx*lx));\n    // Function selector.\n    if(xy.y>1.0-14.0/R.y) col=mix(col,vec3(0.25)+0.5*mod(floor(xy.x*float(NUM_FUNCTIONS)),2.0),0.5);\n    // Render error plot.\n    col=mix(\n        col,\n        c,\n        0.75*smoothstep(\n            -0.02*y,\n            +0.02*y,\n            abs(error(id,x,rel))-y));\n    // Print the function id.\n    int font[]=int[](0x01C0,0x4000,0x7B6F,0x4924,0x73E7,0x79E7,0x49ED,0x79CF,0x7BCF,0x4927,0x7BEF,0x79EF);\n    uint ix=uint(int(floor(0.25*(fragCoord.x-16.0))));\n    uint iy=uint(int(floor(0.25*(fragCoord.y-iResolution.y*0.875))));\n    if(ix<3u&&iy<5u) {if((font[uint(id)/10u%10u+2u]>>((4u-iy)*3u+ix)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    if(ix>=4u&&ix<7u&&iy<5u) {if((font[uint(id)%10u+2u]>>((4u-iy)*3u+ix-4u)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVczG.jpg", "access": "api", "license": "public-domain", "functions": [[2909, 2959, 2979, 2979, 3073], [3075, 3123, 3143, 3143, 3280], [3282, 3343, 3363, 3363, 3536], [3538, 3623, 3643, 3643, 3740], [3742, 3827, 3847, 3847, 3988], [3990, 4074, 4094, 4094, 4271], [4394, 4429, 4454, 4454, 4562], [4564, 4601, 4626, 4626, 4696], [5162, 5192, 5216, 5216, 5408], [5598, 5613, 5636, 5636, 5894], [5896, 5926, 5950, 5950, 6222], [6449, 6479, 6501, 6501, 6672], [6674, 6689, 6711, 6711, 7034], [7036, 7085, 7108, 7108, 7473], [7475, 7519, 7541, 7541, 7748], [7750, 7765, 7787, 7787, 8146], [8148, 8210, 8233, 8233, 8634], [8636, 8679, 8701, 8701, 8914], [8916, 8931, 8953, 8953, 9343], [9345, 9407, 9430, 9430, 9870], [10106, 10106, 10129, 10129, 10376], [10378, 10378, 10401, 10401, 10631], [10633, 10675, 10698, 10698, 11533], [11535, 11535, 11558, 11558, 12545], [12547, 12611, 12635, 12635, 13662], [13761, 13761, 13786, 13786, 14333], [14335, 14335, 14372, 14372, 14479]], "test": "untested"}
{"id": "DlKyzG", "name": "shell grass", "author": "01000001", "description": "Watched acerola's video: [url]https://www.youtube.com/watch?v=9dr-tRQzij4[/url], thought it was pretty cool, made a rudimentary version here. Other methods of rendering grass to come soon...", "tags": ["grass", "acerolafurrychallenge"], "likes": 20, "viewed": 495, "published": 3, "date": "1700351275", "time_retrieved": "2024-07-30T17:21:52.553031", "image_code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 uv = U/r;\n    \n    O = texture(iChannel0, uv);\n    // O = pow(O, vec4(1./2.2));\n    // Looks bad, unnecessary cuz we don't even have any shading.\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35672, "src": "https://soundcloud.com/symphonicsamples/cornfield-chase-hans-zimmer-midi-mockup", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// #define move\n// Uncomment to enable motion\n\nint layers = 2<<5;\nconst float height = .5;\nconst float scale = 20.;\n\nconst float wiggle = 1.;\nconst float heightVariance = .3;\n\nconst vec3 healthy = vec3(0., heightVariance*.5+.2, .05);\nconst vec3 ded = vec3(.8, .75, .4);\n\n#ifdef move\nconst float ssaa = 3.;\n#else\nconst float ssaa = 1.;\n#endif\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec4 ray(vec3 o, vec3 dir, float z){\n    if (dir.z > 0.) return vec4(0);\n    float t = (o.z - z)/dir.z;\n    return vec4(o + dir * t, -t);\n}\n\nvec4 ray(vec3 o, vec3 dir){\n    return ray(o, dir, height);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    cuv += vec2(cos(fract(float(iTime))*123.), sin(fract(float(iTime))*457.))/r.y;\n    \n    vec2 muv = iMouse.x < 1. && iMouse.y < 1.? vec2(0, -.5) :(2.*iMouse.xy-r)/r.y * 2.;\n\n    O = texture(iChannel0, uv);\n\n    #ifdef move\n    vec3 o = vec3(0, -iTime, 1);\n    #else\n    vec3 o = vec3(0, 0, 1);\n    #endif\n    \n    vec3 camDir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    vec3 right = normalize(cross(camDir, vec3(0, 0, 1)));\n    vec3 up = cross(right, camDir);\n    \n    vec3 dir = normalize(vec3(cuv.x, 1, cuv.y));\n    dir = camDir + right * cuv.x + up * cuv.y;\n\n    vec3 pos, m, n, col = vec3(0);\n    for (float s = 0.; s < ssaa; s++){\n        for (float i = 1.; i > 0.; i -= 1./float(layers)){\n\n            m = hash(uvec3(U + s, iTime*1000.));\n            vec4 r = ray(o, dir, i * height + m.x/float(layers));\n            pos = r.xyz;\n            float t = r.w;\n\n            if (pos == vec3(0)){\n                // Sky\n                col = (vec3(exp(-dir.z), exp(-dir.z*.5), .5 * exp(dir.z)));\n                break;\n            }\n\n\n            n = hash(uvec3(mod(vec3(pos.xy + s, 1.) * scale, vec3(2<<7))));\n            // Mod can be replaced with abs at the cost of grass symmetric around the axes\n            // Abs causes mirroring, mod causes tiling\n            // better suggestions welcome.\n\n            vec2 cellCoord = fract(pos.xy * scale) * 2. - 1. // Gives us the coordinates inside the current cell\n               + n.yz*2.-1. // offsets the coordinate centre for off grid grass. Just comment this line to see the difference.\n               + (n.xz*2.-1.)*sin(i*5./wiggle + n.y * 179.) * wiggle // and then we offset based on height so make 'em wiggly\n            ; // This is put here so you can comment the above line without erroring\n\n\n            if (length(cellCoord) < mix(1., n.x, heightVariance)-i){\n                col = mix(col, vec3(mix(healthy, ded, n.x)) * i, 1./(s+1.));\n                break;\n            }\n\n        }\n    }\n    \n    if (iFrame < 20){\n        O = vec4(col, 1.);\n    } else {\n        \n        #ifdef move\n        O.a = 3.;\n        #else\n        O.a = mix(O.a + 1., 1., iMouse.z > 0.?1.:0.);\n        #endif\n        \n        O.xyz = mix(O.xyz, col, 1./O.a);\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 253]], "test": "untested"}
{"id": "dtGcRy", "name": "hexagonal tetrahedron slides", "author": "cyperus", "description": "truchet3d toroidal  hexagonal tiled spherical tetrahedron slides", "tags": ["3d", "grid", "sdf", "tetrahedron", "tiling", "schwarzchristoffel"], "likes": 14, "viewed": 245, "published": 3, "date": "1700341863", "time_retrieved": "2024-07-30T17:21:53.515458", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"hexagonal tetrahedron slides\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//\n// References & Inspiration:\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n// - conformal mapping with confmap.m by Trefethen\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//\n// - signed distance functions & operations by iq\n//   https://iquilezles.org/articles/distfunctions/\n//\n// - quick guide for shadertoy by FabriceNeyret2\n//   https://shadertoyunofficial.wordpress.com/\n// \n// - hexagonal grid by Amit Patel\n//   https://www.redblobgames.com/grids/hexagons/\n//\n//\n// Known Issues:\n//\n// - Artefacts at singularities while raymarching space.\n//   In this case line singularities along the \"truchet net tubes\".\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 5.; \nconst float CAM_FLE  = 2.;\nconst float BB_DIST  = 5.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 310;\nconst float RAY_STEP_FACTOR = 0.06686;\nconst float RAY_PRECISION = 3.;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float rnd = 0.5; float dc = 1.; float d = -1.;\n\n    /// platonic sphere\n    // normalize spherical radius\n    vec3 pn = normalize(p);\n\n    // spherical projection from n cell to 1 cell.\n    float ps_id = 0., sr = 0.;\n    pn = tetra_cells(pn, ps_id, sr); \n\n    // inverse stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cTeraPolyArc2disk(z);\n\n    // r-polygon-distribution\n    float e = 0.4 + 0.1 *cos(3.*atan(z.y, z.x));\n    float en = 1.- e*smoothstep(1.,5., abs(12.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;     \n\n    // stereograpic projection\n    float zz = dot(z,z); pn = vec3(2.*z.x,  2.*z.y, -1.+zz); pn /= 1.+zz;\n\n    // unnormalize spherical radius\n    p = length(p) * pn;\n\n    /// regular polygon tiles\n    vec3 rpt_id = vec3(1.);  float rpt_sr;\n    p.xy = inversesc(hexgrid2hex(p.xy, rpt_id),6);\n\n    /// cylinder radial plane -> halfcomplex plane\n    rxy = length(p.xy); au = atan(p.y, p.x);\n    z = ccos(PI*vec2(rxy,p.z))/0.5; z.x -= -1.28;   \n        \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // ruv \n    z = p.yz;   \n\n    /// truchet 3D\n    const float TC3D_nu = 18.;\n    const float TC3D_nv = 8.;\n    const float TC3D_nr = 1.;\n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz;\n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.);\n    ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // random\n    rnd = hash21(tc_id.xz);\n\n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n\n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );}\n    else\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n\n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n   \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;\n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ) {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = rd*.2+.8;\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // texture\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( 3.*6.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2);\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-8.E-3 * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float \n    PI = abs(atan(0.,-1.));\n\n// helpers\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5);\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5);\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );\n    return (pp+pn);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);}\n\n// schwarzchristoffel\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n} // beta function\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\n// hexagonal grid\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id){\n    const float PI_6 = PI/6.;\n    const float SQRT3 = sqrt(3.);\n    const float SQRT_3 = 1./SQRT3;\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI_6);\t// B:orientation-offset of cell  \n}\n\n// regular circular arc triangle -> unitcircle conformal mapping by using a barycentric approximation\nvec2 cTeraPolyArc2disk(vec2 z) {\n    const int NUM_j = 15;\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264°\n    const float a30 = PI/6.;             // 30°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45°\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGcRy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1457, 1457, 1479, 1479, 3820], [3822, 3835, 3889, 3889, 4497], [4499, 4499, 4544, 4544, 4706], [4708, 4708, 4750, 4750, 5001], [5003, 5015, 5058, 5058, 5249], [5251, 5251, 5308, 5308, 5386], [5388, 5396, 5443, 5482, 8170]], "test": "untested"}
{"id": "dlGyDw", "name": "Year of Truchets #060", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! ", "tags": ["3d", "raymarching", "truchet", "tile"], "likes": 25, "viewed": 259, "published": 3, "date": "1700334059", "time_retrieved": "2024-07-30T17:21:54.277421", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #060\n    11/18/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n\n    truchet pattern https://www.shadertoy.com/view/ddXyzH\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nmat2 r45,r1,r2;\nvec3 hit,hitPoint;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.323); }\nfloat box(vec3 p, vec3 b) {vec3 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\n\n//@iq extrude & twist\nfloat opx(in float d, in float p, in float h){\n    vec2 w = vec2(d,abs(p)-h);\n  \treturn min(max(w.x, w.y),0.)+length(max(w,0.));\n}\nvec3 twist( in vec3 p ){\n    float cx = .015+.01*sin(T*.08);\n    return vec3(rot(cx*p.z)*p.xy,p.z)/1.5;\n}\n\nfloat tile(vec2 uv, float wd) {\n\n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id.xy);\n\n    if(hs>.5)  q.xy *= rot(1.5707);\n    hs = fract(hs*75.32);\n    \n    float pf = .353;\n    vec2 q2 = q; q*=r45;\n    \n    vec2 p2 = vec2(length(q.x+pf),length(q.x-pf));\n    float pq = p2.x<p2.y? q.x+pf : q.x-pf;\n\n    // main pattern\n    float d = abs(length(pq))-wd;\n\n    // alt pattern\n    if(hs>.85) {\n        d = min(length(q2.x),length(q2.y))-(wd*1.4);\n        float xd = length(abs(q2.x)-(wd*1.65))-(wd*.25);\n        d = max(d,-xd);\n    }\n    \n    return d;\n}\n\nvec2 map(vec3 pos){\n\n    vec2 res = vec2(1e5,0);\n\n    vec3 xpo = pos;\n    xpo.z += 12.+5.*sin(T*.1);\n    xpo.yz*=r1;\n    xpo.xz*=r2;\n    \n    float bx = box(xpo,vec3(1.5))-.05;\n    if(bx<res.x) {\n        res = vec2(bx,4.);\n        hit = xpo;\n    }\n    \n    pos = twist(pos);\n    pos.z -= T;\n\n    float k = tile(pos.yz*.75,.15+.1*sin(pos.z*.2));\n    float b = opx(k,abs(pos.x)-8.,1.5)-.02;\n\n    if(b<res.x) {\n        res = vec2(b,2.);\n        hit = pos;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd){\n\tfloat d = 0.,m = 0.;\n    for(int i=0;i<100;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.3:ray.x*.8;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec2 getHit(vec3 n) {\n        //@Shane https://www.shadertoy.com/view/3sVBDd\n        //finding the face of a cube using normal\n        vec3 aN = abs(n);\n        ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n        int face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n        \n        vec2 hpp;\n        if(face==0) hpp = hitPoint.zy;\n        if(face==1) hpp = hitPoint.zx;\n        if(face==2) hpp = hitPoint.xy;\n        if(face==3) hpp = hitPoint.xy;\n        if(face==4) hpp = hitPoint.zx;\n        if(face==5) hpp = hitPoint.yz;\n        return hpp;\n}\n\nvec3 fog = vec3(.11,.09,.08);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv, float bnc) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m = ray.y;\n    d = ray.x;\n    hitPoint = hit;\n\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d,\n             n = normal(p,d);\n             \n        vec3 lpos =vec3(-1.,-2,5.),\n             l = normalize(lpos-p),\n             h = vec3(.5);\n        \n        float shdw = 1.,\n              diff = clamp(dot(n,l),0.,1.);\n              \n        for( float t=.1; t < 8.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>8. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 tn = n;\n        vec2 hpp = getHit(tn);\n\n        if(m==2.) {\n              h = texture(iChannel1,hpp*.5).rgb;\n            ref = h*.5;\n        }\n\n        tn = n;\n        tn.yz*=r1;\n        tn.xz*=r2;\n        hpp = getHit(tn);\n\n        if(m==4.) {\n              h = texture(iChannel2,hpp*.25).rgb;\n            ref = vec3(.5);\n        }\n        \n        C = diff * h;\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    } \n\n    if(bnc>0.) C = mix(C,fog,1.-exp(-.000008*d*d*d));\n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r45 = rot(.7853981634);\n    r1 = rot(T*.05);\n    r2 = rot(T*.1);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    //camera\n    float x = M.xy==vec2(0) || M.z<0. ? .0 : -(M.y / R.y * .2 - .1) * PI;\n    float y = M.xy==vec2(0) || M.z<0. ? .0 :  (M.x / R.x * .2 - .1) * PI;\n    mat2 rx = rot(x), ry = rot(y);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(1);\n    \n    float d =0., a = 0., bnc = 2.;\n    for(float i=0.; i<bnc; i++) {\n        vec3 pass = render(ro, rd, ref, d, uv, bnc);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = exp(-.00001*d*d*d);\n    }\n    \n    C = mix(C,fog,1.-a);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35261, "src": "https://soundcloud.com/dom-in-ator/carbon-based-lifeforms-proton", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGyDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[528, 528, 546, 546, 591], [592, 592, 613, 613, 668], [669, 669, 696, 696, 776], [778, 800, 846, 846, 930], [931, 931, 955, 955, 1036], [1038, 1038, 1069, 1069, 1609], [1611, 1611, 1630, 1630, 2088], [2090, 2090, 2120, 2120, 2359], [2361, 2361, 2392, 2392, 2608], [2610, 2610, 2631, 2736, 3183], [3215, 3215, 3309, 3309, 4508], [4510, 4510, 4551, 4551, 5383]], "test": "untested"}
{"id": "Dtyyzy", "name": "Camera Controller", "author": "GabeRundlett", "description": "Made to play with rotations and projections. Rotors?", "tags": ["sdf", "nearest", "far", "furthest", "near"], "likes": 3, "viewed": 198, "published": 3, "date": "1700330042", "time_retrieved": "2024-07-30T17:21:55.275751", "image_code": "\nstruct InterInfo {\n    float dist;\n    vec3 nrm;\n};\n\nstruct HitInfo {\n    float material_id;\n    InterInfo i;\n    RigidTransform object_trn;\n};\n\nInterInfo ray_object_intersection(in vec3 ro, in vec3 rd, in vec3 rad) {\n    // ray-box intersection in box space\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    // no intersection\n    if (tN > tF || tF < 0.0) {\n        return InterInfo(-1.0, vec3(-1.0));\n    }\n\n    return InterInfo(tN, -sign(rd) * step(tN, t1));\n}\n\nInterInfo ray_object_intersection(vec3 ray_pos, vec3 ray_dir) {\n    return InterInfo(-ray_pos.z / ray_dir.z, vec3(0, 0, 1));\n}\n\nHitInfo trace_scene(vec3 ray_pos, vec3 ray_dir) {\n    HitInfo result;\n    result.material_id = 0.0;\n    result.i.dist = 1.0e9;\n    result.i.nrm = vec3(-1.0);\n\n    {\n        vec3 object_pos = vec3(0.0, 0.0, -0.1);\n        vec3 box_size = vec3(4.0, 4.0, 0.1);\n        RigidTransform object_trn;\n        object_trn.translation = object_pos;\n        object_trn.orientation = from_to_rotor(vec3(1, 0, 0), vec3(1, 0, 0));\n        vec3 object_ray_d = transform(reverse(object_trn.orientation), ray_dir);\n        vec3 object_ray_o = transform(reverse(object_trn.orientation), ray_pos - object_trn.translation);\n        InterInfo object_int = ray_object_intersection(object_ray_o, object_ray_d, box_size);\n        if (object_int.dist > 0.0 && object_int.dist < result.i.dist) {\n            object_int.nrm = transform(object_trn.orientation, object_int.nrm);\n            result.i = object_int;\n            result.material_id = 1.0;\n            result.object_trn = object_trn;\n        }\n    }\n\n    {\n        vec3 object_pos = vec3(0.0, 2, 0.35);\n        vec3 box_size = vec3(0.25);\n        vec3 object_up = vec3(cos(iTime), -sin(iTime), 0.0);\n        RigidTransform object_trn;\n        object_trn.translation = object_pos;\n        object_trn.orientation = from_to_rotor(vec3(1, 0, 0), object_up);\n        vec3 object_ray_d = transform(reverse(object_trn.orientation), ray_dir);\n        vec3 object_ray_o = transform(reverse(object_trn.orientation), ray_pos - object_trn.translation);\n        InterInfo object_int = ray_object_intersection(object_ray_o, object_ray_d, box_size);\n        if (object_int.dist > 0.0 && object_int.dist < result.i.dist) {\n            object_int.nrm = transform(object_trn.orientation, object_int.nrm);\n            result.i = object_int;\n            result.material_id = 2.0;\n            result.object_trn = object_trn;\n        }\n    }\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 image_size = vec4(iResolution.xy, vec2(1.0) / iResolution.xy);\n    // invert Y because OpenGL is silly\n    vec2 pixel_pos = vec2(fragCoord.x, image_size.y - 1.0 - fragCoord.y);\n\n    Player player = load_player(iChannel0);\n    Camera cam = player_get_camera(player, image_size);\n\n    vec2 uv = get_uv(pixel_pos, image_size);\n    ViewRayContext vrc = vrc_from_uv(cam, uv);\n\n    vec3 ray_pos = ray_origin_ws(vrc);\n    vec3 ray_dir = ray_dir_ws(vrc);\n\n    HitInfo scene_hit = trace_scene(ray_pos, ray_dir);\n    vec3 hit_pos = ray_pos + ray_dir * scene_hit.i.dist;\n\n    const vec3 SUN_COL = vec3(1.0, 0.95, 0.60);\n    const vec3 SKY_COL = vec3(0.4, 0.5, 0.9);\n\n    vec3 sun_dir = normalize(vec3(1, -1.5, 3));\n    HitInfo shadow_hit = trace_scene(hit_pos + scene_hit.i.nrm * 0.001, sun_dir);\n\n    vec3 diffuse = vec3(shadow_hit.material_id == 0.0) * max(0.0, dot(sun_dir, scene_hit.i.nrm)) * SUN_COL;\n    diffuse += SKY_COL * (dot(vec3(0, 0, 1), scene_hit.i.nrm) * 0.4 + 0.6);\n\n    fragColor = vec4(1.0);\n    if (scene_hit.material_id == 0.0) {\n        fragColor = vec4(SKY_COL, 1.0);\n    } else if (scene_hit.material_id == 1.0) {\n        vec3 object_hit_pos = transform(reverse(scene_hit.object_trn.orientation), hit_pos - scene_hit.object_trn.translation - scene_hit.i.nrm * 0.001);\n        ivec3 tile = ivec3(floor(object_hit_pos));\n        bool tile_mask = (tile.x & 1) == (tile.y & 1);\n        fragColor = vec4(tile_mask ? vec3(0.3) : vec3(0.4), 1.0);\n        fragColor.rgb *= diffuse;\n    } else if (scene_hit.material_id == 2.0) {\n        vec3 object_hit_pos = transform(reverse(scene_hit.object_trn.orientation), hit_pos - scene_hit.object_trn.translation - scene_hit.i.nrm * 0.001);\n        ivec3 tile = ivec3(floor(object_hit_pos * 8.0));\n        bool tile_mask = ((tile.x + tile.y + tile.z) & 1) == 1;\n        fragColor = vec4(0.8 - 0.8 * fract(object_hit_pos) + float(tile_mask) * 0.1, 1.0);\n        fragColor.rgb *= diffuse;\n    }\n\n    // if (1) {\n    //     // KEYBOARD DEBUG\n    //     int key_id = int(floor(fragCoord.x / 4.0));\n    //     if (fragCoord.y > 10.0 && fragCoord.y < 20.0) {\n    //         fragColor.r = texelFetch(iChannel1, ivec2(key_id, 0), 0).x;\n    //     } else if (fragCoord.y < 10.0) {\n    //         fragColor.g += float((key_id % 8) == 0) * 0.1;\n    //         fragColor.g += float((key_id % 16) == 0) * 0.1;\n    //         fragColor.g += float((key_id % 32) == 0) * 0.5;\n    //     }\n    // }\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MOUSE_SENSITIVITY = 0.01;                  // radians per pixel\nconst float WALK_SPEED = 1.0;                          // units (meters) per second\nconst float SPRINT_SPEED = 4.0;                        // units (meters) per second\nconst float VERTICAL_FOV = 75.0;                       // degrees\nconst float VERTICAL_FOV_ZOOM = 20.0;                  // degrees\nconst float VERTICAL_FOV_ZOOM_ANIMATION_SPEED = 500.0; // degrees per second\n\nconst int KEY_MOVE_FORWARD = 87;  // W\nconst int KEY_MOVE_BACKWARD = 83; // S\nconst int KEY_MOVE_LEFT = 65;     // A\nconst int KEY_MOVE_RIGHT = 68;    // D\nconst int KEY_MOVE_UP = 32;       // SPACE\nconst int KEY_MOVE_DOWN = 17;     // CTRL\nconst int KEY_MOVE_SPRINT = 16;   // SHIFT\nconst int KEY_ZOOM = 70;          // F\n\nconst float PI = 3.14159265;\n\nstruct Rotor3d {\n    float scalar;\n    float xy;\n    float yz;\n    float zx;\n};\nstruct RigidTransform {\n    vec3 translation;\n    Rotor3d orientation;\n};\n\nRotor3d from_to_rotor(vec3 from_dir, vec3 to_dir) {\n    from_dir = normalize(from_dir);\n    to_dir = normalize(to_dir);\n    // Calculations below assume the input directions are normalised\n    vec3 halfway = normalize(from_dir + to_dir);\n    vec3 wedge = vec3(\n        (halfway.x * from_dir.y) - (halfway.y * from_dir.x),\n        (halfway.y * from_dir.z) - (halfway.z * from_dir.y),\n        (halfway.z * from_dir.x) - (halfway.x * from_dir.z));\n    Rotor3d result;\n    result.scalar = dot(from_dir, halfway);\n    result.xy = wedge.x;\n    result.yz = wedge.y;\n    result.zx = wedge.z;\n    return result;\n}\nRotor3d reverse(Rotor3d r) {\n    Rotor3d result;\n    result.scalar = r.scalar,\n    result.xy = -r.xy;\n    result.yz = -r.yz;\n    result.zx = -r.zx;\n    return result;\n}\nvec3 transform(Rotor3d r, vec3 v) {\n    // Assume r is formed by the multiplication of two unit vectors.\n    // Then S = Rv, result = SR^{-1} where R^{-1} is just R with the bivector coefficients negated\n    float S_x = r.scalar * v.x + r.xy * v.y - r.zx * v.z;\n    float S_y = r.scalar * v.y - r.xy * v.x + r.yz * v.z;\n    float S_z = r.scalar * v.z - r.yz * v.y + r.zx * v.x;\n    float S_xyz = r.xy * v.z + r.yz * v.x + r.zx * v.y;\n\n    vec3 result;\n    result.x = S_x * r.scalar + S_y * r.xy + S_xyz * r.yz - S_z * r.zx;\n    result.y = S_y * r.scalar - S_x * r.xy + S_z * r.yz + S_xyz * r.zx;\n    result.z = S_z * r.scalar + S_xyz * r.xy - S_y * r.yz + S_x * r.zx;\n    return result;\n}\n\nstruct Player {\n    vec3 pos;\n    vec4 rot;\n\n    float near;\n    float fov;\n    vec2 mouse_state;\n};\n\nstruct Camera {\n    mat4 view_to_clip;\n    mat4 clip_to_view;\n    mat4 world_to_view;\n    mat4 view_to_world;\n};\n\nstruct ViewRayContext {\n    vec4 ray_dir_cs;\n    vec4 ray_dir_vs_h;\n    vec4 ray_dir_ws_h;\n    vec4 ray_origin_cs;\n    vec4 ray_origin_vs_h;\n    vec4 ray_origin_ws_h;\n};\n\nvoid player_init(inout Player self) {\n    self.pos = vec3(0.0, 0.0, 1.0);\n    self.rot = vec4(0.0, 1.5, 0.0, 0.0);\n    self.near = 0.01;\n    self.fov = VERTICAL_FOV;\n    self.mouse_state = vec2(-1.0);\n}\n\nvoid player_update(inout Player self, float dt, vec4 mouse_pos, sampler2D keyboard_image) {\n    vec2 mouse_delta = vec2(0.0);\n    if (self.mouse_state.x > 0.0) {\n        mouse_delta = mouse_pos.xy - self.mouse_state;\n    }\n    if (mouse_pos.z > 0.0) {\n        self.mouse_state = mouse_pos.xy;\n    } else {\n        self.mouse_state = vec2(-1.0);\n    }\n\n    self.rot.x += mouse_delta.x * MOUSE_SENSITIVITY;\n    self.rot.y += mouse_delta.y * MOUSE_SENSITIVITY;\n\n    self.rot.y = clamp(self.rot.y, 0.0, PI);\n\n    vec3 forward = vec3(sin(self.rot.x), cos(self.rot.x), 0.0);\n    vec3 right = vec3(forward.yx * vec2(1.0, -1.0), 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n\n#define LOAD_KEY(KEY) texelFetch(keyboard_image, ivec2(KEY, 0), 0).x > 0.0\n\n    float speed = WALK_SPEED;\n    if (LOAD_KEY(KEY_MOVE_SPRINT)) {\n        speed = SPRINT_SPEED;\n    }\n\n    if (LOAD_KEY(KEY_MOVE_FORWARD)) {\n        self.pos += forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_BACKWARD)) {\n        self.pos -= forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_LEFT)) {\n        self.pos -= right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_RIGHT)) {\n        self.pos += right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_UP)) {\n        self.pos += up * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_DOWN)) {\n        self.pos -= up * speed * dt;\n    }\n\n    if (LOAD_KEY(KEY_ZOOM)) {\n        self.fov = clamp(self.fov - dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    } else {\n        self.fov = clamp(self.fov + dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    }\n\n#undef LOAD_KEY\n}\n\nmat4 rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(pitch), cos_rot_x = cos(pitch);\n    float sin_rot_y = sin(roll), cos_rot_y = cos(roll);\n    float sin_rot_z = sin(yaw), cos_rot_z = cos(yaw);\n    return mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 inv_rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(-pitch), cos_rot_x = cos(-pitch);\n    float sin_rot_y = sin(-roll), cos_rot_y = cos(-roll);\n    float sin_rot_z = sin(-yaw), cos_rot_z = cos(-yaw);\n    return mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 translation_matrix(vec3 pos) {\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        pos, 1);\n}\n\nCamera player_get_camera(Player self, vec4 tex_size) {\n    Camera result;\n\n    float aspect = tex_size.x * tex_size.w;\n    float tan_half_fov = tan(self.fov * PI / 180.0 * 0.5);\n\n    result.view_to_clip = mat4(0.0);\n    result.view_to_clip[0][0] = +1.0 / tan_half_fov / aspect;\n    result.view_to_clip[1][1] = +1.0 / tan_half_fov;\n    result.view_to_clip[2][2] = +0.0;\n    result.view_to_clip[2][3] = -1.0;\n    result.view_to_clip[3][2] = self.near;\n\n    result.clip_to_view = mat4(0.0);\n    result.clip_to_view[0][0] = tan_half_fov * aspect;\n    result.clip_to_view[1][1] = tan_half_fov;\n    result.clip_to_view[2][2] = +0.0;\n    result.clip_to_view[2][3] = +1.0 / self.near;\n    result.clip_to_view[3][2] = -1.0;\n\n    result.view_to_world = translation_matrix(self.pos) * rotation_matrix(self.rot.x, self.rot.y, self.rot.z);\n    result.world_to_view = inv_rotation_matrix(self.rot.x, self.rot.y, self.rot.z) * translation_matrix(-self.pos);\n\n    return result;\n}\n\nvec2 get_uv(vec2 pix, vec4 tex_size) { return (floor(pix) + 0.5) * tex_size.zw; }\nvec2 cs_to_uv(vec2 cs) { return cs * vec2(0.5, -0.5) + vec2(0.5, 0.5); }\nvec2 uv_to_cs(vec2 uv) { return (uv - 0.5) * vec2(2.0, -2.0); }\n\nViewRayContext vrc_from_uv(Camera cam, vec2 uv) {\n    ViewRayContext res;\n\n    res.ray_dir_cs = vec4(uv_to_cs(uv), 0.0, 1.0);\n    res.ray_dir_vs_h = cam.clip_to_view * res.ray_dir_cs;\n    res.ray_dir_ws_h = cam.view_to_world * res.ray_dir_vs_h;\n    res.ray_origin_cs = vec4(uv_to_cs(uv), 1.0, 1.0);\n    res.ray_origin_vs_h = cam.clip_to_view * res.ray_origin_cs;\n    res.ray_origin_ws_h = cam.view_to_world * res.ray_origin_vs_h;\n\n    return res;\n}\n\nvec3 ray_dir_vs(in ViewRayContext vrc) { return normalize(vrc.ray_dir_vs_h.xyz); }\nvec3 ray_dir_ws(in ViewRayContext vrc) { return normalize(vrc.ray_dir_ws_h.xyz); }\nvec3 ray_origin_vs(in ViewRayContext vrc) { return vrc.ray_origin_vs_h.xyz / vrc.ray_origin_vs_h.w; }\nvec3 ray_origin_ws(in ViewRayContext vrc) { return vrc.ray_origin_ws_h.xyz / vrc.ray_origin_ws_h.w; }\n\n// ShaderToy-specific code\n\nPlayer load_player(sampler2D player_image) {\n    Player result;\n    result.pos = texelFetch(player_image, ivec2(0, 0), 0).xyz;\n    result.rot = texelFetch(player_image, ivec2(1, 0), 0);\n    vec4 nf = texelFetch(player_image, ivec2(2, 0), 0);\n    result.mouse_state = texelFetch(player_image, ivec2(3, 0), 0).xy;\n    result.near = nf.x;\n    result.fov = nf.y;\n    return result;\n}\n\nvoid save_player(Player self, out vec4 fragColor, vec2 fragCoord) {\n    ivec2 pixel_i = ivec2(fragCoord);\n    if (pixel_i.y == 0 && pixel_i.x <= 4) {\n        switch (pixel_i.x) {\n        case 0:\n            fragColor = vec4(self.pos, 0.0);\n            break;\n        case 1:\n            fragColor = self.rot;\n            break;\n        case 2:\n            fragColor = vec4(self.near, self.fov, 0.0, 0.0);\n            break;\n        case 3:\n            fragColor = vec4(self.mouse_state, 0.0, 0.0);\n            break;\n        }\n    }\n}\n", "buffer_a_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Player player = load_player(iChannel0);\n    \n    if (iFrame == 0) {\n        player_init(player);\n    } else {\n        player_update(player, iTimeDelta, iMouse, iChannel1);\n    }\n    \n    // This buffer isn't wasted for another use, it just stores the player state in a few pixels.\n    // So basically, it's only necessary that you call `save_player` last in this function to ensure\n    // the player state is saved in the necessary pixels.\n    \n    save_player(player, fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtyyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 218, 259, 620], [622, 622, 685, 685, 748], [750, 750, 799, 799, 2623], [2625, 2625, 2680, 2680, 5119]], "test": "untested"}
{"id": "mtKyDw", "name": "flat tex glass pasting", "author": "chenxianming", "description": "design this tex using around reps and symbol wires overlay\ninteresting design ticks", "tags": ["2d", "cineshader", "texturedesign"], "likes": 10, "viewed": 570, "published": 3, "date": "1700327978", "time_retrieved": "2024-07-30T17:21:56.189309", "image_code": "#define S smoothstep\n#define I iResolution\n#define PI 3.1415\n#define TAU PI * 2.\n#define atl( a ) dot( a, a )\n#define rot( a ) mat2( cos(a), sin(a), -sin(a), cos(a) )\n// IQ\nfloat rep(inout vec2 p, float rep) \n{\n\n    float an = TAU/rep;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    \n    p *= rot(sym);\n\n    return ia;\n}\n\nfloat Sy1( vec2 u ){\n    float t = iTime * .05;\n    t += .05 * sin( atan( u.x, u.y ) * 7. );\n    return abs( fract( ( max( abs(u.x)-t, abs(u.y)-t ) ) * 7. ) - .5 );\n}\n\nfloat Sy2( vec2 u ){\n    \n    return abs( max(\n        length(u*vec2(.5,1.)+vec2(-.43, 0.) ) - .01,\n        length(u*vec2(.5,1.)+vec2(.43, 0.) ) - .01 ) - .5 );\n}\n\nfloat Sy3( vec2 u ){\n    vec2 u2 = u;\n    \n    rep( u, 6. );\n    u.x -= .1;\n    \n    rep( u, 3. );\n    u.x -= .07;\n    \n    return min(\n        Sy2(u2),\n        abs(\n            ( length( u ) - .01 ) - .05\n        )\n    );\n}\n\nfloat Sy4( vec2 u ){\n    vec2 u2 = u;\n    \n    rep( u, 6. );\n    u.x -= .1;\n    \n    rep( u, 2. );\n    u.x -= .05;\n    \n    return min(\n        Sy3(u2),\n        abs(\n            max(\n               abs(u.x)-.01,\n               abs(u.y)-.01\n            )\n         - .02)\n    );\n}\n\nfloat Sy5( vec2 u ){\n    u *= rot( iTime * -.05 );\n    rep( u, 7. );\n    u.x -= .8;\n\n    rep(u,4.);\n    u.x -= .3;\n    \n    u *= rot( PI * .5 );\n    return Sy4( u );\n}\n\nfloat SyA( vec2 u ){\n    return abs( \n        max(\n            abs(u.x) - .05 * ( abs(u.y+.5) -.1 ),\n            abs( u.y ) - .15\n        ) - .01\n    );\n}\n\nfloat SyAB( vec2 u ){\n    u *= rot( iTime * -.25 );\n    u *= rot( radians( 25. ) );\n    rep( u, 7. );\n    u.x -= .01;\n    u *= rot( PI * -.5 );\n    return SyA( u );\n}\n\nfloat SyAC( vec2 u ){\n    u *= rot( radians( 25. ) );\n    float i = rep( u, 7. );\n    u.x -= 1.3;\n    u *= rot( iTime * ((mod( i, 2. ) == 0.) ? -.25 : .25) );\n    rep( u, 25. );\n    u.x -= .4;\n    u *= rot( PI * -.5 );\n    return SyA( u );\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float A = min( I.x, I.y ), p;\n    vec2 u = ( V * 2. - I.xy ) / A;\n\n    // Time varying pixel color\n    vec3 c = vec3( 0.47, 0.51, 0.52 );\n    \n    p = Sy1( u );\n\n    c = mix(\n        c,\n        vec3( 0.47, 0.51, 0.52 ) * 1.2,\n        // Neyret2\n        atl( smoothstep( 30./A, 0.0, p ) ) * step( .07, length(u) )\n    );\n    \n    p = Sy5( u );\n\n    c = mix(\n        c,\n        vec3( 0.47, 0.51, 0.52 ) * 1.5,\n        atl( smoothstep( 4./A, 0.0, p ) )\n    );\n    \n    p = SyAB( u );\n\n    c = mix(\n        c,\n        vec3( 0.47, 0.51, 0.52 ) * 1.9,\n        atl( smoothstep( 4./A, 0.0, p ) )\n    );\n    \n    p = SyAC( u );\n\n    c = mix(\n        c,\n        vec3( 0.47, 0.51, 0.52 ) * 1.9,\n        atl( smoothstep( 4./A, 0.0, p ) )\n    );\n    \n    p = abs(\n        ( length( u ) - .01 ) - .04\n    );\n    \n    c = mix(\n        c,\n        vec3( 0.47, 0.51, 0.52 ) * 1.9,\n        atl( smoothstep( 4./A, 0.0, p ) )\n    );\n\n      \n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 173, 210, 210, 380], [382, 382, 402, 402, 548], [550, 550, 570, 570, 712], [714, 714, 734, 734, 938], [940, 940, 960, 960, 1218], [1220, 1220, 1240, 1240, 1387], [1389, 1389, 1409, 1409, 1543], [1545, 1545, 1566, 1566, 1711], [1713, 1713, 1734, 1734, 1954], [1956, 1956, 1997, 2047, 3018]], "test": "untested"}
{"id": "dlVyWm", "name": "[WIP] Shell Texturing (furball)", "author": "Falken", "description": "Implementation of Shell Texturing using a SDF, with technique described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\nNOTE: still a WIP!", "tags": ["fuzzy", "shell", "acerolafurrychallenge"], "likes": 8, "viewed": 338, "published": 3, "date": "1700317435", "time_retrieved": "2024-07-30T17:21:57.065965", "image_code": "// an implementation of Shell Texturing, as described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\n// coded by Michael Tedder (@_falken / brs^bas)\n//\n// (note: still a work in progress)\n// grass version is here: https://www.shadertoy.com/view/DsyBWd\n//\n// hat tips to:\n// 1. sdf/lighting: https://www.shadertoy.com/view/stcGRX\n// 2. noise: https://www.shadertoy.com/view/4dS3Wd\n\n// feel free to tweak any of these values below:\nconst int kSubsampleFactor = 1;         // sampling quality, any positive integer > 0\nconst int kNumberOfLayers = 48;         // number of shell layers, any positive integer > 0\nconst float kShellDensity = 100.0;      // detail of points in each layer, any positive value > 0\nconst float kShellLayerSpacing = 0.15;  // spacing between each layer, any positive value > 0\nconst int kNoiseOctaves = 5;            // number of iterations for noise function, any positive integer > 0\n\n// precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec3 x)\n{\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // for performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < kNoiseOctaves; ++i)\n    {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat sdBox(vec3 position, vec3 halfSize)\n{\n\tposition = abs(position) - halfSize;\n\treturn length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0);\n}\n\nfloat sdSphere(vec3 position, float size)\n{\n    return length(position) - size;\n}\n\nfloat sdf(in vec3 position, float size)\n{\n    return sdSphere(position, size);\n}\n\nvec3 normal(vec3 position, float scale)\n{\n\tfloat epsilon = 0.001;\n\tvec3 gradient = vec3(\n\t\tsdf(position + vec3(epsilon, 0, 0), scale) - sdf(position + vec3(-epsilon, 0, 0), scale),\n\t\tsdf(position + vec3(0, epsilon, 0), scale) - sdf(position + vec3(0, -epsilon, 0), scale),\n\t\tsdf(position + vec3(0, 0, epsilon), scale) - sdf(position + vec3(0, 0, -epsilon), scale)\n\t);\n\treturn normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection, float scale)\n{\n\tint stepCount = 128 * 2;\n\tfloat maximumDistance = 5.0;\n\tfloat t = 0.0;\n\tfor (int i = 0; i < stepCount; i++) {\n\t\tif (t > maximumDistance) {\n\t\t\tbreak;\n\t\t}\n\t\tvec3 position = rayOrigin + rayDirection * t;\n\t\tfloat d = sdf(position, scale);\n\t\tif (d < 0.0001) {\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn 0.0;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to)\n{\n\tvec3 forward = normalize(to - from);\n\tvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n\tvec3 up = cross(right, forward);\n\treturn mat3(right, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat angle = 0.5 * (iTime - 8.0);\n\tvec3 cameraOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n\tvec3 cameraTarget = vec3(0.0);\n\tmat3 cameraTransform = lookAtMatrix(cameraOrigin, cameraTarget);\n\tvec3 result = vec3(0.0);\n    \n    const float layerYInc = 1.0 / float(kNumberOfLayers);\n    \n\tivec2 sampleCount = ivec2(kSubsampleFactor, kSubsampleFactor);\n\tfor (int y = 0; y < sampleCount.y; y++)\n    {\n\t\tfor (int x = 0; x < sampleCount.x; x++)\n        {\n\t\t\tvec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n\t\t\tuv = uv / iResolution.xy;\n\t\t\tuv = (uv * 2.0) - 1.0;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n\t\t\trayDirection = cameraTransform * rayDirection;\n            \n\t\t\tvec3 color = vec3(0.0);\n            float layerY = 0.0;\n            for (int layerIndex = 0; layerIndex < kNumberOfLayers; ++layerIndex)\n            {\n                float scale = (layerY * kShellLayerSpacing) + 0.4;\n                float t = raycast(cameraOrigin, rayDirection, scale);\n                if (t > 0.0)\n                {\n                    // same style that iq uses in his shaders\n                    vec3 position = cameraOrigin + rayDirection * t;\n                    vec3 lightDirection = vec3(0.57735);\n                    vec3 n = normal(position, scale);\n                    float diffuseAngle = max(dot(n, lightDirection), 0.0);\n\n                    float v = fbm(normalize(position) * kShellDensity);\n                    if (v > max(0.1, layerY)) {\n                        float r = 0.82 * layerY;\n                        float g = 0.71 * layerY;\n                        float b = 0.43 * layerY;\n                        color = vec3(r, g, b) * (diffuseAngle + 0.05);\n                    }\n                }\n                layerY += layerYInc;\n            }\n\t\t\t// gamma        \n\t\t\tcolor = sqrt(color);\n\t\t\tresult += color;\n\t\t}\n\t}\n\tresult /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[919, 993, 1014, 1014, 1081], [1082, 1082, 1102, 1102, 1207], [1209, 1209, 1230, 1230, 1990], [1992, 1992, 2011, 2011, 2187], [2189, 2189, 2232, 2232, 2365], [2367, 2367, 2410, 2410, 2448], [2450, 2450, 2491, 2491, 2530], [2532, 2532, 2573, 2573, 2930], [2932, 2932, 2995, 2995, 3296], [3298, 3298, 3337, 3337, 3507], [3509, 3509, 3564, 3564, 5560]], "test": "untested"}
{"id": "dtVcWw", "name": "random lozenge tiling (170 ch)", "author": "FabriceNeyret2", "description": "Golfing 775 chars  \"random lozenge tiling\" by jt. https://shadertoy.com/view/ctyyz1", "tags": ["cube", "hexagon", "isometric", "tiling", "2tweets", "short", "golf", "lozenge"], "likes": 16, "viewed": 303, "published": 3, "date": "1700304166", "time_retrieved": "2024-07-30T17:21:57.834909", "image_code": "// Golfing 775 chars \"random lozenge tiling\" by jt. https://shadertoy.com/view/ctyyz1\n\n// ---  -25 ch by Xor\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    vec3  R = iResolution,\n          t = ceil(  mat2x3(4,4,-8,-7,7,0)  * u*2. / R.y );\n    o.rgb = 1. - mod( t - t.yzx  // ← faceId         ↓ hexagonId\n                      - ceil(cos(iTime +2e4*sin(dot(ceil((t.zxy-t)/3.),R)))), 3.); \n}\n\n\n\n\n\n\n/** // --- 195 chars\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    vec3  R = iResolution,\n          t = ceil(  mat2x3(4,4,-8,-7,7,0)  * (R.xy - u-u) / R.y );\n    o.rgb = 1. - mod( t - t.yzx  // ← faceId   ↓ hexagonId\n                     - floor(mod(1e4*sin(dot(floor((t.zxy - t.yzx)/3.) +ceil(iTime),R-73.)),2.)), 3.); \n}\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 148, 148, 390]], "test": "untested"}
{"id": "dlKyWw", "name": "SHARD NOISE", "author": "ENDESGA", "description": "using the splat-field (upgraded to 3D) to inject the tanh function, giving a unique metallic structure.\n'sharpness' parameter can be any value.\nclick to show the full octave-blend that's very perlin-like", "tags": ["3d", "noise", "gradient", "shard"], "likes": 106, "viewed": 3600, "published": 3, "date": "1700303714", "time_retrieved": "2024-07-30T17:21:59.018744", "image_code": "// @ENDESGA\n// splat-field forked from https://www.shadertoy.com/view/clGyWm\n\n#define R iResolution\n#define T (iTime * .1)\n\nvec3 hash(vec3 p)\n{\n    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5,183.3,246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    p = fract(sin(p) * 43758.5453123);\n    return p;\n}\n\n#define tau 6.283185307179586\n\nfloat shard_noise(in vec3 p, in float sharpness) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float v = 0., t = 0.;\n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 o = vec3(x, y, z);\n                vec3 io = ip + o;\n                vec3 h = hash(io);\n                vec3 r = fp - (o + h);\n\n                float w = exp2(-tau*dot(r, r));\n                // tanh deconstruction and optimization by @Xor\n                float s = sharpness * dot(r, hash(io + vec3(11, 31, 47)) - 0.5);\n                v += w * s*inversesqrt(1.0+s*s);\n                t += w;\n            }\n        }\n    }\n    return ((v / t) * .5) + .5;\n}\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 p = F/R.y;\n    vec3 uv = vec3( p + T, T * .5 );\n    bool click = iMouse.z>0.;\n\n    float fade = click ? 4. : pow(p.x,2.) * 30.;\n    \n    if(p.y<0.5 || click) // octave-blend demo\n    {\n        C = vec4(vec3(\n            (shard_noise(64.0*uv,fade) * .03125) +\n            (shard_noise(32.0*uv,fade) * .0625) +\n            (shard_noise(16.0*uv,fade) * .125) +\n            (shard_noise(8.0*uv,fade) * .25) +\n            (shard_noise(4.0*uv,fade) * .5)\n        ),1.);\n    }\n    else\n    C = vec4( vec3(shard_noise(16.0*uv,fade)), 1. );\n    if((p.y > .875 || p.y < .125) && !click) C = round(C);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 143, 143, 314], [347, 347, 397, 397, 1071], [1073, 1073, 1114, 1114, 1716]], "test": "untested"}
{"id": "DlycWm", "name": "Plane Transition Collection", "author": "wilkie", "description": "This is a set of transitions that are manipulations of planes in space. It's a forced perspective out of laziness and because it looks a little better somehow.", "tags": ["transitioncollection"], "likes": 7, "viewed": 224, "published": 3, "date": "1700297869", "time_retrieved": "2024-07-30T17:22:00.305304", "image_code": "// License: MIT\n\nconst float mirror_intensity = 0.25;\n\nconst float stack_rotate_time = 0.2;\nconst float stack_lift_time = 0.1;\nconst float stack_shuffle_time = 0.1;\nconst float stack_rotate = 0.385;\nconst float stack_lift_amount = 0.65;\n\nvec4 box(sampler2D tx, vec2 pos, vec2 size, vec2 uv, float rot, float dy) {\n    float z = 0.25;\n    size.x *= abs(rot - 1.0);\n    float arot = 1.0 - abs(rot - 1.0);\n    float dir = (2.0 * step(rot, 1.0)) - 1.0;\n    float amtx = (uv.x - pos.x + size.x / 2.0) / size.x;\n    amtx = (abs(step(1.0, rot) - amtx) - 0.5) * 2.0;\n    float amty = z * size.y * arot * amtx;\n    size.y += amty;\n    pos.y += dy + dy * amty * 1.6;\n    vec2 uvBox = (uv - pos + size / 2.0) / size;\n    vec4 result = vec4(texture(tx, uvBox).rgb, 1.0);\n    result *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    result *= step(uvBox.y, 1.0) * step(0.0, uvBox.y);\n    float d = clamp(size.x + 0.25, 0.0, 1.0);\n    result *= vec4(d, d, d, 1.0);\n    \n    pos.y -= dy * 2.0;\n    uvBox = (uv - pos + size / 2.0) / size;\n    vec4 mirror = vec4(texture(tx, abs(uvBox)).rgb, 1.0);\n    mirror *= step(0.0, uvBox.x) * step(uvBox.x, 1.0);\n    mirror *= step(uvBox.y, 0.0) * step(-1.0, uvBox.y);\n    uvBox = (1.0 - abs(uvBox));\n    mirror *= vec4(uvBox.y, uvBox.y, uvBox.y, 1.0);\n    mirror *= vec4(d, d, d, 1.0) * mirror_intensity;\n    return result + mirror;\n}\n\n#define PI 3.1415926\n\nvec4 rotate_out(vec4 result, float time, vec2 uv) {\n    time *= 1.5;\n    vec2 size = vec2(1.0 * abs(cos(time * PI)), 1.0 * abs(cos(time * PI)));\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = 1.0 - abs(cos(time * PI));\n    pos.x += rot / 2.0;\n\n    vec4 first = box(iChannel1, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(time * 2.0 + 1.0, 4.0));\n    result += box(iChannel0, pos, size, uv, rot, 0.0) * step(mod(time * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\nvec4 rotate_in(vec4 result, float time, vec2 uv) {\n    time *= 2.0;\n    \n    // The amount to pull it back before rotating the next plane in\n    float amt = 0.385;\n    float rot = abs(mod(time * 2.0, 2.0) - 1.0) * amt * 2.0;\n    \n    // Scene 1 rotation\n    float rot1 = min(rot, amt);\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += rot1 / 2.0;\n    vec2 size = vec2(1.0 - rot1, 1.0 - rot1);\n    vec4 first = box(iChannel1, pos, size, uv, rot1, 0.0);\n    \n    // Scene 2 rotation\n    float rot2 = max(rot + 2.0 * (1.0 - amt), 2.0 - amt);\n    pos = vec2(0.5, 0.5);\n    pos.x -= (2.0 - rot2) / 2.0;\n    size = vec2(abs(1.0 - rot2), abs(1.0 - rot2));\n    vec4 second = box(iChannel0, pos, size, uv, rot2, 0.0);\n    \n    // Form the result\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    \n    // Position first over second if rotation is in an early position\n    result += (first + second * (1.0 - first.a)) * step(rot, amt);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(amt, rot);\n        \n    return result;\n}\n\nvec4 rotate_stack(vec4 result, float time, vec2 uv) {\n    // The amount to pull it back before rotating the next plane in\n    float amt = stack_rotate_time;\n    float lift = stack_lift_time;\n    float shift = stack_shuffle_time;\n    \n    float rot_amt = stack_rotate;\n    float lift_y = stack_lift_amount;\n    \n    float period = amt * 2.0 + shift + lift * 2.0;\n    \n    float t0 = mod(time * 2.0, period * 2.0);\n    float t = mod(t0, period);\n    \n    // Scene 1 rotation\n    float rot = ((min(t, amt) / amt) * rot_amt) * step(t, amt + lift * 2.0 + shift);\n    rot += max(0.0, (amt - (t - amt - lift * 2.0 - shift)) / amt * rot_amt) * step(amt + lift * 2.0 + shift, t);\n    \n    t -= amt;\n    \n    // Lifting\n    float lift1 = step(0.0, t) * (min(t, lift) / lift * lift_y);\n    \n    // Shift time\n    float t2 = t - lift;\n    \n    // (Working ahead... putting it back down)\n    float t3 = t - lift - shift;\n    vec2 pos = vec2(0.5, 0.5);\n    pos.x += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    pos.y += step(0.0, t2) * (min(t2, shift) / shift * 0.05);\n    lift1 -= step(0.0, t3) * (min(t3, lift) / lift * lift_y);\n    vec2 size = vec2(1.0 - rot, 1.0 - rot) * (1.0 - step(0.0, t2) * (min(t2, shift) / shift * 0.1));\n    vec4 first = box(iChannel0, pos, size, uv, rot, lift1) * step(t0, period);\n    first += box(iChannel1, pos, size, uv, rot, lift1) * step(period, t0);\n    \n    t -= lift;\n    float swapped = t;\n    \n    // Scene 2 rotation\n    pos = vec2(0.5, 0.5);\n    pos.x += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    pos.y += 0.05 - step(0.0, t) * (min(t, shift) / shift * 0.05);\n    size = vec2(1.0 - rot, 1.0 - rot) * (0.9 + step(0.0, t) * (min(t, shift) / shift * 0.1));\n    vec4 second = box(iChannel1, pos, size, uv, rot, 0.0) * step(t0, period);\n    second += box(iChannel0, pos, size, uv, rot, 0.0) * step(period, t0);\n    \n    // Form the result    \n    // Position first over second if rotation is in an early position\n    result = result * (1.0 - min(first.a + second.a, 1.0));\n    result += (first + second * (1.0 - first.a)) * step(swapped, 0.0);\n    \n    // Position second over first if rotation is in a later position\n    result += (second + first * (1.0 - second.a)) * step(0.0, swapped);\n        \n    return result;\n}\n\nvec4 rotate(vec4 result, float time, vec2 uv) {\n    time *= 2.0;\n    vec2 pos = vec2(0.5, 0.5);\n    float rot = mod(time * 2.0, 2.0);\n    vec2 size = 0.7 + 0.3 * vec2(1.0 * abs(cos(PI * time)));\n\n    vec4 first = box(iChannel1, pos, size, uv, rot, 0.0);\n    result = result * (1.0 - min(first.a, 1.0));\n    result += first * step(2.0, mod(time * 2.0 + 1.0, 4.0));\n    result += box(iChannel0, pos, size, uv, rot, 0.0) * step(mod(time * 2.0 + 1.0, 4.0), 2.0);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime * 0.25;\n\n    vec4 result = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n    \n    float stack_period = stack_rotate_time * 2.0 + stack_shuffle_time + stack_lift_time * 2.0;\n    \n    time = mod(time, (2.0 / 1.5) + 0.5 + 1.0 + stack_period);\n    \n    // Output to screen (too lazy to step the ifs, lol)\n    if (time < 2.0 / 1.5) {\n        fragColor = rotate_out(result, time, uv);\n    }\n    else {\n        time -= 2.0 / 1.5;\n        if (time < 0.5) {\n            fragColor = rotate_in(result, time, uv);\n        }\n        else {\n            time -= 0.5;\n            if (time < 1.0) {\n                fragColor = rotate(result, time, uv);\n            }\n            else {\n                time -= 1.0;\n                fragColor = rotate_stack(result, time, uv);                \n            }\n        }\n    }\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycWm.jpg", "access": "api", "license": "mit", "functions": [[238, 238, 313, 313, 1356], [1380, 1380, 1431, 1431, 1907], [1909, 1909, 1959, 1959, 3014], [3016, 3016, 3069, 3137, 5282], [5284, 5284, 5331, 5331, 5763], [5765, 5765, 5822, 5872, 6752]], "test": "untested"}
{"id": "DtKyDw", "name": "Basic 2D Perlin Noise (Fixed)", "author": "pokeystick", "description": "https://www.shadertoy.com/view/4llSDn\n with a small fix to get it to compile again", "tags": ["perlinnoise"], "likes": 3, "viewed": 158, "published": 3, "date": "1700285727", "time_retrieved": "2024-07-30T17:22:01.245789", "image_code": "// HASH AND NOISE FUNCTIONS TAKEN FROM IQ ----------------\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(48.7,342.7)+sin(iTime));\n\t\n    return -1.0 + 2.0*fract(sin(h)*54611.5655123);\n}\n\nfloat Noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// ------------------------------------------------------\n\nfloat Smooth(in vec2 p){\n    float corners = (Noise(vec2(p.x-1.0,p.y-1.0))+Noise(vec2(p.x+1.0,p.y-1.0))+Noise(vec2(p.x-1.0,p.y+1.0))+Noise(vec2(p.x+1.0,p.y+1.0)))/16.0;\n    float sides = (Noise(vec2(p.x+1.0,p.y))+Noise(vec2(p.x-1.0,p.y))+Noise(vec2(p.x,p.y+1.0))+Noise(vec2(p.x,p.y-1.0)))/8.0;\n    float center = Noise(vec2(p.x,p.y))/4.0;\n    return corners + sides + center;                                                           \n}\n\nfloat interpolate(float a, float b, float x){\n    float ft = x*3.141592;\n    float f = (1.0-cos(ft))*0.5;\n    return a*(1.0-f) + b*f;\n}\n\nfloat smoothinterp(vec2 p){\n    float inx = floor(p.x);\n    float frx = p.x - inx;\n    float iny = floor(p.y);\n    float fry = p.y - iny;\n    float v1 = Smooth(vec2(inx,iny));\n    float v2 = Smooth(vec2(inx+1.0,iny));\n    float v3 = Smooth(vec2(inx,iny+1.0));\n    float v4 = Smooth(vec2(inx+1.0,iny+1.0));\n    float i1 = interpolate(v1,v2,frx);\n    float i2 = interpolate(v3,v4,frx);\n    return interpolate(i1,i2,fry);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat uv = smoothinterp(fragCoord);\n\tfragColor = vec4(uv,uv,uv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 81, 81, 183], [185, 185, 211, 211, 503], [564, 564, 588, 588, 1000], [1002, 1002, 1047, 1047, 1137], [1139, 1139, 1166, 1166, 1559], [1561, 1561, 1618, 1618, 1690]], "test": "untested"}
{"id": "clGyWm", "name": "Noise - Gabor - 2D - Deriv", "author": "iq", "description": "Analytic derivatives for a simple field of random Gabor kernels", "tags": ["2d", "noise", "gradient", "derivatives", "gabor"], "likes": 45, "viewed": 1367, "published": 3, "date": "1700267251", "time_retrieved": "2024-07-30T17:22:02.149373", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytic derivatives for a simple field of random Gabor kernels\n\n// please never use this hash or any other fract based\n// hash in production. they are really bad.\nvec2 hash( in vec2 x )   \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return fract( 16.0*k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nvec3 gabor_wave(in vec2 p)\n{    \n    vec2  ip = floor(p);\n    vec2  fp = fract(p);\n    \n    const float fr = 2.0*6.283185;\n    const float fa = 4.0;\n    \n    vec3 av = vec3(0.0,0.0,0.0);\n    vec3 at = vec3(0.0,0.0,0.0);\n\tfor( int j=-2; j<=2; j++ ) // can reduce this search to just [-1,1] \n    for( int i=-2; i<=2; i++ ) // if you are okey with some small errors\n\t{\t\t\n        vec2  o = vec2( i, j );\n        vec2  h = hash(ip+o);\n        vec2  r = fp - (o+h);\n\n        vec2  k = normalize(-1.0+2.0*hash(ip+o+vec2(11,31)) );\n\n        float d = dot(r, r);\n        float l = dot(r, k);\n        float w = exp(-fa*d);\n        vec2 cs = vec2( cos(fr*l), sin(fr*l) );\n        \n        av += w*vec3(cs.x, -2.0*fa*r*cs.x - cs.y*fr*k );\n        at += w*vec3(1.0,  -2.0*fa*r);\n\t}\n  //return av;\n    return vec3( av.x, av.yz-av.x*at.yz/at.x  ) /at.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n\n    vec3 f = gabor_wave(8.0*p);\n\n    vec3 col = vec3(0.5 + 0.5*f.x);\n    if( p.y<0.5 )\n    {\n        // show analytical derivatives\n        col = 0.5 + 0.01*vec3(f.yz*8.0,0.0);\n        \n        // show low quality numerical derivatives (check correctness)\n        //col = 0.5 + 0.01*vec3(dFdx(f.x)*iResolution.y, dFdy(f.x)*iResolution.y, 0.0 );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGyWm.jpg", "access": "api", "license": "mit", "functions": [[1213, 1312, 1339, 1339, 1464], [1466, 1466, 1494, 1494, 2306], [2308, 2308, 2365, 2365, 2792]], "test": "ok"}
{"id": "dtGyWw", "name": "Ellipse distance different param", "author": "fishy", "description": "Distance estimate by iq, but this accepts two perpendicular vectors (things break if they aren't) instead of a minor and major radius", "tags": ["2d", "distance", "ellipse"], "likes": 3, "viewed": 136, "published": 3, "date": "1700264421", "time_retrieved": "2024-07-30T17:22:03.008078", "image_code": "// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Using Newtown's root solver to compute the distance to\n// an ellipse, instead of using the analytical solution in\n// https://www.shadertoy.com/view/4sS3zz.\n//\n// In retrospect, it's the same as Antonalog's https://www.shadertoy.com/view/MtXXW7\n//\n// More information here:\n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\n// for visualization purposes only\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdEllipse( vec2 p, vec2 a, vec2 b )\n{\n    // do transformations and get the minor/major radii\n    float la = length(a);\n    float lb = length(b);\n    p *= mat2(a/la, b/lb);\n    vec2 ab = vec2(la, lb);\n    \n    // everything past this point is by iq\n    \n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 a = vec2(sin(iTime*2.5)*0.1 + 0.5, 0);\n    vec2 b = vec2(0, sin(iTime*1.5)*0.1 + 0.5);\n    a *= rot(iTime*0.25);\n    b *= rot(iTime*0.25);\n    if(iMouse.z > 0.001)\n    {\n        a = m;\n        b = (normalize(a)*(sin(iTime*1.5)*0.1+0.5))*rot(1.57);\n    }\n\t\n\tfloat d = sdEllipse( p, a, b );\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    // added these lines to show the vectors\n    col = mix( col, vec3(1.0, 1.0, 0.0), 1.0-smoothstep(0.0,0.01,sdSegment(p, vec2(0), a)) );\n    col = mix( col, vec3(0.0, 1.0, 1.0), 1.0-smoothstep(0.0,0.01,sdSegment(p, vec2(0), b)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGyWw.jpg", "access": "api", "license": "mit", "functions": [[1868, 1903, 1955, 1955, 2078], [2080, 2080, 2123, 2179, 2850], [2852, 2852, 2909, 2909, 3772]], "test": "ok"}
{"id": "dlVcRz", "name": "Image Based Dithering", "author": "bebop_artist", "description": "Dithering Algorithm", "tags": ["dithering"], "likes": 1, "viewed": 136, "published": 3, "date": "1700264274", "time_retrieved": "2024-07-30T17:22:03.861795", "image_code": "#define UV_ORIGIN 0.5\n#define ZOOM 1.0\n#define SPEED 3.0\n\nconst float PI = 3.14;\n\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n    //The output must be between 0.0 and 1.0\n\treturn -1.0 + 2.0*fract(cos(p) * 43758.5453123);\n}\n\nfloat quantize(float inp, float period)\n{\n    return floor((inp)/period)*period;\n}\nvec2 quantize(vec2 inp, vec2 period)\n{\n    return floor((inp)/period)*period;\n}\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, \n                 s,  c );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += hash(uv)/500.0f;\n    vec4 noise = texture(iChannel0, uv*vec2(100.0f));\n    // Time varying pixel color\n    //uv = uv + (noise.xx-0.5f)*0.5f;\n    vec4 im = texture(iChannel1,uv);\n    float steps = 1000.f;\n    float freq = (200.0f/iResolution.x)*quantize(1.0f-quantize(im.x,steps), 1.f/steps);\n    vec2 uv2 = fragCoord;\n    vec2 quv = quantize(uv,vec2(1.0f/steps,1.0f/steps));\n    uv2 *= rotationMatrix(60.0f);\n    float wave = mod(freq*uv2.x,1.0f);\n    bool d = wave < quantize(im.x,1.f/steps);\n    vec2 coord = fragCoord;\n    int aa = 16;\n    vec2 pert = (1.0f/iResolution.xy)/float(aa);\n    for (int i = 0; i < aa; i++){\n        for(int j = 0; j < aa; j++){\n           coord += vec2(pert.x,0);\n           \n        }\n        coord += vec2(0,pert.y);\n    }\n    vec3 col = vec3(d,d,d);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 270], [272, 272, 313, 313, 354], [355, 355, 393, 393, 434], [436, 436, 470, 470, 583], [585, 585, 642, 697, 1588]], "test": "untested"}
{"id": "clycDm", "name": "truchet3d toroidal hexagon tiles", "author": "cyperus", "description": "3d truchet toroidal hexagonal tessellation", "tags": ["3d", "grid", "sdf", "hexagon", "tiling", "schwarzchristoffel"], "likes": 12, "viewed": 180, "published": 3, "date": "1700263628", "time_retrieved": "2024-07-30T17:22:05.314910", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3d toroidal hexagon tiles\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// References, Inspiration:\n//\n// - \"Schwarz-Christoffel Mapping\" by mla\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// - \"Year of Truchets\" #058 by byt3_m3chanic\n//   https://www.shadertoy.com/view/msVfzR\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 4.; \nconst float CAM_FLE = 2.;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.1;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 900;\nconst float RAY_STEP_FACTOR3 = 180./450.;\nfloat RAY_STEP_FACTOR  = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 3.E0;\n\n// shape mod\nfloat RPT_a0 = 6.0;\n\n// fog\nconst float FOG_DENSITY = 1.E-2;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    vec2 z = vec2(0.);\n    float d = -1.;\n\n    /// regular polygon tiles\n    vec3 rpt_id = vec3(1.);\n    p.xy = inversesc(hexgrid2hex(p.xy, rpt_id),6);\n\n    /// torus,sphere,2spheres       \n    // cylinder radial plane -> halfcomplex plane\n    rxy = length(p.xy); au = atan(p.y, p.x);\n    z = 2.*ccos(PI*vec2(rxy,p.z)); z.x -= RPT_a0;   \n            \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI);\n    z = p.yz;\n\n    /// truchet 3D\n    vec3 tc_id = vec3(0.); float tc_a = 0.;\n    // truchet grid\n    float TC3D_nu = 3.*2.*3.;\n    float TC3D_nv = 2.*2.;\n    float TC3D_nr = 1.;\n    \n    p *= vec3(TC3D_nr,TC3D_nu,TC3D_nv); // r,u,v\n    p.yzx = p.xyz;\n\n    ivec3 l0 = -ivec3(TC3D_nv/2.,0,TC3D_nu/2.);\n    ivec3 l1 = ivec3(TC3D_nv/2.,TC3D_nr,TC3D_nu/2.)-ivec3(1.);\n    tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n\n    // random\n    float rnd = hash21(tc_id.xz);\n\n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n\n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n\n    // cell alpha    \n    tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);    \n   \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;\n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bb\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));    \n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, RAY_MIN_DIST );\n    dis.y = min( dis.y, RAY_MAX_DIST );\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break;\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n//\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // modulation shape\n    RPT_a0 = -(3.+ 2. *sin(2.*PI*iTime/60.));\n    \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        vec3 sky_col = rd*.4+.6;\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( 3.*6.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// const\nconst float PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    // x  : periodic in[0,1]\n    // x0 : offset\n    // pw : pulse width in[0,1]\n    // pf : pulse frequency\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn); // in[0.,2.]\n    //return (pp+pn)-(pp*pn);// in[0.,1.]\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));}\n    \nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n  \nvec2 csqr(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y );}\n\nvec2 ccos(vec2 z) {\n    vec2 d=vec2(exp(z.y),exp(-z.y));\n\treturn vec2(cos(z.x)*(d.x+d.y)*.5,-sin(z.x)*(d.x-d.y)*.5);}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993;\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K);\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K);\n  z *= C;\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id){\n    const float SQRT3 = sqrt(3.);\n    const float SQRT_3 = 1./SQRT3;\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI/6.);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI/6.);\t// B:orientation-offset of cell  \n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); // hue, saturation, value\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clycDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1044, 1044, 1066, 1066, 2780], [2782, 2795, 2849, 2849, 3442], [3444, 3444, 3489, 3489, 3651], [3653, 3653, 3695, 3695, 3946], [3948, 3960, 4003, 4003, 4194], [4196, 4196, 4253, 4253, 4331], [4333, 4336, 4383, 4407, 7236]], "test": "untested"}
{"id": "dtVcDD", "name": "Fork Structures nov2023", "author": "amaxwell", "description": "I refactored someone else's shader to help me understand it better.", "tags": ["raymarching"], "likes": 3, "viewed": 137, "published": 3, "date": "1700252683", "time_retrieved": "2024-07-30T17:22:06.077870", "image_code": "// refactored from https://www.shadertoy.com/view/Ms2SDc\n\nconst float PI = 3.14159;\nconst float ep = 0.02;\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nconst vec3 lightColor = vec3(0.08, 0.02, -0.01);\nconst float atmosphere = 0.0625;\nconst int maxIterations = 96;\nconst float holeWidth = 0.05;\n\n// takes a 2d vector and rotates it by some angle\nvec2 rotate(vec2 vector, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return vec2(\n        cosAngle * vector.x - sinAngle * vector.y,\n        sinAngle * vector.x + cosAngle * vector.y    \n    );\n}\n\n// takes a point in space and returns how far it is from the scene\n// this is a very compact way to represent a scene mathematically\nfloat sceneSDF(vec3 pos) {\n\tfloat ground = dot(pos, up) + 0.75;\n\tfloat structure = length(abs(mod(pos, 2.0) - 1.0)) - 1.35 \n        + 0.05 * cos(PI * pos.x * 4.0) \n        + 0.05 * sin(PI * pos.z * 4.0);\n\tfloat slice1 = length(max(abs(mod(pos, 2.0) - 1.0).xz - 1.0, 0.5)) - 0.075 \n        + 0.1 * cos(pos.y * 36.0);\n\tfloat slice2 = length(abs(mod(pos, 0.5)) - 0.25) - 0.975;\n\n\tfloat bubble_w = 0.8 + 0.2 * cos(PI * pos.z) + 0.2 * cos(PI * pos.x);\n\tfloat bubble = length(mod(pos, 0.125) - 0.0625) - bubble_w;\n\n\tfloat hole = length(abs(mod(pos.xz, 1.0) - 0.5)) - holeWidth;\n\n\treturn max(\n        slice1 + slice2,\n        min(\n            -structure, \n            max(\n                -hole - slice2 * 0.375,\n                ground + bubble\n            )\n        )\n    );\n}\n\n// starts from the camera location and moves in the rayDirection until it touches the scene\n// uses the point where the ray hits the scene and its distance from the camera to calculate a color\nvec3 calculateRayColor(vec3 cameraLocation, vec3 rayDirection) {\n    float rayLength = 0.0;\n    for (int i = 0; i < maxIterations; i++) {\n        float distance = sceneSDF(cameraLocation + rayDirection * rayLength);\n        if (abs(distance) < 0.005) break;\n        rayLength += distance * 0.5;\n    }\n\n    vec3 hitPoint = cameraLocation + rayDirection * rayLength;\n\n    float lightIntensity = dot(\n        normalize(vec3(\n            sceneSDF(hitPoint + vec3(-ep, ep, ep)), \n            sceneSDF(hitPoint + vec3(ep, -ep, -ep)), \n            sceneSDF(hitPoint + vec3(ep, ep, -ep))\n        )), \n        vec3(0.1)\n    );\n\n    vec3 baseColor = vec3(lightIntensity) - rayLength * atmosphere;\n    return baseColor * baseColor + vec3(lightIntensity) + rayLength * lightColor;\n}\n\n// returns the direction of the ray for a screen coordinate\nvec3 getRayDirection(vec2 fragCoord) {\n    vec3 rayDirection = normalize(\n        vec3((2.0 * fragCoord / iResolution.xy - 1.0) * vec2(1.625, 1.0), 0.75)\n    );\n    rayDirection.yz = rotate(rayDirection.yz, PI * 0.25 * sin(PI * iTime * 0.125));\n    rayDirection.zx = rotate(rayDirection.zx, PI * cos(-PI * iTime * 0.05));\n    rayDirection.xy = rotate(rayDirection.xy, PI * 0.125 * cos(PI * iTime * 0.125));\n    return rayDirection;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 cameraLocation = vec3(\n        1.5 * cos(PI * iTime * 0.125), \n        4.0 - 3.0 * sin(PI * iTime * 0.125), \n        -1.0 - iTime\n    );\n\n    fragColor = vec4(\n        calculateRayColor(cameraLocation, getRayDirection(fragCoord)), \n        1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 338, 377, 377, 574], [576, 709, 735, 735, 1479], [1481, 1674, 1738, 1738, 2444], [2446, 2506, 2544, 2544, 2939], [2941, 2941, 2993, 2993, 3255]], "test": "untested"}
{"id": "ctyyWw", "name": "population automata", "author": "zzggbb", "description": "population automata", "tags": ["automata"], "likes": 1, "viewed": 121, "published": 3, "date": "1700251191", "time_retrieved": "2024-07-30T17:22:06.985443", "image_code": "#define GRAYSCALE 0\n\n#if GRAYSCALE\n#define color_method vec3\n#else\n#define color_method h2rgb\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = texelFetch(AUTOMATA, ivec2(fragCoord), 0).x;\n    fragColor = vec4(color_method(h), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int x_offsets[8] = int[8](-1, 0, 1,  -1, 1,  -1,  0,  1);\nint y_offsets[8] = int[8]( 1, 1, 1,   0, 0,  -1, -1, -1);\n\nivec2 wrap(vec2 coord) {\n    vec2 new = coord;\n    if (coord.x >= iResolution.x) new.x = coord.x - iResolution.x;\n    if (coord.x < 0.0) new.x = iResolution.x + coord.x;\n    if (coord.y >= iResolution.y) new.y = coord.y - iResolution.y;\n    if (coord.y < 0.0) new.y = iResolution.y + coord.y;\n    return ivec2(new);\n}\n\nvec4 get_cell(vec2 c) {\n    return texelFetch(AUTOMATA, wrap(c), 0);\n}\n\nbool key_pressed(int k) {\n    return texelFetch(KEYBOARD, ivec2(k, 0), 0).x == 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    init_random(fragCoord, iResolution, iFrame);\n    vec2 p = fragCoord / iResolution.xy;\n    vec4 cell_old = get_cell(fragCoord);\n    if (cell_old.a == 0.0 || key_pressed(82)) {\n        float r = random();\n        fragColor = vec4(r, 0.0, 0.0, 1.0);\n    } else {\n        int i = int(random() * 8.0);\n        vec2 offset = vec2(x_offsets[i], y_offsets[i]);\n        float color_new = get_cell(fragCoord+offset).x;\n        fragColor = vec4(color_new, 0.0, 0.0, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RESOLUTION iResolution\n\n#define AUTOMATA iChannel0\n#define KEYBOARD iChannel1\n\n#define COLOR_R vec3(1.0, 0.0, 0.0)\n#define COLOR_G vec3(0.0, 1.0, 0.0)\n#define COLOR_B vec3(0.0, 0.0, 1.0)\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 h2rgb(float h){\n    return hsv2rgb(vec3(h, 1.0, 1.0));\n}\n\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid init_random(vec2 fragCoord, vec3 iResolution, int iFrame){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\nvec3 random_choice(float r, vec3 a, vec3 b) {\n    return (r <= 0.5) ? a : b;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 158, 158, 263]], "test": "untested"}
{"id": "ctVcDD", "name": "Perlin Noise testing", "author": "Elyades", "description": "Trying to make some texture", "tags": ["perlinnoise"], "likes": 0, "viewed": 131, "published": 3, "date": "1700245445", "time_retrieved": "2024-07-30T17:22:07.871075", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.3,0.8);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nfloat rand1(vec2 uv)\n{\n    float l = cos(uv.x + uv.y) - sin(uv.y - uv.x);\n    return ( cos(l + sin(20000000000.0*sin(TWOPI*l)) + 200.0*cos(TWOPI*l) + iTime) ); \n}\n\nfloat rand2(vec2 uv)\n{\n    return ( (cos(TWOPI*(uv.x + uv.x*uv.y + uv.y + 5.0*iTime)/9.0)) + sin(TWOPI*(uv.y+ 0.5*uv.x*uv.y*cos(uv.x + uv.x)/(4.0*sqrt(2.0)))) ) ;\n}\n\nfloat rand3(vec2 uv)\n{\n    float rand = length(uv);\n    return( rand );\n}\n\nvec2 getRandomVector (vec2 uv)\n{\n    float r1 = rand3(uv);\n    vec2 v = vec2(r1,sqrt(2.0-r1*r1));\n    return (v);\n    //return( cos(2.0*floor(200.0*uv)) + sin(2.0*floor(200.0*uv)) );\n}\n\nfloat perlinNoise(vec2 uv)\n{\n    uv = mod(uv,1.0);\n    vec2 roundDown = floor(uv);\n    vec2 roundUp = roundDown + 1.0;\n    vec2 d = uv - roundDown;\n    vec2 vecBL = getRandomVector(roundDown);\n    vec2 vecBR = getRandomVector(roundDown + vec2(1.0,0.0));\n    vec2 vecTL = getRandomVector(roundDown + vec2(0.0,1.0));\n    vec2 vecTR = getRandomVector(roundDown + 1.0);\n    \n    float prod1 = dot(d, vecBL);\n    float prod2 = dot(uv - vec2(roundUp.x,roundDown.y) ,vecBR);\n    float lerp1 = mix(prod1, prod2, d.x);\n    float prod3 = dot(uv - vec2(roundDown.x,roundUp.y) ,vecTL);\n    float prod4 = dot(uv - roundUp,vecTR);\n    float lerp2 = mix(prod3, prod4,d.x);\n    \n    float final = mix(lerp1, lerp2, d.y);\n    return(final);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; uv -= vec2(0.5); uv *= 3.0;\n    \n    float final = perlinNoise(uv);\n    \n    vec3 col = vec3(final);\n\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 122, 144, 330], [332, 332, 354, 354, 494], [496, 496, 518, 518, 660], [662, 662, 684, 684, 735], [737, 737, 769, 769, 921], [923, 923, 951, 951, 1648], [1650, 1650, 1707, 1707, 1889]], "test": "untested"}
{"id": "clKyDD", "name": "Colorful/🐁 3DDiffusionAutomata", "author": "timmaffett", "description": "Fork of @Shane's!\nJust added color by changing channels1 and 2 and added mouse control of camera and ray direction vary over time. Allows exploring how cool and complex @Shane's shader automata is! -TMM\n3D automata moving in a random diffusive fashion.\n", "tags": ["grid", "random", "automata", "cell", "swap", "walk", "traversal"], "likes": 3, "viewed": 193, "published": 3, "date": "1700235931", "time_retrieved": "2024-07-30T17:22:09.032969", "image_code": "// Fork of \"3D Diffusion Automata\" by Shane. https://shadertoy.com/view/cl3yDN\n// 2023-11-17 15:45:14\n\n/*\n\n    Random Diffusion Automata \n    -------------------------\n    \n    Fabrice put together a pixelized diffusion example that was based on a \n    moving image he saw on X.com (both links are below), which was cool and \n    concise, but omitted smooth cell transitions. The source image contained \n    some neat sliding motion based on occupied cell elements moving to empty \n    ones -- Similar to the motion in a sliding puzzle. This is standard \n    stuff, so there are plenty of demonstrations on the internet, and even a \n    few related examples on here, but they tend to be long winded -- my own \n    efforts included...\n    \n    Digressing, SnoopethDuckDuck rearranged Fabrice's example and added the \n    necessary sliding element that gives it that smooth animated appearance.\n    However, he managed to do it using very little code and just one texture \n    channel, which was really cleverly done. After sneaking a peak at his \n    solution, then looking at my own obfuscated mess, I realized that I'd \n    really overthought it... :)\n    \n    Anyway, I'm very greatful for the aforementioned postings, and this is \n    just a 3D extension of that. I used a different template, so the variables \n    and functions don't quite match up to Fabrice and SnoopethDuckDuck's, but \n    it's basically the same thing. There is also an unlisted accompanying \n    2D example with some additional texture-based cell indexing, plus some \n    explanations for anyone interested in this kind of thing.\n    \n    I didn't put a great deal of effort into the design, as I simply wanted \n    to get one of these on the board, as they say. 3D cell swap examples are \n    not common on Shadertoy, but I'm not the first to post one of these. \n    Coposuke posted a beautiful example a couple of years ago. I've posted \n    the link below, for anyone who hasn't seen it. \n    \n    \n    // Largely based on the following:\n    \n    // Fabrice and SnoopethDuckDuck's combined logic, which is\n    // pretty difficult to compete with. It's a really nicely \n    // written example. If anyone does manage to outlogic this \n    // logic, please let me know. :) \n    Cell Swap Automata - SnoopethDuckDuck\n    https://www.shadertoy.com/view/DtccR8\n    \n    // This is inspired by Fabrice's shader\n    Shuffle gradient - random walk 3 - FabriceNeyret2 \n    https://www.shadertoy.com/view/dtSfRh\n    //\n    In turn, based on this X.com post:\n    https://twitter.com/junkiyoshi/status/1697571241513910691\n    \n    // This is my simple 2D version, which is an old version of Fabrice's\n    // that I completely rearranged to incorporate SnoopethDuckDuck's\n    // smooth cell swapping code.\n    Random Diffusion Automata - Shane\n    https://www.shadertoy.com/view/mtdyDH\n    \n    Other examples:\n    \n    // Beautifully done. I haven't had time to look it over, but I can \n    // see that the BRDF is really nicely done. My example also features \n    // BRDF patterned cubes, but that's purely coincidental.\n    High-Collar Cubes - coposuke\n    https://www.shadertoy.com/view/WldBRH\n    \n*/\n\n \n\n//////////////////////////////////\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Alternate gold only color.\n//#define GOLD\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n \n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n\n    /*\n    vec3 idF = step(0., p)*2. - 1.;\n    vec3 faceID = (idF + 1.)/2. + vec3(0, 2, 4);\n    */    \n    \n    // Integer version.\n    ivec3 idF = ivec3(step(0., p))*2 - 1;\n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    return f.x>.5? vec4(p.yz/p.x/2. + .5, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y/2. + .5, idF.y, faceID.y) : \n                   vec4(p.xy/p.z/2. + .5, idF.z, faceID.z); \n}\n\n// IQ's 3D signed box formula.\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n    p = abs(p) - b + sf;\n    return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n \n////////////////////\n\n// Globals for the cell values, moving direction vector and cell ID.\nvec4 gCell;\nvec3 gTmDir;\nvec3 gID3;\n\nvec3 getAutomata(vec3 p, inout vec3 sc){\n\n    \n    // Obtaining the four object (particle) values for this cell.\n    // Channel values:\n    // X: Original cell position ID (for colors, etc). Needs converting to vec2.\n    // Y: Direction (clockwise from the left): Left, up, right, down (0, 1, 2, 3).\n    // Z: Transfer time. Starting (0), ending (1), or somewhere between ([0, 1]).\n    // W: Inactive or active status (0 or 1) -- Empty or not.\n    //\n    // Using \"floor(p)\" to avoid artifacts at certain resolutions.\n    //vec4 cell = texelFetch(iChannel0, ivec2(floor(p/sc)), 0);\n    \n    //vec4 cell = tMap(iChannel0, mod(floor(p/sc), wrap));\n    \n    vec2 uv = convertCoord(mod(floor(p/sc), wrap));//mod(floor(p/sc), wrap)\n    vec4 cell = texelFetch(iChannel0, ivec2(uv), 0);\n\n    // Inactive to active transfer (cell.z), or active to inactive transfer.\n    // Inactive moves forward (cell.z), active are losing a particle, so move in the\n    // opposite direction (1. - cell.z).\n    //\n    // Smoothly transition from one cell to the next. It's a minor distinction, but\n    // an asymmetric easing process needs to be applied prior to mixing.\n    cell.z = smoothstep(.15, .85, cell.z); \n    float tm = mix(cell.z, 1. - cell.z, cell.w);\n     \n    \n    \n    // Cell coordinate ID. Converting from stored float to vec2.\n    //vec3 iq = vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap)));\n    vec3 iq = mod(vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap))), wrap);\n\n\n    // Local cell coordinates.\n    vec3 q = mod(p, sc) -.5*sc; \n    \n    // Cell direction.\n    vec3 dir = indexToDir(cell.y);\n    \n    \n    gCell = cell;\n    \n \n    // Size.\n    //float rndSz = hash21(iq + .11);\n    //float obj = sBoxS(q - tm*dir, vec2(.4), .2);\n    //float obj = length(q - tm*dir) - (.4 - .0*rndSz); // Etc.\n    \n    gTmDir = tm*dir*sc;\n    \n    //q -= gTmDir;\n    \n    gID3 = iq*sc;\n    \n        \n    return q;//vec4(q, iq*sc);\n \n}\n\n\n///////////////////\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gP;\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n\n  \n    // Scale. This will include two blocks, each 8 cells deep, so we'll move the wall\n    // forward by half a unit to obscure the second block.\n    vec3 sc = vec3(1./16.);\n    \n    \n    // Local coordinates and ID.\n    vec3 p = getAutomata(q3, sc);\n    vec3 id3 = gID3;\n \n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - (p))/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    //gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n   \n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    sc -= .005;//*(hash21(id)*.9 + .1);\n    \n  \n    // Move the box.\n    p -= gTmDir;\n    \n\n    // Rendering the box. You could do some cool things here, but I've\n    // kept things simple.\n    float d = sBoxS(p, sc/2., .05*sc.x);\n    \n    //float dS = length(p) - sc.x/2.;\n    //d = mix(d, dS, .125);\n    \n\n    \n    \n    // This is a bit of a hack to get rid of fuzzy shadows. Basically, \n    // don't render inactive cells that are technically out of cell range.\n    if(gCell.z==1. && gCell.w == 0.) d = 1e5;\n    \n   \n\n    // Debug: Getting rid of some boxes.\n    //if(hash31(id3)<.5) d  = 1e5;\n    \n    \n    // Only include one block level (16 z-positions deep), just in front of the wall\n    if(floor(q3.z) != -1.) d = 1e5; \n    \n    // Excluding XY sheets behind this Z depth.\n    //if(floor(id3.z/sc.z)>3.) d = 1e5;\n\n    // Saving the box dimensions and local coordinates.\n    gSc = sc;//vec3(sc.xy, h);\n    gP = p;\n    \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id3);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID, svGID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor, or wall, depending on your perspective. Kind of redundant,\n    // since you can't see it, but it's there, just in case.\n    float fl = -p.z - .5;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n    /*\n    // Putting the boxes in a cage... No. Dumb idea, but I had to try. :)\n    vec3 dC = vec3(1e5);\n    vec3 sc = vec3(1./16.);\n    vec3 q = mod(p + sc/2., sc) -.5*sc; \n    dC.x = sBoxS(q.xy, sc.xy*.05, .025*sc.x);\n    dC.y = sBoxS(q.yz, sc.yz*.05, .025*sc.x);\n    dC.z = sBoxS(q.xz, sc.xz*.05, .025*sc.x);\n    float dR = min(min(dC.x, dC.y), dC.z);\n    \n    fl = min(fl, dR);\n    fl = max(fl, -(p.z + 1. + .05*gSc.z));\n    */\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;// hash31(ro + rd)*.15;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n\n    vec3 id3 = svGID.yzw;\n    vec4 c4 = cubeMap(p);\n    vec2 tuv = c4.xy;\n    float faceID = c4.w;\n\n    vec2 oTuv = tuv;\n\n    vec2 scl = vec2(1);\n    vec2 oScl = scl;\n\n\n    // The two distance field values (they overlap) and corresponding\n    // lines patterns.\n    vec4 d = Truchet(tuv, id3, faceID, scl);\n\n    // Edge width and smoothing factor.\n    float ew2 = .03*oScl.x;\n    float sf2 = .02*oScl.x;\n\n    // Saving the original cube color.\n    float objCol = (.25);\n\n    // A little extra thickness for the edges.\n    d.xy -= ew2*2.;\n\n    // Distance field shading.\n    vec2 sh = max(-d.xy/oScl.x*4., 0.);\n    sh = smoothstep(0., .65, sh);\n\n    // Rendering the two overlapping distance fields and line patterns.\n    for(int i = 0; i<2; i++){\n\n         // Line pattern.\n         float lnCol = mix(.5, .35, 1. - smoothstep(0., sf2, d[i + 2]));\n\n         // Subtle highlighting.\n         lnCol *= .25 + sh[i]*.75;\n\n         // Faux AO, dard edges and pattern.\n         objCol = mix(objCol, 0., (1. - smoothstep(0., sf2*4., d[i]))*.5);\n         objCol = mix(objCol, 0., 1. - smoothstep(0., sf2, d[i]));\n         objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n    }  \n    \n    return objCol;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. \n// There's a six tap version (samples taken from either side of each axis), but this \n// works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the \n    // aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n \n    vec4 b4;\n    for(int i = min(iFrame, 0); i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of \n    //cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some \n    // kind of orthogonal space fix using the Gram-Schmidt process, or something to that \n    // effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more \n    // bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n///////////////////////////\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n} \n*/\n\n//////////\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvec2 mouseRotZoom(vec2 uv) {\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.20, 0.17) : iMouse.xy/iResolution.xy;\n    // allow mouse zoom and rotate    \n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\tuv = mouseRotZoom(uv); // TMM allow mouse to modify uv from start\n    \n\t// Camera Setup.\n\tvec3 lk = vec3(iTime/32., .036, -1); // \"Look At\" position.\n\tvec3 ro = lk + vec3(-.04, .12, -.3);  // Camera position.\n \n \n // TMM and further let mouse moidify camera position\n vec2 mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n ro = ro + vec3( 0.25*mouse.x, 0.02, 0.28 *mouse.y);\n\n\n\n    // Light positioning.\n    vec3 lp = ro + vec3(1, .38, -.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    //TMM and let time move our ray direction with influence from mouse\n    rd *= rotateY(sin(iTime) * mouse.y*0.5); //tmm\n    rd *= rotateX(cos(iTime) * mouse.x*0.5);\n    \n    // Rough fish-eye lens.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.125, 0.))));\n    \n    // Evening the camera up a bit.\n    rd.xy *= rot2(-.02);\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */  \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec3 svP = gP;\n    \n    // Saving the moving direction position vector.\n    vec3 svDir = gTmDir;\n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n        \n        vec3 svTx;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n             vec3 txP = svP;//vec3(svP, sp.z);\n            //txP.xy += svDir;\n            \n            vec3 id3 = svGID.yzw;\n            \n            // Random coloring using IQ's short versatile palette formula.\n            //float rnd = hash31(id3 + .34);\n            //vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2) + .8);\n            \n            \n            // Coloring the individual blocks with the saved ID.\n            vec2 id2 = convertCoord(floor(id3/svSc.x));\n            vec3 col1 = getTex(iChannel1, id2*svSc.x/2.);\n            col1 = smoothstep(.0, .5, col1);\n            \n            // More coloring.\n            vec3 col2 = getTex(iChannel2, id2*svSc.x/2.);\n            col2 = smoothstep(-.1, .35, col2);\n            \n            // Grunge texturing.\n            vec3 tx1 = tex3D(iChannel1, (id3 + txP)*2., sn);\n            vec3 tx2 = tex3D(iChannel1, (id3 + txP)*4., sn);\n            tx1 = smoothstep(.0, .5, tx1);\n             \n            // Random colors.\n            objCol = (hash31(id3 + .22)<.333)? col2 : col1;\n            \n            // Interwoven checkered colors.\n            //vec3 id = floor(id3/svSc);\n            //if(mod(id.x + id.y + id.z, 2.)<.5) objCol = objCol.zyx;\n\n                      \n            // Texturing the colored boxes and adding some sepia.\n            objCol *= vec3(1.5, 1.25, 1)*(tx2*3. + .25);\n \n            \n            #ifdef GOLD \n            // Alternate gold coloring.\n            objCol = vec3(.3 + hash31(id3 + .51)*.4);\n            if(hash31(id3 + .21)<1.5)\n            objCol = .5 + .45*cos(6.2831853*hash31(id3 + .32)/8. + vec3(0, 1.2, 2) + .25);\n            objCol *= vec3(1, 1.1, 1.2);\n            //if(hash31(id3 + .26)<.5) objCol = mix(objCol, objCol.zyx, .75);\n            objCol *= (tx2*3. + .25);\n            #endif\n             \n            //////////////////////\n            // Rendering a cliche art deco multiscale Truchet design onto the cube faces.\n            vec4 c4 = cubeMap(svP);\n            vec2 tuv = c4.xy;\n            float faceID = c4.w;\n\n            vec2 oTuv = tuv;\n\n            vec2 scl = vec2(1);\n            vec2 oScl = scl;\n\n            \n            // The two distance field values (they overlap) and corresponding\n            // lines patterns.\n            vec4 d = Truchet(tuv, id3, faceID, scl);\n\n            // Edge width and smoothing factor.\n            float ew2 = .03*oScl.x;\n            float sf2 = .01*oScl.x;\n            \n            \n            // Evening up the tone, just a little.\n            objCol = mix(objCol, objCol/(1./3. + dot(objCol, vec3(.299, .587, .114))), .5);\n\n            // Saving the original cube color.\n            vec3 svCol = objCol;\n            objCol /= 2.; // Darkening the background.\n\n            // A little extra thickness for the edges.\n            d.xy -= ew2*2.;\n            \n            // Distance field shading.\n            vec2 sh = max(-d.xy/oScl.x*4., 0.);\n            sh = smoothstep(0., .65, sh);\n\n            // Rendering the two overlapping distance fields and line patterns.\n            for(int i = 0; i<2; i++){\n\n                 // Line pattern.\n                 vec3 lnCol = svCol*1.;\n                 lnCol = mix(lnCol, svCol*.25, 1. - smoothstep(0., sf2, d[i + 2]));\n                 \n                 // Subtle highlighting.\n                 lnCol *= .75 + sh[i]*.5;\n\n                 // Faux AO, dard edges and pattern.\n                 objCol = mix(objCol, vec3(0), (1. - smoothstep(0., sf2*8., d[i]))*.5);\n                 objCol = mix(objCol, svCol*.125, 1. - smoothstep(0., sf2, d[i]));\n                 objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n            }\n            \n            \n            // Bump map the above pattern. Not as nice as displacement mapping\n            // in the distance function, but way effective, and way cheaper.\n            // The bump is subtle, but it's there. Too much can be overpowering.\n            sn = doBumpMap(svP, sn, .003);\n              \n\n            // Save the texture postion.\n            svTx = (id3 + txP)*2.;\n \n        }\n        else {        \n            \n            // The dark wall in the background. Hidden behind the boxes.\n            vec3 tx = tex3D(iChannel1, sp*4., sn);\n            objCol = vec3(1.5, 1.25, 1)*(tx*3. + .05)/2.;\n             \n            // Save the texture postion.\n            svTx = sp*4.;\n        }\n        \n        // Adding a purple tinge.\n        //objCol = mix(objCol, objCol*vec3(2, 1, .5).yzx, .5);\n        \n        \n        // Texture based bump mapping. You'd need to uncomment the\n        // bump map function first.\n        //sn = texBump(iChannel1, svTx, sn, .001);///(1. + t/FAR)\n        \n        \n        \n\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n    \t// Diffuse lighting.\n\t    //float diff = max( dot(sn, ld), 0.);\n        \n        float roughness = min(dot(objCol, vec3(.299, .587, .114))*.75 + .15, 1.);\n        float reflectance = .5;\n        float matType = 1.;\n            \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        \n        //TMM\n        //vec3 rTx = vec3(1.12);// \n        vec3 rTx =texture(iChannel3, rf.xzy*vec3(1, -1, -1)).xyz;\n        \n        rTx *= rTx;\n        float spF = 2.; //svObjID<.5? 4. : 2.;\n        objCol = objCol + objCol*speR*rTx*spF;\n         \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*1.75; // Studio.\n        float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); // Outdoor.\n        //float am = clamp(.5 - .35*(rd.x - rd.y), 0., 1.);        \n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(objCol, sn, ld, -rd, matType, roughness, reflectance);\n \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (objCol*am*(sh*.5 + .5) + ct*(sh));        \n        \n        // Ambient occlusion and attenuation.\n        col *= ao*atten;\n          \n           \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(1), smoothstep(.25, .9, t/FAR));\n \n    // Very basic Reinhard tone mapping.\n    col = col/(1. + col/3.);\n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}\n\n\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// A cube of dimension 8 and a square of dimension 64 will\n// each require the same number of pixels for storage.\nconst float wrap = 8.; // (2^3)*(2^3)*(2^3) = 2^12.\nconst float cubeMapRes = 64.; // (2^6)*(2^6) = 2^12.\n\n/////////////////////\n/////////////////////\n\n// I might replace this with the Murmurhash functions, but I wanted\n// to try these out first, since I like the simplicity, and they're\n// supposed to be fast. Anyway, you can read all about it, here:\n\n// A Mind Forever Programming - Random Floats in GLSL 330\n// Author: Lee C\n// https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n \nuint hash( uint x ){\n    x += ( x << 10u ); x ^= ( x >>  6u );\n    x += ( x <<  3u ); x ^= ( x >> 11u );\n    x += ( x << 15u ); return x;\n}\n\nuint hash( uvec2 v ){ return hash( v.x ^ hash(v.y) ); }\nuint hash( uvec3 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ); }\nuint hash( uvec4 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\nfloat hash41( vec4 f ){\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash31( vec3 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash21( vec2 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\n//////////////////////\n\n// Converting pixels on a 2D square area to their equivalent \n// 3D positions and back again: For anyone who finds this confusing,\n// I've explained the simple process below.\n\n\nvec3 convertCoord(vec2 p){\n\n    // Convert the 2D coordinate to its equivalent 3D coordinates.\n    \n    // 2D coordinate -- Wrapping isn't mandatory, but this is a wrapped example.\n    p = mod(floor(p), cubeMapRes); \n    // Converting the above 2D coordinate to its linear representation.\n    float i = p.x + p.y*cubeMapRes;\n\n    // Converting the linear number above to 3D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec3(i, floor(i/wrap), floor(i/(wrap*wrap))), wrap);\n}\n\nvec2 convertCoord(vec3 p){\n\n    // Convert the 3D coordinates to its equivalent 2D coordinates.\n    \n    // Wrapping the 3D coordinates first -- Only for this example.\n    p = mod(floor(p), wrap);\n    // Converting the above 3D coordinate to its linear representation.\n    float i = p.x + (p.y + p.z*wrap)*wrap;\n    // Converting the linear number above to 2D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec2(i, floor(i/cubeMapRes)), cubeMapRes);\n}\n\n\n\n/*\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n*/\n\n/* \n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, 1.);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// IQ's \"uint\" based uvec4 to float hash.\nfloat hash41(vec4 f){\n\n    uvec4 p = floatBitsToUint(f);\n    uint h32 = 19u*p.x + 47u*p.y + 101u*p.z + 131u*p.w + 173u;\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n// Six cube face directions.\nconst vec3[6] e = vec3[6](vec3(-1, 0, 0), vec3(1, 0, 0), vec3(0, -1, 0), vec3(0, 1, 0),\n                          vec3(0, 0, -1), vec3(0, 0, 1));\n \nvec3 indexToDir(float i) {\n   // Converts the indices 0 through to 5 to one of the direction above.\n   return e[int(i)]; \n}\n\nfloat dirToIndex(vec3 p) {\n    \n    // Converts the left, right, down, up, backward, forward \n    // vectors to 0, 1, 2, 3,  4 or 5 respectively.\n    for(int i = 0; i<6; i++){\n        if(p == e[i]) return float(i);\n    }\n    \n    // Redundant, because the above will always return... but I'm paranoid, \n    // so if one day it doesn't, this will be waiting. :D\n    return 0.;\n}\n\nfloat rndDirIndex(vec4 ut){\n    // Returns a random number based on 2D position and time.\n    return mod(floor(96.*hash41(ut)), 6.);\n}\n\nfloat rndDirIndex(vec4 ut, float maxM){\n    // Returns a random number based on 2D position and time,\n    // but with restrictions.\n    return mod(floor(72.*hash41(ut)), maxM);\n}\n\nvec3 rndDir(vec4 u) {\n    // Returns a random direction.\n    return indexToDir(rndDirIndex(u));\n}\n\nvec3 rndDir(vec4 u, float maxM) {\n    // Returns a random direction with restrictions.\n    return indexToDir(rndDirIndex(u, maxM));\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*PI);\n  \n}\n////////////////////\n\n// An art deco multiscale Truchet pattern. Made up on the spot, \n// but it seems to work.\nvec4 Truchet(vec2 p, vec3 cellID, float faceID, inout vec2 scl){\n      \n\n     // Save coordinates.\n     vec2 oP = p;\n\n\n     // Scaling, ID, and local coordinates.\n     vec2 oScl = scl;\n     vec2 id2 = floor(p/scl) + .5;\n     p -= (id2)*scl;//mod(tuv, scl) - scl/2.;\n     \n     // Unique face identifier.\n     vec3 id3 = cellID + vec3(id2/12., faceID/12.);\n\n     // Random subdivision.\n     int divN = 0;\n     if(hash31(id3 + .09)<.5){ \n         scl /= 2.; \n         p = oP;\n         id2 = floor(p/scl) + .5;\n         //p = mod(p, scl) - scl/2.;\n         p -= (id2)*scl;\n         \n         id3 = cellID + vec3(id2/12., faceID/12.);\n         \n         divN++; // Subdivision number.\n     }\n\n\n     \n     // Random coordinate rotation.\n     //if(hash31(id3 + .42)<.5) p = rot2(3.14159/2.*floor(hash21(id3 + .01)*32.))*p;\n     if(hash31(id3 + .42)<.5) p = p.yx*vec2(-1, 1);\n\n     // The distance field holder. The pattern involves rending overlapping,\n     // so requires to place holders.\n     vec2 dd = vec2(1e5);\n     \n     // Triangle experiment for next time.\n     //vec2 rTuv = rot2(3.14159/4.)*tuv;\n     //dd.x = (tuv.x + tuv.y)*.7071;\n     //dd.y = -(tuv.x + tuv.y)*.7071;\n     //dd = max(dd, max(abs(tuv.x), abs(tuv.y)) - scl.x/2.);\n     \n     // Cell bounds.\n     //float bx = sBoxS(p, scl/2. - .005, 0.);\n\n     \n     if(hash31(id3 + .12)<.65){\n     \n         // Random arcs, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .19)<.65){\n             dd.x = length(p - scl/2.);\n             dd.x = abs(dd.x - scl.x/2.);\n         }\n         else {\n             dd.x = length(p - vec2(1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(0, 1)*scl/2.));\n         }\n\n         if(hash31(id3 + .21)<.65){\n             dd.y = length(p + scl/2.);\n             dd.y = abs(dd.y - scl.y/2.);\n         }\n         else {\n             dd.y = length(p - vec2(-1, 0)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, -1)*scl/2.));\n             \n         }  \n\n     }\n     else {\n     \n         // Random lines, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .13)<.65){\n             dd.x = abs(p.y);\n         }\n         else {\n             dd.x = length(p - vec2(-1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(1, 0)*scl/2.));\n         }\n\n         if(hash31(id3 + .14)<.65){\n             dd.y = abs(p.x);\n         }\n         else {\n             dd.y = length(p - vec2(0, -1)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, 1)*scl/2.));\n         }\n     }\n\n\n     // Line pattern.\n     float lNum = 12./oScl.x;\n     float offs = divN==0? .5 : .5; //  Different for different scales.\n     vec2 pat = (abs(fract(dd*lNum + offs) - .5) - .2)/lNum;\n     //vec2 pat = vec2(1e5);//\n\n     // If not subdivided, split the pattern and move it to match the\n     // position of the subdivided one. It's one of many standard\n     // multiscale pattern moves.\n     if(divN == 0) dd = abs(dd - .25*scl.x);\n     //dd = abs(dd + .125) - .125;\n    \n     // Apply some scale based width.\n     dd.xy -= .24/2.*oScl;\n     \n     \n     \n     // Randomize the rendering order to mix things up more.\n     if(hash31(id3 + .15)<.5){ dd = dd.yx; pat = pat.yx; }\n     \n     //dd = max(dd, sBoxS(tuv, scl/2. - .005, 0.));\n \n\n     // Return the overlapping Truchet pattern distances \n     // and the lines pattern distances.\n     return vec4(dd, pat);  \n\n}\n\n\n\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n", "buffer_a_code": "\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    if(fragCoord.x>cubeMapRes || fragCoord.y>cubeMapRes) discard;\n\n\n    // Wrapped coordinates... Kind of redundant here, since we're rejecting\n    // pixels outside this area range, but it's good practice.\n    vec2 u = mod(fragCoord, cubeMapRes);\n    vec4 col;\n    \n    // Convert the 2D canvase coordinates to 3D coordinates.\n    vec3 p = convertCoord(u);\n\n    \n    if(textureSize(iChannel0, 0).x<2 || iFrame==0){ // || iMouse.z>0.\n    \n        // Initial setup conditions:\n        \n        // Initial cell index: This is a 2D position (in float form), which \n        // allows for diffusion of pictures. However, any initial cell \n        // identifier (like a random number) can be put here.\n        col.x = p.x + p.y*wrap + p.z*wrap*wrap;\n        //col.x = p.x + (p.y + p.z*wrap)*wrap;\n        //col.x = floor(u.x/4) + floor(u.y/4.)*iResolution.y;\n        // Direction index. Clockwise from the left. 0,1,2,3.\n        col.y = 0.; // Any number will do.\n        // When conditions are met, the cell object will transfer from one\n        // cell to the next via an interpolating mechanism that ranges\n        // between zero and one.\n        //\n        // Motion timer [0,1] range. Thanks, SnoopethDuckDuck.\n        col.z = 1.; // Put it into \"accepting new transfer\" mode.\n        // Initial random active/inactive threshold. It could be pattern\n        // based, random, or whatever you wish. This one is obviously random.\n        col.w = step(.4, hash31(p + .11)); // Inactive or active: 0 or 1.\n        \n           \n    } \n    else {\n    \n        // Obtain the current stored cell states.\n        col = texelFetch(iChannel0, ivec2(u), 0);  \n        \n        // Obtain the current stored cell states.\n        //vec2 uv = convertCoord(p);\n        //col = texelFetch(iChannel0, ivec2(uv), 0);  \n\n        \n        // I wanted the cells to wrap along the XY plane, but at the same \n        // time be clamped to the near and far Z walls. The solution is very\n        // simple... but still took me an hour. :) In the XY directions, let\n        // the cells objects move in all six directions. However, if they hit \n        // the front or back Z positions, don't allow them to move in the Z \n        // direction... OMG, that was so obvious. :D\n        float maxDirections = (p.z<0. || p.z>=wrap)? 4. : 6.;\n        \n        // Obtain the random direction for this pixel at this point in time.\n        vec3 dir = rndDir(vec4(p, iFrame), maxDirections); \n  \n        \n        // Use the random direction above to move to the neighboring cell in that \n        // direction, then obtain the random direction for that cell... That was a \n        // bit wordy, but a lot of this stuff depends on understanding it.\n        //\n        vec3 nP = p + dir; // Neighboring cell position.\n        // Neighboring cell movement needs to be restricted along the far Z planes also.\n        if(nP.z<0. || nP.z>=wrap) maxDirections = 4.;\n        // The random direction value in the neighboring cell... Not the direction\n        // to the neighboring cell, which is a different entity.\n        vec3 dirNgbr = rndDir(vec4(mod(nP, wrap), iFrame), maxDirections); \n        // Obtain the cell information for that neighbor as well.\n        //vec4 colNgbr = texelFetch(iChannel0, ivec2(mod(p + dir, wrap)), 0);\n        vec2 uvN = convertCoord(mod(nP, wrap));\n        vec4 colNgbr = texelFetch(iChannel0, ivec2(uvN), 0);\n         \n        \n        // If a transfer is still in progress, update the transfer timer -- which,\n        // in turn, will be converted to cell object position.\n        if (col.z < 1.){ \n            // Increment the motion timer.\n            \n            // Converting to 3D cell coordinates.\n            vec3 ip = mod(vec3(col.x, floor(col.x/wrap), floor(col.x/(wrap*wrap))), wrap);\n            \n            float rnd = hash31(ip + .2); // Random number for each cell.\n            float dS =  (1. - rnd*.66)*3.*iTimeDelta; // Incremental distance change.\n            col.z = min(col.z + dS, 1.); // Increasing the distance, whilst not overshooting.\n        }\n        // Both cells (current and neighbor) need to have completed a motion transfer \n        // and be awaiting te next transfer (\"col.z == 1.\" and \"colNgbr.z == 1\").\n        //\n        // The transfer between cells needs to be valid (the cell and neighbor directions \n        // need to point toward each other). Finally, two empty or two full cells obviously \n        // can't cell swap, which leaves full to empty, or empty to full. In other words, \n        // an active cell can only transfer to an inactive one, or an inactive cell can only\n        // receive a transfer from a full one (Ie. col.a != colNgbr.a).\n        else if(colNgbr.z == 1. && dir == -dirNgbr && col.w != colNgbr.w) {\n    \n            // An inactive cell will receive the index of the transferring\n            // active cell.\n            if (col.w == 0.) col.x = colNgbr.x; // New index.\n            col.y = dirToIndex(dir); // Store the random direction index at this time point.\n            col.z = 0.;          // Reset the timer back to the start.\n            col.w = colNgbr.w;   // The inactive cell will now be active, and vice versa.\n \n        }\n        \n        \n    }\n    \n    // Store the updated values to the buffer.\n    fragColor = col;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3377, 3410, 3432, 3432, 3490], [3495, 3649, 3697, 3999, 4908], [4911, 4933, 4968, 5345, 5436], [5438, 5496, 5517, 5601, 6074], [6076, 6107, 6145, 6145, 6244], [6376, 6376, 6416, 7021, 8315], [8739, 8739, 8760, 8916, 11257], [11343, 11366, 11384, 11523, 12229], [12233, 12254, 12290, 12339, 13389], [14210, 14405, 14457, 14538, 15835], [15838, 15990, 16025, 16025, 16276], [16279, 16306, 16345, 16345, 17563], [17568, 17764, 17819, 17928, 19215], [20455, 20455, 20474, 20474, 20523], [20526, 20526, 20554, 20554, 20765], [20767, 20767, 20823, 20860, 30764]], "test": "untested"}
{"id": "DtVyWD", "name": "Texture Smoothing Tunnel", "author": "domrally", "description": "My 1st tunnel! A 3D example to demo the real world behavior of flat texture filtering & mipmaps.\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["tunnel", "flat", "texture", "aliasing", "filtering", "mipmap", "magnification", "smooth", "bilinear", "anti", "minification", "reconstruction"], "likes": 10, "viewed": 249, "published": 3, "date": "1700234902", "time_retrieved": "2024-07-30T17:22:09.991406", "image_code": "/*\nby Dom Mandy in 2023\n*/\nfloat flatstep(float a, float b, float x) { float t = clamp((x - a) / (b - a), 9e-8, 1. - 9e-8), h = atanh(cos(3.14 * t)), H = h * h; return .5 - .5 * sign(h) * sqrt(1. - exp(-H * (.14 * H + 1.27323949) / (.14 * H + 1.))); }\nvec2 flatstep(vec2 a, vec2 b, vec2 x) { return vec2(flatstep(a.x, b.x, x.x), flatstep(a.y, b.y, x.y)); }\nvec4 Texture(sampler2D s, vec2 i) { float t = float(textureSize(s, 0).x); vec2 j = i * t + .5; j = floor(j) + flatstep(vec2(0), vec2(1), fract(j)); return texture(s, (j - .5) / t); }\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 I = iResolution.xy;\n    i += i - I;\n    i /= I.y;\n\n    vec2 v = vec2(.01, .04) * iTime + vec2(\n        atan(i.y, i.x) / 6.28,\n        .3 / sqrt(length(i))\n    );\n\n    // jaggy\n    vec4 a = texelFetch(iChannel0, ivec2(v * 256. + 256.) % 256, 0),\n         // flat magnify & built in mipmap minify\n         b = mix(textureLod(iChannel0, v, .2 / length(i)), Texture(iChannel0, v), .5 * dot(i, i));\n\n    // controls\n    float f = mix(sin(iTime), (2. * iMouse.y - I.y) / I.y, max(0., sign(iMouse.z)));\n\n    o = mix(a, b, step(i.y, f)) * 2. * smoothstep(1.6, .0, sqrt(length(i))) * smoothstep(1.5 / I.y, .0, max(.0, .02 - abs(i.y - f)));\n}\n\n\n/*\nSEE ALSO\n\ntexture\nhttps://www.shadertoy.com/view/XsfGDn\nhttps://iquilezles.org/articles/texture\nhttps://en.wikipedia.org/wiki/Texture_filtering\n\nflat\nhttps://www.shadertoy.com/view/mdKfRR\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n*/\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 70, 70, 251], [252, 252, 291, 291, 356], [357, 357, 392, 392, 539], [542, 542, 578, 578, 1220]], "test": "untested"}
{"id": "DtGcDD", "name": "Doomed Melt", "author": "wilkie", "description": "This is a simulation of the screen wipe transition effect found in the original DOOM.", "tags": ["retro", "doom", "transition", "wipe"], "likes": 1, "viewed": 181, "published": 3, "date": "1700223547", "time_retrieved": "2024-07-30T17:22:10.835151", "image_code": "// This is an implementation that simulates the original DOOM screen\n// melt transition effect.\n\n// Just press 'Reset' to see the wipe in action since it relies on\n// iFrame being 0 to freeze the image in the buffer. You can also\n// just freeze the video yourself.\n\n// License: MIT\n\n// DOOM's random number table\nconst int rndtable[256] = int[256](\n    0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,\n    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,\n    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,\n    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,\n    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,\n    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,\n    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,\n    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,\n    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,\n    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,\n    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,\n    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,\n    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,\n    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,\n    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,\n    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,\n    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,\n    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,\n    120, 163, 236, 249\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float time = mod(iTime, 5.0);\n    \n    // Pull destination color\n    fragColor = texture(iChannel0, uv);\n    \n    // Pick a random starting offset\n    vec4 randColor = texture(iChannel1, vec2(0.0, 0.0));\n    float rand = (randColor.r + randColor.g + randColor.b) / 3.0;\n    randColor = texture(iChannel1, vec2(rand, rand));\n    rand = (randColor.r + randColor.g + randColor.b) / 3.0;\n    \n    // We want a pixel set offset\n    int ridx = int(float(rand * 256.0));\n    int offsety = -(rndtable[(ridx++) % 256] % 16);\n    \n    // We want the relative offset, too\n    int x = int(floor(fragCoord.x / iResolution.x * 160.0));\n    for (int i = 1; i < x; i++) {\n        int delta = (rndtable[(ridx++) % 256] % 3) - 1;\n        offsety = clamp(offsety + delta, -15, 0);\n    }\n    \n    // Vanilla DOOM treats the vertical offsets in terms of 8 pixels.\n    // So, what is the velocity of the melt? (in units of percent per second)\n    // Vanilla DOOM moved 8 pixels per tic (1/35 sec) for an image 200 pixels tall.\n    int tics = int(floor(time / (1.0 / 35.0)));\n    int pixels_per_tic = 8;\n    \n    // Melt\n    offsety = max((offsety * pixels_per_tic) + (tics * pixels_per_tic), 0);\n    \n    // Convert the offsety value, which is the amount the pixel values are shifted down,\n    // into our texture coordinate space.\n    uv.y += min(float(offsety) / 200.0 * (iResolution.x / iResolution.y), 1.0);\n    \n    if (uv.y < 1.0) {    \n        // Pull the frozen frame\n        fragColor = texture(iChannel1, uv);\n    }\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame % 150 == 0) {\n        fragColor = texture(iChannel0, uv);\n    }\n    else {\n\t\tfragColor = texture(iChannel1, uv);\n    }\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGcDD.jpg", "access": "api", "license": "mit", "functions": [[1714, 1714, 1771, 1821, 3378]], "test": "untested"}
{"id": "mlycDW", "name": "droplet lmao", "author": "hatenal", "description": "just a little droplet generator i made while testing out a bokeh effect", "tags": ["effect", "droplet"], "likes": 2, "viewed": 129, "published": 3, "date": "1700222755", "time_retrieved": "2024-07-30T17:22:11.740729", "image_code": "//smoothstep but shorter lmao\n#define S(a, b, t) smoothstep(a, b, t)\n\n// declare the ray\nstruct ray {\n    vec3 o, d;\n};\n\n//function to create the ray from the camera point and return it\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom) {\n    ray a;\n    a.o = camPos;\n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0, 1, 0), f);\n    vec3 u = cross(f, r);\n    vec3 c = a.o + f*zoom; \n    vec3 i = c + uv.x * r + uv.y * u;\n    \n    a.d = normalize(i-a.o);\n    \n    return a;\n}\n\n//math to return the closest point using some math\nvec3 ClosestPoint(ray r, vec3 p) {\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\nfloat DistRay(ray r, vec3 p) {\n    return length(p-ClosestPoint(r, p));\n}\n\n//simple Bokeh function\nfloat Bokeh(ray r, vec3 p, float size, float blur) {\n    float d = DistRay(r, p);\n   \n    float c = S(size, size*(1.-blur), d);\n    c *= mix(.7, 1., S(size*.8, size, d));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalize pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n   \n   //make canvas square\n   uv -= .5;\n   uv.x *= iResolution.x/iResolution.y;\n   \n   // declare camera position and rotation \n   vec3 camPos = vec3(0., 0., 0.);\n   vec3 lookat = vec3(0., 0., .000000000000001);\n\n   //generate the ray\n   ray r = GetRay(uv, camPos, lookat, 2.);\n   \n   vec3 p = vec3(0, 0, 5.);\n   \n   float c = Bokeh(r, p, tan(iTime-1.), tan(iTime-1.));\n   \n   vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*c;\n   \n   fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlycDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 186, 245, 245, 497], [499, 550, 584, 584, 633], [634, 634, 664, 664, 707], [709, 733, 785, 785, 919], [921, 921, 978, 1026, 1535]], "test": "untested"}
{"id": "dtycWW", "name": "3D Ray-sphere intersection", "author": "djancool", "description": "3D version of a ray-sphere intersection shader. With comments explaining how it works so i can look back at it if i need it", "tags": ["3d", "ray", "intersection", "raysphere"], "likes": 1, "viewed": 131, "published": 3, "date": "1700217734", "time_retrieved": "2024-07-30T17:22:12.698169", "image_code": "#define PI 3.14159263535\n//#define SPHERE_MOVEMENT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera cam;\n\n    // ViewDir and fov\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    cam.viewDir = normalize(vec3((fragCoord - iResolution.xy * 0.5) * a, 0.5));\n    // Translate camera position and direction\n    vec2 mouseRotation = vec2( -iMouse.y / iResolution.y * -PI - PI * 0.5, iMouse.x / iResolution.x * PI * -2.0);\n    cam.position = vec3(0.0, 0.0, -3.0);\n    rotateCamera(cam, mouseRotation);\n\n\n    sphere sphere1;\n    #ifdef SPHERE_MOVEMENT\n    sphere1.position = vec3(0.25);\n    sphere1.position *= rotateX(iTime) * rotateY(iTime * 0.9) * rotateZ(iTime * 0.8);\n    #else\n    sphere1.position = vec3(0.0);\n    #endif\n    sphere1.radius = 1.0;\n\n    // Length along RD that is closest to sphere centre/origin\n    float t = dot(sphere1.position - cam.position, cam.viewDir);\n    // Position along RD that is closest to sphere centre/origin\n    vec3 tpos = cam.position + cam.viewDir * t;\n    // Distance from tpos to sphere centre/origin\n    float tdis = distance(tpos, sphere1.position);\n    // Get length of sphere surface to tpos\n    float x1 = sqrt(sphere1.radius * sphere1.radius - tdis * tdis);\n    // Distance along RD to sphere surface\n    float tx1 = t - x1;\n    // Distance along RD to sphere backface\n    float tx2 = t + x1;\n    // Position of sphere surface\n    vec3 tx1Pos = cam.position + cam.viewDir * tx1;\n    // Position of sphere backface\n    vec3 tx2Pos = cam.position + cam.viewDir * tx2;\n    \n    // Calculate normal\n    vec3 normal = normalize(sphere1.position - tx1Pos);\n    vec3 reflectVec = reflect(cam.viewDir, normal);\n    \n    //// Presenting additionals ////\n    \n    // Lambert multiplied by lowest mip of environment texture to get approx avarage scene light\n    vec3 lambert = max(dot(normal, -normalize(vec3(1.0))), 0.0) * textureLod(iChannel0, normal, 10.0).rgb;\n    float fresnel = pow(1.0 - dot(normal, cam.viewDir), 5.0) * 0.96 + 0.04;\n    vec3 reflections = texture(iChannel0, reflectVec).rgb;\n    vec3 col = lambert + reflections * fresnel;\n    \n    vec3 bcol = texture(iChannel0, cam.viewDir).rgb;\n    vec3 finalCol = tdis < sphere1.radius ? col : bcol;\n    \n    // Tonemapping\n    finalCol *= 3.0;\n    finalCol = reinhard_extended_luminance(finalCol, 3.0);\n    \n    fragColor = vec4(vec3(finalCol), 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct camera\n{\n    vec3 position;\n    vec3 viewDir;\n};\n\nstruct sphere\n{\n    vec3 position;\n    float radius;\n};\n\n// https://graphics-programming.org/resources/tonemapping/index.html\n\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nvec3 change_luminance(vec3 c_in, float l_out)\n{\n    float l_in = luminance(c_in);\n    return c_in * (l_out / l_in);\n}\nvec3 reinhard_extended_luminance(vec3 v, float max_white_l)\n{\n    float l_old = luminance(v);\n    float numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\n    float l_new = numerator / (1.0f + l_old);\n    return change_luminance(v, l_new);\n}\n\n//// ROTATION AMTRIX ////\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(1, 0, 0),\n            vec3(0, c, -s),\n            vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n            vec3(c, -s, 0),\n            vec3(s, c, 0),\n            vec3(0, 0, 1));\n}\n\n\nvoid rotateCamera(inout camera cam, vec2 rot)\n{\n    cam.position *= rotateX(rot.x);\n    cam.position *= rotateY(rot.y);\n    \n    cam.viewDir *= rotateX(rot.x);\n    cam.viewDir *= rotateY(rot.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 109, 109, 2375]], "test": "untested"}
{"id": "dtVcW1", "name": "downward-dog", "author": "manthrax", "description": "i have no idea what im doing", "tags": ["trash"], "likes": 4, "viewed": 147, "published": 3, "date": "1700195715", "time_retrieved": "2024-07-30T17:22:13.604745", "image_code": "float scl = 100.;\n\nfloat noise1(in float v,float scl){\n\treturn fract(sin(v*scl)*scl);\n}\nfloat sdfCircle(vec2 uv, vec2 pos,float rad){\n    return length(uv-pos)/rad;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scl-=.01*iTime;\n    vec2 uv = fragCoord/iResolution.x;\n    float pc = atan(uv.x-.5,uv.y-.5) + .26;\n    vec3 col = vec3(noise1((iTime*.1)+uv.x,scl)+pc+noise1((iTime*.1)+uv.y,scl)-noise1((iTime*.1)-uv.y,scl));\n    col *= 1.-sdfCircle(uv,vec2(.5,.2),.1);\n    col *= 1.-sdfCircle(uv,vec2(.5,.2+sin(iTime*.03*.4)),.5);\n    col = fract(col*vec3(1.,2.,3.))-.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 54, 54, 87], [88, 88, 133, 133, 166], [167, 167, 224, 224, 615]], "test": "untested"}
{"id": "dlGyD1", "name": "Basic Rings", "author": "causeNo", "description": "Some first steps. Trying to understand the relationship between time and shapes. Just wanted to make some rings, honestly xD", "tags": ["time", "rings", "uv"], "likes": 2, "viewed": 128, "published": 3, "date": "1700166406", "time_retrieved": "2024-07-30T17:22:14.454473", "image_code": "void mainImage( out vec4 pixlColor, in vec2 pixlCoord )\n{\n    float tau = 6.28318531;\n    vec2 uv = (pixlCoord / iResolution.xy) * 2.0 - vec2(1.0, 1.0);\n    float power = length(uv);\n    \n    float b = tau;\n    //float modTime = iTime - (b * floor(iTime/b));\n    //float modTime = iTime / 100.0;\n    float modTime = sin(iTime * 0.5);\n    float brightness =\n        0.75 * sin(modTime * power * tau)\n        + 0.25 * tan(0.5 * tau + modTime * power * tau);\n    \n    vec3 color = vec3(\n        0.0,\n        0.3 * power * brightness,\n        brightness\n     );\n     pixlColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 594]], "test": "untested"}
{"id": "mlGyW1", "name": "sdf grass", "author": "01000001", "description": "sdf grass instead of [url=DlKyzG]shell texturing[/url]. I don't like it tbh. ", "tags": ["smol"], "likes": 1, "viewed": 103, "published": 3, "date": "1700162890", "time_retrieved": "2024-07-30T17:22:15.313177", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n    \n    O = texture(iChannel0, uv + .5/r);\n    O = pow(O, vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define s(x) m = min(m, x)\nconst float farPlane = 1e5;\nconst float minDist = 1e-5;\nconst int maxSteps = 2<<7;\n\nvec2 masterCell;\n\n#define bladeH 500.\n#define bladeW 2.\n\n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat ellipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n} // By Inigo Quilez\n\n\nfloat df(vec3 p){\n    float m = farPlane;\n    \n\n    if (p.z > bladeH/2. + .3 ) return p.z - bladeH/2.;\n    \n    vec2 cell = floor(p.xy), tempCell;\n    vec2 cellUV = (p.xy-cell-.5)/2.;\n\n\n    //*\n    for (float x = -1.; x<=1.; x++){\n        for (float y = -1.; y <= 1.; y++){\n            tempCell = cell + vec2(x,y);\n            vec3 h = (hash(uvec3(0, mod(tempCell, 1e6)))-.5);\n\n            float d = ellipsoid(\n                vec3(cellUV + h.xy - vec2(x,y)*.5 + vec2(sin(p.z*h.z*3.), cos(p.z*h.z*3.))*.15, p.z), \n                vec3(bladeW, bladeW, bladeH)*.5\n            );\n            \n            if (d < m){\n                m = d;\n                masterCell = tempCell;\n            }\n        }\n    }\n    /*/\n    vec3 h = hash(uvec3(0, mod(cell, 1e6)))-.5;\n\n    s(\n        ellipsoid(\n            vec3(cellUV + h.xy, p.z), \n            vec3(bladeW, bladeW, bladeH)*.5\n        )\n    );\n\n    //*/\n    \n    return m;\n}\n\nvec3 norm(vec3 p, float e){\n    \n    return vec3(\n        \n        df(p + vec3(e, 0, 0)) - df(p - vec3(e, 0, 0)),\n        df(p + vec3(0, e, 0)) - df(p - vec3(0, e, 0)),\n        df(p + vec3(0, 0, e)) - df(p - vec3(0, 0, e))\n        \n    ) / (2. * e);\n\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n    \n    \n    vec3 o = vec3(0, iTime, bladeH*.5);\n    vec3 camf = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    o -= camf*50.;\n    vec3 camr = normalize(cross(camf, vec3(0,0,1)));\n    vec3 camu = cross(camr, camf);\n    vec3 dir = normalize(camf*2. + camu*cuv.y + camr*cuv.x);\n\n    float d,t = 0.;\n    vec3 p;\n    \n    for (int i = 0; i<maxSteps; i++){\n        \n        p = o + dir * t;\n        d = df(p);\n        \n        t += d*.8;\n        \n        if (d < minDist) break;\n        if (d > farPlane) break;\n        \n    }\n    if (p.z > bladeH/2.){\n        O = vec4(1.,exp(-dir.z),exp(dir.z-1.)*.5,1);\n        return;\n    }\n    \n    \n    vec3 h = hash(uvec3(0, mod(masterCell, 1e5)));\n    \n    O = vec4(h.x*.02 + .02 + h.y*.04, .06 + h.y*.07, h.z * .01 + .02 + h.y*.02, 1)\n    *exp((p.z-bladeH/2.)/2.)\n    *(dot(norm(p, t*1e-2), vec3(0, 0, 1))*.5 + .5)\n    *3.\n    ;\n    //vec4(1.-pow(1.-dot(norm(p, t*1e-2).xyz, -dir), 5.));\n    //vec4(exp(-t/30.));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 227]], "test": "untested"}
{"id": "ctKyWR", "name": "Flat Texture Filtering", "author": "domrally", "description": "Using flat functions to make even smoother magnification filtering.\nClick & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["2d", "flat", "texture", "filtering", "magnification", "smooth", "bilinear", "reconstruction"], "likes": 10, "viewed": 182, "published": 3, "date": "1700150359", "time_retrieved": "2024-07-30T17:22:16.077135", "image_code": "/*\nby Dom Mandy in 2023\n*/\nfloat flatstep(float a, float b, float x) {\n    float t = clamp((x - a) / (b - a), 9e-8, 1. - 9e-8),\n          h = atanh(cos(3.14 * t)),\n          H = h * h;\n\n    // error function method by Sergei Winitzki using Padé approximations\n    return .5 - .5 * sign(h) * sqrt(1. - exp(-H * (.14 * H + 1.27323949) / (.14 * H + 1.)));\n}\nvec2 flatstep(vec2 a, vec2 b, vec2 x) { return vec2(flatstep(a.x, b.x, x.x), flatstep(a.y, b.y, x.y)); }\n\n\n/*\nmostly the same as iq's texture example,\njust changed to use flatstep instead of smoothstep\n*/\nvec4 Texture(sampler2D s, vec2 i) {\n    float t = float(textureSize(s, 0).x);\n    i = i * t + .5;\n    i = floor(i) + flatstep(vec2(0), vec2(1), fract(i));\n    return texture(s, (i - .5) / t);\n}\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 v = (i /= iResolution.x) * .1;\n\n\tvec4 a = texture(iChannel0, v),\n         b = Texture(iChannel0, v);\n\n    float f = v.x + mix(-.05 - .05 * sin(.7 * iTime), -.1 * iMouse.x / iResolution.x, max(0., sign(iMouse.z)));\n\to = mix(a, b, step(f, 0.)) * smoothstep(.0, 4e-4, abs(f));\n}\n\n\n/*\nSEE ALSO\n\ntexture\nhttps://www.shadertoy.com/view/XsfGDn\nhttps://iquilezles.org/articles/texture\nhttps://en.wikipedia.org/wiki/Texture_filtering\n\nflat\nhttps://www.shadertoy.com/view/mdKfRR\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n*/\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 70, 70, 355], [356, 356, 395, 395, 460], [463, 561, 596, 596, 754], [755, 755, 791, 791, 1076]], "test": "untested"}
{"id": "DtKyzh", "name": "colorful blur", "author": "zyc", "description": "colorful blur", "tags": ["blur"], "likes": 8, "viewed": 196, "published": 3, "date": "1700145223", "time_retrieved": "2024-07-30T17:22:16.887967", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define blurIntensity 8.0\n#define numIntensity 0.8\n#define colorIntensity 0.8\n#define lightIns 0.05*5.0\n#define horzR 0.2\n#define vertR 0.2\n\nfloat getProgress(float t)\n{\n    return fract(0.3*t);\n}", "buffer_b_code": "\nvec4 neighborColor(int i, vec2 uv, float timeIntensity){\n    // float horzR = 20.;\n    vec2 screenParams = iResolution.xy * 0.5;\n\tfloat blurSize=horzR * timeIntensity * numIntensity;\n\tvec2 unit= blurSize / screenParams.xy;\n\tvec2 uv1 = uv + unit * vec2(i, 0.);\n\tvec2 uv2 = uv - unit * vec2(i, 0.);\n\tvec4 result = texture(iChannel0, uv1)\n\t\t\t\t+ texture(iChannel0, uv2);\n\tif (i < 2) {\n\t\tresult *= .19;\n\t}\n\telse if (i < 3) {\n\t\tresult *= .17;\n\t}\n\telse if (i < 4) {\n\t\tresult *= .15;\n\t}\n\telse if (i < 5) {\n\t\tresult *= .13;\n\t}\n\telse if (i < 6) {\n\t\tresult *= .11;\n\t}\n\telse if (i < 7) {\n\t\tresult *= .08;\n\t}\n\telse if (i < 8) {\n\t\tresult *= .05;\n\t}\n\telse if (i < 9) {\n\t\tresult *= .02;\n\t}\n\treturn result;\n}\n\nfloat neighborWeight(int i) {\n\tfloat result = 0.;\n\tif (i < 2) {\n\t\tresult = .19 * 2.;\n\t}\n\telse if (i < 3) {\n\t\tresult = .17 * 2.;\n\t}\n\telse if (i < 4) {\n\t\tresult = .15 * 2.;\n\t}\n\telse if (i < 5) {\n\t\tresult = .13 * 2.;\n\t}\n\telse if (i < 6) {\n\t\tresult = .11 * 2.;\n\t}\n\telse if (i < 7) {\n\t\tresult = .08 * 2.;\n\t}\n\telse if (i < 8) {\n\t\tresult = .05 * 2.;\n\t}\n\telse if (i < 9) {\n\t\tresult = .02 * 2.;\n\t}\n\treturn result * 10.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float timeIntensity = 1.0 - getProgress(iTime);\n    \n    float half_gaussian_weight[9];\n\thalf_gaussian_weight[0]=.2;//0.137401;\n\thalf_gaussian_weight[1]=.19;//0.125794;\n\thalf_gaussian_weight[2]=.17;//0.106483;\n\thalf_gaussian_weight[3]=.15;//0.080657;\n\thalf_gaussian_weight[4]=.13;//0.054670;\n\thalf_gaussian_weight[5]=.11;//0.033159;\n\thalf_gaussian_weight[6]=.08;//0.017997;\n\thalf_gaussian_weight[7]=.05;//0.008741;\n\thalf_gaussian_weight[8]=.02;//0.003799;\n\tvec4 curColor=texture(iChannel0,uv);\n\tvec4 resultColor=vec4(0.);\n    \n    vec4 centerPixel=curColor*half_gaussian_weight[0];\n\tresultColor += centerPixel;\n\tfloat weight=half_gaussian_weight[0] * mix(10., 1., timeIntensity * numIntensity);\n\tfloat i = 1.;\n\tfloat blurSize=horzR;\n\tfor(int i=1;i<=8;i++){\n\n\t\tresultColor += neighborColor(i, uv, timeIntensity);\n\t\tweight += neighborWeight(i);\n\t}\n    resultColor /= weight / 10.; \n    \n    fragColor = resultColor;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvec4 neighborColor(int i, vec2 uv, float timeIntensity){\n    // float vertR = 20.;\n\tfloat blurSize=vertR * timeIntensity * numIntensity;\n    vec2 screenParams = iResolution.xy * 0.5;\n\tvec2 unit= blurSize / screenParams.xy;\n\tvec2 uv1 = uv + unit * vec2(0., i);\n\tvec2 uv2 = uv - unit * vec2(0., i);\n\tvec4 result = texture(iChannel0, uv1)\n\t\t\t\t+ texture(iChannel0, uv2);\n\tif (i < 2) {\n\t\tresult *= .19;\n\t}\n\telse if (i < 3) {\n\t\tresult *= .17;\n\t}\n\telse if (i < 4) {\n\t\tresult *= .15;\n\t}\n\telse if (i < 5) {\n\t\tresult *= .13;\n\t}\n\telse if (i < 6) {\n\t\tresult *= .11;\n\t}\n\telse if (i < 7) {\n\t\tresult *= .08;\n\t}\n\telse if (i < 8) {\n\t\tresult *= .05;\n\t}\n\telse if (i < 9) {\n\t\tresult *= .02;\n\t}\n\treturn result;\n}\n\nfloat neighborWeight(int i) {\n\tfloat result = 0.;\n\tif (i < 2) {\n\t\tresult = .19 * 2.;\n\t}\n\telse if (i < 3) {\n\t\tresult = .17 * 2.;\n\t}\n\telse if (i < 4) {\n\t\tresult = .15 * 2.;\n\t}\n\telse if (i < 5) {\n\t\tresult = .13 * 2.;\n\t}\n\telse if (i < 6) {\n\t\tresult = .11 * 2.;\n\t}\n\telse if (i < 7) {\n\t\tresult = .08 * 2.;\n\t}\n\telse if (i < 8) {\n\t\tresult = .05 * 2.;\n\t}\n\telse if (i < 9) {\n\t\tresult = .02 * 2.;\n\t}\n\treturn result * 10.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 uv = fragCoord / iResolution.xy;\n    float timeIntensity = 1.0 - getProgress(iTime);\n    \n    float half_gaussian_weight[9];\n\thalf_gaussian_weight[0]=.2;//0.137401;\n\thalf_gaussian_weight[1]=.19;//0.125794;\n\thalf_gaussian_weight[2]=.17;//0.106483;\n\thalf_gaussian_weight[3]=.15;//0.080657;\n\thalf_gaussian_weight[4]=.13;//0.054670;\n\thalf_gaussian_weight[5]=.11;//0.033159;\n\thalf_gaussian_weight[6]=.08;//0.017997;\n\thalf_gaussian_weight[7]=.05;//0.008741;\n\thalf_gaussian_weight[8]=.02;//0.003799;\n\tvec4 curColor=texture(iChannel0,uv);\n\tvec4 resultColor=vec4(0.);\n    \n    \n    vec4 centerPixel=curColor*half_gaussian_weight[0];\n\tresultColor += centerPixel;\n\tfloat weight=half_gaussian_weight[0] * mix(10., 1., timeIntensity * numIntensity);\n\tfloat i = 1.;\n\tfloat blurSize=vertR;\n\tfor(int i=1;i<=8;i++){\n\n\t\tresultColor += neighborColor(i, uv, timeIntensity);\n\t\tweight += neighborWeight(i);\n\t}\n\tresultColor /= weight / 10.; \n    \n    fragColor = resultColor;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926\n\n\nvec2 rot(float angle, vec2 uv)\n{\n    float theta = angle * PI / 180.;\n    mat2 r = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    return uv * r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float timeIntensity = max(0.0, 1.0 - getProgress(iTime));\n    \n    \n    float amount = 40.0;\n    amount += 0.9987*500.0;\n    vec4 curColor = texture(iChannel0, uv);\n\tvec2 screenSize = iResolution.xy;\n\tfloat rescale = max(screenSize.x, screenSize.y) / 1280.;\n\tscreenSize /= rescale;\n\tvec2 unit = 1. / screenSize * .5;\n    vec4 resultColor=curColor; \n\tvec3 maxColor = vec3(0.);//curColor.rgb;\n\tvec3 sumWeight = vec3(0.);//pow(curColor.rgb, vec3(9.));\n\tvec3 sumColor = resultColor.rgb * sumWeight;\n    for (float i = -9.; i <= 9.; i += .75) {\n\t\tfor (float j = -9.; j <= 9.; j += .75) {\n\t\t\tvec2 tempVec = vec2(i, j);\n            \n            if (dot(tempVec, tempVec) >= 50.) continue;\n            vec3 factor = vec3(1.);\n            vec2 newUv = vec2(i + 9., j + 9.) / 18.;\n            float alpha = 1.;\n            vec2 tempUv = uv + blurIntensity * timeIntensity * vec2(i, j) * unit;\n            vec2 tempUv1 = uv + blurIntensity * timeIntensity * vec2(i, j) * unit * 1.7;\n            vec4 blingColor = texture(iChannel1, tempUv1);\n            factor = mix(vec3(1.), blingColor.rgb, pow(blurIntensity / 10., 1.) * colorIntensity * (1. - pow(1. - timeIntensity, 3.)));\n\t\t\tvec3 tempColor = texture(iChannel0, tempUv).rgb;\n\t\t\tmaxColor = max(maxColor, tempColor * factor);\n\t\t\tsumColor += tempColor * (pow(tempColor * factor, vec3(9.)) * amount + .4);\n\t\t\tsumWeight+= pow(tempColor * factor, vec3(9.)) * amount + .4;\n       }\n    }\n    \n    \n    for (float i = 0.; i <= 360.; i += 1.) {\n        vec2 tempVec = rot(i, vec2(7., 0.));\n        vec3 factor = vec3(1.);\n        float alpha = 1.;\n        vec2 tempUv = uv + blurIntensity * timeIntensity * tempVec * unit;\n        vec2 tempUv1 = uv + blurIntensity * timeIntensity * tempVec * unit * 1.7;\n        vec4 blingColor = texture(iChannel1, tempUv1);\n        factor = mix(vec3(1.), blingColor.rgb, pow(blurIntensity / 10., 1.) * colorIntensity * (1. - pow(1. - timeIntensity, 3.)));\n        vec3 tempColor = texture(iChannel0, tempUv).rgb;\n        maxColor = max(maxColor, tempColor * factor);\n        sumColor += tempColor * (pow(tempColor * factor, vec3(9.)) * amount + .4);\n\t\tsumWeight+= pow(tempColor * factor, vec3(9.)) * amount + .4;\n    }\n    \n    \n    resultColor.rgb = clamp(sumColor / sumWeight, 0., 1.);\n\tresultColor.rgb = mix(resultColor.rgb, maxColor, clamp(resultColor.rgb * lightIns, 0., 1.));\n    fragColor = resultColor;\n    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "cl3yDN", "name": "3D Diffusion Automata", "author": "Shane", "description": "3D automata moving in a random diffusive fashion.", "tags": ["grid", "random", "automata", "cell", "swap", "walk", "traversal"], "likes": 80, "viewed": 1086, "published": 3, "date": "1700142229", "time_retrieved": "2024-07-30T17:22:18.260298", "image_code": "/*\n\n    Random Diffusion Automata \n    -------------------------\n    \n    Fabrice put together a pixelized diffusion example that was based on a \n    moving image he saw on X.com (both links are below), which was cool and \n    concise, but omitted smooth cell transitions. The source image contained \n    some neat sliding motion based on occupied cell elements moving to empty \n    ones -- Similar to the motion in a sliding puzzle. This is standard \n    stuff, so there are plenty of demonstrations on the internet, and even a \n    few related examples on here, but they tend to be long winded -- my own \n    efforts included...\n    \n    Digressing, SnoopethDuckDuck rearranged Fabrice's example and added the \n    necessary sliding element that gives it that smooth animated appearance.\n    However, he managed to do it using very little code and just one texture \n    channel, which was really cleverly done. After sneaking a peak at his \n    solution, then looking at my own obfuscated mess, I realized that I'd \n    really overthought it... :)\n    \n    Anyway, I'm very greatful for the aforementioned postings, and this is \n    just a 3D extension of that. I used a different template, so the variables \n    and functions don't quite match up to Fabrice and SnoopethDuckDuck's, but \n    it's basically the same thing. There is also an unlisted accompanying \n    2D example with some additional texture-based cell indexing, plus some \n    explanations for anyone interested in this kind of thing.\n    \n    I didn't put a great deal of effort into the design, as I simply wanted \n    to get one of these on the board, as they say. 3D cell swap examples are \n    not common on Shadertoy, but I'm not the first to post one of these. \n    Coposuke posted a beautiful example a couple of years ago. I've posted \n    the link below, for anyone who hasn't seen it. \n    \n    \n    // Largely based on the following:\n    \n    // Fabrice and SnoopethDuckDuck's combined logic, which is\n    // pretty difficult to compete with. It's a really nicely \n    // written example. If anyone does manage to outlogic this \n    // logic, please let me know. :) \n    Cell Swap Automata - SnoopethDuckDuck\n    https://www.shadertoy.com/view/DtccR8\n    \n    // This is inspired by Fabrice's shader\n    Shuffle gradient - random walk 3 - FabriceNeyret2 \n    https://www.shadertoy.com/view/dtSfRh\n    //\n    In turn, based on this X.com post:\n    https://twitter.com/junkiyoshi/status/1697571241513910691\n    \n    // This is my simple 2D version, which is an old version of Fabrice's\n    // that I completely rearranged to incorporate SnoopethDuckDuck's\n    // smooth cell swapping code.\n    Random Diffusion Automata - Shane\n    https://www.shadertoy.com/view/mtdyDH\n    \n    Other examples:\n    \n    // Beautifully done. I haven't had time to look it over, but I can \n    // see that the BRDF is really nicely done. My example also features \n    // BRDF patterned cubes, but that's purely coincidental.\n    High-Collar Cubes - coposuke\n    https://www.shadertoy.com/view/WldBRH\n    \n*/\n\n \n\n//////////////////////////////////\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Alternate gold only color.\n//#define GOLD\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n \n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n\n    /*\n    vec3 idF = step(0., p)*2. - 1.;\n    vec3 faceID = (idF + 1.)/2. + vec3(0, 2, 4);\n    */    \n    \n    // Integer version.\n    ivec3 idF = ivec3(step(0., p))*2 - 1;\n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    return f.x>.5? vec4(p.yz/p.x/2. + .5, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y/2. + .5, idF.y, faceID.y) : \n                   vec4(p.xy/p.z/2. + .5, idF.z, faceID.z); \n}\n\n// IQ's 3D signed box formula.\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n    p = abs(p) - b + sf;\n    return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n \n////////////////////\n\n// Globals for the cell values, moving direction vector and cell ID.\nvec4 gCell;\nvec3 gTmDir;\nvec3 gID3;\n\nvec3 getAutomata(vec3 p, inout vec3 sc){\n\n    \n    // Obtaining the four object (particle) values for this cell.\n    // Channel values:\n    // X: Original cell position ID (for colors, etc). Needs converting to vec2.\n    // Y: Direction (clockwise from the left): Left, up, right, down (0, 1, 2, 3).\n    // Z: Transfer time. Starting (0), ending (1), or somewhere between ([0, 1]).\n    // W: Inactive or active status (0 or 1) -- Empty or not.\n    //\n    // Using \"floor(p)\" to avoid artifacts at certain resolutions.\n    //vec4 cell = texelFetch(iChannel0, ivec2(floor(p/sc)), 0);\n    \n    //vec4 cell = tMap(iChannel0, mod(floor(p/sc), wrap));\n    \n    vec2 uv = convertCoord(mod(floor(p/sc), wrap));//mod(floor(p/sc), wrap)\n    vec4 cell = texelFetch(iChannel0, ivec2(uv), 0);\n\n    // Inactive to active transfer (cell.z), or active to inactive transfer.\n    // Inactive moves forward (cell.z), active are losing a particle, so move in the\n    // opposite direction (1. - cell.z).\n    //\n    // Smoothly transition from one cell to the next. It's a minor distinction, but\n    // an asymmetric easing process needs to be applied prior to mixing.\n    cell.z = smoothstep(.15, .85, cell.z); \n    float tm = mix(cell.z, 1. - cell.z, cell.w);\n     \n    \n    \n    // Cell coordinate ID. Converting from stored float to vec2.\n    //vec3 iq = vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap)));\n    vec3 iq = mod(vec3(cell.x, floor(cell.x/wrap), floor(cell.x/(wrap*wrap))), wrap);\n\n\n    // Local cell coordinates.\n    vec3 q = mod(p, sc) -.5*sc; \n    \n    // Cell direction.\n    vec3 dir = indexToDir(cell.y);\n    \n    \n    gCell = cell;\n    \n \n    // Size.\n    //float rndSz = hash21(iq + .11);\n    //float obj = sBoxS(q - tm*dir, vec2(.4), .2);\n    //float obj = length(q - tm*dir) - (.4 - .0*rndSz); // Etc.\n    \n    gTmDir = tm*dir*sc;\n    \n    //q -= gTmDir;\n    \n    gID3 = iq*sc;\n    \n        \n    return q;//vec4(q, iq*sc);\n \n}\n\n\n///////////////////\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gP;\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n\n  \n    // Scale. This will include two blocks, each 8 cells deep, so we'll move the wall\n    // forward by half a unit to obscure the second block.\n    vec3 sc = vec3(1./16.);\n    \n    \n    // Local coordinates and ID.\n    vec3 p = getAutomata(q3, sc);\n    vec3 id3 = gID3;\n \n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - (p))/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    //gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n   \n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    sc -= .005;//*(hash21(id)*.9 + .1);\n    \n  \n    // Move the box.\n    p -= gTmDir;\n    \n\n    // Rendering the box. You could do some cool things here, but I've\n    // kept things simple.\n    float d = sBoxS(p, sc/2., .05*sc.x);\n    \n    //float dS = length(p) - sc.x/2.;\n    //d = mix(d, dS, .125);\n    \n\n    \n    \n    // This is a bit of a hack to get rid of fuzzy shadows. Basically, \n    // don't render inactive cells that are technically out of cell range.\n    if(gCell.z==1. && gCell.w == 0.) d = 1e5;\n    \n   \n\n    // Debug: Getting rid of some boxes.\n    //if(hash31(id3)<.5) d  = 1e5;\n    \n    \n    // Only include one block level (16 z-positions deep), just in front of the wall\n    if(floor(q3.z) != -1.) d = 1e5; \n    \n    // Excluding XY sheets behind this Z depth.\n    //if(floor(id3.z/sc.z)>3.) d = 1e5;\n\n    // Saving the box dimensions and local coordinates.\n    gSc = sc;//vec3(sc.xy, h);\n    gP = p;\n    \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id3);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID, svGID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor, or wall, depending on your perspective. Kind of redundant,\n    // since you can't see it, but it's there, just in case.\n    float fl = -p.z - .5;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n    /*\n    // Putting the boxes in a cage... No. Dumb idea, but I had to try. :)\n    vec3 dC = vec3(1e5);\n    vec3 sc = vec3(1./16.);\n    vec3 q = mod(p + sc/2., sc) -.5*sc; \n    dC.x = sBoxS(q.xy, sc.xy*.05, .025*sc.x);\n    dC.y = sBoxS(q.yz, sc.yz*.05, .025*sc.x);\n    dC.z = sBoxS(q.xz, sc.xz*.05, .025*sc.x);\n    float dR = min(min(dC.x, dC.y), dC.z);\n    \n    fl = min(fl, dR);\n    fl = max(fl, -(p.z + 1. + .05*gSc.z));\n    */\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;// hash31(ro + rd)*.15;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n\n    vec3 id3 = svGID.yzw;\n    vec4 c4 = cubeMap(p);\n    vec2 tuv = c4.xy;\n    float faceID = c4.w;\n\n    vec2 oTuv = tuv;\n\n    vec2 scl = vec2(1);\n    vec2 oScl = scl;\n\n\n    // The two distance field values (they overlap) and corresponding\n    // lines patterns.\n    vec4 d = Truchet(tuv, id3, faceID, scl);\n\n    // Edge width and smoothing factor.\n    float ew2 = .03*oScl.x;\n    float sf2 = .02*oScl.x;\n\n    // Saving the original cube color.\n    float objCol = (.25);\n\n    // A little extra thickness for the edges.\n    d.xy -= ew2*2.;\n\n    // Distance field shading.\n    vec2 sh = max(-d.xy/oScl.x*4., 0.);\n    sh = smoothstep(0., .65, sh);\n\n    // Rendering the two overlapping distance fields and line patterns.\n    for(int i = 0; i<2; i++){\n\n         // Line pattern.\n         float lnCol = mix(.5, .35, 1. - smoothstep(0., sf2, d[i + 2]));\n\n         // Subtle highlighting.\n         lnCol *= .25 + sh[i]*.75;\n\n         // Faux AO, dard edges and pattern.\n         objCol = mix(objCol, 0., (1. - smoothstep(0., sf2*4., d[i]))*.5);\n         objCol = mix(objCol, 0., 1. - smoothstep(0., sf2, d[i]));\n         objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n    }  \n    \n    return objCol;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. \n// There's a six tap version (samples taken from either side of each axis), but this \n// works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the \n    // aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n \n    vec4 b4;\n    for(int i = min(iFrame, 0); i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of \n    //cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some \n    // kind of orthogonal space fix using the Gram-Schmidt process, or something to that \n    // effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more \n    // bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n///////////////////////////\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n} \n*/\n\n//////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(iTime/32., .036, -1); // \"Look At\" position.\n\tvec3 ro = lk + vec3(-.04, .12, -.3);  // Camera position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(1, .38, -.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    // Rough fish-eye lens.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.125, 0.))));\n    \n    // Evening the camera up a bit.\n    rd.xy *= rot2(-.02);\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */  \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec3 svP = gP;\n    \n    // Saving the moving direction position vector.\n    vec3 svDir = gTmDir;\n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n        \n        vec3 svTx;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n             vec3 txP = svP;//vec3(svP, sp.z);\n            //txP.xy += svDir;\n            \n            vec3 id3 = svGID.yzw;\n            \n            // Random coloring using IQ's short versatile palette formula.\n            //float rnd = hash31(id3 + .34);\n            //vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(0, 1, 2) + .8);\n            \n            \n            // Coloring the individual blocks with the saved ID.\n            vec2 id2 = convertCoord(floor(id3/svSc.x));\n            vec3 col1 = getTex(iChannel1, id2*svSc.x/2.);\n            col1 = smoothstep(.0, .5, col1);\n            \n            // More coloring.\n            vec3 col2 = getTex(iChannel2, id2*svSc.x/2.);\n            col2 = smoothstep(-.1, .35, col2);\n            \n            // Grunge texturing.\n            vec3 tx1 = tex3D(iChannel1, (id3 + txP)*2., sn);\n            vec3 tx2 = tex3D(iChannel1, (id3 + txP)*4., sn);\n            tx1 = smoothstep(.0, .5, tx1);\n             \n            // Random colors.\n            objCol = (hash31(id3 + .22)<.333)? col2 : col1;\n            \n            // Interwoven checkered colors.\n            //vec3 id = floor(id3/svSc);\n            //if(mod(id.x + id.y + id.z, 2.)<.5) objCol = objCol.zyx;\n\n                      \n            // Texturing the colored boxes and adding some sepia.\n            objCol *= vec3(1.5, 1.25, 1)*(tx2*3. + .25);\n \n            \n            #ifdef GOLD \n            // Alternate gold coloring.\n            objCol = vec3(.3 + hash31(id3 + .51)*.4);\n            if(hash31(id3 + .21)<1.5)\n            objCol = .5 + .45*cos(6.2831853*hash31(id3 + .32)/8. + vec3(0, 1.2, 2) + .25);\n            objCol *= vec3(1, 1.1, 1.2);\n            //if(hash31(id3 + .26)<.5) objCol = mix(objCol, objCol.zyx, .75);\n            objCol *= (tx2*3. + .25);\n            #endif\n             \n            //////////////////////\n            // Rendering a cliche art deco multiscale Truchet design onto the cube faces.\n            vec4 c4 = cubeMap(svP);\n            vec2 tuv = c4.xy;\n            float faceID = c4.w;\n\n            vec2 oTuv = tuv;\n\n            vec2 scl = vec2(1);\n            vec2 oScl = scl;\n\n            \n            // The two distance field values (they overlap) and corresponding\n            // lines patterns.\n            vec4 d = Truchet(tuv, id3, faceID, scl);\n\n            // Edge width and smoothing factor.\n            float ew2 = .03*oScl.x;\n            float sf2 = .01*oScl.x;\n            \n            \n            // Evening up the tone, just a little.\n            objCol = mix(objCol, objCol/(1./3. + dot(objCol, vec3(.299, .587, .114))), .5);\n\n            // Saving the original cube color.\n            vec3 svCol = objCol;\n            objCol /= 2.; // Darkening the background.\n\n            // A little extra thickness for the edges.\n            d.xy -= ew2*2.;\n            \n            // Distance field shading.\n            vec2 sh = max(-d.xy/oScl.x*4., 0.);\n            sh = smoothstep(0., .65, sh);\n\n            // Rendering the two overlapping distance fields and line patterns.\n            for(int i = 0; i<2; i++){\n\n                 // Line pattern.\n                 vec3 lnCol = svCol*1.;\n                 lnCol = mix(lnCol, svCol*.25, 1. - smoothstep(0., sf2, d[i + 2]));\n                 \n                 // Subtle highlighting.\n                 lnCol *= .75 + sh[i]*.5;\n\n                 // Faux AO, dard edges and pattern.\n                 objCol = mix(objCol, vec3(0), (1. - smoothstep(0., sf2*8., d[i]))*.5);\n                 objCol = mix(objCol, svCol*.125, 1. - smoothstep(0., sf2, d[i]));\n                 objCol = mix(objCol, lnCol, 1. - smoothstep(0., sf2, d[i] + ew2));\n\n            }\n            \n            \n            // Bump map the above pattern. Not as nice as displacement mapping\n            // in the distance function, but way effective, and way cheaper.\n            // The bump is subtle, but it's there. Too much can be overpowering.\n            sn = doBumpMap(svP, sn, .003);\n              \n\n            // Save the texture postion.\n            svTx = (id3 + txP)*2.;\n \n        }\n        else {        \n            \n            // The dark wall in the background. Hidden behind the boxes.\n            vec3 tx = tex3D(iChannel1, sp*4., sn);\n            objCol = vec3(1.5, 1.25, 1)*(tx*3. + .05)/2.;\n             \n            // Save the texture postion.\n            svTx = sp*4.;\n        }\n        \n        // Adding a purple tinge.\n        //objCol = mix(objCol, objCol*vec3(2, 1, .5).yzx, .5);\n        \n        \n        // Texture based bump mapping. You'd need to uncomment the\n        // bump map function first.\n        //sn = texBump(iChannel1, svTx, sn, .001);///(1. + t/FAR)\n        \n        \n        \n\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n    \t\n    \t// Diffuse lighting.\n\t    //float diff = max( dot(sn, ld), 0.);\n        \n        float roughness = min(dot(objCol, vec3(.299, .587, .114))*.75 + .15, 1.);\n        float reflectance = .5;\n        float matType = 1.;\n            \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel3, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        float spF = 2.; //svObjID<.5? 4. : 2.;\n        objCol = objCol + objCol*speR*rTx*spF;\n         \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float am = pow(length(sin(sn*2.)*.5 + .5)/sqrt(3.), 2.)*1.75; // Studio.\n        float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); // Outdoor.\n        //float am = clamp(.5 - .35*(rd.x - rd.y), 0., 1.);        \n\n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(objCol, sn, ld, -rd, matType, roughness, reflectance);\n \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (objCol*am*(sh*.5 + .5) + ct*(sh));        \n        \n        // Ambient occlusion and attenuation.\n        col *= ao*atten;\n          \n           \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(1), smoothstep(.25, .9, t/FAR));\n \n    // Very basic Reinhard tone mapping.\n    col = col/(1. + col/3.);\n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}\n\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// A cube of dimension 8 and a square of dimension 64 will\n// each require the same number of pixels for storage.\nconst float wrap = 8.; // (2^3)*(2^3)*(2^3) = 2^12.\nconst float cubeMapRes = 64.; // (2^6)*(2^6) = 2^12.\n\n/////////////////////\n/////////////////////\n\n// I might replace this with the Murmurhash functions, but I wanted\n// to try these out first, since I like the simplicity, and they're\n// supposed to be fast. Anyway, you can read all about it, here:\n\n// A Mind Forever Programming - Random Floats in GLSL 330\n// Author: Lee C\n// https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n \nuint hash( uint x ){\n    x += ( x << 10u ); x ^= ( x >>  6u );\n    x += ( x <<  3u ); x ^= ( x >> 11u );\n    x += ( x << 15u ); return x;\n}\n\nuint hash( uvec2 v ){ return hash( v.x ^ hash(v.y) ); }\nuint hash( uvec3 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ); }\nuint hash( uvec4 v ){ return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\nfloat hash41( vec4 f ){\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash31( vec3 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\nfloat hash21( vec2 f ){\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.;\n}\n\n//////////////////////\n\n// Converting pixels on a 2D square area to their equivalent \n// 3D positions and back again: For anyone who finds this confusing,\n// I've explained the simple process below.\n\n\nvec3 convertCoord(vec2 p){\n\n    // Convert the 2D coordinate to its equivalent 3D coordinates.\n    \n    // 2D coordinate -- Wrapping isn't mandatory, but this is a wrapped example.\n    p = mod(floor(p), cubeMapRes); \n    // Converting the above 2D coordinate to its linear representation.\n    float i = p.x + p.y*cubeMapRes;\n\n    // Converting the linear number above to 3D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec3(i, floor(i/wrap), floor(i/(wrap*wrap))), wrap);\n}\n\nvec2 convertCoord(vec3 p){\n\n    // Convert the 3D coordinates to its equivalent 2D coordinates.\n    \n    // Wrapping the 3D coordinates first -- Only for this example.\n    p = mod(floor(p), wrap);\n    // Converting the above 3D coordinate to its linear representation.\n    float i = p.x + (p.y + p.z*wrap)*wrap;\n    // Converting the linear number above to 2D coordinates. The wrapping is\n    // overkill here, since things have been arranged to fit perfectly, \n    // but it's there anyway.\n    return mod(vec2(i, floor(i/cubeMapRes)), cubeMapRes);\n}\n\n\n\n/*\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n*/\n\n/* \n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    //f.xy = mod(f.xy, 1.);\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// IQ's \"uint\" based uvec4 to float hash.\nfloat hash41(vec4 f){\n\n    uvec4 p = floatBitsToUint(f);\n    uint h32 = 19u*p.x + 47u*p.y + 101u*p.z + 131u*p.w + 173u;\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n*/\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n// Six cube face directions.\nconst vec3[6] e = vec3[6](vec3(-1, 0, 0), vec3(1, 0, 0), vec3(0, -1, 0), vec3(0, 1, 0),\n                          vec3(0, 0, -1), vec3(0, 0, 1));\n \nvec3 indexToDir(float i) {\n   // Converts the indices 0 through to 5 to one of the direction above.\n   return e[int(i)]; \n}\n\nfloat dirToIndex(vec3 p) {\n    \n    // Converts the left, right, down, up, backward, forward \n    // vectors to 0, 1, 2, 3,  4 or 5 respectively.\n    for(int i = 0; i<6; i++){\n        if(p == e[i]) return float(i);\n    }\n    \n    // Redundant, because the above will always return... but I'm paranoid, \n    // so if one day it doesn't, this will be waiting. :D\n    return 0.;\n}\n\nfloat rndDirIndex(vec4 ut){\n    // Returns a random number based on 2D position and time.\n    return mod(floor(96.*hash41(ut)), 6.);\n}\n\nfloat rndDirIndex(vec4 ut, float maxM){\n    // Returns a random number based on 2D position and time,\n    // but with restrictions.\n    return mod(floor(72.*hash41(ut)), maxM);\n}\n\nvec3 rndDir(vec4 u) {\n    // Returns a random direction.\n    return indexToDir(rndDirIndex(u));\n}\n\nvec3 rndDir(vec4 u, float maxM) {\n    // Returns a random direction with restrictions.\n    return indexToDir(rndDirIndex(u, maxM));\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*PI);\n  \n}\n////////////////////\n\n// An art deco multiscale Truchet pattern. Made up on the spot, \n// but it seems to work.\nvec4 Truchet(vec2 p, vec3 cellID, float faceID, inout vec2 scl){\n      \n\n     // Save coordinates.\n     vec2 oP = p;\n\n\n     // Scaling, ID, and local coordinates.\n     vec2 oScl = scl;\n     vec2 id2 = floor(p/scl) + .5;\n     p -= (id2)*scl;//mod(tuv, scl) - scl/2.;\n     \n     // Unique face identifier.\n     vec3 id3 = cellID + vec3(id2/12., faceID/12.);\n\n     // Random subdivision.\n     int divN = 0;\n     if(hash31(id3 + .09)<.5){ \n         scl /= 2.; \n         p = oP;\n         id2 = floor(p/scl) + .5;\n         //p = mod(p, scl) - scl/2.;\n         p -= (id2)*scl;\n         \n         id3 = cellID + vec3(id2/12., faceID/12.);\n         \n         divN++; // Subdivision number.\n     }\n\n\n     \n     // Random coordinate rotation.\n     //if(hash31(id3 + .42)<.5) p = rot2(3.14159/2.*floor(hash21(id3 + .01)*32.))*p;\n     if(hash31(id3 + .42)<.5) p = p.yx*vec2(-1, 1);\n\n     // The distance field holder. The pattern involves rending overlapping,\n     // so requires to place holders.\n     vec2 dd = vec2(1e5);\n     \n     // Triangle experiment for next time.\n     //vec2 rTuv = rot2(3.14159/4.)*tuv;\n     //dd.x = (tuv.x + tuv.y)*.7071;\n     //dd.y = -(tuv.x + tuv.y)*.7071;\n     //dd = max(dd, max(abs(tuv.x), abs(tuv.y)) - scl.x/2.);\n     \n     // Cell bounds.\n     //float bx = sBoxS(p, scl/2. - .005, 0.);\n\n     \n     if(hash31(id3 + .12)<.65){\n     \n         // Random arcs, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .19)<.65){\n             dd.x = length(p - scl/2.);\n             dd.x = abs(dd.x - scl.x/2.);\n         }\n         else {\n             dd.x = length(p - vec2(1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(0, 1)*scl/2.));\n         }\n\n         if(hash31(id3 + .21)<.65){\n             dd.y = length(p + scl/2.);\n             dd.y = abs(dd.y - scl.y/2.);\n         }\n         else {\n             dd.y = length(p - vec2(-1, 0)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, -1)*scl/2.));\n             \n         }  \n\n     }\n     else {\n     \n         // Random lines, interspersed with random points that \n         // break up the pattern.\n\n         if(hash31(id3 + .13)<.65){\n             dd.x = abs(p.y);\n         }\n         else {\n             dd.x = length(p - vec2(-1, 0)*scl/2.);\n             dd.x = min(dd.x, length(p - vec2(1, 0)*scl/2.));\n         }\n\n         if(hash31(id3 + .14)<.65){\n             dd.y = abs(p.x);\n         }\n         else {\n             dd.y = length(p - vec2(0, -1)*scl/2.);\n             dd.y = min(dd.y, length(p - vec2(0, 1)*scl/2.));\n         }\n     }\n\n\n     // Line pattern.\n     float lNum = 12./oScl.x;\n     float offs = divN==0? .5 : .5; //  Different for different scales.\n     vec2 pat = (abs(fract(dd*lNum + offs) - .5) - .2)/lNum;\n     //vec2 pat = vec2(1e5);//\n\n     // If not subdivided, split the pattern and move it to match the\n     // position of the subdivided one. It's one of many standard\n     // multiscale pattern moves.\n     if(divN == 0) dd = abs(dd - .25*scl.x);\n     //dd = abs(dd + .125) - .125;\n    \n     // Apply some scale based width.\n     dd.xy -= .24/2.*oScl;\n     \n     \n     \n     // Randomize the rendering order to mix things up more.\n     if(hash31(id3 + .15)<.5){ dd = dd.yx; pat = pat.yx; }\n     \n     //dd = max(dd, sBoxS(tuv, scl/2. - .005, 0.));\n \n\n     // Return the overlapping Truchet pattern distances \n     // and the lines pattern distances.\n     return vec4(dd, pat);  \n\n}\n\n", "buffer_a_code": "\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n    // Reject any pixels outside the wrapping area to lessen the GPU load.\n    if(fragCoord.x>cubeMapRes || fragCoord.y>cubeMapRes) discard;\n\n\n    // Wrapped coordinates... Kind of redundant here, since we're rejecting\n    // pixels outside this area range, but it's good practice.\n    vec2 u = mod(fragCoord, cubeMapRes);\n    vec4 col;\n    \n    // Convert the 2D canvase coordinates to 3D coordinates.\n    vec3 p = convertCoord(u);\n\n    \n    if(textureSize(iChannel0, 0).x<2 || iFrame==0){ // || iMouse.z>0.\n    \n        // Initial setup conditions:\n        \n        // Initial cell index: This is a 2D position (in float form), which \n        // allows for diffusion of pictures. However, any initial cell \n        // identifier (like a random number) can be put here.\n        col.x = p.x + p.y*wrap + p.z*wrap*wrap;\n        //col.x = p.x + (p.y + p.z*wrap)*wrap;\n        //col.x = floor(u.x/4) + floor(u.y/4.)*iResolution.y;\n        // Direction index. Clockwise from the left. 0,1,2,3.\n        col.y = 0.; // Any number will do.\n        // When conditions are met, the cell object will transfer from one\n        // cell to the next via an interpolating mechanism that ranges\n        // between zero and one.\n        //\n        // Motion timer [0,1] range. Thanks, SnoopethDuckDuck.\n        col.z = 1.; // Put it into \"accepting new transfer\" mode.\n        // Initial random active/inactive threshold. It could be pattern\n        // based, random, or whatever you wish. This one is obviously random.\n        col.w = step(.4, hash31(p + .11)); // Inactive or active: 0 or 1.\n        \n           \n    } \n    else {\n    \n        // Obtain the current stored cell states.\n        col = texelFetch(iChannel0, ivec2(u), 0);  \n        \n        // Obtain the current stored cell states.\n        //vec2 uv = convertCoord(p);\n        //col = texelFetch(iChannel0, ivec2(uv), 0);  \n\n        \n        // I wanted the cells to wrap along the XY plane, but at the same \n        // time be clamped to the near and far Z walls. The solution is very\n        // simple... but still took me an hour. :) In the XY directions, let\n        // the cells objects move in all six directions. However, if they hit \n        // the front or back Z positions, don't allow them to move in the Z \n        // direction... OMG, that was so obvious. :D\n        float maxDirections = (p.z<0. || p.z>=wrap)? 4. : 6.;\n        \n        // Obtain the random direction for this pixel at this point in time.\n        vec3 dir = rndDir(vec4(p, iFrame), maxDirections); \n  \n        \n        // Use the random direction above to move to the neighboring cell in that \n        // direction, then obtain the random direction for that cell... That was a \n        // bit wordy, but a lot of this stuff depends on understanding it.\n        //\n        vec3 nP = p + dir; // Neighboring cell position.\n        // Neighboring cell movement needs to be restricted along the far Z planes also.\n        if(nP.z<0. || nP.z>=wrap) maxDirections = 4.;\n        // The random direction value in the neighboring cell... Not the direction\n        // to the neighboring cell, which is a different entity.\n        vec3 dirNgbr = rndDir(vec4(mod(nP, wrap), iFrame), maxDirections); \n        // Obtain the cell information for that neighbor as well.\n        //vec4 colNgbr = texelFetch(iChannel0, ivec2(mod(p + dir, wrap)), 0);\n        vec2 uvN = convertCoord(mod(nP, wrap));\n        vec4 colNgbr = texelFetch(iChannel0, ivec2(uvN), 0);\n         \n        \n        // If a transfer is still in progress, update the transfer timer -- which,\n        // in turn, will be converted to cell object position.\n        if (col.z < 1.){ \n            // Increment the motion timer.\n            \n            // Converting to 3D cell coordinates.\n            vec3 ip = mod(vec3(col.x, floor(col.x/wrap), floor(col.x/(wrap*wrap))), wrap);\n            \n            float rnd = hash31(ip + .2); // Random number for each cell.\n            float dS =  (1. - rnd*.66)*3.*iTimeDelta; // Incremental distance change.\n            col.z = min(col.z + dS, 1.); // Increasing the distance, whilst not overshooting.\n        }\n        // Both cells (current and neighbor) need to have completed a motion transfer \n        // and be awaiting te next transfer (\"col.z == 1.\" and \"colNgbr.z == 1\").\n        //\n        // The transfer between cells needs to be valid (the cell and neighbor directions \n        // need to point toward each other). Finally, two empty or two full cells obviously \n        // can't cell swap, which leaves full to empty, or empty to full. In other words, \n        // an active cell can only transfer to an inactive one, or an inactive cell can only\n        // receive a transfer from a full one (Ie. col.a != colNgbr.a).\n        else if(colNgbr.z == 1. && dir == -dirNgbr && col.w != colNgbr.w) {\n    \n            // An inactive cell will receive the index of the transferring\n            // active cell.\n            if (col.w == 0.) col.x = colNgbr.x; // New index.\n            col.y = dirToIndex(dir); // Store the random direction index at this time point.\n            col.z = 0.;          // Reset the timer back to the start.\n            col.w = colNgbr.w;   // The inactive cell will now be active, and vice versa.\n \n        }\n        \n        \n    }\n    \n    // Store the updated values to the buffer.\n    fragColor = col;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3yDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3274, 3307, 3329, 3329, 3387], [3392, 3546, 3594, 3896, 4805], [4808, 4830, 4865, 5242, 5333], [5335, 5393, 5414, 5498, 5971], [5973, 6004, 6042, 6042, 6141], [6273, 6273, 6313, 6918, 8212], [8636, 8636, 8657, 8813, 11154], [11240, 11263, 11281, 11420, 12126], [12130, 12151, 12187, 12236, 13286], [14107, 14302, 14354, 14435, 15732], [15735, 15887, 15922, 15922, 16173], [16176, 16203, 16242, 16242, 17460], [17465, 17661, 17716, 17825, 19112], [20283, 20283, 20339, 20376, 29783]], "test": "untested"}
{"id": "dlKcRh", "name": "buble blur", "author": "zyc", "description": "buble  blur effet", "tags": ["blur", "heart"], "likes": 7, "viewed": 230, "published": 3, "date": "1700138339", "time_retrieved": "2024-07-30T17:22:19.238682", "image_code": "const float lightIns = 14.0;\nconst float radius = 8.0;\nconst float ins = 1.1;\nconst float lastR = 24.14;\n\nmat2 rotMatrix(float angle)\n{\n    return mat2(-0.73735, 0.67539,\n                    -0.67539, -0.73735);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = getProgress(iTime);\n    float intensity = progress;\n    float mysize = 97.0;\n    float blurSize = intensity * 1.25;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    mat2 _GoldenRot = rotMatrix(2.39996323);\n    mat2 rot = _GoldenRot;\n    vec3 accumulator = vec3(0.0);\n    vec3 divisor = vec3(0.0);\n    float r = lastR*0.8;\n    float myRatio=max(iResolution.x,iResolution.y)/min(iResolution.x,iResolution.y);\n    vec2 angle = vec2(0.0, 0.35*blurSize*myRatio)/ iResolution.xy;\n\n    float amount = 40.0;\n    amount += 0.9987*500.0;\n    \n    \n    for (int i = 0; i < 120; i++)\n    {\n        float j = float(i);\n        if(j>mysize)\n            break;\n        \n        angle.x*=ratio;\n        angle = rot * angle;\n        angle.x/=ratio;\n        vec3 col = texture(iChannel0,vec2(uv + (r - 1.0)*mix(1.5,1.0,r/lastR) * angle)).rgb;\n        vec3 bokeh = pow(col,vec3(9.0)) * amount+.4;;\n        float d=r/lastR;\n        bokeh=bokeh*smoothstep(1.0,0.9,d)*\n        (ins+(1.0-ins)*smoothstep(0.8,0.9,d));\n        accumulator +=  col*bokeh;\n        divisor += 1.0*bokeh;\n        r += 1.0 / r;\n    }\n    \n    \n    vec3 res= (accumulator / divisor);\n    fragColor = vec4(res, texture(iChannel0,uv).a);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float intensity = getProgress(iTime);\n    float blurSize = intensity * BLUR_SIZE;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 screenSize = iResolution.xy*0.5;\n    const int  radius = 8;\n    vec3 W = vec3(0.299,0.587,0.114);\n    \n    float half_gaussian_weight[9];\n    \n    half_gaussian_weight[0]= 0.20;//0.137401;\n    half_gaussian_weight[1]= 0.19;//0.125794;\n    half_gaussian_weight[2]= 0.17;//0.106483;\n    half_gaussian_weight[3]= 0.15;//0.080657;\n    half_gaussian_weight[4]= 0.13;//0.054670;\n    half_gaussian_weight[5]= 0.11;//0.033159;\n    half_gaussian_weight[6]= 0.08;//0.017997;\n    half_gaussian_weight[7]= 0.05;//0.008741;\n    half_gaussian_weight[8]= 0.02;//0.003799;\n    \n    \n    vec4 sum            = vec4(0.0);\n    vec4 result         = vec4(0.0);\n    vec2 unit_uv        = vec2(blurSize/screenSize.x,blurSize/screenSize.y)*1.25;\n    vec4 curColor       = texture(iChannel0, uv);\n    \n    vec4 centerPixel    = curColor*half_gaussian_weight[0];\n    \n    float sum_weight    = half_gaussian_weight[0];\n    //horizontal\n    for(int i=1;i<=radius;i++)\n    {\n        vec2 curRightCoordinate = uv+vec2(float(i),0.0)*unit_uv;\n        vec2 curLeftCoordinate  = uv+vec2(float(-i),0.0)*unit_uv;\n        vec4 rightColor = texture(iChannel0,curRightCoordinate);\n        vec4 leftColor = texture(iChannel0,curLeftCoordinate);\n        sum+=rightColor*half_gaussian_weight[i];\n        sum+=leftColor*half_gaussian_weight[i];\n        sum_weight+=half_gaussian_weight[i]*2.0;\n    }\n    \n    result = (sum+centerPixel)/sum_weight; \n    \n    fragColor = result;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float progress = getProgress(iTime);\n    float intensity = progress;\n    float blurSize = intensity * BLUR_SIZE;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 screenSize = iResolution.xy*0.5;\n    const int  radius = 8;\n    float half_gaussian_weight[9];\n    \n    half_gaussian_weight[0]= 0.2; //0.2;//0.137401;\n    half_gaussian_weight[1]= 0.19;//0.2;//0.125794;\n    half_gaussian_weight[2]= 0.17;//0.2;//0.106483;\n    half_gaussian_weight[3]= 0.15;//0.2;//0.080657;\n    half_gaussian_weight[4]= 0.13;//0.2;//0.054670;\n    half_gaussian_weight[5]= 0.11;//0.2;//0.033159;\n    half_gaussian_weight[6]= 0.08;//0.2;//0.017997;\n    half_gaussian_weight[7]= 0.05;//0.2;//0.008741;\n    half_gaussian_weight[8]= 0.02;//0.2;//0.003799;\n    \n    vec4 sum            = vec4(0.0);\n    vec4 result         = vec4(0.0);\n    vec2 unit_uv        = vec2(blurSize/screenSize.x,blurSize/screenSize.y)*1.25;\n\n    vec4 centerPixel    = texture(iChannel0, uv);\n    centerPixel = centerPixel*half_gaussian_weight[0];\n    float  sum_weight   = half_gaussian_weight[0];\n    //vertical\n    for(int i=1;i<=radius;i++)\n    {\n        vec2 curBottomCoordinate    = uv+vec2(0.0,float(i))*unit_uv;\n        vec2 curTopCoordinate       = uv+vec2(0.0,float(-i))*unit_uv;\n        sum+=texture(iChannel0,curBottomCoordinate)*half_gaussian_weight[i];\n        sum+=texture(iChannel0,curTopCoordinate)*half_gaussian_weight[i];\n        sum_weight+=half_gaussian_weight[i]*2.0;\n    }\n    \n    \n    result = (sum+centerPixel)/sum_weight;\n    fragColor = result;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLUR_SIZE 0.48\n\n\nfloat getProgress(float t0) {\n    float t = 1.0 - t0;\n    return fract(0.3*t);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 135, 135, 213], [216, 216, 273, 273, 1527]], "test": "untested"}
{"id": "dtVcDz", "name": "N,N-Dimethyltryptamin", "author": "POSTHELIOS", "description": "Certainly, let's go through this GLSL (OpenGL Shading Language) shader code.", "tags": ["fractal"], "likes": 12, "viewed": 322, "published": 3, "date": "1700137238", "time_retrieved": "2024-07-30T17:22:20.236015", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*6.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n       //  g+=e=length(p.yx)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 922]], "test": "untested"}
{"id": "dtKyDR", "name": "hexagon blur fx", "author": "zyc", "description": "hexagon blur fx", "tags": ["blur"], "likes": 4, "viewed": 169, "published": 3, "date": "1700121368", "time_retrieved": "2024-07-30T17:22:21.186474", "image_code": "\n\n#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996323\n\n#define u_Angle 0.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = u_Angle * PI / 180.0;\n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect;\n    vec4 color = dirBlur(iChannel0, uv, dir, progress);\n    fragColor = color;\n}\n\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define progress (fract(0.4*iTime))\n#define u_Strength 0.32\n\nfloat customStep(float edge0, float edge1, float value) {\n    return clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat getScale(float p) {\n    return customStep(1.0, 0.0, p);\n}\n\nvec4 gaussianBlur(sampler2D i_InputTex, vec2 i_Uv, vec2 i_Dir, float i_Strength)\n{\n    float half_gaussian_weight[9];\n    half_gaussian_weight[0]= 0.20;//0.137401;\n    half_gaussian_weight[1]= 0.19;//0.125794;\n    half_gaussian_weight[2]= 0.17;//0.106483;\n    half_gaussian_weight[3]= 0.15;//0.080657;\n    half_gaussian_weight[4]= 0.13;//0.054670;\n    half_gaussian_weight[5]= 0.11;//0.033159;\n    half_gaussian_weight[6]= 0.08;//0.017997;\n    half_gaussian_weight[7]= 0.05;//0.008741;\n    half_gaussian_weight[8]= 0.02;//0.003799;\n    vec4 sum            = vec4(0.0);\n    vec4 result         = vec4(0.0);\n    vec2 unit_uv        = i_Dir * i_Strength;\n    vec4 curColor       = texture(i_InputTex, i_Uv);\n    vec4 centerPixel    = curColor*half_gaussian_weight[0];\n    float sum_weight    = half_gaussian_weight[0];\n    for(int i=1;i<=8;i++)\n    {\n        vec2 curRightCoordinate = i_Uv+float(i)*unit_uv;\n        vec2 curLeftCoordinate  = i_Uv+float(-i)*unit_uv;\n        vec4 rightColor = texture(i_InputTex, curRightCoordinate);\n        vec4 leftColor = texture(i_InputTex, curLeftCoordinate);\n        sum+=rightColor*half_gaussian_weight[i];\n        sum+=leftColor*half_gaussian_weight[i];\n        sum_weight+=half_gaussian_weight[i]*2.0;\n    }\n    result = (sum+centerPixel)/sum_weight; \n    return result;\n}\n\n\nvec4 dirBlur(sampler2D inputTexture, vec2 uv, vec2 dir, float p)\n{\n    float weight = 1.0;\n    float u_Size = 0.41;\n    float u_Bright = 4.8;\n    \n    float u_SizeScale = getScale(p);\n    vec4 resColor = texture(inputTexture, uv);\n    float sumWeight = 1.0;\n    vec4 maxColor = resColor;\n    for (int i = 1; i <= 16; ++i)\n    {\n        vec2 tmpUV = uv + dir * float(i) * u_Size * u_SizeScale;\n        vec4 a = texture(inputTexture, tmpUV);\n        tmpUV = uv - dir * float(i) * u_Size * u_SizeScale;\n        vec4 b = texture(inputTexture, tmpUV);\n        resColor += a + b;\n        vec4 c = max(a, b);\n        maxColor = max(c, maxColor);\n        sumWeight += 2.0;\n    }\n    \n    resColor /= sumWeight;\n    vec4 color = mix(resColor, maxColor, clamp(resColor * u_Bright, 0.0, 1.0));\n    resColor.rgb = color.rgb;\n    return resColor;\n}", "buffer_a_code": "\n#define u_Angle 0.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = radians(u_Angle);\n    float u_SizeScale = getScale(progress);\n    \n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect.xy;\n    vec4 color = gaussianBlur(iChannel0, uv, dir, u_Strength * u_SizeScale);\n    fragColor = color;\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n#define u_Angle 90.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     float theta = radians(u_Angle);\n    float u_SizeScale = getScale(progress);\n    \n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect.xy;\n    vec4 color = gaussianBlur(iChannel0, uv, dir, u_Strength * u_SizeScale);\n    fragColor = color;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996323\n\n#define u_Angle 60.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     float theta = radians(u_Angle);\n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect;\n    vec4 color = dirBlur(iChannel0, uv, dir, progress);\n    fragColor = color;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996323\n\n#define u_Angle -60.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float theta = radians(u_Angle);\n    vec2 rect = vec2(min(720.0, 720.0 * iResolution.x / iResolution.y), min(720.0, 720.0 * iResolution.y / iResolution.x));\n    vec2 dir = vec2(cos(theta), sin(theta)) / rect;\n    vec4 color = dirBlur(iChannel0, uv, dir, progress);\n    fragColor = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 134, 134, 471]], "test": "untested"}
{"id": "dtVyWR", "name": "Gamelan synthesizer", "author": "jarble", "description": "A an arabesque knot pattern with gamelan music.\nClick and drag to move around.", "tags": ["fractal", "music", "rug", "gamelan"], "likes": 9, "viewed": 284, "published": 3, "date": "1700117781", "time_retrieved": "2024-07-30T17:22:22.187797", "image_code": "\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.x>uv.y;\n        \n    for(int k = 0; k < 6; k++){\n\n        //uv.x -= t1_(floor(uv),floor(uv));\n        //uv -= triwave1_(uv);\n\n        //if(uv.y<0.) //amazing pattern!\n        uv =\n            abs(.5+uv+t2)\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n\n        b =\n            uv.y>uv.x\n        ;\n        if(b)\n        uv =\n            uv.yx\n        ;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        //if(uv.x<-.25)\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            //vec3(col.zx*sign(t2.y-t2.x),max(uv.x-uv.y,0.))\n        ;\n        uv +=\n            float(uv.x>uv.y)/1.5\n            //float(uv.x>uv.y&&t2.x>t2.y)/1.5\n            //float(t2.x>t2.y)/1.5\n            //float(uv.x-uv.y)/1.5\n        ;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    a +=\n        floor(mod1(b/2.,2.))\n    ;\n    /*\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/8.),b)*i;\n    }\n    */\n    return\n        mod(mod(floor(a),b)*mod(floor(a/(b)),b),b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    //time += mod(time,5.)-mod(time,3.);\n    return\n        (1.+fmod(time/4.,2.))/(1.+fmod(time,2.))\n    ;\n}\n\n//change the notes without changing the rhythm\nfloat fmod1(float a, float b){\n    return\n        //fmod(a,b)\n        fmod(a+floor(a/4./4.),b)\n        //max(fmod(a+floor(a/4./4.),b),fmod(a+floor(-a/4./4.),b))\n        //fmod(a,b-fmod(a/2.,2.))\n        //fmod(floor(a)*5.,b+fmod(floor(a/8.)*3.,b))\n    ;\n}\n\n#define fract1(a) (1.-fract(-a)*fract(-a))\n//#define fract1(a) pow(1.-fract(-a)*fract(-a),1.+log(2.)-log(2.-fract(a)*fract(a)))\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 sitar6(vec2 a, vec2 nb){\n    return a*a/16./2.*abs((.5*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -(a/4.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\na *= a;\nreturn\na/16./2.*abs((1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  + .5*(1./4.+a*a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))/2. \n;\n}\n\nvec2 instrument1(vec2 a, vec2 nb, int instrument){\nvec2 sitar =\n  sitar5(a,nb)\n  //sitar2(a,nb)\n  //log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.))\n  //a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  //-log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n  \n  ,gamelan = gamelan(a,nb)-gamelan(a,nb/2.)/2.-gamelan(a,nb/4.)/4.\n  ,gamelan1 = a/16./2.*abs(exp(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.)))\n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  ,steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n      + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,guitar = a/16./8.*abs(\n      log(1./2.+a*abs(1./8.-.125/2.*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n      -log(1./2.+a*abs(1./8.-.5*abs(1./2.-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n  )\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ;\n  \n  \n  switch(instrument){\n  case 1:return\n      gamelan\n      //gamelan1\n  ;\n  case 2:return oud;\n  case 3:return steel_drum;\n  case 4:return guitar;\n  case 5:return synth_drum;\n  default:\n  return\n\n      sitar\n      \n      //steel_drum\n      \n      //oud\n      \n      //piano\n      //a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      //+.5*log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.      \n      \n\n      //a/16.*abs(log(1.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      //+log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))/2.      \n      \n      //a/16.*abs(1./4.+log(1.+a*abs(abs(.5-vec2(fract1(nb.x/2.*.998),fract1(nb.y/2.)))/2.))\n      //+log(1./4.+a*abs(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.  \n      \n      //a/16.*abs(1./4.+log(1.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.))\n      //+log(1./4.+a*abs(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/4.)))/2.   \n      \n      //gamelan\n\n      //gamelan 2\n      //a/16.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      //-.125*log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))/2.      \n  \n      //hurdy-gurdy\n      //((abs(log(1./8.+log(1.+a)*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*4.),fract1(nb.y*4.)))/2.))-log(1./8.+log(1.+a)*abs(1./16.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))))\n\n      //log(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a)\n      \n      //abs(log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      //abs(1.+log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      \n      //log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.)))))\n  ;\n  }\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument,float duration,float attack){\n  \n  float s1 =\n      8.,\n  tempo1 =\n      //1.\n      //divide by prime numbers to get an interesting rhythm\n      prime_rhythm(time/2.)/prime_rhythm(time/4.+4.)\n  ,\n  tempo2=prime_rhythm(time+7.),\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./tempo2,\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6+mod(t6/8.,3.)-mod(t6/8.,2.),s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.);\n  vec2\n  a= vec2(\n      //-log(fract(t/tempo2)/4.)*4.\n      //-log(fract(t/2./prime_rhythm(time+14.))*fract(t/prime_rhythm(time+7.))/8.)*4.\n      \n      //sitar / gamelan\n      //abs(1.-log(1./64./4.+fract1(t/2./prime_rhythm(time+14.))/4.)),abs(1.-log(1./64./4.+fract1(t/prime_rhythm(time+7.))/4.))\n      \n      //steel drum / oud\n      //-log(attack+fract1(t/2./prime_rhythm(time+14.))/8./duration),-log(attack+fract1(t/tempo2)/8./duration)\n      -log(attack+fract1(t/tempo2)/8./duration)\n      //hurdy-gurdy\n      //(1.-log(1./32.+abs(1./32.-fract1(t/2./prime_rhythm(time+14.))*2.))),(1.-log(1./32.+abs(1./32.-fract1(t/prime_rhythm(time+7.)))))\n\n  ),\n  nb = vec2(\n      t*pow(2.,(m3+m2-t1*4.-fmod(t/16.,2.)*4.)/7.+scale)*tempo1\n      //t*pow(2.,(m3-m2*2.+t1)/7.+6.5)*tempo1\n      \n      //airhorn remix\n      //abs(t*(pow(2.,(m3+m2-t1*4.)/7.+7.5)*tempo1/2.)-a/16.)*2.\n  );\n  return\n      instrument1(a,nb,instrument)\n      //instrument1(a,nb,6)+instrument1(a,nb,instrument)\n  ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument,float duration){\n    return mainSound1(samp,time,scale,instrument,duration,1./64.*8.);\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument){\n    return mainSound1(samp,time,scale,instrument,1.);\n}\n\nvec2 violin(int a,float b,float scale,int instrument,float duration,float attack){\n    return\n        (mainSound1(a,b,scale,instrument,duration,attack)-mainSound1(a,b,scale,instrument,duration/2.,attack))\n        -(mainSound1(a,b,scale-1.,instrument,duration,attack)-mainSound1(a,b,scale-1.,instrument,duration/2.,attack))\n    ;\n}\n\nvec2 sitar(int a,float b,float scale,int instrument,float duration,float attack){\n    return\n        (mainSound1(a,b,scale,instrument,duration,attack*8.)-mainSound1(a,b,scale,instrument,duration/2.,attack*8.))\n        -(mainSound1(a,b,scale-1.,instrument,duration,attack)-mainSound1(a,b,scale-1.,instrument,duration/2.,attack))\n    ;\n}\n\nvec2 mainSound(int a,float b){\n    return\n        \n        //tabla drum\n        //(mainSound1(a,b,6.5,1,1./4.)/2./4.+mainSound1(a,b,5.5,1,1./8.))\n        \n        //abs(mainSound1(a,b,6.0,1,1.)-mainSound1(a,b,6.0,1,1.))\n        \n        //gamelan\n        //mainSound1(a,b,6.5,1,1./2.)\n        (mainSound1(a,b,6.+3./7.,1,1.)+2.*mainSound1(a,b,7.+3./7.,4,1./2.))\n        \n        //sitar(a,b,6.25,6,1./3.,1./64./4./4.)\n        //violin(a,b,6.5,6,1./4.,1./64./2.)\n        \n        //using sitar2\n        //(mainSound1(a,b,5.5,6,1./2.)-mainSound1(a,b,4.5,6,2.))\n        \n        //sounds like sitar (using oud)\n        //abs(mainSound1(a,b,7.25,2,1./2.)-mainSound1(a,b,6.25,2,1.)/2.)\n        \n        //mainSound1(a,b,5.5,5,2.)\n\n        \n        //oud remix\n        //(mainSound1(a,b,7.,2)+mainSound1(a,b/2.,6.,2))/2.;\n        \n        //cymbal remix\n        //abs(mainSound1(a,b,7.,3,1./4.)-mainSound1(a,b,6.5,3,1./4.))/2.;\n        \n        //gong remix (with oud)\n        //abs(mainSound1(a,b,7.,1)-mainSound1(a,b,6.5,1))/2.;\n        \n        //echo\n        //abs(mainSound1(a,b,6.5,1)+mainSound1(a,b+1./16.,5.5,1))\n        \n        //(mainSound1(a,b,7.5,1)+mainSound1(a,b,6.5,1)+mainSound1(a,b,5.5,1))/3.\n        //(mainSound1(a,b,7.5,1)+mainSound1(a,b/2.,7.5,1)+mainSound1(a,b/4.,7.5,1))/3.\n        //mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,6.5,1)/2.+mainSound1(a,b/4.,6.5,1)/4.+mainSound1(a,b/8.,6.5,1)/8.\n    ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 143], [260, 260, 286, 286, 375], [377, 377, 434, 434, 1599]], "test": "untested"}
{"id": "ctyyR1", "name": "Study: Gyre and Gimble", "author": "kp1197", "description": "For the purposes of study, I derived all the SDFs and all but the torus ray-primitive intersection myself.  Idea: If ray intersection fails, SDF d += MAX_D --> less marching steps.", "tags": ["scifi"], "likes": 9, "viewed": 231, "published": 3, "date": "1700115859", "time_retrieved": "2024-07-30T17:22:23.231008", "image_code": "\n\n// DONE! TODO: fix marching problems\n// DONE! TODO: camera controls\n// DONE! TODO: surface normals\n// DONE! TODO: distance fog\n// TODO: soft shadows\n// TODO: volumetric effects (crepuscular rays)\n\n\nmat4 rx1;\nmat4 rx2;\nmat4 rx3;\nmat4 rx4;\nmat4 rx5;\n\nmat4 tx1;\nmat4 tx2;\nmat4 tx3;\nmat4 tx4;\nmat4 tx5;\n\n// pre-compute transforms so we don't create them in an inner loop\nvoid initRxTx() {\n    \n    float t = iTime + 3.;\n    \n    // outermost ring\n    rx1 = IDENTITY;\n    tx1 = inverse(GLOBAL_TRANSLATION);\n    \n    // ring 2\n    mat4 rx = rotMatrix(0.,t,0.);\n    rx2 = rx * rx1;\n    tx2 = rx * tx1;\n    \n    // ring 3\n    rx = rotMatrix(t,0.,0.);\n    rx3 = rx * rx2;\n    tx3 = rx * tx2;   \n    \n    // ring 4\n    rx = rotMatrix(0.,t,0.);\n    rx4 = rx * rx3;\n    tx4 = rx * tx3;    \n    \n    // gyre/light\n    rx = rotMatrix(0., 5.*t, 0.);\n    rx5 = rx * rx4;\n    tx5 = rx * tx4;\n}\n\n// this map functions updates the material when a new closest primitive is found.\nfloat map(in vec3 ray, in vec4 globalP, in float d, inout vec4 currentMaterial, in float include_lights) {\n\n    vec4 globalRay = vec4(ray,1.);\n    \n    // transformation of p and ray into local transform space\n    vec4 localP   = tx1 * globalP;\n    vec4 localRay = rx1 * globalRay;\n    \n    float dRing;\n    vec4 ringMaterial;\n    \n    // outermost ring\n    localP   = tx2 * globalP;\n    localRay = rx2 * globalRay;\n    dRing = pRing(localP, vec2(4.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(4.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);\n    \n    // ring 2\n    localP   = tx3 * globalP;\n    localRay = rx3 * globalRay;\n    dRing = pRing(localP, vec2(3.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(3.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights); \n    \n    // ring 3\n    localP   = tx4 * globalP;\n    localRay = rx4 * globalRay;\n    dRing = pRing(localP, vec2(2.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(2.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);\n    \n    // ring 4\n    localP   = tx5 * globalP;\n    localRay = rx5 * globalRay;\n    dRing = pRing(localP, vec2(1.,R2)) + MAX_D * pRingBounds(localRay.xyz, localP, vec2(1.,BOUNDSR2));\n    ringMaterial = vec4(localP.xyz, RING_MATERIAL);\n    d = matmin(d, dRing, currentMaterial, ringMaterial, include_lights);    \n\n    // gyre\n    localP   = tx5 * globalP;\n    localRay = rx5 * globalRay;\n    float dSphere = pSphere(localP.xyz, GYRE_RADIUS) + MAX_D * pSphereBounds(localRay.xyz, localP, GYRE_RADIUS);\n    vec4 gyreMaterial = vec4(localP.xyz, GYRE_MATERIAL);\n    d = matmin(d, dSphere, currentMaterial, gyreMaterial, include_lights);\n\n    // floor\n    localP = globalP + vec4(0.,5.,0.,0.);\n    float dFloor = pPlane(localP) + MAX_D * pPlaneBounds(ray, localP);\n    vec4 floorMaterial = vec4(localP.xyz, FLOOR_MATERIAL);\n    d = matmin(d, dFloor, currentMaterial, floorMaterial, include_lights);  \n    \n    return d;\n}\n\n\nvec4 material_query(vec3 ray, inout vec4 globalP) {\n    \n    float currentD = MAX_D;\n    float totalD = 0.;\n    vec4 currentMaterial = vec4(globalP.xyz, SKY_MATERIAL);\n    float hit = 0.0;\n    \n    // raymarch\n    for (int i = 0; i < MAX_STEPS && currentD <= MAX_D; i++) {\n        \n        // uses out params to update the current object coords / material (vec4 currentMaterial) and current distance (float currentD)\n        currentD = map(ray, globalP, currentD, currentMaterial, 1.);\n        totalD += currentD;\n        \n        if (currentD < EPS) {\n            hit = 1.;\n            break;\n        }\n        \n        if (currentD > MAX_D) {\n            hit = 0.;\n            break;\n        }\n        \n        globalP += vec4(ray * currentD, 0.);\n    }\n    \n    // return position in local (object) coordinates and the material ID\n    return currentMaterial * vec4(1.,1.,1.,hit);\n}\n\n// SDF marches from light to object, checking if we can reach the object from the light\n// returns light surface local coordinates (xyz) and shadowing amount (w)\nfloat directIllumination(vec4 lightSurfacePos, vec4 objPos) {\n\n    // setup raymarch, heading from light to object\n    float currentD = MAX_D;\n    float totalD = 0.;\n    vec3 lightToObjectRay = normalize(objPos.xyz - lightSurfacePos.xyz);\n    \n    // SDF raymarch from light surface to objPos, breaking if close to objPos\n    vec4 _;    \n    for (int i = 0; i < MAX_STEPS && currentD <= MAX_D; i++) {\n        currentD = map(lightToObjectRay, lightSurfacePos, currentD, _, 0.);\n        totalD += currentD;\n        // we hit an object...\n        if (currentD < EPS) {\n            // if we made it back to the original object position, hurray, it's illuminated!\n            return step(length(lightSurfacePos.xyz - objPos.xyz), 5.*EPS);\n        }\n        if (totalD > MAX_D) {\n            return 0.;\n        }\n        lightSurfacePos += vec4(lightToObjectRay * currentD, 0.);\n    }\n    return 0.0;\n}\n\nvec3 calcCentralDifferencesNormal(vec3 ray, vec4 worldP) {\n    vec2 eps = vec2(EPS,0.);\n    vec4 _;\n    float dx1 = map(ray, worldP + eps.xyyy, MAX_D, _, 1.);\n    float dy1 = map(ray, worldP + eps.yxyy, MAX_D, _, 1.);\n    float dz1 = map(ray, worldP + eps.yyxy, MAX_D, _, 1.);\n    float dx2 = map(ray, worldP - eps.xyyy, MAX_D, _, 1.);\n    float dy2 = map(ray, worldP - eps.yxyy, MAX_D, _, 1.);\n    float dz2 = map(ray, worldP - eps.yyxy, MAX_D, _, 1.);\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2)/(2.*eps.x));\n}\n\nvec3 getDiffuse(in vec4 result, in vec3 ray) { \n    // SKY\n    if (result.w < 0.5) {\n        return vec3(max(0.,ray.y));\n    }\n    // RING\n    else if (result.w < 1.5) {\n        return DIFFUSE_TERM * texture(iChannel0, result.xyz).xxx;\n    }\n    // LAND\n    else if (result.w < 2.5) {\n        return DIFFUSE_TERM * texture(iChannel2, result.xz).xyz;        \n    }\n    // LIGHT\n    else {\n        return pow(texture(iChannel1, result.xyz / LIGHT_COLOR_REPEAT).xyz, vec3(0.2));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // standard uv\n    vec2 uv = 2.*(fragCoord/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x));    \n    \n    // camera setup\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec4 worldP = vec4(0.,0.,0.,1.);\n    mat4 camTx = translationMatrix(SCENE_CENTER);\n    mat4 camRx = rotMatrix(0.,TAU * iMouse.x / iResolution.x - PI,0.);\n    ray    = (camRx * vec4(ray,1.)).xyz;\n    worldP = camTx * camRx * inverse(camTx) * worldP;\n    \n    // calculate matrices\n    initRxTx();\n    \n    // material query\n    vec4 result = material_query(ray, worldP);\n    \n    // start with diffuse\n    vec3 col = getDiffuse(result, ray);\n    \n    \n    // illumination query\n    vec3 lightToObjRay = normalize(worldP.xyz - SCENE_CENTER);\n    vec4 lightSurfacePos = vec4(GYRE_RADIUS * lightToObjRay + SCENE_CENTER,1.);\n    float lightDistance = length(worldP.xyz - lightSurfacePos.xyz);\n    float illuminated = directIllumination(lightSurfacePos, worldP);\n    \n    // normal\n    vec3 normal = calcCentralDifferencesNormal(ray, worldP);\n \n    \n    // illumination color - sample local coordinates of light object\n    vec4 lightMaterial;\n    map(vec3(0.), lightSurfacePos, MAX_D, lightMaterial, 1.);\n    vec3 lightColor = texture(iChannel1, lightMaterial.xyz / LIGHT_COLOR_REPEAT).xyz;\n    float falloff = pow(max(0.,LIGHT_RADIUS - lightDistance) / LIGHT_RADIUS,2.);\n    float shade = abs(dot(-lightToObjRay,normal.xyz));\n    float lightMask = (step(0.5, result.w) * step(result.w, 50.));\n    \n    \n    \n    // illuminate non-sky and non-light sources\n    col += lightMask * 0.6 * shade * falloff * illuminated * lightColor;\n    \n    // fake ambient lighting from floor\n    col += 0.05 * (dot(normal, vec3(0.,-1.,0.))) * lightColor;\n    \n    // gamma correction\n    col = pow(col, vec3(1.0/2.2));\n    \n    // fake distance fog\n    float objDist = length(worldP.xyz - SCENE_CENTER);\n    col *= 1. - objDist / MAX_D;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// math constants\n#define PI  3.14159\n#define TAU 6.28318\n\n// raymarching\n#define EPS 1e-2\n#define MAX_STEPS 30\n#define MAX_D 20.\n\n\n// materials\n#define SKY_MATERIAL 0.\n#define RING_MATERIAL 1.\n#define FLOOR_MATERIAL 2.\n#define GYRE_MATERIAL 99.\n\n// scene\n#define SCENE_CENTER vec3(1e-6,0.,10.)\n#define GLOBAL_TRANSLATION translationMatrix(SCENE_CENTER)\n#define GYRE_ROTATION rotMatrix(0., 0.25*iTime, 0.)\n#define LIGHT_COLOR_REPEAT 20.\n#define R2 0.5\n#define BOUNDSR2 R2*1.1\n#define GYRE_RADIUS (0.5 + 0.015 * sin(20.*iTime))\n#define LIGHT_RADIUS 10.\n\n// lighting\n#define DIFFUSE_TERM 0.05\n\nconst mat4 IDENTITY = mat4(1.,0.,0.,0.,  0.,1.,0.,0., 0.,0.,1.,0., 0.,0.,0.,1.);\n\nfloat pRing(in vec4 p, in vec2 spec) {\n    vec3 rimPoint = vec3(spec.x * normalize(p.xy), 0.);\n    return length(rimPoint - p.xyz) - spec.y;\n    //same results as IQ: return length( vec2(length(p.xy)-spec.x,p.z) )-spec.y;\n}\n\nfloat pSphere(in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat pPlane(in vec4 p) {\n    return p.y;\n}\n\n\n\n/* Does ray @ p intersect a plane @ vec3(0.) within radius units of vec3(0.)? */\nfloat pSphereBounds(in vec3 ray, in vec4 p, in float radius) {\n    vec3 N = ray; // ray is already normalized, and is already the plane's normal vector\n    float t = dot(N,-p.xyz) / dot(N,ray); // solve for t, parametric form of ray \n    vec3 I = p.xyz + t * ray; // calculate intersection with plane\n    return max(step(t,1e-9),step(radius-length(I),0.)); // return MAX_D if t <= 0.0 or I outside of radius in plane\n}\n\nfloat pPlaneBounds(in vec3 ray, in vec4 p) {\n    // if signs agree, no intersection (i.e.; p is below plane and ray is negative)\n    return step(-EPS, sign(p.y) * sign(ray.y));\n}\n\n// i gave in... quartic discriminant had numerical issues... ty IQ\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\nfloat pRingBounds(in vec3 ray, in vec4 p, in vec2 spec) {\n    float d = iTorus(p.xyz, ray, spec);\n    return step(d,0.);\n}\n\n\nmat4 rotMatrix(in float gamma, in float beta, in float alpha) {\n\n    float cos_alpha = cos(alpha);\n    float sin_alpha = sin(alpha);\n    float cos_beta = cos(beta);\n    float sin_beta = sin(beta);\n    float cos_gamma = cos(gamma);\n    float sin_gamma = sin(gamma);\n\n    return mat4( cos_alpha * cos_beta,  \\\n        cos_alpha * sin_beta * sin_gamma - sin_alpha * cos_gamma,\\\n        cos_alpha * sin_beta * cos_gamma + sin_alpha * sin_gamma,\\\n        0.,\\\n        sin_alpha * cos_beta,\\\n        sin_alpha * sin_beta * sin_gamma + cos_alpha * cos_gamma, \\\n        sin_alpha * sin_beta * cos_gamma - cos_alpha * sin_gamma, \\\n        0.,\\\n        -sin_beta, \\\n        cos_beta * sin_gamma, \\\n        cos_beta * cos_gamma,\\\n        0.,\\\n        0.,0.,0.,1.);\n}\n\nmat4 translationMatrix(in vec3 tx) {\n    return mat4(1.,0.,0.,0.,   0.,1.,0.,0., 0.,0.,1.,0., tx.x,tx.y,tx.z,1.);\n}\n\nfloat matmin(in float currentD, in float d, inout vec4 currentMaterial, in vec4 material, in float include_lights) {\n    d = d + (1.-include_lights) * step(50.,material.w) * MAX_D;\n    float signal = step(d, currentD);\n    currentMaterial = mix(currentMaterial, material, signal);\n    return min(currentD, d);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 369, 386, 386, 878], [880, 962, 1068, 1068, 3141], [3144, 3144, 3195, 3195, 4028], [4030, 4192, 4253, 4306, 5088], [5090, 5090, 5148, 5148, 5617], [5619, 5619, 5665, 5677, 6102], [6105, 6105, 6162, 6181, 8125]], "test": "untested"}
{"id": "mljyzW", "name": "circle packing -31467", "author": "ArmandB", "description": "it is", "tags": ["2d", "sdf", "iterative"], "likes": 3, "viewed": 148, "published": 3, "date": "1700110393", "time_retrieved": "2024-07-30T17:22:24.253274", "image_code": "//buffers A - D place the balls (to allow me to place up to 4 balls per frame)\n//see Cube A for instructions on how to change the scene\n\n//set both to 1 for fast rendering\nconst int superSample = 5;\nconst int maxBounces = 3;\n\n//press space to render fast version (helps to place more balls)\nconst int _space = 32;\n\nbool keyPressed(int key){\n    return texelFetch(iChannel2, ivec2(key,0),0).x >= 1.0;\n}\n\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nvec3 getNormal(vec2 pos){\n    vec4 sampleData = texture(iChannel0, pos);    \n    return normalize(vec3(pos.x, sampleData.x, pos.y) - vec3(sampleData.y,0.0,sampleData.z));\n}\n\nfloat roundSdf(float r, float d){\n    float b = d*d + 2.0*d*r;\n    return sign(b)*sqrt(abs(b));\n}\n\nvec3 roundNormal(float r, float d, vec3 normal){\n    float q = dot(normal.xz,normal.xz)*abs(d*d + 2.0*d*r);\n    float l = (d+r)/sqrt(q);\n    return normalize(vec3(normal.x*l,1.0,normal.z*l));\n}\n\nfloat sdf(vec3 p){\n    vec4 sampleData = texture(iChannel0, p.xz);\n    float k = dot(p.xz-sampleData.yz,p.xz-sampleData.yz);\n    return sqrt(k + p.y*p.y) - sampleData.w;\n}\n\nHit marchRay(Ray ray){\n    float t = 0.0;\n    bool hit = false;\n    ray.origin.xz = fract(ray.origin.xz);\n    for (int i = 0; i < 512; i++){\n        float d = sdf(ray.origin);\n        if (t > 1.0) break;\n        if (abs(d) < 0.001){\n            hit = true;\n            break;\n        }\n\n        t += d;\n        ray.origin += ray.direction*d;\n        ray.origin.xz = fract(ray.origin.xz);\n    }\n    \n    vec4 sampleData = texture(iChannel0, ray.origin.xz);\n    return Hit(hit, t, ray.origin, roundNormal(sampleData.w, sampleData.x, getNormal(ray.origin.xz)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if (!keyPressed(_space)){\n    \n        vec3 totalCol = vec3(0);\n        \n        //super sampling\n        for (int x = 0; x < superSample; x ++){\n            for (int y = 0; y < superSample; y ++){\n                \n                \n                vec2 uv = fract((fragCoord + vec2(x,y)/float(superSample))/iResolution.y);\n\n                vec3 lightPos = vec3(iMouse.x/iResolution.y,0.5,iMouse.y/iResolution.y);\n\n                Ray ray = Ray(vec3(0,-1,0),vec3(uv.x,1,uv.y));\n                bool didhit = false;\n                vec3 light = vec3(1);\n                vec3 lightColor = vec3(0.902,0.902,0.902);\n                \n                //reflection code\n                for (int i = 0; i < maxBounces; i ++){\n                    Hit hit = marchRay(ray);\n                    if (!hit.hit) break;\n                    light += fpow(max(dot(ray.direction,reflect(vec3(0,sin(3.0),cos(3.0)),hit.normal)),0.0),0.9); //specular\n                    light *= lightColor; //tint (or whatever you call it)\n                    ray = Ray(reflect(ray.direction,hit.normal),hit.point + hit.normal*0.1);\n                    didhit = true;\n                }\n                \n                //sample cubemap\n                vec3 col = vec3(0);\n                if (didhit) {\n                    col = texture(iChannel1,ray.direction).rgb*light;\n                } else {\n                    col = texture(iChannel1,normalize(vec3((fragCoord.x - iResolution.x/2.0)/iResolution.y,-0.5,fragCoord.y/iResolution.y-0.5))).rgb;\n                }\n                //add to avg\n                totalCol += col;\n                \n                \n            }\n        }\n\n        fragColor = vec4(totalCol/float(superSample*superSample),1);\n    } else {\n        fragColor = vec4(texture(iChannel0,fragCoord/iResolution.xy));\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = addSphere(iChannel0, float(iFrame) + iDate.x + iDate.y + iDate.z + iDate.w, uv);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Ray {\n    vec3 direction;\n    vec3 origin;\n};\n\nstruct Hit {\n    bool hit;\n    float t;\n    vec3 point;\n    vec3 normal;\n};\n\n//stuff that places things\n\nconst int maxsteps = 1024;\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 getNormal(sampler2D sampler, vec2 uv){\n    vec2 pos = texture(sampler,uv).yz;\n    return normalize(uv - pos);\n}\n\nbool inArea(vec2 p){\n    return p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0;\n}\n\nvec4 textureFetch(sampler2D sampler, vec2 coord){\n    return texelFetch(sampler,ivec2(coord*vec2(textureSize(sampler, 0).xy)),0);\n}\n\nvec4 addSphere(sampler2D sampler, float seed, vec2 uv){\n    vec4 data = textureFetch(sampler,uv);\n    vec2 pos = hash21(seed);\n    float radius = 0.0;\n    if (data == vec4(0)){\n        pos = vec2(0.5);\n        radius = 0.2;\n        data = vec4(999.0);\n    } else {\n        float ld = 0.0;\n        for (int i = 0; i < maxsteps; i++){\n            radius = textureFetch(sampler, pos).x;\n            if (radius >= 0.1 || radius < ld || !inArea(pos)) break;\n            vec2 normal = getNormal(sampler, pos);\n            pos += normal*0.0001*sign(0.5 - radius);\n            ld = radius;\n        }\n    }\n    float d = 999.0;\n    vec2 pos2 = vec2(0.0);\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            vec2 pos3 = pos + vec2(x,y);\n            float d2 = distance(pos3, uv) - radius;\n            if (d2 <= d){\n                d = d2;\n                pos2 = pos3;\n            }\n        }\n    }\n    return d <= data.x ? vec4(d, pos2, radius) : data;\n}", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = addSphere(iChannel0, float(iFrame) + iDate.x + iDate.y + iDate.z + iDate.w + 0.1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = addSphere(iChannel0, float(iFrame) + iDate.x + iDate.y + iDate.z + iDate.w + 0.2, uv);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = addSphere(iChannel0, float(iFrame) + iDate.x + iDate.y + iDate.z + iDate.w + 0.3, uv);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//uncomment to enable custom cubemap textures\n//#define custom_texture\n\n/*\nto load cutom cubemap textures\nuncomment the define above\ninstall https://chromewebstore.google.com/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda?pli=1\ngo to https://hdri-haven.com/ and find and download an hdri you like\nuse https://matheowis.github.io/HDRI-to-CubeMap/ to convert the hdri to a cubemap\ndrag the generated cubemap into channel0 of this buffer\n*/\n\n//based on https://www.gamedev.net/forums/topic/687535-implementing-a-cube-map-lookup-function/5337472/\nvec2 sampleCube(vec3 v){\n\tvec3 vAbs = abs(v);\n\tfloat ma;\n\tvec2 uv;\n    vec2 o;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y){\n\t\tma = 0.5/vAbs.z;\n\t\tuv = v.xy*vec2(sign(v.z),-1);\n        o = vec2(1 + int(v.z < 0.0)*2,1);\n\t} else if (vAbs.y >= vAbs.x){\n\t\tma = 0.5/vAbs.y;\n\t\tuv = v.xz*vec2(1,sign(v.y));\n        o = vec2(1,2*int(v.y < 0.0));\n\t} else {\n\t\tma = 0.5/vAbs.x;\n\t\tuv = v.zy*vec2(-sign(v.x), -1);\n        o = vec2(int(v.x >= 0.0)*2,1);\n\t}\n\treturn (uv*ma + 0.5 + o)/vec2(4,3);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    #ifdef custom_texture\n    fragColor = texture(iChannel0,sampleCube(rayDir*vec3(1,-1,1)));\n    #else\n    fragColor = texture(iChannel1,rayDir);\n    #endif\n}", "cube_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 340, 340, 401], [403, 403, 432, 432, 483], [485, 485, 510, 510, 657], [659, 659, 692, 692, 756], [758, 758, 806, 806, 951], [953, 953, 971, 971, 1124], [1126, 1126, 1148, 1148, 1686], [1688, 1688, 1744, 1744, 3557]], "test": "untested"}
{"id": "dtGcRh", "name": "Shell Texturing Fur Ball", "author": "Dev1ati0n", "description": "Using the shell texturing technique, described here: https://youtu.be/9dr-tRQzij4 but with slightly more fleshed-out physics.\nHopefully my comments are enough to understand what the program is doing, I added them kind of hastily after the fact.", "tags": ["ball", "shell", "acerola", "shelltexturing"], "likes": 5, "viewed": 235, "published": 3, "date": "1700102373", "time_retrieved": "2024-07-30T17:22:25.111978", "image_code": "// Increase to improve performance\n#define shelldistance 0.003\n\nvoid mainImage_orig( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = normalize(vec3(1,fragCoord/iResolution.x-0.5*iResolution.xy/iResolution.x));\n    vec3 ballpos = vec3(6,0,0);\n    vec2 mouse = texture(iChannel1,vec2(0.25,0.75)).xy;\n    ballpos.yz = mouse/iResolution.x-0.5*iResolution.xy/iResolution.x;\n    ballpos.yz *= ballpos.x;\n    float rad;\n    \n    vec3 curve = 0.00004*vec3(0,texture(iChannel1,vec2(0.75,0.25)).xy); // Retrieve fur curvature direction\n    curve /= length(curve) + 1.; // Apply sigmoid function to curvature amount\n    curve *= 4.;\n    \n    \n    for(rad = 0.333; rad >= 0.; rad -= shelldistance){\n        \n        vec3 center = ballpos+curve*rad*rad; // Calculate shell center\n        \n        float det = dot(uv,center)*dot(uv,center)-dot(center,center)+rad*rad+2.*rad+1.; // Sphere intersection\n        \n        vec3 pos = vec3(0);\n        vec3 nrm = vec3(0);\n        vec3 texuv = vec3(0);\n        float diffuse;\n        \n        if(det>0.){ // If ray intersects sphere\n            \n            pos = uv*(dot(uv,center)-sqrt(det)); // Point on sphere\n            nrm = (pos-center)/(rad+1.); // Normal vector\n            diffuse = .1*dot(nrm,vec3(-0.333,0.667,0.667))+.9; // Lambertian diffuse\n            texuv = 30.*nrm/max(max(abs(nrm.x),abs(nrm.y)),abs(nrm.z)); // Texture UV Coordinates\n            float hairlen = 0.2+0.8*texture(iChannel0,texuv/32.+0.0001).r; // Get hair length\n            float r = sqrlen(fract(texuv+0.0001)-0.5); // Get distance from center of strand\n            r = 2.*sqrt(r-0.2499);\n            if(r<(1.-3.*rad/hairlen)){fragColor=diffuse*.5*(rad+2.)*vec4(0.9,0.7,0.5,1.0); return;}\n        }\n    }\n    \n    float det = dot(uv,ballpos)*dot(uv,ballpos)-dot(ballpos,ballpos)+rad*rad+2.*rad+1.;\n    \n    vec3 pos = vec3(0);\n    vec3 nrm = vec3(0);\n    vec3 texuv = vec3(0);\n    float diffuse;\n    \n    if(det>0.){ // If ray intersects sphere\n        pos = uv*(dot(uv,ballpos)-sqrt(det));\n        nrm = (pos-ballpos)/(rad+1.);\n        diffuse = .1*dot(nrm,vec3(-0.333,0.667,0.667))+.9;\n        fragColor=vec4(0.9,0.7,0.5,1.0)*diffuse;\n        return;\n    }\n    \n    fragColor = vec4(0.7,0.8,0.9,1.); // Sky color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 tcol=vec4(0.);\n    const int AA=4;\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n        vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n        mainImage_orig(fragColor,fragCoord+o);\n        tcol+=clamp(fragColor,0.,1.);\n    }\n    fragColor=tcol/float(AA*AA);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0);\n    float maxSpeed = 3000./iFrameRate;\n    \n    if(uv.y>0.5){\n        if(uv.x<0.5){\n            if(iMouse.xy==vec2(0)){fragColor.xy=iResolution.xy*0.5; return;}\n            vec2 lastmouse = texture(iChannel0,vec2(0.25,0.75)).xy;\n            if(sqrlen2(iMouse.xy-lastmouse)>maxSpeed*maxSpeed){fragColor.xy=lastmouse+maxSpeed*normalize(iMouse.xy-lastmouse); return;} // Limit the ball's speed\n            fragColor.xy=iMouse.xy; return;\n        }\n        if(iFrame==0){fragColor.xy=iResolution.xy*0.5; return;}\n    fragColor.xy = texture(iChannel0,vec2(0.25,0.75)).xy; return;\n    }\n    if(uv.x<0.5){\n        vec2 lastmouse;\n        vec2 lastlastmouse;\n        if(iFrame==0){lastmouse=iResolution.xy*0.5; lastlastmouse=lastmouse;}\n        else{\n            lastmouse = texture(iChannel0,vec2(0.25,0.75)).xy;\n            lastlastmouse = texture(iChannel0,vec2(0.75,0.75)).xy;\n        }\n        vec2 currmouse; // Calculate current ball position\n        if(iMouse.xy==vec2(0)){currmouse=iResolution.xy*0.5;}\n        else if(sqrlen2(iMouse.xy-lastmouse)>maxSpeed*maxSpeed){currmouse=lastmouse+maxSpeed*normalize(iMouse.xy-lastmouse);}\n        else{currmouse=iMouse.xy;}\n        \n        vec2 accel = -currmouse+2.*lastmouse-lastlastmouse; // Calculate acceleration of the ball\n        accel *= iFrameRate*iFrameRate;\n        accel.y += -20000.; // Gravity\n        fragColor.xy = texture(iChannel0,vec2(0.25,0.25)).xy; // Get previous hair velocity\n        fragColor.xy += 12.*(accel-texture(iChannel0,vec2(0.75,0.25)).xy)/iFrameRate; // Apply hair acceleration\n        fragColor.xy *= exp(-6./iFrameRate); // Damping\n        return;\n    }\n    fragColor.xy = texture(iChannel0,vec2(0.75,0.25)).xy+9.*texture(iChannel0,vec2(0.25,0.25)).xy/iFrameRate; // Apply hair velocity\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sqrlen(vec3 x){ // length of a vector squared\n    return dot(x,x);\n}\n\nfloat sqrlen2(vec2 x){ // length of a vector squared\n    return dot(x,x);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 126, 126, 2241], [2243, 2243, 2298, 2298, 2602]], "test": "untested"}
{"id": "dtGcDz", "name": "voronoi largest circle", "author": "ArmandB", "description": "finds the largest circle that fits in a voronoi cell (can generalize to any polygon)\nexceptionally slow\nnote how all the correct circles touch 3 edges\nclick + drag to pan", "tags": ["voronoi"], "likes": 7, "viewed": 264, "published": 3, "date": "1700097299", "time_retrieved": "2024-07-30T17:22:25.874938", "image_code": "struct VoronoiData {\n    float dist;\n    float edgedist;\n    float edgedist2;\n    float edgecornerdist;\n    vec2 edgenormal;\n    vec2 edgenormal2;\n    vec2 edgecornernormal;\n    vec2 point;\n};\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//https://iquilezles.org/articles/voronoilines/\nVoronoiData voronoi2dedges(vec2 uv){\n    vec2 n = floor(uv);\n    vec2 f = fract(uv);\n\n\tvec2 mr;\n\n    float md = 8.0;\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=1; i++){\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash22(n + g);\n        vec2 r = g + o - f;\n        float d = dot(r, r);\n\n        if(d < md){\n            md = d;\n            mr = g + o;\n        }\n    }\n\n    float med = 8.0;\n    float med2 = 8.0;\n    float med3 = 8.0;\n    vec2 men = vec2(0);\n    vec2 men2 = vec2(0);\n    vec2 men3 = vec2(0);\n    for(int j=-2; j<=2; j++)\n    for(int i=-2; i<=2; i++){\n        vec2 g = vec2(i,j);\n\t\tg += hash22(n + g);\n        vec2 k = g - mr;\n\n        float l = dot(g + mr - 2.0*f, k)*0.5/length(k);\n        if (l < med){\n            med3 = med2;\n            men2 = men;\n            med2 = med;\n            men3 = men2;\n            men2 = men;\n            men = k;\n            med = l;\n        } else if (l < med2){\n            med3 = med2;\n            med2 = l;\n            men3 = men2;\n            men2 = k;\n        } else if (l < med3){\n            med3 = l;\n            men3 = k;\n        }\n    }\n\n    return VoronoiData(md, med, abs(med - med2), (abs(med - med2) + abs(med - med3))/(med+0.0001), normalize(men), normalize(men2-men), normalize(men - men2 + men - men3), mr + n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - texelFetch(iChannel0, ivec2(1,0), 0).xy)/iResolution.y*2.0;\n    VoronoiData vuv = voronoi2dedges(uv);\n\n    vec2 p = vuv.point;\n    vec2 pi = p; //bad name lol\n    \n    VoronoiData v;\n    for (int i = 0; i < 32; i++){\n        v = voronoi2dedges(p);\n        p -= v.edgenormal*v.edgecornerdist*0.01;\n        if (v.edgecornerdist < 0.0001) break;\n    }\n\n    // Output to screen\n    fragColor = vec4(1);    \n    fragColor = mix(vec4(0.0),fragColor,smoothstep(0.0,1.0,vuv.edgecornerdist*0.5)); //tertiaries\n    fragColor = mix(vec4(1,0,0,0),fragColor,smoothstep(0.0,0.1,distance(uv,pi))); //secondary edges\n    fragColor = mix(vec4(0.000,0.741,0.012,0),fragColor,smoothstep(0.0,0.01,vuv.edgedist2)); //voronoi point\n    fragColor = mix(vec4(0),fragColor,smoothstep(0.0,0.01,abs(distance(uv,p)-v.edgedist))); //largest circle\n    fragColor = mix(vec4(0),fragColor,smoothstep(0.0,0.01,vuv.edgedist)); //edges\n    fragColor = mix(vec4(0.000,0.882,1.000,0),fragColor,smoothstep(0.0,0.1,distance(uv,p))); //center point\n    //fragColor = vec4(vuv.edgecornerdist);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 215, 215, 348], [350, 398, 434, 434, 1680], [1682, 1682, 1739, 1789, 2871]], "test": "untested"}
{"id": "DtyyDz", "name": "additive ocean wave", "author": "aerowave", "description": "simple wave height map generator mixed with a bump map creates this nifty water effect\nmouse to see other render passes ", "tags": ["wave", "water", "ocean", "additive"], "likes": 1, "viewed": 262, "published": 3, "date": "1700091803", "time_retrieved": "2024-07-30T17:22:26.927125", "image_code": "// this wave shader is based on a diagram i saw somewhere (i forget where)\n// this is the closest thing i could find to it:\n// https://confluence.ecmwf.int/download/attachments/340775481/Fig2.2.2A%20Decomposition%20of%20ocean%20waves%202D.png\n\n\nint waveCount = 50;\nfloat scale = 20.0;\n\nconst float PI = 3.14159265359;\n\n\n// code from https://stackoverflow.com/a/4275343\nfloat rand(vec2 co) {\n    return fract(sin(dot(co + 53.2352, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// one wave cycle is t=0 --> t=1\n// returns float 0-1\nfloat waveShape(float t) {\n    //return t; // sawtooth wave, function input\n    return sin(t * 2.0 * PI) * 0.5 + 0.5; // sine wave\n    //return 1.0 - abs(sin(t * 2.0 * PI)); // sharp sine\n}\n\n\nfloat getHeight(vec2 uv) {\n    float height = 0.0;\n    for (int i = 0; i < waveCount; i++) {\n        // wave attributes\n        float dir = rand(vec2(i, i)) * 2.0 * PI;\n        float offset = rand(vec2(i, -i));\n        float width = rand(vec2(-i, i));\n        \n        // apply wave attributes\n        float propagation = (cos(dir) * uv.x + sin(dir) * uv.y) * scale;\n        propagation *= width;\n        propagation += offset;\n    \n        // get the wave\n        height += waveShape(mod(propagation + iTime, 1.0));\n    }\n    \n    return height / float(waveCount);\n}\n\n\n// code from https://www.shadertoy.com/view/MsScRt\nvec4 bumpFromDepth(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = getHeight(uv);\n    \n  vec2 dxy = height - vec2(\n      getHeight(uv + vec2(step.x, 0.)), \n      getHeight(uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\n\n\n\n// le main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // square resolution divider\n    float res = max(iResolution.x, iResolution.y);\n    \n    // calculated wave normal\n    vec4 normal = bumpFromDepth(fragCoord.xy/res, vec2(res), .1);\n    \n    // Image split (mouse controlled)\n    if (fragCoord.x > iMouse.x) {\n        uv += normal.rg * 0.05;\n        if (fragCoord.y > iMouse.y) {\n            // final image\n            fragColor = texture(iChannel0, uv);\n        } else {\n            // distorted image coordinates\n            fragColor = vec4(uv, 1.0, 1.0);\n        }\n    } else {\n        if (fragCoord.y > iMouse.y) {\n            // height map\n            fragColor = vec4(vec3(getHeight(fragCoord.xy/res)), 1.0);\n        } else {\n            // normal map\n            fragColor = vec4(normal.rgb * 0.5 + 0.5, 1.0);\n        }\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 369, 390, 390, 470], [472, 526, 552, 601, 715], [718, 718, 744, 744, 1285], [1288, 1339, 1398, 1398, 1655], [1660, 1671, 1726, 1776, 2606]], "test": "untested"}
{"id": "dtVyRm", "name": "bad voronoi", "author": "aerowave", "description": "very basic voronoi function based on blender's voronoi. sometimes produces null values (shown as flashing colors)\n\nhash function from https://www.shadertoy.com/view/ttc3zr", "tags": ["2d", "3d", "voronoi"], "likes": 2, "viewed": 168, "published": 3, "date": "1700091743", "time_retrieved": "2024-07-30T17:22:27.859632", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // very professional variable naming i know\n    voronoiOut thing = voronoi(vec3(fragCoord / 100.0, iTime / 2.0));\n    \n    // coloring based on cells\n    vec3 col = thing.rand.xyz * (0.5 * (2.0 - thing.dist));\n    \n    // \n    if (col == vec3(0.0)) {\n        col = vec3(sin(iTime * 40.0) * 0.5 + 0.5);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// Hash Functions\n//\n// murmurHashNM() takes M unsigned integers and returns N hash values.\n// The returned values are unsigned integers between 0 and 2^32 - 1.\n//\n// hashNM() takes M floating point numbers and returns N hash values.\n// The returned values are floating point numbers between 0.0 and 1.0.\n\n//------------------------------------------------------------------------------\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 1 input\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 1 input\nvec2 hash21(float src) {\n    uvec2 h = murmurHash21(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 2 inputs\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 3 inputs\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash24(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 4 inputs\nvec2 hash24(vec4 src) {\n    uvec2 h = murmurHash24(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash31(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 1 input\nvec3 hash31(float src) {\n    uvec3 h = murmurHash31(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash32(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 2 inputs\nvec3 hash32(vec2 src) {\n    uvec3 h = murmurHash32(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash34(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 4 inputs\nvec3 hash34(vec4 src) {\n    uvec3 h = murmurHash34(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash41(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 1 input\nvec4 hash41(float src) {\n    uvec4 h = murmurHash41(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash42(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 2 inputs\nvec4 hash42(vec2 src) {\n    uvec4 h = murmurHash42(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash43(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 3 inputs\nvec4 hash43(vec3 src) {\n    uvec4 h = murmurHash43(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\n/* ========================== */\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nfloat random = 1.0;\n\nstruct voronoiOut {\n    float dist;\n    vec3 rand;\n    vec3 pos;\n};\n\nfloat smoothVoronoi(vec2 uv) {\n    vec2 offset = floor(uv);\n\n    float dist = 1.0;\n    \n    for (float j = -1.0; j <= 1.0; j++) {\n        for (float i = -1.0; i <= 1.0; i++) {\n            dist = smin(dist, distance(uv, vec2(i, j) + offset + hash22(floor(vec2(i, j) + offset))), 0.01);\n        }\n    }\n    return dist;\n}\n\n\nvoronoiOut voronoi(vec2 uv) {\n    vec2 offset = floor(uv);\n\n    voronoiOut data = voronoiOut(1.0, vec3(0), vec3(uv, 0.0));\n    \n    for (float j = -1.0; j <= 1.0; j++) {\n        for (float i = -1.0; i <= 1.0; i++) {\n            float current = distance(uv, vec2(i, j) + offset + (hash22(floor(vec2(i, j) + offset))) * random);\n            if (current < data.dist) {\n                data.dist = current;\n                data.rand = hash32(vec2(i, j) + offset);\n                data.pos = vec3(i, j, 0.0) + vec3(offset + (hash22(floor(vec2(i, j) + offset))) * random, 0.0);\n            }\n        }\n    }\n    \n    return data;\n}\n\nvoronoiOut voronoi(vec3 uv) {\n    vec3 offset = floor(uv);\n\n    voronoiOut data = voronoiOut(1.0, vec3(0), uv);\n    \n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            for (float z = -1.0; z <= 1.0; z++) {\n                float current = distance(uv, vec3(x, y, z) + offset + (hash33(floor(vec3(x, y, z) + offset))) * random);\n                if (current < data.dist) {\n                    data.dist = current;\n                    data.rand = hash33(vec3(x, y, z) + offset);\n                    data.pos = vec3(x, y, z) + offset + (hash33(floor(vec3(x, y, z) + offset))) * random;\n                }\n            }\n        }\n    }\n    \n    return data;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 523]], "test": "untested"}
{"id": "DlycWR", "name": "OZORA FESTIVAL - POSTHELIOS RNG", "author": "POSTHELIOS", "description": "Certainly, let's go through this GLSL (OpenGL Shading Language) shader code.", "tags": ["fractal"], "likes": 9, "viewed": 298, "published": 3, "date": "1700065663", "time_retrieved": "2024-07-30T17:22:28.714347", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*6.5;\n        a=10.;\n        p=mod(p-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime*.3+.5*tan(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.2)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n          g+=e=length(p.yx)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlycWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 890]], "test": "untested"}
{"id": "DlyyWR", "name": "DULL SKULL", "author": "Kris_Katur", "description": "// All work and no play makes Jack a Dull Skull //", "tags": ["raymarching", "normals", "fog", "specular", "softshadows", "diffuse", "skeleton", "fresnel", "skull", "bones", "cineshader"], "likes": 53, "viewed": 1646, "published": 3, "date": "1700064860", "time_retrieved": "2024-07-30T17:22:29.748581", "image_code": "// \"Dull Skull\"\n// 2023\n// by KΛTUR\n// License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n\n/*\n=======================================================================\n\nI plan to spend more time working on this shader; thinking of\nadding a background and finishing up the skeleton later on.\nAny feedback or suggestions on improving performance, whether it's\ntweaking the SDF or enhancing the shading, would be great.\nFeel free to use this shader for your own experiments and development,\nadhering to the specified license. I'd love to see different takes on it!\n  \n=======================================================================\n\nCHOOSE FROM DIFFERENT STYLES HERE\n\n0 = SIMPLE DIFFUSE\n1 = FUNKY FRESNEL & NORMALS\n2 = MORE COMPLEX LIGHTING\n3 = GHOST MODE\n*/\n\n#define SHADE 2\n\n//===================================================================//\n\n#define MAX_STEPS 100\n#define MAX_DIST 15.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n//===================================================================//\n// below by https://iquilezles.org/\n\nfloat sUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sphere(vec3 p,float s){\n    return length(p)-s;\n}\n\nfloat Ellipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat rBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat Box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat HollowSphere( vec3 p, float r, float h, float t ){\n  float w = sqrt(r*r-h*h);\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// above by https://iquilezles.org/\n//===================================================================//\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// by https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n    \n    float angle = 2.*PI/repetitions,\n          a = atan(p.y, p.x)+angle,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) *r ;\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nmat2 RotSin(float a, float b, float c){\n    mat2 rot = Rot(sin(a)*b+c);\n    return rot;\n}\n\nfloat Bone(vec3 p,vec3 a, vec3 b, float delta, float r, float r2, float bb){\n        float bone = Capsule(p,a,b,(abs((pow(p.z-delta,2.))))*r2+r);\n        p.z -= delta;\n        bone = max(bone,rBox(p,vec3(bb),.0));//bounding box\n        return bone;\n}\n\nfloat Finger(vec3 p, float scale, float iter, float r, float r2, float bb, float angle){\n        vec3 a = vec3(0);\n        vec3 b = vec3(0,0,1)*scale;\n        float delta = (b-a).z;\n        p.yz *= Rot(angle*.3);\n        float fbone = Bone(p,a,b,delta/2.,r,r2,bb);\n        \n        float eps = .1;\n        float dist = (b-a).z;\n        \n        for (float i=min(iTime,0.0);i<iter;i++){\n            a.z = b.z+.08;\n            b.z = a.z+dist;\n            delta = a.z+(dist)/2.;\n            dist -= eps;\n            p.z -= a.z;\n            p.yz *= Rot(angle);\n            p.z += a.z;\n            r -= 0.001;\n            \n            fbone = min(fbone,Bone(p,a,b,delta,r,r2,bb));\n            \n        }\n        \n        return fbone;\n}\n\nfloat SceneSDF(vec3 p){\n    \n    float t = iTime;\n    \n// ||||||||||||||||||||============|||||||||||||||||||| //    \n// ==================== UPPER BODY ==================== //\n// ||||||||||||||||||||============|||||||||||||||||||| //    \n    \n    // ===== SPINE ===== //\n    vec3 p_spine = p;\n        p_spine.y -= sin(t*.1)*.3;\n        p_spine.z -= .6+sin(t*.2)*sin(t*.51);\n        vec3 p_vert = p_spine;\n            vec3 sSpine = vec3(.13,.09,.13);\n    float spine = Ellipsoid(p_vert,sSpine);//vertebrae - no anatomical accuracy, just an indication that there are vertebrae :)\n        for (float i=0.;i<5.;i++){\n            p_vert.y += .22;\n            p_vert.z += i*.09;\n            sSpine += .01;\n            spine = min(spine,Ellipsoid(p_vert,sSpine));  \n        }\n    spine -= sin(29.*p_vert.x)*sin(21.*p_vert.y)*sin(9.*p_vert.z*.003);//deformation\n     \n    // ===== COLLARBONE ===== //\n        float side = sign(p_spine.x);//side definition\n    \n    vec3 p_cbone = vec3(abs(p_spine.x),p_spine.yz);\n        p_cbone += vec3(-.2,1.,.5);\n        p_cbone.xz *= Rot(1.8+sin(t*.09)*.2);\n        p_cbone.yz *= Rot(sin((side-.23)*t*.6)*.2);\n    float cbone = Bone(p_cbone+sin(p_cbone.z*3.)*.1, vec3(0),vec3(0,0,1.6),.8,.04,.04,1.5);\n    \n// ======================  ARMS ====================== //  \n\n    // ===== UPPER ARM ===== //\n        p_cbone.xz *= Rot(-1.8-sin(t*.09)*.2);//invert collarbone transformation\n    vec3 p_uArm = vec3(abs(p_cbone.x)-1.8,p_cbone.y+.1,p_cbone.z+.3);\n        float ruAxz = (side-.59)*t*.3;\n        p_uArm.xz *= RotSin(ruAxz,.2,.35);\n        p_uArm.xy *= RotSin((side-.19)*t*.42,sin(t*.18)*.6,0.2);\n        p_uArm.yz *= RotSin((side+.12)*t*.62,.2,.1);\n        p_uArm.z -= 1.;\n    float uABone = Bone(p_uArm,vec3(0,0,-1),vec3(0,0,1),0.,.06,.09,1.3);//bone sdf\n    float uArm = sSubtraction(Sphere(p_uArm+vec3(.08,-0.,-1.1),.13),uABone,.2);//deformation of front end of bone\n    \n    // ===== LOWER ARM ===== //\n    vec3 p_lArm = vec3(p_uArm.x,p_uArm.y,p_uArm.z-1.1);\n        p_lArm.xz *= RotSin(-ruAxz,.3,-.6);\n        float t1 = t*.6+sin(t*.22);     \n        float rlAxySin = (side+.13)*t1*.5;\n        float rlAxyAmo = p_lArm.z*.3;\n        float rlAxyOff = p_lArm.z*.7;\n        p_lArm.xy *= Rot(-.3);\n        p_lArm.xy *= RotSin(rlAxySin,-rlAxyAmo,-rlAxyOff-.2);//crossing Ulna and Radius\n        p_lArm.z -= 1.;\n    vec3 p_lArmS = vec3(abs(p_lArm.x)-.09,p_lArm.yz);//mirroring single bone\n        p_lArmS.x += (abs(pow(p_lArmS.z+.7,2.)))*.04;//bending bones\n        vec3 a = vec3(.1,0,1), b = vec3(0.,0,-1);\n        float r2=.04, bb = 1.5;\n        float r = .03;\n    float lArm = Bone(p_lArmS,a,b,0.,r,r2,1.2);//lower arm\n    float arm = min(lArm, uArm);//union upper and lower arm\n\n    // ===== HANDS ===== //\n        // CARPUS\n        \n        p_lArm.xy *= RotSin(rlAxySin,rlAxyAmo,rlAxyOff+.2);//inverse the crossing of Ulna and Radius\n    vec3 p_hand = p_lArm;\n        p_hand.z -= 1.1;//translate anchor point\n        float t2 = sin(t1)+(side-.19)*t1;\n        p_hand.xy *= Rot(1.5);\n        p_hand.xy *= RotSin(-rlAxySin,1.,0.);\n        p_hand.yz *= RotSin(t2+1.91,1.,.45);\n        p_hand.xy *= RotSin((side-.32)*t1+.3,.1,.1);\n    float hand = Ellipsoid(p_hand,vec3(.2,.04,.1));//ellipsoid as base\n        hand -= (sin(27.*p_hand.x)+sin(37.*p_hand.z)*sin(19.*p_hand.y))*.015;//deformation of ellipsoid\n        \n        // FINGERS\n    vec3 pf = vec3(p_hand.xy,p_hand.z-.2);;\n        r = .03, r2=.7, bb=.5;\n            \n            // POINT\n    vec3 pf1 = pf;\n        pf1.xz += vec2(.13,.08);\n        pf1.xz *= Rot(-.2);\n        float fpoint = Finger(pf1,.3,3.,r,r2,bb,(sin(cos(t2*.5)+t2-.12)*(sin(t2)*.4+.7)*.6-.7));\n            // MIDDEL\n    vec3 pf2 = pf;\n        pf2.z += .03;\n        pf2.xz *= Rot(0.);\n        pf2.xy *= Rot(.2);\n        float fmiddle = Finger(pf2,.32,3.,r,r2,bb,(sin(cos(t2*.3)+t2-.2)*(sin(t2)*.4+.7)*.7-.9));\n            // RING\n    vec3 pf3 = pf;    \n        pf3.xz -= vec2(.13,-.05);\n        pf3.xz *= Rot(.15);\n        pf3.xy *= Rot(.3);\n        float fring = Finger(pf3,.3,3.,r,r2,bb,(sin(cos(t2*.7)+t2-.4)*(sin(t2)*.3+.7)*.8-1.));//+sin(t*.7+.5)*.3-.3);\n            // PINKY\n    vec3 pf4 = pf;    \n        pf4.xz -= vec2(.23,-.12);\n        pf4.xz *= Rot(.5);\n        pf4.xy *= Rot(.4);\n        float fpinky = Finger(pf4,.25,3.,r,r2,bb,(sin(cos(t2*.9)+t2)*(sin(t2)*.2+.6)*.8-1.));//;+sin(t+.7)*.2-.4);\n            // THUMB\n    vec3 pf5 = pf;\n        pf5.xz += vec2(.22,.2);\n        pf5.xz *= Rot(-1.2);\n        pf5.xy *= Rot(-.6);\n        pf5.yz *= Rot(-.2);\n        float thumb = Finger(pf5,.14,2.,0.035,r2,bb,(sin(t2-.16)*(sin(t2)*.6+.8)*.8-1.));//+sin(t+1.2)*.3-.15)*.8;        \n        \n    float fingers = min(fpoint,min(fmiddle,min(fring,min(fpinky,thumb))));//union all fingers\n    \n    hand = min(hand, fingers);//union fingers and carpus = hand\n    arm = min(hand,min(arm,min(cbone,spine)));//union hand, arm, collarbone and spine\n\n\n// ||||||||||||||||||||||=======|||||||||||||||||||||| //    \n// ====================== SKULL ====================== //\n// ||||||||||||||||||||||=======|||||||||||||||||||||| //\n\n    \n    // ===== HEAD ===== //\n    vec3 p_skull = p_spine-vec3(0,.7,.7);\n        p_skull.xy *= RotSin(t*.1,cos(t*.4)*.4,sin(t*.3)*.4);\n        p_skull.yz *= RotSin(t*.13,cos(t*.27)*.2,sin(t*.23)*.1);\n    vec3 p_head = p_skull;\n        float d = Ellipsoid(p_head,vec3(.9,1.1,1.2));//head base\n        float p_cutb = p_head.y+.7 + sin(p_head.x + sin(cos(p_head.z*1.4)) * 21.)*.02; //bottom cut\n    p_cutb = sUnion(p_cutb, Ellipsoid(p_head-vec3(0,-.3,-.2),vec3(.7)),.0);//head hole\n    p_cutb = sUnion(p_cutb, Ellipsoid(p_head-vec3(0,-.24,.5),vec3(.51)),.1);//head hole front    \n    d = sSubtraction(p_cutb, d,.05); //bottom cut\n        float p_cutf = -p_head.z+1.1; //forehead plane\n    d = sSubtraction(p_cutf, d,.2); //forehead cut\n    d = min(d, spine);\n    \n        // TEMPLES\n        float cuts_temple = Capsule(vec3(-abs(p_head.x),p_head.yz), vec3(-1.,-1,.8), vec3(-1.8,3,.0), .5 );//temple deepenings\n    d = sSubtraction(cuts_temple, d,.3); //temple cuts\n        float bcut_temple = Capsule(p_head, vec3(-2.,-1.1,.6), vec3(2,-1.1,.6), .6 );//side cuts\n    d = sSubtraction(bcut_temple, d,.3); //side cuts \n        \n        // ZYGOMATIC ARCH\n    vec3 p_zyg = vec3(abs(p_skull.x),p_skull.yz);\n        p_zyg.x += sin(p_zyg.z*4.+PI)*.08;\n        p_zyg.y += cos(p_zyg.z*9.)*.03;\n        float zyg = Capsule(p_zyg,vec3(.5,-.3,.8),vec3(.75,-.3,0.1),(p_zyg.z)*.1);\n    d = sUnion(d,zyg,.06);\n    \n    // ===== UPPER JAW ===== //\n    vec3 p_jaw = p_skull-vec3(0,.36,.1);\n        p_jaw.yz *= Rot(PI);\n        p_jaw.y -= sin(p_jaw.x*37.)*.007 - cos(p_jaw.z*59.)*.01;//deformation\n        float ujaw = HollowSphere(p_jaw+vec3(0,-.95,.6),.38,.02,.05 );//jaw sdf\n        float p_cutB = p_skull.z-.6;//cutting plane back\n        ujaw = sSubtraction(p_cutB, ujaw,.05); //jaw back cut\n    vec3 p_jawsc = vec3(abs(p_skull.x),p_skull.yz); //new point def for side cuts\n        p_jawsc.xy *= Rot(-1.);\n        p_jawsc.yz *= Rot(-.4);\n        p_jawsc.y += .3; \n        ujaw = sSubtraction(p_jawsc.y, ujaw,.04); //side cuts\n    d = sUnion(ujaw, d,.1);//union upper jaw and d     \n    d -= sin(10.*p_skull.x)*sin(8.*p_skull.y)*sin(7.*p_skull.z)*.01;//deformation head\n        \n    // ===== EYES ===== // \n    \n        // CHEEKBONES\n    vec3 p_eyesur = p_skull-vec3(0,.3,0);\n        float eyesur = Ellipsoid(vec3(abs(p_eyesur.x),p_eyesur.yz)+vec3(-.34,.5,-.87),vec3(.25,.24,.2));//cheekbones   \n        eyesur += sin(12.*p_skull.x)*sin(9.*p_skull.y)*sin(13.*p_skull.z)*.05;//deformation\n    d = sUnion(eyesur, d,.2);//union cheekbones and d\n   \n        // EYE HOLES\n    vec3 p_eye = p_skull;\n        p_eye += sin(p_eye.x*29.+cos(p_eye.y*32.))*.008; //eye distortion\n        float eye = Ellipsoid(vec3(abs(p_eye.x),p_eye.y-.4,p_eye.z)+vec3(-.29,.49,-1.1),vec3(.21,.25,.25)); // eye ball\n        eye = sUnion(eye,Sphere(vec3(abs(p_skull.x),p_skull.yz)-vec3(.25,0.,.7),.35),.05);// eye hole back\n        eye = sSubtraction(-p_eye.y,eye,.2);\n    d = sSubtraction(eye, d,.05); //eye ball subtraction        \n        \n    // ===== NOSE ===== //\n    \n        // NOSE BONE\n    vec3 p_nbone = p_skull;\n        p_nbone.yz *= Rot(-2.2);\n        float nbone = HollowSphere(p_nbone+vec3(0,-1.,.4),.1,0.08,.04 );\n    d = sUnion(d,nbone,.05);\n    \n        // NOSE HOLE\n    vec3 p_nose = vec3(abs(p_skull.x),p_skull.yz);\n        p_nose.xy *= Rot(-.4);\n        float nose = Ellipsoid(p_nose-vec3(-.1,-.3,1.),vec3(.05,.1,.8));\n    d = sSubtraction(nose, d,.06); //nose subtraction\n        \n    // ===== LOWER JAW ===== //\n        \n        // LOWER JAW TRANSFORMATION\n    vec3 pN = p_skull;\n        pN.z -= .5;\n        pN.y += .4;\n        pN.yz *= RotSin(sin(t*.8),sin(t)*.3+smoothstep(0.,1.,sin(t)*.3),-.3);\n        pN.z += .5;\n        pN.y -= .4;\n        pN -= sin(pN.y*15.)*.001 - cos(pN.z*39.)*.001;//deformation\n        \n        // CHIN\n    vec3 p_ljaw = pN;//chin part\n        p_ljaw.yz *= Rot(TAU);\n        p_ljaw.y *= .8;\n        p_ljaw.y -= cos(pN.x*15.+sin(pN.y*7.)*2.)*.01;\n        float ljaw = HollowSphere(p_ljaw+vec3(0,.77,-.74),.38,0.03,.04 );//chin sdf  \n       ljaw = sSubtraction(p_ljaw.z-.65,ljaw,.1);//back cut\n        \n        // MANDIBLE BACK\n    vec3 p_maB = vec3(abs(pN.x),pN.yz);\n        p_maB.yz *= Rot(-1.3);\n        p_maB.xz *= Rot(-.34);\n        p_maB.xy *= Rot(-.39);\n        p_maB -= vec3(0.85,.0,.63);\n       ljaw = sUnion(ljaw,rBox(p_maB,vec3(0.,smoothstep(0.,6.,abs(-p_maB.z)+.9),.45),.04),.17);//union chin + mandible\n       ljaw = sSubtraction(Ellipsoid(p_maB-vec3(.0,.0,-.55),vec3(.5,.15,.26)),ljaw,.04);//mandible top cut to get a V\n        p_ljaw -= sin(p_ljaw.y*32.)*.001 - cos(p_ljaw.z*29.)*.007;//deformation\n       ljaw = sSubtraction(p_ljaw.y+.93,ljaw,.02);//bottom cut\n\n    d = min(ljaw, d);//union chin and d      \n\n    // ===== UPPER TEETH ===== //\n    vec3 p_tooth = p_skull;\n        p_tooth -= vec3(0,-.77,.7);\n        p_tooth *= vec3(1.2,1,1);\n        pModPolar(p_tooth.xz, 32.0);//alignment polar\n\n        float teeth = Ellipsoid(p_tooth - vec3(0.43, 0., 0.), vec3(0.03, 0.15, 0.045));\n        teeth = max(teeth, -p_skull.y-.73+sin(p_skull.x*32.)*.006);//cut teetch bottom\n        teeth = max(teeth, -p_skull.z+.7);// cut teeth back\n    d = min(d,teeth);\n        \n    // ===== LOWER TEETH ===== //\n    vec3 p_ltooth = pN;\n        p_ltooth -= vec3(0,-.77,.7);\n        p_ltooth *= vec3(1.2,1,1);\n        pModPolar(p_ltooth.xz, 32.0);//alignment polar\n\n        float lteeth = Ellipsoid(p_ltooth - vec3(0.42, 0., 0.), vec3(0.03, 0.15, 0.045));\n        lteeth = max(lteeth, pN.y+.79+sin(p_skull.x*29.)*.004);//cut teeth top\n        lteeth = max(lteeth, -pN.z+.7);// cut teeth back\n    d = min(d,lteeth);\n       \n    d = min(d,arm);//union skull, arm, hand and fingers\n    \n    return d;\n}\n\nvec3 RayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat March(vec3 ro, vec3 rd){\n    float h=0.;\n    for(int i=0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float dS = SceneSDF(p);\n        h += dS;\n        if(h>MAX_DIST||abs(dS)<SURF_DIST) break;\n    }\n    return h;\n}\n\nvec3 CalcNormal (vec3 p){\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*SceneSDF(p+.001*e);\n    }\n    return normalize(n);\n}\n\nfloat Light(vec3 p, vec3 lpos){\n    vec3 pos = vec3(lpos);\n    vec3 l = normalize(pos-p);\n    vec3 n = CalcNormal(p);\n    float dif = clamp(dot(n,l), 0., 1.);\n    float d = March(p+n*SURF_DIST*2.,l);\n    \n    if(d<length(pos-p)) dif *=.1;\n    \n    return dif;\n}\n\n//by https://iquilezles.org/\nfloat CalcAO( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n//by https://iquilezles.org/\nfloat CalcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t );\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n    }\n    \n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 ComplexLight( in vec3 ro, in vec3 rd, vec3 l, vec3 material){ \n    vec3  col = vec3(0.0);\n    float d = March(ro,rd);\n\n    if( d>-0.5 )\n    {\n        vec3 p = ro + d*rd;\n        vec3 n = CalcNormal(p);\n        vec3 l = normalize(l);\n        vec3 hal = normalize(l-rd);\n        float dif = clamp(dot(n,l),.0,1.)*CalcSoftshadow(p,l,.01,3.);//diffuse\n\t\tfloat spe = pow(clamp(dot(n,hal),0.,1.),16.0)*clamp(1.2+dot(hal,rd),0.,1.);//specular\n\t\tcol = material*dif*30.*spe;\n        float ao = CalcAO(p,n);//ambient occlusion\n\t\tfloat amb = clamp(.5+.5*n.x,0.,1.);//ambient\n        col += material*amb*ao;\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, sin(iTime*.18)*2.*cos(iTime*.52), 12.5);\n    ro.yz *= Rot(sin(iTime*.41)*.2);\n    ro.xz *= Rot(cos(iTime*.32)*.2);\n    \n    vec3 rd = RayDir(uv, ro, vec3(0,0.,0), 2.);\n    \n    vec3 col = vec3(0);\n    \n    float d = March(ro, rd);\n    \n    if(d<MAX_DIST){ \n        vec3 p = ro + rd*d;\n        vec3 n = CalcNormal(p);\n\n    #if SHADE==0\n    vec3 lpos = vec3(-3,6,6);\n    float dif = Light(p,lpos);\n    col = vec3(dif)*3.+.06;   \n    #endif\n    #if SHADE==1\n    float fresnel = pow(1.+dot(rd, n),3.);\n    col = vec3(fresnel*4.);\n    col *= n*.5+.5;\n    #endif\n    #if SHADE==2\n    vec3 material = vec3(.95,.6,.1);\n    col = ComplexLight( ro, rd, vec3(5,4,3),material);\n    #endif\n    #if SHADE==3\n    col = vec3(1.);\n    #endif\n        \n    }\n\n    col = mix( col, vec3(0), 1.-exp( -0.000002*pow(d,6.)) );//fog    \n    col = pow(col, vec3(.4545)); //gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35233, "src": "https://soundcloud.com/myuu/victors-piano-solo-the-piano-duet-corpse-bride-medley", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyyWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1120, 1120, 1165, 1165, 1264], [1266, 1266, 1317, 1317, 1417], [1423, 1423, 1475, 1475, 1574], [1576, 1576, 1605, 1605, 1631], [1633, 1633, 1667, 1667, 1750], [1752, 1752, 1790, 1790, 1881], [1883, 1883, 1911, 1911, 1998], [2000, 2000, 2049, 2049, 2170], [2172, 2172, 2228, 2228, 2394], [2505, 2505, 2524, 2524, 2586], [2588, 2623, 2673, 2673, 2946], [2948, 2948, 2987, 2987, 3037], [3039, 3039, 3115, 3115, 3289], [3291, 3291, 3379, 3379, 4022], [4024, 4024, 4047, 4047, 14805], [14807, 14807, 14854, 14854, 15039], [15041, 15041, 15071, 15071, 15270], [15272, 15272, 15297, 15395, 15602], [15604, 15604, 15635, 15635, 15865], [15867, 15896, 15937, 15937, 16203], [16205, 16234, 16310, 16310, 16794], [16796, 16796, 16862, 16862, 17418], [17420, 17420, 17477, 17477, 18464]], "test": "untested"}
{"id": "DlKczm", "name": "Magma Shader Uwu", "author": "ativata", "description": "Magma shader", "tags": ["magma", "mnd"], "likes": 3, "viewed": 129, "published": 3, "date": "1700057957", "time_retrieved": "2024-07-30T17:22:30.537472", "image_code": "#define S smoothstep\n#define T iTime\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat Reinhard2(float x) {\n    const float L_white = 4.0;\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvec4 sampleMagma(vec2 uv){\n\n    vec4 col;\n    #define BASE 1.0\n\n    // Output to screen\n    col.r = Reinhard2(cnoise(vec3(uv * 4.,iTime)) + BASE);\n    col.g = Reinhard2(cnoise(vec3(uv * 10.,iTime + 100.)) + BASE);\n    col.b = Reinhard2(cnoise(vec3(uv * 6.,iTime + 200.)) + BASE);\n    \n    return col;\n}\n\n\nvec3 triPlanar(vec3 p, vec3 normal) {\n    normal = abs(normal);\n    normal = pow(normal, vec3(5.0));\n    normal /= normal.x + normal.y + normal.z;\n    return (sampleMagma(p.xy * 0.5 + 0.5) * normal.z +\n            sampleMagma(p.xz * 0.5 + 0.5) * normal.y +\n            sampleMagma(p.yz * 0.5 + 0.5) * normal.x).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    col = triPlanar(rd,rd);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 59, 59, 96], [97, 97, 124, 124, 172], [173, 173, 192, 192, 228], [230, 230, 251, 251, 2523], [2525, 2525, 2551, 2551, 2646], [2649, 2649, 2668, 2668, 2730], [2732, 2732, 2782, 2782, 2973], [2974, 2974, 3000, 3000, 3276], [3279, 3279, 3316, 3316, 3596], [3598, 3598, 3655, 3655, 4052]], "test": "untested"}
{"id": "ctVczD", "name": "Bouncy balls - buffer test", "author": "MrNissenDK", "description": "To save processing power, I am trying to save data in Buffer A the ball's color, base position, and velocity.\nI still need a little work but I am learning how I can save data to use in the next frame, so I potentially can make a quadtree once in a frame.", "tags": ["test", "balls", "bouncy", "buffer", "data", "saving"], "likes": 2, "viewed": 192, "published": 3, "date": "1700043097", "time_retrieved": "2024-07-30T17:22:31.307413", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pointCols = int(iResolution.x) / 2;\n    pointRows = NumberOfPoints / pointCols;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    for(int i = 0; i < NumberOfPoints; ++i) {\n        int x = i % pointCols;\n        int y = i / pointRows;\n    \n        vec4 posvel = texture(iChannel0, vec2(x * 2 + 1, y)/iResolution.xy);\n        vec2 pos = pointPos(posvel.xy, posvel.zw, iTime) * iResolution.xy;\n        float dist = distance(pos, fragCoord);\n        if(dist < 10.0) fragColor += texture(iChannel0, vec2(x * 2, y)/iResolution.xy);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int index = int(fragCoord.x) / 2 + int(fragCoord.y) * int(iResolution.x) / 2;\n    if(index < NumberOfPoints) {\n        bool isColorData = int(fragCoord.x) % 2 == 0;\n        vec2 colorDataPos = fragCoord;\n        if(!isColorData) colorDataPos -= vec2(-1, 0);\n        vec4 color = texture(iChannel0, colorDataPos/iResolution.xy);\n        if (color.a != 1.0) {\n            vec2 base = hash12(index);\n            if(isColorData) fragColor = vec4(hash23(base), 1.0);\n            else {\n                vec2 velocity = hash32(vec3(base, uintBitsToFloat(uSeed)));\n                fragColor = vec4(base, vec2(sin(velocity.x * 6.28), sin(velocity.x * 6.28)) * velocity.y);\n            }\n        } else {\n            fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        }\n    } else {\n        fragColor = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int pointCols = 0;\nint pointRows = 0;\n\nconst int NumberOfPoints = 100;\nconst uint uSeed = 18485549u;\nfloat ConvertToFloat(uint n)\n{\n    uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    uint ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    n &= ieeeMantissa;\n    n |= ieeeOne;\n\n    float f = uintBitsToFloat(n);\n    return f - 1.0;\n}\n//pcg_hash https://stackoverflow.com/questions/70985360/how-to-create-a-3d-random-gradient-out-of-3-passed-values-in-a-fragment-shader\n//minor change to add a seed value\nfloat rand(uint i) {\n    uint state = i + (i * 747796405u + 2891336453u) ^ uSeed;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return ConvertToFloat((word >> 22u) ^ word);\n}\n\nfloat rand(float i) { return rand(floatBitsToUint(i)); }\n\nvec3 hash23(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    randV += dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724));\n    \n    return fract(randV);\n}\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y));\n    randV *= dot(randV, vec2(8183.0119, src.z));\n    \n    return fract(randV);\n}\nvec2 hash12(float i) {\n    vec2 randV = vec2(rand(i), rand(i + 6939.9375));\n    randV *= dot(randV, vec2(8183.0119,4912.9833));\n    \n    return fract(randV);\n}\nvec2 hash12(int i) {return hash12(intBitsToFloat(i));}\n\nvec2 pointPos(vec2 base, vec2 vel, float t) {\n    vec2 bound = vec2(\n        abs(mod(t * vel.x + base.x, 2.0) - 1.0),\n        abs(mod(t * vel.y + base.y, 2.0) - 1.0)\n    );\n    return bound;\n}\n\nfloat dist2segment(vec2 p1, vec2 p2, vec2 p) {\n    vec2 ab = p2 - p1;\n    vec2 ap = p - p1;\n\n    float t = dot(ap, ab) / dot(ab, ab);\n\n    t = clamp(t, 0.0, 1.0);\n\n    vec2 closestPoint = p1 + t * ab;\n\n    return length(p - closestPoint);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 611]], "test": "untested"}
{"id": "DlyyRw", "name": "truchet3D toroidal tetrahedron", "author": "cyperus", "description": "truchet3D  toroidal spherical  tetrahedron", "tags": ["3d", "sdf", "truchet", "tetrahedron", "sphericalprojection"], "likes": 12, "viewed": 231, "published": 3, "date": "1700010551", "time_retrieved": "2024-07-30T17:22:32.753547", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"truchet3D toroidal tetrahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 7.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nint   MAX_MARCHING_STEPS = 310;\nconst float RAY_STEP_FACTOR3 = 230./450.;\nfloat RAY_STEP_FACTOR  = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\nfloat RAY_PRECISION = 1.;\n\nconst float PS_a0 = 12.;\n\n// fog\nconst bool  FOG_ON = true;\nconst float FOG_DENSITY = 2.5E-3;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sens of rotation, sig(sr): rotation direction, abs(sr) : number edges\n    vec2 z = vec2(0.);\n    \n    /// platonic sphere\n    // normalize spherical radius\n    vec3 pn = normalize(p);\n    \n    // projection from n cells to 1 cell.\n    pn = tetra_cells(pn, cell_id, sr);\n    \n    // inverse stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cTeraPolyArc2disk(z);\n\n    // r-polygon-distribution\n    vec2 e = vec2(1.8, 0.5);\n    e.y += 0.1 - 0.1 *cos(3.*atan(z.y, z.x));\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;     \n\n    // stereograpic projection\n    float zz = dot(z,z); pn = vec3(2. * z.x,  2. * z.y, -1. + zz); pn /= 1.+zz;\n\n    // unnormalize spherical radius\n    p = length(p) * pn;\n    \n    /// torus,sphere,2spheres\n    // 3D-space: cartesian3D => cylinder3D transformation\n    rxy = length(p.xy); au = atan(p.y, p.x);\n    \n    // 2D-space: complex plane := radial plane in cylinder 3d coordinates  \n    z = vec2(rxy, p.z);\n    \n    // 2Djulia \n    z = cmul(z,z); z.x -= PS_a0;\n     \n    p = vec3(log(length(z)), 0.5*au/PI, 0.5*atan(z.y,z.x)/PI); // r,u,v\n    z = p.yz; // torus uv\n \n    /// truchet 3d\n    // repetition\n    float nu = 3.*2.*6.;\n    float nv = 2.*2.;\n    float nr = 1.;\n    \n    p *= vec3(nr,nu,nv); // r,u,v\n    p.yzx = p.xyz; \n\n    ivec3 l0 = -ivec3(nv/2.,0,nu/2.); ivec3 l1 = ivec3(nv/2.,nr,nu/2.)-ivec3(1.);\n    vec3 tc_id = floor(p);\n    tc_id = clamp(tc_id, vec3(l0), vec3(l1));\n    vec3 q = p - tc_id -0.5;\n    \n    // random\n    float rnd = hash21(tc_id.xz);  \n    \n    // flip cell direction randomly\n    if(rnd<.5) q.x = -q.x;\n    \n    // sdf\n    float r0 = 0.5; float r1 = 0.125;\n    float d;\n    if(fract(rnd*77.57+iTime/6.)>.75) {\n       // offset-xz circle, id diagonal sub domain\n       vec3 q2 =  length(q.xz-.5)<length(q.xz+.5)\n                ? vec3(q.xz-.5,0.)  \n                : vec3(q.xz+.5,1.);\n       d = sdTorus( vec3(q2.x, q.y, q2.y) , vec2(0.5,r1) );\n    }\n    else {\n       d = opSmoothUnion( sdCylinder( q.zxy, r1 ), sdCylinder( q.xzy, r1 ), 0.05 );\n    }\n\n    //d = opIntersection(d, sdBox( q, vec3(r0*0.9))); // TEST: cell BB\n    //d = sdSphere( q, r0 ); // TEST: cell unequal scaling\n    \n    // cell alpha    \n    float tc_a = sdBox( q, vec3(r0*0.9)); float px = fwidth(tc_a);\n    tc_a = smoothstep(px,-px,tc_a);\n    \n    /// return\n    // torus uv, truchet cell alpha, random cell id\n    mat.xy = z; mat.z = tc_a, mat.w = rnd;    \n    return d;\n}\n\n// intersect\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) {\n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t;\n        float h = map( pos);\n        if( t>dis.y || h<th ) break; // ray outside BB or hit\n        t += h*fh;\n    }\n    if( t<dis.y ) {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) { \n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-2.*PI*1.*time/360.);\n    p.zx = crot(p.zx,-2.*PI*3.*time/360.);\n\treturn p.xyz;\n}\n\n// textures\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 truchet3D(in float rnd, in float a ,in float time) {\n    return mix(vec4(1.), vec4(h2rgb( fract(abs(rnd)*22.93 + time)),1.), a);\n}\n\n// main\nvoid mainImage(out vec4 O, in vec2 fragCoord) {  \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // distance hit ray surface\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px );\n\n        //vec3 sun_col = vec3(1.,1.,0.8);\n        vec3 sky_col = mix(vec3(0.714,0.145,0.318), vec3(0.000,0.482,1.000), rd.y*.5+.5);\n\n        // background\n        vec4 C = vec4(sky_col,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // uv-coords\n            vec2 mat_uv = mat.xy;\n                \n            // draw texture layers from back to front\n            O = vec4(0);\n            #if 1\n            if(O.a<1.) {             \n                C = ribbon( 3.*6.* mat_uv.x, 0.0125*iTime); C.rgb *= 0.7;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            #if 1\n            if(O.a<1.) {\n                C = vec4(vec3(n)*0.5,0.2); // normal\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif            \n            #if 1\n            if(O.a<1.) {            \n                C = truchet3D(mat.w, mat.z, iTime/60.); C.rgb *= 0.5;\n                O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n            #endif\n            C = O;\n                       \n            // lighting\n            vec3  came_li_o   = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir = normalize(p - came_li_o);             // direction\n            vec3  came_li_col = vec3(1.,1.,.5);                       // color\n            float came_li_shi = 10.;                                  // shininess            \n\n            float cosa = 1.;\n            O.rgb += 0.1 * cosa * C.rgb * sky_col;           // amb\n            cosa = clamp(dot(-came_li_dir, n), 0., 1.);\n            O.rgb += 0.5 * cosa * C.rgb * came_li_col;       // dif       \n            cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_shi);           \n            O.rgb += 0.4 *(cosa>0.? cosa:0.) * came_li_col ; // spec\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.6 * sky_col;\n            \n            // fog\n            if(FOG_ON)\n                O.rgb = mix(O.rgb, sky_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [], "common_code": "// References:\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//   https://iquilezles.org/\n\n// const\nconst float PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat pow2( in float x){ return x*x;}\n\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    // x  : periodic in[0,1]\n    // x0 : offset\n    // pw : pulse width in[0,1]\n    // pf : pulse frequency\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn); // in[0.,2.]\n    //return (pp+pn)-(pp*pn);// in[0.,1.]\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb) {\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a) {\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z) {\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w) {\n    return cmul(z,cinv(w));}\n\n// polynomial barycentric approximation\nvec2 cTeraPolyArc2disk(vec2 z) {\n    const int NUM_j = 15;\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n// map spherical platonic solid pyramidal sectors to one sector located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr){\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264°\n    const float a30 = PI/6.;             // 30°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45°\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// distribution\nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = z/r; // TODO: test division by zero\n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    //    float e2 = e.x + d0 * 2. * smoothstep(-1., 1., -sh_a);\n    return dist(r, e2) * z;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// sdf\nfloat opIntersection( float d1, float d2 ) {\n    return max(d1,d2); }\n\nfloat opSmoothUnion( in float d1, in float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float r ) {\n  return length(p.xz)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// color\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); // hue, saturation, value\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyyRw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[850, 850, 872, 872, 3467], [3469, 3482, 3536, 3536, 4272], [4274, 4274, 4319, 4319, 4481], [4483, 4483, 4525, 4525, 4776], [4778, 4790, 4833, 4833, 5024], [5026, 5026, 5083, 5083, 5161], [5163, 5171, 5218, 5259, 8210]], "test": "untested"}
{"id": "dlVcRW", "name": "Smooth Life Nov2023", "author": "amaxwell", "description": "Smooth Life Nov2023", "tags": ["conwaylife"], "likes": 7, "viewed": 227, "published": 3, "date": "1700007688", "time_retrieved": "2024-07-30T17:22:33.754870", "image_code": "// I learned from https://www.shadertoy.com/view/XtdSDn\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sigmoid(float x, float shift, float scale) {\n    return 1.0 / (1.0 + exp((shift - x) * 4.0 / scale));\n}\nfloat combinedSigmoid(float x, float lowerBound, float upperBound, float normFactor) {\n    return sigmoid(x, lowerBound, normFactor) * (1.0 - sigmoid(x, upperBound, normFactor));\n}\nfloat rampStep(float position, float value) {\n    return clamp(value - position + 0.5, 0.0, 1.0);\n}\nfloat random(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nconst float PI = 3.14159265;\n\nconst float speed = 1.0;\nconst float outerRad = 10.0;\nconst float innerRad = 3.0;\n\nconst float lowerBound1 = 0.257;\nconst float upperBound1 = 0.336;\nconst float lowerBound2 = 0.365;\nconst float upperBound2 = 0.549;\nconst float normFactor1 = 0.028;\nconst float normFactor2 = 0.147;\n\nfloat transitionFunction(vec2 uv) {\n    float outerSum = 0.0;\n    float innerSum = 0.0;\n    for (float dx = -outerRad; dx <= outerRad; dx++) {\n        for (float dy = -outerRad; dy <= outerRad; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            float weight = texture(iChannel0, uv + d / iResolution.xy).x;\n            float innerRs = rampStep(innerRad, dist);\n            outerSum += weight * innerRs * (1.0 - rampStep(outerRad, dist));\n            innerSum += weight * (1.0 - innerRs);\n        }\n    }\n    outerSum /= PI * (outerRad * outerRad - innerRad * innerRad);\n    innerSum /= PI * innerRad * innerRad;\n\n    float a = combinedSigmoid(outerSum, lowerBound1, upperBound1, normFactor1);\n    float b = combinedSigmoid(outerSum, lowerBound2, upperBound2, normFactor1);\n    float ratio = sigmoid(innerSum, 0.5, normFactor2);\n    return (a * (1.0 - ratio) + b * ratio) * 2.0 - 1.0;\n}\n\nfloat getVal (vec2 fragCoord) {\n    if (iFrame == 0 || (iMouse.z > 0.0 && length(iMouse.xy - fragCoord) < 20.0)) {\n        return random(fragCoord);\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    return texture(iChannel0, uv).x + speed * transitionFunction(uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(vec3(clamp(getVal(fragCoord), 0.0, 1.0)), 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 113, 113, 176]], "test": "untested"}
{"id": "DtVyzW", "name": "Conway's Game of Life Nov2023", "author": "amaxwell", "description": "Conway's Game of Life", "tags": ["conwaylife"], "likes": 4, "viewed": 187, "published": 3, "date": "1699991141", "time_retrieved": "2024-07-30T17:22:34.709318", "image_code": "// I learned from https://www.shadertoy.com/view/Xd33WS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// takes a coordinate and returns a random float\nfloat random(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// takes a coordinate and returns if it was alive before\nbool getWasAlive (vec2 co) {\n    return texture(iChannel0, co / iResolution.xy).r > 0.5;\n}\n\n// takes a coordinate and returns the number of living neighbors it has\nint countLivingNeighbors (vec2 fragCoord) {\n    int n = 0;\n    for (int dx = -1; dx <= 1; dx++) {\n        for (int dy = -1; dy <= 1; dy++) {\n            if (dx == 0 && dy == 0) continue;\n            if (getWasAlive(fragCoord + vec2(dx, dy))) n++;\n        }\n    }\n    return n;\n}\n\n// takes a coordinate and returns if it should be alive\nbool isNextAlive (vec2 fragCoord) {\n    if (iFrame == 0 || length(iMouse.xy - fragCoord) < 5.0) {\n        return random(fragCoord) > 0.5;\n    }\n    \n    int n = countLivingNeighbors(fragCoord);\n    return n == 3 || (n == 2 && getWasAlive(fragCoord));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool v = isNextAlive(fragCoord);\n    fragColor = vec4(v, v, v, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 114, 177]], "test": "untested"}
{"id": "mtyyRD", "name": "Spiral Terrain", "author": "Peace", "description": "Spiral terrain", "tags": ["terrain", "spiral"], "likes": 7, "viewed": 193, "published": 3, "date": "1699982949", "time_retrieved": "2024-07-30T17:22:35.653792", "image_code": "const int MAX_STEPS = 128;\n#define SURFACE_DIST 0.1\nconst float PI = 3.14159265359;\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n};\n\nfloat spiral(vec3 p) {\n    vec2 uv = p.xy;\n    float l = length(uv) * 8.0 - iTime;\n    vec2 p2 = vec2(sin(l), cos(l));\n    float d = 2.0 - pow(distance(uv, p2), 0.1);\n    d = pow(d, 2.0 - length(uv) * 0.5 + 1.0 / (0.2 + dot(uv, uv)));\n    return dot(p, normalize(vec3(0.2, 0.2, -1))) + d;\n}\n\nfloat SDF(vec3 point)\n{\n    return spiral(point);\n}\n\nvec3 getNormal(vec3 point, float dist)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(dist - vec3(SDF(point - e.xyy), SDF(point - e.yxy), SDF(point - e.yyx)));\n}\n\nHit raymarch(vec3 ro, vec3 rd)\n{\n    Hit hit;\n    hit.min_dist = 99999.;\n    hit.point = ro;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        float sdf = SDF(hit.point);\n        if (abs(sdf) < hit.min_dist) \n        {\n            hit.min_dist = sdf;\n            hit.normal = getNormal(hit.point, hit.min_dist);\n            if (sdf <= SURFACE_DIST)\n                break;\n        }\n        hit.point += rd * sdf * 0.1;\n        hit.dist += sdf;\n    }\n    \n    return hit;\n}\n\nvec3 gammaCorrect(vec3 color, float gamma)\n{\n    return pow(color, vec3(1.0 / gamma));\n}\n\nfloat diffuse(vec3 normal, vec3 light_dir)\n{\n    return max(0.0, dot(normal, light_dir));\n}\n    \nfloat specular(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nvec3 gradient(float z, float d) {\n    return mix(\n\t\tvec3(0.4, 0.8, 1.0),\n\t\tmix(\n\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\tvec3(1),\n\t\t\tz * 0.55\n\t\t),\n\t\t1.0 / (d * 0.033)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / mr;\n    vec3 ro = vec3(0, 0, -1);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    Hit hit = raymarch(ro, rd);\n    \n    vec3 lp = vec3(6, 8, -4);\n    vec3 ld = normalize(lp - hit.point);\n    \n    vec3 vd = normalize(ro - hit.point);\n    float s = specular(ld, vd, hit.normal);\n    float spec = pow(s, 32.);\n    spec += pow(s, 64.);\n    spec += pow(specular(normalize(vec3(5, -10, -2)), vd, hit.normal), 8.);\n    float diff = diffuse(hit.normal, ld);\n    float light = spec + diff;\n\n    vec3 color = gradient(hit.point.z, hit.dist + 32. * light);\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 193, 193, 461], [463, 463, 486, 486, 514], [516, 516, 556, 556, 684], [686, 686, 718, 718, 1162], [1164, 1164, 1208, 1208, 1252], [1254, 1254, 1298, 1298, 1345], [1351, 1351, 1410, 1410, 1506], [1508, 1508, 1541, 1541, 1666], [1669, 1669, 1726, 1726, 2404]], "test": "untested"}
{"id": "dlGcRR", "name": "fractalbach_path_tracer_game", "author": "fractalbach", "description": "Path Tracer Game for Github GameOff 2023.\n\nW,A,S,D keys to move and scale the player.\n\nArrow keys to move the camera.\n\nIncreasing your scale will make your score increase more quickly!", "tags": ["tracer"], "likes": 0, "viewed": 101, "published": 3, "date": "1699942394", "time_retrieved": "2024-07-30T17:22:36.614225", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//================================================\n// Constants\n//------------------------------------------------\nconst float PI = 3.18309886183790671537767526745028724;\nconst float PIE = 6.36619772367581343075535053490057448;\n\n#define MEMORY_WASD       ivec2(0,0)\n#define MEMORY_ARROWS     ivec2(0,1)\n#define MEMORY_START_TIME ivec2(1,0)\n#define MEMORY_SCORE      ivec2(1,1)\n#define MEMORY_HIGH_SCORE ivec2(2,0)\n\n//================================================\n// Some Intersections\n//------------------------------------------------\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n//================================================\n// Starfield\n//------------------------------------------------\n// \"SmallStars (138 chars)\"\n// by P_Malin\n// https://www.shadertoy.com/view/Ml2XDt\n// copied on 11/18/2023\n//\nvoid starfield( out vec4 f, vec2 p )\n{\n    p=p/2e3-.2;\n    float b = ceil(atan(p.x, p.y) * 6e2), h = cos(b), z = h / dot(p,p);\n    f = exp(fract(z + h * b + iDate.wwww) * -1e2) / z;\n}\nvoid starfield( out vec3 f, vec2 p )\n{\n    p=p/2e3-.2;\n    float b = ceil(atan(p.x, p.y) * 6e2), h = cos(b), z = h / dot(p,p);\n    f = exp(fract(z + h * b + iDate.www) * -1e2) / z;\n}\n\n\n//================================================\n// Slit scan tunnel\n//------------------------------------------------\n// by roywig\n// copied on 11/18/2023\n// Inspired by physical slit-scan photography, where you dolly the\n// camera backwards while you drag the image across a slit. This \"slit\" is circular.\n\n// Sound borrowed from https://www.shadertoy.com/view/MdfXWX\n\n\n\n//================================================\n// Random Number Generator\n//------------------------------------------------\n//Quality hashes collection\n//by nimitz 2018 (twitter: @stormoid)\n\n//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#if 1\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n#else\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\nuint baseHash(uvec3 p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.z + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\n//Slower, higher quality\nuint baseHash(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n#endif\n\n//---------------------3D input---------------------\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n//---------------------2D input---------------------\n\nfloat hash12(uvec2 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash32(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n//---------------------1D input---------------------\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash21(uint x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash41(uint x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\n//================================================\n// Fonts\n//------------------------------------------------\n// by kishimisu\n// https://www.shadertoy.com/view/dsGXDt\n\n#define FONT_TEXTURE iChannel2\n#define CHAR_SPACING 0.44\n#define makeStr(func_name) float func_name(vec2 u) { _print \n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n#define _end    ); return d; }\n#define _ch(i)  _ 65+int(i)\n#define _dig(i) _ 48+int(i)\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n#define _SPA    ); u.x -= CHAR_SPACING; (0\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    if (decimals > 0) {\n        (0 _DOT ); // Print a dot\n    }\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n\n//================================================\n// Other\n//------------------------------------------------\n", "buffer_a_code": "#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\nconst float velocity = 15.0;\n\nconst vec2 min_offset_wasd = vec2(-1.0, 0.0);\nconst vec2 max_offset_wasd = vec2( 1.0, 1.0);\n\nconst vec2 min_offset_arrows = vec2(-1.0, -0.2);\nconst vec2 max_offset_arrows = vec2( 1.0,  1.0);\n\n\nvoid handleMemory( out vec4 fragColor, in vec2 fragCoord, float player_scale, bool player_enemy_collision )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    \n    if ( iTime < 0.5 ) { \n        fragColor = vec4(0.); \n        return; \n    }\n    \n    // Movement and Scaling using W,A,S,D\n    if ( coord == ivec2(0,0) )\n    {\n        vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n        vec2 left   = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x * vec2(-0.1,  0.0);\n        vec2 up     = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x * vec2( 0.0,  0.1);\n        vec2 right  = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x * vec2( 0.1,  0.0);\n        vec2 down   = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x * vec2( 0.0, -0.1);\n        \n        offset += (left + up + right + down) * velocity * iTimeDelta;\n        offset = clamp( offset, min_offset_wasd, max_offset_wasd );\n        \n        fragColor.xy = offset;\n    }\n    \n    // Moving the camera around using arrow keys\n    else if ( coord == ivec2(0,1) )\n    {\n        vec2 offset = texelFetch( iChannel0, ivec2(0,1), 0 ).xy;\n        vec2 left   = texelFetch( iChannel1, ivec2(KEY_LEFT ,0), 0 ).x * vec2(-0.1,  0.0);\n        vec2 up     = texelFetch( iChannel1, ivec2(KEY_UP   ,0), 0 ).x * vec2( 0.0,  0.1);\n        vec2 right  = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x * vec2( 0.1,  0.0);\n        vec2 down   = texelFetch( iChannel1, ivec2(KEY_DOWN ,0), 0 ).x * vec2( 0.0, -0.1);\n        \n        offset += (left + up + right + down) * velocity * iTimeDelta;\n        offset = clamp( offset, min_offset_arrows, max_offset_arrows );\n        \n        fragColor.xy = offset;\n    }\n    \n    else if ( coord == MEMORY_START_TIME )\n    {\n        float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n        \n        if ( player_enemy_collision ) {\n            fragColor.x = iTime;\n        } else {\n            fragColor.x = start_time;\n        }\n    }\n    \n    else if ( coord == MEMORY_SCORE )\n    {\n        float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n        if ( player_enemy_collision ) {\n            score = 0.0;\n        }\n        \n        float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n        \n        float new_score = score += iTimeDelta * player_scale; // iTimeDelta + iTimeDelta * (player_scale - 1.0) * 4.0;\n        fragColor.x = new_score;\n        \n    }\n    \n    else if ( coord == MEMORY_HIGH_SCORE )\n    {\n        float high_score = texelFetch( iChannel0, MEMORY_HIGH_SCORE, 0 ).x;\n        float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n        fragColor.x = max( high_score, score );\n    }\n}\n\n\n\n//================================================\n// HEY, YOU! TRY ADJUSTING THESE CONSTANTS :D\n//------------------------------------------------\n\n// Higher numbers --> Higher quality\n// Lower numbers  --> Better Performance\n\nconst int MAX_SAMPLES = 2; // initial number of rays born into the world, for each pixel.\nconst int MAX_DEPTH   = 6; // maximum number of reflections or refractions, for each ray.\n\n\n//================================================\n// Structures\n//------------------------------------------------\n\nstruct ray {\n    vec3 origin;    // point in world-space where the ray begins\n    vec3 direction; // unit-vector for the direction of the ray\n};\n\nstruct hit_result {\n    // bool exists        // true if the ray actually hit something\n    vec3  p;            // point in world-space at which the hit occurred\n    vec3  n;            // normal vector (could point either outside or inside)\n    float t;            // time at which the ray hit\n    bool  front_facing; // normal is pointing outwards\n};\n\nstruct sphere {\n    float radius;\n    vec3  center;\n    uint  material;\n};\n\nstruct camera {\n    float aspect_ratio;\n    int image_width;\n    int image_height;\n    vec3 center;\n    vec3 pixel00_loc;\n    vec3 pixel_delta_u;\n    vec3 pixel_delta_v;\n};\n\nstruct material {\n    uint type; // enumerated value corresponding to unique material types\n    float albedo;\n    float attenuation;\n    float fuzz;\n};\n\n//================================================\n// Constants\n//------------------------------------------------\n\nconst float FLOAT_BIG  = 3.4e38; // not the maximum possible float, but it's up there.\nconst vec3 ALBEDO_METAL_GOLD = vec3(0.8, 0.6, 0.2);\n\n// Material Enumerations\nconst uint MAT_LAMBERTIAN = 1u;\nconst uint MAT_METAL = 2u;\nconst uint MAT_DIELECTRIC = 3u;\nconst uint MAT_CHECKER = 4u;\n\n//================================================\n// Variables\n//------------------------------------------------\n\n// Need to make these variable for the moment so that they can be \n// accessed by the random number generator, but there's gotta be a better way\nint current_sample = 0;\n\n// CAMERA\ncamera cam;\n\n\n//================================================\n// The World\n//------------------------------------------------\n\nconst int MAX_SPHERES = 17;\nconst int ENEMY_INDEX_BEGIN = 5;\nconst int NUM_ENEMIES = 8;\n\nsphere all_spheres[MAX_SPHERES] = sphere[MAX_SPHERES]\n(\n    sphere( -0.2 , vec3( 0.0, -0.3, 2.0), MAT_DIELECTRIC ),    // the sphere you control\n    sphere( 0.2 ,  vec3(1.5, -0.3 , 1.0), MAT_DIELECTRIC ),     // another sphere you may control later (off the right atm)\n    sphere( 200.0 , vec3(0., -200.5 , 0. ), MAT_CHECKER ), // the ground\n    sphere( 1.0,  vec3(-0.8, 3.0, 20.0), MAT_METAL ), // the sun\n    sphere( -1.0, vec3(-0.8, 3.0, 20.0), MAT_DIELECTRIC ), // the moon\n    \n    // some spheres that will approach us through the tunnel\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    \n    // extras\n    sphere( -5.5 , vec3(- 8.0, 2.3 , 15.0 ), MAT_DIELECTRIC ), // the left globe\n    sphere( -5.5 , vec3(  8.0, 2.3 , 15.0 ), MAT_DIELECTRIC ), // the right globe\n    \n    sphere( 2.0 , vec3(-6.0, 1.0 ,  6.0 ), MAT_METAL ), // the left globe\n    sphere( 2.0 , vec3( 6.0, 1.0 ,  6.0 ), MAT_METAL ) // the right globe\n    \n    // sphere( 0.15 , vec3(0.0, 0.0 , 0.0 ), MAT_LAMBERTIAN ), // head\n    // sphere( 0.05 , vec3(0.0, 0.3 , 4.0 ), MAT_DIELECTRIC ), // right arm\n    // sphere( 0.05 , vec3(0.0, 0.3 , 4.0 ), MAT_DIELECTRIC ) // left arm\n);\n\n#define SPHERE_SUN 3\n#define SPHERE_MOON 4\n#define SPHERE_HEAD 15\n#define SPHERE_ARM_LEFT 16\n#define SPHERE_ARM_RIGHT 17\n\n//================================================\n// Update the World\n//------------------------------------------------\n\nvoid update_world()\n{\n    float C = cos(iTime/PIE);\n    float S = sin(iTime/PIE);\n    \n    // Control of the Primary Sphere\n    // all_spheres[0].center.x = (iMouse.x / iResolution.x - 0.5) * 5.0;\n    // all_spheres[0].center.y = (iMouse.y / iResolution.y - 0.5) / 2.0 - 0.15;\n    all_spheres[0].center.z = 2.0;\n    // all_spheres[0].radius   = ((iMouse.y / iResolution.y) / 2.0 + 0.2);\n    \n    vec2 input_wasd = texelFetch( iChannel0, MEMORY_WASD, 0 ).xy;\n    all_spheres[0].center.x = 2.0 * input_wasd.x;\n    all_spheres[0].center.y = ( input_wasd.y ) / 1.0 - 0.21;\n    all_spheres[0].radius   = ( input_wasd.y ) / 1.0 + 0.4;\n    \n    \n    // all_spheres[1].center.x = (iMouse.x / iResolution.x - 0.5) * 5.0 + 0.5;\n    all_spheres[1].center.x = all_spheres[0].center.x;\n    all_spheres[1].center.y = all_spheres[0].center.y + 1.5 * abs(all_spheres[0].radius);\n    all_spheres[1].center.z = 2.0;\n    all_spheres[1].radius   = all_spheres[0].radius;\n    \n    // all_spheres[SPHERE_HEAD].center = all_spheres[1].center + vec3( 0.0, all_spheres[0].radius + all_spheres[SPHERE_HEAD].radius - 0.05, 0.0 );\n\n    /*\n    all_spheres[3].center.x = S;\n    all_spheres[3].center.z = -2.-cos(iTime/PIE);\n    all_spheres[1].center.y = 1. + C;\n    all_spheres[2].cent er.y = 1. + S;\n    */\n\n    // update the sun and moon\n    all_spheres[SPHERE_SUN].center.x = 4.0 * cos(iTime);\n    all_spheres[SPHERE_SUN].center.y = 4.0 * sin(iTime);\n   \n    all_spheres[SPHERE_MOON].center.x = 4.0 * cos(iTime + PI);\n    all_spheres[SPHERE_MOON].center.y = 4.0 * sin(iTime + PI);\n    \n    for (int i = ENEMY_INDEX_BEGIN; i < (ENEMY_INDEX_BEGIN + NUM_ENEMIES); i++) {\n        float zi = 50.0;\n        float zf = -1.0;\n        float tf = 2.5;\n        float rate = (zf - zi) / tf;\n        float newTime = iTime + ( float(i)/float(NUM_ENEMIES) * tf );\n        float t = mod(newTime, tf);\n        all_spheres[i].center.z = zi + rate * t;\n        // all_spheres[i].center.x = ( float(i%5)/5. - 0.5 ) * 6.0;\n        all_spheres[i].center.x = ( hash12( uvec2( newTime/tf, i) ) * 2.0 - 1.0 ) * 3.0;\n        all_spheres[i].center.y = -0.5;\n    }\n}\n\n\n//================================================\n// Utils\n//------------------------------------------------\n\n// point in world-space where ray r would be at time t\nvec3 at( ray r, float t ) {\n    return r.origin + t * r.direction;\n}\n\nbool near_zero(in vec3 v) {\n    return all(lessThan(v,vec3(1e-8)));\n}\n\nbool sphere_sphere_collides( sphere s1, sphere s2 ) {\n    float rsquared = ( abs(s1.radius) + abs(s2.radius) );\n    rsquared *= rsquared;\n    vec3 delta = s2.center - s1.center;\n    return dot(delta,delta) < rsquared;\n}\n\n// RANDOM\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\n// requires 2 randomly generated numbers between (0.0, 1.0)\n/*\nvec3 uniform_sphere_area(vec2 rnds) {\n    vec2 u = rnds;\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n    float r1 = rnds[0];\n    float r2 = rnds[1];\n    float theta = 2. * PI * r1;\n    float phi = acos(1. - 2. * r2);\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x,y,z);\n*/\nvec3 uniform_sphere_area(int sample_number, int depth, vec2 fragCoord) {\n    int i = 0;\n    while (true) {\n        vec3 p = hash33(uvec3(iFrame+i, sample_number*MAX_SAMPLES + depth, fragCoord.x + iResolution.x * fragCoord.y));\n        p = 2. * p - 1.;\n        if (dot(p,p) < 1.)\n            return p;\n    }\n}\n\n// returns a randomly generated normal vector\n// on the outward surface of a sphere\nvec3 random_on_hemisphere(vec3 normal, int sample_number, int depth, vec2 fragCoord) {\n    vec3 on_unit_sphere = 2. * normalize(uniform_sphere_area(sample_number, depth, fragCoord)) + 1.;\n    if ( dot( on_unit_sphere, normal ) > 0. ) \n        return on_unit_sphere;\n    else\n        return -on_unit_sphere;\n}\n\n//================================================\n// Textures\n//------------------------------------------------\n\n// color of a checkered texture, given some uv's and a point in world space.\n// However.. the uv's are actually ignored in this current implementation.\nvec3 color_checkers( vec2 uv, vec3 p )\n{\n    const float CHECKER_SCALE = 1.0 / 1.32;\n    const vec3 CHECKER_COLOR_1 = vec3( 0.1, 0.3, 0.2 );\n    const vec3 CHECKER_COLOR_2 = vec3( 0.9, 0.9, 0.9 );\n    ivec3 ip = ivec3( floor( CHECKER_SCALE * p ) );\n    bool isEven = ( ip.x + ip.y + ip.z ) % 2 == 0;\n    return isEven ? CHECKER_COLOR_1 : CHECKER_COLOR_2;\n}\n\nvec3 sky_color(ray r) {\n    vec3 unit = normalize( r.direction );\n    float a = 0.5 * ( unit.y + 1. );\n    vec3 color1 = vec3( 1.0, 1.0, 1.0 );\n    vec3 color2 = vec3( 0.5, 0.7, 1.0 );\n    vec3 result = mix( color1, color2, a );\n    \n    // special sky experiment! I want to add a starfield eventually.\n    // if ( r.direction.y > cos(iTime/PIE) && r.direction.x < (cos(iTime/PIE)) && r.direction.z < sin(iTime/PIE) ) { result = vec3(1.0, 0.5, 0.5); }\n    // iChannelResolution.x * r.direction;\n    // convert cartesian to spherical coordinates\n    \n    float theta = acos( r.direction.z );\n    float phi = sign( r.direction.y ) * acos( r.direction.x / length(r.direction.xy) );\n    \n    float theta1 = theta / PI;\n    float phi1 = phi / PIE;\n    color2 = vec3(cos(theta1 + iTime*2.), 1., 1.);\n    float trippy = sin(10.*abs(r.direction.z / r.direction.x) + 5.*iTime) * 0.5 + 0.5;\n    \n    color1 = vec3(0.9-trippy, 0.5 , 0.7);\n    \n    result = mix(color1, color2, a);\n    \n    return color1;\n}\n\n\n//================================================\n// Path Tracing\n//------------------------------------------------\n\n\nvec3 tunnel1(in vec2 pt) {\n    pt = 3.0*(pt.xy / iResolution.xy - 0.5)*vec2(iResolution.x/iResolution.y,1);\n    float rInv = 1./length(pt);\n    pt = pt * rInv - vec2(rInv + iTime,0.5);\n    return (texture(iChannel0,pt)*rInv/2.).xyz;\n}\n\nvec3 tunnel_reverse(in vec2 pt) {\n    pt = 3.0*(pt.xy / iResolution.xy - 0.5)*vec2(iResolution.x/iResolution.y,1);\n    float rInv = 1./length(pt);\n    pt = pt * rInv - vec2(rInv - iTime,0.5);\n    return (texture(iChannel0,pt)*rInv/2.).xyz;\n}\n\n// Intersection test between a ray and a sphere. If there's a hit, \n// this function will populate the hit_result and then return true.\nbool hit_sphere(in ray r, in sphere s, float tmin, float tmax, out hit_result res) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float d = half_b * half_b - a * c;\n    if (d <= 0.) { return false; }\n    \n    float sqrtd = sqrt(d);\n    float root = (-half_b - sqrtd) / a;\n    if (root <= tmin || tmax <= root) {\n        root = (-half_b + sqrtd) / a;\n        if (root <= tmin || tmax <= root)\n            return false;\n    }\n    res.t = root;\n    res.p = at(r, root);\n    res.n = normalize( (res.p - s.center) / s.radius );\n    res.front_facing = dot(r.direction, res.n) < 0.;\n    res.n = res.front_facing ? res.n : -res.n;\n    return true;\n}\n\n\nbool scatter_metal(in ray r_in, in hit_result rec, in vec3 albedo, inout vec3 attenuation, inout ray scattered, vec2 fragCoord) {\n    const float fuzz = 0.1; // 0.3; // TODO: make this a material parameter\n    vec3 reflected = reflect(normalize(r_in.direction), rec.n);\n    \n    // vec3 uniform_sphere_area(int sample_number, int depth, vec2 fragCoord) {\n    vec3 vec_random = uniform_sphere_area(current_sample, int(fragCoord.x), fragCoord);\n    \n    scattered = ray(rec.p, reflected + fuzz*vec_random);\n    attenuation = albedo;\n    return true;\n}\n\n\nbool scatter_dielectric(in ray r_in, in hit_result rec, in vec3 albedo, inout vec3 attenuation, inout ray scattered) {\n    attenuation = vec3(1.0, 1.0, 1.0);\n    const float ir = 1.5; // index of refraction, TODO: make this a material parameter\n    float refraction_ratio = rec.front_facing ? (1.0/ir) : ir;\n    vec3 unit_direction = normalize(r_in.direction);\n\n    float cos_theta = min(dot(-unit_direction, rec.n), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    vec3 direction;\n\n    if (cannot_refract)\n        direction = reflect(unit_direction, rec.n);\n    else\n        direction = refract(unit_direction, rec.n, refraction_ratio);\n\n    scattered = ray(rec.p, direction);\n\n    return true;\n}\n\n\nvec3 ray_color( ray r, in vec2 fragCoord, int sample_number, bool player_turns_red ) {\n\n    vec3 final_color = vec3(1., 1., 1.);\n    int depth=0;\n    float reflectance = 0.8;\n    \n    for (depth=0; depth<MAX_DEPTH; depth++)\n    {\n        hit_result best_result;\n        sphere sphere_hit;\n        int sphere_hit_index;\n        float tmin = 0.001;\n        float tmax = FLOAT_BIG;\n        bool hit_anything = false;\n        vec3 col = vec3(0.0, 0.0, 0.0);\n\n        // Check for intersections with spheres\n        for (int i=0; i<MAX_SPHERES; i++)\n        {\n            // if (i==0 && tan(hash12(uvec2(iFrame/12, fragCoord.x + iResolution.x*fragCoord.y))/PIE) < 0.4) { continue; } // HACKY TRANSPARENCY\n            // if ( i==0 && ( int(iResolution.x*fragCoord.y)%2==0 ) ) { continue; } // HACKY TRANSPARENCY\n            // if ( i==0 && ( int(fragCoord.x)%2 == 0 && int(fragCoord.y)%2 == 0 ) ) { continue; } // HACKY TRANSPARENCY\n            sphere s = all_spheres[i];\n            hit_result result;\n            bool hit = hit_sphere( r, s, tmin, tmax, result );\n            if (hit) {\n                hit_anything = true;\n                tmax = result.t;\n                best_result = result;\n                sphere_hit = s;\n                sphere_hit_index = i;\n            }\n        }\n\n        if (hit_anything)\n        {\n            // Calculate where the next ray should go\n            float some_random = hash13(uvec3(iFrame, depth*sample_number, fragCoord.y*fragCoord.x));\n            float another_random = hash13(uvec3(iFrame, depth*sample_number, fragCoord.y*fragCoord.x));\n            \n            ray scattered;\n            vec3 attenuation;\n            \n            if (sphere_hit.material == MAT_METAL && scatter_metal(r, best_result, ALBEDO_METAL_GOLD, attenuation, scattered, fragCoord)) {\n                col = attenuation;\n                r = scattered;\n            } \n            else if (sphere_hit.material == MAT_DIELECTRIC && scatter_dielectric(r, best_result, ALBEDO_METAL_GOLD, attenuation, scattered)) {\n                col = attenuation;\n                r = scattered;\n            }\n            else { \n                // lambertian is the default right now\n                // Determine the color (TODO: do this better)\n                if  (sphere_hit.material == MAT_CHECKER ) {\n                    col = color_checkers( vec2(0.0), best_result.p );\n                } else {\n                    col = 0.5 * (normalize(best_result.n) + 1.); // Normal Vector Debug Color\n                }\n                \n                r.direction = best_result.n + random_on_hemisphere(best_result.n, sample_number, depth, fragCoord); // Lambertian\n                if ( near_zero(r.direction) ) {\n                    r.direction = best_result.n;\n                }\n                r.origin = best_result.p + 0.01 * r.direction;\n            }\n\n            // apply red color if the player sphere has been hit recently\n            if ( player_turns_red && (sphere_hit_index == 0 || sphere_hit_index == 1) ) {\n                col = vec3( 1.0, 0.0, 0.0 );\n            }\n            \n            // Fully Apply Color?\n            final_color *= reflectance * col;\n            \n            // final_color = final_color + col * pow(reflectance, float(depth+1));\n        }\n        else\n        {\n            col = sky_color(r);\n            // if ( tan(hash12(uvec2(iFrame/12, fragCoord.x + iResolution.x*fragCoord.y))/PIE) < 0.4 ) { col *= 0.9 ; } //HACKY COLOR CHANGE\n            // starfield(col, vec2((r.direction.x+1.)/2.*iResolution.x, (r.direction.y+1.)/2.*iResolution.y));\n            final_color *= reflectance * col; // pow(reflectance, float(depth+1));\n            // final_color = col;\n            break;\n        }\n    }\n    \n    if (depth==0) {\n        // starfield(final_color, fragCoord);\n        // final_color = tunnel1(fragCoord) * ( tan(hash12(uvec2(iFrame/12, fragCoord.x+iResolution.x*fragCoord.y))/PIE)<0.5 ? 0.4 : 1. );\n        final_color = sky_color(r);\n    } else {\n        final_color = final_color * pow(reflectance, float(depth));\n    }\n    \n    return final_color;\n}\n\n\n//================================================\n// TEXT\n//------------------------------------------------\nmakeStr1f(printHighScore) _T _o _p _SPA _S _c _o _r _e _COL _SPA _dec(i,0) _end\nmakeStr1f(printScore) _S _c _o _r _e _COL _SPA _dec(i,0) _end\nmakeStr1f(printScale) _S _c _a _l _e _COL _SPA _dec(i,2) _end\n\n\n//================================================\n// Main Image\n//------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // UPDATE WORLD\n    update_world();\n\n    // Collision Check\n    bool player_enemy_collision = false;\n    for ( int i = ENEMY_INDEX_BEGIN; i < (ENEMY_INDEX_BEGIN + NUM_ENEMIES); i++ )\n    {\n        if ( sphere_sphere_collides( all_spheres[0], all_spheres[i] ) ) {\n            player_enemy_collision = true;\n            break;\n        }\n    }\n    \n    // Some variables used to turn the player red if there has been a collision recently\n    float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n    bool player_turns_red = ( iTime - start_time ) < 0.5;\n    \n    // Camera\n    cam.center  = vec3(  0.0,  0.5, -2.0 ); // Point camera is looking from\n    vec3 lookat = vec3(  0.0,  0.5,  3.0 ); // Point camera is looking at\n\n    // Camera Hack for fun\n    vec2 input_arrow_keys = texelFetch( iChannel0, ivec2(0,1), 0 ).xy;\n    cam.center.xy += 5.0 * input_arrow_keys.xy;\n    // lookat.xy = lookat.xy + input_arrow_keys.xy;\n    // cam.center.y = max(cam.center.y, 0.0);\n        \n\n    vec3 vup = vec3(0.0, 1.0,  0.0);     // Camera-relative \"up\" direction\n    float vfov = 45.;\n    float focal_length = length(cam.center - lookat);\n    float theta = radians(vfov);\n    float h = tan(theta/2.); \n\n    // Viewport Calculations\n    cam.aspect_ratio = iResolution.x / iResolution.y;\n    float viewport_height = 2. * h * focal_length;\n    float viewport_width = viewport_height * cam.aspect_ratio;\n    \n    // Calculate the u,v,w unit basis vectors for the camera coordinate frame.\n    vec3 w = normalize(cam.center - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n    // vectors across the viewport\n    vec3 viewport_u = viewport_width * -u;\n    vec3 viewport_v = viewport_height * v;\n    \n    // horizontal and vertical delta vectors from pixel to pixel\n    cam.pixel_delta_u = viewport_u / iResolution.x;\n    cam.pixel_delta_v = viewport_v / iResolution.y;\n    \n    // calculate location of the upper left pixel\n    vec3 viewport_upper_left = cam.center - (focal_length * w) - viewport_u/2. - viewport_v/2.;\n    cam.pixel00_loc = viewport_upper_left + 0.5 * (cam.pixel_delta_u + cam.pixel_delta_v);\n    \n    // AIM AND LOAD THE RAY-CANNON\n    vec3 pixel_center = cam.pixel00_loc + (fragCoord.x * cam.pixel_delta_u) + (fragCoord.y * cam.pixel_delta_v);\n    vec3 ray_direction = pixel_center - cam.center;\n    ray r = ray(cam.center, ray_direction);\n    \n    // FIRE THE RAY CANNONS!!!!\n    vec3 col = vec3(0.,0.,0.);\n    for (int i=0; i<MAX_SAMPLES; i++) {\n        r.origin = cam.center;\n        vec2 offset = hash23( uvec3(iFrame, i, fragCoord.x*fragCoord.y) )/2.;\n        vec3 pixel_sample_square = offset.x * cam.pixel_delta_u + offset.y * cam.pixel_delta_v;\n        vec3 pixel_sample = pixel_center + pixel_sample_square;\n        r.direction = pixel_sample - r.origin;\n        col += ray_color(r, fragCoord, i, player_turns_red);\n    }\n    col = col / float(MAX_SAMPLES);\n    \n    // col = ray_color(r, fragCoord);\n    \n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    // Gamma Correction\n    col = sqrt(col);\n\n\n    // Font on the top\n    float player_scale = ( 1.0 + texelFetch( iChannel0, MEMORY_WASD, 0 ).y * 4.0);\n    float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n    float high_score = texelFetch( iChannel0, MEMORY_HIGH_SCORE, 0 ).x;\n\n    \n    vec2 uv = fragCoord / iResolution.y;\n    const float fontsize = 14.0;\n    uv *= fontsize;        // Scale font with font_size\n    uv.y -= fontsize - 1.; // Start drawing from the top\n    // TEXT HIGH SCORE\n    col -= vec3( 0.2, 0.2, 0.2 ) * printHighScore( uv + vec2( -0.05, 0.05 ), high_score ); // shadow text\n    col += vec3( 0.8, 1.0, 0.8 ) * printHighScore( uv, high_score ); // foreground text\n    uv.y++;\n    // TEXT SCORE \n    vec3 score_col1 = player_turns_red ? vec3( 1.0, 0.0, 0.0 ) : vec3( 0.8, 1.0, 0.8 );\n    col -= vec3( 0.2, 0.2, 0.2 ) * printScore( uv + vec2( -0.05, 0.05 ), score ); // shadow text\n    col += score_col1 * printScore( uv, score ); // foreground text\n    uv.y++;\n    // TEXT PLAYER SCALE\n    col -= vec3( 0.2, 0.2, 0.2 ) * printScale( uv + vec2( -0.05, 0.05 ), player_scale ); // shadow text\n    col += vec3( 0.8, 1.0, 0.8 ) * printScale( uv, player_scale ); // foreground text\n\n    // Prevent out-of-bounds colors\n    col = clamp(col, 0., 1.);\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n    \n    handleMemory( fragColor, fragCoord, player_scale, player_enemy_collision );\n    // fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 121]], "test": "untested"}
{"id": "dtdyWf", "name": "blocktexture", "author": "Jatpeng", "description": "blocktexture", "tags": ["blocktexture"], "likes": 3, "viewed": 129, "published": 3, "date": "1699933356", "time_retrieved": "2024-07-30T17:22:37.532769", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //float ratio = iResolution.x / iResolution.y;\n    float offset = 0.;\n    \n    // Benefited by iq's advice, Thanks very much!\n    // ------------------\n    //vec2 duvdx = dFdx(uv);\n    //vec2 duvdy = dFdy(uv);\n    // ------------------\n    \n    \n    float t1 = uv.x - uv.y;\n    float band = .5;\n    float newtime = iTime*0.5;\n    float t = sin(-newtime-floor(-newtime*2.0/3.1415)*3.1415/2.0);\n\n    \n    if(t1 < -1.*band)\n    {\n    \toffset = -1. * t;\n    }\n    else if(t1 > -1.*band && t1 < 0.)\n    {\n    \toffset = 1.*t;\n    }\n    if(t1 > 0. && t1 < 1.*band)\n    {\n        offset = -1.*t;\n    }\n    else if(t1 >band && t1 < 2.*band)\n    {\n    \toffset = 1. * t;\n    }\n    float u = offset;\n    float v = offset;\n        \n\tvec4 col0 = texture(iChannel0, uv + vec2(offset, offset), -10.);\n    vec2 tempuv =  uv + vec2(offset, offset);\n    if(tempuv.y>1.0 || tempuv.y<0.0)\n    {\n        col0 = vec4(1.0);\n    }\n        if(tempuv.x>1.0 || tempuv.x<0.0)\n    {\n        col0 = vec4(1.0);\n    }\n    vec4 col1 = vec4(smoothstep(0.,0.015, abs(t1 - 1.*band)));\n    vec4 col2 = vec4(smoothstep(0.,0.015, abs(t1 + 0.*band)));\n    vec4 col3 = vec4(smoothstep(0.,0.015, abs(t1 + 1.*band)));\n    \n    \n    //fragColor = mix(col0, vec4(1.), (1.- col1)+(1.-col2)+(1.-col3));\n    \n    fragColor = col0;\n/*\n#if 0\n    if(fragCoord.x / fragCoord.y > ratio)\n    {\n    \toffset = 1. * sin(iTime);\n    }\n    else\n    {\n    \toffset = -1.*sin(iTime);\n    }\n#else   \n    \n    float t1 = fragCoord.x - ratio *fragCoord.y;\n    float t2 = iResolution.x - iResolution.y;\n    float band = (iResolution.x - iResolution.y);\n    if(t1 > t2)\n    {\n    \toffset = sin(.5 *iTime);\n    }\n    else if( ((t1 + 1.*band) > t2) || ((t1 + 2.*band) < t2))\n    {\n    \toffset = -sin(.5 *iTime);\n    }\n    else if( ((t1 + 2.*band) > t2) || ((t1 + 3.*band) < t2))\n    {\n    \toffset = sin(.5 *iTime);\n    }\n    \n    //fragColor = vec4(t1 + 1.*band);\n    \n    \n#endif    \n\n    // My Test\n    //fragColor = texture(iChannel0, uv + offset);\n    \n    // ☆ Benefited by iq's advice, Thanks very much!\n    // ------------------\n    //fragColor = textureGrad(iChannel0, uv + offset, duvdx, duvdy);\n    // ------------------\n    \n    // ☆ Benefited by hornet's advice, Thanks very much!\n    // ------------------\n    vec4 col0 = texture( iChannel0, uv+offset, -10.0);\n    // ------------------\n    \n    vec4 col1 = vec4(smoothstep(0.,0.015, abs(t1 + 1.*band)/iResolution.x));\n    vec4 col2 = vec4(smoothstep(0.,0.015, abs(t1 + 0.*band)/iResolution.x));\n    vec4 col3 = vec4(smoothstep(0.,0.015, abs(t1 - 1.*band)/iResolution.x));\n    fragColor = mix(col0, vec4(1.), (1.- col1)+(1.-col2)+(1.-col3));\n */\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2753]], "test": "untested"}
{"id": "DtGcRh", "name": "Shader_user_video", "author": "Gerych", "description": "Shader_user_video", "tags": ["shaderuservideo"], "likes": 0, "viewed": 180, "published": 3, "date": "1699911742", "time_retrieved": "2024-07-30T17:22:38.416406", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    \n    vec4 texColor = texture(iChannel0,xy);\n    \n    float luminance = (texColor.r + texColor.g + texColor.b) / 3.0;\n    \n    vec3 grayscaleColor = vec3(luminance);\n    \n    vec3 originalColor = texColor.rgb;\n    \n    float t = (sin(iTime*2.0) + 1.0) * 0.5;\n    \n    vec3 mixedColor = mix(grayscaleColor, originalColor, t);\n    \n    texColor.rgb = mixedColor;\n    \n    fragColor = texColor;\n}\n\n\n\n\n", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 499]], "test": "untested"}
{"id": "clccDX", "name": "Syracuse extension", "author": "Elyades", "description": "Julia / Mandelbrot syracuse collatz", "tags": ["juliasyracusecomplex"], "likes": 1, "viewed": 177, "published": 3, "date": "1699897953", "time_retrieved": "2024-07-30T17:22:39.271121", "image_code": "// Fork of \"Test julia set\" by Elyades. https://shadertoy.com/view/ddBczW\n// 2023-11-11 14:54:23\n\nfloat PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan2(uv.y,uv.x)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 power2d(vec2 uv, vec2 z)\n{\n    \n    return( exp2d(times(vec2(log(length(uv)),atan2(uv.y,uv.x)),z) ) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 a(vec2 uv, vec2 p, vec2 q, vec2 k)\n{\n    return( 0.5*(times(uv,oneoverz(p)) - (times(q,uv) + k)) );\n}\n\nvec2 b(vec2 uv, vec2 p, vec2 q, vec2 k)\n{\n    return( 0.5*(times(uv,oneoverz(p)) + times(q,uv) + k) );\n}\n\nvec2 syracusepq(vec2 uv, vec2 p, vec2 q, vec2 k)\n{\n    return( (times(cos2d(PI*uv), a(uv,p,q,k)) + b(uv,p,q,k)) );\n}\n\nvec2 syracuse(vec2 uv)\n{\n    return(-0.25*(times(cos2d(PI*uv),5.0*uv + vec2(2.0,0.0)) - (7.0*uv + vec2(2.0,0.0))));\n}\n\nvec2 function(vec2 uv,vec2 c)\n{    \n    vec2 param = (iMouse.xy/iResolution.xy-0.5)*10.0;\n    vec2 p = vec2(1.0,0.5); vec2 q = vec2(1.0,param.y); \n    //float p = 2.1; float q = 3.0;\n    vec2 k = vec2(param.x,0.0);\n    vec2 result = syracusepq(uv,p,q,k);\n    return (times(result,c) + (c));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5(float iteration)\n{\n    float value = 0.5;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.1,0.0);\n    \n    return (a + b*cos(TWOPI*(c*iteration + d)));\n}\n\nvec2 functionPolar(vec2 uv)\n{\n    float n = 3.0;\n    vec2 c = vec2(0.1,-0.8);\n    vec2 result;\n    result.x = pow(uv.x,n);\n    result.y = n*uv.y;\n    return result;\n}\n\nvec2 cartesianToPolar(vec2 uv)\n{\n    float r = length(uv);\n    float theta = atan(uv.y,uv.x);\n    return vec2(r,theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Offset\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 30.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(0.0,0.0);\n    //zoomPoint += 3.0*(iMouse.xy/iResolution.xy - 0.5);\n    \n    //Zoom\n    float zoomAmount = pow(10.0, -max(iTime-3.0,1.0));\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    // Algorithm to color the pixel\n    float tol = pow(10.0,-6.0);\n    \n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    //vec2 c = 3.0*(iMouse.xy/iResolution.xy - 0.5);\n    //float remainder = 1.0 - mod(iTime/10.0,1.0);\n    vec2 c = uv;\n    float threshold = pow(10.0,8.0);\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > threshold){break;}\n    }\n    \n    \n    \n    if(currentModulus < threshold)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            iterationAmount = int(log(float(((iterationAmount+1)))));\n            int periodFast = 15;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 70;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette5(indexMedium);\n            \n            int periodSlow = 201;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clccDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 292, 324, 410], [412, 412, 433, 433, 485], [487, 487, 508, 508, 562], [564, 564, 594, 594, 747], [749, 749, 780, 780, 846], [848, 848, 872, 872, 971], [973, 973, 1004, 1004, 1082], [1084, 1084, 1105, 1105, 1198], [1201, 1201, 1222, 1222, 1330], [1332, 1332, 1373, 1373, 1438], [1440, 1440, 1481, 1481, 1544], [1546, 1546, 1596, 1596, 1662], [1664, 1664, 1688, 1688, 1781], [1783, 1783, 1814, 1814, 2075], [2077, 2077, 2103, 2125, 2311], [2313, 2313, 2345, 2345, 2544], [2546, 2546, 2575, 2575, 2712], [2714, 2714, 2746, 2746, 2835], [2837, 2837, 2894, 2945, 5211]], "test": "untested"}
{"id": "dtGcRz", "name": "Moire Generator", "author": "Emily_TTG", "description": "It takes a hot minute to warm up but then it gets going", "tags": ["mess"], "likes": 1, "viewed": 214, "published": 3, "date": "1699883605", "time_retrieved": "2024-07-30T17:22:40.041063", "image_code": "float vabs(vec2 v)\n{\n    return sqrt(v.x * v.x + v.y * v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float t = iTime;\n\n    float r = tan(pow(uv.y + t, uv.x));\n    float g = tan(pow(vabs(uv) + t, vabs(uv)));\n    float b = tan(pow(uv.x + t, uv.y));\n\n    vec3 col = vec3(r, g, b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 121, 121, 387]], "test": "untested"}
{"id": "dtGyzR", "name": "VHS Scanlines & FX", "author": "mcstuffings", "description": "Subtle VHS scanline effect with film grain, vertical band, and some glitchiness.", "tags": ["scanlines", "glitch", "vhs", "grainy"], "likes": 6, "viewed": 447, "published": 3, "date": "1699878088", "time_retrieved": "2024-07-30T17:22:40.936668", "image_code": "// VHS Scanline Effect\n// by McStuffings 2023\n// License: MIT\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Scanline settings\n    float blendFactor = 0.1; // Use lower values for subtle scanline effect.\n    float scanlineHeight = 4.0;\n    float scanlineIntensity = 0.25;\n    float scrollSpeed = 16.0; // Use +/- values for up/down movement.\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    \n    // Grain settings\n    float grainIntensity = 2.0;\n    vec2 grainSeed = vec2(12.9898, 78.233) + iTime * 0.1; // Varying the seed over time\n    \n    // Glitch settings\n    // Use higher values in this section for extreme effect.\n    float glitchProbability = 0.4;\n    float glitchIntensityX = 0.001; // Intensity of the horizontal jitter\n    float glitchIntensityY = .003; // Intensity of the vertical jitter\n    \n    // Vertical Band settings\n    float bandSpeed = 0.2;\n    float bandHeight = 0.01;\n    float bandIntensity = 0.2;\n    float bandChoppiness = 0.2;\n    float staticAmount = 0.02;\n    float warpFactor = .005;\n    float chromaAmount = .2;\n    \n    // Moving VHS effect\n    float scanline = sin((uv.y * iResolution.y - iTime * scrollSpeed) * (1.0/scanlineHeight));\n    vec3 vhsColor = color * scanline * scanlineIntensity;\n\n    // Grain effect\n    float grain = fract(sin(dot(fragCoord * uv, grainSeed)) * 43758.5453);\n    vhsColor += grain * grainIntensity;\n\n    // Glitch Effect\n    if (fract(iTime) < glitchProbability) {\n        float glitchOffsetX = (fract(sin(iTime * 12.9898) * 43758.5453) - 0.5) * glitchIntensityX;\n        float glitchOffsetY = (fract(cos(iTime * 78.233) * 43758.5453) - 0.5) * glitchIntensityY;\n        uv += vec2(glitchOffsetX, glitchOffsetY);\n    }\n\n    // VHS Band\n    float bandPos = fract(iTime * bandSpeed);\n    float bandNoise = fract(sin(dot(uv * iResolution.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\n    if (abs(uv.y - bandPos) < bandHeight) {\n        // Add static with choppiness\n        float randomStatic = bandNoise * bandChoppiness;\n        vhsColor += vec3(randomStatic) * staticAmount;\n\n        // Add warp effect with choppiness\n        uv.x += sin(uv.y * iResolution.y * 10.0 + randomStatic) * warpFactor;\n\n        // Chromatic aberration with choppiness\n        vec3 chromaColor = vec3(\n            texture(iChannel0, uv + vec2(chromaAmount * randomStatic, 0.0)).r,\n            texture(iChannel0, uv).g,\n            texture(iChannel0, uv - vec2(chromaAmount * randomStatic, 0.0)).b\n        );\n\n        // Mix chromatic aberration with reduced intensity\n        float adjustedIntensity = bandIntensity * (1.0 - randomStatic);\n        vhsColor = mix(vhsColor, chromaColor, adjustedIntensity);\n    }\n\n    // Original color before applying scanlines (but after the glitch, noise, and vertical band)\n    // If you have an input texture, fetch the color from the texture here\n    vec3 originalColor = texture(iChannel0, uv).rgb;\n\n    // Blend the original color with the VHS effect\n    vec3 finalColor = mix(originalColor, vhsColor, blendFactor);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGyzR.jpg", "access": "api", "license": "mit", "functions": [[63, 63, 118, 118, 3090]], "test": "untested"}
{"id": "DdVcWR", "name": "Ray Marching Color Work in progr", "author": "simplexqwe", "description": "Ray Marching if you have tipps leave a comment\nTap on the Frame to move the Camera ", "tags": ["raymarching", "rmc"], "likes": 1, "viewed": 107, "published": 3, "date": "1699875747", "time_retrieved": "2024-07-30T17:22:41.739521", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 mouse=(iMouse-.5*iResolution.xyxy)/iResolution.xyxy*vec4(2,1,2,1);\n    vec3 col  = Controler(uv,iTime,mouse);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "#define MAX_STEPS 100\n#define MAX_DIST 75.\n#define SURF_DIST .01\n\nfloat pi=radians(200.);\n\nvec3 ref(vec3 r,vec3 n){\n    return r-2.*dot(r,n)*n;\n}\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat SmoothMax(float a,float b,float c){\n    return log(exp(a*c)+exp(b*c))/c;\n}\n\nfloat SmoothMin(float a,float b,float c){\n    return -SmoothMax(-a,-b,c);\n}\n\nfloat capsuleDist(vec3 p,vec3 a,vec3 b,float r){\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n    float t = dot(ba,pa)/dot(ba,ba);\n    t=clamp(t,0.,1.);\n    vec3 c  = a+t*ba;\n    return length(p-c)-r;\n    \n}\n\nfloat torusDist(vec3 p, vec2 r,vec3 a){\n    float x =length(p.xz-a.xz)-r.x;\n    return length(vec2(x,p.y-a.y))-r.y;\n}\n\nfloat boxDist(vec3 p,vec3 s){\n    vec3 d=vec3(0.);\n    d.x=(max(vec3(0).x,abs(p.x)-s.x));\n    d.y=(max(vec3(0).y,abs(p.y)-s.y));\n    d.z=(max(vec3(0).z,abs(p.z)-s.z));\n\n    return length(d);\n}\n\nvec4 GetDist(vec3 p){\n    vec4 s=vec4(0.,1.,6.,1.);\n    vec4 c=vec4(2.5,1.,6.,1.);\n    vec3 C=vec3(2.5,3.,6.);\n    vec3 pn=vec3(0,1,0);\n    \n    vec3 pc=vec3(0.,0.,0.);\n    vec3 sc=vec3(0.,1.,0.);\n    vec3 cc=vec3(0.,0.,1.);\n    vec3 bc=vec3(1.,1.,0.);\n    vec3 tc=vec3(1.,0.,1.);\n    \n    float sphereDist= length(p-s.xyz)-s.w;\n    float planeDist = dot(p,normalize(pn))+15.;\n    float cDist     = capsuleDist(p,c.xyz,C,c.w);\n    float TorusDist = torusDist(p,vec2(3.,1.),vec3(-5.5,0,6.));\n    float BoxDist   = boxDist(p-vec3(-3.,3.5,8.5),vec3(1.));\n    \n    vec4 d =vec4(1.);\n\n    if(d.w>sphereDist)d.xyz=sc;\n    d=vec4(d.xyz,min(d.w,sphereDist));\n\n    if(d.w>planeDist)d.xyz=pc;\n    d=vec4(d.xyz,min(d.w,planeDist));\n\n    if(d.w>TorusDist)d.xyz=tc;    \n    d=vec4(d.xyz,min(d.w,TorusDist));\n    \n    if(d.w>cDist)d.xyz=cc;    \n    d=vec4(d.xyz,min(d.w,cDist));\n\n    if(d.w>BoxDist)d.xyz=bc;    \n    d=vec4(d.xyz,min(d.w,BoxDist));\n    \n    return d;\n}\n\nvec4 RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n  vec4 ds;    \n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p = ro+rd*dO;\n    ds=GetDist(p);\n    dO+=ds.w;\n\n    if(dO>MAX_DIST || abs(ds.w)<SURF_DIST) {\n    break;\n    }\n  }  \n  return vec4(ds.xyz,dO);\n}\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p).w;\n    vec2  e = vec2(.01,0.);\n    \n    vec3  n =d-vec3(\n    GetDist(p-e.xyy).w,\n    GetDist(p-e.yxy).w,\n    GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 GetLight (vec3 p,vec3 n,vec3 LightPos,vec2 Shift,vec3 ton,vec3 vd){\n    LightPos.xz  += Shift;\n    vec3 l        = normalize(LightPos-p);    \n    vec3 dif = vec3(clamp(dot(n,l),0.,1.))*ton;\n    vec4 d   = RayMarch(p+n*SURF_DIST*2.,l);\n    float t   = length(LightPos+p);\n    if(d.w<t)dif*=.1;\n    dif/=t/15.;\n    return dif;\n\n}\n\n\nvec3 refl(vec3 ro,vec3 rd,float w1,vec3 lpo,vec2 shift,float boun){\n    \n    vec4 d=RayMarch(ro,rd);\n    vec3 p=ro+rd*d.w;\n    vec3 n=GetNormal(p);\n    vec3 dif=GetLight(p,n,lpo,shift,vec3(boun),rd);\n    \n    vec4 col=d;\n\n    \n    for(float i=2.;i<boun+2.;i++){\n        d=RayMarch(ro,rd);\n        p=ro+rd*d.w;\n        n = GetNormal(p);\n        \n        vec3 dif1=GetLight(p,n,lpo,shift,vec3(boun),rd);\n        \n        float aw=(i-1.)/i;\n        float nw=1.-(i-1.)/i;\n        \n        col=(col*aw+d*nw);\n        dif=(dif*aw+dif1*nw);\n        \n        rd =ref(rd,n);\n        ro =p+n*SURF_DIST;\n    }\n    \n    return dif*col.xyz*boun;\n}\n\nvec3 Controler (vec2 uv,float iTime,vec4 mouse){\n    \n    vec3 ro  = vec3(0,0,-8);\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1));\n    \n    vec3 ce=vec3(0.,1.,6.);\n    \n    rd.yz*=Rot(mouse.y*pi);\n    ro.yz=(ro.yz-ce.yz)*Rot(mouse.y*pi)+ce.yz;\n    \n    rd.xz*=Rot(mouse.x*pi);\n    ro.xz=(ro.xz-ce.xz)*Rot(mouse.x*pi)+ce.xz;\n    \n    vec3 lpo=vec3(1,15,1);\n    vec2 shift=lpo.xy*Rot(iTime);\n    \n    vec3 col=refl(ro,rd,0.,lpo,shift,2.);\n    \n    return col;\n    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 269]], "test": "untested"}
{"id": "ctGyRR", "name": "Ellipse/Splat - projection", "author": "iq", "description": "Analytic projection of an ellipsoidal splat to screen pixels. Ellipses in world space become ellipses in raster space, and can be analytically determined from the camera and disk geometry. it works well except for gracing angles (div by zero).", "tags": ["2d"], "likes": 31, "viewed": 974, "published": 3, "date": "1699874746", "time_retrieved": "2024-07-30T17:22:42.729873", "image_code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic projection of an ellipsoidal splat (ie, anisotropic\n// surfel) to screen pixels. \n//\n// Ellipses in world space become ellipses when projected to the\n// camera view plane. In fact, these ellipses can be analytically\n// determined from the camera parameters and the 3D ellipse geometry,\n// such that their exact position, orientation and surface area\n// can be computed. This means that, given a ellipse and a camera\n// and buffer resolution, there is an analytical formula that \n// provides the amount of pixels covered by a disk in the image.\n// This can be very useful for implementing LOD on oriented point\n// clouds based on their size in screen.\n//\n// This shader implements this formula, and provides too the\n// center and axes of the ellipse.\n//\n// More info: xxx\n// \n// Sphere  projection: https://www.shadertoy.com/view/XdBGzd\n// Disk    projection: https://www.shadertoy.com/view/mltyDN\n// Ellipse projection: https://www.shadertoy.com/view/ctGyRR\n//\n// NOTE - not working at grazing angles when area tends to zero\n//\n// ---------------------------------------------------------------------------------------------\n// Derivation:\n//\n// Ray  : r(t) = t*d  and d = (x,y,l)\n// Disk : <r-c,n> = 0 and <r-c,u>²+<r-c,v>²-1 = 0 with n = u⨯v\n// So\n//\n//   <t*d-c,n> = 0 --> t*<d,n>-<c,n> = 0 --> t = <c,n>/<d,n> --> r = d<c,n>/<d,n>\n//\n// and\n//\n//   <d*<c,n>/<d,n>-c,u>² + <d*<c,n>/<d,n>-c,v>² - 1 = 0\n//\n// If N=<c,n>, U=<c,u> and V=<c,v>, then\n//\n//   <d*N/<d,n>-c,u>² + <d*N/<d,n>-c,v>² - 1 = 0\n//\n//   (<d*N/<d,n>,u>-U)² + (<d*N/<d,n>,v>-V)² - 1 = 0\n//\n//   (<d,u>*N/<d,n>-U)² + (<d,v>*N/<d,n>-V)² - 1 = 0\n//\n//   (<d,u>² + <d,v>²)N²/<d,n>² + M - 2N(U<d,u>/<d,n> + V<d,v>)/<d,n> = 0\n//\n// With M = (U²+V²-1). Multiplying by <d,n>²,\n//\n//    M<d,n>² - 2N<d,n>(U<d,u> + V<d,v>) + N²(<d,u>² + <d,v>²) = 0\n//\n// so\n//\n//   M*(nx*x+ny*y+nz*l)² \n// - 2N(nx*x+ny*y+nz*l)*[U*(x*ux+y*uy+l*uz) + V*(x*vx+y*vy+l*vz)]\n// + N²((x*ux+y*uy+l*uz)² + (x*vx+y*vy+l*vz)² ) = 0\n//\n// We collect the x², xy, y², x, y and 1 terms\n//\n//  f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F = 0\n//\n// So,\n//\n//  A =    M*nx²   - N*(nx*wx*2    ) + N²*(ux²  +vx²  )\n//  C =    M*ny²   - N*(ny*wy*2    ) + N²*(uy²  +vy²  )\n//  F = l²[M*nz²   - N*(nz*wz*2    ) + N²*(uz²  +vz²  )]\n//  B = 2 [M*nx*ny - N*(nx*wy+ny*wx) + N²*(ux*uy+vx*vy)]\n//  D = 2l[M*nx*nz - N*(nx*wz+nz*wx) + N²*(ux*uz+vx*vz)]\n//  E = 2l[M*ny*nz - N*(ny*wz+nz*wy) + N²*(uy*uz+vy*vz)]\n//\n// with w = U*u + V*v\n//\n// This is an ellipse if B²-4AC<0, otherwise it's a hyperbola\n\nstruct ProjectionResult\n{\n  float area;      // probably all we care about is the area\n  vec2  center;    // but i'm outputing all the information \n  vec2  axisA;     // for debugging and illustration purposes\n  vec2  axisB;     // for debugging and illustration purposes\n  float a, b, c, d, e, f; // implicit ellipse f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F \n};\n\nProjectionResult projectSplat( /* disk center     */ in vec3  splat_c, \n                               /* disk u          */ in vec3  splat_u,\n                               /* disk v          */ in vec3  splat_v,\n\t\t\t\t               /* world to camera */ in mat4  cam,\n\t\t\t\t\t\t\t   /* projection      */ in float fle )\n{\n    // transform to camera space\t\n    vec3 splat_n = cross(splat_u,splat_v );\n\tvec3  c = (cam*vec4(splat_c,1.0)).xyz;\n    vec3  u = (cam*vec4(splat_u,0.0)).xyz;\n    vec3  v = (cam*vec4(splat_v,0.0)).xyz;\n    vec3  n = (cam*vec4(splat_n,0.0)).xyz;\n\n    // get implicit f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F = 0 \n    float U = dot(c,u);\n    float V = dot(c,v);\n    float N = dot(c,n);\n    float M = U*U + V*V - 1.0;\n    vec3  w = U*u + V*v;\n\n    float A =          M*n.x*n.x - N*(n.x*w.x*2.0    ) + N*N*(u.x*u.x+v.x*v.x);\n    float C =          M*n.y*n.y - N*(n.y*w.y*2.0    ) + N*N*(u.y*u.y+v.y*v.y);\n    float F = fle*fle*(M*n.z*n.z - N*(n.z*w.z*2.0    ) + N*N*(u.z*u.z+v.z*v.z));\n    float B = 2.0*    (M*n.x*n.y - N*(n.x*w.y+n.y*w.x) + N*N*(u.x*u.y+v.x*v.y));\n    float D = 2.0*fle*(M*n.x*n.z - N*(n.x*w.z+n.z*w.x) + N*N*(u.x*u.z+v.x*v.z));\n    float E = 2.0*fle*(M*n.y*n.z - N*(n.y*w.z+n.z*w.y) + N*N*(u.y*u.z+v.y*v.z));\n\n    // get ellipse/hyperbola parameters from implicit\n    float k0 = B*B - 4.0*A*C;\n\n    /*\n    // alternative computation for k0\n    vec3  z = vec3( u.z*dot(v,v), v.z*dot(u,u), n.z );\n    float q = dot( vec3(U,V,N), z );\n    k0 = 4.0*N*N * (z.x*z.x + z.y*z.y - q*q);\n    */\n    \n    if( k0>0.0 ) // hyperbola\n    {\n        return ProjectionResult( -1.0, vec2(0.0), vec2(0.0), vec2(0.0), A, B, C, D, E, F );\n    }\n    \n    float k1 = B*B + (A-C)*(A-C);\n    float k2 = sqrt(k1);\n    float k3 = k1 - k2*(A-C);\n    float k4 = A*E*E + C*D*D - B*D*E + F*k0;\n    float k5 = k4 / k3;\n\n    vec2  cen = vec2( 2.0*C*D-B*E, 2.0*A*E-B*D )/k0;\n    float lea = sqrt( (A+C+k2)*k5 )/k0;\n    float leb = sqrt( (A+C-k2)*k5 )/k0;\n    vec2  axa = vec2( k2-(A-C),-B ) * lea;\n    vec2  axb = vec2(  B,k2-(A-C) ) * leb;\n\n  //float area = 3.141593*sqrt(dot(axa,axa)*dot(axb,axb));\n    float area = 6.283185*lea*leb*k3;\n  //float area = 6.283185*sqrt(-k0)*abs(k4)/(k0*k0);\n\n\treturn ProjectionResult( area, cen, axa, axb, A, B, C, D, E, F );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\treturn res;\t\n}\n\n// <o+t*d-c,n> = 0\n// <o-c+t*d,n> = 0\n// <o-c,n>+t*<d,n> = 0\n// t = -<o-c,n>/<d,n>\nfloat iEllipse( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n    vec3  n = cross(u,v);\n    float t = -dot(o-c,n)/dot(d,n);\n    vec3  q = o + d*t;\n    float x = dot(q-c,u);\n    float y = dot(q-c,v);\n    return (x*x+y*y-1.0<0.0) ? t : -1.0;\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    const float N = 10.0;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\n    const vec3 disc[3] = vec3[3]( vec3(-2.0, 1.0, 0.0),\n                                  vec3( 3.0, 1.5, 1.0),\n                                  vec3( 1.0,-1.0, 1.0) );\n    const vec3 disu[3] = vec3[3]( vec3( 0.1, 0.2, 0.1)*4., \n                                  vec3( 0.1,-0.1, 0.2)*4., \n                                  vec3( 0.2, 0.1,-0.1)*4. );\n    const vec3 disv[3] = vec3[3]( cross(disu[0],vec3(0,1,0))*1., \n                                  cross(disu[1],vec3(0,1,0))*1., \n                                  cross(disu[2],vec3(0,1,0))*1.);\n    \n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n    for( int i=0; i<3; i++ )\n    {\n        float h = iEllipse( ro, rd, disc[i], disu[i], disv[i] );\n        if( h>0.0 && h<tmin ) \n        { \n            tmin = h; \n            pos = ro + h*rd;\n            nor = normalize(cross(disu[i],disv[i])); \n            sur = 0.5 + 0.5*cos(float(i)*2.0+vec3(0.0,2.0,4.0));\n        }\n    }\n\n    float h = (-2.0-ro.y)/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n        sur = vec3(1.0)*gridTextureGradBox( pos.xz, dFdx(pos.xz), dFdy(pos.xz) );\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n        nor = nor * sign( -dot(nor,rd) );\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\n\t\tfloat sha = 1.0;\n        if( ndl>0.0 )\n        {\n            for( int i=0; i<3; i++ )\n            {\n                if( iEllipse( pos+nor*0.001, lig, disc[i], disu[i], disv[i] ) > 0.0 )\n                {\n                    sha = 0.0;\n                    break;\n                }\n            }\n        }\n\t\tcol = (0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t//-------------------------------------------------------\n    // display ellipses\n\t//-------------------------------------------------------\n    for( int i=0; i<3; i++ )\n\t{\n        ProjectionResult r = projectSplat( disc[i], disu[i], disv[i], cam, fov );\n\n        // display conic section border\n        float f = r.a*p.x*p.x + r.b*p.x*p.y + r.c*p.y*p.y + r.d*p.x + r.e*p.y + r.f;\n        vec2  g = 2.0*vec2(r.a,r.c)*p.xy + r.b*p.yx + vec2(r.d,r.e);                   \n        float d = abs(f)/length(g);\n        col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.00,0.01, d) );\n\n        // if ellipse, display area, center and axes\n        if( r.area>0.0 )\n        {\n            r.area *= iResolution.y*iResolution.y*0.25;\n            col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.00,0.01, sdSegment( p, r.center-r.axisA, r.center+r.axisA ))  );\n            col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.00,0.01, sdSegment( p, r.center-r.axisB, r.center+r.axisB ))  );\n            col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.03,0.04, length(p-r.center)) );\n            vec2 pp = r.center + 0.5*max( max( r.axisA, -r.axisA ), max( r.axisB, -r.axisB ) );\n            col = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))/0.07, floor(r.area) ) );\n        }\n    }\n    //-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGyRR.jpg", "access": "api", "license": "mit", "functions": [[4080, 4080, 4397, 4431, 6343], [8009, 8092, 8156, 8156, 8336], [8338, 8338, 8381, 8381, 8501], [8503, 8503, 8568, 8568, 8827], [8829, 8829, 8886, 8886, 12805]], "test": "error"}
{"id": "ctdcWB", "name": "wave simulation 2.0", "author": "Schatten2020", "description": "simulates waves with a bit more information", "tags": ["wavesimulation"], "likes": 6, "viewed": 171, "published": 3, "date": "1699862396", "time_retrieved": "2024-07-30T17:22:43.500812", "image_code": "#define pi 3.1415926535\n//#define intensityLossMult 1.\n//#define interferenceTollarence .02\n//#define doDistortion\n\n\nconst vec3 constructiveInterferenceCol = vec3(10, 10, -10);\nconst vec3 destructiveInterferenceCol  = vec3(-10, 10, 10);\n\nstruct Wave {\n    vec2 origin;\n    float speed;\n    float energy;\n    float frequency;\n};\n\nconst Wave [] waves = Wave[] (\n    Wave(vec2(.25, .5), 5., 1., 10.),\n    Wave(vec2(.5, .75), 5., 1., 10.),\n    Wave(vec2(.75, .5), 5., 1., 10.)\n);\n\n\n\nfloat calcWave(vec3 pos, Wave wave) {\n    vec2 uv = pos.xy;\n    float iTime = -pos.z;\n    float dst = distance(uv, wave.origin);\n    float dstPhase = dst*wave.frequency * pi;\n    float timeDiff = iTime * wave.speed;\n    float waveVal = sin(dstPhase + timeDiff);\n    waveVal *= wave.energy;\n    #ifdef intensityLossMult\n        float circumference = 2. * pi * dst;\n        float intensityLoss = waveVal - waveVal/circumference;\n        intensityLoss *= intensityLossMult;\n        if(sign(waveVal-intensityLoss) != sign(waveVal)) {\n            waveVal = 0.;\n        } else {\n            waveVal -= intensityLoss;\n        }\n    #endif\n    return waveVal;\n}\n#ifdef interferenceTollarence\nvec2 calcInterference(vec2 uv) {\n    float con = 0.;\n    float des = 0.;\n    int len = waves.length();\n    float mult = 1. / (float(len) * (float(len)-1.) * .5);\n    for(int i = 0; i < len; i++) {\n        Wave wav1 = waves[i];\n        float s1 = distance(wav1.origin, uv);\n        float lambda1 = 2. / wav1.frequency;\n        \n        for(int j = i+1; j < len; j++) {\n            Wave wav2 = waves[j];\n            float lambda2 = 2. / wav2.frequency;\n            if(lambda1 != lambda2) continue;\n            \n            float s2 = distance(waves[j].origin, uv);\n            float ds = abs(s1-s2);\n            float n = abs(ds/lambda1);\n            while(n > 1.) {\n                n -= 1.;\n            }\n            if(abs(n) < interferenceTollarence) {\n                con += mult;\n            } else if (abs(n - .5) < interferenceTollarence) {\n                des += mult;\n            }\n        }\n    }\n    return vec2(con, des);\n}\n#else\nvec2 calcInterference(vec2 uv) {return vec2(0);}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef doDistortion\n        vec2 uv = fragCoord/iResolution.xy;\n    #else\n        vec2 uv = fragCoord/iResolution.y;\n    #endif\n    vec3 pos = vec3(uv, iTime);\n    vec3 col = vec3(0);\n    \n    float sum = 0.;\n    for(int i = 0; i < waves.length(); i++) {\n        sum += calcWave(pos, waves[i]);\n    }\n    float correctedSum = sum/float(waves.length());\n    col.r -= correctedSum;\n    col.g += correctedSum;\n    col = clamp(col, 0., 1.);\n    vec2 interference = calcInterference(uv);\n    col += interference.y * destructiveInterferenceCol;\n    col += interference.x * constructiveInterferenceCol;\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 516, 516, 1132], [2160, 2160, 2217, 2217, 2849]], "test": "untested"}
{"id": "dttcDs", "name": "GptLSL", "author": "jackjackdev", "description": "Gpt made the first version of this shader, then I helped a little", "tags": ["gpt"], "likes": 2, "viewed": 122, "published": 3, "date": "1699854441", "time_retrieved": "2024-07-30T17:22:44.332588", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // uv.x *= iResolution.x / iResolution.y;\n\n    float color = 0.0;\n    vec2 p = uv * 2.0;\n    float time = iTime * 0.5;\n\n    for (int i = 0; i < 20; i++) {\n        p = abs(sin(p)) / dot(p, p) - vec2(cos(time * 0.5) + 1., sin(time * 0.5));\n        color += exp(-length(p*10.0 - vec2(0.8, 0.2)));\n    }\n\n    color = sqrt(color);\n    float grayscale = 0.8 + 0.5 * cos(color + time);\n\n    fragColor = vec4(vec3(grayscale), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 551]], "test": "untested"}
{"id": "mltyDN", "name": "Disk/Surfel/Splat - projection", "author": "iq", "description": "Analytic projection of a disk to screen pixels. Disks in world space become ellipses in raster space, and can be analytically determined from the camera and disk geometry. it works well except for gracing angles (div by zero).", "tags": ["3d", "projection", "analytic", "disk"], "likes": 37, "viewed": 663, "published": 3, "date": "1699827867", "time_retrieved": "2024-07-30T17:22:45.343884", "image_code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic projection of a disk to screen pixels. \n\n// Disks in world space become ellipses when projected to the\n// camera view plane. In fact, these ellipses can be analytically\n// determined from the camera parameters and the disk geometry,\n// such that their exact position, orientation and surface area\n// can be computed. This means that, given a disk and a camera\n// and buffer resolution, there is an analytical formula that \n// provides the amount of pixels covered by a disk in the image.\n// This can be very useful for implementing LOD on oriented point\n// clouds based on their size in screen.\n//\n// This shader implements this formula, and provides too the\n// center and axes of the ellipse.\n//\n// More info: xxx\n// \n// Sphere  projection: https://www.shadertoy.com/view/XdBGzd\n// Disk    projection: https://www.shadertoy.com/view/mltyDN\n// Ellipse projection: https://www.shadertoy.com/view/ctGyRR\n//\n// NOTE - not working at grazing angles when area tends to zero\n//\n// ---------------------------------------------------------------------------------------------\n// Derivation:\n//\n// Ray  : r(t) = t*d  and d = (x,y,-l)\n// Disk : <r-c,n> = 0 and |r-c|²-r² = 0\n// So\n//\n//   <t*d-c,n> = 0 --> t*<d,n>-<c,n> = 0 -->\n//   t = <c,n>/<d,n> --> r = d*<c,n>/<d,n>\n//\n// and\n//\n//   |d*<c,n>/<d,n>-c|²-r²=0 -->\n//   |d|²<c,n>²/<d,n>² - 2<c,d><c,n>/<d,n> + |c|²-r² = 0 -->\n//   |d|²<c,n>² + (|c|²-r²)*<d,n>² - 2<c,d><c,n><d,n> = 0\n//\n// If M=|c|²-r² and N=<c,n> then\n//\n//   M<d,n>² - 2N<c,d><d,n> + |d|²N² = 0\n//\n// So\n//\n//   M*(nx*x+ny*y-nz*l)² - 2N(cx*x+cy*y-l*cz)(nx*x+ny*y-nz*l) + (x²+y²+l²)N² = 0\n//\n// We collect the x², xy, y², x, y and 1 terms\n//\n//  f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F = 0\n//\n// like so\n//\n//  A =    M*nx² - 2N*cx*nx + N²\n//  C =    M*ny² - 2N*cy*ny + N²\n//  F = l²[M*nz² - 2N*nz*cz + N²]\n//  B = 2 [M*nx*ny - N*(cx*ny+cy*nx)]\n//  D = 2l[M*nx*nz - N*(cx*nz+cz*nx)]\n//  E = 2l[M*ny*nz - N*(cy*nz+cz*ny)]\n//\n// This is an ellipse if B²-4AC<0, otherwise it's a hyperbola\n//\n// Find center of the ellipse by making the gradient zero\n//\n//   ∇f(x,y) = 0\n//\n// so\n//\n//   2Ax + By + D = 0 and 2Cy + Bx + E = 0 -->\n//   center = {x,y} = { 2CD-BE, 2AE-BD } / k0\n//\n// with \n//\n//   k0 = B² - 4AC\n//\n// Find rotation anf offest from canonical ellipse\n//\n//   x²/a² + y²/b² - 1 = 0\n//\n// to get\n//   [(x-2CD+BE)*u - (y-2AE+BD)*v]²/(k0²a²) + \n//   [(x-2CD+BE)*v + (y-2AE+BD)*u]²/(k0²b²) - 1 = 0\n// Match terms again, the solve for (u,v,a,b)\n//  axa = ( u,v)*a = { k2-(A-C) , -B } * √((A+C+k2)*k5) / k0;\n//  axb = (-v,u)*b = {  B , k2-(A-C) } * √((A+C-k2)*k5) / k0;\n// with \n//  k1 = B² + (A-C)²\n//  k2 = √k1\n//  k5 = (AE² + CD² - BDE + F*k0) / (k1-k2*(A-C))\n\nstruct ProjectionResult\n{\n    float area;      // probably all we care about is the area\n    vec2  center;    // but i'm outputing all the information \n    vec2  axisA;     // for debugging and illustration purposes\n    vec2  axisB;\n    // implicit ellipse f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F\n\tfloat a, b, c, d, e, f; \n};\n\nProjectionResult projectDisk( /* disk center   */ in vec3  disk_cen, \n                              /* disk normal   */ in vec3  disk_nor,\n                              /* disk radius   */ in float disk_rad,\n\t\t\t\t              /* camera matrix */ in mat4  cam,\n\t\t\t\t\t\t\t  /* projection    */ in float fle )\n{\n    // transform to camera space\t\n\tvec3  c = (cam*vec4(disk_cen,1.0)).xyz;\n    vec3  n = (cam*vec4(disk_nor,0.0)).xyz;\n\n    // get implicit f(x,y) = Ax² + Bxy + Cy² + Dx + Ey + F = 0 \n    float M = dot(c,c) - disk_rad*disk_rad;\n    float N = dot(c,n);\n\n    float A =          M*n.x*n.x - 2.0*N*c.x*n.x + N*N;\n    float C =          M*n.y*n.y - 2.0*N*c.y*n.y + N*N;\n    float F = fle*fle*(M*n.z*n.z - 2.0*N*c.z*n.z + N*N);\n    float B = 2.0*    (M*n.x*n.y - N*(c.x*n.y+c.y*n.x));\n    float D = 2.0*fle*(M*n.z*n.x - N*(c.z*n.x+c.x*n.z));\n    float E = 2.0*fle*(M*n.y*n.z - N*(c.y*n.z+c.z*n.y));\n    \n    // get ellipse parameters from implicit\n    float k0 = B*B - 4.0*A*C;\n    float k1 = B*B + (A-C)*(A-C);\n    float k2 = sqrt(k1);\n    float k3 = k1 - k2*(A-C);\n    float k4 = A*E*E + C*D*D - B*D*E + F*k0;\n    float k5 = k4 / k3;\n\n    vec2  cen = vec2( 2.0*C*D-B*E, 2.0*A*E-B*D )/k0;\n    float lea = sqrt( (A+C+k2)*k5 )/k0;\n    float leb = sqrt( (A+C-k2)*k5 )/k0;\n    vec2  axa = vec2( k2-(A-C),-B ) * lea;\n    vec2  axb = vec2(  B,k2-(A-C) ) * leb;\n\n  //float area = 3.141593*sqrt(dot(axa,axa)*dot(axb,axb));\n    float area = 6.283185*lea*leb*k3;\n  //float area = 6.283185*sqrt(-k0)*abs(k4)/(k0*k0);\n\n\treturn ProjectionResult( area, cen, axa, axb, A, B, C, D, E, F );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat iDisk( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n\tvec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    const float N = 10.0;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\n    const vec4 disc[3] = vec4[3]( vec4(-2.0, 1.0,0.0,1.1),\n                                  vec4( 3.0, 1.5,1.0,1.2),\n                                  vec4( 1.0,-1.0,1.0,1.3) );\n    const vec3 disn[3] = vec3[3]( vec3(-1.0, 1.0, 1.0),\n                                  vec3( 2.0, 1.5,-1.0),\n                                  vec3( 2.0,-2.0, 1.0) );\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n    for( int i=0; i<3; i++ )\n    {\n        float h = iDisk( ro, rd, disc[i].xyz, disn[i], disc[i].w );\n        if( h>0.0 && h<tmin ) \n        { \n            tmin = h; \n            pos = ro + h*rd;\n            nor = normalize(disn[i]); \n            sur = 0.5 + 0.5*cos(float(i)*2.0+vec3(0.0,2.0,4.0));\n  //          sur *= smoothstep(-0.6,-0.2,sin(20.0*length(pos-disc[i].xyz)));\n        }\n    }\n\n    float h = (-2.0-ro.y)/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n        sur = vec3(1.0)*gridTextureGradBox( pos.xz, dFdx(pos.xz), dFdy(pos.xz) );\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n        nor = nor * sign( -dot(nor,rd) );\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\n\t\tfloat sha = 1.0;\n        if( ndl>0.0 )\n        {\n            for( int i=0; i<3; i++ )\n            {\n                if( iDisk( pos+nor*0.001, lig, disc[i].xyz, disn[i], disc[i].w ) > 0.0 )\n                {\n                    sha = 0.0;\n                    break;\n                }\n            }\n        }\n\t\tcol = (0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t//-------------------------------------------------------\n    for( int i=0; i<3; i++ )\n\t{\n        ProjectionResult r = projectDisk( disc[i].xyz, disn[i], disc[i].w, cam, fov );\n        r.area *= iResolution.y*iResolution.y*0.25;\n        if( r.area>0.0 )\n        {\n        \tfloat showMaths = smoothstep( -0.5, 0.5, cos(0.5*6.2831*iTime) );\n            float f = r.a*p.x*p.x + r.b*p.x*p.y + r.c*p.y*p.y + r.d*p.x + r.e*p.y + r.f;\n            vec2  g = 2.0*vec2(r.a,r.c)*p.xy + r.b*p.yx + vec2(r.d,r.e);                   \n            float d = abs(f)/length(g);\n            col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, d)));\n            col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( p, r.center-r.axisA, r.center+r.axisA )) ));\n            col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( p, r.center-r.axisB, r.center+r.axisB )) ));\n            col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.03,0.04, length(p-r.center))));\n            vec2 pp  = r.center + 0.5*max( max( r.axisA, -r.axisA ), max( r.axisB, -r.axisB ) );\n            col = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))/0.07, floor(r.area) ) );\n        }\n    }\n    //-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltyDN.jpg", "access": "api", "license": "mit", "functions": [[4223, 4223, 4528, 4562, 5801], [7468, 7468, 7532, 7532, 7650], [7652, 7652, 7695, 7695, 7815], [7817, 7817, 7882, 7882, 8141], [8143, 8143, 8200, 8200, 11943]], "test": "error"}
{"id": "DtdyDl", "name": "Examples of grad(f(noise(g(r))))", "author": "FordPerfect", "description": "Analytical derivatives of a few noise transformations.\n\nTop-left: numerical gradient.\nTop-right: analytical gradient.\nBottom: their difference (magnified).\nCenter: function value.", "tags": ["noise", "gradient", "derivative"], "likes": 3, "viewed": 172, "published": 3, "date": "1699825886", "time_retrieved": "2024-07-30T17:22:46.146738", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// iq described how to compute noise and its analytical derivatives\n// in the following articles:\n//     https://iquilezles.org/articles/morenoise/\n//     https://iquilezles.org/articles/gradientnoise/\n// and accompanied code:\n//     https://www.shadertoy.com/view/4dXBRH\n//     https://www.shadertoy.com/view/XdXBRH\n//     https://www.shadertoy.com/view/XsXfRH\n//     https://www.shadertoy.com/view/4dffRH\n// The first article states: \"If you implement a ridged Value Noise or\n// other variations you can also easily drive the right way to combine\n// the derivatives, unless you have a discontinuous shaping function like\n// a fabsf().\" (NOTE: ridged noise involves abs()).\n//\n// However, abs() and such are not a big obstacle (you do get garbage\n// at the actual discontinuity points, but that is often acceptable).\n//\n// Below are a few examples of computing derivatives for slightly more\n// involved cases.\n//\n// If you want to be more systematic, a simple automatic differentiation\n// framework (https://en.wikipedia.org/wiki/Automatic_differentiation),\n// operating on (Value,Gradient) pairs (sort of like N-dimensional dual\n// numbers), can probably be implemented in something like 100 lines of\n// GLSL code for 1D, 2D and 3D.\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat rnd2i(ivec2 v)\n{\n    return float(int(hash(uint(v.x+65536*v.y))))*4.6566129e-10;\n}\n\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2d(vec2 v)\n{\n    ivec2 i=ivec2(floor(v)),e=ivec2(0,1);\n    v=fract(v);\n    float A=rnd2i(i+e.xx);\n    float B=rnd2i(i+e.yx);\n    float C=rnd2i(i+e.xy);\n    float D=rnd2i(i+e.yy);\n    vec2 d=30.0*v*v*(v*(v-2.0)+1.0);\n    v=v*v*v*(v*(v*6.0-15.0)+10.0);\n    return vec3(\n        vec2(mix(B-A,D-C,v.y),mix(C-A,D-B,v.x))*d,\n        mix(mix(A,B,v.x),mix(C,D,v.x),v.y));\n}\n\nvec3 f(vec2 v)\n{\n    vec3 ret=vec3(0.0),r=vec3(0);\n    if(true) // Affine argument transform.\n    {\n        float w=0.37;\n        mat2 A=5.0*mat2(0.7,0.8,-0.5,1.0);\n        vec2 b=vec2(1.3,3.7);\n        // See https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs\n        r=w*noise2d(A*v+b);\n        r.xy=r.xy*A; // Multiply gradient with Jacobian.\n        ret+=r;\n    }\n    if(true) // Non-linear argument transform.\n    {\n        float w=0.73;\n        vec2 t=vec2(\n            exp(v.x)*v.y+cos(v.y),\n            sin(v.x)+v.y*v.y+7.0);\n        mat2 J=mat2( // Jacobian (NOTE: column-major!)\n            exp(v.x)*v.y,cos(v.x),\n            exp(v.x)-sin(v.y),2.0*v.y);\n        r=w*noise2d(t);\n        // See https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs\n        r.xy=r.xy*J; // Multiply gradient with Jacobian.\n        ret+=r;\n    }\n    if(true) // Dependent argument transform.\n    {\n        float w=0.23;\n        mat2 A=7.0*mat2(0.4,-0.8,0.5,0.8);\n        vec2 B=vec2(0.8,0.7);\n        r=w*noise2d(A*v+B*ret.z);\n        r.xy=r.xy*A+dot(r.xy,B)*ret.xy;\n        ret+=r;\n    }\n    if(true) // Smooth result transform.\n    {\n        // z -> z*exp(-z)\n        ret=vec3(\n            (exp(-ret.z)-ret.z*exp(-ret.z))*ret.xy,\n            ret.z*exp(-ret.z));\n    }\n    if(true) // Non-smooth result transform.\n    {\n        // Abs and its derivative.\n        ret=ret.z<0.0?-ret:ret;\n    }\n    return ret;\n}\n\n// Analytical derivatives.\nvec2 da(vec2 v)\n{\n    return f(v).xy;\n}\n\n// Numerical derivatives.\nvec2 dn(vec2 v)\n{\n    vec2 e=vec2(0.0,1e-3);\n    //return (vec2(f(v+e.yx).z,f(v+e.xy).z)-f(v).z)/e.y;\n    return (vec2(f(v+e.yx).z,f(v+e.xy).z)-vec2(f(v-e.yx).z,f(v-e.xy).z))/(2.0*e.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 v=fragCoord/iResolution.y;\n    float t=(0.5+0.5*sin(0.25*iTime))*iResolution.x/iResolution.y;\n    vec3 col=vec3(0.5);\n    if(v.y>0.5)\n    {\n        if(v.x>t) col.xy+=0.5*da(v);\n        else      col.xy+=0.5*dn(v);\n        col=mix(col,vec3(cos(4e2*(v.x-t))),exp(-1e4*(v.x-t)*(v.x-t)));\n    }\n    else\n    {\n        col.xy+=25.0*(dn(v)-da(v));\n    }\n    col=mix(col,vec3(0.5)+0.5*f(v).z,smoothstep(0.41,0.39,distance(v,0.5*iResolution.xy/iResolution.y)));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdyDl.jpg", "access": "api", "license": "public-domain", "functions": [[1304, 1345, 1364, 1364, 1459], [1461, 1461, 1483, 1483, 1549], [1551, 1598, 1620, 1620, 1973], [1975, 1975, 1991, 1991, 3471], [3473, 3500, 3517, 3517, 3539], [3541, 3567, 3584, 3584, 3754], [3756, 3756, 3810, 3810, 4391]], "test": "untested"}
{"id": "mlccDl", "name": "My take on the Introduction", "author": "Christiano300", "description": "My take on kishimisu's introduction to Shader Art Coding", "tags": ["remix", "introcuction"], "likes": 4, "viewed": 203, "published": 3, "date": "1699813000", "time_retrieved": "2024-07-30T17:22:47.151052", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.718, 0.761, 0.698);\n    vec3 b = vec3(0.424, 0.297, 0.626);\n    vec3 c = vec3(1.998, 1.499, 0.913);\n    vec3 d = vec3(1.198, -0.115, -0.113);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.; i++) {\n\n        uv = fract(.6432 * uv * (sin(iTime * .53843276) / 1.3 + 1.5)) - .5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * .4 + iTime * .4);\n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n\n        d = pow(.007 / d, 1.2);\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlccDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 235], [237, 237, 294, 294, 822]], "test": "untested"}
{"id": "cttyDj", "name": "Megafan", "author": "misol101", "description": "A rather strange effect that I wanted to try out...", "tags": ["2d", "demo", "silents", "reproduction", "xpose"], "likes": 4, "viewed": 177, "published": 3, "date": "1699800992", "time_retrieved": "2024-07-30T17:22:48.094530", "image_code": "float getCosInput(float n, float w, float m) {\n    float v=mod(n, PI*2.)/(PI*2.) - 0.5;\n    v*=1.+(MAX_WIDTH-w)*m;\n    v=clamp(v+0.5,0.,1.);\n    return v*PI*2.;\n}\n\nfloat swingWidth(float section) {\n    return MAX_WIDTH * (0.55+sin(xTime*swing_speed+section*swing_var)*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(0.);\n    getPhaseData(iTime);\n    float uvTy = uv.y + yTime;\n\n    // determine section\n    float section = 0., yprogress = 0., ss=0.;\n    float fullSegSize = 1./nof_full_sections;\n    for (float i = 0.; i < MAX_NOF_SEG; i++) {\n        float w = abs(swingWidth(i));\n        float old_ss = ss;\n        ss += smoothstep(0.0,1.0,w / MAX_WIDTH) * fullSegSize + fullSegSize * 0.15;\n        if(uvTy >= old_ss && uvTy < ss) {\n            section = i;\n            yprogress = (uvTy - old_ss) / (ss-old_ss);\n            break;\n        }\n    }\n    // fan\n    float w = abs(sin(yprogress * PI) * (swingWidth(section) + 0.02));\n    float dist=abs(uv.x-0.5);\n    if (dist < w) {\n        dist /= w;\n        col = vec4(smoothstep(-1., 1., cos(getCosInput(dist * PI * nof_lines, w, 4.5))));\n        col *= w * 1.9;\n    }\n    // main line\n    float dc = MAX_WIDTH * 2. / nof_lines * main_line_width;\n    float dir = float((int(section) % 2)*2-1);\n    float linw = (sin(yprogress * PI) * (swingWidth(section) + 0.02 - dc*0.5)) * dir;\n    dist=abs(uv.x-0.5-linw);\n    if (dist < dc) {\n        dist /= dc;\n        vec4 col2 = vec4(smoothstep(-1., 1., cos(getCosInput(dist * PI, dist, 0.4)))) * 0.66;\n        col = (dist > 0.65) ? max(col,col2) : col2;\n    }\n    fragColor = col * colorizer;\n}", "image_inputs": [], "common_code": "const float PI = 3.14159265359;\nconst float PHASE_LENGTH = 9.;\nconst float MAX_NOF_SEG = 30.;\nconst float MAX_WIDTH = 0.355;\nconst float FADE_TIME = 1.;\nconst int NOF_PHASES = 5;\n\nfloat nof_lines, nof_full_sections, main_line_width, swing_var, swing_speed, xTime = 0., yTime = 0.;\nvec4 colorizer = vec4(0.5,0.9,0.5, 0.);\n\nvoid getPhaseData(float time) {\n    int phase = (int(time / PHASE_LENGTH) + 0) % NOF_PHASES;\n    xTime = mod(time, PHASE_LENGTH);\n    nof_lines = 41., main_line_width = 0.8;\n\n    switch(phase) {\n        case 0:\n            nof_full_sections = 2.7, swing_var = 2.8, swing_speed = 1.5;\n            yTime = xTime * 0.15;\n            colorizer = vec4(0.5,0.9,0.5, 0.);\n            break;\n        case 1:\n            nof_full_sections = 1.5, swing_var = 1.0, swing_speed = 1.;\n            yTime = 4.6 + xTime * -0.3;\n            colorizer = vec4(0.9,0.9,0.5, 0.);\n            break;\n        case 2:\n            nof_full_sections = 5.0, swing_var = 1.8, swing_speed = 0.8;\n            yTime = xTime * 0.3;\n            colorizer = vec4(0.3,0.7,1.0, 0.);\n            break;\n        case 3:\n            nof_lines = 61., nof_full_sections = 0.6;\n            swing_var = 0.7, swing_speed = 0.9, main_line_width = 1.6;\n            yTime = 3.0 + xTime * -0.1;\n            colorizer = vec4(1.0,0.5,0.5, 0.);\n            break;\n        case 4:\n            nof_full_sections = 3.7, swing_var = 1.2, swing_speed = 2.4;\n            yTime = 4.4 + xTime * -0.42;\n            colorizer = vec4(1.0,0.6,1.0, 0.);\n            nof_lines = 38., main_line_width = 1.1;\n            break;\n    }\n    float ft = FADE_TIME*0.5;\n    if (xTime < ft) colorizer *= (xTime/ft);\n    if (xTime > PHASE_LENGTH - ft) colorizer *= (PHASE_LENGTH - xTime) / ft;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 162], [164, 164, 197, 197, 275]], "test": "untested"}
{"id": "mltyDX", "name": "2D SDF Quadtree Prisms", "author": "Shane", "description": "Raymarching 2D SDF quadtree prisms using a quasi-traversal method.", "tags": ["raymarching", "grid", "voxel", "square", "quadtree", "subdivide"], "likes": 110, "viewed": 1735, "published": 3, "date": "1699793383", "time_retrieved": "2024-07-30T17:22:49.040002", "image_code": "/*\n\n    2D SDF Quadtree Prisms\n    ----------------------\n    \n    Raymarching 2D SDF quadtree prisms using a quasi-traversal method.\n    \n    I love the 2D SDF quadtree aesthetic. I'm not sure why, but I think\n    I like the marriage of art, math and basic computer science algorithms...\n    \n    Anyway, I wanted to play around with Xor's really cool 3D XOR example\n    (link below) so searched for it. Alongside it, I saw XOR's version of \n    Panna_Pudi's rotating square SDF in quadtree form, so naturally got \n    curious as to what they'd look like mixed together... I doubt I'm \n    starting the next art movement here, but it's an interesting visual.\n    \n    Anyway, I kept the coloring simple to honor the style of shaders it was \n    based on. I also stuck with a similar 2D SDF. The demoscene fan in me \n    wanted to use a 3D wireframe cube or 2D metaballs SDF as the subject\n    matter... Maybe next time. :)\n    \n    \n    \n    Inspired by:\n    \n    // Awesome visuals for the amount of code used.\n    Bricks [300] - Xor\n    https://www.shadertoy.com/view/cdKBDy\n    \n    // It has a kind of tech-drawing aesthetic to it that I\n    // find really appealing.\n    Quadicube in 456 chars\n    https://www.shadertoy.com/view/7djyWc\n    // Short version of:\n    Quadicube - panna_pudi \n    https://www.shadertoy.com/view/NsByWV\n\n*/\n\n \n// Maximum ray distance.\n#define FAR  15.\n\n// Global tile scale. Value of about \"1./2.\" to \"1./6\" work, \n// but it's designed to work with the currect value.\n#define GSCALE vec3(1./4.);\n\n// Light type: Point: 0, Direct: 1\n#define LIGHT_TYPE 0\n\n// Forward camera speed for that tunnel boring effect. \n// Set to zero for a static camera.\n#define CAM_Z 1./3.\n\n// I like the look of offset rows to mix things up a bit. Comment\n// it out, if you prefer a more traditional subdivided look.\n#define OFFSET_ROWS\n\n// Grey faces, or not.\n#define GREY_FACES\n\n// Colored prism sides, or not.\n#define COLORED_SIDES\n\n// Single face color override.\n//#define SINGLE_FACE_COLOR\n\n// Bore out some holes.\n//#define HOLES\n\n//////////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1664525U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n \n/*\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n*/\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;   \n     \n}\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Storing the 2D SDF object value. Used for coloring later.\nfloat gBx;\n\n// Height map value.\nfloat hm(in vec2 p){ \n \n    // Moving the pattern forward. Not necessary, but it looks interesting.\n    p.y -= iTime*CAM_Z;\n \n    // Moving the object around a bit.\n    p -= (vec2(cos(iTime), sin(iTime)))*vec2(.5, .25);\n    \n    // Rotation.\n    p = rot2(cos(iTime/2.)*3.14159*.85)*p;\n    \n    // A 2D SDF box.\n    float bx = sBoxS(p, vec2(1.25), .1);\n    gBx = bx;\n\n    // Integrating the box border with a box imprint... Kind of.\n    return min(bx + .65, abs(bx));\n \n }\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){    \n   \n   \n    #ifdef OFFSET_ROWS\n    // Optional: Offset alternate rows.\n    if(mod(floor(p.y/sc.y), 2.)<.5) p.x += sc.x/2.;\n    #endif\n    \n    vec2 q = p;\n    \n    // Cell ID and local coordinates.\n    vec2 ip = (floor(p/sc) + .5)*sc;\n    p -= ip;\n    \n    // Partitioning into cells and providing the local cell ID\n    // and local coordinates.\n    const int n = 2;\n    for(int i = 0; i<n; i++){\n        // Random subdivision -- One big cell becomes four smaller ones.\n        //if(hash21(ip + float(i + 1)*.007)<.5){//(1./float(i + 2))\n        if(hm(ip)>float(n - i)/float(n)/4.) break;\n            \n        p = q;\n        sc /= 2.; // Cut the scale in half.\n        // New cell ID and local coordinates.\n        ip = (floor(p/sc) + .5)*sc;\n        p -= ip;\n        \n    }\n    \n    // Returning the local coordinates and local cell ID.\n    return vec4(p, ip);\n}\n\n\n \n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\nvec4 gID;\n\n\n// A simple glow variable.\nvec3 glow;\n\nfloat map(vec3 q3) {\n\n\n    // Floor. Redundant here.\n    float fl = q3.y + .5;\n \n \n    vec3 sc = GSCALE; // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(q3.xz, sc.xz); \n    vec2 p = p4.xy;\n    vec2 id = p4.zw;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    //vec3 rC = (gDir*sc - vec3(p.x, q3.y, p.y))/gRd;\n    vec2 rC = (gDir.xz*sc.xz - p)/gRd.xz; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    // Adding some subtle randomized animation to break things up a bit.\n    h = clamp(h*2., 0., 1.)*.95 + (sin(hash21(id + .05)*6.28315289 + iTime)*.5 + .5)*.05;\n \n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness.\n    //sc.xz -= .02*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    float d2 = sBoxS(p, sc.xz/2., 0.);\n    //float d2 = sBoxS(p, sc.xz/2., .25*sc.x); // Rounded squares.\n    //float d2 = length(p) - sc.x/2.; // Circles. Interesting, but...\n    \n    #ifdef HOLES\n    if(sc.x>1./16.) d2 = max(d2, -(d2 + sc.x/2.5));\n    #endif\n    \n    // Creating the extruded prisms.\n    float d = opExtrusion(d2, q3.y - h/2., h/2., 0.);\n    \n    \n    // Placing a slightly rounded surface on the faces. Not absolutely\n    // necessary, but it sparkles the light a little more.\n    vec3 p3 = vec3(p.x, q3.y - (h - 3.)  - .0045, p.y);\n    d = min(d, max(length(p3) - 3., d2));\n    \n    d -= min(-d2*2., .06)*.15; // Some beveling.\n    //d += d2*.1; // Raised tops.\n    \n    // Add some gradient glow to the sides.\n    if(q3.y<h){\n        float dd = max(h - q3.y, 0.)/h;\n        glow += max(1. - dd, 0.);    \n    }\n\n    // Saving the box dimensions and local coordinates.\n    gSc = vec3(sc.x, h, sc.z);\n    gP = p;\n    gID = vec4(d, d2, id);\n \n \n    // Scene distance.\n    return min(fl, d);\n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.002, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n \n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    float d, t = hash31(ro + rd)*.25; // Glow jitter.\n    //const float tol = TOLERANCE;\n    vec2 dt = vec2(1e8, 0); // IQ's edge desparkle trick.\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // sign(rd)*.5;\n    gRd = rd;\n    \n\n    // Initialize the glow to zero.\n    glow = vec3(0);\n\n    const int iter = 128;\n    int i = 0;\n     \n    for (i = 0; i < 128; i++) {\n       \n        d = map(ro + rd*t);\n         \n        \n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        if (d<.001 || t > FAR) {\n          break;\n        }\n\n        t += min(d*.9, gCD);\n    }\n    \n    if(i == iter - 1) { t = dt.y; }\n\n\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 p, in vec3 ld, in float lDist, in float k) {\n    \n    float res = 1.;\n    float t = 0.;\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., ld) - .5;\n    gRd = ld; \n\n    for (int i=0; i<64; i++){\n\n        float d = map(p + ld*t);\n        res = min(res, k*d/t);\n        if (d<0. || t>lDist) break;\n\n        t += clamp(min(d*.9, gCD), .01, .25);\n    }\n    return clamp(res, 0., 1.);\n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n \n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\nvec4 render(vec3 ro, vec3 rd){\n\n\n    #if LIGHT_TYPE == 0\n    vec3 lp = ro + vec3(2, 1, 6);\n    #else\n    vec3 ld = normalize(vec3(2, 1. + 4., 6));//-vec3(-1.5, -3, -3)\n    float lDist = FAR;\n    #endif\n    \n\n    float t = rayMarch(ro, rd);\n\n    // Saving the global scale, local cell coorinates and cell ID.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    vec4 svGID = gID;\n    \n    // Saving the 2D object field from the distance function. Used for coloring.\n    float svBX = gBx;\n\n\n    // Initializing.\n    vec3 col = vec3(0);\n   \n    if (t < FAR){\n  \n        // Position and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        \n        // Light.\n        #if LIGHT_TYPE == 0\n        vec3 ld = lp - p;\n        float lDist = length(ld);\n        ld /= lDist;\n        #endif\n        \n         \n        // Shadow and ambient occlusion.\n        float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n        float ao = calcAO(p, n);\n\n \n        // Block ID and corresponding height.\n        vec2 id = svGID.zw;\n  \n        // The rotating box used in the height function. Used for coloring.\n        float bx = abs(svBX + .35) - .25;\n    \n        // Background color.\n        vec3 bgCol = mix(vec3(.8, .8, 1)*1.1, vec3(.65, .6, .9)/1.25, hash21(id + .13));\n        \n        // Shape color.\n        vec3 shCol = mix(vec3(1, .05, .04)*1.5, vec3(1, .1, .1)/2., hash21(id + .14));\n        shCol = mix(shCol, .5 + .45*cos(6.2831*hash21(id + .15)/6. + vec3(0, 1.3, 2)*1.5 + .5), .25);\n        shCol = shCol*1.3 + .05;\n          \n       \n        // Coloring the prism sides.\n        vec3 an = abs(n);\n        int face = max(an.x, an.z)<an.y? 1 : 0;\n        #ifdef COLORED_SIDES\n        if(face == 0){\n            bgCol = mix(bgCol, bgCol*shCol*2., .95);\n            shCol = mix(bgCol/2., bgCol*shCol, .5);//vec3(.7, .9, 1.2)/1.2;\n            bgCol = mix(bgCol, shCol, .5);\n            shCol = bgCol;\n             \n        }\n        #else\n        if(face == 0){\n            shCol = bgCol;\n        }\n        #endif\n        \n        // Further background color refining.    \n        bgCol *= vec3(.7, .9, 1.2)*.85;\n        \n        // Coloring the faces dark grey.\n        #ifdef GREY_FACES\n        if(face==1){ \n            shCol = vec3(1./3.)*dot(shCol, vec3(.299, .587, .114)); \n            bgCol = shCol;              \n        }\n        #endif\n        \n        // Making the shape face color the same as the background.\n        #ifdef SINGLE_FACE_COLOR\n        #ifdef COLORED_SIDES\n        if(face == 1)\n        #endif\n        { shCol = bgCol; }\n        #endif\n    \n        // Applying the shape color to the background. \n        vec3 oCol = mix(bgCol, shCol, (1. - smoothstep(0., .25, bx))*min(svSc.x*10., 1.));\n \n        \n        // Leftover effect from another shader. Interesting... but no. :)\n        //vec2 id2 = floor(id/2.);\n        //if(mod(id2.x + id2.y, 2.)<.5) oCol = mix(oCol, oCol.zyx, .5);\n      \n        // Texture coordinates that match the animation.\n        vec3 txP = vec3(p.x, p.y - svSc.y, p.z);\n        vec3 tx = tex3D(iChannel0, txP/2. + .5, n);\n        \n       \n        // Subtle texture color.\n        oCol *= tx*2. + .45;\n         \n        // Very subtle diffuse texturing. Almost not worth the trouble, \n        // but it's done now. :)\n        vec3 rTxP = txP;\n        rTxP.xz *= rot2(3.14159/9.);\n        vec3 dTx = tex3D(iChannel2, rTxP/vec3(4, 1, 1.), n);\n        float difSt = dot(dTx, vec3(.299, .587, .114));\n\n        // Diffuse value.\n        float dif = max(dot(ld, n), 0.);\n        dif = pow(dif, 2. + difSt*16.); // Diffusivity based on texture.\n        \n        // Specular value.\n        float spe = pow(max(dot(reflect(ld, n), rd), 0.), 8. + 8.*difSt);\n\n  \n\n        // Last minute edge routine. I've returned the nearest 2D object ID and \n        // dimensions from the raymarching routine, and the rest sorts itself out.\n        float ew = .0075*(1. + t*.1); // Edge width.\n        float h = svSc.y; // Height.\n        vec2 sc = svSc.xz; // Top face dimensions.\n        float rct = svGID.y;//sBoxS(svP, sc/2., .0);\n        #ifdef HOLES\n        if(sc.x>1./16.) rct = max(rct, -(rct + sc.x/2.5));\n        #endif\n        float top = max(abs(p.y - h), abs(rct)); // Top.\n        float side = abs(abs(svP.x) - sc.x/2.); // Sides.\n        side = max(side, abs(abs(svP.y) - sc.y/2.));\n        float objEdge = min(top, side - ew*.4) - ew; // Combining.\n        \n        // Using the diffuse value to mix the color up a bit.\n        oCol = mix(oCol, oCol.yxz, dif*dif/5.);\n      \n        \n        // Cheap specular reflections.\n        float speR = pow(max(dot(normalize(ld - rd), n), 0.), 5.);\n        vec3 rf = reflect(rd, n); // Surface reflection.\n        vec3 rTx = texture(iChannel1, -rf).xyz; rTx *= rTx;\n        oCol += oCol*speR*rTx*4.;\n\n        \n        // I wanted to use a little more than a constant for ambient light this \n        // time around, but without having to resort to sophisticated methods, then I\n        // remembered Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //\n        // Studio.\n        float am = pow(length(sin(n*2.)*.5 + .5)/sqrt(3.), 2.)*1.5; \n        // Outdoor.\n        //float am = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1., 1., -sn.z); \n        \n        \n        // Specular color.\n        vec3 speCol = vec3(1, .7, .4);\n        // Mixing the specular color.\n        //speCol = mix(speCol.zyx, speCol, (1. - smoothstep(0., .25, bx))*min(svSc.x*10., 1.));\n\n\n        // Lit color.\n        col = oCol*(am + dif*shd + speCol*spe*shd*4.)*ao;\n        \n\n        \n        // Adding a touch of glow to the column walls.\n        col += col*col*glow/4.;\n\n \n        // Applying the edges to the prism.\n        col = mix(col, col*.1, 1. - smoothstep(0., .005, objEdge));\n\n\n        // Light attenuation. Barely visible, but it's there\n        float rt = t/FAR;\n        col *= 1.5/(1. + rt*.2); \n\n    }\n  \n    // Fog. Not visible, but it's there anyway.\n    col = mix(col, vec3(0), smoothstep(.3, .99, t/FAR));\n    \n    // Returning the final color for this pass... There's only one\n    // pass here, but a render function is useful when you want to\n    // bounce light around.\n    return vec4(col, t);\n  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    // Coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Look vector and camera origin.\n    vec3 lk = vec3(0, 0, iTime*CAM_Z);\n    vec3 ro = lk + vec3(cos(iTime/4.)*.02, 4, -1. + sin(iTime/2.)*.05);\n  \n    // Setting up a camera using the usual process. The variable names\n    // here suggest that this lot came from one of IQ's examples.\n    vec3 ww = normalize(lk - ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww ));\n    vec3 vv = cross(ww, uu);\n    const float FOV = 3.14159/3.; // Field of view.\n    vec3 rd = normalize(u.x*uu + u.y*vv + ww/FOV); // Unit direction vector.\n    \n    // A bit of ray warping just to mix things up.\n    vec2 offs = vec2(fbm(rd.xz*12.), fbm(rd.xz*12. + .35));\n    const float oFct = .01;\n    rd.xz -= (offs - .5)*oFct; \n    rd = normalize(rd);\n    \n    /*\n    // Mouse movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2((iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2((iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n    */\n\n    // Render... I was going to perform a couple of passes, but decided against \n    // it. However, it's usually a good idea to have a separate render function.\n    vec4 c4 = render(ro, rd);\n    vec3 col = c4.xyz;\n    // Vignette and very rough Reinhard tone mapping.\n    col *= smoothstep(1.5, .5, length(2.*fragCoord/iResolution.xy - 1.)*.7);\n    col /= 1. + col/2.5;\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(pow(max(col, 0.), vec3(.4545)), 1);\n    \n    \n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2064, 2097, 2119, 2119, 2177], [2181, 2335, 2383, 2685, 3594], [3596, 3679, 3700, 3864, 3997], [3999, 4041, 4062, 4062, 4295], [4298, 4366, 4384, 4491, 4995], [4997, 5075, 5093, 5093, 5166], [5586, 5642, 5680, 5680, 5765], [5767, 5794, 5864, 5918, 6032], [6034, 6056, 6091, 6468, 6559], [6634, 6655, 6675, 6754, 7126], [7128, 7158, 7194, 7194, 8062], [8334, 8334, 8354, 8386, 11052], [11054, 11145, 11169, 11544, 11816], [11821, 11821, 11855, 11855, 12649], [12651, 12651, 12720, 12720, 13154], [13157, 13307, 13327, 13327, 13673], [13677, 13796, 13830, 13830, 14427], [21391, 21391, 21448, 21470, 22970]], "test": "untested"}
{"id": "DlcyDf", "name": "Triangle Homography", "author": "pyBlob", "description": "Finds the homography that maps [(1,0,0), (0,1,0), (0,0,1)] to [a, b, c] and [ref] to [target]. Mouse moves target. This is much more intuitive than the classic version that maps corners of a rectangle.", "tags": ["triangle", "geometry", "perspective", "homgraphy"], "likes": 9, "viewed": 227, "published": 3, "date": "1699755212", "time_retrieved": "2024-07-30T17:22:49.962535", "image_code": "/*\n\nTask: Find the homography that maps barycentric coordinates\n    [(1,0,0), (0,1,0), (0,0,1)] to [a, b, c]\n    and [ref] to [target].\n\na) Find the affine transformation for the corners of the triangle.\n   Trivial: mat3x2(a, b, c)\n\nb) Find the homography H that fixes the corners of the triangle and moves ref to target.\n   This homography must have eigenvectors [(1,0,0), (0,1,0), (0,0,1)]. Therefore it is a diagonal matrix.\n   Trivial:  diag(ref / tex(a,b,c, target))\n\n*/\n\nvec2 view(vec2 a, vec2 b, vec2 c, vec3 wuv)\n{\n    return mat3x2(a, b, c) * wuv;\n}\n\nvec3 tex(vec2 a, vec2 b, vec2 c, vec2 x)\n{\n    /* mla: less code */\n    return inverse(mat3(a,1,b,1,c,1)) * vec3(x,1);\n\n    /* original: normalized barycentric coordinate, less operations */\n    vec3 wuv = vec3(0, inverse(mat2(b-a, c-a)) * (x-a));\n    wuv.x = 1. - wuv.y - wuv.z;\n    return wuv;\n}\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    float res = 236.;\n    O /= iResolution.y;\n\n    vec3 ref = vec3(1) / 3.;\n    //ref = vec3(.6,1.2,1.2) / 3.;\n\n    vec2 a = vec2(120, 40) / res;\n    vec2 b = vec2(250, 110) / res;\n    vec2 c = vec2(90, 150) / res;\n    vec2 d = view(a,b,c, ref);\n    d = view(a,b,c, vec3(.2,.5,.3));\n    \n    if (iMouse.z > 0.)\n        d = abs(iMouse.xy) / iResolution.y;\n    //else d = abs(mouse.zw) / iResolution.y;\n\n    float r = 3. - min(min(length(O-a), length(O-b)), min(length(O-c), length(O-d))) * iResolution.y;\n\n    // affine\n    vec3 wuv = tex(a,b,c, O);\n\n    // persepective\n    int mode = 0;\n    if (mode == 0)\n        wuv *= ref / tex(a,b,c, d);\n    if (mode == 1 && iMouse.z > 0.)\n        wuv *= 1. + vec3(0, iMouse.xy - iResolution.xy/2.) / iResolution.y;\n\n    vec2 buv = wuv.yz / (wuv.x + wuv.y + wuv.z);\n    float bw = 1. - buv.x - buv.y;\n    //buv *= 3.;\n\n    vec2 uv = buv;\n    //if (false) // <- toggle this and move the mouse\n        uv = fract(uv);\n    float w = 1. - uv.x - uv.y;\n\n    C = vec4(0);\n    C = mix(C, vec4(clamp(vec3(bw, buv), 0., 1.), 1), clamp(-.5+min(uv.x/fwidth(buv.x), min(uv.y/fwidth(buv.y), w/fwidth(bw))), 0., 1.));\n    if (false)\n        C = mix(C, vec4(0), clamp(1.-1.4*abs(uv.x-uv.y)/fwidth(buv.x-buv.y), 0., 1.)*clamp(w/fwidth(bw),0.,1.)),\n        C = mix(C, vec4(0), clamp(1.-1.4*abs(uv.x-w)/fwidth(buv.x-bw), 0., 1.)),\n        C = mix(C, vec4(0), clamp(1.-1.4*abs(uv.y-w)/fwidth(buv.y-bw), 0., 1.));\n    C = mix(C, vec4(1), clamp(r, 0., 1.));\n    C = sqrt(C);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 477, 522, 522, 558], [560, 560, 602, 627, 857], [859, 859, 895, 895, 2390]], "test": "untested"}
{"id": "Dt3yzN", "name": "Rotation Image transition effect", "author": "Nightwarrior", "description": "Transitioning between two images with rotating circles in the middle.", "tags": ["circle", "rotate", "effect", "transition", "rotating", "swap", "change"], "likes": 3, "viewed": 201, "published": 3, "date": "1699740935", "time_retrieved": "2024-07-30T17:22:50.752423", "image_code": "////////////////////////////////////////////\n//                                        //\n//   Made by NightWarrior in ShaderToy    //\n//                                        //\n////////////////////////////////////////////\n\n#define M_PI 3.14159265358979323846264338327950288\n\n// Function to rotate UV coordinates around a given point (rotCenter)\nvec2 rotateUV(vec2 uv, vec2 center, mat2 rotationMatrix) {\n    uv -= center; // Move to origin for rotation\n    uv = rotationMatrix * uv; // Rotate UV coordinates\n    uv += center; // Move back to original position\n    return uv;\n}\n\n// Easing Functions\n\nfloat easeInOutQuint(float x) {\n    if (x < 0.5) {\n        return 16.0 * x * x * x * x * x;\n    } else {\n        return 1.0 - pow(-2.0 * x + 2.0, 5.0) * 0.5;\n    }\n}\n\nfloat easeInOutBack(float x) {\nfloat c1 = 1.70158;\nfloat c2 = c1 * 1.525;\n\nreturn x < 0.5\n  ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2. * x - c2)) / 2.\n  : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat easeInOutElastic(float x) {\n    const float c5 = (2.0 * 3.14159) / 4.5;\n\n    if (x == 0.0) {\n        return 0.0;\n    } else if (x == 1.0) {\n        return 1.0;\n    } else if (x < 0.5) {\n        return -0.5 * pow(2.0, 20.0 * x - 10.0) * sin((20.0 * x - 11.125) * c5);\n    } else {\n        return 0.5 * pow(2.0, -20.0 * x + 10.0) * sin((20.0 * x - 11.125) * c5) + 1.0;\n    }\n}\n\nmat2 getRot(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat smooth_transition_oscillate(float t, float duration, float start, float end) {\n    float v1 = mod(t, duration);\n    float v2 = mod(t, duration * 2.0);\n    float newT = v2 > v1 ? duration - v1 : v1;\n\n    // The transition points also need to be cyclic, using newT for checking\n    float transitionStart = start; // duration / 2.0 - 0.5; // Transition starts at 2\n    float transitionEnd = end; // duration / 2.0 + 0.5;   // Transition ends at 3\n\n    if (newT < transitionStart) {\n        return 0.; // Before the transition starts\n    } else if (newT >= transitionStart && newT < transitionEnd) {\n        // Linear interpolation between 0 and 1 for the transition period\n        return (newT - transitionStart) / (transitionEnd - transitionStart);\n    } else {\n        return 1.; // After the transition ends\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Aspect ratio correction\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= aspectRatio; // Adjust the x coordinate by aspect ratio\n\n    // Calculate the distance from the current point to the center\n    // Adjusted center.x for aspect ratio\n    float dist = length((fragCoord.xy / iResolution.y) - vec2(aspectRatio * 0.5, 0.5));\n\n    // Define radii for the three circles\n    float outerRadius = 0.41;\n    float middleRadius = 0.31;\n    float innerRadius = 0.;\n\n    // Calculate the ring's thickness\n    float thickness = 0.05; // Thickness based on the normalized units\n\n    // Check if we're within the ring's thickness for each circle\n    bool inOuterRing = abs(dist - outerRadius) < thickness * 0.7;\n    bool inMiddleRing = abs(dist - middleRadius) < thickness * 1.3;\n    bool inInnerRing = abs(dist - innerRadius) < thickness * 5.0;\n\n    // Calculate angle for rotation\n    float angle = iTime; // Rotate based on time\n    \n    // oscillators\n    float transitionDuration = 5.0; // Total duration for a full cycle (up and back down)\n    float period = 10.0; // Total duration for a full cycle (up and back down)\n\n    // Calculating the position for bg texture\n    vec2 texRes = vec2(iChannelResolution[0].xy); // Assuming both 0, 1 textures have same resolutions\n    float scaleToFit = iResolution.y / texRes.y;\n    float xOffset = iResolution.x * 0.5 - (texRes.x * scaleToFit) * 0.5;\n    vec2 uvTex = (fragCoord - vec2(xOffset, 0.0)) / scaleToFit;\n    \n    // Calculate screen center adjusted for aspect ratio and scaling\n    vec2 screenCenter = vec2((iResolution.x) * 0.5, iResolution.y * 0.5);\n    \n    // for rotating\n    vec2 rotCenter = vec2(0.5, 0.5);\n    \n    // Calculate factors with staggered start times and special easing\n    float mix1 = smooth_transition_oscillate(iTime, transitionDuration, transitionDuration * 0.2, transitionDuration * 0.8);\n    float mix2 = smooth_transition_oscillate(iTime, transitionDuration, transitionDuration * 0.3, transitionDuration * 0.7);\n    float mix3 = smooth_transition_oscillate(iTime, transitionDuration, transitionDuration * 0.4, transitionDuration * 0.6);\n\n    // Adding more behavior\n    mix1 = easeInOutElastic(mix1);\n    mix2 = easeInOutElastic(mix2);\n    mix3 = easeInOutQuint(mix3);\n\n    // Apply rotation only within the circles\n    vec2 rot1Uv;\n    vec2 rot2Uv;\n    vec2 rot3Uv;\n    if (inOuterRing || inMiddleRing || inInnerRing) {\n        // Convert screen coordinates to normalized UV coordinates for rotation\n        vec2 uvTexCircle = (fragCoord - screenCenter) / iResolution.y + rotCenter;\n        rot1Uv = rotateUV(uvTexCircle, rotCenter, getRot(mix1 * 2. * M_PI));\n        rot2Uv = rotateUV(uvTexCircle, rotCenter, getRot(mix2 * 2. * M_PI * -1.));\n        rot3Uv = rotateUV(uvTexCircle, rotCenter, getRot(mix3 * 2. * M_PI));\n    }\n    \n    float mix4Duration = 0.07;\n    float mix4 = smooth_transition_oscillate(iTime, transitionDuration, transitionDuration / 2. - mix4Duration, transitionDuration / 2. + mix4Duration);\n\n    // Output to screen\n    if (inOuterRing) {\n        fragColor = mix(texture(iChannel0, rot3Uv), texture(iChannel1, rot3Uv), mix3);\n    } else if (inMiddleRing) {\n        fragColor = mix(texture(iChannel0, rot2Uv), texture(iChannel1, rot2Uv), mix2);\n    } else if (inInnerRing) {\n        fragColor = mix(texture(iChannel0, rot1Uv), texture(iChannel1, rot1Uv), mix1);\n    } else {\n        // Textures for the background\n        uvTex /= texRes;\n        vec4 tex1bgColor = texture(iChannel0, uvTex);\n        vec4 tex2bgColor = texture(iChannel1, uvTex);\n        fragColor = mix(tex1bgColor, tex2bgColor, mix4); // Mix the two textures for the background\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3yzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 348, 406, 406, 579], [602, 602, 633, 633, 767], [769, 769, 799, 799, 991], [993, 993, 1026, 1026, 1373], [1375, 1375, 1401, 1401, 1469], [1471, 1471, 1555, 1555, 2292], [2294, 2294, 2349, 2380, 6071]], "test": "untested"}
{"id": "ml3yWn", "name": "\"Crazy Comets\" Tribute", "author": "ruudhelderman", "description": "WARNING - FLASHING LIGHTS\nEarly 1980s, it was so cool to have a spectrum analyzer on your stereo...\nMusic: \"Crazy Comets\" (main theme, C64) by Rob Hubbard.\nhttps://soundcloud.com/commodore64sidtribute/crazy-comets-main-theme-cover", "tags": ["retro", "audio"], "likes": 14, "viewed": 326, "published": 3, "date": "1699730524", "time_retrieved": "2024-07-30T17:22:51.600157", "image_code": "// \"Crazy Comets\" Tribute\n// by Ruud Helderman, November 2023 - MIT License\n//\n// Appropriate music (iChannel0):\n// https://soundcloud.com/commodore64sidtribute/crazy-comets-main-theme-cover\n//\n// Thanks iq for \"Input - SoundCloud\" - https://www.shadertoy.com/view/MsdGzn\n\nfloat rsqr(vec2 xy) { return sqrt(length(xy * xy)); }       // rounded square (x^4 + y^4)^0.25\nfloat rsqr(float x, float y) { return rsqr(vec2(x, y)); }\n\nfloat cup(vec2 p)\n{\n    return (p.y -= 8.0) > 0.0 ? rsqr(abs(p.x) - 8.0, p.y) : abs(length(p) - 8.0);\n}\n\nfloat letter_o(vec2 p)\n{\n    return abs(rsqr(p) - 8.0);\n}\n\nfloat letter_a(vec2 p)\n{\n    return min(\n        p.y > 0.0 ? letter_o(p) : rsqr(abs(p.x) - 8.0, min(p.y + 8.0, 0.0)),\n        rsqr(max(abs(p.x) - 8.0, 0.0), p.y)\n    );\n}\n\nfloat letter_c(vec2 p)\n{\n    return p.x < 0.0 ? letter_o(p) : rsqr(max(p.x - 8.0, 0.0), abs(p.y) - 8.0);\n}\n\nfloat letter_e(vec2 p)\n{\n    return min(letter_c(p), rsqr(clamp(0.0, p.x - 3.0, p.x + 7.0), p.y));\n}\n\nfloat letter_m(vec2 p)\n{\n    float c1 = cos(0.15 * p.x);\n    float c2 = c1 * c1;\n    float c4 = c2 * c2 * 6.0;\n    return min(\n        rsqr(abs(p.x) - 8.0, max(abs(p.y) - 8.0, 0.0)),\n        rsqr(max(abs(p.x) - 7.0, 0.0), max(p.y + c2*c4 - 8.0, min(p.y + c4 - 7.0, 0.0)))\n    );\n}\n\nfloat letter_r(vec2 p)\n{\n    return min(\n        p.x < 4.0 ? rsqr(min(p.x + 8.0, 0.0), abs(p.y - 4.0) - 4.0) : abs(rsqr(p - 4.0) - 4.0),\n        p.x < 0.0 ? rsqr(p.x + 8.0, max(abs(p.y) - 8.0, 0.0)) : cup(-p)\n    );\n}\n\nfloat letter_s(vec2 p)\n{\n    p *= sign(2.0 * p.y - p.x);\n    return p.x > -4.0 ? rsqr(max(p.x - 8.0, 0.0), abs(p.y - 4.0) - 4.0) : abs(rsqr(p + vec2(4, -4)) - 4.0);\n}\n\nfloat letter_t(vec2 p)\n{\n    return min(rsqr(p.x, max(abs(p.y) - 8.0, 0.0)), rsqr(max(abs(p.x) - 8.0, 0.0), p.y - 8.0));\n}\n\nfloat letter_y(vec2 p)\n{\n    return min(cup(p), rsqr(p.x, clamp(0.0, p.y, p.y + 8.0)));\n}\n\nfloat letter_z(vec2 p)\n{\n    return letter_s(p * vec2(-1, 1));\n}\n\nfloat crazy(vec2 p)\n{\n    float n = round(p.x);\n    p.x -= n;\n    p *= 24.0;\n    switch (int(n))\n    {\n        case 0: return letter_c(p);\n        case 1: return letter_r(p);\n        case 2: return letter_a(p);\n        case 3: return letter_z(p);\n        case 4: return letter_y(p);\n        default: return 9.0;\n    }\n}\n\nfloat comets(vec2 p)\n{\n    float n = round(p.x);\n    p.x -= n;\n    p *= 24.0;\n    switch (int(n))\n    {\n        case 0: return letter_c(p);\n        case 1: return letter_o(p);\n        case 2: return letter_m(p);\n        case 3: return letter_e(p);\n        case 4: return letter_t(p);\n        case 5: return letter_s(p);\n        default: return 9.0;\n    }\n}\n\nvec2 bend(vec2 uv)\n{\n    return uv / vec2(1.0 - uv.y, 0.8 + 8.0 * uv.x * uv.x);\n}\n\nvec4 logo_crazy(vec2 uv)\n{\n    return vec4(0.7, 0.5, 0, smoothstep(-2.5, -2.0, -crazy(32.0 * uv + vec2(2.0, -4.4))));\n}\n\nvec4 logo_comets(vec2 uv)\n{\n    uv.y += smoothstep(-4.0, 4.0, -iTime);       // appear from the bottom (first 4 seconds)\n    float f = fract(8.0 * uv.y - 0.5 * iTime);\n    vec3 color = 0.7 * vec3(1, 0.5 + f - smoothstep(0.4, 0.6, f), 0);    // red/yellow gradient\n    return vec4(color, smoothstep(-1.1, -0.9, -abs(comets(8.0 * bend(uv) + vec2(2.5, -0.5)) - 2.0)));\n}\n\nvec4 logo(vec2 uv)\n{\n    return uv.y > uv.x * uv.x + 0.1 ? logo_crazy(uv) : logo_comets(uv);\n}\n\nvec4 starfield(vec2 uv)        // ohhh, it's so retro... flying through a repetitive tube of dots\n{\n    const float r = 22.6;      // sectors per rad; totalling 142 stars (based on 355/113 approx of pi)\n    \n    float a = atan(uv.y, uv.x);                                       // angle (polar coordinate)\n    a += 8.0 * smoothstep(0.2, 0.3, abs(fract(0.02 * iTime) - 0.5));  // periodically rotate the scene\n    float s = floor(a * r);                                           // sector\n    float h = float(int(s) * 43759 ^ 28571) / 271.0;                  // poor PRNG, but is fine here\n    float t = 1.0 / (0.5 + 25.0 * fract(h - 0.2 * iTime));            // tube in 3D perspective\n    float d = length(vec2(1.0 - t / length(uv), a - (s + 0.5) / r));  // distance to star (normalized)\n    return vec4(1, 1, 0.7, 3.0 * t * max(0.0, 1.0 - 2.0 * r * d));    // color, brightness\n}\n\nvec4 wave(vec2 uv)\n{\n    return vec4(0.7, 0, 1,\n        smoothstep(0.02, 0.0, abs((texture(iChannel0, vec2(uv.x + 0.5, 0.75)).x - 0.5) * 0.5 - uv.y)));\n}\n\nfloat fft(vec2 uv)\n{\n    return floor(uv) == vec2(0) ? step(uv.y, texture(iChannel0, vec2(uv.x, 0.25)).x) : 0.0;\n}\n\nvec2 perspective(vec2 uv)\n{\n    const vec3 a = normalize(vec3(2, -1, 2));     // direction looking forward\n    const vec3 b = normalize(vec3(10, 1, -10));   // direction sideways\n    vec3 v = mat3(a, b, cross(a, b)) * vec3(1, 0.5 * uv);\n    return vec2(0.2, 1) * v.xy / v.z + vec2(-0.12, 1.3);\n}\n\nvec4 leds(vec2 uv)\n{\n    const vec2 grid = vec2(128, 100);\n    vec2 s = perspective(uv) * grid;\n    vec2 f = fract(s);\n    vec2 p = (s - f + 0.5) / grid;\n    return vec4(step(0.8, p.y), step(p.y, 0.9), 0,\n        fft(p) * 2.0 * smoothstep(-0.25, 0.25, -length(clamp(vec2(0), f - 0.75, f - 0.25))));\n        //fft(p) * exp(-9.0 * length(clamp(vec2(0), f - 0.75, f - 0.25))));\n}\n\nvec3 mix2(vec4 front, vec3 back)\n{\n    return mix(back, front.rgb, front.a);\n}\n\nvec3 mixall(vec2 uv)\n{\n    return mix2(leds(uv), mix2(wave(uv), mix2(logo(uv), mix2(starfield(uv), vec3(0)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(mixall((fragCoord - 0.5 * iResolution.xy) / iResolution.x), 1);\n}\n", "image_inputs": [{"id": 35208, "src": "https://soundcloud.com/commodore64sidtribute/crazy-comets-main-theme-cover", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3yWn.jpg", "access": "api", "license": "mit", "functions": [[273, 273, 294, 294, 326], [333, 368, 398, 398, 425], [427, 427, 446, 446, 530], [532, 532, 556, 556, 589], [591, 591, 615, 615, 761], [763, 763, 787, 787, 869], [871, 871, 895, 895, 971], [973, 973, 997, 997, 1253], [1255, 1255, 1279, 1279, 1472], [1474, 1474, 1498, 1498, 1640], [1642, 1642, 1666, 1666, 1764], [1766, 1766, 1790, 1790, 1855], [1857, 1857, 1881, 1881, 1921], [1923, 1923, 1944, 1944, 2242], [2244, 2244, 2266, 2266, 2600], [2602, 2602, 2622, 2622, 2683], [2685, 2685, 2711, 2711, 2804], [2806, 2806, 2833, 2833, 3173], [3175, 3175, 3195, 3195, 3269], [3271, 3271, 3370, 3370, 4152], [4154, 4154, 4174, 4174, 4307], [4309, 4309, 4329, 4329, 4423], [4425, 4425, 4452, 4452, 4720], [4722, 4722, 4742, 4742, 5098], [5100, 5100, 5134, 5134, 5178], [5180, 5180, 5202, 5202, 5293], [5295, 5295, 5352, 5352, 5439]], "test": "untested"}
{"id": "Dt3cDf", "name": "Cook-Torrance Raytracing", "author": "Ryukijano", "description": "Classic raytracing using Cook-Torrance shading model. It supports reflection (4 levels) and refraction, hard shadow are supported but enabled only for the ground balls.", "tags": ["raytracing"], "likes": 9, "viewed": 232, "published": 3, "date": "1699723321", "time_retrieved": "2024-07-30T17:22:52.376082", "image_code": "////////////////////////////////////////\n// Classic raytracing\n// Cook-Torrance shading \n//\n// The shaders displays 3 series of balls with different materials:\n// - Ground: Basic (no reflection, no refraction), roughness and density varying foreach ball.\n// - Along blue wall: Reflective materials, roughness and density varying foreach ball.\n// - Along orange wall: Refractive materials,roughness and density varying foreach ball.\n// - Center: the ball at the center is both reflective and refractive.\n//\n// Hard shadow are supported but enabled only for the ground balls.\n//\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tbool reflection;\t// has reflection \n\tbool refraction;\t// has refraction\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n/// fast version test the existence of \n/// an intersection\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n\tbool inside; // inside object\n\tMaterial mat; // object material\n};\n\nfloat fastintSphere(vec3 ro, vec3 rd, vec3 p, float r)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t\tdist = t1>0.?t1:t2;\n\t}\n\treturn dist;\n}\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n\t\t\t\ti.inside = t1<0.;\n\t\t\t\tif (i.inside)\n\t\t\t\t\ti.n *= -1.; //invert the normal when hitting inside during refraction\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfloat fastintPlane(vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n\tfloat res = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t\tres = (-(dot(n, p) + dot(n,ro)) / dpn);\n\treturn res;\n}\n\nbool intPlane(vec3 ro, vec3 rd, vec3 p, vec3 n, Material mat, inout Inter i)\n{\n\tfloat d = -1.;\n\tfloat dpn = dot(rd,n);\n\tif (abs(dpn)>0.00001)\n\t{\n\t\td = -(dot(n, p) + dot(n,ro)) / dpn;\n\t\tif ((d>0.)&&((d<i.d)||(i.d<0.)))\n\t\t{\n\t\t\ti.p = ro+d*rd;\n\t\t\ti.n = n;\n\t\t\ti.d = d;\n\t\t\ti.vd = -rd;\n\t\t\ti.inside = false;\n\t\t\ti.mat = mat;\n\t\t}\n\t}\n\treturn (i.d==d);\n}\n\n//////////////////////////////////////\n/// Shading functions\nvec3 shadeBlinnPhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tvec3 h = normalize(i.vd+ld);\n\tres += specular*pow(dot(i.n,h), 16.);\n\treturn res;\n}\n\nvec3 shadePhong( Inter i, vec3 lp )\n{\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.4;\n\t\n\tvec3 res = vec3(0.);\n\tvec3 ld = normalize(lp-i.p);\n\tres = i.mat.color*diffuse*dot(i.n,ld);\n\tres += specular*pow( clamp(dot(reflect(i.vd,i.n),ld),0.,1.), 16.);\n\treturn res;\n}\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Inter i, Light lig )\n{\n\tfloat roughness = i.mat.roughness;\n\tfloat F0 = i.mat.fresnel;\n\tfloat K = i.mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-i.p);\n\tvec3 h = normalize(i.vd+ld);\n\tfloat NdotL = clamp( dot( i.n, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( i.n, h ),0.,1. );\n\tfloat NdotV = clamp( dot( i.n, i.vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, i.vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*i.mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn res;\n}\n\n////////////////////////////////////\n// Raytracing\n\nfloat hidden( Inter i, vec3 lp)\n{\n\tvec3 ro = i.p;\n\tfloat dmax = length(lp-ro);\n\tvec3 rd = normalize(lp-ro);\n\tro += 0.001*rd;\n\t//\n\tfloat hit = -1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\thit = fastintPlane( ro, rd, p, n);\n\thit = hit>dmax?-1.:hit;\n\t//\n\tif (hit<0.)\n\t{\n\t\tfloat pi = 1.25;\n\t\tp = vec3(-2.5,0.5,-2.5);\n\t\tfor (int k=0; k<5; ++k)\n\t\t{\n\t\t\tp.z = -2.5;\n\t\t\tfor (int l=0;l<5;++l)\n\t\t\t{\n\t\t\t\thit = fastintSphere( ro, rd, p, 0.5);\n\t\t\t\tif ((hit>0.) && (hit<dmax)) break;\n\t\t\t\tp.z += pi;\n\t\t\t}\n\t\t\tif (hit>0.) break;\n\t\t\tp.x += pi;\n\t\t}\n\t}\n\treturn hit;\n}\n\nvec3 raytraceRay( vec3 ro, vec3 rd, inout Inter i)\n{\n\tMaterial mat;\n\tmat.color = vec3(0.75);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 1.;\n\tmat.density = 1.;\n\tvec3 p = vec3(0.,0.,0.);\n\tvec3 n = vec3(0.,1.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.75)*mod(floor(i.p.x)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(-8.,0.,0.);\n\tn = vec3(-1.,0.,0.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.95,0.35,0.)*mod(floor(i.p.y)+floor(i.p.z),2.)+0.25;\n\t}\n\t//\n\tp = vec3(0.,0.,8.);\n\tn = vec3(0.,0.,1.);\n\tif (intPlane( ro, rd, p, n, mat, i))\n\t{\n\t\t// checker plane hack\n\t\ti.mat.color = vec3(0.35,0.65,0.95)*mod(floor(i.p.x)+floor(i.p.y),2.)+0.25;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tfloat pi = 1.25;\n\tfloat ri = 0.2;\n\tp = vec3(-2.5,0.5,-2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.z = -2.5;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.z += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = true;\n\tmat.refraction = false;\n\tmat.n = 1.;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.1;\n\tmat.density = 0.95;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(-2.5,1.,-4.);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.roughness = 0.1;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.roughness += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.density -= ri;\n\t\tp.x += pi;\n\t}\n\t//\n\tmat.color = vec3(1.0,1.0,0.25);\n\tmat.reflection = false;\n\tmat.refraction = true;\n\tmat.n = 1.16;\n\tmat.fresnel = 0.8;\n\tmat.roughness = 0.9;\n\tmat.density = 0.15;\n\tpi = 1.25;\n\tri = 0.2;\n\tp = vec3(4.,1.,2.5);\n\tfor (int k=0; k<5; ++k)\n\t{\n\t\tmat.density = 0.15;\n\t\tp.y = 1.;\n\t\tfor (int l=0; l<5; ++l)\n\t\t{\n\t\t\tintSphere( ro, rd, p, 0.5, mat, i);\n\t\t\tmat.density += ri;\n\t\t\tp.y += pi;\n\t\t}\n\t\tmat.roughness -= ri;\n\t\tp.z -= pi;\n\t}\n\t//\n\tmat.color = vec3(0.0,1.0,1.0);\n\tmat.reflection = true;\n\tmat.refraction = true;\n\tmat.n = 1.33;\n\tmat.fresnel = 0.8;\n\tmat.roughness = .1;\n\tmat.density = 0.5;\n\tp = vec3(0.,4.0,0.);\n\tintSphere( ro, rd, p, 1.5, mat, i);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tif (i.d>0.)\n\t{\n\t\t// ambiant\n\t\tfloat ambiant = 0.1;\n\t\tcol = ambiant*i.mat.color;\n\t\t\n\t\tif (!i.inside)\n\t\t{\n\t\t\t// lighting\n\t\t\tLight lig;\n\t\t\tlig.color = vec3(1.,1.,1.);\n\t\t\tlig.pos = vec3(0., 6., 0.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t\tlig.pos = vec3(-4., 6., -4.);\n\t\t\tif (hidden(i,lig.pos)<0.)\n\t\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t}\n\t}\n\treturn clamp(col,0.,1.);\n}\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\ti.inside = false;\n\t//\n\tvec3 accum = vec3(0.);\n\tvec3 col = vec3(0.);\n\tfloat refl = 1.;\n\tfloat refr = 1.;\n\tcol = raytraceRay(ro, rd, i);\n\taccum += col; // * exp(-0.0005*i.d*i.d);\n\tif (i.mat.reflection)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tlro = li.p;\n\t\tlrd = reflect(-li.vd,li.n);\n\t\tlro += 0.0001*lrd;\n\t\tfor (int k=1; k<4; ++k)\n\t\t{\n\t\t\tli.d = -1.;\n\t\t\trefl *= 1.-i.mat.density;\n\t\t\t//\n\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t//\n\t\t\taccum += col * refl; // * exp(-0.005*i.d*i.d);\n\t\t\tif ((li.d<.0)||(!li.mat.reflection)) break;\n\t\t\tlro = li.p;\n\t\t\tlrd = reflect(-li.vd,li.n);\n\t\t\tlro += 0.0001*lrd;\n\t\t}\n\t}\n\tif (i.mat.refraction)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tfloat n = 1./li.mat.n;\n\t\tfloat cosI = -dot(li.n,li.vd);\n\t\tfloat cost2 = 1.-n*n*(1.-cosI*cosI);\n\t\tif (cost2>0.)\n\t\t{\n\t\t\tlro = li.p;\n\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\tlro += 0.0001*lrd;\n\t\t\tfor (int k=1; k<4; ++k)\n\t\t\t{\n\t\t\t\tli.d = -1.;\n\t\t\t\trefr *= 1.-li.mat.density;\n\t\t\t\t//\n\t\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t\t//\n\t\t\t\taccum += col * refr; //* exp(-0.005*i.d*i.d);\n\t\t\t\tif ((li.d<.0)||(!li.mat.refraction)) break;\n\t\t\t\tif (li.inside)\n\t\t\t\t\tn = li.mat.n;\n\t\t\t\telse\n\t\t\t\t\tn = 1./li.mat.n;\n\t\t\t\tcosI = -dot(li.n,li.vd);\n\t\t\t\tcost2 = 1.-n*n*(1.-cosI*cosI);\n\t\t\t\tif (cost2<=0.) break;\n\t\t\t\tlro = li.p;\n\t\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\t\tlro += 0.0001*lrd;\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(accum,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime);\n\t// camera\t\n\tvec3 ro = vec3( 8.0*cos(Time), 6.0, 8.0*sin(Time) );\n//\tvec3 ro = vec3( -8.0, 6.0, 8.0 );\n\tvec3 ta = vec3( 0.0, 2.5, 0. );\n\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif( iMouse.z>0.0 )\n\t{\n\t\tfloat hd = -m.x * 14.0 + 3.14159;\n\t\tfloat elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n\t\tro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n\t\tro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n\t}\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = raytrace( ro, rd );\n\t\n\tfragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3cDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1256, 1256, 1312, 1312, 1537], [1539, 1539, 1619, 1619, 2091], [2093, 2093, 2147, 2147, 2269], [2271, 2271, 2349, 2349, 2613], [2615, 2676, 2718, 2718, 2941], [2943, 2943, 2980, 2980, 3202], [3204, 3341, 3387, 3387, 4428], [4482, 4482, 4515, 4515, 5041], [5043, 5043, 5095, 5095, 7763], [7765, 7765, 7799, 7799, 9319], [9321, 9321, 9378, 9378, 10185]], "test": "untested"}
{"id": "dl3cDH", "name": "Spheronoi II", "author": "domrally", "description": "Click & Drag!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["voronoi", "flat", "glitch", "spherical", "cell", "tessellation", "polyhedra", "diagram", "decomposition", "dirichlet", "thiessen"], "likes": 21, "viewed": 323, "published": 3, "date": "1699716171", "time_retrieved": "2024-07-30T17:22:53.238775", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 I = iResolution.xy;\n\n    vec3 N, n, F,\n         // ray\n         R = vec3(0, 0, 1),\n         // eye\n         E = vec3(1.2 * (i + i - I) / min(I.x, I.y), -1),\n         // light\n         L = vec3(.7);\n\n    // animation\n    float k, D, f, d = 8.,\n          t = mix(iTime / d, -iMouse.x / 200., max(0., sign(iMouse.z))),\n          r = atan(R.z, R.x) - t,\n          e = atan(E.z, E.x) - t,\n          l = atan(L.z, L.x) - t;\n    R.xz = vec2(cos(r), sin(r));\n    E.xz = vec2(cos(e), sin(e)) * length(E.xz);\n    L.xz = vec2(cos(l), sin(l)) * .7;\n\n    // surface normals\n    for(; k++ < 256.;) {\n        N = normalize(texelFetch(iChannel0, ivec2(k, 8), 0).rgb - .5);\n        N *= sign(f = dot(N, R));\n        F = N - E - R * dot(N - E, N) / abs(f);\n        if ((D = dot(F, F)) < d) d = D, n = N;\n    }\n\n    // lighting\n    float O = max(0., dot(L, n)) + max(0., dot(reflect(L, n), -R));\n    o.rgb = .7 * sqrt(O + O * .1 * vec3(8, 3, 9) * cos(atan(n.z, n.x) - vec3(0, 2, 4)));\n}\n\n\n/*\nSEE ALSO\n\nhttps://en.wikipedia.org/wiki/Voronoi_diagram\nhttps://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n*/\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3cDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 63, 1040]], "test": "untested"}
{"id": "dlKSzm", "name": "Year of Truchets #059", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nAA in Buffer A - turn on with #define AA 2", "tags": ["raymarching", "texture", "truchet"], "likes": 26, "viewed": 353, "published": 3, "date": "1699715452", "time_retrieved": "2024-07-30T17:22:54.002733", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #059\n    11/11/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n    AA in Buffer A - turn on with #define AA 2\n*/\n\nfloat offset[3] = float[]( .0, 1.35, 2.95 );\nfloat weight[3] = float[]( .2, .35, .075 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(.82,.965,1.-dt);\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #059\n    11/11/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-5\n\n// AA - comment out to disable\n//#define AA 2\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\n// globals\nvec3 hit,hitPoint;\nfloat tspeed=0.,gs,gg,time;\n\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(27,32)))*4832.3234); }\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat box(vec3 p, vec3 b) {vec3 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\n\n//@iq extrude\nfloat opx(in float d, in float p, in float h){\n    vec2 w = vec2(d,abs(p)-h);\n  \treturn min(max(w.x, w.y),0.)+length(max(w,0.));\n}\n\nvec2 map(vec3 pos){\n\n    vec2 res = vec2(1e5,0),\n          uv = pos.xz*.235;\n    \n    vec2 id = floor(uv),\n          q = fract(uv)-.5;\n    \n    float rnd = hash21(id+vec2(0,iDate.z)); \n    if(rnd>.5) q.x=-q.x; \n\n    rnd = fract(rnd*32.232);\n    float flt = fract(rnd*31.232);\n\n    vec2 q1 = q-.5, q2 = q+.5;\n    \n    vec2 cv = vec2(length(q1),length(q2));\n    vec2 p = cv.x<cv.y?q1:q2;\n    \n    float ff  = .25+.25*sin(pos.x*.35);\n          ff += .25+.25*cos(pos.z*.65);\n          ff +=  1.3;\n    \n    float thc = .18, wdt = .365;\n    if (flt>.8) { thc = .05;wdt = .3;ff += .45; }\n\n    gs = ff;\n    \n    float k = length(p)-.5; \n          k = abs(k)-thc;\n    \n    if(rnd>.75) k = min(length(q.x)-thc,length(q.y)-thc);\n\n    float d = opx(k,pos.y,3.);\n    float b = box(vec3(q.x,pos.y,q.y),vec3(wdt,ff,wdt))-.1;\n\n    if(flt<.8) { d=max(b,-d); } else { d=max(d,b); }\n    \n    if(d<res.x) {\n        res = vec2(d,flt<.8?flt<.4?2.:4.:5.);\n        hit=pos;\n    }\n\n    float gnd = pos.y+.01;\n    if(gnd<res.x) {\n        float gnt = d-.05;\n        res = vec2(gnd,gnt<gnd?3.:1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    float m = 0.;\n    vec3 color = vec3(0), n = vec3(0), p = vec3(0);\n\n    // marcher\n    for(int i=0;i<132;i++) \n    { \n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += ray.x*.7;\n        m  = ray.y;\n    } \n    \n    hitPoint=hit;\n    gg=gs;\n    \n    if (d < MAX_DIST) \n    {\n        vec3 n = normal(p, d);\n        vec3 lpos =vec3(-4,18,12.*sin(tspeed));\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.05,1.);\n        \n        //shadows\n        float shdw = 1.;\n        for( float t=.1; t < 8.; ) \n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 32.*h/t);\n            t += h;\n            if( shdw<MIN_DIST) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(l,n)),.0),75.);\n        vec3 h = vec3(0);\n \n        if(m==5.) \n        {\n            h = mix(vec3(.5,.3,.0),tex3D(iChannel1,hitPoint,n).rgb,.5);\n            float dd = .25+.25*sin(hitPoint.y*42.);\n            h = mix(h,h*.7,smoothstep(0.,.3,dd));\n            ref = mix(h*.6,vec3(0),dd);\n        }\n        if(m==4.) \n        {\n            h = mix(vec3(.62,.57,.46),tex3D(iChannel2,hitPoint*.5,n).rgb,.5);\n            float dd = hitPoint.y>(gg-.6)&&hitPoint.y<(gg-.15)? 1.:0.;\n            float dx = hitPoint.y>(gg-.5)&&hitPoint.y<(gg-.25)? 1.:0.;\n            h = mix(h,h*.7,dd);\n            h = mix(h,vec3(1),dx);\n            ref = mix(h*.75,vec3(0),dd);\n        }\n        if(m==3.) \n        { \n            h = vec3(.05); \n        }\n        if(m==2.) \n        {\n            h = tex3D(iChannel0,hitPoint*.35,n).rgb;\n            float dd = hitPoint.y>(gg-.6)&&hitPoint.y<(gg-.15)? 1.:0.;\n            float dx = hitPoint.y>(gg-.5)&&hitPoint.y<(gg-.25)? 1.:0.;\n            h = mix(h,h*.7,dd);\n            h = mix(h,vec3(1),dx);\n            ref = mix(vec3(0),vec3(1),dd);\n        }\n        if(m==1.) \n        { \n            h = vec3(.87,.68,.38)*tex3D(iChannel1,hitPoint,n).rgb;\n            ref = h;\n        }\n        \n        color = h*diff+spec;\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    }\n\n    return vec4(color,d);\n}\n\nvec3 renderFull( in vec2 uv )\n{   \n\n    vec3 ro = vec3(22,0,10.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.2-.1)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(-.87-x), ry = rot(y+T*.02);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(1.);\n    float d = 0.,a = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    return mix(vec3(.26,.32,.36),C,exp(-.00003*a*a*a*a));\n}\n\n\nvoid mainImage(out vec4 O, in vec2 F) { \n\n    vec3 col = vec3(0); \n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    #endif\n    \tvec2 p = (-R.xy + 2. * (F + o)) / R.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    O = vec4(col,1);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKSzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[331, 331, 388, 388, 978]], "test": "untested"}
{"id": "mtdyD2", "name": "pseudo-trefoil", "author": "FabriceNeyret2", "description": "variant of generalized solenoid https://shadertoy.com/view/dlVGDW\ntry alt #def L\n\nreal trefoil knot is [ (2+cos3n)*[cos2m, sin2m], sin3n ] https://en.wikipedia.org/wiki/Trefoil_knot\nbut is not easy to raymarch (no SDF). do you have an efficient solution ?", "tags": ["spiral", "ring", "knot", "short"], "likes": 32, "viewed": 387, "published": 3, "date": "1699696405", "time_retrieved": "2024-07-30T17:22:54.771677", "image_code": "// variant of generalized solenoid https://shadertoy.com/view/dlVGDW\n\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))                 // rotation\n\nvec3 S = vec3(3,2,0);                                             // knot parameter\n\n//#define L(p) length(p) - .05                                    // cross section. 2nd = Shane squarish\n//#define L(p) ( q.xy = abs(p) - .05 + .02, min(max(q.x, q.y), 0.) + length(max(q.xy, 0.)) - .02 )\n  #define L(p) int(iTime)%4 < 2 ? length(p) - .05 : ( q.xy = abs(p) - .05 + .02, min(max(q.x, q.y), 0.) + length(max(q.xy, 0.)) - .02 )\n\nfloat sdf(vec3 q) {\n        q = vec3( length(q.xz)-.5, q.y, atan(q.z,q.x)-.5*iTime ), // cylindrical coordinates\n        q = vec3( length(q.xy), atan(q.y,q.x), q.z );             // torus coordinates\n        return L( vec2(q.x-.2, ( mod(S.x*q.z-S.y*q.y,6.28)-3.14 ) /16. )); // solenoïd\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r;\n    vec3  R = iResolution, e = vec3(1e-3,0,0), N,\n          D = normalize(vec3(U+U, -18.*R.y) - R),          // ray direction\n          p = vec3(0,0,15), q,                             // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n       // S = ceil( vec3( 5.*iTime+vec2(1,0),0)   );\n    \n    p.yz *= rot2(-C.y),                                    // rotations\n    p.xz *= rot2(-C.x-1.57),\n    D.yz *= rot2(-C.y),                              \n    D.xz *= rot2(-C.x-1.57);\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, \n        t = min(t, sdf(q) ),                               // solenoïd\n        p += .5*t*D;                                       // step forward = dist to obj    \n    \n    N = vec3( sdf(q+e), sdf(q+e.yxy), sdf(q+e.yyx) ) - t ; // normal\n    O.x < 0. ? O = .5*texture(iChannel0, D) :              // uncomment to display environment \n    O *= O*O*O*3.* texture(iChannel0, reflect(D,N/length(N) ) ); // reflect of environment map\n}\n\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[575, 575, 594, 594, 864], [866, 866, 902, 902, 2053]], "test": "untested"}
{"id": "dt3yD2", "name": "Ray Tracing - M1 Info", "author": "Josephir", "description": "un lancer de rayon simple sur des objets géométriques, la texture des\nobjets à l’aide de procédures, les équations d’éclairement,  des\nmodèles d’éclairement plus complexes prenant en compte la réflexion, et l’occlusion ambiante.", "tags": ["lyon1", "chargueericgalin"], "likes": 0, "viewed": 154, "published": 3, "date": "1699646571", "time_retrieved": "2024-07-30T17:22:56.261693", "image_code": "// IMAGE - M1 INFO\n/* VERY IMPORTANT !!\n\n    - TO CHANGE SCENES, PLEASE DO SO IN INTERSECT(), YOU CAN CALL ALL THE OTHER SCENES FROM THERE !! \n\n    - TO SEE THE AMBIENT OCCLUSION PLEASE COMMENT THE LINE `x = Hit(1000., vec3(0), -1);` in Shade()\n    AND DECOMMENT IT IN INTERSECT().\n\n    - IN COLOR() YOU CAN PLAY AROUND WITH THE NUMBER OF SCENE LIGHTS.\n\n    - TO MAKE GOURSAT STOP GROWING REPLACE `+ 3.5 * cos(iTime) + 14.5` WITH  ` + 11.8`\n\n    - TO MAKE OCTAEDER AND PIPECONNECTOR STOP GROWING REPLACE `+ cos(iTime) * 67.5 - 82.5` WITH `-25.`\n*/ \n\n#define MAX_REFLECTION 5\n\n// Definition of primitives\nstruct Sphere {\n    vec3 center;// Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Ellipsoid {\n    vec3 center;// Center\n    vec3 radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 bottomCenter;// Bottom Center\n    vec3 topCenter;// Top Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Disc {\n    vec3 normal;// Normal\n    vec3 point;// Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Capsule {\n    vec3 bottomCenter;// Bottom Center\n    vec3 topCenter;// Top Center\n    float radius;// Radius\n    int id;// Texture Id\n};\n\nstruct Box {\n    vec3 bottomCorner;// First Corner\n    vec3 topCorner;// Second Corner\n    int id;// Texture Id\n};\n\nstruct Torus {\n    vec3 center;// Center\n    float bigRadius;// Radius between center and the donut cirlce\n    float smallRadius;// Radius between the donut circle and the outer circle\n    int id;// Texture Id\n};\n\nstruct Goursat {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct Octaeder {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct PipeConnector {\n    vec3 center;// Center\n    int id;// Texture Id\n};\n\nstruct Plane {\n    vec3 normal;// Normal\n    vec3 point;// Point\n    int id;// Texture Id\n};\n\nstruct Hit {\n    float t;// Intersection depth\n    vec3 normal;// Normal\n    int id;// Texture Id\n};\n\nstruct Ray {\n    vec3 origin;// Origin\n    vec3 direction;// Direction\n    bool isHomo;// Homothetie boolean\n    bool isRot;// Rotation boolean\n};\n\nstruct Light {\n    vec3 lightColor;//color\n    vec3 lightPos;//position\n};\n\nstruct Scene {\n    //for transformation ray( translation, homo, rotation )\n    Ray tabRay[10];\n    vec3 tabScale[10];\n    vec3 tabAngle[10];\n\n    int nbSphere;// Number of displayed Spheres in the Scene\n    Sphere tabSphere[10];// Array of Spheres\n    Plane plane;// Plane of the Scene\n\n    int nbEllipsoid;// Number of displayed Ellipsoide in the Scene\n    Ellipsoid tabEllipsoid[10];// Array of Ellipsoides\n\n    int nbCylinder;// Number of displayed Cylinder in the Scene\n    Cylinder tabCylinder[10];// Array of Cylinders\n\n    int nbCapsule;// Number of displayed Capsule in the Scene\n    Capsule tabCapsule[10];// Array of Capsules\n\n    int nbBox;// Number of displayed Box in the Scene\n    Box tabBox[10];// Array of Boxes\n\n    int nbTorus;// Number of displayed Torus in the Scene\n    Torus tabTorus[10];// Array of Torus\n\n    int nbGoursat;// Number of displayed EL Goursat in the Scene\n    Goursat tabGoursat[10];// Array of EL Goursat\n\n    int nbOctaeder;// Number of displayed Octaeder in the Scene\n    Octaeder tabOctaeder[10];// Array of Octaeders\n\n    int nbPipeConnector;// Number of displayed PipeConnector in the Scene \n    PipeConnector tabPipeConnector[10];// Array of PipeConnector\n\n    int nbLight;// Number of displayed Light sources in the Scene\n    Light tabLight[25];// Array of Light sources\n};\n\nstruct Material {\n    vec3 diffuse;// Diffuse\n    vec3 ambient;//ambiant\n    vec3 specular;//specular\n    float coefShininess; // reflection coef\n    float reflexivity; // reflexivity du materiel\n    vec3 mirrorColor; // couleur du miroir\n};\n\n//////////////////////////////////////////////////////////////////////////\n//Texturing\n\n/**\n * @brief fonctions using for checkerboard Texture\n * \n * @param vec2 p \n * @return float \n */\nfloat Checkers(in vec2 p) {\n    // Filter kernel\n    vec2 w = fwidth(p)+.001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\n/**\n * @brief Compute point on ray\n * \n * @param Ray ray \n * @param float t \n * @return vec3 \n */\nvec3 Point(Ray ray,float t) {\n    return ray.origin + t * ray.direction;\n}\n\n/**\n * @brief Hashing function\n * \n * @param p : Vector in space\n * @return float : a random number in [-1,1]\n */\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n/**\n * @brief Procedural value noise with cubic interpolation\n * \n * @param p : Point \n * @return float : a random coefiscient\n */\nfloat Noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n/**\n * @brief Sum of Noize\n * \n * @param p : Point\n * @param waveLength : Controls the size of noise patterns\n * @param coef : Coefficient for noise calculation\n * @param iterations : Number of iterations for noise summation\n * @return float : Resulting turbulence value\n */\nfloat Turbulence(in vec3 p, float waveLength, float coef, int iterations) {// somme de bruits \n    float turbulence = coef * Noise(p / waveLength);\n    for (int i = 0; i < iterations; i++) { //boucle pour calculer la somme de bruit\n        coef = coef * 0.5;\n        waveLength = waveLength * 0.5;\n        turbulence = turbulence + coef * Noise(p / waveLength);\n    }\n    return turbulence;\n}\n\n/**\n * @brief convert a float into the type int\n * \n * @param a : Float\n * @return int \n */\nint convert(float a){\n    if (a < 0.0) {\n        a= a - 1.0;\n    }\n    return int(a);\n}\n\n/**\n * @brief Texture of a checkerboard\n * \n * @param point : Point in the space\n * @param color1 : First color of the checkerboard\n * @param color2 : Second color of the checkerboard\n * @return vec3 : Resulting texture\n */\nvec3 Checkboard(vec3 point, vec3 color1, vec3 color2 ){\n    vec3 w = fwidth(point) +.001;\n    int x = convert(point.x);    //convertion en entier\n    int y = convert(point.y);    //correction partie entière des valeurs négatifs pour evité le cas de int(0.4)=int(-0.4)\n    int z = convert(point.z);\n\n        if ((x + y + z) % 2 == 0) {//modulo 2 pour faire 2 cas: coordonées paire, coordonées impaire\n        return color1 / w;\n    } else {\n        return color2 / w;\n    }   \n}\n\n/**\n * @brief Texture of a marble\n * \n * @param point : Point in the space\n * @param color1 : First material of the marble\n * @param color2 : Second material of the marble\n * @return Material : Resulting Marble\n */\nMaterial MarbleTexture(vec3 point, Material color1, Material color2) {\n    point = point + Turbulence(point, 1., 20., 10);\n    float t = cos(point.x);\n    Material finalColor = Material(color1.diffuse * t + color2.diffuse * (0.6 - t), vec3(0.2), color1.specular * t + color2.specular * (1.0 - t), 50., 0., vec3(0.));\n    return finalColor;\n}\n\n/**\n * @brief Texture of a Veins marble\n * \n * @param point : Point in the space\n * @param color1 : Vein material of the marble\n * @param color2 : back material of the marble\n * @return Material : Resulting Veins Marble\n */\nMaterial VeinMarbleTexture(vec3 point, Material color1, Material color2) {\n    point = point + Turbulence(point, 5., 5., 10);\n    float t = tan(point.x*3.);\n    if(t < 4.) {\n        return color1;\n    } \n    else {\n        return color2;\n    }\n}\n\n// Source : https://www.shadertoy.com/view/wl3czM\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\n// Source : https://www.shadertoy.com/view/wl3czM\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\n/**\n * @brief Texture of a Wood \n * \n * @param point : Point in the space\n * @return Material : Resulting a Wood Texture\n */\nfloat WoodTexture(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\n/**\n * @brief Texture of a Wood \n * \n * @param point : Point in the space\n * @return Material : Resulting a Wood Texture\n */\nvec3 WoodTexture2(vec3 p, vec3 color1, vec3 color2) {\n    p = p + Turbulence(p, 5., 0.5, 5);\n    float r = sqrt (p.x * p.x + p.y * p.y);\n    float pattern = 0.5 + 0.5 * cos (10. * 3.1415927 * r) ;   \n    return mix(color1, color2, pattern); \n}\n\n/**\n * @brief Definition of all texture in the scene\n * \n * @param p : Point in the space\n * @param i : Texture index\n * @return Material : Specific material per index\n */\nMaterial Texture(vec3 p, int i) {\n    if (i == 1) { // uniform\n         // return Material(vec3(.8,.0,.1),vec3(0.2,0.2,0.2), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n        return Material(vec3(.8,.5,.4), vec3(0.2), vec3(0.7, 0.7, 0.7), 50., 0., vec3(0.));\n    }\n    else if (i == 2) { // variation\n        vec3 colorA = vec3(0.1,0.1,0.9);\n        vec3 colorB = vec3(1.,0.8,0.2);\n        return Material(mix(colorA, colorB, sin(iTime*0.5)),vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.) );\n    }\n    else if (i == 3) { // Checkboard\n        vec3 texture = Checkboard(p, vec3(1., 1., 1.), vec3(0., 0., 0.));\n        return Material(texture, vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.) );\n    }\n    else if (i == 4) { // Marble\n        Material color1 = Material(vec3(1.2, 1.2, 1.2), vec3(0.4,0.4,0.4), vec3(0.9, 0.9, 0.9), 50., 0., vec3(0.));\n        Material color2 = Material(vec3(0.83, .83, .83), vec3(0.4,0.4,0.4), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n        Material marble = MarbleTexture(p, color1, color2);\n        return marble;\n    }\n    else if (i == 5) { // Marble\n        Material color1 = Material(vec3(0.3, 0.3, 0.3), vec3(0.2,0.2,0.2), vec3(0, 0, 0), 1., 0., vec3(0.));\n        Material color2 = Material(vec3(0.9, 0.9, 0.2), vec3(0.7,0.7,0.7), vec3(3, 3, 3), 100., 0., vec3(0.));\n        Material marble = VeinMarbleTexture(p, color1, color2);\n        return marble;\n    }\n    else if (i == 6) { // Mirror\n        return Material(vec3(.8,.5,.4), vec3(.7), vec3(0.2), 50., 1., vec3(0,0, 0.));\n    }\n    else if (i == 7) { // Wood\n        float woodValue = WoodTexture(p.xy);\n        vec3 color1 = vec3(0.4, 0.2, 0.1);\n        vec3 color2 = vec3(0.2, 0.1, 0.07);\n        vec3 texture = mix(color1, color2, woodValue);\n        return Material(texture, vec3(.2), vec3(0.1), 50., 0., vec3(0, 0, 0));\n    }\n    else if (i == 8) { // Wood 2\n        vec3 color1 = vec3(.17, .1, .05);\n        vec3 color2 = vec3(.08, .05, .03);\n        vec3 texture = WoodTexture2(p, color1, color2);\n        return Material(texture, vec3(.7), vec3(0.2), 50., 0., vec3(0, 0, 0));\n    }\n    else if (i == 0) { // classic checkboard\n        float f = Checkers(.5*p.xy);\n        vec3 col = vec3(.4,.5,.7) + f * vec3(.1);\n        return Material(col, vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9), 50., 0., vec3(0.));\n    }\n    return Material(vec3(0),vec3(0.,0.,0.), vec3(0.2, 0.2, 0.2), 50., 0., vec3(0.));\n}\n\n/**\n * @brief resolv second order equation : ax² + bx + c = 0\n * \n * @param a : float\n * @param b : float\n * @param c : float\n * @return float : min of the 2 solution\n */\nfloat solvRoots(float a, float b, float c) {\n    float t;\n    //on calcul le déterminant d pour trouver les racine de l'équation\n    float d = b * b - 4. * a * c;\n    if (d > 0.){\n        float t1 = (-b - sqrt(d)) / (2.0 * a);\n        float t2 = (-b + sqrt(d)) / (2.0 * a);\n        float t = min(t1, t2);\n        return t;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////\n//Intersection functions\n\n/**\n * @brief Classic sphere intersection\n * \n * @param ray : The ray\n * @param sph : Structure information\n * @param x : Returned intersection information\n * @return true\n * @return false\n */\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n    vec3 oc = ray.origin - sph.center;\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float d = b * b - c;\n    if (d>0.) {\n        float t = -b - sqrt(d);\n        if (t>0.) {\n            vec3 p = Point(ray,t);\n            x = Hit(t, normalize(p-sph.center), sph.id); \n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief Classic Plane intersection\n * \n * @param ray : The ray\n * @param pl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    pl.normal = normalize(pl.normal);\n    float t = -dot(ray.origin - pl.point, pl.normal) / dot(ray.direction, pl.normal);\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        x = Hit(t, pl.normal, pl.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and an Ellipsoid\n * \n * @param ray : The ray\n * @param ellip : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellip, out Hit x) {\n    vec3 oc = ray.origin - ellip.center;\n    float a = dot((ray.direction / ellip.radius), (ray.direction / ellip.radius));\n    float b = 2. * dot((oc / ellip.radius), (ray.direction / ellip.radius));\n    float c = dot((oc/ellip.radius), (oc/ellip.radius)) - dot(ellip.radius, ellip.radius);\n\n    float t = solvRoots(a, b, c);\n    if (t>0.) {\n        vec3 p = Point(ray,t);\n        x = Hit(t,normalize(p-ellip.center),ellip.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Cylinder body\n * \n * @param ray : The ray\n * @param cyl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCylinderBody(Ray ray, Cylinder cyl, out Hit x) {\n    vec3 oa = ray.origin - cyl.bottomCenter;\n    vec3 u = normalize(cyl.topCenter - cyl.bottomCenter);\n    \n    float a = dot(ray.direction, ray.direction) - dot(ray.direction, u) * dot(ray.direction, u); \n    float b = 2. * ( dot(oa, ray.direction) - dot(oa, u) * dot(ray.direction, u));\n    float c = dot(oa, oa) - dot(oa, u) * dot(oa, u) - cyl.radius * cyl.radius;\n    float t = solvRoots(a, b, c);\n    if (t>0.) {\n        vec3 p = Point(ray, t);\n        float v = dot(p - cyl.bottomCenter, u);\n        vec3 h = cyl.bottomCenter + v * u;\n        if (v >= 0. && v <= length(cyl.topCenter - cyl.bottomCenter)) {\n            x = Hit(t, normalize(p - h), cyl.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Disc\n * \n * @param ray : The ray\n * @param disc : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectDisc(Ray ray,Disc disc,out Hit x) {\n    disc.normal = normalize(disc.normal);\n    bool pl = IntersectPlane(ray, Plane(disc.normal, disc.point, disc.id), x);\n    if (pl) {\n        vec3 p = Point(ray, x.t);\n        if (length(p - disc.point) < disc.radius) {\n            // x = Hit(x.t,disc.n, disc.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Cylinder\n * \n * @param ray : The ray\n * @param cyl : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x) {\n    x = Hit(1000., vec3(0), -1);\n    Hit x_;\n    \n    Disc ds1 = Disc(-normalize(cyl.topCenter - cyl.bottomCenter), cyl.bottomCenter, cyl.radius, cyl.id);\n    Disc ds2 = Disc(normalize(cyl.topCenter - cyl.bottomCenter), cyl.topCenter, cyl.radius, cyl.id);\n    bool b1 = IntersectDisc(ray, ds1, x_);\n    if (b1 && x_.t < x.t) {\n        x = x_;\n    }\n    bool b2 = IntersectDisc(ray, ds2, x_);\n    if (b2 && x_.t < x.t) {\n        x = x_;\n    }\n    bool body = IntersectCylinderBody(ray, cyl, x_);\n    if (body && x_.t < x.t) {\n        x = x_;\n    }\n    return b1 || b2 || body;  \n}\n\n/**\n * @brief intersect between a Ray and a Capsule\n * \n * @param ray : The ray\n * @param cap : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    x = Hit(1000., vec3(0), -1);\n    Hit x_;\n    Sphere sph1 = Sphere(cap.bottomCenter, cap.radius, cap.id);\n    Sphere sph2 = Sphere(cap.topCenter, cap.radius, cap.id);\n    bool b1 = IntersectSphere(ray, sph1, x_);\n    if (b1 && x_.t < x.t) {\n        x = x_;\n    }\n    bool b2 = IntersectSphere(ray, sph2, x_);\n    if (b2 && x_.t < x.t) {\n        x = x_;\n    }\n    Cylinder cyl;\n    cyl.bottomCenter = cap.bottomCenter;\n    cyl.topCenter = cap.topCenter;\n    cyl.radius = cap.radius;\n    cyl.id = cap.id;\n    bool body = IntersectCylinderBody(ray, cyl, x_);\n    if (body && x_.t < x.t) {\n        x = x_;\n    }\n    return b1 || body || b2;  \n}\n\n// Source : https://www.shadertoy.com/view/fsB3Wt\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\n\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for (int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n/**\n * @brief intersect between a Ray and a Box\n * \n * @param ray : The ray\n * @param bx : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectBox(Ray ray, Box bx, out Hit x) {\n    vec3 t0, t1;\n    //défini tout les cas de t0 et t1 pour x puis y puis z dans tous les angles de la cam\n    if (ray.direction.x >= 0.) { \n        t0.x = (bx.bottomCorner.x - ray.origin.x) / ray.direction.x;\n        t1.x = (bx.topCorner.x - ray.origin.x) / ray.direction.x;\n    } \n    else { \n        t0.x = (bx.topCorner.x - ray.origin.x) / ray.direction.x;\n        t1.x = (bx.bottomCorner.x - ray.origin.x) / ray.direction.x;\n    } \n    \n    if (ray.direction.y >= 0.) { \n        t0.y = (bx.bottomCorner.y - ray.origin.y) / ray.direction.y;\n        t1.y = (bx.topCorner.y - ray.origin.y) / ray.direction.y;\n    } \n    else { \n        t0.y = (bx.topCorner.y - ray.origin.y) / ray.direction.y;\n        t1.y = (bx.bottomCorner.y - ray.origin.y) / ray.direction.y;\n    } \n    \n    if (ray.direction.z >= 0.) { \n        t0.z = (bx.bottomCorner.z - ray.origin.z) / ray.direction.z;\n        t1.z = (bx.topCorner.z - ray.origin.z) / ray.direction.z;\n    } \n    else { \n        t0.z = (bx.topCorner.z - ray.origin.z) / ray.direction.z;\n        t1.z = (bx.bottomCorner.z - ray.origin.z) / ray.direction.z;\n    }\n    //filtre des cas ne touchant pas la boite\n    if (t0.x > t1.y || t0.y > t1.x) return false;\n    //filtre pour trouver tmin et tmax\n    float tmin = max(t0.x, t0.y);\n    float tmax = min(t1.x, t1.y);\n    //même opération étendu à z\n    if (tmin > t1.z || t0.z > tmax) return false;\n    tmin = max(tmin, t0.z);\n    tmax = min(tmax, t1.z);\n    //sélection du t:\n    float t = (tmin < 0.) ? tmax : tmin;\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        //le centre du box\n        vec3 c = (bx.bottomCorner + bx.topCorner) / 2.;\n        x = Hit(t, normalize(p - c), bx.id);\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a Torus\n * \n * @param ray : The ray\n * @param tor : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectTorus(Ray ray, Torus tor, out Hit x) { \n\n    // http://heigeas.free.fr/laure/ray_tracing/tore.html\n\n    if (tor.bigRadius > tor.smallRadius) {\n        vec3 oc = ray.origin - tor.center;\n\n        float f = dot(ray.direction, ray.direction);\n        float g = 2. * dot(oc, ray.direction); \n        float h = dot(oc, oc) + (tor.bigRadius * tor.bigRadius) - (tor.smallRadius * tor.smallRadius);\n\n        float i = - 4. * (tor.bigRadius * tor.bigRadius) * ((ray.direction.x * ray.direction.x) + (ray.direction.y * ray.direction.y));\n        float j = - 8. * (tor.bigRadius * tor.bigRadius) * ((oc.x * ray.direction.x) + (oc.y * ray.direction.y)); \n        float k = - 4. * (tor.bigRadius * tor.bigRadius) * ((oc.x * oc.x) + (oc.y * oc.y)); \n\n        float a = f * f;\n        float b = 2. * f * g;\n        float c = (2. * f * h) + (g * g) + i;\n        float d = (2. * g * h) + j;\n        float e = (h * h) + k;\n\n        vec4 roots;\n        int nroots = solveQuartic(a, b, c, d, e, roots); \n\n        if (nroots > 0) {\n            float t1, t2, t;\n            if (nroots == 2) {\n                t =  min(roots.x, roots.y);\n            }\n\n            if (nroots == 4) {\n                t1 = min(roots.x, roots.y);\n                t2 = min(roots.z, roots.w);\n                t = min (t1, t2);\n            }\n\n            if (t > 0.) {\n                vec3 p = Point(ray, t);\n                vec3 normale;\n\n                vec3 odt = oc + ray.direction * t;\n                float oxdt = oc.x + ray.direction.x * t;\n                float oydt = oc.y + ray.direction.y * t;\n                float ozdt = oc.z + ray.direction.z * t;\n\n                normale.x = 4. * oxdt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius)) - 8. * dot(tor.bigRadius, tor.bigRadius) * oxdt;\n                normale.y = 4. * oydt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius)) - 8. * dot(tor.bigRadius, tor.bigRadius) * oydt;\n                normale.z = 4. * ozdt * (dot(oc, oc) + 2. * dot(oc, ray.direction * t) + dot(ray.direction * t, ray.direction * t) + dot(tor.bigRadius, tor.bigRadius) - dot(tor.smallRadius, tor.smallRadius));\n                \n                x = Hit(t, normalize(normale),tor.id);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n/**\n * @brief intersect between a Ray and a Goursat Box\n * \n * @param ray : The ray\n * @param goursat : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectGoursat(Ray ray, Goursat goursat, out Hit x) {\n\n    // http://heigeas.free.fr/laure/ray_tracing/cubetroue.html\n\n    vec3 oc = ray.origin - goursat.center;\n    vec3 rayD2 = ray.direction * ray.direction;\n    vec3 rayD3 = rayD2 * ray.direction;\n    vec3 rayO2 = oc * oc;\n    vec3 rayO3 = rayO2 * oc;\n\n    float f = dot(rayD2, rayD2);\n    float g = 4.* dot(oc, rayD3);\n    float h = 6. * dot(rayO2, rayD2);\n    float i = 4. * dot(rayO3, ray.direction);\n    float j = dot(rayO2, rayO2);\n\n    float k = -5. * dot(ray.direction, ray.direction);\n    float l = -10. * dot(oc, ray.direction);\n    float m = -5. * dot(oc, oc) + 3.5 * cos(iTime) + 14.5;\n\n    float a = f;\n    float b = g;\n    float c = h + k;\n    float d = i + l;\n    float e = j + m;\n\n    vec4 roots;\n    int nroots = solveQuartic(a, b, c, d, e, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            float ocX2 = oc.x * oc.x;\n            float ocX3 = ocX2 * oc.x;\n            \n            float ocY2 = oc.y * oc.y;\n            float ocY3 = ocY2 * oc.y;\n            \n            float ocZ2 = oc.z * oc.z;\n            float ocZ3 = ocZ2 * oc.z;\n\n\n            float dXt = ray.direction.x * t;\n            float dYt = ray.direction.y * t;\n            float dZt = ray.direction.z * t;\n\n            float dXt2 = dXt * dXt;\n            float dYt2 = dYt * dYt;\n            float dZt2 = dZt * dZt;\n\n            float dXt3 = dXt2 * dXt;\n            float dYt3 = dYt2 * dYt;\n            float dZt3 = dZt2 * dZt;\n\n            normale.x = 4. * ( ocX3 + 3.*dot(ocX2, dXt) + 3.*dot(oc.x, dXt2) + dXt3) - 10. * (oc.x + ray.direction.x * t );\n            normale.y = 4. * ( ocY3 + 3.*dot(ocY2, dYt) + 3.*dot(oc.y, dYt2) + dYt3) - 10. * (oc.y + ray.direction.y * t );\n            normale.z = 4. * ( ocZ3 + 3.*dot(ocZ2, dZt) + 3.*dot(oc.z, dZt2) + dZt3) - 10. * (oc.z + ray.direction.z * t );\n\n            x = Hit(t, normalize(normale - p), goursat.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and an Octaeder\n * \n * @param ray : The ray\n * @param octa : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectOctaeder(Ray ray, Octaeder octa, out Hit x) {\n\n    // https://mathcurve.com/surfaces/goursat/goursat.shtml\n\n    vec3 oc = ray.origin - octa.center;\n    vec4 roots;\n\n    float rdx = ray.direction.x;\n    float rdy = ray.direction.y;\n    float rdz = ray.direction.z;\n\n    float rdx2 = rdx * rdx;\n    float rdy2 = rdy * rdy;\n    float rdz2 = rdz * rdz;\n\n    float odx = oc.x * rdx;\n    float ody = oc.y * rdy;\n    float odz = oc.z * rdz;\n\n    float ocx2 = oc.x * oc.x;\n    float ocy2 = oc.y * oc.y;\n    float ocz2 = oc.z * oc.z;\n\n    float l = 8. * (dot(rdx2, rdy2) + dot(rdy2, rdz2) + dot(rdz2, rdx2)); \n    float m = 8. * (2. * (dot(odx, rdy2) + dot(ody, rdx2) \n                        + dot(ody, rdz2) + dot(odz, rdy2) \n                        + dot(odz, rdx2) + dot(odx, rdz2)));\n\n    float n =  8. * (dot(ocx2, rdy2) + dot(ocy2, rdx2)\n                    + dot(ocy2, rdz2) + dot(ocz2, rdy2)\n                    + dot(ocz2, rdx2) + dot(ocx2, rdz2)\n                    + 4. * (dot(odx, ody) + dot(ody, odz) + dot(odz, odx)));\n    float o = 8. * (2. * (dot(ocx2, ody) + dot(ocy2, odx) \n                        + dot(ocy2, odz) + dot(ocz2, ody) \n                        + dot(ocz2, odx) + dot(ocx2, odz) ));\n\n    float p = 8. * (dot(ocx2, ocy2) + dot(ocy2, ocz2) + dot(ocz2, ocx2));\n\n    float q = 5. * (dot(ray.direction, ray.direction));\n    float r = 5. * (2. * (dot(oc, ray.direction)));\n    float s = 5. * (dot(oc, oc)) + cos(iTime) * 67.5 - 82.5;\n\n    float f = l;\n    float g = m;\n    float h = n + q;\n    float i = o + r;\n    float j = p + s;\n\n    int nroots = solveQuartic(f, g, h, i, j, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            normale.x = 16. * (oc.x + ray.direction.x * t) * ( dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y * t) + dot(ray.direction.y * t, ray.direction.y * t) \n                            + dot(oc.z, oc.z) + 2. * dot(oc.z, ray.direction.z * t) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 10. * (oc.x + ray.direction.x * t);\n            normale.y = 16. * (oc.y + ray.direction.y * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x * t) + dot(ray.direction.x * t, ray.direction.x * t) \n                            + dot(oc.z, oc.z) + 2. * dot(oc.z, ray.direction.z * t) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 10. * (oc.y + ray.direction.y * t);\n            normale.z = 16. * (oc.z + ray.direction.z * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x * t) + dot(ray.direction.x * t, ray.direction.x * t) \n                            + dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y * t) + dot(ray.direction.y * t, ray.direction.y * t)) \n                            + 10. * (oc.z + ray.direction.z * t);\n\n            x = Hit(t, normalize(normale), octa.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief intersect between a Ray and a PipeConnector \n * \n * @param ray : The ray\n * @param pip : Structure information\n * @param x : Returned intersection information\n * @return true \n * @return false \n */\nbool IntersectPipeConnector(Ray ray, PipeConnector pip, out Hit x) {\n\n    // https://mathcurve.com/surfaces/goursat/goursat.shtml\n\n    vec3 oc = ray.origin - pip.center;\n    vec4 roots;\n\n    float rdx = ray.direction.x;\n    float rdy = ray.direction.y;\n    float rdz = ray.direction.z;\n\n    float rdx2 = rdx * rdx;\n    float rdy2 = rdy * rdy;\n    float rdz2 = rdz * rdz;\n\n    float odx = oc.x * rdx;\n    float ody = oc.y * rdy;\n    float odz = oc.z * rdz;\n\n    float ocx2 = oc.x * oc.x;\n    float ocy2 = oc.y * oc.y;\n    float ocz2 = oc.z * oc.z;\n\n    float l = 2. * (dot(rdx2, rdy2) + dot(rdy2, rdz2) + dot(rdz2, rdx2)); \n    float m = 2. * (2. * (dot(odx, rdy2) + dot(ody, rdx2) \n                        + dot(ody, rdz2) + dot(odz, rdy2) \n                        + dot(odz, rdx2) + dot(odx, rdz2)));\n\n    float n =  2. * (dot(ocx2, rdy2) + dot(ocy2, rdx2)\n                    + dot(ocy2, rdz2) + dot(ocz2, rdy2)\n                    + dot(ocz2, rdx2) + dot(ocx2, rdz2)\n                    + 4. * (dot(odx, ody) + dot(ody, odz) + dot(odz, odx)));\n    float o = 2. * (2. * (dot(ocx2, ody) + dot(ocy2, odx) \n                        + dot(ocy2, odz) + dot(ocz2, ody) \n                        + dot(ocz2, odx) + dot(ocx2, odz) ));\n\n    float p = 2. * (dot(ocx2, ocy2) + dot(ocy2, ocz2) + dot(ocz2, ocx2));\n\n    float q = -3. * (dot(ray.direction, ray.direction));\n    float r = -3. * (2. * (dot(oc, ray.direction)));\n    float s = -3. * (dot(oc, oc)) + cos(iTime) * 67.5 - 82.5;\n\n    float f = l;\n    float g = m;\n    float h = n + q;\n    float i = o + r;\n    float j = p + s;\n\n    int nroots = solveQuartic(f, g, h, i, j, roots);\n\n    if (nroots > 0) {\n        float t1, t2, t;\n        if (nroots == 2) {\n            t =  min(roots.x, roots.y);\n        }\n\n        if (nroots == 4) {\n            t1 = min(roots.x, roots.y);\n            t2 = min(roots.z, roots.w);\n            t = min (t1, t2);\n        }\n\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            vec3 normale;\n\n            normale.x = 4. * (oc.x + ray.direction.x * t) * ( dot(oc.y, oc.y) + 2. * dot(oc.y, ray.direction.y) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 6. * (oc.x + ray.direction.x * t);\n            normale.y = 4. * (oc.y + ray.direction.y * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t)) \n                            + 6. * (oc.y + ray.direction.y * t);\n            normale.z = 4. * (oc.z + ray.direction.z * t) * ( dot(oc.x, oc.x) + 2. * dot(oc.x, ray.direction.x) \n                            + dot(ray.direction.y * t, ray.direction.y * t) + dot(oc.z, oc.z) \n                            + 2. * dot(oc.z, ray.direction.z) + dot(ray.direction.z * t, ray.direction.z * t))\n                            + 6. * (oc.z + ray.direction.z * t);\n\n            x = Hit(t, normalize(normale), pip.id);\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @brief Translates the origin of a ray by a specified point.\n * \n * @param ray : The ray\n * @param p : point\n * @return Ray the translated ray \n */\nRay Translation(Ray ray, vec3 p) {\n    return Ray(ray.origin - p, ray.direction, false, false);\n}\n\n/**\n * @brief Translates the origin of a ray by a specified point.\n * \n * @param ray : The ray vector in space\n * @param p : point\n * @return Ray the translated ray in space\n */\nvec3 Translation(vec3 ray, vec3 p) {\n    return ray - p;\n}\n\n/**\n * @brief Applies rotation to a given normal vector around a specified point.\n * \n * This function applies rotations to a normal vector around the specified point 'tr'.\n * \n * @param normal The normal vector to be rotated.\n * @param rot A vector representing the rotation angles around X, Y, and Z axes.\n * @param tr The center point around which the rotation is performed.\n * @return vec3 The rotated normal vector.\n */\nvec3 RotationNormal(vec3 normal, vec3 rot, vec3 tr) {\n    //construire les matrices de rotations\n    mat3 rotationX = mat3(\n        1., 0.      , 0.       ,\n        0., cos(rot.x), -sin(rot.x),\n        0., sin(rot.x), cos(rot.x)\n    );\n    mat3 rotationY = mat3(\n        cos(rot.y), 0., -sin(rot.y),\n        0.      , 1., 0.       ,\n        sin(rot.y), 0., cos(rot.y)\n    );\n    mat3 rotationZ = mat3(\n        cos(rot.z), -sin(rot.z), 0.,\n        sin(rot.z), cos(rot.z) , 0.,\n        0.      , 0.       , 1.\n    );\n    normal = rotationX * rotationY * rotationZ * normal;\n    return normal;\n}\n\n/**\n * @brief Applies rotation to a ray around a specified point.\n * \n * This function applies rotations to a given ray using the rotation angle around the specified point 'tr'.\n * \n * @param ray The original ray to be rotated.\n * @param rot A vector representing the rotation angles around X, Y, and Z axes.\n * @param tr The center point around which the rotation is performed.\n * @return Ray The rotated ray.\n */\nRay Rotation(Ray ray, vec3 rot, vec3 tr) {\n    //construire les matrices de rotations\n    mat3 rotationX = mat3(\n        1., 0.      , 0.       ,\n        0., cos(rot.x), -sin(rot.x),\n        0., sin(rot.x), cos(rot.x)\n    );\n    mat3 rotationY = mat3(\n        cos(rot.y), 0., -sin(rot.y),\n        0.      , 1., 0.       ,\n        sin(rot.y), 0., cos(rot.y)\n    );\n    mat3 rotationZ = mat3(\n        cos(rot.z), -sin(rot.z), 0.,\n        sin(rot.z), cos(rot.z) , 0.,\n        0.      , 0.       , 1.\n    );\n    //ramener à 0\n    ray.direction = rotationZ * rotationY * rotationX * ray.direction;\n    ray.origin = Translation(ray.origin, tr);\n    //effectuer la rotation\n    ray.origin = rotationZ * rotationY * rotationX * ray.origin;\n    //ramener à où c'était\n    ray.origin = Translation(ray.origin, -tr);\n    return Ray(ray.origin, ray.direction, ray.isHomo, true);\n}\n\n/**\n * @brief Applies a homothety transformation to a ray around a specified point.\n * \n * This function applies a homothety transformation to a given ray by changing its direction and origin,\n * relative to the specified point 'tr'.\n * \n * @param ray The original ray to be transformed.\n * @param homo A vector representing scaling factors for the ray's direction.\n * @param tr The center point around which the homothety transformation is performed.\n * @return Ray The transformed ray.\n */\nRay Homothetie(Ray ray, vec3 homo, vec3 tr) {\n    // change direction\n    ray.direction = ray.direction / homo;\n\n    // move to 0 origin\n    ray.origin = Translation(ray.origin, tr);\n    // change origin\n    ray.origin = ray.origin / homo;\n    // get back the origin\n    ray.origin = Translation(ray.origin, -tr);\n    // normalize the direction\n    ray.direction = normalize(ray.direction);\n    return Ray(ray.origin, ray.direction, true, ray.isRot);\n}\n\n/**\n * @brief Transforms a hit point obtained in homothetic space back to the original space.\n * \n * This function takes a hit point 'homoHit' obtained in homothetic space and transforms it back\n * to the original space using the given baseRay and homoRay for reference. The 'scale' vector\n * is used to scale the transformed point.\n * \n * @param homoHit The hit point in homothetic space.\n * @param baseRay The original ray used as a reference for transformation.\n * @param homoRay The transformed ray used as a reference for transformation.\n * @param scale A vector representing the scaling factors.\n * @return Hit The hit point in the original space.\n */\nHit Homothetie(Hit homoHit, Ray baseRay, Ray homoRay, vec3 scale) {\n    // point d'intersection dans le repère non transformé\n    vec3 homoPoint = Point(homoRay, homoHit.t);\n    // point d'intersection sur le vrai objet transformé\n    homoPoint *= scale;\n    \n    Hit hit = homoHit;\n    // nouveau t à partir du vrai point transformé (on résout juste homoPoint = baseRay.o + t * baseRay.d, \n    // en choisissant n'importe quelle composante, ici x)\n    hit.t = (homoPoint.x - baseRay.origin.x) / baseRay.direction.x;\n    \n    return hit;\n}\n\n/**\n * @brief Computes the center point between two given points.\n * \n * @param cornerA The first point.\n * @param cornerB The second point.\n * @return vec3 The center point between 'cornerA' and 'cornerB'.\n */\nvec3 FindTheCenter(vec3 cornerA, vec3 cornerB) {\n    return (cornerA + cornerB)/2.;\n}\n\n/**\n * @brief Creates a scene of all the objects.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneAllObjects(Ray ray){\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 1;\n    scene.nbEllipsoid = 1;\n    scene.nbCylinder = 1;\n    scene.nbCapsule = 1;\n    scene.nbBox = 1;\n    scene.nbTorus = 1;\n    scene.nbGoursat = 1;\n    scene.nbOctaeder = 1;\n    scene.nbPipeConnector = 1;\n    \n    scene.tabSphere[0] = Sphere(vec3(-4.,5.,4.),1.,1);\n    scene.tabEllipsoid[0] = Ellipsoid(vec3(-4., 0., 4.), vec3(1., 1.2, 0.5), 1);\n    scene.tabCylinder[0] = Cylinder(vec3(0.,5.,0.), vec3(0., 5., 2.1), .75, 1);\n    scene.tabCapsule[0] = Capsule(vec3(0.,2.,0.), vec3(0., 2., 3.1), 0.5 ,1);\n    scene.tabBox[0] = Box(vec3(-1.1, -1.1, 0.1), vec3(2.5, 0.1, 2.1), 1);\n    \n    scene.tabRay[5] = Translation(scene.tabRay[0], vec3(0, -3, 2)); \n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .5, 1);\n    \n    scene.tabGoursat[0] = Goursat(vec3(0., -8., 2.1), 1);\n    \n    scene.tabOctaeder[0] = Octaeder(vec3(-10., -8., 4), 1);\n    scene.tabPipeConnector[0] = PipeConnector(vec3(-23., -3, 10), 1);\n    \n    return scene;\n}\n\n/**\n * @brief Creates a scene where we test Translation, Homotethy and Rotation functions.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneTransformation(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),4);\n    \n    for (int i = 0; i < 9; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    // //Box homothethy\n    scene.nbBox = 1;\n    scene.tabBox[0] = Box(vec3(-4., -1., 2.), vec3(-2, 1., 4.), 2);\n    scene.tabScale[0] = vec3(1., sin(iTime+1.5*3.1415)+2., cos(iTime)+2.);\n    scene.tabRay[0] = Homothetie(scene.tabRay[0], scene.tabScale[0], FindTheCenter(scene.tabBox[0].bottomCorner, scene.tabBox[0].topCorner));\n\n    scene.nbTorus = 1;\n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .2, 7);\n    scene.tabRay[1] = Translation(scene.tabRay[1], vec3(0., 0., 4.));\n    scene.tabScale[1] = vec3(1., 1., 4.);\n    scene.tabAngle[1] = vec3(0.5*-iTime, 0., 0.);\n    scene.tabRay[1] = Rotation(scene.tabRay[1], scene.tabAngle[1], scene.tabTorus[0].center);\n    scene.tabRay[1] = Homothetie(scene.tabRay[1], scene.tabScale[1], scene.tabTorus[0].center);\n\n    scene.nbGoursat = 1;\n    scene.tabGoursat[0] = Goursat(vec3(0, 6, 1), 5); \n    scene.tabScale[2] = vec3(1.,2.,1.);\n    scene.tabRay[2] = Homothetie(scene.tabRay[2], scene.tabScale[2], scene.tabGoursat[0].center);\n\n    scene.nbOctaeder = 1;\n    scene.tabOctaeder[0] = Octaeder(vec3(0, -6, 2.2), 1);\n    scene.tabAngle[3] = vec3(0., iTime, 10.*iTime);\n    scene.tabRay[3] = Rotation(scene.tabRay[3], scene.tabAngle[3], scene.tabOctaeder[0].center);\n\n    return scene;\n}\n\n/**\n * @brief Creates a scene with spheres.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneSphere(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n    \n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n     scene.nbSphere = 4;\n     scene.tabSphere[0] = Sphere(vec3(-3, 0, 1), 1.5, 6);\n     scene.tabSphere[1] = Sphere(vec3(0.,-3.,1.),1.5,8);\n     scene.tabSphere[2] = Sphere(vec3(3.,0.,1.),1.5,6);\n     scene.tabSphere[3] = Sphere(vec3(0.,3.,1.),1.5,7);\n\n    return scene;\n}\n\n/**\n * @brief Creates a scene where we display our Textures.\n * \n * @param ray The ray\n * @return Dynamic scene.\n */\nScene sceneTexture(Ray ray) {\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 1;\n    scene.nbEllipsoid = 1;\n    scene.nbCylinder = 1;\n    scene.nbCapsule = 1;\n    scene.nbBox = 1;\n    scene.nbTorus = 1;\n    scene.nbGoursat = 0;\n    scene.nbOctaeder = 0;\n    scene.nbPipeConnector = 0;\n    \n    scene.tabSphere[0] = Sphere(vec3(0.,-5.,1.), 2.,7);\n    scene.tabEllipsoid[0] = Ellipsoid(vec3(-4., -5., 4.5), vec3(1.,1.,0.5), 4);\n    scene.tabCylinder[0] = Cylinder(vec3(0.,3.,0.), vec3(0., 3., 2.1), .75, 3);\n    scene.tabCapsule[0] = Capsule(vec3(-2.,3.,2.), vec3(-4., 3., 3.), 0.5 ,2);\n    scene.tabBox[0] = Box(vec3(-4., -1.5, 0.), vec3(-2.1, 1.5, 5.), 5);\n    scene.tabTorus[0] = Torus(vec3(0., 0., 0.), 1., .5, 6);\n    scene.tabOctaeder[0] = Octaeder(vec3(0., 5., 3.), 1);\n    \n    return scene;\n}\n\nScene sceneMultiLight(Ray ray) {\n     /* RAPPEL : \n        ACTIVER MULTILIGHT DANS COLOR()\n        LES POSITIONS DE LUMIERES ET LEURS COULEURS SONT GERES DANS LA FONCTION COLOR()\n    */\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbSphere = 2;\n    scene.tabSphere[0] = Sphere(vec3(0.,-2.,1.), 1.,1);\n    scene.tabSphere[1] = Sphere(vec3(0.,2.,1.), 1.,1);\n\n    return scene;\n}\n\nScene sceneOA(Ray ray) {\n    /* RAPPEL : \n        POUR TESTER L'OA IL FAUT COMMENTER LA LIGNE `x = Hit(1000.,vec3(0),-1);`\n        DE LA FONCTION SHADE ET IL FAUT LA DECOMMENTER DE LA FONCTION INTERSECT\n    */\n    Scene scene;\n    scene.plane = Plane(vec3(0.,0.,1.), vec3(0.,0.,0.),0);\n\n    for (int i = 0; i < 10; i++) {\n        scene.tabRay[i] = ray;\n    }\n\n    scene.nbGoursat = 1;\n    scene.tabGoursat[0] = Goursat(vec3(0.,0.,2.5),1);\n\n    return scene;\n}\n\n/**\n * @brief Performs ray intersection with the scene.\n *\n * @param ray The ray to intersect with the scene object.\n * @param x Reference to the Hit structure, stores intersection information.\n * @return True if there is an intersection, false otherwise.\n */\nbool Intersect(Ray ray, inout Hit x) {\n\n    /* RAPPEL : \n    ON DECOMENTE ICI ET ON COMMENTE DANS LA FONCTION SHADE() ET ON PEUT VOIR L'OA \n    NOUBLIEZ DE MODIFER LA FONCTON COLOR POUR L'OA AUSSI\n    */\n    // x = Hit(1000., vec3(0.), -1);\n\n    Scene scene = sceneTransformation(ray);\n    Hit current;\n    bool ret=false;\n    int idR = 0;\n\n    if (IntersectPlane(ray,scene.plane,current) && current.t<x.t) {\n        x = current;\n        ret=true;\n    }\n\n    for (int i = 0; i < scene.nbSphere; i++) {\n        if (IntersectSphere(scene.tabRay[i + idR], scene.tabSphere[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], scene.tabSphere[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbSphere;\n    \n    for (int i = 0; i < scene.nbEllipsoid; i++) {\n        if (IntersectEllipsoid(scene.tabRay[i + idR],scene.tabEllipsoid[i],current) && current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], scene.tabEllipsoid[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbEllipsoid;\n\n    for (int i = 0; i < scene.nbCylinder; i++) {\n        if (IntersectCylinder(scene.tabRay[i + idR], scene.tabCylinder[i],current) && current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabCylinder[i].bottomCenter, scene.tabCylinder[i].topCenter));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbCylinder;\n\n    for (int i = 0; i < scene.nbCapsule; i++) {\n        if (IntersectCapsule(scene.tabRay[i + idR], scene.tabCapsule[i],current)&&current.t<x.t) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabCapsule[i].bottomCenter, scene.tabCapsule[i].topCenter));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbCapsule;\n\n    for(int i = 0; i < scene.nbBox; i++) {\n        if (IntersectBox(scene.tabRay[i+idR], scene.tabBox[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i+idR], scene.tabScale[i+idR]);\n            if (current.t < x.t) {\n                x = current;\n                if(scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i+idR], FindTheCenter(scene.tabBox[i].bottomCorner, scene.tabBox[i].topCorner));\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbBox;\n\n    for (int i = 0; i < scene.nbTorus; i++) {\n        if (IntersectTorus(scene.tabRay[i + idR], scene.tabTorus[i], current)) {\n            if(scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i + idR]);\n            if(current.t < x.t){\n                x = current;\n                if(scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabTorus[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbTorus;\n\n    for (int i = 0; i < scene.nbGoursat; i++) {\n        if (IntersectGoursat(scene.tabRay[i + idR], scene.tabGoursat[i], current)) {\n            if (scene.tabRay[i+idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i+idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabGoursat[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbGoursat;\n\n    for (int i = 0; i < scene.nbOctaeder; i++) {\n        if (IntersectOctaeder(scene.tabRay[i + idR], scene.tabOctaeder[i], current)) {\n            if (scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i+idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabOctaeder[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbOctaeder;\n\n    for (int i = 0; i < scene.nbPipeConnector; i++) {\n        if (IntersectPipeConnector(ray, scene.tabPipeConnector[i], current)) {\n            if (scene.tabRay[i + idR].isHomo)\n                current = Homothetie(current, ray, scene.tabRay[i + idR], scene.tabScale[i + idR]);\n            if (current.t < x.t){\n                x = current;\n                if (scene.tabRay[i + idR].isRot)\n                    x.normal = RotationNormal(x.normal, -scene.tabAngle[i + idR], scene.tabPipeConnector[i].center);\n                ret=true;\n            }\n        }\n    }\n    idR += scene.nbPipeConnector;\n    return ret;\n}\n\n/**\n * @brief Generates a random direction within a hemisphere oriented by a given normal.\n * \n * @param seed An integer seed value to determine the randomness of the direction.\n * @param normal The normal vector representing the orientation of the hemisphere.\n * @return vec3 A random direction vector within the hemisphere.\n */\nvec3 Hemisphere(int seed,vec3 normal) {\n    float a, b;\n    a = fract(sin(176.19 * float(seed)));// Uniform randoms\n    b = fract(sin(164.19 * float(seed)));\n    float u = 2. * 3.1415 * a;// Random angle\n    float v = acos(2. * b - 1.);// Arcosine distribution to compensate for poles\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));// Direction\n    if (dot(d, normal) < 0.) { // Hemishper\n        d = -d; \n    }\n    return d;\n}\n\n/**\n * @brief Computes ambient occlusion at a given point on a surface.\n * \n * @param point The point on the surface for which ambient occlusion is calculated.\n * @param normal The surface normal at the specified point.\n * @param numSamples The number of samples to use for occlusion calculation.\n * @return float The ambient occlusion value in the range [0, 1].\n */\nfloat AmbientOcclusion(vec3 point, vec3 normal, int numSamples) {\n    if (numSamples == 0) {\n        return 1.;\n    }\n\n    float occ = 0.0;\n    \n    for (int i = 0; i < numSamples; i++) {\n        // Generate a random direction in a hemisphere around the normal\n        vec3 hemisphereDir = Hemisphere(i, normal);\n        \n        // Create a ray from the point in the direction of the hemisphereDir\n        Ray occRay = Ray(point + normal * 0.001, hemisphereDir, false, false);\n        \n        // Check for intersections with scene objects\n        Hit occHit;\n        occHit = Hit(.1, vec3(0.), -1);\n        bool hit = Intersect(occRay, occHit);\n        \n        // If no intersection, increase occlusion\n        if (hit && occHit.t < 3. ) {\n            occ += 1.0;\n        }\n    }\n\n    // Normalize occlusion value\n    occ /= float(numSamples) * 4.5;\n    \n    return occ;\n}\n\n/**\n * @brief Calculates the background color based on the viewing direction.\n * \n * @param rd The viewing direction vector.\n * @return vec3 The background color for the given viewing direction.\n */\nvec3 Background(vec3 rd) {\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n/**\n * @brief Creates a camera rotation matrix based on the camera origin and target point.\n * \n * @param ro The camera origin.\n * @param ta The target point that the camera is looking at.\n * @return mat3 The camera rotation matrix.\n */\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n/**\n * @brief Sets up an array of lights with evenly distributed positions and colors.\n *\n * @param l an array of Light structures representing the lights. It is modified in place.\n * @param n The number of lights in one dimension (total number of lights = n * n).\n */\nvoid MultiLight(inout Light l[25], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int index = i * n + j;\n            l[index].lightColor = vec3(1.0 / float(n * n), 1.0 / float(n * n), 1.0 / float(n * n));\n            l[index].lightPos = vec3(1.0 + float(i) / 10.0, 1.0 + float(j) / 10.0, 4.0);\n        }\n    }\n}\n\n/**\n * @brief Apply Phong Model to illuminate the scene and add object Shadows. \n * Can also permit you to see the OA with `if(true)` and `m.ambient` returned\n *\n * @param m Object material.\n * @param n The surface normal at the specified point.\n * @param p The point on the surface.\n * @param camera The camera ray.\n * @return The computed color for the specified point on the surface.\n */\nvec3 Color(Material m, vec3 n, vec3 p, Ray camera) {\n    /*RAPPEL : \n        Eclairage :     \n            UTILISES MULTILIGHT POUR LES OMBRES DEGRADES OU BIEN UTILISES 2 LUMIERES \n            POUR ECLAIRCIR LA SCENE\n\n        Voir OA : N'OUBLIEZ PAS D'AJOUTER `x = Hit(1000., vec3(0), -1);` dans Intersect()\n            et l'enlever de Shade(). \n            Decommenter le `if (true)` et commenter l'autre \n            `if (!Intersect(r, randomHit) ...)` et retourner m.ambient au lieu \n            de finalColor\n    */\n    Scene scene;\n\n    // OMBRE DEGRADE\n    // scene.nbLight = 25;\n    // MultiLight(scene.tabLight, 5);\n\n    // NOMBRE DE LUMIERES INITIALISES AVEC LES COORDOONES DE LUMIERES\n    scene.nbLight = 2;\n    scene.tabLight[0].lightPos = vec3(0,0,4);\n    scene.tabLight[0].lightColor = vec3(1,1,1);\n    scene.tabLight[1].lightPos = vec3(4,4,2);\n    scene.tabLight[1].lightColor = vec3(1,1,1);\n\n    // Rotation de lumiere sur l'axe z\n    Ray rotLight = Rotation(Ray(scene.tabLight[0].lightPos, vec3(0), false, false), vec3(0, 0, iTime), vec3(1, 0, 0));\n    // Pour faire une rotation sur la lumiere decommente cette ligne de code\n    // scene.tabLight[0].lightPos = rotLight.origin; \n    // scene.tabLight[1].lightPos = rotLight.origin; \n\n    Hit randomHit;\n    vec3 finalColor;\n\n    // Je dois calculer la lumiere spectrale et la lumiere diffus           \n    vec3 camDirection = normalize(camera.origin - p); // Direction de la caméra  \n    for (int i = 0; i < scene.nbLight; i++) {\n         vec3 lightDirection = normalize(scene.tabLight[i].lightPos - p);\n         Ray r = Ray(p + n * 0.001, lightDirection, false, false); // le rayon que j'envoie de point d'intersect de mon objet\n\n        randomHit = Hit( length(scene.tabLight[i].lightPos - p), vec3(0.), -1);\n    \n        if (!Intersect(r, randomHit) && randomHit.t >= length(scene.tabLight[i].lightPos - p)) {\n        //if (true) {\n            vec3 reflectDirection = reflect(-lightDirection, n);// Direction de réflexion de lumiere depuis mon objet   \n            \n            float spec = pow(max(dot(camDirection, reflectDirection), 0.0),  m.coefShininess);// coefficient de shininess contrôle la netteté du reflet             \n            vec3 specularColor = m.specular * spec * scene.tabLight[i].lightColor;// Éclairage speculaire             \n            \n            float diff = max(dot(n, lightDirection), 0.0);     \n            vec3 diffuseColor = m.diffuse * diff * scene.tabLight[i].lightColor;// Éclairage diffus\n\n            // Couleur a retourner\n            finalColor += (specularColor * (1. / float(scene.nbLight)) + diffuseColor);// / float(scene.nbLight);\n            // finalColor = m.ambient;\n        } else {\n            finalColor += vec3(0,0,0); \n        }   \n    }\n\n    float ao = AmbientOcclusion(p, n, 64); \n    return finalColor * (1. - ao );\n}\n\n// Rendering\nvec3 Shade(Ray ray) {\n    vec3 resultColor = vec3(0.0);\n\n    for (int reflection = 0; reflection < MAX_REFLECTION; reflection++) {\n        Hit x;\n        x = Hit(1000., vec3(0), -1);\n        bool idx = Intersect(ray, x);\n\n        if (idx) {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.id);\n\n            // return x.normal;//débug normale\n\n            // Si le matériau est un miroir, calculez la couleur réfléchie\n            if (mat.reflexivity > 0.) {\n                vec3 n = x.normal;\n                vec3 reflectDir = reflect(ray.direction, n);\n                ray = Ray(p + n * 0.001, reflectDir, false, false);\n                resultColor += (1.0 - mat.reflexivity) * Color(mat, n, p, ray) + mat.mirrorColor;\n            }\n            else {\n                // Si ce n'est pas un miroir, calculez la couleur normale et terminez la boucle\n                resultColor += Color(mat, x.normal, p, ray);\n                break;\n            }\n        }\n        else {\n            // Si aucune intersection n'est trouvée, retournez la couleur d'arrière-plan\n            resultColor += Background(ray.direction);\n            break;\n        }\n    }\n\n    return resultColor;\n}\n\nvec3 ColorOriginal(Material m,vec3 n) {\n    vec3 light = normalize(vec3(10, 2, 5));\n    float diff = clamp(dot(n, light), 0., 1.);\n    vec3 col = m.diffuse * diff + vec3(.2,.2,.2);\n    return col;\n}\n\nvec3 ShadeOriginal(Ray ray) {\n    // Intersect contains all the geo detection\n    Hit x;\n\n    //DECOMMENTER SI VOUS ACTIVER L'OA SEULEMENT, A REMETTRE PAR LA SUITE\n    x = Hit(1000., vec3(0), -1);\n    bool idx=Intersect(ray,x);\n    \n    if(idx) {\n        vec3 p=Point(ray,x.t);\n        Material mat = Texture(p, x.id);\n        \n        return ColorOriginal(mat, x.normal);\n    }\n    else {\n        return Background(ray.direction);\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy + 2.* fragCoord.xy) / iResolution.y;\n    \n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Ray origin\n    //défini la position de la cam\n    vec3 ro=13. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta=vec3(0., 0., 1.5);\n    mat3 ca=setCamera(ro, ta);\n    \n    // Ray\n    vec3 rd = ca*normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n    \n    // Render\n    vec3 col = Shade(Ray(ro, rd, false, false));\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3yD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3839, 3938, 3965, 3986, 4169], [4171, 4269, 4298, 4298, 4343], [4345, 4459, 4484, 4484, 4579], [4581, 4712, 4736, 4736, 5308], [5310, 5585, 5660, 5679, 5977], [5979, 6071, 6092, 6092, 6158], [6160, 6384, 6439, 6439, 6866], [6868, 7083, 7153, 7153, 7424], [7426, 7650, 7724, 7724, 7895], [7897, 7947, 7966, 7966, 8200], [8202, 8252, 8272, 8272, 8418], [8420, 8545, 8572, 8572, 8627], [8629, 8754, 8807, 8807, 8997], [8999, 9171, 9204, 9204, 11593], [11595, 11767, 11811, 11811, 12099], [12198, 12391, 12445, 12445, 12822], [12824, 13017, 13068, 13068, 13327], [13329, 13539, 13601, 13601, 14077], [14079, 14290, 14352, 14352, 15076], [15078, 15281, 15330, 15330, 15656], [15658, 15864, 15922, 15922, 16502], [16504, 16709, 16765, 16765, 17409], [17411, 17461, 17485, 17485, 17528], [17530, 17530, 17626, 17626, 20076], [20078, 20278, 20325, 20325, 22066], [22068, 22271, 22323, 22383, 24780], [24783, 24996, 25056, 25120, 27286], [27288, 27496, 27555, 27616, 30683], [30685, 30897, 30965, 31026, 34150], [34152, 34306, 34340, 34340, 34403], [34405, 34583, 34619, 34619, 34641], [34643, 35068, 35121, 35164, 35660], [35662, 36077, 36119, 36162, 36949], [36951, 37443, 37488, 37512, 37895], [37897, 38555, 38622, 38682, 39100], [39102, 39313, 39361, 39361, 39398], [39400, 39506, 39537, 39537, 40645], [40647, 40794, 40830, 40830, 42222], [42224, 42324, 42352, 42352, 42779], [42781, 42898, 42927, 42927, 43820], [43822, 43822, 43854, 44007, 44313], [44315, 44315, 44339, 44524, 44774], [44776, 45036, 45074, 45276, 50925], [50927, 51257, 51296, 51296, 51697], [51699, 52066, 52131, 52131, 52941], [52943, 53142, 53168, 53168, 53222], [53224, 53461, 53501, 53501, 53677], [53679, 53948, 53991, 53991, 54305], [54307, 54698, 54750, 55216, 57547], [57549, 57562, 57583, 57583, 58774], [58776, 58776, 58815, 58815, 58974], [58976, 58976, 59005, 59053, 59435], [59437, 59437, 59491, 59588, 60142]], "test": "untested"}
{"id": "dtcyDj", "name": "Shader tutorial fractal", "author": "TheEmeraldChickn", "description": "Done through this video https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["fractal"], "likes": 1, "viewed": 184, "published": 3, "date": "1699641546", "time_retrieved": "2024-07-30T17:22:57.025650", "image_code": "vec3 palette( float t) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263, 0.416, 0.556);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++){ \n    \n        uv = fract(uv * 1.5) - .5;\n    \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n    \n        d = sin(d*8. + iTime * .1)/8.;\n        d = abs(d);\n    \n        d = pow(.01 / d, 1.2);\n    \n        finalColor += col * d;\n        \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 208], [210, 210, 267, 267, 786]], "test": "untested"}
{"id": "ml3yWj", "name": "Approximations of erf(x)", "author": "FordPerfect", "description": "Collection of approximations of erf(x) and their error plots.\n25 functions currently.\n\nPlot is log-log: x is in [1e-7;1e+1], y is in [1e-8;1e-1].\n\nClick at the top to select a function (leftmost=time-reel).\nHold LMB to show plot of the relative error.", "tags": ["function", "error", "erf", "errorfunction", "specialfunction"], "likes": 8, "viewed": 296, "published": 3, "date": "1699637024", "time_retrieved": "2024-07-30T17:22:57.973117", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Several approximations of error function (erf), and their\n// accuracy measurements in float32.\n\n// Functions are tested exhaustively on [-inf,+inf] range of float32 values,\n// using a C++ test program on x86, in IEEE-754 binary32 (-mfpmath=sse),\n// in the default (round-nearest-ties-even) rounding direction, without FMA,\n// using \"glibc 2.31-9\" versions of math functions.\n//\n// NOTE: the results do depend on the floating-point environment,\n// and library math functions, so e.g. the plots here may look different\n// in different GLSL implementations (see e.g. https://www.shadertoy.com/view/dttczs).\n//\n// Both absolute (Eabs) and relative (Erel) errors (maximum, i.e. inf-norm) are\n// reported. NOTE: subnormals (|x|<2^-126) are excluded from *relative*\n// error measurements, since results would probably be less useful\n// otherwise (e.g. erf(2^-149) incurs relative error ~0.114 simply due\n// to roundoff).\n//\n// Several properties (monotonicity, finite on [-inf;+inf], erf(0)=0,\n// erf(±inf)=±1, etc.) are reported (only when violated).\n//\n// Many of these approximations have very wrong asymptotic behaviour\n// for x->inf, actual asymptotic being\n//   1-erf(x)=erfc(x)=exp(-x^2)*(1/(sqrt(pi)*x)+O(x^-3))\n// This is hardly a concern, as float32(erf(x))=1 for x>4 (in default\n// rounding mode). It does matter more if you are approximating\n// erfc (float32(erfc(x))=0 for x>11 in default rounding mode).\n//\n// The plot is log-log: x is in [1e-7;1e+1], y is in [1e-8;1e-1].\n\n// The following have some nice lists of published approximations:\n//   https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n//   Roy M. Howard, 2022, ‘Arbitrarily Accurate Analytical Approximations for the Error Function’, arXiv:2012.04466\n\n// See also https://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\n// for *inverse* erf (useful for converting uniform random into normally distributed).\n// NOTE: analytical inverse also exists for several of the functions here.\n\n//==============================================================================\n// Several approximations from Abramowitz and Stegun.\n\n// f(x)=0   for |x|<2.14e-07\n// |f(x)|=1 for |x|>5.41\n// Eabs<4.7e-4\n// Erel=1 (<1.4e-2 for |x|>1e-3)\nfloat erf_as1(float x)\n{\n    float t=abs(x),y=1.0+t*(0.278393+t*(0.230389+t*(0.000972+t*0.078108))),y2=y*y,y4=y2*y2;\n    return sign(x)*(1.0-1.0/y4);\n}\n\n// f(x)=0   for |x|<1.26e-07\n// |f(x)|=1 for |x|>3.93\n// Eabs<2.19e-5\n// Erel=1 (<8.1e-4 for |x|>1e-3)\nfloat erf_as2(float x)\n{\n    float t=1.0/(1.0+0.47047*abs(x));\n    return sign(x)*(1.0-t*(0.3480242+t*(-0.0958798+t*0.7478556))*exp(-x*x));\n}\n\n// f(x)=0   for |x|<8.45e-7\n// |f(x)|=1 for |x|>3.94\n// Eabs<1.93e-6\n// Erel=1 (9.1e-4 for |x|>1e-3)\nfloat erf_as3(float x)\n{\n    float t=abs(x),y=1.0+t*(0.0705230784+t*(0.0422820123+t*(0.0092705272+t*(0.0001520143+t*(0.0002765672+t*0.0000430638)))));\n    float y2=y*y,y4=y2*y2,y8=y4*y4,y16=y8*y8;\n    return sign(x)*(1.0-1.0/y16);\n}\n\n// Non-monotonic (e.g. around x=-0.152124971).\n// f(x)=0   for |x|<1.81e-7\n// |f(x)|=1 for |x|>3.92\n// Eabs<6.63e-7\n// Erel=1 (<3.8e-4 for |x|>1e-3)\nfloat erf_as4(float x)\n{\n    float t=1.0/(1.0+0.3275911*abs(x));\n    return sign(x)*(1.0-t*(0.254829592+t*(-0.284496736+t*(1.421413741+t*(-1.453152027+t*1.061405429))))*exp(-x*x));\n}\n\n//==============================================================================\n// Several tanh-based approximations.\n// See e.g. Vedder, J. D., 1987, ‘Simple approximations for the error function and its inverse’, American Journal of Physics, vol. 55, pp. 762-763, doi: 10.1119/1.15018\n//\n// NOTE: atanh(erf(x))=C1*x+C3*x^3+C5*x^5+C7*x^7+O(x^9),\n// where\n//   C1=2/sqrt(pi)                                     ≈  1.1283791671\n//   C3=2*(4-pi)/(3*pi^(3/2))                          ≈  0.1027726033\n//   C5=(96-40*pi+3*pi^2)/(15*pi^(5/2))                ≈ -0.00020919464\n//   C7=(5760-3360*pi+532*pi^2-15*pi^3)/(315*pi^(7/2)) ≈ -0.00059012305\n//\n// NOTE: |tanh(x)-erf(x)|<0.082 for all x.\n//\n// See also:\n//   https://math.stackexchange.com/questions/4203484/simple-approximations-for-operatornameerfx\n//   https://math.stackexchange.com/questions/4794193/approximating-for-the-error-function-texterfx-through-an-hyperbolic-tange\n//   https://math.stackexchange.com/questions/4747631/a-better-approximation-of-0-5erfcx\n//\n// Both versions optimized for absolute and relative error are presented.\n\n// |f(x)|=1 for |x|>7.49\n// Eabs<1.9e-2\n// Erel<6.7e-2\nfloat erf_tanh1_abs(float x)\n{\n    // NOTE: truncating the constant to 1.2 yields\n    // slightly larger error (Eabs 0.01891...->0.01947...).\n    return tanh(1.203315375*x);\n}\n\n// |f(x)|=1 for |x|>7.76\n// Eabs<2.8e-2\n// Erel<3.0e-2\nfloat erf_tanh1_rel(float x)\n{\n    return tanh(1.161264952*x);\n}\n\n// NOTE: tanh(A*x+B*x^3) has a reasonably nice analytical inverse.\n// See Vedder's article for details.\n\n// NOTE: A*x+B*x^3 can be written as x*(A+B*x*x),\n// or as (B*x)*(A/B+x*x) which might be better on FMA-capable HW.\n\n// |f(x)|=1 for |x|>3.66\n// Eabs: 2.9e-4\n// Erel: 1.2e-3\nfloat erf_tanh3_abs(float x)\n{\n    return tanh(x*(1.129675826+x*x*0.099792702));\n}\n\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.5e-4\n// Erel<3.6e-4\nfloat erf_tanh3_rel(float x)\n{\n    return tanh(x*(1.128776206+x*x*0.100709669));\n}\n\n// Approximation from current https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.6e-4\n// Erel<4.7e-4\n// NOTE: tiny bit better Eabs than erf_tanh3_vedder_abs (but slightly worse Erel).\nfloat erf_tanh3_wiki(float x)\n{\n    // tanh((2/sqrt(pi))*(x+(11/123)*x^3))\n    return tanh(x*(1.12837923+0.100911958*(x*x)));\n}\n\n// Approximations from Vedder's publication.\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.6e-4\n// Erel<4.7e-4\nfloat erf_tanh3_vedder_abs(float x)\n{\n    // tanh((167/148)*x+(11/109)*x^3)\n    return tanh(x*(1.128378378+0.10091743119*(x*x)));\n}\n\n// |f(x)|=1 for |x|>3.65\n// Eabs<3.9e-4\n// Erel<3.9e-4\nfloat erf_tanh3_vedder_rel(float x)\n{\n    // tanh((993/880)*x+(89/880)*x^3)\n    return tanh(x*(1.12840909+0.101136363*(x*x)));\n}\n\n// Non-monotonic at x=±1.91880643 (the only exceptions in float32).\n// |f(x)|=1 for |x|>3.92\n// Eabs<3.8e-5\n// Erel<2.1e-4\nfloat erf_tanh5_abs(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.128143380+x2*(0.104081184+x2*-0.001786474)));\n}\n\n// Non-monotonic e.g. at x=-1.91638327\n// |f(x)|=1 for |x|>3.88\n// Eabs: 5.8e-5\n// Erel: 5.8e-5\nfloat erf_tanh5_rel(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.128313934+x2*(0.103640769+x2*-0.001615140)));\n}\n\n// NOTE: tanh of 7th order polynomial does not seem to have much better\n// accuracy (Eabs ~3.0e-5). Neither does tanh(a*x*(1+b*x^2)/(1+c*x^2)) (Eabs ~6.4e-5).\n\n//==============================================================================\n// Approximation from\n// Winitzki, S., 2008, ‘A handy approximation for the error function and its inverse’\n// and several related ones.\n\n// Original version. Optimized for asymptotic behaviour.\n// Non-monotonic, e.g. at x=-3.29961586\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.0\n// Eabs: 3.3e-4\n// Erel=1 (<1.2e-2 for |x|>1e-3, <3.6e-4 using expm1)\nfloat erf_winitzki_orig(float x)\n{\n    // sgn(x)*sqrt(1-exp(-x^2*(4/pi+a*x^2)/(1+a*x^2)))\n    float a=0.14;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n// Version optimized for absolute error.\n// Non-monotonic, e.g. at x=-3.30826592\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.01\n// Eabs<1.8e-4 (<1.1e-4 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.6e-4 using expm1)\nfloat erf_winitzki_abs(float x)\n{\n    float a=0.14783;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n// Version optimized for relative error.\n// NOTE: in float32 this only really has better\n// relative error when using expm1.\n// Non-monotonic, e.g. at x=-3.21075726\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>4.01\n// Eabs<1.8e-4 (<1.3e-4 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.3e-4 using expm1)\nfloat erf_winitzki_rel(float x)\n{\n    float a=0.147;\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.27323949+a*x2)/(1.0+a*x2)));\n}\n\n//==============================================================================\n// Couple approximations by Alessandro Soranzo & Emanuela Epure.\n\n// Soranzo, A., & Epure, E., 2012, ‘Simply explicitly invertible approximations to 4 decimals of error function and normal cumulative distribution function’, arXiv:1201.1320v1.\n// Non-monotonic, e.g. at x=-3.622473\n// f(x)=0   for |x|<1.52e-4 (for |x|<2.64e-23 using xepm1)\n// |f(x)|=1 for |x|>4.09\n// Eabs<1.8e-4 (<2.3e-5 using expm1)\n// Erel=1 (<1.2e-2 for |x|>1e-3, <1.3e-4 using expm1)\nfloat erf_soranzo1(float x)\n{\n    // Extension of Winitzki's approximation.\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x;\n    return sign(x)*sqrt(1.0-exp(-x2*(1.2735457+x2*0.1487936)/(1.0+x2*(0.1480931+x2*5.16e-4))));\n}\n\n// Alessandro Soranzo, Emanuela Epure, ‘Very simply explicitly invertible approximations of normal cumulative and normal quantile function’, Applied Mathematical Sciences, Vol. 8, 2014, no. 87, 4323-4341 http://dx.doi.org/10.12988/ams.2014.45338\n// f(x)=0   for |x|<1.13e-07\n// |f(x)|=1 for |x|>3.6\n// Eabs<2.6e-4\n// Erel=1 (<3.0e-3 |x|>1e-3)\nfloat erf_soranzo2(float x)\n{\n    // 2*(2**(-22**(1-41**(sqrt(2)*x/10))))-1\n    // NOTE: this approximation actually kind of\n    // works on (-inf;+inf), but has much worse error\n    // (Eabs ~1.6e-2) for negative arguments, and f(-inf)!=-1,\n    // so we use sgn(x)*f(abs(x)) instead.\n    return sign(x)*(exp2(1.0-pow(22.0,1.0-pow(41.0,(0.14142135623730950488*abs(x)))))-1.0);\n}\n\n//==============================================================================\n// Approximation by R. Menzel, and another related one.\n// NOTE: Vedder's article (in the same journal) references this.\n\n// Menzel, R., 1975, ‘Approximate closed form solution to the error function’, American Journal of Physics, vol. 43, pp. 366-367, doi: 10.1119/1.10085.\n// Menzel, R., 1975, ‘Erratum: Approximate closed form solution to the error function’, American Journal of Physics, vol. 43, p. 923, doi: 10.1119/1.10112.\n// f(x)=0   for |x|<1.5e-4 (for |x|<2.34e-23 using expm1)\n// |f(x)|=1 for |x|>3.69\n// Eabs<6.3e-3\n// Erel=1 (<1.2e-2 for |x|>1e-3, 7.1e-3 using expm1)\nfloat erf_menzel(float x)\n{\n    // sgn(x)*sqrt(1-exp((4/pi)*x^2))\n    return sign(x)*sqrt(1.0-exp(-1.27323954474*x*x));\n}\n\n// R.K. Bhaduri, B.K. Jennings: Note on the error function, Amer. J. Phys. 44 (1976), no. 6, 590 - 592.\n// Non-monotonic, e.g. at x=-1.98238456\n// f(x)=0   for |x|<1.5e-4\n// |f(x)|=1 for |x|>3.93\n// Eabs<7.5e-4\n// Erel=1 (<1.2e-2 for |x|>1e-3)\nfloat erf_bhaduri(float x)\n{\n    // sgn(x)*sqrt(1-exp(-(4/pi)*x^2)*(1+(8*x^4/pi)*(1/3-1/pi)))\n    x=clamp(x,-10.0,+10.0);\n    float x2=x*x,x4=x2*x2;\n    return sign(x)*sqrt(1.0f-exp(-1.27323954474*x2)*(1.0+0.03825689401807295256*x4));\n}\n\n//==============================================================================\n// Approximation from\n// Sandoval-Hernandez, M. A., Vazquez-Leal, H., Filobello-Nino, U. & Hernandez-Martinez, L., 2019, ‘New handy and accurate approximation for the Gaussian integrals with applications to science and engineering’, Open Mathematics, vol. 17, pp. 1774-1793, doi: 10.1515/math-2019-0131.\n\n// Non-monotonic, e.g. at x=-0.994693756\n// f(x)=0   for |x|<3.96e-8\n// |f(x)|=1 for |x|>3.45\n// Eabs<3.4e-5\n// Erel<1.7 (1.1e-4 for |x|>1e-3)\nfloat erf_sandoval_hernandez(float x)\n{\n    // NOTE: Erel for |x|>1e-3 is reduced to 9.0e-5\n    // with sgn(x)*f(abs(x)), but Eabs is ~same.\n    float x2=x*x;\n    return 2.0/(1.0+exp(x*(-2.25675833+x2*(-0.2055452066+x2*(0.0004183892806+x2*(0.00118024611+x2*-0.00012903668))))))-1.0;\n}\n\n//==============================================================================\n// Approximation from\n// Schöpf, H. M. & Supancic, P. H., 2014, ‘On Bürmann’s theorem and its application to problems of linear and nonlinear heat transfer and diffusion: Expanding a function in powers of its derivative’, The Mathematica Journal, vol. 16, pp. 1-44.\n\n// Non-monotonic, e.g. at x=-3.79021573\n// f(x)=0   for |x|<1.7e-4 (for |x|<2.64e-23 using expm1)\n// |f(x)|=1 for |x|>3.89\n// Eabs<3.5e-3\n// Erel=1 (<1.6e-2 for |x|>1e-3, <3.7e-3 using expm1)\nfloat erf_schopf(float x)\n{\n    x=clamp(x,-4.0,+4.0); // Result >1 for e.g. x=10 otherwise.\n    float y=exp(-x*x);\n    return sign(x)*1.1283791671*sqrt(1.0-y)*(0.88622692545+y*(0.155-y*0.042625));\n}\n\n//==============================================================================\n// Approximation from\n// Karagiannidis, G. K.; Lioumpas, A. S. (2007). \"An improved approximation for the Gaussian Q-function\". IEEE Communications Letters. 11 (8): 644–646. doi:10.1109/LCOMM.2007.070470. S2CID 4043576.\n\n// Non-monotonic, e.g. at x=-0.995896518\n// f(x)=0   for |x|<1.0e-3\n// |f(x)|=1 for |x|>3.91\n// Eabs<1.6e-2\n// Erel<14.0\nfloat erf_karagiannidis(float x)\n{\n    // erfc ~ (1-exp(-A*x))*exp(-x^2)/(B*sqrt(pi)*x), A=1.98, B=1.135\n    // NOTE: this approximation produces erfc(0)!=1.\n    float y=abs(x);\n    return y<1e-3? // Undefined at 0, and terrible near it.\n        0.0:\n        sign(x)*(1.0-(1.0-exp(-1.98*y))*exp(-x*x)/(2.01173512*y));\n}\n\n//==============================================================================\n// Approximation from\n// Numerical Recipes in Fortran 77: The Art of Scientific Computing (ISBN 0-521-43064-X), 1992, page 214, Cambridge University Press.\n\n// Non-monotonic, e.g. -0.950222135)=-0.82099247\n// f(x)=0   for |x|<1.19e-7\n// |f(x)|=1 for |x|>3.92\n// Eabs<4.9e-7\n// Erel=1 (<3.5e-4 for |x|>1e-3)\nfloat erf_nrf77(float x)\n{\n    float t=1.0/(1.0+0.5*abs(x));\n    return sign(x)*(1.0-t*exp(\n        -x*x-1.26551223\n        +t*(+1.00002368\n        +t*(+0.37409196\n        +t*(+0.09678418\n        +t*(-0.18628806\n        +t*(+0.27886807\n        +t*(-1.13520398\n        +t*(+1.48851587\n        +t*(-0.82215223\n        +t*(+0.17087277)))))))))));\n}\n\n//==============================================================================\n// What we will be using as a reference implementation.\n// Pretty lame, but it'll serve.\n// Accuracy: ~1.7 ulp.\n// Public domain, but please use something better, like\n// https://git.musl-libc.org/cgit/musl/tree/src/math/erff.c (~0.97 ulp)\n// or something, if you need an actually decent erf(float32).\nfloat erf_ref(float x)\n{\n    // Computed using Sollya.\n    x=clamp(x,-4.0,+4.0);\n    if(abs(x)<0.5)\n    {\n        float x2=x*x;\n        return x+\n              x*(+0.1283791065\n            +x2*(-0.3761229813\n            +x2*(+0.1127839386\n            +x2*(-2.6522522792e-2\n            +x2*(+4.3028555810e-3)))));\n    }\n    else\n    {\n        float y=abs(x);\n        // Weird summation order if for the sake of the monotonicity.\n        if(y<2.0) return sign(x)*(1.0-exp(\n            -y*y\n            +y*(-0.128787279\n            +y*( 0.364905298\n            +y*(-0.105986103\n            +y*( 2.334365435e-2\n            +y*(-3.360495903e-3\n            +y*( 2.324290981e-4\n            +y*  1.251965642e-7))))))\n            +(   4.685858949e-5-y)));\n        else return sign(x)*(1.0-exp(-y\n            +y*(-0.126425505\n            +y*(-0.640088737\n            +y*(-0.101832472\n            +y*(+2.179143392e-2\n            +y*(-3.201373387e-3\n            +y*(+2.837127831e-4\n            +y*(-1.134440117e-5)))))))));\n    }\n}\n\n//==============================================================================\n// Dispatcher.\n\nfloat f(int id,float x)\n{\n    switch(id)\n    {\n        case  0: return erf_ref(x);\n\n        case  1: return erf_as1(x);\n        case  2: return erf_as2(x);\n        case  3: return erf_as3(x);\n        case  4: return erf_as4(x);\n\n        case  5: return erf_tanh1_abs(x);\n        case  6: return erf_tanh1_rel(x);\n        case  7: return erf_tanh3_abs(x);\n        case  8: return erf_tanh3_rel(x);\n        case  9: return erf_tanh3_wiki(x);\n        case 10: return erf_tanh3_vedder_abs(x);\n        case 11: return erf_tanh3_vedder_rel(x);\n        case 12: return erf_tanh5_abs(x);\n        case 13: return erf_tanh5_rel(x);\n\n        case 14: return erf_winitzki_orig(x);\n        case 15: return erf_winitzki_abs(x);\n        case 16: return erf_winitzki_rel(x);\n\n        case 17: return erf_soranzo1(x);\n        case 18: return erf_soranzo2(x);\n\n        case 19: return erf_menzel(x);\n        case 20: return erf_bhaduri(x);\n\n        case 21: return erf_sandoval_hernandez(x);\n\n        case 22: return erf_schopf(x);\n\n        case 23: return erf_karagiannidis(x);\n\n        case 24: return erf_nrf77(x);\n#define NUM_FUNCTIONS 25\n    }\n    return 0.0;\n}\n\nfloat error(int id,float x,int rel)\n{\n    float y=f(id,x),z=erf_ref(x);\n    return rel==0?y-z:(y-z)/z;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 R=iResolution.xy;\n    vec2 xy=fragCoord/R;\n    vec3 col=vec3(0.8,0.75,0.7);\n    int id=int(floor(abs(iMouse.z/R.x)*float(NUM_FUNCTIONS)));\n    int rel=(iMouse.z>=0.0?1:0);\n    if(id==0) id=int(iTime)%(NUM_FUNCTIONS-1)+1;\n    float lx=mix(-7.0,+1.0,xy.x),x=pow(10.0,lx);\n    float ly=mix(-7.0,-1.0,xy.y),y=pow(10.0,ly);\n    float t,p;\n    // Render grid.\n    t=fract(lx);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    t=fract(ly);\n    col=mix(col,vec3(0.0),0.5*exp(-50.0*t*(1.0-t)));\n    p=t;t=fract(pow(10.0,p));\n    col=mix(col,vec3(0.0),0.25*exp(-10.0/p*t*(1.0-t)));\n    col=mix(col,vec3(0.0,1.0,0.0),0.5*exp(-1e4*lx*lx));\n    // Function selector.\n    if(xy.y>1.0-14.0/R.y) col=mix(col,vec3(0.25)+0.5*mod(floor(xy.x*float(NUM_FUNCTIONS)),2.0),0.5);\n    // Render error plot.\n    col=mix(\n        col,\n        vec3(0.25,0.5,0.75),\n        0.75*smoothstep(\n            -0.02*y,\n            +0.02*y,\n            abs(error(id,x,rel))-y));\n    // Print the function id.\n    int font[]=int[](0x01C0,0x4000,0x7B6F,0x4924,0x73E7,0x79E7,0x49ED,0x79CF,0x7BCF,0x4927,0x7BEF,0x79EF);\n    uint ix=uint(int(floor(0.25*(fragCoord.x-16.0))));\n    uint iy=uint(int(floor(0.25*(fragCoord.y-iResolution.y*0.875))));\n    if(ix<3u&&iy<5u) {if((font[uint(id)/10u%10u+2u]>>((4u-iy)*3u+ix)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    if(ix>=4u&&ix<7u&&iy<5u) {if((font[uint(id)%10u+2u]>>((4u-iy)*3u+ix-4u)&1)==1) col=mix(col,vec3(0.125,0.25,0.125),0.75);}\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3yWj.jpg", "access": "api", "license": "public-domain", "functions": [[2187, 2289, 2313, 2313, 2440], [2442, 2545, 2569, 2569, 2686], [2688, 2789, 2813, 2813, 3021], [3023, 3172, 3196, 3196, 3354], [4465, 4520, 4550, 4661, 4695], [4697, 4752, 4782, 4782, 4816], [5040, 5097, 5127, 5127, 5179], [5181, 5236, 5266, 5266, 5318], [5320, 5558, 5589, 5632, 5685], [5687, 5787, 5824, 5862, 5918], [5920, 5975, 6012, 6050, 6103], [6105, 6229, 6259, 6259, 6372], [6374, 6470, 6500, 6500, 6613], [6998, 7248, 7282, 7337, 7471], [7473, 7729, 7762, 7762, 7899], [7901, 8241, 8274, 8274, 8409], [8558, 8952, 8981, 9027, 9171], [9173, 9520, 9549, 9804, 9898], [10103, 10570, 10597, 10635, 10691], [10693, 10937, 10965, 11030, 11173], [11565, 11708, 11747, 11848, 11992], [12350, 12542, 12569, 12569, 12740], [13046, 13167, 13201, 13324, 13486], [13726, 13876, 13902, 13902, 14221], [14223, 14606, 14630, 14660, 15625], [15724, 15724, 15749, 15749, 16872], [16874, 16874, 16911, 16911, 16978]], "test": "untested"}
{"id": "ctccD2", "name": "gyroid 3", "author": "FabriceNeyret2", "description": "gyroid with reflects\nmouse controls camera", "tags": ["raymarching", "sdf", "short"], "likes": 32, "viewed": 389, "published": 3, "date": "1699636906", "time_retrieved": "2024-07-30T17:22:59.105090", "image_code": "// variant of https://shadertoy.com/view/4stfRX\n\nfloat i;                                                      // face id\n\nfloat G( vec3 q ) {\n    vec3 a = abs(q); \n    return max( abs( i = dot(sin(q),cos(q.yzx)) ),            // gyroid.  Is thickness -.1 or -.3 better ?\n                max(a.x,max(a.y,a.z)) -6. );                  // clamped to cube\n}\n\n#define R(a) mat2( sin( a + vec4(0,33,11,0)) )                // rotation\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    vec3  q = iResolution, e = vec3(1e-3,0,0), N,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),                    // ray direction\n          C = iMouse.z > 0. ? 8.*iMouse.xyz/q -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)), // demo mode\n         p = 30./q;                                           // marching point along ray \n    p.xz *= R(C.x), p.yz *= R(C.y),                           // rotation\n    D.xz *= R(C.x), D.yz *= R(C.y);\n    O *= 0.; \n    float d = 1.;\n    for ( O++; O.x > 0. && d > .01 ; O-=.015 )\n        q = p,\n        d = G(q),\n        p += .5*d*D;                                          // step forward = dist to obj\n    \n    O *= i>0. ? vec4(1,.9,.9,1) : vec4(.9,.9,1,1);            // face coloring\n     \n    N = vec3( G(q+e), G(q+e.yxy), G(q+e.yyx) ) - d ;          // normal\n    O.x < 0. ? O = .5*texture(iChannel0, D) :                 // uncomment to display environment \n    O *= length( texture(iChannel0, reflect(D,N/length(N) ) ).rgb ); // reflect of environment map\n    \n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctccD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 142, 142, 354], [431, 431, 467, 467, 1528]], "test": "untested"}
{"id": "cl3cD2", "name": "Circles!!", "author": "arifr123", "description": "Circles", "tags": ["circles"], "likes": 4, "viewed": 135, "published": 3, "date": "1699635287", "time_retrieved": "2024-07-30T17:23:00.097437", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - vec2(0, iResolution.y) / 2.) / iResolution.x;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(4,0,2));\n    \n    vec2 guv = uv;\n    \n    float a = sin(0.5 * iTime);\n    \n    uv.x = mix(1. - uv.x, uv.x, 0.5 * (sign(a) + 1.));\n        \n    uv *= exp(0.01 * iTime);\n    \n    float clamped_a = 1. / min(1. / abs(a), 30.) * sign(a);\n    \n    uv.x = -log(uv.x) / clamped_a;\n    uv.y *= (1. / (1. - 1. / exp(clamped_a))) * exp(a * floor(uv.x));\n    \n    \n    \n    //col = vec3(ceil(uv.x) / 10., 0, 0);\n    \n    uv = 2. * (mod(uv + vec2(0, 0.5), 1.) - 0.5);\n    // [-1, 1] X [-1, 1]\n    \n    \n\n    vec2 abs_uv = abs(uv);\n    if(length(abs_uv) < 1.) {\n        col = 0.5 + 0.5*cos(iTime + guv.xyx + vec3(2,0,4));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3cD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 899]], "test": "untested"}
{"id": "DldyRS", "name": "LineShading-bouncy", "author": "MrNissenDK", "description": "Buitfull line combinations of random start, have hard thinking of ways to make it more performant", "tags": ["lines", "colorful", "random", "bouncy"], "likes": 14, "viewed": 492, "published": 3, "date": "1699633525", "time_retrieved": "2024-07-30T17:23:01.065849", "image_code": "precision lowp float;\n#define numOfPoints 50\n#define seed (653165)\n#define PointDist 0.4\n#define Thickness 0.003\n#define RandomPoints 1000\n\nvec2 posCache[numOfPoints];\nvec2 points[numOfPoints];\nvec3 colors[numOfPoints];\n\nfloat ConvertToFloat(uint n)\n{\n    uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    uint ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    n &= ieeeMantissa;\n    n |= ieeeOne;\n\n    float f = uintBitsToFloat(n);\n    return f - 1.0;\n}\n//pcg_hash https://stackoverflow.com/questions/70985360/how-to-create-a-3d-random-gradient-out-of-3-passed-values-in-a-fragment-shader\n//minor change to add a seed value\nfloat rand(uint i) {\n    uint state = i + (i * 747796405u + 2891336453u) ^ uint(seed);\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return ConvertToFloat((word >> 22u) ^ word);\n}\n\nfloat rand(float i) { return rand(floatBitsToUint(i)); }\n\nvec3 hash23(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    randV += dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724));\n    \n    return fract(randV);\n}\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y));\n    randV *= dot(randV, vec2(8183.0119, src.z));\n    \n    return fract(randV);\n}\nvec2 hash12(float i) {\n    vec2 randV = vec2(rand(i), rand(i + 6939.9375));\n    randV *= dot(randV, vec2(8183.0119,4912.9833));\n    \n    return fract(randV);\n}\nvec2 hash12(int i) {return hash12(intBitsToFloat(i));}\nvec2 pointPos(int pointId, float t) {\n    vec2 pos = posCache[pointId];\n    vec2 aceleration = hash32(vec3(pos, float(seed)));\n    vec2 A = vec2(\n        abs(mod(t * aceleration.x + pos.x, 2.0) - 1.0),\n        abs(mod(t * aceleration.y + pos.y, 2.0) - 1.0)\n    );\n    return A;\n}\n\nfloat dist2segment(vec2 p1, vec2 p2, vec2 p) {\n    vec2 ab = p2 - p1;\n    vec2 ap = p - p1;\n\n    float t = dot(ap, ab) / dot(ab, ab);\n\n    t = clamp(t, 0.0, 1.0);\n\n    vec2 closestPoint = p1 + t * ab;\n\n    return length(p - closestPoint);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float time = iTime * 0.2;\n    vec3 col = vec3(0);\n    vec3 mixColor;\n    float dist, lineDist, t, dist2Pixel;\n    for (int i = numOfPoints - 1; i >= 0; --i) {\n        posCache[i] = hash12(i);\n        points[i] = (pointPos(i, time) - 0.5) * iResolution.xy / iResolution.y;\n        colors[i] = hash23(posCache[i]);\n        dist2Pixel = distance(points[i], uv);\n        if(dist2Pixel > PointDist) continue;\n        \n        for (int j = i + 1; j < numOfPoints; ++j) {\n            dist = distance(points[i], points[j]);\n            if (dist > PointDist) continue;\n            lineDist = dist2segment(points[i], points[j], uv);\n            if (lineDist >= Thickness) continue;\n            \n            vec2 ab = points[j] - points[i];\n            vec2 ap = uv - points[i];\n            t = dot(ap, ab) / dot(ab, ab);\n            mixColor = mix(colors[i], colors[j], clamp(t, 0.0, 1.0));\n            col += mixColor * (PointDist - dist) * 2.0;\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 251, 251, 477], [478, 648, 668, 668, 858], [860, 860, 881, 881, 916], [918, 918, 941, 941, 1139], [1140, 1140, 1163, 1163, 1293], [1294, 1294, 1316, 1316, 1453], [1454, 1454, 1474, 1474, 1508], [1509, 1509, 1546, 1546, 1788], [1790, 1790, 1836, 1836, 2030], [2032, 2032, 2087, 2087, 3145]], "test": "untested"}
{"id": "cltyzs", "name": "Spiral shader", "author": "bigmazi", "description": "Spiral", "tags": ["2d"], "likes": 11, "viewed": 215, "published": 3, "date": "1699614699", "time_retrieved": "2024-07-30T17:23:02.064179", "image_code": "#define pi 3.14159265359\n#define tau 6.28318530718\n\nfloat lerp(float a, float b, float cf)\n{\n    return a + (b - a) * cf;\n}\n\nfloat remap(float x, float a, float b, float A, float B)\n{\n    float cf = (x - a) / (b - a);\n    return lerp(A, B, cf);\n}\n\nfloat circle(float x, float y, float r)\n{\n    return length(vec2(x, y)) - r;\n}\n\nfloat ring(float c, float thickness)\n{\n    float res = 1.0 - abs(c) / thickness;\n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n    float x = v.x;\n    float y = v.y;\n    \n    float sina = sin(a);\n    float cosa = cos(a);\n    \n    float xx = x * cosa - y * sina;\n    float yy = y * cosa + x * sina;\n    \n    return vec2(xx, yy);\n}\n\nfloat spiral(float r0, float dr, float thickness, vec2 uv)\n{    \n    float k = 0.0;\n    \n    for (float r = r0; r >= 0.0; r -= dr)\n    {\n        float ang = atan(uv.y, uv.x);\n        \n        float factor = (r - dr) / r;\n        float rk = remap(ang, -pi, pi, factor, 1.0);\n\n        float c = circle(uv.x, uv.y, r * rk);\n        c = ring(c, thickness);\n        \n        k = max(k, c);\n    }\n    \n    return k;\n}\n\nvec2 disturb(vec2 uv, float periods, float ampl)\n{\n    float a = atan(uv.y, uv.x);\n    a *= periods;\n    \n    return vec2(\n        remap(sin(a), -1.0, 1.0, -ampl, ampl),        \n        remap(cos(a), -1.0, 1.0, -ampl, ampl)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0; uv -= 1.0; uv.x *= iResolution.x / iResolution.y;\n    \n    //uv += disturb(uv, 25.0, 0.025);\n    \n    float bias = mod(iTime * 2.0, tau) - pi;\n    uv = rotate(uv, bias);\n    \n    float dr = 0.15;\n    float thickness = 0.01;\n    float r = 0.8;\n    \n    float k = 0.0;\n    \n    for (float i = 0.0; i < 5.0; ++i)\n    {        \n        float offset = i * -0.02;\n        k = max(k, spiral(r + offset, dr, thickness, uv));\n    }\n        \n    k = smoothstep(0.05, 0.9, k);\n    \n    vec3 clr = vec3(0.7, 0.7, 0.7) * k;\n    fragColor = vec4(clr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 92, 92, 123], [125, 125, 183, 183, 246], [248, 248, 289, 289, 326], [328, 328, 366, 366, 443], [445, 445, 475, 475, 677], [679, 679, 739, 739, 1090], [1092, 1092, 1142, 1142, 1324], [1326, 1326, 1381, 1381, 1981]], "test": "untested"}
{"id": "dltyDS", "name": "Fractal Cosmos", "author": "Ryukijano", "description": " This shader generates a dynamic, fractal-based visual effect that resembles a cosmic nebula. The color palette is inspired by deep space imagery, and the animation evolves over time, creating an immersive and mesmerizing visual experience.", "tags": ["computergraphics"], "likes": 3, "viewed": 153, "published": 3, "date": "1699612331", "time_retrieved": "2024-07-30T17:23:02.987710", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.6) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.5 + iTime * 0.5);\n\n        d = sin(d * 9.0 + iTime) / 9.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.1);\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 211], [213, 213, 268, 268, 774]], "test": "untested"}
{"id": "mlcyWB", "name": "quantum descent", "author": "Dysis", "description": "quantum descent", "tags": ["shader"], "likes": 5, "viewed": 244, "published": 3, "date": "1699583928", "time_retrieved": "2024-07-30T17:23:03.866360", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = 0.0, v = 0.0;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 2.;\n    float time = (iTime-6.0)*50.0;\n    vec3 col = vec3(-0.1);\n    vec3 init = vec3(sin(time * .0032)*.3, .35 - tan(time * .005)*.3, time * 0.0002);\n    for (int r = 0; r < 80; r++) \n    {\n        vec3 p = init + t * vec3(uv, 0.00005);\n        p.z = exp(abs(p.z)) - sin(t);\n        for (int i=0; i < 5; i++) {\n            p = sin(abs(p * 2.04)) / dot(p, p) - 0.7 - t;   \n        }\n        v += pow(dot(p, p), .8) * 0.03;\n        col +=  fract(vec3(v * 0.2+0.4, 12.-t*2., 1.9 + v * 4.) * (v) * 0.00006);\n        t += .02;\n    }\n    fragColor = vec4(clamp(col, .0, 1.0), 1.0);\n}\n", "image_inputs": [{"id": 35202, "src": "https://soundcloud.com/adrian-dulu/01-aphex-twin-xtal?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 714]], "test": "untested"}
{"id": "dt3cDS", "name": "dark realm", "author": "ador", "description": "a dark looking forest", "tags": ["cineshader"], "likes": 0, "viewed": 699, "published": 3, "date": "1699578983", "time_retrieved": "2024-07-30T17:23:04.936499", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates to the range [0, 1]\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Define a dark background color\n    vec3 bgColor = vec3(0.05, 0.05, 0.1);\n\n    // Create a moonlit effect\n    vec3 moonColor = vec3(0.8, 0.8, 0.7);\n    float moonRadius = 0.1;\n    vec2 moonPosition = vec2(0.2, 0.8);\n    float moonIntensity = smoothstep(moonRadius, moonRadius + 0.02, length(uv - moonPosition));\n\n    // Combine background and moonlight\n    vec3 finalColor = mix(bgColor, moonColor, moonIntensity);\n\n    // Add a pseudo-3D effect using noise\n    float depth = 1.0 - 2.0 * fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n    depth = abs(depth);\n\n    // Apply shading based on depth\n    float shading = smoothstep(0.2, 1.0, depth);\n    finalColor *= shading;\n\n    // Apply a vignette effect\n    float vignette = smoothstep(0.8, 1.0, length(uv - 0.5));\n    finalColor *= vignette;\n\n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3cDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 106, 1024]], "test": "untested"}
{"id": "mtcyDS", "name": "nyancats icosahedron jump", "author": "cyperus", "description": "Nyancats jumping over truchet-ways on an spherical  icosahedron.", "tags": ["3d", "sdf", "truchet", "nyancat", "icosahedron", "sphericalprojection"], "likes": 7, "viewed": 196, "published": 3, "date": "1699578511", "time_retrieved": "2024-07-30T17:23:06.064483", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Nyancats Icosahedron Jump\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n//  Code from:\n//   by byt3_m3chanic\n//   - \"Year of Truchets\" #058 https://www.shadertoy.com/view/msVfzR\n//\n//  References:\n//   - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 7.;\nconst float CAM_FLE = 1.3;\nconst float BB_DIST = 4.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BB_DIST;\n\nconst int   MAX_MARCHING_STEPS = 300;\nfloat RAY_STEP_FACTOR3 = 0.5;\nconst float RAY_PRECISION = 0.0001;\n\n// shape transformation parameters\n// icosahedron\nconst int PS_f = 20;\nconst int PS_e_f = 3;\nconst float PS_a0 = 12.;\n\n// fog\nconst bool  FOG_ON = true;\nconst float FOG_DENSITY = 2.5E-3;\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {\n    \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sens of rotation, sig(sr): rotation direction, abs(sr) : number edges\n    vec2 z = vec2(0.);\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p);\n    \n    // icosahedron\n    // projection from n cells to 1 cell. \n    pn = icosa_cells(pn, cell_id, sr);\n    \n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cIcosaPolyArc2disk(z);\n    \n    // set parameters\n    vec2 e = vec2(1.8, 0.18);\n\n    /// r-polygon-distribution\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;     \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    ////fractal level 0: Torus\n    // 3D-space: cartesian3D => cylinder3D transformation\n    au = atan(p.y, p.x);\n    rxy = length(p.xy);\n    // 2D-space: complex plane := radial plane in cylinderc3d coordinates  \n    z = vec2(rxy, p.z);\n    \n    // 2Djulia :realaxis-translation, fraction == 2 => (torus,sphere,2spheres) \n    z = cmul(z,z); z.x -= PS_a0;\n    \n    // distance estimation shape\n    float d = log(length(z));\n    \n    // torus complex plane, torus angle_u, platonic solid cell_id\n    mat.xy = z; mat.z = au, mat.w = cell_id;\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BB_DIST));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos);\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n    p.yz = crot(p.yz,-PI*0.002*time-0.3);\n    p.zx = crot(p.zx,-PI*0.001*time-0.3);\n\treturn p.xyz;\n}\n\n// textures\nfloat grid_uv(in vec2 uv) {\n    // uv grid alpha mask\n    const float sig = 1.; // switch pattern sig in {-1.,+1.}\n    vec2 sw = abs(fract(uv-0.25)-0.5)-0.25;\n    float sdf = sig*min(sw.x,sw.y)*-max(sw.x,sw.y);\n    float pp = fwidth(sdf);\n    return smoothstep(+pp,-pp,sdf);\n}\n            \nvec4 cells(in vec2 uv, in float ps_id ,in int ps_f) {\n    // sectors, uv-grid\n    vec4 C;\n    float sdf = abs(abs(uv.y)-.05)-.05; float px = fwidth(sdf);\n\n    C.a = 1.-smoothstep(px+.01,-px,sdf);\n    C.rgb = h2rgb(ps_id/float(ps_f));      // sector -> col\n    C.rgb *= (0.5+ 0.5 * grid_uv(uv))*0.7; // uv-grid -> value\n    return C;\n}\n\nvec4 ribbon(in float uv_x, in float time) {\n    float sdf = -(2.*pulsecollision(1.,1./3. * uv_x, time, 2./6.)-1.);\n    float px = fwidth(sdf);\n    return vec4( h2rgb(sdf -2./6.)\n               , smoothstep(px+0.1,-px-0.1,sdf+0.2) );\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale);        // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);                   // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time)); // jump, amplitude, frequency\n    vec4 C = vec4(0.);\n    if ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) { // BB rectangle\n        C = texture(iChannel1, vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2));\n        C.rgb = srgb2rgb(C.rgb);\n    }\n    return C;\n}\n\nvec4 truchet(in vec2 uv, float time) {\n    // fork: https://www.shadertoy.com/view/msVfzR by byt3_m3chanic   \n    // coords\n    vec2 dv = fract(uv)-.5,\n         id = floor(uv);\n    \n    // random\n    float rnd = hash21(id);\n    \n    // colors\n    vec4 O; vec4 C;\n    float sdf; float px;\n    \n    // signed distance functions\n    if(rnd<.5) dv.x = -dv.x;\n    \n    vec2  gx = length(dv-.5)<length(dv+.5)\n             ? vec2(dv-.5)\n             : vec2(dv+.5);  \n    \n    float cx = (fract(rnd*77.57+time)>.75)\n             ? min(abs(dv.x),abs(dv.y))\n             : length(gx)-.5;\n    \n    // tiles\n    sdf = abs(cx);  px = fwidth(sdf);\n    C.a = smoothstep(px,-px,sdf-.12);\n    C.rgb = h2rgb(\n                time\n                -uv.x*.075\n                +fract(rnd*147.32+(time*.05))*.35\n                )*.5;\n    O = C;\n    \n    // boder lines\n    sdf = abs(abs(cx)-.12); px = fwidth(sdf);\n    C.a = smoothstep(px+.02,-px,sdf-.02);\n    O = mix(O,vec4(1.), C.a);\n    return O;\n}\n\n//\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // ray\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px ); // distance hit ray surface\n\n        // color\n        // drawing layers\n        // sdf = ... ; px = fwidth(d);\n        // C.a = smoothstep(px+.035,-px,sdf-.125);\n        // C.rgb = ... ;\n        //   near -> far : if(O.a<1.) { O += (1.-O.a) * vec4( C.rgb, 1 ) *C.a;}\n        //   far -> near :  O = mix( O, vec4( C.rgb, 1), C.a );\n        vec3 col_sun = vec3(1.,1.,0.8);\n        vec3 col_sky = 0.5 * vec3(0.7,0.7,1.);\n\n        // background\n        vec4 C = vec4(col_sky,1.);\n        O = C;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // platonic solid sector id\n            float ps_id = mat.w;\n            \n            // uv-coords\n            vec2 mat_uv = 0.5*vec2(mat.z, atan(mat.y,mat.x))/PI;\n            vec2 mat_ny = mat_uv;\n            \n            mat_uv.xy *= vec2(3.*6.,4.); // uv-grid\n            \n            mat_ny += vec2(0.,1./3.);    // nyancat\n            mat_ny *= vec2(6.,1.);\n            \n            // draw texture layers from back to front\n            O = vec4(vec3(0.1,0.1,1.)*0.7,1.);\n            \n            C = cells(mat_uv, ps_id, PS_f);\n            O = mix(O, vec4(C.rgb, 1.), C.a);            \n            \n            C = truchet(mat_uv, 0.05*iTime);\n            O = mix(O, vec4(C.rgb, 1.), C.a);\n            \n            C = nyancat(mat_ny.xy, 3., vec2(0.1,1.), 0.3*iTime); \n            O = mix(O, vec4(C.rgb, 1.), C.a);\n            \n            C = ribbon(mat_uv.x, 0.0125*iTime);\n            O = mix(O, vec4(C.rgb, 1.), C.a);\n\n            // lighting\n            vec3  came_li_o         = transform(vec3(-10.,10.,-10.),iTime); // origine\n            vec3  came_li_dir       = normalize(p - came_li_o);             // direction\n            vec3  came_li_col       = vec3(1.,1.,.5);                       // color\n            float came_li_spec_shi  = 10.;                                  // shininess          \n\n            O.rgb += O.rgb * 0.1 * col_sky;\n            O.rgb += O.rgb * 0.5 * came_li_col * clamp(dot(-came_li_dir, n), 0., 1.);\n            \n            float cosa = pow(clamp(dot(reflect(came_li_dir, n), -rd), 0., 1.), came_li_spec_shi);           \n            vec3 spec_col = vec3(0.);          \n            if (cosa > 0.) {\n              spec_col = came_li_col * cosa;    \n            }\n            O.rgb += 0.4 * spec_col;\n            \n            // fresnel\n            O.rgb += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * col_sky;\n            \n            // fog\n            if(FOG_ON)\n                O.rgb = mix(O.rgb, col_sky, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));    \n        }\n        tot += O.rgb;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    O = vec4(rgb2srgb(tot),1.);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// References:\n//   https://people.maths.ox.ac.uk/trefethen/lightning.html\n//   https://iquilezles.org/\n\n// const\nconst float PI = abs(atan(0.,-1.));\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn); // in[0.,2.]\n    //return (pp+pn)-(pp*pn);// in [0.,1.]\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\n// polynomial barycentric approximation\nvec2 cIcosaPolyArc2disk(vec2 z){\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-1.0000,  0.0081)\n    ,vec2( 0.9973, -0.0741)\n    ,vec2( 0.5000,  0.8660)\n    ,vec2( 0.5000,  0.8660)\n    ,vec2( 0.5000, -0.8660)\n    ,vec2( 0.5000, -0.8660)\n    ,vec2(-0.5628, -0.8266)\n    ,vec2( 0.7134,  0.7008)\n    ,vec2(-0.6770,  0.7360)\n    ,vec2( 0.5660, -0.8244)\n    ,vec2( 0.4380, -0.8990)\n    ,vec2( 0.4776,  0.8786)\n    ,vec2(-1.0000,  0.0000)\n    ,vec2(-1.0000, -0.0000)\n    ,vec2(-0.9975, -0.0702)\n    ,vec2( 0.5013,  0.8653)\n    ,vec2( 0.4987, -0.8668)\n    ,vec2(-1.0000, -0.0015));\n\n    const vec2[] rw = vec2[NUM_j] \n    (vec2( 0.1913, -0.0   )\n    ,vec2( 0.0675, -0.5245)\n    ,vec2( 0.0000,  0.0000)\n    ,vec2(-0.0217,  0.0173)\n    ,vec2( 0.0000,  0.0000)\n    ,vec2( 0.0227, -0.0136)\n    ,vec2(-0.1778,  0.1022)\n    ,vec2( 0.4571, -0.0498)\n    ,vec2( 0.1298,  0.1710)\n    ,vec2(-0.1199, -0.3334)\n    ,vec2(-0.1620,  0.2846)\n    ,vec2(-0.1091,  0.1608)\n    ,vec2(-0.0000,  0.0000)\n    ,vec2( 0.0220,  0.0049)\n    ,vec2(-0.2238,  0.0539)\n    ,vec2( 0.1257,  0.0310)\n    ,vec2(-0.1355, -0.0377)\n    ,vec2(-0.0667,  0.1333));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.3057,  0.0242)\n    ,vec2( 0.1872, -0.0101)\n    ,vec2( 0.1691,  0.2929)\n    ,vec2( 0.1692,  0.2924)\n    ,vec2( 0.1691, -0.2929)\n    ,vec2( 0.1686, -0.2927)\n    ,vec2(-0.1024, -0.1571)\n    ,vec2( 0.1839,  0.1273)\n    ,vec2(-0.1198,  0.1468)\n    ,vec2( 0.1795, -0.1922)\n    ,vec2( 0.0805, -0.2533)\n    ,vec2( 0.1099,  0.2669)\n    ,vec2(-0.3383,  0.0   )\n    ,vec2(-0.3378, -0.0004)\n    ,vec2(-0.2597, -0.0569)\n    ,vec2( 0.1715,  0.2728)\n    ,vec2( 0.1505, -0.2850)\n    ,vec2(-0.3221, -0.0121));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n/// 3D transformations\nmat3 rot3(in vec3 v, in float a) {// rotation from axis angle \n float c = cos(a);\n float s = sin(a);\t\n return mat3\n (c + (1.0 - c) * v.x * v.x,               (1.0 - c) * v.x * v.y - s * v.z,     (1.0 - c) * v.x * v.z + s * v.y,\n      (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y,               (1.0 - c) * v.y * v.z - s * v.x,\n      (1.0 - c) * v.x * v.z - s * v.y,     (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 icosa_cells(in vec3 p, out float cell_id, out float sr){\n\t// icosahedron\n\tconst float phi = (0.5+sqrt(1.25));\n\t// cell-wall-face-normals defined by 2 edge points and the origine.\n\t//----------------------------------------\n    bool ZpYp_ZpYn = dot(vec3( 1., 0., 0.) ,p)>=0.; // yz-rectangle edge\n    \n\tbool XpZp_ZpYp = dot( cross(vec3(+phi,0,+1),vec3(0,+1,+phi)) ,p)>=0.;\n\tbool XpZp_ZpYn = dot( cross(vec3(+phi,0,+1),vec3(0,-1,+phi)) ,p)>=0.;\n    \n\tbool XnZp_ZpYp = dot( cross(vec3(-phi,0,+1),vec3(0,+1,+phi)) ,p)>=0.;\n    bool XnZp_ZpYn = dot( cross(vec3(-phi,0,+1),vec3(0,-1,+phi)) ,p)>=0.;\n    //----------------------------------------\n    bool XpZp_XpZn = dot(vec3( 0., 1., 0.) ,p)>=0.; // zy-rectangle edge\n    \n\tbool YpXp_XpZp = dot( cross(vec3(+1,+phi,0),vec3(+phi,0,+1)) ,p)>=0.;\n\tbool YpXp_XpZn = dot( cross(vec3(+1,+phi,0),vec3(+phi,0,-1)) ,p)>=0.;\n    \n\tbool YnXp_XpZp = dot( cross(vec3(+1,-phi,0),vec3(+phi,0,+1)) ,p)>=0.;\n    bool YnXp_XpZn = dot( cross(vec3(+1,-phi,0),vec3(+phi,0,-1)) ,p)>=0.;\n\t//----------------------------------------\n\tbool YpXp_YpXn = dot(vec3( 0., 0., 1.) ,p)>=0.; // xy-rectangle edge\n    \n\tbool ZpYp_YpXp = dot( cross(vec3(0,+1,+phi),vec3(+1,+phi,0)) ,p)>=0.;\n\tbool ZpYp_YpXn = dot( cross(vec3(0,+1,+phi),vec3(-1,+phi,0)) ,p)>=0.;\n    \n\tbool ZnYp_YpXp = dot( cross(vec3(0,+1,-phi),vec3(+1,+phi,0)) ,p)>=0.;\n    bool ZnYp_YpXn = dot( cross(vec3(0,+1,-phi),vec3(-1,+phi,0)) ,p)>=0.;\n\t//----------------------------------------   \n    \n\t// cells\n    //const float a = atan(1.5-sqrt(1.25)); // angle face center -> edge center\n    const float a = atan(0.5*(3.-sqrt(5.)));\n    vec2 ei_yy = vec2(cos(a),sin(a));\n    const float b = PI/3.; // 60°\n    vec2 ei_zz = vec2(cos(b),sin(b));\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n    if     ( ZpYp_ZpYn && !XpZp_ZpYn   &&  XpZp_ZpYp) { cell_id = 0.;\n        //p.xyz = p.xyz;\n        #if 0\n        a_y = -a+PI;\n        #else\n        p.zx = -p.zx;\n        a_y = -a;\n        #endif\n\t}\n\telse if(!ZpYp_ZpYn &&  XpZp_ZpYn   && !XpZp_ZpYp) { cell_id = 1.; /*opposite side*/\t\n        //p.xyz = p.xyz;\n\t\ta_y = -a;\n\t}\n\t//\n\telse if(!ZpYp_ZpYn &&  XnZp_ZpYn   && !XnZp_ZpYp) { cell_id = 2.;\n        //p.xyz = p.xyz;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;\n\t}\n\telse if( ZpYp_ZpYn && !XnZp_ZpYn   &&  XnZp_ZpYp) { cell_id = 3.; /*opposite side*/\n        //p.xyz = p.xyz;\n\t\ta_y = +a;\n\t\ta_z = -b;\n\t}\n\t// ---------------------------------------------------------------\n    else if( YpXp_YpXn && !ZpYp_YpXn   &&  ZpYp_YpXp) { cell_id = 4.;\n        p.xyz = p.zxy;\n        a_y = -a+PI;\n    }\n    else if(!YpXp_YpXn &&  ZpYp_YpXn   && !ZpYp_YpXp) { cell_id = 5.; /*opposite side*/\n        p.xyz = p.zxy;\n\t\ta_y = -a;\n    }\n    //\n    else if(!YpXp_YpXn && !ZnYp_YpXp   &&  ZnYp_YpXn) { cell_id = 6.;\n        p.xyz = p.zxy;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;        \n    }\n    else if( YpXp_YpXn &&  ZnYp_YpXp   && !ZnYp_YpXn) { cell_id = 7.; /*opposite side*/\n        p.xyz = p.zxy;\n\t\ta_y = +a;\n\t\ta_z = -b;\n    }\n\t// ---------------------------------------------------------------\n    else if( XpZp_XpZn && !YpXp_XpZn   &&  YpXp_XpZp) { cell_id = 8.;\n        p.xyz = p.yzx;\n        a_y = -a+PI;\n    }\n    else if(!XpZp_XpZn &&  YpXp_XpZn   && !YpXp_XpZp) { cell_id = 9.; /*opposite side*/\n        p.xyz = p.yzx;\n\t\ta_y = -a;\n    }\n    //\n    else if(!XpZp_XpZn && !YnXp_XpZp   &&  YnXp_XpZn) { cell_id = 10.;\n        p.xyz = p.yzx;\n\t\ta_y = +a-PI;\n\t\ta_z = +b;\n    }\n    else if( XpZp_XpZn &&  YnXp_XpZp   && !YnXp_XpZn) { cell_id = 11.; /*opposite side*/\n        p.xyz = p.yzx;\n\t\ta_y = +a;\n\t\ta_z = -b;\n    }\n\t// ---------------------------------------------------------------    \n    else if(!XpZp_ZpYp && !YpXp_XpZp   && !ZpYp_YpXp) { cell_id = 12.;\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if( XpZp_ZpYp &&  YpXp_XpZp   &&  ZpYp_YpXp) { cell_id = 13.; /*opposite side*/\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    } \n    // ---------------------------------------------------------------\n    else if( XnZp_ZpYp &&  ZpYp_YpXn   &&  (YnXp_XpZn)) { cell_id = 14.;\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if(!XnZp_ZpYp && !ZpYp_YpXn   && !(YnXp_XpZn)) { cell_id = 15.; /*opposite side*/\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // ---------------------------------------------------------------\n    else if(!XnZp_ZpYn && !(ZnYp_YpXp) && !(YpXp_XpZn)) { cell_id = 16.;\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if( XnZp_ZpYn &&  (ZnYp_YpXp) &&  (YpXp_XpZn)) { cell_id = 17.; /*opposite side*/\n        p.xy = -p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), 2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // ---------------------------------------------------------------\n    else if( XpZp_ZpYn &&  (ZnYp_YpXn) &&  YnXp_XpZp) { cell_id = 18.;\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n        a_y = -a+PI;\n    }\n    else if(!XpZp_ZpYn && !(ZnYp_YpXn) && !YnXp_XpZp) { cell_id = 19.; /*opposite side*/\n        //p.xy = p.xy;\n        mat3 m3 = rot3(normalize(vec3(phi,0.,1.)), -2.*PI/5.); p = p*m3;\n\t\ta_y = -a;\n    }\n    // --------------------------------------------------------------- \n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 3.;  \n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a)\n{   \n    /// r-polygon-distribution\n    float r = length(z); z = z/r; // TEST: (ERROR) division by zero\n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    //    float e2 = e.x + d0 * 2. * smoothstep(-1., 1., -sh_a);\n    return dist(r, e2) * z;\n}\n\nvec3 sp(vec3 zsr)\n{\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr)\n{\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcyDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1057, 1057, 1079, 1099, 2466], [2468, 2468, 2522, 2522, 3355], [3357, 3357, 3402, 3402, 3564], [3566, 3566, 3608, 3634, 3883], [3885, 3897, 3924, 3950, 4173], [4187, 4187, 4240, 4264, 4521], [4523, 4523, 4566, 4566, 4757], [4759, 4759, 4815, 4815, 5326], [5328, 5328, 5366, 5451, 6307], [6309, 6312, 6359, 6381, 9924]], "test": "untested"}
{"id": "DlcyRl", "name": "Rainy Day by Shader Sorcerer", "author": "TimPietrusky", "description": "Trying out the Shader Sorcerer https://chat.openai.com/g/g-6K1Oa7NEx-shader-sorcerer to create a \"Rainy Day\" shader, as it's raining outside today. \n\nThe full chat can be found here: https://chat.openai.com/share/9aa6063b-dd8c-44bf-aae5-4c60e42d0648", "tags": ["noise", "rain", "openai", "gpt", "aigenerated", "gpt4", "agpl", "shadersorcerer"], "likes": 3, "viewed": 128, "published": 3, "date": "1699563460", "time_retrieved": "2024-07-30T17:23:07.052841", "image_code": "/**\n * Rainy Day, generated with Shader Sorcerer by Tim Pietrusky\n * \n * License: AGPL-v3\n * \n * \"Shader Sorcerer\" is an AI Assistant based on OpenAI GPT-Builder using GPT-4-turbo,\n * which you can use via https://chat.openai.com/g/g-6K1Oa7NEx-shader-sorcerer\n * \n * I created the AI Assistant to help out with GLSL. \n * This is the first shader created by the AI Assistant, you can find the whole chat\n * via https://chat.openai.com/share/9aa6063b-dd8c-44bf-aae5-4c60e42d0648\n * The chat shows my whole process of interacting with the Shader Sorcerer to get the final \n * result. I only changed minor things in the code myself, almost everything was\n * generated by AI. \n *\n * It's important to create the shader step by step, adding only one feature at a time.\n * Otherwise the AI Assistant will be confused and produce bad results. \n *\n * What I also saw is, that some things are still wrong related to the knowledge of GPT,\n * so I have to add more information (like the correct implementation of cnoise)\n * into the assistant, so that it can just use the function when needed \n * and not come up with functions itself. \n */\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\n// Classic Perlin Noise\nfloat cnoise(vec2 P){\n\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\tPi = mod(Pi, 289.0);\n\tvec4 ix = Pi.xzxz;\n\tvec4 iy = Pi.yyww;\n\tvec4 fx = Pf.xzxz;\n\tvec4 fy = Pf.yyww;\n\n\tvec4 i = permute(permute(ix) + iy);\n\n\tvec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;\n\tvec4 gy = abs(gx) - 0.5;\n\tvec4 tx = floor(gx + 0.5);\n\tgx = gx - tx;\n\n\tvec2 g00 = vec2(gx.x,gy.x);\n\tvec2 g10 = vec2(gx.y,gy.y);\n\tvec2 g01 = vec2(gx.z,gy.z);\n\tvec2 g11 = vec2(gx.w,gy.w);\n\n\tvec4 norm = 1.79284291400159 - 0.85373472095314 *\n\tvec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n\tg00 *= norm.x;\n\tg01 *= norm.y;\n\tg10 *= norm.z;\n\tg11 *= norm.w;\n\n\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\n\tvec2 fade_xy = fade(Pf.xy);\n\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\treturn 2.3 * n_xy;\n}\n\n\n// Function to calculate the Signed Distance Field for a circle\nfloat circleSDF(vec2 pos, vec2 center, float radius) {\n    return length(pos - center) - radius;\n}\n\n// Pseudo-random number generator\nfloat rand(vec2 co, float seed){\n    return fract(sin(dot(co.xy ,vec2(12.9898 + seed, 78.233 + seed))) * 43758.5453);\n}\n\n// Function to create a lightning effect\nfloat lightning(vec2 uv, float time) {\n    // Use a random factor based on the time to trigger lightning\n    float trigger = step(0.95, rand(vec2(floor(time * 10.0), 0.0), 0.0));\n    // Flash intensity based on a quick sin function to simulate lightning's abrupt onset and fade\n    float intensity = sin(time * 100.0) * trigger;\n    // Clamp the intensity between 0.0 and 1.0\n    return clamp(intensity, 0.0, 1.0);\n}\n\n// Function to calculate the Signed Distance Field for an elongated circle (ellipse)\nfloat elongatedCircleSDF(vec2 pos, vec2 center, vec2 radii) {\n    return length((pos - center) / radii) - 1.0;\n}\n\n// Function to draw rolling hills\nvec3 drawRollingHills(vec2 uv) {\n    float hill1 = sin(uv.x * 3.0 + iTime * 0.2) * 0.25 + 0.25;\n    float hill2 = sin(uv.x * 4.0 + iTime * 0.15 + 1.0) * 0.2 + 0.3;\n    float hill3 = sin(uv.x * 2.0 + iTime * 0.1 - 2.0) * 0.3 + 0.35;\n\n    float hillMask1 = smoothstep(hill1 - 0.02, hill1, -uv.y);\n    float hillMask2 = smoothstep(hill2 - 0.02, hill2, -uv.y);\n    float hillMask3 = smoothstep(hill3 - 0.02, hill3, -uv.y);\n\n    vec3 color = vec3(0.0);\n    vec3 hillColor1 = vec3(0.2, 0.8, 0.2);\n    vec3 hillColor2 = vec3(0.1, 0.7, 0.1);\n    vec3 hillColor3 = vec3(0.0, 0.6, 0.0);\n\n    color = mix(color, hillColor1, hillMask1);\n    color = mix(color, hillColor2, hillMask2);\n    color = mix(color, hillColor3, hillMask3);\n\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalizing the UV coordinates so that (0,0) is the center of the screen\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Wind effect\n    float windStrength = sin(iTime * 0.5) * 0.5; // Oscillating wind strength over time\n    float windAngle = windStrength * 2.2; // Wind angle, you can adjust the multiplier for more or less slant\n    vec2 windDirection = vec2(windStrength, 0.0); // Wind direction (horizontal)\n\n    // Cloud definition\n    vec2 mainCircleCenter = vec2(0.0, 0.2);\n    float mainCircleRadius = 0.2;\n    vec2 leftCircleCenter = mainCircleCenter + vec2(-0.2, -0.05);\n    float leftCircleRadius = 0.15;\n    vec2 rightCircleCenter = mainCircleCenter + vec2(0.2, -0.065);\n    float rightCircleRadius = 0.12;\n    \n    // Calculate the noise value\n    float noiseScale = 0.5;\n    float noiseStrength = 0.2; // Control the amount of noise distortion\n    float noise = cnoise((uv + windDirection) * noiseScale) * noiseStrength;\n   \n    // Calculate the SDF for each cloud part and add noise\n    float mainDist = circleSDF(uv + windDirection, mainCircleCenter, mainCircleRadius);\n    float leftDist = circleSDF(uv + windDirection, leftCircleCenter, leftCircleRadius);\n    float rightDist = circleSDF(uv + windDirection, rightCircleCenter, rightCircleRadius);\n    float cloud = min(min(mainDist, leftDist), rightDist) + noise;\n    float cloudAlpha = 1.0 - smoothstep(0.0, 0.01, cloud);\n    \n    // Raindrops definition\n    float raindropRadius = 0.003;\n    float raindropSpeed = 0.5;\n    vec3 raindropColor = vec3(0.0, 0.0, 1.0);\n    float raindropAlpha = 0.0;\n    vec2 raindropCenter;\n    float raindropDist;\n    float closestRaindropDist = 1.0;\n    \n    float seed = iTime < 0.1 ? iTime : 0.1;\n\n    // Create multiple raindrops with random speeds and streaks\n    for (int i = 0; i < 60; ++i) {\n        vec2 n = vec2(float(i), seed);\n        float randomX = rand(n, seed) * 0.6 - 0.3 - windDirection.x; // Random X within the width of the cloud\n        float randomY = rand(n + vec2(1.0), seed) * mainCircleRadius; // Random Y within the cloud\n        float randomSpeed = raindropSpeed + rand(n + vec2(3.0), seed) * 0.1; // Random speed variation\n        float timeOffset = rand(n + vec2(2.0), seed); // Random time offset for each raindrop\n\n        // Use mod to loop the falling effect, reset to just below the cloud\n        float raindropOffset = mod(iTime * randomSpeed + timeOffset, 1.0);\n\n        // The y-coordinate is adjusted to start from within the main cloud circle\n        vec2 streakCenter = vec2(randomX, mainCircleCenter.y - randomY - raindropOffset);\n        \n        // Apply the wind effect by skewing the falling direction\n        float windOffset = raindropOffset * windAngle;\n        vec2 windEffect = vec2(windOffset, -raindropOffset);\n        \n        // Apply wind effect to the streak center\n        streakCenter += windEffect;\n        \n        // Make the raindrop elongated to create a streak\n        float streakLength = 0.02; // The length of the rain streak\n        vec2 raindropRadii = vec2(raindropRadius, raindropRadius + streakLength * randomSpeed);\n        \n        // Calculate the distance for the elongated circle SDF\n        raindropDist = elongatedCircleSDF(uv, streakCenter, raindropRadii);\n\n        // Raindrop gradient color from top (light blue) to bottom (darker blue)\n        vec3 topColor = vec3(0.5, 0.5, 1.0); // Light blue\n        vec3 bottomColor = vec3(0.0, 0.0, 0.5); // Darker blue\n        \n        // Calculate the relative position along the streak\n        float streakPosition = (uv.y - (streakCenter.y - raindropRadii.y)) / (2.0 * raindropRadii.y);\n        streakPosition = clamp(streakPosition, 0.0, 1.0); // Clamp the position to be between 0 and 1\n\n        // Interpolate the color along the streak\n        vec3 streakColor = mix(bottomColor, topColor, streakPosition);\n        \n        // Randomly decide if this raindrop will have a highlight color\n        float highlightChance = rand(n + vec2(4.0), seed);\n        bool isHighlight = highlightChance > 0.55; // 5% chance of being a highlight\n\n        // Define highlight colors\n        vec3 highlightColor1 = vec3(0.25, 0.25, 1.0);\n        vec3 highlightColor2 = vec3(0.75, 0.5, 1.0);\n        vec3 highlightColor3 = vec3(0.5, 0.75, 1.0);\n\n        // Choose the highlight color based on another random factor\n        int highlightColorIndex = int(mod(rand(n + vec2(5.0), seed) * 3.0, 3.0));\n        vec3 chosenHighlightColor = (highlightColorIndex == 0) ? highlightColor1 :\n                                    (highlightColorIndex == 1) ? highlightColor2 : highlightColor3;\n\n        // Use the highlight color if this raindrop is chosen to be highlighted\n        if (isHighlight) {\n            streakColor = mix(bottomColor, chosenHighlightColor, streakPosition);\n        }\n\n        // Raindrop is not visible when inside the cloud\n        if (streakCenter.y < mainCircleCenter.y - mainCircleRadius) {\n            // Determine the alpha for the closest raindrop (smallest distance)\n            if (raindropDist < closestRaindropDist) {\n                closestRaindropDist = raindropDist;\n                raindropAlpha = 1.0 - smoothstep(0.0, 0.005, raindropDist);\n                raindropColor = streakColor; // Use the gradient color for the raindrop\n            }\n        }\n    }\n\n    // Background color (darker grey)\n    vec3 backgroundColor = vec3(0.2);\n\n    // Determine final color\n    vec3 color = backgroundColor + (drawRollingHills(uv) * .5);\n\n\n    // If we are inside the cloud, render it as white\n    if (cloud < 0.0) {\n        color = vec3(1.0);\n    } else {\n        // If we are not inside the cloud, mix the background with the raindrop\n        // This assumes the cloud is the topmost layer\n        color = mix(color, raindropColor, raindropAlpha);\n        color = mix(color, vec3(1.0), cloudAlpha); // Mix cloud with the rest\n    }\n    \n    // Calculate the lightning effect\n    float lightIntensity = lightning(uv, iTime);\n    \n    // Apply the lightning effect by increasing the brightness\n    color += lightIntensity * vec3(1.0, 1.0, 1.0);\n    \n    // Fog effect\n    float fogIntensity = smoothstep(0.0, 0.2, uv.y - .01);\n    vec3 fogColor = vec3(0.8); // Light gray color for the fog\n    color = mix(color, fogColor, fogIntensity * (1.0 + cloudAlpha)); // Blend the fog based on cloud alpha\n\n    \n    // Setting the final color\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcyRl.jpg", "access": "api", "license": "agpl-3.0", "functions": [[0, 1129, 1148, 1148, 1184], [1185, 1185, 1206, 1206, 1243], [1245, 1269, 1290, 1290, 2275], [2278, 2342, 2396, 2396, 2440], [2442, 2476, 2508, 2508, 2595], [2597, 2638, 2676, 2742, 3054], [3056, 3141, 3202, 3202, 3253], [3255, 3289, 3321, 3321, 4028], [4031, 4031, 4086, 4166, 10528]], "test": "untested"}
{"id": "dttcRs", "name": "convoluted game of life", "author": "ThePlaneGuy45", "description": "floating-point game of life which takes a specialized gaussian distribution to calculate next frame instead of a few rules.\n\nhttps://www.desmos.com/calculator/6hy2n5w4zn", "tags": ["convolution", "gaussian", "gameoflife"], "likes": 2, "viewed": 138, "published": 3, "date": "1699562353", "time_retrieved": "2024-07-30T17:23:07.872649", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.xy != vec2(0)){\n        fragCoord*=iMouse.x/iResolution.x;\n    }\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rrr, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 convolveTexel(sampler2D tex, ivec2 texel, mat3x3 matrix) {\n    ivec2 ts=textureSize(tex,0)-1;\n    vec4 r;\n    for(int x=-1;x<=1;x++){\n    for(int y=-1;y<=1;y++){\n   \n        r+=texelFetch(tex,clamp(texel+ivec2(x,y),ivec2(0),ts),0)*matrix[1-y][1-x];\n    \n    }}\n    return r;\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define PI 3.141592653589793238462643383279\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float bestPoint = 2.18;\n    const float spread0 = 0.58857;\n    const float spread1 = 0.196204;\n    \n    if(iFrame%1==0){\n    \n        vec4 neighbors = convolveTexel(iChannel0, ivec2(fragCoord), mat3x3(\n            1,1,1,\n            1,0,1,\n            1,1,1\n        ));\n        vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0).xyzw;\n    \n        vec4 a = spread0/(current+spread1);\n        vec4 b = a*neighbors - a*bestPoint + a*current/2.0;\n        b*=b;\n        vec4 c = exp(-PI*b);\n    \n        fragColor = c;\n        \n    } else {\n    \n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    }\n    \n    if(iFrame==0){\n        vec3 hash = hash33(vec3(fragCoord, iFrame));\n        fragColor = vec4(hash, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 214]], "test": "untested"}
{"id": "dttczs", "name": "GLSL functions for x->0", "author": "FordPerfect", "description": "Click at the bottom to select a function (leftmost=time-reel).\n\nOne might hope that e.g. sin(x)/x->1 as x->0. GLSL implementation might have other ideas.\n\nPlot is log-scale in x, [1e-8;1], linear in y [-4;+4].", "tags": ["glsl", "ieee754"], "likes": 6, "viewed": 174, "published": 3, "date": "1699560055", "time_retrieved": "2024-07-30T17:23:08.641593", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Illustration/survey of behaviour of various GLSL functions as x->0.\n//\n// E.g. sin(x)/x->1 as x->0, but does that hold numerically for\n// your GLSL implementation?\n\nfloat f(int id,float x)\n{\n    switch(id)\n    {\n        case  0: return 0.0;\n        case  1: return sin(x)/x;\n        case  2: return asin(x)/x;\n        case  3: return (exp(x)-1.0)/x;\n        case  4: return log(1.0+x)/x;\n        case  5: return tan(x)/x;\n        case  6: return atan(x)/x;\n        case  7: return sinh(x)/x;\n        case  8: return asinh(x)/x;\n        case  9: return tanh(x)/x;\n        case 10: return atanh(x)/x;\n        case 11: return sqrt(x)*sqrt(x)/x;\n        case 12: return inversesqrt(x)*inversesqrt(x)*x;\n        case 13: return sqrt(x)*inversesqrt(x);\n        case 14: return (1.0/log(2.0))*(exp2(x)-1.0)/x;\n        case 15: return log(2.0)*log2(1.0+x)/x;\n        case 16: return (1.0/3.0)*smoothstep(0.0,1.0,x)/(x*x);\n#define N 17\n    }\n    return 0.0;\n}\n\nvec3 palette(int id) {return 0.5+0.5*cos(float(id)+vec3(0,2,4));}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    int id=int(abs(iMouse.z/iResolution.x)*float(N));\n    if(id==0) id=int(iTime)%(N-1)+1;\n    vec2 xy=fragCoord/iResolution.xy;\n    float lx=mix(-8.0,0.0,xy.x),x=pow(10.0,lx);\n    float y=mix(-4.0,+4.0,xy.y);\n    float d=f(id,x)-y;\n    vec3 col=vec3(0.125)+0.5*palette(id)*exp(-1e3*d*d);\n    if(xy.y<0.125) col=mix(col,palette(int(xy.x*float(N))),0.5);\n    float s,t=fract(y);\n    col+=0.5*exp(-128.0*t*(1.0-t));\n    t=fract(lx);\n    col+=0.5*exp(-256.0*t*(1.0-t));\n    s=t;t=fract(pow(10.0,s));\n    col+=0.25*exp(-16.0*t*(1.0-t));\n    col+=0.25*exp(-512.0*y*y);\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttczs.jpg", "access": "api", "license": "public-domain", "functions": [[236, 236, 261, 261, 1021], [1023, 1023, 1045, 1045, 1088], [1090, 1090, 1144, 1144, 1739]], "test": "untested"}
{"id": "dtdcRs", "name": "Transparence Ray tracing", "author": "smirboulack", "description": "Transparence en ray tracing + 3 sources lumineuses", "tags": ["refraction"], "likes": 0, "viewed": 116, "published": 3, "date": "1699559181", "time_retrieved": "2024-07-30T17:23:09.585070", "image_code": "/*\n\nRéalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590 UCBL LYON 1 - 2023\n\nPyramide réalisé en suivant les instructions : \n - https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution.html\n - https://www.shadertoy.com/view/MlGcDz\n*/\n\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s,\n        oc * axis.y * axis.x + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.z * axis.y + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    float reflectivity; // Reflectivity coefficient, 0.0 for matte, 1.0 for fully reflective\n    float transparency; // valeur de transparence entre 0 et 1\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\n\nvec3 Damier(vec3 p, float sideSize) {\n    vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n    vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n\n    // Déterminer l'indice de la case dans laquelle se trouve le point\n    ivec3 boxIndex = ivec3(floor(p / sideSize));\n\n    // Calculer si la somme des indices de la case est paire ou impaire\n    int checker = int(boxIndex.x + boxIndex.y + boxIndex.z) % 2;\n\n    // Retourner la couleur correspondante\n    return checker == 0 ? color1 : color2;\n}\n\nvec3 StripedTexture(vec3 p, vec3 color1, vec3 color2, float stripeWidth) {\n    // Calculer le motif à rayures en fonction de la coordonnée x\n    float pattern = sin(p.x * stripeWidth);\n\n    // Déterminer si nous sommes dans une rayure ou non\n    float stripe = step(0.5, pattern);\n\n    // Mélanger les deux couleurs en fonction de la valeur de la rayure\n    return mix(color1, color2, stripe);\n}\n\nMaterial TexturePlane(vec3 p, int i) {\n    if (i == 0) {\n        // Définir les couleurs pour les rayures\n        vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n        vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n        float stripeWidth = 3.1415 * 2.0; // Largeur des rayures\n\n        // Obtenir la texture à rayures\n        vec3 col = StripedTexture(p, color1, color2, stripeWidth);\n        return Material(col, 0.0,0.0); // Matériau non réfléchissant\n    }\n    // Ajouter d'autres cas de textures si nécessaire\n    return Material(vec3(0), 0.0,0.0); // Matériau mat par défaut\n}\n\n//Texture arc-en-ciel\nvec3 RainbowTexture(vec3 p) {\n    float pi = 3.14159265359; // Définir la valeur de pi\n\n    // S'assurer que la coordonnée Y est entre 0 et 1\n    float y = mod(p.y, 1.0); \n\n    // Convertir y en une valeur entre 0 et 2*pi\n    float angle = 2.0 * pi * y;\n\n    // Calculer les valeurs RGB en utilisant des fonctions trigonométriques\n    float r = 0.5 * sin(angle) + 0.5; // Calculer la composante rouge\n    float g = 0.5 * sin(angle + 2.0 * pi / 3.0) + 0.5; // Calculer la composante verte\n    float b = 0.5 * sin(angle + 4.0 * pi / 3.0) + 0.5; // Calculer la composante bleue\n    vec3 color = vec3(r, g, b); // Combiner les composantes RGB en une couleur\n    // Retourner la couleur\n    return color;\n}\n\n// Fonction de bruit simple\nfloat noise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Fonction de texture d'herbe\nvec3 GrassTexture(vec3 p) {\n    // Couleur de base de l'herbe\n    vec3 grassColor = vec3(0.1, 0.5, 0.1);\n\n    // Ajouter une variation de couleur\n    float variation = noise(p.xz * 5.0); // Ajuster l'échelle pour contrôler la fréquence de variation\n    grassColor *= 0.7 + 0.3 * variation; // Assombrir et éclaircir la couleur de base\n\n    // Ajouter des taches plus sombres pour simuler des ombres ou différents types d'herbe\n    float darkPatches = smoothstep(0.4, 0.6, noise(p.xz * 10.0)); // Ajuster l'échelle pour la taille des taches\n    grassColor *= mix(vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0), darkPatches);\n\n    return grassColor;\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif concentrique basé sur la distance au centre\n    float distToCenter = length(p - centerPoint);\n    float concentricValue = sin(distToCenter * frequency);\n\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Combiner les deux motifs\n    float pattern = (concentricValue + radialValue) * 0.5;\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(vec3(0.2, 0.4, 0.6), vec3(0.8, 0.6, 0.4), (pattern + 1.0) * 0.5);\n\n    return color;\n}\n\nvec3 RadialTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n\n    return color;\n}\n\nvec3 multicolorTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n    // Couleur rouge\n    vec3 color3 = vec3(1.0, 0.0, 0.0);\n    // Couleur bleue\n    vec3 color4 = vec3(0.0, 0.0, 1.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n    color = mix(color, color3, pattern);\n    color = mix(color, color4, pattern);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(.8, .5, .4), 0.5,0.0); // Matte material\n    }else if(i==2){\n         //return Material(Damier(p, 0.5), 0.0,0.9);\nreturn Material(vec3(.0, .0, .0), 0.0,0.5); // Matte material\n    } else if(i==3){\n        return Material(ConcentricTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2,0.0);\n    }\n    else if(i==4){\n        return Material(RainbowTexture(p),0.4,0.0);\n    }\n    else if(i==5){\n        return Material(StripedTexture(p, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 3.1415 * 2.0), 0.5,0.0);\n    }\n    else if(i==6){\n        return Material(RadialTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2,0.0);\n    }\n    else if(i==7){\n        //mirror\n        return Material(vec3(0.0, 0.0, 0.0), 1.0,0.0);\n    }else if(i==8){\n        //uniform yellow\n        return Material(vec3(1.0, 1.0, 0.0), 0.0,0.0);\n    }\n    else if (i == 0) {\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col, 0.3,0.0); // Non-reflective material*/\n        //return Material(GrassTexture(p), 0.3,0.0); // Non-reflective grass material\n    }\n    // Add more materials with different reflectivity as needed\n\n    return Material(vec3(0), 0.0,0.0); // Default matte material\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectRotatingSphere(Ray ray, Sphere sph, out Hit x, float angle, vec3 axis) {\n    // 1. Calculer le centre de la sphère\n    vec3 center = sph.c;\n\n    // 2. Calculez la matrice de rotation en fonction de l'axe et de l'angle spécifiés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transform ray\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si la sphère n'était pas tournée\n    if (IntersectSphere(transformedRay, sph, x)) {\n        return true;\n    }\n    return false;\n}\n\nvoid translateSphere(out Sphere s, vec3 maxTranslation, float translation_speed, float time) {\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    s.c += maxTranslation * oscillation;\n}\n\n\nvoid rotateSphere(out Sphere s, float angle, vec3 axis) {\n    axis = normalize(axis); // Assurez-vous que l'axe est normalisé\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    s.c = s.c * cosTheta +\n        cross(axis, s.c) * sinTheta +\n        axis * dot(axis, s.c) * (1.0 - cosTheta);\n}\n\nvoid scaleSphere(out Sphere s, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float scaleFactor = mix(scaleMin, scaleMax, 0.5 * (1.0 + sin(time * scale_speed)));\n\n    s.r *= scaleFactor;\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\n\nvec3 Background(vec3 rd) {\n    // Définir les couleurs du ciel : haut et horizon\n    vec3 skyTopColor = vec3(0.0, 0.5, 0.8); // Bleu profond\n    vec3 skyHorizonColor = vec3(0.7, 0.9, 1.0); // Bleu clair presque blanc\n\n    // Mélanger en fonction de la direction vers le haut (z dans ce cas)\n    // En supposant que rd est normalisé et que rd.z est dans l'intervalle [-1, 1]\n    float t = 0.5 * (rd.z + 1.0); // Échelle à l'intervalle [0, 1]\n    return mix(skyHorizonColor, skyTopColor, t); // Interpoler entre les couleurs de l'horizon et du haut\n}\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    Sphere sph1=Sphere(vec3(0.,0.,1.),1.,2);\n    Sphere sph2=Sphere(vec3(2.,0.,2.),1.,3);\n    rotateSphere(sph2,iTime,vec3(0.,0.0,1.));\n    \n    //PLAN\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    \n    \n    return ret;\n}\n\n\n// Teste si le point est dans l'ombre\nbool InShadow(vec3 point, vec3 lightPos, out float shadowFactor)\n{\n    vec3 toLight = lightPos - point;\n    float distanceToLight = length(toLight);\n    toLight = normalize(toLight);\n\n    Ray shadowRay = Ray(point + toLight * 0.001, toLight); // Décalage pour éviter l'auto-intersection\n    Hit shadowHit;\n\n    // Vérifie les intersections avec n'importe quel objet de la scène\n    if (Intersect(shadowRay, shadowHit))\n    {\n        // Si l'intersection est plus proche que la lumière, le point est dans l'ombre\n        if (shadowHit.t < distanceToLight)\n        {\n            shadowFactor = 0.0; // Dans l'ombre\n            return true;\n        }\n    }\n\n    shadowFactor = 1.0; // Pas dans l'ombre\n    return false;\n}\n\n// Calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    float ao = 0.0;\n    float occlusion = 0.0;\n    float radius = 1.0; // Définit le rayon dans lequel vérifier l'occlusion\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction dans l'hémisphère\n        Ray aoRay = Ray(p + n * 0.001, d); // Décalage de l'origine un peu le long de la normale pour éviter l'auto-intersection\n\n        Hit aoHit;\n        if (Intersect(aoRay, aoHit) && aoHit.t < radius) {\n            occlusion += 1.0; // Ce rayon a frappé quelque chose, donc augmenter l'occlusion\n        }\n    }\n\n    ao = 1.0 - occlusion / float(N); // La fraction de rayons qui n'ont rien frappé\n    return ao;\n}\n\nvec3 applyTransparency(vec3 objectColor, vec3 backgroundColor, float alpha) {\n    // Mix the object color with the background color based on the alpha value\n    return mix(backgroundColor, objectColor, alpha);\n}\n\n\nvec3 PhongIllumination(Material m, vec3 n, vec3 v, vec3 lightPos, float shininess, vec3 point)\n{\n    float shadowFactor;\n    if (InShadow(point, lightPos, shadowFactor))\n    {\n        return vec3(0.0); // Dans l'ombre, pas de composante diffuse ou spéculaire\n    }\n\n    vec3 ambient = 0.1 * m.d; // Couleur ambiante\n\n    // Composante diffuse\n    vec3 l = normalize(lightPos - point);\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * m.d * shadowFactor;\n\n    // Composante spéculaire\n    vec3 r = reflect(-l, n); // Réfléchir le vecteur lumineux sur la normale\n    float spec = pow(max(dot(r, v), 0.0), shininess);\n    vec3 specular = vec3(1.0) * spec * shadowFactor; // En supposant des reflets spéculaires blancs\n\n    return ambient + diffuse + specular;\n}\n\n// Applique le modèle de couleur avec l'illumination de Phong et les ombres\nvec3 Color(Material m, vec3 n, vec3 v, vec3 point)\n{\n    // Définit les positions des lumières\n    vec3 lightPos1 = vec3(1, 20, 10); // Position de la première lumière\n    vec3 lightPos2 = vec3(-2, -20, 10); // secondes lumière\n    vec3 lightPos3 = vec3(-200, -200, 100); // troisième lumière\n    \n    \n    // Calcule la direction de vue\n    vec3 viewDir = normalize(v); // Calcule la direction de vue\n    \n    // Calcule l'occlusion ambiante avant l'éclairage direct\n    float ao = AmbientOcclusion(point, n, 16); // Utilisation de 16 échantillons pour l'AO\n\n    // Illumination de Phong avec ombres pour la première lumière\n    vec3 col = PhongIllumination(m, n, viewDir, lightPos1, 100.0, point);\n    col += PhongIllumination(m, n, viewDir, lightPos2, 100.0, point);\n    col += PhongIllumination(m, n, viewDir, lightPos3, 100.0, point);\n\n    // Applique l'occlusion ambiante à la couleur finale\n    col *= ao;\n\n    return col;\n}\n\n// Rendu avec prise en charge de la transparence\nvec3 Shade(Ray ray)\n{\n    vec3 color = vec3(0.0); // Initialise la couleur à noir\n    vec3 attenuation = vec3(1.0); // Commence sans atténuation\n\n    for (int bounce = 0; bounce < 1000; bounce++)\n    {\n        Hit hit;\n        if (!Intersect(ray, hit))\n        {\n            // Si aucun objet n'est touché, utilisez la couleur de fond\n            color += attenuation * Background(ray.d);\n            break;\n        }\n\n        vec3 point = Point(ray, hit.t); // Point d'intersection\n        Material mat = Texture(point, hit.i);\n\n        // Calcul de la direction de vue\n        vec3 viewDir = normalize(-ray.d);\n\n        // Si le matériau est transparent,tracer un autre rayon\n        if (mat.transparency > 0.0)\n        {\n            // Mélanger avec le fond ou avec la couleur de l'objet derrière\n            vec3 background = Background(ray.d); \n            vec3 objectColor = Color(mat, hit.n, viewDir, point);\n            color += attenuation * applyTransparency(objectColor, background, mat.transparency);\n            \n            // Attnénuation basée sur la transparence pour le prochain rebond\n            attenuation *= (1.0 - mat.transparency);\n\n            // Préparez le rayon pour le prochain passage à travers un nouvel objet\n            ray.o = point + ray.d * 0.001;\n        }\n        else\n        {\n            // Si l'objet n'est pas transparent, calculez la couleur et arrêter la boucle.\n            color += attenuation * Color(mat, hit.n, viewDir, point);\n            break;\n        }\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 661, 706, 706, 1120], [1323, 1323, 1350, 1371, 1539], [1541, 1639, 1673, 1673, 2030], [2033, 2092, 2121, 2121, 2149], [2151, 2151, 2184, 2184, 2204], [2206, 2206, 2243, 2243, 2706], [2708, 2708, 2782, 2850, 3107], [3109, 3109, 3147, 3147, 3714], [3716, 3738, 3767, 3767, 4442], [4444, 4472, 4494, 4494, 4567], [4569, 4600, 4627, 4661, 5249], [5251, 5251, 5329, 5387, 6029], [6031, 6031, 6105, 6229, 6767], [6769, 6769, 6847, 6971, 7711], [7713, 7764, 7797, 7797, 9082], [9084, 9167, 9219, 9219, 9559], [9561, 9561, 9647, 9690, 10379], [10381, 10381, 10475, 10475, 10587], [10590, 10590, 10647, 10647, 10900], [10902, 10902, 10997, 11043, 11158], [11161, 11243, 11294, 11294, 11457], [11459, 11459, 11485, 11540, 12012], [12016, 12085, 12125, 12125, 12301], [12304, 12386, 12421, 12436, 13048], [13051, 13089, 13155, 13155, 13812], [13814, 13848, 13895, 13895, 14547], [14549, 14549, 14626, 14705, 14760], [14763, 14763, 14859, 14859, 15541], [15543, 15620, 15672, 15716, 16563], [16565, 16614, 16635, 16635, 18159], [18163, 18163, 18217, 18314, 18780]], "test": "untested"}
{"id": "cltcDN", "name": "FloatBitsToInt Slub 69", "author": "domrally", "description": "Another study on \"floatBitsToInt\".\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "pixel", "bit", "tweet", "bitwise", "halftweet", "golf", "bitfield"], "likes": 5, "viewed": 165, "published": 3, "date": "1699553148", "time_retrieved": "2024-07-30T17:23:10.345038", "image_code": "/*\n69 characters 🏌️ by Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n   o = vec4(floatBitsToInt(i.x / i.y) % 9);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 85, 85, 131]], "test": "untested"}
{"id": "dldyRl", "name": "Another Vignette Shader", "author": "Kampfhund", "description": "A fairly simple Vignette-Shader.\nI'm open for suggestions as to how to get rid of the cross pattern (and other suggestions and critique as well of course)", "tags": ["postprocessing", "uv", "vignette", "border"], "likes": 0, "viewed": 156, "published": 3, "date": "1699550518", "time_retrieved": "2024-07-30T17:23:11.231668", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    //Change the intensity of the vignette here (Beware it is used as an exponent)\n    float vignette_intensity = 1.1; \n\n    float vignetteX = 1.0 - atan(abs((uv.x * 2.0) - 1.0));\n    float vignetteY = 1.0 - atan(abs((uv.y * 2.0) - 1.0));\n    \n    float vignette = pow(vignetteX, vignette_intensity) * pow(vignetteY, vignette_intensity);\n\n\n    vec4 tex = texture(iChannel0, uv);\n    vec4 color = vec4(tex.r * vignette, tex.g * vignette, tex.b * vignette, 1.0);\n    \n\n    fragColor = color;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 596]], "test": "untested"}
{"id": "ddGyWV", "name": "Hireth", "author": "Dave_Hoskins", "description": "Hireth. A shader for the composer David Julyan [url]https://davidjulyan.bandcamp.com/album/hireth[/url]\n\nThe house appears as distant smoke at first at 190s\n\nSorry of you GPU in screaming at you. I wanted it to be glitch free.\n\n", "tags": ["hireth"], "likes": 37, "viewed": 481, "published": 3, "date": "1699545994", "time_retrieved": "2024-07-30T17:23:12.183124", "image_code": "// Hireth (shader video)\n// by David Hoskins.\n// Licensed under Attribution-NonCommercial-NoDerivatives 4.0 International\n// https://creativecommons.org/licenses/by-nc-nd/4.0/?ref=chooser-v1\n\n// Video for a friend of mine, the composer David Julyan. https://davidjulyan.com/\n// The album can be found here:\n\n// https://davidjulyan.bandcamp.com/album/hireth\n// All rights to the music belong to David Julyan...\n\n\nvec3 sunDir;\nmat3 camMat;\nvec3 cameraPos, cameraTar;\nvec3 sunPos;\n\nfloat gTime;\nfloat roll;\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n\n//----------------------------------------------------------------------------------------\n// Crepuscular light rays...\nfloat godRays(vec2 uv)\n{\n   \tfloat ra =0.0;\n    vec3 sun = sunDir+vec3(0,.4,0);\n    // Find where the sun is in 2D then drag sky pixels accross that direction.\n    // It's not perfect here, but I like the effect.\n\tvec2 sunLoc = vec2(dot( sun, camMat[0] ),dot( sun, camMat[1] ) );\n   \t\n    vec2 p = uv-sunLoc;\n    float add = hash12(uv*4000.)*.05;\n    \n    \n \tfor (float x = .2; x < 1.; x+=.05)\n\t{\n\t\tfloat z = textureLod(iChannel1,(sunLoc+(p*(x+add))+1.)*.5, 0.).w;\n\t\tra+= z*(x-.1);\n\t}\n   \n    return ra*.025;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    return getStore(iChannel0, CAMERA_MAT0).xyz;\n    vec3 dir \t= camMat * normalize( vec3(uv, PROG_Z));\n}\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\nfloat drawValues(vec2 cor)\n{\n\nfloat c = 0.0;\n\n    vec3 camPos = getStore(iChannel0, CAMERA_POS).xyz;\n    vec2 camRot = getStore(iChannel0, CAMERA_ROT).xy;\n    c += PrintValue(cor, vec2(100.,10.),vec2(20,20) , camPos.x, 1.0, 0.);\n    c += PrintValue(cor, vec2(250.,10.),vec2(20,20) , camPos.y, 1., 0.);\n    c += PrintValue(cor, vec2(400.,10.),vec2(20,20) , camPos.z, 1., 0.);\n    \n    c += PrintValue(cor, vec2(100.,40.),vec2(20,20) , camRot.x, 1., 0.);\n    c += PrintValue(cor, vec2(250.,40.),vec2(20,20) , camRot.y, 1., 0.);\n    \n    vec4 sunCol = getStore(iChannel0, SUN_COLOUR);\n    \n    c += PrintValue(cor, vec2(500.,10.),vec2(20,20) , sunCol.w*1000.0, 1., 0.);\n    c += PrintValue(cor, vec2(500.,40.),vec2(20,20) , gTime, 1., 0.);\n    \n    //int t = int(iTime);c += PrintValue(cor, vec2(140.,130.),vec2(20,20) , float((t-1) % 4), 1., 0.);\n    //c += PrintValue(cor, vec2(280.,130.),vec2(20,20) , float(t), 1., 0.);\nreturn c;\n}\n\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    vec2 uv = fragCoord /  iResolution.xy;\n    camMat  = getStoreMat33(iChannel0, CAMERA_MAT0);\n    sunDir  = getStore(iChannel0, SUN_DIR).xyz;\n\n    vec4 temp= getStore(DATA_CHANNEL, SUN_COLOUR);\n    sunColour = temp.xyz;\n    sunUp = max(temp.w, 0.0);\n\n    sunPos = sunDir * 20000.;\n\n    vec4 te = getStore(iChannel0, GLOBAL_TIME);\n    gTime = te.x;\n    roll = te.y;\n    \n    \n    vec4 col = texelFetch(iChannel1,ivec2(fragCoord),0);\n\n    col += godRays(xy) * vec4(mix(vec3(.2), sunColour, .7) *sunUp, 1);\n\n   \n    //col = col*col*(3.0-2.0* col);\n    \n    col.xyz = aces(col.xyz);\n    col = fader(0.,8.,gTime)*fader(370.0, 355.0, gTime)*col;   \n    \n    col = sqrt(col);\n    #ifdef SEE_NUMBERS\n    col += drawValues(fragCoord);\n    #endif\n    \n    col *= .6+0.4*pow(80.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.3 );\t// Vignette\n    col += hash12(fragCoord+iTime*4400.)/64.0; //...Mega-Dither\n  \n\n    fragColor = clamp(col, 0.0, 1.0);\n    \n    \n     \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35201, "src": "https://on.soundcloud.com/iTnaf", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//#define RENDERED_VERSION\n//#define SEE_NUMBERS\n//#define DEBUG\n\n#define TSIZE 256.\n#define TWRAP 255\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define ZERO min(0, iFrame)\n\n#define TAU 6.28318530718\n\n#define FOG_COLOUR vec3(.4, .4, .45)\n\n#define CAMERA_POS\t\t0\n#define CAMERA_ROT\t\t1\n#define CAMERA_BASE\t\t2\n\n#define CAMERA_VEL      3\n#define GLOBAL_TIME\t\t6\n#define CAMERA_ROLL\t\t7\n\n#define SUN_DIR\t\t    8\n#define SUN_COLOUR\t    9\n#define PROG_Z\t\t    1.4\n\n\n#define CAMERA_MAT0\t\t20\n#define CAMERA_MAT1\t\t21\n#define CAMERA_MAT2\t\t22\n//#define SUN_DIRECTION \t5\n#define LAST \t\t\t10\n\n#define DATA_CHANNEL   iChannel0\n\n#define LIGHT_COLOUR vec3(1., .6, .4)\n\n#ifdef RENDERED_VERSION\n#define FAR 20000.\n#else\n#define FAR 9000.\n#endif\n\n\nvec3 sunColour;\nfloat sunUp;\n\n\n//----------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n//----------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n//----------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//----------------------------------------------------------------------------------------\nvoid rot(inout vec2 p, float a)\n{\n    p = cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n//----------------------------------------------------------------------------------------\nfloat noise1( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(hash11(p), hash11(p + 1.0),f);\n\n    return res;\n}\n\n\n\n//----------------------------------------------------------------------------------------\nvec2 noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( hash22(p), hash22(p + vec2(1.0,0.0)),f.x),\n                   mix( hash22(p + vec2(0.0,1.0)), hash22(p + vec2(1.0,1.0)),f.x),f.y);\n    return res-vec2(.5);\n}\n\n//----------------------------------------------------------------------------------------\nfloat noise12( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix( hash12(p), hash12(p + vec2(1.0,0.0)),f.x),\n                   mix( hash12(p + vec2(0.0,1.0)), hash12(p + vec2(1.0,1.0)),f.x),f.y);\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nfloat fbm(in vec2 x )\n{\n    float h = noise12(x)*.5 +\n              noise12(x*2.0+100.)*.3 +\n              noise12(x*4.0+200.)*.2;\n    \n    return h;\n}\n\n//----------------------------------------------------------------------------------------\nint storeIndex(ivec2 p)\n{\n\treturn p.x + 64 * p.y;\n}\n\n//----------------------------------------------------------------------------------------\nvec4 getStore(sampler2D tex,int num)\n{\n\treturn  texelFetch(tex, ivec2(num, 0), 0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 getStoreMat33(sampler2D tex,int num)\n{\n    vec3 m0 = texelFetch(tex, ivec2(num, 0),   0).xyz;\n    vec3 m1 = texelFetch(tex, ivec2(num+1, 0), 0).xyz;\n    vec3 m2 = texelFetch(tex, ivec2(num+2, 0), 0).xyz;\n    return mat3(m0, m1, m2);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., sa.y,    0., 1., 0.,   -sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//----------------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\n\n// Exponential fader...\nfloat fader(const in float edge0, const in float edge1, const in float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/distfunctions/\n//----------------------------------------------------------------------------------------\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sdHorizontalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n    \n//----------------------------------------------------------------------------------------\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\n\n\n\n\n", "buffer_a_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n// Derivative pre-process...\n\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+9) & TWRAP);  // ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, 1.5 );\n}\n\n//---------------------\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|****               |\n//|****               |\n//|****               |\n//---------------------\n// The block is in the bottom left 256x256 of buffer texture\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n// Draw it only once to relavent area...\n\n// It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n// Pre-calc all we can...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}", "buffer_a_inputs": [], "buffer_b_code": "//#define FLY_CAMERA\n\n#define START_TIME 0.\n//330 is before the house\n\n//Time muliplier, use 1.0 For Hireth music track.\n#define TIME_MULTI 1.  \n\n\n// Movement...\n// * * CONTROLS * *\n// WASD or CURSOR keys\n// Mouse drag to turn.\n// SHIFT & SPACE for 2X & 4X speed\n\n\n#define INVERT_Y 0\n#define ACCEL .005\n#define DECAY  .8 // how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  10.0\n#define TAU 6.28318530718\n\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\nstruct Camera\n{\n    vec3 pos;\n    vec2 rot;\n};\n\n#ifndef FLY_CAMERA\n // Catmull-rom spline coords & rotations...\nCamera camPos[] = Camera[](\n    Camera(vec3(-129, 393, 17460), vec2(14,191)),\n    Camera(vec3(-422, 400, 18000), vec2(0,200)), // Back from start\n    Camera(vec3(-822, 420, 17900), vec2(-20,220)),\n    Camera(vec3(-1768, 327, 17900), vec2(00,180)),\n    Camera(vec3(-1968, 327, 17000), vec2(00,180)),\n    Camera(vec3(-2100, 546, 16200), vec2(00,224)),\n    Camera(vec3(-2710, 223, 15303), vec2(4,152)),\n    Camera(vec3(-2755, 316, 14919), vec2(36,217)),\n    Camera(vec3(-2408, 465, 14637), vec2(11,242)),// Over side nodule.\n    Camera(vec3(-1991, 582, 14380), vec2(13,278)),\n    Camera(vec3(-1493, 428, 14618), vec2(13,268)),// First plane.\n    Camera(vec3(-693, 249, 14678), vec2(2,202)),\n    Camera(vec3(-693, 249, 14678), vec2(2,142)),\n    Camera(vec3(-826, 274, 14352), vec2(17,160)),\n    Camera(vec3(-859, 400, 14271), vec2(-20,173)),//Chopper style lift\n    Camera(vec3(-1332, 408, 13776), vec2(4,132)),\n    Camera(vec3(-2475, 258, 13507), vec2(-10,108)),\n    Camera(vec3(-2732, 270, 13423), vec2(-10,103)),\n    Camera(vec3(-3139, 404, 12999), vec2(1,146)),\n    Camera(vec3(-3581, 406, 11841), vec2(-5,174)), // Black mount om left\n    Camera(vec3(-2873, 341, 9728), vec2(-3,218)),\n    Camera(vec3(-2873, 541, 9628), vec2(-3,248)),\n    Camera(vec3(-2543, 396, 9651), vec2(-10,205)),\n    Camera(vec3(-2157, 254, 9538), vec2(-20,206)),\n    Camera(vec3(-2205, 225, 8378), vec2(-2,193)),\n    Camera(vec3(-2369, 286, 7384), vec2(16,166)),\n    Camera(vec3(-2714, 228, 6717), vec2(8,179)),\n    Camera(vec3(-2472, 312, 6464), vec2(-16,204)),\n    Camera(vec3(-2186, 365, 5913), vec2(-45,197)),\n    Camera(vec3(-2237, 220, 5330), vec2(-13,178)),\n    Camera(vec3(-2879, 361, 4766), vec2(-13,159)),\n    Camera(vec3(-2965, 371, 4592), vec2(-11,202)),\n    Camera(vec3(-2851, 371, 4332), vec2(-10,225)),\n    Camera(vec3(-2541, 135, 4107), vec2(-3,209)),\n    Camera(vec3(-2541, 80, 4007), vec2(10,209))\n\n    );\n\n\n        \n#endif\n         \n\n//----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)/256.0, .25)).x);\n}\n\n//----------------------------------------------------------------------------------------\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\n\n#ifndef FLY_CAMERA\n\n// Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    vec3 c2 = -.5 * p0\t+ 0.5*p2;\n\tvec3 c3 = p0\t\t+ -2.5*p1 + 2.0*p2 + -.5*p3;\n    vec3 c4 = -.5 * p0\t+ 1.5*p1 + -1.5*p2 + 0.5*p3;\n\treturn(((c4 * t + c3) * t + c2) * t + p1);\n}\n\n//-----------------------------------------------------------------------------------------------------------\nCamera getPosAtTime(float t)\n{\n    Camera cam;\n\n\n    int i = int(t);\n    \n\n    ivec4 id = ivec4(i-1, i, i+1, i+2);\n    // Don't scrub memory with illegal indexing...\n    id = clamp(id, 0, camPos.length()-1);\n    \n \n    vec3 p0 = camPos[id.x].pos;\n    vec3 p1 = camPos[id.y].pos;\n    vec3 p2 = camPos[id.z].pos;\n    vec3 p3 = camPos[id.w].pos;\n\n    t = fract(t);\n    \n    cam.pos = spline(p0, p1, p2, p3, t);\n    \n    t = t*t*(3.0-2.0*t);\n    float x1 = camPos[id.y].rot.x;\n    float x2 = camPos[id.z].rot.x;\n    x1 = mix(x1, x2, t);\n    \n    float y1 = camPos[id.y].rot.y;\n    float y2 = camPos[id.z].rot.y;\n    y1 = mix(y1, y2, t);\n\n    cam.rot = vec2(x1, y1);\n    \n    return cam;\n\n} \n\n#endif\t\n\n\n//-----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    colour = vec4(0.0,0.0,0.0,1.0);\n    int  index = storeIndex(ivec2(coord));\n\n    #ifdef FLY_CAMERA\n \n        if ( index == CAMERA_POS)\n        {\n            vec3 camPos = getStore( DATA_CHANNEL, CAMERA_POS).xyz;\n            vec3 camVel = getStore( DATA_CHANNEL, CAMERA_VEL).xyz;\n\n            if (iFrame == 0)\n\t\t    {\n        \t\tcolour = vec4(-2300., 250., 3900.,0);\n            }else\n            {\n                camVel *= 200.*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos += camVel;\n            \tcolour = vec4(camPos, 0);\n            }\n        }\n        else if ( index <= CAMERA_BASE )\n        {\n            vec4 baseCamRot = getStore( DATA_CHANNEL, CAMERA_BASE);\n            vec4 camRot =  getStore( DATA_CHANNEL, CAMERA_ROT);\n\n\n            vec2 mouseRot = -(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.) *360.0;\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            \n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n            //\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( index == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tcolour = vec4(14, 191, .0,0);\n            \t}else\n                {\n                    //camRot = fract(camRot/360.0) * 360.0;\n                    colour = camRot;\n                }\n            }\n            else\n            {\n            \tcolour = baseCamRot;\n                baseCamRot = fract(baseCamRot/360.0) * 360.0;\n            }\n        }\n        else if ( index == CAMERA_VEL)\n        {\n            vec4 camVel = getStore( DATA_CHANNEL, CAMERA_VEL);\n            mat3 camMat = getStoreMat33(iChannel0, CAMERA_MAT0);\n            vec3 forward = camMat[2] * ACCEL;\n            vec3 right \t = camMat[0] * ACCEL;\n            if (iFrame == 0) camVel = vec4(0);\n\n            camVel *= DECAY; // exponential decay\n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n \n\n\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            colour = camVel;\n        }\n    \n    #else\n    \n    float t = getStore(iChannel0, GLOBAL_TIME).x*.1;\n \n    if ( index == CAMERA_POS)\n    {\n\t\tCamera camInfo = getPosAtTime(t);\n        vec3 pos = camInfo.pos;\n\t\tcolour = vec4(pos, 1.0);\n    }else\n    if ( index == CAMERA_ROT)\n    {\n        Camera camInfo = getPosAtTime(t);\n        colour.xy = camInfo.rot;\n    }\n        \n    #endif\n    \n    if (index >= CAMERA_MAT0 && index <= CAMERA_MAT2)\n    {\n        float roll = 0.0;\n        vec3 dir;\n        vec2 cam =  getStore( DATA_CHANNEL, CAMERA_ROT).xy;\n        cam *= TAU/360.;\n        mat3 mat = viewMat(cam.x, cam.y);\n        switch (index)\n        {\n            case CAMERA_MAT0:\n                colour.xyz = mat[0];\n            break;\n            case CAMERA_MAT1:\n                colour.xyz = mat[1];\n            break;\n            case CAMERA_MAT2:\n                colour.xyz = mat[2];\n            break;\n         }\n      }\n      else if ( index == GLOBAL_TIME)\n      {\n            float gTime = iTime * TIME_MULTI + START_TIME;\n            float roll = .05 * sin(iTime*.3);\n            colour = vec4(gTime, roll,0,0);    \n            \n    }\n    else if (index == SUN_DIR)\n    { \n        float t = getStore(iChannel0, GLOBAL_TIME).x*.0064+.93;\n        //t = -.5;\n        vec3 sun = vec3(0,0,1);\n        rot(sun.yz, -t);\n        rot(sun.xy, -.5);\n        //colour.xyz = normalize( vec3(  0.3, .3, -.4 ) );\n        colour.xyz = sun;\n        \n    }else\n    if (index == SUN_COLOUR)\n    {\n        float t = clamp(getStore(iChannel0, SUN_DIR).y, 0.0, 1.0);\n        t = sqrt(t);\n        \n        \n    \n        colour.xyz = vec3(1.0, .2+sqrt(t)*.8, .1+t*.9  );\n        \n        //colour.yz -= pow(t, 100.)*.3;\n        \n        \n        colour.w = clamp(t, 0.0, 1.0);\n        colour = clamp(colour, 0.0, 1.0);\n    }\n    \n    \n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Atmosphere stuff thanks to:\n// https://www.shadertoy.com/view/MtBcz1\n\n#define ANG2 1.33\n#define ANG3 1.8\nbool houseVisible;\nbool doorHit;\n\nfloat smokeDist = 0.0;\n#ifdef DEBUG\nfloat iterations;\n#endif\n\n\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.;\n//const vec3 PARALLEL_DIR = normalize(vec3(.35 , .2, .5));\nvec3 sunDir;\n\nvec3 cameraPos, cameraTar;\nmat3 cameraMat;\n\nconst vec3 camHouse = vec3(-2350., 70., 3800.);\nconst vec3 chimney = camHouse+vec3(-97,120,0);\n//const vec3 houseLight = vec3(-2500., 100., 3800.);\nconst vec3 houseLight = vec3(-2350., 100., 3850.);\n\nvec3 camRay;\nfloat gTime;\nfloat movement = 0.0;\nfloat fade;\nfloat roll;\n\nfloat sphereFog( vec3  ro, vec3  rd,   // ray origin, ray direction\n                  vec3  sc, float sr,   // sphere center, sphere radius\n                  float dbuffer )       // depth buffer\n{\n    // normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer / sr;\n    vec3  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    \n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    // not visible (behind camera or behind ndbuffer)\n    if( t2 < 0.0 || t1 > ndbuffer ) return 0.0;\n\n    //return h*h*h*h;\n    // clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Thanks to iq for the derivative solution, many years ago...\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n\n\tvec4 n = texelFetch(iChannel2, ivec2(floor(x)) & TWRAP, 0);\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Add random rocks with random heights...\nfloat rocks(in vec2 p)\n{\n    float d = 0.0;\n    p *= 8.;\n    p += fbm(p)-.5;\n\tvec2 v2 = fract(p)-.5;\n    float str = noise12((p));\n    str = pow(str, 20.0)*30.;\n    d += max(.8-(length(v2)), 0.0)*(str)*.5;\n    return d*4.;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat roads(in vec2 p)\n{\n    float n = fbm(p*.695+vec2(2.14, 0.0))-.5;\n    n = 1.-abs(n);\n    n = min(pow(n, 50.0), noise12(p*8.)*.4+.5);\n    return n*6.;\n}\n\nfloat noise13(in vec3 x)\n{\n    // Use 2D texture...\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n \n//-------------------------------------------------------------------------------------------------------\n float sdfHouse(vec3 p, float d)\n {\n     //d = 1000.0;\n     d = sdBox(p, vec3(100,50,50));\n     \n    if (d< -4.5)\n         houseVisible = true;\n    else\n         houseVisible = false;\n\n    d = min(d, sdBox(p-vec3(-95,40,0), vec3(10,100,10)));\n\n    vec3 q = p- vec3(0,50,0);\n    rot(q.yz, .78);\n    d = min(d, roundedBox(q, vec3(96,40,40), 4.));\n\n    d = max(d, -sdBox(p, vec3(90,38,45)));     \n    p.x = abs(p.x);\n\n    d = max(d, -sdBox(p - vec3(60,0,50), vec3(20, 14, 25)));\n    d = max(d, -sdBox(p - vec3(5,-20,50), vec3(10, 30, 25)));\n    \n    float dor = sdBox(p - vec3(5,-20,40), vec3(10, 30, 5));\n    \n    if (dor < .5)\n        doorHit = true;\n    d = min(d, dor);\n   \n    // Cheap windows...\n    d = min(d, sdVerticalCapsule(p-vec3(52, -20,48), 35.,.5));\n    d = min(d, sdVerticalCapsule(p-vec3(67, -20,48), 35.,.5));\n    d = min(d, sdHorizontalCapsule(p-vec3(40, 0,48), 40.,.5));\n    \n    \n    //d = min(d, sdRoundCone(p, camHouse, camHouse-vec3(0,200,0), 100.0, 400.0));\n    if (!doorHit)\n        d+=noise13(p*.25)*.5;\n\n     \n\n\n     return d;\n}\n\n//-------------------------------------------------------------------------------------------------------\n float sdfHouseShad(vec3 p, float d)\n {\n    p = p - camHouse;\n     d = roundedBox(p, vec3(100,50,50), .1);\n\n     d = min(d, roundedBox(p-vec3(-95,70,0), vec3(10,70,10), .1));\n     vec3 q = p- vec3(0,50,0);\n     rot(q.yz, .78);\n     d = min(d, roundedBox(q, vec3(100,40,40)*.9, 10.1));\n     \n\n     return d;\n}\n \n \n \n//-------------------------------------------------------------------------------------------------------\nfloat house(in vec3 p)\n{\nfloat d = 1000.0;\n\n    p = p - camHouse;\n    float bound = sdBox(p, vec3(130,160,120));\n    if (bound < 0.0)\n    {\n  \n        d = sdfHouse(p, bound);\n    }\n\nreturn d;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat terrainSDF( in vec3 p, float z)\n{\n    float a = 0.0;\n    float h = length(p.xz-camHouse.xz);\n    vec2  d = vec2(0.0);\n    float b = 400.;//smoothstep(0.0, 2000.0, h)*500.0+40.;\n    b*= (.2+smoothstep(00.0,1500.0,h)*1.5);\n    p = p*0.0007;    \n    \n    int iter = 1;\n\n    // Decrease iteration detail with distance, but always do furniture..\n    if (z >= 0.0)\n    {\n        // Up to 14 levels of fractal...\n        iter = 14-int(log2(z*.01+1.0));\n        iter = clamp(iter, 2, 14);\n        //iter = 14;\n        \n        a -= roads(p.xz*4.);\n        a += rocks(p.xz*6.);\n        #ifdef DEBUG\n        iterations = float(iter);\n        #endif\n        \n    }\n    \n\tfor (int i = 0; i < iter; i++)\n\t{\n        vec3 n = noiseD(p.xz);\n        \n        d += n.yz;\n        a += b*n.x/(.85+dot(d,d));\n\n\t\tb *= 0.43;\n        p.xz = rotMat*p.xz;\n        //p.xz -= n.yz*.2;\n        p.xz += n.zy*.2;\n\t}\n    \n\n\treturn a;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat smokeCone(vec3 p)\n{\n    float t = gTime*.6;\n    float sm = sdRoundCone(p, chimney, chimney+vec3(sin(p.y*.015+t*1.)*40.+p.y*.5,1000, cos(p*0.01+t)*40.), 4.0, 200.0);\n    return sm;\n\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat map(vec3 p, float z)\n{\n    float h = p.y-terrainSDF(p, z);\n    h = min(h, house(p));\n    \n\n    // Check for smoke volume...\n    float s = smokeCone(p);\n    if (smokeDist < 0.0 && s < 0.1)\n        smokeDist = z;\n\n    return min(h, max(s, 35.));\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat mapShad(vec3 p, float z)\n{\n    float h = p.y-terrainSDF(p, z);\n    h = min(h, sdfHouseShad(p,0.0));\n    return h;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamPos(float t)\n{\n\tvec3 p = vec3(sin(t)*1500.-4500.+cos(t*.5)*1000., 300.+sin(t)*250., cos(t*1.1)*1500.-1400.+cos(t*.3)*1000.);\n    return p;\n}\n\n//-------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    cameraPos = getStore(DATA_CHANNEL, 0).xyz;\n    \n   \tvec2 camRot = getStore(DATA_CHANNEL, 1).xy;\n    \n    vec2 cam = camRot * TAU / 360.0;\n\n  \n\tvec3 dir = normalize(vec3(uv,PROG_Z));\n    cameraMat = getStoreMat33(iChannel0, CAMERA_MAT0);\n    dir = cameraMat *dir;\n    return dir;\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nvec3 getSky(vec3 raydir)\n{\n\tvec3 sundir = sunDir;\n    sundir.y = max(sundir.y, -.07);\n    float a = dot(raydir, sunDir);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 3.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 2.0);\n\tfloat mymie = sundt * special_trick * 0.4;\n\tvec3 suncolor = mix(vec3(1.), max(vec3(0.0), vec3(1.0) - vec3(10.5, 20.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(.2), bluesky - vec3(5.5, 13.0, 22.4) * 0.004 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n    \n    \n\tbluesky2 = max(bluesky2 + mymie * suncolor,0.0)+.0;\n    bluesky2 = mix(bluesky2, FOG_COLOUR, sunUp*.3)*.5+vec3(0.01,0.01,.02);\n     \n    bluesky2 += pow(max(a, .0), 2000.0) * 20. * sunColour;\n\n    bluesky2  = clamp(bluesky2, 0.0, 1.0);\n    \n    \n    \n\n    \n    return bluesky2;\n} \n/*\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.3,.5,1.0),clamp((1.-exp(-dir.y))*1., 0.0, 1.))*.1;\n    float a = dot(dir, sunDir);\n    col += pow(max(a, .0), 800.0) * 40. * sunColour;\n    \n    float red   = max(.9  - sunUp, 0.0);\n    col.x += pow(max(.8 - dir.y,0.0), 4.)* 30.0 * red;\n    float horiGlow   = max(.8 -sunUp, 0.0);\n    col += pow(max(.5 - dir.y,0.0), 2.)*15.0 * horiGlow;\n    //col += pow(max(.4 - dir.y,0.0), .5)*.5;\n    //col*=pow(max(a, 0.0), 10.0)*.4;\n    col *= sunUp;\n\n    return col+.02;\n}\n*/\n\n//-------------------------------------------------------------------------------------------------------\nfloat softShadow(in vec3 ro, in vec3 rd, float dis )\n{\n    float minStep = .4;\n\n    float res = 1.0;\n    float t = 0.01;\n\n\tfor( int i=0; i<25; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = mapShad(p, dis);\n\t\tres = min( res, 25.0*h/t );\n\t\tt += max(minStep,h);\n\t\tif( res<0.2) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------------------\n// From here: https://www.shadertoy.com/view/3lsSzf\nvec3 getNormal(const in vec3 pos, float ds)\n{\n    \n    ds = max(ds*ds*.001/iResolution.y, .1 );\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+ds*e, ds);\n    }\n    return normalize(n);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor, vec3 dir, float dis)\n{\n    vec3 li;\n    float l = max(dot(dir, nor), 0.0);\n    vec3 ref = reflect(nor, camRay);\n    float sh = softShadow(p+nor*.5, dir, dis);\n    l *= sh;\n    li = l * sunColour*sunUp;\n    li = li+pow(max(dot(ref, sunDir), 0.0), 100.0)*sunColour*sh;\n    li = li*sunUp+.01;\n    li = clamp(li, 0.0, 1.0);\n    if (houseVisible)\n    {\n        vec3 fpos = camHouse+vec3(-50,0,0);\n        float fl = length(fpos - p);\n\n        vec3 fp = (fpos-p) / fl;\n        vec3 fire = fp/fl;\n        fl = (fl*fl)*.00001;\n        \n        l = max(dot(fire, nor) / fl, 0.0)*2.0;\n        li += l * vec3(1.0+noise1(gTime*8.),.2,0);\n    }\n    \n    ref = houseLight - p;\n    l = length(ref);\n    // Lamp outside house...\n    if (l < 150.0)\n    {\n        vec3 n = ref / l;\n        l = smoothstep(100.0, 0.0, l);\n        float a = max(dot(n, nor), 0.0);\n        float dim = smoothstep(-.5, -1.5,dot(n, vec3(0,-1,0)));\n        l = l*dim;\n        li += l * LIGHT_COLOUR;\n    }\n\n    return clamp(li, 0.0, 1.0);\n    \n}\n\nvec3 brickt(vec2 p2)\n{\n    p2 += noise2(p2*1.)*.05;\n    p2.x+=floor(p2.y)*.5;\n\n    vec2 fp2=fract(p2);\n    float brick=length(max(vec2(0.0),abs(fp2-vec2(0.5))-vec2(0.46,0.43))*vec2(2,1));\n    return mix(texture(iChannel3, p2.xy*.2).xyz, vec3(.0),smoothstep(0.0,0.1,brick));\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 material(vec3 p, vec3 nor)\n{\n\n    if (house(p) <= 0.2)\n    {\n        if (nor.y> .3 && nor.y < .8) return vec3(.1);\n        if (doorHit)\n            return vec3(.0,.1,0.1);\n        else\n            return (nor.z > .8)? brickt(p.xy*vec2(.065, .1))*.5:brickt(p.zy*vec2(.065, .1));\n\n    }\n    \n\n    float n = fbm(p.xz*.025);\n\n    vec3 mat = vec3(n*.8);\n    float g = fbm(p.xz*.006);\n\n    mat  = mat*g*.3;\n    mat  = mix(mat, min(vec3(1),vec3(.2+nor.y)), smoothstep(.91, .99, nor.y));\n    \n    return mat+vec3(0.04,0.04,nor.y*.1);\n}\n\n\n\n//-------------------------------------------------------------------------------------------------------\nfloat rayMarch(in vec3 rO, in vec3 rD, in float t)\n{\n\tfloat d;\n    float adj = .2;// Estimate error adjust starts very small\n    doorHit = false;\n    smokeDist = -1.0;\n    \n    #ifdef RENDERED_VERSION\n    for(int j = ZERO; j < 320 && t < FAR; j++)\n    #else\n    for(int j = ZERO; j < 260 && t < FAR; j++)\n    #endif\n\t{\n        d = map(rO + t*rD, t);\n        if (abs(d) < .2) break;\n        t += d * adj;\n        adj += .001;\n\t}\n \n\treturn t;\n}\n\n\nfloat collectSmoke(in vec3 rO, in vec3 rD, in float d)\n{\n    \n    float a = 0.0;\n   \n    for(int j = ZERO; j < 50; j++)\n\t{\n        vec3 pos = rO + rD * d;\n        \n        float h = smokeCone(pos)-.1;\n        if (h > 0.0) break;\n        float n = noise13(pos*.02-vec3(gTime*.3,gTime*.2,0));\n        \n        a += .03 * n*n*3. * smoothstep(1300.0, 400.0, pos.y);\n        if (a > 1.0 )\n        {\n            break;\n        }\n        d += 3.;\n     }\n     return clamp(a, 0.0, 1.0);\n}\n\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = getStore(DATA_CHANNEL,GLOBAL_TIME).x;\n    gTime += hash12(fragCoord)*.2;\n    sunDir = getStore(DATA_CHANNEL, SUN_DIR).xyz;\n    vec4 temp= getStore(DATA_CHANNEL, SUN_COLOUR);\n    sunColour = temp.xyz;\n    sunUp = max(temp.w, 0.0);\n    houseVisible = false;\n\n    vec4 te = getStore(DATA_CHANNEL, GLOBAL_TIME);\n    gTime = te.x;\n    roll = te.y;\n\n    vec2 xy = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x / iResolution.y, 1.0);\n    camRay = getCamera(uv);\n\n    vec3 col = getSky(camRay);\n    //col = vec3(.5);\n    \n    float dis = rayMarch(cameraPos, camRay, hash12(fragCoord)*1.);\n    \n    float godBri = 0.0;\n\n    \n    if (dis < FAR)\n    {\n        vec3 pos = cameraPos+camRay * dis;\n        float d = dis*.0001;\n        vec3 nor = getNormal(pos, dis);\n        col = material(pos,nor) * lighting(pos, nor, sunDir, dis);\n        col = mix(FOG_COLOUR*sunUp, col, exp(-d*d*1.2));\n    }else\n    {\n        godBri = 1.0;\n    }\n    //col = clamp(col, 0.0, 1.0);\n    \n    if (smokeDist > 0.0)\n    {\n        //col = clamp(col, 0.0, 1.0);\n        col = mix(col, vec3(0), collectSmoke(cameraPos, camRay, smokeDist)*.6);\n    }\n\n    col = clamp(col, 0.0, 1.0);\n    //col = col*col*(3.0-2.0*col);\n\n    vec3 lamp = (houseLight - cameraPos);\n    float d  = length(lamp);\n    \n    if (d< dis+40.)\n    {\n        lamp /= d;\n        float l = max(dot(lamp, camRay), 0.0);\n        col += pow(l, 8000.0)*.2 * LIGHT_COLOUR;\n     }\n     #ifdef DEBUG\n     col = mix(col, hash31(iterations*30.), .2); \n     #endif\n    \n    \n    float localFog = sphereFog(cameraPos, camRay, camHouse+ vec3(0,0,40), 300.0, dis);\n    \n    col += pow(localFog, 2.0) * vec3(1, .5 , .3)*.1;\n    \n//    float sphereFog( vec3  ro, vec3  rd,   // ray origin, ray direction\n//                  vec3  sc, float sr,   // sphere center, sphere radius\n//                  float dbuffer )       // depth buffer\n\n    \n    \n\n\n    fragColor = vec4(col,godBri);\n     \n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGyWV.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[505, 505, 524, 524, 715], [718, 838, 862, 862, 1348], [1350, 1456, 1481, 1481, 1587], [1782, 1782, 1893, 1893, 2616], [2618, 2618, 2646, 2646, 3550], [3553, 3659, 3716, 3716, 4732]], "test": "untested"}
{"id": "mtccR8", "name": "Projet infographie M1 info", "author": "smirboulack", "description": "Projet réalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590", "tags": ["projetinfographie"], "likes": 0, "viewed": 116, "published": 3, "date": "1699543531", "time_retrieved": "2024-07-30T17:23:13.313103", "image_code": "/*\n\nRéalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590 UCBL LYON 1 - 2023\n\nPyramide réalisé en suivant les instructions : \n - https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution.html\n - https://www.shadertoy.com/view/MlGcDz\n*/\n\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\n// Structure représentant un disque\nstruct Disque_cylindre {\n    vec3 centre; // Centre du disque\n    vec3 normal; // Normale du disque\n    float rayon; // Rayon du disque\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un cylindre\nstruct Cylinder {\n    vec3 c; // Centre de la base du cylindre\n    vec3 top; // Point du haut du cylindre\n    float r; // Rayon du cylindre\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un tore\nstruct Tore {\n    vec3 c; // Centre du tore\n    vec2 t; // Rayons majeur et mineur du tore\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant une capsule\nstruct Capsule {\n    vec3 a; // Point de départ de la capsule\n    vec3 b; // Point de fin de la capsule\n    float r; // Rayon de la capsule\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un ellipsoïde\nstruct Ellipsoid {\n    vec3 c; // Centre de l'ellipsoïde\n    vec3 r; // Rayons dans les directions x, y et z\n    int i; // Identifiant de la texture\n};\n\nstruct Triangle {\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\nstruct Pyramid {\n    Triangle sides[4]; // Un pyramide avec une base carrée a 4 côtés triangulaires\n    int i; // Identifiant de texture\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\n//Matrices de rotation\nmat3 rotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s,\n        oc * axis.y * axis.x + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.z * axis.y + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    float reflectivity; // Reflectivity coefficient, 0.0 for matte, 1.0 for fully reflective\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\n\nvec3 Damier(vec3 p, float sideSize) {\n    vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n    vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n\n    // Déterminer l'indice de la case dans laquelle se trouve le point\n    ivec3 boxIndex = ivec3(floor(p / sideSize));\n\n    // Calculer si la somme des indices de la case est paire ou impaire\n    int checker = int(boxIndex.x + boxIndex.y + boxIndex.z) % 2;\n\n    // Retourner la couleur correspondante\n    return checker == 0 ? color1 : color2;\n}\n\nvec3 StripedTexture(vec3 p, vec3 color1, vec3 color2, float stripeWidth) {\n    // Calculer le motif à rayures en fonction de la coordonnée x\n    float pattern = sin(p.x * stripeWidth);\n\n    // Déterminer si nous sommes dans une rayure ou non\n    float stripe = step(0.5, pattern);\n\n    // Mélanger les deux couleurs en fonction de la valeur de la rayure\n    return mix(color1, color2, stripe);\n}\n\nMaterial TexturePlane(vec3 p, int i) {\n    if (i == 0) {\n        // Définir les couleurs pour les rayures\n        vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n        vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n        float stripeWidth = 3.1415 * 2.0; // Largeur des rayures\n\n        // Obtenir la texture à rayures\n        vec3 col = StripedTexture(p, color1, color2, stripeWidth);\n        return Material(col, 0.0); // Matériau non réfléchissant\n    }\n    // Ajouter d'autres cas de textures si nécessaire\n    return Material(vec3(0), 0.0); // Matériau mat par défaut\n}\n\n//Texture arc-en-ciel\nvec3 RainbowTexture(vec3 p) {\n    float pi = 3.14159265359; // Définir la valeur de pi\n\n    // S'assurer que la coordonnée Y est entre 0 et 1\n    float y = mod(p.y, 1.0); \n\n    // Convertir y en une valeur entre 0 et 2*pi\n    float angle = 2.0 * pi * y;\n\n    // Calculer les valeurs RGB en utilisant des fonctions trigonométriques\n    float r = 0.5 * sin(angle) + 0.5; // Calculer la composante rouge\n    float g = 0.5 * sin(angle + 2.0 * pi / 3.0) + 0.5; // Calculer la composante verte\n    float b = 0.5 * sin(angle + 4.0 * pi / 3.0) + 0.5; // Calculer la composante bleue\n    vec3 color = vec3(r, g, b); // Combiner les composantes RGB en une couleur\n    // Retourner la couleur\n    return color;\n}\n\n// Fonction de bruit simple\nfloat noise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Fonction de texture d'herbe\nvec3 GrassTexture(vec3 p) {\n    // Couleur de base de l'herbe\n    vec3 grassColor = vec3(0.1, 0.5, 0.1);\n\n    // Ajouter une variation de couleur\n    float variation = noise(p.xz * 5.0); // Ajuster l'échelle pour contrôler la fréquence de variation\n    grassColor *= 0.7 + 0.3 * variation; // Assombrir et éclaircir la couleur de base\n\n    // Ajouter des taches plus sombres pour simuler des ombres ou différents types d'herbe\n    float darkPatches = smoothstep(0.4, 0.6, noise(p.xz * 10.0)); // Ajuster l'échelle pour la taille des taches\n    grassColor *= mix(vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0), darkPatches);\n\n    return grassColor;\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif concentrique basé sur la distance au centre\n    float distToCenter = length(p - centerPoint);\n    float concentricValue = sin(distToCenter * frequency);\n\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Combiner les deux motifs\n    float pattern = (concentricValue + radialValue) * 0.5;\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(vec3(0.2, 0.4, 0.6), vec3(0.8, 0.6, 0.4), (pattern + 1.0) * 0.5);\n\n    return color;\n}\n\nvec3 RadialTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n\n    return color;\n}\n\nvec3 multicolorTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n    // Couleur rouge\n    vec3 color3 = vec3(1.0, 0.0, 0.0);\n    // Couleur bleue\n    vec3 color4 = vec3(0.0, 0.0, 1.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n    color = mix(color, color3, pattern);\n    color = mix(color, color4, pattern);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(.8, .5, .4), 0.5); // Matte material\n    }else if(i==2){\n         return Material(Damier(p, 0.5), 0.5);\n    } else if(i==3){\n        return Material(ConcentricTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2);\n    }\n    else if(i==4){\n        return Material(RainbowTexture(p),0.4);\n    }\n    else if(i==5){\n        return Material(StripedTexture(p, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 3.1415 * 2.0), 0.5);\n    }\n    else if(i==6){\n        return Material(RadialTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2);\n    }\n    else if(i==7){\n        //mirror\n        return Material(vec3(0.0, 0.0, 0.0), 1.0);\n    }else if(i==8){\n        //uniform yellow\n        return Material(vec3(1.0, 1.0, 0.0), 0.0);\n    }\n    else if (i == 0) {\n        /* float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col, 0.0); // Non-reflective material */\n        return Material(GrassTexture(p), 0.3); // Non-reflective grass material\n    }\n    // Add more materials with different reflectivity as needed\n\n    return Material(vec3(0), 0.0); // Default matte material\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectRotatingSphere(Ray ray, Sphere sph, out Hit x, float angle, vec3 axis) {\n    // 1. Calculer le centre de la sphère\n    vec3 center = sph.c;\n\n    // 2. Calculez la matrice de rotation en fonction de l'axe et de l'angle spécifiés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transform ray\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si la sphère n'était pas tournée\n    if (IntersectSphere(transformedRay, sph, x)) {\n        return true;\n    }\n    return false;\n}\n\nvoid translateSphere(out Sphere s, vec3 maxTranslation, float translation_speed, float time) {\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    s.c += maxTranslation * oscillation;\n}\n\n\nvoid rotateSphere(out Sphere s, float angle, vec3 axis) {\n    axis = normalize(axis); // Assurez-vous que l'axe est normalisé\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    s.c = s.c * cosTheta +\n        cross(axis, s.c) * sinTheta +\n        axis * dot(axis, s.c) * (1.0 - cosTheta);\n}\n\nvoid scaleSphere(out Sphere s, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float scaleFactor = mix(scaleMin, scaleMax, 0.5 * (1.0 + sin(time * scale_speed)));\n\n    s.r *= scaleFactor;\n}\n\nbool IntersectDisqueCylindre(Ray ray, Disque_cylindre d, out Hit x) {\n    float t = -dot(ray.o - d.centre, d.normal) / dot(ray.d, d.normal);\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        if (distance(p, d.centre) <= d.rayon) {\n            x = Hit(t, d.normal, d.i);\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\n\nbool intersectCylinder(Ray ray, Cylinder cylinder, out Hit hit) {\n\n    // Calculer le décalage entre l'origine du rayon et le centre du cylindre\n    vec3 oc = ray.o - cylinder.c;\n\n    // Extraire les composantes x et y de la direction du rayon\n    vec2 dxy = ray.d.xy;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y;\n    float b = 2. * (oc.x * ray.d.x + oc.y * ray.d.y);\n    float c = oc.x * oc.x + oc.y * oc.y - cylinder.r * cylinder.r;\n\n    // Calculer le discriminant de l'équation quadratique\n    float discriminant = b * b - 4.0 * a * c;\n\n    // Si le discriminant est positif, le rayon intersecte le cylindre\n    if (discriminant > 0.0) {\n\n        // Calculer les deux points d'intersection possibles\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Choisir le point d'intersection le plus proche\n        float t = min(t1, t2);\n\n        // Vérifier si le point d'intersection est devant le rayon et à l'intérieur de la hauteur du cylindre\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            if (p.z > cylinder.c.z && p.z < cylinder.top.z) {\n\n                // Calculer le vecteur normal au point d'intersection\n                vec3 u = cylinder.top - cylinder.c;\n                vec3 q = cylinder.c + (dot(u, p - cylinder.c) / dot(u, u)) * u;\n                vec3 n = normalize(p - q);\n\n                // Stocker les détails de l'intersection dans la structure hit\n                hit.t = t;\n                hit.n = n;\n                hit.i = cylinder.i;\n\n                return true;\n            }\n        }\n\n        // Si le rayon pointe vers le haut, vérifier l'intersection avec le disque inférieur du cylindre\n        if (ray.d.z > 0.0) {\n            Disque_cylindre disque = Disque_cylindre(cylinder.c, vec3(0., 0., -1), cylinder.r, cylinder.i);\n            if (IntersectDisqueCylindre(ray, disque, hit)) {\n                return true;\n            }\n        } \n        // Si le rayon pointe vers le bas, vérifier l'intersection avec le disque supérieur du cylindre\n        else {\n            Disque_cylindre disque = Disque_cylindre(cylinder.top, vec3(0., 0., 1), cylinder.r, cylinder.i);\n            if (IntersectDisqueCylindre(ray, disque, hit)) {\n                return true;\n            }\n        }\n    }\n\n    // Si aucune intersection n'a été trouvée, retourner false\n    return false;\n}\n\n\nbool IntersectCylinderRotation(Ray ray, Cylinder cyl, float angleX, float angleY, float angleZ, out Hit hit) {\n    // 1. Calculer le centre du cylindre\n    vec3 center = 0.5 * (cyl.c + cyl.top);\n\n    // 2. Calculez les matrices de rotation pour chaque axe\n    mat3 rotX = rotationMatrix(vec3(1, 0, 0), angleX);\n    mat3 rotY = rotationMatrix(vec3(0, 1, 0), angleY);\n    mat3 rotZ = rotationMatrix(vec3(0, 0, 1), angleZ);\n\n    // Multipliez les matrices de rotation pour obtenir une matrice composite\n    mat3 compositeRotation = rotZ * rotY * rotX;\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(compositeRotation); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace du cylindre rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si le cylindre n'était pas tourné\n    if (intersectCylinder(transformedRay, cyl, hit)) {\n        return true;\n    }\n    return false;\n}\n\nvoid TranslateCylinder(inout Cylinder cyl, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    cyl.c += translation;\n    cyl.top += translation;\n}\n\n\nvoid ScaleCylinder(out Cylinder cyl, float scaleFactorAxis, float scaleFactorRadius, float scaleSpeed, float time) {\n    vec3 center = 0.5 * (cyl.c + cyl.top);\n\n    float oscillationAxis = 0.5 * sin(time * scaleSpeed) + 1.5; // Oscille entre 1.0 et 2.0\n    float oscillationRadius = 0.5 * sin(time * scaleSpeed) + 1.5; // Oscille entre 1.0 et 2.0\n\n    float finalScaleFactorAxis = scaleFactorAxis * oscillationAxis;\n    float finalScaleFactorRadius = scaleFactorRadius * oscillationRadius;\n\n    cyl.c = center + (cyl.c - center) * finalScaleFactorAxis;\n    cyl.top = center + (cyl.top - center) * finalScaleFactorAxis;\n    cyl.r *= finalScaleFactorRadius;\n}\n\n\nvoid RotateCylinder(out Cylinder cyl, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    cyl.c = cyl.c * cosTheta +\n        cross(axis, cyl.c) * sinTheta +\n        axis * dot(axis, cyl.c) * (1.0 - cosTheta);\n    cyl.top = cyl.top * cosTheta +\n        cross(axis, cyl.top) * sinTheta +\n        axis * dot(axis, cyl.top) * (1.0 - cosTheta);\n}\n\n// Signed distance function for a torus\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nbool IntersectTorus(Ray ray, Tore tor, out Hit x) {\n    float tMin = 0.0; // Distance minimale pour l'intersection\n    float tMax = 1000.0; // Distance maximale arbitraire pour l'intersection\n    float epsilon = 0.001; // Petite valeur pour vérifier la proximité à la surface\n    float tCurrent = tMin;\n\n    // Ray marching loop\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = Point(ray, tCurrent); // Point sur le rayon à la distance tCurrent\n        vec3 localP = p - tor.c; // Convertir le point en coordonnées locales du tore\n\n        // Calcul de la distance signée du point au tore\n        float dist = sdTorus(localP, tor.t);\n\n        // Si la distance est inférieure à epsilon, on a une intersection\n        if (abs(dist) < epsilon) {\n            // Approximation of the normal using the gradient of the SDF\n            vec3 nor = normalize(vec3(\n                sdTorus(localP + vec3(epsilon, 0.0, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, epsilon, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, 0.0, epsilon), tor.t) - dist\n            ));\n\n            // Stocker les informations d'intersection dans la structure Hit\n            x = Hit(tCurrent, nor, tor.i);\n            return true; // Intersection trouvée\n        }\n\n        // Avancer le long du rayon de la distance calculée\n        tCurrent += dist;\n\n        // Si on dépasse tMax, il n'y a pas d'intersection\n        if (tCurrent >= tMax) {\n            return false;\n        }\n    }\n\n    // Si on sort de la boucle sans trouver d'intersection\n    return false;\n}\n\n\nbool IntersectTorusRotation(Ray ray, Tore tor, float angle, vec3 axis, out Hit hit) {\n    // Obtenir le centre du tore\n    vec3 center = tor.c;\n\n    // Calculer la matrice de rotation basée sur l'axe et l'angle donnés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculer la matrice de rotation inverse pour transformer le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformer le rayon pour le positionner dans l'espace du tore rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = normalize(invRot * ray.d);\n\n    // Effectuer l'intersection comme si le tore n'avait pas été tourné\n    return IntersectTorus(transformedRay, tor, hit);\n}\n\nbool IntersectTorusRotation2(Ray ray, Tore tor, float anglex, float angley, float anglez, out Hit hit) {\n    // Calculer le centre du tore\n    vec3 center = tor.c;\n\n    // Calculez la matrice de rotation\n    mat3 rot = rotationMatrixX(anglex) * rotationMatrixY(angley) * rotationMatrixZ(anglez);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace du tore rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuez l'intersection comme si le tore n'était pas tourné\n    return IntersectTorus(transformedRay, tor, hit);\n}\n\nvoid translateTorus(inout Tore tor, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n    tor.c += translation;\n}\n\nvoid scaleTorus(inout Tore tor, float scalespeed, float minscale, float maxscale, float time) {\n\n    // Calculer le facteur d'oscillation\n    float oscillation = 0.5 * sin(time * scalespeed) + 0.5; // Oscille entre 0 et 1\n\n    // Adapter l'oscillation pour qu'elle varie entre minscale et maxscale\n    float scaleFactor = mix(minscale, maxscale, oscillation);\n\n    tor.t *= scaleFactor;\n}\n\nvoid rotateTore(out Tore tor, vec3 origin, float rayon, float time) {\n    float angle = time; // Vous pouvez ajuster la vitesse de rotation en multipliant \"time\" par un facteur\n\n    // Calculer la position relative du tore par rapport à \"origin\"\n    vec3 relativePos = tor.c - origin;\n\n    // Trouver une position sur le cercle de rotation\n    tor.c.x = origin.x + rayon * cos(angle);\n    tor.c.y = origin.y + rayon * sin(angle);\n    tor.c.z = origin.z; // Assumons que le mouvement est dans le plan XY\n\n    // Ajouter le décalage pour centrer le tore autour du point d'origine\n    tor.c += relativePos;\n}\n\n\n/**\n * Vérifie si un rayon intersecte une capsule.\n * La capsule est définie par deux sphères (aux extrémités) et un cylindre (au milieu).\n * La fonction teste d'abord l'intersection avec les sphères, puis avec le cylindre.\n * Si une intersection est trouvée, les informations d'intersection sont stockées dans la structure 'Hit'.\n *\n * @param ray Le rayon à tester pour l'intersection.\n * @param capsule La capsule avec laquelle tester l'intersection.\n * @param x Structure de sortie pour stocker les informations d'intersection si une intersection est trouvée.\n * @return 'true' si une intersection est trouvée, 'false' sinon.\n */\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n\n    // Créer deux sphères représentant les extrémités de la capsule\n    Sphere s1 = Sphere(capsule.a, capsule.r, capsule.i);\n    Sphere s2 = Sphere(capsule.b, capsule.r, capsule.i);\n\n    Hit hit1;\n    Hit hit2;\n    // Tester l'intersection avec les deux sphères\n    bool intersectS1 = IntersectSphere(ray, s1, hit1);\n    bool intersectS2 = IntersectSphere(ray, s2, hit2);\n\n    // Calculer la direction entre les deux centres des sphères\n    vec3 ba = capsule.b - capsule.a;\n    vec3 oa = ray.o - capsule.a;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, ba), 2.0) / dot(ba, ba);\n    float b = 2.0 * (dot(ray.d, oa) - (dot(ray.d, ba) * dot(oa, ba)) / dot(ba, ba));\n    float c = dot(oa, oa) - pow(dot(oa, ba), 2.0) / dot(ba, ba) - capsule.r * capsule.r;\n\n    // Calculer le discriminant\n    float h = b * b - 4.0 * a * c;\n\n    // Si le discriminant est positif, il y a une intersection avec le cylindre de la capsule\n    if (h >= 0.0) {\n        float t1 = (-b - sqrt(h)) / (2.0 * a);\n        float t2 = (-b + sqrt(h)) / (2.0 * a);\n\n        // Choisir le point d'intersection le plus proche\n        float t = (t1 > 0.0) ? t1 : t2;\n\n        // Calculer le point d'intersection\n        vec3 pt = Point(ray, t);\n        // Projeter ce point sur la ligne reliant les centres des sphères\n        vec3 projection = capsule.a + (dot(pt - capsule.a, ba) / dot(ba, ba)) * ba;\n\n        // Vérifier si le point projeté est entre les deux centres des sphères\n        if (t > 0.0 && dot(ba, projection - capsule.a) > 0.0 && dot(-ba, projection - capsule.b) > 0.0) {\n            x = Hit(t, normalize(pt - projection), capsule.i);\n            return true;\n        }\n    }\n\n    // Si l'intersection avec la première sphère est valide et plus proche que la deuxième\n    if (intersectS1 && (intersectS2 && hit1.t < hit2.t || !intersectS2)) {\n        x = hit1;\n        return true;\n    }\n\n    // Si l'intersection avec la deuxième sphère est valide\n    if (intersectS2) {\n        x = hit2;\n        return true;\n    }\n\n    // Si aucune intersection n'a été trouvée\n    return false;\n}\n\n\nbool IntersectCapsuleRotate(Ray ray, Capsule cap, float angle, vec3 axis, out Hit hit) {\n    // Calculer le centre de la capsule\n    vec3 center = 0.5 * (cap.a + cap.b);\n\n    // Calculer la matrice de rotation basée sur l'axe et l'angle donnés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculer la matrice de rotation inverse pour transformer le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformer le rayon pour le positionner dans l'espace de la capsule rotative\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuer l'intersection comme si la capsule n'avait pas été tournée\n    return IntersectCapsule(transformedRay, cap, hit);\n}\n\nvoid translateCapsule(inout Capsule cap, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    cap.a += translation;\n    cap.b += translation;\n}\n\nvoid scaleCapsule(inout Capsule cap, float minscale, float maxscale, float time) {\n    float scaleSpeed = 4.0;\n    float oscillation = 0.5 * sin(time * scaleSpeed) + 0.5;\n    float scaleFactor = mix(minscale, maxscale, oscillation);\n\n    vec3 midPoint = (cap.a + cap.b) * 0.5;\n    cap.a = midPoint + (cap.a - midPoint) * scaleFactor;\n    cap.b = midPoint + (cap.b - midPoint) * scaleFactor;\n    cap.r *= scaleFactor;\n}\n\n\nvoid rotateCapsule(inout Capsule cap, float angleSpeed, float time) {\n    float theta = angleSpeed * time;\n\n    // Matrice de rotation autour de l'axe Y\n    mat3 rotationMatrix = mat3(\n        cos(theta), 0, sin(theta),\n        0, 1, 0,\n        -sin(theta), 0, cos(theta)\n    );\n\n    cap.a = rotationMatrix * cap.a;\n    cap.b = rotationMatrix * cap.b;\n}\n\n/**\n * Vérifie si un rayon intersecte un ellipsoïde.\n * Si une intersection est trouvée, les informations d'intersection sont stockées dans la structure 'Hit'.\n *\n * @param ray Le rayon à tester pour l'intersection.\n * @param ell L'ellipsoïde avec lequel tester l'intersection.\n * @param x Structure de sortie pour stocker les informations d'intersection si une intersection est trouvée.\n * @return 'true' si une intersection est trouvée, 'false' sinon.\n */\nbool IntersectEllipsoid(Ray ray, Ellipsoid ell, out Hit x) {\n    // Calculer le vecteur entre l'origine du rayon et le centre de l'ellipsoïde\n    vec3 ro = ray.o - ell.c;\n    vec3 rd = ray.d;\n\n    // Calculer l'inverse des rayons de l'ellipsoïde\n    vec3 invR = 1.0 / ell.r;\n    // Transformer l'origine et la direction du rayon par l'inverse des rayons de l'ellipsoïde\n    vec3 ood = ro * invR;\n    vec3 d = rd * invR;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float A = dot(d, d);\n    float B = 2.0 * dot(d, ood);\n    float C = dot(ood, ood) - 1.0;\n\n    // Calculer le discriminant de l'équation quadratique\n    float det = B * B - 4.0 * A * C;\n\n    // Si le discriminant est positif, il y a une intersection\n    if (det > 0.) {\n        float t = (-B - sqrt(det)) / (2.0 * A);\n        // Vérifier si le point d'intersection est en avant du rayon\n        if (t > 0.) {\n            // Calculer le point d'intersection\n            vec3 p = Point(ray, t);\n            // Calculer la normale à la surface de l'ellipsoïde au point d'intersection\n            vec3 normal = normalize(2.0 * (p - ell.c) * invR);\n\n            // Stocker les informations d'intersection dans la structure Hit\n            x = Hit(t, normal, ell.i);\n            return true;\n        }\n    }\n\n    // Si aucune intersection n'a été trouvée\n    return false;\n}\n\nbool IntersectEllipsoidRotate(Ray ray, Ellipsoid ell, float angle, vec3 axis, out Hit hit) {\n    // Calculez la matrice de rotation\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace de l'ellipsoïde rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - ell.c) + ell.c; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuez l'intersection comme si l'ellipsoïde n'était pas tourné\n    return IntersectEllipsoid(transformedRay, ell, hit);\n}\n\n\nvoid translateEllipsoid(inout Ellipsoid ell, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    ell.c += translation;\n}\n\nvoid scaleEllipsoid(inout Ellipsoid ell, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float oscillation = 0.5 * (1.0 + sin(time * scale_speed));\n    float scaleFactor = mix(scaleMin, scaleMax, oscillation);\n\n    ell.r *= scaleFactor;\n}\n\n\nvoid rotateEllipsoid(inout Ellipsoid ell, float angleSpeed, float time) {\n    float theta = angleSpeed * time;\n\n    // Matrice de rotation autour de l'axe Y\n    mat3 rotationMatrix = mat3(\n        cos(theta), 0, sin(theta),\n        0, 1, 0,\n        -sin(theta), 0, cos(theta)\n    );\n\n    // Appliquer la rotation à la position de l'ellipsoïde\n    ell.r = rotationMatrix * ell.r;\n}\n\n// Intersection de triangle\nbool IntersectTriangle(Ray ray, Triangle triangle, out Hit x) {\n    // Calcul des vecteurs de côté du triangle\n    vec3 v1v0 = triangle.v1 - triangle.v0;\n    vec3 v2v0 = triangle.v2 - triangle.v0;\n    // Vecteur entre l'origine du rayon et le premier sommet du triangle\n    vec3 rov0 = ray.o - triangle.v0;\n\n    // Calcul de la normale du triangle\n    vec3 n = cross(v1v0, v2v0);\n    // Calcul du vecteur q pour l'intersection\n    vec3 q = cross(rov0, ray.d);\n    // Inverse du dénominateur pour l'intersection\n    float d = 1.0 / dot(ray.d, n);\n    // Calcul des coordonnées barycentriques u et v\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    // Calcul de la distance t le long du rayon jusqu'à l'intersection\n    float t = d * dot(-n, rov0);\n\n    // Vérification si l'intersection est à l'intérieur du triangle\n    if (u < 0.0 || v < 0.0 || (u + v) > 1.0) return false;\n\n    // Mise à jour de l'information de l'impact\n    x.t = t;\n    x.n = n;\n    x.i = 0; // L'identifiant de texture n'est pas utilisé dans cet exemple\n    return t >= 0.0;\n}\n\n\n// Intersection de pyramide\nbool IntersectPyramid(Ray ray, Pyramid pyramid, out Hit hit) {\n    // Initialisation de la distance d'impact à une valeur très élevée\n    hit.t = 1e10;\n    bool intersected = false;\n    Hit tempHit;\n\n    // Vérification de l'intersection avec chaque côté de la pyramide\n    for (int i = 0; i < 4; ++i) {\n        if (IntersectTriangle(ray, pyramid.sides[i], tempHit)) {\n            // Si une intersection plus proche est trouvée, mise à jour de l'impact\n            if (tempHit.t < hit.t) {\n                hit = tempHit;\n                hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n                intersected = true;\n            }\n        }\n    }\n\n    // Vérification de l'intersection avec la base de la pyramide, divisée en deux triangles\n    // Définition des sommets pour la base de la pyramide\n    vec3 pBase1 = pyramid.sides[0].v1; // On suppose que c'est le premier sommet de la base\n    vec3 pBase2 = pyramid.sides[1].v1; // On suppose que c'est le deuxième sommet de la base\n    vec3 pBase3 = pyramid.sides[2].v1; // On suppose que c'est le troisième sommet de la base\n    vec3 pBase4 = pyramid.sides[3].v1; // On suppose que c'est le quatrième sommet de la base\n\n    Triangle baseTri1, baseTri2;\n\n    // Attribution des sommets pour le premier triangle de la base\n    baseTri1.v0 = pBase1;\n    baseTri1.v1 = pBase3;\n    baseTri1.v2 = pBase2;\n\n    // Attribution des sommets pour le second triangle de la base\n    baseTri2.v0 = pBase1;\n    baseTri2.v1 = pBase4;\n    baseTri2.v2 = pBase3;\n\n    // Test d'intersection avec les triangles de la base\n    if (IntersectTriangle(ray, baseTri1, tempHit)) {\n        if (tempHit.t < hit.t) {\n            hit = tempHit;\n            hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n            intersected = true;\n        }\n    }\n\n    if (IntersectTriangle(ray, baseTri2, tempHit)) {\n        if (tempHit.t < hit.t) {\n            hit = tempHit;\n            hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n            intersected = true;\n        }\n    }\n\n    // Si une intersection a eu lieu, normalisation de la normale de l'impact\n    if (intersected) {\n        hit.n = normalize(hit.n);\n    }\n\n    return intersected;\n}\n\n\n// Fonction pour faire tourner un point en utilisant une matrice de rotation\nvec3 rotatePoint(mat3 m, vec3 p) {\n    return m * p;\n}\n\nbool IntersectRotatingPyramid(Ray ray, Pyramid pyramid, float angle, vec3 axis, out Hit hit) {\n    // Créer une matrice de rotation à partir de l'axe et de l'angle\n    mat3 rotMat = rotationMatrix(axis, angle);\n    \n    // Faire tourner les sommets de la pyramide\n    Pyramid rotatedPyr;\n    for (int i = 0; i < 4; ++i) {\n        rotatedPyr.sides[i].v0 = rotatePoint(rotMat, pyramid.sides[i].v0);\n        rotatedPyr.sides[i].v1 = rotatePoint(rotMat, pyramid.sides[i].v1);\n        rotatedPyr.sides[i].v2 = rotatePoint(rotMat, pyramid.sides[i].v2);\n    }\n    rotatedPyr.i = pyramid.i;\n    \n    // Utiliser la fonction existante IntersectPyramid ou une logique similaire ici\n    return IntersectPyramid(ray, rotatedPyr, hit);\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\n\nvec3 Background(vec3 rd) {\n    // Définir les couleurs du ciel : haut et horizon\n    vec3 skyTopColor = vec3(0.0, 0.5, 0.8); // Bleu profond\n    vec3 skyHorizonColor = vec3(0.7, 0.9, 1.0); // Bleu clair presque blanc\n\n    // Mélanger en fonction de la direction vers le haut (z dans ce cas)\n    // En supposant que rd est normalisé et que rd.z est dans l'intervalle [-1, 1]\n    float t = 0.5 * (rd.z + 1.0); // Échelle à l'intervalle [0, 1]\n    return mix(skyHorizonColor, skyTopColor, t); // Interpoler entre les couleurs de l'horizon et du haut\n}\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n// Fonction pour créer une pyramide avec un centre de base et une hauteur donnés\nvoid createPyramid(out Pyramid pyr, vec3 baseCenter, float baseSize, float height, int textureId) {\n    float halfBase = baseSize * 0.5;\n    vec3 pTop = baseCenter + vec3(0.0, height, 0.0); // Ajuster la hauteur pour le sommet supérieur\n    vec3 pBase1 = baseCenter + vec3(-halfBase, 0.0, halfBase);\n    vec3 pBase2 = baseCenter + vec3(halfBase, 0.0, halfBase);\n    vec3 pBase3 = baseCenter + vec3(halfBase, 0.0, -halfBase);\n    vec3 pBase4 = baseCenter + vec3(-halfBase, 0.0, -halfBase);\n\n    // Attribuer les sommets aux côtés de la pyramide\n    pyr.sides[0].v0 = pTop; pyr.sides[0].v1 = pBase1; pyr.sides[0].v2 = pBase2;\n    pyr.sides[1].v0 = pTop; pyr.sides[1].v1 = pBase2; pyr.sides[1].v2 = pBase3;\n    pyr.sides[2].v0 = pTop; pyr.sides[2].v1 = pBase3; pyr.sides[2].v2 = pBase4;\n    pyr.sides[3].v0 = pTop; pyr.sides[3].v1 = pBase4; pyr.sides[3].v2 = pBase1;\n    pyr.i = textureId; // Attribuer l'identifiant de texture pour la pyramide\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    Sphere sph1=Sphere(vec3(0.,0.,1.),1.,2);\n    Sphere sph2=Sphere(vec3(2.,0.,2.),1.,3);\n    rotateSphere(sph2,iTime,vec3(0.,0.0,1.));\n    \n    //Cylindre\n    Cylinder cyl1 = Cylinder(vec3(5.0, 6.0, 2.0), vec3(5.0, 6.0, 4.0), 1.0, 2);\n    \n    //Ellipsoid\n    Ellipsoid ell1 = Ellipsoid(vec3(0.0, 5.0, 1.0), vec3(1.0, 1.5, 0.5), 4);\n    \n    //Capsule\n    Capsule cap1 = Capsule(vec3(5.0, 0.0, 3.0), vec3(5.0, 0.0, 1.0), 0.5, 6);\n    translateCapsule(cap1, vec3(1.0, 1.0, 2.0), 2.0, iTime);\n    \n    //Tore\n    Tore tor1 = Tore(vec3(-3.0, 3.0, 3.5), vec2(1.0, 0.5), 7);\n    scaleTorus(tor1, 4.0, 0.5, 1.0,iTime);\n    //Pyramid\n    Pyramid pyramid;\n    createPyramid(pyramid,vec3(0.0, 0.0, 5.0), 2.0, 2.0, 4);\n    \n    //PLAN\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectRotatingPyramid(ray,pyramid,iTime,vec3(0.0, 0.0, 1.0),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray,cap1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectTorus(ray,tor1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoidRotate(ray,ell1,iTime,vec3(0.0, 0.0, 1.0),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinderRotation(ray,cyl1,iTime,0.0,0.0,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\n\n// Teste si le point est dans l'ombre\nbool InShadow(vec3 point, vec3 lightPos, out float shadowFactor)\n{\n    vec3 toLight = lightPos - point;\n    float distanceToLight = length(toLight);\n    toLight = normalize(toLight);\n\n    Ray shadowRay = Ray(point + toLight * 0.001, toLight); // Décalage pour éviter l'auto-intersection\n    Hit shadowHit;\n\n    // Vérifie les intersections avec n'importe quel objet de la scène\n    if (Intersect(shadowRay, shadowHit))\n    {\n        // Si l'intersection est plus proche que la lumière, le point est dans l'ombre\n        if (shadowHit.t < distanceToLight)\n        {\n            shadowFactor = 0.0; // Dans l'ombre\n            return true;\n        }\n    }\n\n    shadowFactor = 1.0; // Pas dans l'ombre\n    return false;\n}\n\n// Calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    float ao = 0.0;\n    float occlusion = 0.0;\n    float radius = 1.0; // Définit le rayon dans lequel vérifier l'occlusion\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction dans l'hémisphère\n        Ray aoRay = Ray(p + n * 0.001, d); // Décalage de l'origine un peu le long de la normale pour éviter l'auto-intersection\n\n        Hit aoHit;\n        if (Intersect(aoRay, aoHit) && aoHit.t < radius) {\n            occlusion += 1.0; // Ce rayon a frappé quelque chose, donc augmenter l'occlusion\n        }\n    }\n\n    ao = 1.0 - occlusion / float(N); // La fraction de rayons qui n'ont rien frappé\n    return ao;\n}\n\nvec3 PhongIllumination(Material m, vec3 n, vec3 v, vec3 lightPos, float shininess, vec3 point)\n{\n    float shadowFactor;\n    if (InShadow(point, lightPos, shadowFactor))\n    {\n        return vec3(0.0); // Dans l'ombre, pas de composante diffuse ou spéculaire\n    }\n\n    vec3 ambient = 0.5 * m.d; // Couleur ambiante\n\n    // Composante diffuse\n    vec3 l = normalize(lightPos - point);\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * m.d * shadowFactor;\n\n    // Composante spéculaire\n    vec3 r = reflect(-l, n); // Réfléchir le vecteur lumineux sur la normale\n    float spec = pow(max(dot(r, v), 0.0), shininess);\n    vec3 specular = vec3(1.0) * spec * shadowFactor; // En supposant des reflets spéculaires blancs\n\n    return ambient + diffuse + specular;\n}\n\n// Applique le modèle de couleur avec l'illumination de Phong et les ombres\nvec3 Color(Material m, vec3 n, vec3 v, vec3 point)\n{\n    // Définit les positions des lumières\n    vec3 lightPos1 = vec3(1, 10, 10); // Position de la première lumière\n    \n    // Calcule la direction de vue\n    vec3 viewDir = normalize(v); // Calcule la direction de vue\n    \n    // Calcule l'occlusion ambiante avant l'éclairage direct\n    float ao = AmbientOcclusion(point, n, 16); // Utilisation de 16 échantillons pour l'AO\n\n    // Illumination de Phong avec ombres pour la première lumière\n    vec3 col = PhongIllumination(m, n, viewDir, lightPos1, 10.0, point);\n\n    // Applique l'occlusion ambiante à la couleur finale\n    col *= ao;\n\n    return col;\n}\n\n// Rendu\nvec3 Shade(Ray ray)\n{\n    vec3 color = vec3(0.0); // Initialise la couleur à noir\n    vec3 attenuation = vec3(1.0); // Commence sans atténuation\n\n    // Intersect contient toute la détection géométrique\n    Hit x;\n    bool hitSomething = Intersect(ray, x);\n    \n    if (hitSomething)\n    {\n        vec3 p = Point(ray, x.t); // Point d'intersection\n        Material mat = Texture(p, x.i);\n        \n        // Calcule la direction de vue\n        vec3 viewDir = normalize(-ray.d);\n        \n        // Calcule la couleur avec l'illumination de Phong et les ombres\n        color += attenuation * Color(mat, x.n, viewDir, p);\n\n        // Si le matériau est réfléchissant, calcule la réflexion\n        if (mat.reflectivity > 0.0)\n        {\n            // Calcule la direction de réflexion et crée un nouveau rayon\n            vec3 reflectedDir = reflect(ray.d,x.n);\n            Ray reflectedRay = Ray(p + reflectedDir * 0.001, reflectedDir); // Décalage pour éviter l'auto-intersection\n            \n            // Effectue un test d'intersection secondaire pour le rayon réfléchi\n            Hit reflectedHit;\n            if (Intersect(reflectedRay, reflectedHit))\n            {\n                vec3 reflectedPoint = Point(reflectedRay, reflectedHit.t);\n                Material reflectedMat = Texture(reflectedPoint, reflectedHit.i);\n                vec3 reflectedViewDir = normalize(-reflectedRay.d);\n                \n                // Calcule la couleur au point d'intersection du rayon réfléchi\n                vec3 reflectedColor = Color(reflectedMat, reflectedHit.n, reflectedViewDir, reflectedPoint);\n                \n                // Mélange la couleur réfléchie avec la couleur actuelle en fonction de la réflectivité du matériau\n                color = mix(color, reflectedColor, mat.reflectivity);\n            }\n            else\n            {\n                // S'il n'y a pas d'intersection pour le rayon réfléchi, utilise la couleur de fond\n                color = mix(color, Background(reflectedRay.d), mat.reflectivity);\n            }\n        }\n    }\n    else\n    {\n        color = Background(ray.d);\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtccR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1896, 1919, 1954, 1954, 2093], [2095, 2095, 2130, 2130, 2269], [2271, 2271, 2306, 2306, 2445], [2447, 2447, 2492, 2492, 2906], [3046, 3046, 3073, 3094, 3262], [3264, 3362, 3396, 3396, 3753], [3756, 3815, 3844, 3844, 3872], [3874, 3874, 3907, 3907, 3927], [3929, 3929, 3966, 3966, 4429], [4431, 4431, 4505, 4573, 4830], [4832, 4832, 4870, 4870, 5429], [5431, 5453, 5482, 5482, 6157], [6159, 6187, 6209, 6209, 6282], [6284, 6315, 6342, 6376, 6964], [6966, 6966, 7044, 7102, 7744], [7746, 7746, 7820, 7944, 8482], [8484, 8484, 8562, 8686, 9426], [9428, 9479, 9512, 9512, 10691], [10693, 10776, 10828, 10828, 11168], [11170, 11170, 11256, 11299, 11988], [11990, 11990, 12084, 12084, 12196], [12199, 12199, 12256, 12256, 12509], [12511, 12511, 12606, 12652, 12767], [12769, 12769, 12838, 12838, 13129], [13132, 13132, 13197, 13277, 15616], [15619, 15619, 15729, 15770, 16771], [16773, 16773, 16875, 16907, 17101], [17104, 17104, 17220, 17220, 17761], [17764, 17764, 17827, 17827, 18178], [18180, 18220, 18251, 18251, 18325], [18327, 18327, 18378, 18378, 19912], [19915, 19915, 20000, 20033, 20757], [20759, 20759, 20863, 20897, 21586], [21588, 21588, 21683, 21715, 21881], [21883, 21883, 21978, 22020, 22271], [22273, 22273, 22342, 22342, 22880], [22883, 23527, 23587, 23661, 25735], [25738, 25738, 25826, 25866, 26608], [26610, 26610, 26710, 26742, 26934], [26936, 26936, 27018, 27018, 27354], [27357, 27357, 27426, 27426, 27710], [27712, 28178, 28238, 28320, 29542], [29544, 29544, 29636, 29675, 30282], [30285, 30285, 30389, 30421, 30587], [30589, 30589, 30694, 30740, 30894], [30897, 30897, 30970, 30970, 31279], [31281, 31309, 31372, 31421, 32387], [32390, 32418, 32480, 32555, 34690], [34693, 34770, 34804, 34804, 34824], [34826, 34826, 34920, 34991, 35552], [35555, 35637, 35688, 35688, 35851], [35853, 35853, 35879, 35934, 36406], [36410, 36479, 36519, 36519, 36695], [36697, 36780, 36879, 36879, 37726], [37728, 37810, 37845, 37860, 39640], [39643, 39681, 39747, 39747, 40404], [40406, 40440, 40487, 40487, 41139], [41141, 41141, 41237, 41237, 41919], [41921, 41998, 42050, 42094, 42667], [42669, 42678, 42699, 42699, 44841], [44843, 44843, 44897, 44994, 45460]], "test": "untested"}
{"id": "DldyRs", "name": "Siri Light", "author": "Peace", "description": "Siri Light", "tags": ["light", "siri"], "likes": 0, "viewed": 65, "published": 3, "date": "1699543326", "time_retrieved": "2024-07-30T17:23:14.080052", "image_code": "const float TAU = 6.28318530718;\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p)  {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tf *= f * (3.0 - 2.0 * f);\n\tfloat res = mix(\n\t\tmix(hash12(i), hash12(i + vec2(1, 0)), f.x),\n\t\tmix(hash12(i + vec2(0, 1)), hash12(i + vec2(1)), f.x), f.y);\n\treturn res * res;\t\n}\n\nfloat fbm(vec2 p) {\n\treturn 0.6 * noise(p) + 0.3 * noise(p * 2.0);\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * (2.0 * sqrt(0.5 + 0.5 * cos(TAU * (c * t + d))) - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min_res * 1.1;\n    float t = iTime;\n\n    float l = dot(uv, uv);\n    fragColor = vec4(0);\n\tfloat r = 4.0 / min_res;\n    float sm = smoothstep(1.0 + r, 1.0 - r, l);\n    float sm2 = smoothstep(1.0, 1.0 - r * 2., l);\n    float d = sm * l * l * l * 2.0;\n    vec3 norm = normalize(vec3(uv, 1. - d));\n    float a = atan(uv.y, uv.x) / TAU + t * 0.1;\n    vec3 col = pal(a, vec3(0.3),vec3(0.5),vec3(1),vec3(0.0,0.8,0.8));\n    vec3 cd = abs(col);\n    vec3 c = col;\n    c += l * max(0.0, l - 0.5 * dot(c, c));\n    c += 0.3 * noise(uv * 3.0 / (1. + norm.z * norm.z * norm.z * 2.0));\n    col = c + col * pow((1.0 - sm - pow(max(0.0, length(uv) - 1.0), 0.2)) * 2.0, 4.0);\n    float f = fbm(normalize(uv + 1e-5) * 2. + t) + 0.1;\n    uv *= f + 0.1;\n    uv *= 0.5;\n    l = dot(uv, uv);\n    vec3 ins = normalize(cd);\n    float ind = 0.2 + pow(smoothstep(0.0, 1.5, sqrt(l)) * 48.0, 0.25);\n    ind *= ind * ind * ind;\n    ind = 1.0 / ind;\n    ins *= ind;\n\tfloat m = sm * smoothstep(0.7, 1.0, ind);\n    col += ins * ins * m;\n\tcol -= 0.7 * ins * m;\n    col += abs(norm) * (1.0 - d) * 0.5;\n\tfloat alpha = length(col) * d + m + (1. - d) * 0.3;\n    fragColor = vec4(mix(vec3(1, 1, 1), col, alpha * sm2), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 56, 56, 167], [169, 169, 191, 191, 408], [410, 410, 429, 429, 478], [480, 480, 531, 531, 608], [610, 610, 662, 662, 1958]], "test": "untested"}
{"id": "ct3yzl", "name": "Testing datatype / conversion ", "author": "FabriceNeyret2", "description": "testing https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Conversion_constructors\nAlas, GLSL-ES is not GLSL", "tags": ["conversion", "spec", "datatype", "glsles"], "likes": 3, "viewed": 212, "published": 3, "date": "1699524889", "time_retrieved": "2024-07-30T17:23:15.275855", "image_code": "// testing https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Conversion_constructors\n\n#if 0 // not supported in GLSL-ES :-/\n\n    struct S { float A;vec2 B; };  \n    S a[3] = { {1., {-19., 4.5} }, {-3.0, {2.718, 2.} }, {29.5, {3.142, 3.333} } };\n\n    const float b[] = float[]( 1.,2.,3.) + float[]( 1.,2.,3.);\n\n    vec3 multidim[5][2]; \n\n    uint i = 3;\n\n#endif\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n   U /= iResolution.xy;\n   \n    // supported:\n    mat4 M = mat4( mat2(3) ); // mat2(i) = diag. mat4(mat2): rest is unit matrix\n    O = M[ int(4.*U) ] *.6;\n\n#if 0                    // not clear whether this is the expected behavior (it just ignores the mat4x2) )\n    mat2x4 A = mat2x4( mat4x2(1,.9,.8,.7, .6,.5,.4,.3) );\n    O = A[0]; // = vec4(1 ,.9,0,0);\n    O = A[1]; // = vec4(.8,.7,0,0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3yzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 404, 404, 806]], "test": "untested"}
{"id": "Dtcyzl", "name": "fractal symmetry sponge", "author": "chenxianming", "description": "the symmetry mat3 algorithm form shane's Refractive Poly", "tags": ["raymarching", "fractal", "generative", "cineshader"], "likes": 12, "viewed": 774, "published": 3, "date": "1699524749", "time_retrieved": "2024-07-30T17:23:16.148522", "image_code": "#define I iResolution\n#define PI 3.1415926\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define v( a ) clamp(a , 0., 1. )\n#define T( s ) fract( iTime * s ) * PI * 4.\n\n// shane's Refractive Poly\n// https://www.shadertoy.com/view/DtjSWh\nconst float PHI = (1. + sqrt(5.))/2.; // 1.618\nconst float J = (PHI - 1.)/2.; // .309016994375\nconst float K = PHI/2.; // J + .5\nconst mat3 R0 = mat3(.5,  -K,   J,  K,  J, -.5,  J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5,  J, .5,   K, .5 , -K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K, .5, -K,  -J,  K ,  J, .5);\n\nvec3 repNormal(vec3 p){ \n    p *= .9;\n    p = R0*abs(p);\n\n    p = R1*abs(p);\n    //p.xz *= rot( -T( .0125 ) );\n    p = R2*abs(p);\n    p.yz *= rot( -T( .025 ) );\n    return abs(p) - .1;  \n}\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float c) {\n    return -smin(-a, -b, c);\n}\n\n#define ax( a, b ) smin( a, b, .1 )\n\nfloat sp( vec3 p ){\n    \n    float c = 5.;\n    \n    for( float i = 0.; i < c; i++ ){\n        p.xz = abs( p.xz );\n        p.xy *= rot( i / c );\n        p.x = abs( p.x );\n        p.xz *= rot( i /c * .5 );\n        p.yz = abs( p.yz );\n        p.yz *= rot( i /c * .5 );\n    }\n\n    return max(\n        max( abs( p.x ) - .4, abs( p.y ) - .4 ),\n        abs( p.z ) - .004\n    );\n}\n\nfloat st( vec3 p ){\n    p.xz *= rot( T( .025 ) );\n    // return sp( p );\n    \n\tfloat s=0.3;\n\tfor(float i=0.;i<3.;i++){\n\t\tp=abs(p)-s;\n\t\tp.xz *= rot( i / 3. );\n\t\ts=s/2.5;\n\t}\n    \n    return max(\n        -sp( p ),\n        length( p ) - .35\n    );\n}\n\n\nfloat calcCore( vec3 p ){\n    p.y -= .1;\n\n    p.xz *= rot( T( .05 ) );\n    p.yz *= rot( -T( .05 ) );\n    \n    p = repNormal( p );\n\n    float d = max(\n        max( abs( p.y ) - .2, abs( p.z ) - .2 ),\n        abs( p.x ) - .09\n    );\n    \n    d = max(\n        d,\n        -st( p * 2.1 )\n    );\n    \n    \n    return d;\n}\n    \n\nfloat df( vec3 p ){\n    \n    vec3 p2 = p;\n    \n    return calcCore( p );\n}\n\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvec3 l2(in vec3 b) {\n  vec2 a = vec2(1, -2) * 2.;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nfloat g( vec3 a, vec3 p ){\n    return v( dot( a, l(p) ) );\n}\n\nfloat S( vec3 p, vec3 ca, vec3 r, float q ){\n    return v( pow( dot( l( p ), normalize( normalize( ca ) - r ) ), q ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat bgFractal(vec2 u ){\n    float s = .2;\n    // u *= rot( iTime );\n    for( float i = 0.; i < 20.; i++ ){\n        u=abs(u)-.1;\n        u.y = abs( u.y ) - .1 * s;\n        u*=rot( i/3.1415 + ( .6 - cos( iTime * .25 ) * .2 ) );\n        u.x = sin( abs( u.x ) - .01 );\n        s *= 1.1;\n    }\n    \n    float p = abs( length( u ) ) - .1;\n    \n    p = smoothstep( 0.01, p, 0.019 );\n    p = dot( p, p );\n    return p;\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n// some where but for desgin\nvec3 colorCir( vec2 p ){\n    // Position normalised into (-1, 0, 1)\n    vec2 d = 1.0 - (p * 2.0);\n    \n    // Distance from screen center\n    float dist = sqrt((d.x*d.x) + (d.y*d.y));\n    \n    // Rotation\n    float r = acos(d.x / dist);\n    // r += T( .025 );\n    if (d.y < 0.0) { r = PI-(r + PI); } // Sort out the bottom half (y=-1)\n\n    // From radians (0 - 2_PI) to hue (0 - 1)\n    float hue = ((r / PI) / 2.0);\n    \n    // Into color\n    return hsl2rgb( vec3(hue, 1.0, 0.5));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float A = min( I.x, I.y );\n    vec2 u = ( V * 2. - I.xy ) / A;\n    \n    vec3 c, p, o = vec3( 0., 0., -1.5 ), r = vec3( u * .4, 1. );\n    c += .05;\n    c += smoothstep( 0.5, .0, ( u.y / 2. + .5 ) + .2 );\n\n    c += \n    (bgFractal( u ) * colorCir( u ) * .3 * ( 1. - smoothstep( 0., 1.5, length(u)-.01 ) ) ) * ( 1. - smoothstep( 1., .3, ( u.y / 2. + .5 ) + .2 ) );\n    \n    float t, d, i;\n    for( ; i < 64.; i++ ){\n        p = o + r * t,\n        d = df( p ),\n        t += d;\n        if( t < .64 || abs( d ) < 1e-3 )\n            break ;\n    }\n\n    \n    if( d < 1e-3 ){\n        \n          vec3 p2 = p;\n\n            p2 = repNormal( p2 );\n            \n            vec3 n = l( p );\n            float rc = g( vec3( .0, 1.1, -.1 ), p );\n\n            // c += rc * .1;\n            \n            vec3 rr = reflect(l(p), r);\n\n            \n            //c += rr * .1;\n            float amb = dot(n, vec3(1.0, 1.0, -1.6));\n            \n            c = vec3( .1 );\n            \n            c += S( p, n, r, 5. ) * .1;\n            //c +=  rr.x * .1;\n\n            float ss = calcSoftshadow( p, vec3( -.5, 1.1, -1. ), 0.1, .5, 0 ) * rc;\n            c += ss ;\n            \n            c = sqrt( c );\n            c += p2 * .4;\n            c = v( c );\n    }\n    \n    \n    p = vec3( 0 );\n    i = 0.,\n    d = 0.,\n    t = 0.;\n    \n    for( ; i < 24.; i++ )\n        p = o + r * t,\n        p.y *= -1.,\n        //p.x -= .05,\n        p.y -= .77,\n        d = df( p ),\n        t += d;\n    if( d < 1e-3 ){\n        vec3 p2 = repNormal( p );\n        vec3 rr = reflect(l(p), c);\n        /*\n        c += vec3( p2.x, p2.y, p2.z / 2. + .5 ) * .1 +\n            (.5 + .35 * cos(o + p.xyx * 2. + vec3(1, 5, 2))) * .05;\n        c += rr * .1;\n        */\n        c -= rr.r * .1 - p2 * .1;\n    }\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtcyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[562, 562, 585, 585, 750], [752, 752, 792, 792, 874], [876, 876, 915, 915, 946], [985, 985, 1004, 1004, 1356], [1358, 1358, 1377, 1377, 1603], [1606, 1606, 1631, 1631, 1921], [1928, 1928, 1947, 1947, 2002], [2004, 2004, 2023, 2023, 2219], [2221, 2221, 2241, 2241, 2434], [2436, 2436, 2462, 2462, 2496], [2498, 2498, 2542, 2542, 2619], [2621, 2621, 2714, 2714, 3568], [3570, 3570, 3595, 3595, 3984], [3986, 3986, 4012, 4012, 4152], [4153, 4182, 4206, 4249, 4664], [4667, 4667, 4708, 4758, 6564]], "test": "untested"}
{"id": "ctccRl", "name": "INRIA's Voronoi", "author": "rubioh", "description": "Voronoi from INRIA's website (in fact it's a delaunay tesselation on their website nvm I'm too lazy to change this it's a 5minutes work) : https://www.inria.fr/fr/modelisation-et-simulation", "tags": ["voronoiinria"], "likes": 7, "viewed": 276, "published": 3, "date": "1699523827", "time_retrieved": "2024-07-30T17:23:16.908490", "image_code": "// INSPIRE FROM https://www.inria.fr/fr/modelisation-et-simulation\n\n#define AA\n#define PI 3.14\nvec2 hash22(vec2 st) {\n    return vec2(fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123),fract(cos(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123));\n}\n\nvec2 voronoi(vec2 uv)\n{\n    vec2 uv_id = floor (uv);\n    vec2 uv_st = fract(uv);\n\n    vec2 m_diff;\n    vec2 m_point;\n    float m_dist = 10.;\n    for (int j = -2; j<=2; j++){\n        for (int i = -2; i<=2; i++){\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash22(uv_id + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point);\n            vec2 diff = neighbor + point - uv_st;\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = point + neighbor + uv_id;\n            }\n        }\n    }\n    return vec2(m_point);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    uv = uv*5.;\n    vec2 m = ( 2.*iMouse.xy - iResolution.xy ) / iResolution.y;\n    m *= 5.;\n    \n    \n    vec2 dx = vec2(1./iResolution.y*5., .0);\n    vec2 dy = vec2(.0, 1./iResolution.y*5.);\n    \n    float P = .9;\n    vec3 C = vec3(.2, .9, .4)*1.2;\n    \n    vec2 uv_w = voronoi(uv);      \n    float L = 1.5*1./(1.+length(uv_w - m));\n    vec3 col = pow(L, P) * C;\n    \n    \n    // CHEAP VERSION OF ANTI ALIASING :'(\n    #ifdef AA\n    uv_w = voronoi(uv+dx);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv+dy);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv-dx);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n    \n    uv_w = voronoi(uv-dy);      \n    L = 1.5*1./(1.+length(uv_w - m));\n    col += pow(L, P) * C;\n\n    \n    col /= 5.;\n    #endif\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctccRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 117, 117, 323], [325, 325, 348, 348, 961], [964, 964, 1021, 1021, 1990]], "test": "untested"}
{"id": "mltyzf", "name": "CRT-rjf", "author": "starfreakclone", "description": "A CRT shader designed by Ryan Fleury", "tags": ["crt"], "likes": 0, "viewed": 147, "published": 3, "date": "1699517420", "time_retrieved": "2024-07-30T17:23:17.770186", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tint = vec4(0.85);\n    float sin_pos = float(iTime * 20.0);\n\n    float sin_offset_1 = sin(sin_pos + uv.y*50.0)*0.0005;\n    float sin_offset_2 = sin(sin_pos + uv.y*30.0)*0.0009;\n    float sin_offset_3 = sin(sin_pos + uv.x*60.0)*0.0001;\n    float round_offset = sin(uv.x*3.14159)*0.03;\n    vec4 color = texture(iChannel0, uv+vec2(sin_offset_1, -round_offset));\n    color.r = texture(iChannel0, uv+vec2(sin_offset_2, -round_offset)).r;\n    color *= tint;\n    float crt_wave_val = sin((uv.y + sin_offset_3 - round_offset)*400.0);\n    crt_wave_val *= crt_wave_val;\n    color.r += crt_wave_val*(1.0/16.0);\n    color.g += crt_wave_val*(1.0/10.0);\n    color.b += crt_wave_val*(1.0/6.0);\n\n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 860]], "test": "untested"}
{"id": "ctdyRf", "name": "gapz lan", "author": "chenxianming", "description": "inifinity nope this band anytime.", "tags": ["band", "cineshader"], "likes": 11, "viewed": 1281, "published": 3, "date": "1699493128", "time_retrieved": "2024-07-30T17:23:18.701696", "image_code": "#define I iResolution\n#define PI 3.1415\n#define TAU PI * 2.\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define v( a ) clamp( a, 0., 1. )\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat cc( vec2 u ){\n    // ships\n    float py = u.y;\n    \n    py = abs( pow( py, 2. ) );\n    py -= .1;\n    py *= 6. * ( u.y / 2. + .5 );\n    py = abs( py ) - .01;\n\n    return min(\n        max(\n            abs( u.x ) - .7 * py,\n            abs( u.y ) - .3\n        ),\n        length( u + vec2( 0., -.1 ) ) - .19\n    );\n}\n\nfloat texp( vec2 u ){\n    float p;\n    \n    p = length( u ) - .4;\n    \n    p = max(\n        p,\n        -( length( u ) - .35 )\n    );\n    \n    p = max(\n        p,\n        -( abs( u.y - .03 ) - .14 )\n    );\n    return p;\n}\n\nfloat texw( vec2 u ){\n    float w = max(\n        sin( atan( u.x, u.y + .29 ) * 3.5 - PI * .5 ),\n        ( length( u ) - .28 )\n    );\n    \n    vec2 cu = u * 4.;\n    \n    cu.y -= .3;\n    cu.x = abs( cu.x ) - .5 * ( u.y / 2. + .5 );\n    cu.y = abs( cu.y ) - .35;\n    cu *= rot( PI * .1 );\n    \n    \n    float cr = cc( cu * 1.1 );\n    \n    w = max(\n        w,\n        -cr\n    );\n    \n    return w;\n}\n\nvoid updatePos( inout vec3 p ){\n    p.xz *= rot( iTime );\n    p.zy *= rot( iTime );\n}\n\nfloat hx( vec3 p ){\n\n    updatePos( p );\n    float py = p.y;\n    \n    py = abs( py ) - .5;\n    py = clamp( py, -.27 , 1. );\n    py = abs( py ) - .01;\n\n    return max(\n        sdHexagon( p.xz, 1.44 * py ),\n        abs( p.y ) - .5\n    );\n}\n\nfloat fcs( vec3 p ){\n    updatePos( p );\n    \n    p.xz *= rot( PI * .34 );\n    p.z += .18;\n    \n    return max(\n        max( \n            abs( p.x ) - .21,\n            abs( p.y ) - .21\n        ),\n        abs( p.z ) - .21\n    );\n}\n\n\nfloat slavers( vec3 p ){\n    \n    p.xy *= rot( p.z * .8 );\n    p.z += iTime * .5;\n    p = mod( p, 1. ) - .5;\n    p.xz *= rot( iTime );\n    \n\n    return max(\n        sdHexagon( p.xy, .2 ),\n        abs( p.z ) - .01\n    );\n}\n\n\nvec3 lc( vec3 p ){\n    p.xz *= rot( .5 );\n    \n    for( float i = 0.; i < 3.; i++ ){\n        p.yz *= rot(  i );\n        p.xy *= rot(  i );\n        p.x = abs( p.x ) - i * .07;\n        p.xz *= rot( i );\n        p.z = abs( p.z ) - i * .07;\n    }\n    \n    p.y -= .05;\n    return p;\n}\n\n\nfloat df( vec3 p ){\n\n    float d = 1.;\n\n    d = min(\n        d,\n        slavers( p )\n    );\n\n    d = min(\n        d,\n        hx( p )\n    );\n    \n    d = min(\n        d,\n        fcs( p )\n    );\n    \n    return d;\n}\n\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / I.y;\n    \n    \n    vec3 c, p, o = vec3( 0., 0., -3. ), r = vec3( u * .25, 1. );\n    float t, d, i, dp, e = sqrt( 1e-4 );\n    \n    for( ; i < 64.; i++ ){\n        p = o + r * t,\n        d = df( p ),\n        dp = ( 1. - abs( d ) / e ),\n        c += ( dp > 0. && df( p ) == hx(p) ) ? .01 * 64. / i * dp / t : 0.;\n        \n        if( dp > 0. && df( p ) == hx(p) ){\n           c += lc( reflect( ( p ) , r ) ) * .3 * (2. - cos( vec3( .7, sin( p.x ), abs(r.z) ) ))\n           * .35 * 64. / i * dp / t;\n           c += vec3( 0.17, 0.78, 0.98 ) * .1 * 64. / i * dp / t;\n        }\n        \n        \n        if( dp > 0. && ( df( p ) == fcs( p ) ) ){\n            vec3 pp = p;\n            // yes the same as stereo yes\n            updatePos( pp );\n            \n            pp.xz *= rot( PI * .34 );\n            p.z += .18;\n            \n            float x = (mod( round(iTime* .5), 2. ) == 0. ) ? round( fract( iTime * 7. + 123.456 ) ) : 1.;\n            \n            c += max( -l( pp ).z, 0. ) * step( max( abs( pp.x ) - .2, abs( pp.y ) - .2 ), 0. ) * vec3( 0.16, 0.79, 0.97 ) * .01;\n            c += vec3( max( -l( pp ).z, 0. ) * step( texw( pp.xy * 3. ), 0. ) ) * vec3( 0.97, 0.17, 0.31 ) * x;\n            c += vec3( max( -l( pp ).z, 0. ) * step( texp( pp.xy * 3. ), 0. ) ) * vec3( 0.17, 0.97, 0.86 ) * x;\n        }\n        \n        c += (  dp > 0. && ( df( p ) == slavers( p ) ) ) ? vec3( 0.17, 0.78, 0.98 ) * .05 * 64. / i * dp / t : vec3(0);\n            \n        \n        \n        t += max( abs( d )  * .66667, e );\n    }\n    \n\n\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 193, 193, 383], [385, 385, 404, 417, 703], [705, 705, 726, 726, 925], [927, 927, 948, 948, 1322], [1324, 1324, 1355, 1355, 1409], [1411, 1411, 1430, 1430, 1648], [1650, 1650, 1670, 1670, 1879], [1882, 1882, 1906, 1906, 2103], [2106, 2106, 2124, 2124, 2385], [2388, 2388, 2407, 2407, 2601], [2603, 2603, 2622, 2622, 2818], [2821, 2821, 2862, 2912, 4518]], "test": "untested"}
{"id": "cttyRf", "name": "4x3 Neural Cellular Automata", "author": "ThePlaneGuy45", "description": "mat4x3 create life thing ig\n\nterritorial simulator with the current neural network it's using. going from normal size to fullscreen is kinda fun.", "tags": ["cellularautomata", "neuralnetwork"], "likes": 1, "viewed": 184, "published": 3, "date": "1699490810", "time_retrieved": "2024-07-30T17:23:19.631210", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.xy != vec2(0)){\n        fragCoord*=iMouse.x/iResolution.x;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0)*.5+.5;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define v(x, y) ivec2(mod(c+vec2(x, y), iResolution.xy))\n\nvoid mainImage( out vec4 t, in vec2 c )\n{\n    if(iFrame==0){\n        t=vec4(hash33(vec3(c, SEED))*2.-1.,1.0); \n        return;\n    }\n    \n    if(!(mod(float(iFrame), 1.0)==0.0)){\n        t=texelFetch(iChannel0, ivec2(c), 0);\n        return;\n    }\n    \n    float rng = hash33(vec3(c, iFrame)).r*2.-1.;\n    \n    vec3 u = texelFetch(iChannel0, v( 0, 1), 0).rgb;\n    vec3 d = texelFetch(iChannel0, v( 0,-1), 0).rgb;\n    vec3 l = texelFetch(iChannel0, v( 1, 0), 0).rgb;\n    vec3 r = texelFetch(iChannel0, v(-1, 0), 0).rgb;\n    \n    u =    up*vec4(u, rng);\n    d =  down*vec4(d, rng);\n    l =  left*vec4(l, rng);\n    r = right*vec4(r, rng);\n    \n    vec4 b = normalize(vec4(upBias,downBias,leftBias,rightBias));\n    \n    vec3 f = clamp(b.x*u+b.y*d+b.z*l+b.w*r, -1.0, 1.0);\n\n    t = vec4(f,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SEED 0\n\nconst float SPR = 1.0;\n\nconst float  upBias = 1.0;\nconst mat4x3 up = mat4x3(\n    1.0,-1.0,-1.0,\n   -1.0, 1.0,-1.0,\n   -1.0,-1.0, 1.0,\n    SPR, SPR, SPR\n);\n\nconst float  downBias = 1.0;\nconst mat4x3 down = mat4x3(\n    1.0,-1.0,-1.0,\n   -1.0, 1.0,-1.0,\n   -1.0,-1.0, 1.0,\n    SPR, SPR, SPR\n);\n\nconst float  leftBias = 1.0;\nconst mat4x3 left = mat4x3(\n    1.0,-1.0,-1.0,\n   -1.0, 1.0,-1.0,\n   -1.0,-1.0, 1.0,\n    SPR, SPR, SPR\n);\n\nconst float  rightBias = 1.0;\nconst mat4x3 right = mat4x3(\n    1.0,-1.0,-1.0,\n   -1.0, 1.0,-1.0,\n   -1.0,-1.0, 1.0,\n    SPR, SPR, SPR\n);", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 b = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = mix(a, b, iMouse.y/iResolution.y);\n    if(iFrame<=1){fragColor=a;}\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 204]], "test": "untested"}
{"id": "mt3cRX", "name": "uint < 0:   GLSL bug #73 ? (→no)", "author": "FabriceNeyret2", "description": "I can have a negative uint !  ( white band of left third ). \n\nBug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1500687", "tags": ["glsl", "bug"], "likes": 0, "viewed": 172, "published": 3, "date": "1699467748", "time_retrieved": "2024-07-30T17:23:20.679407", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float x = 3.* U.x / iResolution.x;  // x in [0,3]\n    \n // uint i =       uint( x ) - 1u ;\n    uint i = uint( uint( x ) - 1u );  // to be really sure\n\n    O = vec4( int(i) == -1 );\n // O = vec4( float(i) < 0. ); // no bug with float\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3cRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 277]], "test": "untested"}
{"id": "DtcczX", "name": "Graphic Design Experiment 10", "author": "yasuo", "description": "Graphic Design Experiment 10", "tags": ["graphicdesign", "cineshader"], "likes": 45, "viewed": 1117, "published": 3, "date": "1699457655", "time_retrieved": "2024-07-30T17:23:22.177402", "image_code": "// The box intersection code is based on the iq's. https://www.shadertoy.com/view/ld23DV\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n#define BOX_NUM 27.\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat getAnimatedRotValue(float delay){\n    float frame = mod(iTime,9.0+delay)-delay;\n    float time = frame;\n    float duration = 0.7;\n    float rotVal = 0.0;\n    if(frame>=1. && frame<3.){\n        time = getTime(time-1.,duration);\n        rotVal = cubicInOut(time)*90.;\n    } else if(frame>=3. && frame<5.){\n        time = getTime(time-3.,duration);\n        rotVal = 90.+cubicInOut(time)*90.;\n    } else if(frame>=5. && frame<7.){\n        time = getTime(time-5.,duration);\n        rotVal = 180.+cubicInOut(time)*90.;\n    } else if(frame>=7. && frame<9.){\n        time = getTime(time-7.,duration);\n        rotVal = 270.+cubicInOut(time)*90.;\n    }\n    \n    return rotVal;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return vec4(-1.0);\n\n    vec4 res = vec4(tN, step(tN,t1) );\n    \n    // add sign to normal and convert to ray space\n\tres.yzw = (txi * vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n\treturn res;\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nfloat truchetGraphic(vec2 p, float dir){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.212;\n    \n    p*=Rot(radians(45.));\n    vec2 prevP2 = p;\n    float a = radians(45.);\n    float d = abs(max(-dot(p+vec2(0.095),vec2(cos(a),sin(a))),B(p,vec2(0.15))))-0.03;\n    p+=vec2(0.085);\n    p*=Rot(radians(45.));\n    d = max(-B(p,vec2(0.03,0.003)),d);\n    \n    p = prevP2;\n    p+=vec2(0.105);\n    \n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.075;\n    d = max(-B(p,vec2(0.007)),d);\n    \n    p = prevP;\n    p = mod(p,0.03)-0.015;\n    float d2 = length(p)-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.y*=dir;\n    p*=Rot(radians(45.));\n    float sdir = SymdirY(p);\n    p.x*=1.7;\n    p.y+=iTime*0.1*sdir;\n    p.y = mod(p.y,0.08)-0.04;\n    p.y*=sdir*-1.;\n    d2 = Tri(p,vec2(0.015));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x*=dir;\n    p*=Rot(radians(135.));\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    d2 = min(B(p,vec2(0.0005,0.01)),B(p,vec2(0.01,0.0005)));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat ui(vec2 p){\n    vec2 prevP = p;\n    p = mod(p,0.06)-0.03;\n    float d = min(B(p,vec2(0.0001,0.006)),B(p,vec2(0.006,0.0001)));\n    p = prevP;\n    d = max(B(p,vec2(0.55,0.3)),d);\n    \n    p.x = abs(p.x)-0.7;\n    vec2 prevP2 = p;\n    float a = radians(-50.);\n    p.y = abs(p.y)-0.2;\n    float d2 = abs(max(-dot(p,vec2(cos(a),sin(a))),B(p,vec2(0.08,0.4))))-0.0001;\n    p = prevP2;\n    d2 = max(p.x-0.05,min(B(p-vec2(-0.08,0.0),vec2(0.003,0.03)),d2));\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.y = abs(p.y)-0.35;\n    p*=Rot(radians(50.));\n    d2 = B(p,vec2(0.0001,0.15));\n    d = min(d,min(B(p,vec2(0.003,0.05)),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.56;\n    p.y = abs(p.y)-0.42;\n    p.x = abs(p.x)-0.012;\n    d2 = abs(length(p)-0.008)-0.0003;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.46;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.02)))-0.0005;\n    d = min(d,max(-(p.y+0.016),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.75;\n    p.y = mod(p.y,0.018)-0.009;\n    d2 = B(p,vec2(0.015,0.001));\n    d2 = max(abs(prevP.y)-0.05,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    // camera movement\t\n\tfloat an = radians(90.);\n\tvec3 ro = vec3( 2.5*cos(an), 0., 2.5*sin(an) );\n    \n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(5.0));\n        \n        float delay = 2.5;\n        float frame = mod(iTime,11.0+delay)-delay;\n        float time = frame;\n        \n        float duration = 0.7;\n        float rotVal = 0.0;\n        if(frame>=1. && frame<3.){\n            time = getTime(time-1.,duration);\n            rotVal = cubicInOut(time)*90.;\n        } else if(frame>=3. && frame<5.){\n            time = getTime(time-3.,duration);\n            rotVal = 90.+cubicInOut(time)*90.;\n        } else if(frame>=5. && frame<7.){\n            time = getTime(time-5.,duration);\n            rotVal = 180.+cubicInOut(time)*90.;\n        } else if(frame>=7. && frame<9.){\n            time = getTime(time-7.,duration);\n            rotVal = 270.+cubicInOut(time)*90.;\n        } else if(frame>=9.){\n            time = getTime(time-9.,duration+0.5);\n            rotVal = 360.-cubicInOut(time)*360.;\n        }\n        \n        ro.xz *= Rot(radians(-rotVal));\n    }\n    \n    vec3 ta = vec3( 0.0, 0.,0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3 nor = vec3(0.0);\n\tvec3 pos = vec3(0.0);\n\tfloat oid = 0.0;\n    mat4 txxRef = mat4(0.0);\n    float dir = 0.0;\n    \n    float dist = .3;\n    for(float i = 0.; i<BOX_NUM; i+=1.){\n        int index = int(i);\n\n        float x = dist-(float(mod(i,3.))*dist);\n        float y = dist-(floor(mod(i,9.)/3.)*dist);\n        float z = dist-(floor(i/9.)*dist);\n\n        float rotVal = getAnimatedRotValue(i*0.15);\n        mat4 rot = rotationAxisAngle( normalize(mod(i,2.) ==0.?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)), radians(rotVal) );\n        \n        mat4 tra = translate( x, y, z );\n        mat4 txi = tra * rot; \n        mat4 txx = inverse( txi );\n        \n        vec4 res = iBox( ro, rd, txx, txi, vec3(0.15) );\n        if( res.x>0.0 && res.x<tmin  ) { \n            tmin = res.x; \n            nor = res.yzw;\n            oid = i;\n            txxRef = txx;\n            \n            dir = 1.;\n            if(mod(i,5.) == 0.)dir = -1.;\n        }\n    }\n\n\tvec3 col = vec3(0.) ;\n\n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // materials\n\t\tfloat occ = 1.0;\n\t\tvec3 mate = vec3(1.0);\n        \n        for(float i = 0.; i<BOX_NUM; i+=1.){\n            int index = int(i);\n            if(oid == i){\n                vec3 opos = (txxRef*vec4(pos,1.0)).xyz;\n                vec3 onor = (txxRef*vec4(nor,0.0)).xyz;\n\n                vec3 colXZ = mix(col,vec3(1.),S(truchetGraphic(opos.xz,dir),0.0));\n                vec3 colYZ = mix(col,vec3(1.),S(truchetGraphic(opos.yz,dir),0.0));\n                vec3 colXY = mix(col,vec3(1.),S(truchetGraphic(opos.xy,dir),0.0));\n                mate = colXZ*abs(onor.y)+colXY*abs(onor.z)+colYZ*abs(onor.x);\n             }\n        }\n        \n        // lighting\n        vec3 lig = normalize(vec3(0.8,2.4,3.0));\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        vec3 hal = normalize(lig-rd);\n        \n        float amb = 0.6 + 0.4*nor.y;\n        float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n        float spe = clamp(dot(nor,hal),0.0,1.0);\n        col  = 4.0*vec3(1.00,0.80,0.60)*dif;\n        col += 2.0*vec3(0.20,0.30,0.40)*amb;\n        col += 2.0*vec3(0.30,0.20,0.10)*bou;\n        col *= mate;                      \n\t} else {\n        float d = ui(p);\n        col = mix(col,vec3(0.7),S(d,0.0));\n    }\n\t\n    // gamma\n    col = pow( col, vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n/* // The old shader to test. This one is the ray marching version.\n#define MAX_STEPS 36\n#define MAX_DIST 2.\n#define SURF_DIST .003\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n\nvec3 positions[27] = vec3[](vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.));\nmat2 rots[27] = mat2[](mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.),mat2(0.));\nfloat dirs[27] = float[](1.,-1.,1.,1.,1.,-1.,1.,-1.,1.,1.,-1.,1.,1.,1.,-1.,1.,-1.,1.,1.,-1.,1.,1.,1.,-1.,1.,-1.,1.);\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat getAnimatedRotValue(float delay){\n    float frame = mod(iTime,9.0+delay)-delay;\n    float time = frame;\n    float duration = 0.7;\n    float rotVal = 0.0;\n    if(frame>=1. && frame<3.){\n        time = getTime(time-1.,duration);\n        rotVal = cubicInOut(time)*90.;\n    } else if(frame>=3. && frame<5.){\n        time = getTime(time-3.,duration);\n        rotVal = 90.+cubicInOut(time)*90.;\n    } else if(frame>=5. && frame<7.){\n        time = getTime(time-5.,duration);\n        rotVal = 180.+cubicInOut(time)*90.;\n    } else if(frame>=7. && frame<9.){\n        time = getTime(time-7.,duration);\n        rotVal = 270.+cubicInOut(time)*90.;\n    }\n    \n    return rotVal;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    vec2 res = vec2(0.0);\n    float dist = .3;\n    float size = .15;\n    \n    float rotVal = getAnimatedRotValue(0.0);\n    int index = 0;\n\n    positions[index] = vec3(dist);\n    rots[index] = Rot(radians(rotVal));\n    p += positions[index];\n    p.yz*= rots[index];\n    float d = B3D(p,vec3(size));\n\n    res = vec2(d,index);    \n \n    float len = float(positions.length());\n    for(float i = 1.; i<len; i+=1.){\n        p = prevP;\n        float rotVal = getAnimatedRotValue(i*0.15);\n        index = int(i);\n        \n        float x = dist-(float(mod(i,3.))*dist);\n        float y = dist-(floor(mod(i,9.)/3.)*dist);\n        float z = dist-(floor(i/9.)*dist);\n        positions[index] = vec3(x,y,z);\n        rots[index] = Rot(radians(rotVal));\n        p += positions[index];\n        if(dirs[index] == 1.){\n            p.yz*= rots[index];\n        } else {\n            p.xz*= rots[index];\n        }\n        \n        float d = B3D(p,vec3(size));\n\n        vec2 res2 = vec2(d,index);\n        res = mix(res,res2,step(res2.x,res.x));\n    }\n    \n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-20));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff;\n    diffCol += col*vec3(0.5)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nfloat truchetGraphic(vec2 p, float dir){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.212;\n    \n    p*=Rot(radians(45.));\n    vec2 prevP2 = p;\n    float a = radians(45.);\n    float d = abs(max(-dot(p+vec2(0.095),vec2(cos(a),sin(a))),B(p,vec2(0.15))))-0.03;\n    p+=vec2(0.085);\n    p*=Rot(radians(45.));\n    d = max(-B(p,vec2(0.03,0.003)),d);\n    \n    p = prevP2;\n    p+=vec2(0.105);\n    \n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.075;\n    d = max(-B(p,vec2(0.007)),d);\n    \n    p = prevP;\n    p = mod(p,0.03)-0.015;\n    float d2 = length(p)-0.0005;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.y*=dir;\n    p*=Rot(radians(45.));\n    float sdir = SymdirY(p);\n    p.x*=1.7;\n    p.y+=iTime*0.1*sdir;\n    p.y = mod(p.y,0.08)-0.04;\n    p.y*=sdir*-1.;\n    d2 = Tri(p,vec2(0.015));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x*=dir;\n    p*=Rot(radians(135.));\n    p.y = abs(p.y)-0.17;\n    p*=Rot(radians(45.));\n    d2 = min(B(p,vec2(0.0005,0.01)),B(p,vec2(0.01,0.0005)));\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 n2 = n;\n    p+=positions[mat];\n    if(dirs[mat] == 1.){\n        p.yz*= rots[mat];\n        n2.yz*= rots[mat];\n    } else {\n        p.xz*= rots[mat];\n        n2.xz*= rots[mat];\n    }\n    \n    col = diffuseMaterial(n,rd,p,vec3(0.2));\n    \n    vec3 colXZ = mix(col,vec3(1.),S(truchetGraphic(p.xz,dirs[mat]),0.0));\n    vec3 colYZ = mix(col,vec3(1.),S(truchetGraphic(p.yz,dirs[mat]),0.0));\n    vec3 colXY = mix(col,vec3(1.),S(truchetGraphic(p.xy,dirs[mat]),0.0));\n\n    return colXZ*n2.y+colXY*n2.z+colYZ*n2.x;\n}\n\nfloat ui(vec2 p){\n    vec2 prevP = p;\n    p = mod(p,0.06)-0.03;\n    float d = min(B(p,vec2(0.0001,0.006)),B(p,vec2(0.006,0.0001)));\n    p = prevP;\n    d = max(B(p,vec2(0.55,0.3)),d);\n    \n    p.x = abs(p.x)-0.7;\n    vec2 prevP2 = p;\n    float a = radians(-50.);\n    p.y = abs(p.y)-0.2;\n    float d2 = abs(max(-dot(p,vec2(cos(a),sin(a))),B(p,vec2(0.08,0.4))))-0.0001;\n    p = prevP2;\n    d2 = max(p.x-0.05,min(B(p-vec2(-0.08,0.0),vec2(0.003,0.03)),d2));\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.y = abs(p.y)-0.35;\n    p*=Rot(radians(50.));\n    d2 = B(p,vec2(0.0001,0.15));\n    d = min(d,min(B(p,vec2(0.003,0.05)),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.56;\n    p.y = abs(p.y)-0.42;\n    p.x = abs(p.x)-0.012;\n    d2 = abs(length(p)-0.008)-0.0003;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y)-0.46;\n    p.y*=-1.;\n    d2 = abs(Tri(p,vec2(0.02)))-0.0005;\n    d = min(d,max(-(p.y+0.016),d2));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.75;\n    p.y = mod(p.y,0.018)-0.009;\n    d2 = B(p,vec2(0.015,0.001));\n    d2 = max(abs(prevP.y)-0.05,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.57);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        \n        float delay = 2.5;\n        float frame = mod(iTime,11.0+delay)-delay;\n        float time = frame;\n        \n        float duration = 0.7;\n        float rotVal = 0.0;\n        if(frame>=1. && frame<3.){\n            time = getTime(time-1.,duration);\n            rotVal = cubicInOut(time)*90.;\n        } else if(frame>=3. && frame<5.){\n            time = getTime(time-3.,duration);\n            rotVal = 90.+cubicInOut(time)*90.;\n        } else if(frame>=5. && frame<7.){\n            time = getTime(time-5.,duration);\n            rotVal = 180.+cubicInOut(time)*90.;\n        } else if(frame>=7. && frame<9.){\n            time = getTime(time-7.,duration);\n            rotVal = 270.+cubicInOut(time)*90.;\n        } else if(frame>=9.){\n            time = getTime(time-9.,duration+0.5);\n            rotVal = 360.-cubicInOut(time)*360.;\n        }\n        \n        ro.xz *= Rot(radians(-rotVal));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        float ud = ui(uv);\n        col = mix(col,vec3(0.7),S(ud,0.0));\n    }\n    \n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[476, 476, 503, 503, 587], [589, 589, 628, 628, 673], [675, 675, 714, 714, 1349], [1351, 1399, 1476, 1513, 2052], [2054, 2054, 2101, 2101, 2505], [2507, 2507, 2552, 2552, 2668], [2671, 2671, 2711, 2711, 3722], [3724, 3724, 3741, 3741, 4821]], "test": "untested"}
{"id": "ct3czX", "name": "xor 3d", "author": "Virgill", "description": "Fooling around with integer logic and buffers", "tags": ["3d", "xor", "feedback", "sierpinski", "integer"], "likes": 25, "viewed": 480, "published": 3, "date": "1699457487", "time_retrieved": "2024-07-30T17:23:23.066026", "image_code": "// Fooling around with integer logic and buffers\n// I always wonder how much beauty lies in simple integer math\n\n// Thx to Fabrice Neyret for reducing the code size of my mess <3\n\n// Music done with 4klang\n\n\nM   O =  (1.-U.y) * O * vec4(.8,1,.9,0)\n        +.1 - .1 * fract( 1e4* sin( dot(U*iTime, R-71.))); // noise\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M   uvec2 I = uvec2( ( int(u.y) - iFrame ) *8 , u *4. ); \n    uint  a = ( I.x-I.y&I.x+I.y ) / uint( 7.+ iTime/6. );\n    a = ( int(u.y) & 1 ) > 0 \n          ? a |= uint( (1.01*O.y-.04) *256. )\n          : a ^= uint(       O.y      *256. );    \n    O = vec4( a & 255u )/256.;\n}\n\n  ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35197, "src": "https://soundcloud.com/virgill/4klang-the-scientist", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define M                                        \\\nvoid mainImage( out vec4 O, vec2 u ) {           \\\n        u.y++;                                   \\\n        vec2 R = iResolution.xy, U = u / R;      \\\n        O = texture(iChannel0, U );", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3czX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtdcR2", "name": "Hex/Barycentric ⅁I⅂ᗺƎꓤꓕ┣┳┻┫Tiles", "author": "ollj", "description": "floor()-LATTICED Gilbert tessellation,where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds into its 2 neighbor tiles,BUT on a hex lattice (instead of rectangle-lattice,by jt) ,making barycentric borders.", "tags": ["2d", "grid", "hexagon", "road", "tile", "tesselation", "gilbert"], "likes": 10, "viewed": 262, "published": 3, "date": "1699448961", "time_retrieved": "2024-07-30T17:23:23.942682", "image_code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n//https://en.wikipedia.org/wiki/Gilbert_tessellation\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n//+acos(-1.) offsets the period, because this version demoes what i added shifted-tile-colors\n#define timeOscillator cos(iTime*.6+acos(-1.))*.5+.5\n\n#define rot(a) ;mat2 m=rotby(acos(a));u*=m;center*=m\n//rmax paints a road in locally offset-rotated uv, of height [h]\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\n//*.89 to account for \"road width\" in a hacky way.\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5*.85\n ;}\n \n//extra roads need anarbitiarily different alternative hash.\nfloat h21b(ivec2 i\n){return sin(float(33*i.x)-cos(float(15*i.y)))*.5*.85\n ;}\n\n//brightness factor of gilbert-tesselated-tiles\n#define gttb .3\n\n//green tiles with magenta/pink/purple roads\n//branches always go off clockwise of trunks\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.,l=0.;rmax//purple main road trunk (is not a fork, sets 2 adjacent forks)\n ;if(u.y-center.y<h//top or bottom forks?\n ){//bottom 2 forks are h21b() hashed, not set by neighbors.\n  ;float h=h21b(i+ivec2(-1,1))\n  ;rot(.5)//height of bottom adjacent yellow\n  ;rmax\n   ;if(u.y-center.y<h\n   ){float h=h21b(i+ivec2(1,1))\n    ;rot(.5)//height of bottom adjacent blue \n    ;rmax\n    ;if(u.y-center.y>h)l=1.;else l=.84\n   ;}\n ;}else{//top 2 forks are set by adacent main roads\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;rot(.5)\n  ;rmax\n  ;l=.6\n  ;if(u.y-center.y>h\n  ){float h=h21(i+ivec2(1,1))//height of top adjacent burple\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y>h)l=.2;else l=.4\n  ;}\n ;}\n \n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(r,l*gttb,r)\n ;}\n\n//blue tiles with yellow roads\n//branches always go off clockwise of trunks\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.,l=.6;rot(-.5);rmax//vellow tiles main road trunk\n ;if(u.y-center.y<h\n  ){//2 bottom road forks\n   ;float h=-h21b(i+ivec2(1,-1))//height left adjacent blue\n   ;rot(.5)\n   ;rmax\n   ;l=.4\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21b(i+ivec2(-2,2))//height of top left adjacend purple\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;if(u.y-center.y>h)l=1.;else l=0.\n    ;}\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;if(u.y-center.y>h)l=.2;else l=.8\n   ;}\n  ;}\n  \n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(r,r,l*gttb)\n ;}\n\n//red tiles with cyan/lightBlue roads\n//branches always go off clockwise of trunks\n//BUT NOT HERE\n//...swapping 1 branch with its trunk to ddisrupt large troiangles\n//that emerge from [all forks branch clockwise]\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5));u*=m;center*=m\n ;float r=0.,l=.8;rmax //blue main trunk\n ;if(u.y-center.y<h\n  ){//2 top branches\n   ;float h=h21(i+ivec2(-1,-1))//height \n   ;rot(.5)\n   ;rmax\n   ;l=.6\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height \n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n    ;if(u.y-center.y>h)l=0.;else l=.2\n   ;}\n  ;}else{//2 bottom branches\n      //this trunk was swapped with its branch below\n      ;float h=h21b(i+ivec2(2,2))//connect to right yellow tile \n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n  ;if(u.y-center.y<h\n   ){}else{\n    \n    //this branch was swapped with its trunk above\n  ;float h=h21b(i+ivec2(1,-1))//connect to top right purple tile \n  ;rot(.5)\n  ;rmax\n      ;if(u.y-center.y>h)l=.4;else l=1.\n   ;}\n  ;}\n ;r*=r+.5 //optional; fallof quadratically\n ;return vec3(l*gttb,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= mix(22.,9.,timeOscillator)//zoom scale image\n ;v*= mix(22.,9.,timeOscillator)//zoom scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),-.3+.8*vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n //;vec3 col=mix(vec3(0),vec3(.33),timeOscillator)\n ;col=max(col,roads(u,i,t))*2.\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){if(iMouse.w<0.)u-=iMouse.xy\n ;vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}", "image_inputs": [], "common_code": "\nfloat sdSegment( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );}\n\n//i could still keeps the unrotated u AND center, and avoid cumulative-rotation-precision-losses.\n//i think i can not get away with less total rotations.\n\n/*\n//hoped to minimize trigonometry rotations but it seems fruitless\n//currently need to rotate uv AND center for each added rotated road.\n//because both are needed to be independently in thebranch condition.\n\n\n//\n//i need to not only rotate a line, but also offset its height, and that rotates 2 points again.\n//using line, so i only need to rotate 1 point\nfloat line( vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n}\n\n//return distance of p to line trough a and vec2(0)\nfloat l0( vec2 p, vec2 a){\n    vec2 b=vec2(0);\n\tvec2 pa=p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n;}*/\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdcR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1408, 1448, 1469, 1469, 1703], [1705, 1740, 1766, 1766, 1816], [1883, 1934, 1954, 1954, 2009], [2012, 2073, 2094, 2094, 2149], [2216, 2306, 2367, 2367, 3154], [3156, 3232, 3293, 3293, 4196], [4198, 4411, 4472, 4472, 5394], [5397, 5397, 5455, 5455, 5816], [5818, 5818, 5846, 5846, 6322], [6324, 6324, 6364, 6364, 6475]], "test": "untested"}
{"id": "mttcR2", "name": "Hexagonal ┣┳┻┫ ꓕTiles detailings", "author": "ollj", "description": "That floor-LATTICED Gilbert tessellation, where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds straight into neighbor tiles, BUT on a hex lattice (instead of rectangle-lattice)\n", "tags": ["2d", "grid", "hexagon", "road", "tile", "tesselation", "gilbert"], "likes": 4, "viewed": 146, "published": 3, "date": "1699447488", "time_retrieved": "2024-07-30T17:23:24.706640", "image_code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n//https://en.wikipedia.org/wiki/Gilbert_tessellation\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n#define timeOscillator cos(iTime*.6)*.5+.5\n\n#define rot(a) ;mat2 m=rotby(acos(a));u*=m;center*=m\n//rmax paints a road in locally offset-rotated uv, of height [h]\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5//*2.+.3\n ;}\n \n//extra roads need anarbitiarily different alternative hash.\nfloat h21b(ivec2 i\n){return sin(float(33*i.x)-cos(float(15*i.y)))*.5//*2.+.3\n ;}\n\n//branches always go off clockwise of trunks\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.;rmax//purple main road trunk (is not a fork, sets 2 adjacent forks)\n ;if(u.y-center.y<h//top or bottom forks?\n ){//bottom 2 forks are h21b() hashed, not set by neighbors.\n  ;float h=h21b(i+ivec2(-1,1))\n  ;rot(.5)//height of bottom adjacent yellow\n  ;rmax\n   ;if(u.y-center.y<h\n   ){float h=h21b(i+ivec2(1,1))\n    ;rot(.5)//height of bottom adjacent blue \n    ;rmax\n   ;}\n ;}else{//top 2 forks are set by adacent main roads\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;rot(.5)\n  ;rmax\n  ;if(u.y-center.y>h\n  ){float h=h21(i+ivec2(1,1))//height of top adjacent burple\n   ;rot(.5)\n   ;rmax\n  ;}\n ;}\n ;return vec3(r,0,r)\n ;}\n \n//branches always go off clockwise of trunks\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){;float r=0.;rot(-.5);rmax//vellow tiles main road trunk\n ;if(u.y-center.y<h\n  ){//2 bottom road forks\n   ;float h=-h21b(i+ivec2(1,-1))//height left adjacent blue\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21b(i+ivec2(-2,2))//height of top left adjacend purple\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;}\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n   ;}\n  ;}\n ;return vec3(r,r,0)\n ;}\n\n//branches always go off clockwise of trunks\n//BUT NOT HERE\n//...swapping 1 branch with its trunk to ddisrupt large troiangles\n//that emerge from [all forks branch clockwise]\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5));u*=m;center*=m\n ;float r=0.;rmax //blue main trunk\n ;if(u.y-center.y<h\n  ){//2 top branches\n   ;float h=h21(i+ivec2(-1,-1))//height \n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height \n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}\n  ;}else{//2 bottom branches\n      //this trunk was swapped with its branch below\n      ;float h=h21b(i+ivec2(2,2))//connect to right yellow tile \n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n\n  ;if(u.y-center.y<h\n   ){}else{\n    \n    //this branch was swapped with its trunk above\n  ;float h=h21b(i+ivec2(1,-1))//connect to top right purple tile \n  ;rot(.5)\n  ;rmax\n   ;}\n  ;}\n ;return vec3(0,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= mix(66.,9.,timeOscillator) // scale image\n ;v*= mix(66.,9.,timeOscillator)// scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n ;col+=roads(u,i,t)\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}", "image_inputs": [], "common_code": "\nfloat sdSegment( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );}\n\n//i could still keeps the unrotated u AND center, and avoid cumulative-rotation-precision-losses.\n//i think i can not get away with less total rotations.\n\n/*\n//hoped to minimize trigonometry rotations but it seems fruitless\n//currently need to rotate uv AND center for each added rotated road.\n//because both are needed to be independently in thebranch condition.\n\n\n//\n//i need to not only rotate a line, but also offset its height, and that rotates 2 points again.\n//using line, so i only need to rotate 1 point\nfloat line( vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n}\n\n//return distance of p to line trough a and vec2(0)\nfloat l0( vec2 p, vec2 a){\n    vec2 b=vec2(0);\n\tvec2 pa=p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n;}*/\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttcR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1305, 1345, 1366, 1366, 1600], [1602, 1637, 1663, 1663, 1713], [1780, 1780, 1800, 1800, 1859], [1862, 1923, 1944, 1944, 2003], [2005, 2050, 2111, 2111, 2759], [2762, 2807, 2868, 2868, 3631], [3633, 3808, 3869, 3869, 4652], [4655, 4655, 4713, 4713, 5074], [5076, 5076, 5104, 5104, 5504], [5506, 5506, 5546, 5546, 5627]], "test": "untested"}
{"id": "dldyzj", "name": "Hexagonal ┣┳┻┫ ꓕTiles clockwised", "author": "ollj", "description": "That floor-LATTICED Gilbert tessellation, where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds straight into neighbor tiles, BUT on a hex lattice (instead of rectangle-lattice)\n", "tags": ["2d", "grid", "hexagon", "road", "tile", "tesselation", "gilbert"], "likes": 2, "viewed": 131, "published": 3, "date": "1699446725", "time_retrieved": "2024-07-30T17:23:25.659093", "image_code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n#define timeOscillator cos(iTime*.6)*.5+.5\n\n#define rot(a) ;mat2 m=rotby(acos(a));u*=m;center*=m\n//rmax paints a road in locally offset-rotated uv, of height [h]\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5//*2.+.3\n ;}\n \n//extra roads need anarbitiarily different alternative hash.\nfloat h21b(ivec2 i\n){return sin(float(33*i.x)-cos(float(15*i.y)))*.5//*2.+.3\n ;}\n\n//branches always go off clockwise of trunks\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=0.;rmax//purple main road trunk (is not a fork, sets 2 adjacent forks)\n ;if(u.y-center.y<h//top or bottom forks?\n ){//bottom 2 forks are h21b() hashed, not set by neighbors.\n  ;float h=h21b(i+ivec2(-1,1))\n  ;rot(.5)//height of bottom adjacent yellow\n  ;rmax\n   ;if(u.y-center.y<h\n   ){float h=h21b(i+ivec2(1,1))\n    ;rot(.5)//height of bottom adjacent blue \n    ;rmax\n   ;}\n ;}else{//top 2 forks are set by adacent main roads\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;rot(.5)\n  ;rmax\n  ;if(u.y-center.y>h\n  ){float h=h21(i+ivec2(1,1))//height of top adjacent burple\n   ;rot(.5)\n   ;rmax\n  ;}\n ;}\n ;return vec3(r,0,r)\n ;}\n \n//branches always go off clockwise of trunks\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){;float r=0.;rot(-.5);rmax//vellow tiles main road trunk\n ;if(u.y-center.y<h\n  ){//2 bottom road forks\n   ;float h=-h21b(i+ivec2(1,-1))//height left adjacent blue\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21b(i+ivec2(-2,2))//height of top left adjacend purple\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n    ;}\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;rot(.5)\n    ;rmax\n   ;}\n  ;}\n ;return vec3(r,r,0)\n ;}\n\n//branches always go off clockwise of trunks\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5));u*=m;center*=m\n ;float r=0.;rmax //blue main trunk\n ;if(u.y-center.y<h\n  ){//2 top branches\n   ;float h=h21(i+ivec2(-1,-1))//height \n   ;rot(.5)\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height \n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}\n  ;}else{//2 bottom branches\n  ;float h=h21b(i+ivec2(2,2))//connect to top right purple tile \n  ;rot(.5)\n  ;rmax\n  ;if(u.y-center.y<h\n   ){}else{\n    ;float h=h21b(i+ivec2(1,-1))//connect to right yellow tile \n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}\n  ;}\n ;return vec3(0,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= mix(66.,9.,timeOscillator) // scale image\n ;v*= mix(66.,9.,timeOscillator)// scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n ;col+=roads(u,i,t)\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}", "image_inputs": [], "common_code": "\nfloat sdSegment( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );}\n\n//i could still keeps the unrotated u AND center, and avoid cumulative-rotation-precision-losses.\n//i think i can not get away with less total rotations.\n\n/*\n//hoped to minimize trigonometry rotations but it seems fruitless\n//currently need to rotate uv AND center for each added rotated road.\n//because both are needed to be independently in thebranch condition.\n\n\n//\n//i need to not only rotate a line, but also offset its height, and that rotates 2 points again.\n//using line, so i only need to rotate 1 point\nfloat line( vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n}\n\n//return distance of p to line trough a and vec2(0)\nfloat l0( vec2 p, vec2 a){\n    vec2 b=vec2(0);\n\tvec2 pa=p-a, ba = b-a;\n\tfloat h = dot(pa,ba)/dot(ba,ba);\n\treturn length( pa - ba*h );\n;}*/\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1252, 1292, 1313, 1313, 1547], [1549, 1584, 1610, 1610, 1660], [1727, 1727, 1747, 1747, 1806], [1809, 1870, 1891, 1891, 1950], [1952, 1997, 2058, 2058, 2706], [2709, 2754, 2815, 2815, 3578], [3580, 3625, 3686, 3686, 4357], [4360, 4360, 4418, 4418, 4779], [4781, 4781, 4809, 4809, 5209], [5211, 5211, 5251, 5251, 5332]], "test": "untested"}
{"id": "cldyR2", "name": "bluish circles illusion", "author": "FabriceNeyret2", "description": "reproducing Gianni Sarcone's https://twitter.com/gsarcone/status/1721681488628854791", "tags": ["illusion", "2tweets", "perception", "golf", "reproduction"], "likes": 22, "viewed": 277, "published": 3, "date": "1699432782", "time_retrieved": "2024-07-30T17:23:26.663408", "image_code": "// reproducing Gianni Sarcone's https://twitter.com/gsarcone/status/1721681488628854791\n// golfed version below\n\n#define f(v)  sin( 27.*(v) )\n#define S(v) smoothstep( -1., 1., ( f(v) -.7 ) / fwidth(f(v)) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u - .5*R ) / R.y;                   // normalize coordinates\n    float l = length(U), a = atan(U.y,U.x),         // polar coords\n         s1 = S(a - l ),                            // still spirals\n         s2 = S(a + l - .3*iTime );                 // rotating counter-spirals\n    O = max( vec4(1,1,0,0) * max(s1,s2) ,           // yellow spirals\n             s1 * s2 );                             // white intersection\n}\n\n\n\n\n\n\n\n/** // --- 206 chars by timestamp\n\n\n#define f(v)  sin( 27.*( atan(U.y,U.x) - v )) //\n#define S(v) smoothstep( -1., 1., ( f(v) -.7 ) / fwidth(f(v)) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.xyz = iResolution;    \n    float l = length( U -= .5*O.xy ) / O.y;    \n    O += S( l ) + S( .3 * iTime + l ) - O;\n    O.z--;\n}\n\n/**/\n\n\n\n\n\n/** // --- 235/227 chars golfed version:\n\n#define f(v)  sin( 27.*( atan(U.y,U.x) - v )) //\n#define S(v) smoothstep( -1., 1., ( f(v) -.7 ) / fwidth(f(v)) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.xyz = iResolution;\n    U -= .5*O.xy;    \n    float l = length(U) / O.y,\n          a = S( l ),\n          b = S( .3*iTime + l );\n    O = max( vec4(1,1,0,0) * max(a,b) , a * b );\n//  O =      vec4(1,1,0,0) * (a+b)    + a * b  ;  // -8ch, slightly different\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 245, 245, 715]], "test": "untested"}
{"id": "mlcczj", "name": "Nyancats Tetra Race", "author": "cyperus", "description": "Nyancats running on a spherical tetrahedron rotating in hyperspace.", "tags": ["3d", "sdf", "tetrahedron", "nyancat", "stereographic", "hypersphere"], "likes": 3, "viewed": 159, "published": 3, "date": "1699417376", "time_retrieved": "2024-07-30T17:23:27.736539", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Nyancats Tetra Race\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n//  - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 7.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 6.;\nconst float RAY_MIN_DIST = 0.5;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 300;\nfloat RAY_STEP_FACTOR3 = 0.568;\nconst float RAY_PRECISION = 0.001;\n\n// 4D rotation\nfloat ROT_4D_a = 1./60.;\n\n// equal spaced skin width\nconst float SD_w0 = 0.1;\n\n// texture\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(6., 1.);\n\n// data from sdf\nvec4 mat = vec4(0);\n\nfloat map(in vec3 p) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    p = rot4D( p, 2.*PI*ROT_4D_a, sqrt(abs(8.)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = tetra_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    // complex plane   \n    z = cTeraPolyArc2disk(z);\n\n    /// r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (8.<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(8.));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereographic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= 8.;\n\n    // distance estimation\n    float d = log(length(z));\n    \n    // equal spaced skin\n    d =  abs(d) - SD_w0;\n    \n    #if 0\n    st_assert( d != INF, 0 ); // Shows the +INF singularity as a sphere (floating point precision).\n    #else\n    if (d == INF) {d = 1.;} // step through the singularity\n    #endif\n    \n    // torus complex plane, torus angle_u, platonic solid cell_id\n    mat.xy = z; mat.z = au *fracu, mat.w = cell_id;\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos);\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\treturn p.xyz;\n}\n\nvec4 nyancat(vec2 z, float scale, vec2 ju, float time) {   \n    z.x = fract(z.x-time/scale); // run, input z.x in [0., 1.], periodic & cyclic in x-direction (0)\n    z.y = fract(z.y);            // periodic in y-direction (comment in out)\n    z *= scale;\n    z.y -= ju.x*abs(cos(PI*ju.y*time));           // jump, amplitude, frequency\n    return ((.05<z.x&&z.x<.9)&&(0.<z.y&&z.y<.65)) // BB rectangle\n    ? texture(iChannel1,\n        vec2(40./256.*(z.x+floor(6.*fract(ju.y*time))),z.y+.2)) // sprite animation loop\n    : vec4(0.);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation    \n    ROT_4D_a *= 1. * iTime;\n    \n    // anti-aliasing to take a picture\n    vec3 tot = vec3(0.0);\n    #define AA 1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {       \n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o) - iResolution.xy)/iResolution.y;\n        \n        // camera viewport --> worldspace\n        vec3 ro = vec3(0,0,-CAM_DIST);\n        vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n             ro = transform(ro,iTime);\n             rd = normalize(transform(rd,iTime));\n        \n        // ray\n        float px = 2.0/( iResolution.y*CAM_FLE );\n        float t = intersect( ro, rd, px ); // distance hit ray surface\n\n        // color\n        vec3 col_sun = vec3(1.,1.,0.8);\n        vec3 col_sky = vec3(0.7,0.7,1.);\n        \n        // background\n        vec3 col = col_sky;\n        \n        // object surface\n        if (t >= 0.) {\n            // surface properties\n            vec3 p = ro + rd * t;\n            vec3 n = calcNormal( p, 0.001);\n            \n            // platonic solid sector id\n            float ps_id = mat.w;\n            col = h2rgb(ps_id/float(4));\n            \n            // uv-coords\n            vec2 mat_uv = 0.5*vec2(mat.z, atan(mat.y,mat.x))/PI;\n            vec2 mat_ny = mat_uv;\n            \n            // uv-grid\n            mat_uv.xy *= vec2(3.*1.,3.);\n            col *= 0.5+ 0.5*smoothstep( -TEX_UV_SHARPNESS,TEX_UV_SHARPNESS\n                                      , sin(2.*PI*mat_uv.x)*sin(2.*PI*mat_uv.y));\n            // nyancat            \n            mat_ny += vec2(0.,1./3.);\n            mat_ny *= vec2(7.,1.);\n            vec4 tex = nyancat(mat_ny.xy, 3., vec2(0.1,1.), 0.5*iTime);\n            col = mix(col,tex.rgb,tex.a);\n\n            // lighting\n            // point_light\n            vec3 point_lo = vec3(0, -10, 0);\n            vec3 point_ld = normalize(point_lo - p);\n\n            // phong: ambient- diffuse- specular- light reflections\n            col = col * 0.5  * col_sky\n                + col * 0.25 * col_sun * clamp(dot(point_ld, n), 0., 1.)\n                + col * 0.75 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n            // fresnel\n            col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * col_sky;\n        }\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // gamma correction\n    fragColor = vec4(rgb2srgb(tot),1.);\n}\n", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cTeraPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 15; // poles\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n/// 4D transformation\nvec4 sp3to4D(vec3 p3) {\n    float r2_p3=dot(p3,p3);\n    if(r2_p3<=1.) {               // Pn\n        float k = 2./(1.+r2_p3);\n        return vec4(k*p3,(1.-k));}\n    else {                        // Ps TODO: Spherical singularity does not disappear! That would be too easy. :)\n        p3 = p3/r2_p3; r2_p3 = dot(p3,p3);\n        float k = 2./(1.+r2_p3);\n        return vec4(k*p3,-(1.-k));}\n}\n\nvec3 sp4to3D(vec4 p4) {\n    if(p4.w<=0.) {                 // Pn\n        float k = 1./(1.-p4.w);\n        return k*p4.xyz;}\n    else {                         // Ps TODO: Spherical singularity does not disappear! That would be too easy. :)\n        float k = 1./(1.+p4.w);\n        vec3 p3 = k*p4.xyz;\n        return p3/dot(p3,p3);}\n}\n\nvec3 rot4D(in vec3 p, in float t, in float r_inv) {\n    p /=r_inv;            // normalize to hyper-unit-circle (unit-sphere)\n    vec4 p4 = sp3to4D(p); // forward project 3d hyper-plane to 4d hyper-unit-sphere\n    // rotations\n    p4.xw = cmul(p4.xw, vec2(cos(-t),sin(-t)));\n    p4.xy = cmul(p4.xy, vec2(cos(-0.7*t),sin(-0.7*t)));\n    p4.yz = cmul(p4.yz, vec2(cos(-0.3*t),sin(-0.3*t)));\n    p = sp4to3D(p4);      // back project 4d hyper-unit-sphere to 3d hyper-plane (3d cartesian space)\n    p *=r_inv;            // unnormalize from hyper-unit-circle (unit-sphere)\n    return p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr){\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264°\n    const float a30 = PI/6.;             // 30°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45°\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/articles/intersectors/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n \n// colorspace transformations\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\n// srgb <--> rgb (linear)\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcczj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[966, 966, 988, 1006, 2474], [2476, 2476, 2530, 2530, 3367], [3369, 3369, 3414, 3414, 3576], [3578, 3578, 3620, 3646, 3811], [3813, 3813, 3869, 3869, 4347], [4349, 4349, 4404, 4426, 6961]], "test": "untested"}
{"id": "mt3yRj", "name": "spqr planetary survey: europa", "author": "spqr", "description": "a", "tags": ["a"], "likes": 10, "viewed": 267, "published": 3, "date": "1699400760", "time_retrieved": "2024-07-30T17:23:28.747835", "image_code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/articles/fbmsdf\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\n\n\nvec3 jitter (float t ) {\n  return vec3(rnd(t), 0., rnd(t + 6.124))/3.;\n}\n\nvec3 sino3 ( float t ) {\n  vec3 r = vec3(0);\n  for (float i = 0. ; i < 19.; i ++ ){\n    r += vec3( sin(t + i), cos(t-i *.79),0)/pow((i+1.),1.4);  \n  }\n  return r/3.;\n\n}\nfloat sino ( float t ) {\n  float r = 0.;\n  float scale = 1.;\n  for (float i = 0. ; i < 10.; i ++ ){\n    r +=  sin(t + rnd(t))/scale;\n    scale *= 2.1;\n  }\n  return r;\n\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\nfloat cone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 1; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbmPositive( in vec3 p, in float th, in float d )\n{\n\n\n   \n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 10;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        \n        //mutate landscape\n        //float porous = mix(0.02,0.1,sin(tick(iTime/10000.))) + .01;  // default 0.1;\n        float porous = .1;\n        \n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n  \n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    \n    return vec2( d, t );\n}    \n\nvec2 sdFbmNegative( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        \n        //mutate landscape\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        //float porous = .15;\n        \n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n  \n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    \n    return vec2( d, t );\n}    \n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n   \n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    \n    \n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\n\nfloat dolmens (vec3 p) {\n  float box = box(p, vec3(.3,.3,.3));\n  return box;\n\n}\n\nfloat hash (float t ) {\n  return fract(sin(t * 123.853 + 6467.166) * 992.124); \n}\n\nvec3 vollight;\n\nint matter;\nvec2 map( in vec3 p, in float dis )\n{\n    // geo \n\n  \n    //p.y += sin((p.x/17.)+ iTime/2.1)*1.; \n    p.y += sin((p.z/15.12)+ iTime/4.)*.5; \n    p.y += sin((p.x/11.12)+ iTime/3.)*.5; \n   \n    \n    \n    p.y *= .8;\n    \n     vec3 w = p;\n    \n    // varies the base terrain in an interesting way\n    p.y *= (sin(p.z/3.2)*.5 + .5 ) + .4;\n    p.y *= (sin(p.x/3.91)*.5 + .5 ) + .45;\n    \n    vec3 q = p;\n    \n  \n\n    float d = p.y;\n    \n    \n \n    p.xz += (sin(p.x) + cos(p.z)/1000.) * .5; // seems to 'tilt' the formations\n    q.y += (sin(p.x) + cos(p.z)/1000.) * .5; // seems to 'tilt' the formations\n    \n    vec2 dt = sdFbmPositive( p * vec3(1), dis*precis, d );\n  \n    vec2 et = sdFbmNegative( q * vec3(1), dis*precis, d)/2.;\n    \n    \n   \n  \n    \n    float level = sin(iTime/14.1) * .5 + .3;  \n\n\n    //return dt;\n    vec2 ice = min(dt,et);\n    vec2 water = vec2(level + w.y,0.);\n    vec2 final =  min(water,ice);\n    \n\n    return final;\n   \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t,0.).x;\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nfloat probe( in vec3 ro, in vec3 rd)\n{\n\n    float t,dd;\n    vec3 pos = vec3(0);\n    for( float i = 0.; i < 120.;i++ )\n    {\n    \n       pos = ro + t*rd;\n    \n\t   float h = map( pos, 0. ).x;\n       \n       if ( h < .1 ) {\n         break;\n       }\n        t += h;\n       dd += t;\n      \n    \n    }\n    return dd;\n   \n}\n\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\n\n\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d,0.).x/d);\n}\n\nfloat getWave(float t) {\n  float str = 1.;\n  float fre = 1.;\n  float total = 0.;\n  for (float i=0.; i < 3.; i++) {\n    total += cos(t * fre) * str; \n    fre *=2.1;\n    str *= .5;\n  }\n  return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 z = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n    float pi = acos(-1.);\n \n  \n  \n\n    // nav\n    float tt = iTime * 3. + 141.;\n \n \n    float height = getWave(iTime)/2.5;\n    float forward = tt * 2.5 ;\n    ro = vec3(0.0, height, forward); \n    ro.y += 1.;\n    ta = ro + vec3(0,0,1);\n   \n   \n    vec3 ro_off = getPos(tt);\n    ro.x /= 3.;\n    vec3 ta_off = getPos(tt + 7.11);\n    \n    ro += ro_off/36.;\n    ta += ta_off/66.;\n    \n    \n    float jitter = rnd(tick(tt))/79. * sino(tt);\n    ro.y += jitter;\n    //ta.y -= jitter;\n    \n    \n    \n    vec3 arm = vec3(0,0,10);\n    arm.xz *= rot(sin(iTime/6.7) * 2.1);///6.) * (3.14/2.) + (3.14/2.));\n   \n    //ta += arm/3.;\n   \n   \n   \n   \n    // camera matrix\n    \n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(z.xy,2.0));\n    \n    rd.xy *= rot(sin(iTime)*.1);\n    \n    float t = 0.;\n   \n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float d;\n    float i;\n    \n    \n    \n    // spotlight\n    \n    //vec3 volarm = vec3(cos(iTime), .5 , sin(iTime))*0.5 ;\n    //vollight = ro + vec3(0,-3.4,3.5) + volarm;\n    //vec3 voltarget = vec3(cos(iTime*2.),3.*sin(iTime),sin(iTime*2.))*13.;\n    //float atm = 0.;\n    \n    // march\n    \n\tfor( i=0.; i<550.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\td = map( pos, 0. ).x*flip ;\n       \n        \n        //vec3 spotdir = vollight - pos;\n        //vec3 globalspotdir = normalize(voltarget - vollight);\n        //float spotdist = length(vollight-pos);\n        \n        //float cone = clamp( max(0., dot(normalize(spotdir),globalspotdir)) * .3, 0., 1.);\n        //cone = pow(cone,2.);// + abs(sin(iTime) * 10.));\n       \n        //atm +=  cone * (.1/pow(spotdist,2.));\n        \n        \n        \n        if( d<.001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += d ; // overstepping\n       dd += t;\n\t}\n   \n\t\n    \n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 sunlight = vec3(0,10,-10);\n    sunlight.xz *= rot(iTime * .98);\n    //sunlight.yz *= rot(iTime * .28);\n\n\n\n    // color\n   \n    \n    float shadow = shadow(pos, normalize(sunlight), .1, length(sunlight-pos));\n    float dif = dot(normalize(sunlight),nor) * 10.7; \n    float spec= pow(max(dot(reflect(sunlight,nor),-rd),.0), 3.2);\n    float fren = pow(1.+dot(nor,rd),1.);\n    float sss = getsss(pos,rd,1.); // \"10\" makes it look like the peaks are sunlit\n    float ao = pow(1. - i/1000.,8.);\n  \n    vec3 col = vec3(1);\n    vec3 hue = vec3(.7,.8,1.);\n    col *= dif * .2 * hue;\n    col *= shadow * hue * .25;\n    col += spec * .001 * hue;  \n    col += sss * 6.6;  \n    col += fren * hue;\n    col *= ao * hue;\n    col = mix(col, hue, pow(i/1500.,10.3));\n    \n  \n  \n \n  \n    \n    if (! hit ) {\n  \n      float x = dot(rd, normalize(sunlight))*.5 + .5;\n      x *= x * x;\n      col = vec3(.2,.3,.8) * x * .8 * (1.-rd.y);\n      if ( rd.y < .02) {\n        col *= .044;\n      }\n    }\n    //col += atm * 3.3;\n    // fog\n    \n  \n  \n   \n    col = pow(col,vec3(.5));\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3yRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 233, 233, 287], [290, 290, 314, 314, 362], [364, 364, 388, 388, 532], [533, 533, 557, 557, 702], [703, 703, 726, 726, 829], [830, 830, 852, 852, 1060], [1062, 1062, 1116, 1171, 1395], [1397, 1397, 1421, 1421, 1623], [1628, 1628, 1650, 1650, 1726], [1728, 1728, 1756, 1756, 1808], [1809, 1809, 1848, 1848, 1920], [1921, 1921, 1950, 1950, 1985], [1987, 1987, 2016, 2016, 2051], [2053, 2053, 2085, 2085, 2120], [2123, 2123, 2164, 2164, 2236], [2239, 2239, 2280, 2280, 2352], [2354, 2354, 2381, 2381, 2407], [2408, 2408, 2445, 2586, 2801], [2803, 2826, 2851, 2851, 2929], [2931, 2931, 2954, 2954, 3085], [3086, 3086, 3144, 3186, 4037], [4043, 4043, 4101, 4137, 4981], [4988, 4988, 5040, 5040, 5231], [5327, 5327, 5355, 5355, 5381], [5384, 5384, 5404, 5404, 5449], [5450, 5450, 5482, 5482, 5508], [5528, 5528, 5552, 5552, 5607], [5609, 5609, 5632, 5632, 5690], [5720, 5720, 5757, 5817, 6662], [6664, 6664, 6728, 6728, 6974], [6977, 6977, 7015, 7015, 7293], [7297, 7297, 7341, 7341, 7563], [7570, 7570, 7612, 7612, 7662], [7666, 7666, 7702, 7702, 7752], [7754, 7754, 7778, 7778, 7954], [7956, 7956, 8013, 8013, 11174]], "test": "untested"}
{"id": "Dlccz2", "name": "spqr planetary survey: ganymede", "author": "spqr", "description": "a", "tags": ["a"], "likes": 2, "viewed": 167, "published": 3, "date": "1699399449", "time_retrieved": "2024-07-30T17:23:29.746166", "image_code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/articles/fbmsdf\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 1.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return vec3(s.x, s.y, s.z);\n}\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\nvec2 unit ( float t ) {\n  float a =  fract( sin(t * 1841.63623 + 2714.23423))* 324.114;\n  float x = cos(a);\n  float y = sin(a);\n  return vec2(x,y);\n\n}\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n/*\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n*/\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 4; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}    \n\n\n\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<11; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\nvec2 map( in vec3 p, in float dis )\n{\n    \n   \n    float spot = sph(p - ro   - vec3(0,0,2), .01); \n    \n    p.y *= .5; // default 1.0\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    d = p.y;\n    // terrain\n    vec2 dt = sdFbm( p, dis*precis, d );\n    //vec2 et = sdFbm( p, dis*precis, -d );\n   \n    //float hole = box(p - ro, vec3(1.));\n    //dt.x = max(dt.x, -hole);\n    dt.x = min(dt.x, spot);\n    return dt;\n    //return max(dt,-et);\n}\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\nvec3 jump( float t ) {\n  float sc = 4.;\n  float y = sin(iTime);\n  vec2 a = unit(floor(t)) *sc *y;;\n  vec2 b = unit(floor(t)+1.)*sc*y;\n  \n  float height = 5.6 + sin(iTime);\n  return ( mix( vec3(a.x, height,a.y), vec3(b.x,height,b.y), fract(t)));  \n\n}\n\nvec2 offset (float t ) {\n  \n  t /= 1.;\n  float a = cos(t) + cos(t*2.1)/2.3 + cos(t*4.2)/ 4.1;\n  float b = cos(t*1.1) + cos(t*1.9)/1.7 + cos(t*4.)/ 3.6;\n \n  \n \n  return vec2(a,b)/10.;\n\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n       \n    float time = iTime * 1.3;\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n  \n  \n    // navigation\n  \n    float n = time;   \n\n    vec3 fwd = vec3(0,0,1.) * iTime;\n    float ix = n * .37;\n \n    vec3 ro = getPos(ix)*4. + fwd;\n    vec3 ta = getPos(ix - 8.3141)*4. + fwd;\n    ro.y *= .5;\n    ta.y *= .1;\n    \n    ro.y += .3;\n    ta.y += .2;\n\n/* \n    vec3 pole = vec3( cos(tt), 0., sin(-tt) )* 1.2;   \n    ro = vec3(offset(n), tt);\n    ta = vec3(offset(n+1.), tt +2.*sin(iTime/4.1));\n    ro.y +=.5;\n    ro += pole;\n    ta += pole;\n*/    \n    \n   \n    \n\n    \n    // camera matrix\t\n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(p.xy,2.0));\n    \n   \n\n\n  \n\n    // raymarch\n    float t = 0.;\n    vec2 h = vec2(0.0,0.0);\n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float i;\n\tfor( i=0.; i<300.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\th = map( pos, t )*flip;\n        if( abs(h.x)<.0001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += h.x   * 1.; // overstepping\n       dd += t;\n\t}\n   \n\t\n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 light = normalize(vec3(1,0,3));\n    light.xz *= rot(iTime*.31);\n    \n    float shade = dot(nor,light) + .45; \n    float ao = pow(1. - i/300.,8.);\n    \n    float spec= pow(max(dot(reflect(light,nor),-rd),.0), 17.);\n    //float sss = getsss(ro,rd,1.2);\n    vec3 col = vec3(1.,.5,.3);\n    col *= pow(shade,1.2);\n    col *= pow(ao,1.2) ;\n    //col += spec  ;\n    //col *= sss * 20.;\n    \n    float spot = length(pos - ((ro + vec3(0.,0.,2.))  ));\n    \n    \n    col += .001/pow(spot,10.) * vec3(.6,.5,1);\n   \n  \n    \n    if (! hit) {\n      col = vec3(.9,.2,.1) * rd.y/.4; \n    }\n    \n    // fog\n    col = mix(col, vec3(.3), i/2000.);\n  \n  \n   \n    col = pow(col,vec3(.35));\n    \n  \n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlccz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 235, 235, 338], [339, 339, 361, 361, 569], [571, 571, 625, 680, 904], [906, 906, 930, 930, 1150], [1152, 1152, 1175, 1175, 1229], [1230, 1230, 1253, 1253, 1380], [1381, 1381, 1409, 1409, 1461], [1463, 1463, 1492, 1492, 1527], [1529, 1529, 1558, 1558, 1593], [1595, 1595, 1627, 1627, 1662], [1665, 1665, 1706, 1706, 1778], [1781, 1781, 1822, 1822, 1894], [1896, 1896, 1923, 1923, 1949], [1950, 1950, 1987, 2128, 2343], [2345, 2368, 2393, 2393, 2471], [2472, 2921, 2944, 2944, 3075], [3076, 3076, 3126, 3162, 3923], [3932, 3932, 3956, 3956, 4177], [4179, 4179, 4231, 4231, 4408], [4504, 4504, 4532, 4532, 4558], [4561, 4561, 4581, 4581, 4626], [4627, 4627, 4659, 4659, 4685], [4704, 4704, 4741, 4741, 5164], [5167, 5167, 5211, 5211, 5433], [5437, 5437, 5459, 5459, 5535], [5536, 5536, 5558, 5558, 5785], [5787, 5787, 5811, 5811, 5972], [5974, 5974, 6016, 6016, 6066], [6069, 6069, 6126, 6126, 8117]], "test": "untested"}
{"id": "cl3yRj", "name": "Hexagonal ┣┳┻┫ ꓕTiles Beta", "author": "ollj", "description": "That floor-LATTICED Gilbert tessellation, where a straight main road is either horizontal or vertical, and randomly shifted, and that then bleeds straight into neighbor tiles, BUT on a hex lattice (instead of rectangle-lattice)\n", "tags": ["2d", "grid", "hexagon", "road", "tile", "tesselation", "gilbert"], "likes": 3, "viewed": 165, "published": 3, "date": "1699389088", "time_retrieved": "2024-07-30T17:23:30.905067", "image_code": "//A proper noun for this may be \"Gilbert tessellation\", to look up in math texts.\n\n//On shadertoy, for speed, we tend to do floor()-lattices before doing a Voronoi.\n//same seems to be true for gilbert tesselation, for speed on smaller neighborhoods.\n\n// parent shader \"Hexagonal Grid Traversal - 2D\" \n// was Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//removed the traversal and the AA, but really needed everything else.\n//especially hexagonGetID() and id2center()\n\n\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/NlKfWt\n//older approach has non-parallel lines           : https://www.shadertoy.com/view/7ldfzS\n//honorable aunt                    wiggles around: https://www.shadertoy.com/view/DsGBDK\n//honorable uncle    working in industrial storage: https://www.shadertoy.com/view/dtccWn\n//in memory to         something similar was tried: https://www.shadertoy.com/view/clfSDj\n\n#define timeOscillator cos(iTime*.6)*.5+.5\n#define rmax r=max(r,1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h))))\n\n// return the hexagon that p belongs to\nivec2 uv2id(vec2 p\n){vec2  q=vec2( p.x, p.x*.5+p.y*0.8660254037)\n ;ivec2 i = ivec2(floor(q))\n ;vec2  f =       fract(q)\n ;int v = mod3(i.x+i.y)\n ;ivec2 id = i + v\n ;if( v==2 ) id -= (f.x>f.y)?ivec2(1,2):ivec2(2,1)\n ;return ivec2( id.x, (2*id.y-id.x)/3 );}\n\n// return the center of an hexagon\nvec2 id2center(ivec2 id\n){return vec2(float(id.x),float(id.y)*1.732050807);}\n\n//=============================================================\n\nfloat h21(ivec2 i\n){return sin(float(15*i.x)+cos(float(33*i.y)))*.5//*2.+.3\n ;}\n\nvec3 road0(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){float r=1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h)))\n ;if(u.y-center.y<h\n ){\n  ;//hal=.1//below red main road\n  ;//add green road\n\n ;}else{\n  ;//hal=0.//above red main road\n  ;float h=h21(i+ivec2(-1,1))//height of top adjacent blue\n  ;mat2 m=rotby(acos(.5));u*=m;center*=m\n  ;rmax\n  ;if(u.y-center.y<h\n  ){\n  ;}else{\n   ;float h=h21(i+ivec2(1,1))//height of top adjacent green\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;\n  ;}\n ;}\n ;return vec3(r,0,r)\n ;}\n \n\nvec3 road1(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(-.5));u*=m;center*=m\n ;float r=1.-smoothstep(-kPtRa,kPtRa,sdSegment(u-center,vec2(-2,h),vec2(2,h)))\n  ;if(u.y-center.y<h\n  ){\n  ;}else{\n   ;float h=-h21(i+ivec2(2,0))//height of right adjacent red\n   //-h21 is negated cause a clockwise meets a counterclockwise!!\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n   ;}else{\n    ;float h=-h21(i+ivec2(1,-1))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}\n  ;}\n ;return vec3(r,r,0)\n ;}\n\n\nvec3 road2(vec2 u,vec2 center, float kPtRa,float h,ivec2 i\n){mat2 m=rotby(acos(.5))\n ;float r=0.\n ;u*=m\n ;center*=m\n ;rmax\n ;if(u.y-center.y<h\n  ){  \n   ;float h=h21(i+ivec2(-1,-1))//height of right adjacent re\n   ;mat2 m=rotby(acos(.5));u*=m;center*=m\n   ;rmax\n   ;if(u.y-center.y<h\n   ){\n    ;float h=-h21(i+ivec2(-2,0))//height of right adjacent red\n    //-h21 is negated cause a clockwise meets a counterclockwise!!\n    ;mat2 m=rotby(acos(.5));u*=m;center*=m\n    ;rmax\n   ;}else{\n   ;}\n  ;}else{\n  ;}\n ;return vec3(0,r,r)\n ;}\n\n\nvec3 roads(vec2 u,ivec2 i,int t//uvScreen,hexID,hexType\n){const float kPtRa = 0.3;\n ;vec2 center=id2center(i);\n ;//vec2 r=1.-smoothstep(-v*0.5,v*0.5,vec2(sdDisk(u,center,kPtRa)))\n ;vec3 r;\n ;float h=h21(i)\n ;     if(t==0)r=road0(u,center,kPtRa,h,i)\n ;else if(t==1)r=road1(u,center,kPtRa,h,i)\n ;else         r=road2(u,center,kPtRa,h,i)\n ;r=mix(vec3(max(max(r.x,r.y),r.z)),r,timeOscillator)//mix road color\n ;return r\n ;}\n\nvec3 render(vec2 u,vec2 v\n){ ;// scale image\n ;u*= 9.// scale image\n ;v*= 9.// scale image\n ;ivec2 i=uv2id(u)\n ;int t=(mod3(i.x))\n ;float backgroundBrightness=.5\n ;vec3 col=mix(vec3(0),vec3(t)/2.*backgroundBrightness,timeOscillator)//mix background tiles showing\n ;col+=roads(u,i,t)\n //vec3  col=vec3(fract(float(i)/3.))\n ;// draw ray\n ;// prepare for hex-traverse\n ;return col;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec3 c=render((u-iResolution.xy)/iResolution.y,1./iResolution.xy)\n ;o=vec4(c,1);}", "image_inputs": [], "common_code": "float sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdDisk( vec2 p, vec2 a, float r ){\n\treturn length(p-a)-r;}\n\n//return matrix that rotates by t\nmat2 rotby(float t\n){float ct=cos(t),st=sin(t)\n ;return mat2(ct,-st, st, ct);}\n\n//rotate 60deg clockwise\n#define r60 (mat2(-1,sqrt(3.),-1,-sqrt(3.))*.5)\n\nint   mod3(int   n){return (n<0) ? 2-((2-n)%3) : n%3;}\n//ivec2 mod3(ivec2 n){return ivec2(mod3(n.x),mod3(n.y));}//not needed\n    // Other methods of computing mod3:           // PC-WebGL  Native-OpenGL  Android WebGL\n    //\n    // 1.  return (n<0) ? 2-((2-n)%3) : n%3;      //    Ok        Ok            Ok \n    // 2.  return int((uint(n)+0x80000001U)%3u);  //    Ok        Ok            Broken\n    // 3.  n %= 3; return (n<0)?n+3:n;            //    Ok        Broken        Ok\n    // 4.  n %= 3; n+=((n>>31)&3); return n;      //    Ok        Broken        Ok\n    // 5.  return ((n%3)+3)%3;                    //    Ok        Broken        Ok\n    // 6.  return int[](1,2,0,1,2)[n%3+2];        //    Ok        Broken        Ok\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3yRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1133, 1173, 1194, 1194, 1428], [1430, 1465, 1491, 1491, 1541], [1608, 1608, 1628, 1628, 1687], [1689, 1689, 1750, 1750, 2240], [2244, 2244, 2305, 2305, 2894], [2897, 2897, 2958, 2958, 3426], [3429, 3429, 3487, 3487, 3848], [3850, 3850, 3878, 3878, 4229], [4231, 4231, 4271, 4271, 4352]], "test": "untested"}
{"id": "mtdcRS", "name": "playing wth hardware derivatives", "author": "FabriceNeyret2", "description": ".", "tags": ["dfdx", "dfdy", "fwidth", "gradients", "hardwarederivatives"], "likes": 20, "viewed": 310, "published": 3, "date": "1699376707", "time_retrieved": "2024-07-30T17:23:31.901403", "image_code": "#define T(ch)  O = texture(ch, u/R ), H = float(textureSize(ch,0).y)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, G,\n          U = ( u+u - R ) / R.y,\n          L = cos(3.*iTime+vec2(0,33));              // rotating light direction\n    float H,s,l,d, a=1.;                             // a = amplification\n    T(iChannel3);                                    // load texture in O, size in H\n    s = 10.*R.y/H;                                   // normalization for resolution invariance\n    l = length(O.rgb);                               // luminance\n    G = vec2( dFdx(l), dFdy(l) ) *s;                 // luminance gradient \n    d = fwidth(l) *s;                                // luminance gradient (approx)\n    vec4 D = fwidth(O)*s, Gx = dFdx(O)*s, Gy = dFdy(O)*s; // color gradients\n    \n    int i = int(iTime)%10;                           // cycles all modes\n    \n    O =  i==0 ? O/D/5.                               // force color gradients to 1 \n       : i==1 ? vec4(l/d/5.)                         // force luminance gradients to 1 \n       \n       : i==2 ? D                                    // show color gradient (approx)\n       : i==3 ? sqrt(Gx*Gx+Gy*Gy)                    // show color gradient\n       : i==4 ? vec4( d )                            // show luminance gradient amplitude (approx)\n       : i==5 ? vec4( length(G) )                    // show luminance gradient amplitude\n       \n       : i==6 ? vec4(.5+ a*G,0,0)                    // show luminance gradient vector\n       : i==7 ? vec4(.5+ a*dot( G, normalize(U) ) )  // radial light luminance gradient \n       : i==8 ? .5+ a* ( Gx * L.x + Gy * L.y )       // light color gradient\n       :        vec4( .5+ a* dot( G, L ) );          // light luminance gradient\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 108, 108, 1770]], "test": "untested"}
{"id": "ctdyzB", "name": "Graph: f(x) = x - a", "author": "kalisina", "description": "Graph of f(x) = x - a\n\nFollowing my previous graph of f(x) = x\nhttps://www.shadertoy.com/view/DsVBWy\n\nand my graph of f(x) = x*x\nhttps://www.shadertoy.com/view/DtccRH\n", "tags": ["beginner", "graph", "maths"], "likes": 1, "viewed": 136, "published": 3, "date": "1699369892", "time_retrieved": "2024-07-30T17:23:32.823937", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float lineWidth = 0.01;\n    float a = sin(iTime);\n    \n    vec3 col = vec3(smoothstep(2.0 / iResolution.y, 0.0, abs(uv.x - uv.y - a) - lineWidth));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 359]], "test": "untested"}
{"id": "DttcRS", "name": "Sliding circle optical illusion", "author": "thepinkpanzer", "description": "Managed to recreate a classic optical illusion. Anti-aliasing would be a nice improvement if anyone wants something to do.", "tags": ["opticalillusion", "moving", "vision"], "likes": 18, "viewed": 255, "published": 3, "date": "1699362656", "time_retrieved": "2024-07-30T17:23:33.885100", "image_code": "#define PI 3.14159265\n// converts phase to color\nvec4 color(float t)\n{\n    vec4 c = 0.5 + 0.5*cos(vec4(0, 0.6667*PI, 1.3333*PI, 0)+t);\n    c = tanh(2.5*normalize(c));\n    c*= c;\n    //c/= max(max(c.x, c.y), c.z);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates relative to screen center and direction of travel\n    vec2 centered = fragCoord - iResolution.xy/2.;\n    float d0      = random(floor(iTime*DIRFREQ)*PI);\n    float d1      = random( ceil(iTime*DIRFREQ)*PI);\n    float dd      = d1 - d0;\n    // always ensure we take the shortest path to the next direction (rotate by less than 180 deg)\n    dd            = fract(dd + 0.5);\n    dd           -= 0.5;\n    float theta   = 2.*PI*mix(d0, d0+dd, smoothstep(0.5-MOVETIME, 0.5+MOVETIME, fract(iTime*DIRFREQ)));\n    vec2 direc    = vec2(sin(theta), cos(theta));\n    \n    // background color\n    fragColor = vec4(0.5);\n    \n    // inside the ring\n    if (abs(length(centered) - CIRCLERADIUS) < CIRCLEWIDTH/2.)\n    {\n        // generate padding phase offset\n        float padding = (CIRCLEWIDTH*CIRCLEWIDTH/4.-(length(centered) - CIRCLERADIUS)*(length(centered) - CIRCLERADIUS));\n        padding /= (CIRCLEWIDTH/2.);\n        padding /= PADTHICKNESS;\n        padding  = min(1., padding);\n        // padding = 0 inside the ring\n        padding  = 1.-padding;\n        // padding is a different sign on the inner edge to outer (grad(padding) is the same)\n        padding *= sign(CIRCLERADIUS - length(centered));\n        \n        fragColor = color(CYCLEFREQ*iTime + atan(centered.y, centered.x)+padding*dot(normalize(centered), direc)*PADSTRENGTH);\n    }\n    else if (length(centered) < CIRCLERADIUS)\n    {\n        // inner circle (draw arrow)\n        // normal to direc and rotated-coordinates position\n        vec2 ndirec = vec2(direc.y, -direc.x);\n        vec2 rotpos = vec2(dot(ndirec, centered), dot(direc, centered));\n        \n        bool arrow  = (0.4*CIRCLERADIUS-(rotpos.y) > 2.*abs(rotpos.x) && (rotpos.y) > CIRCLERADIUS/20.) || (abs(rotpos.x) < CIRCLERADIUS/20. && rotpos.y > -0.4*CIRCLERADIUS && rotpos.y < CIRCLERADIUS/19.);\n        \n        \n        if (arrow)\n        {\n            fragColor *= 0.7;\n        }\n    }\n}", "image_inputs": [], "common_code": "// Size and thickness of the circle\n#define CIRCLERADIUS iResolution.y/3.5\n#define CIRCLEWIDTH  iResolution.y/8.\n// Size of the 'pad' which has a different phase to the rest\n#define PADTHICKNESS 7.\n// Amount by which the pad's phase changes relative to the main ring\n#define PADSTRENGTH  2.\n// Frequency at which directions change, and (half) the fraction of time spent changing directions\n#define DIRFREQ      0.4\n#define MOVETIME     0.3\n// Frequency of colour cycling\n#define CYCLEFREQ    20.\n\nfloat random(float seed)\n{\n    seed  = fract(seed) + 12.14243;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 1.54324;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 1.54324;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 15.4324;\n    return fract(seed*seed);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 49, 70, 70, 228], [229, 229, 286, 355, 2222]], "test": "untested"}
{"id": "dttyD7", "name": "buggy mandelbulb", "author": "ninofiliu", "description": "buggy mandelbulb", "tags": ["raymarching"], "likes": 0, "viewed": 136, "published": 3, "date": "1699312792", "time_retrieved": "2024-07-30T17:23:34.851515", "image_code": "// lygia\n\nvec2 cart2polar(in vec2 st) {\n    return vec2(atan(st.y, st.x), length(st));\n}\n\nvec3 cart2polar( in vec3 st ) {\n    float r = length(st);\n    float theta = acos(st.z/r);\n    float phi = atan(st.y, st.x);\n    return vec3(r, theta, phi);\n}\n\nvec2 mandelbulbSDF( in vec3 st ) {\n   vec3 zeta = st;\n   float m = dot(st,st);\n   float dz = 1.;\n   float n = mod(iTime, 10.);\n   const int maxiterations = 20;\n   float iterations = 0.0;\n   float r = 0.0; \n   float dr = 1.0;\n   for (int i = 0; i < maxiterations; i+=1) {\n       dz = n*pow(m, 3.5)*dz + 1.0;\n       vec3 sphericalZ = cart2polar( zeta ); \n       float newx = pow(sphericalZ.x, n) * sin(sphericalZ.y*n) * cos(sphericalZ.z*n);\n       float newy = pow(sphericalZ.x, n) * sin(sphericalZ.y*n) * sin(sphericalZ.z*n);\n       float newz = pow(sphericalZ.x, n) * cos(sphericalZ.y*n);\n       zeta.x = newx + st.x;\n       zeta.y = newy + st.y;\n       zeta.z = newz + st.z;\n\n       m = dot(zeta, zeta);\n       if ( m > 2.0 )\n         break;\n   }\n \n   // distance estimation through the Hubbard-Douady potential from Inigo Quilez\n   return vec2(0.25*log(m) * sqrt(m) / dz, iterations);\n}\n\n// mine\n\nfloat sdf(vec3 p) {\n    return mandelbulbSDF(p).x;\n}\n\nconst float rot_speed = 0.1;\nconst float surface = 0.001;\nconst int max_steps = 100;\nconst float zoom = 1.5;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cam_pos = 1.*vec3(2.*cos(rot_speed*iTime), 2.*sin(rot_speed*iTime), 1.);\n    vec3 cam_dir = normalize(-cam_pos); // looks at center\n    vec3 cam_x = vec3(cam_dir.y, -cam_dir.x, 0);\n    vec3 cam_y = cross(cam_x, cam_dir);\n    \n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/max(iResolution.x, iResolution.y);\n    uv.y *= iResolution.y/max(iResolution.x, iResolution.y);\n    vec3 ray_dir = normalize(cam_dir + uv.x * cam_x / zoom + uv.y * cam_y / zoom);\n    \n    vec3 p = cam_pos;\n    int i = 0;\n    while(i < max_steps) {\n        float d = sdf(p);\n        if (d < surface) { break; }\n        p += ray_dir * 0.99*d;\n        i++;\n    }\n    vec3 normal = normalize(sdf(p) - vec3(\n        sdf(p+5.*surface*vec3(1.,0.,0.)),\n        sdf(p+5.*surface*vec3(0.,1.,0.)),\n        sdf(p+5.*surface*vec3(0.,0.,1.))\n    ));\n    \n    // half lambert with hemisphere light\n    float l = 0.5+0.5*dot(normal, normalize(vec3(0.5,0.,-1.)));\n    fragColor = vec4(vec3(l),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 39, 39, 88], [90, 90, 121, 121, 247], [249, 249, 283, 283, 1137], [1148, 1148, 1167, 1167, 1200], [1312, 1312, 1367, 1367, 2363]], "test": "untested"}
{"id": "DttcW8", "name": "Heightmap Ambient Occlusion", "author": "AshenFlowersFalling", "description": "Simple ambient occlusion computation on a heightfield.\nHold LMB to reset accumulation (if enabled).\nVarious options are in \"Common\"", "tags": ["ambientocclusion"], "likes": 4, "viewed": 256, "published": 3, "date": "1699312324", "time_retrieved": "2024-07-30T17:23:36.187942", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //fragColor = texture(iChannel0, uv);\n    //fragColor = texture(iChannel0, uv).yyyy*texture(iChannel0, uv).xxxx/64.0;\n    fragColor = texture(iChannel0, uv).yyyy;\n    //fragColor = texture(iChannel0, uv).xxxx/H_SCALE;\n    //fragColor = texture(iChannel0, uv).yyyy*texture(iChannel1, uv);\n    \n    //fragColor = vec4(LOGARITHMIC_MAX_STEPS(256) / 256.0);\n    //fragColor = vec4(LOGARITHMIC_RADIUS(20))/5.0;\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SQUARE_WIDTH 64.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n    \n    // Needed to get accurate float values in mipmaps\n    // texture\n    fragColor = texture(iChannel0, ZOOM_FACTOR * fragCoord.xy/iResolution.xy);\n    fragColor.z = texelFetch(iChannel1, ivec2(0), 0).z;\n    \n    if (iMouse.z > 0.0)\n        fragColor.z = intBitsToFloat(iFrame);\n        \n    return;\n    \n    // sphere and raised plane\n    fragColor.x = (1.0 - min(length(iResolution.xy/2.0 - fragCoord)/128.0, 1.0));\n    if (fragCoord.x < iResolution.x/2.0)\n        fragColor.x += 0.0;\n    else\n        fragColor.x = max(fragColor.x, 0.25);\n        \n    return;\n    \n    // square\n    vec2 off = abs(fragCoord.xy - iResolution.xy/2.0);\n    if ((off.x < SQUARE_WIDTH) && (off.y < SQUARE_WIDTH))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n        \n    return;\n    \n    // sine wave\n    off = vec2(0.0, iResolution.y/2.0 + 32.0*sin(fragCoord.x / 32.0));\n    vec2 diff = abs(fragCoord.xy - off);\n    if ((diff.y < 32.0) && (diff.x > 64.0) && (diff.x < iResolution.x - 64.0))\n        fragColor.x = H_SCALE;\n    else\n        fragColor.x = 0.0;\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define INFINITE_ACCUMULATE 1                // just accumulate forever\n#define LUMINANCE_SIGMA 0.25                 // fall-off rate for gaussian in luminance\n#define PLANAR_DISTANCE_SIGMA 3.0            // fall-off rate for gaussian in distance\n#define ZOOM_FACTOR 0.25                     // how much to zoom in on the texture\n#define SIMPLE_BILATERAL_FILTER 0            // use a simple box-filter\n#define BILATERAL_FILTER_HWIDTH 8            // half-width of bilateral filter\n#define MAX_ACCUMULATE_STEPS 8               // maximum frames to accumulate\n#define ACCUMULATE_STEP_SPACING 15           // frames between updating accumulation\n#define BILATERAL_FILTER 1                   // blur the result with a bilateral filter\n#define ACCUMULATE 1                         // set to 0 to perform computation in a single-pass\n#define MODE_LOGARITHMIC 0                   // set to 1 to perform variable-size steps in the tracer\n#define LINEAR_AXIS_DIRECTIONS 4             // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LOGARITHMIC_AXIS_DIRECTIONS 64       // number of axis directions to trace per frame, must be >4 for logarithmic mode\n#define LINEAR_STEPS 256                     // steps that the linear solver performs on each ray\n#define H_SCALE 128.0                        // vertical scale\n#define RANDOMISED_DIRECTIONS 1              // set to 0 to use fixed ray directions every frame. This MUST be set to 1 if ACCUMULATE != 0\n\n#define LOG2 log2\n#define LOGARITHMIC_STEP_ANGLE ((360.0 / float(LOGARITHMIC_AXIS_DIRECTIONS)) * 0.01745329251994329576923690768489)\n#define LOGARITHMIC_MAX_STEPS(width) (1.0 + log2(float(width)) / log2((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))))\n#define LOGARITHMIC_DIST(n) pow(((1.0 + sin(LOGARITHMIC_STEP_ANGLE)) / (1.0 - sin(LOGARITHMIC_STEP_ANGLE))), float(n) - 1.0)\n#define LOGARITHMIC_RADIUS(n) (LOGARITHMIC_DIST(n) * sin(LOGARITHMIC_STEP_ANGLE))\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\n// random float that uses the full range from [0, 1)\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h_scale = H_SCALE;\n#if MODE_LOGARITHMIC\n    int axis_count = LOGARITHMIC_AXIS_DIRECTIONS;\n    int steps = int(min(ceil(LOGARITHMIC_MAX_STEPS(2.0*max(iResolution.x, iResolution.y))), float(LINEAR_STEPS)));\n#else\n    int axis_count = LINEAR_AXIS_DIRECTIONS;\n    int steps = LINEAR_STEPS;\n#endif\n    vec2 initial_pos = fragCoord.xy;\n    float h_initial;\n    float total_fov = 0.0;\n    float dist_scale = 1.0 / sin(3.141592653 / float(axis_count));\n    int base_frame;\n    int actual_frame;\n    \n    fragColor = vec4(0.0);\n    \n    ivec2 offset = ivec2(0, 0);\n\n#if ACCUMULATE\n    offset.x = int(hash(uint(iFrame/1)) & uint(0x7FFFFFFF));\n    offset.y = int(hash(hash(uint(iFrame/1)) & uint(0x7FFFFFFF)) & uint(0x7FFFFFFF));\n#endif\n    h_initial = texture(iChannel0, (initial_pos)/iResolution.xy).x * h_scale;\n    base_frame = floatBitsToInt(texelFetch(iChannel0, ivec2(0), 0).z);\n    \n    actual_frame = (iFrame-base_frame) / ACCUMULATE_STEP_SPACING;\n    \n// this makes the following loop VERY slow\n#if RANDOMISED_DIRECTIONS\n    float angle_noise = texelFetch(iChannel1, (ivec2(fragCoord) + offset) % ivec2(iChannelResolution[1].xy), 0).x; // slow, great quality\n    // float angle_noise = float(int(hash(uvec3(iFrame,fragCoord.xy)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // slow, good quality\n    // float angle_noise = float(int(hash(uint(iFrame)) & uint(0x7FFFFFFF)) % 1024)/1024.0; // fast, garbage quality\n#else\n   float angle_noise = 0.0;\n#endif\n\n#if ACCUMULATE\n    if ((actual_frame > MAX_ACCUMULATE_STEPS && (INFINITE_ACCUMULATE == 0)) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) != 0))\n    {\n        fragColor = texture(iChannel2, (initial_pos)/iResolution.xy);\n        return;\n    }\n#endif\n    \n    if ((ACCUMULATE==0) || (((iFrame-base_frame)%ACCUMULATE_STEP_SPACING) == 0) || (INFINITE_ACCUMULATE != 0))\n    for (int i = 0; i < axis_count; i++)\n    {\n        vec2 dir;\n        float maxslope = 0.0;\n        \n        dir.x = sin(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        dir.y = cos(2.0 * 3.141592653 * ((float(i) + angle_noise)/float(axis_count)));\n        \n        for (int j = 1; j < steps; j++)\n        {\n            vec2 pos;\n            float h_current;\n            float width;\n            float dist = float(j);\n            \n#if MODE_LOGARITHMIC\n            dist = LOGARITHMIC_DIST(j);\n            width = LOGARITHMIC_RADIUS(j) * 2.0;\n#else\n            width = 1.0;\n#endif\n            pos.x = initial_pos.x + dir.x*dist;\n            pos.y = initial_pos.y + dir.y*dist;\n            \n            h_current = textureLod(iChannel0, (pos)/iResolution.xy, log2(width)).x * h_scale;\n            \n            maxslope = max(maxslope, (h_current - h_initial) / dist);\n        }\n        total_fov += 1.0 - maxslope / sqrt(maxslope*maxslope + 1.0);\n    }\n    total_fov /= float(axis_count);\n \n    fragColor.x = h_initial;\n#if ACCUMULATE\n    fragColor.y = float(actual_frame) * texelFetch(iChannel2, ivec2(fragCoord.xy), 0).y / float(actual_frame + 1) + total_fov / float(actual_frame + 1);\n#else\n    fragColor.y = total_fov;\n#endif\n    fragColor.z = texelFetch(iChannel1, ivec2(fragCoord) % ivec2(iChannelResolution[1].xy), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 centre = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 accum = centre;\n    float weight;\n    \n#if BILATERAL_FILTER\n#if SIMPLE_BILATERAL_FILTER\n    weight = 0.0;\n    accum.y = 0.0;\n    // box filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            local_weight = pow(1.0 - abs(p.y - centre.y), 4.0);\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#else\n    weight = 0.0;\n    accum.y = 0.0;\n    // gaussian filter\n    for (int y = -BILATERAL_FILTER_HWIDTH; y <= BILATERAL_FILTER_HWIDTH; y++)\n        for (int x = -BILATERAL_FILTER_HWIDTH; x <= BILATERAL_FILTER_HWIDTH; x++)\n        {\n            ivec2 coord = (ivec2(fragCoord) + ivec2(x, y)) % ivec2(iResolution.xy);\n            float local_weight;\n            if (coord.x < 0)\n                coord.x += int(iResolution.x);\n            if (coord.y < 0)\n                coord.y += int(iResolution.x);\n            coord %= ivec2(iResolution.xy);\n            vec4 p = texelFetch(iChannel0, coord, 0);\n            \n            float c = exp(-0.5 * pow((length(vec2(x,y))) / PLANAR_DISTANCE_SIGMA, 2.0));\n            float s = exp(-0.5 * pow((abs(p.y - centre.y)) / LUMINANCE_SIGMA, 2.0));\n            \n            local_weight = c*s;\n            \n            accum.y += local_weight * p.y;\n            weight += local_weight;\n        }\n#endif\n#else\n    weight = 1.0;\n#endif\n    fragColor = accum;\n    fragColor.y = accum.y / weight;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 559]], "test": "untested"}
{"id": "dttcW7", "name": "raymarched cubes depthmap", "author": "ninofiliu", "description": "raymarched cubes depthmap", "tags": ["raymarching"], "likes": 6, "viewed": 197, "published": 3, "date": "1699311655", "time_retrieved": "2024-07-30T17:23:37.191259", "image_code": "// lygia\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cubeSDF(vec3 p, float s)  { return boxSDF(p, vec3(s)); }\n\n// mine\n\nfloat sdf(vec3 p) {\n    return cubeSDF(p, 1.);\n}\n\nconst float rot_speed = 0.3;\nconst float surface = 0.01;\nconst int max_steps = 100;\nconst float mod_size = 10.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cam_pos = 3.*vec3(2.*cos(rot_speed*iTime), 2.*sin(rot_speed*iTime), 1.);\n    vec3 cam_dir = normalize(-cam_pos); // looks at center\n    vec3 cam_x = vec3(cam_dir.y, -cam_dir.x, 0);\n    vec3 cam_y = cross(cam_x, cam_dir);\n    \n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/max(iResolution.x, iResolution.y);\n    uv.y *= iResolution.y/max(iResolution.x, iResolution.y);\n    vec3 ray_dir = normalize(cam_dir + uv.x * cam_x + uv.y * cam_y);\n    \n    vec3 p = cam_pos;\n    int i = 0;\n    while(i < max_steps) {\n        float d = sdf(p);\n        if (d < surface) { break; }\n        p += ray_dir * d;\n        p = mod(p+0.5*vec3(mod_size), mod_size)-0.5*vec3(mod_size);\n        i++;\n    }\n    \n    fragColor = vec4(vec3(1.-float(i)/float(max_steps)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 42, 42, 133], [135, 135, 168, 168, 197], [208, 208, 227, 227, 256], [371, 371, 426, 426, 1216]], "test": "untested"}
{"id": "mldyW7", "name": "basic raymached cube", "author": "ninofiliu", "description": "basic raymached cube", "tags": ["raymarching"], "likes": 1, "viewed": 150, "published": 3, "date": "1699310486", "time_retrieved": "2024-07-30T17:23:38.233473", "image_code": "// lygia\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cubeSDF(vec3 p, float s)  { return boxSDF(p, vec3(s)); }\n\n// mine\n\nfloat sdf(vec3 p) {\n    return cubeSDF(p, 1.);\n}\n\nconst float rot_speed = 0.3;\nconst float surface = 0.01;\nconst int max_steps = 100;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cam_pos = 2.*vec3(2.*cos(rot_speed*iTime), 2.*sin(rot_speed*iTime), 1.);\n    vec3 cam_dir = normalize(-cam_pos); // looks at center\n    vec3 cam_x = vec3(cam_dir.y, -cam_dir.x, 0);\n    vec3 cam_y = cross(cam_x, cam_dir);\n    \n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/max(iResolution.x, iResolution.y);\n    uv.y *= iResolution.y/max(iResolution.x, iResolution.y);\n    vec3 ray_dir = normalize(cam_dir + uv.x * cam_x + uv.y * cam_y);\n    \n    vec3 p = cam_pos;\n    int i = 0;\n    while(i < max_steps) {\n        float d = sdf(p);\n        if (d < surface) { break; }\n        p += ray_dir * d;\n        i++;\n    }\n    \n    fragColor = vec4(vec3(float(i)/float(max_steps)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 42, 42, 133], [135, 135, 168, 168, 197], [208, 208, 227, 227, 256], [343, 343, 398, 398, 1117]], "test": "untested"}
{"id": "dldyDM", "name": "Wrap a function around a circle", "author": "bigmazi", "description": "Toying with math :)", "tags": ["2d", "math"], "likes": 3, "viewed": 189, "published": 3, "date": "1699304637", "time_retrieved": "2024-07-30T17:23:39.276684", "image_code": "#define pi 3.14159265359\n#define pi2 1.57079632679\n\n#define FUNC sin\n\nfloat lerp(float a, float b, float cf)\n{\n    return a + (b - a) * cf;\n}\n\nfloat remap(float x, float a, float b, float A, float B)\n{\n    float cf = (x - a) / (b - a);\n    return lerp(A, B, cf);\n}\n\nfloat shapecf(float r, float thresh, float tolerance, float from, float to, float x, float y, float direction)\n{    \n    float ang = atan(y, x) + mod(iTime, pi * 2.0) * direction;\n    \n    float linex = remap(ang, -pi2, pi2, from, to);\n    float liney = FUNC(linex);\n    \n    float R = remap(liney, -thresh, thresh, 0.0, 2.0 * r);    \n    float k = y / x;\n    \n    float X = sqrt(R * R / (1.0 + k * k)) * sign(x);\n    float Y = k * X;\n    \n    float len = length(vec2(x, y) - vec2(X, Y));    \n    float cf = 1.0 - len / tolerance;\n    \n    return clamp(cf, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv *= pi * 2.2;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float a = sin(iTime);\n    float b = abs(a) + 0.1;\n    float c = sign(a);\n\n    float f = shapecf(5.0, b * 40.0, 0.2, -pi * 12.0, pi * 12.0, uv.x, uv.y, 1.0 * c);\n    f = smoothstep(0.3, 0.8, f);\n    \n    float g = shapecf(2.5, b * 40.0, 0.2, -pi * 12.0, pi * 12.0, uv.x, uv.y, -1.0 * c);\n    g = smoothstep(0.3, 0.8, g);\n    \n    vec3 clr = vec3(0.9, 0.8, 0.2) * max(f, g);    \n    fragColor = vec4(clr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 110, 110, 141], [143, 143, 201, 201, 264], [266, 266, 378, 378, 835], [837, 837, 892, 892, 1445]], "test": "untested"}
{"id": "dlcyD7", "name": "Does Your GPU Support Denormals?", "author": "krax", "description": "This comes off the back of some research I did:\n[url]https://alister-chowdhury.github.io/posts/20231030-preserving-small-values/[/url]\nI have a fast encode/decode for bit packed uints using denormals.\nSadly, I don't know how widespread support is on GPUs.", "tags": ["utility", "font", "ieee"], "likes": 13, "viewed": 1689, "published": 3, "date": "1699288013", "time_retrieved": "2024-07-30T17:23:40.159324", "image_code": "#define MSG(A, B, C, D, E, F, G, H)                                                                                    \\\n    {                                                                                                                  \\\n        uint[] msg = uint[8](A, B, C, D, E, F, G, H);                                                                  \\\n        if(coord.x >= 0 && coord.x < 32)                                                                               \\\n        {                                                                                                              \\\n            c = msg[coord.x / 4] >> (coord.x & 7) * 8;                                                                 \\\n        }                                                                                                              \\\n    }\n\n\n#define RUN_TEST(flag, A, B, C, D, E, F, G, H)                                                                         \\\n    {                                                                                                                  \\\n        uint[] msg = uint[8](A, B, C, D, E, F, G, H);                                                                  \\\n        msg[7] = flag ? 2745414048u : 3166286262u;                                                                     \\\n        if(coord.x >= 0 && coord.x < 32)                                                                               \\\n        {                                                                                                              \\\n            c = msg[coord.x / 4] >> (coord.x & 7) * 8;                                                                 \\\n            if (coord.x >= 28)                                                                                         \\\n            {                                                                                                          \\\n                col.xyz = flag ? vec3(0., 1., 0.) : vec3(1., 0., 0.);                                                  \\\n            }                                                                                                          \\\n        }                                                                                                              \\\n    }\n\n\nfloat unpackNorm(uint src, uint shift, uint numbits)\n{\n    // These should be evaluated statically at compile-time\n    uint maxValue = (1u << numbits) - 1u;\n    uint floatShift = 24u - numbits;\n    uint mask = maxValue << floatShift;\n    float norm = 1.0 / asfloat(mask);\n\n    // This branch should be folded and be a constant\n    // single shift.\n    if(floatShift < shift)\n    {\n        src >>= (shift - floatShift);\n    }\n    else\n    {\n        src <<= (floatShift - shift);\n    }\n\n    src &= mask;\n    return asfloat(src) * norm;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 S = uv * vec2(32., 16.);\n    \n    ivec2 coord = ivec2(S) + ivec2(-2,1);\n    uv = fract(S) * vec2(.03125, .0625) + vec2(.015625, 0.);\n    \n    vec4 col = vec4(1.);\n    uint c = 208u; // 0x\n    uint f = 3166286262u;\n    uint p = 2745414048u;\n    \n    vec4 ref = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    switch(coord.y)\n    {\n        // Does your GPU support denormals?\n        // Well, does it?\n        case 15:\n        {\n            MSG(2207621044u,2241833424u,2696401026u,2242105509u,2191491200u,2511655044u,2642583454u,3481509009u);\n            break;\n        }\n        // Sanity\n        // Check if the compiler itself properly handles denormals, it should round\n        // half of 2047 to eiter 1023 or 1024.\n        case 13:\n        {\n            uint rounded = asuint(0.5 * asfloat(2047u));\n            bool ok = (rounded == 1023u) || (rounded == 1024u);\n            RUN_TEST(ok, 2577306019u,3738208644u,3739147998u,3739147998u,3739147998u,3739147998u,3504266974u,3503345872u);\n            break;\n        }\n        // Storage\n        // Did denormals survive being stored in a texture?\n        // (Assuming shader toy uses full float32)\n        case 12:\n        {\n            bool ok = asuint(ref.x) != 0u;\n            RUN_TEST(ok, 2191492259u,3499464593u,3739147998u,3739147998u,3739147998u,3739147998u,3504266974u,3503345872u);\n            break;\n        }\n        // Fast encoding\n        // Were we able to do a fast float to uint conversion via denormals?\n        // We use ref.y which would be 1.0, to ensure the compiler doesn't optimize it away and to ensure\n        // the calculation is done on the GPU.\n        case 11:\n        {\n            bool ok = asuint(ref.y * asfloat(2047u)) == 2047u;\n            RUN_TEST(ok, 2223215030u,2476651984u,2660865183u,3739144343u,3739147998u,3739147998u,3504266974u,3503345872u);\n            break;\n        }\n        // Fast decoding (upper)\n        // Can we atlesat use fast encoding for the upper bits?\n        case 10:\n        {\n            uint _255 = uint(ref.z);\n            bool ok = abs(unpackNorm(_255, 0u, 8u) - 1.) <= 0.05; // very generous bias\n            RUN_TEST(ok, 2223215030u,2476061904u,2660865183u,2245578903u,2190835840u,3739144409u,3504266974u,3503345872u);\n            break;\n        }\n        // Fast decoding (lower)\n        // Did anything less than 0.5 survive?\n        case 9:\n        {\n            uint _255 = uint(ref.z);\n            bool ok = abs(unpackNorm(_255, 0u, 9u) - 0.5) <= 0.05; // very generous bias\n            RUN_TEST(ok, 2223215030u,2476061904u,2660865183u,2631454871u,2190837663u,3739144409u,3504266974u,3503345872u);\n            break;\n        }\n        case 3:\n        {\n            MSG(2627784912u,2508427669u,2627044560u,2510147740u,2241825232u,2508378242u,2224850307u,3503346051u);\n            break;\n        }\n    }\n\n    c &= 0xffu;\n    fragColor = col * texture(iChannel1, vec2(c&15u,c>>4) * .0625 + uv).x;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(asfloat(0x7fffffu), 1., 255.5, 0.);\n}", "buffer_a_inputs": [], "common_code": "// I have no idea if this even does anything on shadertoy\nprecision highp float;\nprecision highp int;\n\n#define asuint  floatBitsToUint\n#define asfloat uintBitsToFloat\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2315, 2315, 2369, 2429, 2850], [2853, 2853, 2908, 2908, 5879]], "test": "untested"}
{"id": "DtccRM", "name": "Sin Rug 53", "author": "domrally", "description": "So small it feels like someone must have found it before. 18 Characters over the shortest possible shadertoy of 35.\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "pixel", "sin", "mini", "short", "tweet", "micro", "18", "halftweet", "golf"], "likes": 7, "viewed": 255, "published": 3, "date": "1699281685", "time_retrieved": "2024-07-30T17:23:41.069890", "image_code": "/*\n53 chars 🏌️ by Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    o = sin(i.x * i.yyyy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtccRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 80, 80, 109]], "test": "untested"}
{"id": "dt3yD7", "name": "Big-Small Swap Automata", "author": "SnoopethDuckDuck", "description": "any improvements/suggestions are welcome :)\n\npress alt+down if you go fullscreen", "tags": ["grid", "automata", "cellular", "cell", "cool", "ca", "shuffle"], "likes": 38, "viewed": 594, "published": 3, "date": "1699280476", "time_retrieved": "2024-07-30T17:23:41.975468", "image_code": "// Rough overview:\n// Buffer A swaps the positions of 3 cell types: off, small, big\n// with different protocols for each swap type:\n// off->small, off->big, small->off, big->off\n// (big cells comprise of 4 indexed cells which act as corners)\n\n// Image interprets buffer A data and draws moving circles\n\n// Values:\n// o.r: Color\n// o.g: 0=off, 1=small, 2,3,4,5=big corners\n// o.b: Direction index 0,1,2,3\n// o.a: Motion timer [0,1] range\n\n// Other variants you could try:\n// - 2x1 cells which rotate around an endpoint to move\n// - replace o.r with encoded start position, and restrict cell\n//   position to be within (or outside) neighbourhood of start pos\n// - allow cells to push each other, e.g. 1|1|0 -> 0|1|1\n// - rock paper scissors variant, i.e. 0,1,2,3 instead of on/off\n//   1 can do swaps with 0,2\n//   2 can do swaps with 1,3 etc. (motion timer maybe inapplicable)\n// - or have rps pushing, 1 pushes 2, 2 pushes 3, 3 pushes 1\n// - give each cell a lifetime, then have spawning conditions too\n// (these are really just ordinary CA + a motion timer)\n\n#define pi 3.14159\n//#define cell(d) texture(iChannel0, d/R+u)\n#define cell(d) texelFetch(iChannel0, ivec2(d+zoom*(px-.5*R)+.5*R), 0)\n\nvoid mainImage( out vec4 o, vec2 px )\n{\n    vec2 R = iResolution.xy;\n    float zoom = 29./R.y;\n    vec2 u = zoom * (px - .5*R)/R + .5;\n         \n    o = cell(0.);\n    \n    // Get cell direction and next cell along\n    vec2 dir = indexToDir(o.b);\n    vec4 c = cell(dir);\n    \n    // Magic equation that sorts out motion\n    // (I definitely understand how this works)\n    float m = smoothstep(.1, .9, o.a) - step(1., o.g);\n    vec2 p = m * dir;\n    \n    // Circle radius\n    float r = .5;\n    if (o.g > 1.) r = 1.;\n    \n    // Offset circle position for big cells\n    if      (o.g==2.) p += vec2( .5,  .5); // bl\n    else if (o.g==3.) p += vec2(-.5,  .5); // br\n    else if (o.g==4.) p += vec2( .5, -.5); // tl\n    else if (o.g==5.) p += vec2(-.5, -.5); // tr\n    else if (o.g==0. && o.a < 1. && c.g > 1.) {\n        r = 1.;\n        if      (c.g==2.) p += vec2( .5,  .5);\n        else if (c.g==3.) p += vec2(-.5,  .5);\n        else if (c.g==4.) p += vec2( .5, -.5);\n        else if (c.g==5.) p += vec2(-.5, -.5);\n    }\n    \n    // Oscillate radius with motion\n    r *= mix(.5+.5*o.r, 1., pow(4.*o.a*(1.-o.a), 32.));\n    \n    // Draw circle with color\n    vec2 f = fract(u * R) -.5 - p;\n    float s = smoothstep(0., .1, r-length(f));\n    float s2 = smoothstep(0., .1, r-length(f+vec2(.2)));\n\n    vec4 col = .6 + .4 * cos(2.*pi*(8.*o.r + 0.*o.a+vec4(0,4,5,0)/12.));\n    col = max(col, (.7-.5*col)*exp(-8.*abs(r-length(f+.1*r))))\n        - .4*exp(-7.*abs(r-length(f-.08*r)));\n        \n    o = pow(.02+s*col, vec4(1./1.7));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Debugging (set to 0 to disable)\n#define smallSwap 1\n#define bigSwap 1\n\n// Swap speed\n#define speed .016\n\nvec2 indexToDir(float i) {\n    if (i == 0.) return vec2(-1, 0); // l\n    if (i == 1.) return vec2( 0, 1); // t\n    if (i == 2.) return vec2( 1, 0); // r\n                 return vec2( 0,-1); // b\n}\n\nfloat dirToIndex(vec2 u) {\n    if (u == vec2(-1, 0)) return 0.; // l\n    if (u == vec2( 0, 1)) return 1.; // t\n    if (u == vec2( 1, 0)) return 2.; // r\n                          return 3.; // b\n}\n\n// From Fabrice\n// https://www.shadertoy.com/view/WttXWX\n#define hashi(x) triple32(x)\n#define hash(x)  ( float( hashi(floatBitsToUint(hash13(x))) ) / float( 0xffffffffU ) )\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Alternative checkNeighbour function\n/*\nbool checkNeighbour(vec4 o, vec4 c, vec2 u, vec2 dir) {\n    vec2 offset;\n    if (dir == vec2(-1, 0)) {\n        if      (c.g == 3.) offset = vec2(0, 1);\n        else if (c.g == 5.) offset = vec2(0, -1);\n    } \n    else if (dir == vec2(0, 1)) {\n        if      (c.g == 2.) offset = vec2(1, 0);\n        else if (c.g == 3.) offset = vec2(-1, 0);\n    } \n    else if (dir == vec2(1, 0)) {\n        if      (c.g == 2.) offset = vec2(0, 1);\n        else if (c.g == 4.) offset = vec2(0, -1);\n    } \n    else if (dir == vec2(0, -1)) {\n        if      (c.g == 4.) offset = vec2(1, 0);\n        else if (c.g == 5.) offset = vec2(-1, 0);\n    }\n    \n    vec4 n = cell(u+offset);\n    vec2 ndir = pickDir(o, u+offset);\n    \n    // Cell is off, not moving, has same direction\n    return n.g == 0. && n.a == 1. && ndir == dir;\n}\n//*/\n", "buffer_a_code": "// Values:\n// o.r: Color\n// o.g: 0=off, 1=small, 2,3,4,5=big corners\n// o.b: Direction index 0,1,2,3\n// o.a: Motion timer [0,1] range\n\n#define cell(u) texelFetch(iChannel0, ivec2(u), 0)\n\n// Big/small cells (o.g > 0.) generate an index \n// corresponding to a direction to swap cells\nfloat getIndex(vec2 u) {\n    return floor(4.*hash(vec3(u, float(iFrame))));\n}\n\n// The offset to bottom left corner in big cells\n// (return vec2(0) if bl or is not a big cell)\n// 4 5 \n// 2 3\nvec2 getBigOffset(vec4 o) {\n    if (o.g == 3.) return vec2(-1,  0); // br\n    if (o.g == 4.) return vec2( 0, -1); // tl\n    if (o.g == 5.) return vec2(-1, -1); // tr\n                   return vec2( 0,  0); // bl\n}\n\n// Big/small cells generate a random direction to swap in\nvec2 getDir(vec4 o, vec2 u) {\n    vec2 offset = getBigOffset(o);\n    return indexToDir(getIndex(u+offset));\n}\n\n// Off cells pick a direction based on their neighbouring cells\n// to resolve conflicts \n// i.e. if multiple cells want to swap with this one, pick one\nvec2 pickDir(vec4 o, vec2 u) {\n    // Check neighbours until we find a cell wanting to swap\n    // first check for big cells (clockwise)\n    // then small cells (anticlockwise)\n    vec2 sdir = vec2(0);\n    float baseIndex = getIndex(u);\n    for (float i; i < 4.; i++) {\n        vec2 dir = indexToDir(mod(baseIndex + i, 4.));\n        vec4 c = cell(u+dir);\n        vec2 cdir = getDir(o, u+dir);\n        \n        // Cell is on, not moving and wants to swap\n        if (c.g > 0. && c.a == 1. && dir == -cdir) {\n            // Cell is big, return direction index\n            if (c.g > 1.) return dir;\n                \n            // Cell is small, consider it\n            sdir = dir;      \n        }           \n    }\n    return sdir;\n}\n\n// Off cells check a neighbour cell's values so that\n// big/off swaps can occur (big cells swap with 2 off cells)\nbool checkNeighbour(vec4 o, vec4 c, vec2 u, vec2 dir) {\n    // Neighbour cell which big cell will also swap with\n    vec2 offset = (1.+2.*(dir+getBigOffset(c))) * mod(dir+1., 2.);\n    vec4 n = cell(u+offset);\n    vec2 ndir = pickDir(o, u+offset);\n    \n    // Cell is off, not moving, has same direction\n    return n.g == 0. && n.a == 1. && ndir == dir;\n}\n\nvoid swapOff(inout vec4 o, vec2 u) {    \n    vec2 dir = pickDir(o, u);        \n\n    // Another cell wants to swap\n    if (dir != vec2(0)) {\n        vec4 c = cell(u+dir); \n        vec2 cdir = getDir(c, u+dir);\n\n        // Swap directions align, and cell is not moving\n        if (dir == -cdir && c.a == 1.) {\n            // Swap with small cell\n            #if smallSwap == 1\n            if (c.g==1.) { \n                o.rg = c.rg; // Copy color and cell type\n                o.b = dirToIndex(cdir); // Store direction for Image tab\n                o.a = 0.; // Reset motion timer\n            }\n            #endif\n            \n            // Swap with big cell if neighbour wants to swap too\n            #if bigSwap == 1\n            if (c.g>1. && checkNeighbour(o,c,u,dir)) {\n                o.rg = c.rg; \n                o.b = dirToIndex(cdir); \n                o.a = 0.;\n            }\n            #endif\n        }\n    } \n}\n\nvoid swapSmall(inout vec4 o, vec2 u) {\n    #if smallSwap != 1\n        return;\n    #endif\n    \n    vec2 dir = getDir(o, u);\n    vec4 c = cell(u+dir);\n    \n    // Swap if cell is off, not moving, directions align\n    if (c.g == 0. && c.a == 1.) {\n        vec2 cdir = pickDir(c, u+dir);\n        if (dir == -cdir) {\n            o.g = 0.;\n            o.b = dirToIndex(dir);\n            o.a = 0.;\n        }\n    }\n}\n\nvoid swapBig(inout vec4 o, vec2 u) {\n    #if bigSwap != 1\n        return;\n    #endif\n    \n    // Bottom left pixel of big cell determines most swap logic\n    vec2 bl = u + getBigOffset(o);    \n    float index = getIndex(bl);\n    vec2 dir = indexToDir(index);\n    \n    // p1, p2 are the positions our big cell wants to move into\n    vec2 p1 = bl, p2 = bl;\n    if      (index == 0.) p1 += vec2(-1, 0), p2 += vec2(-1, 1); // l\n    else if (index == 1.) p1 += vec2( 0, 2), p2 += vec2( 1, 2); // t\n    else if (index == 2.) p1 += vec2( 2, 0), p2 += vec2( 2, 1); // r\n    else if (index == 3.) p1 += vec2( 0,-1), p2 += vec2( 1,-1); // b\n    \n    vec4   c1 = cell(p1),          c2 = cell(p2);\n    vec2 dir1 = pickDir(c1, p1), dir2 = pickDir(c2, p2);\n    \n    // Swap if both cells are:\n    // off, not moving, want to swap (directions align)\n    if (c1.g==0. && c1.a==1. && dir1==-dir &&\n        c2.g==0. && c2.a==1. && dir2==-dir) {            \n        vec4 c = cell(u+dir);\n        // m checks if cell will still be in big cell after swapping\n        // (by checking proximity to p1)\n        // e.g.: dir = (1, 0), \n        // 4 | 5 | 0 --> 0 | 4 | 5\n        // 2 | 3 | 0     0 | 2 | 3\n        // 5,3 -> 4,2 so stay in big cell\n        // 4,2 -> 0,0 so don't stay in big cell\n        float m = max(abs(u.x-p1.x), abs(u.y-p1.y));\n        if (m == 1.)\n            o.g = cell(u-dir).g;\n        else \n            o.g = 0.;  \n        o.b = dirToIndex(dir);\n        o.a = 0.;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    // Initialize\n    if (iFrame < 1) {\n        // Spawn big cells\n        vec2 f = floor(u/2.);\n        o.r = hash12(f);      // Color\n        o.g = step(.75, hash12(.1*f)); // Cell type\n        \n        // Spawn small cells (if no big cell)\n        if (o.g == 0.) { \n            o.r = hash12(u);     \n            o.g = step(.7, hash12(.1*u)); \n        } \n        // Set corner id for big cell\n        else { \n            vec2 m = mod(u, 2.)-.5;\n            if      (m == vec2(0, 0)) o.g = 2.; // bl\n            else if (m == vec2(1, 0)) o.g = 3.; // br\n            else if (m == vec2(0, 1)) o.g = 4.; // tl\n            else if (m == vec2(1, 1)) o.g = 5.; // tr            \n        }\n        o.b = 0.; // Direction index\n        o.a = 1.; // Motion timer\n    } \n    // Update\n    else {\n        o = cell(u);\n        \n        // Increment motion timer\n        if (o.a < 1.) { \n            float inc = speed * (.5+.5*o.r);\n            if (iMouse.z > 0.) inc = 1.;\n            o.a = min(1., o.a+inc);\n        }\n        // Swap cells\n        else {\n            if      (o.g == 0.) swapOff(o, u);  \n            else if (o.g == 1.) swapSmall(o, u);\n            else if (o.g > 1.)  swapBig(o, u); \n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3yD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1195, 1195, 1234, 1234, 2714]], "test": "untested"}
{"id": "dlccDM", "name": "GLSL Angle bug #72", "author": "FabriceNeyret2", "description": "this should plot a large dot, \nbut on Windows/Angle it gives random noise in a square on red bg (at least once the texture is loaded)\n\nBug report : [url]  https://bugs.chromium.org/p/chromium/issues/detail?id=1499875 [/url]", "tags": ["glsl", "bug", "angle"], "likes": 6, "viewed": 295, "published": 3, "date": "1699277889", "time_retrieved": "2024-07-30T17:23:42.824199", "image_code": "// acid test simplified from https://www.shadertoy.com/view/DdyfW3 vs https://shadertoy.com/view/dsyBzV\n\nvoid mainImage(out vec4 O, vec2 I) {\n\n    vec2 R = iResolution.xy, x,F,H, \n         U =  ( 2.*I - R ) / R.y;                                      // --- normalize coordinates in [-r,r]x[-1,1]\n    O = vec4(0);\n\n    float j = 1.;\n    for ( float i = 0.; i < 1.; i++ )             // no bug if commented (despite useless)\n        for( float j = 1.; j < 2.; j++ )          // no bug if commented (despite useless)\n        {\n         // vec2 x = j*U; F = floor(x);           // no bug if used\n                 x = j*U; F = floor(x);           // bug if used ( on Windows )\n         // vec2 F = floor(j*U) ;                 // no bug if used\n         //      F = floor(j*U) ;                 // no bug if used\n         \n            H = texture(iChannel2, F ).xy;                             // --- get random vec2 from H. Since F=floor(), is always texture(vec2(0))\n         // H = texture(iChannel2, U ).xy;                     // on Windows this give the same result than using F !\n         // H = texture(iChannel2, 0.*F ).xy;                  // no bug with this version (despite does the same)\n         // H = texture(iChannel2, min(0.,iTime)*F ).xy;       // no bug with this version (despite does the same)\n         // H = fract(1e3*sin((F)*mat2(13.3,71.1,37.7,19.7))); // no bug with this version (analytical random instead of texture)\n         \n            if( length( U - H ) < .1 ) O++;                            // --- draw large dot at location H\n            if(  x == F ) O.r++;                  // on Windows, this is always true ! floor was ignored \n        }\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlccDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 1677]], "test": "untested"}
{"id": "mtccDM", "name": "On the sine wave", "author": "bigmazi", "description": "My first shader :)", "tags": ["2d", "sine"], "likes": 6, "viewed": 234, "published": 3, "date": "1699277564", "time_retrieved": "2024-07-30T17:23:43.848460", "image_code": "float pi = 3.14159265359;\n\nfloat sinlen(float x)\n{\n    return (sin(2.0 * x) + 6.0 * x) * 0.25;\n}\n\nfloat normaly(float x0, float y0, float x)\n{\n    float cosx0 = cos(x0);\n    return (-x / cosx0) + (y0 + x0 / cosx0);\n}\n\nfloat solvex(float x, float y)\n{\n    float rem = mod(x - pi * 0.5, pi);\n    \n    if (rem == 0.0)\n        return x;\n    \n    float s = sign(cos(x));\n    \n    float begin = x - rem;\n    float end = begin + pi;\n    \n    for (int i = 0; i < 1000; ++i)\n    {\n        float m = (begin + end) * 0.5;\n        \n        if (s * normaly(x, y, m) < s * sin(m))\n        {\n            end = m;\n        }\n        else\n        {\n            begin = m;\n        }\n    }\n    \n    return begin;\n}\n\nvoid grid(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv0 = uv;\n    uv0 = uv0 * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;    \n    uv += 0.05;\n    \n    uv = fract(uv * 10.0);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = 1.0 - abs(uv);\n    \n    vec2 wb = smoothstep(0.92, 0.96, uv);    \n    vec3 col = vec3(0.2, 1.0, 0.8) * pow(max(wb.x, wb.y), 3.0);\n    \n    vec2 b = smoothstep(-0.95, -0.9, -abs(uv0));\n    col *= min(b.x, b.y);\n    \n    col *= 0.32;\n    fragColor = vec4(col, 1.0);\n}\n\nfloat sine(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x *= pi * 2.0;\n    uv.y *= pi * 2.0;\n    \n    vec2 dyn = vec2(0.0, 0.0);\n    dyn.x += (fract(iTime / 2.46) - 0.5) * pi * 4.0 * iResolution.x / iResolution.y * 1.4;\n    \n    float radius = 0.52;\n    \n    float dist = length(uv - vec2(dyn.x, sin(dyn.x)));\n    \n    float solution = solvex(uv.x, uv.y);\n\n    if (solution < dyn.x)\n    {\n        dist = length(uv - vec2(solution, sin(solution)));\n    }\n    else\n    {\n        solution = dyn.x;\n    }\n\n    float tail = pi * 3.3;\n    float extra = 1.0 - sinlen(dyn.x - solution) / tail;\n    extra = clamp(extra, 0.0, 1.0);\n    extra = pow(extra, 1.5);\n    \n    float k = max(0.0, 1.0 - dist / extra / radius);\n    k = pow(k, 0.8);\n    k *= extra;\n    \n    return k;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    grid(fragColor, fragCoord);\n    float k = sine(fragCoord);    \n    \n    vec3 col = vec3(0.2, 0.8, 0.7);    \n    \n    fragColor = vec4(mix(fragColor.rgb, col, k * 1.88), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtccDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 96], [98, 98, 142, 142, 216], [218, 218, 250, 250, 694], [696, 696, 746, 746, 1242], [1244, 1244, 1275, 1275, 2120], [2122, 2122, 2177, 2177, 2358]], "test": "untested"}
{"id": "clccWM", "name": "pumpkin6666", "author": "saanvirt", "description": "pumpkin", "tags": ["pumpkin"], "likes": 0, "viewed": 151, "published": 3, "date": "1699253165", "time_retrieved": "2024-07-30T17:23:44.807895", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdMouth(vec2 p, float r){\n    return length(p)-r;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.2 + 0.2*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col = mix(col, 0.2*vec3(150./250., 50./219., 0.), 1.-smoothstep(0.19, 0.25, uv.y));\n   \n    col = mix(col, vec3(0.9, 0.5, 0.), smoothstep(0.,0.03,-sdCircle(r, 0.9)));\n    vec3 cInside = vec3(1., 1., 0.);\n\n\n    vec2 rMirrorX = vec2(abs(r.x), r.y);\n    float eyes = smoothstep(0., 0.03, -sdEquilateralTriangle(rMirrorX-vec2(0.4, 0.4), 0.2));\n    col = mix(col, cInside, eyes);\n    \n    float eyes1 = smoothstep(0., 0.02, -sdEquilateralTriangle(rMirrorX-vec2(0.2, 0.6), 0.1));\n    col = mix(col, cInside, eyes1);\n    float eyes2 = smoothstep(0., 0.02, -sdEquilateralTriangle(rMirrorX-vec2(0.05, 0.7), 0.1));\n    col = mix(col, cInside, eyes2);\n    \n    \n   \n    float mouth = smoothstep(0., 0.06,-sdMouth(rMirrorX-vec2(0., 0.), 0.3));\n    col = mix(col, cInside, mouth);\n    \n    float nose = smoothstep(0., 0.03, -sdEquilateralTriangle(rMirrorX-vec2(0., 0.), 0.1));\n    col = mix(col, vec3(0.), nose);\n    \n\n    fragColor= vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clccWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 119, 119, 328], [330, 330, 367, 367, 447], [450, 450, 501, 501, 809], [811, 811, 842, 842, 869], [872, 872, 929, 929, 2057]], "test": "untested"}
{"id": "dldyWN", "name": "Box w/ diff. radius on x or y", "author": "lf94", "description": "Allow for different radius along the x or y axis! This is particularly useful in 3D, for shapes like phones.\n\nNote: I'm a completely SDF noob. I'm open to simplifications or improvements :D\n", "tags": ["box", "radius"], "likes": 0, "viewed": 156, "published": 3, "date": "1699242280", "time_retrieved": "2024-07-30T17:23:45.749378", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// I'm starting with 2D but should scale up to 3D no problem\n// This demonstrates having different radius ratios\n// I need this for my SDF CAD stuff\n\n\n// Most mininal example. You see it stretches the circle.\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(vec2(p.x / 2., p.y))-r;\n}\n\n// Derived from the SDF box video from IQ.  The max(r.y/r.x, 1.) is my stuff\nfloat sdBox1(in vec2 p, in vec2 r) {\n  return sqrt(pow(max((p.x-r.x)*max(r.y/r.x, 1.), 0.0),2.) + pow(max((p.y-r.y)*max(r.x/r.y, 1.),0.0),2.));\n}\n\n// This is the final form\nfloat sdBox( in vec2 p, in vec2 b, in vec2 r )\n{\n    vec2 s = max(vec2(r.y/r.x, r.x/r.y), 1.);\n    vec2 b2 = b*vec2(r.y/r.x, r.x/r.y);\n    vec2 d = abs(p)-b2;\n    vec2 d2 = vec2((d.x-r.x)*s.x, (d.y-r.y)*s.y);\n    \n    return (length(max(d2,0.0)) + min(max(d2.x,d2.y),0.0)) - max(r.y/r.x, r.x/r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdBox(p * 10., vec2(1.0, 1.0), vec2(4.00, 1.00)) / 10.;\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdBox(p * 10., vec2(1.0, 1.0), vec2(4.00, 1.00)) / 10.;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyWN.jpg", "access": "api", "license": "mit", "functions": [[1230, 1288, 1330, 1330, 1374], [1376, 1453, 1489, 1489, 1598], [1600, 1626, 1674, 1674, 1925], [1927, 1927, 1984, 1984, 2699]], "test": "ok"}
{"id": "mttcD4", "name": "Stars on drugs", "author": "Hotrhodium", "description": "ChatGPT made \"Can you do a different one with psychedelic colors and stars blinking?\"", "tags": ["chatgpt"], "likes": 1, "viewed": 138, "published": 3, "date": "1699236893", "time_retrieved": "2024-07-30T17:23:46.797575", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time\n    float time = iTime;\n\n    // Color cycling\n    float colorCycle = sin(time * 0.5) * 0.5 + 0.5;\n    vec3 color = vec3(sin(uv.x + colorCycle), cos(uv.y + colorCycle), sin(colorCycle));\n    \n    // Noise for stars\n    float noise = fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // Star blinking effect\n    float starIntensity = step(0.98, noise) * sin(time * 10.0 * noise);\n    \n    // Combine color cycling and stars\n    vec3 finalColor = color + vec3(starIntensity);\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 731]], "test": "untested"}
{"id": "dltcW4", "name": "Projected disk ellipse", "author": "hasse", "description": "The perspective projection of a disk is an ellipse in screen-space. This shader finds the parameters of that ellipse.\nThere are some float instabilities near grazing angles. This sometimes leads to flickering in the major axis when the disk is flipping.", "tags": ["3d", "projection", "ellipse", "perspective", "disk"], "likes": 1, "viewed": 192, "published": 3, "date": "1699230927", "time_retrieved": "2024-07-30T17:23:47.671239", "image_code": "// Forked from https://www.shadertoy.com/view/ll3Xzf\n// Original license text:\n\n// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Disk projection code (project_disk()) is by me and is CC0.\n// Currently, there's some float instability near grazing angles.\n// https://math.stackexchange.com/questions/2411047/parameters-of-the-conic-curve-resulting-from-the-perspective-projection-of-a-cir/2411591#comment4978079_2411047\n// https://en.wikipedia.org/wiki/Ellipse#General_ellipse\nvoid project_disk(\n    vec3 center,\n    vec3 normal,\n    float radius,\n    vec2 proj_info,\n    out vec2 proj_center,\n    out vec2 major,\n    out vec2 minor\n){\n    float nc = dot(normal, center);\n    float r2 = radius * radius;\n    float c2r2 = dot(center, center) - r2;\n    vec3 n2 = normal * normal;\n\n    vec3 ACF = nc * nc - 2.0f * center * normal * nc + c2r2 * n2;\n    float A = ACF.x, C = ACF.y, F = ACF.z;\n    float B = 2.0f * c2r2 * normal.x * normal.y - 2.0f * (center.x * normal.y + center.y * normal.x) * nc;\n\n    proj_center = (normal.xy * normal.z * r2 + center.xy * center.z) / (r2 - r2 * n2.z - center.z * center.z);\n\n    float angle = -0.5f * atan(B, A-C);\n    float cos_a = cos(angle);\n    float sin_a = sin(angle);\n    float cos2_a = cos_a * cos_a;\n\n    // TODO: It may be possible to simplify this further.\n    float K = A*proj_center.x*proj_center.x + B*proj_center.x*proj_center.y + C*proj_center.y*proj_center.y - F;\n\n    float radius_num = sqrt(abs(K * (2.0f * cos2_a - 1.0f)));\n    float major_radius = radius_num * inversesqrt(abs((A + C) * cos2_a - A));\n    float minor_radius = radius_num * inversesqrt(abs((A + C) * cos2_a - C));\n    \n    major = vec2(sin_a, cos_a) * major_radius;\n    minor = vec2(cos_a, -sin_a) * minor_radius;\n\n    proj_center *= 2.0f / proj_info;\n    major *= 2.0f / proj_info;\n    minor *= 2.0f / proj_info;\n}\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n\tvec3  q = ro - cen;\n    float t = -dot(nor,q)/dot(rd,nor);\n    if( t<0.0 ) return -1.0;\n    vec3 d = q + rd*t;\n    if( dot(d,d)>(rad*rad) ) return -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n\n    vec2 p = (fragCoord.xy/iResolution.xy) * 2.0f - 1.0f;\n    float aspect = iResolution.x / iResolution.y;\n    p.x *= aspect;\n\n\n    // camera position\n\tvec3 ro = vec3( 0,0,1.5 );\n\t// create view ray\n\tvec3 rd = normalize(vec3(p.xy, -1.5) );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    tot += col;\n\n    float proj_plane_dist = 1.5 * aspect * 0.5f;\n    vec2 proj_info = vec2(proj_plane_dist, proj_plane_dist);\n    vec2 proj_center;\n    vec2 major;\n    vec2 minor;\n    project_disk(\n        disk_center-ro,\n        disk_axis,\n        disk_radius,\n        proj_info,\n        proj_center,\n        major,\n        minor\n    );\n\n    vec2 nmajor = normalize(major);\n    vec2 nminor = normalize(minor);\n\n    // Paint major axis point\n    if(distance(p, proj_center + major) < 0.015f)\n        tot = vec3(0,1,0);\n\n    // Paint major axis line\n    if(distance(p, proj_center + dot(p-proj_center, nmajor) * nmajor) < 0.005f && abs(dot(p-proj_center, nmajor)) < length(major))\n        tot = vec3(0,1,0);\n\n    // Paint minor axis point\n    if(distance(p, proj_center + minor) < 0.015f)\n        tot = vec3(0,0,1);\n\n    // Paint minor axis line\n    if(distance(p, proj_center + dot(p-proj_center, nminor) * nminor) < 0.005f && abs(dot(p-proj_center, nminor)) < length(minor))\n        tot = vec3(0,0,1);\n\n    // Paint center of projected ellipse\n    if(distance(p, proj_center) < 0.015f)\n        tot = vec3(1,0,0);\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltcW4.jpg", "access": "api", "license": "mit", "functions": [[1158, 1507, 1665, 1665, 2864], [2866, 2891, 3052, 3052, 3222], [3224, 3224, 3281, 3281, 5204]], "test": "ok"}
{"id": "mltcW4", "name": "Flower Circles ", "author": "atomgrafika", "description": "Fine, symmetrical geometric art, made for everyone to enjoy!", "tags": ["circles", "flower", "hypnotic", "warm"], "likes": 6, "viewed": 224, "published": 3, "date": "1699230464", "time_retrieved": "2024-07-30T17:23:48.555874", "image_code": "//This code is just the modificatipon of the original post //https://www.shadertoy.com/view/mtyGWy by kishimisu\n\nvec3 palette( float t ) {\n    vec3 a = vec3(1.0, 0.0, 0.5);\n    vec3 b = vec3(0.2, 0.8, 0.0);\n    vec3 c = vec3(1.0, 1.0, 0.8);\n    vec3 d = vec3(0.0,0.2,0.9);\n\n    vec3 timePhase = vec3(1.0, 2.0, 3.0) * t;\n\n    return a + b*cos( 2.0*(c*t+d) );\n}\nconst float PI = 5.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n\nfloat segments = 227.25;\n    float angle = 5.0 * PI / segments;\n\n float r = length(uv);\n    float theta = atan(uv.y, uv.x);   \n\n    theta = abs(mod(theta, angle) - angle * 0.5);\n\nfloat rotationSpeed = 0.1; // The speed of rotation, change this value to make it faster or slower\n    theta += iTime * rotationSpeed;\n    \n    uv = r * vec2(cos(theta), sin(theta));\n   \n     for (float i = 5.3; i < 5.9; i+= 0.55) {\n        uv = fract(uv * 2.1) - 0.5;\n        float d = length(uv) * exp(-r);\n\n        vec3 col = palette(length(uv0) + i*.1 + iTime*0.1);\n\n        d = sin(d*15. + iTime)/10.;\n        d = abs(d);\n        d = pow(0.005 / d, 1.0);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 138, 138, 359], [383, 383, 439, 439, 1286]], "test": "untested"}
{"id": "dttcW4", "name": "\"kishimisu\" Introduction", "author": "todyscau", "description": "I followed the steps from kishimisu's - \"An introduction to Shader Art Coding\" YouTube Video. I customized a few settings to fit my liking. Thank You.", "tags": ["fractal", "colorful"], "likes": 3, "viewed": 132, "published": 3, "date": "1699230094", "time_retrieved": "2024-07-30T17:23:49.658925", "image_code": "vec3 pallete( float t ) {\n\n    vec3 a = vec3 (0.368, 0.560, 0.560);\n    vec3 b = vec3 (0.388, 0.265, 0.265);\n    vec3 c = vec3 (-0.302, 1.433, -0.194);\n    vec3 d = vec3 (0.397, -0.103, -0.052); \n    \n    return a + b*cos( 6.28318*(c*t*d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    vec2 uv0 = uv;    \n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        uv = fract(uv * 1.9) - 0.5;    \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = pallete(length(uv0) + i*.4 + iTime*.4);\n    \n        d = sin(d*12. + iTime)/8.;\n        d = abs(d);\n        d = pow(0.02 / d, 1.1);\n    \n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 243], [245, 245, 301, 301, 812]], "test": "untested"}
{"id": "DltcWN", "name": "render desert cloud", "author": "jarble", "description": "Render complex mountain combined with sky light, mountain fog, cloud\nBased on [url=https://www.shadertoy.com/view/NscGWl]this terrain[/url]", "tags": ["noise", "fbm", "music", "mountainsdf"], "likes": 10, "viewed": 316, "published": 3, "date": "1699219227", "time_retrieved": "2024-07-30T17:23:50.659250", "image_code": "/**\n    Render complex mountain combined with sky light, mountain fog, cloud\n*/\n\n#define ROTATE_MATRIX mat2(0.6, -0.8, 0.8, 0.6)\n#define PIXEL_COORD_REDUCTION_FACTOR 0.003         \n#define MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR 120.0*8.\n#define RAYMARCH_ITER_COUNT 256\n#define RAYMARCH_ITER_PRECISION 1e-4\n#define SOFTSHADOW_ITER_COUNT 80\n\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat random(in vec2 p) {\n    vec2 q = 55.1876653 * fract(p * 10.1321513);\n    return fract((q.x + q.y) * q.x * q.y);\n}\n\n// return noise value and noise gradient\nvec3 noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * f * (1.0 - f);\n\n    vec2 offset = vec2(1.0, 0.0);\n    float a = random(i);\n    float b = random(i + offset.xy);\n    float c = random(i + offset.yx);\n    float d = random(i + offset.xx);\n\n    float noiseV = a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y;\n    vec2 noiseG = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);\n    return vec3(noiseV, noiseG);\n}\n\nvec2 fluid(vec2 uv){\n //add some turbulence\n for (float i = 1.; i < 4.; i++)\n  {\n    float i1 = i/2.;\n    float s2 = (cos(uv.x*i1)/i1)/2.;\n    float s1 = (sin(uv.y*i1)/i1+iTime/i1/i1)/2.;\n    uv.x += s1;\n    uv.y += s2;\n  }\n  return uv;\n}\n\n// Fractal Brownian motion: generator cloud\nfloat fbm(vec2 p) {\n    p = fluid(p);\n    float res = 0.0;\n    float factor = 0.5;\n    for (int i = 0; i < 4; i++) {\n        res += factor * noise(p).x;\n        p = ROTATE_MATRIX * p * 2.0;\n        factor *= 0.5;\n    }\n    return res;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //uv /= 2.;\n    //this function generates the terrain height\n    //uv *= .75;\n    float value = 0.;\n    float amplitude = .75,n2=0.;\n    //amplitude /= 16.;\n    vec2 n1 = vec2(0.);\n    mat2 r = rotate2D(12.);\n    float terrain_scale = 16.;\n    uv *= terrain_scale;\n    vec2 uv1 = uv;\n        \n        \n\n        \n    for (int i = 0; i < octaves; i++)\n    {\n        \n\n        //domain warping\n        float u1 = 2.;\n        for(int i = 0; i < 3; i++){\n            vec2 s3 = vec2(sin(uv.x/u1*amplitude+u1),cos(uv.y/u1*amplitude+u1));\n            n1 += s3.x*amplitude;\n            uv += s3*r;\n            u1 *= 2.;\n        }\n        \n        \n        \n        \n        n1 =\n            //vec2(sin(uv.x+cos(uv.y*.37)/.37),cos(uv.y+sin(uv.x*.37)/.37))\n            //vec2(sin(uv.x-n1.y*value),cos(uv.y-n1.x*value))\n            //vec2(sin(uv.x),cos(uv.y))\n            //vec2(sin(uv.x),cos(uv.y))*r //badlands\n            //(vec2(sin(uv.x),cos(uv.y))+n1)/2.\n            (n1+abs(n1-vec2(sin(uv.x),cos(uv.y))))/2.\n        ;\n        uv1 = uv;\n        n2 =\n            n1.x+n1.y\n            //((n1.x+n1.y)-n2)\n            //n1.x+n1.y+n2*.37\n        ;\n        value -=\n            abs(n2)*amplitude\n            //abs(n2-value) * amplitude\n        ;\n        \n        //waves\n        //value += sin(uv.x/1000.+iTime)/10.;\n        \n        //erosion\n        value = sqrt(value*value+.0001);\n        \n        amplitude *= .37;\n        \n        //This makes it somewhat more realistic\n        //amplitude *= (1.+sin(uv.x/4.)/4.);\n\n        uv = \n            //uv*2.05*r+vec2(0.,n2)\n            uv*2.0*r+n1\n        ;\n        //r = rotate2D(12.+(n2)*value/8.);\n    }\n    \n    return value/terrain_scale;\n}\n\n// Low precision mountain sdf, use to determine the position of camera\nfloat sdfMountainLowPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,4)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\n// Mid precision mountain sdf, use to raymarch \nfloat sdfMountainMidPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,8)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\nfloat sdfMountainHighPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,8)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\nvec3 calNormal(vec3 p, float t) {\n    vec2 delta = vec2(1e-3 * t, 0.0);\n    float px = sdfMountainHighPrecision(p.xz - delta.xy) - sdfMountainHighPrecision(p.xz + delta.xy);\n    float py = 2.0 * delta.x;\n    float pz = sdfMountainHighPrecision(p.xz - delta.yx) - sdfMountainHighPrecision(p.xz + delta.yx);\n    return normalize(vec3(px, py, pz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i = 0; i < RAYMARCH_ITER_COUNT; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - sdfMountainMidPrecision(p.xz);\n        if (abs(h) < t * RAYMARCH_ITER_PRECISION || t > tmax) {\n            break;\n        }\n        t += 0.4 * h;\n    }   \n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float dis) {\n    float minStep = clamp(0.01 * dis, 0.5, 50.0);\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < SOFTSHADOW_ITER_COUNT; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - sdfMountainMidPrecision(p.xz);\n        res = min(res, 8.0 * h / t);\n        t += max(minStep, h);\n        if (res < 0.001 || p.y > 200.0) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    vec3 baseSkyCol = vec3(0.3, 0.5, 0.85);\n    vec3 baseGraySkyBandCol = vec3(0.7, 0.75, 0.85);\n    vec3 baseSunCol1 = vec3(1.0, 0.7, 0.4);\n    vec3 baseSunCol2 = vec3(1.0, 0.8, 0.6);\n    vec3 baseSunCol3 = vec3(1.0, 0.8, 0.7);\n    float sunCol1Weight = 0.25;\n    float sunCol2Weight = 0.25;\n    float sunCol3Weight = 0.2;\n\n    vec3 cloudCol = vec3(1.0, 0.95, 1.0);\n    float cloudSparsity = 0.01;\n    float cloudH = 300.0;\n    \n    vec3 baseMountainCol = vec3(0.67, 0.57, 0.44);\n    vec3 baseMountainFogCol = vec3(0.5, 0.75, 1.0);\n\n    vec3 softShadowAmplificationCof = vec3(8.0, 5.0, 3.0); \n    vec3 ambientColComponentCof = vec3(0.4, 0.6, 1.0);\n    vec3 backgroundCompoentCof = vec3(0.4, 0.5, 0.6);\n\n    float angle = 0.05 * iTime;\n    float r = 300.0;\n    float forward_offset = 0.01;\n    vec2 px2 = vec2(r * sin(angle), r * cos(angle));\n    float h = sdfMountainLowPrecision(px2) + 25.0;\n    vec3 lookAt = vec3(r * sin(angle + forward_offset), h, r * cos(angle + forward_offset));\n    vec3 ro = vec3(px2.x, h, px2.y);\n    float focus_distance = 1.0;\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n\n    float tmin = 0.01;    // minimum iter distance of raymarch\n    float tmax = 1000.0;  // maximum iter distance of raymarch\n    float maxH = 300.0;   // maximum height of mountain\n    \n    // optimize: determine tmax and tmin by maximum height of mountain \n    float curMaxDistance = (maxH - ro.y) / rd.y; // distance of ro to highest mountain position\n    if (curMaxDistance > 0.0) {\n        if (maxH > ro.y) {\n            tmax = min(tmax, curMaxDistance);\n        } else {\n            tmin = max(tmin, curMaxDistance);\n        }\n    }\n    \n    vec3 sunDir = normalize(vec3(0.8, 0.5, -0.2));\n    float sunDot = clamp(dot(sunDir, rd), 0.0, 1.0);\n    float t = rayMarch(ro, rd, tmin, tmax);\n    \n    float difCof = 0.1;\n\n    // rendering\n    if (t < tmax) {\n        // rendering mountain\n        vec3 p = ro + t * rd;\n        vec3 n = calNormal(p, t);\n        vec3 difCol = difCof * baseMountainCol;\n        col = difCol; \n\n        vec3 linearColCof = vec3(0.0);\n        float difDot = clamp(dot(n, sunDir), 0.0, 1.0);\n        float softShadowCof = softShadow(p + 0.01 * sunDir, sunDir, t);\n        float softCofX = softShadowCof;\n        float softCofY = softShadowCof * softShadowCof * 0.5 + softShadowCof * 0.5;\n        float softCofZ = softShadowCof * softShadowCof * 0.8 + softShadowCof * 0.2;\n        float ambientCof = clamp(0.5 + 0.5 * n.y, 0.0, 1.0); // ambient occlusion cof\n        float backgroundCof = clamp(0.2 + 0.8 * dot(vec3(-sunDir.x, 0.0, sunDir.z), n), 0.0, 1.0);\n        linearColCof += difDot * softShadowAmplificationCof * vec3(softCofX, softCofY, softCofZ);\n        linearColCof += ambientCof * ambientColComponentCof * 5.0; \n        linearColCof += backgroundCof * backgroundCompoentCof;\n\n        col *= linearColCof;\n\n        // add fog effect to remote mountains: remote mountain means bigger t\n        col = mix(col, 0.75 * baseMountainFogCol, 1.0 - exp(-0.002 * t));\n    } else {\n        // rendering sky\n        col = baseSkyCol - rd.y * rd.y * rd.y * 0.3;\n        col = mix(col, 0.85 * baseGraySkyBandCol, pow(1.0 - max(rd.y, 0.0), 4.0));\n\n        // rendering sun\n        col += sunCol1Weight * baseSunCol1 * pow(sunDot, 16.0);\n        col += sunCol2Weight * baseSunCol2 * pow(sunDot, 256.0);\n        col += sunCol3Weight * baseSunCol3 * pow(sunDot, 512.0);\n\n        // rendering cloud\n        vec2 cloudPos = ro.xz + rd.xz * (cloudH - ro.y) / rd.y + iTime * 3.0;\n        // Effect1: The effect of the cloud is relatively continuous and dense\n        // col = mix(col, cloudCol, 0.5 * fbm(cloudSparsity * cloudPos)); \n        \n        // Effect2: The effect of the cloud is relatively not continuous and not dense\n        col = mix(col, cloudCol, 0.75 * smoothstep(0.4, 0.8, fbm(cloudSparsity * cloudPos)));\n    }\n\n    col += 0.3 * vec3(1.0, 0.7, 0.3) * pow(sunDot, 8.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\nfloat mod1(float a,float b){\n    return \n        mod(a,b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        mod1(a1,4.)\n    ;\n    \n    return\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){    \n    return (1.+fmod(time/2.,2.))/(1.+fmod(time/4.,2.));\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument){\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time/4.)/prime_rhythm(time/4.+4.)*2.\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod(t/t3/2.,s1/2.);\n  ;\n  vec2 a=\n      vec2(-(log(1./64.+fract1(t/2./prime_rhythm(time+14.))/4.)),-(log(1./64.+fract1(t/prime_rhythm(time+7.))/8.)))\n\n  ,\n  nb =\n      t*vec2(pow(2.,(m3+m2-t1*4.)/7.+scale),pow(2.,(m3+m2-t1*4.)/7.+scale))*tempo1\n  ,\n  //sitar = sitar(a,nb)\n  sitar =\n      //log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n      a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n  ,gamelan = a/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,\n  steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud = oud(a,nb)\n  ;\n  switch(instrument){\n  case 1:\n  \n  return\n      gamelan\n      //oud\n      //steel_drum\n      //sitar\n      //hurdy-gurdy\n      //(abs(log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n\n      //log(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a)\n      \n      //abs(log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      //abs(1.+log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      \n      //log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.)))))\n  ;\n  case 2: return sitar;\n  case 3: return oud;\n  case 4: return steel_drum;\n  default: return sitar;\n  }\n}\n\nvec2 mainSound(int a,float b){\n    return\n        (mainSound1(a,b,6.,3))\n        \n        //my favorite remix!\n        //(mainSound1(a,b/2.,7.5,4)+mainSound1(a,b,6.5,3))/2.\n        \n        //(mainSound1(a,b,5.5,4)+mainSound1(a,b*2.,6.5,3))/2.\n        \n        //gong remix (using oud)\n        //abs(mainSound1(a,b,6.5,3)-mainSound1(a,b,6.,3)/2.)\n        \n        //black metal!\n        //abs(mainSound1(a,b,6.5,3)-mainSound1(a,b*2.,6.,3))/2.\n\n        \n        //mainSound1(a,b/2.,6.5,1)+mainSound1(a,b,5.5,3)/2.+mainSound1(a,b*2.,4.5,1)/4.+mainSound1(a,b*4.,3.5,1)/8.\n        //(mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,7.5,1)+mainSound1(a,b/4.,8.5,1))\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltcWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 369, 369, 457], [459, 459, 510, 510, 699], [701, 701, 726, 726, 820], [822, 863, 886, 886, 1386], [1388, 1388, 1408, 1431, 1626], [1628, 1672, 1691, 1691, 1908], [1910, 1910, 1934, 1934, 1986], [1989, 1989, 2024, 2106, 3712], [3714, 3785, 3827, 3827, 3926], [3928, 3976, 4018, 4018, 4117], [4119, 4119, 4162, 4162, 4261], [4263, 4263, 4296, 4296, 4610], [4612, 4612, 4670, 4670, 4967], [4969, 4969, 5016, 5016, 5426], [5428, 5428, 5450, 5450, 9464], [9466, 9466, 9521, 9521, 9612]], "test": "untested"}
{"id": "cltyD4", "name": "CRT-Easymode", "author": "starfreakclone", "description": "GLSL port of CRT-Easymode: https://github.com/libretro/common-shaders/blob/master/crt/shaders/crt-easymode.cg", "tags": ["crt"], "likes": 4, "viewed": 260, "published": 3, "date": "1699214166", "time_retrieved": "2024-07-30T17:23:51.488034", "image_code": "// This is largely the crt-easymode shader found at https://github.com/libretro/glsl-shaders/blob/master/crt/shaders/crt-easymode.glsl.\n\n#define FragColor fragColor\n\n#define COMPAT_PRECISION\n\n#define OutputSize iResolution.xy\n#define TextureSize iResolution.xy\n#define InputSize iResolution.xy\n#define Texture iChannel0\n\n#define COMPAT_TEXTURE texture\n\n#if 0\nuniform COMPAT_PRECISION vec2 OutputSize;\nuniform COMPAT_PRECISION vec2 TextureSize;\nuniform COMPAT_PRECISION vec2 InputSize;\nuniform sampler2D Texture;\nCOMPAT_VARYING vec4 TEX0;\n#endif\n\n#define FIX(c) max(abs(c), 1e-5)\n#define PI 3.141592653589\n\n#define TEX2D(c) dilate(COMPAT_TEXTURE(Texture, c))\n\n// compatibility #defines\n#define Source Texture\n#define vTexCoord uv\n\n#define SourceSize vec4(TextureSize, 1.0 / TextureSize) //either TextureSize or InputSize\n#define outsize vec4(OutputSize, 1.0 / OutputSize)\n\n#ifdef PARAMETER_UNIFORM\n// All parameter floats need to have COMPAT_PRECISION in front of them\nuniform COMPAT_PRECISION float SHARPNESS_H;\nuniform COMPAT_PRECISION float SHARPNESS_V;\nuniform COMPAT_PRECISION float MASK_STRENGTH;\nuniform COMPAT_PRECISION float MASK_DOT_WIDTH;\nuniform COMPAT_PRECISION float MASK_DOT_HEIGHT;\nuniform COMPAT_PRECISION float MASK_STAGGER;\nuniform COMPAT_PRECISION float MASK_SIZE;\nuniform COMPAT_PRECISION float SCANLINE_STRENGTH;\nuniform COMPAT_PRECISION float SCANLINE_BEAM_WIDTH_MIN;\nuniform COMPAT_PRECISION float SCANLINE_BEAM_WIDTH_MAX;\nuniform COMPAT_PRECISION float SCANLINE_BRIGHT_MIN;\nuniform COMPAT_PRECISION float SCANLINE_BRIGHT_MAX;\nuniform COMPAT_PRECISION float SCANLINE_CUTOFF;\nuniform COMPAT_PRECISION float GAMMA_INPUT;\nuniform COMPAT_PRECISION float GAMMA_OUTPUT;\nuniform COMPAT_PRECISION float BRIGHT_BOOST;\nuniform COMPAT_PRECISION float DILATION;\n#else\n\n#if 0 // Original values.\n#define SHARPNESS_H 0.5\n#define SHARPNESS_V 1.0\n#define MASK_STRENGTH 0.3\n#define MASK_DOT_WIDTH 1.0\n#define MASK_DOT_HEIGHT 1.0\n#define MASK_STAGGER 0.0\n#define MASK_SIZE 1.0\n#define SCANLINE_STRENGTH 1.0\n#define SCANLINE_BEAM_WIDTH_MIN 1.5\n#define SCANLINE_BEAM_WIDTH_MAX 1.5\n#define SCANLINE_BRIGHT_MIN 0.35\n#define SCANLINE_BRIGHT_MAX 0.65\n#define SCANLINE_CUTOFF 400.0\n#define GAMMA_INPUT 2.0\n#define GAMMA_OUTPUT 1.8\n#define BRIGHT_BOOST 1.2\n#define DILATION 1.0\n\n#pragma parameter SHARPNESS_H             \"Sharpness Horizontal\"     0.5   0.0  1.0     0.05\n#pragma parameter SHARPNESS_V             \"Sharpness Vertical\"       1.0   0.0  1.0     0.05\n#pragma parameter MASK_STRENGTH           \"Mask Strength\"            0.3   0.0  1.0     0.01\n#pragma parameter MASK_DOT_WIDTH          \"Mask Dot Width\"           1.0   1.0  100.0   1.0\n#pragma parameter MASK_DOT_HEIGHT         \"Mask Dot Height\"          1.0   1.0  100.0   1.0\n#pragma parameter MASK_STAGGER            \"Mask Stagger\"             0.0   0.0  100.0   1.0\n#pragma parameter MASK_SIZE               \"Mask Size\"                1.0   1.0  100.0   1.0\n#pragma parameter SCANLINE_STRENGTH       \"Scanline Strength\"        1.0   0.0  1.0     0.05\n#pragma parameter SCANLINE_BEAM_WIDTH_MIN \"Scanline Beam Width Min.\" 1.5   0.5  5.0     0.5\n#pragma parameter SCANLINE_BEAM_WIDTH_MAX \"Scanline Beam Width Max.\" 1.5   0.5  5.0     0.5\n#pragma parameter SCANLINE_BRIGHT_MIN     \"Scanline Brightness Min.\" 0.35  0.0  1.0     0.05\n#pragma parameter SCANLINE_BRIGHT_MAX     \"Scanline Brightness Max.\" 0.65  0.0  1.0     0.05\n#pragma parameter SCANLINE_CUTOFF         \"Scanline Cutoff\"          400.0 1.0  1000.0  1.0\n#pragma parameter GAMMA_INPUT             \"Gamma Input\"              2.0   0.1  5.0     0.1\n#pragma parameter GAMMA_OUTPUT            \"Gamma Output\"             1.8   0.1  5.0     0.1\n#pragma parameter BRIGHT_BOOST            \"Brightness Boost\"         1.2   1.0  2.0     0.01\n#pragma parameter DILATION                \"Dilation\"                 1.0   0.0  1.0     1.0\n#endif\n#define SHARPNESS_H 0.5\n#define SHARPNESS_V 1.0\n#define MASK_STRENGTH 0.6\n#define MASK_DOT_WIDTH 1.0\n#define MASK_DOT_HEIGHT 1.0\n#define MASK_STAGGER 0.0\n#define MASK_SIZE 1.0\n#define SCANLINE_STRENGTH 1.0\n#define SCANLINE_BEAM_WIDTH_MIN 1.5\n#define SCANLINE_BEAM_WIDTH_MAX 1.5\n#define SCANLINE_BRIGHT_MIN 0.35\n#define SCANLINE_BRIGHT_MAX 0.65\n#define SCANLINE_CUTOFF 400.0\n#define GAMMA_INPUT 2.0\n#define GAMMA_OUTPUT 1.8\n#define BRIGHT_BOOST 1.2\n#define DILATION 1.0\n\n#endif\n\n// Set to 0 to use linear filter and gain speed\n#define ENABLE_LANCZOS 1\n\nvec4 dilate(vec4 col)\n{\n    vec4 x = mix(vec4(1.0), col, DILATION);\n\n    return col * x;\n}\n\nfloat curve_distance(float x, float sharp)\n{\n\n/*\n    apply half-circle s-curve to distance for sharper (more pixelated) interpolation\n    single line formula for Graph Toy:\n    0.5 - sqrt(0.25 - (x - step(0.5, x)) * (x - step(0.5, x))) * sign(0.5 - x)\n*/\n\n    float x_step = step(0.5, x);\n    float curve = 0.5 - sqrt(0.25 - (x - x_step) * (x - x_step)) * sign(0.5 - x);\n\n    return mix(x, curve, sharp);\n}\n\nmat4 get_color_matrix(vec2 co, vec2 dx)\n{\n    return mat4(TEX2D(co - dx), TEX2D(co), TEX2D(co + dx), TEX2D(co + 2.0 * dx));\n}\n\nvec3 filter_lanczos(vec4 coeffs, mat4 color_matrix)\n{\n    vec4 col        = color_matrix * coeffs;\n    vec4 sample_min = min(color_matrix[1], color_matrix[2]);\n    vec4 sample_max = max(color_matrix[1], color_matrix[2]);\n\n    col = clamp(col, sample_min, sample_max);\n\n    return col.rgb;\n}\n\nvec4 compute(vec2 uv)\n{\n    vec2 dx     = vec2(SourceSize.z, 0.0);\n    vec2 dy     = vec2(0.0, SourceSize.w);\n    vec2 pix_co = vTexCoord * SourceSize.xy - vec2(0.5, 0.5);\n    vec2 tex_co = (floor(pix_co) + vec2(0.5, 0.5)) * SourceSize.zw;\n    vec2 dist   = fract(pix_co);\n    float curve_x;\n    vec3 col, col2;\n\n#if ENABLE_LANCZOS\n    curve_x = curve_distance(dist.x, SHARPNESS_H * SHARPNESS_H);\n\n    vec4 coeffs = PI * vec4(1.0 + curve_x, curve_x, 1.0 - curve_x, 2.0 - curve_x);\n\n    coeffs = FIX(coeffs);\n    coeffs = 2.0 * sin(coeffs) * sin(coeffs * 0.5) / (coeffs * coeffs);\n    coeffs /= dot(coeffs, vec4(1.0));\n\n    col  = filter_lanczos(coeffs, get_color_matrix(tex_co, dx));\n    col2 = filter_lanczos(coeffs, get_color_matrix(tex_co + dy, dx));\n#else\n    curve_x = curve_distance(dist.x, SHARPNESS_H);\n\n    col  = mix(TEX2D(tex_co).rgb,      TEX2D(tex_co + dx).rgb,      curve_x);\n    col2 = mix(TEX2D(tex_co + dy).rgb, TEX2D(tex_co + dx + dy).rgb, curve_x);\n#endif\n\n    col = mix(col, col2, curve_distance(dist.y, SHARPNESS_V));\n    col = pow(col, vec3(GAMMA_INPUT / (DILATION + 1.0)));\n\n    float luma        = dot(vec3(0.2126, 0.7152, 0.0722), col);\n    float bright      = (max(col.r, max(col.g, col.b)) + luma) * 0.5;\n    float scan_bright = clamp(bright, SCANLINE_BRIGHT_MIN, SCANLINE_BRIGHT_MAX);\n    float scan_beam   = clamp(bright * SCANLINE_BEAM_WIDTH_MAX, SCANLINE_BEAM_WIDTH_MIN, SCANLINE_BEAM_WIDTH_MAX);\n    //float scan_weight = 1.0 - pow(cos(vTexCoord.y * 2.0 * PI * SourceSize.y) * 0.5 + 0.5, scan_beam) * SCANLINE_STRENGTH;\n    float scan_weight = 1.0 - pow(cos(vTexCoord.y * SourceSize.y) * 0.5 + 0.5, scan_beam) * SCANLINE_STRENGTH;\n\n    float mask   = 1.0 - MASK_STRENGTH;    \n    vec2 mod_fac = floor(vTexCoord * outsize.xy * SourceSize.xy / (InputSize.xy * vec2(MASK_SIZE, MASK_DOT_HEIGHT * MASK_SIZE)));\n    int dot_no   = int(mod((mod_fac.x + mod(mod_fac.y, 2.0) * MASK_STAGGER) / MASK_DOT_WIDTH, 3.0));\n    vec3 mask_weight;\n\n    if      (dot_no == 0) mask_weight = vec3(1.0,  mask, mask);\n    else if (dot_no == 1) mask_weight = vec3(mask, 1.0,  mask);\n    else                  mask_weight = vec3(mask, mask, 1.0);\n\n#if 0\n    if (InputSize.y >= SCANLINE_CUTOFF) \n        scan_weight = 1.0;\n#endif\n\n    col2 = col.rgb;\n    col *= vec3(scan_weight);\n    col  = mix(col, col2, scan_bright);\n    col *= mask_weight;\n    col  = pow(col, vec3(1.0 / GAMMA_OUTPUT));\n\n    return vec4(col * BRIGHT_BOOST, 1.0);\n}\n\n/* There was an interesting discussion about getting a better CRT-staggered look which is closer to a slot mask: https://forums.libretro.com/t/crt-easymode/1648\n\nThanks for the compliment Patrick.\n\nI believe your friend is referring to the RGB mask that, by default, mimics an aperture grille pattern running vertically along the screen. The mask in this shader is fixed pixel, so the density of the pattern will vary depending on your display’s resolution. On a lower res screen it may appear more like an LCD grid, whereas on a 4K display it will appear very fine and perhaps closer to a real CRT with an aperture grille. I use a 1080p monitor and I wouldn’t call the mask realistic at that resolution, but I just happen to like the way it looks.\n\nYour friend may also be more accustomed to CRTs with shadow masks. You can see the differnce here:\n\nCrt-easymode can be configured in a Lottes style shadow mask (a la crt-lottes) by setting the following parameters like so: MASK_SUBPIXEL_WIDTH 2.0, MASK_SUBPIXEL_HEIGHT 1.0, MASK_STAGGER 3.0.\n\nYou can see a preview here (second pic):\n\nviewtopic.php?f=6&t=2360 96\n\nIf someone prefers having no mask, they can set MASK_STRENGTH to 0.0 – and if they do that I recommend also lowering BRIGHT_BOOST to 1.0 as that parameter is meant to make up for the brightness loss caused by the mask.\n\nAlso, in case you’re still using RetroArch 1.0.0.2, lord ashram has a dropbox where he posts test builds. These newer builds have a parameter menu that lets you adjust shader parameters from within RetroArch.\n\n1.0.0.3 Beta is apparently coming soon too.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n#endif\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = compute(uv);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DldcW4", "name": "Japanese synth-wave sunset", "author": "atomgrafika", "description": "Stylish synthwave sunset that reminds me of Japan. Have fun!", "tags": ["sunset", "background", "japanese", "bg", "synthwave"], "likes": 5, "viewed": 198, "published": 3, "date": "1699213766", "time_retrieved": "2024-07-30T17:23:52.305847", "image_code": "//Based on https://www.shadertoy.com/view/Wt33Wf by kaiware007\n\nfloat sun(vec2 uv, float battery)\n{\n    float val = smoothstep(0.3, 0.29, length(uv));\n    float bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.1 * (battery + 0.002)) * 80.0) \n                + clamp(uv.y * 15.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 0.8);\n    return clamp(val * cut, 0.1, 1.0) + bloom * 0.4;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.5) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n    vec2 lines = smoothstep(size, vec2(0.0), uv);\n    lines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float battery = 0.5; // Assume full battery for simplicity\n\n    // Grid\n    // float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    if (uv.y < -0.19)\n    {\n        uv.y = 1.0 / (abs(uv.y + 0.2) + 0.05);\n        uv.x *= uv.y * 1.0;\n        float gridVal = grid(uv, battery);\n        col = mix(col, vec3(1.0, 1.0, 1.0), gridVal);\n    }\n\n    // Sun calculation\n    vec2 sunPosition = vec2(0.0, 0.3); // Center the sun in the viewport\n    float sunVal = sun(uv - sunPosition, battery);\n    \n    col = mix(vec3(1.0, 1.0, 1.0), col, sunVal);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 99, 99, 420], [422, 422, 458, 458, 763], [765, 765, 822, 822, 1506]], "test": "untested"}
{"id": "DldyW4", "name": "Stable color expanding rings", "author": "olehermanse", "description": "First stab at making expanding circles with somewhat stable colors", "tags": ["circles"], "likes": 1, "viewed": 130, "published": 3, "date": "1699211685", "time_retrieved": "2024-07-30T17:23:53.156573", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n    float y = -1.0 + 2.0 * (fragCoord.y / iResolution.y);\n    float x = (-1.0 + 2.0 * (fragCoord.x / iResolution.x)) * ratio;\n    float time = 0.2 * iTime;\n    vec2 uv = vec2(x, y);\n    vec2 origin = vec2(0.0, 0.0);\n    float dist = distance(uv, origin);\n\n    float wave = 0.5 + 0.5 * sin(time + 10.0*(-time + dist));\n    float stepped = step(0.5, wave);\n    float colorTime = dist - 1.0 * time;\n    vec3 col = pal( colorTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    fragColor = vec4(stepped * col, 0.5);\n    // fragColor = vec4(stepped, stepped, stepped, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 170, 170, 824]], "test": "untested"}
{"id": "cdKfzt", "name": "RayMarchHelloWorld", "author": "GabrielTheWalrus", "description": "Raymarching tutorial", "tags": ["raymarch", "tutorial"], "likes": 0, "viewed": 166, "published": 3, "date": "1699205498", "time_retrieved": "2024-07-30T17:23:54.015277", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nmat3 setCamera(vec3 ro, vec3 lookat, vec3 wUp){\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(f,r,u);\n}\n\nvec2 getDist(vec3 p){\n\n    float t = iTime;\n\n    vec4 sphere = vec4(0., 1., 5., 1.);\n    vec4 sphere2 = vec4(.5, 3., 2., 2.);\n    vec4 wall = vec4(0.0, .0, 2, 1.0);\n    \n    float sphereDist = sdSphere((p-sphere.xyz), sphere.w);\n    float sphereDist2 = sdSphere((p-sphere2.xyz), sphere2.w);\n    float groundDist = sdPlane(p);\n    \n    if(sphereDist < groundDist)\n        return vec2(sphereDist, 1.);\n    \n    else return vec2(groundDist, 0.);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n\n    float dO = .0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        \n        vec3 p = ro + rd * dO; // distancia da superficie\n        float dS = getDist(p).x;\n        dO = dO + dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n \n     float d = getDist(p).x;\n     vec2 e = vec2(.01, 0);\n     \n     vec3 n = d - vec3(\n         getDist(p-e.xyy).x,\n         getDist(p-e.yxy).x,\n         getDist(p-e.yyx).x);\n         \n     return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightSourcePos){\n    \n    vec3 l = normalize(lightSourcePos-p); // light direction from point p\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    \n    float d = rayMarch(p+n*SURF_DIST*2.0, l);\n    \n    if(d < length(lightSourcePos-p))\n        return dif*0.2;\n\n    return dif;\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // 640 x 360\n    //uv = uv*2.0 - 1.0f; //Pq isso é ruim?\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 ro = vec3(.0, 1.0, -2.);\n    vec3 lookat = vec3(.0, 1., 5.);\n    \n    mat3 cameraMatrix = setCamera(ro, lookat, vec3(0., 1., 0.));\n    \n    float zoom = 1.;\n    \n    vec3 c = ro + cameraMatrix[0]*zoom;\n    vec3 i = c + uv.x * cameraMatrix[1] + uv.y * cameraMatrix[2];\n    \n    //vec3 rd = i - ro;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0)); ///outro tipo de camera?\n    \n    vec3 lightSourcePos = vec3(sin(t), 5., cos(t));\n    \n    float res = rayMarch(ro, rd);\n    vec3 p = ro + rd * res;\n    \n    res = getLight(p, lightSourcePos);\n    vec2 teste = getDist(p);\n    \n    vec3 sphereColor = vec3(1.0, .0, 1.0);\n    vec3 groundColor = vec3(.0, 1.0, 0.0);\n    \n    //res /= 20.; \n    \n   // res = smoothstep(.001, 1., res);\n    \n    vec3 col = vec3(res);\n    \n    \n    if(teste.y == 1.0)\n        col = col * sphereColor;\n    else\n        col = col * groundColor;\n    \n    //fragColor = vec4(uv, 0., 1.);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 92, 92, 107], [109, 109, 144, 144, 170], [172, 172, 219, 219, 377], [379, 379, 400, 400, 823], [826, 826, 859, 859, 1134], [1136, 1136, 1159, 1159, 1374], [1376, 1376, 1420, 1420, 1710], [1712, 1712, 1769, 1819, 2961]], "test": "untested"}
{"id": "dlcyWN", "name": "HUD element - 01", "author": "atomgrafika", "description": "Shader to make a you're HUD design pop or just for entertainment :)", "tags": ["vfx", "red", "hud"], "likes": 2, "viewed": 145, "published": 3, "date": "1699205300", "time_retrieved": "2024-07-30T17:23:54.909885", "image_code": "//This code is just the modificatipon of the original post //https://www.shadertoy.com/view/mtyGWy by kishimisu\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.2, 0.0, 0.0);\n    vec3 c = vec3(1.0, 1.0, 0.8);\n    vec3 d = vec3(0.0,0.0,0.9);\n\n    vec3 timePhase = vec3(1.0, 2.0, 3.0) * t;\n\n    return a + b*cos( 2.0*(c*t+d) );\n}\nconst float PI = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n\nfloat segments = 127.8;\n    float angle = 5.0 * PI / segments;\n\n float r = length(uv);\n    float theta = atan(uv.y, uv.x);   \n\n    theta = abs(mod(theta, angle) - angle * 0.5);\n\nfloat rotationSpeed = 0.1; // The speed of rotation, change this value to make it faster or slower\n    theta += iTime * rotationSpeed;\n    \n    uv = r * vec2(cos(theta), sin(theta));\n   \n     for (float i = 5.3; i < 5.9; i+= 0.8) {\n        uv = fract(uv * 2.1) - 0.5;\n        float d = length(uv) * exp(-r);\n\n        vec3 col = palette(length(uv0) + i*.1 + iTime*0.2);\n\n        d = sin(d*15. + iTime)/10.;\n        d = abs(d);\n        d = pow(0.005 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 138, 138, 359], [383, 383, 439, 439, 1284]], "test": "untested"}
{"id": "DttyWH", "name": "Alien Xor Tapestry", "author": "domrally", "description": "A study on \"floatBitsToInt\".\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "pixel", "alien", "xor", "tile", "bit", "mosaic", "carpet", "tweet", "diagram", "bitwise", "circuit", "roller", "bitfield"], "likes": 7, "viewed": 251, "published": 3, "date": "1699199343", "time_retrieved": "2024-07-30T17:23:55.756621", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    // +33 = 127 characters with the animation\n    i = mod(iTime / 1e3 + i, iResolution.x);\n\n    // 94 characters for static\n    ivec2 m = floatBitsToInt(i) / 99 * 99;\n    o = vec4(0);\n    o[(m.x ^ m.y)%7]++;\n}\n\n\n/*\nSEE ALSO\n\nhttps://www.shadertoy.com/view/dlcyR4\nhttps://www.shadertoy.com/view/3tlcz4\nhttps://en.wikipedia.org/wiki/Bitwise_operation#XOR\nhttps://en.wikipedia.org/wiki/Modulo#In_programming_languages\nhttps://registry.khronos.org/OpenGL-Refpages/es3.0/html/floatBitsToInt.xhtml\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 110, 274]], "test": "untested"}
{"id": "DldyWH", "name": "spqr the great migration", "author": "spqr", "description": "a", "tags": ["a"], "likes": 2, "viewed": 157, "published": 3, "date": "1699188042", "time_retrieved": "2024-07-30T17:23:56.938461", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash13(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  r = smoothstep(0.,1.,r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\n\n\n\n\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n    //pt.xz=pt.x<pt.z?pt.zx:pt.xz;\n  }\n  return pt;\n}\n\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return max(max(q.x,q.y),q.z);\n   //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nint matter = 0;\nfloat art(vec3 p, float f1) {\n\n\n\n  \n vec3 pt=p;\n  \n\n  float width = 19.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  \n  float zz = 111.1;\n  \n  pt=ifs(pt,vec3(3.6,3.0+0.4+(zz + f1 * 121.1)/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n\n  float dist;\n  \n  dist=box(pt,vec3(.17));\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\n\n\n\n\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\n\nfloat map2(vec3 p) {\n\n\n \n  float dom = 11.;\n  vec3 id = floor(p/dom);\n  float f1 = hash(id);\n  \n  p.xy = mod(p.xy, dom) - dom/2.;\n  float a = art(p,f1);\n \n  return a;\n}\n\nvec3 sinz ( float t, vec3 u) {\n\n    vec3 a = hash33(u);\n    vec3 b = hash33(u+25.2335);\n    vec3 c = hash33(u+646.223);\n\n    a.xz *= rot(hash31(u)+22.53+t);\n    a.yz *= rot(hash31(u)+44.22+t);\n    a.xy *= rot(hash31(u)+966.33+t);\n \n \n    b.xz *= rot(hash31(u)+11.343+2.*t);\n    b.yz *= rot(hash31(u)+144.22+2.*t);\n    b.xy *= rot(hash31(u)+266.33+2.*t);\n    \n    c.xz *= rot(hash31(u)+64.4+3.*t);\n    c.yz *= rot(hash31(u)+4114.22+3.*t);\n    c.xy *= rot(hash31(u)+56.33+3.*t);\n\n \n    \n    vec3 z = sin(t) * a + cos(t*4.14+5.235)/4. * b + sin(t*7.11+66.23)/7.;\n    return z;\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat art(vec3 p, vec3 id) {\n\n\n\n\n\n  \n vec3 pt=p;\n  \n\n  float width = 13.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  float zz =   iTime + hash31(id)*110.;\n  pt=ifs(pt,vec3(3.6,3.0+0.4+zz/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n\n  float dist;\n  \n  dist=box(pt,vec3(.17));\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\nfloat glow = 0.;\nfloat confine(vec3 p, vec3 r, vec3 d) {\n    vec3 t = (d/2. - p) / r;\n    t = max(t, -t);\n    return max(max(max(t.x, t.y), t.z),0.);\n}\n\n\nfloat map ( vec3 p , vec3 r) {\n\n   // geo\n  \n  \n\n    vec3 q = p;\n    float dom =6.;\n    \n    vec3 id = floor(p/dom-0.5);\n    \n\n    \n    p = (fract(p/dom-0.5)-0.5)*dom;\n   \n    \n    \n    vec3 size = hash33(id);\n    vec3 jump = hash33(id.zxy + 2553.1242);\n    float prob = hash31(id.zxy);\n    \n    if ( prob *(sin(id.z)*.5+.5)< .3) {\n        size *= 0.;\n    }\n \n \n    vec3 f1 = sinz(iTime*pow(hash31(id),.3), id);//fbm(vec3(iTime*.3)+id);\n  \n    float b1 = box(p + f1*2., size);\n    \n    float bound = box(p, vec3((dom/2.)+.1));\n     \n    //return min(b,-bound);\n    float y = 4.;\n    //float a1 = art((p+f1*2.)*size*y)/(y*max(max(size.z,size.y),size.z));\n    float a1 = art((p+f1*2.)*3.,id)/3.;\n    \n    \n    float balls = max(.1,sph(p + f1 *2., 1.5));\n    glow += .001/(.1+abs(balls));\n    \n    return min(balls,min(-bound,max(b1,a1)));\n}\n\nvec3 norm(vec3 p,vec3 r, vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx,r)-map(p-d.yxx,r),\n    map(p+d.xyx,r)-map(p-d.xyx,r),\n    map(p+d.xxy,r)-map(p-d.xxy,r)\n  ));\n}\n\n\nvec3 norm3(vec3 p, vec3 r) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p,r)-vec3(map(p-off.xyy,r), map(p-off.yxy,r), map(p-off.yyx,r))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  r = smoothstep(0.,1.,r);\n\n  return i+r;  \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  float tt = tick(iTime*.1); ;\n  \n  // nav\n  \n  vec3 s = vec3(1,2,3.1);\n  vec3 neck = vec3(0,0,100);\n\n  neck.yz*=rot(tick(tt));\n  \n  s += neck;\n  \n  vec3 arm = vec3(0.235,0.532,10);\n  arm.xz *= rot(tick(tt*.91));\n  arm.xy *= rot(tick(tt*1.21));\n  \n  vec3 fwd = vec3(0,0,1)*tt*250.;\n  s += fwd;\n  \n  vec3 t =  s + arm;\n   \n  \n\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz -= dot(uv,uv)/15.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n  float u =0.;\n  for(float z=0.;z<300.;z++){ \n    \n    i = z;\n    d = map(p,r);\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 500.) {\n        break;\n    }\n    \n    dd += d;\n    p += r * d;\n\n  }\n \n vec3 col = vec3(0);\n \n     vec3 n = norm(p, r, vec2(0.0, 1.0E-2) );\n     vec3 l1 = normalize(vec3(-1,-4,-1));\n     l1.xz *= rot(tt);\n     l1.yz *= rot(tt*2.55);\n     \n     vec3 l2 = normalize(vec3(1));\n     l2.xz *= rot(tt*1.41);\n     l2.yx *= rot(tt*1.35);\n   \n   \n     \n        \n     if ( dot(n,l1) < 0.) {\n              l1 = -l1;\n     }\n     if ( dot(n,l2) < 0.) {\n              l2 = -l2;\n     }\n     vec3 h1 = normalize(l1-r);\n     vec3 h2 = normalize(l2-r);\n     \n     float spec1 =( 0.4 + pow(max(0., dot(n,h1)),41.));\n     float spec2 =( 0.4 + pow(max(0., dot(n,h2)),22.));\n    \n     float diff = max(0., dot(n,l1));\n    \n    \n     float aosize = 1.;\n     float ao = 1.-smoothstep(0.,1.,map(p + n * aosize, r)/aosize); \n    \n     \n   \n     col +=  diff * (spec1 + spec2);\n     //col += spec1;\n     //col -= ao;\n  \n     col += glow*1.3;\n  n2=norm(p, r, vec2(0.0, 1.0E-2) );\n  n1=norm(p, r, vec2(0.0, 2.0E-2) );\n  edge=saturate(length(n1-n2)/0.1);\n  col -= edge;\n  \n  \n  if (!hit) {\n        col =   mix(   vec3(.7,.4,.4),vec3(.8,.5,.3), pow(dot(r,normalize(vec3(1.,1.,0.))),.5));\n        \n        col = abs(col+.1);\n        col = vec3(.8,.5,.2)*1.5;\n        float f1 = (dot(r, vec3(0,0,1))*.5+.5);\n        f1 = pow(f1,1.);\n      \n        \n        \n        col = mix(col, vec3(.2,.0,0),f1);\n        //col = mix(col, vec3(.4,.1,.1), pow(abs(dot(r, normalize(vec3(0,0,1)))),1.));\n  }\n\n  fragColor = vec4(col, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 210, 210, 313], [314, 314, 336, 336, 544], [545, 545, 567, 567, 733], [737, 737, 766, 766, 831], [832, 832, 874, 874, 981], [983, 983, 1006, 1006, 1114], [1116, 1116, 1140, 1140, 1687], [1689, 1689, 1711, 1711, 1919], [1921, 1921, 1946, 1946, 1979], [1983, 1983, 2004, 2004, 2053], [2054, 2054, 2074, 2074, 2123], [2125, 2125, 2146, 2146, 2193], [2194, 2194, 2213, 2213, 2282], [2284, 2284, 2309, 2309, 2778], [2780, 2780, 2803, 2803, 2920], [2921, 2921, 2941, 2941, 3125], [3129, 3129, 3158, 3158, 3187], [3191, 3191, 3216, 3216, 3256], [3261, 3261, 3275, 3275, 3315], [3318, 3318, 3354, 3354, 3407], [3438, 3438, 3477, 3477, 3554], [3557, 3557, 3587, 3587, 3613], [3616, 3616, 3654, 3654, 3977], [3980, 3980, 4007, 4007, 4033], [4035, 4035, 4063, 4063, 4094], [4097, 4097, 4125, 4125, 4251], [4270, 4270, 4299, 4299, 4767], [4773, 4773, 4796, 4796, 4975], [4978, 4978, 4998, 4998, 5146], [5148, 5148, 5178, 5178, 5723], [5724, 5724, 5747, 5747, 5850], [5852, 5852, 5880, 5880, 6349], [6367, 6367, 6406, 6406, 6501], [6504, 6504, 6534, 6545, 7342], [7344, 7344, 7378, 7378, 7515], [7518, 7518, 7546, 7546, 7673], [7679, 7679, 7700, 7700, 7817], [7821, 7821, 7878, 7878, 10322]], "test": "untested"}
{"id": "cl3cD4", "name": " Rubik's mat sphere", "author": "chenxianming", "description": "i think mod position can't be rotation single cell.", "tags": ["rubik", "mat", "cineshader"], "likes": 16, "viewed": 900, "published": 3, "date": "1699180629", "time_retrieved": "2024-07-30T17:23:57.976685", "image_code": "\n#define I iResolution\n#define S .25\n#define cc 3.\n#define sp .3\n#define T(s) fract(iTime * s) * PI * 4.\n#define T2(s) fract(iTime * s) * 5.\n#define tl( s ) fract( iTime * s )\n#define PI 3.1415926\n#define TAU 6.2831852\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n\n\nfloat O( vec3 p ){\n    return length( p ) - .25;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat ct( vec3 p, vec3 p2 ){\n    return max(\n        sdCapsule( p, normalize( p2 ), vec3(0), .01 ),\n        max(\n            max(\n                abs( p.x ) - .5,\n                abs( p.y ) - .5\n            ),\n            abs( p.z ) - .5\n        )\n    );\n}\n\nfloat f( vec3 p, vec3 p2 ){\n    \n    return min(\n        O( p2 ),\n        ct( p, p2 )\n    );\n}\n\nvoid updateCR( inout vec3 a, inout vec3 b, inout vec3 c, float i ){\n    a.xy *= rot( T( S ) );\n    a.x += ( sp * 2. ) * i - ( sp * ( cc - 1. ) );\n    b.x += ( sp * 2. ) * i - ( sp * ( cc - 1. ) );\n\n    c.xz *= rot( T( S ) );\n    c.x += ( sp * 2. ) * i - ( sp * ( cc - 1. ) );\n}\n\nvoid updateXY( inout vec3 a, inout vec3 b, float j ){\n    a.xy *= rot( T( S ) );\n    b.y += ( sp * 2. ) * j - ( sp * ( cc - 1. ) );\n    a.y += ( sp * 2. ) * j - ( sp * ( cc - 1. ) );\n}\n\nvoid updateR( inout vec3 a, inout vec3 b, float h ){\n    a.z += ( sp * 2. ) * h - ( sp * ( cc - 1. ) );\n    b.xz *= rot( T( S ) );\n    b.z += ( sp * 2. ) * h - ( sp * ( cc - 1. ) );\n}\n\nfloat df( vec3 p ){\n\n    p.xz *= rot( T( S * .5 ) );\n    p.zy *= rot( T( S * .5 ) );\n\n  \n    float d = .1, i, id;\n        \n    for( ;i < cc; i++ ){\n    \n        vec3 p1 = p,\n             p1a = p,\n             p1b = p;\n        \n        updateCR( p1a, p1, p1b, i );\n    \n        for( float j = 0.;j <cc; j++ ){\n            vec3 p2 = p,\n                 p2a = p;\n            \n            updateXY( p2a, p2, j );\n\n            for( float h = 0.;h < cc; h++ ){\n                id++;\n                vec3 p3 = p,\n                     p3a = p;\n                \n                updateR( p3, p3a, h );\n                \n                \n                vec3 m3 = vec3( p1.x, p2.y, p3.z );\n                \n                if( h == 0. && ( tl( .5 ) < .75 && tl( .5 ) > .5 )  )\n                // if( h == 0. && tl( .5 ) < .5 )\n                    m3.x = p1a.x,\n                    m3.y = p2a.y;\n\n\n                if( j == 1. && ( tl( .5 ) > .75 && tl( .5 ) < 1. ) )\n                // if( j == 1. && tl( .5 ) > .5 )\n                    m3.x = p1b.x,\n                    m3.z = p3a.z;\n\n                \n                if( id != 14. )\n                    d = min(\n                        d,\n                        f( p, m3 )\n                    );\n                    \n            }\n        }\n    }\n        \n    return d;\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / I.y;\n    \n    vec3 c, p, o = vec3( 0., 0., -2.5 ), r = vec3( u, 1. );\n    float t, d, i, dp, e = sqrt( 1e-4 );\n    for( ; i < 40.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        dp = ( 1. - abs( d ) / e ),\n        c += ( dp > 0. ) ? .1 * ( i / 40. ) * dp / t : 0.,\n        t += max( abs( d ), e * .5 );\n\n\n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 295, 295, 327], [329, 329, 381, 381, 508], [510, 510, 538, 538, 766], [768, 768, 795, 795, 862], [864, 864, 931, 931, 1141], [1143, 1143, 1196, 1196, 1327], [1329, 1329, 1381, 1381, 1512], [1514, 1514, 1533, 1533, 2825], [2827, 2827, 2868, 2918, 3314]], "test": "untested"}
{"id": "cddBzf", "name": "Newton's Fractal test", "author": "Elyades", "description": "newton fractal", "tags": ["newtonfractal"], "likes": 3, "viewed": 156, "published": 3, "date": "1699177790", "time_retrieved": "2024-07-30T17:23:58.749619", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return vec2( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,2.0);\n    vec3 d = vec3(0.0,0.2,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.33,0.66);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.5,1.0);\n    vec3 d = vec3(0.0,0.8,0.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5 (float t)\n{\n    float value = 0.61;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*t + d)));\n}\n\nvec2 square(vec2 uv)\n{\n    return vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y);\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    float cosine = cos(angle); float sine = sin(angle);\n    return (vec2(cosine*uv.x - sine*uv.y, sine*uv.x + cosine*uv.y));\n}\n\nfloat n = 3.0;\n\nvec3 colorroot(float t, float k)\n{\n    float r = mod(k,3.0);\n    if (r == 0.0){return(palette1(t));}\n    else if(r == 1.0){return(palette2(t));}\n    else {return(palette3(t));}\n}\n\nvec3 colorunity(float t, vec2 znext, float p)\n{\n    for (int k = 0; k < int(p); k++)\n    {\n        if (norm(znext - exp2d(vec2(0.0,TWOPI*float(k)/p))) < 0.1)\n        {\n            return(colorroot(t,float(k)));\n        }\n    }\n}\n\nvec3 colorgeneral(float t, vec2 znext)\n{\n    vec3 col;\n    float iterationCount = t;\n    float scale = 8.0;\n    if (znext.x > 0.0 && znext.y > 0.0){col = palette1(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x > 0.0 && znext.y < 0.0){col = palette2(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x < 0.0 && znext.y > 0.0){col = palette3(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x < 0.0 && znext.y < 0.0){col = palette4(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}  \n    return(col);\n}\n\nvec2 function(vec2 uv, vec2 c)\n{\n    //return( power(uv,3.0) + times((c-vec2(1.0,0.0)),uv) - c );\n    float remainder = 0.0;\n    return (remainder*sin2d(uv) - (1.0-remainder)*power(uv,4.0) + c);\n}\n\nvec2 dfunction(vec2 uv,vec2 c)\n{\n    //return(3.0*power(uv,2.0) + c - vec2(1.0,0.0));\n    float remainder = 0.0;\n    return(remainder*cos2d(uv) - 4.0*(1.0-remainder)*power(uv,3.0));\n}\n\nvec2 newtonIteration(vec2 uv, vec2 c)\n{\n    vec2 a = vec2(1.8 - min(0.8,iTime/10.0));\n    uv = uv - a*times(function(uv,c),oneoverz(dfunction(uv,c)));\n    return(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*300.0;\n    uv *= pow(10.0, (-1.5 + 0.4*cos(iTime*5.0))*min(max(iTime-9.0,0.0),1.0));\n    uv += vec2(0.0, 0.0);\n    uv = rotate(uv,max(iTime-8.0,0.0)*2.0);\n    vec2 zcurrent = uv;\n    float tolerance1 = pow(10.0,-10.0);\n    float tolerance2 = pow(10.0,-10.0);\n    vec2 znext = zcurrent;\n    float norm2 = 1.0;\n    int maxIteration = 1000;\n    int iterationCount = 0;\n    //vec2 c = (iMouse.xy/iResolution.xy - 0.5)*8.0;\n    vec2 c = oneoverz(uv);\n    while((norm(function(zcurrent,c)) > tolerance1) && (iterationCount <= maxIteration) )\n    {\n        zcurrent = znext;\n        znext = newtonIteration(zcurrent,c);\n        norm2 = norm(znext - zcurrent);\n        iterationCount += 1;\n    }\n    \n    vec3 col;\n    if(norm2 < tolerance2)\n    {\n        // for roots of unity:\n        //col = colorunity(float(iterationCount),znext,n);\n        // for anything else whose roots we dont know at first (i cba):\n        //col = colorgeneral(float(iterationCount), znext);\n        float scale = 20.0;\n        col = palette5(float(iterationCount)/scale);\n    }\n    \n    else{col = vec3(0.0);}\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 127, 159, 245], [314, 314, 345, 345, 411], [413, 413, 437, 437, 536], [538, 538, 559, 559, 617], [619, 619, 640, 640, 733], [736, 736, 757, 757, 865], [867, 867, 897, 897, 1050], [1052, 1052, 1078, 1100, 1286], [1288, 1288, 1314, 1336, 1524], [1526, 1526, 1552, 1574, 1760], [1762, 1762, 1788, 1810, 1996], [1998, 1998, 2023, 2023, 2215], [2217, 2217, 2239, 2239, 2296], [2298, 2298, 2318, 2318, 2412], [2414, 2414, 2449, 2449, 2576], [2594, 2594, 2628, 2628, 2772], [2774, 2774, 2821, 2821, 3002], [3004, 3004, 3044, 3044, 3587], [3589, 3589, 3621, 3686, 3785], [3787, 3787, 3819, 3872, 3970], [3972, 3972, 4011, 4011, 4140], [4142, 4142, 4199, 4199, 5371]], "test": "untested"}
{"id": "dldcW8", "name": "twisted dodecahedron", "author": "cyperus", "description": "twisted toroidal spherical regular dodecahedron", "tags": ["3d", "sdf", "stereographic"], "likes": 7, "viewed": 286, "published": 3, "date": "1699160734", "time_retrieved": "2024-07-30T17:23:59.729998", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"twisted dodecahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n//  - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n#define BG_CUBEMAP\n\n// ray casting bounding shape\nconst float CAM_DIST = 4.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 8.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 700; // <1, 700, 2000>\nfloat RAY_STEP_FACTOR3 = 0.27755;   // <0.05, 0.27755 ,0.5>\nconst float RAY_PRECISION = 0.00001;\n\n// 4D rotation\nconst bool ROT_4D = false;\nfloat ROT_4D_t = 0.; \n\n// dodecahedron\nconst int PS_f = 12;\nconst int PS_e_f= 5;\nfloat PS_a0 = 8.;\n\n// torus\nfloat J1_sh_a0 = -1.0; // -1.0\nfloat J1_sh_a1 = -0.4; // -0.4\nint   J1_sh_f1 = 1*PS_e_f;\nfloat J1_sh_pa1 = 0.03;\nint   J1_to_c1 = 6*PS_e_f;\nint   J1_to_f1 = 2*PS_e_f;\nconst float J1_to_pa1 = 0.;\n\n// texture\n// 0: dodeca_cell_id <-> stripes, 1: stripes, 2: normal, 3: dodeca_cell_id, else: plain color\nconst int   TEX_MODE = 0;\nconst bool  TEX_UV_ON = false;\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(1*PS_e_f, 1*PS_e_f);\n\n// fog\nbool  FOG_ON = true;\nconst float FOG_DENSITY = 0.003;\n\nfloat map(in vec3 p, out vec4 mat) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    if(ROT_4D) p = rot4Dz( p, ROT_4D_t, sqrt(abs(PS_a0)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = dodeca_cells(pn, cell_id, sr);\n    // invers stereographic projection\n    //if (pn.z < 0.) // north pol\n    {\n        z = pn.xy/(1.-pn.z);\n        z = cDodecaPolyArc2disk(z);\n    }\n\n    /// r-polygon-distribution\n    vec2 e = vec2(3., 0.5);\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    ////fractal level 1: 2Djulia realaxis-translation,fraction,rotation\n    float sh1 = J1_sh_a0;\n    float to1 = au*float(J1_to_c1)/float(J1_to_f1);\n    sh1 += J1_sh_a1*(1.-pulsecollision(float(J1_sh_f1),au/PI, J1_sh_pa1, 0.5));\n    to1 += J1_to_pa1;  \n    z = crpt(z, to1, float(J1_to_f1), sh1);\n    fracu *= float(J1_sh_f1);\n\n    // distance estimation\n    float d = log(length(z));\n    \n    #if 0\n    st_assert( d != INF, 0 ); // Shows the +INF singularity as a sphere (floating point precision).\n    #else\n    if (d == INF) {d = 1.;} // step through the singularity\n    #endif\n    \n    mat.x = cell_id; mat.yz = z; mat.w = au *fracu; // platonic solid cell_id, metatorus complex plane, metatorus angle_u\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 rescol, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field\n    vec4 trap; // data from surface intersection point\n    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos, trap );\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec4 tmp; // dummie\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy,tmp) - map(p-e.xyy,tmp),\n\t\tmap(p+e.yxy,tmp) - map(p-e.yxy,tmp),\n\t\tmap(p+e.yyx,tmp) - map(p-e.yyx,tmp) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\treturn p.xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation shape\n    const float time_periode = 30.; // 2.*2.*(1.5+3.+3.) in seconds\n    float ntime    = iTime/time_periode;\n    float ntime_id = floor(ntime);     // in {0., 1., 2., ... }\n    float ntime_fr = ntime - ntime_id; // in [ 0.,+1.]\n    ROT_4D_t = ntime;\n\n    PS_a0 *= sin(2.*PI*ntime); // in [-PS_a0, +PS_a0] in length units fractal level 0;\n\n    int sw0 = int(ntime_id) % 2;   \n    if (PS_a0 >= 0.) {\n        J1_sh_a0 = -1.0 * smoothstep( 2., 4., PS_a0);\n        J1_sh_a1 = -0.4 * smoothstep( 4., 6., PS_a0);\n        J1_sh_f1 = sw0*PS_e_f;\n        J1_sh_pa1 *= 30. * ntime; //\n        J1_to_c1 = (3 -4 * sw0) * 2 * PS_e_f; // \n        //J1_to_f1 = 2*PS_e_f;\n    }\n    else {\n        J1_sh_a0 = 2. *smoothstep( 2., 4., -PS_a0); // -2.\n        J1_sh_a1 = 0. *smoothstep( 4., 6., -PS_a0);\n        //J1_sh_f1 = 1*PS_e_f;\n        J1_sh_pa1 *= 0. * ntime;\n        J1_to_c1 = 0*PS_e_f;\n        J1_to_f1 = (sw0+1) *PS_e_f;    \n    }\n      \n    // normalized coords\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // camera viewport --> worldspace\n    vec3 ro = vec3(0,0,-CAM_DIST);\n    vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n    \t ro = transform(ro,iTime);\n\t     rd = normalize(transform(rd,iTime));\n\n    // ray\n    vec4 mat = vec4(0.0); // material-data: vec4(float cell_id, vec2 complex plane, float angle-u)\n    float px = 2.0/( iResolution.y*CAM_FLE );\n    float t = intersect( ro, rd, mat, px ); // distance hit ray surface\n    \n    // color\n    vec3 col_sun = vec3(1.,1.,0.8);\n    vec3 col_sky = vec3(0.8,0.8,1.);\n    #ifdef BG_CUBEMAP\n    vec3 col_nebula = srgb2rgb(texture(iChannel0, rd).rgb);\n    // background-color\n    vec3 bg_col = col_sky * col_nebula;\n    #else\n    vec3 bg_col = vec3(0.9);    \n    #endif\n\n    vec3 col = vec3(0.3); // init, test-color\n    // no hit -> sky\n    if (t < 0.0) {\n        col = bg_col;\n    }\n    // hit -> object surface\n    else {\n    \t// surface properties\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal( p, 0.001);        \n        // object id\n        float obj_id = mat.x;\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = 0.5*mat.w/PI;\n        mat_uv.y = atan(mat.z,mat.y)/PI;\n        // uv-texture\n        col = (TEX_MODE == 0) ? mix( h2rgb(obj_id/float(PS_f)),h2rgb(abs(mat_uv.y)) ,smoothstep(1.,3., abs(PS_a0)) ) // dodeca_cell_id <-> stripes\n            : (TEX_MODE == 1) ? h2rgb(abs(mat_uv.y))       // stripes\n            : (TEX_MODE == 2) ? 0.6*n+vec3(0.4)            // normal\n            : (TEX_MODE == 3) ? h2rgb(obj_id/float(PS_f))  // dodeca_cell_id\n            : vec3(0.8);\n        \n        // uv-grid (TODO: not orthogonal!)\n        if(TEX_UV_ON) {\n            mat_uv *= PI*TEX_UV_SUBDIV;\n            col *= 0.5+ 0.5*smoothstep(-TEX_UV_SHARPNESS,TEX_UV_SHARPNESS, sin(mat_uv.x)*sin(mat_uv.y) );\n        }        \n        // lighting\n        // point_light\n        vec3 point_lo = vec3(0, -10000, 0);\n        vec3 point_ld = normalize(point_lo - p);\n        // cubemap light\n        #ifdef BG_CUBEMAP\n        vec3 col_spe = srgb2rgb(texture(iChannel0, reflect(rd, n)).rgb);\n        #endif\n        // Phong: ambient- diffuse- specular- light reflections\n        #ifdef BG_CUBEMAP        \n        col = 0.25  * col * col_sky\n            + 0.5   * col * col_sky * col_spe\n            + 0.125 * col * col_sun * clamp(dot(point_ld, n), 0., 1.)\n            + 0.125 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n        // fresnel\n        col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * bg_col;\n        #else\n        col = 0.5  * col\n            + 0.25 * col * col_sun * clamp(dot(point_ld, n), 0., 1.)\n            + 0.25 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n        #endif\n\n    }\n    // fog\n    if(FOG_ON) col = mix(col, bg_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));\n    // gamma correction\n    fragColor = vec4(rgb2srgb(col),1.);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float PI_2 = PI/2.;\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  /* (z*e^ia)^p-x0 */\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cDodecaPolyArc2disk(vec2 z){\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 25; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2(-0.8260, - 0.5637)\n    ,vec2( 0.8091, + 0.5877)\n    ,vec2(-0.3090, - 0.9511)\n    ,vec2(-0.3089, - 0.9511)\n    ,vec2( 0.8089, - 0.5879)\n    ,vec2(-1.0000, + 0.0000)\n    ,vec2(-1.0000, + 0.0001)\n    ,vec2(-0.3090, + 0.9511)\n    ,vec2(-0.3089, + 0.9511)\n    ,vec2( 0.9996, - 0.0294)\n    ,vec2( 0.9103, + 0.4140)\n    ,vec2( 0.2242, + 0.9746)\n    ,vec2( 0.3369, - 0.9415)\n    ,vec2(-0.8576, + 0.5143)\n    ,vec2(-0.4307, - 0.9025)\n    ,vec2(-0.3567, + 0.9342)\n    ,vec2(-0.9988, - 0.0485)\n    ,vec2( 0.7796, + 0.6263)\n    ,vec2( 0.7796, - 0.6263)\n    ,vec2(-0.2828, - 0.9592)\n    ,vec2(-0.3161, + 0.9487)\n    ,vec2(-1.0000, + 0.0075)\n    ,vec2(-0.2187, + 0.9758)\n    ,vec2( 0.8366, - 0.5479)\n    ,vec2( 0.8134, + 0.5817));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2(-0.1213, - 0.0   )\n    ,vec2( 0.0028, + 0.0187)\n    ,vec2( 0.0000, - 0.0000)\n    ,vec2(-0.0010, + 0.0008)\n    ,vec2(-0.0017, - 0.0008)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2(-0.0041, - 0.0007)\n    ,vec2(-0.0000, - 0.0000)\n    ,vec2( 0.0219, - 0.0012)\n    ,vec2(-0.2767, - 0.2629)\n    ,vec2( 0.2548, - 0.3937)\n    ,vec2( 0.4733, + 0.0936)\n    ,vec2(-0.0954, - 0.0232)\n    ,vec2(-0.1703, + 0.0600)\n    ,vec2(-0.0347, - 0.0277)\n    ,vec2(-0.3617, + 0.0048)\n    ,vec2(-0.0493, + 0.0086)\n    ,vec2( 0.1573, + 0.1009)\n    ,vec2(-0.0406, - 0.0040)\n    ,vec2(-0.0118, - 0.0116)\n    ,vec2( 0.0485, + 0.1712)\n    ,vec2(-0.0014, + 0.0204)\n    ,vec2( 0.1498, + 0.3189)\n    ,vec2(-0.0419, - 0.0255)\n    ,vec2( 0.1042, - 0.0471));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2(-0.2339, - 0.1614)\n    ,vec2( 0.2737, + 0.1982)\n    ,vec2(-0.1045, - 0.3217)\n    ,vec2(-0.1039, - 0.3216)\n    ,vec2( 0.2731, - 0.1991)\n    ,vec2(-0.3383, + 0.0   )\n    ,vec2(-0.3379, + 0.0006)\n    ,vec2(-0.1045, + 0.3217)\n    ,vec2(-0.1039, + 0.3216)\n    ,vec2( 0.2841, - 0.0069)\n    ,vec2( 0.2810, + 0.1078)\n    ,vec2( 0.0682, + 0.2764)\n    ,vec2( 0.0943, - 0.2680)\n    ,vec2(-0.2418, + 0.1502)\n    ,vec2(-0.1496, - 0.2698)\n    ,vec2(-0.1287, + 0.2944)\n    ,vec2(-0.3202, - 0.0306)\n    ,vec2( 0.2411, + 0.2130)\n    ,vec2( 0.2411, - 0.2130)\n    ,vec2(-0.0808, - 0.3165)\n    ,vec2(-0.1114, + 0.3141)\n    ,vec2(-0.3331, + 0.0088)\n    ,vec2(-0.0510, + 0.3095)\n    ,vec2( 0.2770, - 0.1635)\n    ,vec2( 0.2747, + 0.1886));\n    \n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);\n}\n\n/// 4D transformation\nvec3 rot4Dz(in vec3 p, in float t, in float r_inv) {\n    float a = 2.*PI*t;    \n    p /= r_inv;\n    float rn = length(p);\n    float rn2 = dot(rn,rn);\n    vec2 zw = cmul(vec2(2.*p.z, rn2-1.),vec2(cos(a),sin(a)));\n    p = vec3(2.*p.xy,zw.x)/(rn2+1.-zw.y);   \n    return r_inv * p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 dodeca_cells(in vec3 p, out float cell_id, out float sr) {\n\t//// dodecaeder\n\tconst float gr0 = (1.+sqrt(5.))/2.; const float gr1 = 1./gr0; const float gr2 = gr0-gr1;\n\t// cell-wall-face-normals\n\tbool nx = dot(vec3( 1., 0., 0.),p)>=0.;\n\tbool ny = dot(vec3( 0., 1., 0.),p)>=0.;\n\tbool nz = dot(vec3( 0., 0., 1.),p)>=0.;\n\t//\n\tbool n0A = dot(vec3( gr2,-gr0, gr1),p)>=0.;\n\tbool n0B = dot(vec3( gr1, gr2,-gr0),p)>=0.;\n\tbool n0C = dot(vec3(-gr0, gr1, gr2),p)>=0.;\n\t//\n\tbool n1A = dot(vec3(-gr2,-gr0,-gr1),p)>=0.;\n\tbool n1B = dot(vec3(-gr1, gr2, gr0),p)>=0.;\n\tbool n1C = dot(vec3( gr0, gr1,-gr2),p)>=0.;\n\t//\n\tbool n2A = dot(vec3(-gr2, gr0, gr1),p)>=0.;\n\tbool n2B = dot(vec3(-gr1,-gr2,-gr0),p)>=0.;\n\tbool n2C = dot(vec3( gr0,-gr1, gr2),p)>=0.;\n\t//\n\tbool n3A = dot(vec3( gr2, gr0,-gr1),p)>=0.;\n\tbool n3B = dot(vec3( gr1,-gr2, gr0),p)>=0.;\n\tbool n3C = dot(vec3(-gr0,-gr1,-gr2),p)>=0.;\n\n\t// cells\n    float a = PI_2-atan((sqrt(5.)-1.)/2.);\n    float b = PI/10.; // 18°\n    float a_x = 0.; float a_y = 0.; float a_z = 0.;\n\t// ---------------------------------------------------------------\n\t//Fpxpy\n    if(ny && !n2B && n2C && !n0C && n0B)\t\n\t{\n\t\tcell_id = 0.;\n\t\ta_y = PI_2;\n        a_x = a-PI_2;\n\t\ta_z = b;\n\t}\n\t//Fnxny\n\telse if(!ny && n2B && !n2C && n0C && !n0B)\n\t{\n\t\tcell_id = 1.;\n\t\ta_y = PI_2;\n        a_x = a+PI_2;\n\t\ta_z = b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpxny\n\telse if(ny && n1B && !n1C && n3C && !n3B)\n\t{\n\t\tcell_id = 2.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a-PI_2;\n\t\ta_z =  b;\n\t}\n\t//Fnxpy\n\telse if(!ny && !n1B && n1C && !n3C && n3B)\n\t{\n\t\tcell_id = 3.;\n\t\ta_y = -PI_2;\n\t\ta_x =  a+PI_2;\n\t\ta_z =  b;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpypz\n\telse if(!nz && n3C && !n3A && n0A && !n0C)\n\t{\n\t\tcell_id = 4.;\n\t\ta_y =  0.;\n        a_x =  a;\n\t\ta_z =  b;\n\t}\n\t//Fnynz\n\telse if(nz && !n3C && n3A && !n0A && n0C)\n\t{\n\t\tcell_id = 5.;\n\t\ta_y =  0.; \n\t\ta_x =  a+PI;\n\t\ta_z =  b;\n\t}\n\n\t// ---------------------------------------------------------------\n\t//Fpynz\n\telse if(nz && n2C && !n2A && n1A && !n1C)\n\t{\n\t\tcell_id = 6.;\n\t\ta_y =  0.;\n        a_x = -a+PI;\n\t\ta_z = -b;        \n\t}\n\t//Fnypz\n\telse if(!nz && !n2C && n2A && !n1A && n1C)\n\t{\n\t\tcell_id = 7.;\n\t\ta_y =  0.;\n        a_x = -a;\n\t\ta_z = -b;       \n\t}\n\t// ---------------------------------------------------------------\n\t//Fpzpx\n\telse if(!nx && n1A && !n1B && n0B && !n0A)\n\t{\n\t\tcell_id = 8.;\n\t\ta_y =  a-PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t//Fnznx\n\telse if( nx && !n1A && n1B && !n0B && n0A)\n\t{\n\t\tcell_id = 9.;\n\t\ta_y =  a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  0.;\n\t}\n\t// ---------------------------------------------------------------\n\t//Fpznx\n\telse if(nx && n3A && !n3B && n2B && !n2A)\n\t{\n\t\tcell_id = 10.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  0.;\n\t\ta_z =  b+PI_2;\n\t}\n\t//Fnzpx\n\telse if(!nx && !n3A && n3B && !n2B && n2A )\n\t{\n\t\tcell_id = 11.;\n\t\ta_y = -a+PI_2;\n\t\ta_x =  PI;\n\t\ta_z =  b-PI_2;\n\t}\n\t// ---------------------------------------------------------------\n\t// cell orientation\n\tvec2 ei_y = vec2(cos(a_y),sin(a_y)); p.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tvec2 ei_x = vec2(cos(a_x),sin(a_x)); p.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\tvec2 ei_z = vec2(cos(a_z),sin(a_z)); p.xy = cmul(p.xy,ei_z); // rotate around z-axis\n\t// non cyclic\n\tsr = 5.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// colorspace transformations\nvec3 rgb2hsv(vec3 col) {\n    // https://en.wikipedia.org/wiki/HSL_and_HSV\n    col = clamp(col, 0., 1.); \n    //\n    float m_max = max(col.r,max(col.g,col.b));\n    float m_min = min(col.r,min(col.g,col.b));\n    float d = m_max-m_min;\n    // hue\n    float h = 0.; // if(d == 0.) undefined\n    if(m_max==col.r) {h = (col.g-col.b)/d+0.;}\n    if(m_max==col.g) {h = (col.b-col.r)/d+2.;}\n    if(m_max==col.b) {h = (col.r-col.g)/d+4.;}\n    h = fract(h/6.); // periodic in[0.,1.]\n    // value\n    float v = m_max;\n    // saturation\n    float s = (v == 0.)?0.: d/v;\n    return vec3(h,s,v);\n}\n\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldcW8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1474, 1474, 1510, 1528, 3322], [3324, 3324, 3395, 3395, 4318], [4320, 4320, 4365, 4365, 4575], [4577, 4577, 4619, 4645, 4809], [4811, 4811, 4866, 4888, 8889]], "test": "untested"}
{"id": "cldyWH", "name": "Cosinus Magic", "author": "fadedave", "description": "Dragging from the middle of the screen outwards zooms out the 'universe'\n( on mobile, you have to tap, instead of dragging )", "tags": ["geometry"], "likes": 0, "viewed": 77, "published": 3, "date": "1699160595", "time_retrieved": "2024-07-30T17:24:00.498942", "image_code": "void mainImage( out vec4 pcol, in vec2 pcoord )\n{\n    vec2 uv = pcoord/iResolution.xy-0.5;\n    vec2 um = abs(iMouse.xy/iResolution.xy-0.5);\n    vec3 col;\n    \n    col = 0.05 + 0.2*cos(iTime+uv.xyx+vec3(0,2,4));\n    //if (cos(0.37*uv.x*uv.y*200.+iTime*1.3)>0.9) {\n    if ( cos(0.37*uv.x*1000.*pow(10.0,(um.x*um.y*40.))*uv.y+iTime*1.3) >0.9 ) {\n    col = uv.yyx+vec3(0.8,0.5,0.5)+0.2;\n    }\n    pcol = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 416]], "test": "untested"}
{"id": "cttyDH", "name": "Biome Generator / Biome Boundary", "author": "kp1197", "description": "Generates an infinite map with 5 distinct biomes", "tags": ["procedural"], "likes": 4, "viewed": 127, "published": 3, "date": "1699148390", "time_retrieved": "2024-07-30T17:24:01.380584", "image_code": "#define ANIMATE vec2(iTime/3.,0.)\n\nconst float ZOOM = 10.;\nconst float WORLD_SCALE = 8000.;\n\n// concentration parameter - higher value results in less material 'bleeding'\n// if your weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float K = 20.;\n\n// if weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float NULL_WEIGHT = 10.;\n\n\n\n///  2 out, 2 in...\nvec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat simplex_noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\n\nconst mat2 mtx = mat2( vec2(0.80,  0.60), vec2(-0.60,  0.80 ));\n\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\tf += simplex_noise(p); \n\tp = mtx*p*1.99;\n\tf += 0.50000*simplex_noise(p ); \n\tp = mtx*p*1.99;\n\tf += 0.25000*simplex_noise(p  ); \n\tp = mtx*p*1.99;\n\tf += 0.125000*simplex_noise(p); \n\tp = mtx*p*1.99;\n\tf += 0.062500*simplex_noise(p); \n\tp = mtx*p*1.99;\t\n\treturn f / 0.9375;\n}\n\nfloat clamp_fbm(float value) {\n\treturn smoothstep(0.2, 0.6, value);\n}\n\nfloat adventure_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm( p ));\n}\n\nfloat danger_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm((p + vec2(1000.))));\n}\n\nfloat deadly_zoneness(vec2 p) {\n\treturn clamp_fbm(fbm((p + vec2(2000.))  ));\n}\n\nfloat abyss_zoneness(vec2 p) {\n\treturn  clamp_fbm(fbm((p + vec2(3000.))  ));\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4_(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D, vec3 NULL) {\n\tfloat softmaxDenominator = exp(K * materials.x) + \n        exp(K * materials.y) + \n        exp(K * materials.z) + \n        exp(K * materials.w) + \n        exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    return sm_a * A + sm_b * B + sm_c * C + sm_d * D + sm_null * NULL;\n}\n\nvec3 softmaxmix_4(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D) {\n\tvec4 softmaxed_materials = exp(K * materials) / dot(exp(K * materials), vec4(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C + softmaxed_materials.w * D;\n}\n\nfloat indecision_4_(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tfloat softmaxDenominator = exp(K * materials.x) + exp(K * materials.y) + exp(K * materials.z) + exp(K * materials.w) + exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = (sm_a * log(sm_a) +\n\t\t\t\t\t sm_b * log(sm_b) +\n\t\t\t\t\t sm_c * log(sm_c) +\n\t\t\t\t\t sm_d * log(sm_d) +\n\t\t\t\t\t sm_null * log(sm_null)) / log(1./5.);\n    return normalized_entropy;\n}\n\nvec2 to_world(vec2 a) {\n    vec2 world_uv  = ( vec4(a.x, a.y, 0., 1.)).xy; \n\tvec2 p = ZOOM * world_uv / WORLD_SCALE;// + vec2(iTime/10.,0.);\n    return p;\n}\n\nfloat surf_highlights(vec2 p) {\n    return dot(hash(p), hash(p + 100.));\n}\n\nvec3 SPHERE_CENTER = vec3(0.0,0.0,4.0);\nfloat SPHERE_RADIUS = 1.0;\n\nfloat sphereDist(vec3 p) {\n    return length(p - SPHERE_CENTER) - SPHERE_RADIUS;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    vec2 screen_uv = fragCoord / iResolution.xx - 0.5*vec2(1.,iResolution.y/iResolution.x);\n    vec3 ray = normalize(vec3(screen_uv, 1.));\n    vec2 p = screen_uv + ANIMATE;\n\n\t// zones\n\tfloat a = (adventure_zoneness(p));\n\tfloat b = (danger_zoneness(p));\n\tfloat c = (deadly_zoneness(p));\n\tfloat d = (abyss_zoneness(p));\n    \n    // value of current zone\n    float level = softmaxmix_4(vec4(a,b,c,d), vec3(a), vec3(b), vec3(c), vec3(d)).x;\n    \n    // lighting\n    float dLdx = dFdx(level);\n    float dLdy = dFdy(level);\n    vec3 normal = normalize(vec3(dLdx, dLdy,1.));\n    vec3 lightDir = normalize(vec3(0.9,0.5,1.));\n    float lighting = pow(abs(dot(normal,lightDir)),2.);\n    \n\n    vec2 warped_p = p.xy*5. + 0.25 * simplex_noise(p.xy);\n\tfloat coast_highlight = level + 1.5;\n\tvec3 water = coast_highlight*hsv2rgb(vec3(0.6, 1., 0.5)); //vec3(120,180,120)/255.0;\n\tvec3 a_color = 0.6 * lighting + 0.4 * texture(iChannel0, warped_p).rgb;//hsv2rgb(vec3(0.4, 1., 0.5)); //vec3(68,188,216)/255.0;\n\tvec3 b_color = 0.6 * lighting + 0.4 * vec3(1.5,1.5,0.6) * texture(iChannel1, warped_p).rgb;//hsv2rgb(vec3(0.6, 1., 0.5));//vec3(24,116,165)/255.0;\n\tvec3 c_color = 0.6 * lighting + 0.4 * texture(iChannel2, warped_p).rgb;//hsv2rgb(vec3(0.8, 1., 0.5)); //vec3(101,36,23)/255.0;\n\tvec3 d_color = 0.6 * lighting + 0.4 * vec3(0.6,1.5,0.6) * texture(iChannel3, warped_p).rgb;//hsv2rgb(vec3(0.9, 0.5, 0.5)); //vec3(0.)/255.0;\n\t\n\t// zone base color for viz\n\tvec3 color = softmaxmix_4_(vec4(a, b, c, d), a_color, b_color, c_color, d_color, water);\n\t\n\tfloat borders = abs(indecision_4_(vec4(a, b, c, d)));\n    \n    vec3 base_color = mix(color, d_color, borders);\n    vec3 tinted_color =  base_color * vec3(1.5,0.8,0.5);\n    \n    fragColor.rgb = pow(tinted_color, vec3(0.8));\n\n    \n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 386, 405, 405, 539], [541, 541, 575, 575, 1054], [1124, 1124, 1145, 1145, 1434], [1436, 1436, 1466, 1466, 1505], [1507, 1507, 1541, 1541, 1572], [1574, 1574, 1605, 1605, 1650], [1652, 1652, 1683, 1683, 1730], [1732, 1732, 1762, 1762, 1810], [1812, 1853, 1880, 1880, 2006], [2009, 2124, 2203, 2203, 2734], [2736, 2736, 2803, 2803, 3011], [3013, 3013, 3050, 3137, 3820], [3822, 3822, 3845, 3845, 3978], [3980, 3980, 4011, 4011, 4054], [4124, 4124, 4150, 4150, 4206], [4209, 4209, 4266, 4266, 6034]], "test": "untested"}
{"id": "cltyWH", "name": "SoftMax-based Blending/Mixing", "author": "kp1197", "description": "Need an N-element analogue of \"mix\"?  Or, a soft version of \"max\"?  Here's softmaxmix! 2, 3, and 4 dimensional impls included. Alt. impls with handling of all-zero weights. indecision measures how \"confused\" softmaxmix is (click to viz)", "tags": ["blending", "entropy", "mixing", "softmax"], "likes": 3, "viewed": 127, "published": 3, "date": "1699142159", "time_retrieved": "2024-07-30T17:24:02.153518", "image_code": "// visualization colors\n#define A_ texture(iChannel0, p).rgb\n#define B_ texture(iChannel1, p).rgb\n#define C_ texture(iChannel2, p).rgb\n#define D_ texture(iChannel3, p).rgb\n#define NULL_COLOR vec3(0.)\n#define PI 3.14159\n\n\n// concentration parameter - higher value results in less material 'bleeding'\n// if your weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float K = 80.;\n\n// if weights are between 0.0 and 1.0 you shouldn't need to adjust\nconst float NULL_WEIGHT = 5.;\n\n\n// mix between A and B by picking the max weight in `vec2 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_2(vec2 materials, vec3 A, vec3 B) {\n    vec2 softmaxed_materials = exp(K * materials) / dot(exp(K * materials),vec2(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B;\n}\n\n\n// implementation of softmax_mix_2 that falls back on a NULL material when all material influences are zero\nvec3 softmaxmix_2_(vec2 materials, vec3 A, vec3 B, vec3 NULL) {\n    vec3 mat_prime = vec3(K*materials.x, K*materials.y, NULL_WEIGHT);\n    vec3 softmaxed_materials = exp(mat_prime) / dot(exp(mat_prime),vec3(1.));\n    return softmaxed_materials.x * A + \n            softmaxed_materials.y * B +\n            softmaxed_materials.z * NULL;\n}\n\n// mixes between A, B and C by picking the max weight in `vec3 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_3(vec3 materials, vec3 A, vec3 B, vec3 C) {\n    vec3 softmaxed_materials = exp(K * materials) / dot(exp(K * materials),vec3(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C;\n}\n\n// implementation of softmax_mix_3 that includes a NULL material when all material influences are zero\nvec3 softmaxmix_3_(vec3 materials, vec3 A, vec3 B, vec3 C, vec3 NULL) {\n    vec4 mat_prime = vec4(K*materials.x, K*materials.y, K*materials.z, NULL_WEIGHT);\n    vec4 softmaxed_materials = exp(mat_prime) / dot(exp(mat_prime),vec4(1.));\n    return softmaxed_materials.x * A + \n            softmaxed_materials.y * B +\n            softmaxed_materials.z * C + \n            softmaxed_materials.w * NULL;\n}\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D) {\n\tvec4 softmaxed_materials = exp(K * materials) / dot(exp(K * materials), vec4(1.));\n    return softmaxed_materials.x * A + softmaxed_materials.y * B + softmaxed_materials.z * C + softmaxed_materials.w * D;\n}\n\n// mixes between A, B, C and D by picking the max weight in `vec4 materials`, but a 'soft max' instead of max(...)\nvec3 softmaxmix_4_(vec4 materials, vec3 A, vec3 B, vec3 C, vec3 D, vec3 NULL) {\n\tfloat softmaxDenominator = exp(K * materials.x) + \n        exp(K * materials.y) + \n        exp(K * materials.z) + \n        exp(K * materials.w) + \n        exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    return sm_a * A + sm_b * B + sm_c * C + sm_d * D + sm_null * NULL;\n}\n\n// returns number indicating how 'unsure' the softmax is... i.e., if two infleunces are tied.\n// can work like a boundary detector.\nfloat indecision_2(vec2 materials) {\n    // softmax to turn weights/influences into a probability distribution\n    vec2 softmaxedMaterials = exp(K * materials) / dot(exp(K * materials), vec2(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./2.);\n\treturn normalized_entropy;\n}\n\n// implementation that falls back to a 'null material' when all weights are zero\nfloat indecision_2_(vec2 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n    vec3 mat_prime = vec3(K * materials.x, K * materials.y, NULL_WEIGHT);\n    // softmax to turn weights/influences into a probability distribution\n    vec3 softmaxedMaterials = exp(mat_prime) / dot(exp(mat_prime), vec3(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./3.);\n\treturn normalized_entropy;\n}\n\n\nfloat indecision_3(vec3 materials) {\n    // softmax to turn weights/influences into a probability distribution\n    vec3 softmaxedMaterials = exp(K * materials) / dot(exp(K * materials),vec3(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./3.);\n\treturn normalized_entropy;\n}\n\n\n// implementation that falls back to a 'null material' when all weights are zero\nfloat indecision_3_(vec3 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n    vec4 mat_prime = vec4(K * materials.x, K * materials.y, K * materials.z, NULL_WEIGHT);\n    // softmax to turn weights/influences into a probability distribution\n    vec4 softmaxedMaterials = exp(mat_prime) / dot(exp(mat_prime),vec4(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxedMaterials, log(softmaxedMaterials)) / log(1./4.);\n\treturn normalized_entropy;\n}\n\n\nfloat indecision_4(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tvec4 softmaxed_materials = exp(materials) / dot(exp(materials),vec4(1.));\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = dot(softmaxed_materials, log(softmaxed_materials)) / log(1./4.);\n    return normalized_entropy;\n}\n\nfloat indecision_4_(vec4 materials) {\n    // augment list of materials with the null material (meaning no material assigned)\n\tfloat softmaxDenominator = exp(K * materials.x) + exp(K * materials.y) + exp(K * materials.z) + exp(K * materials.w) + exp(NULL_WEIGHT);\n\tfloat sm_a = exp(K * materials.x) / softmaxDenominator;\n\tfloat sm_b = exp(K * materials.y) / softmaxDenominator;\n\tfloat sm_c = exp(K * materials.z) / softmaxDenominator;\n\tfloat sm_d = exp(K * materials.w) / softmaxDenominator;\n\tfloat sm_null = exp(NULL_WEIGHT) / softmaxDenominator;\n    // normalized entropy: -sum_N(p * log(p)) / -log(1/N)\n    float normalized_entropy = (sm_a * log(sm_a) +\n\t\t\t\t\t sm_b * log(sm_b) +\n\t\t\t\t\t sm_c * log(sm_c) +\n\t\t\t\t\t sm_d * log(sm_d) +\n\t\t\t\t\t sm_null * log(sm_null)) / log(1./5.);\n    return normalized_entropy;\n}\n\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat circle_a(vec2 p) {\n    float animate = 0.1 * abs(sin(iTime));\n\treturn smoothstep(-0.3, 0., -length(p - vec2(-0.15, -0.15) ));\n}\n\nfloat circle_b(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.0, 0.15) ));\n}\n\nfloat circle_c(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.15, -0.15) ));\n}\n\nfloat circle_d(vec2 p) {\n\treturn smoothstep(-0.3, 0., -length(p - vec2(0.0, 0.30)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\tvec2 p  = 2. * (fragCoord.xy/iResolution.xx - 0.5 * vec2(1.,iResolution.y/iResolution.x));\n\t\n\t// circles\n\tfloat a = 0.5*(circle_a(p));\n\tfloat b = 0.5*(circle_b(p));\n\tfloat c = 0.5*(circle_c(p));\n    float d = 0.5*(circle_d(p));\n\n    \n    // softmax blend\n    vec3 blend = softmaxmix_3_(vec3(a,b,c),A_,B_,C_,NULL_COLOR);\n    \n    // indecision / softmax boundaries\n    vec3 boundary = vec3(indecision_3_(vec3(a,b,c)));\n    \n    float swipe = mix(sin(iTime), 2.*(iMouse.x/iResolution.x - 0.5), float(iMouse.z > 0.));\n    \n    vec3 scene = mix(blend, boundary, smoothstep(swipe-0.05, swipe+0.05, p.x));\n    fragColor.rgb = scene;\n    fragColor.rgb += smoothstep(-0.01,0.0,-abs(p.x-swipe));\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 599, 650, 650, 804], [807, 915, 978, 978, 1250], [1252, 1364, 1423, 1423, 1605], [1607, 1710, 1781, 1781, 2109], [2111, 2226, 2293, 2293, 2501], [2503, 2618, 2697, 2697, 3228], [3230, 3362, 3398, 3472, 3740], [3742, 3823, 3860, 3947, 4355], [4358, 4358, 4394, 4468, 4735], [4738, 4819, 4856, 4943, 5367], [5370, 5370, 5406, 5493, 5755], [5757, 5757, 5794, 5881, 6564], [6567, 6608, 6635, 6635, 6761], [6763, 6763, 6787, 6787, 6896], [6898, 6898, 6922, 6922, 6985], [6987, 6987, 7011, 7011, 7076], [7078, 7078, 7102, 7102, 7164], [7167, 7167, 7222, 7222, 7914]], "test": "untested"}
{"id": "DtccDr", "name": "Mand'brot", "author": "domrally", "description": "Escapes & Traps.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "mandelbrot", "orbit", "trap", "escape", "short"], "likes": 8, "viewed": 194, "published": 3, "date": "1699108781", "time_retrieved": "2024-07-30T17:24:03.086024", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    // layout\n    uv = 3. * (2. * uv - iResolution.xy) / iResolution.x;\n    uv.x += .6;\n    mat2 orbit, trap, shift = mat2(uv, -uv.y, uv);\n\n    // animation\n    float t = .5 + .5 * sin(iTime);\n    shift = trap = t * shift + (1. - t) * inverse(shift);\n\n    // fractal\n    float escape, orbitSize, trapSize = 9.;\n    for (; ++escape < 99.;) {\n        orbit = orbit * orbit + shift;\n\n        if (4. < (orbitSize = determinant(orbit))) break;\n        if (orbitSize < trapSize) trap = orbit, trapSize = orbitSize;\n\n    }\n\n    // orbit trap\n    float hue = iTime + atan(trap[0].y, trap[0].x);\n    trapSize = smoothstep(-.02, .15, trapSize);\n\n    // palette\n    vec3 color = 1. + vec3(.8, .3, .9) * cos(vec3(hue - 2.1, hue, hue + 2.1));\n    color *= mix(escape / 15., trapSize, step(99., escape));\n\n    // gamma\n    pixel.rgb = pow(color, vec3(1) / 2.2);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtccDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 68, 82, 918]], "test": "untested"}
{"id": "dttcDr", "name": "Focus closely", "author": "scry", "description": "its a little slow tbh :P", "tags": ["2d", "psychedelic", "trippy", "replication"], "likes": 14, "viewed": 242, "published": 3, "date": "1699099050", "time_retrieved": "2024-07-30T17:24:03.953705", "image_code": "////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n#define R iResolution.xy\n#define ar R.x/R.y\nvec3 cs = vec3(1.,2.,3.);\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n    #if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n    #else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n    #endif    \n}\nvec3 t1(vec2 uv, float t, float v) {\n    vec3 col = vec3(0.);\n    float c = length(uv);\n    \n    uv = vec2(log(length(uv)),atan(uv.x,uv.y));\n    //uv.x *= sin(time*0.1);\n    //uv.x += time*8.;\n    //uv.x *= sin(-time*0.1)*0.1+0.5;\n    //uv.x -= t*-0.2+time*0.1;\n    uv.x += v*-2.;\n    uv.x *= 0.3;\n    //uv.x += time10.5;\n    //uv.y += -time*10.;\n    uv.x += uv.y*0.0795;\n    float sx = floor(uv.x*2.)/pi+2.+fract((uv.y/pi/2.+0.5))*-0.3183;\n    //uv.x += sin(uv.y*80.)*0.1;\n    uv.x = (fract(uv.x*2.)-0.5)/2.;\n    //\n    //uv.x *= 0.5;\n    \n    float s = (min(abs(uv.x-sin(uv.y*8.)*0.1),abs(uv.x+sin(uv.y*8.)*0.1)));\n    //s = min(s,abs(-abs(uv.x)+0.1));\n    //s = min(s,abs(-abs(uv.x)+0.2));\n    //s = min(s,(min(abs((abs(uv.x)-0.15)-sin(uv.y*8.)*0.05),abs((abs(uv.x)-0.15)+cos(uv.y*8.)*0.05))));\n    //s += 0.1;\n    col -= (smoothstep(0.01,0.,abs(uv.x-0.25))+smoothstep(0.01,0.,abs(uv.x+0.25)))*0.02;\n    col -= fcos(uv.xxx*190.+t*25.)*0.1;\n    \n    //col += sin(sx*2.);\n    col += fcos(sx*28.+t+cs*0.2+t*8.)*0.12;\n    col += fcos(sx*0.65*v*v+t*0.1+cs*0.8+time*2.)*0.4+0.6;\n    //col += sin(cs+s*200.+sx*10.+t*10.)*0.5;\n    //col += smoothstep(0.002+pow((1-c),5.)*0.02,0.,s)*(c*0.5+0.5);\n    col = clamp(col,-0.,1.);\n    return col;\n}\n\nvec3 t2(vec2 uv, float t) {\n    vec3 col = vec3(0.);\n    float c = length(uv);\n    uv = uv/dot(uv,uv);\n    uv *= 0.002;\n    uv *= 30.;\n    //uv.xy *= pow(time*0.3,2.)+1.;\n    uv = (fract(uv*12.-0.5)-0.5)/12.;\n    uv = abs(uv)-0.024;\n    uv *= r2d(time*-12.);\n    col = t1(uv,t,log(c)*0.8)*0.7;\n    col = clamp(col,0.,1.);\n    col = mix(col,vec3(0.5),log(1.-c)*0.);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    uv *= 0.6;\n    vec3 col = vec3(0.);\n    float c = length(uv);\n    for (int j=0;j<4;j++) {\n    float jj = float(j+1);\n    vec2 ov = uv;\n    uv *= 1.+sin(time+jj+c+sin(uv.x*8.-time)+sin(uv.y*8.+time))*0.06;\n    uv *= r2d(sin(time+jj+c*2.)*deg*4.);\n    //uv = abs(uv)-0.25;\n    for (int i=0;i<12;i++) {\n        float ii = float(i);\n        float aa = fract(ii/48.+jj/3.+time+c*1.5);\n        float sa = abs(aa-0.5)*2.;\n        uv *= 1.+sin(time+jj+c+cos(uv.x*8.-time)+cos(uv.y*8.+time))*0.0005;\n        vec3 nl = t2(uv,time-ii*pi)*sa*0.03*(sin(jj*pi+time)*0.5+0.5);\n        //col += (sin(nl*12.+atan(uv.x,uv.y)+time));\n        col += nl+sin(col*8.+nl*12.+sin(atan(uv.x,uv.y))+time+c*2.)*0.002;\n        //col += floor(nl*128.)/68.;\n        uv += vec2(sin(time+c*5.*sa+sa+cos(uv.x*18.+time)+jj),cos(time+c*8.*sa+sa+sin(uv.y*18.+time*0.4)))*0.0013*sa*sin(c*1.2+time+jj*2.)*jj;\n        \n    }\n    ov *= 0.95;\n    uv = ov;\n    }\n    //col -= 0.12;\n    col *= 3.;\n    col += 0.2;\n    //col = sin(col*12.+time+atan(uv.x,uv.y)+c*8.)*0.5+0.5;\n   // col -= 0.44;\n   // col *= 4.9;\n    col = pow(col,vec3(2./1.2));\n    //col -= sin(col*8.+time)*0.5+0.5;\n    // (sin(col+time)*0.75+0.25)+sin(col-1.2)*0.;\n    \n    //col = sin(cs+col*8.+time)*0.5+0.5;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 237, 237, 286], [287, 308, 332, 332, 504], [505, 505, 541, 541, 1741], [1743, 1743, 1770, 1770, 2125], [2127, 2127, 2182, 2182, 3553]], "test": "untested"}
{"id": "dldyDr", "name": "Mandelbrot coloreado", "author": "EnriqueDreams", "description": "Un mandelbrot coloreado, el zoom es el eje x del ratón", "tags": ["mandelbrot"], "likes": 2, "viewed": 130, "published": 3, "date": "1699098441", "time_retrieved": "2024-07-30T17:24:04.837342", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    float zoom = pow(10., -m.x*3.);\n    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 c = uv * zoom * 3.;\n    \n    c += vec2(- .69955, .37999);\n    \n    vec2 z = vec2(0.);\n    \n    float iter = 0.;\n    \n    const float max_iter = 500.;\n    \n    for(float i = 0.; i < max_iter; i++){\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n        \n        if(length(z) > 2.) break;\n        iter++;\n    }\n    \n    float t = iter / 500.;\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c1 = vec3(1.0,1.0,10.);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    \n    vec3 col;\n    if(length(z)>2.)\n    {\n        col = a + b*cos( 6.28318*(c1*t+d) );\n    }\n    else\n        col = vec3(0.);\n    \n    // Output to screen\n    fragColor = vec4(col,0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 905]], "test": "untested"}
{"id": "dltyWr", "name": "Dawn at a distant world II", "author": "mrange", "description": "License CC0: Dawn at a distant world II\nA few years ago I did \"Dawn at a distant world\"\nThe height field is still good I think but the old shader had lots of aliasing.\nTried to fix some of them", "tags": ["terrain", "fbm"], "likes": 49, "viewed": 586, "published": 3, "date": "1699092357", "time_retrieved": "2024-07-30T17:24:05.692057", "image_code": "// License CC0: Dawn at a distant world [REMASTERED]\n//  A few years ago I did \"Dawn at a distant world\"\n//  The height field is still good I think but the old shader had \n//  lots of aliasing.\n//  I learnt a few tricks since that time though and applied some of them\n//  I think it improved the shader a fair bit even though some aliasing remains\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  fragColor = texture(iChannel1, q);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35170, "src": "https://soundcloud.com/mikeoldfieldofficial/mike-oldfield-let-there-be?in=user-837937811/sets/mike-oldfield-official&si=99bd68bdd3d843ff9260ff7e75ffa886&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// License CC0: Dawn at a distant world [REMASTERED]\n//  A few years ago I did \"Dawn at a distant world\"\n//  The height field is still good I think but the old shader had \n//  lots of aliasing.\n//  I learnt a few tricks since that time though and applied some of them\n//  I think it improved the shader a fair bit even though some aliasing remains\n\n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TOLERANCE       1E-3\n#define MAX_ITER        40\n#define MIN_DISTANCE    0.01\n#define MAX_DISTANCE    9.0\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3  skyCol1       = vec3(0.35, 0.45, 0.6);\nconst vec3  skyCol2       = vec3(0.0);\nconst vec3  skyCol3       = pow(skyCol1, vec3(0.25));\nconst vec3  sunCol1       = vec3(1.0,0.6,0.4);\nconst vec3  sunCol2       = vec3(1.0,0.9,0.7);\nconst vec3  smallSunCol1  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  smallSunCol2  = vec3(1.0,0.5,0.25)*0.5;\nconst vec3  mountainColor = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet        = vec4(80.0, -20.0, 100.0, 50.0)*1000.0;\nconst vec3  ringsNormal   = normalize(vec3(1.0, 1.25, 0.0));\nconst vec4  rings         = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 center = sphere.xyz;\n  float radius = sphere.w;\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nfloat noise1(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n  \n  const float r = 0.225;\n \n  float d = circle(p, 2.0*r);\n  \n  float h = hh.x*smoothstep(0.0, r, -d);\n\n  return h*0.25;\n}\n\nfloat noise2(vec2 p) {\n  vec2 n = mod2_1(p);\n  vec2 hh = hash(sqrt(2.0)*(n+1000.0));\n  hh.x *= hh.y;\n\n  p *= ROT(TAU*hh.y);\n  const float r = 0.45;\n \n  float d = egg(p, 0.75*r, 0.5*r*abs(hh.y));\n  \n  float h = -abs(hh.x)*(smoothstep(0.0, r, -2.0*d)-0.3*smoothstep(0.0, 0.2*r, -d));\n\n  return h*0.275;\n}\n\nfloat height(vec2 p, int mx) {\n  const float aa   = 0.45;\n  const float oo   = 3.93;\n  const float near = 0.25;\n  const float far  = 0.65;\n  const mat2 pp   = 2.03*ROT(1.2);\n  \n  float a = 1.0;\n  float o = 0.2;\n  float s = 0.075*sin(p.x+p.y);\n  float d = 0.0;\n  \n  int i = 0;\n  for (; i < 4;++i) {\n    float nn = a*noise2(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    p *= pp;\n    o *= oo;\n  }\n\n  \n  for (; i < mx; ++i) {\n    float nn = a*noise1(p);\n    s += nn;\n    d += abs(a);\n    p += o;\n    a *= aa;\n    o *= oo;\n    p *= pp;\n  }\n \n\n  float hid = (s/d);\n  \n  return hid;\n}\n\nfloat height(vec2 p) {\n  return height(p, 6);\n}\n\nfloat hiheight(vec2 p) {\n  return height(p, 8);\n}\n  \nvec3 normal(vec2 p, float aa) {\n  vec2 eps = vec2(aa, 0.0);\n  \n  vec3 n;\n  \n  n.x = (hiheight(p - eps.xy) - hiheight(p + eps.xy));\n  n.y = 2.0*eps.x;\n  n.z = (hiheight(p - eps.yx) - hiheight(p + eps.yx));\n  \n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float id, out int max_iter) {\n  float dt = 0.1;\n  float d = id;\n  for (int i = 0; i < MAX_ITER; ++i) {\n    vec3 p = ro + d*rd;\n    float h = height(p.xz);\n    if (d > MAX_DISTANCE) {\n      max_iter = i;\n      return MAX_DISTANCE;\n    }\n    float hd = p.y - h;\n    if (hd < TOLERANCE) {\n      max_iter = i;\n      return d;\n    }\n    dt = max(hd, TOLERANCE);\n    d += dt;\n  }\n  \n  max_iter = MAX_ITER;\n  return d;\n}\n\nvec3 sunDirection() {\n  return normalize(vec3(-0.5, 0.085, 1.0));\n}\n\nvec3 smallSunDirection() {\n  return normalize(vec3(-0.2, -0.05, 1.0));\n}\n\nvec3 rocketDirection() {\n  return normalize(vec3(0.0, -0.2+mod(iTime, 90.0)*0.0125, 1.0));\n}\n\nfloat psin(float f) {\n  return 0.5 + 0.5*sin(f);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 sunDir = sunDirection();\n  vec3 smallSunDir = smallSunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  float smallSunDot = max(dot(rd, smallSunDir), 0.0);\n  \n  float angle = atan(rd.y, length(rd.xz))*2.0/PI;\n\n  vec3 skyCol = mix(mix(skyCol1, skyCol2, smoothstep(0.0 , 1.0, 5.0*angle)), skyCol3, smoothstep(0.0, 1.0, -5.0*angle));\n  \n  vec3 sunCol = 0.5*sunCol1*pow(sunDot, 20.0) + 8.0*sunCol2*pow(sunDot, 2000.0);\n  vec3 smallSunCol = 0.5*smallSunCol1*pow(smallSunDot, 200.0) + 8.0*smallSunCol2*pow(smallSunDot, 20000.0);\n\n  vec3 dust = pow(sunCol2*mountainColor, vec3(1.75))*smoothstep(0.05, -0.1, rd.y)*0.5;\n\n  vec2 si = raySphere(ro, rd, planet);\n  float pi = rayPlane(ro, rd, rings);\n  \n  float dustTransparency = smoothstep(-0.075, 0.0, rd.y);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*vec3(0.9, 0.8, 0.7), 0.3*vec3(0.9, 0.8, 0.7), pow(psin(planetLat+1.0)*psin(sqrt(2.0)*planetLat+2.0)*psin(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  vec3 rocketDir = rocketDirection();\n  float rocketDot = max(dot(rd, rocketDir), 0.0);\n  float rocketDot2 = max(dot(normalize(rd.xz), normalize(rocketDir.xz)), 0.0);\n  vec3 rocketCol = vec3(0.25)*(3.0*smoothstep(-1.0, 1.0, psin(iTime*15.0*TAU))*pow(rocketDot, 70000.0) + smoothstep(-0.25, 0.0, rd.y - rocketDir.y)*step(rd.y, rocketDir.y)*pow(rocketDot2, 1000000.0))*dustTransparency;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(psin(ringsPeriod+1.0)*psin(sqrt(0.5)*ringsPeriod+2.0)*psin(sqrt(0.45)*ringsPeriod+4.0)*psin(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = psin(ringsPeriod*10.0)*psin(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n//  float ringsDiff = max(-dot(rings.xyz, sunDir), 0.0);\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*mountainColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*dustTransparency*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  final += skyCol + sunCol + smallSunCol + dust + rocketCol;\n\n  return final;\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 nrd) {\n  int max_iter = 0;\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0);\n  \n  float id = (0.125 - ro.y)/rd.y;\n  \n  if (id > 0.0)   {\n    float d = march(ro, rd, id, max_iter);\n    vec3 sunDir = sunDirection();\n    vec3 osunDir = sunDir*vec3(-1.0, .0, -1.0);\n    vec3 p = ro + d*rd;\n    vec3 np = ro + d*nrd;\n    float aaf = smoothstep(0.0, 0.45, -rd.y);\n    float aa = sqrt(8.0)*distance(np, p)/max(aaf, 1E-3);\n    vec3 normal = normal(p.xz, aa);\n    \n    float amb = 0.2;\n\n    float dif1 = max(0.0, dot(sunDir, normal));\n    vec3 shd1 = sunCol2*mix(amb, 1.0, pow(dif1, 0.75));\n\n    float dif2 = max(0.0, dot(osunDir, normal));\n    vec3 shd2 = sunCol1*mix(amb, 1.0, pow(dif2, 0.75));\n\n    vec3 ref = reflect(rd, normal);\n    vec3 rcol = skyColor(p, ref);\n\n    col = mountainColor*amb*skyCol3;\n    col += mix(shd1, shd2, -0.5)*mountainColor;   \n    float fre = 1.0+dot(normal, rd);\n    fre *= fre;\n    fre *= fre;\n    col += rcol*fre*0.5;\n    col += p.y;\n    col = tanh(col);\n    //col.x += 1.0-aaf;\n    col = mix(col, skyCol, smoothstep(0.5*MAX_DISTANCE, 1.*MAX_DISTANCE, d));\n  } else {\n    col = skyCol;\n  }\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec2 np = p+1.0/iResolution.y;\n  float off = 0.5*iTime;\n\n  vec3 ro  = vec3(0.5, 1.0-0.25, -2.0 + off);\n  vec3 la  = ro + vec3(0.0, -0.00,  2.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + 2.0*ww);\n\n  vec3 col = getColor(ro, rd, nrd);\n\n  float f = sqrt(max(iTime-length(p+vec2(0.0, 1.0)), 0.0));\n  col *= smoothstep(0.25, 4.0, f);\n\n  return col;\n  \n}\nconst vec3  luma        = vec3(0.299, 0.587, 0.114);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  \n  vec3 col = effect(p);\n\n  const int c = 2;\n  vec2 AA = 3.0/iResolution.xy;\n  vec2 start = q-float(c)*AA;\n  vec3 bcol = vec3(0); \n  for (int y = -c; y <= c; ++y) {\n    vec2 pp = start;\n    for (int x = -c; x <= c; ++x) {\n      vec3 fcol = texture(iChannel0, pp).xyz;\n      bcol += fcol;\n      pp.x += AA.x;\n    }\n\n    start.y += AA.y;\n  }\n  \n  bcol /= float((2*c+1)*(2*c+1));\n  bcol = clamp(bcol, 0.0, 10.0);\n  vec4 pcol = texture(iChannel0, q);\n  float blum = min(min(pcol.x, pcol.y), pcol.z);\n  float bm = 0.5*smoothstep(0.5, 0.85, blum);\n  col = mix(col, 1.05*bcol, bm);\n\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltyWr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[349, 349, 401, 401, 480]], "test": "untested"}
{"id": "DdKBDd", "name": "Dark Matter II", "author": "ElSolem", "description": "https://www.shadertoy.com/view/7ltyDN", "tags": ["simple", "parallax", "fun", "polyrefraction", "biconvex", "biconcave"], "likes": 0, "viewed": 153, "published": 3, "date": "1699069662", "time_retrieved": "2024-07-30T17:24:06.587662", "image_code": "//Adopted from https://www.shadertoy.com/view/tsXBzS Fractal Pyramid, by bradjamesgrant\n\nvec3 palette(float d){\n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;\n\treturn mix(vec3(mx,my,0.9),vec3(1.,0.,1.),d); //color of the stars\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a)*0.9;\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = float(iFrame)*0.002;\n        p.yz =rotate(p.yz,t);//rotation speed\n        p.xz =rotate(p.xz,t*1.6); //Rotation speed\n        p.xz = abs(p.xz);\n        p.xz-=.3; //Size???\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*2.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*0.03)/(3000.*(d));//v1: pink, v2:brightness\n        t+=d;\n    }\n    return vec4(col,60./(d*10.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(41.,41.,-0.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(55,3.,57.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n    }\n    else\n    {\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 111, 111, 259], [261, 261, 289, 289, 365], [367, 367, 385, 385, 638], [640, 640, 667, 667, 1074], [1076, 1076, 1133, 1198, 2429]], "test": "untested"}
{"id": "mlcyDn", "name": "whole lotta particles", "author": "mds2", "description": "Someone on the facebook group asked how to make a whole lotta particles using domain repetition.\n\nThis is my attempt at that.  I should comment it or something.", "tags": ["example", "demo"], "likes": 7, "viewed": 185, "published": 3, "date": "1699064382", "time_retrieved": "2024-07-30T17:24:07.406473", "image_code": "// because I hacked this together, there are two ways to increase particle density\n// Prefer to use this one. \n// integer values between 1 and 20 (inclusive) work best.\n// larger numbers correspond to more particles.\n#define TORUS_DENSITY 2.0\n\n\n#define MAX_DIST 5.0\n\n// density and inverse density of the actual grid.\n// These are more finicky than TORUS_DENSITY\n#define DENSITY 20.0\n#define INV_DENSITY 0.05\n\nfloat box_length(in vec3 pt) {\n // use thsi in single_item_sdf to change the base shape\n vec3 p = abs(pt);\n return max(p.x, max(p.y, p.z));\n}\n\nfloat single_item_sdf(in vec3 pt) {\n  // base sdf for a sphere.  You can put other shapes in here\n  // for instance, change \"length\" to \"box_length\" to replace ellipsoids with boxes\n  return length(pt) - 1.0;\n}\n\nfloat gridded_sdf(in vec3 pt) {\n  // this is where the domain repetition happens. We transform the coordinates and use \"mod\"\n  // to make an SDF of one object into an SDF of a bunch of (gridded) copies of that object.\n  vec3 new_pt = mod(DENSITY * pt + vec3(4.0), vec3(8.0)) - vec3(4.0);\n  if (pt.z > 0.6 || pt.z < -0.8) {\n    // and we do want to clamp the domain of where the particles show up in z.\n    new_pt.z = DENSITY * pt.z;\n  }\n  return INV_DENSITY * single_item_sdf(new_pt);\n}\n\nfloat sdf(in vec3 pt) {\n  // and here we transform our grid of repeated particles onto a flowing animation of repeated particles\n  // we do this by creating a mapping from visual space to grid space.  In this case we're wrapping\n  // the grid of particles around a toroid.\n  //\n  // Yeah, I know, I wouldn't be able to follow this math either if I hadn't written it.\n  float height = pt.y + 0.5;\n  float base = length(pt.xz + vec2(0.0, 1.0)) - 1.25;\n  float d = length(vec2(height, base)) - 0.375;\n  float theta = atan(pt.z + 1.0, pt.x);\n  float phi = atan(height, base);\n  const float scale = TORUS_DENSITY;\n  vec3 xformed = scale * vec3(0.25 * 3.2 * phi / 3.141592654 + 0.25 * iTime,0.5 * iTime +  3.2 * theta / 3.141592654, d);\n  return gridded_sdf(xformed)/scale;\n}\n\nvec3 normed_grad(in vec3 pt) {\n  // cheap trick for getting the surface normal of the surface of an sdf.\n  // Just numerically evaluate the gradient! And then normalize it!\n  // since we're normalizing it anyway, we don't care about the \"divide by step size\" thing\n  // that most numerical calculations of gradients have.\n  float v = sdf(pt);\n  return normalize(vec3(sdf(pt + vec3(0.01, 0.0, 0.0)) - v,\n                        sdf(pt + vec3(0.0, 0.01, 0.0)) - v,\n                        sdf(pt + vec3(0.0, 0.0, 0.01)) - v));\n}\n\nfloat raycast(in vec3 dir, in vec3 orig, out float accum) {\n  // this is my personal favorite modification of the shadertoy raycasting algorithm\n  // in addition to returning the distance along a ray until you hit the surface\n  // of an SDF, it also approximates the integral of 1/sdf^2 along the ray.\n  //\n  // This lets me compute a sort of foggy \"glow\" around the particles.\n  accum = 0.0;\n  float along = 0.0;\n  float last_dist = sdf(orig);\n  for (int i = 0; i < 100; ++i) {\n    float stepsize = 0.4 * last_dist;\n    float next_dist = sdf(orig + (along + stepsize) * dir);\n    accum += stepsize * 0.5 * (1.0 / max(last_dist*last_dist, 0.001) + 1.0 / max(next_dist*next_dist, 00.1));\n    last_dist = next_dist;\n    along += stepsize;\n    if (abs(last_dist) < 1.0e-3) {\n      return along;\n    }\n    if (last_dist > MAX_DIST) {\n      return MAX_DIST + 1.0;\n    }\n  }\n  return along;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    vec3 ray = normalize(vec3(uv, -1.0));\n    \n    vec3 orig = vec3(0.0, 0.0, 1.0);\n    \n    float pitch = -1.0 * iMouse.y/iResolution.y;\n    \n    float cpitch = cos(pitch);\n    float spitch = sin(pitch);\n    \n    mat3 orient = mat3(1.0, 0.0, 0.0, 0.0, cpitch, spitch, 0.0, -spitch, cpitch);\n    \n    orig = orient * (orig + vec3(0.0, 0.5, 1.0)) - vec3(0.0, 0.5, 1.0);\n    ray = orient * ray;\n    \n    float accum;\n    \n    float d = raycast(ray, orig, accum);\n    \n    // base color comes from that integral along a ray of 1/sdf^2, but,\n    // there's a trick here. For rays that get really close to objects, this spikes\n    // to way above 1.  And the graphics pipeline does clamping for you when converting to color.\n    // So if you multiply a signal that sometimes get's really large by a color with different values\n    // for red, green, and blue, you get a bit of a color gradient as the thing you're drawing gets\n    // more intense.\n    vec3 col = 0.00625 * accum * vec3(0.5, 0.1, 1.0);\n    \n    if (d < MAX_DIST) {\n      // and if the ray actually hits an object, we do a bit of shading, so that the \"particles\"\n      // show up more clearly and the whole thing doesn't just look like a blob of gelatinous fog.\n      vec3 surfNorm = normed_grad(orig + d * ray);\n      vec3 bounce = normalize(reflect(ray, surfNorm));\n      float raw_shine = max(0.0, dot(bounce, normalize(vec3(0.5, 1.0, 1.0))));\n      raw_shine = raw_shine * raw_shine;\n      raw_shine = raw_shine * raw_shine;\n      col.g += raw_shine * raw_shine * raw_shine;\n      col += 0.4 * max(vec3(0.5), vec3(1.5, 1.0, 0.5) * texture(iChannel0, bounce).rgb);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 440, 497, 551], [553, 553, 588, 734, 763], [765, 765, 796, 982, 1251], [1253, 1253, 1276, 1619, 2022], [2024, 2024, 2054, 2345, 2550], [2552, 2552, 2611, 2929, 3438], [3440, 3440, 3497, 3547, 5332]], "test": "untested"}
{"id": "msVfzR", "name": "Year of Truchets #058", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n", "tags": ["2d", "pattern", "tiles", "truchets"], "likes": 26, "viewed": 282, "published": 3, "date": "1699045490", "time_retrieved": "2024-07-30T17:24:08.177412", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #058\n    11/03/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\nvec3 hue(float t){ return .5+.5*cos(6.5*(t)+vec3(0,1,2)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 xv = uv;\n    \n    // @stb\n    uv.x -= .25;\n    uv /= uv.x*uv.x + uv.y*uv.y;\n    uv.x += 2.;\n    \n    uv *= rot(T*.15);\n    uv = vec2(log(length(uv)),atan(uv.y,uv.x))*2.546;//1.273;//.637;//.31825;//other good values\n\n    uv.x -= (M.z>0.) ? (M.x/R.x*3.-1.5)*PI : 1.5*sin(T*.1);\n\n    float tt = T*.08;\n    float px = fwidth(uv.x);\n    \n    vec2 dv = fract(uv)-.5,\n         id = floor(uv);\n\n    float rnd = hash21(id),\n          bnd = fract(rnd*147.32+(T*.05));\n\n    vec3 h = hue(tt-uv.x*.015)*.85,\n         g = hue(tt+bnd*.35-uv.x*.075)*.5;\n         \n    if(rnd<.5) dv.x = -dv.x;\n       rnd = fract(rnd*147.32+tt);\n       \n    vec2  gx = length(dv-.5)<length(dv+.5) ? vec2(dv-.5) : vec2(dv+.5);\n    float cx = (rnd>.75) ? min(length(dv.x),length(dv.y)) : length(gx)-.5;\n\n    h = mix(h,h*.5,smoothstep(.035+px,-px,abs(cx)-.125));\n    h = mix(h,g,smoothstep(px,-px,abs(cx)-.12));\n    h = mix(h,vec3(1),smoothstep(px,-px,abs(abs(cx)-.12)-.01));\n\n    fragColor = vec4(pow(h,vec3(.4545)),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVfzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[355, 355, 373, 373, 417], [418, 418, 439, 439, 501], [502, 502, 520, 520, 561], [563, 563, 612, 612, 1652]], "test": "untested"}
{"id": "clcyDr", "name": "silly anime water", "author": "cedric_h", "description": "weeeee", "tags": ["water", "silly", "anime"], "likes": 7, "viewed": 225, "published": 3, "date": "1699040245", "time_retrieved": "2024-07-30T17:24:08.941369", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// https://iquilezles.org/articles/voronoilines\n//\n// More Voronoi shaders:\n//\n// Exact edges:  https://www.shadertoy.com/view/ldl3W8\n// Hierarchical: https://www.shadertoy.com/view/Xll3zX\n// Smooth:       https://www.shadertoy.com/view/ldB3zc\n// Voronoise:    https://www.shadertoy.com/view/Xd23Dh\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( 0.1*iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( 0.1*iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n/* FBM!!! */\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\nfloat aastep(float threshold, float value) {\nfloat afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\nreturn smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = 1.4*fragCoord/iResolution.x;\n    p += 0.24*fbm6((p*2.0 + iTime*0.15));\n    \n    vec3 c = voronoi( 8.0*p );\n\n\t// isolines\n    vec3 col = vec3(0.0, 0.6, 0.9);\n    // borders\t\n    col = mix( vec3(0.6,0.8,0.99), col, smoothstep( 0.0075, 0.025, c.x ) );\n    // feature points\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcyDr.jpg", "access": "api", "license": "mit", "functions": [[1868, 1868, 1890, 1920, 2101], [2103, 2103, 2130, 2130, 3237], [3305, 3305, 3331, 3331, 3360], [3362, 3362, 3384, 3384, 3737], [3739, 3739, 3762, 3762, 3821], [3823, 3823, 3867, 3867, 4011], [4013, 4013, 4070, 4070, 4386]], "test": "untested"}
{"id": "DtccWr", "name": "WGPU Semantic Error:case not int", "author": "jakel101", "description": "This is a minimal reproduction of a switch case on Shadertoy using constant ints. It doesn't get translated correctly and throws a Semantic error in naga.", "tags": ["error"], "likes": 1, "viewed": 182, "published": 3, "date": "1699038672", "time_retrieved": "2024-07-30T17:24:10.175070", "image_code": "// 1. declare constant integers\n\nconst int ID_left = 0;\nconst int ID_right = 1;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy;\n    \n    int side = int(uv.x);\n \n    vec3 col = vec3(0.2);\n    \n    // 2. switch case on an int\n    switch(side)\n    {\n    // 3. use those constants \n    case ID_left:\n    {\n        col *= 4.0;\n    }\n    case ID_right:\n    {\n        col *= 2.0;\n    }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtccWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 139, 139, 476]], "test": "untested"}
{"id": "ctcyWn", "name": "Graphic Design Experiment 9", "author": "yasuo", "description": "Graphic Design Experiment 9", "tags": ["graphicdesign", "cineshader"], "likes": 24, "viewed": 952, "published": 3, "date": "1699030612", "time_retrieved": "2024-07-30T17:24:11.038761", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),-antialiasing(1.5),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec3 graphicItem0(vec2 p, vec3 col){\n    vec2 prevP = p;\n    float d = length(p-vec2(0.0,0.12))-0.06;\n    float d2 = B(p,vec2(0.025,0.1));\n    d = min(d,d2);\n    d2 = length(p-vec2(0.0,-0.098))-0.0256;\n    d = abs(min(d,d2))-0.007;\n    \n    d2 =  length(p-vec2(0.0,0.12))-0.02;\n    d = min(d,d2);\n    \n    d2 =  length(p-vec2(0.0,0.24))-0.015;\n    d = min(d,d2);    \n    \n    d2 = abs( length(p-vec2(0.0,0.24))-0.03)-0.002;\n    d = min(d,d2);      \n    \n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    return col;\n}\n\nvec3 graphicItem0Group(vec2 p, vec3 col){\n    vec2 prevP = p;\n    col = graphicItem0(p,col);\n    p.x = abs(p.x)-0.12;\n    p.y-=0.1;\n    col = graphicItem0(p,col);\n    return col;\n}\n\nvec3 graphicItem0Layer(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x = abs(p.x);\n    p.y+=iTime*0.1;\n    p*=2.5;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    \n    float n = random(id);\n    gr.x+=sin(n*2.)*0.25;\n    gr.y+=sin(n*2.)*0.3+mix(0.0,1.,step(0.9,n));\n    gr*=clamp(n*1.5,0.85,1.5);\n    col = graphicItem0Group(gr,col);\n    \n    return col;\n}\n\nvec3 graphicItem0Layer2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.12;\n    p.y+=iTime*0.12;\n    p*=2.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    \n    float n = random(id);\n    gr.x+=sin(n*2.)*0.25;\n    gr.y+=sin(n*2.)*0.3+mix(0.0,1.,step(0.9,n));\n    gr*=clamp(n*1.5,0.6,1.5);\n    col = graphicItem0(gr,col);\n    \n    return col;\n}\n\nfloat hexagon(vec2 p, float animate){\n    p*=Rot(radians(-30.*iTime)*animate);\n    float size = 0.1;\n    float d = B(p,vec2(size-0.02,0.1));\n    p.x = abs(p.x)-size;\n    p.y = abs(p.y)-size*0.35;\n    float a = radians(-120.);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    return abs(d)-0.003;\n}\n\nvec3 graphicItem1(vec2 p, vec3 col){\n    vec2 prevP = p;\n    float d = hexagon(p,0.0);\n    p.y = abs(p.y)-0.19;\n    float d2 = hexagon(p,0.0);\n    d = min(d,d2);\n    p = prevP;\n    p.x = abs(p.x)-0.16;\n    p.y = abs(p.y)-0.09;\n    d2 = hexagon(p,1.);\n    d = min(d,d2);\n    col = mix(col,vec3(0.7),S(d,0.0));\n    return col;\n}\n\nvec3 graphicItem1Layer(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.3;\n    p.y+=iTime*0.15;\n    p.y+=0.2;\n    p*=2.1;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    \n    float n = random(id);\n    gr.x+=sin(n*10.)*0.1;\n    gr.y+=sin(n*10.)*0.1+mix(0.0,1.,step(0.9,n));\n    gr*=Rot(n*2.);\n    gr*=clamp(n*2.5,0.85,2.5);\n    col = graphicItem1(gr,col);\n    \n    return col;\n}\n\nvec3 graphicItem2(vec2 p, vec3 col){\n    \n    float d = 10.;\n    for(float i = 0.; i<3.; i++){\n        \n        p = abs(p)-0.01;\n        p*=Rot(radians(45.0+(30.0*iTime)));\n        p.y+=0.05;\n        p*=1.6;\n        \n        vec2 prevP = p;\n\n        p.y+=0.2;\n        p.x = abs(p.x);\n        p.x-=0.22;\n        p*=Rot(radians(30.0));\n        d = length(p)-0.4;\n        d = max(-(length(p-vec2(0.15,0.0))-0.31),d);\n\n        p = prevP;\n        p.y-=0.4;\n        float d2 = length(p)-0.4;\n        d2 = max(-(length(p-vec2(0.0,0.15))-0.31),d2);\n        d = min(d,d2);\n\n        p = prevP;\n        p.y-=0.05;\n        d2 = abs(length(p)-0.35)-0.05;\n        d = abs(min(d,d2))-0.01;\n    }\n    \n    col = mix(col,vec3(0.4),S(d,0.0));\n     \n    return col;\n}\n\nvec3 graphicItem2Layer(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=0.9;\n    \n    p.x+=0.5;\n    p.y+=iTime*0.2;\n    p.y+=0.5;\n    \n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    \n    float n = random(id);\n    gr.y+=sin(n*50.)*0.2;\n    gr*=clamp(n*1.,0.6,1.);\n    col = graphicItem2(gr,col);\n    \n    return col;\n}\n\nfloat circleAnimation(vec2 p, float size, float lineWidth, float dir, float b){\n    vec2 prevP = p;\n    p*=Rot(radians(20.*iTime*dir));\n    float d = abs(abs(length(p)-0.5)-size)-lineWidth;\n    \n    p = DF(p,b);\n    p-=0.007;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.02,1.));\n    \n    d = max(-d2,d);\n    return d;\n}\n\nfloat graphicItem3(vec2 p){\n    float d = B(p,vec2(0.008,0.08));\n    float d2 = B(p,vec2(0.08,0.008));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 lineGraphicsLayer(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.x = abs(p.x);\n    p.y+=iTime*0.08;\n    p*=4.;\n    \n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n\n    float n = random(id);\n    gr*=Rot(radians(mix(0.0,90.,step(0.5,n))));\n    \n    float lineWidth = 0.008;\n    vec3 lineColor = vec3(0.3);\n    gr*=Rot(radians(45.));\n    gr.x = abs(gr.x)-0.707;\n    float d = circleAnimation(gr,0.14,lineWidth,-1.0,2.);\n    col = mix(col,lineColor,S(d,-0.001));\n    d = abs(abs(length(gr)-0.5)-0.09)-lineWidth;\n    col = mix(col,lineColor,S(d,-0.001));\n    d = circleAnimation(gr,0.03,lineWidth,1.0,2.);\n    col = mix(col,lineColor,S(d,-0.001));\n    d = abs(abs(length(gr)-0.5)-0.19)-lineWidth;\n    col = mix(col,lineColor,S(d,-0.001));\n    return col;\n}\n\nvec3 lineGraphicsLayer2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y+=iTime*0.08;\n    p*=4.;\n    p-=0.5;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n\n    float n = random(id);\n    \n    float lineWidth = 0.008;\n    vec3 lineColor = vec3(0.6);\n\n    float d = mix(0.0,step(0.5,n),circleAnimation(gr,0.35,lineWidth,1.,1.5));\n    float d2 = mix(0.0,step(0.5,n),circleAnimation(gr,0.3,lineWidth,-1.,1.5));\n    d = min(d,d2);\n    d2 = mix(step(0.5,n),1.0,graphicItem3(gr));\n    d = min(d,d2);\n    col = mix(col,lineColor,S(d,-0.002));\n\n    return col;\n}\n\nvec3 drawGraphics(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    col = graphicItem2Layer(p,col);\n    col = lineGraphicsLayer(p,col);\n    col = lineGraphicsLayer2(p,col);\n    col = graphicItem0Layer(p,col);\n    col = graphicItem0Layer2(p,col);\n    col = graphicItem1Layer(p,col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    col = drawGraphics(p,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 488, 488, 561], [563, 563, 599, 599, 1078], [1080, 1080, 1121, 1121, 1260], [1262, 1262, 1303, 1303, 1624], [1626, 1626, 1668, 1668, 1988], [1990, 1990, 2027, 2027, 2286], [2288, 2288, 2324, 2324, 2614], [2616, 2616, 2657, 2657, 3012], [3014, 3014, 3050, 3050, 3762], [3764, 3764, 3805, 3805, 4092], [4094, 4094, 4173, 4173, 4421], [4423, 4423, 4450, 4450, 4560], [4562, 4562, 4603, 4603, 5321], [5323, 5323, 5365, 5365, 5879], [5881, 5881, 5917, 5917, 6183], [6185, 6185, 6242, 6242, 6397]], "test": "untested"}
{"id": "mttyz7", "name": "Jantung", "author": "zhonkvision", "description": "Jantung Berdegup degap\n\nI found this on twigl, ", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 7, "viewed": 200, "published": 3, "date": "1699028210", "time_retrieved": "2024-07-30T17:24:11.926388", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 n, q, p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float d = dot(p, p), S = 12.0, i, a = 0.0;\n    \n    for (int j = 4; j < 40; j++)\n    {\n        mat2 m = mat2(cos(10.0), -sin(10.0), sin(10.0), cos(10.0));\n        p *= m;\n        n *= m;\n        q = p * S + iTime * 4.0 + sin(iTime * 8.0 - d * 2.0) * 0.6 + float(j) + n;\n        a += dot(cos(q) / S, vec2(0.2));\n        n -= sin(q);\n        S *= 1.2;\n    }\n    fragColor=vec4(0);\n    fragColor = (a + 0.2) * vec4(4.0, 1.0, 1.0, 1.0) + a + a - d;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 579]], "test": "untested"}
{"id": "mtdczM", "name": "defender fork", "author": "jorge2017a2", "description": "defender fork", "tags": ["defenderfork"], "likes": 13, "viewed": 207, "published": 3, "date": "1699023481", "time_retrieved": "2024-07-30T17:24:12.793071", "image_code": "///---por jorge flores\n//jorge2017a1\n///defender fork ---- 3-nov-2023\n//referencia\n//https://www.shadertoy.com/view/ml3cRH\n\nvec3 cuadroChico(vec2 p, vec3 col, vec3 col2)\n{\n    vec2 pos=p-vec2(0.5,0.9);\n    vec2 pos2=p-vec2(0.5,0.9);\n    float d0= sdBox(pos, vec2(0.135,0.075) );\n    float d1= sdBox(pos2, vec2(0.125,0.068) );\n    vec3 colin=col2;\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col, abs(d0)-0.015);\n    col= DrawFigSolo(colin, col, d1);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = fragCoord.xy/iResolution.xy;\n    \n    vec3 col=texture(iChannel0,uv).xyz;\n    vec3 col2=texture(iChannel0,uv*4.6+vec2(-1.85,-3.8)).xyz;\n    col+= cuadroChico(uv,col, col2);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define antialiasing(n) n/min(288.,512.)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nconst int ENEMY_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,\n0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,\n0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,0,1,1,2,1,2,2,1,0,0,0,0,0,\n0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,\n0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,\n0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,\n0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,\n0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\nconst int NAVE_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,\n0,2,1,2,2,1,1,1,1,0,0,0,5,0,0,0,\n0,0,0,2,2,2,1,1,1,1,1,1,1,3,4,0,\n0,0,0,2,2,1,3,4,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\nconst int NAVE_E_BITMAP[256] = int[]\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,\n0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,\n0,1,0,0,0,3,3,0,3,3,0,0,0,1,0,0,\n0,1,2,2,0,3,2,0,3,2,0,2,2,1,0,0,\n0,0,1,2,2,2,2,2,2,2,2,2,1,0,0,0,\n0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\nconst int NAVE_BOMBA[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,\n0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,\n0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nvec3 RGB3(float r ,float g, float b)\n{ return vec3(r/255.,g/255.,b/255.);}\n\n\n\nint readEnemyBitMap(in vec2 uv) \n{ return ENEMY_BITMAP[int(uv.y) * 16 + int(uv.x)]; }\n\n\nvec3 GetColorEnemy(int opc)\n{   switch(opc)\n    {   case 0:return RGB3(0.,0.,0.);\n        case 1:return RGB3(0.,184.,0.);\n        case 2:return RGB3(254.,184.,0.);\n    }\n    return vec3(1.0);\n}\n\n\nvec3 GetColorNave(int opc)\n{   switch(opc)\n    {\n        \n    case 0:return RGB3(0.,0.,0.);\n    case 1:return RGB3(140.,140.,140.);\n    case 2:return RGB3(255.,0.,255.);\n    case 3:return RGB3(255.,255.,255.);\n    case 4:return RGB3(0.,159.,98.);\n    case 5:return RGB3(255.,255.,0.);\n\n    }\n    return vec3(1.0);\n}\n\n\nvec3 GetColorNave_E(int opc)\n{   switch(opc)\n    {\n    //(0,0,0),(0,0.624,0.384),(1,0.976,0.616),(1,0,0),\n    case 0:return vec3(0.,0.,0.);\n    case 1:return vec3(0,0.624,0.384);\n    case 2:return vec3(1,0.976,0.616);\n    case 3:return vec3(1,0,0);\n    }\n    return vec3(1.0);\n}\n\nvec3 GetColorBOMBA(int opc)\n{   switch(opc)\n    {\n    case 0:return vec3(0.,0.,0.);\n    case 1:return vec3(0.953,0.62,0.467);\n    case 2:return vec3(0.886,0,0.498);\n    }\n    return vec3(1.0);\n}\n\n\nvec3 PonerEnemy(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( ENEMY_BITMAP[pix.x+pix.y*16] );    \n        if(opc!=0)\n        col=GetColorEnemy(opc); \n    }\n    return col;\n}\n\n\nvec3 PonerNave(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave(opc);\n    }\n    return col;\n}\n\n\nvec3 PonerNave_E(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_E_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave_E(opc);\n    }\n    return col;\n}\n\n\nvec3 PonerBOMBA(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BOMBA[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorBOMBA(opc);\n    }\n    return col;\n}\n\n\n// T = terrain world position\nvec3 Terrain(vec2 uv, float T, vec3 col)\n{\n    float scale = 64.;\n    float a = T*.25 + uv.x*7.;\n    float elev = sin(a+cos(a)*1.205-sin(a*4.)*cos(a))*.1+.2+sin(a*17.)*.01;\n    float uy = floor(uv.y*scale)/scale;\n    if (abs(uy-elev) < .007)\n    {\n        col = vec3(1.,.4,0);\n    }\n    return col;\n}\n\n\nvec3 hacertierraB(vec2 p, vec3 col)\n{\n    float fx=(2.0*sin(p.y));\n    fx=abs(fx)-0.1;\n    col= DrawFigBorde(vec3(0.0), col, abs(fx)-0.001);\n    \n    return col;\n}\n\nvec3 monta(vec2 p, vec3 colOut,vec3 colIn)\n{   float d1=(cos(p.x*0.25 +cos(p.x*0.5)))+p.y-2.0;\n    float d2=abs(d1)-0.05;\n    d1=d2;\n    colOut= DrawFigBorde(colIn,colOut,d1);\n    return colOut;\n}\n", "buffer_a_code": "//https://www.shadertoy.com/view/ml3cRH\nvec3 Stars(vec2 w, vec3 col)\n{\n    if (w.y > .2)\n    {\n        float y = w.y * 50.;\n        if (sin(y) > .9 && sin(iTime*.5 + w.x*2. + w.y*43100.+cos(w.y)) > .9999991) return vec3(1);\n    }\n    return col;\n}\n\nfloat rand(vec2 co)\n{ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);}\n\nfloat noise(vec2 co)\n{\n    vec2 p = floor(co);\n    vec2 f = fract(co);\n    float a = rand(p);\n    float b = rand(p + vec2(1.0, 0.0));\n    float c = rand(p + vec2(0.0, 1.0));\n    float d = rand(p + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n//https://www.shadertoy.com/view/DscSWX\nvec3 stars3(vec2 uv, vec3 col )\n{\n    float time = mod(iTime, 100.);\n    float speed = 1.0;\n    float frequency = 6.0;\n    float density = 0.2;\n    int depth = 2;\n    vec3 color = vec3(0.8, 0.8, 1.);\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    float noiseValue = 0.0;\n    for (int i = 0; i < depth; i++) {\n        noiseValue += noise(uv * frequency + vec2(-time * speed, 0.0)) * density;\n        frequency *= 2.0;\n        density *= 0.5;\n    }\n    col+=color * noiseValue;\n    return col;\n}\n\nvec3 fuego(vec2 p,vec2 pos,  vec3 col)\n{   if( p.x>pos.x && p.x<pos.x+0.5)\n    { float d1=p.y+pos.y;\n        col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1)-0.001);\n    }\n    return col;\n}\n\nvec3 soloLinea(vec2 p, vec3 col)\n{   float d1=p.y-0.8;\n    col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1)-0.001);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 col;\n    float t=iTime;\n    col= soloLinea(uv,col);\n    col= monta( uv*11.0+vec2(t,0.0),col,vec3(1.0,1.0,1.0));\n    col=Stars(uv, col);\n    if (2.0*sin(t)>0.0)\n        col=stars3(uv,col );\n        \n    ivec2 posi=ivec2(2,2);\n    ivec2 pos2=ivec2(5,5);\n    ivec2 pos3=ivec2(10+int(5.0*sin(iTime)),8);\n    col= PonerEnemy(uv, posi+ivec2(0,int(4.0*abs(sin(t)))), col);\n    col=PonerNave(uv*0.75, pos2, col);\n    col= fuego(uv,vec2(0.5+ mod(iTime,1.5),-0.445), col);\n    col=PonerNave_E(uv,pos3,col);\n     col=PonerBOMBA(uv, ivec2(15,9+int(4.0*sin(t))),col);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 171, 171, 464], [466, 466, 523, 523, 787]], "test": "untested"}
{"id": "mltyRN", "name": "Palette Cleanser", "author": "domrally", "description": "A small 2D pastel rainbow color palette.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["2d", "color", "palette", "rainbow", "short", "pastel"], "likes": 2, "viewed": 199, "published": 3, "date": "1699023143", "time_retrieved": "2024-07-30T17:24:13.667732", "image_code": "/*\nby Dom Mandy 🎨 in 2023\n*/\nvec3 palette(float l, float h) { return l + l * vec3(.7874, .2848, .9278) * cos(h - vec3(0, 2.1, 4.2)); }\n\n\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    uv = (uv + uv - iResolution.xy) / iResolution.x;\n    float hue = atan(uv.y, uv.x) + iTime,\n          lightness = pow(smoothstep(2., 0., length(uv) - .1), 9.);\n\n    // pastel\n    vec3 color = palette(lightness, hue);\n    \n    color = mix(color, vec3(1), pow(lightness, 9.));\n    pixel.rgb = pow(color, vec3(1) / 2.2);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 64, 64, 137], [140, 140, 181, 181, 504]], "test": "untested"}
{"id": "DltcRM", "name": "Blue Pentagon", "author": "QuantumSuper", "description": "A pseudo-3d animation by morphing glowing 2d shapes.", "tags": ["2d", "glow", "25d", "pentagon"], "likes": 6, "viewed": 254, "published": 3, "date": "1699008567", "time_retrieved": "2024-07-30T17:24:14.495520", "image_code": "// Blue Pentagon v0.7.231103 by QuantumSuper\n// pseudo-3d animation by morphing glowing 2d shapes\n// \n\n#define PI 3.14159265359 \n\nvec3 tmUnreal( vec3 x){ //tone map, source: https://www.shadertoy.com/view/llXyWr, thanks at Xor for highlighting\n    return x / (x + .155) * 1.019;\n}\n\nfloat sdPentagon( vec2 p, float r){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const vec3 k = vec3( .809016994, .587785252, .726542528);\n    p.x = abs(p.x);\n    p -= 2.*min( dot(vec2(-k.x,k.y),p), 0.) * vec2( -k.x, k.y);\n    p -= 2.*min( dot(k.xy,p), 0.) * k.xy;\n    p -= vec2( clamp( p.x, -r*k.z, r*k.z), r);    \n    return length(p) * sign(p.y);\n}\n\nfloat myObj(vec2 p, float scale, float speed, float off){\n    return abs(sdPentagon( p/vec2(cos(iTime*speed+off),1.-sin(iTime*speed+off)*p.x/cos(iTime*speed+off)), .85/scale)) + .01;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\tvec3 col = vec3(0);\n    float amp;\n  \n    // Settings\n    float scale = 4. + .5*sin(iTime/8.); //coordinate system scale\n    float matDiff = .33; //material brightness difference   \n    float speed = .5; //speed factor\n    vec3 color1 = vec3( 23,123,250)/256.; //cneon blue\n    vec3 color2 = vec3( 30, 29,215)/256.; //vw2 blue\n    \n    float off=.01; //rotation offset per slice\n    float num = 32.; //number of 2d slices\n\n    // Calculation\n    for(float n=0.;n<num;n++){\n        amp = .01 / max( .01, myObj( uv, scale, speed, n*off)) //draw\n            * ((uv.x/cos(iTime*speed+n*off)*scale*.5+1.5) * (1.-matDiff) + (cos(iTime*speed+PI/2.+n*off)*.5+.5) * matDiff); //lighting\n        col += clamp(amp,.0,1.) * (color1*(1.-n/num)+color2*n/num) / num; //color \n        off *= 1.05 - .05*cos(iTime/PI); //iterate rotation offset\n    }\n      \n    fragColor = vec4( tmUnreal(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 153, 243, 280], [282, 282, 317, 376, 651], [653, 653, 710, 710, 840], [842, 842, 897, 897, 1905]], "test": "untested"}
{"id": "DtdyRM", "name": "Fork Parallax v Ars77", "author": "chenxianming", "description": "It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though. [url]https://cineshader.com/view/wtdSR8[/url]", "tags": ["triangle", "cineshader"], "likes": 1, "viewed": 730, "published": 3, "date": "1699006027", "time_retrieved": "2024-07-30T17:24:15.431018", "image_code": "#define PI 3.1415\n#define TAU PI * 2.\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// IQ\nfloat tri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat rep(inout vec2 p, float rep) \n{\n\n    float an = TAU/rep;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    \n    p *= rot(sym);\n\n    return ia;\n}\n\n\nfloat tex( vec2 u ){\n    \n    u.y -= 1. / 3.;\n    \n    vec2 u2 = u;\n    float p = 1.;\n    // fpos\n    for( float i = 0.; i < 3.; i++ ){\n        u2.y += sqrt( 3. ) * .1;\n        u2.x = abs( u2.x ) - .1;\n        p = min(\n            p,\n            tri( u2, .1 )\n        );\n    }\n    \n    p = min(\n        p,\n        tri( u, .1 )\n    );\n    \n    return p;\n}\n/*\nfloat cu( vec2 p, float size ){\n    return max(\n            abs( p.x ) - size,\n            abs( p.y ) - size\n        );\n}\n*/\n\nfloat TFace( vec3 p ){\n    /*\n    // tri geo\n    float py = clamp( -p.y, 0., 1. );\n    py = abs( py ) - .01;\n    \n    return max(\n        cu( p.xz, 1. * py ), // prisma overlay\n        // tri( p.xz, 1. * py ),\n        abs( p.y ) - .2\n    );\n    \n    */ \n    \n    // faces\n    \n    return max(\n        tri( p.xy, .21 ),\n        abs( p.z ) - .001\n    );\n}\n\nfloat map( vec3 p ){\n\n    \n    \n    return TFace( p );\n}\n\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 1.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0, dist;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n        \n        p.x = abs( p.x ) - .25,\n        p.xz *= rot( iTime ),\n        rep( p.xz , 3. ),\n        p.x -= .105,\n        p.y += .1,\n        p.xz *= rot( PI * .5 ),\n        p.yz *= rot( PI * .11 ),\n        p.y -= .1;\n        \n\t\tdist = map(p);\n        \n        \n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    \n        \n    if( dist < 1e-3 ){\n        col -= vec3( step( tex( p.xy * 2. ), 0. ) * max( -calcNormal( p ).z, 0. ) ) * .2;\n    }\n    \n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Parallax view on Cineshader\",\n\t\"description\": \"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 126, 126, 213], [215, 215, 261, 261, 302], [304, 310, 346, 346, 555], [557, 557, 594, 594, 764], [767, 767, 787, 787, 1121], [1251, 1251, 1273, 1522, 1604], [1606, 1606, 1626, 1626, 1662], [1665, 1665, 1695, 1695, 1977], [1979, 1979, 2036, 2036, 3769]], "test": "untested"}
{"id": "mtcyzM", "name": "False Mirror Distortions Imp", "author": "ersh", "description": "Use it as a funny mirror.\n\nFeel free to replace the texture in Channel1 to any other texture or video or webcam!", "tags": ["2d", "fractal", "distortion"], "likes": 5, "viewed": 441, "published": 3, "date": "1698997858", "time_retrieved": "2024-07-30T17:24:16.326623", "image_code": "// Liquid curved mirror - Improved.\n// Feel free to replace the texture in Channel1 to any other texture or video or webcam!\n\n\n// Amount of distortion\n#define SCALE 1.\n\n// Check out settings on the \"Buffer A\" tab.\n\n//// What to do on the border: one of {\n//#define TRANSFORM      NONE\n//#define TRANSFORM      LOOP\n//#define TRANSFORM      MIRROR\n#define TRANSFORM      MIRRORX\n//// }\n\nvec4 T(ivec2 x) { return texelFetch(iChannel0, x, 0); }\n\nvec4 T2(vec2 x) {\n#define NONE(X)           X\n#define LOOP(X)           fract(X)\n#define MIRROR(X)         abs((mod(X + 1., 2.)) - 1.)\n#define MIRRORX(X)         vec2(abs((mod(X.x, 2.)) - 1.), abs((mod(X.y + 1., 2.)) - 1.))\n  return texture(iChannel1, TRANSFORM(x), 0.);\n}\n\n//#define XYSQ   vec2(1., iResolution.x / iResolution.y)\n\n#define XYSQ   (iResolution.x > iResolution.y ? \\\n                vec2(1., iResolution.x / iResolution.y) : \\\n                vec2(1., iResolution.x*iResolution.x / iResolution.y/iResolution.y)) \\\n// EOM\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 v = T(ivec2(fragCoord)).xyz;\n    vec2 sh = v.xy * min(iResolution.x, iResolution.y) / 4000. * SCALE * XYSQ;\n    float scos = cos(v.z*4.), ssin = sin(v.z*4.);\n    sh = vec2(\n        sh.x * scos + sh.y * ssin,\n      - sh.x * ssin + sh.y * scos);\n    fragColor = vec4(\n        T2(uv + sh).rgb,\n        1.0);\n}\n\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define SPEED           1.     /* 0 ... max */\n#define SMOOTH          1      /* 0 or 1 */\n#define SMOOTHNESS      0.48   /* 0: smooth ... 0.5: step */\n#define DISPERSE_TIERS  1      /* 0 or 1 */\n#define WAVE            0      /* 0 or 1 */\n\n\nint imod(int a, int b) { return a % b; }\nint iabs(int x) { return x >= 0 ? x : -x; }\nint isign(int x) { return x >= 0 ? 1 : -1; }\nint maxx;\nvec4 T(ivec2 x) {\n  return\n      x.x < 0 ? texelFetch(iChannel0, ivec2(0, x.y), 0) - texelFetch(iChannel0, ivec2(-x.x, x.y), 0) :\n      x.x > maxx ? texelFetch(iChannel0, ivec2(maxx, x.y), 0) - texelFetch(iChannel0, ivec2(maxx-x.x, x.y), 0) :\n      texelFetch(iChannel0, x, 0);\n\n#define FETCH(X)               texelFetch(iChannel0, X, 0)\n#define SAW(X, MAXX)           ivec2(iabs((imod(X.x + MAXX, MAXX * 2)) - MAXX), X.y)\n#define SGN(X, MAXX)           float(-isign(imod(X.x, MAXX * 2) - MAXX))\n#define MIRROR(FN, X, MAXX)    (FN(SAW(X, MAXX)) * SGN(X, MAXX))\n  // return MIRROR(FETCH, x, maxx);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  1.5 / pow(3., ceil(log(min(iResolution.x,iResolution.y)+1.)/log(2.)) - 5.);\n}\n\nivec2 iResolution_i;\nivec2 tier2(ivec2 v) {\n  return ivec2(\n        tier_n(v.x - iResolution_i.x/2),\n        tier_n(v.y - iResolution_i.y/2));\n}\n\nivec2 tier2_s(ivec2 v) {\n  return ivec2(\n        tier_s(v.x - iResolution_i.x/2),\n        tier_s(v.y - iResolution_i.y/2));\n}\n\n#define min4(x1, x2, x3, x4)                  min(min(x1,x2),min(x3,x4))\n#define min8(x1, x2, x3, x4, x5, x6, x7, x8)  min(min4(x1, x2, x3, x4),min4(x5, x6, x7, x8))\n\nvec4 a_mesh8(ivec2 pt1, ivec2 st) {\n  return\n        (T(pt1.xy + ivec2( st.x,  0.)) +\n         T(pt1.xy + ivec2(-st.x,  0.)) +\n         T(pt1.xy + ivec2( 0.,  st.y)) +\n         T(pt1.xy + ivec2( 0., -st.y)) +\n         T(pt1.xy + ivec2( st.x,  st.y)) +\n         T(pt1.xy + ivec2( st.x, -st.y)) +\n         T(pt1.xy + ivec2(-st.x,  st.y)) +\n         T(pt1.xy + ivec2(-st.x, -st.y))) / 8.;\n}\n\nvec4 a_mesh4(ivec2 pt1, ivec2 st) {\n  return\n        (T(pt1.xy + ivec2( st.x,  0.)) +\n         T(pt1.xy + ivec2(-st.x,  0.)) +\n         T(pt1.xy + ivec2( 0.,  st.y)) +\n         T(pt1.xy + ivec2( 0., -st.y))) / 4.;\n}\n\nvec4 a_mesh_h(ivec2 pt1, ivec2 st) {\n  return\n       (T(pt1.xy + ivec2( st.x,  0.)) +\n        T(pt1.xy + ivec2(-st.x,  0.))) / 2.;\n}\n\nvec4 a_mesh_v(ivec2 pt1, ivec2 st) {\n  return\n       (T(pt1.xy + ivec2( 0.,  st.y)) +\n        T(pt1.xy + ivec2( 0., -st.y))) / 2.;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh =\n#if WAVE\n        sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n#else\n        0.;\n#endif\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\n#if SMOOTH\n#define SMOOTH_TIME  fract(tm)\n#else\n#define SMOOTH_TIME  0.\n#endif\n\nfloat randt(ivec2 nx, int t, float y) {\n#if DISPERSE_TIERS\n    float tm = ((100. + iTime*SPEED + y*33.33) + float(nx.x)/100.) / float(t+1);\n#else\n    float tm = (100. + iTime*SPEED);\n#endif\n    float tt = floor(tm), tf = SMOOTH_TIME;\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(SMOOTHNESS, 1.-SMOOTHNESS, tf));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    maxx = iResolution_i.x;\n\n    if (fragCoord_i == ivec2(0)/*iResolution_i/2*/) {\n        fragColor.r =\n            0.;\n            //randt(fragCoord_i, tier_n(pow2ceil(iResolution_i.x)), fragCoord.y);\n        return;\n    }\n\n    ivec2 pow2_mid_adj = ivec2(\n        (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1,\n        (pow2ceil(iResolution_i.y) - iResolution_i.y) >> 1);\n    ivec2 tier = ivec2(\n        tier_n(fragCoord_i.x + pow2_mid_adj.x),\n        tier_n(fragCoord_i.y + pow2_mid_adj.y));\n    ivec2 st = ivec2(1) << tier;\n\n    vec4 avg;\n    int ist;\n    if (st.x < st.y) {\n        st.y = 0; ist = st.x;\n        avg = a_mesh_h(fragCoord_i, st);\n    } else if (st.y < st.x) {\n        st.x = 0; ist = st.y;\n        avg = a_mesh_v(fragCoord_i, st);\n    } else {\n        ist = st.x;\n        avg = a_mesh4(fragCoord_i, st);\n    }\n\n    fragColor.rgb =\n        avg.rgb + vec3(\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y    ) * float(ist) * pow_of_2_adj(iResolution.xy),\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y+0.3) * float(ist) * pow_of_2_adj(iResolution.xy),\n            randt(fragCoord_i, min(tier.x, tier.y), fragCoord.y+0.6) * float(ist) * pow_of_2_adj(iResolution.xy)\n        );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 403, 403, 441], [443, 443, 460, 460, 715], [981, 981, 1038, 1038, 1396]], "test": "untested"}
{"id": "cdVfWw", "name": "poly omina", "author": "nahtelius", "description": "bubububka", "tags": ["2d2dornot2d"], "likes": 1, "viewed": 187, "published": 3, "date": "1698980600", "time_retrieved": "2024-07-30T17:24:17.241178", "image_code": "//112233344445555?????\nfloat s7=2.645751311065;\nfloat s2=1.414213562373;\nfloat plotline(in mat2 pts,in vec2 xy){ //x1,y1,x2,y2\n    xy.x=xy.x*iResolution.x/iResolution.y;\n    float den1=pts[0][0]-pts[1][0];\n    float den2=pts[1][0]-pts[0][0];\n    float up1=xy.x-pts[1][0];\n    float up2=xy.x-pts[0][0];\n    float liney=pts[0][1]*up1/den1+pts[1][1]*up2/den2;\n    return step(1.-(fwidth(xy.x)+fwidth(xy.y))*(.65+0.3*cos(.4*iTime)),1.-abs(liney-xy.y));\n\n}                                                                                \n\nfloat maz(vec2 uv,float t){\n    vec2 mazingpt=vec2(cos(sin(tan(t)+t)+t),sin(cos(tan(pow(2.,1./2.)*t)+t)+t));\n    return plotline(mat2(vec2(sin(t),cos(t))*0.8*tan(0.2*t),mazingpt),vec2(uv.x,uv.y));;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float yaxis=step(abs(uv.x),fwidth(uv.x));\n    float xaxis=step(abs(uv.y),fwidth(uv.y));\n    \n    vec3 col=vec3(0.,0.,0.);\n    int n=300+int(50.*sin(iTime));\n    for(int i=0;i<n;i++){\n        float fl=maz(uv,iTime-float(i)*((s7+s2*tan(.01*s7*s2*iTime))*sin(1./s2*iTime)/float(n))); //s7#@(!@#@!!!,tan@!@#$@(@@\n        vec3 lines=vec3(fl)*(vec3((cos(iTime))*float(i)*(0.5/float(n)),float(i)*(.9/float(n)),(sin(iTime))*float(i)*(0.5/float(n)))+vec3(0.5,0.,1.));\n        col+=lines;\n    }\n    vec2 bound=vec2(-2.+(sin(0.01*iTime)),1.*3.*sin(0.1*iTime));\n    col=mix(vec3(bound.x),vec3(bound.y),col/(bound.y-bound.x));\n    col/=vec3(1.24514); //For ur eys\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    //col+=pfl2;\n    //col+=pfl3;\n    //float fl2=maz(uv,iTime);\n    //float fl3=maz(uv,iTime-.5*sin(iTime));\n    //float tl=plotline(mat2(1,0,1,3),vec2(uv.x,fl2));\n    //vec3 pfl2=vec3(fl2*0.5,0.,fl2);\n    //vec3 pfl3=vec3(fl3*0.8,fl3*0.1,fl3);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 112, 126, 451], [533, 533, 560, 560, 732], [734, 734, 791, 841, 1860]], "test": "untested"}
{"id": "Dl3yzM", "name": "Fast Volumetric Clouds", "author": "Zi7ar21", "description": "Weird idea, if the sun is directly overhead and our noise function is a 2D height map we can get the depth travelled through the volume for free when we sample the height map to get the density\nI get 4 ms frametimes at 1920x1080 on my GTX 1650", "tags": ["approximation", "garbage", "approximate"], "likes": 19, "viewed": 500, "published": 3, "date": "1698973482", "time_retrieved": "2024-07-30T17:24:18.445958", "image_code": "float fBm(vec2 x) {\n    // 4-octave fractal brownian motion (no mipmaps)\n    return\n    0.5333333333333333*textureLod(iChannel0, 0.00390625*x, 0.0).r+\n    0.2666666666666667*textureLod(iChannel0, 0.00781250*x, 0.0).g+\n    0.1333333333333333*textureLod(iChannel0, 0.01562500*x, 0.0).b+\n    0.0666666666666667*textureLod(iChannel0, 0.03125000*x, 0.0).a;\n}\n\nfloat fBm_MipMap(vec2 x) {\n    // 4-octave fractal brownian motion\n    return\n    0.5333333333333333*texture(iChannel0, 0.00390625*x).r+\n    0.2666666666666667*texture(iChannel0, 0.00781250*x).g+\n    0.1333333333333333*texture(iChannel0, 0.01562500*x).b+\n    0.0666666666666667*texture(iChannel0, 0.03125000*x).a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0); // initialize fragColor\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(0.5*iResolution.y); // screen-space uv coords\n\n    vec3 ro = vec3( 0.0, -1.0,  0.0); // ray origin\n    vec3 rd = vec3(uv.x, uv.y, -1.0)/sqrt(dot(uv,uv)+1.0); // ray direction\n\n    //rd = normalize(rd); // normalize ray direction\n\n    // animate camera position\n    //ro.x = sin(3.*iTime); // swing left and right\n    //ro.y += 0.5*cos(3.*iTime); // swing up and down\n    ro.z = -5.0*iTime; // fly forward forever\n\n    const float step_size = 0.5*0.3333333333333333; // fixed step size\n\n    vec3 transmittance = vec3(1); // contribution to total light\n\n    float dithering_offset = texture(iChannel1, 0.0009765625*fragCoord).r; // initial offset to dither sampling\n\n    // main loop\n    for(int i = 0; i < 64; i++) {\n        if(transmittance.r < 0.00390625) break; // if contribution is 1/256 (8-BPC limit) stop\n\n        float t = step_size*(float(i)+dithering_offset); // distance along the camera ray we are sampling\n\n        vec3 x = ro+t*rd; // point along the camera ray we are sampling\n\n        if(x.y < -0.5 || x.y > 0.5) continue; // skip sampling noise above and below the clouds\n\n        //float hmin = -0.2*fBm(x.xz)+0.5; // different noise at the bottom of clouds experiment (looked terrible lol)\n        float hmax = fBm(x.xz)-0.4; // height of the top of the clouds\n        //float hmax2 = fBm(x.xz+0.2*vec2(cos(iTime),sin(iTime)))-0.4; // angled shadow experiment\n\n        float density = max(hmax-abs(x.y),0.0); // density of the volume at the sampled point\n\n        float illumin = 2.0*exp(-5.0*max(hmax-max(x.y,-hmax),0.)); // amount of light recieved at the sampled point\n\n        density *= 50.0; // make the volume more dense\n\n        transmittance *= exp(-step_size*density); // account for loss in contribution (less light makes it through denser reigons)\n\n        fragColor.rgb += step_size*transmittance*density*illumin; // add light to the total\n    }\n\n    vec4 p = vec4(0.0, 1.0, 0.0, 1.0); p = normalize(p);\n\n    float ground_t = -(dot(ro+vec3(0.0,3.0,0.0),p.xyz)-p.y)/dot(rd,p.xyz); // ground plane intersection\n\n    vec3 gx = ro+ground_t*rd; // point the ground ray hit\n\n    float hmax = fBm_MipMap(gx.xz)-0.4; // height of the top of the clouds above the point on the ground\n\n    float ill = 0.2*exp(-2.0*max(hmax-max(gx.y,-hmax),0.)); // amount of light recieved at the point on the ground\n\n    // calculate final color (if the ground ray hit, the ground color\n    // if not, the sky color\n    fragColor.rgb = fragColor.rgb + (ground_t > 0.0 ? transmittance*vec3(0.8)*ill : transmittance*(0.9*max(rd.y,0.)+0.1)*vec3(0.6,0.7,0.8));\n\n    //fragColor.rgb = fragColor.rgb + transmittance*(0.9*max(rd.y,0.)+0.1)*vec3(0.6,0.7,0.8); // calculate the final color (light from sky)\n\n    //fragColor.rgb = max(fragColor.rgb,0.0);\n\n    fragColor.rgb *= 2.0; // exposure\n\n    fragColor.rgb = fragColor.rgb/(fragColor.rgb+1.0); // tonemap\n\n    //fragColor.rgb = tanh(fragColor.rgb); // tonemap\n\n    //fragColor.rgb = clamp(fragColor.rgb,0.,1.); // clamp values\n\n    //fragColor.rgb = pow(fragColor.rgb,vec3(1./2.2)); // undo display gamma\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3yzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 72, 353], [355, 355, 381, 421, 670]], "test": "untested"}
{"id": "ctcyRM", "name": "False Mirror Distortions v3", "author": "ersh", "description": "Use it as a funny mirror.", "tags": ["2d", "fractal", "distortion"], "likes": 1, "viewed": 183, "published": 3, "date": "1698972949", "time_retrieved": "2024-07-30T17:24:19.212906", "image_code": "// Liquid curved mirror.\n// Feel free ro replace the texture in Channel1 to any other texture or video or webcam!\n\n/*\n VARIANT:\n   1 = horizontal + diagonal\n   2 = horizontal + diagonal\n   3 = horizontal + vertical\n   4 = 2 diagonal\n   5 = 2 directions, relative to 0 and 90 deg\n   6 = 2 directions, relative to +/- 45 deg\n   7 = constrained angle around +/- 45 deg\n   8 = 8 directions\n*/\n#define VARIANT 5\n\n// Amount of distortion\n#define SCALE 1.\n\n//// One of {\n//#define TRANSFORM      NONE\n//#define TRANSFORM      LOOP\n//#define TRANSFORM      MIRROR\n#define TRANSFORM      MIRRORX\n//// }\n\nvec4 T(ivec2 x) { return texelFetch(iChannel0, x, 0); }\n\nvec4 T2(vec2 x) {\n#define NONE(X)           X\n#define LOOP(X)           fract(X)\n#define MIRROR(X)         abs((mod(X + 1., 2.)) - 1.)\n#define MIRRORX(X)         vec2(abs((mod(X.x, 2.)) - 1.), abs((mod(X.y + 1., 2.)) - 1.))\n  return texture(iChannel1, TRANSFORM(x), 0.);\n}\n\n#define XYSQ     vec2(1., iResolution.x / iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#if VARIANT == 1\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.x+s2.y, s2.x-s2.y)/1.45;\n#elif VARIANT == 2\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.x+s2.y, s2.x-s2.y)/1.45;\n#elif VARIANT == 3\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.y, s2.x);\n#elif VARIANT == 4\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s1 = vec2(s1.x+s1.y, s1.x-s1.y)/1.45;\n    s2 = vec2(s2.x-s2.y, s2.x+s2.y)/1.45;\n#elif VARIANT == 5\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926 + 3.1415926/2.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 6\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926 - 3.1415926/4.;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926 + 3.1415926/4.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 7\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926/4. - 3.1415926/4.;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926/4. + 3.1415926/4.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 8\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.y, s2.x);\n    vec2 s3 = vec2(\n        T(ivec2(int(fragCoord.x), 5)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 7)).r\n    );\n    vec2 s4 = vec2(\n        T(ivec2(int(fragCoord.x), 6)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 8)).r\n    );\n    s3 = vec2(s3.x+s3.y, -s3.x+s3.y)/1.45;\n    s4 = vec2(s4.x-s4.y,  s4.x+s4.y)/1.45;\n    fragColor = vec4(T2(uv + (s1 + s2 + s3 + s4) / 2.4 * SCALE * XYSQ).rgb, 1.0);\n    return;\n#endif\n    fragColor = vec4(T2(uv + (s1 + s2) / 2. * SCALE * XYSQ).rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nint imod(int a, int b) { return a % b; }\nint iabs(int x) { return x >= 0 ? x : -x; }\nint isign(int x) { return x >= 0 ? 1 : -1; }\nvec4 T(ivec2 x, int maxx) {\n  // return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n\n  //if (x.x < 0) x.x = 0; else if (x.x > maxx) x.x = maxx; return texelFetch(iChannel0, x, 0);\n\n  //return\n  //    x.x < 0 ? texelFetch(iChannel0, ivec2(-x.x, x.y), 0) :\n  //    x.x > maxx ? texelFetch(iChannel0, ivec2(maxx-x.x, x.y), 0) :\n  //    texelFetch(iChannel0, x, 0);\n\n  return\n      x.x < 0 ? texelFetch(iChannel0, ivec2(0, x.y), 0) - texelFetch(iChannel0, ivec2(-x.x, x.y), 0) :\n      x.x > maxx ? texelFetch(iChannel0, ivec2(maxx, x.y), 0) - texelFetch(iChannel0, ivec2(maxx-x.x, x.y), 0) :\n      texelFetch(iChannel0, x, 0);\n\n#define FETCH(X)               texelFetch(iChannel0, X, 0)\n#define SAW(X, MAXX)           ivec2(iabs((imod(X.x + MAXX, MAXX * 2)) - MAXX), X.y)\n#define SGN(X, MAXX)           float(-isign(imod(X.x, MAXX * 2) - MAXX))\n#define MIRROR(FN, X, MAXX)    (FN(SAW(X, MAXX)) * SGN(X, MAXX))\n  // return MIRROR(FETCH, x, maxx);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(min(iResolution.x,iResolution.y)+1.)/log(2.)) - 2.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    //if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 30.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x - 1;\n\n    if (fragCoord_i.x == iResolution_i.x/2) {\n        fragColor.r = 0.;\n            // randt(fragCoord_i, tier_n(pow2ceil(iResolution_i.x)), fragCoord.y)\n            // * iResolution.x * pow_of_2_adj(iResolution.xy) / 2.;\n        return;\n    }\n\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n    //if (st > iResolution_i.x) st = iResolution_i.x;\n\n    fragColor.r =\n        randt(fragCoord_i, tier, fragCoord.y)\n        * float(st)\n        * pow_of_2_adj(iResolution.xy)\n        + (T(ivec2(fragCoord_i.x - st, fragCoord_i.y), maxx).r\n        + T(ivec2(fragCoord_i.x + st, fragCoord_i.y), maxx)).r / 2.;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 612, 612, 650], [652, 652, 669, 669, 924], [984, 984, 1041, 1041, 5243]], "test": "untested"}
{"id": "mtdczN", "name": "Twitter art w/mouse/hue interact", "author": "timmaffett", "description": "-tmm only added hue changing and mouse interaction to @mrange work\nCC0: A rough copy of twitter art\n@tequibo shared their most popular piece\nOriginal: https://x.com/tequibo/status/1720022416452190249", "tags": ["2d", "twitter"], "likes": 5, "viewed": 193, "published": 3, "date": "1698967112", "time_retrieved": "2024-07-30T17:24:20.182314", "image_code": "// Fork of \"A rough copy of twitter art\" by mrange. https://shadertoy.com/view/DtdczN\n// 2023-11-02 23:15:10\n\n// CC0: A rough copy of twitter art\n//  @tequibo shared their most popular piece. I really liked it and thought I\n//  should make a stab at shaderify it. It's kind of there but not really.\n//  Lots of hacking with little thought to try to replicate the original roughly.\n//  Original: https://x.com/tequibo/status/1720022416452190249\n\n//  I really like how something so simple looks very cool\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nfloat tri(vec2 p, float r) {\n  p = -p;\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - r;\n  p.y = p.y + r/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0*r, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat dot2(vec2 p) {\n  return dot(p,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n  if(mouse.x==0.0) mouse.x=0.0001;// no div by 0\n  if(mouse.y==0.0) mouse.y=0.0001;// no div by 0\n  \n  const float hueStepNum = PI;\n  float hueStepDiv = 45.*(mouse.x/mouse.y); //45.+45.*mouse.x;\n  float hueStep = hueStepNum/hueStepDiv;\n  float time=iTime/2.0;\n\n  const float stp = max(0.1, 0.01);\n  const float mx = 1.;\n  const float cnt = 1.0/stp;\n  const float add = 0.05;\n  const vec3 bgcol = HSV2RGB(vec3(0., 0.95, 0.025));\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  const float hue = 0.4666;\n  float tm = TIME;\n  for (float i = mx; i > 0.; i -= stp) {\n    float r0 = i;\n    vec2 p0 = p;\n    mat2 r = ROT(TAU/6.0*sin(tm-2.25*i));\n    vec3 gcol0 = HSV2RGB(vec3(hue*time+(hueStep*2.*i*mouse.y/mouse.x), 1.25*sqrt(r0), mix(1.0, 0.125, sqrt(r0))));\n    p0 *= r;\n    float d0 = tri(p0, i);\n    if (d0 < 0.0) {\n      col = mix(col, gcol0 , mix(1.0, 0.5*dot2(p), r0));\n    }\n\n    float r1 = i-0.5*stp;\n    vec2 p1 = p ;    \n    vec3 gcol1 = HSV2RGB(vec3(hue*time+(hueStep*i*mouse.y/mouse.x), 1.25*sqrt(r1), mix(1.0, 0.125, sqrt(r1))));\n    p1 *= transpose(r);\n    float d1 = tri(p1, i-0.5*stp);\n    if (d1 < 0.0) {\n      col = mix(col, gcol1, mix(1.0, 0.5*dot2(p), r1));\n    }\n  }\n  col *= smoothstep(1., 0.0, length(p));\n  col += bgcol;\n    \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[683, 683, 711, 711, 918], [1072, 1072, 1094, 1094, 1240], [1535, 1535, 1555, 1555, 1576], [1578, 1578, 1635, 1635, 3125]], "test": "untested"}
{"id": "dldyRN", "name": "a function plotter", "author": "kp1197", "description": "function plotter for my own purposes of debugging... thought it might be useful to everyone else too.  was a fun project ~30 minutes.", "tags": ["visualizer", "function", "plotter"], "likes": 7, "viewed": 241, "published": 3, "date": "1698965594", "time_retrieved": "2024-07-30T17:24:21.203584", "image_code": "const float Y_RANGE = 2.0;\nconst float MAJOR_TICKS = 1.0;\nconst float MINOR_TICKS = 0.25;\n\n\n// put your own functions here\n\n// green\nfloat f1(float x) {\n    return pow(x,2.);\n}\n\n// orange\nfloat f2(float x) {\n    return -pow(x,2.);\n}\n\n// blue\nfloat f3(float x) {\n    return sin(x);\n}\n\nvec2 to_plot_space(vec2 p) {\n    return (Y_RANGE * iResolution.x/iResolution.y ) * 2.0 * (p - vec2(0.5, 0.5 * iResolution.y/iResolution.x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xx;\n    uv = to_plot_space(uv);\n    \n    // Interactivity\n    vec2 mouse_uv = iMouse.xy/iResolution.xx;\n    mouse_uv = to_plot_space(mouse_uv);\n    uv = uv - step(1.,iMouse.z) * mouse_uv;\n\n    float edge_distance = 0.01 * Y_RANGE;\n    float smoothstep_left_edge = 1. - edge_distance;\n    \n    float x_axis = smoothstep(smoothstep_left_edge, 1.0, 1.-abs(uv.y));\n    float y_axis = smoothstep(smoothstep_left_edge, 1.0, 1.-abs(uv.x));\n    \n    float major_tick_length = 6. * edge_distance;\n    float major_x_ticks = (1.-step(major_tick_length, abs(uv.y))) * smoothstep(smoothstep_left_edge, 1.0, 1.-abs(mod(uv.x, MAJOR_TICKS)));\n    float major_y_ticks = (1.-step(major_tick_length, abs(uv.x))) * smoothstep(smoothstep_left_edge, 1.0, 1.-abs(mod(uv.y, MAJOR_TICKS)));\n    \n    float minor_tick_length = 2. * edge_distance;\n    float minor_x_ticks = (1.-step(minor_tick_length, abs(uv.y))) * smoothstep(smoothstep_left_edge, 1.0, 1.-abs(mod(uv.x, MINOR_TICKS)));\n    float minor_y_ticks = (1.-step(minor_tick_length, abs(uv.x))) * smoothstep(smoothstep_left_edge, 1.0, 1.-abs(mod(uv.y, MINOR_TICKS)));\n    \n    float grid = smoothstep(smoothstep_left_edge, 1.0, 1.-min(mod(uv.x, MINOR_TICKS), mod(uv.y, MINOR_TICKS)));\n    \n    float plot1 = smoothstep(smoothstep_left_edge, 1.0, 1. - abs(uv.y - f1(uv.x)));\n    float plot2 = smoothstep(smoothstep_left_edge, 1.0, 1. - abs(uv.y - f2(uv.x)));\n    float plot3 = smoothstep(smoothstep_left_edge, 1.0, 1. - abs(uv.y - f3(uv.x)));\n\n    \n    float i = 0.;\n    i = max(x_axis, i);\n    i = max(y_axis, i);\n    i = max(major_x_ticks, i);\n    i = max(major_y_ticks, i);\n    i = max(minor_x_ticks, i);\n    i = max(minor_y_ticks, i);\n    \n    \n    vec3 chart_color = vec3(i);\n    vec3 grid_color = grid * vec3(0.2, 0.2, 0.2);\n    vec3 plot_color_1 = plot1 * vec3(0.1, 0.9, 0.1);\n    vec3 plot_color_2 = plot2 * vec3(0.9, 0.9, 0.1);\n    vec3 plot_color_3 = plot3 * vec3(0.1, 0.1, 0.9);\n    \n    vec3 color = vec3(0.);\n    color = max(color, chart_color);\n    color = max(color, grid_color);\n    color = max(color, plot_color_1);\n    color = max(color, plot_color_2);\n    color = max(color, plot_color_3);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 133, 152, 152, 176], [178, 188, 207, 207, 232], [234, 242, 261, 261, 282], [284, 284, 312, 312, 426], [429, 429, 486, 528, 2763]], "test": "untested"}
{"id": "DttcRN", "name": "Tandot Suns 6̶4̶ 69", "author": "domrally", "description": "A small colorful carpet.\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "pixel", "color", "moire", "tiling", "mini", "tile", "dot", "mosaic", "carpet", "tangent", "short", "tweet", "micro", "halftweet", "golf"], "likes": 4, "viewed": 196, "published": 3, "date": "1698959085", "time_retrieved": "2024-07-30T17:24:22.314613", "image_code": "/*\n69 characters by Dom Mandy\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    o = vec4(0);\n    o[int(tan(dot(i, i)))]++;\n}\n\n\n/*\n64 characters by Dom Mandy in 2023\n*\nvoid mainImage(out vec4 o, vec2 i) {\n    o -= o;\n    o[int(tan(dot(i, i)))]++;\n}\n*/\n\n\n/*\nSEE ALSO\n\nhttps://www.shadertoy.com/view/DscyRf\nhttps://www.shadertoy.com/view/XsKSRy\nhttps://www.shadertoy.com/view/lstGRl\nhttps://www.shadertoy.com/view/XstGDN\nhttps://www.shadertoy.com/view/4tfXW8\nhttps://www.shadertoy.com/view/MlXXR8\nhttps://www.shadertoy.com/view/4tXXRH\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 69, 69, 118]], "test": "untested"}
{"id": "dldyR4", "name": "Portal VFX", "author": "trooper905", "description": "my first shader toy", "tags": ["portal"], "likes": 2, "viewed": 161, "published": 3, "date": "1698956629", "time_retrieved": "2024-07-30T17:24:23.109488", "image_code": "// Fork of \"\" by None. https://shadertoy.com/view/-1\n// 2023-10-29 22:14:00\n\n// cosine based palette, 4 vec3 params\n//This fuction is explained here\n//https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n\n    //Palette Created app\n    //http://dev.thi.ng/gradients/\n    vec3 a = vec3(0.158, 1.102, 0.468);\n    vec3 b = vec3(0.502,0.502,1.000);\n    vec3 c = vec3(0.428, 1.000, 1.008);\n    vec3 d = vec3(0.000, 0.538, 0.312);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n    vec2 uv3 = uv;\n    vec2 uv4 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    vec3 mask = vec3(0.0);\n\n    uv = fract(uv * 1.) - 0.5;\n    vec3 col;\n    float size = .5;\n    float sizeB = .8;\n    float f = 0.;\n    float d = 0.;\n    float sq = abs(sin(sizeB + iTime*.3)/2.5);\n    \n    float bounds = sdBox(uv0,vec2(sizeB,sizeB));\n    //bounds = (pow(.02/ bounds, 1.));\n    //bounds = abs(bounds);\n    bounds = smoothstep(0.05,0.,bounds);\n    //inverts the colors\n    //bounds = .02/bounds;\n    \n    \n    for(float i = 0.0; i < 4.0; i++)\n    {\n        uv = fract(uv * 1.4) - 0.5;\n        uv2 = fract(uv2 *2.) - 0.5;\n        uv2.x = fract(uv2.x -(iTime*.1)) - 0.5;\n        uv3 = fract(uv3 *1.-(iTime*.1)) - 0.5;\n        \n        uv4 = fract(uv4 * .5) - 0.5;\n        \n        float d = sdBox(uv,vec2(.1,.1));\n        float f = sdBox(uv3,vec2(size,size));\n        float e = sdBox(uv0,vec2(size-.2,size-.2));\n        \n        float y = sdBox(uv3,vec2(sq,sq));\n        float z = sdBox(uv4,vec2(sq,sq));\n        \n        \n        z = abs(z);\n        z = smoothstep(0.,.1,z);\n        z = (.02/z);\n        \n        y = abs(y);\n        y = smoothstep(0.,.1,y);\n        y = .005/y;\n        \n        d += length(d) * exp(length(uv0));\n        //f += length(uv*.25) * exp(length(uv0));\n        \n        e += length(f) * exp(length(uv0));\n        e += d* exp(length(uv0));\n        \n        f = length(f);\n        \n        float tri = sdEquilateralTriangle(uv0,.7);\n        float di = sdRhombus(uv0,vec2(sq*2.,sq*2.));\n        \n        di = abs(di);\n        di = smoothstep(0.,.1,di);\n        di = .01/di;\n        \n        d = sin(d*6. + iTime)/3.;\n        d = abs(d);\n        d = pow(0.06 / d, 1.0);\n        \n        float g =(pow(0.03/ f, 2.));\n        f = asin(pow(0.01/ f, 1.));\n        //f = exp(f);\n        \n        e = (pow(0.03/ e, 1.));\n\n        vec3 col = palette(length(uv0) + iTime*.5);\n        //col -= palette(length(z));\n       \n\n        float final = (.01/(d/z)+di);\n        //float final = z;\n       \n        mask += final;\n        finalColor += (col* final)*bounds;\n    }\n    \n  \n    //fragColor = vec4(mask,1.0);\n    fragColor = vec4(finalColor,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 193, 216, 278, 480], [482, 482, 519, 519, 599], [601, 601, 643, 643, 669], [671, 671, 725, 725, 934], [936, 936, 965, 965, 993], [994, 994, 1036, 1036, 1217], [1219, 1219, 1276, 1276, 3536]], "test": "untested"}
{"id": "DtdczN", "name": "A rough copy of twitter art", "author": "mrange", "description": "CC0: A rough copy of twitter art\n@tequibo shared their most popular piece. I really liked it and thought I\nshould make a stab at shaderify it. It's kind of there but not really.\nOriginal: https://x.com/tequibo/status/1720022416452190249", "tags": ["2d", "twitter"], "likes": 23, "viewed": 273, "published": 3, "date": "1698955654", "time_retrieved": "2024-07-30T17:24:24.016064", "image_code": "// CC0: A rough copy of twitter art\n//  @tequibo shared their most popular piece. I really liked it and thought I\n//  should make a stab at shaderify it. It's kind of there but not really.\n//  Lots of hacking with little thought to try to replicate the original roughly.\n//  Original: https://x.com/tequibo/status/1720022416452190249\n\n//  I really like how something so simple looks very cool\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nfloat tri(vec2 p, float r) {\n  p = -p;\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - r;\n  p.y = p.y + r/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0*r, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat dot2(vec2 p) {\n  return dot(p,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  const float stp = max(0.1, 0.01);\n  const float mx = 1.;\n  const float cnt = 1.0/stp;\n  const float add = 0.05;\n  const vec3 bgcol = HSV2RGB(vec3(0., 0.95, 0.025));\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  const float hue = 0.4666;\n  float tm = TIME;\n  for (float i = mx; i > 0.; i -= stp) {\n    float r0 = i;\n    vec2 p0 = p;\n    mat2 r = ROT(TAU/6.0*sin(tm-2.25*i));\n    vec3 gcol0 = hsv2rgb(vec3(hue, 1.25*sqrt(r0), mix(1.0, 0.125, sqrt(r0))));\n    p0 *= r;\n    float d0 = tri(p0, i);\n    if (d0 < 0.0) {\n      col = mix(col, gcol0 , mix(1.0, 0.5*dot2(p), r0));\n    }\n\n    float r1 = i-0.5*stp;\n    vec2 p1 = p ;    \n    vec3 gcol1 = hsv2rgb(vec3(hue, 1.25*sqrt(r1), mix(1.0, 0.125, sqrt(r1))));\n    p1 *= transpose(r);\n    float d1 = tri(p1, i-0.5*stp);\n    if (d1 < 0.0) {\n      col = mix(col, gcol1, mix(1.0, 0.5*dot2(p), r1));\n    }\n  }\n  col *= smoothstep(1., 0.0, length(p));\n  col += bgcol;\n    \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[573, 573, 601, 601, 808], [962, 962, 984, 984, 1130], [1425, 1425, 1445, 1445, 1466], [1468, 1468, 1525, 1525, 2606]], "test": "untested"}
{"id": "ctdczN", "name": "twisted tetrahedron", "author": "cyperus", "description": ":)", "tags": ["3d", "sdf", "stereographic", "hypersphere"], "likes": 0, "viewed": 186, "published": 3, "date": "1698955556", "time_retrieved": "2024-07-30T17:24:25.056282", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"twisted tetrahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n//  - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 8.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 600;\nfloat RAY_STEP_FACTOR3 = 0.333;\nconst float RAY_PRECISION = 0.00001;\n\n// teraheder\nconst int PS_f= 4;\nconst int PS_e_f= 3;\nconst float PS_a0 = 8.;\n\n// torus\nconst float J1_sh_a0 = -1.0;\nconst float J1_sh_a1 = -0.4;\nconst int   J1_sh_f1 = 2*PS_e_f;\nfloat J1_sh_pa1 = 0.03;\nconst int   J1_to_c1 = 4*PS_e_f;\nconst int   J1_to_f1 = 2*PS_e_f;\nconst float J1_to_pa1 = 0.;\n\n// texture\nconst int   TEX_MODE = 1; // 0: white, 1: stripes, 2: normal, 3: tetra_cell_id\nconst bool  TEX_UV_ON = true;\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(1*PS_e_f, 1*PS_e_f);\n\n// fog\nconst bool  FOG_ON = true;\nconst float FOG_DENSITY = 0.003;\n\nfloat map(in vec3 p, out vec4 mat) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges per face\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    p = rot4Dz( p, iTime/20., sqrt(abs(PS_a0)));\n    float a_y = 2.*PI* iTime/30.; p.zx = cmul(p.zx, vec2(cos(a_y),sin(a_y)));\n    float a_z = -2.*PI* iTime/30.; p.xy = cmul(p.xy, vec2(cos(a_z),sin(a_z)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n  \n    // projection from n cells to 1 cell. \n    pn = tetra_cells(pn, cell_id, sr);\n    \n    // invers stereographic projection\n    z = pn.xy/(1.-pn.z);\n    z = cTeraPolyArc2disk(z);\n\n    /// r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    float fracu = 1.0;\n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    ////fractal level 1: 2Djulia realaxis-translation,fraction,rotation\n    float sh1 = J1_sh_a0;\n    float to1 = au*float(J1_to_c1)/float(J1_to_f1);\n    sh1 += J1_sh_a1*(1.-pulsecollision(float(J1_sh_f1),au/PI, J1_sh_pa1, 0.5));\n    to1 += J1_to_pa1;  \n    z = crpt(z, to1, float(J1_to_f1), sh1);\n    fracu *= float(J1_sh_f1);\n\n    // distance estimation\n    float d = log(length(z));\n    \n    //st_assert( d != INF, 0 ); // Show the +INF singularity.\n    if (d == INF) {d = 1.;} // Step through the singularity.\n    \n    mat.x = cell_id; mat.yz = z; mat.w = au *fracu; // platonic solid cell_id, metatorus complex plane, metatorus angle_u\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 rescol, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field\n    vec4 trap; // data from surface intersection point\n    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos, trap );\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec4 tmp; // dummie\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy,tmp) - map(p-e.xyy,tmp),\n\t\tmap(p+e.yxy,tmp) - map(p-e.yxy,tmp),\n\t\tmap(p+e.yyx,tmp) - map(p-e.yyx,tmp) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\tp.xz = crot(p.xz,- 0.1 * time);\n\treturn p.xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation\n    J1_sh_pa1 *= iTime;\n   \n    // normalized coords\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // camera viewport --> worldspace\n    vec3 ro = vec3(0,0,-CAM_DIST);\n    vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n    \t ro = transform(ro,iTime);\n\t     rd = normalize(transform(rd,iTime));\n\n    // ray\n    vec4 mat = vec4(0.0); // material-data: vec4(float cell_id, vec2 complex plane, float angle-u)\n    float px = 2.0/( iResolution.y*CAM_FLE );\n    float t = intersect( ro, rd, mat, px ); // distance hit ray surface\n    \n    // color\n    vec3 col_sun = vec3(1.,1.,0.8);\n    vec3 col_sky = vec3(0.8,0.8,1.);  \n    vec3 col_nebula = (rd.y>0. ? 1. : 0.96) * srgb2rgb(texture(iChannel0, vec3(rd.x,abs(rd.y),rd.z)).rgb);\n    // background-color    \n    vec3 bg_col = col_sky * col_nebula;\n\n    vec3 col = vec3(1,1,0); // init, test-color\n    // no hit -> sky\n    if (t < 0.0) {\n        col = bg_col;\n    }\n    // hit -> object surface\n    else {\n    \t// surface properties\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal( p, 0.001);        \n        // object id\n        float obj_id = mat.x;\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = 0.5*mat.w/PI;\n        mat_uv.y = atan(mat.z,mat.y)/PI;\n        // uv-texture\n        col = (TEX_MODE == 1) ? h2rgb(abs(mat_uv.y))       // stripes\n            : (TEX_MODE == 2) ? 0.6*n+vec3(0.4)            // normal\n            : (TEX_MODE == 3) ? h2rgb(obj_id/float(PS_f))  // tetra_cell_id\n            : vec3(1.);\n        col *= 2.; // light emitter\n        // uv-grid (TODO: not orthogonal!)\n        if(TEX_UV_ON) {\n            mat_uv *= PI*TEX_UV_SUBDIV;\n            col *= 0.5+ 0.5*smoothstep(-TEX_UV_SHARPNESS,TEX_UV_SHARPNESS, sin(mat_uv.x)*sin(mat_uv.y) );\n        }        \n        // lighting\n        // point_light\n        vec3 point_lo = vec3(0, -10000, 0);\n        vec3 point_ld = normalize(point_lo - p);\n        // cubemap light\n        vec3 col_nebula_ref = srgb2rgb(texture(iChannel0, reflect(rd, n)).rgb);\n        // Phong: ambient- diffuse- specular- light reflections\n        col = 0.25 * col * col_sky\n            + 0.25 * col * col_nebula_ref\n            + 0.25 * col * col_sun * clamp(dot(point_ld, n), 0., 1.)\n            + 0.25 * col * col_sun * pow(clamp(dot(reflect(point_ld, n), -rd), 0., 1.), 10.);\n        // fresnel\n        col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * bg_col;\n    }\n    // fog\n    if(FOG_ON) col = mix(col, bg_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));\n    // gamma correction\n    fragColor = vec4(rgb2srgb(col),1.);\n}\n", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  /* (z*e^ia)^p-x0 */\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cTeraPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 15; // poles\n    const vec2[NUM_j] rf = vec2[]\n    (vec2(-0.4534, -0.8913)\n    ,vec2( 0.5001,  0.8660)\n    ,vec2(-1.0000,  0.0001)\n    ,vec2( 0.5008, -0.8656)\n    ,vec2(-0.5452,  0.8383)\n    ,vec2( 0.1901,  0.9818)\n    ,vec2( 0.9875, -0.1576)\n    ,vec2(-0.9856, -0.1691)\n    ,vec2( 0.4224, -0.9064)\n    ,vec2( 0.5738,  0.8190)\n    ,vec2(-0.9995,  0.0311)\n    ,vec2( 0.4858,  0.8741)\n    ,vec2( 0.5760, -0.8175)\n    ,vec2(-1.0000, -0.0061)\n    ,vec2( 0.4959, -0.8684));\n    \n    const vec2[NUM_j] rw = vec2[]\n    (vec2( 0.2728,  0.0   )  \n    ,vec2( 0.0003,  0.0126)\n    ,vec2(-0.0016, -0.0121)\n    ,vec2(-0.0172,  0.0324)\n    ,vec2( 0.1417, -0.4629)\n    ,vec2(-0.4681, -0.2288)\n    ,vec2(-0.2433,  0.2822)\n    ,vec2( 0.1996, -0.0082)\n    ,vec2( 0.2884, -0.0353)\n    ,vec2(-0.0666,  0.1824)\n    ,vec2(-0.0357, -0.1136)\n    ,vec2(-0.1091,  0.0396)\n    ,vec2(-0.0831,  0.2627)\n    ,vec2( 0.0598, -0.0284)\n    ,vec2( 0.0597,  0.0760));\n\n    const vec2[NUM_j] rz = vec2[]\n    (vec2(-0.239570, -0.459171)\n    ,vec2( 0.354172,  0.611300)\n    ,vec2(-0.706487,  0.001072)\n    ,vec2( 0.356785, -0.606740)\n    ,vec2(-0.277869,  0.437059)\n    ,vec2( 0.047259,  0.573454)\n    ,vec2( 0.515842, -0.066306)\n    ,vec2(-0.591622, -0.166501)\n    ,vec2( 0.221135, -0.605193)\n    ,vec2( 0.413545,  0.494105)\n    ,vec2(-0.671697,  0.057599)\n    ,vec2( 0.309337,  0.611574)\n    ,vec2( 0.414577, -0.491758)\n    ,vec2(-0.695342, -0.019940)\n    ,vec2( 0.334074, -0.612218));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++)\n    {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zd += zj; // sum denominator\n        zn += cmul(rf[j], zj); // sum nominator\n    }\n    return cdiv(zn, zd);;\n}\n\n/// 4D transformation\nvec3 rot4Dz(in vec3 p, in float t, in float r_inv){\n    float a = 2.*PI*t;\n    p /= r_inv;\n    float rn = length(p);\n    float rn2 = dot(rn,rn);\n    vec2 zw = cmul(vec2(2.*p.z, rn2-1.),vec2(cos(a),sin(a)));\n    p = vec3(2.*p.xy,zw.x)/(rn2+1.-zw.y);\n    \n    return r_inv * p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 tetra_cells(in vec3 p, out float cell_id, out float sr){\n\t//// tetrahedron (bounded by a cube)\n\t// cells: A,B,C,D\n\t// cell walls defined by the face_normal\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    \n    // map n-cells to 1-cell by rotation\n    // rotation angles\n    const float a45 = PI/4.;             // 45° \n    const float a35 = atan(sqrt(8.))/2.; // 35.264°\n    const float a30 = PI/6.;             // 30°\n    \n    const vec2 ei_a45 = vec2(cos(a45), sin(a45));\n    const vec2 ei_a35 = vec2(cos(a35), sin(a35));\n    const vec2 ei_a30 = vec2(cos(a30), sin(a30));\n    \n    vec2 ei_y = ei_a45;   \n    vec2 ei_x = ei_a35;\n    vec2 ei_z = ei_a30;\n    // symmetries\n    if(nBA && nCA && nDA) //inside cell A\n\t{\n\t\tcell_id =  0.;\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if( nCB && nDB && !nBA) //inside cell B\n\t{\n\t\tcell_id =  1.;\n\t\tei_y   *= -1.; // a = -3.*45°\n        ei_x.y *= -1.; // a = -35.264°\n\t}\n\telse if(!nCA && !nCB && nDC) //inside cell C\n\t{\n\t\tcell_id =  2.;\n\t\tei_y.x *= -1.; // a = +3.*45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\telse if(!nDA && !nDB && !nDC)//inside cell D\n\t{\n\t\tcell_id =  3.;\n\t\tei_y.y *= -1.; // a = -45°\n\t\tei_z.y *= -1.; // a = -30°\n\t}\n\tp.zx = cmul(p.zx,ei_y); // y-axis\n\tp.yz = cmul(p.yz,ei_x); // x-axis\n\tp.xy = cmul(p.xy,ei_z); // z-axis\n\t// 3 edges per face, non cyclic\n\tsr = 3.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/articles/intersectors/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// colorspace transformations\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdczN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1321, 1321, 1357, 1375, 3202], [3204, 3204, 3275, 3275, 4198], [4200, 4200, 4245, 4245, 4455], [4457, 4457, 4499, 4525, 4723], [4725, 4725, 4780, 4802, 7460]], "test": "untested"}
{"id": "cldcz4", "name": "Ocular Harpsichord", "author": "misha", "description": "See sound as colors!\n\nReplace the Soundcloud texture in iChannel0 of Buffer A to explore different songs or change it to microphone.", "tags": ["microphone"], "likes": 1, "viewed": 167, "published": 3, "date": "1698950213", "time_retrieved": "2024-07-30T17:24:25.963856", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 freqRGB = texture(iChannel0,vec2(0.5,0.5)).rgb;\n    vec4 barOverlay = texture(iChannel1,uv);\n\n    // Set the output color (fill the entire texture)\n    fragColor = vec4(mix(freqRGB,barOverlay.rgb,barOverlay.a),1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float resolutionX = iResolution.x;\n    \n    float wavelength = mapWavelength(fragCoord.x / resolutionX);\n    \n    // Fetch the spectrum color\n    float spectrum = texture(iChannel0, vec2(fragCoord.x / resolutionX, 0.25 )).x;\n    \n    // Get the CIE XYZ color matching functions\n    vec3 cieXYZ = cieColorMatchingFunction(wavelength);\n    \n    // Output the product of spectrum and CIE functions\n    fragColor = vec4(cieXYZ * spectrum, spectrum);\n}\n\n// https://soundcloud.com/cure88200/440hz_sine_wave\n// https://soundcloud.com/lindstedt/55-110-220-440-hz-sine-wave\n// https://soundcloud.com/stagedoorpro/gustav-mahler-symphony-no-3-dm-brazilian-symphonic-orchestra\n// https://soundcloud.com/keno-leon-58106006/sinewavetonescale\n// https://soundcloud.com/manoo-cher/c-major-scale\n// https://soundcloud.com/bradingrao/c-major-scale-flute\n// https://soundcloud.com/kenzaisounds/shepard-tone", "buffer_a_inputs": [{"id": 35155, "src": "https://soundcloud.com/stagedoorpro/gustav-mahler-symphony-no-3-dm-brazilian-symphonic-orchestra", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Approximation of CIE 1931 color matching functions\nvec3 cieColorMatchingFunction(float wavelength) {\n    float x, y, z;\n\n    // xBar approximation\n    x = exp(-pow((wavelength - 595.8) / 33.33, 2.0));\n\n    // yBar approximation\n    y = exp(-pow((wavelength - 556.3) / 31.38, 2.0));\n\n    // zBar approximation\n    z = exp(-pow((wavelength - 449.8) / 36.06, 2.0));\n\n    return vec3(x, y, z);\n}\n\nvec3 convertXYZtoRGB(vec3 XYZ) {\n    // Convert XYZ to linear RGB (simplified D65 white point and sRGB primaries)\n    mat3 XYZ_to_RGB = mat3( 3.2406, -1.5372, -0.4986,\n                           -0.9689,  1.8758,  0.0415,\n                            0.0557, -0.2040,  1.0570);\n    vec3 linearRGB = XYZ_to_RGB * XYZ;\n\n    // Gamma correction for sRGB\n    vec3 gammaCorrectedRGB = pow(linearRGB, vec3(1.0 / 2.2));\n    \n    return gammaCorrectedRGB;\n}\n\nfloat mapWavelength(float x) {\n    // Assuming the spectrum's wavelengths are linearly mapped to [380, 780] nm\n    // return 420.0 + x*(720.0 - 420.0);\n    return 420.0 + log2(x+1.0)*(720.0 - 420.0);\n    //return 420.0 + mod(log2(x+1.0) * 1234.0, (700.0 - 420.0));\n}", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float resolution = 512.0;\n    vec3 XYZ = vec3(0.0);\n\n    // Sum the results from Buffer A\n    for (float i = 0.0; i < 1.0; i+=1.0/resolution) {\n        XYZ += texture(iChannel0, vec2(i, 0.5)).xyz;\n    }\n\n    // Normalize the XYZ values (assuming equal energy white point)\n    XYZ /= resolution;\n    \n    XYZ *= 2.0;\n\n    // Convert XYZ to linear RGB and apply gamma correction (as before)\n    vec3 RGB = convertXYZtoRGB(XYZ);\n\n    // Set the output color (fill the entire texture)\n    fragColor = vec4(RGB, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 XYZ = texture(iChannel0, vec2(uv.x, 0.25 ));\n    \n    vec3 RGB = convertXYZtoRGB(XYZ.xyz);\n    \n    fragColor = vec4(RGB,float(XYZ.w > (uv.y * 2.0)));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 327]], "test": "untested"}
{"id": "cldyR4", "name": "peaky icosahedron", "author": "FabriceNeyret2", "description": "mouse controls camera. \ndual of https://shadertoy.com/view/mlcyzN", "tags": ["raymarching", "sdf", "short", "golf"], "likes": 10, "viewed": 218, "published": 3, "date": "1698946160", "time_retrieved": "2024-07-30T17:24:26.726816", "image_code": "// variant of \"peaky dodecahedron\" https://shadertoy.com/view/mlcyzN\n// ( icosahedron is the dual )\n\n#define rot(a)    mat2(cos((a)+vec4(0,33,11,0)))              // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,a,l, P = .628; // pi/5\n    vec3  R = iResolution, \n          D = normalize( 2.*vec3(U, -R.y) - R ),              // ray direction\n          p = vec3(0,0,12), q,                                // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )           // march scene\n        q = p, \n        q.yz *= rot(C.y),                                     // rotations\n        q.xz *= rot(C.x),\n        l = length(q.xy),a = atan(q.y,q.x), q.z<0. ? a += P, q.z = -q.z :a,// top down symetry +rot pi/5     \n        q.xy = l * cos( mod(a,P*2.)-P + vec2(0,33) ),         // 5-fold symmetry\n        q.xz *= rot( abs(atan(q.z,l))<.7 ? 1.26 : .55  ),     // tilt 1.26 = pi/2 - pi/10\n        t = length(q.xy)+.2*q.z-1.,                           // draw pick\n     // t = min(t, length(q)-2.5),                            // uncomment: mine\n     // t = max(t, 2.5-length(q)),                            // uncomment: picks alone\n        p += .2*t*D;                                          // step forward = dist to obj  \n \n    O *= O*O*O*2.;                                            // color scheme\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 212, 212, 1498]], "test": "untested"}
{"id": "mlcyzN", "name": "peaky dodecahedron", "author": "FabriceNeyret2", "description": "mouse controls camera. \n", "tags": ["raymarching", "sdf", "short", "golf"], "likes": 17, "viewed": 252, "published": 3, "date": "1698944834", "time_retrieved": "2024-07-30T17:24:27.989440", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,33,11,0)))                // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,a,l, P = .628; // pi/5\n    vec3  R = iResolution, \n          D = normalize( 2.*vec3(U, -R.y) - R ),              // ray direction\n          p = vec3(0,0,12), q,                                // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )            // march scene\n        q = p, \n        q.yz *= rot(C.y),                                     // rotations\n        q.xz *= rot(C.x),\n        l = length(q.xy),a = atan(q.y,q.x), q.z<0. ? a += P, q.z = -q.z :a,// top down symetry +rot pi/5     \n        abs(atan(q.z,l)) < 1.\n          ? q.xy = l * cos( mod(a,P*2.)-P + vec2(0,33) ),     // 5-fold symmetry\n            q.xz *= rot(1.12), q                              // tilt 1.12 = pi/2 - pi/5\n          : q = q.yxz,                                        // top-down face\n        t = length(q.xy)+.2*q.z-1.,                           // draw pick\n     // t = min(t, length(q)-2.),                             // uncomment: mine\n     // t = max(t, 2.-length(q)),                             // uncomment: picks alone\n     // t = q.z-2.,                                           // uncomment: shitty dodecahedron :-)\n        p += .4*t*D;                                          // step forward = dist to obj  \n \n    O *= O*O*O*2.;                                            // color scheme\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 1605]], "test": "untested"}
{"id": "ml3yR4", "name": "Study of exploding random colors", "author": "timmaffett", "description": "Adding a little movement to https://shadertoy.com/view/dldyRn by @Elsio. \nmouse modifies exploding/imploding directions", "tags": ["color", "random", "study", "pattern"], "likes": 2, "viewed": 139, "published": 3, "date": "1698934842", "time_retrieved": "2024-07-30T17:24:28.996747", "image_code": "// Fork of \"Estudo de cores aleatorias \" by Elsio. https://shadertoy.com/view/dldyRn\n// 2023-11-02 14:15:57\n\n#define cor(a) (cos(a * 6.3 + vec3(0, 23., 21.) * a) * .5 + .5)\n\n// tks Blackle!\n#define FBI floatBitsToInt\nfloat hash(vec2 p) {\n    float a = p.x, b = p.y;\n    int x = FBI(cos(a)) ^ FBI(a),\n        y = FBI(cos(b)) ^ FBI(b);\n    return float((x * x + y) * (y * y - x) + x) / 2.14e9;\n}\n\n#define EXPLOSION_RATE     8.0\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    \n    vec2 uvTest = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec2 R = iResolution.xy; o *= 0.;\n    u = 36. * (u - R / 2.) / R.y;\n        \n    float time = floor(iTime*EXPLOSION_RATE);\n    \n    vec2 time2 = vec2(sign(mouse.x)*sign(uvTest.x)*time, sign(mouse.y)*sign(uvTest.y)*time);\n    \n    vec3 p  = vec3(u, 1),\n         q  = fract(p) - .5,\n         id = floor(p) - .5;\n         \n    float z = 1. - length(q.xy);\n    \n    o.rgb += z * cor(hash(id.xy-time2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3yR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 237, 237, 393], [427, 427, 466, 466, 1045]], "test": "untested"}
{"id": "DlccR4", "name": "False Mirror Distortions", "author": "ersh", "description": "Use it as a funny mirror.", "tags": ["2d", "fractal", "distortion"], "likes": 1, "viewed": 239, "published": 3, "date": "1698923605", "time_retrieved": "2024-07-30T17:24:30.209504", "image_code": "// Liquid curved mirror.\n// Feel free ro replace the texture in Channel1 to any other texture or video.\n\n/*\n   1 = horizontal + diagonal, border pinned\n   2 = horizontal + diagonal, center pinned\n   3 = horizontal + vertical, center pinned\n   4 = 2 diagonal, center pinned\n   5 = 2 directions, relative to 0 and 90 deg\n   6 = 2 directions, relative to +/- 45 deg\n   7 = constrained angle around +/- 45 deg\n   8 = 8 directions\n*/\n\n#define VARIANT 8\n\n#define SCALE 0.7\n\n\n\nint maxx;\nint mid;\n\nvec4 T(ivec2 x) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\nvec4 TM(ivec2 x) {\n  return T(x) - T(ivec2(mid, x.y)) * 0.7;\n}\n\nvec4 T2(vec2 x) {\n  x.x = 1. - x.x;\n  return texture(iChannel1, x, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    maxx = int(iResolution.x)-1;\n    mid = int(iResolution.x)>>1;\n    float pix = 1.5 / iResolution.y;\n#if VARIANT == 1\n    vec2 s1 = vec2(\n        T(ivec2(int(fragCoord.x), 1)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        T(ivec2(int(fragCoord.x), 2)).r,\n        T(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.x+s2.y, s2.x-s2.y)/1.45;\n#elif VARIANT == 2\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.x+s2.y, s2.x-s2.y)/1.45;\n#elif VARIANT == 3\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.y, s2.x);\n#elif VARIANT == 4\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s1 = vec2(s1.x+s1.y, s1.x-s1.y)/1.45;\n    s2 = vec2(s2.x-s2.y, s2.x+s2.y)/1.45;\n#elif VARIANT == 5\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926 + 3.1415926/2.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 6\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926 - 3.1415926/4.;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926 + 3.1415926/4.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 7\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    float a1 = T(ivec2(int(fragCoord.x), 0)).r * 3.1415926/2. - 3.1415926/4.;\n    float cs1 = cos(a1), sn1 = sin(a1);\n    s1 = vec2(cs1 * s1.x + sn1 * s1.y, -sn1 * s1.x + cs1 * s1.y);\n\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    float a2 = T(ivec2(int(fragCoord.x), 5)).r * 3.1415926/2. + 3.1415926/4.;\n    float cs2 = cos(a2), sn2 = sin(a2);\n    s2 = vec2(cs2 * s2.x + sn2 * s2.y, -sn2 * s2.x + cs2 * s2.y);\n#elif VARIANT == 8\n    vec2 s1 = vec2(\n        TM(ivec2(int(fragCoord.x), 1)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 3)).r\n    );\n    vec2 s2 = vec2(\n        TM(ivec2(int(fragCoord.x), 2)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 4)).r\n    );\n    s2 = vec2(s2.y, s2.x);\n    vec2 s3 = vec2(\n        TM(ivec2(int(fragCoord.x), 5)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 7)).r\n    );\n    vec2 s4 = vec2(\n        TM(ivec2(int(fragCoord.x), 6)).r,\n        TM(ivec2(int(fragCoord.y/iResolution.y*iResolution.x), 8)).r\n    );\n    s3 = vec2(s3.x+s3.y, -s3.x+s3.y)/1.45;\n    s4 = vec2(s4.x-s4.y,  s4.x+s4.y)/1.45;\n    fragColor = vec4(T2(uv + (s1 + s2 + s3 + s4) / 2.4 * SCALE).rgb, 1.0);\n    return;\n#endif\n    fragColor = vec4(T2(uv + (s1 + s2) / 2. * SCALE).rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(iResolution.x+1.)/log(2.)) - 3.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\n//#define MOD(X)  ((X + iResolution_i.x) % iResolution_i.x)\n#define MOD(X)  X\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 9.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x-1;\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n\n    float c = randt(fragCoord_i, tier, fragCoord.y) * float(st) * pow_of_2_adj(iResolution.xy);\n    //if (tier < tier_n(pow2ceil(iResolution_i.x))-2) {\n        c += (T(ivec2(MOD(fragCoord_i.x - st), fragCoord_i.y), maxx).r + T(ivec2(MOD(fragCoord_i.x + st), fragCoord_i.y), maxx)).r / 2.;\n    //}\n    fragColor = vec4(vec3(c), 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlccR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 490, 507, 507, 582], [583, 583, 601, 601, 645], [647, 647, 664, 664, 720], [722, 722, 779, 779, 5102]], "test": "untested"}
{"id": "cttcRH", "name": "Breathing Terrain2 + smooth", "author": "ersh", "description": "Breathing Terrain (meditation).\nThis shader demonstrates generation of smooth random functions, over space and time.", "tags": ["2d", "fractal", "terrain", "generative", "meditaion"], "likes": 2, "viewed": 111, "published": 3, "date": "1698909392", "time_retrieved": "2024-07-30T17:24:31.129046", "image_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\nvec4 TM(ivec2 x, int maxx, int mid) {\n  return T(x, maxx) - T(ivec2(mid, x.y), maxx)*0.5;\n}\n\nfloat stylize(float cc, float tf, float ts) {\n    float pw = pow(cc,0.8);\n    float cr = (floor(pw*30. + ts)-ts)/30. + fract(cc*30. + tf)/20.;\n    return cr;\n}\n\nfloat stylize2(float cc, float tf, float ts) {\n    float pw = cc * 1.06;//pow(cc,0.8);\n    float cr = (floor(pw*5. + ts)-ts)/5. + fract(cc*10. + tf);\n    return cr;\n}\n\nfloat atan2f(vec2 v, float sc, float sh, float sha) {\n    float a = v.y != 0. ? atan(v.x / v.y) : 3.14159265358/2.;\n    return fract((a / 3.1415926 + sha) * sc + sh);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//#define SMOOTH(BIG, SMALL, DIFF)    smoothstep(0., 1., ((BIG) - (SMALL))*pix)\n#define SMOOTH(BIG, SMALL, DIFF)    clamp(((BIG) - (SMALL))/(DIFF), 0., 1.)\n#define BLEND(COLOR, OP)  \\\n  float addOp = (1. - fragColor.a) * (OP); \\\n  fragColor += vec4((COLOR) * vec3(addOp), addOp); \\\n// EOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int maxx = int(iResolution.x)-1;\n    int imid = int(iResolution.x)>>1;\n    float pix = 1.5 / iResolution.y;\n    fragColor = vec4(0.);\n\n    // Land\n    float c = T(ivec2(int(fragCoord.x), 3), maxx).r * 1.5 - T(ivec2(imid, 3), maxx).r*0.6 + 0.35;\n    if (c > uv.y) {\n        float cc = uv.y - c + 0.8;\n        float op = SMOOTH(c, uv.y, pix);\n        BLEND(vec3(stylize(cc, 0., 0.))*vec3(0.7, 0.5, 0.3), op);\n        if (op == 1.) return;\n    }\n\n    vec2 cs;\n    float d, r, rpw;\n\n    // Sun\n    cs = iResolution.xy*vec2(0.75, 0.65);\n    d = distance(fragCoord.xy, cs);\n    rpw = pow(T(ivec2(int(atan2f(fragCoord - cs, 5., iTime / 40., 0.5)*iResolution.x), 2), maxx).r + 0.5, 5.) * 5. + 0.4;\n    r = min(iResolution.x, iResolution.y) * 0.17 * rpw;\n    if (d < r) {\n        float cc = d / r;\n        float op = SMOOTH(r, d, 1.5 * rpw);\n        BLEND(vec3(vec2(stylize(1.-cc*0.2, iTime/3., iTime/5.)), 1.-cc), op);\n        if (op == 1.) return;\n    }\n    \n    // Stars\n    for (int i = 0; i < 20; i++) {\n        cs = iResolution.xy * (hash21(float(i+1)) * vec2(1., 0.6) + vec2(0, 0.4));\n        d = distance(fragCoord.xy, cs);\n        rpw = pow(T(ivec2(int(atan2f(fragCoord - cs, 2., -iTime * (hash11(float(i+1))-0.5)/10., float(i*2))*iResolution.x), 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        float rpwMid = pow(T(ivec2(imid, 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        r = min(iResolution.x, iResolution.y) * max(0.1 * rpw - rpwMid * 0.02, rpwMid * 0.04);\n        if (d < r) {\n            float cc = d / r;\n            float op = SMOOTH(r, d, (1. + 0.1/pix) * rpw);\n            BLEND(vec3(stylize2(1.-cc*0.3, iTime*1.5, iTime)), op);\n            if (op == 1.) return;\n        }\n    }\n\n    // Cloud\n    for (int n = 0; n < 4; n += 1) {\n        float h = (T(ivec2(fragCoord.x, 2), maxx).r + 0.0) * 0.1;\n        cs = iResolution.xy*vec2(0.45 - float(n) * 0.05, 0.45 + h);\n        d = distance(fragCoord.xy, cs);\n        float sc = smoothstep(0.41 + h, 0.44 + h, uv.y);\n        //float sc = 1.-pow(1.-smoothstep(0.41, 0.44, uv.y), 2.);\n        float rpw = (T(ivec2(int(atan2f(fragCoord - cs, 1., 3.1415926/2., float(n)*0.753 - iTime * (float(n) - 1.4) / 100.)*iResolution.x), 4+n), maxx).r + 0.5) * 0.5 * sc + 0.1;\n        r = min(iResolution.x, iResolution.y) * (0.21 - float(n)*0.015) * rpw;\n        if (d < r) {\n            float cc = d / r;\n            //fragColor = vec4(vec3(stylize((1.-cc*0.1), iTime/5., iTime/15.) * (smoothstep(0.41, 0.5, uv.y)*0.9 + 0.1)), 1.0);\n            float op = SMOOTH(r, d, 2.5);\n            BLEND(vec3(1.), op);\n            if (op == 1.) return;\n        }\n    }\n\n    // Water\n    if (uv.y < 0.35) {\n        c = T(ivec2(int(fragCoord.x), 2), maxx).r/5. + 0.35;\n        float cc = 1. - pow(uv.y - c + 0.9, 10.);\n        BLEND(vec3(0.,  vec2(stylize(cc, -iTime/3., -iTime/5.))* vec2(0.4, 0.45)), 1.0);\n        return;\n    }\n\n\n    // Small stars\n#define SKY_TO(X)       ((X) * vec2(1., 0.65) + vec2(0., 0.35))\n#define SKY_FROM(X)     ((X - vec2(0., 0.35)) / vec2(1., 0.65))\n#define SKYY_TO(X)       ((X) * 0.65 + 0.35)\n#define SKYY_FROM(X)     ((X - 0.35) / 0.65)\n#define MID(X)        (1.-(pow((X-0.5),2.)*.4))\n    float nStars = iResolution.x * iResolution.y / 10000.;\n    for (float n = 0.; n < nStars; n++) {\n        cs = iResolution.xy * SKY_TO(hash21(-n-10.));\n\n        //cs += vec2(\n        //    TM(ivec2(int(cs.x), 8), maxx, imid).r,\n        //    TM(ivec2(int(SKYY_FROM(cs.y/iResolution.y)*iResolution.x), 11), maxx, imid).r\n        //)*iResolution.xy/vec2(10.);\n\n        d = distance(cs, fragCoord.xy);\n        if (d <= 1.) {\n            float op = SMOOTH(1., d, 1.);\n            BLEND(vec3(stylize2(1.-d*0.005, -iTime/20. + n/nStars, -iTime/30.)), op);\n            break;\n        }\n    }\n\n    // Sky\n    float cc = clamp(uv.y * 1.3 - 0.5, 0., 1.);\n    //float cc = (1.-uv.y) * 1.1 - 0.1;\n    BLEND(vec3(0., 0., stylize(cc, -iTime/8., iTime/12.)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(iResolution.x+1.)/log(2.)) - 3.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\n//#define MOD(X)  ((X + iResolution_i.x) % iResolution_i.x)\n#define MOD(X)  X\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 30.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x-1;\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n\n    float c = randt(fragCoord_i, tier, fragCoord.y) * float(st) * pow_of_2_adj(iResolution.xy);\n    //if (tier < tier_n(pow2ceil(iResolution_i.x))-2) {\n        c += (T(ivec2(MOD(fragCoord_i.x - st), fragCoord_i.y), maxx).r + T(ivec2(MOD(fragCoord_i.x + st), fragCoord_i.y), maxx)).r / 2.;\n    //}\n    fragColor = vec4(vec3(c), 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 75, 75, 150], [151, 151, 188, 188, 242], [244, 244, 289, 289, 403], [405, 405, 451, 451, 571], [573, 573, 626, 626, 741], [743, 784, 805, 805, 938], [939, 939, 961, 961, 1089], [1090, 1090, 1113, 1113, 1198]], "test": "untested"}
{"id": "mtcyRn", "name": "Confetti Illusion (374 chars)", "author": "fenix", "description": "The confetti illusion, an extension of the Munker illusion, described in Novick and Kitaoka's 2021 paper with the same name. All the balls are the same color.\n\nhttps://journalofillusion.net/index.php/joi/article/view/6152/13750#content/figure_reference_58", "tags": ["color", "optical", "illusion", "perception", "codegolf"], "likes": 18, "viewed": 306, "published": 3, "date": "1698897957", "time_retrieved": "2024-07-30T17:24:31.910955", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  The confetti illusion, an extension of the Munker illusion, described in Novick and\n//  Kitaoka's 2021 paper with the same name. All the balls are the same color.\n//\n//      https://journalofillusion.net/index.php/joi/article/view/6152/13750#content/figure_reference_58\n//\n//  The effect, if you're having any trouble seeing it, is supposed to be that the\n//  colors of the stripes \"bleed\" into the spheres, making them appear to be different\n//  colors. For me, if I look directly at the spheres, I can see the brown, but the\n//  spheres in my peripheral vision look properly tinted.\n// \n//  In experimenting, I found that the width of the stripes plays an important role in\n//  the illusion, and this is also discussed in the paper. For the effect to work well\n//  in full screen, you are advised to raise the number from 1e2 to 2e2 or even 3e2\n//  depending on how big your monitor is, and how close you sit to it.\n//\n//  One thing I noticed is that the effect does not work as well when the spheres are\n//  white as they do as this brown color. I guess that's because there's less distance\n//  between this color and any of the stripes?\n//\n//  Golfing is encouraged! One place I think might be an opportunity is the calculation\n//  of the stripe colors, which are meant to be equal-luminance. The equation I came up\n//  with is based on solving a quadratic through the three values I computed from the \n//  \"standard\" luminance formula. Maybe there's a trick for computing these colors more\n//  compactly?\n// ---------------------------------------------------------------------------------------\n\n// Hoping this version works for everybody and is still pretty short: 374 chars\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 n, R = iResolution.xy;\n    u /= R.y;\n    int i, c = int(u.y * 1e2) % 3; // Increase the 1e2 here to make more stripes\n    \n    O = vec4(.2);\n    O[c] = float(c*c*4 - c*6 + 5) * .1; // Aiming for similar luminance\n\n    while (i < 7)\n    {\n        float t = mod(iTime / 4., 5.), x = t - u.x;\n        if ((i++ % 3 != c || x > 0. && x < 2.5) &&\n            (i % 3 == c || x < 1. || x > 2.5))\n\n            n = u\n                - sin((1.256 * t + float(i) * .9) * vec2(1, 2)) * vec2(.5, .3)\n                - .5 * R / R.y,\n            \n            x = sqrt(t = .01 - dot(n, n)),\n            \n            O = t > 0. ? (max(0., t = n.y - n.x + x) + .03) * vec4(4, 3, 2, 0) // Sphere color, set to vec4(4) for white\n                         + pow((t + x) * 4., 40.) // Specular\n                         : O;\n    }\n}\n/**/\n\n// Attempting to start to apply FabriceNeyret2's ideas: 371 chars (discarded because of some platform specific problem)\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 n, R = iResolution.xy;\n    u /= R.y;\n    int i, c = int(u.y * 1e2) % 3; // Increase the 1e2 here to make more stripes\n    \n    O = vec4(.2);\n\n    for (O[c] = float(c*c*4 - c*6 + 5) * .1; i++ < 7; )\n    {\n        float t = mod(iTime / 5., 4.), z = t - u.x;\n        O = (i % 3 != c || z > 0. && z < 2.5) &&\n            (i % 3 == c || z < 1. || z > 2.5) ?\n                n = u - .5 * R / R.y\n                    - sin((1.57 * t + float(i) * .9) * vec2(1, 2)) * vec2(.5, .3),\n            \n                z = sqrt(t = .01 - dot(n, n)),\n            \n                t > 0. ? (max(0., t = n.y - n.x + z) + .03) * vec4(4, 3, 2, 0) // Sphere color, set to vec4(4) for white\n                         + pow((t + z) * 4., 40.) // Specular\n                         : O : O;\n    }\n}\n/**/\n\n// From FabriceNeyret2: also 371 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 n, R = iResolution.xy;\n    u /= R.y;\n    int i, c = int(u.y * 1e2) % 3; // Increase the 1e2 here to make more stripes\n    \n    for (O = vec4(.2), O[c] = float(c*c*4 - c*6 + 5) * .1; i < 7 ; )\n    {\n        float t = mod(iTime/5., 4.), z = t - u.x;\n            ( i++ % 3 != c || z > 0. && z < 2.5 )\n         && ( i   % 3 == c || z < 1. || z > 2.5 )\n          ? n = u - .5* R/R.y\n                  - vec2(.5,.3)* sin( ( 1.57*t + float(i)*.9 ) *vec2(1,2) ),\n            z = sqrt( t = .01 - dot(n,n) ),\n            O = t > 0. ? (max(0., t = n.y - n.x + z) + .03) * vec4(4,3,2,0) // Sphere color, set to vec4(4) for white\n                         + pow( (t + z) *4., 40.) // Specular\n                         : O : O;\n    }\n}\n/**/\n\n// My original: 412 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3 n, R = iResolution;\n    u /= R.y;\n    int i = 0, c = int(u.y * 1e2) % 3; // Increase the 1e2 here to make more stripes\n    \n    O = vec4(.2);\n    O[c] = float(c*c*4 - c*6 + 5) * .1; // Aiming for similar luminance\n\n    while (i < 7)\n    {\n        float t = mod(iTime, 20.) / 5.;\n        if ((i++ % 3 != c || u.x < t && u.x > t - 2.5) &&\n           (i % 3 == c || u.x > t - 1. || u.x < t - 2.5))\n        {\n            n = vec3(u, 1)\n                    - sin((1.57 * t + float(i) * .9) * vec3(1, 2, 0)) * vec3(.5, .3, 0)\n                    - .5 * R / R.y;\n            \n            n.z = sqrt(t = n.z*n.z - dot(n, n) + .01);\n            \n            O = t > 0. ? (max(0., t = n.y - n.x + n.z) + .03) * vec4(4, 3, 2, 0) // Sphere color, set to vec4(4) for white\n                         + pow(max(0., t + n.z) * 4., 40.) // Specular\n                         : O;\n        }\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcyRn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1815, 1899, 1935, 1935, 2752]], "test": "untested"}
{"id": "clcczH", "name": "0x01", "author": "elora", "description": "Art of shaders.", "tags": ["learning"], "likes": 1, "viewed": 156, "published": 3, "date": "1698871907", "time_retrieved": "2024-07-30T17:24:32.780630", "image_code": "//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 69, 69, 253], [255, 295, 352, 352, 838]], "test": "untested"}
{"id": "DlcyzH", "name": "Dark Aurelia 4 Windows Terminal", "author": "mrange", "description": "CC0: Dark Aurelia\nAnother take on the aurelia logo\nShader gallery here: https://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d", "aurelia"], "likes": 24, "viewed": 338, "published": 3, "date": "1698870552", "time_retrieved": "2024-07-30T17:24:33.649307", "image_code": "// CC0: Dark Aurelia for Windows Terminal\n// Another take on the aurelia logo\n// Shader gallery here: https://mrange.github.io/windows-terminal-shader-gallery/\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define REV(x)      exp2((x)*zoom)\n#define FWD(x)      (log2(x)/zoom)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 baseCol00 = HSV2RGB(vec3(341.0/360.0, 0.96, 0.85));\nconst vec3 baseCol01 = HSV2RGB(vec3(260.0/360.0, 0.75, 0.36));\nconst vec3 baseCol10 = HSV2RGB(vec3(285.0/360.0, 0.68, 0.45));\nconst vec3 baseCol11 = HSV2RGB(vec3(268.0/360.0, 0.72, 0.40));\nconst vec3 gcol = HSV2RGB(vec3(0.6, 0.95, 0.00025));\nconst mat2 arot = ROT(radians(34.0));\nconst vec2 soff = vec2(0.01, 0.01)*(arot);\nconst float zoom = log2(1.8);\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  k = max(k, 1E-3);\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec4 daurelia(vec2 p, float r) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x += -0.033;\n  p1.y += -0.004;\n  vec2 p2 = p;\n  p2.x += 0.48;\n  p2.y += -0.06;\n  vec2 p3 = p;\n  p3.x += -0.495;\n  p3.y += -0.06;\n  vec2 p4 = p;\n  p4.x += 0.39;\n  p4.y += -0.86;\n  vec2 p5 = p;\n  p5.x += 0.78;\n  p5.y += 0.4;\n  vec2 p6 = p;\n  p6.x += 0.035;\n\n  float d0 = box(p0, vec2(1.0, 0.285)-r);\n  float d1 = box(p1, vec2(0.225, 1.01)-r);\n  float d2 = box(p2, vec2(0.17, 0.63)-r);\n  float d3 = box(p3, vec2(0.11, 0.63)-r);\n  float d4 = box(p4, vec2(0.06, 0.06)-r);\n  float d5 = box(p5, vec2(0.06, 0.07)-r);\n  float d6 = box(p6, vec2(0.55, 0.45)-r);\n\n  d0 -= r;\n  d1 -= r;\n\n  float d7 = -(d0 - 0.06);\n\n  d1 = pmax(d1, d7, r);\n\n  float d = d2;\n  d = min(d, d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d -= r;\n  d = pmax(d, d7,r);\n  return vec4(d0, d1, d, d6);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec3 aurelia(vec3 col, float aa, vec2 p) {\n\n  p *= arot;\n  vec4 ad = daurelia(p, 0.0);\n  vec4 sad = daurelia(p+soff, 0.025);\n  float m0 = clamp(0.35*dot2(p-vec2(1.0, 0.0)), 0.0, 1.0);\n  float m1 = clamp(0.35*dot2(p-vec2(0.0, 1.0)), 0.0, 1.0);\n  float shd = mix(0.75, 1.0, smoothstep(aa, -aa, -ad.w));\n  vec3 bcol0 = mix(baseCol00, baseCol01, m0);\n  vec3 bcol1 = mix(baseCol00, baseCol01, m1)*shd;\n  vec3 bcol2 = mix(baseCol10, baseCol11, m1)*shd;\n  float sd = min(min(sad.x, sad.y), sad.z);\n  float od = min(min(ad.x, ad.y), ad.z);\n  od = abs(od)-aa;\n\n  sd += 0.025;\n  sd = max(sd, 0.0175);\n  sd *= sd;\n\n  col += gcol/sd;\n  col = mix(col, mix(bcol0, col, 0.0), smoothstep(aa, -aa, ad.x));\n  col = mix(col, mix(bcol1, col, 0.0), smoothstep(aa, -aa, ad.y));\n  col = mix(col, mix(bcol2, col, 0.0), smoothstep(aa, -aa, ad.z));\n  col = mix(col, vec3(1.0), smoothstep(aa, -aa, od));\n  return col;\n}\n\nvec3 effect(vec3 col, float aa, vec2 op) {\n  const float angle = TAU/10.0; \n  const mat2 rot = ROT(0.5*angle);\n\n  float gtm = 0.125*TIME;\n  op *= ROT(0.25*gtm);\n  float od = 1E4;\n  \n  for (int j = 0; j < 2; ++j){\n    float tm = gtm+float(j)*0.5;\n    float ctm = floor(tm);\n    float ftm = fract(tm);\n    float z = REV(ftm);\n    vec2 p = op;\n    p /= z;\n  \n    float d = 1E4;\n    float n = floor(FWD(length(p)));\n    float r0 = REV(n);\n    float r1 = REV(n+1.0);\n    \n    for (int i = 0; i < 2; ++i) {\n      vec2 pp = toPolar(p);\n      mod1(pp.y, angle);\n      vec2 rp = toRect(pp);\n      \n      float d0 = circle(rp, r0);\n      float d1 = circle(rp, r1);\n      float d2 = segment(rp, rot*vec2(r0, 0.0), vec2(r1, 0.0));\n      float d3 = segment(rp, transpose(rot)*vec2(r0, 0.0), vec2(r1, 0.0));\n      d0 = abs(d0);\n      d1 = abs(d1);\n      d = min(d, d0);\n      d = min(d, d1);\n      d = min(d, d2);\n      d = min(d, d3);\n      float gd = d*z;\n      p *= rot;\n    }\n    d *= z;\n    od = min(od, d);\n  }\n\n  od -= aa*0.5;\n  col = mix(col, mix(baseCol00, baseCol01, tanh(dot2(op*1.0))), smoothstep(aa, -aa, od));\n  col += 50.0*gcol.zxy/max(dot2(op), 0.01);\n\n  return col;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  \n  vec2 ap = p;\n  float aaa = aa; \n  const float iz = sqrt(0.5);\n  ap /= iz;\n  aaa /= iz;\n\n  col = effect(col, aa, p);\n  col = aurelia(col, aaa, ap);\n  col *= smoothstep(1.25, 0.5, length(pp));\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 582, 582, 728], [1440, 1558, 1597, 1597, 1716], [1718, 1804, 1843, 1843, 1968], [1970, 2088, 2115, 2115, 2191], [2193, 2293, 2332, 2332, 2437], [2439, 2439, 2478, 2478, 2507], [2509, 2509, 2531, 2531, 2575], [2577, 2577, 2598, 2598, 2643], [2645, 2645, 2676, 2676, 2702], [2704, 2704, 2736, 2736, 3532], [3534, 3534, 3554, 3554, 3576], [3578, 3578, 3620, 3620, 4470], [4472, 4472, 4514, 4514, 5644], [5647, 5647, 5703, 5703, 6126]], "test": "untested"}
{"id": "tsKcWw", "name": "Line circle intersection", "author": "Kaeylos", "description": "small exemple line cicle intersection", "tags": ["intersection"], "likes": 1, "viewed": 128, "published": 3, "date": "1698870304", "time_retrieved": "2024-07-30T17:24:34.409275", "image_code": "float diskSDF(vec2 pos, vec2 center, float radius) {\n\treturn length(pos-center) - radius;\n}\n\nfloat lineSDF(vec2 p, vec2 a, vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat lineCicleIntersect(vec3 cicle, vec2 a, vec2 b) {\n    vec2 dir = normalize(b - a);\n    vec2 toShpere = cicle.xy - a;\n    \n    vec2 point = dir * dot(toShpere -b, dir);\n    return length(point - cicle.xy) < cicle.z ? 1.0 : 0.0;\n}\n                  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t//float zoom = 2.5;\n\t//uv *= zoom;\n\t\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    vec3 color = vec3(0.7);  \n    \n    vec2 a = cos(iTime + vec2(0.,5.));\n\tvec2 b = cos(iTime + vec2(0.,5.) + 3.1);\n    \n    // line\n\tfloat thickness = .01;\n    float dLine = lineSDF(uv, a, b) - thickness;\n    color = vec3(dLine > thickness ? 1.0 : 0.0);\n    // mouse cicle\n    float radius = 0.2;\n    color = mix(color, vec3(lineCicleIntersect(vec3(mouse, radius), a, b), 1, 0), diskSDF(uv, mouse, radius) < 0.0 ? 1.0 : 0.0);\n\n\tfragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 91], [93, 93, 132, 132, 252], [254, 254, 308, 308, 487], [507, 507, 564, 564, 1200]], "test": "untested"}
{"id": "DtccRH", "name": "Graph: f(x) = x^2", "author": "kalisina", "description": "Graph of f(x) = x^2\n\nFollowing my previous graph of f(x) = x\nhttps://www.shadertoy.com/view/DsVBWy\n\nthis is now a representation of f(x) = x*x", "tags": ["beginner", "parabola", "maths"], "likes": 2, "viewed": 139, "published": 3, "date": "1698867877", "time_retrieved": "2024-07-30T17:24:35.157276", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= 2.0;\n    \n    //vec3 col  = vec3(abs(uv.x * uv.x - uv.y) < 0.01);\n    \n    const float lineWidth = 0.01;\n    vec3 col = vec3(smoothstep(2.0 / iResolution.y, 0.0, abs(uv.x * uv.x - uv.y) - lineWidth));\n    \n    //float f   = uv.x * uv.x - uv.y;\n    //vec4 col = vec4( 1. - abs(f) / fwidth(f) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtccRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 529]], "test": "untested"}
{"id": "ct3yz8", "name": "Infinite TV wall zoom (200 char)", "author": "ruudhelderman", "description": "Just one of those infinite zooms.\nNotice how I am using mix to cheat my way through the transitions.\nYes, it is very well possible to code golf it even further down.", "tags": ["2d", "zoom"], "likes": 16, "viewed": 241, "published": 3, "date": "1698866032", "time_retrieved": "2024-07-30T17:24:35.986059", "image_code": "// Infinite TV wall zoom\n// by Ruud Helderman, November 1, 2023 - MIT License\n\n#define R 160.   // resolution: how many images make up one image, both horizontally and vertically\n\n#define T(z) texture(iChannel0, round(fract((c / iResolution.xy - .5) * pow(R, z) + .5) * R) / R)\n\nvoid mainImage(out vec4 o, vec2 c)\n{\n    float z = fract(2. * acos(.96 * cos(.1 * iTime)) - .7);    // alternately zoom in and out\n    //float z = fract(.2 * iTime);     // zoom out forever\n    //float z = fract(-.2 * iTime);    // zoom in forever\n    \n    o = mix(T(z), T(z - 1.), z);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3yz8.jpg", "access": "api", "license": "mit", "functions": [[279, 279, 315, 315, 566]], "test": "untested"}
{"id": "dsVczc", "name": "raytracing͏", "author": "01000001", "description": "finally attempted it properly... not that the result is any good.", "tags": ["thing"], "likes": 2, "viewed": 146, "published": 3, "date": "1698865543", "time_retrieved": "2024-07-30T17:24:37.181862", "image_code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    O = texture(iChannel0, uv);\n    \n    O = O/(1.+O);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DEPTH 5\n#define OBJECT_COUNT 5\n\nconst vec3 up = vec3(0, 1, 0);\n\nstruct material\n{\n    float metallic;\n    float roughness;\n    float specular;\n    vec3 col;\n    \n};\n\nstruct sphere\n{\n    vec3 pos;\n    float radius;\n    material mat;\n};\n\nstruct box\n{\n    vec3 pos;\n    vec3 up; // Length of up is scale\n    material mat;\n};\n\nstruct plane\n{\n    vec3 pos;\n    vec3 normal;\n    material mat;\n};\n\nstruct rayHit\n{\n    float t1;\n    float t2;\n    vec3 pos;\n    vec3 normal;\n    vec3 incoming;\n    vec3 reflection;\n    bool hit;\n    vec3 origin;\n    material mat;\n};\n\nconst float pi = 3.14159;\nfloat cameraFarPlane = 1e8;\nfloat fieldOfView = 2.;\nfloat mouseSensitivity = 2.;\n\n\n\n\n// Materials //\n\n    const material testBlue = material(\n        0.0,                // Metallic \n        0.0,               // Roughness\n        0.5,              // Specular\n        vec3(.1, .3, .8) // Colour\n    );\n\n\n    const material testRed = material(\n        0.0,                // Metallic \n        0.5,               // Roughness\n        0.1,              // Specular\n        vec3(.8, .2, .2) // Colour\n    );\n\n    const material testGreen = material(\n        1.,                 // Metallic \n        0.,                // Roughness\n        0.2,              // Specular\n        vec3(.1, .6, .3) // Colour\n    );\n\n    const material testRandom = material(\n        1.0,                   // Metallic \n        0.2,                  // Roughness\n        0.5,                 // Specular\n        vec3(0.2, 0.0, 0.7) // Colour\n    );\n\n\n\n\n// Geometry //\n        \n    sphere sp1 = sphere(\n        vec3(-1, 0, 0), // Position\n        .5,            // Radius\n        testBlue      // Material\n    );\n    \n    box bo1 = box(\n        vec3(1, 0, 0),          // Position\n        normalize(vec3(1))*.5, // Up\n        testBlue              // Material\n    );\n    \n    plane pl1 = plane(\n        vec3(0, -1, 0), // Position\n        vec3(0, 1, 0), // Normal\n        testRed       // Material\n    );\n\n    box bo2 = box(\n        vec3(2, 0, 0),         // Position\n        normalize(vec3(1))*.5,// Up\n        testGreen            // Material\n    );\n    \n    sphere sp2 = sphere(\n        vec3(1, -3.8, -0.5), // Position\n        3.,                 // Radius\n        testRandom         // Material\n    );\n\n\n\n\n\n// General functions // \n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nmat3 matTowards( vec3 n ){\n    \n    vec3 r = normalize(abs(dot(n, up)) < 1e-2?cross(n, up):cross(n, normalize(vec3(1))));\n    vec3 f = cross(r, n);\n    \n    return mat3(r, f, n); \n}\n\nvec3 cosDist( uvec3 x, vec3 norm ){ // Cosine weighted distribution\n    vec2 u = circleSample(x);\n    return vec3(u, sqrt(1.-u.x*u.x-u.y*u.y)) * matTowards(norm);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn 5.*(\n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7));\n}\n\n\n\n\n\n\n\n\n// Intersection functions\n\nrayHit sphereRay(vec3 o, vec3 dirV, sphere sp)\n{    \n    rayHit hit;\n    hit.incoming = dirV;\n\n    float t = dot(sp.pos - o, dirV);\n    vec3 p = o + dirV*t;\n    \n    float y = length(sp.pos - p);\n    \n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n    \n    if (y < sp.radius && t > 0.) //hit && in front of camera\n    {\n        float x = sqrt(sp.radius*sp.radius - y*y);\n        hit.t1 = t-x;\n        hit.t2 = t+x;\n        \n        vec3 p1 = o + dirV*hit.t1;\n        vec3 n = normalize(p1 - sp.pos);\n        hit.normal = n;\n        hit.hit = true;\n        hit.pos = p1;\n        hit.mat = sp.mat;\n        hit.origin = sp.pos;\n    }\n    else if (y < sp.radius)\n    {\n        hit.hit = false;\n    }\n    return hit;\n\n}\n\nrayHit planeRay(vec3 o, vec3 dirV, plane p)\n{\n    rayHit hit;\n    hit.incoming = dirV;\n    hit.hit = false;\n    \n    float dist = -(dot(p.normal, p.pos-o));\n    \n    if (dist > 0.0)\n    {\n        dist /= dot(dirV, -p.normal);\n\n\n        hit.t1 = cameraFarPlane;\n        hit.t2 = cameraFarPlane;\n\n        if (dist > 0.0)\n        {\n            hit.t1 = dist;\n            hit.hit = true;\n            hit.pos = o + hit.t1 * dirV;\n            hit.normal = p.normal;\n            hit.origin = p.pos;\n            hit.mat = p.mat;\n        }\n    }\n    \n    return hit;\n    \n}\n\nrayHit boxRay(vec3 o, vec3 dirV, box b)\n{\n\n    rayHit hit;\n    hit.incoming = dirV;\n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n    hit.hit = false;\n    \n    rayHit tempHits[6];\n    rayHit minHit;\n    \n    float minDist = cameraFarPlane;\n    \n    \n    vec3 dirs[6];\n    dirs[0] = normalize(b.up);\n    dirs[1] = b.up==vec3(0,0,1)?vec3(1, 0, 0):normalize(cross(b.up, vec3(0, 0, 1)));\n    dirs[2] = normalize(cross(b.up, dirs[1]));\n    dirs[3] = -dirs[0];\n    dirs[4] = -dirs[1];\n    dirs[5] = -dirs[2];\n    float scale = length(b.up);\n    \n    for (int i = 0; i<6; i++)\n    {\n        dirs[i] = dirs[i]*(scale-0.001);\n        plane p;\n        p.pos = dirs[i]; p.normal = dirs[i];\n        tempHits[i] = planeRay(o-b.pos, dirV, p);\n                \n    }\n    \n    for (int i = 0; i<6; i++)\n    {\n        rayHit hi = tempHits[i];\n        if (hi.hit \n        &&  max(abs(dot(hi.pos, dirs[0])), \n            max(abs(dot(hi.pos, dirs[1])), \n                abs(dot(hi.pos, dirs[2])))) < (scale*scale))\n        {\n            hit = hi;\n            hit.normal = normalize(hit.normal);\n            hit.pos += b.pos;\n            hit.origin = b.pos;\n        }\n\n    }\n    \n    hit.mat = b.mat;\n    \n    return hit;\n\n}\n\nrayHit pew(vec3 o, vec3 dirV, plane p){\n    return planeRay(o, dirV, p);\n\n}\n\nrayHit pew(vec3 o, vec3 dirV, box b){\n    return boxRay(o, dirV, b);\n}\n\nrayHit pew(vec3 o, vec3 dirV, sphere s){\n    return sphereRay(o, dirV, s);\n}\n\n\nrayHit ray(vec3 o, vec3 dirV, float t){\n\n\n    // Animation //\n    \n    sp1.pos.xy = vec2(cos(t + vec2(0, 11))) * vec2(1, .6) - vec2(1,0);\n    sp1.pos.z = -.5;\n    \n    bo1.up = normalize(vec3(cos(t * vec3(1,3,2)*.4)))*.5;\n    bo1.pos.x += sin(t)*.5;\n    \n    ///////////////\n\n\n\n\n    rayHit hit;\n    hit.incoming = dirV;\n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n    hit.hit = false;\n    \n    rayHit hits[OBJECT_COUNT];\n    \n    \n    // Rendering //\n    \n    hits[0] = pew(o, dirV, sp1);\n    hits[1] = pew(o, dirV, pl1);\n    hits[2] = pew(o, dirV, bo1);\n    hits[3] = pew(o, dirV, bo2);\n    hits[4] = pew(o, dirV, sp2);\n\n\n    ///////////////\n    \n    \n    // Pick the closest hit\n    for (int i = 0; i < OBJECT_COUNT; i++){        \n        if (hits[i].hit && hits[i].t1 < hit.t1) hit = hits[i];\n    } \n    hit.reflection = reflect(hit.incoming, hit.normal);\n    return hit;\n}", "buffer_a_code": "#define time iTime\n//47.9\n#define bgTime iTime\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = iMouse.xy==vec2(0)?vec2(0):(2.*iMouse.xy-r)/r.y;\n\n        \n    vec3 o = vec3(0, 0, -2.5);\n    \n    vec3 camDir = vec3(sin(muv.x)*cos(muv.y), sin(muv.y), cos(muv.x)*cos(muv.y));\n    \n    vec3 camRight = normalize(cross(up, camDir));\n    vec3 camUp = cross(camDir, camRight);\n    \n    vec3 dirV = normalize(camDir + camRight * cuv.x + camUp * cuv.y);\n    \n    \n    rayHit hit;\n    rayHit hits[DEPTH];\n    \n    vec3 col = vec3(1);\n    vec3 light = vec3(0);\n    \n    for (int i = DEPTH; i-->0;){\n        \n        \n        hit = ray(o, dirV, time);\n        hits[i] = hit;\n\n        if (hit.hit){\n            vec3 h = hash(uvec3(U.y, iFrame, U.x));\n            if (h.x < hit.mat.specular*(1.-pow(dot(hit.normal, -hit.incoming), 5.))){\n                //Specular\n            } else {\n                if (h.y < hit.mat.metallic){\n                    //Metallic\n                    col *= hit.mat.col;\n                } else {\n                    // Dielectric\n                    col *= hit.mat.col;\n                    hit.mat.roughness = 1.;\n                }\n            }\n            \n            if (i == 0) col *= 0.;\n        } else {\n            light = background(bgTime, dirV);\n            break;\n        }\n        \n        o = hit.pos;\n        dirV = mix(hit.reflection, cosDist( uvec3(iFrame, U.y, U.x), hit.normal), hit.mat.roughness);\n    }\n    \n    col *= light;\n    O.xyz = col;\n    \n    \n    \n    \n    hit = hits[DEPTH-1];\n    // Temporal Accumulation\n    \n    if (hit.hit && iFrame > 10){\n        O.w = hash(uvec3((abs(hit.pos + hit.normal + hit.incoming)) * 1e7)).z;\n    } else {\n        O.w = mod(iTime, 1.);\n        \n        O.xyz = background(bgTime, dirV);\n    }\n    \n    vec4 last = texture(iChannel0, uv);\n    float change = float(bool(abs(O.w - last.w)));\n    \n    \n    O.xyz = mix(last.xyz, O.xyz, min(1., mix(change, 1., 0.01)));\n    \n    //O.xyz = vec3(float(bool(last.w - O.w)));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 148]], "test": "untested"}
{"id": "cl3cz8", "name": "twisted hexahedron", "author": "cyperus", "description": " doc: https://people.maths.ox.ac.uk/trefethen/lightning.html :)", "tags": ["3d", "sdf", "stereographic", "hypersphere"], "likes": 13, "viewed": 218, "published": 3, "date": "1698864361", "time_retrieved": "2024-07-30T17:24:38.228065", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"twisted hexahedron\"\n//\n// created by Colling Patrik (cyperus) in 2023\n//\n// DOCUMENTATION:\n// - https://people.maths.ox.ac.uk/trefethen/lightning.html\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// ray casting bounding shape\nconst float CAM_DIST = 6.;\nconst float CAM_FLE = 1.3;\nconst float BBOX_RADIUS = 8.;\nconst float RAY_MIN_DIST = 0.;\nconst float RAY_MAX_DIST = CAM_DIST+1.1*BBOX_RADIUS;\n\n// ray march\nconst int MAX_MARCHING_STEPS = 600; /*<1, 300, 2000>*/\nfloat RAY_STEP_FACTOR3 = 0.27755; /*<0.05, 0.27755 ,1.0 */\nconst float RAY_PRECISION = 0.00001;\n\n// hexaeder\nconst int PS_f = 6;\nconst int PS_e_f = 4;\nconst float PS_a0 = 8.;\n\n// torus\nconst float J1_sh_a0 = -1.;\nconst float J1_sh_a1 = -0.4;\nconst int   J1_sh_f1 = 1*PS_e_f;\nfloat J1_sh_pa1 = 0.03;\nconst int   J1_to_c1 = 12*PS_e_f;\nconst int   J1_to_f1 = 2*PS_e_f;\nconst float J1_to_pa1 = 0.0;\n\n// texture\nconst int   TEX_MODE = 1; // 0: white, 1: stripes, 2: normal, 3: hex_cell_id\nconst bool  TEX_UV_ON = true;\nconst float TEX_UV_SHARPNESS = 0.00000001;\nconst vec2  TEX_UV_SUBDIV = vec2(1*PS_e_f, 1*PS_e_f);\n\n// shade\nconst bool SHADE_ON = true;\n\n// fog\nconst bool  FOG_ON = true;\nconst float FOG_DENSITY = 0.001;\n\nfloat map(in vec3 p, out vec4 mat) {   \n    //// sdf's\n    float rxy = 0., au = 0.0, av = 0.0;\n    float cell_id = 0., sr = 0.; //sig(sr): sens of rotation, abs(sr) : number edges\n    vec2 z = vec2(0.);\n    \n    // stereographic 4D, rotation\n    p = rotz4D( p, iTime/20., sqrt(abs(PS_a0)));\n    float a_xy = 2.*PI*iTime/30.;\n    p.xy = cmul(p.xy, vec2(cos(a_xy),sin(a_xy)));\n           \n    //// map platonic solid cells to one cell\n    vec3 pn = normalize(p); \n\n    // projection from n cells to 1 cell. \n    pn = hexa_cells(pn, cell_id, sr);\n    z = pn.xy/(1.-pn.z);\n    z = cHexaPolyArc2disk(z);\n\n    /// r-polygon-distribution\n    vec2 e = vec2(sqrt(2.), 0.5);\n    float en = 1.+( (PS_a0<0.?e.x:e.y)-1. )*smoothstep(1.,5., abs(PS_a0));        \n    float r = length(z); vec2 zn = z/r;\n    z = dist(r, en) * zn;   \n\n    /// stereograpic projection    \n    pn = sp(vec3(z,sr));\n\n    /// scale radius\n    p = length(p) * pn;\n    \n    ////fractal level 0: Torus\n    au = atan(p.y, p.x);\n    rxy = length(p.xy); \n    z = vec2(rxy, p.z);\n    z = cmul(z,z); z.x -= PS_a0;\n    \n    ////fractal level 1: 2Djulia realaxis-translation,fraction,rotation\n    float sh1 = J1_sh_a0;\n    float to1 = au*float(J1_to_c1)/float(J1_to_f1);\n    sh1 += J1_sh_a1*(1.-pulsecollision(float(J1_sh_f1),au/PI, J1_sh_pa1, 0.5));\n    to1 += J1_to_pa1;  \n    z = crpt(z, to1, float(J1_to_f1), sh1);     \n\n    // distance estimation shape\n    float d = log(length(z));\n    \n    #if 0\n    st_assert( d != INF, 0 ); // Shows the +INF singularity as a sphere (floating point precision).\n    #else\n    if (d == INF) {d = 1.;} // step through the singularity\n    #endif\n   \n    mat.x = cell_id; mat.yz = z; mat.w = au *float(J1_sh_f1); // object id, complex plane metatorus, angle-u metatorus\n    return d;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 rescol, in float px) {\n    float res = -1.0; // init no intersection\n    \n    // bounding shape BB\n    vec2 dis = isphere( ro, rd , abs(BBOX_RADIUS));\n    \n    if( dis.y<0.0 ) return -1.0; // check BB behind came\n\n    dis.x = max( dis.x, RAY_MIN_DIST ); // check min ray length\n    dis.y = min( dis.y, RAY_MAX_DIST ); // check max ray length\n\n    // raymarch signed distance field\n    vec4 trap; // data from surface intersection point\n    \n\tfloat fh = RAY_STEP_FACTOR3;\n    float t = dis.x; // ray starts at boundingbox\n    for( int i=0; i<MAX_MARCHING_STEPS; i++  ) // max steps\n    { \n        vec3 pos = ro + rd*t;\n        float th = RAY_PRECISION * px * t; //th = 0.0001; // minimal bound surface hit\n        float h = map( pos, trap );\n        if( t>dis.y || h<th ) break; // ray outside BB or hit.\n        t += h*fh; // distance\n    }\n    if( t<dis.y ) // ray inside BB\n    {\n        rescol = trap; // save data\n        res = t; // save ray length\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, in float prec ) {\n    vec4 tmp; // dummie\n    vec2 e = vec2( prec, 0. );\n    return normalize(vec3(\n\t\tmap(p+e.xyy,tmp) - map(p-e.xyy,tmp),\n\t\tmap(p+e.yxy,tmp) - map(p-e.yxy,tmp),\n\t\tmap(p+e.yyx,tmp) - map(p-e.yyx,tmp) )\n    \t);\n}\n\nvec3 transform(in vec3 p, in float time) {\n\t// camera transformation\n\tif (iMouse.x > 0.0)\n\t{\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\tp.yz = crot(p.yz,-PI*m.y);\n\t\tp.zx = crot(p.zx,-PI*m.x);\n\t}\n\t//p.xz = crot(p.xz,time*0.1);\n\treturn p.xyz;\n}\n\nvec3 phong(in vec3 lightdir, in vec3 raydir, in vec3 surfnormal) {\n  //cubemap\n  //vec3 K_a = 1.5 * vec3(0.0,0.5,0.8) * texture(iChannel0, reflect(rd, normal)).rgb;\n  // ratio reflection, light color\n  vec3 K_a = 0.25 * vec3(0.7, 0.7, 0); //ambient light\n  vec3 K_d = 0.5  * vec3(0.7, 0.5, 0); //diffuse light\n  vec3 K_s = 0.25 * vec3(1); float alpha = 10.;// specular light\n\n  float diffuse = clamp(dot(lightdir, surfnormal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightdir, surfnormal), -raydir), 0., 1.), alpha);\n  // ambient- diffuse- specular- light reflection\n  return K_a + K_d * diffuse + K_s * specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // slider mapping\n    RAY_STEP_FACTOR3 = (0.5-0.0001)* pow(RAY_STEP_FACTOR3, 3.) + 0.0001;\n    \n    // time modulation\n    J1_sh_pa1 *= iTime;\n   \n    // normalized coords\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // camera viewport --> worldspace\n    vec3 ro = vec3(0,0,-CAM_DIST);\n    vec3 rd = vec3(-uv.x,uv.y,CAM_FLE);\n    \t ro = transform(ro,iTime);\n\t     rd = normalize(transform(rd,iTime));\n\n    // ray\n    vec4 mat = vec4(0.0); // material-data: vec4(float cell_id, vec2 complex plane, float angle-u)\n    float px = 2.0/( iResolution.y*CAM_FLE );\n    float t = intersect( ro, rd, mat, px ); // distance hit ray surface\n    \n    // color\n    // background-color\n    vec3 bg_col = smoothstep(vec3(1.000,0.945,0.678),vec3(1.000,0.749,0.459),vec3(0.5,rd.y,0.6));\n         bg_col *= srgb2rgb( texture(iChannel0, vec3(-rd.x,rd.yz)).rgb );\n    vec3 bg_hsv = rgb2hsv(bg_col);\n         bg_hsv.x +=0.01*iTime;\n         bg_col = hsv2rgb(bg_hsv.x,0.8* bg_hsv.y,1.5*bg_hsv.z);\n\n    vec3 col = vec3(1,1,0); // init, test-color\n    if (t < 0.0) /* no hit -> sky */ {\n        col = bg_col;\n    }\n    else /* hit -> object, surface */ {\n    \t// surface properties\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal( p, 0.001);        \n        // object id\n        float obj_id = mat.x;\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = 0.5*mat.w/PI;\n        mat_uv.y = atan(mat.z,mat.y)/PI;\n        // uv-texture\n        col = (TEX_MODE == 1) ? h2rgb(abs(mat_uv.y))      // stripes\n            : (TEX_MODE == 2) ? 0.6*n+vec3(0.4)           // normal\n            : (TEX_MODE == 3) ? h2rgb(obj_id/float(PS_f)) // hex_cell_id\n            : vec3(1.);\n        // uv-grid (TODO: not orthogonal!)\n        if(TEX_UV_ON) {\n            mat_uv *= PI*TEX_UV_SUBDIV;\n            col *= 0.5+ 0.5*smoothstep(-TEX_UV_SHARPNESS,TEX_UV_SHARPNESS, sin(mat_uv.x)*sin(mat_uv.y) );\n        }        \n        // lighting\n        if (SHADE_ON) {\n            // point_light\n            vec3 point_lo = vec3(-8, -6, -5);\n            vec3 point_ld = normalize(point_lo - p);\n            float point_li = 0.6;\n            // came_light\n            vec3 came_lo = transform(vec3(0.,0.,-CAM_DIST),iTime); // light origine\n            vec3 came_ld = normalize(came_lo - p); // light direction\n            float came_li = 0.4; // light intensity\n            // Phong\n            col *= 0.6;\n            col += 0.2 * phong(point_ld, n , rd);\n            col += 0.2 * phong(came_ld, n, rd);\n            // fresnel\n            col += pow(clamp(1. - dot(n, -rd), 0., 1.), 5.) * 0.4 * bg_col;\n        }\n    }\n    // fog\n    if(FOG_ON) col = mix(col, bg_col, 1.0 - exp(-FOG_DENSITY * pow(t,3.)));\n    // gamma correction\n    fragColor = vec4(rgb2srgb(col),1.);\n}\n", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// consts\nconst float PI = abs(atan(0.,-1.));\nconst float INF = abs(1./0.);\nconst float NAN = abs(0./0.);\n\n/// 1D transformations\nfloat pulsecollision(in float pf, in float x, in float x0, in float pw) {\n    /*\n    x  : periodic in [0,1]\n    x0 : offset\n    pw : pulse width in [0,1]\n    pf : pulse frequency \n    */\n    float ntriw_p = abs( fract( pf*(x - x0) )-0.5); // x_normalized triangle wave function moving in +x_direction\n    float ntriw_n = abs( fract( pf*(x + x0) )-0.5); // x_normalized triangle wave function moving in -x_direction\n    float pp = smoothstep( 0.5*pw, 0., ntriw_p );   // pulse moves in +x_direction\n    float pn = smoothstep( 0.5*pw, 0., ntriw_n );   // pulse moves in -x_direction\n    return (pp+pn);                                 // smooth superposition\n}\n\n/// 2D transformations\n/// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);}\n\nvec2 crot(vec2 z,float a){\n    return cmul(vec2(cos(a),sin(a)),z);}\n\nvec2 cinv(vec2 z){\n    return z*vec2(1,-1)/dot(z,z);}\n    \nvec2 cdiv(vec2 z, vec2 w){\n    return cmul(z,cinv(w));}\n\nvec2 cpow(vec2 z, float q){\n    float r=pow(length(z), q);\n\tfloat a=q*atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));}\n\nvec2 cpow(vec2 z, int n){\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));}\n\nvec2 crpt(vec2 z, float a, float p, float x0){\n  /* (z*e^ia)^p-x0 */\n  return cpow( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\nvec2 cHexaPolyArc2disk(vec2 z) {\n    // https://people.maths.ox.ac.uk/trefethen/lightning.html\n    const int NUM_j = 18; // poles\n    const vec2[] rf = vec2[NUM_j]\n    (vec2( 0.7072, -0.7070)\n    ,vec2(-0.7070,  0.7072)\n    ,vec2(-0.0377, -0.9993)\n    ,vec2( 0.7072,  0.7070)\n    ,vec2(-0.7072, -0.7070)\n    ,vec2(-0.0377,  0.9993)\n    ,vec2( 0.5452, -0.8383)\n    ,vec2( 0.9936,  0.1126)\n    ,vec2(-0.9936,  0.1126)\n    ,vec2(-0.7983, -0.6022)\n    ,vec2(-0.7563,  0.6542)\n    ,vec2( 0.6542,  0.7563)\n    ,vec2( 0.7563, -0.6542)\n    ,vec2(-0.6235,  0.7818)\n    ,vec2(-0.7167, -0.6974)\n    ,vec2(-0.6542, -0.7563)\n    ,vec2( 0.7342,  0.6790)\n    ,vec2( 0.7025, -0.7117));\n\n    const vec2[] rw = vec2[NUM_j]\n    (vec2( 0.0135,  0.0   )\n    ,vec2( 0.0008,  0.0001)\n    ,vec2(-0.5762,  0.1282)\n    ,vec2( 0.0013,  0.0002)\n    ,vec2(-0.0135, -0.0085)\n    ,vec2( 0.1239, -0.0601)\n    ,vec2(-0.2162, -0.3769)\n    ,vec2( 0.1197, -0.1327)\n    ,vec2( 0.2544,  0.0708)\n    ,vec2( 0.3228,  0.3050)\n    ,vec2( 0.0377, -0.0056)\n    ,vec2( 0.0362, -0.0135)\n    ,vec2( 0.1439, -0.0871)\n    ,vec2( 0.0551,  0.0066)\n    ,vec2(-0.0935,  0.1492)\n    ,vec2(-0.2397,  0.1216)\n    ,vec2( 0.0218, -0.0211)\n    ,vec2( 0.0077, -0.0763));\n\n    const vec2[] rz = vec2[NUM_j]\n    (vec2( 0.366242, -0.365216)\n    ,vec2(-0.365216,  0.366242)\n    ,vec2(-0.012767, -0.414156)\n    ,vec2( 0.366242,  0.365216)\n    ,vec2(-0.366242, -0.365216)\n    ,vec2(-0.012767,  0.414156)\n    ,vec2( 0.216186, -0.397592)\n    ,vec2( 0.413695,  0.038296)\n    ,vec2(-0.413695,  0.038296)\n    ,vec2(-0.391705, -0.251311)\n    ,vec2(-0.383838,  0.291533)\n    ,vec2( 0.291533,  0.383838)\n    ,vec2( 0.383838, -0.291533)\n    ,vec2(-0.266502,  0.388876)\n    ,vec2(-0.372411, -0.341303)\n    ,vec2(-0.291533, -0.383838)\n    ,vec2( 0.378349,  0.316470)\n    ,vec2( 0.350877, -0.369995));\n\n    // polynomial barycentric representation\n    vec2 zn = vec2(0.); vec2 zd = vec2(0.);       \n    for(int j = 0; j<NUM_j; j++) {\n        vec2 zj = cdiv( rw[j], (z-rz[j]));\n        zn += cmul(rf[j], zj); // sum nominator\n        zd += zj;              // sum denominator\n    }\n    return cdiv(zn, zd);\n}\n\n/// 4D transformation\nvec3 rotz4D(in vec3 p, in float t, in float r_inv){\n    float a = 2.*PI*t;\n    p /= r_inv;\n    float rn = length(p);\n    float rn2 = dot(rn,rn);\n    vec2 zw = cmul(vec2(2.*p.z, rn2-1.),vec2(cos(a),sin(a)));\n    p = vec3(2.*p.xy,zw.x)/(rn2+1.-zw.y);   \n    return r_inv * p;\n}\n\n// map spherical platonic solid pyramidal-face-cells to one cell located at -z-axis.\nvec3 hexa_cells(in vec3 p, out float cell_id, out float sr){\n\t//// hexagon\n    // cells +X, -X, +Y, -Y,+Z, -Z\n    // cell walls defined by the face_normals\n    bool nBA = dot(vec3( 1., 0.,-1.),p)>=0.;\n\tbool nCA = dot(vec3( 0., 1.,-1.),p)>=0.;\n\tbool nDA = dot(vec3( 1., 1., 0.),p)>=0.;\n\tbool nCB = dot(vec3(-1., 1., 0.),p)>=0.;\n\tbool nDB = dot(vec3( 0., 1., 1.),p)>=0.;\n\tbool nDC = dot(vec3( 1., 0., 1.),p)>=0.;\n    // map (+X, -X, +Y, -Y,+Z, -Z)-cells to (-Z)-cell by rotation\n    // rotation angles\n    const float a90 = PI/2.; // a = 90°       \n    const vec2 ei_a0   = vec2(1., 0.);             // a = 0° \n    const vec2 ei_a90  = vec2(cos(a90), sin(a90)); // a = 90°\n    \n    vec2 ei_y; vec2 ei_x;\n\t//inside cell +X: +X --> -Z\n\tif(nBA && nDA && !nCB && nDC) {\n\t\tcell_id = 0.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -X: -X --> -Z\n\telse if(!nBA && !nDA && nCB && !nDC) {\n\t\tcell_id = 1.;\n\t\tei_y = -ei_a90;\n\t\tei_x = ei_a0;\n\t}\n    //inside cell +Y: +Y --> -Z\n\telse if(nCA && nDA && nCB && nDB) {\n\t\tcell_id = 2.;\n\t\tei_y = -ei_a90;\n\t\tei_x = -ei_a90;\n\t}\n\t//inside cell -Y: -Y --> -Z\n\telse if(!nCA && !nDA && !nCB && !nDB ) {\n\t\tcell_id = 3.;\n\t\tei_y = ei_a90;\n\t\tei_x = ei_a90;\n\t}\n\t//inside cell +Z: +Z --> -Z\n\telse if(!nBA && !nCA && nDB && nDC) {\n\t\tcell_id = 4.;\n\t\tei_y = -ei_a0; // 180°\n\t\tei_x = ei_a0;\n\t}\n\t//inside cell -Z: -Z --> -Z\n\telse if(nBA && nCA && !nDB && !nDC) {\n\t\tcell_id = 5.;\n\t\tei_y = ei_a0;\n\t\tei_x = ei_a0;\n\t}        \n\t// cell orientation\n\tp.zx = cmul(p.zx,ei_y); // rotate around y-axis\n\tp.yz = cmul(p.yz,ei_x); // rotate around x-axis\n\t// non cyclic\n\tsr = 4.;\n    return p;\n}\n\n// stereographic projection \nfloat sig(float x) {\n    return x < 0. ? -1. : +1.; \n    }\n\nfloat dist(float x, float e) {\n    // e in [0., +inf]\n    return sign(x)*abs( pow(sign(x)*x, abs(e)) );\n    //return sign(x)*abs( pow(abs(x), abs(e)) );\n    }\n   \nvec2 r_poly_dist(vec2 z, vec2 e, float sh_a) {   \n    /// r-polygon-distribution\n    float r = length(z); z = (r<0.)? vec2(0) : z/r; \n    float d0 = 0.5 *abs(e.y-e.x);\n    float e2 = e.x + d0 + d0 * (2.*smoothstep(-1., 1., -sh_a) - 1.);\n    return dist(r, e2) * z;\n}   \n\nvec3 sp(vec3 zsr){\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // stereopraphic projection (complex plane to unit sphere)\n    float zz = dot(z,z); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(2. * z.x,  2. * z.y, -1. + zz);\n        }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(2. * z.x, -2. * z.y,  1. - zz);\n        }\n    pn /= 1.+zz;\n    return pn;\n}\n\nvec3 spb(vec3 zsr) {\n    vec2 z = zsr.xy; float sr = zsr.z;\n    // inverse stereograpic projection\n    float k = 2./(1.+dot(z,z)); vec3 pn;\n    if (bool(sig(sr))) {// north pole\n        pn = vec3(k*z, k-1.); }\n    else { // south pol\n        z = cinv(z);\n        pn = vec3(k*z, -(k-1.)); }\n    return pn;\n}\n\n// bb\nvec2 isphere(in vec3 ro, in vec3 rd, in float r) {\n    // https://iquilezles.org/\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;   \n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// colorspace transformations\nvec3 rgb2hsv(vec3 col) {\n    // https://en.wikipedia.org/wiki/HSL_and_HSV\n    col = clamp(col, 0., 1.); \n    //\n    float m_max = max(col.r,max(col.g,col.b));\n    float m_min = min(col.r,min(col.g,col.b));\n    float d = m_max-m_min;\n    // hue\n    float h = 0.; // if(d == 0.) undefined\n    if(m_max==col.r) {h = (col.g-col.b)/d+0.;}\n    if(m_max==col.g) {h = (col.b-col.r)/d+2.;}\n    if(m_max==col.b) {h = (col.r-col.g)/d+4.;}\n    h = fract(h/6.); // periodic in[0.,1.]\n    // value\n    float v = m_max;\n    // saturation\n    float s = (v == 0.)?0.: d/v;\n    return vec3(h,s,v);\n}\n\nvec3 h2rgb(float h){\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return rgb*rgb*(3.0-2.0*rgb); /* cubic smoothing */\n}\n\nvec3 hsv2rgb(float h, float s, float v){     \n    return v * mix( vec3(1.0), h2rgb(h), s); /* hue, saturation, value */\n}\n\n// srgb <--> rgb (linear)\nvec3 srgb2rgb(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 rgb2srgb(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3cz8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1403, 1403, 1439, 1457, 3177], [3179, 3179, 3250, 3250, 4205], [4207, 4207, 4252, 4252, 4462], [4464, 4464, 4506, 4532, 4728], [4730, 4730, 4796, 4929, 5355], [5357, 5357, 5412, 5435, 8180]], "test": "untested"}
{"id": "Dt3cz8", "name": "Aerial View", "author": "fishy", "description": "Something I made. No multisample antialiasing!\nChange scene scale in Common if it's too slow\nHas day night cycle", "tags": ["voronoi", "noise", "simple", "clouds", "fbm", "antialiasing", "aa", "stylized", "fwidth", "land"], "likes": 9, "viewed": 203, "published": 3, "date": "1698864325", "time_retrieved": "2024-07-30T17:24:39.117688", "image_code": "vec4 cubic(float v){\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w) * (1.0/6.0);\n}\n\nvec4 textureBc(sampler2D sampler, vec2 texCoords, int lod){\n\n   vec2 texSize = vec2(textureSize(sampler, lod));\n   vec2 invTexSize = 1.0 / texSize;\n   \n   texCoords = texCoords * texSize - 0.5;\n\n   \n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n\n    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\n    \n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n    \n    offset *= invTexSize.xxyy;\n    \n    vec4 sample0 = textureLod(sampler, offset.xz, float(lod));\n    vec4 sample1 = textureLod(sampler, offset.yz, float(lod));\n    vec4 sample2 = textureLod(sampler, offset.xw, float(lod));\n    vec4 sample3 = textureLod(sampler, offset.yw, float(lod));\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = textureBc(iChannel0, fragCoord/iResolution.xy*RES_SCALE, 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime iDate.w\n//#define iDate vec4(iTime)\n\n#define PI 3.1415926535\n#define TAU (2.0*PI)\n\n#define sstep(a, b, x) smoothstep(a-b, a+b, x)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat voronoi( in vec2 x, float t, float w )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n\tfloat m = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2(float(i), float(j));\n        vec2 o = hash22(n + g);\n        o = 0.5 + 0.5*sin(t + 6.2831*o);\n\t\tfloat d = length(g - f + o);\n\t\tfloat h = smoothstep(-1.0, 1.0, (m-d)/w);\n\t    m   = mix(m, d, h) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n\t\n\treturn m;\n}\n\nfloat noise(vec3 p)\n{\n    vec2 o = vec2(0, 1);\n    vec3 a = floor(p);\n    \n    vec3 i = fract(p);\n    i = 3.0*i*i-2.0*i*i*i;\n    float x, y;\n    \n    float xtl = hash13(a + o.xyx);\n    float xbl = hash13(a + o.xxx);\n    float xtr = hash13(a + o.yyx);\n    float xbr = hash13(a + o.yxx);\n    x = mix(mix(xbl, xtl, i.y), mix(xbr, xtr, i.y), i.x);\n    \n    float ytl = hash13(a + o.xyy);\n    float ybl = hash13(a + o.xxy);\n    float ytr = hash13(a + o.yyy);\n    float ybr = hash13(a + o.yxy);\n    y = mix(mix(ybl, ytl, i.y), mix(ybr, ytr, i.y), i.x);\n    \n    return mix(x, y, i.z);\n}\n\n#define fbm2(uv, func) (func(uv+10.0)*0.5+func(uv*2.0+10.0)*0.25)\n#define fbm4(uv, func) (fbm2(uv, func)+func(uv*4.0+10.0)*0.125+func(uv*8.0+10.0)*0.0625)\n#define fbm8(uv, func) (fbm4(uv, func)+func(uv*16.0+10.0)/16.0+func(uv*32.0+10.0)/32.0+func(uv*64.0+10.0)/64.0+func(uv*128.0+10.0)/128.0)\n\n#define OCEAN_COLOR vec3(0.3, 0.4, 0.8)\n#define SAND_COLOR vec3(0.9,0.75,0.4)\n#define LAND_COLOR vec3(0.2, 0.8, 0.3)\n#define SNOW_COLOR vec3(0.9, 0.9, 1.0)\n#define CLOUDS_COLOR vec3(1, 1, 1)\n\n#define srgb3(c) pow(c, vec3(2.2))\n\nconst vec4[] layers = vec4[] (\n                            vec4(srgb3(OCEAN_COLOR), 0.6),\n                            vec4(srgb3(SAND_COLOR) , 0.62),\n                            vec4(srgb3(LAND_COLOR) , 0.75),\n                            vec4(srgb3(SNOW_COLOR) , 1.0)\n                          );\n\nvec4 renderClouds(vec2 uv)\n{\n    vec2 vpos = uv*6.0+iTime*vec2(0.1, 0.000);\n    float v = voronoi(vpos, iTime*0.4, 1.0);\n    float n = fbm2(vec3(uv*2.0+30.0+iTime*vec2(0.1, 0.003), iTime*0.1), noise);\n    n = sstep(0.4+sin(iTime*0.01)*0.1, 0.2, n);\n    v = n-v;\n    v = smoothstep(0.0, fwidth(v), v);\n    return vec4(CLOUDS_COLOR, 1)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord /= RES_SCALE;\n    if(any(greaterThan(fragCoord, iResolution.xy)))\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n        vec2 mo = (iMouse.xy*2.0-iResolution.xy)/iResolution.y;\n        uv += iTime*vec2(0.1, 0.003);\n        vec4 land, clouds;\n        float sunAngle = fract(iDate.w/86400.0-0.325)*TAU;\n        float sunGrad = max(0.0,sin(sunAngle));\n\n        clouds = renderClouds(uv);\n        float cloudsShadow = renderClouds(uv-vec2(0.1*tan(sunAngle-PI*0.5), 0)).a*0.75;\n        cloudsShadow *= pow(sunGrad, 0.2);\n\n        float n = fbm4(vec3(uv*2.0, 0), noise);\n        land = vec4(layers[0].rgb, 1);\n        for(int i = 1; i < layers.length(); i++)\n        {\n            land.rgb = mix(land.rgb, layers[i].rgb, smoothstep(n+fwidth(n), n, layers[i-1].w));\n        }\n\n        fragColor.a = 1.0;\n        fragColor = land;\n        fragColor.rgb *= 1.0-cloudsShadow;\n        fragColor.rgb = mix(fragColor.rgb, clouds.rgb, clouds.a);\n        fragColor.rgb *= 1.01-pow(vec3(pow(1.0-sunGrad, 2.0)), vec3(6.0, 4.0, 3.0));\n        fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n        fragColor = mix(texture(iChannel0, (fragCoord*RES_SCALE)/iResolution.xy), fragColor, 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RES_SCALE 1.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 254], [256, 256, 315, 315, 1193], [1195, 1195, 1252, 1252, 1331]], "test": "untested"}
{"id": "DtccR8", "name": "Cell Swap Automata", "author": "SnoopethDuckDuck", "description": "This is inspired by Fabrice's shader\nhttps://www.shadertoy.com/view/dtSfRh\n\nand this twitter (formerly known as X) post:\nhttps://twitter.com/junkiyoshi/status/1697571241513910691\n", "tags": ["grid", "automata", "cell", "cool", "ca", "reproduction"], "likes": 46, "viewed": 520, "published": 3, "date": "1698862484", "time_retrieved": "2024-07-30T17:24:40.048199", "image_code": "// This is inspired by Fabrice's shader\n// https://www.shadertoy.com/view/dtSfRh\n\n// and this twitter (formerly known as X) post:\n// https://twitter.com/junkiyoshi/status/1697571241513910691\n\n// I think it would go well with Shane's moving cubes\n// https://www.shadertoy.com/view/cdtfWS\n\n// Rough overview:\n// Buffer A runs a cellular automata where:\n// - each cell is on or off\n// - each cell picks a neighbour cell to move into\n// - if an on/off pair want to move into each other, they swap\n// - when in a moving state, cells increment a timer\n\n// Image interprets Buffer A by:\n// - drawing \"on\" cells\n// - offsetting cell circle positions using the cell's timer\n\n#define pi 3.14159\n\nvoid mainImage( out vec4 o, vec2 px )\n{\n    px *= .06;\n    o = texture(iChannel0, px / iResolution.xy);\n\n    // Mix between cell positions\n    // Flip o.a motion with on/off value o.g\n    float mx = mix(o.a, 1.-o.a, o.g);\n    mx = smoothstep(0.2, 0.8, mx);\n    \n    vec2 dir = indexToDir(o.b);\n    vec2 f = fract(px) -.5 - mx*dir;\n    float s = smoothstep(0., .1, .3+.2*o.r-length(f));\n    \n    vec4 col = .6+.4*cos(2.*pi*(2.*o.r+vec4(0,1.5,2,0)/6.));\n    \n    o = sqrt(s * col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 indexToDir(float i) {\n    if (i == 0.) return vec2(-1, 0);\n    if (i == 1.) return vec2( 0, 1);\n    if (i == 2.) return vec2( 1, 0);\n    return vec2(0, -1);\n}\n\nfloat dirToIndex(vec2 u) {\n    if (u == vec2(-1, 0)) return 0.;\n    if (u == vec2( 0, 1)) return 1.;\n    if (u == vec2( 1, 0)) return 2.;\n    return 3.;\n}\n\n// From Fabrice\n// https://www.shadertoy.com/view/WttXWX\n#define hashi(x) triple32(x)\n#define hash(x)  ( float( hashi(floatBitsToUint(hash13(x))) ) / float( 0xffffffffU ) )\n\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_a_code": "float getIndex(vec2 u) {\n    return floor(4.*hash(vec3(u,.1*iTime)));\n}\n\nvec2 getDir(vec2 u) {\n    return indexToDir(getIndex(u));\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    if (iFrame < 1) {\n        o.r = hash12(u);     // Color\n        o.g = step(.2, o.r); // 0=off, 1=on\n        o.b = 0.;            // Direction index 0,1,2,3\n        o.a = 1.;            // Motion timer [0,1] range\n    } \n    else {\n        o = texelFetch(iChannel0, ivec2(u), 0);  \n        \n        vec2 dir = getDir(u);\n        vec2 cdir = getDir(u + dir);\n        vec4 c = texelFetch(iChannel0, ivec2(u + dir), 0);\n        \n        // Increment motion timer\n        float inc = .05 * (1.-o.r) * 60. * iTimeDelta;\n        if (o.a < 1.) \n            o.a = min(1., o.a+inc);\n            \n        // Swap cells if:\n        // - other cell is not moving\n        // - other cell wants to move to this cell\n        // - other cell's on/off value is different to this cell\n        else if (c.a == 1. && dir == -cdir && o.g+c.g == 1.) {\n            // Off cells change their color, on cells keep color\n            if (o.g == 0.)\n                o.r = c.r;\n            o.g = c.g;         // Swap on/off value\n            o.b = getIndex(u); // Store direction for Image tab\n            o.a = 0.;          // Initialize timer\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtccR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[686, 686, 725, 725, 1167]], "test": "untested"}
{"id": "DsyBWd", "name": "Shell Texturing (grass)", "author": "Falken", "description": "Implementation of Shell Texturing using a SDF, with technique described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\n", "tags": ["grass", "fur", "shell", "acerolafurrychallenge"], "likes": 5, "viewed": 469, "published": 3, "date": "1698855568", "time_retrieved": "2024-07-30T17:24:40.888951", "image_code": "// a simple implementation of Shell Texturing, as described by Acerola: https://www.youtube.com/watch?v=9dr-tRQzij4\n// coded by Michael Tedder (@_falken / brs^bas)\n//\n// uses SDFs for each layer in place of drawing multiple quads.\n// for a slightly better demo, see: https://www.shadertoy.com/view/dlVyWm\n// (not terribly optimized due to lack of time, sorry!)\n//\n// hat tips to:\n// 1. sdf/lighting: https://www.shadertoy.com/view/stcGRX\n// 2. noise: https://www.shadertoy.com/view/4dS3Wd\n\n// feel free to tweak any of these values below:\nconst int kSubsampleFactor = 1;         // sampling quality, any positive integer > 0\nconst int kNumberOfLayers = 32;         // number of shell layers, any positive integer > 0\nconst float kShellDensity = 500.0;      // detail of points in each layer, any positive value > 0\nconst float kShellLayerSpacing = 0.1;   // spacing between each layer, any positive value > 0\n\n// precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat sdBox(vec3 position, vec3 halfSize)\n{\n\tposition = abs(position) - halfSize;\n\treturn length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0);\n}\n\nfloat sdf(in vec3 position)\n{ \n\tfloat halfWidth = 0.5; \n\tfloat halfHeight = 0.001;\n\tfloat halfDepth = 0.5;\n\treturn sdBox(position, vec3(halfWidth, halfHeight, halfDepth));\n}\n\nvec3 normal(vec3 position)\n{\n\tfloat epsilon = 0.001;\n\tvec3 gradient = vec3(\n\t\tsdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n\t\tsdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n\t\tsdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n\t);\n\treturn normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection, vec3 translation)\n{\n\tint stepCount = 128 * 2;\n\tfloat maximumDistance = 5.0;\n\tfloat t = 0.0;\n\tfor (int i = 0; i < stepCount; i++) {\n\t\tif (t > maximumDistance) {\n\t\t\tbreak;\n\t\t}\n\t\tvec3 position = rayOrigin + rayDirection * t;\n\t\tfloat d = sdf(position + translation);\n\t\tif (d < 0.0001) {\n\t\t\treturn t;\n\t\t}\n\t\tt += d;\n\t}\n\treturn 0.0;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to)\n{\n\tvec3 forward = normalize(to - from);\n\tvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n\tvec3 up = cross(right, forward);\n\treturn mat3(right, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat angle = 0.5 * (iTime - 8.0);\n\tvec3 cameraOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n\tvec3 cameraTarget = vec3(0.0);\n\tmat3 cameraTransform = lookAtMatrix(cameraOrigin, cameraTarget);\n\tvec3 result = vec3(0.0);\n    \n    const float layerYInc = 1.0 / float(kNumberOfLayers);\n    \n\tivec2 sampleCount = ivec2(kSubsampleFactor, kSubsampleFactor);\n\tfor (int y = 0; y < sampleCount.y; y++)\n    {\n\t\tfor (int x = 0; x < sampleCount.x; x++)\n        {\n\t\t\tvec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n\t\t\tuv = uv / iResolution.xy;\n\t\t\tuv = (uv * 2.0) - 1.0;\n\t\t\tuv.x *= iResolution.x / iResolution.y;\n\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n\t\t\trayDirection = cameraTransform * rayDirection;\n            \n\t\t\tvec3 color = vec3(0.0);\n            float layerY = 0.0;\n            for (int layerIndex = 0; layerIndex < kNumberOfLayers; ++layerIndex)\n            {\n                vec3 translation = vec3(0.0, -layerY * kShellLayerSpacing, 0.0);\n                float t = raycast(cameraOrigin, rayDirection, translation);\n                if (t > 0.0)\n                {\n                    // same style that iq uses in his shaders\n                    vec3 position = cameraOrigin + rayDirection * t;\n                    vec3 lightDirection = vec3(0.57735);\n                    vec3 n = normal(position);\n                    float diffuseAngle = max(dot(n, lightDirection), 0.0);\n\n                    // position (xz along plane) is in range [-0.5 .. +0.5] so renormalize for noise\n                    float v = noise(position.xz * kShellDensity);\n                    if (v > max(0.1, layerY)) {\n                        color = vec3(0.0, max(0.1, layerY), 0.0);\n                        color *= diffuseAngle;\n                    }\n                }\n                layerY += layerYInc;\n            }\n\t\t\t// gamma        \n\t\t\tcolor = sqrt(color);\n\t\t\tresult += color;\n\t\t}\n\t}\n\tresult /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsyBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[910, 984, 1004, 1004, 1109], [1111, 1111, 1132, 1132, 1469], [1471, 1471, 1514, 1514, 1647], [1649, 1649, 1678, 1678, 1822], [1824, 1824, 1852, 1852, 2167], [2169, 2169, 2237, 2237, 2545], [2547, 2547, 2586, 2586, 2756], [2758, 2758, 2813, 2813, 4812]], "test": "untested"}
{"id": "csVfDt", "name": "Octagramatron", "author": "ElSolem", "description": "https://www.shadertoy.com/view/tlVGDt", "tags": ["parallax", "octagram"], "likes": 8, "viewed": 134, "published": 3, "date": "1698847640", "time_retrieved": "2024-07-30T17:24:41.982028", "image_code": "precision highp float;\n\nfloat gTime = 0.0;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n    pos *= scale;\n    float base = sdBox(pos, vec3(0.4, 0.4, 0.1)) / 1.5;\n    pos.xy *= 5.0;\n    pos.y -= 3.5;\n    pos.xy *= rot(0.75);\n    float result = -base;\n    return result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n    vec3 pos_origin = pos;\n    pos = pos_origin;\n    pos.y += sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box1 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.y -= sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box2 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.x += sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box3 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.x -= sin(gTime * 0.4) * 2.5;\n    pos.xy *= rot(0.8);\n    float box4 = box(pos, 2.0 - abs(sin(gTime * 0.4)) * 1.5);\n    pos = pos_origin;\n    pos.xy *= rot(0.8);\n    float box5 = box(pos, 0.5) * 6.0;\n    pos = pos_origin;\n    float box6 = box(pos, 0.5) * 6.0;\n    float result = max(max(max(max(max(box1, box2), box3), box4), box5), box6);\n    return result;\n}\n\nfloat map(vec3 pos, float iTime) {\n    vec3 pos_origin = pos;\n    float box_set1 = box_set(pos, iTime);\n    return box_set1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 2.0;\n\n    if (abs(xy) < abs(threshold)) {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec3 ro = vec3(0.0, -0.2, iTime * 4.0);\n        vec3 ray = normalize(vec3(p, 1.5));\n        ray.xy = ray.xy * rot(sin(iTime * 0.03) * 5.0);\n        ray.yz = ray.yz * rot(sin(iTime * 0.05) * 0.2);\n        float t = 0.1;\n        vec3 col = vec3(0.0);\n        float ac = 0.0;\n\n        for (int i = 0; i < 99; i++) {\n            vec3 pos = ro + ray * t;\n            pos = mod(pos - 2.0, 4.0) - 2.0;\n            gTime = iTime - float(i) * 0.01;\n\n            float d = map(pos, iTime);\n            d = max(abs(d), 0.01);\n            ac += exp(-d * 23.0);\n            t += d * 0.55;\n        }\n\n        col = vec3(ac * 0.02);\n        col += vec3(0.0, 0.2 * abs(sin(iTime)), 0.5 + sin(iTime) * 0.2);\n        fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * sin(iTime)));\n    } else {\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec3 ro = vec3(0.0, -0.2, iTime * 4.0);\n        vec3 ray = normalize(vec3(p, 1.5));\n        ray.xy = ray.xy * rot(sin(iTime * 0.03) * 5.0);\n        ray.yz = ray.yz * rot(sin(iTime * 0.05) * 0.2);\n        float t = 0.1;\n        vec3 col = vec3(0.0);\n        float ac = 0.0;\n\n        for (int i = 0; i < 99; i++) {\n            vec3 pos = ro + ray * t;\n            pos = mod(pos - 2.0, 4.0) - 2.0;\n            gTime = iTime - float(i) * 0.01;\n\n            float d = map(pos, iTime);\n            d = max(abs(d), 0.01);\n            ac += exp(-d * 23.0);\n            t += d * 0.55;\n        }\n\n        col = vec3(ac * 0.02);\n        col += vec3(0.0, 0.2 * abs(sin(iTime)), 0.5 + sin(iTime) * 0.2);\n        fragColor = vec4(col, 1.0 - t * (0.02 + 0.02 * sin(iTime)));\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 86, 105, 105, 171], [173, 173, 202, 202, 297], [299, 299, 333, 333, 516], [518, 518, 556, 556, 1408], [1410, 1410, 1444, 1444, 1536], [1538, 1538, 1593, 1593, 3509]], "test": "untested"}
{"id": "DsKfDt", "name": "PolyParallax Pyramid", "author": "ElSolem", "description": "https://www.shadertoy.com/view/tsXBzS :: xy = p.x / p.y", "tags": ["parallax", "4d", "pyramid"], "likes": 4, "viewed": 103, "published": 3, "date": "1698847631", "time_retrieved": "2024-07-30T17:24:42.854695", "image_code": "vec3 palette(float d) {\n    return mix(vec3(0.2, 0.7, 0.9), vec3(1.0, 0.0, 1.0), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    for (int i = 0; i < 8; ++i) {\n        float t = iTime * 0.2;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    return dot(sign(p), p) / 5.0;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\n\nbool Alakazan(float value1, float value2) {\n    return (value1 == value2) || (value1 != value2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 2.0;\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(xy, threshold);\n\n    if (alakazanResult) {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n        vec3 ro = vec3(0.0, 0.0, -50.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    } else {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n        vec3 ro = vec3(0.0, 0.0, -50.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 86], [88, 88, 118, 118, 198], [200, 200, 219, 219, 444], [446, 446, 473, 473, 855], [857, 857, 900, 900, 955], [957, 957, 1012, 1012, 2166]], "test": "untested"}
{"id": "Dt3yzr", "name": "Widynski's \"Squares\" Hash", "author": "domrally", "description": "32 bit uniform randomness that is difficult to distinguish from true random. Source 64 bit version passes big crush randomness tests. This one does not have a big enough period to pass.\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]", "tags": ["noise", "pixel", "random", "generator", "state", "hash", "squares", "pseudo", "entropy", "seed", "weyl", "rng", "philox", "crush", "bernard", "widynski"], "likes": 5, "viewed": 197, "published": 3, "date": "1698847287", "time_retrieved": "2024-07-30T17:24:43.737335", "image_code": "/// by Dom Mandy in 2023\n/// (Thanks for corrections & discussion everyone!)\n\n\n/*\nSquares rng from Bernard Widynski in 2020 (based on version 6 - Feb 1, 2022).\nNOT cryptographic.\nOriginal 64 bit version passes the big crush tests.\nThis is a 32 bit translation that does not pass.\n*/\nuint hash(uint seed) {\n    uint t, x, y, z, key = 0xc8e42f6du;\n\n    y = x = key * seed; z = y + key;\n    x = x * x + y; x = (x>>16) | (x<<16);\n    x = x * x + z; x = (x>>16) | (x<<16);\n    x = x * x + y; x = (x>>16) | (x<<16);\n    t = x = x * x + z; x = (x>>16) | (x<<16);\n    \n    return t ^ (x * x + y) >> 16;\n}\n\n\n/*\nUniform pseudorandom number generator.\nGPU friendly since it doesn't need the previous random number for the next one.\n*/\nfloat random(float seed) {\n    // maximum unsigned int to normalize float (thanks @spalmer!)\n    return float(hash(floatBitsToUint(seed))) / float(~0u);\n}\n\n\nvoid mainImage(out vec4 pixel, vec2 i) {\n    vec2 uv = ceil(i / 9.) * 9.;    \n    uv.x += iDate.w + float(iFrame);\n    uv.y *= iResolution.x;\n\n    // seed with unique value per coordinate\n    vec3 v = vec3(random(uv.y + uv.x), random(2. * uv.y + uv.x), random(3. * uv.y + uv.x)),\n    \n    color = mix(v, vec3(v.x), roundEven(i.x / iResolution.x));\n    pixel.rgb = pow(color, vec3(1) / 2.2);\n}\n\n\n/*\nFURTHER READING\n\nhttps://squaresrng.wixsite.com/rand\nhttps://arxiv.org/pdf/2004.06278.pdf\nhttps://en.wikipedia.org/wiki/TestU01\nhttps://en.wikipedia.org/wiki/Middle-square_method\nhttps://en.wikipedia.org/wiki/Counter-based_random_number_generator\nhttps://en.wikipedia.org/wiki/List_of_random_number_generators#Pseudorandom_number_generators_(PRNGs)\n*/\n\n\n/*\nSIMILAR HASHES\n\nu32noise4 OC by FordPerfect in 2023\nhttps://www.shadertoy.com/view/mdGBWc\n\nphilox4x32_7 implemented by tomohiro in 2017\nhttps://www.shadertoy.com/view/XslBR4\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3yzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 283, 305, 305, 596], [599, 724, 750, 816, 878], [881, 881, 921, 921, 1273]], "test": "untested"}
{"id": "cldyRn", "name": "Breathing Terrain", "author": "ersh", "description": "Breathing Terrain (meditation).\nThis shader demonstrates generation of smooth random functions, over space and time.", "tags": ["2d", "fractal", "terrain", "generative", "meditaion"], "likes": 4, "viewed": 150, "published": 3, "date": "1698845630", "time_retrieved": "2024-07-30T17:24:44.668845", "image_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nfloat stylize(float cc, float tf, float ts) {\n    float pw = pow(cc,0.8);\n    float cr = (floor(pw*30. + ts)-ts)/30. + fract(cc*30. + tf)/20.;\n    return cr;\n}\n\nfloat stylize2(float cc, float tf, float ts) {\n    float pw = cc * 1.06;//pow(cc,0.8);\n    float cr = (floor(pw*5. + ts)-ts)/5. + fract(cc*10. + tf);\n    return cr;\n}\n\nfloat atan2f(vec2 v, float sc, float sh, float sha) {\n    float a = v.y != 0. ? atan(v.x / v.y) : 3.14159265358/2.;\n    return fract((a / 3.1415926 + sha) * sc + sh);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int maxx = int(iResolution.x)-1;\n\n    // Land\n    float c = T(ivec2(int(fragCoord.x), 3), maxx).r + 0.4;\n    if (c > uv.y) {\n        float cc = uv.y - c + 0.8;\n        fragColor = vec4(vec3(stylize(cc, 0., 0.))*vec3(0.7, 0.5, 0.3), 1.0);\n        return;\n    }\n\n    vec2 cs = iResolution.xy*vec2(0.75, 0.65);\n    float d = distance(fragCoord.xy, cs);\n    float r = min(iResolution.x, iResolution.y) * 0.17;\n\n    // Sun\n    cs = iResolution.xy*vec2(0.75, 0.65);\n    d = distance(fragCoord.xy, cs);\n    r = min(iResolution.x, iResolution.y) * 0.17;\n    r *= pow(T(ivec2(int(atan2f(fragCoord - cs, 5., iTime / 40., 0.5)*iResolution.x), 2), maxx).r + 0.5, 5.) * 5. + 0.4;\n    if (d < r) {\n        float cc = d / r;\n        fragColor = vec4(vec2(stylize(1.-cc*0.2, iTime/3., iTime/5.)), 1.-cc, 1.0);\n        return;\n    }\n    \n    // Stars\n    for (int i = 0; i < 20; i++) {\n        cs = iResolution.xy * (hash21(float(i+1)) * vec2(1., 0.6) + vec2(0, 0.4));\n        d = distance(fragCoord.xy, cs);\n        r = min(iResolution.x, iResolution.y) * 0.1;\n        r *= pow(T(ivec2(int(atan2f(fragCoord - cs, 2., -iTime * (hash11(float(i+1))-0.5)/10., float(i*2))*iResolution.x), 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        if (d < r) {\n            float cc = d / r;\n            fragColor = vec4(vec3(stylize2(1.-cc*0.3, iTime*1.5, iTime)), 1.0);\n            return;\n        }\n    }\n\n    // Cloud\n    for (int n = 0; n < 4; n += 1) {\n        float h = (T(ivec2(fragCoord.x, 2), maxx).r + 0.0) * 0.1;\n        cs = iResolution.xy*vec2(0.45 - float(n) * 0.05, 0.45 + h);\n        d = distance(fragCoord.xy * vec2(1.,1.), cs);\n        r = min(iResolution.x, iResolution.y) * (0.21 - float(n)*0.015);\n        float sc = smoothstep(0.41 + h, 0.44 + h, uv.y);\n        //float sc = 1.-pow(1.-smoothstep(0.41, 0.44, uv.y), 2.);\n        r *= (T(ivec2(int(atan2f(fragCoord - cs, 1., 3.1415926/2., -iTime * (float(n) - 1.4) / 100.)*iResolution.x), 4+n), maxx).r + 0.5) * 0.5 * sc + 0.1;\n        if (d < r) {\n            float cc = d / r;\n            //fragColor = vec4(vec3(stylize((1.-cc*0.1), iTime/5., iTime/15.) * (smoothstep(0.41, 0.5, uv.y)*0.9 + 0.1)), 1.0);\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    \n\n    // Water\n    if (uv.y < 0.35) {\n        c = T(ivec2(int(fragCoord.x), 2), maxx).r/5. + 0.35;\n        float cc = 1. - pow(uv.y - c + 0.9, 10.);\n        fragColor = vec4(0.,  vec2(stylize(cc, -iTime/3., -iTime/5.))* vec2(0.4, 0.45), 1.0);\n        return;\n    }\n\n    // Sky\n    float cc = uv.y * 1.3 - 0.5;\n    //float cc = (1.-uv.y) * 1.1 - 0.1;\n    fragColor = vec4(0., 0., stylize(cc, -iTime/8., iTime/12.), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(iResolution.x)/log(2.)) - 3.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\n//#define MOD(X)  ((X + iResolution_i.x) % iResolution_i.x)\n#define MOD(X)  X\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 30.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x-1;\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n\n    float c = randt(fragCoord_i, tier, fragCoord.y) * float(st) * pow_of_2_adj(iResolution.xy);\n    //if (tier < tier_n(pow2ceil(iResolution_i.x))-2) {\n        c += (T(ivec2(MOD(fragCoord_i.x - st), fragCoord_i.y), maxx).r + T(ivec2(MOD(fragCoord_i.x + st), fragCoord_i.y), maxx)).r / 2.;\n    //}\n    fragColor = vec4(vec3(c), 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 75, 75, 150], [152, 152, 197, 197, 311], [313, 313, 359, 359, 479], [481, 481, 534, 534, 649], [651, 692, 713, 713, 846], [847, 847, 869, 869, 997], [998, 998, 1021, 1021, 1106]], "test": "untested"}
{"id": "ddyyWy", "name": "Predator Target", "author": "misterprada", "description": "Shader Journey Introduction (Predator Laser Target)", "tags": ["target", "neon", "predator", "shaderjourney"], "likes": 4, "viewed": 293, "published": 3, "date": "1698842438", "time_retrieved": "2024-07-30T17:24:45.583399", "image_code": "float SDF_Triangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)/sign(p.y);\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.6, 0.1, 0.2);\n    vec3 b = vec3(0.6, 0.7, 0.4);\n    vec3 c = vec3(1.0, .0, .3);\n    vec3 d = vec3(0.463,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // Fix resize window\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Simplified formula of the lines above\n    //vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n    // Rotate\n    //uv = rotate(uv, (sin(iTime) + cos(iTime)) * 2.);\n\n    // Zoom \n    //uv /= abs(sin(iTime) + cos(iTime)) + 0.4;\n\n    // Draw Triangle\n    float d = SDF_Triangle(uv, 0.7);\n    d = abs(d);\n    d = 0.02 / d;\n    color *= d;\n\n    float d_triangle = d;\n\n    // Draw Circle\n    float flasLight = abs(sin(iTime))  + .3;\n    d = length(uv);\n    d = abs(d);\n    d = 0.4 / d;\n    color *= smoothstep(0.55, 0.9, d);\n    //color *= flasLight;\n\n    color -= abs(sin(palette(d_triangle + iTime)));\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 254], [256, 256, 281, 281, 463], [465, 465, 522, 572, 1493]], "test": "untested"}
{"id": "msKBzD", "name": "Spiral Triad", "author": "misterprada", "description": "[url]https://github.com/MisterPrada[/url]", "tags": ["colors"], "likes": 23, "viewed": 424, "published": 3, "date": "1698841062", "time_retrieved": "2024-07-30T17:24:46.487981", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.000,1.000,0.000);\n    vec3 d = vec3(0.5,0.2,0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat SDF_Triangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)/sign(p.y);\n}\n\nfloat spiral(in vec2 p)\n{\n    float x = p.x*3.;\n    float m = min (fract (x), fract (3. -x)) ;\n    return smoothstep (-0.2, .5, m*.5+.2-p.y) ;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec2 st = vec2 (atan(uv.x, uv.y), length (uv)) ;\n    uv = vec2 (st.x / 6.2831+.5 - sin(-iTime + st.y), st.y);\n    float c = 0.0;\n    \n    float triangle = SDF_Triangle((fragCoord.xy-.5*iResolution.xy) / iResolution.y, .3);\n    \n    c = spiral(uv) * 2. * spiral(vec2(spiral(uv / 0.6), triangle));\n    \n    \n    c += triangle * 0.6;\n\n    \n    vec3 col = palette(length(st.y) + .4 + iTime*.4);\n    col *= c;\n    \n    \n    uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    c *= smoothstep(0.0, 0.05, length(uv));\n\n    col *= c;\n\n    st.x=fract(9.*sin(8.*(ceil(st.x*384.)/128.)));\n\n    float\n        t=iTime*2.*((st.x+.5)/2.), \n        b=pow(1.-fract(st.y+st.x+t),4.);\n\n    b=(b*.5)+step(1.-b,.05);\n    col += st.y * b*vec3(0.,.5,1.);\n    \n    \n    fragColor = vec4 (col, 1.) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 204], [206, 206, 251, 251, 460], [462, 462, 487, 487, 606], [608, 608, 665, 665, 1522]], "test": "untested"}
{"id": "cltyzr", "name": "3D Procedural Texture Generator", "author": "blackholes", "description": "How to use it?\nSave the picture from z=1 to z=textureSize/amount in full screen mode.If texture size is 128 and the amount is 8,you will get 16 pictures and cut each the size to 128x1024.Create a new 128x16384 picture and splicing them from top to bottom.", "tags": ["procedural", "3d", "cube", "texture", "color", "coordinate"], "likes": 1, "viewed": 242, "published": 3, "date": "1698839462", "time_retrieved": "2024-07-30T17:24:47.246951", "image_code": "const int colorType=0;\nint z=\n1\n;\n//z:coordnate xyz\n\nconst int amount=8;//How much be shown at once\nconst float textureSize=128.f;//texture3D size:128x128x128\n#define PI 3.1415926535f\nfloat j;\nvec3 r;\nvec3 random3(vec3 c) {\n\tj = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333,G3 =  0.1666667;\n/* 3d simplex noise */\nvec3 s,x,e,i1,i2,x1,x2,x3;\nvec4 w,d;\nfloat simplex3d(vec3 p) {\np*=0.5f;\n//p.z*=0.5f;\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t s = floor(p + dot(p, vec3(F3)));\n\t x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t e = step(vec3(0.0), x - x.yzx);\n\t i1 = e*(1.0 - e.zxy);\n\t i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t x1 = x - i1 + G3;\n\t x2 = x - i2 + 2.0*G3;\n\t x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return 30.f/15.f*dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.545f*simplex3d(m)+\n    0.545f*simplex3d(m/exp(1.f))+\n    0.545f*simplex3d(m/exp(2.f));\n}\n\nfloat devide(float x)\n{\nif(x<0.5f)\nreturn x*x*2.f;\nelse\n{\nreturn 1.f-(x-1.f)*(x-1.f)*2.f;\n}\n}\n\n\tfloat value;\n    vec2 p;\n    vec3 p3;\n    const vec3 GRID_DIMS = textureSize*vec3(0.5f, 0.5f, 0.5f);\nvec3 a;\nvec3 m;\nvec3 color,color1,color2;\nbool isBright;\nint z2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tp.x = fragCoord.x;\n    p.y = iResolution.y-fragCoord.y;\nz=(z-1)*amount;\n    if(p.x>=0.f&&p.x<textureSize&&\n    p.y>=0.f&&p.y<textureSize*float(amount)\n    )\n    {\n    for(int i=1;i<=amount;i++)\n    {\n    if(p.y>=textureSize*float(i-1)&&p.y<textureSize*float(i))\n    {\n    p3.y=p.y-textureSize*float(i-1);\n    z2=z+i;\n    }\n    }\n    p3 = vec3(p.x,p3.y, float(z2)-0.5f);\n    if(p3.z>=0.f&&p3.z<textureSize)\n    {\n      \n        if(colorType==0)\n        {//COORDINATE\n            vec3 coordinate3D=p3/textureSize;\n            color=coordinate3D;\n        }\n         if(colorType==1)\n        {//3D NOISE\n            color=0.6f+vec3(0.2f)*simplex3d(p3);\n        }\n        if(colorType==2)\n        {//3D FRACTAL\n            color=0.6f+vec3(0.2f)*simplex3d_fractal(p3);\n        }\n    }\n}\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 223, 223, 381], [534, 534, 559, 559, 1708], [1748, 1815, 1848, 1848, 1952], [1954, 1954, 1977, 1977, 2047], [2216, 2216, 2273, 2273, 3087]], "test": "untested"}
{"id": "DltcRn", "name": "film with black mask divider", "author": "zyc", "description": "film with black mask divider", "tags": ["mask", "film", "open"], "likes": 0, "viewed": 159, "published": 3, "date": "1698836956", "time_retrieved": "2024-07-30T17:24:48.232317", "image_code": "\n#define MIN_SIZE 0.02\n#define MAX_SIZE 0.5\n\n// Draw dividing bars.\nfloat dividingBar(float p,float start, float end){\n    return 1.0 - step(start, p) * step(p, end);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float progress = fract(0.2 * iTime);\n    \n    vec4 origin = texture(iChannel0, uv);\n    \n    float luminance = 0.2126 * origin.r + 0.7152 * origin.g + 0.0722 * origin.b;\n\n    // Time varying pixel color\n    vec3 col = mix(vec3(luminance), origin.rgb, step(0.5, uv.x));\n    \n    col *= dividingBar(uv.x, 0.5, 0.5 + mix(MIN_SIZE, MAX_SIZE, 1.0 - progress));\n\n    // Output to screen \n    fragColor = vec4(col,origin.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 68, 118, 118, 168], [171, 171, 228, 278, 742]], "test": "untested"}
{"id": "ctdyRn", "name": "Green Mercury 2", "author": "dr2", "description": "Metallic slime (mercury?) in channels formed by dynamic(!) random rectangular tiling\n(mouseable, click upper-right for new run)", "tags": ["collision", "metaballs", "dynamics", "physics"], "likes": 26, "viewed": 287, "published": 3, "date": "1698833650", "time_retrieved": "2024-07-30T17:24:49.434103", "image_code": "// \"Green Mercury 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Mix of \"Green Mercury\" and \"Random Rectangular Tiling\")\n\n#define AA    0  // (= 0/1) optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat Minv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nmat3 DirVuMat (vec3 vd);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 vnObj, ltDir;\nfloat tCur, dstFar, surfHt, surfScl;\nint nFrame, nBall, idBall, txOff;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define H(z) (0.6 + 0.4 * cos (0.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  s = - (ro.y - surfHt) / rd.y;\n  sLo = s;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - SurfHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > SurfHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++)\n     d = SmoothMin (d, PrSphDf (p - Loadv4 (txOff + 3 * n).xyz, 0.45), 2.);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh, nDotL;\n  bgCol = vec3 (0.6, 0.6, 0.55);\n  dstObj = ObjRay (ro, rd);\n  dstSurf = (rd.y < 0.) ? SurfRay (ro, rd) : dstFar;\n  col = bgCol;\n  if (min (dstObj, dstSurf) < dstFar) {\n    sh = 1.;\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      col4 = vec4 (0.5, 1., 0.2, 0.3);\n      vn = ObjNf (ro);\n    } else {\n      ro += dstSurf * rd;\n      col4 = vec4 (mix (vec3 (0.4, 0.3, 0.3), vec3 (0.6, 0.6, 0.6),\n         smoothstep (0., 0.1, ro.y)), 0.05);\n      vn = SurfNf (ro);\n      if (ro.y < 0.02) vn = VaryNf (2. * ro, vn, 1. - smoothstep (0.5, 0.7, dstSurf / dstFar));\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstSurf) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (bgCol, col, min (1., exp2 (8. * (1. - 1.2 * min (dstObj, dstSurf) / dstFar))));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr, bMid;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  txOff = 3;\n  stDat = Loadv4 (0);\n  surfHt = stDat.x;\n  surfScl = stDat.y;\n  nBall = int (stDat.w);\n  mPtr.xyz = Loadv4 (1).xyz;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az = -2. * pi * mPtr.x;\n    el = -0.5 * pi * mPtr.y;\n  } else {\n    az = 0.;\n    el = 0.;\n  }\n  az -= 0.01 * pi * tCur;\n  el = clamp (el + pi * (0.17 + 0.1 * sin (0.031 * pi * tCur)), 0.05 * pi, 0.4 * pi);\n  bMid = Loadv4 (2);\n  ro = bMid.xyz + min (5. * bMid.w, 120.) * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n  vuMat = DirVuMat (normalize (bMid.xyz - ro));\n  zmFac = 4.;\n  dstFar = 250.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1., 0.3, 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Green Mercury 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, todCur, nStep, surfHt, surfScl;\nint nFrame, nBall, txOff;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define H(z) (0.6 + 0.4 * cos (0.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (txOff + 3 * mId).xyz;\n  vm = Loadv4 (txOff + 3 * mId + 1).xyz;\n  wm = Loadv4 (txOff + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (txOff + 3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (txOff + 3 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  txOff = 3;\n  nBall = 60;\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= txOff + 3 * nBall) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  if (pxId >= txOff) mId = (pxId - txOff) / 3;\n  else mId = -1;\n  doInit = (nFrame <= 1);\n  if (! doInit) {\n    nStep = Loadv4 (0).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (txOff + 3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if      (pxId == 0) stDat = vec4 (surfHt, surfScl, nStep, float (nBall));\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, 0.);\n  else if (pxId == 2) stDat = bMid;\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 3 * mId);\n    stDat = (mId == 0) ? vec4 (rm, 0.) : ((mId == 1) ? vec4 (vm, 0.) : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (mod (p + vec3 (37., 39., 41.), 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Green Mercury 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, todCur, nStep, surfHt, surfScl;\nint nFrame, nBall, txOff;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define H(z) (0.6 + 0.4 * cos (0.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (txOff + 3 * mId).xyz;\n  vm = Loadv4 (txOff + 3 * mId + 1).xyz;\n  wm = Loadv4 (txOff + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (txOff + 3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (txOff + 3 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  txOff = 3;\n  nBall = 60;\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= txOff + 3 * nBall) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  if (pxId >= txOff) mId = (pxId - txOff) / 3;\n  else mId = -1;\n  doInit = (nFrame <= 1);\n  if (! doInit) {\n    nStep = Loadv4 (0).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (txOff + 3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if      (pxId == 0) stDat = vec4 (surfHt, surfScl, nStep, float (nBall));\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, 0.);\n  else if (pxId == 2) stDat = bMid;\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 3 * mId);\n    stDat = (mId == 0) ? vec4 (rm, 0.) : ((mId == 1) ? vec4 (vm, 0.) : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (mod (p + vec3 (37., 39., 41.), 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Green Mercury 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, todCur, nStep, surfHt, surfScl;\nint nFrame, nBall, txOff;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define H(z) (0.6 + 0.4 * cos (0.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (txOff + 3 * mId).xyz;\n  vm = Loadv4 (txOff + 3 * mId + 1).xyz;\n  wm = Loadv4 (txOff + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (txOff + 3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (txOff + 3 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  txOff = 3;\n  nBall = 60;\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= txOff + 3 * nBall) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  if (pxId >= txOff) mId = (pxId - txOff) / 3;\n  else mId = -1;\n  doInit = (nFrame <= 1);\n  if (! doInit) {\n    nStep = Loadv4 (0).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (txOff + 3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if      (pxId == 0) stDat = vec4 (surfHt, surfScl, nStep, float (nBall));\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, 0.);\n  else if (pxId == 2) stDat = bMid;\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 3 * mId);\n    stDat = (mId == 0) ? vec4 (rm, 0.) : ((mId == 1) ? vec4 (vm, 0.) : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (mod (p + vec3 (37., 39., 41.), 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Green Mercury 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, todCur, nStep, surfHt, surfScl;\nint nFrame, nBall, txOff;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define H(z) (0.6 + 0.4 * cos (0.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++)\n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (txOff + 3 * mId).xyz;\n  vm = Loadv4 (txOff + 3 * mId + 1).xyz;\n  wm = Loadv4 (txOff + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (txOff + 3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (txOff + 3 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  txOff = 3;\n  nBall = 60;\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= txOff + 3 * nBall) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  if (pxId >= txOff) mId = (pxId - txOff) / 3;\n  else mId = -1;\n  doInit = (nFrame <= 1);\n  if (! doInit) {\n    nStep = Loadv4 (0).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (txOff + 3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if      (pxId == 0) stDat = vec4 (surfHt, surfScl, nStep, float (nBall));\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, 0.);\n  else if (pxId == 2) stDat = bMid;\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 3 * mId);\n    stDat = (mId == 0) ? vec4 (rm, 0.) : ((mId == 1) ? vec4 (vm, 0.) : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (mod (p + vec3 (37., 39., 41.), 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdyRn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[693, 693, 718, 718, 2010], [2012, 2012, 2035, 2035, 2108], [2110, 2110, 2144, 2144, 2672], [2674, 2674, 2696, 2696, 2835], [2837, 2837, 2859, 2859, 3016], [3018, 3018, 3051, 3051, 3234], [3236, 3236, 3257, 3257, 3508], [3510, 3510, 3547, 3547, 3790], [3792, 3792, 3827, 3827, 4870], [4872, 4872, 4928, 4928, 6429], [6431, 6431, 6464, 6464, 6491], [6493, 6493, 6515, 6515, 6542], [6544, 6544, 6589, 6589, 6681], [6683, 6683, 6713, 6713, 6826], [6828, 6828, 6853, 6853, 7022], [7056, 7056, 7080, 7080, 7155], [7157, 7157, 7181, 7181, 7308], [7310, 7310, 7335, 7335, 7519], [7521, 7521, 7550, 7550, 7762], [7764, 7764, 7803, 7803, 8060], [8154, 8154, 8179, 8179, 8302]], "test": "untested"}
{"id": "DttcRn", "name": "flowergrid", "author": "zhangzhihao", "description": "花型格子", "tags": ["grid"], "likes": 5, "viewed": 140, "published": 3, "date": "1698833195", "time_retrieved": "2024-07-30T17:24:50.264882", "image_code": "\nfloat squared(float value) { return value * value; }\n\nfloat grid(vec2 uv, float battery)\n{\n\tfloat lineIntensity;\n    float glowWidth;\n    \n\tfloat Y = uv.y;\n    lineIntensity = (0.4 + squared(1.6 * abs(mod(uv.x  + iTime,2.0) - 1.0)))-(0.4 + squared(1.6 * abs(mod(uv.y  + iTime,2.0) - 1.0)));\n    glowWidth = abs(lineIntensity / (150.0 * Y));\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += lineIntensity;\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.0, 0.0);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(0.0, 0.5, 1.0), gridVal);\n        }\n       \n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.g, col.b) , col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 53], [55, 55, 91, 91, 614], [618, 618, 675, 675, 1282]], "test": "untested"}
{"id": "ml3yzr", "name": "Film roll scrolling effect ", "author": "zyc", "description": "Film roll scrolling effect ", "tags": ["texture", "zoom", "scroll", "tiling"], "likes": 4, "viewed": 203, "published": 3, "date": "1698828792", "time_retrieved": "2024-07-30T17:24:51.114610", "image_code": "// Fork of \"Fork Tiled Text zyc 785\" by zyc. https://shadertoy.com/view/DlsSRB\n// 2023-11-01 08:52:52\n\n// vertical scroll: 1\n// horizontal scroll: 0\n#define SCROLL_DIRECTION 0\n//#define FIX_CENTER\n\n\n#define PI 3.14159265358979323846\n\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float padding = 0.015;\n    float aspect = 16./9.;\n    vec4 color = vec4(1.);\n    float cycleTime = mod(iTime, 2.0)/2.0;\n    float time = 3.*cos((cycleTime + 1.0) * PI) / 2.0 + 0.5;\n    \n    vec2 uv = (1.5 * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y *= aspect; // fix aspect ratio\n    \n    #if (SCROLL_DIRECTION == 0)\n       float rows = 1.;\n        // calc row index to offset x of every other row\n        float rowIndex = floor(uv.y * rows);\t\t\n        float oddEven = mod(rowIndex, 2.);\n\n        // create grid coords & set color\n        vec2 uvRepeat = fract(uv * rows);\t\t\n        if(oddEven == 1.) {\n            #ifdef FIX_CENTER\n                uvRepeat = fract(vec2(0.5, 0.) + uv * rows);\n            #else\n                uvRepeat = fract(vec2(time, 0.) + uv * rows); // scroll override\n            #endif\n        } else {\n            uvRepeat = fract(vec2(-time, 0.) + uv * rows); // scroll override\n        }\n\n        // add padding and only draw once per cell\n        uvRepeat *= 1. + padding * 2.;\n        uvRepeat -= padding;\n    #else\n        float columns = 1.;\n        // calc row index to offset x of every other row\n        float columnIndex = floor(uv.x * columns);\t\t\n        float oddEven = mod(columnIndex, 2.);\n\n        // create grid coords & set color\n        vec2 uvRepeat = fract(uv * columns);\t\t\n        if(oddEven == 1.) {\n            #ifdef FIX_CENTER\n                uvRepeat = fract(vec2(0., 0.5) + uv * columns);\n            #else\n                uvRepeat = fract(vec2(0., -time) + uv * columns); // scroll override\n            #endif\n        } else {\n            uvRepeat = fract(vec2(0., time) + uv * columns); // scroll override\n        }\n\n        // add padding and only draw once per cell\n        uvRepeat *= 1. + padding * 2.;\n        uvRepeat -= padding;\n    #endif\n    \n    // antialias - probably a very long & stupid way of doing it, but it's smooth :)\n    float alphaX = 1.0;\n    float alphaY = 1.0;\n    float center = 0.5;\n    float repeatThresh = 0.51;\t// push out a little so we don't cut any texture off. also helps blend nicely when no padding\n    float aa = repeatThresh - center;\n    aa *= 0.5;\n    float centerDistX = distance(center, uvRepeat.x);\n    float centerDistY = distance(center, uvRepeat.y);\n    if(centerDistX > repeatThresh - aa) alphaX = map(centerDistX, repeatThresh - aa, repeatThresh + aa, 1., 0.);\n    if(centerDistY > repeatThresh - aa) alphaY = map(centerDistY, repeatThresh - aa, repeatThresh + aa, 1., 0.);\n    float alpha = min(alphaX, alphaY);\n    color = texture(iChannel0, uvRepeat);\n    color = mix(vec4(1.), color, alpha);\n\n    // draw repeating texture\n    fragColor = color;\n}\n\n/*\n\t// simple texture repeat option\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv = rotateCoord(uv, 0.2 * sin(iTime));\n    uv.y *= 4.5/3.; // fix aspect ratio\n    uv *= 1. + 0.75 * sin(iTime); // zoom\n    vec4 color = texture(iChannel0, uv + vec2(iTime, 3. * sin(iTime)));\n    fragColor = color;\n*/", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3yzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 309, 309, 378], [380, 380, 437, 437, 3108]], "test": "untested"}
{"id": "dlcyRr", "name": "Where Sand of Gold Flows", "author": "INCHMAN1900", "description": "This is some cool effect I accidentally created when I was learning noise and fbm in The Book of Shaders.\n\nTry to change the variable(LOOP, amplitude, frequency...) in fbm function to see other interesting patterns.", "tags": ["noise", "fbm"], "likes": 9, "viewed": 205, "published": 3, "date": "1698824804", "time_retrieved": "2024-07-30T17:24:51.955362", "image_code": "float random(vec3 st) {\n    return fract(sin(dot(st,vec3(397.523,591.5939,69.437)))*53426.79);\n}\n\nfloat noise(vec3 st) {\n    vec3 ip = floor(st);\n    vec3 fp = fract(st);\n    \n    float a = random(ip);\n    float b = random(ip + vec3(1., 0., 0.));\n    float c = random(ip + vec3(0., 1., 0.));\n    float d = random(ip + vec3(1., 1., 0.));\n    // add time factor for flow effect.\n    float e = random(ip + vec3(0., 0., 1.));\n    float f = random(ip + vec3(1., 0., 1.));\n    float g = random(ip + vec3(0., 1., 1.));\n    float h = random(ip + vec3(1., 1., 1.));\n    \n    vec3 u = fp * fp * (3.0 - 2.0 * fp);\n    float n = mix(\n        mix(mix(a, b, u.x), mix(c, d, u.x), u.y),\n        mix(mix(e, f, u.x), mix(g, h, u.x), u.y),\n        u.z\n    );\n    return n * 1.5 - .5;\n}\n\nfloat fbm(vec2 uv) {\n    int LOOP = 6;\n    float amplitude = 1.5;\n    float frequency = .5;\n    float ag = .5;\n    float fg = 2.;\n    float n = 0.;\n    for (int i = 0; i < LOOP; i++) {\n        n += noise(vec3(uv * .2 + n * frequency, iTime * .2 + length(uv) * .1) * frequency) * amplitude;\n        frequency *= fg;\n        amplitude *= ag;\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 col = vec3(fbm(uv * 50.));\n    col *= texture(iChannel0, col.xy).rgb;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 96], [98, 98, 120, 120, 767], [769, 769, 789, 789, 1130], [1132, 1132, 1189, 1189, 1341]], "test": "untested"}
{"id": "Dl3czn", "name": "Coloring-Book Mandelbrot", "author": "jackjackdev", "description": "Pretty straightforward mandelbrot shader", "tags": ["mandelbrot"], "likes": 2, "viewed": 130, "published": 3, "date": "1698800295", "time_retrieved": "2024-07-30T17:24:52.758216", "image_code": "// Coloring-Book Mandelbrot\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Add some movement over time\n    float zoom = .10 + 0.35*sin(0.5);\n    vec2 move = vec2(sin(0.2)*0.5, cos(0.3)*0.5);\n\n    // Adjust the coordinates for the Mandelbrot set\n    vec2 c = (uv * vec2(3.5, 2.0)*zoom - vec2(2.5, 1.0) + move);\n    vec2 z = vec2(0.0);\n    float n = 0.0;\n    for (int i = 0; i < 100; i++) {\n        if (dot(z, z) > 4.0) break;\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        n++;\n    }\n\n    // Convert iteration number to color with more blue emphasis\n    float hue = 1.+  15.*sin(iTime*.5 + n); \n    float saturation = pow(abs(sin(iTime + n * 1.1)), 1.0);\n    float value = (step(0.02, fract(n)));\n\n    fragColor = vec4(vec3(hue, saturation, value)*0.9, 1.0) + vec4(0.0, 0.0, value, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3czn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 112, 889]], "test": "untested"}
