{"id": "sdBGDR", "name": "RGB wave", "author": "invokegs", "description": "Just something stange...", "tags": ["waves"], "likes": 1, "viewed": 275, "published": 3, "date": "1617214801", "time_retrieved": "2024-07-30T19:29:41.547976", "image_code": "void mainImage( out vec4 o, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R;\n    uv.x *= R.x / R.y;\n\n    float t = iTime * .6;\n    uv *= 8.;\n    uv -= vec2(t*.5, -t*.3);\n    float ctime = cos(iTime);\n    \n    vec2 N = (fragCoord / R );\n    float fM = mod(smoothstep(.0,.1,abs(N.y * N.x * ctime)), 0.06) * 1.5 * ctime;\n    \n    float fY = (N.y * 6.);\n    float fX = (N.x * 6.);\n    \n    o = vec4(\n        fM * fY * fX, \n        fM * fY, \n        fM * fX, \n        1\n    );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 503]], "test": "untested"}
{"id": "fdBGDz", "name": "Geodesic raytracer", "author": "sibaku", "description": "Distancefield raytracing on a 3D manifold given as the graph of a function f(x,y,z). You can also implement your own! This is done with automatic differentiation. Mouse and WASD to move! More info at the top of the shader!", "tags": ["riemann", "metric", "geodesic", "automaticdifferentiation", "manifold"], "likes": 12, "viewed": 564, "published": 3, "date": "1617207177", "time_retrieved": "2024-07-30T19:29:42.521374", "image_code": "//********************************************************************\n//\n// INSTRUCTIONS:\n//\n// This shader implements basic distancefield raytracing of a regular grid on\n// a 3D manifold given as the graph of a function f(x,y,z).\n//\n// Click and drag the mouse to look around. WASD for movement. You are moving\n// through distorted space, so you might not move in a straight line, but\n// instead move along the shortest paths in curved space.\n// Press \"R\" to reset the view.\n//\n// WARNING: The space-bending and movement might be a bit nauseating. I tried to\n// not make stuff move too fast, but wanted to give a short warning anyways.\n\n// DISPLAY OPTIONS:\n// Below you can find a few defines to control the look of the grid, background\n// and general tracing\n//\n// FUNCTIONAL OPTIONS\n// The actual function is defined in the common shader part under \"Metric\n// functions\".  A few functions are predefined, but you can implement your own\n// in \"HessNum3 fCustom(in HessNum3 x, in HessNum3 y, in HessNum3 z, float\n// globalTime)\". Just comment in the one you want to see or comment all of them\n// out to use the custom function. Additional information can be found there as\n// well.\n//\n// Note: As calculating the metric from the function requires 1st and 2nd order\n// derivatives and it would be cumbersome to calculate and implement them for\n// each function, I use automatic differentiation, which is why you need to use\n// the special types and operations defined in the automatic differentiation\n// header below to implement your own f.\n//\n//\n//********************************************************************\n\n// Maximum number of trace steps\n// Higher step number will let you look farther, especially with higher\n// deformations\n#define MAX_STEPS 100\n// The maximum length traversed per step. Lower values produce higher quality\n// paths through the curved space\n#define STEP_LENGTH 0.4\n\n// Grid parameters\n#define GRID_SIZE 5.0\n#define GRID_THICKNESS 0.2\n\n// Linear fog parameters\n#define FOG_MAX_DIST 50.0\n#define FOG_MIN_DIST 10.0\n#define FOG_COLOR vec3(0.1)\n\n// Surface epsilon\n#define EPS 0.005\n\n//********************************************************************\n//\n// Distance helpers and tracing\n//\n//********************************************************************\n#define INF 3.402823466e+38\n\nfloat sdf(in vec3 p);\n\n// Tracing function\nbool trace(inout vec3 p, in vec3 dir, out float t, out int steps) {\n\n  steps = 0;\n  t = 0.0;\n\n  for (int n = 0; n < MAX_STEPS && t < FOG_MAX_DIST; n++) {\n\n    float d = sdf(p);\n\n    if (d < EPS) {\n      return true;\n    }\n\n    // make step length dependent on distance field to not miss geometry, but\n    // also use EPS as a min step\n    float s = max(EPS, min(d, STEP_LENGTH));\n\n    // \"acceleration\" of a particle traveling along the geodesic\n    vec3 vp = compute_update(p, dir, iTime);\n\n    // euler integration\n    dir += vp * s;\n    // position euler step\n    p += dir * s;\n\n    // maybe not fully correct, but try to preserve arc length by normalizing\n    // dir\n    dir = normalize(dir);\n\n    // length traveled, used for fog\n    t += s;\n\n    steps++;\n  }\n\n  return false;\n}\n\nfloat sdfBox2d(vec2 p, vec2 b);\nfloat sdfGrid(vec3 p, vec3 cellSize, vec3 gridHalfLength);\nvec3 normal(in vec3 p);\n\n//********************************************************************\n//\n// Image formation\n//\n//********************************************************************\n\nvec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos);\n\nfloat simpleColor(float coord, float gridSize, float repetition);\n\nvec4 loadValue(in ivec2 re) { return texelFetch(iChannel0, re, 0); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float aspect = iResolution.x / iResolution.y;\n\n  vec3 rayDir;\n  vec3 p;\n\n  {\n    vec2 thetaPhi = loadValue(D_thetaPhi).xy;\n    float theta = thetaPhi.x;\n    float phi = thetaPhi.y;\n\n    vec3 eye = loadValue(D_pos).xyz;\n    // vec3 eye = vec3(0.0);\n    vec3 center =\n        eye + vec3(sin(theta) * sin(phi), cos(theta), sin(theta) * cos(phi));\n    // inverse projection and view matrices\n    mat4 PInv = perspectiveInv(radians(90.), aspect, 0.1, 100.);\n    mat4 VInv = lookAtInv(eye, center, vec3(0., 1., 0.));\n\n    rayDir = createRay(uv, PInv, VInv);\n    p = eye;\n  }\n\n  float t = 0.0;\n  int steps = 100;\n\n  vec3 col = vec3(0.0);\n\n  if (trace(p, rayDir, t, steps)) {\n    vec3 N = normal(p);\n\n    col =\n        vec3(simpleColor(p.x, GRID_SIZE, 3.0), simpleColor(p.y, GRID_SIZE, 7.0),\n             simpleColor(p.z, GRID_SIZE, 11.0));\n\n    vec3 LPos = vec3(1.0, 2.0, 0.0);\n    col = shade(p, N, col, LPos);\n\n  } else {\n    t = INF;\n  }\n\n  // simple linear fog\n  float fogFactor = (FOG_MAX_DIST - t) / (FOG_MAX_DIST - FOG_MIN_DIST);\n  fogFactor = clamp(fogFactor, 0.0, 1.0);\n  col = mix(FOG_COLOR, col, fogFactor);\n\n  fragColor = vec4(col, 1.0);\n}\n\n//***************\n\nfloat sdfBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfGrid(vec3 p, vec3 cellSize, vec3 gridHalfLength) {\n  vec3 pg = floor(p / cellSize) * cellSize;\n\n  vec3 center = pg + cellSize * 0.5;\n\n  float d = sdfBox2d(p.xz - center.xz, gridHalfLength.xz);\n  d = min(d, sdfBox2d(p.xy - center.xy, gridHalfLength.xy));\n  d = min(d, sdfBox2d(p.yz - center.yz, gridHalfLength.yz));\n  return d;\n}\n\nfloat sdf(in vec3 p) {\n  float d = sdfGrid(p, vec3(GRID_SIZE), vec3(GRID_THICKNESS));\n  return d;\n}\n\nvec3 normal(in vec3 p) {\n  return normalize(\n      vec3(sdf(p + vec3(EPS, 0., 0.)) - sdf(p - vec3(EPS, 0., 0.)),\n           sdf(p + vec3(0., EPS, 0.)) - sdf(p - vec3(0., EPS, 0.)),\n           sdf(p + vec3(0., 0., EPS)) - sdf(p - vec3(0., 0., EPS))));\n}\n\n//********************************************************************\n//\n// Shading and main\n//\n//********************************************************************\nvec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos) {\n  vec3 L = normalize(LPos - P);\n  // simple two sided diffuse shading\n  return color * clamp(abs(dot(L, N)), 0.0, 1.0);\n}\n\nfloat simpleColor(float coord, float gridSize, float repetition) {\n\n  float cr = (gridSize * 0.5 - coord) / gridSize;\n\n  float v = pow(sin(PI * cr / 2.0), 2.0);\n\n  return v;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Data load/store from https://www.shadertoy.com/view/Ms3XWN\n\nvoid storeValue(in ivec2 re, in vec4 va, inout vec4 fragColor,\n                in ivec2 fragCoord) {\n  fragColor = (re.x == fragCoord.x && re.y == fragCoord.y) ? va : fragColor;\n}\nvec4 loadValue(in ivec2 re) { return texelFetch(iChannel0, re, 0); }\n\nbool isKeyPressed(int key) {\n  return texelFetch(iChannel1, ivec2(key, 1), 0).x == 1.0;\n}\n\nbool isKeyDown(int key) {\n  return texelFetch(iChannel1, ivec2(key, 0), 0).x == 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n\n  // skip processing outside of data\n  if (ifragCoord.x > 6)\n    discard;\n\n  float deg2Rad = PI / 180.0;\n\n  // reset with R\n  if (iFrame == 0 || isKeyPressed(82)) {\n    storeValue(D_thetaPhi, vec4(90.0 * deg2Rad, 0.0, 0.0, 0.0), fragColor,\n               ifragCoord);\n    storeValue(D_lastMouse, vec4(-1.0), fragColor, ifragCoord);\n    storeValue(D_pos, vec4(0.0), fragColor, ifragCoord);\n    return;\n  }\n\n  vec4 thetaPhi = loadValue(D_thetaPhi);\n  vec4 lastMouse = loadValue(D_lastMouse);\n\n  // click and drag camera movement\n  if (iMouse.z > 0.0 && lastMouse.z > 0.) {\n    vec2 dm = (iMouse.xy - lastMouse.xy) / iResolution.xy;\n    thetaPhi.y -= dm.x * 2.0 * PI;\n    thetaPhi.x -= dm.y * PI;\n    thetaPhi.x = clamp(thetaPhi.x, 5.0 * deg2Rad, PI - 5.0 * deg2Rad);\n  }\n  lastMouse = iMouse;\n\n  vec4 pos = loadValue(D_pos);\n\n  {\n    float theta = thetaPhi.x;\n    float phi = thetaPhi.y;\n\n    vec3 dir = vec3(sin(theta) * sin(phi), cos(theta), sin(theta) * cos(phi));\n    mat4 VInv = lookAtInv(pos.xyz, pos.xyz + dir, vec3(0., 1., 0.));\n    vec3 right = (VInv * vec4(1.0, 0.0, 0.0, 0.0)).xyz;\n\n    vec3 move = vec3(0.0);\n\n    if (isKeyDown(87)) // W\n    {\n      move += dir;\n    }\n    if (isKeyDown(83)) // A\n    {\n      move -= dir;\n    }\n    if (isKeyDown(65)) // S\n    {\n      move -= right;\n    }\n    if (isKeyDown(68)) // D\n    {\n      move += right;\n    }\n\n    if (dot(move, move) > 0.0) {\n      move = normalize(move);\n      const int numSteps = 5;\n      const float speed = 2.0;\n      float stepLength = speed * iTimeDelta / float(numSteps);\n\n      // movement through the distorted space should be done in the same way as\n      // with the view rays\n      for (int i = 0; i < numSteps; i++) {\n        vec3 vp = compute_update(pos.xyz, move, iTime);\n        // euler integration\n        move += vp * stepLength;\n        // position euler step\n        pos.xyz += move * stepLength;\n        // should be very small step lengths so we skip normalization\n      }\n    }\n  }\n\n  storeValue(D_thetaPhi, thetaPhi, fragColor, ifragCoord);\n  storeValue(D_lastMouse, lastMouse, fragColor, ifragCoord);\n  storeValue(D_pos, pos, fragColor, ifragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//********************************************************************\n//\n// Begin of automatic differentiation header\n// Full code with additional functions (gradients, jacobians, ...) can be found\n// at: https://github.com/sibaku/glsl-autodiff\n//\n//********************************************************************\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_\n//********************************************************************\n//\n// End automatic differentiation header\n//\n//********************************************************************\n\n//********************************************************************\n//\n// Metric functions\n//\n//********************************************************************\n#define PI 3.14159265359\n\n// Predefined functions!\n// Just comment in the one you want to see! (comment out the other ones)\n// If none is defined, the default identity operation is used (f(x,y,z) = 0).\n// You can comment out all predefined ones and implement your own in fCustom\n\n#define EXPONENTIAL\n// #define SADDLE\n//  #define WAVES\n// #define PARABOLA\n// #define IDENTITY\n\n// Implement your custom height function here and comment out all the defines\n// above! You can use all the mathematical operations defined in the automatic\n// differentiation header above\nHNum3 fCustom(in HNum3 x, in HNum3 y, in HNum3 z,\n                 float globalTime) {\n  return constH3(0.0);\n}\n\nHNum3 fExponential(in HNum3 x, in HNum3 y, in HNum3 z,\n                      float globalTime);\nHNum3 fSaddle(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime);\nHNum3 fWaves(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime);\nHNum3 fParabola(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime);\nHNum3 fIdentity(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime);\n\n// Height function used for the metric. More information in compute_update\nHNum3 f(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime) {\n\n#if defined EXPONENTIAL\n  return fExponential(x, y, z, globalTime);\n#elif defined SADDLE\n  return fSaddle(x, y, z, globalTime);\n#elif defined WAVES\n  return fWaves(x, y, z, globalTime);\n#elif defined PARABOLA\n  return fParabola(x, y, z, globalTime);\n#elif defined IDENTITY\n  return fIdentity(x, y, z, globalTime);\n#else\n  return fCustom(x, y, z, globalTime);\n#endif\n}\n\nHNum3 hessF(vec3 p, float globalTime) {\n  // compute hessian with addition time parameter\n\n  vec3 uGrad = vec3(1., 0., 0.);\n  HNum3 uHessian = HNum3(p.x, uGrad, mat3(0.));\n  vec3 vGrad = vec3(0., 1., 0.);\n  HNum3 vHessian = HNum3(p.y, vGrad, mat3(0.));\n  vec3 wGrad = vec3(0., 0., 1.);\n  HNum3 wHessian = HNum3(p.z, wGrad, mat3(0.));\n  return f(uHessian, vHessian, wHessian, globalTime);\n}\nvec3 compute_update(vec3 p, vec3 v, float globalTime) {\n\n  // explicit form of the christoffel symbols for the metric given by graph of\n  // the function f(x_1,x_1,x_3) df/dx_i = f_i d^2f/(dx_j dx_j) = f_{i,j}\n  // gamma_{i,j}^k = f_k*f_{i,j}/(1 + |grad(f)|^2)\n\n  // This is the update given by the differential geodesic equation used for\n  // numerical integration in local coordinates (x_i) for a curve c_i(t) = x_i\n  // d^2 c_k/dt^2 = gamma_{i,j}^k * d c_i/dt * d c_j/dt\n\n  // The local position's velocity is given by the ray's current direction\n\n  // compute first and second order derivatives\n  HNum3 r = hessF(p, globalTime);\n\n  vec3 vp = vec3(0.0);\n\n  for (int k = 0; k < 3; k++) {\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        vp[k] += r.g[k] * r.h[j][i] * v[i] * v[j];\n      }\n    }\n  }\n\n  return -vp / (1.0 + dot(r.g, r.g));\n}\n\n//********************************************************************\n//\n// Data\n//\n//********************************************************************\n\nconst ivec2 D_lastMouse = ivec2(0, 0);\nconst ivec2 D_thetaPhi = ivec2(2, 0);\nconst ivec2 D_pos = ivec2(4, 0);\n\n//********************************************************************\n//\n// Camera functions\n//\n//********************************************************************\n// This assumes the pixel position px to be in [0,1],\n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv);\n\nmat4 translate(vec3 t);\nmat4 translateInv(vec3 t);\n\nmat4 scale(vec3 s);\nmat4 scaleInv(vec3 s);\n\nmat4 rightToLeft();\nmat4 rightToLeftInv();\n\nmat4 ortho(float l, float r, float b, float t, float n, float f);\nmat4 orthoInv(float l, float r, float b, float t, float n, float f);\n\nmat4 projection(float n, float f);\nmat4 projectionInv(float n, float f);\n\nmat4 perspective(float fov, float aspect, float n, float f);\nmat4 perspectiveInv(float fov, float aspect, float n, float f);\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up);\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up);\n\n//********************************************************************\n//\n// Implementation\n//\n//********************************************************************\nHNum3 fExponential(in HNum3 x, in HNum3 y, in HNum3 z,\n                      float globalTime) {\n  HNum3 rx = sub(x, 0.0);\n  HNum3 ry = sub(y, 1.0);\n  HNum3 rz = sub(z, 2.0);\n\n  HNum3 x2 = mult(rx, rx);\n  HNum3 y2 = mult(ry, ry);\n  HNum3 z2 = mult(rz, rz);\n\n  HNum3 sum = neg(add(x2, add(y2, z2)));\n\n  HNum3 f1 = a_exp(mult(sum, 1.0 / (abs(sin(globalTime / 3.0)) + 0.1)));\n\n  rx = sub(x, -6.0);\n  ry = sub(y, -0.25);\n  rz = sub(z, 3.5);\n\n  x2 = mult(rx, rx);\n  y2 = mult(ry, ry);\n  z2 = mult(rz, rz);\n\n  sum = neg(add(x2, add(y2, z2)));\n  sum = mult(sum, 0.1);\n  HNum3 f2 = mult(a_exp(sum), abs(sin(globalTime / 5.0)) * 5.0);\n  return add(f1, f2);\n}\nHNum3 fSaddle(in HNum3 x, in HNum3 y, in HNum3 z,\n                 float globalTime) {\n  return mult(0.25 * pow(sin(globalTime / 2.0), 2.0),\n              sub(add(mult(x, x), mult(z, z)), mult(y, y)));\n}\nHNum3 fWaves(in HNum3 x, in HNum3 y, in HNum3 z, float globalTime) {\n  float frequency = 2.0 * PI / (10.0 + 3.0 * sin(0.1 * globalTime));\n  return a_cos(add(mult(x, frequency), mult(z, frequency)));\n}\nHNum3 fParabola(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime) {\n  HNum3 rel = sub(x, 0.0);\n  HNum3 sum = mult(rel, rel);\n\n  rel = sub(y, 0.0);\n  sum = add(sum, mult(rel, rel));\n\n  rel = sub(z, -10.0);\n  sum = add(sum, mult(rel, rel));\n  return mult(sum, 0.1);\n}\nHNum3 fIdentity(in HNum3 x, in HNum3 y, in HNum3 z,\n                   float globalTime) {\n  return constH3(0.0);\n}\n\n\n//********************************************************************\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv) {\n\n  // convert pixel to NDS\n  // [0,1] -> [-1,1]\n  vec2 pxNDS = px * 2. - 1.;\n\n  // choose an arbitrary point in the viewing volume\n  // z = -1 equals a point on the near plane, i.e. the screen\n  vec3 pointNDS = vec3(pxNDS, -1.);\n\n  // as this is in homogenous space, add the last homogenous coordinate\n  vec4 pointNDSH = vec4(pointNDS, 1.0);\n  // transform by inverse projection to get the point in view space\n  vec4 dirEye = PInv * pointNDSH;\n\n  // since the camera is at the origin in view space by definition,\n  // the current point is already the correct direction (dir(0,P) = P - 0 = P\n  // as a direction, an infinite point, the homogenous component becomes 0\n  // the scaling done by the w-division is not of interest, as the direction\n  // in xyz will stay the same and we can just normalize it later\n  dirEye.w = 0.;\n\n  // compute world ray direction by multiplying the inverse view matrix\n  vec3 dirWorld = (VInv * dirEye).xyz;\n\n  // now normalize direction\n  return normalize(dirWorld);\n}\n\n// matrix operations\nmat4 translate(vec3 t) {\n  return mat4(vec4(1., 0., 0., 0.), vec4(0., 1., 0., 0.), vec4(0., 0., 1., 0.),\n              vec4(t, 1.));\n}\nmat4 translateInv(vec3 t) { return translate(-t); }\n\nmat4 scale(vec3 s) {\n  return mat4(vec4(s.x, 0., 0., 0.), vec4(0., s.y, 0., 0.),\n              vec4(0., 0., s.z, 0.), vec4(0., 0., 0., 1.));\n}\nmat4 scaleInv(vec3 s) { return scale(1. / s); }\n\nmat4 rightToLeft() {\n  // 1 0 0  0\n  // 0 1 0  0\n  // 0 0 -1 0\n  // 0 0 0  1\n  return scale(vec3(1., 1., -1.));\n}\n\nmat4 rightToLeftInv() {\n  // same matrix\n  return rightToLeft();\n}\n\nmat4 ortho(float l, float r, float b, float t, float n, float f) {\n\n  // translation and scale\n  return scale(vec3(2. / (r - l), 2. / (t - b), 2. / (f - n))) *\n         translate(vec3(-(l + r) / 2., -(t + b) / 2., -(f + n) / 2.));\n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f) {\n  return translateInv(vec3(-(l + r) / 2., -(t + b) / 2., -(f + n) / 2.)) *\n         scaleInv(vec3(2. / (r - l), 2. / (t - b), 2. / (f - n)));\n}\n\nmat4 projection(float n, float f) {\n  // n 0 0 0\t0\n  // 0 n 0 0\t0\n  // 0 0 n+f\t-fn\n  // 0 0 1\t0\n  return mat4(vec4(n, 0., 0., 0.), vec4(0., n, 0., 0.), vec4(0., 0., n + f, 1.),\n              vec4(0., 0., -f * n, 0.));\n}\n\nmat4 projectionInv(float n, float f) {\n  // 1/n \t0 \t0 \t\t0\n  // 0 \t1/n\t0 \t\t0\n  // 0\t0\t0 \t\t1\n  // 0\t0\t-1/fn\t(f+n)/fn\n\n  return mat4(vec4(1. / n, 0., 0., 0.), vec4(0., 1. / n, 0., 0.),\n              vec4(0., 0., 0., -1. / (f * n)),\n              vec4(0., 0., 1., (f + n) / (f * n)));\n}\n\nmat4 perspective(float fov, float aspect, float n, float f) {\n  float l = tan(fov / 2.) * n;\n  float b = l / aspect;\n\n  return ortho(-l, l, -b, b, n, f) * projection(n, f) * rightToLeft();\n}\n\nmat4 perspectiveInv(float fov, float aspect, float n, float f) {\n  float l = tan(fov / 2.) * n;\n  float b = l / aspect;\n\n  return rightToLeftInv() * projectionInv(n, f) * orthoInv(-l, l, -b, b, n, f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n\n  vec3 z = normalize(eye - center);\n  vec3 x = normalize(cross(up, z));\n  vec3 y = cross(z, x);\n\n  mat4 v = mat4(vec4(x.x, y.x, z.x, 0.), vec4(x.y, y.y, z.y, 0.),\n                vec4(x.z, y.z, z.z, 0.), vec4(0., 0., 0., 1.));\n\n  return v * translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up) {\n  vec3 z = normalize(eye - center);\n  vec3 x = normalize(cross(up, z));\n  vec3 y = cross(z, x);\n\n  return translateInv(-eye) *\n         mat4(vec4(x, 0.), vec4(y, 0.), vec4(z, 0.), vec4(0., 0., 0., 1.));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2346, 2366, 2433, 2433, 3149], [3566, 3566, 3595, 3595, 3634], [3636, 3636, 3691, 3691, 4883], [4904, 4904, 4936, 4936, 5017], [5019, 5019, 5078, 5078, 5356], [5358, 5358, 5380, 5380, 5457], [5459, 5459, 5483, 5483, 5711], [5713, 5881, 5944, 5944, 6066], [6068, 6068, 6134, 6134, 6243]], "test": "untested"}
{"id": "NdBGDR", "name": "Vogel Disk Sampling", "author": "Tech_", "description": "Here is a shader about vogel disk sampling! Enjoy!", "tags": ["sampling", "disk"], "likes": 11, "viewed": 681, "published": 3, "date": "1617197475", "time_retrieved": "2024-07-30T19:29:43.387059", "image_code": "\nvec2 GetVogelDiskSample(int sampleIndex, int sampleCount, float phi) \n{\n    const float goldenAngle = radians(180.0) * (3.0 - sqrt(5.0));\n    float sampleIndexF = float(sampleIndex);\n    float sampleCountF = float(sampleCount);\n    \n    float r = sqrt((sampleIndexF + 0.5) / sampleCountF);  // Assuming index and count are positive\n    float theta = sampleIndexF * goldenAngle + phi;\n    \n    float sine = sin(theta);\n    float cosine = cos(theta);\n    \n    return vec2(cosine, sine) * r;\n}\n\n#define TOTAL_SAMPLES int((sin(iTime * 0.2) * 0.5 + 0.5) * 120.0 + 20.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.3;\n\n    vec3 col;\n    \n    const float phi = 1.6180;\n    float minDist = 10000.0;\n    \n    for (int i = 0; i < TOTAL_SAMPLES; i++) \n    {\n        vec2 point = GetVogelDiskSample(i, TOTAL_SAMPLES, phi); \n        float d = distance(uv, point);\n        minDist = min(minDist, d);\n    }\n    \n    // Suggested by elenzil (https://www.shadertoy.com/user/elenzil)\n    float smoothEpsilon = 3.0 / iResolution.y;\n    col += smoothstep(0.03 + smoothEpsilon, 0.03 - smoothEpsilon, minDist);\n   \n    // col += step(minDist, 0.05);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 72, 72, 491], [567, 567, 624, 624, 1300]], "test": "untested"}
{"id": "7sS3Rw", "name": "metaballs colored", "author": "grevel", "description": "metashapes\n\nclick LMB to make them shine\n\nhttps://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nhttps://jsfiddle.net/87nw05kz/", "tags": ["blobs", "metaballs", "colors", "meta", "blob", "colored", "metashapes"], "likes": 3, "viewed": 411, "published": 3, "date": "1617186833", "time_retrieved": "2024-07-30T19:29:44.230803", "image_code": "\n//click LMB to make them shine\n\n\n// number of balls\n#define nBalls 15\n\n\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat r(uint seed)  // random numbers\n{\n    return float(Hash(seed)) / 4294967295.0; // 2^32-1\n}\n\nfloat interpolate(float a, float b, float d)\n{\n    return -(a-b)*d+a;\n}\n\nvec3 gradient(float c)\n{\n    vec4 cols[4];\n    \n    //                 r          g         b      position on gradient space (0 and 1 required)\n    cols[0] = vec4(255./255., 193./255., 36./255., 0.0);\n    cols[1] = vec4(182./255., 255./255., 36./255., 0.3);\n    cols[2] = vec4(255./255.,  76./255., 36./255., 0.6);\n    cols[3] = vec4(255./255., 200./255., 36./255., 1.0);\n    \n    \n    // pick two colors that are on the sides of a sample\n    int i = 0;\n    while(!(c >= cols[i].w && c <= cols[i+1].w))\n    {\n        i++;\n    }\n    \n    vec4 Bcol = cols[i];\n    vec4 Tcol = cols[i+1];\n    \n    // transform them to bottomColor-0.0 and topColor-1.0\n    c -= Bcol.w;\n    Tcol.w -= Bcol.w;\n    Bcol.w -= Bcol.w;\n\n    c /= Tcol.w;\n    Bcol.w /= Tcol.w;\n    Tcol.w /= Tcol.w;\n\n\n    // interpolate color\n    vec3 outcome;\n    outcome.x = interpolate(Bcol.x, Tcol.x, c);\n    outcome.y = interpolate(Bcol.y, Tcol.y, c);\n    outcome.z = interpolate(Bcol.z, Tcol.z, c);\n    \n    return outcome;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy + vec2(-.35, -.2)) * vec2(1.7);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float size = 1./ 0.04; // change size\n\n    uint rN = uint(4);  // seed value (change for different trajectories and colors)\n\n    float d = 0.;     // sum of 1/dist for all balls\n    vec3 col = vec3(0);\n\n    float cd[nBalls];     // 1/dist^2 for all balls \n    vec2 balls[nBalls];   // positions\n    vec3 colors[nBalls];  // colors\n    float total=0.;       // sum of cds\n    \n    for(int i = 0; i < nBalls; i++) // initialize balls\n    {\n        balls[i] = vec2(r(rN) + r(rN + uint(1))*sin(r(rN + uint(2)) + iTime*r(rN + uint(3))), r(rN + uint(4)) + r(rN + uint(5))*.6*sin(r(rN + uint(6)) + iTime*r(rN + uint(7))));\n        //colors[i] = vec3(r(rN + uint(8)), r(rN + uint(9)), r(rN + uint(10)));\n        //colors[i] /= vec3(max(colors[i].x, max(colors[i].y, colors[i].z)));\n        colors[i] = gradient(r(rN + uint(8)));\n        rN += uint(100);\n    }\n    \n\n    for(int i = 0; i < nBalls; i++) // distances for interpolation of colors\n    {\n        float dist = length(balls[i]-uv);\n        d += 1./dist * (.6+r(rN+uint(100))*.4);\n\n        if(dist == 0.) col = colors[i];\n\n        float oneover = 1./pow(dist, 4.);\n\n        cd[i] = oneover;\n        total += oneover;\n\n        rN += uint(100);\n    }\n\n    \n    //if(d > size-.5)   // no background\n    //if(d < size+1.5)  // border mode\n    //{\n        for(int i = 0; i < nBalls; i++)  // interpolation of colors based on distances\n        {\n            float ratio = cd[i] / total;\n            col.x += ratio * colors[i].x;\n            col.y += ratio * colors[i].y;\n            col.z += ratio * colors[i].z;\n        }\n    //}\n\n    \n    \n    if(iMouse.z > .5)   // coloring modes\n        col = vec3(smoothstep(size-11., size, d), smoothstep(size-6., size, d), smoothstep(size-30., size, d));\n    else\n        col *= vec3(.3+.73*smoothstep(size-0.5, size, d));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 92, 92, 232], [234, 234, 273, 273, 330], [332, 332, 378, 378, 403], [405, 405, 429, 429, 1392], [1395, 1395, 1452, 1452, 3411]], "test": "untested"}
{"id": "7sjGRw", "name": "mandelbrot zooming", "author": "grevel", "description": "click in different places for different colors", "tags": ["fractal", "interactive", "colors", "zoom", "animated", "animation"], "likes": 1, "viewed": 243, "published": 3, "date": "1617186620", "time_retrieved": "2024-07-30T19:29:45.077539", "image_code": "\nfloat mandelbrot(vec2 c, float it)  // check if a point belongs to the mandelbrot set\n{\n    vec2 z = c;\n    float i = 0.;\n    \n    float maxDist = 0.;\n    \n    while (i < it && length(z) < 3.)\n    {\n        vec2 zn = vec2(z.x * z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z = zn;\n        \n        float dist = length(c-z);\n        \n        if(dist > maxDist) maxDist = dist;\n        \n        i++;\n    }\n    //return smoothstep(1.3, 2.7, length(z));\n    //return i/it * maxDist*.1;\n    //return i/it;\n    return maxDist*.1;\n}\n\nfloat interpolate(float a, float b, float d)\n{\n    return -(a-b)*d+a;\n}\n\nfloat map(float v, float a1, float a2, float b1, float b2)\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    //uv.x = map(fragCoord.x, 0., 800., -3., 1.4);\n    //uv.y = map(fragCoord.y, 0., 450., -1.3, 1.3);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    if(iMouse.xy == vec2(0.)) mouseUV = vec2(.7);\n    \n    \n    float interpolation = 1.-pow(0.5+0.5*sin(iTime/3.), 3.); // 0-zoom out 1-zoom in\n    float zoom = .00003; // smaller = closer\n    \n    // calculate current camera position based on zoom and interpolation value\n    uv.x = map(fragCoord.x, 0., iResolution.x, interpolate(-3., -0.761574-zoom, interpolation), interpolate(1.4, -0.761574+zoom, interpolation));\n    uv.y = map(fragCoord.y, 0., iResolution.y, interpolate(-1.3, -0.0847596-zoom, interpolation), interpolate(1.3, -0.0847596+zoom, interpolation));\n    \n    float r = 1.-mandelbrot(uv, mouseUV.x*750.);\n    float g = 1.-mandelbrot(uv, mouseUV.y*300.);\n    float b = mandelbrot(uv, 10.);\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 88, 88, 521], [523, 523, 569, 569, 594], [596, 596, 656, 656, 696], [698, 698, 755, 755, 1669]], "test": "untested"}
{"id": "ssjGRw", "name": "concentric wobbling circles", "author": "grevel", "description": "click to change blob's position", "tags": ["circles", "interactive", "sin", "circle", "animated", "wobbling"], "likes": 2, "viewed": 263, "published": 3, "date": "1617186060", "time_retrieved": "2024-07-30T19:29:46.176601", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159265359;\n\n    float aspR = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= aspR;\n    \n\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    mouseUV.y /= aspR;\n    \n    float fStar = sin(iTime*5.)*sin(2.*round(9.*(sin(iTime/5.)+1.)/2.+1.)*atan((uv.y-mouseUV.y)/(uv.x-mouseUV.x)));\n\n    float distR = 0.5 + 0.5*sin(1. -iTime*3.0 + fStar+length(uv - mouseUV)*(51.0 + 10.1*sin(iTime*5.0)));\n    float distG = 0.5 + 0.5*sin(2. -iTime*3.0 + fStar+length(uv - mouseUV)*(50.0 + 10.5*sin(iTime*5.0)));\n    float distB = 0.5 + 0.5*sin(1.5 -iTime*3.0 + fStar+length(uv - mouseUV)*(52.0 + 10.9*sin(iTime*5.0)));\n    \n    vec3 c = vec3(smoothstep(0.2, 0.8, distR), smoothstep(0.3, 0.7, distG), smoothstep(0.1, 0.9, distB));\n    \n    \n    \n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 870]], "test": "untested"}
{"id": "7s23zw", "name": "gamma detection test, RGB", "author": "hornet", "description": "A test for gamma-levels that includes three tests rather than just the usual 50% grey.\nOn most monitors, a power-function does not appear to be adequate correction.\n(see also https://www.shadertoy.com/view/Xdl3DM )", "tags": ["gamma", "gammacorrection", "brightness"], "likes": 4, "viewed": 319, "published": 3, "date": "1617183412", "time_retrieved": "2024-07-30T19:29:47.034308", "image_code": "// Fork of \"gamma detection test\" by hornet. https://shadertoy.com/view/llfSRM\n// 2021-03-31 09:28:07\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces);\n\n/*\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n//noise\nfloat pattern( vec2 fc, float v )\n{\n    return step( hash12n(fc) / v, 1.0 );\n}\n*/\n\n\n//const float s=0.2;\n//const vec3 bias=vec3(s,s,1.0);\nvec3 pattern( vec2 fc, float v )\n{\n    //note: 2x2 ordered dithering, ALU-based (omgthehorror)\n\tvec2 ij = floor(mod( fc.xy, vec2(2.0,2.0) ));\n\tfloat idx = ij.x + 2.0*ij.y;\n\tvec4 m = step( abs(vec4(idx)-vec4(0.0,1.0,2.0,3.0)), vec4(0.5,0.5,0.5,0.5) ) * vec4(0.75,0.25,0.00,0.50);\n\tfloat d = m.x+m.y+m.z+m.w;\n\n    float ret = step(d,v);\n    return vec3( ret, ret, ret );  // * bias;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outcol = vec4(0.0);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 luv = fract( 3.0 * uv );\n    \n    //circle\n    vec2 aspect = vec2( 1.0, iResolution.y / iResolution.x );\n    bool ref = length((vec2(1.0/2.0,0.5)-luv)*aspect) < 0.11;\n    \n    if ( uv.x < 1.0/3.0 )\n\t\toutcol.rgb = ref ? vec3(0.25,0.25,0.25) : pattern(fragCoord,0.15);\n    else if ( uv.x < 2.0/3.0 )\n        outcol.rgb = ref ? vec3(0.50,0.50,0.50) : pattern(fragCoord,0.30);\n    else\n        outcol.rgb = ref ? vec3(0.75,0.75,0.75) : pattern(fragCoord,0.60);\n\n    if ( uv.y < 1.0/3.0 )\n\t\toutcol.rgb *= vec3(0,0,1);\n    else if ( uv.y < 2.0/3.0 )\n        outcol.rgb *= vec3(0,1,0);\n    else\n        outcol.rgb *= vec3(1,0,0);\n\n    float gamma = 1.5 + iMouse.x/iResolution.x;\n    outcol = pow( outcol, vec4(1.0 / (1.5 + iMouse.x/iResolution.x)) );\n    //outcol = pow( outcol, vec4(1.0 / 2.00) ); //dell 2410\n    //outcol = pow( outcol, vec4(1.0 / 2.15) ); //NEC ps272w\n    //outcol = pow( outcol, vec4(1.0 / 2.15) ); //EIZO cg277\n    \n    outcol.rgb = mix( outcol.rgb, vec3(0.0), PrintValue( (uv-vec2(0.43,0.9))*40.0, gamma, 1.0, 2.0) );\n    \n\tfragColor = outcol;\n}\n\n\n\n\n\n//////////////\n\n\n\n//---------------------------------------------------------------\n// number rendering code below by P_Malin\n//\n// https://www.shadertoy.com/view/4sf3RN\n//---------------------------------------------------------------\n\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\t\t\t\tfDigitCharacter = mod(floor(fDigitValue+0.0001), 10.0);\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s23zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 568, 602, 662, 950], [955, 955, 1012, 1012, 2159]], "test": "untested"}
{"id": "7sj3zw", "name": "Mandelbox crystal", "author": "mrange", "description": "License CC0: Mandelbox crystal\nWas reminded by some great additions lately that refraction is pretty cool to play around with\n", "tags": ["3d", "raymarch", "mandelbox"], "likes": 16, "viewed": 591, "published": 3, "date": "1617180925", "time_retrieved": "2024-07-30T19:29:48.073529", "image_code": "// License CC0: Mandelbox crystal\n//  Was reminded by some great additions lately that refraction is pretty\n//  cool to play around with\n\n// Uncomment for a different \"skybox\"\n//#define SKY_VARIANT\n\n#define TOLERANCE         0.0001\n#define MAX_RAY_LENGTH    8.0\n#define MAX_RAY_MARCHES   100\n#define TIME              iTime\n#define RESOLUTION        iResolution\n// SABS by ollij\n#define LESS(a,b,c)       mix(a,b,step(0.,c))\n#define SABS(x,k)         LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n\n#define PERIOD            30.0\n#define FADE              3.0\n#define TIMEPERIOD        mod(TIME,PERIOD)\n#define NPERIOD           floor(TIME/PERIOD)\n#define PSIN(x)           (0.5 + 0.5*sin(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n#ifdef SKY_VARIANT\n#define SKYCOLOR(ro, rd)  skyColor1(ro, rd)\n#else\n#define SKYCOLOR(ro, rd)  skyColor0(ro, rd)\n#endif\n\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\nconst mat2  rot0          = ROT(0.0);\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst float boundingSphere= 4.0;\nconst float dfZoom        = 1.0/8.0;\nconst vec3  glowCol       = vec3(3.0, 2.0, 1.);\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nfloat g_rand              = 0.5;\nmat2  g_rotb              = rot0;\nmat2  g_rotc              = rot0;\nmat2  g_rotd              = rot0;\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat hash(float co) {\n  co += 6.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's smooth min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's box\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray sphere density\nfloat raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// From stackoverflow\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// IQ's ray sphere 4 intersection\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  // Perhaps IQ's ray sphere 4 supports inner intersect but I couldn't get it to work\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// Based on EvilRyu's Mandelbox\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z) {\n  float rand = g_rand;\n  float off = iTime*0.25;\n  vec4 offset = z;\n  float dr = 1.0;\n  float d = 1E6;\n  float k = mix(0.05, 0.25, fract(37.0*rand));\n  for(int n = 0; n < 4; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    float dd = min(d, (length(z) - 2.5)/abs(dr));\n    if (n < 2) d = dd;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  return fract(17.0*rand) > 0.5 ? pmin(d0, d, 0.05) : d0;\n}\n\nfloat df(vec3 p) {\n  const float s = dfZoom;\n  float rand = g_rand;\n\n  p /= s;\n\n  float dbs = sphere(p, boundingSphere);\n//  if (dbs > 0.5) return dbs;\n\n  float a = fract(3.0*rand);\n  vec4 pp = vec4(p.x, p.y, p.z, 2.0*a*a);\n\n  pp.xw *= g_rotb;\n  pp.yw *= g_rotc;\n  pp.zw *= g_rotd;\n  \n  float dmb = mb(pp);\n  \n  float d = dmb;\n  d = max(d, dbs);\n  \n  return d*s;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render0(vec3 ro, vec3 rd, out float sd, out float td) {\n  int iter = 0;\n  const vec4 bs = vec4(vec3(0.0), boundingSphere*dfZoom);\n  const vec4 gs = vec4(vec3(0.0), boundingSphere*dfZoom*0.66);\n  vec2 tbs = raySphere(ro, rd, bs);\n  if (tbs == vec2(miss)) {\n    td = miss;\n    return vec3(0.0);\n  }\n  \n  float t = rayMarch(ro, rd, iter);\n  \n  sd = raySphereDensity(ro, rd, gs, t);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n\n  float h = g_rand;\n  \n  if (t < MAX_RAY_LENGTH) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+0.25*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n    td        = t;\n  } else {\n    // Ray intersected sky\n    td        = miss;\n    return vec3(0.0);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n    \n  return col*ifade;\n}\n\nvec3 skyColor0(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.75));\n\n  if (tp > 0.0) {\n    // Ray intersected plane\n    vec3 pos  = ro + tp*rd;\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 col = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    float f = exp(-20.0*(max(tp-3.0, 0.0) / MAX_RAY_LENGTH));\n    return mix(final, col , f);\n  } else {\n    // Ray intersected sky\n    return final;\n  }\n}\n\nvec3 skyColor1(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.75));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.1+1.0*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 render1(vec3 ro, vec3 rd) {\n  const float eps  = 0.001;\n  vec3 ipos = ro + eps*rd;\n  vec3 ird  = rd;\n  float isd = 0.0;\n  float itd = 0.0;\n  vec3 col = vec3(0.0);\n  \n  const float scaleUp = 2.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    float rtd = miss;\n    float rsd;\n    col = scaleUp*render0(ipos, ird, rsd, rtd);\n    isd += rsd;\n    if (rtd < miss) { \n      itd += rtd; \n      break;\n    }\n    \n    float its4  = IRAYSHAPE(ipos, ird);\n    itd         += its4;\n    vec3 nipos  = ipos + ird*its4;\n    vec3 inor   = -sphere4Normal(nipos);\n    vec3 irefr  = refract(ird, inor, 1.0/refrIndex);\n    if (irefr == vec3(0.0)) {\n      ipos = nipos;\n      ird  = reflect(ird, inor);\n    } else {\n      vec3 rskyCol= SKYCOLOR(ipos, irefr);\n      col = rskyCol;\n      break;\n    }\n  }\n  float h = g_rand;\n  float t = 0.2;\n  vec3 hsv  = vec3(fract(h - 0.6 + 0.4+0.25*t), 0.3, 1);\n  vec3 glowCol = hsv2rgb(hsv);\n\n  isd = h > 0.5 ? isd : 0.0;\n  col = mix(col, 2.0*glowCol, isd);\n  \n  col *= exp(mix(-vec3(2.0, 3.0, 4.0).zyx, vec3(0.0), tanh_approx(3.0*isd))*itd);\n  \n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float rand = hash(NPERIOD);\n  g_rand = rand;\n\n  float a = fract(3.0*rand);\n  const float aa = PI/4.0;\n  const float bb = PI/4.0-aa*0.5;\n  float b = bb+aa*fract(5.0*rand);\n  float c = bb+aa*fract(7.0*rand);\n  float d = bb+aa*fract(13.0*rand);\n  g_rotb = ROT(b);\n  g_rotc = ROT(c);\n  g_rotd = ROT(d);\n\n\n  vec3 ro = 0.6*vec3(2.0, 0, 0.2)+vec3(0.0, 0.75, 0.0);\n  ro.xz *= ROT((TIME*0.05));\n  ro.yz *= ROT(sin(TIME*0.05*sqrt(0.5))*0.5);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n//  rdd = 2.0;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, FADE, TIMEPERIOD);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEPERIOD);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [{"id": 26447, "src": "https://soundcloud.com/serein/to-speak-of-solitude", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3zw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1796, 1796, 1821, 1821, 1850], [1852, 1852, 1874, 1874, 1935], [1937, 1937, 1965, 1985, 2061], [2063, 2082, 2121, 2121, 2209], [2211, 2211, 2246, 2246, 2331], [2333, 2333, 2364, 2364, 2390], [2392, 2404, 2431, 2431, 2528], [2530, 2562, 2604, 2604, 2863], [2865, 2892, 2959, 2959, 3440], [3442, 3464, 3486, 3486, 3655], [3658, 3692, 3738, 3738, 4583], [4585, 4585, 4615, 4615, 4652], [4654, 4654, 4701, 4865, 5044], [5046, 5077, 5120, 5120, 5167], [5169, 5201, 5249, 5249, 5481], [5483, 5483, 5537, 5581, 5661], [5663, 5663, 5681, 5681, 6174], [6176, 6176, 6194, 6194, 6540], [6542, 6542, 6590, 6590, 6785], [6787, 6787, 6810, 6810, 7019], [7021, 7021, 7089, 7089, 7368], [7370, 7370, 7407, 7407, 7659], [7661, 7661, 7721, 7721, 8937], [8939, 8939, 8973, 8973, 9854], [9856, 9856, 9890, 9890, 10953], [10956, 10956, 10988, 10988, 12029], [12031, 12031, 12062, 12062, 13139], [13140, 13140, 13195, 13195, 14190]], "test": "untested"}
{"id": "7sjGzw", "name": "Zoomer", "author": "wyatt", "description": "I havent made a zoomer in a while. this one is a feedback between the total derivative and a vector field. ", "tags": ["tensor"], "likes": 11, "viewed": 346, "published": 3, "date": "1617176571", "time_retrieved": "2024-07-30T19:29:48.843470", "image_code": "Main {\n    vec4 a = A(U), b = B(U);\n    float t = b.x*b.y+b.w*b.z;\n    Q = a.xzyw+b+t*vec4(10);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 Qb= B(U);\n    vec2 du = vec2(0),m=vec2(0);\n    box if (abs(x)!=abs(y)){\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        du -= .25*mat2(b)*u;\n        m += .25*a.xy;\n    }\n    Q.xy = mix(Q.xy,m,1.);\n    Q.xy = mix(Q.xy,du,.33);\n    if (length(Q.xy)>0.)\n    Q.xy = mix(Q.xy,normalize(Q.xy),.3);\n    if (iFrame < 1) Q = vec4(sin(.04*U.y),cos(.04*U.x),0,0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = B(U);\n    vec4 Qa= A(U);\n    vec4 du = vec4(0),m=vec4(0);\n    box if (abs(x)!=abs(y)){\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        du += vec4(u.x*a.xy,u.y*a.xy);\n        m += .25*b;\n    }\n    Q = mix(Q,m,1.);\n    Q = mix(Q,du,.1);\n    if (iFrame < 1) Q = vec4(sin(.01*U.y),-cos(.01*U.x),0,1);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q,vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define _a 1e-3\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))", "buffer_c_code": "Main {\n\n    U -= 0.5*R;\n    U *= (1.-_a);\n    U += 0.5*R;\n    Q = A(U);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\n    U -= 0.5*R;\n    U *= (1.-_a);\n    U += 0.5*R;\n    Q = A(U);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "llsyDM", "name": "Multiverse2", "author": "patu", "description": "POC for last scene from https://www.youtube.com/watch?v=oITx9xMrAcM", "tags": ["demoscene", "spaghetti"], "likes": 8, "viewed": 337, "published": 3, "date": "1617153472", "time_retrieved": "2024-07-30T19:29:49.775977", "image_code": "#define getNormal getNormalCube\n\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 80.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nbool inball = false;\nfloat iter = 0.;\n\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat noiseShort(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 DE(vec3 p)\n{\n \tconst float scale = 1.45;\n\tconst float offset = 2.0;\n    const int FRACTALITERATIONS = 15;\n    vec3 modifier = vec3(-12.3 , -4.1, -4.1);\n\tp.y = -p.y;\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        \n\t\tp.xy = (p.x + p.y <= 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x + p.z <= 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z + p.y <= 0.0) ? -p.yz : p.zy;\n\n\t\tp.y -= 4.1;\n        pR(p.xz, 0.82915);\n        \n        p.yz = -p.zy * vec2(1., -1.);\n        p.x -= 25.;\n        pR(p.zx, -.16915);\n\n\t\tp = scale*p-offset*(scale-1.0) * modifier;\n\t}\n \tvec3 obj;\n    obj.x = length(p) * pow(scale, -float(FRACTALITERATIONS)); \n\n    return obj;\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 bp = p;\n   // p += 15.;\n    vec3 r = pMod3(p, vec3(100.));\n\tp += noiseShort(r) * 20.;\n    vec3 obj, obj2;\n    obj2.x = FAR;\n    obj.x = FAR;\n    obj.y = 2.;\n\n    if (inball) {\n        obj.x = min(obj.x, DE(p).x);\n        obj2.y = 3.;\n        obj = opU2(obj, obj2);\n    } else {\n        obj.x = min(obj.x, fSphere(p, noiseShort(p * .05 + t) * 2. + 30. * sin(length(r)))); \n\n    }\n\n    return obj;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 tr = vec3(.5, -1., 0.0);\n    for (int i = 0; i < 126; i++) {\n        vec3 d = map(ro + rd * tr.x);\n        tr.x += d.x * 0.4; // Using more accuracy, in the first pass.\n        tr.yz = d.yz;\n        if (abs(d.x) < 0.02 || tr.x > FAR) break;\n\t\titer += 1.;\n    }\n    return tr;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).x - map( pos - delta.xyy ).x;\n   n.y = map( pos + delta.yxy ).x - map( pos - delta.yxy ).x;\n   n.z = map( pos + delta.yyx ).x - map( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = 3.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(1. - max(rd.y, 0.0), .1);\n   vec3 sky = mix(fromRGB(0,136,254), vec3(.1, .2, .3) * .1, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n   \n   return clamp(sky / noiseShort(rd * 3.), 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n    \n    if (obj.material.x == 0.0) { \n        col = vec3(1., .6, .5);       \n    };\n    \n    if (obj.material.x == 1.0) { col = fromRGB(255,128,0); }\n    if (obj.material.x == 2.0) { \n        col = fromRGB(255,128,50);     \n    }\n    \n    if (obj.material.x == 4.0) { \n        col = vec3(1., .6, .5); \n    };\n    return col;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 7.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .04) * 26.0, \n        ck = cos(-t2 * .07) * 32.0 - sk,\n        \n        mat = 0.;\n    \n    light = vec3(0., 17., 100.);        \n    lightDir = light;\n        \n    vec3 \n        vuv = vec3(sin(t / 10.), 1., sin(t / 10.)), // up\n    \tro = vec3(-2., ck, sk) + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 10.); // pos\n    ro -= 120.;\n    vec3\n        vrp =  vec3(sin(t / 30.) * 12., + sin(t * 2.) / 5., 10.) +\n        \tvec3(\n                -2., \n                0. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n\n    vec3 tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    hit = ro + rd * tr.x;\n    vec3 otr = tr;\n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, 15.2);\n\n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n        \n    if (tr.x < FAR) { \n        sceneColor += 0.2;\n        inball = true;\n        vec3 bcol = vec3(0.);\n        if (tr.x > 0.) {\n            rd = refract(rd, sn, 1. - min(1., tr.x / 100.));\n            bcol = vec3(1., .9, 1.0) * pow(noiseShort(sn * 1.) * 1.3, 7.) * .3;\n            bcol += pow(max(0., dot(rd, normalize(light))), 13.);\n            tr = trace(hit, rd);\n        } else {\n            tr = trace(ro, rd);\n        }\n        \n        if (tr.x < FAR) {\n        \thit = hit + rd * (tr.x);\n            sceneColor += 9. / pow(tr.x, 1.1);\n            sceneColor = mix(sceneColor, sky, clamp(tr.x / 30., 0., 1.));\n        } else {\n            sceneColor += sky;\n        }\n        sceneColor += bcol;\n\n    } else {\n        sceneColor = sky;\n\n    }\n    sceneColor += pow(sin(float(iter) / 500.), 1.9) ;\n    sceneColor = mix(sceneColor, sky, clamp(otr.x / 400., 0., 1.));\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 309, 346, 346, 438], [440, 440, 466, 466, 716], [717, 717, 752, 752, 809], [958, 958, 990, 990, 1032], [1034, 1034, 1065, 1065, 1114], [1225, 1225, 1257, 1257, 1282], [1284, 1284, 1301, 1301, 1927], [1929, 1929, 1947, 1947, 2359], [2361, 2361, 2391, 2391, 2678], [2680, 2680, 2725, 2725, 3297], [3320, 3320, 3349, 3349, 3581], [3616, 3616, 3649, 3649, 3882], [3885, 3885, 3934, 3934, 4047], [4049, 4049, 4100, 4100, 4504], [4506, 4506, 4557, 4557, 4911], [4913, 4913, 4990, 4990, 5928], [5930, 5930, 5985, 5985, 8334]], "test": "untested"}
{"id": "4tfyzf", "name": "Wreck Scanners", "author": "patu", "description": "#makeYourShadersPublic\n\n", "tags": ["2d", "3d"], "likes": 20, "viewed": 521, "published": 3, "date": "1617152451", "time_retrieved": "2024-07-30T19:29:50.549908", "image_code": "#define T texture(iChannel0, uv\n#define W vec2\n\n#define BLOOM\n\n#define time iTime\n#define res iResolution\n\nfloat alpha;\n\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.001*8./6.,.001, 0) * .05;\n\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    float bc = 1.;\n\tfor (int j=0;j<70;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        vec4 col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (intensity(col) > .9) {            \n\t\t\tbloom += col; \n            bc++;\n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n    \n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = (\n        texture(iChannel0,uv) \n    \t+ (texture(iChannel0,uv + pixel.xz)\n        \t+ texture(iChannel0,uv + pixel.zx)\n        \t+ texture(iChannel0,uv - pixel.xz)\n        \t+ texture(iChannel0,uv - pixel.zx)\n         ) * .25\n    ) / 2.,\n        \n    oo = orgColor;\n    \n    alpha = texture(iChannel0,uv).a;\n    \n    dof(iChannel0,uv, 20., orgColor);\n    \n    #ifdef BLOOM\n    \n    orgColor += bloom * 0.003;\n    #endif\n    \n    float df = min(1., pow(abs(alpha - .7) * 3., 2.));\n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tdf,\n            0.,\n            1.\n        )\n    );\n    \n    \n    orgColor = mix(\n        orgColor * 2., \n        blur, \n        clamp(\n        \tmin(1., pow((uv.y-.2) * .4, 1.)),\n            0.,\n            1.\n        )\n    );\n    \n \t\n    fragColor = orgColor;    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define getNormal getNormalCube\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 50.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noiseShort(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1., .5, 0.)); \n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\ngeometry DE(vec3 p, float c)\n{\n    \n \tconst float scale = 2.8;\n\tconst float offset = 9.0;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(19.3, -3., 3.2);\n\n    for(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        p = abs(p);\n        \n\t\tp.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n        p.x += 90.;\n        pR(p.xy, .725 );\n        p.zy += 22.;\n        \n        p.xyz = scale* p.xyz - offset*(scale - .3) * modifier.xyz;\n        \n\t}\n \tgeometry obj, obj2;\n    \n    obj.dist = fBox(p, vec3(10., 199., 0.1)) * (pow(scale, -float(FRACTALITERATIONS))); \n\tobj.material = vec2(1., 0.);\n    \n    obj.space = p;\n    return obj;\n}\n\n// Repeat in two dimensions\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    \n    p.zyx = mod(p.zyx, vec3(150., 150., 50.)) - vec3(75., 75, 25);\n \n    geometry obj;\n    obj = DE(p, 1.);\n    \n    obj.space = p;\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 640.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        minDist = min(minDist, mp.dist * 3.);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 1.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n\n\n\n#define EPSILON .00001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).dist - map( pos - delta.xyy ).dist;\n   n.y = map( pos + delta.yxy ).dist - map( pos - delta.yxy ).dist;\n   n.z = map( pos + delta.yyx ).dist - map( pos - delta.yyx ).dist;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n\n    if (obj.material.x == 1.0) { \n        col = vec3(.0, .0, 0.);// + abs(sin(obj.space.x + obj.space.z + iTime * 3.) );\n        //col *= noiseShort(p * .02) *14.;\n    }\n    //col += fract(obj.space.z * -0.1 + t) * 10.;\n    return col;//* fract(p.y / 10.) * 10.;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 2.1); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 10.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv = ouv - .5;\n   // uv.y /= iResolution.x/ iResolution.y;\n    vol = 1.;//length(texture(iChannel0, vec2(.42, .25)).rgb);\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .4) * 6.0, \n        ck = cos(-t2 * .4) * 2.0,\n        \n        mat = 0.;\n    \n    light = vec3(.0, 0., -310.);        \n\n    vec3 \n        vuv = vec3(0., 1.,0.), // up\n    \tro = vec3(121., -14., 73.);// + vec3(sin(t) * 1. + 60., -20. - cos(t / 9.) * 1., 13.);//iMouse.y / 2. - 100., 10.); // pos\n\tro.x -= t * 10.;    \n    light =+ro;\n    \n    vec3 oro = ro;\n    vec3\n        vrp =  vec3(-t * 10., 0. , 0.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\t\n    vec3 sceneColor = vec3(0.);\n    vec3 lp = light;// + ro;\n\tlightDir = lp;\n\t\n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, light + ro, 1.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn, 9.1);\n\t\n   if (tr.dist < FAR) { \n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * 1.) * 1.;\n        sceneColor = col;\n        sceneColor *= sh;        \n        \n        sceneColor = mix(sceneColor, vec3(0.), saturate(tr.dist * 1.3 / FAR));\n    } else {\n    \ttr.dist = FAR;\n    }\n    \n    float flareDist = 1e9;\n    vec3 flareCol = vec3(0.), flareCol_B = vec3(0.);\n    for (float k = 0.; k < 256.; k++) {\n        vec3 flarePos = \n            vec3(\n                 sin(k / 32.) * 35. - t * 10. + 10.,\n                -6.-cos(k / 6. - t / 3.) * sin(k - k * 0.1 + sin(t / 13.) * 2.) * 12.,\n                cos( t /  14. + k / 12.) * 35. * (sin(t * .2+ k) / 2. + .8)\n            );\n\t\tflareDist = min(distance(tr.hit, flarePos), flareDist); \n        if (tr.dist > distance(flarePos, ro)) {\n            flareCol_B += abs(vec3(1., 0.2, 0.)) * pow(max(0., dot(normalize(-ro + flarePos) * 0.99, rd) * 1.0), 400.) * 0.94;\n            flareCol += abs(vec3(1., .2, 0.)) * pow(pow(max(0., dot(normalize(-ro + flarePos), rd) * 1.0), 52200. - distance(ro, flarePos) * 50.) / distance(ro, flarePos) * 100., 5.) * abs(sin(t + k));\n        }\n        \n    }\n    if (flareCol.r > 0.2) {\n        tr.dist = .7 * 210.;\n    }\n    \n    flareCol += flareCol_B;\n    \n    sceneColor += pow(vec3(1., 0.2, 0.) / (flareDist / 4.), vec3(4.) * .4);\n    \n    sceneColor *= ao; \n    sceneColor = mix(sceneColor, vec3(.1, .1, .1), clamp(tr.dist / 210., 0. ,1.)); \n\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), tr.dist / 160.);\n    fragColor.rgb += flareCol;\n    fragColor.rgb += pow(flareCol, vec3(1.0)) * 1.4;\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 310, 310, 364], [366, 410, 465, 465, 798], [800, 894, 948, 948, 1837]], "test": "untested"}
{"id": "Nd2Gzw", "name": "Cubic Bezier to \"y=\"", "author": "oneshade", "description": "Cubic bezier in 1D segments.", "tags": ["bezier", "de", "y", "cubic", "parametric"], "likes": 4, "viewed": 200, "published": 3, "date": "1617144214", "time_retrieved": "2024-07-30T19:29:51.426565", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Custom struct\nstruct Custom {\n    vec2 p1;\n    vec2 p2;\n    bool tf;\n};\n\nstruct DualRoots3 {\n    int nroots;\n    vec2[3] roots;\n};\n\n// Automatic differentiation utilities\nvec2 fMul(in vec2 a, in vec2 b) { return vec2(a.x * b.x, a.x * b.y + a.y * b.x); }\nvec2 fDiv(in vec2 a, in vec2 b) { return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x)); }\nvec2 fSquare(in vec2 z) { return vec2(z.x * z.x, 2.0 * z.x * z.y); }\nvec2 fCube(in vec2 z) { float q = z.x * z.x; return vec2(q * z.x, 3.0 * z.y * q); }\nvec2 fSqrt(in vec2 z) { float q = sqrt(z.x); return vec2(q, 0.5 * z.y / q); }\nvec2 fCos(in vec2 z) { return vec2(cos(z.x), -sin(z.x) * z.y); }\nvec2 fAcos(in vec2 z) { return vec2(acos(z.x), -z.y / sqrt(1.0 - z.x * z.x)); }\nvec2 fSinh(in vec2 z) { return vec2(sinh(z.x), cosh(z.x) * z.y); }\nvec2 fCosh(in vec2 z) { return vec2(cosh(z.x), sinh(z.x) * z.y); }\nvec2 fAsinh(in vec2 z) { return vec2(asinh(z.x), z.y / sqrt(z.x * z.x + 1.0)); }\nvec2 fAcosh(in vec2 z) { return vec2(acosh(z.x), z.y / sqrt(z.x * z.x - 1.0)); }\nvec2 fAbs(in vec2 z) { return vec2(abs(z.x), z.y * sign(z.x)); }\nvec2 fSign(in vec2 z) { return vec2(sign(z.x), 0.0); }\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nDualRoots3 solveCubic(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 aa = fSquare(a), bb = fSquare(b);\n\n    vec2 denom = 3.0 * aa;\n    vec2 inflect = fDiv(b, 3.0 * a);\n\n    vec2 p = fDiv(c, a) - fDiv(bb, denom);\n    vec2 q = fDiv(fMul(bb, b), 13.5 * fMul(aa, a)) - fDiv(fMul(b, c), denom) + fDiv(d, a);\n    vec2 ppp = fCube(p), qq = fSquare(q);\n\n    vec2 p2 = fAbs(p);\n    vec2 v1 = fMul(fDiv(vec2(1.5, 0.0), p), q);\n\n    DualRoots3 roots = DualRoots3(1, vec2[3](vec2(0.0), vec2(0.0), vec2(0.0)));\n    if (qq.x * 0.25 + ppp.x / 27.0 > 0.0) {\n        vec2 v2 = fMul(v1, fSqrt(fDiv(vec2(3.0, 0.0), p2)));\n        if (p.x < 0.0) roots.roots[0] = fMul(fSign(q), fCosh(fAcosh(fMul(v2, -fSign(q))) / 3.0));\n        else roots.roots[0] = fSinh(fAsinh(v2) / 3.0);\n        roots.roots[0] = -2.0 * fMul(fSqrt(p2 / 3.0), roots.roots[0]) - inflect;\n    }\n\n    else {\n        vec2 ac = fAcos(fMul(v1, fSqrt(fDiv(vec2(-3.0, 0.0), p)))) / 3.0, m = 2.0 * fSqrt(-p / 3.0);\n        roots.roots[0] = fMul(m, fCos(ac                           )) - inflect;\n        roots.roots[1] = fMul(m, fCos(ac - vec2(2.09439510239, 0.0))) - inflect;\n        roots.roots[2] = fMul(m, fCos(ac - vec2(4.18879020479, 0.0))) - inflect;\n        roots.nroots = 3;\n    }\n\n    return roots;\n}\n\n// Invert x to get t and plug it into y\nDualRoots3 yBezier(in vec2 x, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 coeff1 = vec2(3.0 * b.x - 3.0 * c.x - a.x + d.x, 0.0);\n    vec2 coeff2 = vec2(3.0 * a.x + 3.0 * c.x - 6.0 * b.x, 0.0);\n    vec2 coeff3 = vec2(3.0 * b.x - 3.0 * a.x, 0.0);\n    vec2 coeff4 = vec2(a.x, 0.0) - x;\n\n    DualRoots3 t = solveCubic(coeff1, coeff2, coeff3, coeff4);\n    DualRoots3 y = DualRoots3(t.nroots, vec2[3](vec2(0.0), vec2(0.0), vec2(0.0)));\n    for (int n=0; n < t.nroots; n++) {\n        vec2 tInv = vec2(1.0, 0.0) - t.roots[n];\n        y.roots[n] = a.y * fMul(tInv, fSquare(tInv)) + 3.0 * b.y * fMul(t.roots[n], fSquare(tInv)) +\n                     3.0 * c.y * fMul(tInv, fSquare(t.roots[n])) + d.y * fMul(t.roots[n], fSquare(t.roots[n]));\n    }\n\n    return y;\n}\n\n// Points where the x derivative is zero and the DE breaks down\nCustom xMaxBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    float coeff1 = 9.0 * b.x - 3.0 * a.x - 9.0 * c.x + 3.0 * d.x;\n    float coeff2 = 6.0 * a.x - 12.0 * b.x + 6.0 * c.x;\n    float coeff3 = 3.0 * b.x - 3.0 * a.x;\n\n    float discr = coeff2 * coeff2 - 4.0 * coeff1 * coeff3;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * coeff1;\n\n        float t1 =  (root - coeff2) / denom, t1Inv = 1.0 - t1;\n        float t2 = -(root + coeff2) / denom, t2Inv = 1.0 - t2;\n\n        vec2 p1 = a * t1Inv * t1Inv * t1Inv + 3.0 * b * t1 * t1Inv * t1Inv +\n                  3.0 * c * t1Inv * t1 * t1 + d * t1 * t1 * t1;\n\n        vec2 p2 = a * t2Inv * t2Inv * t2Inv + 3.0 * b * t2 * t2Inv * t2Inv +\n                  3.0 * c * t2Inv * t2 * t2 + d * t2 * t2 * t2;\n\n        return Custom(p1, p2, true);\n    }\n\n    return Custom(vec2(0.0), vec2(0.0), false);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s3) * 0.5;\n    vec2 b = vec2(s1, s2) * 0.5;\n    vec2 c = vec2(c3, c1) * 0.5;\n    vec2 d = vec2(c2, s1) * 0.5;\n\n    DualRoots3 y = yBezier(vec2(uv.x, 1.0), a, b, c, d);\n    for (int n=0; n < y.nroots; n++) {\n        float de = abs(uv.y - y.roots[n][0]) / sqrt(1.0 + y.roots[n][1] * y.roots[n][1]);\n        if (n == 0) draw(de - 0.01, vec3(1.0, 0.5, 0.0));\n        if (n == 1) draw(de - 0.01, vec3(1.0, 0.0, 0.0));\n        if (n == 2) draw(de - 0.01, vec3(0.0, 0.0, 1.0));\n    }\n\n    Custom xMax = xMaxBezier(a, b, c, d);\n    if (xMax.tf) {\n        draw((length(uv - xMax.p1) - 0.02), vec3(1.0));\n        draw((length(uv - xMax.p2) - 0.02), vec3(1.0));\n    }\n\n    draw(sdLine(uv, a, b), vec3(1.0));\n    draw(sdLine(uv, b, c), vec3(1.0));\n    draw(sdLine(uv, c, d), vec3(1.0));\n\n    draw(length(uv - a) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - b) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - c) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - d) - 0.01, vec3(1.0, 1.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Gzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 242, 275, 275, 324], [325, 325, 358, 358, 423], [424, 424, 449, 449, 492], [493, 493, 516, 516, 576], [577, 577, 600, 600, 654], [655, 655, 677, 677, 719], [720, 720, 743, 743, 799], [800, 800, 823, 823, 866], [867, 867, 890, 890, 933], [934, 934, 958, 958, 1014], [1015, 1015, 1039, 1039, 1095], [1096, 1096, 1118, 1118, 1160], [1161, 1161, 1184, 1184, 1215], [1305, 1305, 1372, 1372, 2564], [2566, 2606, 2681, 2681, 3370], [3372, 3436, 3499, 3499, 4321], [4411, 4411, 4458, 4458, 4566], [4568, 4568, 4623, 4623, 5983]], "test": "untested"}
{"id": "fd2GRw", "name": "Cyber Fuji 2020 audio reactive", "author": "Chaotnix", "description": "based on Cyber Fuji 2020 by  kaiware007 https://www.shadertoy.com/view/Wt33Wf\n I just added mic\n", "tags": ["sun", "80s", "retro", "mic", "fuji", "cineshader"], "likes": 13, "viewed": 8879, "published": 3, "date": "1617135896", "time_retrieved": "2024-07-30T19:29:52.516649", "image_code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n\tval = val - 0.4f + pow(texture(iChannel0, vec2(0.1, .25)).r, 1.0f) * 1.0f;\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.7f + pow(texture(iChannel0, vec2(0.1, .25)).r, 0.7f) * 1.0f );\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(texture(iChannel0, vec2(0.1, .25)).r, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.9   + pow(texture(iChannel0, vec2(0.1, .35)).r, 0.7f);\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -1.  + pow(texture(iChannel0, vec2(0.1, .25)).r, 0.7f);\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2GRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 417], [419, 419, 455, 455, 815], [817, 817, 841, 841, 860], [862, 862, 927, 927, 1237], [1239, 1239, 1288, 1288, 1407], [1409, 1409, 1446, 1446, 1530], [1532, 1532, 1581, 1581, 1684], [1686, 1686, 1769, 1835, 2439], [2441, 2441, 2498, 2498, 6463]], "test": "untested"}
{"id": "ssSGRw", "name": "mouse 360", "author": "jorge2017a1", "description": "mouse 360", "tags": ["mouse360"], "likes": 2, "viewed": 280, "published": 3, "date": "1617115039", "time_retrieved": "2024-07-30T19:29:53.645631", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    \n    vec3 pp=p;\n    \n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist5,100. ,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n  \n    p.y=p.y-5.0;\n   \n    \n    \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n    float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    \n    \n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    \n   res =opU3(res, vec3(sdsp2,2.0,-1)); \n    \n  \n    //return (dist, id_color, id_material)\n    return res;\n}\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n//-------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\nvec3 mirror(inout vec3 p, inout vec3 n, inout vec3 rd, int opmat) {\n\tp += n * MIN_DIST * 2.;\n    rd = reflect(rd, n);\n\n    TObj Obj;\n\tfloat l = RayMarch(p, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 colobj;\n    if (Obj.id_color<100.0)\n\t\t{ colobj=getColor(int( Obj.id_color)); }\n    \n    \n    if ( float( Obj.id_color)>=100.0  && float( Obj.id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( Obj.id_color));\n        colobj=coltex;\n\t}\n    \n    if (Obj.id_material>-1.0 && Obj.id_color==-1.0)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, Obj.id_material); \n        }\n    \n    if (l>MAX_DIST)\n        return colobj;\n    \n\tp = p + rd * l;\n\tn = GetNormal(p);\n    \n\trd=reflect(rd,n);\n    p = p + rd * EPSILON;\n    \n    vec3 col=(Getluz( p,mObj.ro,rd, n, vec3(1.0) ,light_pos1)*colobj)*0.85;\n    \n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_color==201)\n    \t{ colobj= mirror(p, n, rd, id_color); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 0.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n     vec2 mouse = iMouse.xy / iResolution.xy - .1;\n     vec3 ro = vec3(0., 15. + mouse.y*10. , -20.);\t\t//origin (camera)\n    ro= getMouse(ro);\n    \n    vec3 lookat = vec3(0., 1., 6.);\n    float zoom = 1.;\n    vec3 F = normalize(lookat-ro);\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F));\n    vec3 U = normalize(cross(F, R));\n    \n    vec3 c = ro + F*zoom;\n    \n    vec3 i = c + uv.x*R + uv.y*U;\n    vec3 rd = i-ro;\n    \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        \n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 595, 595, 616], [617, 617, 649, 649, 733], [734, 734, 780, 780, 867], [869, 913, 960, 960, 987], [989, 989, 1032, 1032, 1059], [1061, 1061, 1109, 1109, 1137], [1138, 1222, 1258, 1258, 1303], [1304, 1369, 1403, 1403, 1501], [1502, 1502, 1536, 1536, 1628], [1629, 1629, 1663, 1663, 1755], [1756, 1796, 1830, 1830, 1927], [1928, 1968, 1993, 1993, 3607], [3608, 3608, 3673, 3673, 4257], [4259, 4310, 4334, 4334, 4522], [4524, 4524, 4557, 4557, 5268], [5270, 5324, 5360, 5360, 5594], [5595, 5721, 5757, 5757, 5962], [5963, 6034, 6058, 6058, 6313], [6361, 6361, 6410, 6410, 6663], [6664, 6698, 6778, 6778, 7055], [7098, 7098, 7165, 7165, 7948], [7950, 8001, 8048, 8048, 8825], [8879, 8879, 8972, 8972, 9467], [9469, 9469, 9496, 9496, 9606], [9607, 9656, 9713, 9713, 11368]], "test": "untested"}
{"id": "sdSGRw", "name": "Batik patterns", "author": "jarble", "description": "This fractal makes many patterns that resemble batik cloth.\nFull-screen mode recommended.", "tags": ["fractal", "batik"], "likes": 4, "viewed": 288, "published": 3, "date": "1617113772", "time_retrieved": "2024-07-30T19:29:54.409588", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07);\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.2;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n            vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [725, 725, 772, 772, 828], [830, 830, 887, 887, 1627]], "test": "untested"}
{"id": "3tcfDf", "name": "Realistic Flag", "author": "TekF", "description": "March 31st is Transgender Day of Visibility, so I thought it was a good time to revisit the [url=https://www.shadertoy.com/view/ldX3DX]flag shader[/url] I made 8 years ago (before I came out as trans!).\n", "tags": ["raymarching", "uvmapping"], "likes": 42, "viewed": 1042, "published": 3, "date": "1617107041", "time_retrieved": "2024-07-30T19:29:55.477732", "image_code": "// Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// Trans day of visibility is March 31st.\n\n\nconst float tau = 6.28318530717958647692;\n\nvec2 gFragCoord;\n\n\n// Tone Mapping\n\nconst float exposure = .75;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.1);\nconst vec3 blackClip = vec3(.0);\nconst vec3 blackSoftness = vec3(.05);\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n    col *= exposure;\n\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\n\nfloat linstep( float a, float b, float c )\n{\n    return clamp((c-a)/(b-a),0.,1.);\n}\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = gFragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    x = x*sqrt(3./4.) + x.yx*vec2(1,-1)*sqrt(1./4.); // tilt the grid so it's not aligned to the flag to make it less visible\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p + f;\n\n#if (0)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 fuv = uv - vec2(iuv);\n    \n\tvec4 rg = mix( mix(\n\t\t\t\ttexelFetch( iChannel0, iuv&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,0))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\t  mix(\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(0,1))&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,1))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\tfuv.y );\n#endif\t\t\t  \n\n\treturn rg;\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n    float time = iTime*2.;\n\n\tvec2 p = pos+vec2(-2,.2)*time;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*time;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 1.6;\n\tp += vec2(-1,0)*time;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.2;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.5;\n}\n\nvec3 Normal( vec3 pos )\n{\n\tvec2 delta = vec2(-1,1)*.01;//*length(fwidth(pos)); // gets moire artefacts if this is too small\n\treturn normalize(\n                DistanceField( pos + delta.xxx )*delta.xxx +\n                DistanceField( pos + delta.yyx )*delta.yyx +\n                DistanceField( pos + delta.yxy )*delta.yxy +\n                DistanceField( pos + delta.xyy )*delta.xyy\n            );\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n    // bow the left edge so it's just mounted at 2 points\n    float bow = cos(target.y*6.283185/4.)*.08;\n    target.x -= bow;\n\n    float droop = 2.; // the technique isn't really robust enough for this to look realistic at bigger values\n    target.y += droop;\n    \n\t// need to march vertically to absorb vertical creases, and horizontally for horizontal ones\n\t// cheat, by seperating these two\n\tvec2 uv = vec2(0);\n\t\n    // make flag droop toward the right by offsetting target y\n    // hopefully this means it will droop more the more disruption there is\n//    target.y += target.x*.5;\n    \n    \n\tconst int n = 16;\n\tconst float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring\n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\t//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);\n\t\t//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);\n        \n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n    \n//    uv.y += (uv.x+1.)*uv.x*.05; // droop toward the end\n\t\n    uv.y -= droop;\n    \n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\n\nvec3 Pattern( vec2 uv )\n{\n    // striped patterns\n\n    // trans flag\n    vec3 colours[] = vec3[]( vec3(.3,.7,1), vec3(1,.2,.4), vec3(1), vec3(1,.2,.4), vec3(.3,.7,1) );\n\n    // lesbian\n    //vec3 colours[] = vec3[]( vec3(.8,.05,.0), vec3(1,.3,.0), vec3(1,.5,.2), vec3(1), vec3(1,.3,.6), vec3(.7,.1,.4), vec3(.5,.0,.2) );\n    \n    float smoothidx = (1.-uv.y)*float(colours.length()) + .5;\n    int idx = int(floor( smoothidx ));\n    float fidx = smoothidx - float(idx);\n    fidx -= .5;\n    \n    return mix(colours[max(0,idx-1)],colours[idx],\n                //step(.0,fidx)); // aliased\n                 smoothstep( -fidx, 1.-fidx, fidx/max(fwidth(smoothidx),.0001) ));// anti-aliased\n\n/*\n    // checker\n    float pattern = (fract(uv.x/.2)-.5)*(fract(uv.y/.3)-.5);\n    return mix( vec3(.03), vec3(1), smoothstep( -fwidth(pattern)*.5, fwidth(pattern)*.5, pattern ) ); // this antialiasing doesn't work\n*/\n}\n\nfloat Mask( vec2 uv )\n{\n    // todo: use fwidth so it is correct for distance\n\n\treturn max(\n            smoothstep(.495,.5,abs(uv.x-.5)),\n            smoothstep(.495,.5,abs(uv.y-.5))\n        );\n}\n\n\nfloat Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*500.*.85;\n\tfloat f = (sin(a.x)+sin(a.y))*.25+.5;\n\n    f = mix( f, .5, min( 1., .2*max( fwidth(a.x), fwidth(a.y) ) ) ); // prevent moire\n\n    return f;\n}\n\n\nfloat Seam( vec2 uv )\n{\n    return smoothstep( .5, .48, abs(uv.y-.5) )\n          *smoothstep( 1., .985, uv.x )\n          *smoothstep( .02, .03, uv.x );\n}\n\n\nvec3 airColourLog2 = vec3(.1,.3,.6);\n\n// quick and pretty sky colour\nvec3 SkyColour( vec3 ray )\n{\n    vec3 col = exp2(-ray.y/airColourLog2); // blue - from https://www.shadertoy.com/view/4ljBRy\n    \n    // add some clouds\n    vec2 cloudUV = ray.xz/(ray.y+.2) + iTime*vec2(-.03,0);\n    vec4 clouds = (\n          Noise(4.*cloudUV)\n        + Noise(10.*cloudUV)*.4\n        + Noise(25.*cloudUV)*.16\n        + Noise(50.*cloudUV)*.04\n        )/1.6;\n    \n    col = mix( col, clouds.yyy, pow(smoothstep(.05,.6,clouds.x),8.)*1.*max(0.,ray.y) );\n    \n    // horizon\n    float horizonSDF = ray.y - .09 - .04*Noise(ray.xz*9.).x - .03*(.5-abs(Noise(ray.xz*5.).x-.5));\n    col = mix( col, mix( vec3(1), vec3(.1), exp2(-3.*airColourLog2*.01/(.01+max(0.,-horizonSDF))) ), smoothstep(.003, -.003, horizonSDF ) );\n    \n    return col;\n}\n\n\nvec3 Ambient( vec3 normal )\n{\n    return mix( vec3(.1,.07,.05), vec3(.15,.2,.25), normal.y*.3+.7 );\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n\n\n    vec3 camPos, ray;\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    if ( dot(iMouse.xy,vec2(1)) <= 0. ) mousePos = (.5-.5*cos(vec2(1.,.618)*.1*iTime)) * vec2(1,.5);\n    CamPolar( camPos, ray, vec3(1.5,0,0), vec2(-.8,-.5)+vec2(1.2,1.5)*mousePos.yx, 20.0, 5. );\n    \n    if ( dot(iMouse.xy,vec2(1)) <= 0. )\n    {\n        // keep the camera on the ground, so it feels like we're looking up at a flag in a physical space\n        camPos = camPos * (-20.)/(camPos.y);\n        // for some reason this is offsetting the view to the right, so the flag's not at the centre of the frame\n        // this wasn't intentional but I like it!\n    }\n\n    float t = 0.0;\n    float h = 1.0;\n    for ( int i=0; i < 30; i++ ) // this holds up surprisingly well at low counts\n    {\n        if ( h < .01 )\n            break;\n        float h = DistanceField( camPos+t*ray );\n        t += h;\n    }\n\n    vec3 pos = camPos + t*ray;\n\n    vec2 uv = UVMapping( pos.xy );\n\n    vec3 albedo = Pattern( uv );\n\n    float mask = Mask(uv);\n\n    float weave = Weave(uv);\n    float seam = Seam(uv);\n\n    vec3 normal = Normal( pos );\n\n    const vec3 lightCol = vec3(1.8,1.6,1.3);\n    const vec3 lightDir = normalize(vec3(-3,.7,-.6));\n\n    float nl = dot(normal,lightDir);\n    float l = max( nl, .0 );\n//    float bl = max( mix(-nl,1.,.3), .0 ); // back light - including some scatter to prevent dark line where nl=0\n    vec3 scatteredLight = pow(albedo,vec3(2)) * smoothstep( .7, -1., nl ); // scattered light, favouring back-light\n    vec3 ambient = Ambient( normal ) * .3;\n\n    scatteredLight *= mix( .3, .7, weave );\n    ambient *= mix( 1.7, .3, weave );\n    l *= mix( 1.15, .85, weave );\n    \n    scatteredLight *= mix( .5, 1., seam );\n    \n    vec3 col = albedo;\n    col *= (l + scatteredLight)*lightCol + ambient;\n    \n    // todo: do GGX specular\n    col += lightCol * weave * pow(max(0.,dot(normalize(lightDir-ray),normal)),80.)*.2;\n    \n    // rim light - to make it feel a bit fuzzy\n    col += pow( dot(normal,ray)+1., 4. ) * (ambient+lightCol) * albedo *.5;\n\n    // atmospheric fog\n    col = mix( vec3(1), col, exp2( -t * airColourLog2 / 200. ) );\n\n    //if ( uv.x < .0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n    vec4 flagCol = vec4( col, 1. - mask );\n\n\n    fragColour.rgb = SkyColour(ray);\n    \n    // add flagpole\n    const float poleThickness = .05;\n    vec3 polePos = vec3(-poleThickness,1.1,0) - camPos; // centred on sphere at top of pole\n    \n    float distanceOfPoleAlongRay = dot( ray.xz, polePos.xz )/dot(ray.xz,ray.xz);\n    \n    float poleT = 1.;\n    bool intersection = false;\n    \n    // this is hacky and wrong, but it made the maths simpler and the error won't be obvious unless the camera gets close enough for a lot of perspective distortion\n    // basically I'm drawing a slice through the centre of the pole, rather than a 3D pole, for no reason other than I'm too lazy to look up/figure out the correct maths!\n    float poleOutlineSDF = length( vec2( length(ray.xz*distanceOfPoleAlongRay-polePos.xz), max(0.,ray.y*distanceOfPoleAlongRay-polePos.y) ) )  - poleThickness;\n    float halfFWidthPoleSDF = fwidth(poleOutlineSDF)*.5;\n    if ( poleOutlineSDF < halfFWidthPoleSDF )\n    {\n        poleT = distanceOfPoleAlongRay;\n        intersection = true;\n    \n        vec3 polePos = poleT*ray - polePos;\n    \n        vec3 poleNorm = polePos / poleThickness; // this is a hack\n        poleNorm.y = max(poleNorm.y,0.);\n    \n        poleNorm -= ray*sqrt(1.-min(1.,dot(poleNorm,poleNorm)));\n        poleNorm = normalize(poleNorm);\n    \n        vec3 poleCol = vec3(.6) * ( lightCol*max( dot( poleNorm, lightDir ), .0 ) + Ambient(poleNorm)*.5 );\n    \n        poleCol = mix( vec3(1), poleCol, exp2( -poleT * airColourLog2 / 200. ) );\n\n        fragColour.rgb = mix( poleCol, fragColour.rgb, linstep(-halfFWidthPoleSDF,halfFWidthPoleSDF,poleOutlineSDF) );\n        // todo - fake AA with rim-alpha\n    }\n\n    if ( !intersection || poleT > t )\n    {\n        fragColour.rgb = mix( fragColour.rgb, flagCol.rgb, flagCol.a );\n    }\n\n    // fake flat flagpole - I don't like this, I can replace it with a real one easily enough\n//    col = mix( col, vec3(cos(uv.x*50.0)),smoothstep(0.015,0.01,abs(uv.x+.01))*smoothstep(1.01,1.0,uv.y));\n\n    // tone mapping\n    fragColour.rgb = fragColour.rgb;\n\n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n\n    fragColour.a = 1.;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfDf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[522, 522, 554, 554, 639], [641, 641, 673, 673, 755], [757, 757, 784, 784, 1297], [1300, 1300, 1344, 1344, 1383], [1385, 1678, 1791, 1821, 2288], [2291, 2291, 2316, 2316, 3073], [3103, 3103, 3135, 3135, 3456], [3458, 3458, 3491, 3491, 3534], [3536, 3536, 3561, 3561, 3937], [3939, 3982, 4013, 4071, 5295], [6202, 6202, 6225, 6279, 6397], [6400, 6400, 6424, 6424, 6604], [6607, 6607, 6630, 6630, 6760], [6801, 6832, 6860, 6860, 7580], [7583, 7583, 7612, 7612, 7684], [7688, 7688, 7746, 7746, 12122]], "test": "untested"}
{"id": "NsS3Rw", "name": "Calibration", "author": "iq", "description": "Calibration", "tags": ["2d", "calibration"], "likes": 55, "viewed": 2759, "published": 3, "date": "1617095109", "time_retrieved": "2024-07-30T19:29:56.336437", "image_code": "// Created by inigo quilez - iq/2021\n\n\n// Useful calibration shader, not just for Shadertoy, but\n// for any renderer.\n//\n//\n// 1. checks that all pixels are rendered,\n//    including first and last rows and columns, in orange\n//\n// 2. checks that there's no pixel interpolation happening\n//    in the canvas (1x1 checkerboard in bottom left corner)\n//\n// 3. checks that gamma in fine (no circles should be visible\n//    in the image)\n//\n// 4. checks resolution\n//\n// 5. checks no frames are skipped (every box should be\n//    ticked/highlighted exactly once at the appropriate\n//    framerate column)\n\n//-----------------------------------------------------------------\n\nfloat PrintDigit(in int n, in vec2 p)\n{\t\t\n    // digit bitmap by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    const int lut[10] = int[10](480599,139810,476951,476999,71028,464711,464727,476228,481111,481095);\n    \n\tivec2 xy = ivec2(p*vec2(4,5));\n\tint   id = 4*xy.y + xy.x;\n    return float( (lut[n]>>id) & 1 );\n}\n\nfloat PrintInt(const in vec2 uv, in int value )\n{\n    float res = 0.0;\n\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        float maxDigits = (value==0) ? 1.0 : floor(1.0+log2(float(value))/log2(10.0));\n        float digitID = floor(uv.x);\n        if( digitID>=0.0 && digitID<maxDigits )\n        {\n            float digitVa = mod( floor(float(value)/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n            res = PrintDigit( int(digitVa), vec2(fract(uv.x), uv.y) );\n        }\n    }\n\treturn res;\t\n}\n\nfloat PrintIntN(const in vec2 uv, in int value, in int maxDigits )\n{\n    float res = 0.0;\n\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int digitID = int(floor(uv.x));\n        if( digitID>=0 && digitID<maxDigits )\n        {\n            float digitVa = mod( floor(float(value)/pow(10.0,float(maxDigits-1-digitID)) ), 10.0 );\n            res = PrintDigit( int(digitVa), vec2(fract(uv.x), uv.y) );\n        }\n    }\n\treturn res;\t\n}\n\n//-----------------------------------------------------------------\n\nvec3 pat1( in vec2 pixel, in vec2 res )\n{\n    vec2  uv = pixel/res.y;\n    \n    vec2 p = floor(pixel*exp2(-floor(6.0*uv.y)) );\n\n    float col = mod( p.x + p.y, 2.0 );\n    col *= smoothstep(0.005,0.010,abs(fract(6.0*uv.y+0.5)-0.5));\n    \n    return vec3( col );\n}\n\nvec3 pat2( in vec2 pixel, in vec2 res )\n{\n    vec2 uv = (2.0*pixel-res)/res.y;\n    float h = res.y*0.8;\n    \n    vec3 col = vec3(0.2);\n    \n    if( pixel.y<h )\n    {\n        col = vec3( pixel.y/h );\n\n        if( uv.x>0.0 )\n        {\n            vec2 p = floor(pixel);\n            float f = mod( p.x +p.y, 2.0 );\n\n            const float gamma = 2.3;\n            float midgrey = pow( 0.5, 1.0/gamma );\n\n            f = mix( midgrey,  f, smoothstep(0.1,0.101,length(vec2(uv.x,(fract(3.0*uv.y+0.5)-0.5)/3.0)-vec2(0.5*res.x/res.y,0.0))) );\n\n            col = vec3(f);\n        }\n    }\n    else\n    {\n        vec2 q = vec2(uv.x,uv.y-0.9);\n        q = 0.707*abs(vec2(q.x+q.y,-q.y+q.x));\n        q = (q.y<q.x)?q.yx:q;\n        q -= vec2(0.01,0.05);\n        float t = step( max(q.x,q.y), 0.0 );\n        \n        t += PrintInt( (uv-vec2(-0.5,0.85))*10.0, int(iResolution.x) );\n        t += PrintInt( (uv-vec2( 0.1,0.85))*10.0, int(iResolution.y) );\n\n        int ideg = int(iTime*60.0);\n        int degs = (ideg   ) % 60;\n        int secs = (ideg/60) % 60;\n        int mins = (ideg/3600) % 60;\n        t += PrintIntN( (uv-vec2(-0.3,0.67))*10.0, mins, 2 );\n        t += PrintIntN( (uv-vec2( 0.0,0.67))*10.0, secs, 2 );\n        t += PrintIntN( (uv-vec2( 0.3,0.67))*10.0, degs, 2 );\n        \n        // draw : :\n        q = vec2( abs(uv.x-0.087)-0.147,abs(uv.y-0.72)-0.035);\n        q = abs(q)-0.01;\n        t += step( max(q.x,q.y), 0.0 );\n\n        col = mix( col, vec3(1.0,0.5,0.0), t );\n    }\n\n\n    return col;\n}\n\nvec3 pat3( in vec2 pixel, in vec2 res )\n{\n    float v = pixel.y/res.y;\n    \n    int fps = 10;\n    if( pixel.x>res.x*1.0/5.0 ) fps =  15;\n    if( pixel.x>res.x*2.0/5.0 ) fps =  30;\n    if( pixel.x>res.x*3.0/5.0 ) fps =  60;\n    if( pixel.x>res.x*4.0/5.0 ) fps = 120;\n    int id = int(floor(v*float(fps)));\n    \n    float f = 0.2+0.2*float(id&1);\n    \n    vec3 col = vec3(f);\n\n    if( (int(iTime*float(fps))%fps)==id ) col = vec3(1.0);\n\n    col *= smoothstep(0.01,0.02,abs(fract(5.0*pixel.x/res.x+0.5)-0.5));\n\n    \n    vec2 q = vec2( mod(pixel.x,res.x/5.0)-res.x/64.0,pixel.y-res.y*0.97);\n    float t = PrintInt( q/res.y*50.0, fps );\n    \n    col = mix( col, vec3(1.0,0.5,0.0), t );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x0 = iResolution.x*0.0/3.0;\n    float x1 = iResolution.x*1.0/3.0;\n    float x2 = iResolution.x*2.0/3.0;\n    float wi = iResolution.x/3.0;\n    \n    vec3                 col = pat1(fragCoord-vec2(x0,0.0),vec2(wi,iResolution.y));\n    if( fragCoord.x>x1 ) col = pat2(fragCoord-vec2(x1,0.0),vec2(wi,iResolution.y));\n    if( fragCoord.x>x2 ) col = pat3(fragCoord-vec2(x2,0.0),vec2(wi,iResolution.y));\n\n    col *= smoothstep( 2.0, 4.0, mod(fragCoord.x,wi) );\n\n    ivec2 p = ivec2(fragCoord);\n    ivec2 r = ivec2(iResolution);\n    if( p.x==0 || p.y==0 || p.x==(r.x-1)  || p.y==(r.y-1) ) col = vec3(1.0,0.5,0.0);\n\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 710, 783, 990], [1973, 1973, 2014, 2014, 2234], [2236, 2236, 2277, 2277, 3735], [4443, 4443, 4500, 4500, 5146]], "test": "untested"}
{"id": "ssj3zD", "name": "Transparency Thing", "author": "Tater", "description": "just for fun.", "tags": ["2d", "random", "abstract"], "likes": 2, "viewed": 297, "published": 3, "date": "1617087362", "time_retrieved": "2024-07-30T19:29:57.106379", "image_code": "//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat circle(vec2 uv, float r){\nreturn smoothstep(r,r-0.04*hash21(r).x,length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+10.0;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0; i<150.0; i++){\n    \n        vec3 c = vec3(hash21(i*0.3123+floor(t)),hash21(i*0.3344+floor(t)).x); //Color\n        \n        vec2 pos = + vec2(sin(hash21(i).x*t),cos(hash21(i).y*t)); //Position\n        \n        c*=vec3(circle(uv+pos,0.1+0.0002*i+0.1*hash21(i).x))*(hash21(i).x*0.7); \n        \n        col.rgb+=c;\n    }\n    col+=0.25*(1.0-smoothstep(0.1,0.102,-(abs(uv.y)-0.3-0.2*sin(t)*sin(t))+0.02*sin(uv.x*20.0+t*10.0)));\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 61, 61, 189], [190, 190, 221, 221, 275], [277, 277, 334, 334, 937]], "test": "untested"}
{"id": "ss23zD", "name": "Just a Color Wheel", "author": "etiennecreator", "description": "Color wheel", "tags": ["color", "wheel", "colorwheel"], "likes": 0, "viewed": 298, "published": 3, "date": "1617082956", "time_retrieved": "2024-07-30T19:29:57.926186", "image_code": "#define PI 3.1416\n\nvec3 hsv2rgb(in vec3 c)\n{\n  c.x/=360.0;\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx,0.0,1.0), c.y);\n}\n\nvec4 drawColorRing(in vec2 uv){\n    float UV = floor(1.0-uv.y );\n    float rad = UV * 2.0 * PI+atan(uv.y,uv.x);\n    float degree = rad/(2.0*PI)*360.0;\n    return vec4(hsv2rgb(vec3(degree,1.0,1.0)),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragCoord-=iResolution.xy*vec2(0.5);\n    vec2 UV=fragCoord/(iResolution.y*0.5);\n   \n    vec4 ringColor = drawColorRing(UV);\n    fragColor=vec4(0.15,0.15,0.15,1.0);\n    fragColor=fragColor*(1.0-ringColor.a)+ringColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss23zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 44, 44, 219], [221, 221, 252, 252, 425], [427, 427, 484, 484, 704]], "test": "untested"}
{"id": "fdj3RW", "name": "reflection study", "author": "elenzil", "description": "just looking at 45 reflections.", "tags": ["mirrors"], "likes": 8, "viewed": 298, "published": 3, "date": "1617077405", "time_retrieved": "2024-07-30T19:29:58.741007", "image_code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-03-29 16:22:45\n\n// pixel epsilon for smoothstep\nfloat gSmoothEps;\n\n\n////////////////////////////////\n// Distance functions\n\nfloat sdDisk(in vec2 p, in vec2 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdCircle(in vec2 p, in vec2 c, in float r, in float w) {\n    return abs(sdDisk(p, c, r - w)) - w;\n}\n\n\n////////////////////////////////\n// Transformations\n\nvec2 rot45l(in vec2 p) {\n    return vec2((p.y + p.x) * INVSQRT2, (p.y - p.x) * INVSQRT2);\n}\n\nvec2 rot45r(in vec2 p) {\n    return vec2((p.x - p.y) * INVSQRT2, (p.y + p.x) * INVSQRT2);\n}\n\nvec2 mirrorX(in vec2 p) {\n    return vec2(abs(p.x), p.y);\n}\n\nvec2 mirrorY(in vec2 p) {\n    return vec2(p.x, abs(p.y));\n}\n\n// Is there a way to shortcut a 45 reflection ?\nvec2 mirror45l(in vec2 p) {\n    p = rot45l(p);\n    p = mirrorX(p);\n    p = rot45r(p);\n    return p;\n}\n\nvec2 mirror45r(in vec2 p) {\n    p = rot45r(p);\n    p = mirrorX(p);\n    p = rot45l(p);\n    return p;\n}\n\n\n////////////////////////////////\n// Miscellaneous\n\nfloat ss(in float d) {\n    return smoothstep(gSmoothEps, -gSmoothEps, d);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.78);\n    setupTime(iTime);\n    gSmoothEps = gWorldFromScreenFac * 1.0;\n    \n    // point and mouse\n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(iMouse.xy);\n    \n    if (length(iMouse.xy) < 50.0) {\n        float t = float(iFrame) / 60.0;\n        m = vec2(cos(t * TAO * 0.1), sin(t * TAO * 0.1)) * 0.8;\n    }\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.0, 0.8, 0.5);\n    const vec3 colFG4 = vec3(0.1, 0.6, 0.9);\n    const vec3 colFG5 = vec3(0.5, 0.4, 0.9);\n    const vec3 colBG2 = vec3(0.0);\n    const vec3 colBG3 = vec3(0.2);\n    \n    vec2 p45 = rot45l(p);\n    \n    vec3 col = colBG;\n    col.r   *= p  .x > 0.0 ? 1.3 : 1.0;\n    col.g   *= p  .y > 0.0 ? 1.1 : 1.0;\n    col.b   *= p45.y > 0.0 ? 1.1 : 1.0;\n    col.rgb *= p45.x > 0.0 ? 1.1 : 1.0;\n    col.rgb *= mix(1.0, 0.9, clamp(pow(length(p * 0.6), 2.2) / 2.0, 0.0, 1.0) * 2.0);\n    \n    float diskRad = 0.4;\n    float lineWid = 1.0 * gSmoothEps;\n    \n    // axes:  45 and regular\n    col = mix(col, colBG3, 0.5 * ss(min(abs(p45.x), abs(p45.y)) - lineWid * 0.5));\n    col = mix(col, colBG3, 0.5 * ss(min(abs(p  .x), abs(p  .y)) - lineWid * 0.5));\n\n    // dark tint inside main circle\n    col = mix(col, colFG1, -0.1 * ss(sdDisk(p, m, diskRad)));\n    \n    // reflections\n    col = mix(col, colFG5, ss(sdCircle(mirror45l(p), m, diskRad * 0.40, lineWid)));\n    col = mix(col, colFG2, ss(sdCircle(mirror45r(p), m, diskRad * 0.55, lineWid)));\n    col = mix(col, colFG4, ss(sdCircle(mirrorX  (p), m, diskRad * 0.70, lineWid)));\n    col = mix(col, colFG3, ss(sdCircle(mirrorY  (p), m, diskRad * 0.85, lineWid)));\n    \n    // main circle\n    col = mix(col, colFG1, ss(sdCircle(          p , m, diskRad * 1.00, lineWid)));\n    \n    RGBA = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "const float PI       = 3.14159265359;\nconst float TAO      = PI * 2.0;\nconst float SQRT2    = 1.41421356237;\nconst float INVSQRT2 = 1.0 / SQRT2;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdj3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 257, 257, 289], [291, 291, 353, 353, 396], [452, 452, 476, 476, 543], [545, 545, 569, 569, 636], [638, 638, 663, 663, 697], [699, 699, 724, 724, 758], [760, 810, 837, 837, 911], [913, 913, 940, 940, 1014], [1068, 1068, 1090, 1090, 1143], [1145, 1145, 1190, 1190, 3069]], "test": "untested"}
{"id": "fdBGRD", "name": "test1011", "author": "wei", "description": "test1011", "tags": ["test10"], "likes": 1, "viewed": 222, "published": 3, "date": "1617076529", "time_retrieved": "2024-07-30T19:29:59.674511", "image_code": "\n\n#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 13758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat circle(in vec2 _st, in float _r, in float _radius, in float _a, in float _t){\n    _st = rotate2d( iTime*_r*PI ) * _st;\n\n    float r = length(_st)*2.0;\n    float a = atan(_st.y,_st.x);\n    float f = _radius + sin(a*_a)*noise(_st+0.2*iTime+_t)*.03+0.01;\n    return 1.-smoothstep(f,f+0.007,r);\n}\n\nvec3 s(in vec2 st, in float _r, in float _radius, in float _a, in float _t){\n    vec3 color = vec3(0.);\n    float r = 0.24;\n\n    color += circle(st-vec2(-r, 0.12),_r, _radius,_a,_t);\n    color *= circle(st-vec2(r, 0.21),_r, _radius,_a,_t);\n    color *= vec3(0.6, 0.8,0.1);\n    \n    return color;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x /iResolution.y;\n    st *= 2.;\n    vec3 color = vec3(0.);\n    st-=vec2(1.8, 1.);\n    float t= 0.1;\n    for(int i=0;i<20;++i)\n    {\n    \n       st = rotate2d(2./PI) * st;\n       t-= 100.;\n      color += s(st,0.3,0.5,1.,t);\n    }\n\n\n   color += vec3(circle(st,-0.1,0.5,10.,1.));\n  color -= vec3(circle(st,-0.1,0.48,10.,1.));\n    \n    color += vec3(circle(st,0.1,0.54,7., 20.));\n   color -= vec3(circle(st,0.1,0.52,7.,20.));\n    \n   color += vec3(circle(st,0.2,0.6,12., 2.));\n   color -= vec3(circle(st,0.2,0.58,12.,2.));\n\n   color += vec3(circle(st,0.2,0.1,6., 2.))*vec3(0.1, 0.8,0.1)*2.;\n   fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 56, 56, 142], [144, 144, 171, 171, 288], [290, 290, 316, 316, 653], [655, 655, 738, 738, 953], [955, 955, 1031, 1031, 1257], [1259, 1259, 1316, 1316, 2001]], "test": "untested"}
{"id": "7djGRD", "name": "tres brazos--three arms", "author": "jorge2017a1", "description": "tres brazos--three arms", "tags": ["tresbrazosthreearms"], "likes": 1, "viewed": 231, "published": 3, "date": "1617073177", "time_retrieved": "2024-07-30T19:30:00.443455", "image_code": "//por jorge flores p.\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n  \nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick)\n{\n    //correcion por FabriceNeyret2,     \n    float pix = 1.5/iResolution.y;\n    return smoothstep(thick + pix, thick - pix, sdSegment(p,a,b));   \n\n    //return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));   \n}\n\nvec3 LineasCuadriculado(vec2 p, vec3 col)\n{\n     vec2 a1=vec2(0.0,-1.5);\n    vec2 b1=vec2(0.0,1.5);\n     \n    vec2 a2=vec2(-2.0, 0.0);\n    vec2 b2=vec2( 2.0, 0.0);\n    \n    //float thick = 2./iResolution.y;\n    float thick =3./iResolution.y;\n    \n    float ds2= line(p, a1, b1, thick);  //vertical\n    float ds3= line(p, a2, b2, thick);  //horizontal\n    \n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds2);\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds3);\n    return col;\n    \n}\n    \nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}    \n\nvec3 HacerBrazo(vec2 p, vec3 col )\n{\n    float thick = 2./iResolution.y;\n    \n    vec2 p1=vec2(0.0,0.0) ;\n    vec2 p2=vec2(0.5,0.5) ;\n    \n    vec2 p3=p2 ;\n    vec2 p4=p3+vec2(0.35,0.0) ;\n    \n    \n    vec2 p5=p4 ;\n    vec2 p6=p5+vec2(0.3,0.3) ;\n    \n    \n    vec2 pr1= RotarPuntoPivote( p,  p1, iTime);\n    vec2 pr2= RotarPuntoPivote( pr1,p3, iTime);\n    vec2 pr3= RotarPuntoPivote( pr2,p5, iTime*0.25);\n    \n    \n    float ds2= line(pr1, p1, p2, thick);  \n    float ds3= line(pr2, p3, p4, thick);  \n    float ds4= line(pr3, p5, p6, thick);  \n    \n    col = mix(col,vec3(1.0, 0.0,0.0),ds2);\n    col = mix(col,vec3(0.0, 0.0,1.0),ds3);\n    col = mix(col,vec3(0.0, 1.0,1.0),ds4);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv;\n    //vec3 col=vec3(0.65,0.7,1.0);\n    vec3 col=vec3(0.65);\n    col= LineasCuadriculado(p, col);\n    col= HacerBrazo( p,col );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 167, 167, 189], [190, 190, 223, 223, 245], [246, 246, 279, 279, 300], [660, 660, 696, 696, 741], [745, 745, 797, 797, 916], [919, 919, 953, 953, 1050], [1052, 1052, 1089, 1089, 1169], [1172, 1172, 1207, 1207, 1235], [1238, 1238, 1299, 1340, 1531], [1533, 1533, 1576, 1576, 2005], [2011, 2011, 2066, 2066, 2193], [2199, 2199, 2235, 2235, 2899], [2901, 2901, 2958, 2958, 3217]], "test": "untested"}
{"id": "sdjGRD", "name": "Volcanic trenches", "author": "jarble", "description": "A simple fractal formula.", "tags": ["lava", "volcano", "volcanic"], "likes": 5, "viewed": 287, "published": 3, "date": "1617072402", "time_retrieved": "2024-07-30T19:30:01.659205", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(iTime/2.0,iTime/8.0)/10.0;\n    for(int c=0;c<3;c++){\n        float scale = 2.5;\n        float scale1 = 1.5;\n        float scale3 = 8.0;\n        for(int i=0;i<9;i++)\n        {\n            uv = (fract(uv/scale1)+fract(uv/scale/scale3))*scale1;\n            uv= fract(uv/(scale1-fract((uv.x-uv.y)/(scale3)))-(uv/(scale+(fract(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n            uv=uv.yx+col.xy;\n            uv.x *= -1.;\n\n        }\n        col[c] += abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 748]], "test": "untested"}
{"id": "ss2GzW", "name": "Seafloor fractal", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "feather", "coral"], "likes": 3, "viewed": 297, "published": 3, "date": "1617069063", "time_retrieved": "2024-07-30T19:30:02.505941", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -1.0;\n        }\n     col[c] = fract((uv.y)+(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 698]], "test": "untested"}
{"id": "sd23RW", "name": "Acid Acid", "author": "Tater", "description": "I figured I had to make one of these at some point. ", "tags": ["2d", "waves", "flashing", "lsd"], "likes": 6, "viewed": 342, "published": 3, "date": "1617064593", "time_retrieved": "2024-07-30T19:30:03.275883", "image_code": "float func(float x){\nfloat r = 0.0; \nr+=abs(-0.3+sin(iTime+x))*2.0;\nr+=abs(-0.3+sin(-iTime+x))*2.0;\nr*=r;\nr/=6.0;\nreturn r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    uv.y=-uv.y;\n    float y0 = uv.y;\n    float y1 = uv.y;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i<17; i++){\n        float fi = float(i);\n        y1=uv.y+1.5-0.1*fi;\n        \n        y1+=0.1*-(0.5+(sin(uv.x+t)*sin(uv.x+t)))*func(t+10.0*uv.x+fi*2.0);\n        \n        y0 = y0*step(step(0.4,y1),0.01)+y1*step(0.4,y1);\n    }\n    col.g=(1.0-fract(y0*12.0*(0.1+pow(sin(0.3*t+1.0),2.0))));\n    col.r=(1.0-fract(y0*6.0*(0.1+pow(sin(0.6*t+2.0),2.0))));\n    col.b=(1.0-fract(y0* 3.0*(0.1+pow(sin(0.9*t+3.1),2.0))))*(sin(t)*sin(t));\n    //col+=1.0-step(0.41,y0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd23RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 125], [126, 126, 183, 183, 864]], "test": "untested"}
{"id": "7ss3zX", "name": "Solar fields", "author": "z0rg", "description": "A bit of fun on this brilliant song :)\nYou can make it your window terminal background following link here :\nhttps://github.com/seb776/WindowsTerminalShaders\n", "tags": ["abstract", "planets", "asteroid"], "likes": 20, "viewed": 907, "published": 3, "date": "1617045193", "time_retrieved": "2024-07-30T19:30:04.193429", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n//\n// You can make it your window terminal background following link here :\n// https://github.com/seb776/WindowsTerminalShaders\n//\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n#define FFT(a) texelFetch(iChannel1, ivec2(a, 0), 0).x\nfloat _time;\nmat2 r2d(float a) {float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _star(vec2 p, vec2 s)\n{\n    p*= r2d(PI/4.);\n    float a = _sqr(p, s);\n    float b = _sqr(p, s.yx);\n    return min(a, b);\n}\n\nfloat _stars(vec2 uv)\n{\n    vec2 ouv = uv;\n    float th = 0.002;\n    vec2 rep = vec2(0.1);\n\n    vec2 idx = floor((uv+rep*.5)/rep);\n    \n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    uv += sin(length(idx)*10.)*rep*.25;\n    float sz = sat(sin(idx.x*5.+idx.y+_time+length(ouv)*10.))*sat(length(ouv*2.)-.5);\n    return _star(uv, vec2(20.*th, th)*.5*sz);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.173,0.145,0.129)*(1.-sat(length(uv)-.5));\n    vec3 rgb = vec3(1.000,0.000,0.349);\n    \n    float th = 0.002;\n    float shp = 400.;\n    \n    float sun = _cir(uv, .1);\n    float innerSun = max(sun, (sin((uv.x+uv.y)*200.+_time*10.)+.7)*5.);\n    sun = abs(sun)-th;\n    innerSun = min(sun, innerSun);\n    col = mix(col, rgb, 1.-sat(innerSun*shp));\n    \n    float ta=_time*.5;\n    vec2 pa = uv-vec2(sin(ta), cos(ta))*.5;\n    float pla = _cir(pa, .04);\n    pla = abs(pla)-th;\n    pla = min(pla, _sqr(pa*r2d(-PI/4.), vec2(.08, th)));\n    col = mix(col, rgb, 1.-sat(pla*shp));\n    \n    float tb = _time;\n    vec2 pb = uv-vec2(sin(tb), cos(tb))*.2;\n    float plb = _cir(pb, .02);\n    col = mix(col, rgb, 1.-sat(plb*shp));\n    \n    float tc = _time*.7;\n    vec2 pc = uv-vec2(sin(tc), cos(tc))*.3;\n    float plc = _cir(pc, .05);\n    col = mix(col, rgb,  1.-sat(plc*shp));\n    \n    float stars = _stars(uv);\n    col = mix(col, rgb, 1.-sat(stars*shp));\n    \n    col += .5*sat(vec3(1.000,0.000,0.298)*5.)*(1.-sat(length(uv)));\n    \n    col *= .7*mix(vec3(1.000,0.000,0.298), vec3(0.), sat(length(uv)))*pow(FFT(20), .5);\n\n    col = mix(col, col.zyx, sat(length(uv)));\n    uv *= r2d(_time*.1);\n    uv += (sin(length(uv)*2.)*.5+.5)*.15;\n    col += sat(length(uv))*sat(length(uv))*pow(texture(iChannel0, 3.*uv*(sin(_time)*.01+.5)).x, 25.)*\n    mix(vec3(1.000,0.122,0.427), vec3(1.000,0.710,0.078), sat(length(uv)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = iTime*.5+texture(iChannel0, fragCoord/8.).x*iTimeDelta;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv *= 2.+sin(_time*.5);\n    vec3 col  = rdr(uv).zxy;\n    for (int i = 0; i < 16; ++i)\n    {\n        float f = (float(i)/16.)*(pow(FFT(50), 1.)*2.+.5);\n        float coef = 1.-sat(float(i)/16.);\n        col += rdr(uv*(1.-f*.1))*coef*.3;\n    }\n    col = pow(col, vec3(1.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26403, "src": "https://soundcloud.com/solarfields/10-solar-fields-asteroid-time", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ss3zX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[650, 650, 669, 669, 726], [727, 727, 756, 756, 782], [784, 784, 812, 812, 863], [865, 865, 894, 894, 993], [995, 995, 1018, 1018, 1341], [1343, 1343, 1362, 1362, 2799]], "test": "untested"}
{"id": "7djGRR", "name": "Gerstner Wave Approximation", "author": "Tech_", "description": "Here is a shader approximating Gerstner Waves... Based on https://catlikecoding.com/unity/tutorials/flow/waves/\nEnjoy!", "tags": ["waves", "water", "approximation", "gerstner"], "likes": 15, "viewed": 1261, "published": 3, "date": "1617028470", "time_retrieved": "2024-07-30T19:30:04.962373", "image_code": "#define MAX_STEPS 120\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define S smoothstep\n#define T iTime\n\n#define PI 3.1415\n#define SPEED 1.0\n\nstruct RayMarchObject \n{\n    int materialID;\n    float dist;\n};\n\n// Material struct currently only consists of an albedo color, but\n// can easily be extended\nstruct Material \n{\n    vec3 albedo;\n};\n\nMaterial[1] materials = Material[1](\n    Material(vec3(0.0, 0.35, 1.0))\n);\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 GerstnerWave(vec2 coord, float wavelength, float steepness, vec2 direction) \n{\n    const float gravitationalConst = 9.81;\n    \n    vec3 gerstner;\n    float k = 2.0 * PI / wavelength;\n    float c = sqrt(gravitationalConst / k);\n    float a = steepness / k;\n    vec2 dir = normalize(direction);\n    float f = k * (dot(dir, coord.xy) - c * iTime * SPEED);\n    \n    gerstner.x += dir.x * (a * cos(f));\n    gerstner.y = a * sin(f);\n    gerstner.z += dir.y * (a * cos(f));\n    \n    return gerstner;\n}\n\nRayMarchObject GetScene(vec3 p) \n{\n    vec3 waves;\n    waves += GerstnerWave(p.xz * 880.0, 60.0, 1.0, vec2(1, 1));\n    waves += GerstnerWave(p.xz * 880.0, 31.0, 1.0, vec2(1, 0.6));\n    waves += GerstnerWave(p.xz * 880.0, 18.0, 1.0, vec2(1, 1.3));\n    waves += GerstnerWave(p.xz * 880.0, 26.0, 1.0, vec2(0.7, 1.0));\n    waves += GerstnerWave(p.xz * 880.0, 22.0, 1.0, vec2(0.8, 0.6));\n    \n    waves *= 0.02;\n\n    float distGround = sdBox(p - waves * 0.01, vec3(0.1, 0.01, 0.1));\n    RayMarchObject ground = RayMarchObject(1, distGround);\n    \n    const int objectCount = 1;\n    RayMarchObject[objectCount] allObjects = RayMarchObject[objectCount](\n        ground\n    );\n    \n    //////////////////////////////////////////\n    \n    RayMarchObject finalObject = allObjects[0];\n    \n    for (int i = 0; i < objectCount - 1; i++) {\n        RayMarchObject currentObj = allObjects[i + 1];\n        if(currentObj.dist < finalObject.dist) finalObject = currentObj;\n    }\n    \n    return finalObject;\n}\n\nRayMarchObject RayMarch(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    int materialID;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        RayMarchObject object = GetScene(p);\n        float dS = object.dist;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) {\n            materialID = object.materialID;\n            break;\n        }\n    }\n    \n    return RayMarchObject(materialID, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetScene(p).dist;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetScene(p - e.xyy).dist,\n        GetScene(p - e.yxy).dist,\n        GetScene(p - e.yyx).dist);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0.1, -0.05, -0.15);\n    \n    if(m.xy == vec2(0.0)) {\n        m = vec2(0.56, 0.6);\n    }\n       \n    ro.yz *= Rot(m.y + 0.2);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    RayMarchObject scene = RayMarch(ro, rd);\n\n    if(scene.dist < MAX_DIST) \n    {\n        vec3 p = ro + rd * scene.dist;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 cubeMap = textureLod(iChannel0, r, 2.0).rgb;\n        col = cubeMap;\n    } else \n    {\n        col = vec3(0.025, 0.02, 0.025);\n    }\n    \n    vec2 st = fragCoord / iResolution.xy;\n    col *= mix(sin(st.x * PI) * sin(st.y * PI), 1.0, 0.2);\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 437, 437, 499], [501, 501, 532, 532, 619], [621, 621, 704, 704, 1120], [2115, 2115, 2159, 2159, 2527], [2529, 2529, 2553, 2553, 2773], [2775, 2775, 2825, 2825, 3016], [3018, 3018, 3075, 3075, 3943]], "test": "untested"}
{"id": "fdB3zD", "name": "For Willi, HSX", "author": "MacLin", "description": "For Willi, HSX", "tags": ["test"], "likes": 2, "viewed": 239, "published": 3, "date": "1617011736", "time_retrieved": "2024-07-30T19:30:05.925797", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 f = texture(iChannel0, uv) + 0.5;\n    vec2 duv = vec2(dFdx(f.x), dFdy(f.x)) * REFRACTION_RATIO;\n\n    vec4 col = texture(iChannel1, uv + duv);\n \n    //fragColor = vec4(f.x, 0.0, 0.0, 1.0);\n    //fragColor = vec4(0.0, f, 0.0, 1.0);\n    //fragColor = vec4(depth.x, depth.y, 0.0, 1.0);\n    //fragColor = vec4(0.0, 0.0, depth.z, 1.0);\n    //fragColor = vec4(duv.xy, 0.0, 1.0);\n    fragColor = vec4(col.xyz, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///////////////////////////////////////////////////////////\nbool CheckRainDrop(vec2 uv)\n{\n    float d = length(iMouse.xy - uv * iResolution.xy) / RAINDROP_SIZE;\n    \n    return d < 1.0 && iMouse.w>0.0;\n}\n\n\n///////////////////////////////////////////////////////////\nbool CheckWind(vec2 uv)\n{\n    float d = length(iMouse.x - uv.x * iResolution.x) / RAINDROP_SIZE;\n    \n    return d < 1.0 && iMouse.w>0.0;\n}\n\nvec3 getPositionVeclocityAcceleration(vec2 uv, float m, float k, float damping)\n{\n    // each texel meaning: r = position, g = velocity, b = acceleration\n    \n    // Get 4 neighbour pixel, (p)osition, (v)elocity, (a)cceleration\n    vec2 duv0 = vec2(0.0/iResolution.x,  1.0/iResolution.y);\n    vec2 duv1 = vec2(0.0/iResolution.x, -1.0/iResolution.y);\n    vec2 duv2 = vec2(-1.0/iResolution.x, 0.0/iResolution.y);\n    vec2 duv3 = vec2(1.0/iResolution.x, 0.0/iResolution.y);\n\n    vec4 oldpva0 = texture(iChannel0, uv + duv0);\n    vec4 oldpva1 = texture(iChannel0, uv + duv1);\n    vec4 oldpva2 = texture(iChannel0, uv + duv2);\n    vec4 oldpva3 = texture(iChannel0, uv + duv3);\n    vec4 oldpva = texture(iChannel0, uv);\n    \n    // calculate new force, negihbour pixel act like a spring, pulling center pixel\n    vec4 newpva = vec4(0.0, 0.0, 0.0, 0.0);\n    newpva.z += k * (oldpva0.x - oldpva.x) / m;  // F = -k * dx\n    newpva.z += k * (oldpva1.x - oldpva.x) / m;  // F = -k * dx\n    newpva.z += k * (oldpva2.x - oldpva.x) / m;  // F = -k * dx\n    newpva.z += k * (oldpva3.x - oldpva.x) / m;  // F = -k * dx\n\n    // calculate new velocity\n    newpva.y = oldpva.y + newpva.z;              // v = u + acc\n    newpva.y = damping * newpva.y;\n    \n    oldpva.x = CheckRainDrop(uv) ? RAINDROP_MAX_DEPTH : oldpva.x;\n    \n    newpva.x = oldpva.x + newpva.y;              // p1 = p0 + v\n#ifdef LIMIT_MAX_POSITION\n    newpva.x = clamp(newpva.x, -RAINDROP_MAX_DEPTH, RAINDROP_MAX_DEPTH);\n#endif\n        \n    return newpva.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 pva = getPositionVeclocityAcceleration(uv, MASS, SPRING_K, DAMPING);  \n\n    fragColor = vec4(pva, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MASS     1.0\n#define SPRING_K 0.5\n#define DAMPING  0.98\n#define REFRACTION_RATIO 0.1\n\n#define RAINDROP_SIZE 3.0\n#define RAINDROP_MAX_DEPTH 2.0\n\n#define LIMIT_MAX_POSITION ", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 523]], "test": "untested"}
{"id": "sd2Gzh", "name": "Sin Wave Wave [2D]", "author": "Tater", "description": "non ray marched version of [url]https://www.shadertoy.com/view/tsKSzR[/url]\n\nThere may be a less janky way to AA this, but I couldn't figure it out.\n\n", "tags": ["2d", "wave", "monochrome"], "likes": 38, "viewed": 1233, "published": 3, "date": "1616984445", "time_retrieved": "2024-07-30T19:30:06.698731", "image_code": "//2D version of https://www.shadertoy.com/view/tsKSzR\n//Original by skaplun\n\n//I tried to match it just by looking\n\n//I tried to match the perspective for fun but it got kinda tedious so\n//it's not perfect.\n\n\n#define pi 3.141592653\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*1.0;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    uv.y=-uv.y;\n    float y0 = uv.y;\n    float y1 = uv.y;\n    \n    float wc = 130.0;\n    float aa = 0.005*(450.0/max(iResolution.y,450.0)); \n    float w = 0.0035; //width\n    w-=aa; \n    \n    for(int i = 0; i<int(wc); i++){\n        float fi = float(i);\n        \n        y1=uv.y+1.1-2.5*(pow(fi/9.0,2.0)/300.0);\n\n        float x = uv.x*4.4+1.8*sin(fi/11.0+t)*((fi*3.3)/300.0);\n        \n        float h;\n        h = 3.5*sin((fi/11.0)+t);\n        \n        //Try these too\n        //h = 3.5*sin((fi/11.0)+t)*sin((fi/11.0)+t);\n        //h = 3.5*abs(sin((fi/11.0)+t));\n        \n        y1+=h*(cos(x*pi)+1.0)*0.05*step(-1.0,x)*step(x,1.0);\n        \n        y0 = y0*smoothstep((y1+w)+aa,(y1+w)+aa*3.0,0.4)  \n        +(y1-w)*smoothstep(0.4,0.4+aa,(y1-w)+aa);    \n    }\n    \n    //This is bad but I'm too stupid to fix it.\n    y0=1.0-y0;\n    y0=smoothstep(y0-0.4,y0,0.6);\n    y0=1.0-y0;\n\n    fragColor = vec4(vec3(y0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2Gzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 289, 289, 1298]], "test": "untested"}
{"id": "ss2Gz1", "name": "bajando edificio", "author": "jorge2017a1", "description": "bajando edificio", "tags": ["bajandoedificio"], "likes": 1, "viewed": 226, "published": 3, "date": "1616980468", "time_retrieved": "2024-07-30T19:30:07.467675", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\nfloat tau = atan(1.0) * 8.0;\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//Hexagonal Prism - exact\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n    \nvec3 HacerCuartoyPuertas(vec3 pp)\n{\n    vec3 p=pp;\n    pp.y=pp.y+3.0;\n    p=pp;\n    \n    float numItem=6.0;\n     p= rotate_x( p, radians(90.0));\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n     float sdb1a= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.8,6.0,15.0) ); //hex rgrande \n    float sdb2a= sdBox(rep2-vec3(5.0,0.0,-5.5), vec3(6.5,3.0,8.0) );  //puertas\n    p=pp-vec3(0.0,5.0,0.0);\n    vec3 p0= rotate_y( p, radians(330.0));\n    vec3 p1= rotate_y( p, radians(30.0));\n    vec3 p2= rotate_y( p, radians(90.0));\n    float tp0= sdTriPrism(p0 -vec3(0.0,0.0,-11.0), vec2(3.5,2.) );\n    float tp1= sdTriPrism(p1 -vec3(0.0,0.0,-11.0), vec2(3.5,2.0) );\n    float tp2= sdTriPrism(p2 -vec3(0.0,0.0,-11.0), vec2(3.5,2.0) );\n     p=pp;\n     vec3 p4= rotate_x( p, radians(90.0));\n     float hp1= sdHexPrism( p4-vec3(0.0,0.0,-14.0), vec2(15.0,0.5) );\n    float dif;\n    dif=differenceSDF(sdb1a, sdb2a);\n    dif=differenceSDF(dif, tp0);\n    dif=differenceSDF(dif, tp1);\n    dif=differenceSDF(dif, tp2);\n     vec2 res=vec2(9999.9,-1.0);\n    res = opU2( res, vec2(dif,1.0));\n    res = opU2( res, vec2(hp1,2.0));\n    return vec3(res,-1.0);\n}\n\nvec3 parteMedia(vec3 pp)\n{\n    vec3 p=pp;\n    p=pp;\n    float numItem=6.0;\n    p= rotate_x( p, radians(90.0));\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1a= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.8,6.0,10.0) ); //hex rgrande \n    \n    p=pp;\n    vec3 p4= rotate_x( p, radians(90.0));\n    float hp1= sdHexPrism( p4-vec3(0.0,0.0,-10.0), vec2(20.0,0.5) );\n    vec2 res=vec2(9999.9,-1.0);\n    res = opU2( res, vec2(sdb1a,1.0));\n    res = opU2( res, vec2(hp1,4.0));\n    return vec3(res,-1.0);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    \n    vec3 pp=p;\n    /*\n    p.x=opRep1D(p.x, 40.0 );\n    p.z=opRep1D(p.z, 45.0 );\n    */\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    vec3 p1=p;\n    vec3 p2=p;\n     \n     p1.y=opRep1D(p1.y, 60.0 );\n     p2.y=p2.y-30.0;\n     p2.y=opRep1D(p2.y, 60.0 );\n     \n    \n    p1.xz= rotatev2(p1.xz, radians(iTime*2.0));\n    vec3 hcp1= HacerCuartoyPuertas(p1-vec3(0.0,0.0,0.0));\n    p2.xz= rotatev2(p2.xz, radians(30.));\n    vec3 hcp2= HacerCuartoyPuertas(p2-vec3(0.0,0.0,0.0));\n    \n    \n    res =opU3(res, hcp1); \n    res =opU3(res, hcp2); \n    \n  //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    float mz=-40.+abs(20.0*sin(t*0.125));\n    vec3 ro=vec3(0.0,7.0-t,mz );\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        \n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Gz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 626, 626, 647], [648, 648, 680, 680, 764], [765, 765, 811, 811, 898], [899, 899, 933, 933, 995], [996, 996, 1033, 1033, 1128], [1129, 1129, 1168, 1168, 1263], [1264, 1264, 1303, 1303, 1398], [1399, 1399, 1438, 1438, 1533], [1535, 1579, 1626, 1626, 1653], [1655, 1655, 1698, 1698, 1725], [1727, 1727, 1775, 1775, 1803], [1804, 1888, 1924, 1924, 1969], [1970, 2035, 2069, 2069, 2167], [2168, 2168, 2202, 2202, 2294], [2295, 2295, 2329, 2329, 2421], [2422, 2462, 2496, 2496, 2593], [2622, 2622, 2658, 2658, 2931], [2933, 2933, 2969, 2969, 3052], [3054, 3054, 3088, 3088, 3261], [3267, 3267, 3302, 3302, 4395], [4397, 4397, 4423, 4423, 4899], [4900, 4940, 4965, 4965, 5656], [5658, 5658, 5723, 5723, 6307], [6309, 6360, 6384, 6384, 6572], [6574, 6574, 6607, 6607, 7297], [7302, 7356, 7392, 7392, 7626], [7627, 7728, 7808, 7808, 8076], [8171, 8171, 8264, 8264, 8364], [8366, 8366, 8393, 8393, 8503], [8504, 8553, 8610, 8610, 9967]], "test": "untested"}
{"id": "Ns23z1", "name": "Autumn grid ", "author": "josemorval", "description": "Just a bunch of cubes in a repeated space with some noisy movement", "tags": ["raymarching", "cubes", "repeated"], "likes": 40, "viewed": 891, "published": 3, "date": "1616959298", "time_retrieved": "2024-07-30T19:30:08.242604", "image_code": "//Box signed distance\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Distance mapping\nfloat map(vec3 p){\n    float d = 1000.;\n    vec3 q = p;\n    \n    //Here we compute the cell coordinates + index per cell\n    float size = 2.;\n    vec3 iq = floor((p+size/2.)/size);\n    q = mod(q+size/2.,size)-size/2.;\n    \n    //Some noisy pattern\n    float n=0.;\n    n+=0.5*sin(0.8*iq.x+1.1*iTime)*sin(0.71*iq.y+0.2*iTime+0.4)*sin(0.85*iq.z+0.3*iTime+1.4);\n    n+=0.5*sin(0.5*iq.x+1.1*iTime+1.5)*sin(0.3*iq.y+1.3*iTime+1.7)*sin(0.1*iq.z+0.3*iTime+2.4);\n    n = 1.-smoothstep(0.,0.2,n+0.1);\n\n    \n    //Distance to box in a cell + space clamp (tweak box distance to raymarch slow)\n    d = 0.25*box(q,0.9*vec3(n));\n    d = max(d,box(p,vec3(9.)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = 0.001*vec2(1.,0.);float d = map(p);\n    return normalize(vec3(map(p+e.xyy)-d,map(p+e.yxy)-d,map(p+e.yyx)-d));\n}\n\n//Raymarch (and shadow march) routines\nconst float FAR = 10000.;\nfloat raytrace(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return t;\n        }\n        t+=d;\n    }\n    \n    return FAR;\n}\n\nfloat shadow(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return 0.;\n        }\n        t+=d;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n\n    float f =0.5*sin(0.5*iTime)-0.5;\n\n    //Ortho camera\n    vec3 ro= 5.*vec3(3.*sin(f),2.,3.*cos(f));\n    vec3 rd = -normalize(ro);\n    vec3 up = vec3(0.,1.,0.);vec3 fw =rd;vec3 ri = cross(fw,up); up = cross(ri,fw);\n    ro=ro+20.*(uv.x*ri+uv.y*up);\n    \n    float t = raytrace(ro,rd);\n    \n    //Background\n    col = vec3(1.,0.9,0.8)*(0.4-0.3*uv.y);\n    vec3 lightdir = normalize(vec3(1.,2.,1.));\n    \n    if(t<FAR){\n        \n        //Simple lighting (dot, shadow and height based)\n        vec3 pos = ro+rd*t;\n        vec3 n = normal(pos);\n        float sha = shadow(pos+0.01*n,lightdir);\n        \n        vec3 lin = max(dot(n,lightdir),0.)*vec3(1.,0.95,0.85)*(0.+1.*sha);\n        lin += 1.1*vec3(0.1,0.05,0.0)*(1.5+0.1*pos.y);\n        \n        \n        col = lin;\n \n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 51, 51, 138], [140, 159, 177, 177, 820], [822, 822, 842, 842, 967], [1034, 1034, 1066, 1066, 1245], [1247, 1247, 1277, 1277, 1456], [1458, 1458, 1515, 1515, 2461]], "test": "untested"}
{"id": "Nd2Gz1", "name": "MovingNoise(+sound)", "author": "Biverom", "description": "Moving Noise (with sound)", "tags": ["noise"], "likes": 1, "viewed": 359, "published": 3, "date": "1616957055", "time_retrieved": "2024-07-30T19:30:09.056428", "image_code": "//https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint hash(uint state) {\n    state ^= 2747636419u;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    return state;\n}\n\nfloat scaleToRange01(uint state) {\n    return float(state) / 4294967295.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float fact = scaleToRange01(hash(uint(0.1*iTime*iTime*iTime*iTime + (800.0*fragCoord.y+fragCoord.x))));\n\n    vec3 col = vec3(fact,fact,fact);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "uint hash(uint state) {\n    state ^= 2747636419u;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    return state;\n}\n\nfloat scaleToRange01(uint state) {\n    return float(state) / 4294967295.0;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time*scaleToRange01(hash(uint(0.1*time*time*time*time+2.0)))));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Gz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 93, 93, 269], [271, 271, 305, 305, 347], [349, 349, 406, 456, 705]], "test": "untested"}
{"id": "sdS3zh", "name": "relaxing patern", "author": "mdb", "description": "just sit, put a Head phone and put the shader full screen and you can just lisen to the music and relax", "tags": ["art"], "likes": 18, "viewed": 521, "published": 3, "date": "1616954973", "time_retrieved": "2024-07-30T19:30:09.832353", "image_code": "//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\nfloat noise(vec2 pos)\n{\n    vec2 id, id2, pt;\n    float d;\n    float dist = 1e5;\n    \n    id = floor(pos);\n    \n    for(float x = -1.0; x < 2.0; x++){\n    for(float y = -1.0; y < 2.0; y++){\n        id2 = id + vec2(x, y);\n        initRandomGenerator(id2);\n        pt = vec2(random(), random());\n        d = distance(pos, pt + id2);\n        dist = min(dist, d);\n    \n    }}\n    return max(0.0, 1.0 - dist);\n    \n}\nfloat fbm( vec2 pos )\n{\n    float f = 0.0;\n    float a = 1.0;\n    float d = 0.5;\n    a*=d;\n    f += a*noise(pos); pos*=2.01; a *= d;\n    f += a*noise(pos); pos*=2.01; a *= d;\n    f += a*noise(pos); pos*=2.01; a *= d;\n    f += a*noise(pos); pos*=2.01; a *= d;\n    f += a*noise(pos); pos*=2.01; a *= d;\n    f += a*noise(pos);\n    return f;\n}\nvec3 patern(vec2 pos){\n    float beat = texture(iChannel0, vec2(0.5, 0.0)).x;\n    float k = fbm(pos - vec2(0.0, 0.6*pow(texture(iChannel0, vec2(0.1, 0.0)).x, 8.0)));\n    float k2 = fbm(pos + 338.78 + k*4.0 + iTime*0.03);\n    k2*=0.7+beat*0.3;\n    return sin(vec3(k2*9.0, k2*7.0+beat*0.3, k2*6.0))*0.5+ 0.5;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 col = patern(uv*3.0);\n    //col +=  + texture(iChannel0, vec2(0.5, 0.0)).x*0.1;\n    //vec3 col = texture(iChannel0,vec2(fragCoord.x/iResolution.x*0.1, 0.0)).xyz;\n    uv.x *= iResolution.y/iResolution.x;\n    col *= (1.0 + pow(4.0*max(texture(iChannel0, vec2(0.95, 0.0)).x - texture(iChannel0, vec2(0.85, 0.0)).x, 0.0), 3.0));\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), texture(iChannel0, vec2(0.01, 0.0)).x*0.005 );\n    \n    float beat = texture(iChannel0, vec2(0.5, 0.0)).x;\n    col *= 1.0 + beat*1.5;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 26372, "src": "https://soundcloud.com/ceket/peter-von-poehl-the-story-of", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 99, 99, 249], [250, 250, 284, 284, 330], [332, 332, 347, 347, 398], [399, 469, 492, 492, 880], [881, 881, 904, 904, 1220], [1221, 1221, 1243, 1243, 1530], [1532, 1532, 1589, 1589, 2199]], "test": "untested"}
{"id": "fsj3Rh", "name": "CameraUVDistort1", "author": "Biverom", "description": "CameraUVDistort1", "tags": ["camera"], "likes": 3, "viewed": 432, "published": 3, "date": "1616945059", "time_retrieved": "2024-07-30T19:30:10.596813", "image_code": "float glfact = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 duv = 0.5*uv+0.5;\n    \n    float fact = 0.5*(cos(1.0-(0.05*sqrt(pow(iMouse.x-fragCoord.x,2.0)+pow(iMouse.y-fragCoord.y,2.0)))) + 1.0);\n    \n    vec2 newuv = (fact*glfact)*duv + (1.0-fact*glfact)*uv;\n\n    vec3 col = texture(iChannel0,newuv).rgb;\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(newuv,1.0,1.0);\n    //fragColor = vec4(fact,fact,fact,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 489]], "test": "untested"}
{"id": "7sBGR1", "name": "field of quadripoles", "author": "FabriceNeyret2", "description": "dots emit tetraequivalued fields, figured as R,G,B,Y resulting in a quadripolar field.\nParticle tetrasign checkered along grid.\n\nmouse click: signed values  otherwise in [0,1]   ( null potential = half-grey )", "tags": ["dipole", "tripole", "quarks", "chromodynamics", "quadripole"], "likes": 13, "viewed": 462, "published": 3, "date": "1616937392", "time_retrieved": "2024-07-30T19:30:11.357779", "image_code": "// variant of quadripole https://shadertoy.com/view/7sBGzh\n\n\n#define F(P)     1./dot(P-U,P-U)       // point field\n#define CS(a)    vec2(cos(a),sin(a))\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define rot(a)   mat2(cos(a + vec4(0,11,33,0)))\n\nint n =17;  // neighborhod. big since 1/d don't decrease fast enough.\n            //              should approx F with narrower support\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 4.* ( 2.*u - R ) / R.y,\n         I = floor(U), P,I1,\n         A = CS(1.9111),  // 109.5 : tetraedron vertical angle\n         j = CS(2.0944);  // 2pi/3 \n    mat4x3 J = mat4x3( vec3(0,0,1) ,vec3(1,0,1)*A.yyx, vec3(j,1)*A.yyx, vec3(j.x,-j.y,1)*A.yyx );\n    vec3 F = vec3(0);\n\n    float f, f0;\n    for (int k=0; k<n*n; k++) {    // --- sum influences from neighbor particlse \n        I1 = I + vec2(k%n -n/2,k/n -n/2);         // neighbor cell\n        P = I1 + (hash2(I1)-.5) *rot(iTime*8.*(hash(I1)-.5)) +.5; // random dot in the current neighbor cell\n        float f =  F(P);\n        F += J[int(mod(I1.x+2.*I1.y,4.))] * F(P); // particle potential ( checkered tetrasign )\n        f0 = max( f0, f );\n    }   \n    O =  F * J; \n    O += O.w *vec4(1,1,0,0);       // remap O.w as yellow\n    \n    if (iMouse.z<=0.) O = .5+.5*O; // not click: [0,1] values, otherwise signed\n    O = max( O, f0/R.y );          // display white dot at particle location\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 490, 528, 528, 1516]], "test": "untested"}
{"id": "7sBGzh", "name": "quadripole 2", "author": "FabriceNeyret2", "description": "dots emit tetraequivalued fields, figured as R,G,B,Y  ( green is mouse controlled ), resulting in a quadripolar field.\n( it quickly decrease as grey with distance ) \n\nThe right way is using a 4-simplex.", "tags": ["dipole", "tripole", "quarks", "chromodynamics", "quadripole"], "likes": 9, "viewed": 362, "published": 3, "date": "1616933476", "time_retrieved": "2024-07-30T19:30:12.120739", "image_code": "// variant of tripole https://shadertoy.com/view/Ns23zR\n// variant of dipole  https://shadertoy.com/view/Nsj3zR\n\n\n#define F(P)  1./dot(P-U,P-U)       // point field\n#define CS(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = ( 2.*iMouse.xy  - R ) / R.y,\n         P = vec2(.4,0) +.3*CS(2.*iTime);\n    vec4 f = vec4( F(vec2(0,.3)), F(M), F(vec2(0,-.3)), F(P) );\n\n#if 1 // --- the correct way: using a simplex\n    vec2 A = CS(1.9111),  // 109.5 : tetraedron vertical angle\n         j = CS(2.0944);  // 2pi/3 \n\n    mat4x3 J = mat4x3( vec3(0,0,1) ,vec3(1,0,1)*A.yyx, vec3(j,1)*A.yyx, vec3(j.x,-j.y,1)*A.yyx );\n    vec3 F;\n#else // --- the wrong way: using 2D equals angle ( because not all mutually equal ) \n    mat4x2 J = mat4x2( vec2(1,0) ,vec2(0,1), vec2(-1,0), vec2 (0,-1) );\n    vec2 F;\n#endif    \n\n    F = J * f;\n    O = .5+.5*  F * J; O += (O.a-.5)*vec4(1,1,0,0);\n    \n    f /= R.y;\n    O =  max( O, max( max( f.x, f.y ),  max( f.z , f.w ) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 238, 238, 1038]], "test": "untested"}
{"id": "Nd2GRR", "name": "Erosion Landscape", "author": "Dragonpeak", "description": "A test of erosion and general terrain generation/rendering.\nSpace to reset terrain(needed if screen size changes).\n\nAsync texture loading might break this shader sometimes, if so wait for the clouds to load and then reset with space or the back button.", "tags": ["procedural", "raymarching", "simulation", "clouds", "landscape", "volumetrics", "erosion"], "likes": 33, "viewed": 1344, "published": 3, "date": "1616923062", "time_retrieved": "2024-07-30T19:30:13.073192", "image_code": "// a better version is available at https://www.shadertoy.com/view/st2BRW\nvec3 CAMERA_POS = vec3(-1.5, -1.5, 1.);\nconst vec3 CAMERA_LOOK = vec3(0.,0.,0.);\nconst float FAR = 5.;\n\nconst float EPS = .01;\nconst float SHADOW_EPS = .03;\nconst float STEP_SIZE = .001;\nconst float SHADOW_STEP = .06;\nconst vec3 SUN_DIR = normalize(vec3(.3, .5, .1));\nconst vec3 SUN_COL = vec3(1,.7,.4)*2.;\nconst vec3 AMBIENT = vec3(.3,.35,.53)*.3;\n\nconst vec2 W_NRM_EPS = vec2(.001,0.);\n\nconst float CLOUDS_STEP = .007;\nconst int CLOUD_OCT = 7;\nconst float CLOUD_SCALE = .0016;\nconst float CLOUD_LIGHT_STEP = .1;\nconst float CLOUD_LIGHT_FAR = .5;\n\nconst int TERRAIN_BUMP_OCT = 4;\n\nconst vec2 T_NRM_EPS = vec2(.0017,0.);\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec2 ray_box_intersect( vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    //from https://iquilezles.org/articles/intersectors\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(FAR); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nvec4 get_terrain(vec2 p)\n{\n    //if(p.x > 1. || p.y > 1.|| p.x < 0.|| p.y < 0.) return vec4(0,0,1,0);\n    return texture(iChannel0, (p+vec2(1))*.4);\n}\n\nvec4 march_terrain(vec3 pos, vec3 dir, float dist, float far)\n{\n    vec4 data = vec4(0);\n    while(dist < far)\n    {\n        vec3 p = pos+dir*dist;\n        data = get_terrain(p.xy);\n        if(p.z < data.w+EPS)return vec4(data.xyz, dist-STEP_SIZE/2.);\n        dist += STEP_SIZE;\n    }\n    return vec4(data.xyz, FAR);\n}\nfloat march_shadows(vec3 p, vec3 d, float k)\n{\n    float r = 1.;\n    float dep = 0.001+SHADOW_EPS;\n    while(dep < FAR)\n    {\n        vec3 p = p+d*dep;\n        float dist = get_terrain(p.xy).w;\n        if(p.z < dist+SHADOW_EPS) 0.;\n        \n        r = min(r, k*(p.z-dist)/dep);\n        dep += SHADOW_STEP;\n    }\n    return r;\n}\n\n\nfloat cloud_dens(vec3 p)\n{\n   float s = 1.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < CLOUD_OCT; i++)\n   {\n       data += noise(((p.xy+vec2(float(i)*7.8936345, float(i)*-13.73467))*s)+WIND*iTime, iChannel2, vec2(1024), CLOUD_SCALE, .001)*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   data = min(max(data-.65, 0.)*4., 1.);\n   \n   float h = max(1.-max(abs(p.z-.4)+4.93, 0.)*.2, 0.);\n   \n   return data*h*10.;\n       \n}\n\nvec3 march_cloud_light(vec3 p, vec3 dir)\n{\n    float dep = 0.;\n    float dens = 0.;\n    //float amt = (ma-mi)/CLOUDS_STEP;\n    while(dep < CLOUD_LIGHT_FAR)\n    {\n        vec3 pos = p+dir*dep;\n        dens += cloud_dens(pos);\n        dep += CLOUD_LIGHT_STEP;\n    }\n    return mix(SUN_COL, vec3(.8, .8, 1.),  clamp(pow(dens, .2), 0., 1.))*1.4+AMBIENT;\n}\n\nvec4 march_clouds(vec3 p, vec3 dir, float mi, float ma)\n{\n    float dep = mi;\n    float dens = 0.;\n    vec3 light = vec3(1.);\n    float amt = (FAR-mi)/CLOUDS_STEP;\n    while(dep < ma)\n    {\n        vec3 pos = p+dir*dep;\n        float cd = cloud_dens(pos);\n        dens += cd;\n        dep += CLOUDS_STEP;\n        if(cd > .01)light += march_cloud_light(pos, SUN_DIR)*(1./dens);\n    }\n    return vec4(light/amt,clamp(dens, 0., 1.));\n}\n\n\n\nfloat terrain_bump(vec2 p)\n{\n   float s = 1.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < TERRAIN_BUMP_OCT; i++)\n   {\n       data += noise(((p.xy+vec2(float(i)*7.8936345, float(i)*-13.73467))*s), iChannel2, vec2(1024), .1, .001)*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   return data;\n}\n\nvec3 terrain_bump_nrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(terrain_bump(p+T_NRM_EPS) - terrain_bump(p-T_NRM_EPS));\n    nrm.y = -(terrain_bump(p+T_NRM_EPS.yx) - terrain_bump(p-T_NRM_EPS.yx));\n    nrm.z = 1.;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n\nfloat get_ao(vec2 p)\n{\n    vec2 t = vec2(EPS*3., 0);\n    float ao = 0.;\n    \n    float b = get_terrain(p).w;\n    \n    float x = (get_terrain(p+t).w+get_terrain(p-t).w+get_terrain(p+t.yx).w+get_terrain(p-t.yx).w)/4.;\n    \n    ao += b-x;\n    \n    return ao*16.+.4;\n}\n\nvec3 texture_terrain(vec3 p, vec3 nrm, bool is_edge)\n{\n    vec3 col = vec3(0.);\n    vec3 stone = vec3(.6);\n    vec3 grass = vec3(.4, .6, .4);\n    vec3 snow = vec3(1.1, 1.1, 1.2)*4.;\n    float stone_mask = min(max((dot(nrm, vec3(0,0,1))-.87), 0.)*8., 1.);\n    float snow_mask = min(max((p.z-.14), 0.)*64., 1.);\n    \n    if(is_edge)//draw edge\n    {\n        float h = get_terrain(p.xy).w-p.z;\n        stone_mask += 1.-min(max(h-.01, 0.)*64., 1.);\n        \n    }\n    \n    vec3 ground = mix(grass, snow, snow_mask);\n    \n    col = mix(stone, ground, stone_mask);\n\n    \n    return col;\n}\n\nvec3 shade_terrain(vec3 p, vec3 nrm, vec3 dir, float dist, bool is_edge)\n{\n\n    vec3 col = texture_terrain(p,nrm,is_edge);\n    float sun = clamp(dot(SUN_DIR, nrm), 0.,1.);\n    vec3 r = reflect(dir, nrm);\n    vec3 ref = vec3(min(max((dot(r, SUN_DIR)-.85), 0.)*4., 1.));\n    if(!is_edge)\n    {\n        float shadow = clamp(march_shadows(p, SUN_DIR, 10.),0.,1.);\n\n        sun *= shadow;\n        ref *= shadow;\n    }\n    vec3 light = SUN_COL*sun;\n    light += AMBIENT;\n    light += ref;\n    \n    if(!is_edge)\n    {\n        float ao = get_ao(p.xy);\n\n        light *= ao;\n    }\n    \n  \n    col *= light;\n    //col = nrm;\n    //col = vec3(shadow);\n   \n    return col;\n}\n\nvec3 draw_fog(vec3 p, float d, bool is_edge)\n{\n    if(is_edge)return vec3(0);\n    d /= FAR;\n    float z = 1.-min(max(p.z-.03, 0.)*5., 1.);\n    z *= d;\n    return vec3(.7, .7, .9)*z*.7;\n}\n\nvec3 shade_sky(vec3 d)\n{\n    vec3 col = mix(vec3(.8,.8, 1.), vec3(.025, .05, .7)*.8, clamp(d.z+.4, 0., 1.));\n    \n    \n    col += SUN_COL*max(1.-max(distance(SUN_DIR, d)+.9, 0.), 0.)*10.;\n    \n    return col;\n}\n\nfloat water_h(vec2 p)\n{\n    return noise((p*1.2)+WIND*.5*iTime, iChannel2, vec2(1024), .1, .001);\n}\n\nvec3 water_nrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(water_h(p+W_NRM_EPS) - water_h(p-W_NRM_EPS));\n    nrm.y = -(water_h(p+W_NRM_EPS.yx) - water_h(p-W_NRM_EPS.yx));\n    nrm.z = 1.;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\nvec3 fresnel(float cosTheta, vec3 F0)\n{\n    //from https://learnopengl.com/PBR/Theory\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 shade_water(vec3 dir, float d, float wd, vec3 nrm)\n{\n    nrm = normalize(nrm+water_nrm((CAMERA_POS+dir*wd).xy));\n    float fr = fresnel(dot(dir, nrm), vec3(1.055)).x;//fresnel\n    vec3 sky = shade_sky(reflect(dir, nrm));\n    return vec3(sky*fr*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    if(DEBUG_DRAW_PARTICLES)\n    {\n        col = vec3(texture(iChannel0, fragCoord/iResolution.xy).w);\n        for(int i = 0; i < PARTICLE_COUNT_X; i++)\n        {\n            for(int j = 0; j < PARTICLE_COUNT_Y; j++)\n            {\n                vec4 data = texelFetch(iChannel1, ivec2(i,j), 0);\n                if(floor(data.xy) == floor(fragCoord.xy)) col = vec3(data.z, 1, 0);\n            }\n        }\n    }\n    else\n    {\n        CAMERA_POS.y = sin(iTime*0.2)*2.5;\n        CAMERA_POS.x = cos(iTime*0.2)*2.5;\n\n        vec3 local_dir = ray_direction(80., iResolution.xy, fragCoord);\n\n        mat4 view = view_matrix(CAMERA_POS, CAMERA_LOOK, vec3(0.,0.,1.));\n        vec3 dir = (view * vec4(local_dir, 0.)).xyz;\n\n        vec3 b_nrm;\n        vec3 box_s = vec3(1,1,FAR);\n        vec2 b_dist = ray_box_intersect(CAMERA_POS, dir, box_s, b_nrm);\n        col = shade_sky(dir);\n        if(b_dist.x<FAR)\n        {\n\n            vec4 data = march_terrain(CAMERA_POS, dir, b_dist.x, b_dist.y);\n            if(data.w <= b_dist.x+EPS) data = vec4(b_nrm, b_dist.x);\n            data.w = min(data.w, b_dist.y);\n            vec3 pos = CAMERA_POS+dir*data.w;\n            \n            bool is_edge = data.xyz == vec3(0,1,0) || data.xyz == vec3(0,-1,0) || data.xyz == vec3(1,0,0) || data.xyz == vec3(-1,0,0);\n            vec3 water_nrm;\n            vec2 water_d = ray_box_intersect(CAMERA_POS, dir, vec3(box_s.xy, WATER_HEIGHT), water_nrm);\n            //if(is_edge) data.xyz = b_nrm;\n            if(data.w < b_dist.y)\n            {\n                 if(!is_edge)data.xyz = normalize(data.xyz+terrain_bump_nrm(pos.xy));\n                 col = shade_terrain(pos, data.xyz, dir, data.w,is_edge);\n                \n                 //col = data.xyz;\n            }\n            if(water_d.x < data.w)\n            {\n\n                col += shade_water(dir, data.w, water_d.x, water_nrm);\n            }\n            vec3 ndump;\n            col += draw_fog(pos, data.w,is_edge);\n            vec2 cbox = ray_box_intersect(CAMERA_POS-vec3(0.,0.,.4), dir, vec3(box_s.xy, .1),ndump);\n            if(cbox.x < FAR)\n            {\n                vec4 cld = march_clouds(CAMERA_POS, dir+vec3(vec2(pcg2d(uvec2(fragCoord)+uint(iFrame)))/float(0xffffffffu)*.002, 0.), cbox.x+.01, min(data.w, cbox.y));\n                col = mix(col, cld.rgb, cld.w);\n                //col = vec3(1.);\n            }\n           \n            //col = vec3(cld.rgb);\n            \n        }\n    }\n    //col = vec3(cloud_dens(vec3(fragCoord/iResolution.xy*3., 1.)));\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.1)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//terrain\nconst float SCALE = .004;\nconst vec2 OFF = vec2(.1, -.2);\nconst float BLUR_AMT = .1;\n\nconst vec2 NRM_EPS = vec2(.6,0.);\nconst float NRM_SOFT = .01;\nconst int OCT = 8;\n\n\n\n\nfloat get_terrain(vec2 p)\n{\n    float data = 0.;\n    if(iFrame < 5 || is_space_down(iChannel3))\n    {\n        p/=iResolution.xy;\n        p += OFF;\n        float s = 1.;\n        float a = .5;\n        \n        for(int i = 0; i < OCT; i++)\n        {\n            data += noise((p+vec2(float(i)*7.8936345, float(i)*-13.73467))*s, iChannel0, vec2(1024), SCALE, BLUR_AMT)*a;\n            s*= 1.7;\n            a*= .5;\n        }\n       \n        data = pow(data, 3.2);\n    }\n    else\n    {\n        data = texture(iChannel1, p/iResolution.xy).w;\n    }\n    \n    return data;\n}\n\nvec3 get_nrm(vec2 uv)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(get_terrain(uv+NRM_EPS) - get_terrain(uv-NRM_EPS));\n    nrm.y = -(get_terrain(uv+NRM_EPS.yx) - get_terrain(uv-NRM_EPS.yx));\n    nrm.z = NRM_EPS.x*NRM_SOFT;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = get_terrain(fragCoord);\n    for(int i = 0; i < PARTICLE_COUNT_X; i++)\n    {\n        for(int j = 0; j < PARTICLE_COUNT_Y; j++)\n        {\n            vec4 d = texelFetch(iChannel2, ivec2(i,j), 0);\n            if(d.w == 1.)\n            {\n                f += d.z * (1.-clamp(distance(d.xy,fragCoord)/ERODE_SIZE*64.,0.,1.));\n            }\n            else f -= ERODE_AMT * (1.-clamp(distance(d.xy,fragCoord)/ERODE_SIZE,0.,1.));\n        }\n    }\n    f = clamp(f,0.,1.);\n    fragColor = vec4(get_nrm(fragCoord),f);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst int PARTICLE_COUNT_X = 40;\nconst int PARTICLE_COUNT_Y = 40;\nconst vec2 SAMPLE[] = vec2[](vec2(0,1),vec2(1,0), vec2(0,-1),vec2(-1,0),vec2(1,1),vec2(-1,1),vec2(1,-1),vec2(-1,-1));\nconst float ERODE_AMT = .00004;\nconst float PICK_AMT = .0000001;\nconst float MAX_PICK = .000001;\nconst float PART_RESET_AMT = 0.96;\nconst float RAND_AMT = .3;\nconst bool DEBUG_DRAW_PARTICLES = false;\nconst float ERODE_SIZE = 1.2;\nconst float FULL_RESET_INT = 200.;\n\nconst float WATER_HEIGHT = .03;\n\nconst vec2 WIND = vec2(.06, .1);\n\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nfloat noise(vec2 p, sampler2D s, vec2 r, float sc, float bl)\n{\n    float data = 0.;\n    for(int i = 0; i < 8; i++)\n    {\n        data+=texture(s, p*sc+SAMPLE[i]*(bl/r.x)).x/8.;\n    }\n    return data;\n}\n\n\nbool is_space_down(sampler2D key)\n{\n    return texelFetch(key, ivec2(32,0),0).x>0.;\n}", "buffer_b_code": "//particles\n\n\nconst float SAMPLE_DIST = .1;\n\n\nvec4 init(vec2 p)\n{  \n    return vec4(vec2(pcg2d(uvec2(p)+uint(iFrame)))/float(0xffffffffu)*iResolution.xy, 0.01,0.01);\n}\n\nvec2 get_vel(vec4 p)\n{\n    vec2 vel = vec2(0);\n    vel += texelFetch(iChannel1, ivec2(p.xy), 0).xy;\n    \n    vel += (vec2(pcg2d(uvec2(p.xy)+uint(iFrame)))/float(0xffffffffu)*2.-1.)*RAND_AMT;\n    \n    return vel;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0);\n    if(int(fragCoord.x)+1 < PARTICLE_COUNT_X && int(fragCoord.y)+1 < PARTICLE_COUNT_Y)\n    {\n        if(iFrame < 5 || is_space_down(iChannel2))\n        {\n           fragColor = init(fragCoord);\n        }\n        else\n        {\n           vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n           \n            \n           fragColor = o;\n           vec2 vel = get_vel(fragColor);\n           fragColor.xy += vel;\n           vec4 d = texelFetch(iChannel1, ivec2(fragColor.xy), 0);\n           float h_a_p = d.w;\n           fragColor.z += h_a_p * PICK_AMT;\n           fragColor.z = min(MAX_PICK, fragColor.z);\n           if(fragColor.w == 1.) fragColor = init(fragCoord);\n           if(length(vel) < 0.5, mod(float(iFrame), FULL_RESET_INT)==1. || dot(d.xyz, vec3(0,0,1)) > PART_RESET_AMT || h_a_p <=WATER_HEIGHT || fragColor.x < 0. || fragColor.x > iResolution.x  || fragColor.y < 0. || fragColor.y > iResolution.y)\n           {\n               fragColor.w = 1.;\n           }\n\n\n        }\n    }\n\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 695, 749, 799, 919], [921, 921, 971, 1021, 1247], [1249, 1249, 1328, 1384, 1861], [1863, 1863, 1889, 1964, 2013], [2015, 2015, 2078, 2078, 2333], [2334, 2334, 2380, 2380, 2662], [2665, 2665, 2691, 2691, 3094], [3096, 3096, 3138, 3138, 3447], [3449, 3449, 3506, 3506, 3880], [3884, 3884, 3912, 3912, 4184], [4186, 4186, 4217, 4217, 4453], [4456, 4456, 4478, 4478, 4720], [4722, 4722, 4776, 4776, 5304], [5306, 5306, 5380, 5380, 5968], [5970, 5970, 6016, 6016, 6156], [6158, 6158, 6182, 6182, 6368], [6370, 6370, 6393, 6393, 6469], [6471, 6471, 6495, 6495, 6711], [6713, 6713, 6752, 6798, 6855], [6857, 6857, 6914, 6914, 7112], [7114, 7114, 7171, 7171, 9774]], "test": "untested"}
{"id": "NsSGR1", "name": "otro templo-27-03", "author": "jorge2017a1", "description": "otro templo-27-03", "tags": ["otrotemplo2703"], "likes": 6, "viewed": 226, "published": 3, "date": "1616901950", "time_retrieved": "2024-07-30T19:30:14.035619", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n//#define MIN_DIST 0.001\n#define MIN_DIST 0.01\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n//Hexagonal Prism - exact\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nvec3 cuarto1(vec3 pp)\n{\t\n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    vec3 p=pp;\n\n    p= rotate_x(p-vec3(0.0,0.0,0.0), radians(90.0));\n    float h1= sdHexPrism( p, vec2(10.0,15.0) );\n     p=pp;\n    float tp1= sdTriPrism( p-vec3(0.0,0.0,-8.0), vec2(5.0,20.0) );\n    float b1= sdBox(p-vec3(0.0,-6.5,-8.0), vec3(4.4,5.0,20.0) );\n    float dif=differenceSDF(h1,tp1);\n    dif=differenceSDF(dif, b1);\n    res =opU3(res, vec3(dif,100.0,MATERIAL_NO)); \n    return res;\n}\n    \n\n\nvec3 cuarto2(vec3 pp)\n{\t\n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    vec3 p=pp;\n\n    float zdist=30.0;\n    p=p-vec3(0.0,0.0,zdist);\n    p= rotate_x(p, radians(90.0));\n    float h1b= sdHexPrism( p, vec2(30.0,20.0) );\n\n    p=pp;\n     p=p-vec3(0.0,0.0,zdist);\n    float tp1b= sdTriPrism( p-vec3(0.0,10.0,-8.0), vec2(8.0,40.0) );\n    \n    float b1b= sdBox(p-vec3(0.0,-2.0,-5.0), vec3(10.0,10.0,40.0) );\n    \n    float difb=differenceSDF(h1b,tp1b);\n    difb=differenceSDF(difb, b1b);\n    res =opU3(res, vec3(difb,100.0,MATERIAL_NO)); \n    \n    return res;\n}\n \n//htps://mercury.sexy/hg_sdf/\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n \n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) \n{\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    p.z= opRep1D( p.z, 90.0 );\n    \n    vec3 pp=p;\n    \n    \n\tfloat planeDist1 = p.y+12.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,101.0,-1.0)); //inf\n    \n    vec3 c1=cuarto1(p);\n    res =opU3(res, c1); \n    \n    vec3 c2=cuarto2(p);\n    res =opU3(res, c2); \n    \n    p.y=p.y+4.5;\n    p.x=abs(p.x)-15.0;\n    float sc1 =sdCylinderXZ( p-vec3(0.0), vec2(2.0,35.0) );\n    float sc2 =sdCylinderXZ( p-vec3(0.0,-7.0,0.0), vec2(3.0,0.5) );\n    float sc3 =sdCylinderXZ( p-vec3(0.0,18.0,0.0), vec2(3.0,0.5) );\n      \n    float Uc1= fOpUnionColumns(sc1, sc2,  1.8,  4.0);\n    Uc1= fOpUnionColumns(Uc1, sc3,  1.8,  4.0);\n    \n     res =opU3(res, vec3(Uc1,3.0,-1.0)); \n     \n     \n     vec3 p2=p;\n     p2.x= abs( p2.x)-20.0;\n     float box1 = sdBox(p2-vec3(0.0,-2.0,0.0), vec3(3.0,4.0,2.0) );\n     float box2 = sdBox(p2, vec3(1.0,20.0,1.0) );\n     box2= fOpUnionColumns(box2, box1, 1.8,  2.0);\n     res =opU3(res, vec3(box2,6.0,-1.0)); \n  \n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n       for(int i=0; i <= MAX_STEPS; i++) \n    //for(int i=0; i<MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        /*\n        if ( abs(dS.x)<MIN_DIST)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n       */\n        //if ( abs(dS.x)<MIN_DIST || i == MAX_STEPS-1)\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n         \n        \n        if(dO>MAX_DIST)\n        //{ mObj.hitbln = false; minDist = min(minDist, dO);break; }\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,-2.0,-25.0+t);\n     vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;  mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n        /*\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n        */\n        \n         //sugerencia por ocb,\n        col = pow(col, vec3(1.0/2.2));\n        col = mix(col, getSkyColA(rd), min(1.,.01*d));   // fading with sky color depending on the distance\n\n\n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.1415926\n#define pi 3.141592\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return ( mat3(tx*tx, ty*ty, tz*tz)*n); \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[591, 591, 627, 627, 648], [649, 649, 681, 681, 765], [766, 766, 805, 805, 900], [901, 901, 940, 940, 1035], [1036, 1036, 1075, 1075, 1170], [1200, 1200, 1236, 1236, 1509], [1511, 1555, 1602, 1602, 1629], [1631, 1631, 1674, 1674, 1701], [1703, 1703, 1751, 1751, 1779], [1780, 1864, 1900, 1900, 1945], [1951, 2016, 2050, 2050, 2148], [2149, 2149, 2183, 2183, 2275], [2276, 2276, 2310, 2310, 2402], [2403, 2443, 2477, 2477, 2574], [2577, 2577, 2613, 2613, 2696], [2699, 2699, 2722, 2722, 3169], [3177, 3177, 3200, 3200, 3738], [3741, 3807, 3832, 3832, 3872], [3874, 4018, 4058, 4058, 4179], [4182, 4256, 4316, 4316, 4934], [4937, 4977, 5002, 5002, 6053], [6057, 6057, 6122, 6122, 6706], [6708, 6759, 6783, 6783, 6971], [6973, 6973, 7006, 7006, 8005], [8007, 8061, 8097, 8097, 8331], [8332, 8387, 8436, 8436, 8689], [8690, 8724, 8804, 8804, 9081], [9124, 9175, 9222, 9222, 10009], [10063, 10063, 10156, 10156, 10583], [10585, 10585, 10612, 10612, 10722], [10724, 10773, 10830, 10830, 12413]], "test": "untested"}
{"id": "fdB3zh", "name": "Random procedural textures 4", "author": "jarble", "description": "This fractal formula makes many interesting tiled patterns, or procedural textures.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 283, "published": 3, "date": "1616899470", "time_retrieved": "2024-07-30T19:30:14.804563", "image_code": "\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07);\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = .5;\n    float scale = 1.1;\n    //float scale2 = .25;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    float scale2 = h1.z+.5;\n    vec2 uv1 = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv1 += vec2(iTime/2.0,iTime/3.0)/t1/8.0; \n    vec2 uv = uv1; \n    for(int c=0;c<6;c++){\n        uv = triangle_wave(uv,scale,h1);\n        uv.yx = triangle_wave(uv+col.xy,scale,h1);\n        //offset /= scale2;\n        uv.x /= -1.0;\n        col[c] = fract((uv.x)-(uv.y));\n        col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 348, 371, 371, 456], [458, 568, 590, 590, 723], [727, 727, 774, 774, 830], [832, 832, 889, 889, 1484]], "test": "untested"}
{"id": "MdXyzB", "name": "sandstorm cube - [poc]", "author": "patu", "description": "POC for \"sandstorm cube\" from Phobos PC 8k intro.  https://youtu.be/_iyo6pT3ZVU?t=2159 2017\n#makeYourShadersPublic\n\n", "tags": ["cube", "demoscene", "sandstorm", "phobos"], "likes": 21, "viewed": 670, "published": 3, "date": "1616887901", "time_retrieved": "2024-07-30T19:30:15.755022", "image_code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 100.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.0, 1.0, 1.)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat tri( in vec2 p )\n{\n    return 0.2*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\n\nfloat cloud (in vec2 p) {\n    \n    p *= 2.507;\n    p.y -= 0.5 * iTime;\n    float s = 1.0;\n\tfloat t = 0.0;\n    \n\tfor( int i=0; i< 3; i++ )\n\t{\n        t += s * tri( p );\n\t\ts *= 0.15 + .9 * t;\n        p = 1.9317 * m2 * p + (t - 0.5 ) * .1;// + sin(iTime / 14.);\n\t}\n    \n    return pow(t + .4, 2.2);\n}\nfloat spherical_texturing(in vec3 normal, float delta) {\n     float u = atan(normal.z, normal.x) / PI * 2.0 + delta;\n\t float v = asin(normal.y) / PI * 2.0;\n     return cloud(vec2(u, v));\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\n\n\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\nvec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = texture(t, p.yz);\n\tvec4 y = texture(t, p.zx);\n\tvec4 z = texture(t, p.xy);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec2 mpi(vec2 p) {\n\tp = mod(p, 2.);\n    if (p.x > 1.) p.x = 2. - p.x;\n    if (p.y > 1.) p.y = 2. - p.y;\n    \n    return p ;//+ sin( p.y - p.x) * .1;\n}\nvec2 pixel = vec2(0.);\n\nfloat noi(vec3 p) {\n \tfloat noise = \n        2. * textureLod(iChannel0, mpi(-vec2(p.yx * 0.3) - vec2(t * 1.2, 1.2)), 4.).r;\n       // texture(iChannel0, pixel + mpi(-vec2(p.yx * 0.25) - vec2(t * 1.2, 1.2))).r;\n    \n    noise *= \n        textureLod(iChannel0, mpi(-vec2(p.xz * .02) - vec2(-t * .4, 9.)), 4.).r;\n        \n    \n    noise -= textureLod(iChannel0, mpi(vec2((noise), p.xy * .1)),4.).r * 2.;\n      \n    \n    return noise;\n}\n\ngeometry map(vec3 p) {\n    \n    vec3 bp = p;\n    \n    geometry obj2, obj, cap;\n    \n    p = bp;\n    \n\tfloat noise = noi(p);\n    \n\tcap.dist = length(p.zy) - 1.4 - noise; \n    \n    cap.material = vec2(2., 0.);\n    cap.space = p;\n\n    obj.material = vec2(2., 0.);\n    bp.y += 3.;// + noise *.1;\n    bp.y += texture(iChannel0, mpi(p.xz * 0.9 + vec2(0., t * 3.))).r * 0.1;\n    \n    obj.dist = fBox2Cheap(bp.xy, vec2(10., 1.));\n    obj.space = p;\n    \n    bp += vec3(0., 0., +16.);\n    \n    bp.y -= 6.;\n    pR(bp.xy, t);   \n    pR(bp.xz, t);\n    \n\n    obj2.dist = fBox(bp, vec3(9.) + sin(t * .5) * 2.);\n    obj2.material = vec2(3., 0.);\n    \n    geometry obj3 = obj2;\n    \n    obj2.dist += abs(noise * .5);\n    \n    //if (obj.dist > 18.) return obj2;\n    \n    cap.dist = smin(obj2.dist, cap.dist, .15 + noise * .01);\n    \n    obj2.dist -= 1.;\n    \n    p.z -= 6.;\n    p.x -= 2.;\n    p.y += 1.5 + sin(t) * noi(p.zyx / 90.) * 4.2;\n    \n   \n    return geoU(geoU(obj, cap), obj3);\n}\n\n\nfloat t_min = 0.1;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 100.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        //minDist = min(minDist, mp.dist * 3.);\n        //if (i < 116) mp.glow = pow(1. / minDist, 1.8);\n        \n        //glow = pow( 1. / minDist, 0.8);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .4;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 12;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = .5;\n    float dist = 1.;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.8, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = .4;\n   float sunAmount = max(dot(rd, lightDir), .4);\n   float v = pow(1.2 - max(rd.y, 0.0), 3.);\n   vec3 sky = mix(fromRGB(255,136,154), vec3(1., .5, .3) * 1., v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 111.0)* sunSize, 1. * sunSize);\n   \n    //if (showSun) sky += texture(iChannel0, vec2(v, rd.x) * 4.).rgb / 4.;\n   //if (showSun) sky -= fract(v /  4.) * vec3(0.3, 0.2, 0.1) ;//- noise(rd.xy * 100.);\n   return clamp(sky, 0.0, 1.0);\n}\n\nvec4 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec4 col = vec4(.0);\n    col.rgb = vec3(1., .6, 0.4) * 4.;\n    \n    if (obj.material.x == 1.0) { \n        col /= 9.;\n        col += pow(texture(iChannel0, mpi(p.xz / 3. + vec2(0, t * 2.))).rrrr * 3., vec4(.4));///col.a = .5;\n    };    \n        \n    if (obj.material.x == 3.0) {\n        col += 10.;  \n    }\n\n    return col;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir ) {  // camera to point vector\n    \n    float c = .3;\n    float b = .3;\n\n    float fogAmount = c * exp(-rayOri.y * b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    \n    vec3  fogColor  = vec3(1., .6, .3);//Sky(rayDir, false, normalize(light)) * 1.;//\n    \n    return mix( rgb, fogColor, min(1.2, fogAmount) );\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec4 sceneCol = vec4(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 1.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 0.1);\n\n\n    vec4 objCol = getObjectColor(sp, sn, obj);\n\t  \n\n    sceneCol.rgb += (objCol.rgb * (diff + .15) * spec  * .1);\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    vol = 1.;//length(texture(iChannel0, vec2(.42, .25)).rgb);\n    \n    pixel = 1./iResolution.xy;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    //uv.y *= 1.2;\n    //vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .4) * 166.0, \n        ck = cos(-t2 * .4) * 162.0,\n        \n        mat = 0.;\n    \n    //uv.x *= 1. + abs(cos(uv.y)) / 2.; // fisheye\n    \n    light = vec3(10., 20., -10.);        \n    lightDir = light;\n    \n    //uv += length(uv)/4.;//pow(uv, vec2(1.));\n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(0., -1., 10.);// + vec3(iMouse.x / 2. - 100.,iMouse.y / 2. - 100., 10.); // pos\n    \n    vec3\n        vrp =  vec3(0., 1.4, 0.) , // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        object;        \n\t\n    vec3 sceneColor = vec3(0.);\n    \n    vec3 lp = light;\n\tlightDir = lp;\n    \n    geometry tr = trace(ro, rd);\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist / 6.);\n    tr.hit = ro + rd * tr.dist;\n    \n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, ro + light, 2.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn, 1.6);\t\n\n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n    \n\n    float alpha = 0.;\n    if (tr.dist < FAR) { \n        \n        vec4 col = doColor(tr.hit, rd, tr.sn, light, tr) * 1.;\n        //alpha = pow(tr.dist / FAR * 3.6, 6.);\n        sceneColor = col.rgb;\n        \n        sceneColor *= ao; \n        sceneColor *= sh;\n        \n               \n        sceneColor *= 1. + length(\n            max(0.,\n                1. * max(\n                    0.,\n                    length(normalize(light.xy) * max(vec2(0.), tr.sn.xy))\n                )\n             * 3.\n        ));\n        sceneColor = mix(sceneColor, skyNoSun, (1. - fog) * .6);  \n        sceneColor = mix(sceneColor, skyNoSun, saturate(tr.dist * 1.1 / FAR));\n    } else {\n        sceneColor = sky;\n    \ttr.dist = FAR;\n    }\n    \n    sceneColor = applyFog(sceneColor, tr.dist, ro, rd) + 0.1 * texture(iChannel0,mpi(tr.hit.xy * .2)).r;\n   \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), alpha);\n    fragColor = pow(fragColor, vec4(1.4));\n\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 70.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(\n        fbm(vec3(uv.y + 32. + uv.xy * 1.1, 0))// -\n        //fbm(vec3(uv.y + 32. + uv.xy * 13.5, 0))\n        ,\n        0,\n        0,\n        1.\n    );\n    \n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 275, 275, 332], [443, 443, 466, 466, 495], [496, 496, 519, 519, 548], [549, 549, 574, 574, 603], [646, 646, 670, 670, 724], [726, 726, 751, 751, 1023], [1024, 1024, 1080, 1080, 1212], [1214, 1214, 1244, 1244, 1273], [1275, 1372, 1445, 1445, 1731], [1734, 1734, 1754, 1754, 1840], [1842, 1842, 1862, 1862, 1960], [1963, 1963, 1995, 1995, 2037], [2039, 2039, 2073, 2073, 2118], [2120, 2120, 2151, 2151, 2200], [2338, 2338, 2379, 2379, 2434], [2436, 2436, 2477, 2477, 2532], [2534, 2534, 2565, 2565, 2617], [2619, 2619, 2650, 2650, 2697], [2699, 2739, 2759, 2759, 2784], [2786, 2786, 2806, 2806, 2841], [2843, 2843, 2863, 2863, 2908], [2910, 2949, 2969, 2969, 2994], [2996, 2996, 3014, 3014, 3064], [3066, 3150, 3194, 3194, 3297], [3299, 3371, 3420, 3420, 3457], [3460, 3604, 3644, 3644, 3765], [3768, 3796, 3833, 3833, 3924], [3926, 3962, 3990, 3990, 4071], [4073, 4130, 4164, 4164, 4190], [4194, 4194, 4234, 4234, 4315], [4316, 4316, 4348, 4348, 4373], [4375, 4375, 4408, 4408, 4564], [4566, 4566, 4624, 4624, 4806], [4808, 4808, 4826, 4826, 4958], [4983, 4983, 5002, 5002, 5415], [5417, 5417, 5439, 5439, 6388], [6462, 6462, 6494, 6494, 7898], [7901, 7901, 7946, 7946, 8522], [8546, 8546, 8575, 8575, 8819], [8821, 8821, 8870, 8870, 8986], [8988, 8988, 9039, 9039, 9584], [9586, 9586, 9637, 9637, 9966], [9968, 9968, 10182, 10209, 10494], [10496, 10496, 10573, 10573, 11223], [11225, 11225, 11280, 11342, 13872]], "test": "untested"}
{"id": "ssj3zz", "name": "Fractal impressionism", "author": "jarble", "description": "These fractal patterns reminds me of impressionist landscape paintings.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 337, "published": 3, "date": "1616880800", "time_retrieved": "2024-07-30T19:30:16.524963", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .17;\n    float scale2 = offset;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            \n            \n            \n            uv.y /= -1.0;\n            uv = uv.yx;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3zz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [747, 747, 794, 794, 850], [852, 852, 909, 909, 1710]], "test": "untested"}
{"id": "fds3Wl", "name": "Rainbow tie-dye", "author": "jarble", "description": "This fractal pattern has many overlapping and blended colors.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 6, "viewed": 290, "published": 3, "date": "1616879644", "time_retrieved": "2024-07-30T19:30:17.297897", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.2;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [747, 747, 794, 794, 850], [852, 852, 909, 909, 1644]], "test": "untested"}
{"id": "fs23Rz", "name": "Among the dunes", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nThis started out as a fork of https://www.shadertoy.com/view/WstGDs, my froge shader\nThen I started messing around with perlin noise from https://www.shadertoy.com/view/tdtGR8", "tags": ["raymarching", "sdf", "loading", "dunes", "willstall"], "likes": 7, "viewed": 417, "published": 3, "date": "1616853873", "time_retrieved": "2024-07-30T19:30:18.068836", "image_code": "const int aa = 2;\nconst float maxDist = 100.0;\nconst vec3 lightDirection = normalize(vec3(.5,.5, .2));\nconst vec3 blobOffset = vec3(.0, .0, -.4);\n\nfloat getHeightMapValue(vec2 point)\n{\n    point*=.04;\n    vec2 st = (point+141.15) * .8;\n    \n    st.x -= iTime*.2;\n    point.y += iTime*.24;\n    \n    float perlin1 = getPerlin(point);\n    float perlin2 = getPerlin(st);\n    return mix(perlin1, perlin2, .5)*20.0;\n}\n\nfloat mapSpheres(vec3 point)\n{\n    sphere s1 = sphere(blobOffset + vec3(.0, .1, .0), .07);\n    sphere s2 = sphere(blobOffset + vec3(cos(iTime)*.1, sin(iTime)*.1, .1), .1);\n    sphere s3 = sphere(blobOffset + vec3(.1,.1, .1), .05);\n    float d = smin(sphDist(point, s1), sphDist(point,s2), .2);\n    d = smin(d, sphDist(point, s3), .15);\n   \n    return d;\n}\n\nsdfRet map(vec3 point)\n{\n    float d1 = mapSpheres(point);\n    \n    //heightmapped plane\n    float d2 = point.y+1.2 + getHeightMapValue(point.xz);\n    \n    if(d1 < d2)\n    {\n        return sdfRet(d1,.0);\n    } else \n    {\n        return sdfRet(d2, 1.0);\n    }\n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*CLOSE_ENOUGH).sdf + \n                      k.yyx*map( p + k.yyx*CLOSE_ENOUGH).sdf + \n                      k.yxy*map( p + k.yxy*CLOSE_ENOUGH).sdf + \n                      k.xxx*map( p + k.xxx*CLOSE_ENOUGH).sdf );\n}\n\nvec3 lighting(vec3 point)\n{\n\tdirLight sun = dirLight(lightDirection, 1.0, vec3(1.0,.9,.8),.02);\n    \n    vec3 normal = calcNormal(point);\n    \n    return diffuse(normal,sun);\n}\n\nvec3 goochShading(vec3 point, vec3 viewDirection)\n{\n    const vec3 surface = vec3(1.0, 1.0, 1.0);\n    const vec3 warm = vec3(1.0, .1, .0) + .25 *surface;\n    const vec3 cold = vec3(.0, .1, .55) + .25*surface;\n    const vec3 highlight = vec3(1.0);\n    \n    vec3 normal = calcNormal(point);\n    const vec3 upDirection = vec3(.0, -1.0, .0);\n    \n    float lambert = dot(normal, upDirection);\n    float t = (lambert+1.0) * .5;\n    vec3 r = 2.0*lambert*normal - upDirection;\n    float s = max(min(100.0*dot(r, viewDirection)-97.0, .0), 1.0);\n    \n    return mix(highlight, mix(warm, cold, t), s);\n}\n\nray getCurrentRay(vec2 uv)\n{\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + vec3(.0,.2,1.5);\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return ray(rayOrigin, rayDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 total = vec3(.0);\n    //MSAA\n    for(int i = 0; i <aa;i++)\n    for(int j = 0; j <aa;j++)\n    {\n    \t//offset the uv for MSAA\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n    \tuv.x *= iResolution.x/iResolution.y;\n    \t\n    \tray currentRay = getCurrentRay(uv);\n    \t\n        //sky color\n    \tvec3 col = vec3(.2,.4,.9)-vec3(.4,.4,.9)*currentRay.direction.y;\n    \t\n        //raymarching\n    \tfloat dist = .0;\n    \tfor(int i = 0; i < 200; i++)\n    \t{\n            //point at which we'll sample distances\n    \t\tvec3 rayPoint = currentRay.origin + currentRay.direction *dist;\n    \t    \n            //sampling of distances\n            sdfRet ret = map(rayPoint);\n            \n            //smaller than our epsilon : hit!\n    \t    if(ret.sdf < CLOSE_ENOUGH)\n    \t    {\n                if(ret.id > .5) col = lighting(rayPoint)*vec3(.9568,0.8862,0.776); \n                else col = goochShading(rayPoint, currentRay.direction);\n    \t        \n                col += fog(dist);\n    \t        break;\n    \t    }\n    \t    if(dist > maxDist) break;\n    \t    dist += ret.sdf;\n    \t}\n     \n    \ttotal += col;\n    }\n    total /= float(aa*aa);\n    \n    // Output to screen\n    fragColor = vec4(pow(total,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "#define CLOSE_ENOUGH .01\n\n// ----structs----\n\nstruct sdfRet\n{\n\tfloat sdf;\n    float id;\n};\n    \nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n  \nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct dirLight\n{\n\tvec3 direction;\n    float intensity;\n    vec3 color;\n    float ambient;\n};\n\n\n// ----distance functions----\n\n//all from iq : https://iquilezles.org/articles/distfunctions\n\nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ----lighting----\n\nvec3 fog(float dist)\n{\n    return vec3(.05) * min(exp(dist*.3-20.0), 1.0);\n}\n\nvec3 diffuse(vec3 normal, dirLight l)\n{\n\treturn max(dot(normal, l.direction)*l.intensity, l.ambient)*l.color;\n}\n\n// ----noise----\n\nvec2 pseudorandPos(vec2 randseed)\n{\n    return abs(cos(fract(randseed * dot(sin(randseed * 242.589), vec2(42.4391588, 3.91711988))) * 294419.4857));\n}\n\nvec2 getGradient(vec2 coord)\n{\n\treturn 2. * normalize(pseudorandPos(floor(coord))) - 1.0;\n}\n\n//from : https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds%20/perlin-noise-part-2?url=procedural-generation-virtual-worlds%20/perlin-noise-part-2\nfloat smoothFloat(float t)\n{\n\treturn t * t * (3. - 2. * t);\n}\n\n//from : https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds%20/perlin-noise-part-2?url=procedural-generation-virtual-worlds%20/perlin-noise-part-2\nfloat getPerlin(vec2 coord)\n{\n\tint xi0 = int(floor(coord.x)); \n \tint yi0 = int(floor(coord.y)); \n \tint xi1 = xi0 + 1; \n \tint yi1 = yi0 + 1;\n \tfloat tx = coord.x - floor(coord.x); \n \tfloat ty = coord.y - floor(coord.y); \t\n \tfloat u = smoothFloat(tx);\n \tfloat v = smoothFloat(ty);\n \t// gradients at the corner of the cell\n \tvec2 c00 = getGradient(vec2(xi0, yi0));\n \tvec2 c10 = getGradient(vec2(xi1, yi0)); \n \tvec2 c01 = getGradient(vec2(xi0, yi1)); \n \tvec2 c11 = getGradient(vec2(xi1, yi1));\n \t// generate vectors going from the grid points to p\n \tfloat x0 = tx, x1 = tx - 1.;\n \tfloat y0 = ty, y1 = ty - 1.;\n \tvec2 p00 = vec2(x0, y0); \n \tvec2 p10 = vec2(x1, y0); \n \tvec2 p01 = vec2(x0, y1); \n \tvec2 p11 = vec2(x1, y1);\t\n \t// linear interpolation\n \tfloat a = mix(dot(c00, p00), dot(c10, p10), u); \n \tfloat b = mix(dot(c01, p01), dot(c11, p11), u);\n \treturn abs(mix(a, b, v)); // g \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 184, 184, 411], [413, 413, 443, 443, 768], [770, 770, 794, 794, 1031], [1033, 1086, 1116, 1116, 1405], [1407, 1407, 1434, 1434, 1583], [1585, 1585, 1636, 1636, 2178], [2180, 2180, 2208, 2234, 2561], [2563, 2563, 2620, 2620, 3884]], "test": "untested"}
{"id": "Ns23zR", "name": "tripole 2", "author": "FabriceNeyret2", "description": "dots emit 1,J,J fields, figured as R,G,B  ( green is mouse controlled ), resulting in a tripolar field.\n( it quickly decrease as grey with distance )\n\n( Not totally unrelated to chromodynamics ;-) : hadrons = R+G+B tripoles, mesons = C + antiC dipoles ).", "tags": ["dipole", "tripole", "quarks", "chromodynamics", "hadron"], "likes": 9, "viewed": 326, "published": 3, "date": "1616848877", "time_retrieved": "2024-07-30T19:30:18.926542", "image_code": "// variant of dipole  https://shadertoy.com/view/Nsj3zR\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = ( 2.*iMouse.xy  - R ) / R.y,\n        J0 = vec2(  1.,  0. ),\n        J1 = vec2( -.5,  sqrt(3.)/2. ),\n        J2 = vec2( -.5, -sqrt(3.)/2. ),\n\n#define F(P)  1./dot(P-U,P-U)     \n\n    F =  F(vec2(0,.3))*J0 + F(M)*J1 + F(vec2(0,-.3))*J2 ;\n    O = .5+.5* vec4( dot(F,J0), dot(F,J1),  dot(F,J2), 0);\n    \n    O =  max( max( O, F(M)/R.y ),  max( F(vec2(0,.3)) , F(vec2(0,-.3)) ) /R.y );\n\n/* // --- equivalent:\n    mat3x2 J = mat3x2(J0,J1,J2);\n    vec3 f = vec3( F(vec2(0,.3)), F(M), F(vec2(0,-.3)) );\n    F =  J * f;\n    O = .5+.5* vec4( F * J, 0);\n    f /= R.y;\n    O =  max( max( O, f.y ),  max( f.x , f.z ) );\n*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Nd23zR", "name": "mana!", "author": "DEMERCY", "description": "make some difference with voronoi pattern", "tags": ["2d", "voronoipattern"], "likes": 0, "viewed": 232, "published": 3, "date": "1616848669", "time_retrieved": "2024-07-30T19:30:19.702468", "image_code": "vec2 N22(vec2 p ){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+= dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\nfloat remap(float a1,float a2,float b1,float b2,float v){\n    return abs(a1-v/(a2-v))*b1+abs(a2-v/(a1-v))*b2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     uv *= 5.;\n    float m = 0.;\n    float t = iTime*2.;\n   \n    float minDist =3.;\n    vec3 col = vec3(0);\n    \n        \n    int stage = 5;\n    for(int i = stage;i>0;i--){\n        uv = uv*1.2+t*.2;\n        vec2 gv = fract(uv) -.5;\n        vec2 id = floor(uv);\n        vec3 c = vec3(0);\n    \n        for(int y = -1;y<= 1;y++){\n            for(int x = -1;x<= 1;x++){\n                vec2 offs = vec2(x,y);\n            \n                vec2 n =  N22(id + offs+float(i));\n                vec2 p = offs + sin(n*t)*.5;\n                float d = length(gv-p);\n    \n                if(minDist > d){\n                    minDist = d;\n                }\n            }\n        }\n        c= vec3(1.5*remap(0.,1.,0.7,0.,minDist),1.*remap(0.,1.,0.3,0.,minDist),1.4*minDist);\n        col = mix(col,c,.1);\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 140], [141, 141, 198, 198, 252], [254, 254, 311, 311, 1202]], "test": "untested"}
{"id": "Nsj3zR", "name": "dipole 2", "author": "FabriceNeyret2", "description": "center dot emit + field and mouse dot emit - field, both resulting in a dipolar field.\n( at distance, it decreases as 2 dot( axis, d ) / d  with d the distance vector. ) ", "tags": ["dipole"], "likes": 5, "viewed": 279, "published": 3, "date": "1616848428", "time_retrieved": "2024-07-30T19:30:20.473407", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = ( 2.*iMouse.xy  - R ) / R.y;\n\n#define F(P)  1./dot(P-U,P-U)     \n\n    O = ( F() - F(M) ) *vec4(-1,1,0,0 );\n    O =  max(O, max( F() , F(M) ) /R.y );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsj3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 264]], "test": "untested"}
{"id": "fd23zR", "name": "Hypnosis (polar c.s.)", "author": "Paws22", "description": "My friend made me do it.", "tags": ["polar", "hypno"], "likes": 3, "viewed": 308, "published": 3, "date": "1616848424", "time_retrieved": "2024-07-30T19:30:21.240356", "image_code": "float dist( vec2 pol )\n{\n    pol.x = fract(pol.x);\n    if (pol.x >= pol.y)\n    {\n        pol.y += 0.5;\n        return abs(pol.x - pol.y);\n    }\n    else\n    {\n        pol.y -= 0.5;\n        return abs(pol.x - pol.y);\n    }\n}\n\nmat2 _rot(float th)\n{\n\tvec2 a = sin(vec2(1.5707963, 0) + th);\n\treturn mat2(a.xy, -a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    mat2 rot = _rot(-iTime * 10.0);\n    \n    uv *= 2.0;\n    uv *= rot;\n    \n    float rad = acos(dot(normalize(uv), vec2(1.0, 0.0)));\n    \n    float angle = degrees(rad) / 360.0;\n    if (uv.y < 0.0)\n        angle = 1.0 - angle;\n    \n    float l = length(uv);\n    \n    vec2 polar = vec2(l, angle);\n    \n    polar.x *= 2.0;\n    \n    float d = dist(polar);\n    \n    vec3 col = vec3(sign(d - 0.3));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd23zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 223], [225, 225, 246, 246, 319], [321, 321, 378, 378, 883]], "test": "untested"}
{"id": "Ndj3zR", "name": "Sphere UV seam with mipmap filte", "author": "soadzoor", "description": "Description of the problem: There's a slight vertical seam on the sphere when I'm using mipmap filtering, not present when I'm using linear filtering.\nAs per mla's comment: \"mipmap level selection using a screenspace derivative with a discontinuity\"", "tags": ["raycasting"], "likes": 3, "viewed": 329, "published": 3, "date": "1616847095", "time_retrieved": "2024-07-30T19:30:22.011294", "image_code": "#define PI 3.14159265359\n#define SOLVE_PROBLEM false\n\nfloat intersectSphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    vec3 ro = vec3(-2.0, 0.0, 0.5);\n    vec3 rt = vec3(0.0, 0.0, 0.0);\n    mat3 cam = setCamera(ro, rt, 0.35);\n    vec3 rd = normalize(cam * vec3(p, -1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float fragCoordToMouse = iMouse.x - fragCoord.x;\n    bool solveProblem = fragCoordToMouse > 0.0;\n    \n    if (abs(fragCoordToMouse) < 1.0)\n    {\n        col = vec3(1.0);\n    }\n    else\n    {\n        float t = intersectSphere(ro, rd, vec3(0.0), 1.0);\n\n        vec3 hitPoint = ro + rd * t;\n\n\n        if (t > 0.0)\n        {\n            vec2 sphereUV = vec2(\n                0.5 + atan(hitPoint.z, hitPoint.x) / (2.0 * PI),\n                0.5 - asin(hitPoint.y) / PI\n            );\n\n            // Solution found here, thanks!: https://www.shadertoy.com/view/3dVSzm\n            if (solveProblem)\n            {\n                // trick from Fabrice to avoid the discontinuity at Greenwich.\n                vec2 df = fwidth(sphereUV);\n                if(df.x > 0.5)\n                {\n                    df.x = 0.0;\n                }\n\n                col = textureLod(iChannel0, sphereUV, log2(max(df.x, df.y)*1024.)).xyz;\n            }\n            else\n            {\n                col = texture(iChannel0, sphereUV).rgb;\n            }\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 124, 124, 325], [327, 327, 382, 382, 560], [562, 562, 619, 669, 2046]], "test": "untested"}
{"id": "7df3Dl", "name": "Conics through Five Elements", "author": "mla", "description": "As nice a bit of maths as you are likely to see today: drawing conic sections through three points and tangent to two lines (or through two points and tangent to three lines).", "tags": ["conic", "projective"], "likes": 9, "viewed": 392, "published": 3, "date": "1616843988", "time_retrieved": "2024-07-30T19:30:23.003641", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conics through 3 points and 2 lines. mla, 2021\n//\n// A conic through three given points and tangent to two given lines,\n// must satisfy a quartic equation, and thus there are four solutions\n// (taking due account of multiple roots), though the points of tangency\n// may not be real. A lovely geometric solution is given by Heinrich\n// Drrie in 100 Great Problems of Elementary Mathematics, making use\n// of Desargues' Involution Theorem (though Apollonius had a thing or\n// two to say about all this as well).\n//\n// https://archive.org/details/100GreatProblemsOfElementaryMathematicsDoverHeinrichDrrie/page/n281/\n//\n// The white conics pass through the three red points and are tangent to\n// the green lines, the blue conics are tangent to the three red lines\n// (dual to the red points) and pass through the green points (dual to\n// the green lines).\n//\n// In the default configuration (see code), one of the green lines is\n// the line at infinity, so cannot be seen and the white conics are all\n// parabolas, with the dual blue conics all appearing as ellipses (I'll\n// leave why that is so as a puzzle).\n//\n// The mouse sets the position of the green line. For some positions there is\n// no (real) solution for the conic - I'll leave the criteria for that as\n// another puzzle.\n//\n// A nice video from CodeParade on all this & more:\n// https://www.youtube.com/watch?v=X83vac2uTUs who has some nice code here\n// (this shader uses a similar solution but was developed independently):\n// https://github.com/HackerPoet/Conics\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\nint configuration = 2;\n\nfloat lwidth = 0.015;\nfloat pwidth = 0.05;\nconst float scale = 2.5;\n\nconst vec3 background = vec3(0);//vec3(1,1,0.5);\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = pcolor2;\nconst vec3 ccolor0 = 0.8*vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate (what about adjugate?).\n\n// The triangle of reference (ToR subsequently) is the three\n// points with homogeneous coordinates (1,0,0),(0,1,0),(0,0,1)\n// The ToR is mapped to any three points p,q,r by the matrix\n// mat3(p,q,r) (with the usual glsl column major convention) and\n// so the inverse matrix maps p,q,r to the ToR, and we can solve\n// many problems more easily by first mapping selected points to\n// the ToR, solving a simpler problem, and mapping back at the end.\n//\n// A conic through the ToR is represent by a matrix with the form\n//\n// C = mat3(0,d,e,\n//          d,0,f,\n//          e,f,0)\n//\n// which represents the conic with equation:\n//\n// dxy + ezx + fyz = 0\n//\n// and this can be thought of as a constraint on d,e,f for it to\n// pass through the point (x,y,z)\n//\n// The inverse of C gives the line equation form of the conic,\n// ie. vec3(l,m,n)*inverse(C)*vec3(l,m,n) = 0 just when the line\n// (l,m,n) is tangent to the conic.\n//\n// For a conic through the ToR, the requirement that the conic is\n// tangent to a line (l,m,n) simplifies to:\n//\n// 4mnef = (me+nf-ld),\n//\n// a quadratic constraint, so there will be 0,1, or 2 ways it can\n// be satisfied in general. This constraint may be simplified if,\n// for example, the line passes through a vertex of the ToR, in which\n// case one of l,m,n are zero and the constraint becomes linear (if\n// two are zero, then the line is a side of the ToR and the problem\n// becomes even simpler).\n//\n// The most difficult situation is for three points and two general\n// lines (or dually, three lines and two points), with two quadratic\n// constraints, giving rise to a quartic equation.\n//\n// In this case, there is a simpler way to proceed using the\n// Desargues Involution Theorem, for details see Drrie, but\n// briefly, the two tangent lines meet the conic at two points,\n// with the tangent chord between, and the sides of the ToR meet\n// the tangent chord at the fixpoints of a certain involution of\n// the line (an involution is a self-inverse projective\n// transformation, with t mapping to t' with tt' + b(t+t') + d = 0),\n// the involution on BC, for example, takes (0,1,0) to (0,0,1) and\n// (0,-n,m) to (0,-N,M) where (l,m,n) and (L,M,N) are the two lines.\n// In fact, for our involutions, b = 0 and d = mM/nN for BC\n// with the fixpoint being (0,1,sqrt(d)) (with no solution if d < 0)\n// and similarly on AC (it's easy to see there are either 3 real\n// fixpoints or 1, so we only need to calculate for two lines).\n\nmat3 pointconic(vec3 p, vec3 P) {\n  // Construct matrix for conic through vertices of ToR\n  // (so diagonal is zero) and through p and P\n  //float x = p[0], y = p[1], z = p[2];\n  //float X = P[0], Y = P[1], Z = P[2];\n  // Solve the homogeneous linear system\n  // dxy+exz+fyz = 0\n  // dXY+eXZ+fYZ = 0\n  // This is just the intersection of two lines, so:\n  vec3 l0 = p.xzy*p.yxz; //vec3(x*y,z*x,y*z);\n  vec3 l1 = P.xzy*P.yxz; //vec3(X*Y,Z*X,Y*Z);\n  vec3 def = cross(l0,l1);\n  float d = def[0], e = def[1], f = def[2];\n  return mat3(0,d,e,\n              d,0,f,\n              e,f,0);\n}\n\nbool lineconicparams(out vec2 res, vec3 a, vec3 A) {\n  float l = a[0], m = a[1], n = a[2];\n  float L = A[0], M = A[1], N = A[2];\n  float lL = l*L, mM = m*M, nN = n*N;\n  // sqrt(d) and sqrt(D) are fixpoints of the involutions\n  // as described above.\n  if (lL == 0.0 || mM == 0.0 || nN == 0.0) return false;\n  float d = mM/nN;\n  if (d < 0.0) return false;\n  float D = nN/lL;\n  if (D < 0.0) return false;\n  res = vec2(sqrt(d),sqrt(D));\n  return true;\n}\n\nmat3 cofactor(mat3 m) {\n  // Cofactor matrix of m, ie. the transpose of the adjugate\n  // (determinant is dot(m[0],cross(m[1],m[2])) and matrix\n  // multiplication is dot products of rows and columns)\n  return mat3(cross(m[1],m[2]),\n              cross(m[2],m[0]),\n              cross(m[0],m[1]));\n}\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = iTime;\n  p.y -= 0.1;\n  p.xy = rotate(p.xy,0.2*t);\n  p.y += 0.1;\n  if (false) p.yz = rotate(p.yz,0.1618*t);\n  return p;\n}\n\nfloat dwidth;\n\nfloat pointdist(vec3 p, vec3 q) {\n  if (p.z == 0.0 || q.z == 0.0) return 1.0;\n  p /= p.z; q /= q.z; // Normalize\n  return smoothstep(0.75*pwidth,max(pwidth,0.75*pwidth+dwidth),distance(p,q));\n}\n\nfloat conicdist(vec3 p, mat3 m) {\n  float d = dot(p,m*p);\n  vec3 dd = 2.0*m*p;\n  d = abs(d/(p.z*length(dd.xy))); // Normalize for Euclidean distance\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nfloat linedist(vec3 p, vec3 l) {\n  float k = p.z*length(l.xy);\n  if (k == 0.0) return 1.0;\n  float d = abs(dot(p,l)/k);\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,1.0-level);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 pos = map(fragCoord.xy);\n  dwidth = fwidth(pos.x/pos.z);\n\n  vec3 p0,p1,p2,l0,L0;\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0); p2 = vec3(0,0,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.4,0.5,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1); p2 = vec3(0,1,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.5,0.5,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,1,1); p1 = vec3(0.866,-0.5,1); p2 = vec3(-0.866,-0.5,1);\n    l0 = vec3(0,0,1); L0 = vec3(-0.8,0,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1); p2 = vec3(-1,0,1);\n    l0 = vec3(1,1,0); L0 = vec3(1.5,0.618,1);\n  }\n  p0 = transform(p0); p1 = transform(p1); p2 = transform(p2);\n  //l0 = transform(l0); L0 = transform(L0);\n  if (iMouse.x != 0.0) L0 = map(iMouse.xy);\n\n  vec3 p01 = join(p0,p1);\n  vec3 p02 = join(p0,p2);\n  vec3 p12 = join(p1,p2);\n\n  vec3 color = background;\n  \n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,linedist(pos,p01));\n  color = cmix(color,lcolor2,linedist(pos,p02));\n  color = cmix(color,lcolor2,linedist(pos,p12));\n\n  // The tangent lines\n  color = cmix(color,lcolor1,linedist(pos,l0));\n  color = cmix(color,lcolor1,linedist(pos,L0));\n\n  // The lines of the ToR\n  color = cmix(color,lcolor0,linedist(pos,p0));\n  color = cmix(color,lcolor0,linedist(pos,p1));\n  color = cmix(color,lcolor0,linedist(pos,p2));\n\n  mat3 m = mat3(p0,p1,p2); // Map from ToR to (p0,p1,p2)\n  if (determinant(m) != 0.0) {\n    // m must be invertible\n    vec3 l1 = l0*m, L1 = L0*m; // Map the lines\n    m = inverse(m); // And invert for point mapping\n    vec2 t;\n    if (lineconicparams(t,l1,L1)) {  // Find involution fixpoints\n      for (int i = -1; i <= 1; i += 2) {\n        for (int j = -1; j <= 1; j += 2) {\n          // Each involution has two fixpoints t\n          // so there are 4 combinations possible\n          vec3 p = vec3(0,1,float(i)*t[0]);\n          vec3 P = vec3(float(j)*t[1],0,1);\n          vec3 l = cross(p,P);  // Line though p and P\n          vec3 q = cross(l,l1); // Intersect with tangents to give points on conic\n          vec3 Q = cross(l,L1);\n          mat3 c = pointconic(q,Q); // Find conic through ToR, q and Q\n          c = transpose(m)*c*m; // Conjugate with map to ToR\n          // And draw conic and dual\n          color = cmix(color,ccolor0,conicdist(pos,c));\n          // For the dual, just use the cofactor matrix\n          color = cmix(color,ccolor1,conicdist(pos,cofactor(c)));\n        }\n      }\n    }\n  }\n\n  color = cmix(color,pcolor2,pointdist(pos,p01));\n  color = cmix(color,pcolor2,pointdist(pos,p02));\n  color = cmix(color,pcolor2,pointdist(pos,p12));\n\n  color = cmix(color,pcolor1,pointdist(pos,l0));\n  color = cmix(color,pcolor1,pointdist(pos,L0));\n\n  color = cmix(color,pcolor0,pointdist(pos,p0));\n  color = cmix(color,pcolor0,pointdist(pos,p1));\n  color = cmix(color,pcolor0,pointdist(pos,p2));\n\n  fragColor = vec4(pow(color,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7df3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[5106, 5106, 5139, 5458, 5687], [5689, 5689, 5741, 5741, 6139], [6141, 6141, 6164, 6341, 6440], [6442, 6442, 6469, 6567, 6590], [6592, 6622, 6640, 6640, 6708], [6710, 6710, 6746, 6746, 6798], [6800, 6800, 6824, 6824, 6957], [6974, 6974, 7007, 7007, 7167], [7169, 7169, 7202, 7202, 7384], [7386, 7386, 7418, 7418, 7572], [7574, 7574, 7624, 7624, 7665], [7667, 7667, 7724, 7724, 10652]], "test": "untested"}
{"id": "7dB3Rz", "name": "Circular Bar Audio Visualizer", "author": "Tater", "description": "Can't believe I got this to work after having the idea. \nPress pause and play if the audio doesn't start.\nMouse click mirrors, mouse x controls smoothing, mouse y controls wobble.", "tags": ["2d", "mouse", "sound", "audiovisualizer"], "likes": 15, "viewed": 653, "published": 3, "date": "1616827976", "time_retrieved": "2024-07-30T19:30:23.776575", "image_code": "#define pi 3.14159265359\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n\n//Inspired by this random gif I saw in someone's steam workshop icon\n//https://steamuserimages-a.akamaihd.net/ugc/1774952891092106678/2D0BC0B276D7C72CA57E2ED2BAA2A55652BD9F0F/\n\n//Mouse click mirrors, mouse x controls smoothing, mouse y controls wobble.\n\n\n//Song\n//https://soundcloud.com/surrealrecordings/babokon-laces\n//https://soundcloud.com/insan3lik3/hai\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    vec2 mXY=(iMouse.xy)/iResolution.y; \n    float r = length(uv);\n    \n    if(iMouse.z == 0.0){\n    mXY = vec2(0.5,0.5);\n    }\n    \n    //uv*=rot(iTime*0.3); //SPIIN\n    \n    //wavey\n    uv*=rot(3.0*mXY.y*0.03*sin(t+18.0*(1.0-length(uv))));\n    \n    //converting to polar coordinates 0<->360 -> 0<->1.0\n    //If you know a more elegant way to do this let me know\n    \n    /*\n    float th = atan(uv.y/uv.x);\n    th += pi*step(0.0,-uv.x)+2.0*pi*step(0.0,-uv.y)*step(0.0,uv.x);\n    th /= 2.0*pi;\n    */\n   \n    //I found a more elegant way :D\n    float th = atan(-uv.y,-uv.x)/(2.0*pi)+0.5;\n    \n    \n    float c = 120.0; //bar count (looks pretty cool with low bar counts as well)\n    \n    //c += floor(30.0*pow(sin(t*0.25),2.0)); //bar count changing\n    \n    if(iMouse.z>0.0){\n    th = fract(th*(2.0));\n    }\n    \n    \n    float thID = floor(th*c)/c;\n    th = fract(th*c);\n    \n    float w = (0.12/100.0)*c; //bar gap (try using 0.0)\n    float st = 0.15; //center circle size\n    \n    float aa = c/R.y*step(0.01,w);\n    float aa2 = (0.005)*450.0/R.y;\n\n    //averaging the sound sample from the range of each bar(s) so it's smoother\n    float afft = 0.0;\n    float lps = 0.0;\n    for(int i=int((thID-((1.0+mXY.x*2.0-1.0)/c))*512.0); i<int((thID+(1.0/c))*512.0); i++){\n        afft+=texelFetch( iChannel0, ivec2(clamp(float(i),0.0,512.0),0), 0 ).x;\n        lps++;\n    }\n    afft/=lps;\n    \n    float sen = 2.9; //log scale adjustment\n    float end = (log(0.001+afft*sen)+st)/(log(sen)*2.0);\n    end = (end+afft*0.6)/2.0;\n    //end = clamp(end,0.0,0.50);\n    \n    vec3 col1 = vec3(256.0,66.0,66.0)/256.0;\n    vec3 col2 = vec3(66.0,66.0,245.0)/256.0;\n    vec3 col3 = mix(col1,col2,r*2.6);\n    float li1 = smoothstep(w-aa,w,th)-smoothstep(1.0-w-aa,1.0-w,th);\n    float li2 = smoothstep(st-aa2,st,r)-smoothstep(end-aa2,end,r);\n    float o = min(li1,li2);\n    col3*= o;\n    col3 += (1.0-o)*mix(vec3(0),vec3(32.0,4.0,64.0)/256.0,length(uv));\n    \n    fragColor = vec4(col3,1.0);\n}", "image_inputs": [{"id": 26844, "src": "https://soundcloud.com/insan3lik3/hai", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dB3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 495, 495, 2557]], "test": "untested"}
{"id": "7sSGzz", "name": "4-Dimensional Ray-Marching", "author": "Zi7ar21", "description": "Ray-Marching in 4D projected onto a virtual Volumetric Display.", "tags": ["raymarching", "raymarch", "raymarched", "volumetric", "raymarcher", "4d", "4dimensional"], "likes": 4, "viewed": 398, "published": 3, "date": "1616822591", "time_retrieved": "2024-07-30T19:30:24.550506", "image_code": "// ####### 4-Dimensional Ray-Marching #######\n// Made by Jacob Bingham (Zi7ar21) on March 26th, 2021\n// Last Updated: March 26th, 2021 at 23:30 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the\n// original (and possibly updated version) can be found at:\n// https://www.shadertoy.com/view/7sSGzz\n\n// ##### CONSTANTS #####\n// Octuple Precision, even though Shadertoy is Full Precision (32-Bit Floating Point)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### PARAMETERS #####\n#define mousesensitivity 4.0\n#define gamma 2.2\n\n// 3D Parameters\n#define camfov 1.0\n#define maxmarches 32\n#define maxdist 4.0\n#define stepsize 0.125\n\n// 4D Parameters\n#define camfov4D 1.0\n#define campos4D vec4(0.0, 0.0, 0.0, (sin(iTime*pi*(1.0/3.0)))-1.0)\n#define maxmarches4D 32\n#define maxdist4D 4.0\n#define collisiondist 0.125\n\n// ##### RNG #####\n// RNG Utilities from Michael0884: https://www.shadertoy.com/user/michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state>>((state>>28U)+4U))^state)*277803737U;\n    ns = (word>>22U)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\n//vec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Hash from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p){\n\tvec4 p4 = fract(vec4(p)*vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// ##### 4D DISTANCE ESTIMATORS #####\n// Hypersphere Distance Estimator\nfloat hypersphere(vec4 raypos, vec4 sphpos, float sphrad){\n    return length(raypos-sphpos)-sphrad;\n}\n\n// Multiple Hyperspheres Distance Estimator\nfloat hyperspheres(vec4 raypos){\n    // Set-Up Variables\n    float sphere, minimum;\n\n    // Main Distance Estimator Loop\n    for(int i = 0; i < 8; i++){\n        // Compute the distance to a random hypersphere\n        sphere = hypersphere(raypos, normalize(hash41(float(i))-0.5), 0.125);\n\n        // The first sphere is the minimum of the first iteration\n        if(i == 0){minimum = sphere;}\n\n        // Find the closest sphere\n        minimum = min(sphere, minimum);\n    }\n    \n    // Return the distance to the closest sphere\n    return minimum;\n}\n\n// ##### ROTATION MATRICIES #####\n// The 4D Rotation Matrix was also made by Michael0884\n// aOb Plane Rotation\nmat4 rotplane(int a, int b, float angle){\n    mat4 rot = mat4(1.0);\n    float s = sin(angle), c = cos(angle);\n    rot[a][a] = c; rot[a][b] =-s;\n    rot[b][a] = s; rot[b][b] = c;\n    return rot;\n}\n\n// Rotation Matrix\nmat4 rotmat4D(vec4 rotation){\n    return rotplane(0, 1, rotation.x)*rotplane(1, 2, rotation.y)*rotplane(2, 3, rotation.z)*rotplane(3, 0, rotation.w);\n}\n\n// Rotation Matrix from LoicVDB\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// ##### RENDERING #####\n// 4D Ray-Marching\nvec3 raymarch4D(vec4 raydir, vec4 rayori){\n    // Put our Ray at the Camera Position\n    vec4 raypos = rayori;\n\n    // Initialize our Distance Estimator Variable\n    float distest;\n\n    // The Main Ray-Marching Loop\n    for(int i = 0; i < maxmarches4D; i++){\n        // Check if our Ray escaped the scene\n        if(length(raypos-rayori) > maxdist4D){break;}\n\n        // Find the distance from our Ray to our scene\n        distest = hyperspheres(raypos);\n\n        // Check if our Ray collided with the scene\n        if(distest < collisiondist){return vec3(1.0);}\n\n        // March our Ray\n        raypos += raydir*distest;\n    }\n\n    // If our Ray hit nothing, retuurn the Background Color\n    return vec3(0.0);\n}\n\n// 3D Screen Output Image\nvec3 mainImage4D(vec3 uv){\n    // Calculate the Direction of the Ray\n    mat4 rotmat = rotmat4D(vec4(0.0, 0.0, 0.0, 0.0));\n\n    // Render the Image\n    vec4 raydir = normalize(camfov4D*(uv.x*rotmat[0]+uv.y*rotmat[1]+uv.z*rotmat[2])+rotmat[3]);\n\n    // Output the Image to the Volumetric Display\n    vec3 color = raymarch4D(raydir, campos4D);\n    return color;\n}\n\n// 3D Raymarching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Put our Ray at the Camera Position\n    vec3 raypos = rayori+(raydir*rand()*stepsize);\n\n    // Initialize our Density Variable\n    vec3 density = vec3(0.0);\n\n    // The Main Ray-Marching Loop\n    for(int i = 0; i < maxmarches; i++){\n        // Check if our Ray escaped the scene\n        if(length(raypos-rayori) > maxdist){break;}\n\n        // Find the Volumetric Display's Color\n        density += mainImage4D(raypos);\n\n        // March our Ray\n        raypos  += raydir*stepsize;\n    }\n\n    // Return the total density\n    return density*0.125;\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize RNG\n    INIT_RNG;\n\n    // Set up Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, fragCoord.xy)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    vec2 mouse = vec2(iTime*pi*0.25, 0.0);\n    //vec2 mouse = vec2(0.0, 0.0);\n    #ifdef mousesensitivity\n    if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n    #endif\n\n    // Calculate the Direction of the Ray\n    mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n    // Render the Image\n    vec3 color = raymarch(raydir, vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0));\n\n    // Tonemap HDR\n    color = pow(color/(1.0+color), vec3(1.0/gamma));\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1131, 1131, 1142, 1142, 1278], [1280, 1280, 1293, 1293, 1337], [1338, 1338, 1351, 1351, 1380], [1381, 1381, 1394, 1394, 1431], [1432, 1432, 1445, 1445, 1490], [1492, 1552, 1588, 1588, 1685], [2007, 2071, 2092, 2092, 2237], [2239, 2311, 2369, 2369, 2412], [2414, 2458, 2490, 2514, 3007], [3009, 3120, 3161, 3161, 3315], [3317, 3336, 3365, 3365, 3487], [3489, 3521, 3548, 3587, 3980], [3982, 4026, 4068, 4110, 4739], [4741, 4767, 4793, 4835, 5128], [5130, 5148, 5188, 5230, 5742], [5744, 5764, 5818, 5840, 6688]], "test": "untested"}
{"id": "7sBGzR", "name": "Grid Lines 2D", "author": "lumic", "description": "Simple grid shader with major/minor lines.", "tags": ["2d", "grid"], "likes": 4, "viewed": 1686, "published": 3, "date": "1616809070", "time_retrieved": "2024-07-30T19:30:25.315460", "image_code": "#define MAJOR_INTERVAL 0.25\n#define INTERVAL_DIVISIONS 4.0\n\n#define MAJOR_INTENSITY 0.9\n#define MINOR_INTENSITY 0.3\n\n#define PI 3.141592653589793238f\n\nfloat grid(float x) {\n  // TODO make line width zoom-independent\n  float major = smoothstep(0.995, 1.0, cos(x * (2. * PI) / MAJOR_INTERVAL)) * MAJOR_INTENSITY;\n  float minor = smoothstep(0.97, 1.0, cos(x * (2. * PI) * INTERVAL_DIVISIONS / MAJOR_INTERVAL)) * MINOR_INTENSITY;\n  return max(major, minor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Vertically normalized pixel coordinates (from 0 to 1 on vertical only)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.2);\n    \n    float xCol = grid(uv.x);\n    float yCol = grid(uv.y);\n    \n    col = col + max(xCol, yCol);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 172, 215, 455], [457, 457, 514, 592, 822]], "test": "untested"}
{"id": "ssBGRR", "name": "brickmod", "author": "Del", "description": "brick", "tags": ["bricks"], "likes": 6, "viewed": 303, "published": 3, "date": "1616802642", "time_retrieved": "2024-07-30T19:30:26.083407", "image_code": "// brickmod\n//#define SYMMETRIC\n\nvec4 BrickGridMod(vec2 uv, out vec2 id,float aspect)\n{\n    vec2 pos = uv * vec2(1.0,aspect);\n    pos.x += floor(uv.y*aspect)/aspect;\n    id = floor(pos);\n    id.y /= aspect;\n    pos = fract(pos);\n    vec2 uv2 = fract (pos)-0.5;\n    uv2.y /= aspect;\n    pos=abs(fract (pos + 0.5) - 0.5);\n    float d = min(pos.x,pos.y/aspect);\n    return vec4(abs(d),length(uv2),uv2);\n}\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.0;//iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n    float zoom = 8.0;\n    if (iMouse.z>0.5)\n        zoom += sin(uv.x*3.0+iTime); // Wibble\n\t\n\tvec2 id;\n\tvec4 h = BrickGridMod(uv*zoom, id, 2.4);\n    \n    #ifdef SYMMETRIC\n    // symmetric\n    float patternVal =165.5; // 33.5\n    float blend = pow(abs(sin(length(id)*patternVal + t*0.65)), 16.0);\t// pulse mult\n    #else\n    // randomized\n    float blend = pow(abs(sin(hash21(id)*4.35 + t*0.65)), 16.0);\t// pulse mult\n    #endif\n\n\tvec3 shapecol1  = vec3(0.4,0.2,0.2);\n\tvec3 shapecol2  = vec3(0.65,0.55,0.5);\n\tshapecol1 = mix(shapecol1,shapecol2,blend);\n\tvec3 finalcol = mix(vec3(0.1),shapecol1,smoothstep(0.0, 0.035, h.x)); \n\t//finalcol = mix(vec3(1.0),finalcol,smoothstep(0.0, 0.035, h.y)); \n\tfragColor = vec4(finalcol,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 87, 87, 401], [403, 431, 452, 452, 515], [517, 517, 574, 574, 1397]], "test": "untested"}
{"id": "3t2fWK", "name": "Cheap Tilt Shift", "author": "tomorrowevening", "description": "Cheap tilt shift using a texture bias", "tags": ["tiltshift"], "likes": 1, "viewed": 780, "published": 3, "date": "1616786786", "time_retrieved": "2024-07-30T19:30:26.858336", "image_code": "// based on https://www.shadertoy.com/view/XdfBDf\n\nconst float blurAmount = 5.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float position = smoothstep(0.1, 0.5, distance(0.5, uv.y));\n    float bias = position * blurAmount;\n\tfragColor = texture(iChannel0, uv, bias);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 139, 139, 330]], "test": "untested"}
{"id": "sds3Ds", "name": "p6 voronoy pattern", "author": "DEMERCY", "description": "practice2020", "tags": ["pattern"], "likes": 0, "viewed": 235, "published": 3, "date": "1616777480", "time_retrieved": "2024-07-30T19:30:27.622292", "image_code": "vec2 N22(vec2 p ){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+= dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float m = 0.;\n    float t = iTime*4.;\n    \n    float minDist =3.;\n    vec3 col = vec3(0);\n    \n    if(false){\n        for(float i = 0.;i<50.;i++){\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n*t);\n            \n            float d = length(uv - p);\n            m += smoothstep(.02,.01,d);\n            if(d < minDist){\n                minDist = d;\n            }\n        }\n    }else{\n       uv *= 5.;\n       vec2 gv = fract(uv) - .5;\n       vec2 id = floor(uv);\n       vec2 cid = vec2(0);\n       //col.rg = abs(id*.1);\n       \n       for(int y = -1;y<= 1;y++){\n            for(int x = -1;x<= 1;x++){\n               vec2 offs = vec2(x,y);\n               \n               vec2 n =  N22(id + offs);\n               vec2 p = offs + sin(n*t)*.5;\n               float d = length(gv-p);\n               \n               //p-= gv;                  //Manhattan Dist\n               //d = length(p);\n               //d = abs(p.x)+abs(p.y);\n               if(minDist > d){\n                   minDist = d;\n                   cid = abs(id+offs);\n                   //col   = vec3(cid,.5);\n               }\n            }\n            \n        }\n       //col   = vec3(cid*.1,minDist); \n       col = vec3(1.,minDist,minDist);\n    }\n    \n    \n    \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 140], [142, 142, 199, 199, 1537]], "test": "untested"}
{"id": "fdXGDl", "name": "texture roll", "author": "FabriceNeyret2", "description": "texture 4-quadrants roll.\nSince it is done on a buffer of uv coordinates rather than directly on the texture pixels, this allows videos or webcam.\nRolling back should restore the image.", "tags": ["uv", "roll"], "likes": 5, "viewed": 454, "published": 3, "date": "1616773076", "time_retrieved": "2024-07-30T19:30:28.389242", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel1, T(U).xy );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 V = U - R/2.;\n    \n    if (iFrame<1) O.xy = U/R; // init with uv coordinates\n    else\n      O =  iFrame % 2 > 0     // must alternate rolls to allow transmission via overlapping\n             ?  T( U + vec2( 0 , sign(V.x) ))\n             :  T( U + vec2( -sign(V.y), 0.));  // 0. instead of 0 to fix a windows bug.\n}                                               // see https://www.shadertoy.com/view/fsj3Wh\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 78]], "test": "untested"}
{"id": "7ss3Wf", "name": "Hand like camera moving,zoom in ", "author": "krotos139", "description": "hand like camera", "tags": ["zoom", "webcam", "hand"], "likes": 0, "viewed": 427, "published": 3, "date": "1616767168", "time_retrieved": "2024-07-30T19:30:29.157189", "image_code": "// The MIT License\n\n// The noise function from this article: https://iquilezles.org/articles/voronoise\n\nvec3 hash3(vec2 p)  // replace this by something better\n{\n    float x  = fract( p.x*0.3183099+.1 );\n\tx *= fract(x*17.0);\n    float y  = fract( p.y*0.9843579+.1 );\n\ty *= fract(y*11.0);\n    float z  = fract( p.x*0.4837598+.1 + p.y*0.5790343+.1 );\n\tz *= fract(z*7.0);\n    return vec3( x, y, z );\n}\n\nfloat noise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float t = iTime*3.0;\n    float zoom = 1.0+3.0*noise(vec2(t*0.1), 0.3, 1.0)+0.4*noise(vec2(t*0.4), 0.3, 1.0);\n    vec2 shift =  2.0f*vec2(noise(vec2(t*0.1,-t*0.2), 0.3, 1.0), noise(vec2(-t*0.1,t*0.2), 0.3, 1.0)) - vec2(0.5);\n    shift.y *= 0.5;\n    shift = shift*(zoom-1.0);\n    float scale = 1.0/zoom;\n    \n    vec4 c = texture(iChannel0, shift+(.5 + -.5 * scale +  uv * scale), 1.0);\n    fragColor = c;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ss3Wf.jpg", "access": "api", "license": "mit", "functions": [[104, 104, 161, 161, 398], [400, 400, 444, 444, 922], [925, 925, 982, 982, 1435]], "test": "untested"}
{"id": "fds3Ws", "name": "Travellers", "author": "Dragonpeak", "description": "inspired by https://www.youtube.com/watch?v=X-iSQQgOd1A\nSpace to reset", "tags": ["2d", "abstract", "slime", "tendrils", "slimemould", "mould", "travellers"], "likes": 12, "viewed": 878, "published": 3, "date": "1616761651", "time_retrieved": "2024-07-30T19:30:29.929125", "image_code": "\nconst vec2 EPS = vec2(0.0001, 0.);\nconst float SOFT = 1.;\n\nconst vec3 LIGHT = normalize(vec3(-.8, .5, .2));\n\nvec3 get_nrm(vec2 uv)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = texture(iChannel1, uv+EPS).x - texture(iChannel1, uv-EPS).x;\n    nrm.y = texture(iChannel1, uv+EPS.yx).x - texture(iChannel1, uv-EPS.yx).x;\n    nrm.z = EPS.x*SOFT;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    \n\n    float d = texture(iChannel1, uv).x;\n    \n    vec3 nrm = get_nrm(uv);\n    \n    col = mix(vec3(0,0.04, 0.08), vec3(.5, .7, .9)*1.3, d) + min((d*300.), .1);\n    if(d == 1.)col += .2;\n\n    float light = max(dot(nrm, LIGHT), 0.7);\n    col *= light;\n    //col = nrm;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int TRAVELLER_COUNT_X = 80;\nconst int TRAVELLER_COUNT_Y = 80;\nconst float FADE_RATE = .994;\nconst float RAND_WALK = .3;\nconst float SPEED = .6;\nconst float SCENT_STRENGTH = .8;\nconst float SENSOR_DIST = 2.;\nconst float START_SPREAD = 5.;\nconst float SENSOR_FORWARD = 4.;\nconst float START_VEL = .1;\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nuvec4 pcg4d(uvec4 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n\tv = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n\n\n\nbool is_space_down(sampler2D key)\n{\n    return texelFetch(key, ivec2(32,0),0).x>0.;\n}", "buffer_a_code": "//traveller data\n\n\n\nvec4 init(vec2 p)\n{\n    uvec4 r = pcg4d(uvec4(p.xy, 1, 1));\n    return vec4(iResolution.xy/2.-START_SPREAD/2.+vec2(r.xy)/float(0xffffffffu)*START_SPREAD, (vec2(r.zw)/float(0xffffffffu)*2.-1.)*START_VEL);//vec2(r.zw)/float(0xffffffffU)*2.-1.);\n}\n\n\n\n\n\nvec2 calc_velocity(vec4 t)\n{\n    vec2 vel = t.zw;\n    \n    if(t.x < 0. || t.x > iResolution.x) vel.x = -vel.x; \n    if(t.y < 0. || t.y > iResolution.y) vel.y = -vel.y; \n    \n    vel += (vec2(pcg2d(uvec2(t.xy*iTime*60.)))/float(0xffffffffu)*2.-1.)*RAND_WALK;\n    \n    vec2 a = normalize(t.zw);\n    vec2 b = vec2(a.y, -a.x)+a*SENSOR_FORWARD;\n    vec2 c = vec2(-a.y, a.x)+a*SENSOR_FORWARD;\n    a*=SENSOR_FORWARD;\n    \n    a *= texelFetch(iChannel1, ivec2(a*SENSOR_DIST+t.xy), 0).w;\n    b *= texelFetch(iChannel1, ivec2(b*SENSOR_DIST+t.xy), 0).w;\n    c *= texelFetch(iChannel1, ivec2(c*SENSOR_DIST+t.xy), 0).w;\n    \n    vel += (a+b+c)*SCENT_STRENGTH;\n    \n    return vel*(1./length(vel))*SPEED;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(int(fragCoord.x)+1 < TRAVELLER_COUNT_X && int(fragCoord.y)+1 < TRAVELLER_COUNT_Y)\n    {\n        if(iFrame < 5 || is_space_down(iChannel2))\n        {\n           fragColor = init(fragCoord);\n        }\n        else\n        {\n           fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n           fragColor.zw = calc_velocity(fragColor);\n\n           fragColor.xy += fragColor.zw;\n\n\n        }\n    }\n\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//diffusion\n\nconst ivec2 BLUR[] = ivec2[](ivec2(0, 1), ivec2(0,-1), ivec2(1, 0), ivec2(-1,0));\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 5 || is_space_down(iChannel2))\n    {\n        fragColor = vec4(0,0,0,0);\n       \n    }\n    else \n    {\n        vec4 col = vec4(0.);\n        for(int i = 0; i < 4; i++)\n        {\n            col += texelFetch(iChannel1, ivec2(fragCoord)+BLUR[i], 0)*.25;\n        }\n\n        col *= FADE_RATE;\n        for(int i = 0; i < TRAVELLER_COUNT_X; i++)\n        {\n            for(int j = 0; j < TRAVELLER_COUNT_Y; j++)\n            {\n                vec4 data = texelFetch(iChannel0, ivec2(i,j), 0);\n                if(floor(data.xy) == floor(fragCoord.xy)) col = vec4(1);\n            }\n        }\n\n        fragColor = col;\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 133, 133, 383], [386, 386, 443, 493, 893]], "test": "untested"}
{"id": "Ndl3Ds", "name": "Flying Bathtubs", "author": "dr2", "description": "Ornithopter squadron", "tags": ["flight", "kinematics", "replicate", "absurd"], "likes": 18, "viewed": 439, "published": 3, "date": "1616756973", "time_retrieved": "2024-07-30T19:30:30.882575", "image_code": "// \"Flying Bathtubs\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Length4 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 wngLink;\nvec3 sunDir, qHit, flDisp;\nvec2 cId, wngCs;\nfloat tCur, dstFar, bGrid, grLim, wngH, wngAh, whlRad, whlRot, hVel, prpRot;\nint idObj;\nconst int idBod = 1, idProp = 2, idWingF = 3, idWingC = 4, idLnk = 5, idEng = 6, idNos = 7,\n   idWhl = 8, idSpok = 9, idSeat = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat BodDf (vec3 p)\n{\n  return PrRound4BoxDf (p, vec3 (max (vec2 (0.15, 0.4) - vec2 (0.03, 0.1) * p.z * p.z, 0.), 1.6), 0.3);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, dr, dw, dx;\n  dMin = dstFar;\n  p -= flDisp;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  q = p;\n  q.z -= -0.2;\n  db = BodDf (q);\n  d = SmoothMax (min (abs (db) - 0.03, max (q.y + 0.45, db)), q.y - 0.3, 0.02);\n  d = max (d, 0.07 - length (vec2 (q.y + 0.65, abs (q.z) - 0.8)));\n  d = 0.9 * min (d, PrRoundBoxDf (vec3 (abs (q.x) - 0.45, q.y + 0.65, abs (q.z) - 0.8), vec3 (0.01, 0.1, 0.02), 0.02));\n  DMINQ (idBod);\n  q = p;\n  q.z = abs (q.z + 0.2) - 1.;\n  q.y -= 0.1;\n  d = max (PrRoundBox2Df (q.yz, vec2 (0.01, 0.1), 0.02), db);\n  DMINQ (idSeat);\n  q = p;\n  q.z -= -0.2;\n  d = min (max (PrCylDf (q, 0.32, 0.08), 0.05 - length (q.xz - vec2 (0., 0.08))),\n     PrCylDf (q - vec3 (0., 0., -0.35), 0.25, 0.3));\n  DMINQ (idEng);\n  q = p;\n  q.y -= 0.6;\n  d = PrCapsDf (q.xzy, 0.05, 1.1);\n  DMINQ (idEng);\n  q = p;\n  q.x = abs (q.x) - wngLink.x;\n  dx = 0.03 - q.x;\n  q.z -= -0.02;\n  d = PrCapsDf (q, 0.06, 0.42);\n  q.xy = Rot2Cs (q.xy, wngCs * vec2 (1., -1.));\n  d = min (d, PrCylDf (q - vec3 (wngLink.y, 0., -0.15), 0.02, 0.55));\n  DMINQ (idWingF);\n  dr = length (q.xz) - 2.8;\n  q.xz = Rot2D (q.xz, 0.06 * pi);\n  dw = dot (vec2 (abs (q.z) + 0.2, q.x), sin (-0.06 * pi + vec2 (0.5 * pi, 0.)));\n  d = max (max (abs (q.y) - 0.01, abs (dw) - 0.6), max (dr, dx));\n  DMINQ (idWingC);\n  d = max (length (vec2 (dr, q.y)) - 0.02, abs (dw) - 0.6);\n  q.xz = Rot2D (vec2 (q.x, abs (q.z) - 0.26), -0.04 * pi);\n  dw = dot (vec2 (abs (q.z) - 0.135, q.x), sin (-0.02 * pi + vec2 (0.5 * pi, 0.)));\n  d = min (d, max (length (vec2 (q.y, dw)) -0.02, max (dr - 0.01, dx)));\n  DMINQ (idWingF)\n  q = p;\n  q.x = abs (q.x) - wngLink.x;\n  q.xy -= wngLink.y * wngCs;\n  d = PrCylDf (q, 0.06, 0.04);\n  DMINQ (idLnk);\n  q.xy = Rot2D (q.xy, wngAh);\n  q.x -= 0.5 * wngLink.w;\n  d = PrCylDf (q.yzx, 0.02, 0.5 * wngLink.w);\n  DMINQ (idLnk);\n  q = p;\n  q.y -= wngH - 0.6;\n  d = PrCylDf (q.xzy, wngLink.z - 0.01, 0.7);\n  DMINQ (idLnk);\n  q.yz -= vec2 (-0.7, -0.1);\n  d = PrCylDf (q, 0.03, 0.1);\n  DMINQ (idLnk);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (wngLink.z, wngH);\n  d = PrCylDf (q, 0.05, 0.04);\n  DMINQ (idLnk);\n  q = p;\n  q.z -= -1.3;\n  d = PrCylDf (q, 0.03, 1.);\n  DMINQ (idProp);\n  q.z -= -1.;\n  d = PrCapsDf (q, 0.1, 0.03);\n  DMINQ (idProp);\n  q.xy = Rot2D (q.xy, prpRot);\n  q.yz = Rot2D (q.yz, 0.35 * pi * sign (q.x));\n  q.x = abs (q.x) - 0.48;\n  d = PrRoundBoxDf (q, vec3 (0.38, 0.002, 0.07 * (1. + q.x)), 0.01);\n  DMINQ (idProp);\n  q = p;\n  q.z -= 1.7;\n  d = max (PrCapsDf (q, 0.15, 0.15), - db);\n  DMINQ (idNos);\n  q = p;\n  q.y -= -0.7 + max (1.1 - flDisp.y, 0.);\n  q.z = abs (q.z + 0.2) - 0.8;\n  d = PrCylDf (q.yzx, 0.03, 0.65);\n  q.x = abs (q.x) - 0.6;\n  q.yz = Rot2D (q.yz, whlRot * sign (p.z));\n  d = min (d, max (abs (length (q.yz) - whlRad + 0.02) - 0.02, abs (q.x) - 0.04));\n  DMINQ (idWhl);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (8. * (atan (q.z, - q.y) / (2. * pi) + 0.5) + 0.5) / 8.);\n  q.y -= 0.19;\n  d = PrCylDf (q.xzy, 0.02, 0.19);\n  DMINQ (idSpok);\n  return dMin;\n}\n\nvoid ObjState ()\n{\n  vec2 h;\n  float wngAng, tc, t, tt;\n  tc = tCur + 0.7 * (cId.x + cId.y);\n  t = cos (2. * pi * mod (0.6 * tc, 1.));\n  wngAng = 0.12 * pi * (1. + 0.7 * t);\n  wngCs = sin (wngAng + vec2 (0.5 * pi, 0.));\n  wngH = wngLink.y * wngCs.x + wngLink.x - wngLink.z;\n  wngH = sqrt (max (0., wngLink.w * wngLink.w - wngH * wngH));\n  wngAh = pi + asin (wngH / wngLink.w);\n  wngH += wngLink.y * wngCs.y;\n  tt = (mod (0.3 * tc, 6.) - 2.) / 4.;\n  h = Hashv2v2 (17.1 * cId + 0.1) - 0.5;\n  flDisp.xz = bGrid * (cId + 0.5 + 0.2 * h);\n  flDisp.y = 1. + ((tt > 0.) ? 0.2 * (1. - t) + (7. + dot (h, vec2 (0.5))) *\n     SmoothBump (0.2, 0.8, 0.2, tt) : 0.);\n  prpRot = -2. * pi * tc;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = (Maxv2 (abs (cId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    if (Maxv2 (abs (cId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * bGrid;\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, q;\n  float dstObj, dstGrnd, sh, t;\n  bool isBg;\n  wngLink = vec4 (0.5, 0.8, 0.08, 1.5);\n  hVel = 1.;\n  whlRad = 0.4;\n  whlRot = - (hVel / whlRad) * tCur;\n  dstGrnd = dstFar;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBod) {\n      t = BodDf (qHit);\n      if (qHit.y < 0.25) col4 = vec4 (1., 1., 0.8, 0.2) * (0.85 + 0.15 * smoothstep (0., 0.02, abs (mod (4. *\n         ((t > 0.) ? 2. * qHit.y : ((abs (qHit.z) < 1.8) ? qHit.z : 2. * qHit.x)) + 0.5, 1.) - 0.5) - 0.05));\n      else col4 = mix (vec4 (0.8, 0.7, 0., 0.2), vec4 (0.5, 0.2, 0., 0.1), smoothstep (0.01, 0.02, abs (t)));\n      if (t > 0. && PrRoundBox2Df (qHit.zy - vec2 (1.3, -0.01), vec2 (0.3, 0.15), 0.01) < 0.) col4.rgb =\n         mix (col4.rgb, vec3 (1., 0.2, 0.2), ShowIntPZ ((qHit.zy - vec2 (1.3 + 0.25 * sign (qHit.x), -0.13)),\n         vec2 (0.5 * sign (qHit.x), 0.25), 3., 1. + grLim - cId.x + (2. * grLim + 1.) * (grLim - cId.y)));\n    } else if (idObj == idProp) col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.8, 0.9, 0.8, 0.2), \n       smoothstep (0., 0.02, abs (qHit.x - 0.27) - 0.05));\n    else if (idObj == idWingF) col4 = vec4 (0.8, 0.5, 0.1, 0.2);\n    else if (idObj == idWingC) col4 = vec4 (0.9, 0.9, 0.8, 0.2) * (0.93 + 0.07 * smoothstep (0., 0.02,\n       abs (abs (length (qHit.xz) - 1.9) - 0.3) - 0.01));\n    else if (idObj == idLnk) col4 = vec4 (0.8, 0.6, 0.3, 0.2);\n    else if (idObj == idEng) col4 = vec4 (0.8, 0.85, 0.8, 0.2);\n    else if (idObj == idNos) col4 = vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idWhl) col4 = vec4 (0.7, 0.6, 0.6, 0.05);\n    else if (idObj == idSpok) col4 = vec4 (0.5, 0.6, 0.7, 0.1);\n    else if (idObj == idSeat) col4 = vec4 (0.5, 0.2, 0., 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       mod (16. * qHit.z, 1.) - 0.2));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    cId = floor (ro.xz / bGrid);\n    q = ro;\n    q.xz += (hVel / sqrt(2.)) * tCur;\n    col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.), smoothstep (0.2, 0.8, Fbm2 (4. * q.xz)));\n    col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.3, 0.6, dstGrnd / dstFar));\n    vn = VaryNf (4. * q, vec3 (0., 1., 0.), 2. * (1. - smoothstep (0.1, 0.3, dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n    isBg = true;\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (dstObj >= dstFar) col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bGrid = 8.;\n  grLim = 3.;\n  az = pi;\n  el = -0.04 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 7., -4. - 1.4 * (grLim + 1.) * bGrid * (0.9 - 0.1 * cos (4. * az)));\n  ro.xz = Rot2D (ro.xz, - az) + 0.5 * bGrid;\n  zmFac = 3.;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (0., 1., 1.));\n  sunDir.xz = Rot2D (sunDir.xz, -0.01 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Length4 (vec3 p)\n{\n  return sqrt (length (p * p));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3Ds.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1195, 1195, 1217, 1217, 1323], [1325, 1325, 1347, 1347, 4324], [4326, 4326, 4344, 4344, 5006], [5008, 5008, 5041, 5041, 5677], [5679, 5679, 5700, 5700, 5955], [5957, 5957, 5994, 5994, 6481], [6483, 6483, 6517, 6517, 7343], [7345, 7345, 7380, 7380, 10171], [10215, 10215, 10271, 10271, 11483], [11485, 11485, 11531, 11531, 11578], [11580, 11580, 11627, 11627, 11674], [11676, 11676, 11723, 11723, 11771], [11773, 11773, 11815, 11815, 11866], [11868, 11868, 11911, 11911, 11975], [11977, 11977, 12001, 12001, 12035], [12037, 12037, 12059, 12059, 12086], [12088, 12088, 12110, 12110, 12137], [12139, 12139, 12184, 12184, 12287], [12289, 12289, 12334, 12334, 12372], [12374, 12374, 12431, 12431, 12514], [12516, 12516, 12552, 12552, 12758], [12760, 12760, 12790, 12790, 12903], [12905, 12905, 12936, 12936, 13000], [13002, 13002, 13025, 13025, 13129], [13202, 13202, 13234, 13234, 13782], [13784, 13784, 13846, 13846, 14213], [14247, 14247, 14271, 14271, 14324], [14326, 14326, 14350, 14350, 14480], [14482, 14482, 14507, 14507, 14653], [14655, 14655, 14680, 14680, 14866], [14868, 14868, 14890, 14890, 15044], [15046, 15046, 15067, 15067, 15222], [15224, 15224, 15253, 15253, 15465], [15467, 15467, 15506, 15506, 15686]], "test": "untested"}
{"id": "Nsl3Dl", "name": "Quadratic Bezier to \"y=\"", "author": "oneshade", "description": "Solving for the y coordinate of a quadratic bezier. The same process can be applied to other parametrics, take the inverse of the x component and plug it into the y component as the parameter.", "tags": ["bezier", "1d", "de", "quadratic", "inverse", "parametric"], "likes": 1, "viewed": 137, "published": 3, "date": "1616747469", "time_retrieved": "2024-07-30T19:30:31.654512", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// There are two roots, you can only choose one (k = -1 or k = 1)\nvec2 yBezier(in float x, in float k, in vec2 a, in vec2 b, in vec2 c) {\n    float c1 = a.x - 2.0 * b.x + c.x;\n    float c2 = 2.0 * (b.x - a.x);\n    float c3 = a.x - x;\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        float t = (sqrt(discr) * k - c2) / c1 * 0.5, tInv = 1.0 - t;\n        if (abs(t - 0.5) < 0.5) return vec2(a.y * tInv * tInv + 2.0 * b.y * tInv * t + c.y * t * t, 1.0);\n        return vec2(0.0);\n    }\n\n    return vec2(0.0);\n}\n\n// Derivative (mainly for distance estimation)\nvec2 dBezier(in float x, in float k, in vec2 a, in vec2 b, in vec2 c) {\n    float c1 = a.x - 2.0 * b.x + c.x;\n    float c2 = 2.0 * (b.x - a.x);\n    float c3 = a.x - x;\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        float sq = sqrt(discr);\n\n        float t = (sq * k - c2) / c1 * 0.5;\n        if (abs(t - 0.5) < 0.5) { // In the range [0, 1]\n            float u = 2.0 * (a.y * (t - 1.0) + b.y * (1.0 - 2.0 * t) + c.y * t);\n            float v = u * k / sq;\n            return vec2(v, 1.0);\n        }\n\n        return vec2(0.0);\n    }\n\n    return vec2(0.0);\n}\n\nvec3 xMaxBezier(in vec2 a, in vec2 b, in vec2 c) {\n    float t = (a.x - b.x) / (a.x - 2.0 * b.x + c.x), tInv = 1.0 - t;\n    if (abs(t - 0.5) < 0.5) return vec3(a * tInv * tInv + 2.0 * b * tInv * t + c * t * t, 1.0);\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s3) * 0.5;\n    vec2 b = vec2(s1, s2) * 0.5;\n    vec2 c = vec2(c3, c1) * 0.5;\n\n    // First part (k = 1)\n    vec2 dx = dBezier(uv.x, 1.0, a, b, c);\n    if (dx.y > 0.0) {\n        vec2 de = abs(uv.y - yBezier(uv.x, 1.0, a, b, c)) / sqrt(1.0 + dx * dx);\n        draw(de.x - 0.01, vec3(1.0, 0.5, 0.0));\n    }\n\n    // Second part (k = -1)\n    dx = dBezier(uv.x, -1.0, a, b, c);\n    if (dx.y > 0.0) {\n        vec2 de = abs(uv.y - yBezier(uv.x, -1.0, a, b, c)) / sqrt(1.0 + dx * dx);\n        draw(de.x - 0.01, vec3(0.0, 0.0, 1.0));\n    }\n\n    draw(sdLine(uv, a, b), vec3(1.0));\n    draw(sdLine(uv, b, c), vec3(1.0));\n\n    vec3 xMax = xMaxBezier(a, b, c);\n    if (xMax.z > 0.0) draw((length(uv - xMax.xy) - 0.02) + 0.01 * sin(iTime * 10.0), vec3(1.0, 0.0, 0.0));\n\n    draw(length(uv - a) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - b) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - c) - 0.01, vec3(1.0, 1.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsl3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 115, 115, 223], [225, 291, 362, 362, 757], [759, 806, 877, 877, 1390], [1392, 1392, 1442, 1442, 1631], [1633, 1633, 1688, 1688, 2973]], "test": "untested"}
{"id": "fsl3D2", "name": "Ligth in the dark", "author": "Arseny", "description": "exp", "tags": ["2d"], "likes": 0, "viewed": 224, "published": 3, "date": "1616742506", "time_retrieved": "2024-07-30T19:30:32.424453", "image_code": "#define S smoothstep\n#define pi (3.14159265359)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 toPolar(vec2 uv){ // 0 <= x and -pi <= y <= pi\n    return vec2(length(uv), atan(uv.y, uv.x));\n}\n\nvec2 toNormalizedPolar(vec2 uv){ // 0 <= res.x and 0 <= res.y <= 1\n    vec2 res = toPolar(uv);\n    res.y = fract(res.y / pi / 2. + 1.);\n    return res;\n}\n\nvec4 roundedSquare(vec2 uv){\n    vec2 pv = toNormalizedPolar(uv);\n    //return vec4(pv.x, vec3(uv * step(pv.x, 1.), sqrt(1. - pv.x * step(pv.x, 1.))));\n    float t = pv.y;\n    t = fract(t * 4.);\n    t = 2. * abs(t - 0.5);\n    float maxval = mix(1., sqrt(2.), cos(iTime));\n    maxval = mix(1., sqrt(2.), 0.25);    \n    float needD = mix(maxval, 1., S(0., 1., t));\n    float d = pv.x - needD;\n    //return vec4(d / needD, vec3(0.));\n    float l = smoothstep(0., 1., -d / needD);\n    //l = pow(l, 1.5);\n    float k = sqrt(max(1. - l*l, 0.));\n    k *= step(0., -d);\n    l = step(0., -d) * l + step(-d, 0.);\n    return vec4(d, vec3(normalize(uv) * k, l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // uv.y in range(-0.5, 0.5) uv.x proportionately\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float k = 2.5;\n    uv *= k;\n    float pix = 3. / iResolution.y;\n    pix *= k;\n    \n    vec3 lightDir = normalize(vec3(0.4 * sin(iTime * 1.5), 0.4 * cos(iTime * 1.), -1.));\n    //lightDir = vec3(0., 0.2, -1.);\n    vec4 sqrInfo = roundedSquare(uv);\n    fragColor = vec4(sqrInfo.yzw * 0.5 + 0.5, 0.);\n    fragColor = vec4(smoothstep(0., -1., dot(sqrInfo.yzw, lightDir)) * 0.4 + 0.3);\n    \n    return;\n    vec3 ref = reflect(lightDir, sqrInfo.yzw);\n    \n    float d = sqrInfo.x;\n    fragColor = vec4(S(0., pix, abs(d + 0.5 * sin(iTime) + 0.5)));\n    //fragColor = vec4(-d);\n    //return;\n    fragColor = vec4(abs(sqrInfo.yzw), 0.);\n    fragColor = vec4(ref, 0.);\n    \n    //fragColor = vec4(step(0., ref.z) * ref.z * ref.z * ref.z);\n    fragColor = vec4(pow(ref.z, 1.));\n    fragColor = vec4(max(-dot(sqrInfo.yzw, lightDir), 0.) * ref.z * ref.z);\n    //fragColor = vec4(ref.z);\n    //fragColor = vec4(smoothstep(0., 0.01, abs(sqrInfo.x - 0.5 + 0.5 * cos(iTime))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 140, 162, 162, 312], [314, 314, 336, 365, 414], [416, 416, 448, 482, 569], [571, 571, 599, 599, 1223], [1225, 1225, 1282, 1340, 2366]], "test": "untested"}
{"id": "7sfGWs", "name": "photomenon", "author": "wyatt", "description": "Caustics with particles, a lot of the 'photons' are lost unfortunately. (meant to be sped up)", "tags": ["fluid", "automata"], "likes": 10, "viewed": 447, "published": 3, "date": "1616724280", "time_retrieved": "2024-07-30T19:30:33.206362", "image_code": "// Fork of \"Aqua Vista\" by wyatt. https://shadertoy.com/view/ssXGDB\n// 2021-03-26 01:23:33\n\n// Fork of \"Temperatures\" by wyatt. https://shadertoy.com/view/fsf3zS\n// 2021-03-22 22:23:14\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-18 22:39:28\n\n// Display \nMain \n{\n    float w = B(U).w;\n    Q = (1.+sin(2.+A(U).w+vec4(1,2,3,4)))*\n    (pow(w,10.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define box2 for(int x=-2;x<=2;x++)for(int y=-1;y<=1;y++)\n\n#define r2 0.70710678118\nfloat hash(vec2 p) // Dave H\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = 0.1*a.w*(a.w*(a.w-.9)+.1);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.y -= .1/R.y;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(iMouse.xy-0.5*R),0,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,step(U.y,.5*R.y)*(1.-step(abs(U.x-.5*R.x),0.1*R.x)));\n    if (U.x < 1.||R.x-U.x<1.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n    if (R.y-U.y<1.)Q.w*=0.;\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = B(U);\n    box2 {\n        vec2 u = vec2(x,y);\n        vec4 a = B(U+u);\n        if (length(a.xy-U)<length(Q.xy-U)){\n            Q = a;\n        }\n    }\n    vec4 n = A(Q.xy+vec2(0,1)),\n         e = A(Q.xy+vec2(1,0)),\n         s = A(Q.xy-vec2(0,1)),\n         w = A(Q.xy-vec2(1,0));\n    vec2 g = vec2(e.w-w.w,n.w-s.w);\n    \n    Q.zw += .04*g;\n    if (length(Q.zw)>0.) Q.zw = .5*normalize(Q.zw);\n    Q.xy += Q.zw;\n    if (iFrame < 1||R.y-U.y<2.) {\n        Q = vec4(round(U/3.)*3.+3.*\n        2.*hash(vec2(U.x,iFrame))-1.,0,-1);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\n    Q = B(U);\n    vec4 a = A(U);\n    Q *= .99;\n    Q += .013*exp(-.2*length(a.xy-U));\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdf3Wl", "name": "perlin-stimulated force field", "author": "morisil", "description": "experiment, a study for another project", "tags": ["perlin", "focefield"], "likes": 11, "viewed": 427, "published": 3, "date": "1616711361", "time_retrieved": "2024-07-30T19:30:33.992261", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec4 prevPixel = texture(iChannel0, uv);\n    vec2 prevForce = prevPixel.xy;\n    prevForce *= .99;\n    vec2 newForce = prevForce + vec2(\n        Perlin3D(vec3(st * 2., iTime * 5.)),\n        Perlin3D(vec3((st + 1000.) * 2., iTime * 5.))\n    ) * sin(iTime) * 20. + st * .2;\n    fragColor = vec4(newForce.x, newForce.y, 0.0, 0.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec2 force = texture(iChannel0, uv).xy;\n    vec3 prevColor = texture(iChannel1, uv - force * .00001).rgb;\n    prevColor *= .999;\n    float dist = length(st * 3.1);\n    prevColor += vec3(sin(-iTime * 10. + dist * 50.)) \n        //* smoothstep(1., .9, dist)\n        * .05;\n    fragColor = vec4(prevColor, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "Nsf3Ws", "name": "random generator", "author": "mdb", "description": "easy to use pseudo random generator that you can copy paste on your project", "tags": ["random"], "likes": 13, "viewed": 1782, "published": 3, "date": "1616704506", "time_retrieved": "2024-07-30T19:30:34.780154", "image_code": "//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    vec3 col = vec3(random());\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 99, 99, 249], [250, 250, 291, 291, 404], [406, 406, 421, 421, 472], [544, 544, 601, 601, 702]], "test": "untested"}
{"id": "fsfGDl", "name": "Sphere Spiral", "author": "me_123", "description": "A spiral made of 500 spheres.\nIt uses a bounding volume to improve the performance.", "tags": ["pointcloud"], "likes": 3, "viewed": 362, "published": 3, "date": "1616696902", "time_retrieved": "2024-07-30T19:30:35.609936", "image_code": "bool showDebug = false;\nvec4 load(in vec2 coord) {\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\nfloat camSize = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    if (iMouse.z < 2.) {\n        mouse = vec2(iTime/5.0, (sin(iTime/2.0)*0.5)+0.5);\n    }\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n    vec3 at = vec3(0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n    vec3 minB = load(vec2(clamp(iFrame, 0, min(count-1, int(iResolution.x)-1)), 1)).xyz;\n    vec3 maxB = load(vec2(clamp(iFrame, 0, min(count-1, int(iResolution.x)-1)), 2)).xyz;\n    float dist = 10000.;\n    bool hitBound = box(ro-(maxB-0.1), rd, ((minB-maxB)/2.0)+0.1).x > 0.0;\n    vec3 col = vec3(0);\n    if (hitBound) {\n        if (showDebug) {\n            col += 0.1;\n        }\n        for (int i = 0; i < count; i += 1) {\n            vec4 pix = load(vec2(i, 0));\n            if (pix.w == 0.) {\n                break;\n            }\n            vec3 coord = pix.xyz;\n            float d = sphere(ro, rd, coord, 0.1).x;\n            if (dist > d && d > 0.) {\n                dist = d;\n            }\n        }\n    }\n    if (dist != 10000.) {\n        vec3 position = ro+rd*dist;\n        col = abs(position)+((length(position)/2.0)-0.7);\n    }\n    if (!showDebug) {\n    float d = box(ro+vec3(5., 1.2, 5.0), rd, vec3(5.0, 0.1, 5.0)).x;\n        if (dist > d && d > 0.) {\n            col = 1.0-clamp(vec3(length(ro+rd*d))/5., 0.0, 1.0);\n        }\n    }\n    fragColor = vec4(col, 0.0);\n    if (showDebug) {\n        fragColor += texture(iChannel0, fragCoord.xy/iResolution.xy*0.1);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 load(in vec2 coord) {\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    ivec2 frag = ivec2(fragCoord);\n    if (iFrame < count/5) {\n        if (frag.y == 0 && frag.x == iFrame*5) {\n            fragColor = vec4(rus(uv), 1);\n        }\n        if (frag.y == 0 && frag.x == (iFrame*5)+1) {\n            fragColor = vec4(rus(uv), 1);\n        }\n        if (frag.y == 0 && frag.x == (iFrame*5)+2) {\n            fragColor = vec4(rus(uv), 1);\n        }\n        if (frag.y == 0 && frag.x == (iFrame*5)+3) {\n            fragColor = vec4(rus(uv), 1);\n        }\n        if (frag.y == 0 && frag.x == (iFrame*5)+4) {\n            fragColor = vec4(rus(uv), 1);\n        }\n    }\n    if (iFrame < count) {\n        if (frag.y == 1 && frag.x == (iFrame)) {\n            fragColor = vec4(max(load(vec2(frag.x, 0)), load(vec2(frag.x-1, 1))).xyz, 1);\n        }\n        if (iFrame == 1) {\n            if (frag.y == 2 && frag.x == (iFrame)) {\n                fragColor = vec4(min(load(vec2(frag.x, 0)), vec4(1000.)).xyz, 1);\n            }\n        } else {\n            if (frag.y == 2 && frag.x == (iFrame)) {\n                fragColor = vec4(min(load(vec2(frag.x, 0)), load(vec2(frag.x-1, 2))).xyz, 1);\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nconst int count = 500;\nconst float PI = 3.1415;\nconst float PI2= 6.283;\nvec3 rus(vec2 seed) {\n    float thata = (hash(seed)-0.5)*PI2;\n    float phi = hash(seed)*PI;\n    float x = sin(thata*5.0)*sin(phi);\n    float y = cos(thata*5.0)*sin(phi);\n    float z = cos(phi);\n    return vec3(x, z, y);\n}\n//by IQ\nvec2 box( vec3 ro, vec3 rd, vec3 boxSize) \n{\n    ro -= boxSize;\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\nvec2 sphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 50, 50, 103], [124, 124, 181, 181, 1939]], "test": "untested"}
{"id": "sds3WX", "name": "ray marching - v5 (reflections)", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 9, "viewed": 297, "published": 3, "date": "1616688771", "time_retrieved": "2024-07-30T19:30:36.489584", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 30.0\n#define FOG_DENSITY 0.2\n#define COLLISION_THRESHOLD 0.001\n#define MAX_STEP_SIZE 10000000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(-vec3(1,-1,1));\nvec3 light2 = normalize(-vec3(-0.5,-1,0.9));\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess, out float reflectance){\n    float d = MAX_STEP_SIZE; // min safe distance\n\n\n    float d1 = box(rotate(ray-vec3(0,0,9), vec3(1,1,0), iTime), vec3(0.0,1.4,1.), 0.3);\n    float d2 = box(rotate(ray - vec3(5.+sin(iTime*.7)*0.5,sin(iTime*0.3)*.5+1.,9), vec3(-1,10,0),-0.5), vec3(1,2,1), 0.1);\n    float d3 = sphere(ray - vec3(-5,1,12), 4.) + smoothstep(1.,0.,sin(ray.y*5.+iTime))*.2;\n    float d4 = sphere(vec3(ray.x, ray.y*( 1.-(1.+sin(iTime*5.))*.04 ), ray.z) - vec3(3,2,20), 7.);\n    d1 = min(min(d1, d2), min(d3, d4));\n    float d0 = plane(ray-vec3(0,-2,6), normalize(vec3(0,1,0)));\n    d = min(d1, d0);\n    \n    if(d1 < d0){\n        if(d1 < d2 && d1 < d3 && d1 < d4){\n            color = vec3(.9,.5,.1);\n        }\n        else{\n            color = vec3(.5,.0,.9);\n        }\n    }\n    else{\n        color = vec3(.04,.04,.04);\n    }\n    shininess = .9;\n    return d;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    float r = 0.;\n    return safe_distance(ray, c, s, r);\n}\n\nvec3 normal(vec3 ray){\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n\n    vec3 n = vec3(safe_distance(ray)) - vec3(\n        safe_distance(ray - epsilon.xyy),\n        safe_distance(ray - epsilon.yxy),\n        safe_distance(ray - epsilon.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 pos, vec3 ray, float k){\n    float d = 0.1;\n    float val = 1.;\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float h = safe_distance(pos+ray*d);\n        if(h < COLLISION_THRESHOLD){ // collision\n            return 0.;\n        }\n        val = min(val, k*h/d);\n        \n        d += h;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    return val;\n}\n\nvec3 ray_march(vec3 ray_dir){\n    vec3 total_color = vec3(0);\n    float shininess = 0.;\n    float reflectance = 0.;\n    vec3 body_color = vec3(0);\n    int reflections = 0;\n    //float d = 0.; // ray length\n    vec3 ray = vec3(0.);\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray, body_color, shininess, reflectance);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 color = vec3(0);\n        \n            vec3 n = normal(ray);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            \n            \n            // shadow\n            /*float s = shadow(ray, light1, 5.5);\n            l1 = max(l1 - (1.-s)*.2, 0.);*/\n            \n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5; // normal color\n            color = body_color*0.1; // ambient\n            color += body_color*l1 + body_color*l2; // difuse light\n            color += (vec3(0.5)*pow(l1, 30.) + vec3(.0)*pow(l2, 100.))*shininess; // specular light            \n            \n            // fog in the distance\n            color /= (exp((length(ray)-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            total_color = mix(color, total_color, float(reflections)*0.8);\n            \n            // reflection\n            if(++reflections < 2){\n                ray_dir = -normalize(2. * dot(n, ray_dir) * n - ray_dir);\n                //ray_dir = normalize(ray_dir*(1.-1./dot(ray_dir, n)));\n                ray += ray_dir*0.1;\n            }\n            else{\n                break;\n            }\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        ray += ray_dir*step_size;\n        \n        if(length(ray) > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.6,.3)*pow(max(1.-min_distance,0.),10.);\n    \n    return total_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n    fragColor = vec4(ray_march(normalize(vec3(uv, f))),1);\n}", "image_inputs": [], "common_code": "// SHAPES\n// pos is vector from center of the sphere to ray\nfloat octahedron(vec3 pos, float r){\n    return (dot(abs(pos), vec3(1)) - r) *0.57735027;\n}\n\nfloat sphere(vec3 pos, float r){\n    return length(pos) - r; // + sin(pos.x*20.)*0.05;\n}\n\nfloat pipe(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r;\n}\n\nfloat pipe_wave(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r + r*0.02*cos(length(dir*dot(pos,dir))*10.);\n}\n\nfloat box(vec3 pos, vec3 size, float r){\n    pos = abs(pos)-size;\n    return length(max(pos, 0.)) + min(max(max(pos.x, pos.y),pos.z),0.) - r;\n}\n\nfloat plane(vec3 pos, vec3 n){\n    return dot(pos, n);\n}\n\n// BLENDING\nfloat smooth_min( float d1, float d2, float s ) {    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nvec4 smooth_min_color(vec4 c1, vec4 c2, float s){ // c_.w component is distance\n    float d1 = c1.w, d2 = c2.w;\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*c2 + (1.-t)*c1)/2.;\n}\n\n// QUATERNION ROTATION\nvec4 rotation_q(vec3 u, float t){ // rotation axis - normalized, rotation angle / 2\n    return vec4(u * sin(t), cos(t));\n}\nvec3 rotate(vec3 v, vec4 q){ // vector to rotate, rotation quaternion\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec3 rotate(vec3 v, vec3 u, float t){\n    vec4 q = rotation_q(normalize(u), t);\n    return rotate(v, q);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 391, 391, 478], [480, 480, 570, 570, 1412], [1414, 1414, 1444, 1444, 1544], [1546, 1546, 1568, 1568, 1819], [1821, 1821, 1863, 1863, 2227], [2229, 2229, 2258, 2258, 4225], [4227, 4227, 4284, 4284, 4447]], "test": "untested"}
{"id": "ssfGDf", "name": "Lemniscate of Bernoulli - DE II", "author": "oneshade", "description": "I tried gradient descent and bisection as well as a combination of them but none of them worked so I ended up brute forcing it, at least it has some symmetry! Suggestions for other optimization methods are welcome!", "tags": ["bernoulli", "parametric", "approximate", "lemniscate", "propeller"], "likes": 6, "viewed": 225, "published": 3, "date": "1616685946", "time_retrieved": "2024-07-30T19:30:37.268501", "image_code": "/*\nPrevious distance estimation: https://www.shadertoy.com/view/3tKyD3\nIt is much faster than this one and is a decent estimate (good enough\nto raymarch in around 100 steps)\n\nDesmos graph: https://www.desmos.com/calculator/fmafjbtbu4\n*/\n\n#define dot2(v) dot(v, v)\n\nfloat sqLineDist(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Parametrized lemniscate of Bernoulli\nvec2 pos(in float t, in vec2 ab) {\n    return vec2(cos(t), sin(t)) * ab * sqrt(max(0.0, cos(2.0 * t)));\n}\n\n// ab: vec2(lobe width, lobe height)\nfloat sdPropeller(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    float dt = 0.025; // Adjust to desired accuracy\n    vec2 prev = pos(dt, ab);\n    float dist = sqLineDist(p, pos(0.0, ab), prev);\n    for (float t=2.0 * dt; t < 0.78539816339 + dt; t += dt) {\n        vec2 cur = pos(t, ab);\n        dist = min(dist, sqLineDist(p, prev, cur));\n        prev = cur;\n    }\n\n    p = p / ab * sqrt(2.0);\n    float sgn = sign(dot2(vec2(p.x - 1.0, p.y)) * dot2(vec2(p.x + 1.0, p.y)) - 1.0);\n    return sqrt(dist) * sgn;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 3.0;\n\n    float d = sdPropeller(uv, 1.0 + vec2(cos(iTime), sin(iTime)));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 316, 316, 422], [424, 464, 498, 498, 569], [571, 608, 650, 650, 1115], [1117, 1117, 1172, 1172, 1575]], "test": "untested"}
{"id": "sss3DX", "name": "Neon circuits", "author": "jarble", "description": "This fractal pattern has many overlapping and blended colors.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 8, "viewed": 384, "published": 3, "date": "1616685281", "time_retrieved": "2024-07-30T19:30:38.031462", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.01;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<6;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1)+triangle_wave(uv.yx,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [747, 747, 794, 794, 850], [852, 852, 909, 909, 1671]], "test": "untested"}
{"id": "fds3DX", "name": "3D Sierpinski ternary bits (2)", "author": "FabriceNeyret2", "description": "Isometric symmetrical perspective + color scheme variant.\n3D Sierpinsky: outside if one of the ternary bits of location is 1 in at least 2 dimensions simultaneously.\nBut you can experiment other counts ;-)\n\nset OPAQUE to 0 for transparency ( costly ! )", "tags": ["sierpinski", "sierpinsky"], "likes": 9, "viewed": 363, "published": 3, "date": "1616665976", "time_retrieved": "2024-07-30T19:30:38.797413", "image_code": "// variant of https://shadertoy.com/view/fsf3WX\n\n#define OPAQUE 1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    vec2 R = iResolution.xy, S = vec2(.5,.866),\n         V = vec2( U.x, dot(U,S) ), A;\n    vec3 I0;\n    float Z = pow(3.,6.), a = Z/R.y, z;\n    V /= R.y; R = vec2(Z), V *= Z;\n    int i, n = int(log2(R.x));\n\n\n    for ( z = 0.; z <= R.y; z++ ) {                   // slices along depth\n        ivec3 I = ivec3 ( V -z , z ) , F; I0=vec3(I); // I = 3D location\n        A = abs( vec2(I) - R.y/2. );\n        if ( max(A.x,A.y) < R.y/2. )\n        for ( i = 0; i <= n; i++, I/=3 ) {            // inspect ternary bits\n            F = 1-abs(I%3-1);                         // iseq(I,1)\n         // F = ivec3(equal( I%3, ivec3(1) ));        // iseq(I,1)\n            if ( F.x+F.y+F.z > 1 ) break;             // at least 2 bits at 1: exit\n          }\n#if OPAQUE\n        if ( i == n+1 ) break;                        // in Sierpinsky\n\n#else\n        if ( i == n+1 )  O += vec4( i == n+1 );       // in Sierpinsky : optical depth++\n#endif\n    }\n  \n#if OPAQUE\n    if ( i == n+1 ) {                                 // in Sierpinsky  paint\n        vec3 A = abs( I0/Z*2. - 1. );\n        i = int(iTime-1.) % 5;\n        O = i==0 ? vec4( exp(-z*4./R.y) )             // AO \n          : i==1 ? vec4(1.-abs( I0/Z - .5 ), 1)       // color schemes\n          : i==2 ? vec4( exp(-(1.-max(A.x,max(A.y,A.z)))*2.) )\n          : i==4 ? vec4( exp(-A*2.) , 1)\n          :        vec4( exp(-(1.-A)*2.) , 1);\n    }\n#else\n    O = 1.-exp(-O/40.);                               // optical depth to opacity\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 1595]], "test": "untested"}
{"id": "Ndl3Wf", "name": "Circles 242", "author": "Paws22", "description": "circle", "tags": ["circle"], "likes": 1, "viewed": 221, "published": 3, "date": "1616665338", "time_retrieved": "2024-07-30T19:30:39.572341", "image_code": "float dist(vec2 p)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    return r - 1.0 + sin(3.0 * a + 2000.0 * r * r * sin(iTime)) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    \n    float d = dist(uv);\n    \n    \n    \n    vec3 col = vec3(1.0 - abs(d) / 2.0);\n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 148], [150, 150, 207, 207, 418]], "test": "untested"}
{"id": "Nss3WX", "name": "LowRes FMV + Dithering effect", "author": "MrHimself", "description": "Low res + small color palette (8/16 bit comparable)+ dithering Effect on top of camera", "tags": ["pixel", "dithering", "lowres"], "likes": 6, "viewed": 658, "published": 3, "date": "1616660174", "time_retrieved": "2024-07-30T19:30:40.343280", "image_code": "const float PIXEL_FACTOR = 320.;\nconst float COLOR_FACTOR = 3.;\n\n//wiki Ordered dithering table\nconst mat4 ditherTable = mat4(\n    0.0, 8.0, 2.0, 10.0,\n    12.0, 4.0, 14.0, 6.0,\n    3.0, 11.0, 1.0, 9.0,\n    15.0, 7.0, 13.0, 5.0\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                  \n    // Reduce pixels            \n    vec2 size = PIXEL_FACTOR * iResolution.xy/iResolution.x;\n    vec2 coor = floor( fragCoord/iResolution.xy * size) ;\n    vec2 uv = coor / size;   \n                \n   \t// Get source color\n    vec3 col = texture(iChannel0, uv).xyz;     \n    \n    // Dither\n    col += ditherTable[int( coor.x ) % 4][int( coor.y ) % 4] * 0.015; // last number is dithering strength\n\n    // Reduce colors    \n    col = floor(col * COLOR_FACTOR) / COLOR_FACTOR ; \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nss3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 290, 341, 846]], "test": "untested"}
{"id": "ssf3DX", "name": "Real-Time Raytracing (PPT)", "author": "Zi7ar21", "description": "slapping denoise stuff together like it's play-doh", "tags": ["raytracer", "ray", "globalillumination", "raytrace", "raytraced", "pathtracing", "pathtracer", "pathtraced", "taa", "temporalantialiasing"], "likes": 17, "viewed": 794, "published": 3, "date": "1616644812", "time_retrieved": "2024-07-30T19:30:41.120203", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ####### Real-Time Ray-Tracing (PPT) #######\n// Made by Zi7ar21 (Jacob Bingham)\n\n// PPT: Pure Path-Tracing\n\n// Made on March 24th, 2021\n// Last Updated: March 24th, 2021 at 21:56 Mountain Standard Time\n\n// This shader is a fully path-traced sphere with Temporal Anti-Aliasing. It doesn't have reprojection.\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/ssf3DX\n\n// You can remove these social media links when using elsewhere:\n// Discord: @Zi7ar21#2168\n//\n// Twitter: @Zi7ar21\n// https://twitter.com/Zi7ar21\n//\n// YouTube: Jacob Bingham\n// https://www.youtube.com/channel/UCuOqD4WwtUZMOquSIeJ-AAA\n\n// ##### PARAMETERS #####\n// Temporal Anti-Aliasing (TAA)\n#define TAA\n// I made this poor implementation of Temporal Anti-Aliasing.\n// Basically, it blends the newly rendered frame with the old one\n// and is more biased to the new frame when the difference between\n// the old and new depth is smaller.\n\n// Camera Field of View\n#define camfov 1.0\n\n// Mouse Control Sensitivity (Comment to Disable Mouse)\n#define mousesensitivity 8.0\n\n// Maximum Ray Bounces\n#define maxbounces 8U\n\n// Step Size Threshold (because 0.0 gives yucky artifacts on surfaces!)\n#define stepthreshold 1e-4\n\n// Light Source Direction\n#define lightdir vec3(1.0)\n\n// Samples-Per-Pixel (SPP)\n#if HW_PERFORMANCE >= 0\n#define SPP 8U\n#elif\n#define SPP 1U\n#endif\n// (If Shadertoy detects that you are on a potato, it should be disabled by default)\n// Examples:\n// SPP 1: 1*iFrame (1x Performance)\n// SPP 2: 2*iFrame (2x Slower)\n// SPP 4: 4*iFrame (4x Slower)\n// SPP 8: 8*iFrame (8x Slower)\n\n// ##### CONSTANTS #####\n// Octuple Precision, even though Shadertoy is Full Precision (32-Bit Floating Point)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### RNG #####\n// RNG Utilities from Michael0884: https://www.shadertoy.com/user/michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state>>((state>>28U)+4U))^state)*277803737U;\n    ns = (word>>22U)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n\n// ##### TEXTURES #####\n// Fractal Brownian Motion (FBM) Noise Octaves\n#define octaves 8U\n\n// Gradient Noises (from Samplers)\nfloat noise(vec3 pos){\n    return texture(iChannel1, pos).r;\n}\n\nfloat noise(vec2 pos){\n    return texture(iChannel2, pos).r;\n}\n\n// Fractal Brownian Motion Noises\nfloat fbm(vec3 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.zyx*2.0;\n    }\n    return outCol;\n}\n\nfloat fbm(vec2 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.yx*2.0;\n    }\n    return outCol;\n}\n\n// ##### OTHER FUNCTIONS #####\n// Rotation Matrix\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// Almost everything is from the great Inigo Quilez:\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;}\n    h = sqrt(h);\n    return -b-h;\n}\n\n// Unused\n/*// Triangle Intersection Function\nvec3 tri(vec3 raydir, vec3 rayori, mat3 triangle){\n    vec3 v1v0 = triangle[1]-triangle[0];\n    vec3 v2v0 = triangle[2]-triangle[0];\n    vec3 rov0 = rayori-triangle[0];\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, raydir);\n    float d = 1.0/dot(raydir, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot( q, v1v0);\n    float t = d*dot(-n, rov0);\n    if(u < 0.0 || u > 1.0 || v < 0.0 || (u+v) > 1.0 ){t = -1.0;}\n    return vec3(t, u, v);\n}*/\n\n// Plane Intersection Function (with help from LoicVDB)\n// https://www.shadertoy.com/user/loicvdb\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out vec3 norm, out uint objectid){\n    // Compute all intersections, and find the closest object\n    float int0 = plane(raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float int1 = sphere(raydir, rayori, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(int0, int1);\n    if(int0 <= 0.0){minimum = int1;}\n    if(int1 <= 0.0){minimum = int0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == int0){\n        norm = vec3(0.0, 1.0, 0.0);\n        objectid = 1U;\n        return int0;\n    }\n\n    if(minimum == int1){\n        norm = normalize((rayori+(raydir*int1))-vec3(0.0, 0.5, 0.0));\n        objectid = 2U;\n        return int1;\n    }\n\n    // NULL Object (just to be safe)\n    norm = vec3(0.0);\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### PBR AND MATERIALS #####\n// Poorly Based on: https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX Normal Distribution Function\nfloat GGX(vec3 norm, vec3 highlightdir, float roughness){\n    float a2     = roughness*roughness;\n    float NdotH  = max(dot(norm, highlightdir), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom    = a2;\n    float denom  = (NdotH2*(a2-1.0)+1.0);\n          denom  = pi*denom*denom;\n    return nom/denom;\n}\n\n// Fresnel Schlick\nvec3 fresnel(vec3 raydir, vec3 normal, vec3 F0){\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Get the Material Properties of an Object\nvoid getmat(in uint objectid, in vec3 raypos, out vec3 albedo, out vec3 spec, inout vec3 norm, out float rough){\n    if(objectid == 1U){\n        albedo = vec3(0.5);\n        spec = vec3(0.6);\n        rough  = (fbm(raypos.xz*0.025)/10.0)+0.125;\n        return;\n    }\n\n    if(objectid == 2U){\n        albedo = vec3(0.8, 0.4, 0.2);\n        spec = vec3(0.6);\n        rough  = (fbm(normalize(raypos-vec3(0.0, 0.5, 0.0))*0.125)*0.5)+0.125;\n        return;\n    }\n\n    // NULL Object\n    albedo = vec3(0.0);\n    spec = vec3(0.0);\n    rough  = 0.0;\n    return;\n}\n\n// ##### RENDERING #####\n// Sky\nvec3 skycol(vec3 raydir){\n    vec3 outCol;\n\n    // Light Source\n    if(length(raydir-normalize(lightdir)) < 0.25){\n        outCol = vec3(10.0);\n        return outCol;\n    }\n\n    // Background Gradient\n    outCol = vec3(dot(raydir+vec3(0.0), vec3(0.0, 1.0, 0.0)));\n    return outCol;\n}\n\n// Ray-Tracing\nvec4 raytrace(vec3 raydir, vec3 rayori){\n    vec3 raypos = rayori, outCol = vec3(1.0), albedo, spec, norm;\n    float depth, rough;\n    uint objectid;\n    for(uint i = 0U; i < maxbounces; i++){\n        float intersection = intersect(raydir, raypos, norm, objectid);\n        if(i == 0U){\n            depth = intersection;\n        }\n        if(intersection <= 0.0){break;}\n        raypos += raydir*intersection;\n        raypos += norm*stepthreshold;\n        getmat(objectid, raypos, albedo, spec, norm, rough);\n        outCol *= albedo*fresnel(raydir, norm, spec);\n        raydir = reflect(raydir, normalize(nrand3(rough, norm)));\n    }\n\n    // Return the Color of the Sky\n    return vec4(outCol*skycol(raydir), depth);\n}\n\n// ##### OUTPUT IMAGE #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 backbuffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    INIT_RNG;\n    vec4 color = vec4(0.0);\n    for(uint i = 0U; i < SPP; i++){\n        // Normalized Screen UV Coordinates Centered on (0.0, 0.0)\n        vec2 uv = 2.0*(nrand2(0.5, fragCoord)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n        // Calculate the Ray Direction\n        vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n        #ifdef mousesensitivity\n        if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n        #endif\n        mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n        vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n        // Render the Image\n        color += raytrace(raydir, vec3(-sin(mouse.x)*2.0, (sin(iTime*pi)/8.0)+0.5, -cos(mouse.x)*2.0));\n    }\n\n    color /= float(SPP);\n\n    // HDR to SDR Tonemapping\n    color = vec4(pow(color.rgb/(1.0+color.rgb), vec3(1.0/2.2)), color.w);\n\n    // Temporal Anti-Aliasing (TAA)\n    // See the first parameter in the list at the top of this shader for an explanation\n    #ifdef TAA\n    if(color.w > 0.0 || iFrame != 0){\n        color = vec4(mix(color.rgb, backbuffer.rgb, 1.0-clamp(abs(color.w-backbuffer.w)+0.125, 0.0, 1.0)), color.w);\n    }\n    #endif\n\n    // Output to Screen\n    fragColor = vec4(max(color.rgb, 0.0), color.w);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssf3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 116]], "test": "untested"}
{"id": "ssXGDf", "name": "Ultimate Stress", "author": "wyatt", "description": "Experiment in ultimate tensile strength", "tags": ["fluid", "automata"], "likes": 13, "viewed": 494, "published": 3, "date": "1616643590", "time_retrieved": "2024-07-30T19:30:41.893136", "image_code": "// Fork of \"Glaciers\" by wyatt. https://shadertoy.com/view/NssGDj\n// 2021-03-24 23:48:04\n\n// Fork of \"Paint Crack\" by wyatt. https://shadertoy.com/view/fdlGDB\n// 2021-03-24 05:01:47\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-23 06:44:39\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U),\n         n = A(U+vec2(0,1)),\n         e = A(U+vec2(1,0)),\n         s = A(U-vec2(0,1)),\n         w = A(U-vec2(1,0));\n     vec2 g = 0.25*vec2(e.w-w.w,n.w-s.w);\n     vec3 no = normalize(vec3(g,.6));\n     vec3 re = reflect(vec3(0,0,1),no);\n     Q = f.w*(0.8+0.5*re.xxxx);\n     Q *= 2.-texture(iChannel2,re);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 qB = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b= B(U+u);\n        Q.xy -= 0.1*a.w*a.w*(a.w*(a.w*mat2(b)*mat2(qB)+mat2(-1.)))*u;  \n    }\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,.6*exp(-9e-4*length(U-0.5*R)));\n    if (Q.w>3.)Q.w=3.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-36.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-36.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.w *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.w *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n    Q = B(U);\n    vec4 qA = A(U);\n    vec4 dQ = vec4(0);\n    box if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u);\n        vec2 v = a.xy-qA.xy;\n        dQ -= a.w*vec4(u.x*v,u.y*v);\n    }\n    Q += dQ;\n    Q = mix(Q,vec4(1,0,0,1),exp(-1000.*qA.w));\n    if (iFrame < 1) Q = vec4(1,0,0,1);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    float w = 0.;\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ += Qb*wa+qb*wb;\n        w += wa+wb;\n        \n    }\n    if (w>0.)dQ/=w;\n    Q = dQ;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssXGDX", "name": "Better clouds 3", "author": "MinimilisticBits", "description": "cloud", "tags": ["clouds"], "likes": 9, "viewed": 296, "published": 3, "date": "1616636899", "time_retrieved": "2024-07-30T19:30:42.659088", "image_code": "//NOT MY CODE///////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    col = vec3(1.)-exp(-0.4*col);\n    vec3 a = vec3(0.3,0.7,0.7)-0.1;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc *= pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.0)?2.*pi-acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nvec3 sky(vec3 d, vec3 ld){\nfloat thetas = dot(ld, vec3(0.,0.,1.));\nfloat theta = dot(d, vec3(0.,0.,1.));\n//if(theta < 0.0)return vec3(0.);\nfloat thetay = dot(d,ld);\nfloat y = acos(thetay);\nfloat taa = dot(-d, vec3(0.,0.,1.));\nfloat tay = dot(-d,ld);\nfloat Fred = (1.0 -1.32004*exp(0.14318/taa))*(1.0+5.30694*exp(-2.48062*y)+0.3167*tay*tay);\nfloat F2 = 1.0-(-0.523242)*(1.0+5.30694*exp(-2.48062*y)+0.3167*thetas*thetas);\nfloat Fblue = (1.0 + -0.27416*exp(-0.0668/taa))*(1.0+0.20388*exp(-1.68898*y)+0.04418*tay*tay);\nif(theta<0.03)return F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n\nreturn 0.2*vec3((1.0 - thetas)*Fred, Fblue*0.4*max(ld.z,0.), Fblue) + F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n}\n\n//NOT MY CODE////////////////////\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //#ifdef TURBULENT\n    //return 1. - abs(noise)*0.5;\n    //#else\n    return (noise*0.25 + 0.5);\n    //#endif\n}\n////////////////////////////////////\n\n\nfloat noise(vec3 uv){\nreturn fract(sin(uv.x*23. + uv.y*345.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\nfloat noise2(vec3 uv){\nvec3 f = floor(uv);\nvec3 i = fract(uv);\ni = smoothstep(0.,1.,i);\nfloat a = noise(f);\nfloat b = noise(f+vec3(1.,0.,0.));\nfloat c = noise(f+vec3(0.,1.,0.));\nfloat d = noise(f+vec3(1.,1.,0.));\nfloat e = noise(f+vec3(0.,0.,1.));\nfloat f2 = noise(f+vec3(1.,0.,1.));\nfloat g = noise(f+vec3(0.,1.,1.));\nfloat h = noise(f+vec3(1.,1.,1.));\n\nfloat m1 =  mix(mix(a,b,i.x),mix(c,d,i.x),i.y);\nfloat m2 =  mix(mix(e,f2,i.x),mix(g,h,i.x),i.y);\nreturn mix(m1,m2,i.z);\n}\n\nfloat fbm2(vec3 uv){\nreturn noise2(uv)*0.5+noise2(uv*2.0)*0.25+noise2(uv*4.)*0.125+noise2(uv*8.)*0.0625;\n}\nfloat fbm(vec3 uv){\nreturn cyclicNoise(uv+cyclicNoise(uv));;\n}\n\n\nfloat Tr(float densityMultiplier, float collectedDensity){\nreturn exp(-collectedDensity*densityMultiplier);\n}\n\nfloat Powder(float densityMultiplier, float collectedDensity){\nreturn 1.0 - exp(-collectedDensity*densityMultiplier*2.0);\n}\n\nfloat phase(float r, float wave){\nreturn (2.0*3.14159*r)/wave;\n}\n\nfloat RayleighPhase(float theta){\nfloat a = 0.0596831036595;\nfloat b = (1.+theta*theta);\nreturn a*b;\n}\n\nfloat HenyeyGreensteinPhase(float g, float theta){\nfloat a = 1.0 - g*g;\nfloat b = 12.5663706144*pow(1.0+g*g-2.*g*theta,1.5);\nreturn a/b;\n}\n\nfloat SchlickApproximationPhase(float g, float theta){\nfloat k = 1.55*g-0.55*g*g*g;\nfloat a = 1.0 - k*k;\nfloat sub = 1.0 + k*theta;\nfloat b = 12.5663706144*sub*sub;\nreturn -(a/b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n   \n    \n    vec2 uv = fragCoord/iResolution.xy;\n     \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    vec3 lig = normalize(vec3(0.2,1.,1.));\n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, mouse.x*90.);\n   \n   vec2 ps = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    ps.x *= iResolution.x/iResolution.y;\n   \n   \n    vec3 p = vec3(0.,iTime*0.4,0.);\n    //vec3 col = sky(d, lig);\n    vec3 col = vec3(0.1,0.05,0.01);\n    const int iter = 183;\n    float shadow_dist = 50.;\n    float ss = 1.0/float(shadow_dist);\n    float trans = 1.;\n    float trans2 = 1.;\n    vec3 c;\n    vec3 normal;\n   \n    float accumdist = 0.;\n    float curdensity = 0.;\n    float transmittance = 1.;\n    vec3 tryTr = vec3(0.);\n    //float shadowstepsize = 1. / float(iter);\n\n    float density = 1.0;\n    //density *= ss;\n    vec3 lightenergy = vec3(0.);\n    vec3 lightpowder = vec3(0.);\n    float ShadowDensity = 3.0;\n    float PowderDensity = 6.0;\n    vec3 hitpos;\n   \n    float hm = HenyeyGreensteinPhase(0.5, dot(d,lig));\n    float rm;\n    float org;\n   \n    float minus = 0.5;\n    float mult = 2.2;\n   \n    //p+=d*2.;\n    float t1;\n    float t2;\n    // intersect2(vec3 p, vec3 d, vec3 sp, float w)\n   //ec2 i = rayBoxDst(vec3(0.,0.,0.2)-vec3(3.,3.,2.1), vec3(0.,0.,0.2)+vec3(3.,3.,2.), p, vec3(1.0)/d);\n   // if(i.x < i.y){\n         //vec3 end = p+d*i.y;\n        // p = vec3(0.);\n        // p.zx = rot(p.zx, iTime);\n        p.y += 16.2;\n        vec3 keeptrack = p;\n         bool hit_volume = false;\n         for(int i = 0; i < iter; i++){\n             float nos = fbm(p*mult);\n             if((nos - minus) > 0.01 && length(keeptrack-p) > 1.){\n               if(!hit_volume){\n                 // normal = normalize(nos.yzw);\n                  hit_volume = true;\n                  hitpos = p;\n                  org = max(nos-minus,0.);\n               }\n               \n               vec3 lpos = p;\n               float shadowdist = 0.;\n     \n               for (int s = 0; s < 5; s++)\n               {\n                  float lsample = fbm(lpos*mult)-minus;  \n                  shadowdist += max(lsample, 0.);\n                  lpos += lig*ss;\n               }\n               \n               transmittance += max(nos-minus,0.);\n               trans *= 1.0 - (max(nos-minus,0.));\n               lightenergy += vec3(Tr(0.5*ShadowDensity, shadowdist)\n               ,Tr(1.*ShadowDensity, shadowdist),\n               Tr(2.*ShadowDensity, shadowdist))*trans*max(nos-minus,0.);\n               lightpowder += vec3(Powder(0.5*PowderDensity, shadowdist)\n               ,Powder(1.*PowderDensity, shadowdist),\n               Powder(2.*PowderDensity, shadowdist))*trans*max(nos-minus,0.);\n               //lightenergy*=hm;\n               float g = abs(sin(iTime));\n               //hm += ;\n               //rm += RayleighPhase(dot(d,lig));\n             }\n             p+=d*ss;\n            // d = mix(normalize(randomHemisphereDirection(d,seed)), d, 0.99);\n             \n         }\n         tryTr = vec3(Tr(0.5, transmittance),\n         Tr(1., transmittance),\n         Tr(2., transmittance));\n         if(transmittance != 1.){\n         col = col*trans + lightenergy*lightpowder*3.;\n         }\n  //  }\n   \n   // col = ACESFilm(col);\n   // col = pow(col, vec3(1./1.4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 48, 48, 220], [243, 243, 300, 350, 662]], "test": "untested"}
{"id": "tt3yR2", "name": "Pixel Art Aesthetics", "author": "ChrisK", "description": "Attempting to render 3d geometry in the style of hand-drawn pixel art.\n\nRotate the shapes with the mouse.", "tags": ["3d", "retro", "pixelart"], "likes": 95, "viewed": 2919, "published": 3, "date": "1616630251", "time_retrieved": "2024-07-30T19:30:43.619521", "image_code": "// CRT EFFECTS HAPPEN HERE\n\n// this code is mostly reused from https://www.shadertoy.com/view/MdyyWt\n\n//toggle CRT effects with these\n   #define SCANLINES\n   #define SHADOW_MASK\n   //#define SCREEN_SHAPE\n   //#define LIGHT_EFFECTS\n\n#define SCREEN_CURVE_RADIUS\t\t5.0\n#define SCREEN_CORNER_RADIUS\t0.1\n#define BRIGHTNESS      \t\t1.5\n#define PIXEL_SHARPNESS   \t\t2.0\n#define LINE_SHARPNESS\t\t\t6.0\n#define MASK_STRENGTH\t\t\t0.15\n\n\n#define gaussian(a,b)\texp2((a)*(a)*-(b))\n\n\nvec2 curveScreen( vec2 uv ) {\n    float r = 3.14159265*0.5/SCREEN_CURVE_RADIUS;\n    float d = 1.0-cos(uv.x*r)*cos(uv.y*r);\t\t//distance to screen\n    float s = cos(r);\t\t\t\t\t\t\t//scale factor to re-fit window\n    return uv / (1.0-d) * s;\n}\n\n\nfloat discardCorners( vec2 pos ) {\n    pos = abs(pos);\n    pos.x = pos.x*1.333-0.333;\t\t\t\t\t\t\t\t\t\t\t// 4:3 aspect ratio correction\n    if( min(pos.x, pos.y) < 1.0-SCREEN_CORNER_RADIUS ) return 1.0;\t\t// not near corner -- break early\n    float d = distance( pos, vec2(1.0-SCREEN_CORNER_RADIUS) );\n    return float( d<SCREEN_CORNER_RADIUS );\n}\n\n\nvec3 getSample( vec2 pos, vec2 off ) {\n\t//get nearest emulated sample\n\tvec2 ir = IRES * TILES;\n    pos = floor(pos*ir) + vec2(0.5) + off;\n\tvec3 col = vec3(0.0);\n\tif ( pos.x>=0.0 && pos.x<=ir.x*2.0 && pos.y>=0.0 && pos.y<=ir.y ) {\n        col = texelFetch( iChannel0, ivec2(pos), 0).rgb;\n        col = pow( ( (col + 0.055) / 1.055), vec3(2.4) );\t\t// SRGB => linear\n\t}\n\treturn col;\n}\n\n\nvec3 getScanline( vec2 pos, float off ) {\n\t// 3-tap gaussian filter to get colour at arbitrary point along scanline\n    vec2 ir = IRES * TILES;\n    float d = 0.5-fract(pos.x*ir.x);\n\tvec3 ca = getSample( pos, vec2(-1.0, off ) );\n\tvec3 cb = getSample( pos, vec2( 0.0, off ) );\n\tvec3 cc = getSample( pos, vec2( 1.0, off ) );\n\tfloat wa = gaussian( d-1.0, PIXEL_SHARPNESS );\n\tfloat wb = gaussian( d,     PIXEL_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, PIXEL_SHARPNESS );\n\treturn ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);\n}\n\n\nvec3 getScreenColour( vec2 pos ) {\n\t//Get influence of 3 nearest scanlines\n    vec2 ir = IRES * TILES;\n    float d = 0.5-fract(pos.y*ir.y);\n\tvec3 ca = getScanline( pos,-1.0 );\n\tvec3 cb = getScanline( pos, 0.0 );\n\tvec3 cc = getScanline( pos, 1.0 );\n    float wa = gaussian( d-1.0, LINE_SHARPNESS );\n\tfloat wb = gaussian( d,     LINE_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, LINE_SHARPNESS );\n    return ( ca*wa + cb*wb + cc*wc );\n}\n\n\nvec3 SlotMask_PixelPerfect( vec2 pos ) {\n    //pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    pos /= 1.0 + floor( iResolution.y / (IRES.y*15.0) );\n    float glow = 0.5;\n    float f = mod(pos.x,3.0);\n    vec3 col = vec3( (f<=1.0), (f>1.0&&f<=2.0), (f>2.0) );\n    col += vec3( (f<1.5 || f>=2.5), (f>0.5 && f<=2.5), (f>1.5 || f<=0.5) ) * glow;\n    col *= ( mod(pos.y+(fract(pos.x/6.0)>0.5?1.5:0.0),3.0)<1.0 ) ? glow : 1.0;\n    col /= 1.0+glow;\n    return col;\n}\n\n\nvec3 ACESFilm( vec3 x ) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord / iResolution.xy;\n   \tpos = pos*2.0 - 1.0;\n    pos.x *= iResolution.x/iResolution.y*(IRES.y/IRES.x);\t\t\t\t\t\t// 4:3 aspect\n    \n    #ifdef SCREEN_SHAPE\n    pos = curveScreen(pos);\t\t\t\t\t\t\t\t\t\t\t// curve screen\n    #endif\n    \n    if(max( abs(pos.x), abs(pos.y) )<1.0) {\t\t\t\t\t\t\t// skip everything if we're beyond the screen edge\n    \t\n        vec3 col = vec3(1.0);\n        \n        #ifdef SCREEN_SHAPE\n        col *= discardCorners(pos);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n        col *= 1.0 - sqrt(length(pos)*0.25);\t\t\t\t\t\t// vignette\n        #endif\n        \n        pos = pos*0.5 + 0.5;\n\n        #ifdef SCANLINES\n\t\tcol *= getScreenColour( pos );\n        #else\n        col *= getSample( pos, vec2(0.0) );\n        #endif\n        \n        #ifdef SHADOW_MASK\n        vec3 shadowmask = SlotMask_PixelPerfect( fragCoord );\n        col *= mix( vec3(1.0-MASK_STRENGTH), vec3(1.0+MASK_STRENGTH), shadowmask);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n\t\tcol *= BRIGHTNESS;\n    \tcol = ACESFilm(col);\n        #endif\n    \n    \tcol = pow( col, vec3(1.0/2.4) ) * 1.055 - 0.055;\t\t\t// linear => SRGB\n    \n    \tfragColor = vec4( col, 1.0 );\n    }\n    \n    //fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// 3D CALCULATIONS HAPPEN HERE\n\n// shapes are generated using simplified versions of\n// the functions described by Inigo Quilez in this article:\n// https://iquilezles.org/articles/intersectors \n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nint shape = 0;\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat IntersectUnitCube ( vec3 ro, vec3 rd ) {\n    vec3 tmin = (0.5-ro)/rd;\t\t\t\t\t\t\t// distances to positive planes\n    vec3 tmax = (-0.5-ro)/rd;\t\t\t\t\t\t\t// distances to negative planes\n    vec3 rmin = min(tmin, tmax);\t\t\t\t\t\t// distances to front-facing planes\n    vec3 rmax = max(tmin, tmax);\t\t\t\t\t\t// distances to back-facing planes\n    float dback  = min( min(rmax.x, rmax.y), rmax.z );\t// distance to nearest back-facing side\n    float dfront = max( max(rmin.x, rmin.y), rmin.z );\t// distance to furthest front-facing side (possible collision distance)\n    return dback>=dfront ? dfront : -dfront;\n}\n\n\nfloat IntersectSphere ( vec3 ro, vec3 rd, float rad ) {\n    float b = dot(ro,rd);\n    float h = b*b - dot(ro,ro) + rad*rad;\n    return (h<0.0) ? -1.0 : -b-sqrt(h);   // -b+sqrt(h) = backface distance\n}\n\n\nfloat IntersectXUnitCylinder ( vec3 ro, vec3 rd, float rad ) {\n    vec3 oc = ro + vec3(0.5,0.0,0.0);\n    float a = 1.0 - rd.x*rd.x;\n    float b = dot(oc,rd) - oc.x*rd.x;\n    float c = oc.y*oc.y + oc.z*oc.z - rad*rad;\n    float h = b*b - a*c;\n    if( h<0.0 ) return -1.0;              // miss\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    float y = oc.x + t*rd.x;\n    if( y>0.0 && y<1.0 ) return t;        // body hit?\n    t = (float(y>=0.0) - oc.x)/rd.x;\n    return ( abs(b+a*t)<h ) ? t : -1.0;   // cap hit?\n}\n\n\nfloat IntersectCone( vec3 ro, vec3 rd, float h, float r ) {\n    vec3  oa = ro - vec3(0.0, h*0.5, 0.0);\n    float m0 = h*h;\n    float m1 = oa.y*-h;\n    float m2 = rd.y*-h;\n    if( m1<0.0 && dot(oa*m2-rd*m1, oa*m2-rd*m1)<(r*r*m2*m2) ) return -m1/m2;  // cap hit?\n    float hy = m0 + r*r;\n    float k2 = m0*m0            - m2*m2*hy;\n    float k1 = m0*m0*dot(rd,oa) - m1*m2*hy + m0*r*r* m2;\n    float k0 = m0*m0*dot(oa,oa) - m1*m1*hy + m0*r*r*(m1*2.0 - m0);\n    float t = ( -k1-sqrt(k1*k1 - k2*k0) ) / k2;\n    float y = m1 + t*m2;\n    return ( y>=0.0 && y<=m0 ) ? t : -1.0;   // body hit?\n}\n\n\nvec4 getrendersample ( vec3 ro, vec3 rd ) {\n    float rl;\n    switch(shape) {\n    case 0:\n        rl = IntersectUnitCube( ro, rd );\n        break;\n    case 1:\n        rl = IntersectSphere( ro, rd, 0.6 );\n        break;\n    case 2:\n        rl = IntersectXUnitCylinder( ro, rd, 0.6 );\n        break;\n    case 3:\n        rl = IntersectCone( ro, rd, 1.2, 0.6 );\n        break;\n    }\n    \n    if ( rl > 0.0 ) {\n\t\tvec3 xyz = ro + rd*rl;\n        \n        vec3 nor;                 // surface normal\n        float dith = 0.0;         // how much lighting is dithered across surface\n        switch(shape) {\n        case 0: // unit cube\n            nor = round( xyz*1.00001 );\n            break;\n        case 1: // sphere\n            nor = normalize(xyz); dith = 0.35;       \n            break;\n        case 2: // unit length x-cylinder\n            if (abs(xyz.x)>0.4999) { nor = vec3(0.0,0.0,sign(xyz.x)); } else { nor = vec3(0.0,normalize(xyz.yz)); dith = 0.35; }\n            break;\n        case 3: // cone (h=1.2, r=0.6)\n            if (abs(xyz.y)>0.5999) { nor = vec3(0.0,sign(xyz.y),0.0); } else { nor = normalize(vec3(xyz.x,-(length(xyz.xz)/2.0),xyz.z)); dith = 0.35; }\n            break;\n        }\n        \n        // material ID\n        float mat = (xyz.x>0.0 ^^ xyz.y>0.0 ^^ xyz.z>0.0) ? 1.0 : 2.0;\n        \n        // lambertian diffuse\n        vec3 ld = normalize( vec3(1,2,1) );\n        float br = max( dot(-ld,nor), 0.0);\n        \n        // phong specular\n        float spec = 0.0;\n        if (br>0.0) {\n            vec3 h = -normalize(ld+rd);\n            spec = pow( dot(nor,h), 500.0);\n        }\n        \n        // depth\n        float depth = rotate(xyz, -vec3(iTime*0.5)).z + 5.0;\n        \n        return vec4( mat, br, dith, spec );\n    } else {\n        return vec4( 0.0 );\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/IRES;\n    uv = uv*2.0 - 1.0;\n\n    vec2 tile = floor( (uv+1.0)*0.5 );\n    shape = int( floor( mod(tile.x,2.0) )\n               + floor( mod(tile.y,2.0) ) * 2.0 );\n\n    uv = mod( uv+1.0, vec2(2.0) ) - 1.0;\n    uv.y *= IRES.y/IRES.x;\n    \n    //vec3 r = vec3(iTime*0.5);\n    vec3 r = vec3( -iMouse.yx/iResolution.yx*7.0, 0.0 ); \n    \n    vec3 campos = vec3(0.0,0.0,-2.5);\n    vec3 camray = normalize( vec3(uv,1.35) );\n    campos = rotate( campos, r );\n    camray = rotate( camray, r );\n     \n    fragColor = getrendersample( campos, camray );\n}", "buffer_a_inputs": [], "common_code": "//#define IRES vec2(120, 120)\n#define IRES (vec2(16, 9)*5.0)\n\n#define TILES 2.0", "buffer_b_code": "// CONVERTING 3D DATA TO 'PIXEL ART' HAPPENS HERE\n\n// Just dropping the resolution and crushing the colour data would be simple, but making it\n// appear 'hand-made' presents a few challenges. I'm attempting to roughly translate my\n// thought process when drawing pixel art into code here, so I targeted the following goals:\n\n// 1) NICE, HAND-PICKED COLOURS\n// I think a lot of the aesthetic appeal in pixel art (and the fun in making it) comes from\n// getting a lot out of very little, so the smaller the palette is, the better. I'm using a\n// hand-picked palette of 9 colours here. These colours mostly make up two gradients, which\n// correspond to the orange and blue materials at different levels of brightness. Both\n// gradients use the same dark outline and specular highlight colours, for simplicity.\n\n// 2) AESTHETICALLY APPEALING BALANCE OF FLATNESS AND DETAIL\n// Lighting gradients across flat surfaces are rare in pixel art, even when they are physically\n// accurate. For this reason, I differentiate between flat and curved surfaces. The diffuse\n// lighting on curved surfaces is dithered with a bayer matrix, but flat surfaces are left\n// perfectly flat, with no lighting variation from one side to another. On objects with more\n// texture it would be better to replace the bayer matrix with a pattern that better described\n// the surface, or maybe a normal map (so that the surface details rotate with the geometry).\n\n// 3) USING DARK OUTLINES TO CLEARLY SEPERATE 'SPRITES' FROM 'BACKGROUND'\n// Self-explanatory. On the highlighted sides of the objects, these outlines are coloured to\n// match the object material, for a bit of extra visual interest. They are also anti-aliased,\n// but very approximately, based off of a set of intuitive rules rather than anything with\n// any physical accuracy. For more complicated 'sprites' with overlapping geometry, it would\n// also be desirable to have some internal outlines seperating ovelapping elements.\n\n// I think these three things go a long way toward achieving the pixel art look, at least in\n// this very simple case.\n\n\n#define SPEC_DITHER   0.01\n\n#define BG_COL        vec3( 0.6, 0.8, 0.8 )\n#define OUTLINE       vec3( 0.2, 0.0, 0.1 )\n#define HIGHLIGHT     vec3( 1.0, 1.0, 0.8 )\n\n\nconst vec3 palette_a[5] = vec3[5](OUTLINE,\n                                  vec3( 0.6, 0.0, 0.3 ),\n                                  vec3( 1.0, 0.2, 0.1 ),\n                                  vec3( 1.0, 0.7, 0.2 ),\n                                  HIGHLIGHT );\n                            \nconst vec3 palette_b[5] = vec3[5](OUTLINE,\n                                  vec3( 0.0, 0.2, 0.5 ),\n                                  vec3( 0.1, 0.5, 0.7 ),\n                                  vec3( 0.2, 0.7, 1.0 ),\n                                  HIGHLIGHT );\n\nconst mat4 bayer = mat4( 0,  8,  2, 10,\n  \t\t\t\t\t\t12,  4, 14,  6,\n   \t\t\t\t\t\t 3, 11,  1,  9,\n   \t\t\t\t\t\t15,  7, 13,  5)/16.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fc = fragCoord.xy;\n\n    vec4 shape = texelFetch(iChannel0,ivec2(fc),0);\n    vec4 n = texelFetch(iChannel0,ivec2(fc)+ivec2(0,1),0);\n    vec4 s = texelFetch(iChannel0,ivec2(fc)-ivec2(0,1),0);\n    vec4 e = texelFetch(iChannel0,ivec2(fc)+ivec2(1,0),0);\n    vec4 w = texelFetch(iChannel0,ivec2(fc)-ivec2(1,0),0);\n    \n    int neighbours      = int(n.x>0.0) + int(s.x>0.0) + int(e.x>0.0) + int(w.x>0.0);\n    int lightneighbours = int(n.y>0.0) + int(s.y>0.0) + int(e.y>0.0) + int(w.y>0.0);\n    \n    vec3 col = BG_COL;\n    int br = -1;\n    \n    if( shape.x <= 0.0 ) {\n        // background stripes\n        if( sin((fc.x+fc.y)/5.0+iTime*5.0)>0.0 ) col = HIGHLIGHT;\n    \n        // outlines\n        if (neighbours > 0) {\n            shape.x = max( max(n.x,s.x), max(e.x,w.x) );\n            br = ( lightneighbours == neighbours ) ? 1 : 0;\n            \n            //when bordering brightest areas:\n            if ( max(max(n.y,s.y),max(e.y,w.y)) > 0.5 ) {\n                // search diagonals -- if 2/8 or fewer neighbours are occupied, then lighten 1 step more\n                // together with a darkened pixel inside the shape, this will improve the AA on the line\n                vec4 ne = texelFetch(iChannel0,ivec2(fc)+ivec2( 1, 1),0);\n                vec4 nw = texelFetch(iChannel0,ivec2(fc)+ivec2( 1,-1),0);\n                vec4 se = texelFetch(iChannel0,ivec2(fc)+ivec2(-1, 1),0);\n                vec4 sw = texelFetch(iChannel0,ivec2(fc)+ivec2(-1,-1),0);\n                neighbours += int(ne.x>0.0) + int(nw.x>0.0) + int(se.x>0.0) + int(sw.x>0.0);\n                if (neighbours<=2) br++;\n            }\n        }\n    } else {\n        ivec2 buv = ivec2( mod( fc, 4.0 ) );\n        float ba = bayer[buv.x][buv.y];\n    \n        // face shading\n        shape.y -= ba*shape.z;\n        //br = int(shape.y) + 1;\n        \n        br = int( ceil( shape.y*2.0 ) ) + 1;\n        \n        // specular highlight\n        if (shape.w-ba*SPEC_DITHER > 0.001 ) br++;\n        if (shape.w-ba*SPEC_DITHER*2.0 > 0.001 ) br++;\n        br = min(br,4);\n        \n        // darken to approximate anti-aliasing on edges of bright area\n        if ( br>=3 && lightneighbours<=2 ) br--;\n    }\n    \n    if ( br >= 0 ) {\n        col = (shape.x>1.5) ? palette_b[br] : palette_a[br];\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 463, 492, 492, 698], [701, 701, 735, 735, 1038], [1041, 1041, 1079, 1110, 1422], [1425, 1425, 1466, 1540, 1941], [1944, 1944, 1978, 2018, 2375], [2378, 2378, 2418, 2470, 2839], [2842, 2842, 2867, 2867, 2947], [2950, 2950, 3007, 3007, 4249]], "test": "untested"}
{"id": "ldsXWH", "name": "solarDance [mod1]", "author": "entropynine", "description": "modified version from trisomie21", "tags": ["audio", "solar"], "likes": 3, "viewed": 374, "published": 3, "date": "1616627556", "time_retrieved": "2024-07-30T19:30:44.390459", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// modified only for learning fun\n\nfloat snoise(vec3 uv, float res)\t// code modded from trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.5*sin(iTime) ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5*sin(iTime), 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5*sin(iTime);\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 18707, "src": "https://soundcloud.com/callmemano/zeitgeist", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 177, 177, 703], [722, 722, 779, 779, 3270]], "test": "untested"}
{"id": "7dfGWX", "name": "Liney", "author": "Daizuukee", "description": "just some lines, might make them more pog later", "tags": ["lines"], "likes": 9, "viewed": 395, "published": 3, "date": "1616627448", "time_retrieved": "2024-07-30T19:30:45.162396", "image_code": "#define PI 3.141592653589793\nfloat PHI=1.61803398874989484820459;//  = Golden Ratio\n\nfloat random(in vec2 xy,in float seed){\n    float f=length(fract((cross((cross(fract(xy.yxy*PHI*seed)+seed,fract(xy.xyx/seed)+seed)*PHI),vec3(5./PHI,7./PHI,3./PHI)))));\n    return fract(f*seed);\n}\n\nfloat noise(vec2 st){\n    vec2 st0=floor(st);\n    vec2 st1=.5-cos((st-st0)*PI)*.5;\n    float a0=random(vec2(int(st0.x),int(st0.y)),1.);\n    float a1=random(vec2(int(st0.x)+1,int(st0.y)),1.);\n    \n    float a2=random(vec2(int(st0.x),int(st0.y)+1),1.);\n    float a3=random(vec2(int(st0.x)+1,int(st0.y)+1),1.);\n    \n    float b0=(a1-a0)*st1.x+a0;\n    \n    float b1=(a3-a2)*st1.x+a2;\n    return(b1-b0)*st1.y+b0;\n}\n\nfloat LineHeight(vec2 uv){\n    return noise(uv);\n}\n#define lines 20.\n#define height 0.5\n#define edges 0.1\n#define horizontalEdges 0.05\n\nbool HitsLines(vec2 uv,float vOffset){\n    if(uv.x < horizontalEdges || uv.x > 1.-horizontalEdges)\n        return false;\n    uv.x = uv.x * (1.-horizontalEdges*2.) + horizontalEdges;\n    for(float i=lines;i >= 0.;i--){\n        vec2 nuv = uv + vec2(0,((i + 0.5)/(lines)-1.) * (1.-edges*2.) - edges);\n        vec2 check = vec2(uv.x* 20. + iTime * (abs(lines/2.-i) * -0.25 + 1.125),i * 10.);\n        float h = (LineHeight(check + vec2(0,vOffset))-0.5) * height * (1.-pow(abs(2.*(uv.x - 0.5)) + 0.15,0.25));\n        if(h > nuv.y)\n            return false;\n        if(h < nuv.y && h > nuv.y - 0.004)\n            return true;\n    }\n    return false;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    float r = (HitsLines(fragCoord/iResolution.xy, 0.25))?0.5:0.;\n    float g = (HitsLines(fragCoord/iResolution.xy, -0.25))?0.5:0.;\n    float b = (HitsLines(fragCoord/iResolution.xy, -0.5))?0.5:0.;\n    fragColor=(HitsLines(fragCoord/iResolution.xy,0.))?vec4(1,1,1,1):vec4(r,g,b,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 126, 126, 283], [285, 285, 306, 306, 694], [696, 696, 722, 722, 746], [832, 832, 870, 870, 1476], [1477, 1477, 1530, 1530, 1815]], "test": "untested"}
{"id": "fdXGDf", "name": "goku v3", "author": "jorge2017a1", "description": "goku v3", "tags": ["gokuv3"], "likes": 3, "viewed": 336, "published": 3, "date": "1616621063", "time_retrieved": "2024-07-30T19:30:45.936326", "image_code": "//por jorge2017a1 ----jorgeFloresP\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly11 POLY(11)\nfloat sdPoly28 POLY(28)\nfloat sdPoly17 POLY(17)\nfloat sdPoly09 POLY(9)\nfloat sdPoly25 POLY(25)\n\n\nvec2 pt25[ 25]=vec2[](  \nvec2(.52,.01),vec2(.21,.14),vec2(.29,.17),vec2(.12,.34),vec2(.26,.34),\nvec2(.12,.54),vec2(.09,.58),vec2(.05,.61),vec2(.01,.64),vec2(.04,.67),\nvec2(.11,.70),vec2(.17,.71),vec2(.21,.71),vec2(.25,.69),vec2(.31,.65),\nvec2(.27,.82),vec2(.26,.86),vec2(.22,.95),vec2(.19,1.00),vec2(.26,1.00),\nvec2(.35,.98),vec2(.44,.93),vec2(.49,.86),vec2(.55,.72),vec2(.52,.01) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.53,.03),vec2(.82,.08),vec2(.76,.13),vec2(.91,.19),vec2(.80,.23),\nvec2(.97,.37),vec2(.92,.41),vec2(.88,.43),vec2(.84,.44),vec2(.98,.59),\nvec2(.91,.60),vec2(.82,.60),vec2(.73,.58),vec2(.55,.72),vec2(.53,.03) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.38,.11),vec2(.35,.29),vec2(.32,.53),vec2(.53,.61),vec2(.73,.50),\nvec2(.67,.12),vec2(.66,.10),vec2(.62,.06),vec2(.56,.02),vec2(.55,.01),\nvec2(.52,.00),vec2(.48,.02),vec2(.43,.05),vec2(.39,.09),vec2(.38,.11) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.35,.29),vec2(.37,.27),vec2(.36,.34),vec2(.39,.32),vec2(.38,.42),\nvec2(.38,.45),vec2(.41,.50),vec2(.42,.41),vec2(.42,.38),vec2(.44,.33),\nvec2(.45,.39),vec2(.46,.44),vec2(.47,.47),vec2(.51,.52),vec2(.55,.56),\nvec2(.53,.61),vec2(.32,.53),vec2(.35,.29) );\n\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.70,.28),vec2(.68,.26),vec2(.69,.33),vec2(.66,.30),vec2(.67,.35),\nvec2(.68,.40),vec2(.68,.45),vec2(.67,.48),vec2(.66,.45),vec2(.65,.42),\nvec2(.62,.38),vec2(.59,.35),vec2(.59,.39),vec2(.59,.45),vec2(.58,.50),\nvec2(.57,.53),vec2(.55,.56),vec2(.53,.61),vec2(.73,.50),vec2(.70,.28) );\n\n\n//float sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.38,.12),vec2(.36,.12),vec2(.34,.14),vec2(.31,.18),vec2(.31,.19),\nvec2(.31,.27),vec2(.31,.30),vec2(.32,.30),vec2(.34,.29),vec2(.35,.28),\nvec2(.38,.12) );\n\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.67,.12),vec2(.69,.12),vec2(.71,.13),vec2(.74,.18),vec2(.74,.18),\nvec2(.75,.22),vec2(.75,.26),vec2(.75,.29),vec2(.74,.30),vec2(.73,.31),\nvec2(.70,.28),vec2(.67,.12) );\n\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.41,.40),vec2(.39,.42),vec2(.41,.46),vec2(.42,.46),vec2(.44,.47),\nvec2(.47,.46),vec2(.47,.44),vec2(.49,.40),vec2(.48,.40),vec2(.47,.43),\nvec2(.45,.44),vec2(.43,.44),vec2(.41,.40) );\n\n\n//float sdPoly13 POLY(13)\nvec2 pt13b[ 13]=vec2[](  \nvec2(.56,.41),vec2(.58,.44),vec2(.59,.45),vec2(.61,.47),vec2(.64,.46),\nvec2(.65,.44),vec2(.67,.42),vec2(.65,.39),vec2(.64,.42),vec2(.62,.43),\nvec2(.61,.43),vec2(.59,.42),vec2(.56,.41) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.40,.18),vec2(.39,.23),vec2(.39,.24),vec2(.39,.28),vec2(.40,.31),\nvec2(.42,.34),vec2(.43,.35),vec2(.45,.35),vec2(.46,.34),vec2(.48,.32),\nvec2(.49,.28),vec2(.49,.20),vec2(.46,.18),vec2(.40,.18) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15c[ 15]=vec2[](  \nvec2(.57,.19),vec2(.56,.22),vec2(.56,.25),vec2(.56,.28),vec2(.57,.31),\nvec2(.58,.33),vec2(.60,.34),vec2(.62,.35),vec2(.64,.34),vec2(.65,.30),\nvec2(.65,.26),vec2(.64,.19),vec2(.62,.19),vec2(.59,.18),vec2(.57,.19) );\n\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.51,.15),vec2(.51,.16),vec2(.52,.18),vec2(.52,.16),vec2(.52,.16),\nvec2(.51,.15) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.48,.13),vec2(.51,.12),vec2(.53,.12),vec2(.55,.13),vec2(.58,.15),\nvec2(.55,.13),vec2(.52,.12),vec2(.51,.12),vec2(.48,.13) );\n\n\n\nvec3 RostroGoku(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  float sd1 = sdPoly25(p-vec2(0.0,-0.2), pt25);\n  float sd2 = sdPoly15(p-vec2(0.0,-0.2), pt15);\n  float sd3 = sdPoly15(p-vec2(0.0,-0.2), pt15b);\n  float sd4 = sdPoly18(p-vec2(0.0,-0.2), pt18);\n  float sd5 = sdPoly20(p-vec2(0.0,-0.2), pt20);\n  float sd6 = sdPoly11(p-vec2(0.0,-0.2), pt11); //orejas izq\n  float sd7 = sdPoly12(p-vec2(0.0,-0.2), pt12); //orejas der\n  float sd8 = sdPoly13(p-vec2(0.0,-0.2), pt13); //ceja izq\n  float sd9 = sdPoly13(p-vec2(0.0,-0.2), pt13b); //ceja der\n  float sd10 = sdPoly14(p-vec2(0.0,-0.2), pt14);\n  float sd11 = sdPoly15(p-vec2(0.0,-0.2), pt15c);\n  //nariz\n  float sd12 = sdPoly6(p-vec2(0.0,-0.2), pt6);\n  float sd13 = sdPoly9(p-vec2(0.0,-0.2), pt9);\n  float ojo1= sdCircle(  p-vec2(0.44+0.03*sin(iTime),0.05), 0.022 );\n  float ojo2= sdCircle(  p-vec2(0.59+0.03*sin(iTime),0.05), 0.022 );\n  \n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd1,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd2,0.0));\n  col = mix(col,vec3(0.98, 0.82,0.720),S(sd3,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd4,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd5,0.0));\n  //orejas\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd6,0.0));\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd7,0.0));\n  //cejas\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd8,0.0));\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd9,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd10,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd11,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd12,0.0));\n  //boca\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd13,0.0));\n  //ojos\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo1,0.0));\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo2,0.0));\n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.7);\n    // escala\n    p.x*=0.7;\n    p*=0.5+1.0*abs(sin(iTime*0.35));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     col= RostroGoku( p,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "//modificado por jorge flores p.  -24-mar-2020\n\n//Created by nabr in 2019-06-05\n// https://www.shadertoy.com/view/WlSGWw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\nvec2 synthv2( float t)\n{\n// --------- SYNTH\n    int t1=int(t) % 4;\n    vec2 valor=mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1];\n    \n\tvec2 s = sin(t * mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1]) - .5;\n    vec2 s2 = tan(t * valor)*tan(t * valor)+ 1.0;\n    \n\tif(t<6.) // intro\n    {\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n        s+=s2;\n    }\n\telse \n    {\n\n        s *=  sin(s * mod(t*0.5, 8.) * 16.) ;\n        s=s*s2;\n    }   \n    return s;\n}\n   \nvec2 m(float t)\n{\n    vec2 s= synthv2( t);\n\t// --------- DRUMS(kick)\n    \n\tfloat tm = mod(t, .5);\n    float tm2 = mod(t, 1.8);\n    \n\tif(t<6.) tm = mod(t, 1.5); // intro\n\tfloat finetune = 1.8;\n    \n\t// kick\n\t\n    float k = (sin(80.0 * exp(-sin(tm * finetune) * 10.0)) * exp(-tm * 10.0));\n\tk *= cos(120.0 * exp(-tm * 2.0));\n    \n    // sub\n\tfloat kovt = (k - sin(tm * 580.) * exp(-tm * 1.5));\n\tkovt *= min(1., tm * 100.) * max(0., .5 - tm);\n\tkovt -= (.25 - asin(kovt * tm * 12.));\n\tk *= min(1., tm * 500.) * max(0., 1. - tm);\n\tk = 1.9 * (kovt + k);\n    \n    // -------- MASTER\n\treturn (k + .4 * s ) * .25;\n}\n\n//modificado por jorge flores p.  -24-mar-2020\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\nvec2 mainSound( in int samp,float time){return m(time);}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 395, 395, 417], [418, 418, 451, 451, 473], [474, 474, 507, 507, 528], [530, 568, 604, 604, 649], [650, 663, 700, 700, 773], [775, 775, 810, 810, 834], [836, 836, 870, 870, 963], [4839, 4839, 4879, 4879, 6514], [6515, 6515, 6572, 6572, 6878]], "test": "untested"}
{"id": "fsf3Wf", "name": "Fractal 46_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 512, "published": 3, "date": "1616620575", "time_retrieved": "2024-07-30T19:30:46.707265", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=.1*H(log(s)*.1+.2)*exp(-2.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,2.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        q=p;\n        s=4.;\n        for(int j=0;j++<6;s*=e)\n            p=sign(p)*(1.-abs(abs(p-2.)-1.)),\n            p=p*(e=6./clamp(dot(p,p),.1,3.))-q*vec3(2,8,1)-vec3(5,2,1);\n        g+=e=length(p)/s;\n    }\n    O.xyz=mix(O.xyz,dot(O.xyz,vec3(1))*vec3(1),.2);\n    O.xyz=min(O.xyz,.99);\n    O.xyz=pow(O.xyz,vec3(1,1,5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 754]], "test": "untested"}
{"id": "fsXGWf", "name": "persistence of vision POV5", "author": "FabriceNeyret2", "description": "NB: don't try bluenoise or other textures ;-)", "tags": ["persistenceofvision", "pov"], "likes": 4, "viewed": 336, "published": 3, "date": "1616616480", "time_retrieved": "2024-07-30T19:30:47.474214", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n // O -= O;\n    O = texelFetch(iChannel1, ivec2(U)%textureSize(iChannel1,0).x, 0 ).xxxx;\n    \n    if ( texture(iChannel0, U/R).x > .5 ) O = 1.-O;  // option 1\n // O = fract( O + texture(iChannel0, U/R).x );      // option 2\n\n\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 295]], "test": "untested"}
{"id": "NsXGWf", "name": "Next Level Raytracing", "author": "oneshade", "description": "Messing around with an idea I had. Instead of solving an equation, just create an intersection formula! Its rather unintuitive but you can get some cool looking stuff, plus its exact :P I'm not too happy how the shading turned out...", "tags": ["raytracing", "experiment", "idea"], "likes": 2, "viewed": 135, "published": 3, "date": "1616616242", "time_retrieved": "2024-07-30T19:30:48.246151", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 rd = normalize(vec3(uv, -1.0));\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n    vec4 center = texelFetch(iChannel0, iFragCoord, 0);\n    vec4 right = texelFetch(iChannel0, iFragCoord + ivec2(1, 0), 0);\n    vec4 up = texelFetch(iChannel0, iFragCoord + ivec2(0, 1), 0);\n\n    float diff = 1.0;\n    vec3 normal;\n    if (center[3] > 0.0 && right[3] > 0.0 && up[3] > 0.0) {\n        normal = normalize(vec3(right[3] - center[3], up[3] - center[3], 0.02));\n        diff = sqrt(max(0.0, dot(normal, -rd)));\n    }\n\n    fragColor.rgb = center.rgb * diff;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float iScene(in vec3 ro, in vec3 rd) {\n    return dot(cos(rd * 10.0), vec3(1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(iTime);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), -1.0);\n\n    float tScene = iScene(ro, rd);\n    if (tScene > 0.0) {\n        fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        fragColor[3] = tScene;\n    }\n\n    /*\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (tScene > 0.0 ? tPlane < tScene : true)) {\n            fragColor[3] = tPlane;\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n    */\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 716]], "test": "untested"}
{"id": "Nsf3DX", "name": "contrast blink perception", "author": "FabriceNeyret2", "description": "up to which column do you perceive random blinking ?  ~ 1/4\nleft = 0% contrast    right = 25% contrast\nNote that perception is very different when stopping the shader.\nAlso sensitive to proper monitor tunning.", "tags": ["perception"], "likes": 5, "viewed": 278, "published": 3, "date": "1616615920", "time_retrieved": "2024-07-30T19:30:49.009110", "image_code": "#define hash3(p) fract(sin(dot(p,vec3(127.1,311.7, 269.5)))*43758.5453123)\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = .25 * U/iResolution.x;\n    float h = hash3(vec3(U,iTime)) > .5 ? -1. : 1. ;\n    O = vec4( .5 + .5 * U.x * h );\n    \n    O = pow(O, vec4(1./2.2) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 115, 115, 272]], "test": "untested"}
{"id": "fsf3WX", "name": "3D Sierpinski ternary bits", "author": "FabriceNeyret2", "description": "3D Sierpinsky: outside if one of the ternary bits of location is 1 in at least 2 dimensions simultaneously.\nBut you can experiment other counts ;-)\n\nset OPAQUE to 0 for transparency ( costly ! )", "tags": ["sierpinski", "sierpinsky"], "likes": 14, "viewed": 368, "published": 3, "date": "1616612094", "time_retrieved": "2024-07-30T19:30:49.775063", "image_code": "// Fork of \"Sierpinsky ternary bits\" by FabriceNeyret2. https://shadertoy.com/view/NdX3WX\n\n#define OPAQUE 1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    vec2 R = iResolution.xy;\n    int i, z, n = int(log2(R.x));\n\n    vec2 t = .5 * vec2( cos(iTime), sin(iTime) );   // 3rd dim projection angle\n\n // z = iFrame % int(R.y); { \n    for ( z = 0; z <= int(R.y); z++ ) {             // slices along depth\n        ivec3 I =  ivec3 (U - t*float(z) , z ), F;  // I = 3D location\n        for ( i = 0; i <= n; i++, I/=3 ) {          // inspect ternary bits\n            F = 1-abs(I%3-1);                       // iseq(I,1)\n         // F = ivec3(equal( I%3, ivec3(1) ));      // iseq(I,1)\n            if ( F.x+F.y+F.z > 1 ) break;           // at least 2 bits at 1: exit\n          }\n#if OPAQUE\n        if ( i == n+1 ) {                           // in Sierpinsky\n            O += vec4( i == n+1 )*exp(-float(z)*4./R.y); // AO \n            break;\n        }\n#else\n        if ( i == n+1 )  O += vec4( i == n+1 );     // in Sierpinsky : optical depth++\n#endif\n    }\n  \n#if !OPAQUE\n    O = 1.-exp(-O/40.);                             // optical depth to opacity\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 147, 147, 1160]], "test": "untested"}
{"id": "fdf3D2", "name": "ray marching - v3", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 3, "viewed": 246, "published": 3, "date": "1616611398", "time_retrieved": "2024-07-30T19:30:50.551985", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.2\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(vec3(-1,0,-1));\nvec3 light2 = normalize(vec3(0.5,1,-0.9));\n\nfloat distance_to_wave_sphere_repeat(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(vec3(mod(ray.x+2.,2.)-1., ray.y, mod(ray.z+2.,2.)-1.), pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_plane(vec3 ray, vec3 pos, vec3 normal){\n    return dot(ray-pos, normal);\n}\n\nfloat distance_to_wave_plane(vec3 ray, vec3 pos, vec3 normal){\n    return dot(ray-pos, normal)+sin(ray.x*2.+iTime)*0.1 + cos(ray.z*4.+iTime)*0.1;\n}\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(ray, pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    /*float h = clamp( 0.5 + 0.5*(d2-d1)/s, 0.0, 1.0 );\n    return mix( d2, d1, h ) - s*h*(1.0-h);*/\n    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nvec4 smooth_min_color(vec4 c1, vec4 c2, float s){ // c_.w component is distance\n    float d1 = c1.w, d2 = c2.w;\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*c2 + (1.-t)*c1)/2.;\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float min_distance = MAX_STEP_SIZE;\n    \n    float size = .8;\n    float orbit = 1.6;\n    float k = SHAPE_BLEND;\n    \n    //float d = distance_to_wave_sphere_repeat(ray, vec3(0,-4,0), 1., 0.05, vec3(5.3,3.7,4.5), 1.9);\n    float d = distance_to_wave_plane(ray, vec3(0,-3,0), normalize(vec3(0,1,0)));\n    float d1 = distance_to_wave_sphere(ray, vec3(0,0,6), 1.5, 0.05, vec3(5.3,3.7,4.5), .9);\n    float d2 = distance_to_sphere(ray, vec3(orbit*sin(iTime*2.0), orbit*sin(iTime*0.8), 6.+orbit*sin(iTime*0.6)), size); \n    float d3 = distance_to_sphere(ray, vec3(orbit*sin(iTime*0.8), orbit*sin(iTime*0.6), 6.+orbit*sin(iTime*2.)), size); \n    float d4 = distance_to_sphere(ray, vec3(orbit*sin(iTime*0.1), orbit*sin(iTime*2.0), 6.+orbit*sin(iTime*0.4)), size); \n    //float d5 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.5), 2.*sin(iTime*2.1), 6.+2.*sin(iTime*0.7)), size);\n   \n    //min_distance = smooth_min(smooth_min(smooth_min(d1, d2, k), smooth_min(d3, d4, k), k), d5, k);\n    \n    // shape blending\n    min_distance = smooth_min(smooth_min(d1,d2,k), smooth_min(d3,d4,k), k);\n    min_distance = min(min_distance, d);\n    \n    \n    // color blending\n    float p = 0., q = 1., r = .5;\n    \n    vec4 c1 = vec4(.1,.1,.1, d1); // center ball\n    vec4 c2 = vec4(p,q,r, d2);\n    vec4 c3 = vec4(r,p,q, d3);\n    vec4 c4 = vec4(q,r,p, d4);\n    \n    k = COLOR_BLEND;\n    \n    color = smooth_min_color(smooth_min_color(c1,c2,k), smooth_min_color(c3,c4,k), k).xyz;\n    \n    shininess = 1.;\n    \n    if(d == min_distance){\n        color *= 0.4;\n        //color = vec3(.05,.05,.05);\n        shininess = 1.5;\n    }\n    \n    \n    return min_distance;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5;\n            color = bodyColor*l1 + bodyColor*l2 + (vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.))*shininess;\n            //color = vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.);\n            \n            // fog in the distance\n            color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.4,.9)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 465, 465, 693], [695, 695, 752, 752, 787], [789, 789, 851, 851, 936], [938, 938, 1043, 1043, 1221], [1223, 1223, 1277, 1277, 1314], [1316, 1316, 1365, 1466, 1543], [1545, 1545, 1594, 1624, 1728], [1730, 1730, 1797, 1797, 3439], [3441, 3441, 3471, 3471, 3550], [3552, 3552, 3574, 3574, 3936], [3938, 3938, 3963, 3963, 5166], [5168, 5168, 5225, 5260, 5505]], "test": "untested"}
{"id": "sds3Wj", "name": "ray marching - v4 (shadow)", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 0, "viewed": 225, "published": 3, "date": "1616611188", "time_retrieved": "2024-07-30T19:30:51.313948", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.2\n#define COLLISION_THRESHOLD 0.001\n#define MAX_STEP_SIZE 10000000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(-vec3(2,-5,-0.2));\n//vec3 light2 = normalize(vec3(0.5,-1,0.9));\nvec3 light2 = normalize(-vec3(-1,-1,5));\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float d = MAX_STEP_SIZE; // min safe distance\n\n    float d1 = box(rotate(ray-vec3(0,0,9), vec3(1,1,0), iTime), vec3(0.0,1.4,1.), 0.3);\n    float d2 = box(rotate(ray - vec3(5.+sin(iTime*.7)*0.5,sin(iTime*0.3)*.5+1.,9), vec3(-1,10,0),-0.5), vec3(1,2,1), 0.1);\n    float d3 = sphere(ray - vec3(-5,1,12), 4.) + smoothstep(1.,0.,sin(ray.y*5.+iTime))*.2;\n    float d4 = sphere(vec3(ray.x, ray.y*( 1.-(1.+sin(iTime*5.))*.04 ), ray.z) - vec3(3,2,20), 7.);\n    d1 = min(min(d1, d2), min(d3, d4));\n    float d0 = plane(ray-vec3(0,-2,6), normalize(vec3(0,1,0)));\n    d = min(d1, d0);\n    \n    shininess = .0;\n    if(d1 < d0){\n        if(d1 < d2 && d1 < d3 && d1 < d4){\n            color = vec3(.9,.9,.9);\n        }\n        else{\n            color = vec3(.5,.7,.9);\n        }\n        shininess = .3;\n    }\n    else{\n        color = vec3(1.,1,1);\n    }\n    \n    return d;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n\n    vec3 n = vec3(safe_distance(ray)) - vec3(\n        safe_distance(ray - epsilon.xyy),\n        safe_distance(ray - epsilon.yxy),\n        safe_distance(ray - epsilon.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 pos, vec3 ray, float k){\n    float d = 0.1;\n    float val = 1.;\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float h = safe_distance(pos+ray*d);\n        if(h < COLLISION_THRESHOLD){ // collision\n            return 0.;\n        }\n        val = min(val, k*h/d);\n        \n        d += h;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    return val;\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3((1.-ray.y),.6,1);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            \n            // shadow\n            float s = shadow(ray*d, light1, 5.5);\n            l1 = max(l1 - (1.-s)*.6, 0.);\n            \n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5; // normal color\n            color = bodyColor*.5; // ambient light\n            color += (bodyColor*vec3(1,1,1)*l1 + bodyColor*vec3(1,.6,1)*l2)*.8; // difuse light\n            color += (vec3(0.5)*pow(l1, 30.) + vec3(.0)*pow(l2, 30.))*shininess; // specular light\n            \n            // fog in the distance\n            //color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.6,.3)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // animate light\n    light1 = rotate(normalize(-vec3(0,-5,-0.2)), vec3(0,0,1), sin(iTime*0.2)*0.4);\n\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n    fragColor = vec4(ray_march(normalize(vec3(uv, f))),1);\n}", "image_inputs": [], "common_code": "// SHAPES\n// pos is vector from center of the sphere to ray\nfloat octahedron(vec3 pos, float r){\n    return (dot(abs(pos), vec3(1)) - r) *0.57735027;\n}\n\nfloat sphere(vec3 pos, float r){\n    return length(pos) - r; // + sin(pos.x*20.)*0.05;\n}\n\nfloat pipe(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r;\n}\n\nfloat pipe_wave(vec3 pos, vec3 dir, float r){\n    return length(pos - dir*dot(pos, dir))-r + r*0.02*cos(length(dir*dot(pos,dir))*10.);\n}\n\nfloat box(vec3 pos, vec3 size, float r){\n    pos = abs(pos)-size;\n    return length(max(pos, 0.)) + min(max(max(pos.x, pos.y),pos.z),0.) - r;\n}\n\nfloat plane(vec3 pos, vec3 n){\n    return dot(pos, n);\n}\n\n// BLENDING\nfloat smooth_min( float d1, float d2, float s ) {    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nvec4 smooth_min_color(vec4 c1, vec4 c2, float s){ // c_.w component is distance\n    float d1 = c1.w, d2 = c2.w;\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*c2 + (1.-t)*c1)/2.;\n}\n\n// QUATERNION ROTATION\nvec4 rotation_q(vec3 u, float t){ // rotation axis - normalized, rotation angle / 2\n    return vec4(u * sin(t), cos(t));\n}\nvec3 rotate(vec3 v, vec4 q){ // vector to rotate, rotation quaternion\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec3 rotate(vec3 v, vec3 u, float t){\n    vec4 q = rotation_q(normalize(u), t);\n    return rotate(v, q);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[404, 404, 435, 435, 522], [524, 524, 591, 591, 1456], [1458, 1458, 1488, 1488, 1567], [1569, 1569, 1591, 1591, 1842], [1844, 1844, 1886, 1886, 2250], [2252, 2252, 2277, 2277, 3714], [3716, 3716, 3773, 3794, 4041]], "test": "untested"}
{"id": "sdl3W2", "name": "marching cubes personal test", "author": "sirjofri", "description": "marching cubes personal test. this was for learning purposes only.", "tags": ["marching"], "likes": 1, "viewed": 511, "published": 3, "date": "1616607759", "time_retrieved": "2024-07-30T19:30:52.075911", "image_code": "vec3 lightPos = vec3(-10., 5., 10.);\nvec3 lightCol = vec3(1., 1., .9);\nvec3 ambiCol = vec3(.8, .9, 1.);\n\nvec3 camrot = vec3(0.7, .85, 0.);\n\nvec3 getLightVector(vec3 p)\n{\n    return normalize(lightPos-p);\n}\n\nfloat sdBox(vec3 pos, vec3 dim, vec3 p)\n{\n    return length(max(vec3(0), abs(p-pos)-dim));\n}\n\nfloat sdSphere(vec3 pos, vec3 p, float r)\n{\n    return distance(pos, p) - r;\n}\n\nfloat aNoise(vec3 pos)\n{\n    return smoothstep(0., 1., texture(iChannel1, pos.xy*2.).r*texture(iChannel1, pos.xz*1.).r)*.01;\n}\n\nfloat aBox(vec3 pos)\n{\n    return sdBox(vec3(.0, .3, .0), vec3(.3, .15, .1), pos)-sin(pos.x*25.+iTime*4.)*0.01-.01-aNoise(pos)-aNoise(pos*.2)*4.;\n}\nfloat bBox(vec3 pos)\n{\n    return sdBox(vec3(0., .6, sin(iTime)*.1), vec3(.1, .15, .1), pos)-aNoise(pos)-.01-aNoise(pos*.2)*4.;\n}\n\nfloat compose(vec3 pos)\n{\n    return min(\n        min(\n            min(\n                aBox(pos),\n                bBox(pos)\n            ),\n            distance(vec3(pos.x, pos.y, 0.), pos)\n        ),\n        sdSphere(pos, vec3(sin(iTime*2.)*.35, cos(iTime*3.5)*.2+.5, sin(iTime)*.05+.06), .1)\n    );\n}\n\nfloat shadow(vec3 pos)\n{\n    float res = 1.;\n    float t = .0;\n    float ph = 1e10;\n    vec3 lv = getLightVector(pos);\n    for(int i = 0; i < 32; i++)\n    {\n        float h = compose(pos + lv*t);\n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 8.*d/max(0., t-y));\n        ph = h;\n        t += h;\n        if (res < .0001 || t > distance(lightPos, pos)) break;\n    }\n    res = clamp(res, 0., 1.);\n    return res*res*(3.-2.*res);\n}\n\n/* how to color the boxes individually? */\nvec3 color(vec3 pos, vec3 normal)\n{\n    vec3 left = texture(iChannel0, pos.yz*2.).rgb;\n    vec3 front = texture(iChannel0, pos.xz*2.).rgb;\n    vec3 top = texture(iChannel0, pos.xy*2.).rgb;\n    vec3 col = mix(mix(left, front, abs(normal.y)), top, pow(abs(normal.z), .5));\n    return pow(col, vec3(1.2));\n}\n\nfloat calcAO(vec3 pos, vec3 normal)\n{\n    float dist = .05;\n    float d = compose(pos + normal*dist);\n    return mix(.6, 1., clamp(d/dist, 0., 1.));\n}\n\n/* thanks wikipedia. Now I understand rotation matrices. */\nvec3 calcRayDir(vec3 d)\n{\n    mat3 yaw = mat3(\n        cos(camrot.x), -sin(camrot.x), 0.,\n        sin(camrot.x),  cos(camrot.x), 0.,\n        0.           ,  0.           , 1.\n    );\n    mat3 pitch = mat3(\n        1., 0., 0.,\n        0., cos(camrot.y), -sin(camrot.y),\n        0., sin(camrot.y),  cos(camrot.y)\n    );\n    mat3 roll = mat3(\n        cos(camrot.z), 0., sin(camrot.z),\n        0., 1., 0.,\n        -sin(camrot.z), 0., cos(camrot.z)\n    );\n    \n    d *= roll;\n    d *= pitch;\n    d *= yaw;\n    return normalize(d);\n}\n\n\n/* Thanks iq */\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*compose(p+e*h); /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    for (int i=0; i<64; i++) {\n        float n = compose(ro + rd*d);\n        d += n;\n        if (n < .01)\n            return d;\n    }\n    return 1000.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= iResolution.y/iResolution.x/2.;\n    uv -= .5;\n    \n    float speed = .3;\n    vec3 campos = vec3(sin(iTime*speed)*.2-.5, cos(iTime*speed)*.15+.15+1., 1.);\n    vec3 raydir = vec3(uv.x, -2., uv.y);\n    camrot.z = cos(sin(iTime*.5)*50.)*sin(iTime*3.)*.01;\n    raydir = calcRayDir(raydir);\n    lightPos = vec3(sin(iTime*.7)*5., cos(iTime*.7)*5., sin(iTime*.2)*3.+5.);\n    \n    \n    float d = march(campos, raydir);\n    vec3 pos = campos + raydir*d;\n    float dist = distance(pos, campos);\n    vec3 normal = calcNormal(pos);\n    vec3 lightVector = getLightVector(pos);\n    float shade = shadow(pos);\n    \n    float shadow = min(shade, mix(.3, 1., dot(normal, lightVector)));\n    \n    vec3 col = clamp(vec3(1.8-dist), 0., 1.)*color(pos, normal);\n    col *= calcAO(pos, normal);\n    float mixvis = smoothstep(1., .95, sin(iTime)*abs(sin(dist*100.-iTime*5.)));\n    col = mix(col*vec3(.8, .9, .8), col, mixvis);\n    vec3 result = mix(col*.4, col*lightCol, shadow);\n    result = col * lightCol * shadow;\n    result += ambiCol*.6*col;\n    \n //   result = vec3(d*.05);\n\n    fragColor = vec4(result, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 169, 169, 205], [207, 207, 248, 248, 299], [301, 301, 344, 344, 379], [381, 381, 405, 405, 507], [509, 509, 531, 531, 656], [657, 657, 679, 679, 786], [788, 788, 813, 813, 1090], [1092, 1092, 1116, 1116, 1559], [1561, 1604, 1639, 1639, 1908], [1910, 1910, 1947, 1947, 2060], [2062, 2122, 2147, 2147, 2648], [2651, 2667, 2692, 2692, 2966], [2968, 2968, 2999, 2999, 3171], [3173, 3173, 3230, 3230, 4375]], "test": "untested"}
{"id": "fss3D2", "name": "Fractal 45_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 5, "viewed": 340, "published": 3, "date": "1616586401", "time_retrieved": "2024-07-30T19:30:52.848844", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=.03*H(log(s)*.3+.5)*exp(-8.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,1.2);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=2.;\n        for(int j=0;j++<10;s*=e)\n            p=sign(p)*(1.-abs(abs(p-2.)-1.)),\n            p=p*(e=6./clamp(dot(p,p),.1,3.))-vec3(8,.2,8);\n        g+=e=length(p)/s;}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fss3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 611]], "test": "untested"}
{"id": "fslGD2", "name": "9. Raymarching 1", "author": "Sp3cim4n", "description": "Learning Shader Magic", "tags": ["raymarching", "sdf", "learning"], "likes": 1, "viewed": 242, "published": 3, "date": "1616574988", "time_retrieved": "2024-07-30T19:30:53.612801", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0., 1., 6., 1.);\n    \n    float sphere_dist = length(p - s.xyz) - s.w;\n    float plane_dist = p.y;\n    \n    float d = min(sphere_dist, plane_dist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i = 0; i <= MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO * rd;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO>MAX_DIST || ds < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n             GetDist(p - e.xyy),\n             GetDist(p - e.yxy),\n             GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos =  vec3(0, 4, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime) * 3.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(l, n), 0., 1.);\n        \n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d < length(lightPos - p))\n        dif *= .1;\n\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. *fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(.0, 1., .0);\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p /*Surface Position*/ = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 272], [274, 274, 308, 308, 535], [537, 537, 561, 561, 770], [772, 772, 796, 796, 1118], [1120, 1120, 1175, 1175, 1532]], "test": "untested"}
{"id": "WtdBRS", "name": "Moon - distance 2D", "author": "iq", "description": "Exact distance to a moon shape", "tags": ["2d", "sdf", "moon", "distance"], "likes": 30, "viewed": 2557, "published": 3, "date": "1616567072", "time_retrieved": "2024-07-30T19:30:54.376759", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D moon shape\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        return length(p-vec2(a,b));\n    }\n\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.3;\n    m *= 1.3;\n    \n    float ra = 1.0;\n    float rb = 0.8;\n    float di = 1.2*cos(iTime+3.9);\n    \n\tfloat d = sdMoon( p, di, ra, rb );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdMoon(m, di, ra, rb );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBRS.jpg", "access": "api", "license": "mit", "functions": [[1241, 1241, 1293, 1293, 1582], [1584, 1584, 1641, 1641, 2378]], "test": "untested"}
{"id": "NssGDj", "name": "Glaciers", "author": "wyatt", "description": "attempt at simulating freezing temperatures ", "tags": ["fluid", "automata"], "likes": 23, "viewed": 385, "published": 3, "date": "1616562504", "time_retrieved": "2024-07-30T19:30:55.161660", "image_code": "// Fork of \"Paint Crack\" by wyatt. https://shadertoy.com/view/fdlGDB\n// 2021-03-24 05:01:47\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-23 06:44:39\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = vec4(.1,.3,.6,1)+f.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 qB = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b= B(U+u);\n        Q.xy -= 0.1*a.w*(a.w*(a.w*mat2(b)-mat2(.9)))*u;  \n    }\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,.7*exp(-.005*length(U-0.5*R)));\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.1*max(1.-6.*Q.w*q.w,0.);\n       float k = .5+.1*max(1.-6.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n    Q = B(U);\n    vec4 qA = A(U);\n    vec4 dQ = vec4(0);\n    box if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u);\n        vec2 v = a.xy-qA.xy;\n        dQ -= a.w*vec4(u.x*v,u.y*v);\n    }\n    Q += dQ;\n    Q = mix(Q,vec4(1,0,0,1),exp(-1000.*qA.w));\n    if (iFrame < 1) Q = vec4(1,0,0,1);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    float w = 0.;\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ += Qb*wa+qb*wb;\n        w += wa+wb;\n        \n    }\n    if (w>0.)dQ/=w;\n    Q = dQ;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdf3D2", "name": "Real-Time Raytracing (Not PTGI!)", "author": "Zi7ar21", "description": "slapping crap together like it's play-doh", "tags": ["raytracer", "raytracer", "raytracer", "ray", "raytrace", "raytrace", "raytrace", "raytraced", "raytraced", "raytraced"], "likes": 0, "viewed": 337, "published": 3, "date": "1616561722", "time_retrieved": "2024-07-30T19:30:55.938583", "image_code": "// ####### Real-Time Ray-Traced (Not PTGI!) #######\n// Made by Zi7ar21 (Jacob Bingham)\n\n// Made on March 23rd, 2021\n// Last Updated: March 23rd, 2021 at 22:35 Mountain Standard Time\n\n// This shader ray-traces a sphere and an infinite plane. It has GGX, Hard Shadows, and Fresnel.\n// That's about it really... not Path-Traced in any way, shape, or form.\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/sdf3D2\n\n// You can remove these social media links when using elsewhere:\n// Discord: @Zi7ar21#2168\n//\n// Twitter: @Zi7ar21\n// https://twitter.com/Zi7ar21\n//\n// YouTube: Jacob Bingham\n// https://www.youtube.com/channel/UCuOqD4WwtUZMOquSIeJ-AAA\n\n// ##### PARAMETERS #####\n// Camera Field of View\n#define camfov 1.0\n\n// Mouse Control Sensitivity (Comment to Disable Mouse)\n#define mousesensitivity 8.0\n\n// Maximum Ray Bounces (UNUSED)\n#define maxbounces 32U\n\n// Hard-Shadow Threshold (because 0.0 gives yucky artifacts on the backs of surfaces!)\n#define hardshadow 1e-4\n\n// Shadow Strength\n#define shadowbias 0.5\n\n// Light Source Direction\n#define lightdir vec3(1.0)\n\n// Super-Sample Anti-Aliasing\n// Comment to disable SSAA, otherwise resolution is multiplied by 2.0*n\n#if HW_PERFORMANCE >= 0\n#define SSAA 1\n#endif\n// (If Shadertoy detects that you are on a potato, it should be disabled by default)\n// Examples:\n// SSAA 1: 2.0*iResolution.xy (4x Slower)\n// SSAA 2: 4.0*iResolution.xy (8x Slower)\n// SSAA 3: 6.0*iResolution.xy (12x Slower)\n// SSAA 4: 8.0*iResolution.xy (16x Slower)\n\n// ##### CONSTANTS #####\n// Octuple Precision, even though Shadertoy is Full Precision (32-Bit Floating Point)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### TEXTURES #####\n// Fractal Brownian Motion (FBM) Noise Octaves\n#define octaves 8U\n\n// Gradient Noises (from Samplers)\nfloat noise(vec3 pos){\n    return texture(iChannel0, pos).r;\n}\n\nfloat noise(vec2 pos){\n    return texture(iChannel1, pos).r;\n}\n\n// Fractal Brownian Motion Noises\nfloat fbm(vec3 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.zyx*2.0;\n    }\n    return outCol;\n}\n\nfloat fbm(vec2 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.yx*2.0;\n    }\n    return outCol;\n}\n\n// ##### OTHER FUNCTIONS #####\n// Rotation Matrix\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// Almost everything is from the great Inigo Quilez:\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;}\n    h = sqrt(h);\n    return -b-h;\n}\n\n// Unused\n/*// Triangle Intersection Function\nvec3 tri(vec3 raydir, vec3 rayori, mat3 triangle){\n    vec3 v1v0 = triangle[1]-triangle[0];\n    vec3 v2v0 = triangle[2]-triangle[0];\n    vec3 rov0 = rayori-triangle[0];\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, raydir);\n    float d = 1.0/dot(raydir, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot( q, v1v0);\n    float t = d*dot(-n, rov0);\n    if(u < 0.0 || u > 1.0 || v < 0.0 || (u+v) > 1.0 ){t = -1.0;}\n    return vec3(t, u, v);\n}*/\n\n// Plane Intersection Function (with help from LoicVDB)\n// https://www.shadertoy.com/user/loicvdb\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out vec3 norm, out uint objectid){\n    // Compute all intersections, and find the closest object\n    float int0 = plane(raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float int1 = sphere(raydir, rayori, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(int0, int1);\n    if(int0 <= 0.0){minimum = int1;}\n    if(int1 <= 0.0){minimum = int0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == int0){\n        norm = vec3(0.0, 1.0, 0.0);\n        objectid = 1U;\n        return int0;\n    }\n\n    if(minimum == int1){\n        norm = normalize((rayori+(raydir*int1))-vec3(0.0, 0.5, 0.0));\n        objectid = 2U;\n        return int1;\n    }\n\n    // NULL Object (just to be safe)\n    norm = vec3(0.0);\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### PBR AND MATERIALS #####\n// Poorly Based on: https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX Normal Distribution Function\nfloat GGX(vec3 norm, vec3 highlightdir, float roughness){\n    float a2     = roughness*roughness;\n    float NdotH  = max(dot(norm, highlightdir), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom    = a2;\n    float denom  = (NdotH2*(a2-1.0)+1.0);\n          denom  = pi*denom*denom;\n    return nom/denom;\n}\n\n// Fresnel Schlick\nvec3 fresnel(vec3 raydir, vec3 normal, vec3 F0){\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Get the Material Properties of an Object\nvoid getmat(in uint objectid, in vec3 raypos, out vec3 albedo, out vec3 spec, inout vec3 norm, out float rough){\n    if(objectid == 1U){\n        albedo = vec3(1.0);\n        spec = vec3(0.6);\n        rough  = (fbm(raypos.xz*0.01)/10.0)+0.5;\n        return;\n    }\n\n    if(objectid == 2U){\n        albedo = vec3(1.0);\n        spec = vec3(0.6);\n        rough  = (fbm(normalize(raypos-vec3(0.0, 0.5, 0.0))*0.05)*0.5)+0.25;\n        return;\n    }\n\n    // NULL Object\n    albedo = vec3(0.0);\n    spec = vec3(0.0);\n    rough  = 0.0;\n    return;\n}\n\n// Compute Shading\nvoid calcshading(inout vec3 outCol, in vec3 raydir, in vec3 albedo, in vec3 spec, in vec3 norm, in float rough){\n    float shadeGGX = GGX(reflect(raydir, norm), normalize(vec3(1.0)), rough);\n    vec3 shadefresnel = fresnel(raydir, norm, spec);\n    outCol = shadefresnel*shadeGGX*albedo;\n    return;\n}\n\n// ##### RENDERING #####\n// Sky\nvec3 skycol(vec3 raydir){\n    vec3 outCol;\n\n    // Light Source\n    if(length(raydir-normalize(lightdir)) < 0.25){\n        outCol = vec3(10.0);\n        return outCol;\n    }\n\n    // Background Gradient\n    outCol = vec3(dot(raydir+vec3(0.0, 0.125, 0.0), vec3(0.0, 1.0, 0.0)));\n    return outCol;\n}\n\n// Hard Shadows\nfloat calcshadow(vec3 raydir, vec3 rayori){\n    // We need these to use the intersection function, and then we can just yeet them\n    // (We could make another intersection that doesn't but that would take up a lot of space\n    // and be tedious to make one match the other when laying out a scene)\n    vec3 norm = vec3(0.0);\n    uint objectid = 0U;\n\n    // Find the intersection\n    float intersection = intersect(raydir, rayori, norm, objectid);\n\n    // If we intersected with the scene, then a shadow is being cast\n    if(intersection >= 0.0){return 0.0;}\n\n    // Otherwise the light source is shining on our surface\n    return 1.0;\n}\n\n// Ray-Tracing\nvec3 raytrace(vec3 raydir, vec3 rayori){\n    vec3 raypos = rayori, outCol = vec3(1.0), col, albedo, spec, norm;\n    float rough;\n    uint objectid;\n    for(uint i = 0U; i < maxbounces; i++){\n        float intersection = intersect(raydir, raypos, norm, objectid);\n        if(intersection <= 0.0){break;}\n        raypos += raydir*intersection;\n        getmat(objectid, raypos, albedo, spec, norm, rough);\n        calcshading(outCol, raydir, albedo, spec, norm, rough);\n        outCol = mix(outCol, outCol*calcshadow(normalize(lightdir), raypos-raydir*hardshadow), shadowbias);\n\n        // For Pure Reflections (Mirrors)\n        //raydir = reflect(raydir, norm);\n\n        // Return Shaded Output\n        return outCol;\n    }\n\n    // Return the Color of the Sky\n    return skycol(raydir);\n}\n\n// ##### OUTPUT IMAGE #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = vec3(0.0);\n    #ifdef SSAA\n    for(int y = -SSAA; y < SSAA; y++){\n    for(int x = -SSAA; x < SSAA; x++){\n        // Normalized Screen UV Coordinates Centered on (0.0, 0.0)\n        vec2 uv = 2.0*((fragCoord+(vec2(x, y)/float(SSAA*2)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n        // Calculate the Ray Direction\n        vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n        #ifdef mousesensitivity\n        if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n        #endif\n        mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n        vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n        // Render the Image\n        color += raytrace(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n    }\n    }\n\n    // Convert the sum to the average\n    color = color/float(SSAA*SSAA*4);\n    #endif\n    #ifndef SSAA\n    // Normalized Screen UV Coordinates Centered on (0.0, 0.0)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Calculate the Ray Direction\n    vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    #ifdef mousesensitivity\n    if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n    #endif\n    mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n    // Render the Image\n    color = raytrace(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n    #endif\n\n    // HDR to SDR Tonemapping\n    color = pow(color/(1.0+color), vec3(1.0/2.2));\n\n    // Output to Screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdf3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1864, 1899, 1921, 1921, 1961], [1963, 1963, 1985, 1985, 2025], [2027, 2061, 2081, 2081, 2288], [2290, 2290, 2310, 2310, 2516], [2518, 2568, 2595, 2634, 3027], [3029, 3200, 3266, 3266, 3454], [3960, 4058, 4119, 4119, 4244], [4246, 4277, 4353, 4415, 5083], [5085, 5226, 5283, 5283, 5533], [5535, 5554, 5602, 5602, 5663], [5665, 5709, 5821, 5821, 6246], [6248, 6267, 6379, 6379, 6567], [6569, 6601, 6626, 6626, 6897], [6899, 6915, 6958, 7213, 7552], [7554, 7569, 7609, 7609, 8355], [8357, 8385, 8439, 8439, 10160]], "test": "untested"}
{"id": "7dfGWj", "name": "Space Filling Rotating Squares", "author": "Tater", "description": "It was fun figuring out the how the squares should scale, I'm sure I'll use this for something eventually.\n\n", "tags": ["squares"], "likes": 6, "viewed": 271, "published": 3, "date": "1616559773", "time_retrieved": "2024-07-30T19:30:56.714508", "image_code": "mat2 rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv*=2.0+mod(floor(iTime/3.14159265359*2.0)*2.0,8.0);\n    float t = iTime;\n    //uv/=(pow((-cos(t*4.0)*0.5+0.5),0.45)*(sqrt(2.0)-1.0)+1.0);\n    vec2 ID = 1.-2.*mod(floor(uv),2.);\n    //float yID=1.0-2.0*mod(floor(uv.y),2.0);\n    //float xID=1.0-2.0*mod(floor(uv.x),2.0);\n    uv = mod(uv,1.0)-0.5;\n    uv*=rot(ID.x*ID.y*t)*(pow((-cos(t*4.0)*0.5+0.5),0.45)*(sqrt(2.0)-1.0)+1.0);\n    \n    //uv = (fract(uv*2.0)-0.5)*step(abs(uv.x),0.5)*step(abs(uv.y),0.5);\n      \n    \n    vec2 S = smoothstep(-.005,.005,.5-abs(uv) );\n    uv *= S.x*S.y;\n    \n    //uv = uv*smoothstep(abs(uv.x)-0.005,abs(uv.x)+0.005,0.5)*smoothstep(abs(uv.y)-0.005,abs(uv.y)+0.005,0.5);\n    //uv = uv*step(abs(uv.x),0.5)*step(abs(uv.y),0.5);\n    \n    fragColor = vec4(.5,.5,1,1)* S.x*S.y;\n    \n    \n    /*\n    //not really sure how to do this better\n    vec3 col;\n    if(length(uv.x)!=0.0){\n        col.rgb = vec3(0.5,0.5,1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n    */\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 79], [80, 80, 137, 137, 1155]], "test": "untested"}
{"id": "Nsl3DS", "name": " Spheres", "author": "personalizedrefrigerator", "description": "A set of spheres, based on the amazing _Ray Tracing in One Weekend_. See https://raytracing.github.io/books/RayTracingInOneWeekend.html. \nClick and drag to rotate the camera.", "tags": ["raytracer", "spheres"], "likes": 1, "viewed": 284, "published": 3, "date": "1616556178", "time_retrieved": "2024-07-30T19:30:57.667959", "image_code": "// Ref: https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nconst vec3 ORIGIN = vec3(0.0, 0.0, 0.0);\nconst float MAX_DIST = 999999999.0;\n\n// General options\n#define COLORFUL_BACKGROUND\n#define AUTO_MOVING_CAMERA\n\n// Anti-aliasing (bigger numbers => higher quality, but slower)\nconst int NUM_SAMPLES = 10;\n\n// Ray bouncing\nconst int MAX_RAY_DEPTH = 5;\n\n#define SCENE_NUM_SPHERES 9\nstruct Scene\n{\n    Sphere spheres[SCENE_NUM_SPHERES];\n};\n\nDEF_SCENE_HIT(Scene)\n    DEF_SCENE_OBJ(spheres, SCENE_NUM_SPHERES)\nEND_DEF_SCENE_HIT(Scene)\n\n// Get the vec3(red, green, blue) color associated with\n// the given ray (casts a ray into the scene).\nvec3 ray_color(Ray r, const in Scene scene)\n{\n    color3 colorMask = vec3(1.0, 1.0, 1.0);\n        \n    color3 colorShift;\n    Ray scattered;\n    \n    for (int depth = 0; depth < MAX_RAY_DEPTH; depth++)\n    {\n        vec3 unit_direction = normalize(r.v);\n        HitRecord h = hit(scene, r, 0.0001, MAX_DIST);\n\n        if (!h.valid)\n        {\n#ifdef COLORFUL_BACKGROUND\n            float a = 0.5 * (unit_direction.y + 1.0) * 33.0 + 4.0 * sin(iTime / 8.0);\n            float b = 0.5 * (unit_direction.x + 1.0) * 33.0;\n            \n            color3 background = cos(2.0 * PI * vec3(tan(a / b), a - b, a * b));\n            background = clamp(background, vec3(0.0), vec3(1.0));\n#else\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color3 background = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);\n#endif\n            \n            return colorMask * background;\n        }\n        \n        if (!scatter(r, h, colorShift, scattered))\n        {\n            return colorMask * colorShift;\n        }\n        \n        r = scattered;\n        colorMask *= colorShift;\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nScene generateScene()\n{\n    float t = iTime;\n    float orangeRadius = 2.0 * tan(t / 4.0);\n    \n    Scene scene = Scene\n    (Sphere[](\n        Sphere(vec3(0.6 * cos(t), 0.0, 0.6 * sin(t) - 1.0), 0.05, DEFAULT_MATERIAL_METAL),\n        Sphere(vec3(0.67 * cos(2.0*t), 0.2 * sin(t), 0.5 * sin(2.0*t) - 1.0), 0.03, DEFAULT_MATERIAL),\n        Sphere(vec3(0.0, 0.0, -1.0), 0.5, DEFAULT_MATERIAL_METAL),\n        Sphere(vec3(0.9, -0.2, -1.0), 0.3, DEFAULT_MATERIAL_GLASS),\n        Sphere(vec3(-0.9, -0.2, 1.0), 0.3, Material(vec3(0.9, 0.2, 0.0), 1.1, MATERIAL_GLASS)),\n        Sphere(vec3(-0.9, -0.1, 2.0), 0.4, Material(vec3(0.9, 0.2, 0.0), 0.2, MATERIAL_METAL)),\n        Sphere(vec3(0.0, -500.5, -1.0), 500.0, DEFAULT_MATERIAL_MATTE),\n        Sphere(vec3(0.0, 0.0, -10.0), 5.0, Material(vec3(0.3, 0.9, 0.5), 0.6, MATERIAL_METAL)),\n        Sphere(vec3(4.0 * sin(t), -2.0 * orangeRadius - abs(sin(t)), -6.0), orangeRadius, \n                Material(vec3(0.9, 0.3, 0.1), 0.6, MATERIAL_MATTE))\n    ));\n    \n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    srand(9.0 + fragCoord.y / iResolution.y \n        + fragCoord.x / iResolution.x + fragCoord.x / fragCoord.y);\n    \n    Scene scene = generateScene();\n    float mouseX = iMouse.x / iResolution.x - 0.5;\n    float mouseY = iMouse.y / iResolution.y - 0.5;\n    \n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n    {\n        mouseX = 0.0;\n        mouseY = 0.0;\n    }\n    \n#ifdef AUTO_MOVING_CAMERA\n    vec3 camPos = vec3(sin(iTime / 4.0), 0.0, cos(iTime / 4.0)) * tan(iTime / 12.0) * 2.0;\n#else\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n#endif\n\n    mat3 camMat = yRotMatrix33(mouseX * 2.0 * PI) * xRotMatrix33(-mouseY * PI);\n    \n    vec3 col     = vec3(0.0, 0.0, 0.0);\n    vec3 lastCol = col;\n    vec2 lastOffset = vec2(0.0);\n    \n    for (int i = 0; i < NUM_SAMPLES; i++)\n    {\n        vec2 xy = fragCoord + vec2(rand(), rand());\n    \n        // Normalized pixel coordinates (from -1 to 1)\n        vec2 uv = (2.0 * xy/iResolution.xy - vec2(1.0, 1.0)) * iResolution.xy / iResolution.y;\n\n        Ray ray = Ray(camMat * vec3(uv, -1.0), ORIGIN + camPos);\n        ray.v = normalize(ray.v);\n        \n        vec3 currentCol = ray_color(ray, scene);\n        col += currentCol;\n    }\n    \n    col /= float(NUM_SAMPLES);\n    \n    // Gamma correction. (Gamma=2.0, so raise the color\n    // to the 1/2 power.)\n    col = clamp(sqrt(col), vec3(0.0), vec3(0.999));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// A set of utilities.\n// Based on the tutorial \n// Ray Tracing in One Weekend. raytracing.github.io/books/RayTracingInOneWeekend.html\n// (accessed Mar. 23, 2021)\n\n///////////// Type aliases\n#define point3 vec3\n#define color3 vec3\n\n///////////// Constants\nconst float PI = 3.14159265358979323826;\n\n///////////// Struct definitions (methods further below)\n\nstruct Ray\n{\n    vec3 v; // direction (**v**ector)\n    vec3 origin; // origin\n};\n\nstruct Material\n{\n    color3 color;\n    float  param;\n    int    typeId;\n};\n\nstruct HitRecord\n{\n    bool valid;\n    vec3 p; // hit point\n    vec3 norm;\n    Material  material;\n    float t;\n};\n\nstruct Sphere\n{\n    vec3 center; // center\n    float r; // radius\n    Material material;\n};\n\n///////////// Numeric utilities\n\n// Returns a pseudo-random number in [0, 1)\n// See also https://www.shadertoy.com/view/3slSzn\nfloat _rand_seed = 0.0;\nfloat rand()\n{\n    _rand_seed++;\n    \n    return fract(sin(_rand_seed) * 5985.32576);\n}\n\nfloat rand(float min, float max)\n{\n    return min + (max - min) * rand();\n}\n\nvec3 rand_vec3(float comp_min, float comp_max)\n{\n    return vec3(rand(comp_min, comp_max), rand(comp_min, comp_max), rand(comp_min, comp_max));\n}\n\nvoid srand(float seed)\n{\n    _rand_seed = abs(seed);\n}\n\n///////////// Transformation utilities\n\n    \n// See https://en.wikipedia.org/wiki/Rotation_matrix\nmat3 yRotMatrix33(float ry)\n{\n    float cos_part = cos(ry);\n    float sin_part = sin(ry);\n    \n    return mat3(\n        cos_part, 0.0, sin_part,\n        0.0,      1.0, 0.0,\n        -sin_part, 0.0, cos_part\n    );\n}\n\nmat3 zRotMatrix33(float rz)\n{\n    float cos_part = cos(rz);\n    float sin_part = sin(rz);\n    \n    return mat3(\n        cos_part, -sin_part, 0.0,\n        sin_part, cos_part,  0.0,\n        0.0,      0.0,       1.0\n    );\n}\n\nmat3 xRotMatrix33(float rx)\n{\n    float cos_part = cos(rx);\n    float sin_part = sin(rx);\n    \n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos_part, -sin_part,\n        0.0, sin_part, cos_part\n    );\n}\n\n///////////// RAY\n\nvec3 at(const in Ray r, float t)\n{\n    return r.v * t + r.origin;\n}\n\n////////////// MATERIALS\nconst int MATERIAL_MATTE = 0;\nconst int MATERIAL_METAL = 1;\nconst int MATERIAL_GLASS = 2;\n\n\nconst Material DEFAULT_MATERIAL_MATTE = \n    Material(vec3(0.5, 0.5, 0.6), 0.3, MATERIAL_MATTE);\n\nconst Material DEFAULT_MATERIAL_METAL = \n    Material(vec3(0.5, 0.5, 0.5), 0.0, MATERIAL_METAL);\n    \nconst Material DEFAULT_MATERIAL_GLASS = \n    Material(vec3(0.8), 1.3, MATERIAL_GLASS);\n\nconst Material DEFAULT_MATERIAL = DEFAULT_MATERIAL_MATTE;\n\n// Reflects [vecIn] with respect to [normal]. Assumes vecIn has unit length.\nvec3 _reflected(vec3 vecIn, vec3 normal)\n{\n    // Say we have,\n    //  \\   N   /  ^     Where N is the normal,\n    // v \\ ^  /   |     v is the incident ray\n    //    \\ | / r  | B   and r is the reflected ray.\n    //     \\|/     |\n    //--------------- \n    //       \\     ^\n    //        \\ v  |\n    //         \\   | B\n    //          \\  |\n    //\n    // Notice that v + 2 B = r.\n    // B = proj_N ( v ) = N sin(/2 - ) = N cos()\n    //                  = N (unit(v)N)\n    // As such,\n    vec3 reflected = vecIn - 2.0 * normal * dot(normal, vecIn);\n    return reflected;\n}\n\n// Gets an approximation of reflectance for a surface with\n// ratio of indicies of refraction [refractionRatio].\n// TODO: _Ray Tracing in One Weekend_ states that this is \n//       the Schlick approximation. I don't understand what\n//       this is approximating. Research this.\nfloat _reflectance(float cos_angle, float refractionRatio)\n{\n    float r0 = (1.0 - refractionRatio) / (1.0 + refractionRatio);\n    r0 *= r0;\n    \n    return r0 + (1.0 - r0) * pow(1.0 - cos_angle, 5.0);\n}\n\n// Scatter a ray based on a collision record (takes\n// material into account).\n// Returns:\n// {\n//   true  => scattered\n//   false => absorbed\n// }\nbool scatter(const in Ray rayIn, const in HitRecord hit, \n        out color3 colorShift, out Ray scattered)\n{\n    colorShift = hit.material.color;\n    int materialId = hit.material.typeId;\n    \n    // This seems to not work with switch/case statements in Safari.\n    // Use if statements.\n    \n    if (materialId == MATERIAL_MATTE)\n    {\n        // Matte: Scatter in a random direction with respect\n        //        to the normal.\n        vec3 rand_dir = \n            normalize(rand_vec3(-hit.material.param, 1.0));\n        vec3 rand_vec = rand_dir * rand();\n        scattered.v = hit.p + hit.norm + rand_vec;\n        scattered.origin = hit.p;\n\n        // Matte: Always scatter.\n        return true;\n    }\n    else if (materialId == MATERIAL_METAL)\n    {\n        vec3 rayIn_dir = normalize(rayIn.v);\n        \n        vec3 reflected = _reflected(rayIn_dir, hit.norm);\n        scattered.v = reflected;\n\n        if (hit.material.param > 1e-8) \n        {\n            vec3 random_unit_vec = normalize(rand_vec3(-1.0, 1.0));\n            scattered.v += hit.material.param * random_unit_vec;\n        }\n\n        scattered.origin = hit.p;\n\n        // Absorb if the scattered ray opposes the normal\n        //  (closer to anti-parallel than parallel).\n        return dot(reflected, hit.norm) >= 0.0;\n    }\n    else if (materialId == MATERIAL_GLASS)\n    {\n        vec3 rayIn_dir = normalize(rayIn.v);\n    \n        // For simplicity, assume we're always handling\n        // air and this' material, not some other substance.\n        float refractionRatio = hit.material.param;\n        \n        if (dot(rayIn_dir, hit.norm) <= 0.0)\n        {\n            refractionRatio = 1.0 / refractionRatio;\n        }\n        \n        vec3 in_perp = rayIn_dir - hit.norm;\n        vec3 out_perp = in_perp * refractionRatio;\n        \n        scattered.origin = hit.p;\n        scattered.v = out_perp - hit.norm;\n        \n        float cos_angle = dot(-rayIn_dir, hit.norm);\n        float sin_angle = sqrt(1.0 - pow(cos_angle, 2.0));\n        float sin_otherAngle = refractionRatio * sin_angle;\n        \n        // Impossible sine of other angle?\n        // We need to reflect.\n        if (sin_otherAngle > 1.0 || _reflectance(cos_angle, refractionRatio) > rand())\n        {\n            vec3 reflected = _reflected(rayIn_dir, hit.norm);\n            scattered.v = reflected;\n        \n            return dot(reflected, hit.norm) >= 0.0;\n        }\n        \n        return true;\n    }\n    \n    // Unknown: Absorb.\n    return false;\n}\n\n////////////// HIT-ABLES\n\nHitRecord hit(const in Sphere s, const in Ray r, float t_min, float t_max)\n{\n    HitRecord result;\n    \n    // Compute ray-sphere intersection.\n    //   Say r(t) = At + B and the sphere has center C and radius s.\n    //   We then have (r(t) - C)(r(t) - C) = s.\n    //   Expanding, \n    //          (At + B - C)(At + B - C) = s\n    //           AA t + 2 A(B - C) t + (B - C)(B - C) = s\n    //   which can be solved with the quadratic formula.\n    vec3 BC = r.origin - s.center;\n    \n    // Finding (a, b, c) for (-b  sqrt(b - 4ac)) / 2 / a\n    //  or equivalently\n    //         (a, b/2, c) for (-b/2  sqrt((b/2) - ac)) / a\n    float a = dot(r.v, r.v);\n    float half_b = dot(r.v, BC);\n    float c = dot(BC, BC) - s.r * s.r;\n    \n    // The descriminant tells us whether we have a solution\n    float desc = half_b * half_b - a * c;\n    \n    // We're not taking square roots of negative numbers,\n    result.valid = (desc >= 0.0);\n    \n    if (!result.valid)\n    {\n        // So just return an arbitrary result that we've marked as\n        // invalid.\n        return result;\n    }\n    \n    // Substitute into the quadratic formula for t such that\n    //    r(t) is a point on the sphere.\n    result.t    = ( -half_b - sqrt(desc) ) / a;\n    \n    if (result.t < t_min || result.t > t_max)\n    {\n        // Try again with the other root.\n        result.t = ( -half_b + sqrt(desc) ) / a;\n    \n        if (result.t < t_min || result.t > t_max)\n        {\n            result.valid = false;\n            return result;\n        }\n    }\n    \n    vec3 hit_pos = at(r, result.t);\n    \n    // Finally, the normal is from the center of the sphere to\n    // the collision point.\n    // This gives us the outward normal.\n    result.norm = normalize(hit_pos - s.center);\n    \n    result.p = hit_pos;\n    result.material = s.material;\n    \n    // Make sure the normal is pointing outwards relative to the\n    // face the ray intersected with.\n    bool front_face = dot(r.v, result.norm) < 0.0;\n    \n    if (!front_face)\n    {\n        result.norm = -result.norm;\n    }\n    \n    return result;\n}\n\n// Scene tables\n\n#define DEF_SCENE_HIT(SceneTypename) \\\nHitRecord hit(SceneTypename s, Ray r, float t_min, float t_max) \\\n{\\\n    HitRecord result;\\\n    result.valid = false;\\\n    result.t = t_max;\\\n    \\\n    float closestSoFar = t_max;\\\n\n\n#define DEF_SCENE_OBJ(fieldName, objCount) \\\n    for (int i = 0; i < objCount; i++) \\\n    { \\\n        HitRecord rec = hit(s.\\\n        fieldName\\\n        [i], r, t_min, result.t);\\\n        if (rec.valid)\\\n        { \\\n            result = rec; \\\n        } \\\n    } \\\n\n\n#define END_DEF_SCENE_HIT(SceneTypename) \\\n    return result; \\\n}\n\n", "sound_code": "struct Note\n{\n    float duration;\n    float pitch;\n    float volume;\n};\n\n// Beats per minute.\nconst float BPM = 240.0;\nconst int NUM_NOTES = 12;\n\nfloat[] MINOR_SCALE = float[](\n    0.0, 2.0, 3.0, 5.0, 7.0, 8.0, 10.0, 12.0, 14.0, 15.0, 17.0, 18.0, 24.0\n);\n\nvoid getCurrentBeat(float time, float bpm, out float noteStartTime, out int beat)\n{\n    beat          = int(floor(time / 60.0 * bpm));\n    noteStartTime = float(beat) * 60.0 / bpm;\n}\n\nfloat playNote(const in Note note, float absTime, float relTime)\n{\n    float frequency = 110.0 * pow(2.0, note.pitch / 12.0);\n    return note.volume * round(sin(frequency * 2.0 * PI * absTime + 6.0 * sin(relTime * 2.0 * PI))) * exp(-relTime / note.duration + 0.1);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    int beat;\n    float noteStartTime;\n    getCurrentBeat(time, BPM, noteStartTime, beat);\n    \n    beat %= 300;\n    float result = 0.0;\n    \n    for (int i = 0; i < NUM_NOTES; i++)\n    {\n        int noteIdx = ((i - 1) ^ beat) - ((i + 1) ^ beat) + beat;\n        float pitchShift = 0.0;\n        float volume = 1.0;\n        \n        if (i >= 5)\n        {\n            float beatf = float(beat);\n            noteIdx = int(sin(tan(beatf) - beatf)\n                       * float(MINOR_SCALE.length()));\n            \n            pitchShift = -float(i ^ beat) / float(NUM_NOTES) / 4.0;\n            volume *= sin(float(i) - beatf) + 1.0;\n        }\n        \n        noteIdx = abs(noteIdx);\n        noteIdx %= MINOR_SCALE.length();\n        \n        float pitch = MINOR_SCALE[noteIdx] + pitchShift;\n        Note note = Note(0.3, pitch, volume);\n        result += playNote(note, time, time - noteStartTime);\n    }\n    \n    result /= float(NUM_NOTES);\n    \n    return vec2( result );\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsl3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2795, 2795, 2852, 2852, 4254]], "test": "untested"}
{"id": "fdl3Wj", "name": "Simple Halftone - CMYK Colors II", "author": "choxi", "description": "Part 6 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 0, "viewed": 946, "published": 3, "date": "1616550740", "time_retrieved": "2024-07-30T19:30:58.433911", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float dotResolution = 50.;\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 color = texture(iChannel0, uv);\n  \n  // RGB-to-CMYK conversion\n  vec4 cmyk;\n  cmyk.xyz = 1.0 - color.rgb;\n  cmyk.w = min(cmyk.x, min(cmyk.y, cmyk.z));\n  cmyk.xyz -= cmyk.w;\n\n  // Build dot grid for each CMYK component\n  vec2 cUV = dotResolution*mat2(0.966, -0.259, 0.259, 0.966)*uv;\n  vec2 cUV2 = 2.0*fract(cUV)-1.0;\n  float cR = sqrt(cmyk.x);\n  float c = smoothstep(cR + 0.1, cR - 0.1, length(cUV2));\n  \n  vec2 mUV = dotResolution*mat2(0.966, 0.259, -0.259, 0.966)*uv;\n  vec2 mUV2 = 2.0*fract(mUV)-1.0;\n  float mR = sqrt(cmyk.y);\n  float m = smoothstep(mR + 0.1, mR - 0.1, length(mUV2));\n  \n  vec2 yUV = dotResolution*uv;\n  vec2 yUV2 = 2.0*fract(yUV)-1.0;\n  float yR = sqrt(cmyk.z);\n  float y = smoothstep(yR + 0.1, yR - 0.1, length(yUV2));\n  \n  vec2 kUV = dotResolution*mat2(0.707, -0.707, 0.707, 0.707)*uv;\n  vec2 kUV2 = 2.0*fract(kUV)-1.0;\n  float kR = sqrt(cmyk.w);\n  float k = smoothstep(kR + 0.1, kR - 0.1, length(kUV2));\n  \n  vec3 rgb = 1. - vec3(c, m, y);\n  rgb = mix(rgb, vec3(0., 0., 0.), k);\n  fragColor = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdl3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1169]], "test": "untested"}
{"id": "NssGWj", "name": "Simple Halftone - CMYK Colors", "author": "choxi", "description": "Part 5 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 0, "viewed": 737, "published": 3, "date": "1616549364", "time_retrieved": "2024-07-30T19:30:59.200861", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float dotResolution = 30.;\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 color = texture(iChannel0, uv);\n  \n  // RGB-to-CMYK conversion\n  vec4 cmyk;\n  cmyk.xyz = 1.0 - color.rgb;\n  cmyk.w = min(cmyk.x, min(cmyk.y, cmyk.z));\n  cmyk.xyz -= cmyk.w;\n\n  vec2 mUV = dotResolution*uv;\n  vec2 mUV2 = 2.0*fract(mUV)-1.0;\n  float mR = sqrt(cmyk.y);\n  float m = smoothstep(mR + 0.1, mR - 0.1, length(mUV2));\n  \n  vec3 rgb = 1. - vec3(0., m, 0.);\n  fragColor = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 527]], "test": "untested"}
{"id": "ssX3D2", "name": "Simple Halftone - Sampling", "author": "choxi", "description": "Part 3 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 2, "viewed": 751, "published": 3, "date": "1616548231", "time_retrieved": "2024-07-30T19:30:59.967810", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float dotResolution = 60.0;\n    float dotRadius = 0.8;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0 * fract(uv * dotResolution) - 1.0;\n    float distance = length(uv2);\n    vec4 color0 = texture(iChannel0, uv);\n    \n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color = mix(color0, white, step(dotRadius, distance));\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 544]], "test": "untested"}
{"id": "7dfGD2", "name": "Distance to 3D Quadratic Bezier", "author": "oneshade", "description": "The distance to quadratic bezier splines generalizes to other dimensions.", "tags": ["3d", "raymarching", "sdf", "bezier", "spline", "quadratic", "exact"], "likes": 16, "viewed": 831, "published": 3, "date": "1616545213", "time_retrieved": "2024-07-30T19:31:00.743736", "image_code": "float sdBezier(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3) {\n    vec3 c1 = p - v1;\n    vec3 c2 = 2.0 * v2 - v3 - v1;\n    vec3 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec3 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec3 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid addShape(in float dist, in int id, inout vec2 scene) {\n    if (dist < scene.x) scene = vec2(dist, id);\n}\n\nvec2 mapScene(in vec3 p) {\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(c2 * 2.0, s3 + 0.25, s1) * 2.0;\n    vec3 b = vec3(s1 * 2.0, s2 + 0.25, c3) * 2.0;\n    vec3 c = vec3(c3 * 2.0, c1 + 0.25, s2) * 2.0;\n\n    vec2 scene = vec2(sdBezier(p, a, b, c) - 0.15, 0);\n    addShape(length(p - a) - 0.25, 1, scene);\n    addShape(length(p - c) - 0.25, 2, scene);\n    addShape(length(p - b) - 0.25, 3, scene);\n    addShape(sdLine(p, a, b) - 0.075, 4, scene);\n    addShape(sdLine(p, b, c) - 0.075, 5, scene);\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            int id = int(d.y);\n            vec3 n = getNormal(p);\n            float diff = sqrt(max(0.0, dot(-rd, n)));\n\n            if (id == 0) fragColor.rgb = vec3(diff, 0.8 * diff, 0.0);\n            if (id == 1) fragColor.rgb = vec3(0.0, 0.0, diff);\n            if (id == 2) fragColor.rgb = vec3(0.0, 0.0, diff);\n            if (id == 3) fragColor.rgb = vec3(diff, 0.0, 0.0);\n            if (id == 4) fragColor.rgb = vec3(0.1 * diff);\n            if (id == 5) fragColor.rgb = vec3(0.1 * diff);\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (t < 20.0 ? tPlane < t : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= 0.8 * exp(-mapScene(iPlane).x);\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 1276], [1278, 1278, 1325, 1325, 1433], [1435, 1435, 1494, 1494, 1544], [1546, 1546, 1572, 1572, 2210], [2212, 2212, 2239, 2239, 2498], [2500, 2500, 2555, 2555, 4905]], "test": "untested"}
{"id": "sdX3W2", "name": "liquid chrome", "author": "morisil", "description": "quick experiment", "tags": ["noise", "texture", "moire"], "likes": 8, "viewed": 447, "published": 3, "date": "1616538212", "time_retrieved": "2024-07-30T19:31:01.522653", "image_code": "// Fork of \"trippy segmented noise moire \" by morisil. https://shadertoy.com/view/fdfGW2\n// 2021-03-23 22:18:28\n\n// Fork of \"textured noise segments\" by morisil. https://shadertoy.com/view/fsX3zX\n// 2021-03-23 16:31:22\n\nconst float NOISE_SCALE = .8;\nconst float NOISE_SPEED = .1;\nconst float WAVE_SHIFT_IMPACT = .04;\nconst float WAVE_SPEED = 5.;\nconst float WAVE_FREQUENCY = 80.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 noiseSt = st * NOISE_SCALE;\n    vec2 noise = vec2(Perlin3D(vec3(noiseSt, iTime * NOISE_SPEED)) + 1.) / 2.;\n    vec2 uvShift = vec2(\n        sin(iTime * WAVE_SPEED + noise * WAVE_FREQUENCY)\n    ) * WAVE_SHIFT_IMPACT;\n    vec3 color = texture(\n        iChannel1,\n        uv - uvShift\n    ).rgb;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdX3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[381, 381, 438, 438, 903]], "test": "untested"}
{"id": "7dX3Dj", "name": "GridX6", "author": "Del", "description": "6 simple drop in grid distance functions - click a grid to show it as full screen\nHEX original  - https://www.shadertoy.com/view/lldfWH\nTRI original - https://www.shadertoy.com/view/4dKXR3\nOCT original - https://www.shadertoy.com/view/3tGBWV", "tags": ["grid", "square", "diamond", "distance", "brick", "hex", "tri", "octagon"], "likes": 22, "viewed": 557, "published": 3, "date": "1616535997", "time_retrieved": "2024-07-30T19:31:02.289602", "image_code": "// Simple Hex, Tri, Square, Ocatagonal, Diamond and Brick grids - (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 23/03/2021\n\n// All 6 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\n// simple diamond grid equiv\nvec4 DiamondGrid(vec2 uv, out vec2 id)\n{\n    uv = uv* mat2(1,-1,1,1);\n    return(SquareGrid(uv,id));\n}\n\n// simple brick grid equiv\nvec4 BrickGrid(vec2 uv, out vec2 id)\n{\n    vec2 pos = uv * vec2(1.0,2.0);\n    if(fract(uv.y)>0.5)\n        pos.x += 0.5;\n    id = floor(pos);\n    id.y *= 0.5;\n    pos = fract(pos);\n    vec2 uv2 = fract (pos)-0.5;\n    uv2.y *= 0.5;\n    pos=abs(fract (pos + 0.5) - 0.5);\n    float d = min(pos.x,pos.y*0.5);\n    return vec4(abs(d),length(uv2),uv2);\n}\n\n// Shanes ocatagonal-diamond grid equiv - https://www.shadertoy.com/view/3tGBWV \nvec4 OcatagonalGrid(vec2 uv, out vec2 id)\n{\n    vec2 guv;\n    vec2 p = uv - .5;\n    id = floor(p) + .5;\n    p -= id;\n    float d = abs(p.x) + abs(p.y) - (1. - sqrt(2.)/2.);\n    if(d<.0)\n    {\n        // inside a diamond\n        guv = fract(p-0.5)-0.5;\n        id += .5;\n    }\n    else\n    {\n        // inside an octagon\n        guv = fract(p)-0.5;\n        p = uv;\n        id = floor(p) + .5;\n        p -= id;\n        d = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n    }\n    return vec4(abs(d), length(guv), guv);\n}\n\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 6xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(vec2 xxyy)\n{\n    float gridtype = 0.5;\n    vec2 mx = ((iMouse.xy-.5*iResolution.xy) / iResolution.xy)+0.5;\n    if (iMouse.z>0.5)\n        xxyy=mx;\n    if (xxyy.x>0.66)\n        gridtype=2.5;\n    else if (xxyy.x>0.33)\n        gridtype = 1.5;\n    if (xxyy.y<0.5)\n        gridtype+=3.0;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float zoom = 8.0;\n    if (iMouse.z>0.5)\n        zoom += sin(t);\n    float gridtype = SelectGrid(vec2(xx,yy));\n    if (gridtype>= 5.0)\n        h = BrickGrid(uv*zoom, id);\n    else if (gridtype>= 4.0)\n        h = DiamondGrid(uv*zoom, id);\n    else if (gridtype>= 3.0)\n        h = OcatagonalGrid(uv*zoom, id);\n    else if (gridtype>= 2.0)\n        h = SquareGrid(uv*zoom, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*zoom, id);\n    else\n        h = TriGrid(uv*zoom, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol1 = vec3(0.35,0.15,0.2);\n    vec3 shapecol2 = vec3(0.9,0.9,0.45);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float blend = pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    float cm = 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n\n    vec3 shapecol = mix(shapecol1,shapecol2,blend)*cm;\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025), step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 375, 411, 411, 919], [921, 1134, 1170, 1170, 1728], [1730, 1758, 1797, 1797, 1996], [1998, 2027, 2067, 2067, 2129], [2131, 2158, 2196, 2196, 2504], [2506, 2587, 2630, 2630, 3125], [3128, 3128, 3170, 3170, 3211], [3213, 3273, 3302, 3302, 3594], [3596, 3596, 3653, 3653, 5746]], "test": "untested"}
{"id": "sdfGz7", "name": "Castle Oblivion", "author": "kstyler", "description": "A shader inspired by castle oblivion from kingdom hearts", "tags": ["3d", "raymarching", "organization13", "kingdomhearts"], "likes": 12, "viewed": 452, "published": 3, "date": "1616535469", "time_retrieved": "2024-07-30T19:31:03.065529", "image_code": "//Reference https://iquilezles.org/articles/distfunctions\n\nfloat pi = acos(-1.);\nint mat_id = 0;\n\nfloat s_union( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat s_sub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvec3 radial_rep(vec3 p, float num_rep){\n    float ang = (2.*pi) / num_rep;\n    float sector = round(atan(p.z,p.x)/ang); \n    float an = sector*ang;\n    vec3 q = p;\n    q.xz = rot(an)*q.xz;\n    return q;\n} \n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat disk(vec3 p , float radius, float thickness){\n    float d = length(p.xz)-radius;\n    d = max(d,p.y-thickness*.5);\n    d = max(d,-p.y-thickness*.5);\n    return d;\n}\nfloat block( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pedestal(vec3 p){\n    p.y+=10.;\n    float union_ptc = 1.5;\n    float y_offset = 3.;\n    float top =  block(p+vec3(0.,-y_offset,0.),vec3(2.,.6,2.));\n    float mid =  block(p,vec3(1.5,2.5,1.5));\n    float bot =  block(p+vec3(0.,y_offset,0.),vec3(2.5,.6,2.5));\n    return s_union(bot,s_union(top,mid,union_ptc),union_ptc);\n}\n\nfloat planter(vec3 p){\n    p.y+=10.;\n    vec3 pos = radial_rep(p,4.)-.1;\n    float poker = block(pos+vec3(-5.,0.,0.),vec3(1.5,2.,3.));\n    float union_ptc = .5;\n    float y_offset = 3.5;\n    float top =  block(p+vec3(0.,-y_offset,0.),vec3(4.5,.6,4.5));\n    float mid =  block(p,vec3(4.,3.5,4.));\n    float bot =  block(p+vec3(0.,y_offset,0.),vec3(4.5,.6,4.5));\n    float core = s_union(bot,s_union(top,mid,union_ptc),union_ptc);\n    return s_sub(poker,core,union_ptc);\n}\n\nfloat vase(vec3 p){\n    p.y +=5.;\n    float pre_core = sphere(p,2.);\n    float core = max(pre_core,p.y-1.5);\n    float top = torus(p+vec3(0.,-1.5,0.),vec2(1.6,.3));\n    return min(top,core);\n}\n\nfloat room_box(vec3 p){\n    p+=vec3(0.,-7.7,-59.);\n    float box1 = block(p,vec3(25.,19.,60.));\n    float box2 = block(p,vec3(24.,18.,64.));\n    float box3 = block(p+vec3(0.,8.,29.),vec3(8.,10.,3.));\n    return max(-box3,max(box1,-box2));\n}\n\nfloat base(vec3 p){\n    vec3 pos = radial_rep(p,12.)-.1;\n    vec3 pos2 = radial_rep(p,12.*3.);\n    vec3 posOfs = vec3(9.,0.,0.);\n    vec3 posOfs2 = vec3(4.,0.,0.);\n    float dsk = disk(p,5.,.9);\n    float cutter = block(pos-posOfs,vec3(5.,6.,200.));\n    return max(-sphere(pos2-posOfs2,.3),max(-cutter,dsk));\n}\n\nfloat column_shaft(vec3 p){\n    p.y-=15.;\n    float rad = 2.;\n    rad -= (sin(p.y*.1)-1.)*.8;\n    rad -= 0.50*(0.3+0.3*sin(13.*atan(p.x,p.z)));\n    float d = length(p.xz)- rad;\n    d = max(d,p.y);\n    d = max(d,-p.y-30.);\n    return d;\n}\n\nfloat ellipsoid(vec3 p, vec3 r ){\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat chip(vec3 p){\n    p*=.9;\n    p.xz*=rot(p.x*.2);\n    return ellipsoid(p,vec3(5,6.-max(2.,p.y),.8)*.2);\n}\n\nfloat chip_ring(vec3 p,float r){\n    vec3 pos = radial_rep(p,12.);\n    vec3 final_pos = pos - vec3(r,0,0);\n    final_pos.xz*=rot(90.*pi/180.);\n    final_pos.yz*=rot(15.*pi/180.);\n    return chip(final_pos);\n}\n\nfloat full_column(vec3 p){\n    p.y+=15.;\n    vec3 q = abs(p+vec3(0.,-15.,0.));\n    vec3 b = abs(q+vec3(0.,15.,0.)); \n    q+=vec3(0.,-1.8,0.);\n    q.xz*=rot(45.*pi/180.);\n    q.xy*=rot(pi);\n    b.xy*=rot(pi);\n    b.y+=15.*2.;      \n    float total_base = min(chip_ring(q+vec3(0,11.4,0),3.3),\n            s_union(chip_ring(b+vec3(0.,-1.2 ,0.),3.55),\n            (base(b)),.45));                            \n                   \n    return min(column_shaft(p+vec3(0.,-15.,0.)),total_base);\n}\n\nfloat door_frame(vec3 p){\n    vec3 q = p;\n    p.x = abs(p.x);\n    p.x-= 9.;\n    float tall_block = block(p,vec3(1.1,10,1.1));\n    float base_block = block(p+vec3(0.,10,0.),vec3(1.6,.5,1.6));\n    float top_block = block(q+vec3(0.,-10,0),vec3(11,1.,1.6));\n    float top_block2 = block(q+vec3(0.,-11,0),vec3(12,.5,2.));\n    return s_union(top_block2,s_union(top_block,s_union(tall_block,base_block,.5),.5),1.5);\n}\n\n\nfloat plant(vec3 p){ \n    p.y+=7.;   \n    p.y+=(1.+sin(p.z*2.+.1))*.2;\n    p*=.5;\n    float eli = 90.;\n    for(int i = -4; i<-1; i++){\n        p.xz*=rot(((float(i)*10.)*pi/180.));\n        vec3 pos = radial_rep(p,5.)-.1;\n        pos.y+=float(i)*.4;\n        pos.x-=float(i)*.2;\n        pos.xz*=rot(-90.*pi/180.);\n        eli =s_union(eli,ellipsoid(pos,vec3((1.+pos.z*.001),.4,3.)),.1);\n    }\n    return eli;\n}\n\nfloat full_planter(vec3 p){\n    return min(plant(p),planter(p));\n}\n\nfloat full_pedistal(vec3 p){\n    return min(plant((p+vec3(0.,1.2,0.))/.4),min(vase(p),pedestal(p)));\n}\n\nfloat stair_way(vec3 p){\n    float c =4.;\n    vec3 q = p;\n    p.y+=12.7;\n    p.zy*=rot(8.*pi/180.);\n    p.z = p.z-c*clamp(round(p.z/c),-8.,0.);\n    p.z = mod(p.z+0.5*c,c)-0.5*c;  \n    p.zy *= rot(-8.*pi/180.);\n    float stp = block(p,vec3(10.,2.7,.5));\n    return stp;\n}\n\nfloat hall_way(vec3 p){\n    p.z+=10.;\n    float size = 10.;\n    float box1 = block(p,vec3(size,size+5.,size));\n    float box2 = block(p,vec3(size-.5,size+5.-.6,size+1.));\n    return max(box1,-box2);\n}\n\nfloat full_hall(vec3 p){\n    p.xz*=rot(pi);\n\n    return min(door_frame(p-vec3(0.,3.,-21.)),min(hall_way(p),\n        min(door_frame(p+vec3(0,.3,0.)),stair_way(p))));}\n\nfloat map(vec3 p){\n    float c =200.;\n    float c2 =c/4.;\n\n    vec3 q = p;\n    vec3 r = p;\n    vec3 s = p;\n      \n    p.zy*=rot(-8.*pi/180.);\n    p.z = mod(p.z+0.5*c,c)-0.5*c;\n    p.zy*=rot(8.*pi/180.);\n    \n    float box = block(p,vec3(100.,100,.1));\n    box = max(box,-block(p,vec3(8,10,1.)));\n    \n    q.y+=6.;\n    q.xz+=c2/2.;\n    q.zy*=rot(-8.*pi/180.);  \n    q.z = mod(q.z+0.5*c2,c2)-0.5*c2;\n    q.x = q.x-c2*clamp(round(q.x/c2),0.,1.);\n    q.zy*=rot(8.*pi/180.);\n   \n    r.x+=c2*.5/2.;\n    r.z+=50.;\n    r.y+=6.;\n    r.zy*=rot(-8.*pi/180.);  \n    r.z = mod(r.z+0.5*c2*2.,c2*2.)-0.5*c2*2.;\n    r.x = r.x-(c2*.5)*clamp(round(r.x/(c2*.5)),0.,1.);\n    r.zy*=rot(8.*pi/180.);\n     \n    s.x+=c2*.6/2.;\n    s.z+=100.;\n    s.y+=16.;\n    s.zy*=rot(-8.*pi/180.);  \n    s.z = mod(s.z+0.5*c2*4.,c2*4.)-0.5*c2*4.;\n    s.x = s.x-(c2*.6)*clamp(round(s.x/(c2*.6)),0.,1.);\n    s.zy*=rot(8.*pi/180.);\n    \n    return min(full_planter(s*.9),min(full_pedistal(r*.8),\n        min(full_column(q*.6),min(box,full_hall(p)))));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i <700; i++){\n        dst = map(ro+rd*tot);\n        tot += dst;\n        if(dst < 0.03 || tot > 700.){\n            tot=float(i)/200.;//https://www.shadertoy.com/view/tdBGWD\n            break;\n        }\n    }\n    if (dst > 0.03) mat_id = 1;\n    return tot;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,-1.,iTime*20.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float tilt = -8.;\n    ro.yz*=rot(tilt*pi/180.);\n    rd.yz*=rot(tilt*pi/180.);\n    vec3 col = 1.-vec3(march(ro,rd));\n    if(mat_id ==1)col = vec3(.95); \n    fragColor = vec4((col),1.0);\n}", "image_inputs": [{"id": 26334, "src": "https://soundcloud.com/michael-mike-carter/kingdom-hearts-iii-organization-13", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 144, 144, 244], [246, 246, 290, 290, 391], [393, 393, 411, 411, 460], [462, 462, 501, 501, 666], [669, 669, 704, 704, 735], [738, 738, 768, 768, 833], [835, 835, 886, 886, 1004], [1005, 1005, 1035, 1035, 1122], [1124, 1124, 1147, 1147, 1451], [1453, 1453, 1475, 1475, 1923], [1925, 1925, 1944, 1944, 2117], [2119, 2119, 2142, 2142, 2359], [2361, 2361, 2380, 2380, 2671], [2673, 2673, 2700, 2700, 2910], [2912, 2912, 2945, 2945, 3034], [3036, 3036, 3055, 3055, 3145], [3147, 3147, 3179, 3179, 3355], [3357, 3357, 3383, 3383, 3844], [3846, 3846, 3871, 3871, 4256], [4668, 4668, 4695, 4695, 4734], [4736, 4736, 4764, 4764, 4838], [4840, 4840, 4864, 4864, 5110], [5112, 5112, 5135, 5135, 5312], [5314, 5314, 5338, 5338, 5479], [5481, 5481, 5499, 5499, 6492], [6494, 6494, 6524, 6524, 6840], [6842, 6842, 6897, 6897, 7223]], "test": "untested"}
{"id": "fsfGDB", "name": "London 3D - projective mapping", "author": "FabriceNeyret2", "description": "Mouse controls camera.  bottom left: back to auto demo.\nSPACE to show scene.\nTAB to toggle masking of hidden parts.\nInspired by Sig'97 \"Tour into the picture\" http://graphics.cs.cmu.edu/courses/15-463/2006_fall/www/Papers/TIP.pdf", "tags": ["raytracing", "raymarching", "regentstreet"], "likes": 19, "viewed": 584, "published": 3, "date": "1616533917", "time_retrieved": "2024-07-30T19:31:03.845442", "image_code": "#define rot(a)          mat2( cos( a + vec4(0,33,11,0)) )\n#define rot3(V)         V.yz *= rot(.03), V.xz *= rot(.4) // proj to photo frame\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat s,c0,c1, l=16.;                                 // material id\n\nfloat map( vec3 q ) {                                 // 3D model of Regent Street\n    q += vec3(-182,2,2);\n    float l = length(q.xz),\n    t = min( c1 = l-160.,                             // right facade\n             c0 = 184.-l );                           // left facade\n    t = min( t, max( l-170., 16.-q.y ));              // top of right facade\n \n    t = min(t, max( length(q.xz+vec2(174.1,40))-1.4 , abs(q.y)-1.8 ) ); // bus\n    t = min(t, max( length(q.xz+vec2(165,40))-.9 , abs(q.y)-1.45 ) );   // car\n    t = min(t, max( length(q.xz+vec2(169.5,25))-.24 , abs(q.y)-1. ) );   // pole\n    t = min( t, s = q.y);                             // floor\n    t = max( t, q.z -2. );                            // front plane\n    return t;\n}\n\n#define march \\\n    for ( ; c < 350. && t > .01 ; c++ )               /* march scene         */ \\\n        t = map(p),                                   /* distance to objects */ \\\n        p += .5*t*D;                                  /* sphere-tracing step */\n        \nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,                      // normalized centered coords\n         M = iMouse.xy;\n\n    float t = iTime, \n          c = 0., F=4.;                               // color (pseudo-shading), delta per iteration\n    vec3  D = normalize( vec3(U,-F) ),                // ray direction. z = field of view = zoom\n          p = length(M) > 20.                         // ray origin, then current point on ray\n                ? M/=R,- vec3( 4.*(M.x-.5), 0, 15.*(M.y-.2) )            // mouse control\n                                          // p.y += 5.*(1.-M.y);\n                : vec3(2.*cos(iTime),1.+sin(iTime),-5.-5.*cos(iTime/3.));// demo mode\n    rot3(D), rot3(p);                                 // rotate camera\n    march;                                            // march scene\n    \n    if (keyToggle(32)) {                              // --- show 3D mode\n        c = 1. - c/250.;                              // pseudo-lighting\n        O = t==c0 ? vec4(.6,1,.8,1) : t==c1 ? vec4(1,.8,.6,1) \n           : t==s ? vec4(0,.2,0,1) : vec4(1);         // coloring\n        O = c*O; \n    } else O-=O;\n                                                      // --- project photo on 3D scene\n    vec3 X = vec3(1,0,0), Y = vec3(0,1,0), Z = vec3(0,0,1), p0=p;\n    rot3(X), rot3(Y), rot3(Z);\n // p.xz *= rot(-.4); p.yz *= rot(-.03);              // why is it not equivalent ?\n    vec2 T = .5 - 2.*R.y/R*vec2( dot(p,X), dot(p,Y) ) / dot(p,Z), // go to texture-projector space\n         A = abs(T-.5); \n    D = normalize(p), p-=p, c=0., t++; march;         // new ray to check whether p was hidden\n    if ( max(A.x,A.y) < .5) O += keyToggle(32)\n               ? 2.*( textureLod(iChannel0,T,0.) - textureLod(iChannel0,T,2.) ) // sketch (in 3D mode )\n               : length(p-p0)/ abs(dot(p0,Z))<.1 || !keyToggle(9)               // p not hidden:\n                   ?   texture(iChannel0,T)                                     // projected texture\n                   : ( textureLod(iChannel0,T,log2(l))*l-texture(iChannel0,T) )/(l-1.); // desoccluded: mask front object\n\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 298, 359, 1017], [1288, 1288, 1324, 1324, 3435]], "test": "untested"}
{"id": "NdXGD2", "name": "Distance to Quadratic Bezier", "author": "oneshade", "description": "It seems to be the parametric equivalent of a parabola.", "tags": ["2d", "sdf", "bezier", "distance", "quadratic", "parametric", "exact"], "likes": 6, "viewed": 261, "published": 3, "date": "1616523972", "time_retrieved": "2024-07-30T19:31:04.617379", "image_code": "// Desmos graph with some explanations:\n// https://www.desmos.com/calculator/8krasu99ke\n\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s3) * 0.5;\n    vec2 b = vec2(s1, s2) * 0.5;\n    vec2 c = vec2(c3, c1) * 0.5;\n\n    float d = sdBezier(uv, a, b, c);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - a) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - b) - 0.01));\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - c) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 152, 152, 1365], [1367, 1367, 1422, 1422, 2440]], "test": "untested"}
{"id": "fdfGW2", "name": "trippy segmented noise moire ", "author": "morisil", "description": "quick experiment", "tags": ["noise", "texture", "moire"], "likes": 4, "viewed": 371, "published": 3, "date": "1616519470", "time_retrieved": "2024-07-30T19:31:05.385325", "image_code": "// Fork of \"textured noise segments\" by morisil. https://shadertoy.com/view/fsX3zX\n// 2021-03-23 16:31:22\n\nconst float NOISE_SCALE = .5;\nconst float NOISE_SCALING_SPEED = 1.1;\nconst float NOISE_SPEED = .6;\nconst float SEGMENT_COUNT = float(500);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 channel0Color = 1. - texture(iChannel0, uv).rgb;\n    vec3 channel1Color = 1. - texture(iChannel1, uv).rgb;\n    vec2 noiseSt = st * NOISE_SCALE;\n    float noise = (Perlin3D(vec3(noiseSt, iTime * NOISE_SPEED)) + 1.) / 2.;\n    float segment = mod(noise * SEGMENT_COUNT, 1.);\n    int segmentIndex = int(noise * SEGMENT_COUNT);\n    vec3 color;\n    if (mod(float(segmentIndex), 2.) == 0.) {\n        color = mix(channel0Color, channel1Color, segment);\n    } else {\n      color = mix(channel1Color, channel0Color, segment);\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 304, 304, 998]], "test": "untested"}
{"id": "NdX3Wj", "name": "Angular repeticion", "author": "jorge2017a1", "description": "Angular repeticion", "tags": ["angularrepeticion"], "likes": 2, "viewed": 227, "published": 3, "date": "1616513755", "time_retrieved": "2024-07-30T19:31:06.336781", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec2 MediaEsfera(vec3 p, float numItem)\n{\n    \n    p= rotate_x(p-vec3(0.0,0.0,0.0), radians(90.0));\n    float tau = atan(1.0) * 8.0;\n    vec3 pp;\n\n    float alto=8.0;\n    p-=vec3(0.0,0.0,alto);\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    vec3 rep3 = opAngRep(p, tau / (numItem/2.0));\n    \n    float diam=8.0;\n\tfloat sdsp1=sdSphere(p, diam);\n    float sdsp2=sdSphere(p, diam+0.5);\n    float sdb1= sdBox(rep2, vec3(8.5,0.2,diam));\n    float sdb2= sdBox(p-vec3(0.0,0.,-diam/2.0-0.5), vec3(8.5,diam+0.5,diam/2.0));\n    float sPostes= sdCylinderXY(  rep3-vec3(6.0,0.0,-alto), vec2(0.8,alto) );\n    \n    vec2 res2 = vec2(-9999.9,-1.0);\n    float res;\n    res2= opU2( vec2(sdsp1,1.0), vec2(sdb1,4.0) );\n    res2= opI2(res2, vec2(sdsp2, 4.0) );\n    res2.x=differenceSDF(res2.x,sdb2);\n    res2= opU2(res2, vec2( sPostes,5.0) ); \n  return  res2;\n}\n\n\nvec2 DiscoConBarandal(vec3 pp)\n{\n vec3 p=pp;\n vec2 res=vec2(9999.9,-1.0);\n float numItem =10.0;\n \n float tau = atan(1.0) * 8.0;\n p= rotate_x(p-vec3(0.0,1.0,0.0), radians(90.0));\n vec3 rep2 = opAngRep(p, tau / numItem);\n vec3 rep3 = opAngRep(p, tau / numItem);\n vec3 rep4 = opAngRep(p-vec3(0.0,0.0,6.0), tau / numItem);\n\n float b1= sdBox(rep2-vec3(9.0,0.0,0.0), vec3(0.5,3.5,0.5));\n float b2= sdBox(rep4-vec3(9.0,0.0,0.0), vec3(0.5,3.5,0.5));\n float c1= sdCylinderXZ(pp, vec2(10.0,0.5) );\n float sPostes= sdCylinderXY(  rep3-vec3(9.0,0.0,3.0), vec2(0.5,3.0) );\n \n res=vec2(c1,1.0);\n res=opU2(res,vec2(b1,2.0));\n res=opU2(res,vec2(b2,2.0));\n res= opU2(res, vec2( sPostes,7.0) ); \n return res;\n}\n\nvec2 DiscoConBarandal2Postes(vec3 pp)\n{\n vec3 p=pp;\n vec2 res=vec2(9999.9,-1.0);\n float numItem =14.0;\n \n float tau = atan(1.0) * 8.0;\n float ancho=15.0;\n float alto=9.0;\n p= rotate_x(p-vec3(0.0,1.0,0.0), radians(90.0));\n vec3 rep2 = opAngRep(p, tau / numItem);\n vec3 rep3 = opAngRep(p, tau / numItem);\n vec3 rep4 = opAngRep(p-vec3(0.0,0.0,6.0), tau / numItem);\n vec3 rep5 = opAngRep(p, tau / 6.0);\n\n float b1= sdBox(rep2-vec3(ancho-1.0,0.0,0.0), vec3(0.5,3.5,0.5));\n float b2= sdBox(rep4-vec3(ancho-1.0,0.0,0.0), vec3(0.5,3.5,0.5));\n float c1= sdCylinderXZ(pp, vec2(ancho,0.5) );\n float sPostesA= sdCylinderXY(  rep3-vec3(ancho-1.0,0.0,3.0), vec2(0.5,3.0) );\n float sPostesB= sdCylinderXY(  rep5-vec3(ancho/1.5-1.0,0.0,alto), vec2(0.5,alto) );\n \n res=vec2(c1,1.0);\n res=opU2(res,vec2(b1,2.0));\n res=opU2(res,vec2(b2,2.0));\n res= opU2(res, vec2( sPostesA,7.0) ); \n res= opU2(res, vec2( sPostesB,5.0) ); \n return res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n \tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    p.y=p.y-10.0;\n    \n   vec2 me1=MediaEsfera( p-vec3(0.0,26.0,0.0), 12.0);\n   vec2 db1=DiscoConBarandal(p-vec3(0.0,18.0,0.0));\n   vec2 db2=DiscoConBarandal2Postes(p-vec3(0.0,0.0,0.0));\n   res =opU3(res, vec3(me1.x,me1.y,MATERIAL_NO)); \n   res =opU3(res, vec3(db1.x,db1.y,MATERIAL_NO));\n   res =opU3(res, vec3(db2.x,db2.y,MATERIAL_NO));\n     //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n       if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n       if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO);break; }\n        dO += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n  \n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,17.0+20.0*abs(sin(t)),-35.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n    //col= getSkyColB(rd, uv, vec3(0.0));\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdX3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[563, 563, 599, 599, 620], [621, 621, 653, 653, 737], [739, 739, 778, 778, 873], [874, 874, 913, 913, 1008], [1009, 1009, 1048, 1048, 1143], [1145, 1189, 1236, 1236, 1263], [1265, 1265, 1308, 1308, 1335], [1337, 1337, 1385, 1385, 1413], [1461, 1486, 1520, 1520, 1618], [1619, 1619, 1653, 1653, 1745], [1746, 1746, 1780, 1780, 1872], [1873, 1913, 1947, 1947, 2044], [2076, 2076, 2102, 2102, 2156], [2158, 2158, 2192, 2192, 2360], [2362, 2362, 2403, 2403, 3203], [3206, 3206, 3238, 3238, 3898], [3900, 3900, 3939, 3939, 4818], [4820, 4860, 4885, 4885, 5492], [5496, 5496, 5561, 5561, 6125], [6127, 6178, 6202, 6202, 6363], [6365, 6365, 6398, 6398, 7062], [7063, 7117, 7153, 7153, 7387], [7388, 7489, 7569, 7569, 7837], [7838, 7889, 7936, 7936, 8723], [8777, 8777, 8870, 8870, 9145], [9149, 9149, 9176, 9176, 9286], [9292, 9341, 9398, 9398, 10825]], "test": "untested"}
{"id": "sslGWB", "name": "Fractal 44_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 366, "published": 3, "date": "1616502797", "time_retrieved": "2024-07-30T19:31:07.098744", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<80.;\n        O.xyz+=.05*abs(cos(d+log(s)*.8))*exp(-1.5*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=1.5;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=1.5;\n        for(int j=0;j++<8;s*=e)\n            p=sign(p)*(1.2-abs(p-1.2)),\n            p=p*(e=8./clamp(dot(p,p),.6,5.5))+q-vec3(.3,8,.3);\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 575]], "test": "untested"}
{"id": "ssX3WB", "name": "ray marching - v2", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 0, "viewed": 207, "published": 3, "date": "1616493074", "time_retrieved": "2024-07-30T19:31:07.864696", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.1\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(vec3(1,1,-.9));\nvec3 light2 = normalize(vec3(-1,0,-.9));\n\nfloat distance_to_wave_sphere_repeat(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(vec3(mod(ray.x+2.,2.)-1., ray.y, mod(ray.z+2.,2.)-1.), pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(ray, pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    /*float h = clamp( 0.5 + 0.5*(d2-d1)/s, 0.0, 1.0 );\n    return mix( d2, d1, h ) - s*h*(1.0-h);*/\n    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float min_distance = MAX_STEP_SIZE;\n    \n    float size = .9;\n    float k = SHAPE_BLEND;\n    \n    float d = distance_to_wave_sphere_repeat(ray, vec3(0,-4,0), 1., 0.05, vec3(5.3,3.7,4.5), 1.9);\n    float d1 = distance_to_wave_sphere(ray, vec3(0,0,6), 1.5, 0.05, vec3(5.3,3.7,4.5), .9);\n    float d2 = distance_to_sphere(ray, vec3(2.*sin(iTime*2.), 2.*sin(iTime*0.8), 6.+2.*sin(iTime*0.6)), size); \n    /*float d3 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.8), 2.*sin(iTime*0.6), 6.+2.*sin(iTime*2.)), size); \n    float d4 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.1), 2.*sin(iTime*2.), 6.+2.*sin(iTime*0.4)), size); \n    float d5 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.5), 2.*sin(iTime*2.1), 6.+2.*sin(iTime*0.7)), size); */\n   \n    //min_distance = smooth_min(smooth_min(smooth_min(d1, d2, k), smooth_min(d3, d4, k), k), d5, k);\n    \n    // shape blending\n    min_distance = smooth_min(d1, d2, k);\n    min_distance = min(min_distance, d);\n    \n    // color blending\n    vec3 color1 = vec3(1,0,0);\n    vec3 color2 = vec3(.3,0,1);\n    \n    shininess = 1.;\n      \n    float t = tanh((d1-d2)*COLOR_BLEND);\n    color = ((1.+t)*color1 + (1.-t)*color2)/2.;\n    \n    // glow on intersection\n    color += vec3(1,1,1)*(pow(1.-t*t, 10.*(4.+sin(ray.y*100.)+cos(ray.x*100.)) ));\n    \n    if(d == min_distance){\n        color *= 0.3;\n        shininess = 0.;\n    }\n    \n    \n    return min_distance;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5;\n            color = bodyColor*l1 + bodyColor*l2 + (vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.))*shininess;\n            \n            // fog in the distance\n            color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.4,.9)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 463, 463, 691], [693, 693, 798, 798, 976], [978, 978, 1032, 1032, 1069], [1071, 1071, 1120, 1221, 1298], [1300, 1300, 1367, 1367, 2772], [2774, 2774, 2804, 2804, 2883], [2885, 2885, 2907, 2907, 3269], [3271, 3271, 3296, 3296, 4429], [4431, 4431, 4488, 4523, 4768]], "test": "untested"}
{"id": "sdl3WS", "name": "Stairway to Hell", "author": "dr2", "description": "More balls leaping downstairs", "tags": ["collision", "ball", "dynamics", "physics", "step"], "likes": 15, "viewed": 376, "published": 3, "date": "1616492747", "time_retrieved": "2024-07-30T19:31:08.818147", "image_code": "// \"Stairway to Hell\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// More balls leaping downstairs\n// A companion to \"Stairway from Heaven\" (and based on \"Racetrack\")\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 200;   // same in all shaders\nconst float nLev = 16.;\n\nvec3 ltDir, vnBall, bSize;\nfloat tCur, dstFar, helHt;\nint idBall, idObj;\nconst int idHel = 1, idTier = 2, idWal = 3, idGrnd = 4;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h, r;\n  dMin = dstFar;\n  q = p;\n  q.y -= helHt;\n  d = PrCylDf (q.xzy, bSize.x, 0.01);\n  DMIN (idHel);\n  q = p;\n  q.y -= 0.5;\n  d = dMin;\n  for (float nh = float (VAR_ZERO); nh < nLev; nh ++) {\n    q.y -= bSize.y;\n    d = min (d, PrCylDf (q.xzy, bSize.x - 0.5 + nh * bSize.z, bSize.y));\n  }\n  q = p;\n  h = 0.5 * (nLev * bSize.y + 0.5);\n  q.y -= h;\n  r = bSize.x + nLev * bSize.z;\n  d = max (PrCylDf (q.xzy, r - 0.25, h), - d);\n  DMIN (idTier);\n  h += 1.3 * bSize.y;\n  q = p;\n  q.y -= h;\n  d = max (PrCylDf (q.xzy, r + 0.5, h), r - 0.5 - length (q.xz));\n  DMIN (idWal);\n  q = p;\n  d = max (q.y - 2. * h + 1., r - length (q.xz));\n  DMIN (idGrnd);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.47 * p.w * clamp ((nLev + 2.) * bSize.y + mod (float (n), 2.) - p.y, 0.1, 1.);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.47 * p.w * clamp ((nLev + 2.) * bSize.y + mod (float (n), 2.) - p.y, 0.1, 1.);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.5 + 0.5 * smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return 0.6 + 0.4 * step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 BallCol ()\n{\n  float c;\n  c = 33. * float (idBall) / float (nBall);\n  return HsvToRgb (vec3 (mod (c, 1.), 1. - 0.1 * mod (c, 8.), 1.)) * BallChqr (idBall, vnBall);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, dstBall, sh;\n  col = vec3 (0.2);\n  dstObj = ObjRay (ro, rd);\n  dstBall = BallHit (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += rd * dstObj;\n      vn = ObjNf (ro);\n      if (idObj == idHel) {\n        col4 = vec4 (mix (vec3 (1., 0., 0.), vec3 (0.8, 0.4, 0.),\n           step (0.6, Fbm2 (4. * ro.xz * vec2 (1. + 0.5 * sin (tCur))))), -1.);\n        vf = vec2 (4., 2.);\n      } else if (idObj == idWal) {\n        col4 = vec4 (0.6, 0.6, 0.65, 0.05) * (0.85 + 0.15 * smoothstep (0., 0.05, mod (0.5 * ro.y, 1.)));\n        vf = vec2 (32., 1.);\n      } else if (idObj == idTier) {\n        col4 = (floor (mod (ro.y / bSize.y + 0.55, 2.)) == 0.) ? vec4 (0.5, 0.4, 0.3, 0.05) :\n           vec4 (0.6, 0.65, 0.5, 0.05);\n        vf = vec2 (32., 0.5);\n      } else if (idObj == idGrnd) {\n        col4 = mix (vec4 (0.2, 0.25, 0.2, 0.), vec4 (0.4, 0.4, 0.2, 0.), Noisefv2 (128. * ro.xz)) *\n           (1. - 0.3 * Fbm2 (0.25 * ro.zx));\n        vf = vec2 (4., 2.);\n      }\n      vn = VaryNf (vf.x * ro, vn, vf.y);\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (BallCol (), 0.1);\n    }\n    if (col4.a >= 0.) {\n      sh = min (ObjSShadow (ro + 0.01 * ltDir, ltDir), BallHitSh (ro + 0.01 * ltDir, ltDir, 10.));\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    if (dstBall < dstObj) col = mix (vec3 (1., 0., 0.) * (0.6 - 0.4 * dot (vn, rd)), col, \n       0.3 + 0.7 * smoothstep (0.2, 1.2, Loadv4 (4 * idBall).y - helHt));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 rd, ro, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bSize = Loadv4 (4 * nBall).xyz;\n  helHt = 0.5 + 0.4 * (1. + sin (0.2 * pi * tCur));\n  dstFar = 200.;\n  az = 0.;\n  el = -0.3 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.2 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, -0.22 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 7., -110.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  zmFac = 4.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Stairway to Hell\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 200;\nconst float nLev = 16.;\n\nvec3 bSize;\nfloat todCur, stSize, fOvlap, fricN, fricS, fricSW, fricT;\nconst float pi = 3.14159;\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam;\n  float fDamp, fCent, grav, rSep, szN, szAv, ft, ms, drv, dt, fnh;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricS = 0.05;\n  fricSW = 1.;\n  fricT = 0.5;\n  fDamp = 0.02;\n  fCent = 0.01;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  for (float nh = float (VAR_ZERO); nh <= nLev; nh ++) {\n    dr.y = (nh < nLev) ? max (abs (rm.y) - (nh + 1.) * bSize.y, 0.) : 0.;\n    dr.xz = vec2 (min (length (rm.xz) - bSize.x - nh * bSize.z, 0.) * normalize (rm.xz));\n    rSep = length (dr);\n    if (rSep < szAv) {\n      CollFc (rSep, szAv, dr, vm, wm, am, wam);\n    }\n  }\n  am.xz -= fCent * normalize (rm.xz);\n  am.y -= grav * ms;\n  am -= fDamp * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = (bSize.x + (nLev - 1.) * bSize.z) * sin (2. * pi * mIdf / float (nBall) + vec2 (0.5 * pi, 0.));\n  rm.y = (nLev + 2.) * bSize.y + mod (mIdf, 2.);\n  vm = 0.5 * normalize (vec3 (Hashff (mIdf + todCur), 0., Hashff (mIdf + todCur)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 1) discard;\n  todCur = iDate.w;\n  doInit = (iFrame <= 5);\n  if (doInit) {\n    bSize = vec3 (3., 1., 1.6);\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (4 * nBall);\n    bSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else {\n      Step (mId, rm, vm, qm, wm, sz);\n      if (rm.y < 0.) Init (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = pxId - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    stDat = vec4 (bSize, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Stairway to Hell\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 200;\nconst float nLev = 16.;\n\nvec3 bSize;\nfloat todCur, stSize, fOvlap, fricN, fricS, fricSW, fricT;\nconst float pi = 3.14159;\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam;\n  float fDamp, fCent, grav, rSep, szN, szAv, ft, ms, drv, dt, fnh;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricS = 0.05;\n  fricSW = 1.;\n  fricT = 0.5;\n  fDamp = 0.02;\n  fCent = 0.01;\n  grav = 10.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  for (float nh = float (VAR_ZERO); nh <= nLev; nh ++) {\n    dr.y = (nh < nLev) ? max (abs (rm.y) - (nh + 1.) * bSize.y, 0.) : 0.;\n    dr.xz = vec2 (min (length (rm.xz) - bSize.x - nh * bSize.z, 0.) * normalize (rm.xz));\n    rSep = length (dr);\n    if (rSep < szAv) {\n      CollFc (rSep, szAv, dr, vm, wm, am, wam);\n    }\n  }\n  am.xz -= fCent * normalize (rm.xz);\n  am.y -= grav * ms;\n  am -= fDamp * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = (bSize.x + (nLev - 1.) * bSize.z) * sin (2. * pi * mIdf / float (nBall) + vec2 (0.5 * pi, 0.));\n  rm.y = (nLev + 2.) * bSize.y + mod (mIdf, 2.);\n  vm = 0.5 * normalize (vec3 (Hashff (mIdf + todCur), 0., Hashff (mIdf + todCur)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 1) discard;\n  todCur = iDate.w;\n  doInit = (iFrame <= 5);\n  if (doInit) {\n    bSize = vec3 (3., 1., 1.6);\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (4 * nBall);\n    bSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else {\n      Step (mId, rm, vm, qm, wm, sz);\n      if (rm.y < 0.) Init (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = pxId - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    stDat = vec4 (bSize, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3WS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[865, 865, 887, 887, 1575], [1577, 1577, 1610, 1610, 1794], [1796, 1796, 1817, 1817, 2074], [2076, 2076, 2113, 2113, 2342], [2344, 2344, 2378, 2378, 2870], [2872, 2872, 2919, 2919, 3374], [3376, 3376, 3418, 3418, 3624], [3626, 3626, 3643, 3643, 3796], [3798, 3798, 3833, 3833, 5565], [5567, 5567, 5623, 5623, 6739], [6741, 6741, 6783, 6783, 6834], [6836, 6836, 6861, 6861, 7257], [7259, 7259, 7283, 7283, 7419], [7421, 7421, 7451, 7451, 7564], [7566, 7566, 7602, 7602, 7808], [7842, 7842, 7866, 7866, 7996], [7998, 7998, 8023, 8023, 8209], [8211, 8211, 8232, 8232, 8387], [8389, 8389, 8418, 8418, 8630], [8632, 8632, 8671, 8671, 8851], [8945, 8945, 8970, 8970, 9093]], "test": "untested"}
{"id": "sssGWS", "name": "Fractal 43_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 10, "viewed": 436, "published": 3, "date": "1616492181", "time_retrieved": "2024-07-30T19:31:09.591080", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<80.;\n        O.xyz+=.02*abs(cos(d+log(s)*.3))*exp(-.5*i*i*e)\n    )\n    {\n        p=g*d;\n        p-=vec3(1.,.1,.1);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=1.5;\n        for(int j=0;j++<15;s*=e)\n            p=sign(p)*(1.2-abs(p-1.2)),\n            p=p*(e=8./clamp(dot(p,p),.3,5.5))+q*2.;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 573]], "test": "untested"}
{"id": "Ndl3DB", "name": "Fuzzy Neural XOR", "author": "oneshade", "description": "Output of a neural network I trained to perform XOR operations. The corners of the square are the data points, blue = 0, red = 1. Drag with the mouse to move the view.", "tags": ["test", "xor", "fuzzy", "neural", "deeplearning", "neuralnetworks", "datascience"], "likes": 7, "viewed": 193, "published": 3, "date": "1616486094", "time_retrieved": "2024-07-30T19:31:10.542536", "image_code": "/*\nI read through this online book about how neural networks work:\nhttp://neuralnetworksanddeeplearning.com/\n\nIt was pretty good but a little bit technical. When I first read it,\nI had no idea what a derivative was or what the notation meant so I\nkind of gave up on it at first (partly my reason for being excited\nwhen I learned out how to compute derivatives) :/\n\nAnyway, I picked it back up later on and made it through and made a small neural\nnetwork library in python:\nhttps://replit.com/@hathnoname/Deep-Learning-II\n\nThen ported it to JavaScript (multidimensional arrays = I need recursion) :D\nPlain version: https://codehs.com/editor/html/3926213/2209646/index.html\np5.js version (why?): https://editor.p5js.org/pythontales/full/Ef7HJ26zk\n\nI partially auto-generated the GLSL data with this little program I made:\nhttps://replit.com/@hathnoname/Neural-Network-to-GLSL#main.py\n*/\n\n#define draw(d, c) fragColor.rgb = mix(fragColor.rgb, c, smoothstep(unit, 0.0, d))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    uv -= (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 2.0 / iResolution.y;\n\n    // Query the neural network and colorize the result\n    mat1x1 result = ProcessNN(mat2x1(uv.x, uv.y));\n    fragColor = vec4(result._00, 0.0, 1.0 - result._00, 1.0);\n\n    vec2 cornerA = vec2(0.0, 0.0);\n    vec2 cornerB = vec2(1.0, 0.0);\n    vec2 cornerC = vec2(1.0, 1.0);\n    vec2 cornerD = vec2(0.0, 1.0);\n\n    draw(sdLine(uv, cornerA, cornerB, 0.01), vec3(0.0));\n    draw(sdLine(uv, cornerB, cornerC, 0.01), vec3(0.0));\n    draw(sdLine(uv, cornerC, cornerD, 0.01), vec3(0.0));\n    draw(sdLine(uv, cornerD, cornerA, 0.01), vec3(0.0));\n\n    draw(sdDisc(uv, cornerA, 0.05), vec3(0.0));\n    draw(sdDisc(uv, cornerB, 0.05), vec3(0.0));\n    draw(sdDisc(uv, cornerC, 0.05), vec3(0.0));\n    draw(sdDisc(uv, cornerD, 0.05), vec3(0.0));\n}", "image_inputs": [], "common_code": "// 1 row, 1 column\nstruct mat1x1 {\n    float _00;\n};\n\n// 2 rows, 1 column\nstruct mat2x1 {\n    float _00;\n    float _10;\n};\n\n// 10 rows, 1 column\nstruct mat10x1 {\n    float _00;\n    float _10;\n    float _20;\n    float _30;\n    float _40;\n    float _50;\n    float _60;\n    float _70;\n    float _80;\n    float _90;\n};\n\n// 10 rows, 2 columns\nstruct mat10x2 {\n    float _00; float _01;\n    float _10; float _11;\n    float _20; float _21;\n    float _30; float _31;\n    float _40; float _41;\n    float _50; float _51;\n    float _60; float _61;\n    float _70; float _71;\n    float _80; float _81;\n    float _90; float _91;\n};\n\n// 1 row, 10 columns\nstruct mat1x10 {\n    float _00; float _01; float _02; float _03; float _04; float _05; float _06; float _07; float _08; float _09;\n};\n\n// 10 rows, 10 columns\nstruct mat10x10 {\n    float _00; float _01; float _02; float _03; float _04; float _05; float _06; float _07; float _08; float _09;\n    float _10; float _11; float _12; float _13; float _14; float _15; float _16; float _17; float _18; float _19;\n    float _20; float _21; float _22; float _23; float _24; float _25; float _26; float _27; float _28; float _29;\n    float _30; float _31; float _32; float _33; float _34; float _35; float _36; float _37; float _38; float _39;\n    float _40; float _41; float _42; float _43; float _44; float _45; float _46; float _47; float _48; float _49;\n    float _50; float _51; float _52; float _53; float _54; float _55; float _56; float _57; float _58; float _59;\n    float _60; float _61; float _62; float _63; float _64; float _65; float _66; float _67; float _68; float _69;\n    float _70; float _71; float _72; float _73; float _74; float _75; float _76; float _77; float _78; float _79;\n    float _80; float _81; float _82; float _83; float _84; float _85; float _86; float _87; float _88; float _89;\n    float _90; float _91; float _92; float _93; float _94; float _95; float _96; float _97; float _98; float _99;\n};\n\nmat1x1 mul_mat1x10_mat10x1(in mat1x10 a, in mat10x1 b) {\n    return mat1x1(a._00 * b._00 + a._01 * b._10 + a._02 * b._20 + a._03 * b._30 + a._04 * b._40 + a._05 * b._50 + a._06 * b._60 + a._07 * b._70 + a._08 * b._80 + a._09 * b._90);\n}\n\nmat10x1 mul_mat10x2_mat2x1(in mat10x2 a, in mat2x1 b) {\n    return mat10x1(a._00 * b._00 + a._01 * b._10,\n                   a._10 * b._00 + a._11 * b._10,\n                   a._20 * b._00 + a._21 * b._10,\n                   a._30 * b._00 + a._31 * b._10,\n                   a._40 * b._00 + a._41 * b._10,\n                   a._50 * b._00 + a._51 * b._10,\n                   a._60 * b._00 + a._61 * b._10,\n                   a._70 * b._00 + a._71 * b._10,\n                   a._80 * b._00 + a._81 * b._10,\n                   a._90 * b._00 + a._91 * b._10);\n}\n\nmat10x1 mul_mat10x10_mat10x1(in mat10x10 a, in mat10x1 b) {\n    return mat10x1(a._00 * b._00 + a._01 * b._10 + a._02 * b._20 + a._03 * b._30 + a._04 * b._40 + a._05 * b._50 + a._06 * b._60 + a._07 * b._70 + a._08 * b._80 + a._09 * b._90,\n                   a._10 * b._00 + a._11 * b._10 + a._12 * b._20 + a._13 * b._30 + a._14 * b._40 + a._15 * b._50 + a._16 * b._60 + a._17 * b._70 + a._18 * b._80 + a._19 * b._90,\n                   a._20 * b._00 + a._21 * b._10 + a._22 * b._20 + a._23 * b._30 + a._24 * b._40 + a._25 * b._50 + a._26 * b._60 + a._27 * b._70 + a._28 * b._80 + a._29 * b._90,\n                   a._30 * b._00 + a._31 * b._10 + a._32 * b._20 + a._33 * b._30 + a._34 * b._40 + a._35 * b._50 + a._36 * b._60 + a._37 * b._70 + a._38 * b._80 + a._39 * b._90,\n                   a._40 * b._00 + a._41 * b._10 + a._42 * b._20 + a._43 * b._30 + a._44 * b._40 + a._45 * b._50 + a._46 * b._60 + a._47 * b._70 + a._48 * b._80 + a._49 * b._90,\n                   a._50 * b._00 + a._51 * b._10 + a._52 * b._20 + a._53 * b._30 + a._54 * b._40 + a._55 * b._50 + a._56 * b._60 + a._57 * b._70 + a._58 * b._80 + a._59 * b._90,\n                   a._60 * b._00 + a._61 * b._10 + a._62 * b._20 + a._63 * b._30 + a._64 * b._40 + a._65 * b._50 + a._66 * b._60 + a._67 * b._70 + a._68 * b._80 + a._69 * b._90,\n                   a._70 * b._00 + a._71 * b._10 + a._72 * b._20 + a._73 * b._30 + a._74 * b._40 + a._75 * b._50 + a._76 * b._60 + a._77 * b._70 + a._78 * b._80 + a._79 * b._90,\n                   a._80 * b._00 + a._81 * b._10 + a._82 * b._20 + a._83 * b._30 + a._84 * b._40 + a._85 * b._50 + a._86 * b._60 + a._87 * b._70 + a._88 * b._80 + a._89 * b._90,\n                   a._90 * b._00 + a._91 * b._10 + a._92 * b._20 + a._93 * b._30 + a._94 * b._40 + a._95 * b._50 + a._96 * b._60 + a._97 * b._70 + a._98 * b._80 + a._99 * b._90);\n}\n\nmat10x1 add_mat10x1_mat10x1(in mat10x1 a, in mat10x1 b) {\n    return mat10x1(a._00 + b._00,\n                   a._10 + b._10,\n                   a._20 + b._20,\n                   a._30 + b._30,\n                   a._40 + b._40,\n                   a._50 + b._50,\n                   a._60 + b._60,\n                   a._70 + b._70,\n                   a._80 + b._80,\n                   a._90 + b._90);\n}\n\nmat1x1 add_mat1x1_mat1x1(in mat1x1 a, in mat1x1 b) {\n    return mat1x1(a._00 + b._00);\n}\n\nfloat sigmoid(in float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\nmat10x1 sigmoid_mat10x1(in mat10x1 m) {\n    return mat10x1(sigmoid(m._00),\n                   sigmoid(m._10),\n                   sigmoid(m._20),\n                   sigmoid(m._30),\n                   sigmoid(m._40),\n                   sigmoid(m._50),\n                   sigmoid(m._60),\n                   sigmoid(m._70),\n                   sigmoid(m._80),\n                   sigmoid(m._90));\n}\n\nmat1x1 sigmoid_mat1x1(in mat1x1 m) {\n    return mat1x1(sigmoid(m._00));\n}\n\nmat1x1 ProcessNN(in mat2x1 x) {\n    // Weight matrices\n    mat10x2 w1 = mat10x2(0.03319712196019374, 1.1443213500808143,\n                         4.1025171907472755, -3.3939830868252456,\n                         0.5371019223094989, -1.0676141608532879,\n                         3.3130540787612626, 2.932565477397576,\n                         -0.18699484207423323, -1.6230113875442005,\n                         -0.9989000059106591, 2.3518615871738273,\n                         0.9973805334227819, -1.5477152792319964,\n                         0.006535311163502047, 0.2938333563134656,\n                         1.3704374425038752, 0.7553207017474318,\n                         -1.1964403302092619, 0.7424747719924473);\n\n    mat10x10 w2 = mat10x10(-0.6768025286377598, -0.27581221417023444, 0.4912528203596843, 0.9400120935639843, -0.6056903527179655, -0.3987402660056572, 0.2227405626577809, -0.3866184867506283, -0.5249349658586657, -0.0782531756658623,\n                           -0.2689811316425999, -0.26272811172488064, -0.3603328264920885, 0.48308675140359403, 0.01649225880976562, -1.0760315121339439, 0.468769941977845, 0.48960739773039386, -0.7075747936482282, 0.3334055377343561,\n                           1.0455836327358385, -0.5841272876958203, 0.5001124083214444, -0.6891890477526228, -0.20527535433452967, 1.6040962956119083, -0.1209685485559765, 0.24440864866408915, -0.6646529414477744, 0.9779954122797109,\n                           -0.8257989974373184, 0.21893672848783285, 0.310546033541851, -0.9853165294611814, -0.6732428414763356, -0.07346480711305561, 0.6958688756482168, 0.3684194621634489, -0.9488344745706886, 0.8332880339640742,\n                           0.18518573920422657, 3.597226723892344, -1.111243255068065, -2.3905799711217446, -1.2970939487925481, 1.430276408072052, -1.3416738427094392, 0.8570069417219405, -0.9302251061559289, -0.1732136937175002,\n                           -0.7110678021682101, -0.8435272874637136, -0.9512417807972643, 1.066524728010091, 0.7046744837394627, -0.3323768974190991, -0.5922532450688203, -0.8682643859803765, -0.7183519665869231, -0.6603321383713966,\n                           -0.16667093163389887, -0.34218062546004946, 0.3214280643916874, 1.0198515234868897, -0.8715985990858606, -0.5571298449739921, 0.7118293934286183, -0.5149412594733537, -0.9056519843568237, 0.6056953138022804,\n                           -1.2685220417407892, -2.6651720161535364, 0.8685569116187667, 2.254966981649588, 1.0833914890790128, -0.35276231402347985, 0.904578081137413, 0.47066413977476307, 0.164994101903616, -0.4570107810635503,\n                           -0.5789810823682393, 0.4411527520906639, 0.5681751388564962, -0.2324651139132623, -0.46592371778418723, -0.22604159073381783, -0.8111695364866206, 0.768031104608796, 0.26761060404559484, 0.06422461569208453,\n                           -0.9340985316366729, -1.4074246833902868, 0.9603559293842688, 0.15132786604190876, 1.2768492830701852, -0.8938873936122481, 0.28590358364788077, 0.8578593497833432, -0.18826085911177398, 0.9214212993695868);\n\n    mat10x10 w3 = mat10x10(0.46676272343418007, 0.332592443659391, 1.2642565683754867, -0.6563336988445874, 1.5585217136059126, -0.6681070284038748, -0.4720370136060689, -1.359070695152831, -0.6398201641378277, -0.5984324035869767,\n                           -0.5409997617549247, 0.15998104086179915, 0.37009515712568614, 0.843495148906926, 1.586885007491395, -0.10403367938261608, -0.02003774360180638, -0.33832089975395124, 0.853333521210561, -1.6470289960947953,\n                           0.2616388575131632, -0.692159671456188, -0.20050862659183194, -0.5662148669116635, 0.010957521727648425, -0.469341152143319, -0.7135682319650349, 0.9669317198210222, -0.6363769457362074, 0.2852003374455695,\n                           -0.7464089186550206, 0.6022134970115437, -0.6348132285566299, 0.6771778379197521, -1.0998067743086384, -0.16814538576534666, 0.43465163556782127, 0.47508582974139096, -0.04473195316603569, -0.9068276037731076,\n                           0.9208645404123257, 0.6722254171061278, -0.6410526546541312, 0.020169883959730198, -0.13268329377433333, -0.4666561275957545, 0.25073083605609797, 1.2326732126956859, -0.08879019699915498, -0.7009860102270311,\n                           0.9989182090855052, 0.013830717781969534, -1.0641868493328248, -0.46890940361060274, -3.4038334011001306, 0.738791270350262, 0.4732314579236462, 2.4556939329714016, 0.14571145959764267, 1.0908061928749264,\n                           0.15466848584103293, 0.4273155873746734, 0.3664746983853679, 0.8093853931719543, 0.8940348020332515, 0.6839691856917931, -0.7637730825849424, -1.5675189252253519, 0.31108632939484704, -0.8240728717427835,\n                           0.8541101945173094, -0.7185054916128308, -0.17658314941057984, -0.623325377649105, 1.7679899930133705, -0.06761914944684302, -0.3545928901565393, -1.0559698485659559, 0.9065391336337847, -0.5319309256508692,\n                           -0.06742418620918407, 1.1607155138985432, -0.030913005873041244, -0.5631361967045277, -2.203697583987918, 0.1438673857884247, -0.02602940921115312, 1.2167637774088538, -0.5751881474463547, 0.4755783155709031,\n                           -0.27167342262469774, 0.05482346051981047, 0.9731748128009687, 0.6762066921735885, 1.598110631400287, -0.04747474183436243, -0.08179003670829647, -0.2921869130403052, 0.1464790340291019, -1.1987187506821098);\n\n    mat1x10 w4 = mat1x10(-2.177233718263722, -1.9010100206388543, 0.5494688788820955, 0.8168450813201754, 0.9361644411916604, 4.629773010702745, -1.6864751424887752, -1.8815771905221081, 2.5885685628056523, -1.612274192626207);\n\n    // Bias matrices (really column vectors)\n    mat10x1 b1 = mat10x1(-0.5321156028370169,\n                         1.9280505695263235,\n                         -0.7809458091944289,\n                         -0.6405181110978984,\n                         0.9661568738528844,\n                         0.21171734903751635,\n                         -0.7700648811812087,\n                         0.5282999314591963,\n                         0.2145147184590241,\n                         -0.27443820308791467);\n\n    mat10x1 b2 = mat10x1(0.47902447005940907,\n                         -0.03758760533029638,\n                         0.6608977808710413,\n                         -0.6832595918867784,\n                         -0.1913160428473142,\n                         0.063409386651786,\n                         0.7631860226239787,\n                         -0.306802137235167,\n                         -0.7467216920805032,\n                         0.4599784182699998);\n\n    mat10x1 b3 = mat10x1(-0.5355010564587633,\n                         -0.20151652712700624,\n                         0.20916348246743377,\n                         0.688588730890243,\n                         -0.45095366133021497,\n                         0.035847439577213536,\n                         0.2933532099557393,\n                         -0.30893823176433294,\n                         0.2479200535333875,\n                         -0.8689063226666305);\n\n    mat1x1 b4 = mat1x1(-0.22213313858704573);\n\n    // Repeatedly calculate new value of x: Xn+1 = (dot(Wn, Xn) + Bn)\n    // Propagating the results through the layers\n    mat10x1 l1 = sigmoid_mat10x1(add_mat10x1_mat10x1(mul_mat10x2_mat2x1(w1, x), b1));\n    mat10x1 l2 = sigmoid_mat10x1(add_mat10x1_mat10x1(mul_mat10x10_mat10x1(w2, l1), b2));\n    mat10x1 l3 = sigmoid_mat10x1(add_mat10x1_mat10x1(mul_mat10x10_mat10x1(w3, l2), b3));\n    mat1x1 l4 = sigmoid_mat1x1(add_mat1x1_mat1x1(mul_mat1x10_mat10x1(w4, l3), b4));\n\n    return l4;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[970, 978, 1026, 1026, 1058], [1060, 1060, 1119, 1119, 1231], [1233, 1233, 1288, 1288, 2214]], "test": "untested"}
{"id": "Nss3WB", "name": "Fractal 42_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 4, "viewed": 347, "published": 3, "date": "1616483981", "time_retrieved": "2024-07-30T19:31:11.308488", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=1.;\n        ++i<80.;\n        O.xyz+=.04*abs(cos(d+log(s)*.3))*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=mix(.5,10.,step(.5,fract(iTime*.1)));\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=1.5;\n        for(int j=0;j++<12;)\n            p=sign(p)*(1.5-abs(p-1.5)),\n            p=p*(e=8./clamp(dot(p,p),.5,5.))+q,s*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nss3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 591]], "test": "untested"}
{"id": "fdlGDB", "name": "Paint Crack", "author": "wyatt", "description": "Attempt to make the effect of paint drying", "tags": ["fluid", "automata"], "likes": 9, "viewed": 418, "published": 3, "date": "1616482380", "time_retrieved": "2024-07-30T19:31:12.088403", "image_code": "// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-23 06:44:39\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = c.xywz*min(f.w,1.3);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b= B(U+u);\n        Q.xy -= 0.2*a.w*(a.w*(a.w*mat2(b)-mat2(1.)))*u;  \n    }\n    Q.xy *= 1.-1e-2;\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0.,.6-.6*exp(-.1*length(U-0.5*R)));\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.5*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.5*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    float w = 0.;\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ += Qb*wa+qb*wb;\n        w += wa+wb;\n        \n    }\n    if (w>0.)dQ/=w;\n    Q = dQ;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main \n{\n    Q = B(U);\n    vec4 qA = A(U);\n    vec4 dQ = vec4(0);\n    box if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = a.xy-qA.xy;\n        dQ -= .2*a.w*vec4(u.x*v,u.y*v);\n    }\n    Q += dQ;\n    if (iFrame < 1) Q = vec4(1,0,0,1);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NssGWB", "name": "UI splitter", "author": "elenzil", "description": "splits the UI into two, including mouse events.\nactual shaders from IQ: https://www.shadertoy.com/view/lssGRM\nand TDM: https://www.shadertoy.com/view/Ms2SD1\n\ntbh, I haven't tested mouse z & w.", "tags": ["ui", "util", "splitter", "taggui"], "likes": 12, "viewed": 426, "published": 3, "date": "1616480823", "time_retrieved": "2024-07-30T19:31:13.042852", "image_code": "// splits the UI into two.\n// actual shaders from IQ: https://www.shadertoy.com/view/4sX3Rn\n// and TDM: https://www.shadertoy.com/view/Ms2SD1\n\nvec3 gResolution;\nvec4 gMouse;\n\nvoid mainImageLeft( out vec4 fragColor, in vec2 fragCoord );\nvoid mainImageRight( out vec4 fragColor, in vec2 fragCoord );\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 splitInfo = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float splitPos = splitInfo.x;\n    bool isGrabbed = splitInfo.y == 1.0;\n   \n    RGBA = vec4(vec3(isGrabbed ? 1.0 : 0.5), 1.0);\n    \n    if (XY.x < splitPos - splitterRad) {\n        gResolution   = iResolution;\n        gResolution.x = splitPos - splitterRad;\n        gMouse        = texelFetch(iChannel0, ivec2(1, 0), 0);\n        mainImageLeft(RGBA, XY);\n    }\n    else if (XY.x > splitPos + splitterRad) {\n        gResolution   = iResolution;\n        gResolution.x = iResolution.x - splitPos - splitterRad;\n        gMouse        = texelFetch(iChannel0, ivec2(2, 0), 0);\n        mainImageRight(RGBA, vec2(XY.x - splitPos - splitterRad, XY.y));\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI      = 3.141592;\nconst float EPSILON = 1e-3;\n#define EPSILON_NRM (0.1 / gResolution.x)\n#define AA_AA\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7)); \n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );    \n    vec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_AA(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n        d = sea_octave((uv+SEA_TIME)*freq,choppy);\n        d += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n        uv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map_AA(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map_AA(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n        float hmid = map_AA(p);\n        if(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / gResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= gResolution.x / gResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n        pow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n// main\nvoid mainImageLeft( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + gMouse.x*0.01;\n    \n#ifdef AA_AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = fragCoord+vec2(i,j)/3.0;\n            color += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n    fragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n// Created by inigo quilez - iq/2013\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+12.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*50.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n    for( int i=0; i<16; i++ )\n    {\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n    float d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.8,0.9,1.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = raycast(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,1.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        col += sun;\n        dis = 140.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 10.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(0.45) );\n    // contrast/brightness\n    col = 1.3*col-0.1;\n    // tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col;\n}\n\nvoid mainImageRight( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / gResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= gResolution.x/gResolution.y;\n    vec2 m = vec2(0.5);\n    if( gMouse.z>0.0 ) m = gMouse.xy/gResolution.xy;\n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, 1.0 );\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float splitterWidth = 3.0;\nconst float splitterRad   = splitterWidth / 2.0;\nconst float splitterExtra = 3.0;", "buffer_a_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    if (IJ.y > 0) {\n        return;\n    }\n    \n    bool  isMousePressed      = iMouse.z >= 1.0;\n    bool  wasMouseJustPressed = iMouse.w >= 1.0;\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    float splitPos            = state.x;\n    bool  isGrabbed           = (state.y == 1.0) && isMousePressed;\n    bool  isDownInLeft        = (state.y == 2.0) && isMousePressed;\n    bool  isDownInRight       = (state.y == 3.0) && isMousePressed;\n    \n    if (iFrame < 5) {\n        splitPos = iResolution.x / 2.0;\n    }\n    \n    if (isGrabbed) {\n        if (isMousePressed) {\n            splitPos = iMouse.x;\n            splitPos = max(splitPos - splitterRad, 0.0);\n            splitPos = min(splitPos + splitterRad, iResolution.x);\n        }\n        else {\n            isGrabbed = false;\n        }\n    }\n    else {\n        if (wasMouseJustPressed) {\n            float d = iMouse.x - splitPos;\n            if (d < -splitterRad - splitterExtra) {\n                isDownInLeft = true;\n            }\n            else if (d > splitterRad + splitterExtra) {\n                isDownInRight = true;\n            }\n            else {\n                isGrabbed = true;\n                splitPos = iMouse.x;\n                splitPos = max(splitPos - splitterRad, 0.0);\n                splitPos = min(splitPos + splitterRad, iResolution.x);\n            }\n        }\n    }\n    \n    if (abs(splitPos - iResolution.x / 2.0) < 10.0) {\n        splitPos = iResolution.x / 2.0;\n    }\n    \n    if (length(iMouse.xy) < 20.0) {\n        float s  = sin(iTime * 0.7);\n        float th = 0.5;\n        splitPos = mix(iResolution.x * 0.2, iResolution.x * 0.8,\n                       smoothstep(th, -th, s));\n        isGrabbed = abs(s) < th;\n    }\n\n    if (IJ.x == 0) {\n        RGBA.x = splitPos;\n        RGBA.y = isGrabbed ? 1.0 : (isDownInLeft ? 2.0 : (isDownInRight ? 3.0 : 0.0));\n    }\n    else if (IJ.x == 1) {\n        if (isDownInLeft) {\n            RGBA = iMouse;\n        }\n        else {\n            RGBA = texelFetch(iChannel0, ivec2(1, 0), 0);\n        }\n    }\n    else if (IJ.x == 2) {\n        if (isDownInRight) {\n            RGBA = iMouse;\n            RGBA.x = iMouse.x - splitPos - splitterRad;\n        }\n        else {\n            RGBA = texelFetch(iChannel0, ivec2(2, 0), 0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 344, 344, 1061], [1940, 1948, 1974, 1974, 2332], [2333, 2333, 2355, 2355, 2438], [2439, 2439, 2465, 2465, 2772], [2774, 2786, 2824, 2824, 2866], [2867, 2867, 2913, 2913, 3013], [3015, 3022, 3048, 3048, 3157], [3159, 3166, 3207, 3207, 3378], [3380, 3380, 3402, 3402, 3855], [3857, 3857, 3885, 3885, 4338], [4340, 4340, 4403, 4403, 4897], [4899, 4910, 4945, 4945, 5136], [5138, 5138, 5194, 5194, 5727], [5729, 5729, 5771, 5771, 6480], [6482, 6490, 6551, 6551, 6965], [7751, 7751, 7774, 7774, 7812], [7814, 7814, 7837, 7837, 7887], [7889, 7889, 7912, 7912, 8006], [8008, 8049, 8088, 8088, 8470], [8519, 8519, 8539, 8556, 9137], [9139, 9139, 9179, 9179, 9522], [9524, 9524, 9556, 9556, 9771], [9773, 9773, 9838, 9838, 10092], [10094, 10094, 10136, 10136, 10484], [10530, 10530, 10581, 10595, 12831], [12833, 12833, 12895, 12895, 13706]], "test": "untested"}
{"id": "NdsGWS", "name": "Parabola in the Middle", "author": "oneshade", "description": "An exercise in differentiation, integration and solving systems of equations to form a parabola that exactly matches the slope at two points on a cosine wave (not always possible). And a shader visualization to go with it.", "tags": ["math", "quadratic", "analytic", "exercise", "parabola", "integration", "differentiation", "systemsofequations"], "likes": 8, "viewed": 173, "published": 3, "date": "1616472513", "time_retrieved": "2024-07-30T19:31:13.807806", "image_code": "#define PI 3.14159265359\n\n#define drawSDF(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n#define drawFunction(f, d, t, c) color = mix(color, c, smoothstep(unit, 0.0, abs(uv.y - f(uv.x)) / sqrt(1.0 + pow(d(uv.x), 2.0)) - t))\n\n// Parabola and derivative for DE\nfloat f1(in float x) {\n    return x * x / (3.0 * PI) - 3.0 * PI / 4.0;\n}\n\nfloat f1Prime(in float x) {\n    return 2.0 * x / (3.0 * PI) ;\n}\n\n// Composition of the parabola and cosine wave\nfloat f2(in float x) {\n    return mix(f1(x), cos(x), step(0.0, abs(x) - 3.0 * PI / 2.0));\n}\n\nfloat f2Prime(in float x) {\n    return mix(f1Prime(x), -sin(x), step(0.0, abs(x) - 3.0 * PI / 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 16.0;\n    float unit = 32.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    drawSDF(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    drawFunction(cos, -sin, 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    drawFunction(f1, f1Prime, 0.25 * unit, vec3(1.0, 0.0, 0.0));\n    drawFunction(f2, f2Prime, 0.25 * unit, vec3(0.5, 0.0, 0.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 266, 288, 288, 338], [340, 340, 367, 367, 403], [405, 452, 474, 474, 543], [545, 545, 572, 572, 647], [649, 649, 704, 704, 1334]], "test": "untested"}
{"id": "Nds3DS", "name": "Lofi gif background loop", "author": "TheNosiriN", "description": "made in 1 day for weekly #willstallchallenge", "tags": ["reflection", "clouds", "sky", "city", "gif", "lofi", "street", "nft", "willstall"], "likes": 30, "viewed": 730, "published": 3, "date": "1616472358", "time_retrieved": "2024-07-30T19:31:14.584729", "image_code": "//made by TheNosiriN\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/R;\n    #ifdef MARGIN\n    if(uv.x < marginSize || uv.x > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    float size = 3.0;\n    vec3 color;\n    vec4 tex = texture(iChannel0, uv);\n    \n    float smp = 0.;\n    for (float i=-size; i<=size; i++){\n        for (float j=-size; j<=size; j++)\n        {\n            //(fragCoord+vec2(i,j)/size)/iResolution.xy //hmm...\n            //some chroma\n            color.r += texture(iChannel0, uv+(vec2(i,j))/720./size).r;\n            color.g += texture(iChannel0, uv+(vec2(i,j)*4.0)/720./size).g;\n            color.b += texture(iChannel0, uv+(vec2(i,j)*8.0)/720./size).b;\n            smp++;\n        }\n    }\n    color /= smp;\n    //color = tex.rgb; //remove blur stuffs\n    \n    color = smoothstep(0.,1.,color);\n    //color = sqrt(color);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// pow for vibrance\nconst vec3 purple = vec3(1.000,0.455,0.745);\nconst vec3 purple2 = pow(vec3(0.353,0.255,0.576), vec3(1.5))*2.;\nconst vec3 suncol = vec3(1.000,0.522,0.008);\nconst vec3 yellow = pow(vec3(1.000,0.741,0.333), vec3(3))*3.;\n//\n\n\n\n\n\nvec2 street(vec3 p)\n{\n    p.x += TIME*8.0;\n    \n    //fence\n    vec3 p1 = p;\n    p1.y += 20.9;\n    p1.z -= 30.;\n    \n    vec2 qf = abs(p1.yz+vec2(0.1,0))-vec2(0.05, 0.01);\n    vec2 d2 = vec2(M(qf), 1);\n    qf = abs(p1.yz-vec2(0.1,0))-vec2(0.05, 0.01);\n    d2.x = min(d2.x, M(qf));\n    \n    p1.x = mod(p1.x+5.0,10.0)-5.0;\n    qf = abs(p1.xz)-0.1;\n    d2.x = min(d2.x, max(M(qf), p1.y-0.15));\n    //\n    \n    //street lamps... I guess? :p\n    p1.z += 10.0;\n    p1.x = mod(p.x+30.,60.)-30.;\n    p1.y -= 7.0;\n    vec2 d3 = vec2(max(length(p1.xz)-0.1, p1.y), 0);\n    p1.z = abs(p1.z);\n    float dt = (sin(p1.z*0.5))*0.9;\n    d3.x = min(d3.x, max(length(p1.xy-vec2(0,dt))-0.1, p1.z-2.0) );\n    p1.z -= 2.2;\n    p1.y -= 0.7;\n    vec2 lmp = vec2(length(p1*vec3(1,1.25,0.6))-0.2, 2);\n    if (p1.y > 0.){ lmp.y = 1.0; }\n    d3 = mind(d3, lmp);\n    //\n    \n    //buildings\n    p.x = mod(p.x+9.0,18.0)-9.0;\n    if (p.z < 0.){ p.z = mod(p.z+6.0,12.0)-6.0; }\n    \n    vec2 q = abs(abs(abs(p.xz)-1.2)-1.12)-1.0;\n    vec2 d = vec2(M(q), 1);\n    \n    float wp = mod(p.y+0.3,0.4)-0.2;\n    vec2 q1 = abs(vec2(q.x+0.65,wp))-vec2(0.2,0.1);\n    d = maxd(d, vec2(-M(q1), 3));\n    vec2 q2 = abs(vec2(q.y+0.65,wp))-vec2(0.2,0.1);\n    d = maxd(d, vec2(-M(q2), 3));\n    \n    q = abs(q+0.1)-0.2;\n    d = mind(d, vec2(M(q), 0));\n    \n    d.x = max(d.x, p.y-1.);\n    q = abs(p.xz-vec2(0,2.5))-0.7;\n    d = mind(d, vec2(max(M(q), p.y-2.7), 1) );\n    //\n    \n    d = mind(d, mind(d2, d3));\n    return d;\n}\n\n\nvec3 march(vec3 eye, vec3 dir, float maxd){\n    \n    float d, i; vec2 ind;\n    for (; i<100. && d < maxd; i++){\n        vec3 p = eye + dir * d;\n        ind = street(p);\n        if (abs(ind.x) < 0.001 * d)break;\n        d += ind.x;\n    }\n    return vec3(d, ind.y, pow(i/60., 2.5));\n}\n\n\n\n\nmat2 rotate(float angle){\n\tangle *= 3.142 / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat fbm(vec2 p){\n    float f;\n    f  = 0.5000*noise(p); p = M2*p*2.02 + TIME*0.1;\n    f += 0.2500*noise(p); p = M2*p*2.03 + TIME*0.1;\n    f += 0.1250*noise(p);\n    return f;\n}\n\nvec3 getSky(vec3 dir){\n    dir += Noise(dir.xy+TIME)*0.01;\n    vec3 sky = mix(yellow, purple2, saturate( pow(dir.y, 0.8)*2.0 ));\n    dir.xz *= rotate(20.);\n    dir.xy *= rotate(-22.);\n    float sun = smoothstep(-0.005,0.005,length(dir.yz)-0.04);\n    \n    vec3 col = mix(suncol, sky, sun);\n    \n    float shape = 0.;\n    vec2 mp = dir.yz;\n    for (float i=0.1; i<=1.0; i+=0.2){\n        shape = mix(shape, max(0.3,1.0-i), \n            smoothstep(0.01,-0.01, mp.x-mp.y+0.075 + sin(mp.y*100.+TIME)*0.01 )\n        );\n        mp.y = -mp.y*0.7;\n    }\n    \n    shape = shape*fbm(dir.zy/(mp.x-mp.y+0.15)*2.5 + vec2(0,TIME)*0.2) + shape;\n    shape = saturate(shape);\n    \n    col = mix(col, purple2*pow(yellow,vec3(0.5)), shape);\n    \n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R;\n    vec3 rand = Noise(uv);\n    #ifdef MARGIN\n    if(uv.x < marginSize || uv.x > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    uv = (fragCoord.xy-R*0.5)/R.y;\n    \n    vec3 eye = vec3(-25,-23,35),\n    f = normalize(vec3(30, 0, 8) - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -3.0)), 0)\n    ).xyz;\n    \n    dir.yz *= rotate(sin(TIME));\n    \n    vec3 col;\n    \n    vec3 dist = march(eye, dir, 200.);\n    if (dist.x < 200.){\n        eye += dir * dist.x;\n        vec3 P = vec3(-4, 4, 0) * 0.001;\n        vec3 N = normalize(\n            street(eye+P.xyy).x * \n            P.xyy + street(eye+P.yxy).x * \n            P.yxy + street(eye+P.yyx).x * \n            P.yyx + street(eye+P.xxx).x * \n            P.xxx\n        );\n        N = normalize(N + rand*0.05);\n        \n        col += dot(N, vec3(0,0,1)) *0.5+0.25;\n        dir = reflect(dir, N);\n        col *= getSky(dir);\n        \n        if (dist.y == 0.){ col *= 0.5; }\n        if (dist.y == 2.){ col = suncol; }\n        if (dist.y == 3.){ col = purple2; }\n    }else{\n        col = getSky(dir);\n    }\n    col = mix(col, purple*pow(yellow,vec3(0.2)), saturate(dist.z+rand*0.2));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MARGIN //comment this for fullscreen\n\n#define TIME (iTime)\n#define M(p) max((p).x,(p).y)\n#define R (iResolution.xy)\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define Noise(uv) textureLod(iChannel0,uv,1.).rgb\n\n\n\nconst float marginSize = 0.15;\n\n\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat hash21(vec2 p){\n    return (fract(sin(dot(p, p+5373.836))*9272.8363) *2.0-1.0);\n}\n\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(\n        mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n        mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n    u.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 940]], "test": "untested"}
{"id": "NdlGWS", "name": "Rave Rectangles", "author": "Tater", "description": "I wanted to make something with the mouse function and ended up making whatever this is. \nMouse code still works but it's pretty boring.\n4th shader I've made so far.", "tags": ["2d", "mouse", "flashing"], "likes": 1, "viewed": 300, "published": 3, "date": "1616467691", "time_retrieved": "2024-07-30T19:31:15.358660", "image_code": "#define PI 3.14159265\nmat2 rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nfloat height(float x,vec2 mXY){\n    if(iMouse.z>0.0){ return -pow(abs(x-mXY.x),2.0)*30.0+3.333*mXY.y+0.3; }\n    else{ return (abs(tan((x-mXY.x)*5.0))-1.0)*4.0+3.333*mXY.y+0.3; }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //scale -0.5 <> 0.5\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=iTime*0.9;\n    vec2 mXY;\n    if(iMouse.z>0.0){\n        mXY=(iMouse.xy-.5*iResolution.xy)/iResolution.y; }\n    else{\n        mXY= vec2(cos(t)*0.7,0.2* sin(t));\n        uv*=rot(tan(sin(t*2.0)*1.46)); \n        uv=0.5*sin(uv*0.9)*2.1;\n        uv=0.5*tan(uv*1.3)*1.9;}       \n    \n    //wavey\n    uv.x+=0.5*sin(cos(uv.y*15.0)*(PI/2.0))*(0.01+0.01*sin(t));\n    //Scaling x and splitting into columns\n    float scale = 12.5*(1.0+0.8*sin(123.0*floor(t/PI*2.0+PI/2.0)));\n    uv.x*=scale;\n    \n    float xID = (0.5+floor(uv.x))/scale; \n    //rectangles\n    float top = clamp(step(uv.y,0.3*height(xID,mXY)),0.0,1.0);\n    float bot = clamp(1.0-step(uv.y,-0.3*height(xID,vec2(mXY.x,-mXY.y))),0.0,1.0);\n    //color\n    float rt = t/PI*2.0+PI/2.0;\n    float r = 0.5+0.2*sin(floor(rt));\n    float g = 0.5+0.2*sin(floor(rt)+10.0);\n    float b = 0.5+0.2*sin(floor(rt)+20.0);\n    vec3 col = vec3(top+bot)*vec3(r,g,b); \n    //tinted BG\n    col.rgb += 0.3*vec3(r,g,b)*(step((col.r*col.g*col.b),0.001));\n    //flashing/pulse\n    col.rgb += 3.0*vec3(r,g,b)*pow(abs(pow(sin(2.0*t),9.0)),2.0);   \n    //col.rgb=vec3(0.5+uv,0.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 101], [102, 102, 133, 133, 281], [282, 282, 339, 363, 1571]], "test": "untested"}
{"id": "NslGWS", "name": "Simple Halftone - Vary Dot Size", "author": "choxi", "description": "Part 4 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 0, "viewed": 679, "published": 3, "date": "1616459564", "time_retrieved": "2024-07-30T19:31:16.156526", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float dotResolution = 80.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0 * fract(uv * dotResolution) - 1.0;\n    float distance = length(uv2);\n    vec4 color0 = texture(iChannel0, uv);\n    float dotRadius = 1.0 - (color0.r + color0.g + color0.b) / 3.0;\n    \n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color = mix(color0, white, step(dotRadius, distance));\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 585]], "test": "untested"}
{"id": "fsl3R2", "name": "Breathing Eye", "author": "manu210404", "description": "I took some inspiration from the logo of this website and decided to add my own twist to it. ", "tags": ["noise", "eye", "psychedelic", "iris"], "likes": 25, "viewed": 701, "published": 3, "date": "1616456997", "time_retrieved": "2024-07-30T19:31:16.921481", "image_code": "#define PI acos(-1.)\n\n// -------------------------------------- //\n// Animation\n#define ANIM\n\n// inner/outer Radius of iris\n#define INNER_R (0.25+sin(iTime*PI*0.5)*0.06125)\n#define OUTER_R .875\n\n// Background, background of the iris, inner and outer color of eye\n#define BG     vec3(0.1, 0.0, 0.1 )\n#define EYE_BG vec3(0.1, 0.05,0.15)\n#define EYE_1  vec3(0.5, 0.25,0.03)\n#define EYE_2  vec3(0.45,0.65,0.6 )\n\n// how many layers of \"strings\" are rendered\n#define LAYERS 4\n// -------------------------------------- //\n\n// Antialiasing\n#define EPS 12. / iResolution.y / length(p) // epsilon for antialiasing\n\n// gamma correction\n#define G(a) pow((a), vec3(0.4545))\n#define IG(a) pow((a), vec3(2.2))\n\n// hash functions by Dave_Hoskins - https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash11(in float p) {uvec2 n = uint(int(p)) * UI2;uint q = (n.x ^ n.y) * UI0;return float(q) * UIF;}\n\nvec2 hash22(in vec2 p) {uvec2 q = uvec2(ivec2(p))*UI2;q = (q.x ^ q.y) * UI2;return vec2(q) * UIF;}\n\n// simplex noise by iq - https://www.shadertoy.com/view/Msf3WH\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404,K2 = 0.211324865;vec2 i=floor(p+(p.x+p.y)*K1),a=p-i+(i.x+i.y)*K2;float m=step(a.y,a.x);vec2 o=vec2(m,1.-m);\n    vec2 b=a-o+K2,c=a-1.+2.*K2;vec3 h=max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.),n=h*h*h*h*vec3(dot(a,hash22(i+0.0)),dot(b,hash22(i+o)),dot(c,hash22(i+1.)));\n    return dot(n,vec3(70.0));\n}\n\nmat2 rot(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat iris(in vec2 p) {\n    float d = (OUTER_R + INNER_R) * 0.5;\n    d = (abs(length(p) - d) - d + INNER_R) / (d - INNER_R); // normalized distance to the radii\n    mat2 r;                        // animated rotation of noise-domain\n    float s,                       // animated scale of noise-domain\n          a = atan(p.y, p.x),      // angle to center\n          na,                      // offset of the angle (determined by 2d-noise)\n          f = exp2(float(LAYERS)), // scale of the layers\n          pattern,                 // output variable\n          n,                       // value of the \"strings\" (determined by looping 1d-noise)\n          t,                       // added thickness to \"strings\"\n          alpha;                   // maybe not alpha but I don't know how else to call it\n    vec2 m = iMouse.xy/iResolution.y; // mouse offset of noise-domain\n\n    #ifdef ANIM\n    s = sin(iTime * PI * 0.25) * 0.25;    // animated scale of domain\n    r = rot(iTime * PI * 0.0078125);      // animated rotation of domain\n    #endif\n    \n    for (int i=0; i<LAYERS; i++) {\n        na = a + noise((p - m/f) * 1.5 * f * (1. + s / f) * r) * length(p) * 0.5 / f; // noise to warp strings\n        n = noise(vec2(sin(na),cos(na)) * 2. * f);                                    // value of strings\n        \n        \n        t = .75 / f ;                                     // thickness/density of strings\n        t += - 1.5 * smoothstep(1.0, 0.0, d + 0.5) + 1.5; // strings are cut off at the edge of the iris\n        t += -.125 * smoothstep(1.0, 0.0, d + 1.);        // strings are thicker when closer to center radius\n        \n        pattern -= smoothstep(-0.35,  0.25,  n - t) * 0.5 * pattern; // \"shadows\" of the \"strings\"\n        alpha =    smoothstep(-EPS*f, EPS*f, n - t);\n        pattern += pow(alpha, 2.) * (1. - pattern);               // addition of the layers (i don't really know what im doing here but it looks nice)\n    \n        f *= 0.5;\n    }\n    return max(0.0, pattern); // because of the shadows it could be negative so i clamp it here\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float irisPerimiter_mask = smoothstep(0.1,  -0.1,  length(p) - OUTER_R);\n    float irisPupil_mask =     smoothstep(0.05, -0.05, length(p) - INNER_R);\n    float iris_mask =          -irisPupil_mask + irisPerimiter_mask;\n    \n    float iris_pattern = iris(p);\n    \n    vec3 iris_color = IG(mix(G(EYE_1), G(EYE_2), vec3(sqrt(clamp((length(p) - INNER_R) / (OUTER_R - INNER_R) + 0.01, 0.0, 1.0))))); // color gradient (is this how you gamma correct?)\n    \n    vec3 col = iris_pattern * iris_color + EYE_BG * (1. - iris_pattern); // blending between the gradient and the background\n    \n    col = col * iris_mask + (1. - iris_mask) * BG;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[927, 927, 953, 953, 1032], [1034, 1034, 1058, 1058, 1132], [1134, 1197, 1221, 1221, 1554], [1556, 1556, 1578, 1578, 1641], [1643, 1643, 1666, 1666, 3705], [3707, 3707, 3764, 3764, 4508]], "test": "untested"}
{"id": "ssXGDB", "name": "Aqua Vista", "author": "wyatt", "description": "I went on a rainy walk with Maggie this morning. It's sunny now.", "tags": ["fluid", "automata"], "likes": 17, "viewed": 496, "published": 3, "date": "1616453822", "time_retrieved": "2024-07-30T19:31:17.707380", "image_code": "// Fork of \"Temperatures\" by wyatt. https://shadertoy.com/view/fsf3zS\n// 2021-03-22 22:23:14\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-18 22:39:28\n\n// Display \nMain \n{\n    vec4 f = A(U);\n    Q = 1.-(.5-0.5*(sin(3.5-.3*(f.z)+vec4(1,2,3,4))))*f.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = 0.07*a.w*((a.w-1.)+.3);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    if (abs(U.y-0.6*R.y)<.3*R.y) {\n        Q.xy -= Q.xy*.1*exp(-16.*Q.w*Q.w);\n    }\n    Q.y -= 3e-4;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(iMouse.xy-0.5*R),-1,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.12);\n    if (R.y-U.y<2.) Q.zw = mix(Q.zw,vec2(-8.*step(U.x,.5*R.x)*U.x/R.x,1.5-U.x/R.x*1.),.005);\n    if (U.x < 1.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n    if (R.x-U.x<1.) Q.w *= 0.;\n    if (abs(R.x*.5-U.x)<1.&&U.y<.15*R.y) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-3.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-3.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tds3Wn", "name": "Postcard Raytracer Port", "author": "Bio_Cyan", "description": "A GLSL port of Andrew Kensler's postcard raytracer.", "tags": ["raymarching"], "likes": 5, "viewed": 357, "published": 3, "date": "1616450786", "time_retrieved": "2024-07-30T19:31:18.547135", "image_code": "vec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 coord;\nfloat randState;\nvec2 rand() {\n    randState++;\n    return hash23(vec3(coord, randState));\n}\n\nfloat box_dist(vec3 point, vec3 mins, vec3 maxs)\n{\n    mins = point - mins;\n    maxs = maxs - point;\n    return -min(min(min(mins.x, maxs.x), min(mins.y, maxs.y)), min(mins.z, maxs.z));\n}\n\nfloat signed_dist(in vec3 point, out int type)\n{\n    float dist = 1e9;\n    vec2 flattened = point.xy;\n    vec4 line[] = vec4[](\n        vec4(-26, 0, -26, 16),\n        vec4(-26, 8, -22, 8),\n        vec4(-26, 16, -22, 16),\n        vec4(-13, 0, -13, 16),\n        vec4(-15, 0, -11, 0),\n        vec4(-15, 16, -11, 16),\n        vec4(-7, 0, 2, 16),\n        vec4(-7, 16, 2, 0),\n        vec4(3, 0, 10, 16),\n        vec4(10, 16, 14, 0),\n        vec4(8, 8, 12, 8),\n        vec4(18, 0, 18, 16),\n        vec4(18, 8, 22, 8),\n        vec4(18, 16, 22, 16),\n        vec4(20, 8, 26, 0)\n    );\n    for (int i = 0; i < 15; i++) {\n        vec2 base = line[i].xy*0.5;\n        vec2 edge = line[i].zw*0.5 - base;\n        float t = dot(flattened - base, edge)/dot(edge, edge);\n        t = min(max(0.0, t), 1.0);\n        vec2 offset = flattened - (base + edge*t);\n        dist = min(dist, dot(offset, offset));\n    }\n    dist = sqrt(dist);\n    vec2 a[] = vec2[](\n        vec2(-11, 6),\n        vec2(11, 6)\n    );\n    for (int i = 0; i < 2; i++) {\n        vec2 o = flattened - a[i];\n        float newdist;\n        if (o.x > 0.0) {\n            newdist = abs(sqrt(dot(o, o)) - 2.0);\n        } else {\n            o.y += o.y > 0.0 ? -2.0 : 2.0;\n            newdist = sqrt(dot(o, o));\n        }\n        dist = min(dist, newdist);\n    }\n    dist = pow(pow(dist, 8.0) + pow(abs(point.z), 8.0), 0.125) - 0.5;\n    type = 1;\n    float wall_dist = min(\n        -min(\n            box_dist(point, vec3(-30.0, -0.5, -30.0), vec3(30.0, 18.0, 30.0)),\n            box_dist(point, vec3(-25.0, 17.0, -25.0), vec3(25.0, 20.0, 25.0))\n        ),\n        box_dist(vec3(mod(abs(point.x), 8.0), point.yz), vec3(1.5, 18.5, -25.0), vec3(6.5, 20.0, 25.0))\n    );\n    if (wall_dist < dist) {\n        dist = wall_dist;\n        type = 2;\n    }\n    float source_dist = 19.9 - point.y;\n    if (source_dist < dist) {\n        dist = source_dist;\n        type = 3;\n    }\n    return dist;\n}\n\nint march_ray(in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal)\n{\n    int type;\n    int steps = 0;\n    float dist;\n    for (float t = 0.0; t < 100.0; t += dist) {\n        hit = origin + direction*t;\n        dist = signed_dist(hit, type);\n        if (dist < 0.01 || ++steps > 99) {\n            normal = normalize(vec3(\n                signed_dist(hit + vec3(0.01, 0.0, 0.0), steps) - dist,\n               \tsigned_dist(hit + vec3(0.0, 0.01, 0.0), steps) - dist,\n                signed_dist(hit + vec3(0.0, 0.0, 0.01), steps) - dist\n            ));\n            return type;\n        }\n    }\n    return 0;\n}\n\nvec3 trace_ray(vec3 origin, vec3 direction)\n{\n    vec3 hit;\n    vec3 normal;\n    vec3 reflected = vec3(0.0);\n    vec3 t = vec3(1.0);\n    vec3 light = normalize(vec3(0.6, 0.6, 1.0));\n    for (int bounce = 0; bounce < 3; bounce++) {\n        int type = march_ray(origin, direction, hit, normal);\n        if (type == 0) {\n            break;\n        }\n        if (type == 1) {\n            direction = direction - 2.0*normal*dot(normal, direction);\n            origin = hit + direction*0.1;\n            t *= 0.2;\n        }\n        if (type == 2) {\n            float irradiance = dot(normal, light);\n            vec2 rand = rand();\n            float yaw = 6.283185*rand.x;\n            float cosine2 = rand.y;\n            float sine = sqrt(1.0 - cosine2);\n            float g = normal.z < 0.0 ? -1.0 : 1.0;\n            float u = -1.0/(g + normal.z);\n            float v = normal.x*normal.y*u;\n            direction = -vec3(v, g + normal.y*normal.y*u, -normal.y)*cos(yaw)*sine\n                + vec3(1.0 + g*normal.x*normal.x*u, g*v, -g*normal.x)*sin(yaw)*sine\n                + normal*sqrt(cosine2);\n            origin = hit + direction*0.1;\n            t *= 0.2;\n            if (irradiance > 0.0 && march_ray(hit + normal*0.1, light, hit, normal) == 3) {\n                reflected += t*vec3(500.0, 400.0, 100.0)*irradiance;\n            }\n        }\n        if (type == 3) {\n            reflected += t*vec3(50.0, 80.0, 100.0);\n            break;\n        }\n    }\n    \n    return reflected;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    coord = fragCoord;\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    vec3 eye = vec3(-22.0, 5.0, 25.0);\n    vec3 gaze = normalize(vec3(-3.0, 4.0, 0.0) - eye);\n    vec3 left = normalize(vec3(gaze.z, 0.0, -gaze.x))/width;\n    vec3 up = cross(gaze, left);\n    vec3 color = vec3(0.0);\n    float x = width - fragCoord.x;\n    float y = fragCoord.y;\n    int samples = 16;\n    for (int i = 0; i < samples; i++) {\n        vec2 offset = rand();\n        color += trace_ray(eye, normalize(gaze + left*(x - width/2.0 + offset.x) + up*(y - height/2.0 + offset.y)));\n    }\n   \tcolor = color/float(samples) + vec3(14.0/241.0);\n    color /= color + vec3(1.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tds3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 141], [172, 172, 185, 185, 247], [249, 249, 299, 299, 436], [2365, 2365, 2446, 2446, 2983], [2985, 2985, 3030, 3030, 4466], [4468, 4468, 4523, 4523, 5232]], "test": "untested"}
{"id": "NsX3DB", "name": "ray marching - v1", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 1, "viewed": 242, "published": 3, "date": "1616449212", "time_retrieved": "2024-07-30T19:31:19.409828", "image_code": "#define NUMBER_OF_STEPS 100\n#define MAX_DISTANCE 10.0\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\nconst int n = 8;\nvec3 p[n] = vec3[](\n    vec3(-1,-1, 4), vec3(-1, 1, 4), vec3(1, 1, 4), vec3(1, -1, 4),\n    vec3(-1, 1, 6), vec3(1, 1, 6), vec3(1, -1, 6), vec3(-1,-1, 6)\n);\nfloat f = 1.; // focal length\nvec3 light = normalize(vec3(1,0,-1));\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r + sin(ray.x*4.+iTime)*.1 + sin(ray.y*3.+iTime)*.1 + sin(ray.z*4.+iTime)*.1;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nfloat safe_distance(vec3 ray){\n    float min_distance = MAX_STEP_SIZE;\n    /*float avg = 0.;\n    for(int i=0; i<n; i++){\n        float d = 0.0;\n        if(i%2 == 0){\n            d = distance_to_sphere(ray, p[i], 0.7);\n        }\n        else{\n            d = distance_to_wave_sphere(ray, p[i], 0.7);\n        }\n        \n        if(d < min_distance)min_distance = d;\n    }*/\n    \n    float d1 = distance_to_wave_sphere(ray, vec3(-2,0,6), 2.3);\n    float d2 = distance_to_sphere(ray, vec3(-1.+4.*pow(abs(sin(iTime*0.5)),4.),0,6), 1.); \n   \n    min_distance = smooth_min(d1, d2, 0.4);\n    \n    return min_distance;\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float d = 0.; // ray length\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l = max(dot(n, light), 0.);\n            //color = vec3(l,l,l);\n            color = -n*0.5+0.5;\n            break;\n        }\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsX3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 380, 439, 439, 551], [553, 553, 607, 607, 644], [646, 646, 695, 695, 767], [769, 769, 799, 799, 1380], [1382, 1382, 1404, 1404, 1766], [1768, 1768, 1793, 1793, 2330], [2332, 2332, 2389, 2424, 2669]], "test": "untested"}
{"id": "7dXGWB", "name": "Boiling Point.", "author": "wyatt", "description": "Boiling caused by kinetic instability. ", "tags": ["fluid", "automata"], "likes": 23, "viewed": 540, "published": 3, "date": "1616448830", "time_retrieved": "2024-07-30T19:31:20.296457", "image_code": "// Fork of \"River Delta\" by wyatt. https://shadertoy.com/view/fsf3RB\n// 2021-03-22 21:28:30\n\n// Fork of \"Bubbles!!!\" by wyatt. https://shadertoy.com/view/sdfGWr\n// 2021-03-18 23:35:41\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-14 23:43:37\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 a = A(U), b = B(U);\n    Q = atan(a.wwww);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.1*a.w*(a.w*(a.w-.1-b.w))*u;  \n    }\n    if (iMouse.z>0.) \n    Q.xy += 1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0,step(length(U-0.5*R),0.5*R.y));\n    \n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.1*Q.w*(a.w+.1*b.w)*u;  \n    }\n    if (iMouse.z>0.) \n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,1.);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ltBDs", "name": "Cabin in the woods", "author": "Dave_Hoskins", "description": "Cabin in the woods. This was going to be an ambitious ghostly trek to a spooky cabin. But the woods turned out far too neat and well kempt, so it got less scary as writing continued. So, now there's Rhododendrons in the forest, not ghosts! \n", "tags": ["3d", "raymarching", "sound", "cabin", "woods"], "likes": 33, "viewed": 971, "published": 3, "date": "1616447560", "time_retrieved": "2024-07-30T19:31:21.445385", "image_code": "// Cabin in the Woods \n// This tab does all the 2D screen affects...\n// (C) 2021 David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\n\n// The Voronoi distance field was the fun part (in Buffer B). Each tree is a symetrical lathed object,\n// with a diffrerent sinewave tilt for each one, giving a more natural look.\n// Also, amazingly, my ray-march distances are accurate, for a change :)\n\n// I think it's slow because of using an full screen buffer to do a map.\n// ** Hello, 'Beautypi' If you're still developing, can we please have buffer size options?\n// Thanks!!!\n\n// All ray marching is done in B and all information is then passed to be rendered in C, with:\n//     .xy = normal\n//     .z  = object ID for material lookup table.\n//     .w  = Occlusion shadow amount.\n//     .zw = could be compressed more but I didn't need it in the end.\n\n//  D Holds the map.\n//  Main does the overlay effects like fog and lense flare.\n\nvec3 sunLight;\nfloat distLight;\n\n\n//--------------------------------------------------------------------------\n// Thanks to Inigo, for doing a spherical fogging area, it saved me a lot of time...\n// https://iquilezles.org/articles/spheredensity\n\nfloat sphereFog( vec3  ro, vec3  rd,   // ray origin, ray direction\n                  vec3  sc, float sr,   // sphere center, sphere radius\n                  float dbuffer )       // depth buffer\n{\n    // normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer / sr;\n    vec3  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    \n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    // not visible (behind camera or behind ndbuffer)\n    if( t2 < 0.0 || t1 > ndbuffer ) return 0.0;\n\n    //return h*h*h*h;\n    // clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n\n//----------------------------------------------------------------------------------------\nvec3 lenseFlare(vec2 uv,vec3 dir, mat3 camMat, float dist)\n{\n\n    vec3 col = vec3(0);\n    float bri = max(dot(dir, sunLight), 0.);\n\n    if (bri > 0.0)\n\t{\n\n        bri *= smoothstep(400.,0.,dist);\n        mat3 inv = transpose(camMat);\n        vec3 cp = inv * (- sunLight * FAR*2.);\n        vec2 sun2d = 1. * cp.xy / cp.z;\n        //if (sun2d.x < -2.5) return col;\n         bri *= smoothstep(1.2, .5,length(sun2d)*.5);\n    \tvec2 texUV = .5+.5*sun2d*vec2(iResolution.y/iResolution.x,1.0);\n    \tfloat z = texture(iChannel0, texUV).w;\n        if (z > dist)\n        {\n            vec2 uvT = uv - sun2d;\n            //bri = pow(bri, 1.0)*10.;\n\n        \n            float glare1 = max(dot(dir,sunLight),0.0);\n            uvT = uvT*(length(uvT));\n            float glare3 = max(1.-pow(length(uvT+sun2d*2.)*1., 1.), 0.0)*1.5;\n            uvT = mix (uvT, uv, -4.2);\n            float glare2 = max(2.0-length(uvT+sun2d*8.0)*2.2, 0.0) *.5;\n\n\n            col += bri * vec3(1.)  * pow(glare1, 200.);\n            float dim = bri * bri*.2;\n            col += bri * vec3(1.,1.,1.0) * pow(glare2, 3.)*dim;\n            col += bri * vec3(.5, .4, .3) * pow(glare3, 3.2)*dim;\n        }\n\t}\n    return col;\n}\n\n//----------------------------------------------------------------------------------------\n//==========================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    fragColour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    vec4 lightData = texelFetch( iChannel1, ivec2(C_LIGHTDIR, 0),0 );\n    distLight = lightData.w;\n    sunLight = lightData.xyz;\n    \n    vec3 spot = SPOT_POS;\n    float dist = fragColour.w;\n    \n    float t  = getTime(iTime);\n    camera = getCameraPos(t);\n    \n            \n    vec2 camRot = texelFetch( iChannel1, ivec2(C_CAMROT,0),0 ).xy;\n    mat3 camMat = getCamFromRots(camRot, t);\n    vec3 rayDir = normalize( vec3(uv, 1.));\n    rayDir = camMat * rayDir;\n\n    vec3 col = vec3(0);\n    float fog = sphereFog(camera, rayDir, spot, 200., dist);    \n    col = mix(col, FOG_COLOUR, fog*3.);\n    \n    fog = sphereFog(camera, rayDir, spot, 45., dist);    \n    col = mix(col, FOG_COLOUR*3., min(fog*fog*3.5, 1.0));\n\n    col  = fragColour.xyz+col;\n    col += lenseFlare(uv, rayDir, camMat, distLight);    \n\n    // Clamp 0 to 1 range for addition screen effects.\n    col = clamp(col, 0.0, 1.0);\n    \n    // Contrast then desaturate the colours, there's an artistic method in the madness...\n    col = col*col*(3.0-2.*col);\n    col = mix( col, vec3(dot(col,vec3(0.33))), 0.2);\n    // Vignette\n    vec2 q = fragCoord  / iResolution.xy;\n\tcol *= 0.5 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n    \n\n    col = mix(col, vec3(0), smoothstep(-400.,-500.,t) + smoothstep(450.,500.,t));\n    fragColour = vec4(sqrt(col), 1.0);\n    \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28016, "src": "https://soundcloud.com/big-sauce-491221177/the-caretaker-an-empty-bliss-beyond-this-world", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Cabin in the Woods \n// (C) 2021 David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\n//--------------------------------------------------------------------------\n#define EXPORTED 0\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define ZERO min(0,iFrame)\n#define FAR 1000.0\n\n\n#define SPOT_POS vec3(40,30,70)\n#define MOON_POS normalize(vec3(1,1,1))\n#define TREE1_SPACING 23.\n#define TREE2_SPACING 30.5\n#define TREE_LEAVES 55.\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(.03, .04, .03)\n\n#define ID_BLACK     0\n#define ID_CABIN     1\n#define ID_WINDOW    2\n#define ID_PLANEWOOD 3\n#define ID_LAMPPOST  4\n#define ID_GROUND    5 \n#define ID_TREES     16\n#define ID_BUSHES    20\n#define ID_STUMP     24\n#define ID_RHODA     25\n\n        \n\n// Bump map defines...\n#define BM_FLAT   0\n#define BM_BARK   1\n#define BM_GROUND 2\n#define BM_CABIN  3\n\n\n#define C_CAMROT    1\n#define C_TORPOS    2\n#define C_TORDIR    4\n#define C_LIGHTDIR   5\n\n//--------------------------------------------------------------------------\nstruct Materials\n{\n    vec4 colour; // Specular in w.\n    int bumpID;\n    int tex;\n};\n// There 4 different coloured trees and bushes...\nMaterials materials[] = Materials[](\n    Materials(vec4 (0,0,0,0), BM_FLAT, 0), // default\n    Materials(vec4 (.1,.05,.03,0), BM_CABIN, 1),   // 1 Cabin\n    Materials(vec4 (.0,.01,.03,.5), BM_FLAT, 0),   // 2 Window\n    \n\n\n    Materials(vec4 (.1,.05,.0,.05), BM_FLAT, 0),    // 3 Wood\n    Materials(vec4 (.05,.02,.0,.0), BM_FLAT, 0),     // 4 Lamp post\n    Materials(vec4 (.2,.4,.1,.0), BM_GROUND, 0),     // 5 Ground\n    Materials(vec4 (1.), BM_FLAT, 0), // 6 temp..\n    Materials(vec4 (1.), BM_FLAT, 0), // 7 temp..    \n    Materials(vec4 (1.), BM_FLAT, 0), // 8 temp..    \n    Materials(vec4 (1.), BM_FLAT, 0), // 9 temp..\n    Materials(vec4 (1.), BM_FLAT, 0), // 10 temp..\n    Materials(vec4 (1.), BM_FLAT, 0), // 11 temp..\n    \n    Materials(vec4 (1.), BM_FLAT, 0), // 12 temp..    \n    Materials(vec4 (1.), BM_FLAT, 0), // 13 temp..\n    Materials(vec4 (1.), BM_FLAT, 0), // 14 temp..\n    Materials(vec4 (1.), BM_FLAT, 0), // 15 temp..\n\n\n    \n    Materials(vec4 (.1,.07,.05,.05), BM_BARK, 1),      // 16 Trees\n    Materials(vec4 (.075,.06,.05,.05), BM_BARK, 1),    // 17   \"\n    Materials(vec4 (.07,.04,.01,.05), BM_BARK, 1),     // 18   \"\n    Materials(vec4 (.025,.01,.0,.05), BM_BARK, 1),     // 19   \"\n    \n    \n    Materials(vec4 (.1,.2,.05,.0), BM_BARK, 1),       // 20 Bushes\n    Materials(vec4 (.03,.05,.0,.0), BM_BARK, 1),      // 21   \"\n    Materials(vec4 (.01,.02,.01,.0), BM_BARK, 1),     // 22   \"\n    Materials(vec4 (.015,.015,.0,.0), BM_BARK, 1),    // 23   \"\n    Materials(vec4 (.06,.05,.05,.0), BM_BARK, 1),     // 24   Stump\n    Materials(vec4 (.06,.08,.02,.0), BM_FLAT, 1)      // 25   Tuffs\n  \n);\n\n\nvec3 camera;\n\n// Can't use iTime in the common buffer, which his a disappointment.\n//--------------------------------------------------------------------------\nfloat getTime(float t)\n{\n    t = mod(t*10.,1000.0);\n    return t-500.;\n}\n\n//--------------------------------------------------------------------------\nvec3 getPath(float t)\n{\n\n    return vec3(t,6.,-sin(t*.008)*120.+150.);\n}\n\n//--------------------------------------------------------------------------\nmat3 getCamMat( in vec3 dir, float cr )\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(-cw,cp) );\n\tvec3 cv = normalize( cross(cu, -cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 getCamFromRots(vec2 camRot, float t)\n{\n\n    float roll = .01 * sin(t*.3);\n    vec3 rayDir = vec3(0, 0, 1);\n    rayDir.zy = rayDir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*rayDir.yz;\n    rayDir.xz = rayDir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*rayDir.zx;\n\n    mat3 camMat = getCamMat(rayDir, roll);\n\n    return camMat;\n }\n//--------------------------------------------------------------------------\nfloat roundBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n//--------------------------------------------------------------------------\nfloat roundBox2D( vec2 p, vec2 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 getCameraPos(float t)\n{\n    vec3 p =  getPath(t);\n    float s = abs(sin(t*.3));\n\n    p.y += s*s;\n\n    return p;\n }\n//--------------------------------------------------------------------------\nfloat doClearing(vec2 p)\n{\n    float d = (length(p+vec2(-12,-20)))-55.;\n    vec2 path = getPath(p.x).xz;\n    \n    float f = length(path-p)-30.;\n    d = min(d, roundBox2D(p, vec2 (2.,105.0), .1)-10.);\n    //return max(-d,-f);\n    return min(d, f);\n}\n\n//--------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    p*= 100.;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//--------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n//--------------------------------------------------------------------------\nfloat sMax( in float a, in float b, in float s )\n{\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n//--------------------------------------------------------------------------\nint treeType(vec2 p, float block)\n{\n    p = floor((p)/block)*block;\n    return int(hash12(p*103.5)*4.);\n}\n\n//--------------------------------------------------------------------------\nuint convertUint(float value)\n{\n    value = (value + 1.0) * 0.5;\n    return uint((value*255.0));\n}\n\n\n//--------------------------------------------------------------------------\nvec2 packData(vec4 nor)\n{\n    uint x = convertUint(nor.x);\n    uint y = convertUint(nor.y);\n    uint z = convertUint(nor.z);\n    uint w = uint(nor.w);\n    return vec2(x + (y << 8), z + (w << 8));\n} \n\n//--------------------------------------------------------------------------\nvec4 unpackData(vec2 src)\n{\n  vec4 o;\n  \n  src /= 256.0; \n  o.x = fract(src.x);\n  \n  o.y = fract(src.x / 256.0f);\n  o.z = fract(src.y);\n  o.w = src.y;\n\n  //Unpack to the -1..1 range\n  o.xyz = (o.xyz*2.0)-1.0;\n  \n  return o;\n}\n\n\n//--------------------------------------------------------------------------\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin)\n{\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n\nfloat cylinder(vec3 p, vec2 h)\n{\n    float d = length(p.xz);\n    d = max(d - h.x,   (p.y) - h.y);\n    return d;\n}\n\n\n//--------------------------------------------------------------------------\nvec4 tex3D( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture(sam, p.yz);\n\tvec4 y = texture(sam, p.zx);\n\tvec4 z = texture(sam, p.xy);\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\n//--------------------------------------------------------------------------", "buffer_a_code": "// (C) 2021 David Hoskins.\n// This is the movement tab, it started off as manual control, but that's all gone now.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\n#define NUM_POINTS 61\n\n#define INVERT_Y 0\n#define ACCEL .1\n#define DECAY  .8 // how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  10.\n\n#define WALKING\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\n//vec3 camPos[NUM_POINTS];\n\n\n         \n//----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texelFetch( iChannel1, ivec2(key, 0), 0).x);\n}\n\n//-----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour = vec4(0.0,0.0,0.0,1.0);\n\n\n    \n    int ctrl = int(fragCoord.x);\n    if (fragCoord.y > 1.0 && iFrame == 0)\n    {\n         fragColour = vec4(0);\n         return;\n    }\n    \n    float travelTime =  getTime(iTime);\n    vec3 pos = getCameraPos(travelTime);\n    if ( int(fragCoord.y) == 0 )\n    {\n\n        switch (ctrl)\n        {\n        case C_CAMROT:\n            vec3 at = getPath(travelTime+2.1);\n            vec3 at2 = vec3(50,5.,0);\n            float m = smoothstep(400., 0.0, length(pos-SPOT_POS));\n            at = mix(at, at2, m);\n            at = pos - at;\n            float r = -atan(at.z, at.x);\n            vec2 camRot = vec2(0.0, r-PI*.5);\n            //camRot.x = sin(travelTime*.6)*.5;\n            float ti = mod(travelTime*.06-3., 20.0);\n            float t2 = smoothstep(8.0, 13.0, ti) *  smoothstep(16.0, 13.0, ti);\n            float t = smoothstep(0.0, 3.0, ti) *  smoothstep(6.0, 3.0, ti);\n            \n            camRot.y+=sin(t)*1.5 - sin(t2)*1.5;\n            \n            ti = mod(travelTime*.04, 13.0);\n            t = smoothstep(0.0, 3.0, ti) *  smoothstep(6.0, 3.0, ti);\n            camRot.x-=sin(t)*.7;\n            \n            \n            t = smoothstep(0.0, 3.0, t) *  smoothstep(6.0, 3.0, t);\n            fragColour.xy = camRot;\n    \n        break;\n        case C_TORDIR:\n            float spe = iTime;\n            vec3 torchDir = normalize(vec3(+sin(spe)*.2-.2, .05, -1.));\n            camRot = texelFetch( iChannel0, ivec2(C_CAMROT,0),0 ).xy;\n            torchDir.zy = torchDir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*torchDir.yz;\n            torchDir.xz = torchDir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*torchDir.zx;\n            vec3 oldDir = texelFetch( iChannel0, ivec2(C_TORDIR,0),0 ).xyz; \n            t = getTime(iTime);\n            if (t > .5)\n                torchDir = oldDir *.8 + torchDir *.2;\n            fragColour = vec4(normalize(torchDir), 0);\n        break;\n        case C_TORPOS:\n            \n            spe = length(pos);\n            vec3 camPos = vec3(.8,-2.4,1.);\n            camRot = texelFetch( iChannel0, ivec2(C_CAMROT,0),0 ).xy;\n            camPos.zy = camPos.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*camPos.yz;\n            camPos.xz = camPos.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*camPos.zx;        \n            fragColour = vec4(camPos, 0);\n     \n        break;\n        case C_LIGHTDIR:\n        \n            //pos =  texelFetch( iChannel0, ivec2(C_CAMPOS,0),0 ).xyz;\n            pos = SPOT_POS - pos;\n            fragColour = vec4(normalize(pos), length(pos));\n        \n        break;\n    }\n    }\n        \n\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Cabin in the Woods \n// (C) 2021 David Hoskins.\n// This tab does all the ray marching. \n// And puts information into a makeshift G-Buffer.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\nfloat time;\nvec3 lightDir;\nvec3 lightDiff;\nvec3 spot;\nvec2 camRot;\nvec3 rayDir;\n\n//--------------------------------------------------------------------------\nvec4 inClearing(vec2 p)\n{\n    vec4 dat = texelFetch(iChannel1, ivec2(p)+128, 0);\n    return dat;\n}\n\n//--------------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    // Use 2D texture...\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//--------------------------------------------------------------------------\nfloat noise( in vec2 x )\n{\n    // Use 2D texture...\n\n\treturn texture( iChannel0, (x + .5)/256.0, -99.0).x;\n\n}\n\n//--------------------------------------------------------------------------\nvoid rot45(inout vec2 p)\n{\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n//--------------------------------------------------------------------------\n// Tree distance functions.\n// Uses the distance to the naerest cell from a voronoi function...\n// It allows quite handy lathed distance fields.\nfloat tree(vec3 p, in float d, in vec4 dat)\n{\n    int id = int(dat.x);\n    float treeSize = dat.y;\n    if (id >= ID_TREES && id < ID_TREES+4)\n    {\n        treeSize += smoothstep(TREE_LEAVES-15.0, TREE_LEAVES+15., p.y)*treeSize*2.;//(blockSize*.5-treeSize);\n        float d2 = d - treeSize;\n        if ( d2 > 5.0) return d2;\n        \n        float w = noise(p*vec3(.8,.3,.8))*(.5+smoothstep(TREE_LEAVES-20.,TREE_LEAVES+20.,p.y)*10.);\n        //treeSize -= w;\n        d2 -= w;\n        return d2;\n    }\n    else\n    if (id >= ID_BUSHES && id < ID_BUSHES+4)\n    {\n        float d2 = d - smoothstep(-8.3, 5., p.y)*smoothstep(40., 2., p.y) * treeSize;\n        if ( d2 > 1.0) return d2;\n        \n        float w = noise(p*2.3);\n        d2 = d2 + w;\n        \n        return d2;\n    }else\n    if (id == ID_STUMP)\n    {\n    \n        float d2 = max(d - dat.y,   p.y-dat.z);\n        d = min(d+.1, d2);\n        if (d2 > 3.) return d; \n        float w =noise(p*vec3(2,1,2));\n\n        return (d2-w);\n    }else\n     if (id == ID_RHODA)\n    {\n        \n        float d2 = length(vec2(p.y-1., d))-dat.y;\n        if (d2 > 3.) return min(d+.1, d2); \n        //vec2 loc = vec2(atan(p.z,p.x)*40., p.y*.3)*3.;\n        float w =tex3D(iChannel0, p.yxz*.01, normalize(p)).x*1.;\n        w += tex3D(iChannel0, p*.02, normalize(p)).x*.5;\n \n        return d2-w;\n    }\n\n    return d;\n\n}\n\n\n//--------------------------------------------------------------------------\nfloat windows(vec3 p)\n{\n    p.x = abs(p.x);\n    return roundBox(p - vec3(25, 12, 39.25), vec3(7.5, 6.5, .2),1.);\n}\n\n//--------------------------------------------------------------------------\nfloat ground(vec3 p)\n{\n    float l = length(getPath(p.x) - p);\n    l = min(l, roundBox2D(p.xz, vec2 (.1,150.0), .1)+20.);\n \n \n    float n = texture(iChannel2, p.xz*.01).y;//(noise(p)+ noise(p*2.1)*.6)*smoothstep(80.0, 0.0, l);\n    \n    return p.y += smoothstep(50.0, 30.0, l)*4.+n*l*.04;\n}\n\nfloat lampPost(vec3 p)\n{\n    //return fPlane(p, vec3(0,1,0), 0.0);\n    return p.y;\n}\n\n\n//--------------------------------------------------------------------------\nfloat flatWoodBits(vec3 p)\n{\n    float d =0.0;\n    d = roundBox(p - vec3(0,6.2, 39.5), vec3(5.8, 8., 1.), .2);\n    p.x = abs(p.x);\n    d = min(d, roundBox(p - vec3(25, 12, 40.0), vec3(8.0, .1, .3),.2));\n    d = min(d, roundBox(p - vec3(25, 12, 40.0), vec3(.1, 8.0, .3),.2));\n    return d;\n}\n   \n//--------------------------------------------------------------------------\nfloat cabin(vec3 p)\n{\n    float d = roundBox(p, vec3(40., 70, 40.), 1.2);// + abs(sin(p.z*PI/2.)*.5) + abs(sin(p.x*PI/2.)*.5));\n    // Doors and window holes...\n    p.x = abs(p.x);\n    d = max(d, -roundBox(p - vec3(25, 12, 42.5), vec3(8., 7, 3.), .4));\n    d = max(d, -roundBox(p - vec3(3,6, 42.5), vec3(3., 8, 3.), .3));\n    float ch = roundBox(p - vec3(39,15, 0.), vec3(3., 40, 6.), .8);  // Chimney\n    \n    // Do a mirror then a 45 degres rotation...\n    p.x = -abs(p.x);\n    rot45(p.xy);\n  \n    // Cut roof off from the box...\n    d = max(d, -fPlane(p,vec3(0, -1.,0), 50.7 ));\n    // Do roof also using the transformed point...\n    d = min(d, roundBox(p-vec3(40,52,0), vec3(50., 1, 60.), .15));\n    d = min(d, ch);\n    \n   \n    return d;\n}\n\n//--------------------------------------------------------------------------------------------------\nvec4 voronoi( vec3 p)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n    float d = 1000.7, d2;\n    vec4 ret = vec4(0.0,.7,0,0);\n    vec2 tp;\n    \n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 q = g + p.xz;\n            \n\n            vec4 dat = inClearing(q);\n \n            if (dat.x == 0.0)\n            {\n                d2 = .7;\n            }else\n            {\n                vec2 n = textureLod(iChannel0,(q)/256.0, -100.0).xy;\n                tp = g + n  - f + sin(p.y-n.y*37.)*.2;\n                d2 = dot(tp, tp);\n            }\n            \n            if (d2 < d)\n            {\n                d = d2;\n                ret = vec4(dat.xyz, sqrt(d));\n            }\n\n\t\t}\n\t}\n \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------\nfloat map(in vec3 p, float ds)\n{\n    float d= 10000.;\n    float size = 8.0, cl;\n\n\n    vec4 res = voronoi(p/TREE1_SPACING);\n    if (res.x != 0.0)\n    {\n         d = min(d, tree(p, res.w * TREE1_SPACING, res));\n    }\n    else   d = min(d, .8 * TREE1_SPACING);\n        \n    d = min(d, ground(p));\n    d = min(d, cabin(p));\n    d = min(d, windows(p));\n    d = min(d, ground(p));\n    d = min(d, cylinder(p- vec3(SPOT_POS.x,0,SPOT_POS.z), vec2(.5,SPOT_POS.y-2.)));\n\n//d = min(d, flatWoodBits(p));\n\n\n    \n\treturn d;\n}\n\n//------------------------------------------------------------------------------\nint  mapMaterial(in vec3 p)\n{\n    int mat = 0;\n\n    if (ground(p) < .1)\n    {\n        mat = ID_GROUND;\n    }\n\n \n    if (cabin(p) < .1)\n    {\n        mat = ID_CABIN;\n    }\n    if ( windows(p) < 0.1)\n    {\n        mat = ID_WINDOW;\n    }\n    if (flatWoodBits(p) < .1)\n    {\n        mat = ID_PLANEWOOD;\n    }\n    \n    vec4 res = voronoi(p/TREE1_SPACING);\n    if (res.x > 0.1)\n    {\n        float d = tree(p, res.w * TREE1_SPACING, res);\n        if (d < .1)\n        {\n           mat = int(res.x);\n        }\n    }\n        \n   \n\n    return mat;\n}\n/*\n//------------------------------------------------------------------------------\nfloat getShadow( in vec3 ro)\n{\n\tfloat res = 1.0;\n    float t = 1.;\n\tfloat h;\n    \n    lightDiff = (spot-ro);\n    float disToLight = length(lightDiff);\n    lightDir = normalize(lightDiff);\n    if (disToLight > 1000.0) return res;\n    for (int i =ZERO; i < 15; i++)\n\t{\n        vec3 p =  ro + lightDir*t;\n\t\th = map(p, t);\n        res = min(6.*h / t*t, res);\n\t\tt += h*1.3;\n        if (t > disToLight || res< .1) break;\n\t}\n    return clamp(res,.3, 8.0);\n}\n*/\n//--------------------------------------------------------------------------\nfloat raymarchScene(vec2 coord, vec3 ro, vec3 rd)\n{\n    float l = hash12(coord)*10., d;\n    int i;\n#if EXPORTED\n    for (int i = 0; i < 150; i++)\n#else\n    for (int i = 0; i < 80; i++)\n#endif\n\n    {\n        vec3 p = ro + rd * l;\n        d = map(p, l);\n        if (abs(d) < 0.03 || l >= FAR || p.y > 200.) break;\n        l += d;\n\t}\n    vec3 p = ro + rd * l;\n    \n\n    return l;\n}\n\n//--------------------------------------------------------------------------\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    ds = clamp(ds*ds*.0001, 0.1,10.5);\n    //ds = .01;\n\n    float c = map(pos, .1);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, ds), map(pos + eps_zero.yxy, ds),\n                          map(pos + eps_zero.yyx, ds) - c));\n}\n\n//--------------------------------------------------------------------------\nfloat calcOcc( in vec3 pos, in vec3 nor, float di)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= .2; h < 4.; h+= 1.)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = map(opos, di);\n        occ += (h-d)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1. - occ, 0.2, 1.0 );\n}\n\n//--------------------------------------------------------------------------\n\n//==========================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    spot = SPOT_POS;\n    time = iTime;\n\n\n    // Camera stuff...\n\n//    camera = texelFetch( iChannel3, ivec2(C_CAMPOS,0), 0 ).xyz;\n//    camera = getCameraPos(iTime);\n    float time =  getTime(iTime);\n    camera = getCameraPos(time);\n    rayDir = normalize( vec3(uv, 1.));\n        \n    vec2 camRot = texelFetch( iChannel3, ivec2(C_CAMROT,0),0 ).xy;\n    mat3 camMat = getCamFromRots(camRot, time);\n    rayDir = camMat * rayDir;\n\n\n\n    // March the scene....\n    float dist = raymarchScene(fragCoord, camera, rayDir);\n    vec4 mat;\n    \n    vec3 col = vec3(0.);\n    \n    if (dist < FAR)\n    {\n        vec3 pos = camera + dist * rayDir;\n        vec3 nor = getNormal(pos, dist);\n        float id = float(mapMaterial(pos));\n        // Pack Normal and material ID into 2 floats..\n        col.xy = packData(vec4(nor, id+.5));\n        // Just put shadow influence into z...\n        col.z = calcOcc(pos, nor, dist);\n    }else\n    {\n       col = vec3(0,0,0);\n       dist = 2000.0;\n    }\n    \n    \n    // Distance goes into w....\n    fragColour = vec4(col, dist);\n}\n//==========================================================================\n\n\n\n\n", "buffer_b_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// (C) 2021 David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\n// This buffer renders the tiny G-Buffer created in 'B'\n//     .xy = normal\n//     .z  = object ID for material lookup table.\n//     .w  = Occlusion shadow amount.\n//     .zw = could be compressed more but I didn't need it in the end.\n// Material reference data in 'Common' tab\n\nfloat time;\nvec3 lightDir;\nvec3 lightDiff;\nvec3 spot;\n\nvec2 camRot;\nvec3 rayDir;\nvec3 torPos;\nvec3 torchDir;\n\n\n//--------------------------------------------------------------------------\n// Ray-cone intersection nabbed from iq, and hacked to make just it non-capped:\n// https://iquilezles.org/articles/intersectors\n\n\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\n// Thanks Inigo, I used most of this...\n// cone defined by extremes pa and pb, and radious ra and rb.\nfloat coneIntersect( in vec3  ro, in vec3  rd, in vec3  pa, in vec3  pb, in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n         //if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    //else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return t;\n    }\n    \n    return -1.0;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 doSky(vec3 dir)\n{\n    vec3 col = FOG_COLOUR;\n    //if (dir.y > 0.0) col = mix(vec3(FOG_COLOUR), vec3(.0, 0.1,0.1),sqrt(dir.y));\n    return col;\n}\n\n\n//--------------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    // Use 2D texture...\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+ 0.5)/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n//--------------------------------------------------------------------------\nvec3 textureBump( sampler2D tx, in vec3 p, in vec3 nor, float f)\n{\n    \n    const vec2 e = vec2(.002, 0);\n    float ref = tex3D(tx, p, nor).x;                 \n    vec3 grad = (vec3(tex3D(tx, p - e.xyy, nor).x,\n                      tex3D(tx, p - e.yxy, nor).x,\n                      tex3D(tx, p - e.yyx, nor).x )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*f );\n}\n\n//--------------------------------------------------------------------------\nvec3 treeBump( sampler2D tx, in vec3 p, in vec3 nor, float f)\n{\n    \n   //const vec2 e = vec2(.003, 0);\n    \n    vec3 grad = (tex3D(tx, p*vec3(.5,.2,.5), nor).xyz)-.5;  \n    grad = grad*grad*grad*grad*10000.*f;\n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad );\n}\n\n\n//--------------------------------------------------------------------------\nvec3 torchLight(vec3 p, vec3 eyeDir, vec4 dif, vec3 nor, float sh)\n{\n\n    lightDiff = (torPos-p);\n    float disToLight = length(lightDiff);\n    lightDir = normalize(lightDiff);\n\n    vec3 col = vec3(0);\n    float bri = 0.0;\n       \n    //lightDiff = torPos-p;\n    float str = 2.0/pow(disToLight, 1.2);\n    lightDiff = lightDiff * str;\n    float ang = dot(lightDiff, torchDir);\n    ang = smoothstep(.7,.9, ang);\n    bri  = (max(dot(lightDiff, nor), 0.0))*ang*7.*sh;\n    //bri *= smoothstep(140.0, 0.0, length(disToLight));\n    col  = dif.xyz* bri;\n    nor = reflect(eyeDir, nor); // Specular...\n    col += pow(max(dot(lightDir, nor), 0.0), 18.0)*ang*dif.w*4.;\n    \n    return col;\n }\n \n\n//--------------------------------------------------------------------------\nvec3 getLighting(vec3 pos, vec3 eyeDir, vec4 dif, vec3 nor, float sh)\n{\n\n    lightDiff = (spot-pos);\n    float disToLight = length(lightDiff);\n    lightDir = lightDiff / disToLight;\n\n    float ang = dot(lightDiff, torchDir);\n    ang = smoothstep(.7,.9, ang);\n    float bri = (max(dot(lightDir, nor), 0.0));\n    float d = length(disToLight);\n    bri *= (10000. / (d*d)) * sh;\n    //bri *= smoothstep(10.0, 0.0, sqrt(pos.y));\n\tvec3 col = dif.xyz * SUN_COLOUR * bri;\n  \n        \n    nor = reflect(eyeDir, nor); // Specular...\n    col += pow(max(dot(lightDir, nor), 0.0), 8.0)  * sh * dif.w;\n\n    \n    \n    return col;\n}\n\n//--------------------------------------------------------------------------\nfloat fogmap(in vec3 q)\n{\n    q = q*.04;\n\tq += time * .1;\n    \n\tfloat f = clamp(noise(q)+noise(q*2.3)*.55+noise(q*5.)*.4, 0.0, 1.)*.2+  noise(q*10.0)*.1;\n    \n    return f;\n}\n\n//--------------------------------------------------------------------------\nvec3 fogClouds(in vec3 col, in vec3 ro, in vec3 rd, in float mt, float cone)\n{\n    float d = .4;\n    vec3 fCol = vec3(.0);\n    float f = 0.0;\n    for(int i = 0; i < 10; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos);\n        vec3 lDir = normalize(pos - spot );\n        f += clamp(rz*smoothstep(d,d*1.8,mt),0.,1.) * .6 * smoothstep(1.0, 15.0, pos.y);\n        \n        d *= 1.8;\n        if (d>mt)break;\n    }\n\n    col = mix (col, FOG_COLOUR, f);\n    \n    return col;\n}\n\n//--------------------------------------------------------------------------\nvec4 getDiffuse(vec3 p, int id, vec3 nor)\n{\n    vec4 diff  = materials[id].colour;\n    \n    if (id == ID_GROUND)\n    {\n        // See if the point is on a path...\n\n        float l = length(getPath(p.x) - p);\n        l = min(l, roundBox2D(p.xz, vec2 (.01,135.0), .01)+14.);\n        diff = mix(diff, vec4(.15, .1,.1,.1), smoothstep(35., 20., l));\n        \n        float n = noise(p*.5)+ noise(p*1.)*.5+ noise(p*2.)*.25;\n        diff = diff * mix(vec4(.6,.3, .0, .0), vec4(.2, .15, .0, .8), n);\n        diff.xyz = mix(diff.xyz, texture(iChannel1, p.xz*.08).xyz, .5);\n\n        // Tyre tracks with a clamped cosine wave....\n        l*= .2;\n        l = clamp(l, -TAU, TAU);\n        l *= ((cos(l+PI)))*.04;\n        l = clamp(l, 0.,.3);\n\n        diff -= l;\n        return diff;\n    }else\n    if (id >= ID_TREES && id <= ID_TREES + 4)\n    {\n        vec3 te = tex3D(iChannel1, p*vec3(.3, .1, .3), nor).xyz;\n        //diff = mix(diff, vec4(te, .4), .1);\n        diff.xyz *= te;\n        diff = mix(diff, vec4(0.0,.02,0,0), smoothstep(TREE_LEAVES-20., TREE_LEAVES+10., p.y));\n    }else\n    if (id == ID_CABIN)\n    {\n        diff = mix(diff, tex3D(iChannel1, p*vec3(.01, .05, .01), nor)* .3, .7);\n    }\n    if (id == ID_RHODA)\n    {\n        vec4 te = tex3D(iChannel0, p*.0023, nor);\n        float n = noise(p);\n        float v = sin(p.y)+sin(p.z+p.x*1.);\n     \n        diff = mix(diff, te, max(v*.1,0.0));\n        \n    }\n        \n\n    \n    return diff;\n}\n\n//--------------------------------------------------------------------------\nvec3 getBumpMap(in vec3 p, in int id, in vec3 nor, float f)\n{\nf = max(.5/f, .02);\n   if (id == BM_FLAT) return nor;\n\n    if (id == BM_BARK)\n    {\n        nor =  treeBump( iChannel0, p*.02*vec3(1.5, .3, 1.5), nor, f*3.);\n    }\n    else if (id == BM_GROUND)\n    {\n//const vec2 e = vec2(.001, 0);\n\n        \n        float l = length(getPath(p.x) - p);\n\n        vec3 grad = texture(iChannel1, p.xz*.03).xyz*2.-.5;\n        grad += (texture(iChannel1, p.xz*.06).zyx-.5)-.5;\n\n        l = clamp(l, -TAU, TAU);\n        l *= ((cos(l+PI)))*.04;\n        l = clamp(l, 0.,1.);\n        nor = normalize( nor + grad*f*100.*l);\n    }\n    else if (id == BM_CABIN)\n    {\n        nor.z += (abs(sin(p.y*PI*.5))-1.)*f*32.;\n        nor.y += (abs(sin(p.y*PI*.5))-1.)*f*32.;\n        //nor.x += tex3D(iChannel0, p*.5, nor).x-.5; \n        nor = normalize(nor);\n    }                  \n    return nor;\n}\n\n\n\n//==========================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    spot = SPOT_POS;\n    time = iTime;\n\n\n    // Camera stuff...\n\n    float time =  getTime(iTime);\n    camera = getCameraPos(time);\n    rayDir = normalize( vec3(uv, 1.));\n        \n    //mat3 camMat = getStoreMat33(iChannel3);\n    vec2 camRot = texelFetch( iChannel2, ivec2(C_CAMROT,0),0 ).xy;\n    mat3 camMat = getCamFromRots(camRot, time);\n    rayDir = camMat * rayDir;\n \n\n    //torPos  = camera + texture( iChannel2, vec2(6.5,.5)/iResolution.xy, -100.0 ).xyz;\n    torPos  = camera + texelFetch( iChannel2, ivec2(C_TORPOS, 0), 0 ).xyz;\n    // Fetch the marched scene....\n    vec4 fetch = texelFetch( iChannel3, ivec2(fragCoord), 0);\n    vec4 mat;\n    \n    vec3 col = vec3(0.);\n    torchDir = texelFetch( iChannel2, ivec2(C_TORDIR, 0), 0 ).xyz;\n\n    float dist = fetch.w;\n    float shad = 1.0;\n\n    \n    if (dist < FAR)\n    {\n        vec3 pos = camera + dist * rayDir;\n\n        \n        // Unpack data from buffer B...\n        vec4 data = unpackData(fetch.xy);        \n        vec3 nor = data.xyz;\n        int id = int(data.w);\n        shad = fetch.z;\n\n        // Get diffuse colour from ID...\n        vec4 diff = getDiffuse(pos, id, nor);\n        \n        // Get bump map from ID...\n        nor = getBumpMap(pos, materials[id].bumpID, nor, dist);\n        \n        col = getLighting(pos, rayDir, diff, nor, shad);\n        col += torchLight(pos, rayDir, diff, nor, shad);\n        //col = clamp(col, 0.0, 1.0);\n        col = mix(col,FOG_COLOUR, smoothstep(20.0, 90.0, pos.y));\n        \n     }else\n     dist = FAR;\n    \n    \n    float ret;\n    //float cone = infCone(camera, rayDir, torPos, torPos+torchDir*282.0, .2, 195.0, ret);\n    float cone = coneIntersect(camera, rayDir, torPos, torPos-torchDir*10.0, .4, 12.0);\n\n    //else \n\n    //cone = cone*0.004;\n    \n  if (cone > 0.0 && cone < dist)\n  {\n      //cone = max(0.0, (15.-pow(cone, 3.3)*.01))*.02;\n      //cone = smoothstep(12.0, 0.0, cone)*.8;\n      cone = 1.9/cone;\n  }else cone = .0;\n    \n    cone = pow(cone, 10.0);\n    col = mix(FOG_COLOUR, col,  min(1.0, exp(-dist *.015)));\n\n    col = clamp(cone+col, 0.0, 1.0);\n    fragColour = vec4(col, dist);\n}\n//==========================================================================\n\n\n\n\n", "buffer_c_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// A simple map layout with path and clearing for cabin.  \n// (C) 2021 David Hoskins.\n// The Voronoi function uses this a tree reference. \n\n//  It may have been a lot faster if I could use different sized buffers.\n// As it is the code indexes into a massive full screen sized buffer, which can't be fast.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licence options\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    //if (iFrame > 3 || (fragCoord.x >= 256. || fragCoord.y >= 256.)) discard;\n    \n    int id;\n    float size, height;\n    \n    float d = doClearing((fragCoord-128.)*TREE1_SPACING);\n    if (d <= 0.0)\n        fragColour = vec4(0);\n    else \n    {\n        id = int(hash12(fragCoord*3.5+40.)*10.)+ID_TREES;\n        \n        if (id >= ID_TREES && id < ID_TREES+4)\n        {\n            size = floor(hash12(fragCoord*4.5)*4.0+1.);\n        }else\n        if (id >= ID_BUSHES && id < ID_BUSHES+4) // Bushes have a bigger foot print.\n        {\n            size = floor(hash12(fragCoord*3.5)*6.0+4.);\n        }else\n        if (id == ID_STUMP) // Bushes have a bigger foot print.\n        {\n            size = floor(hash12(fragCoord*3.5)*6.0+1.);\n            height = hash12(fragCoord*30.0)*20.0 + 1.;\n            \n        }else\n        if (id == ID_RHODA) // Rhodoendron\n        {\n            size = floor(hash12(fragCoord*3.5)*7.0+4.);\n            height = hash12(fragCoord*30.0)*4.0 + 2.;\n        }\n       \n        fragColour = vec4( float(id),     // X = type ID\n                           size,          // Y = size\n                           height,\n                           0);\n\n     }\n\n}", "buffer_d_inputs": [], "sound_code": "// Cabin in the Woods \n// Audio tab. Some quiet wind and crunchy foot steps.\n// Edited version from Frozen Wasteland:\n// https://www.shadertoy.com/view/Xls3D2\n\n// (C) 2021 David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Contact the author for other licence options\n\n\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat tri(in float x){return abs(fract(x)-.5)*2.0;}\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\t//p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 shash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 Noise21(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n    \n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nfloat Noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f)-.5;\n\n}\n\n\n//----------------------------------------------------------------------------------------\n//  2 out, 2 in...\nvec2 Noise22(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( shash22(p),          shash22(p + add.xy),f.x),\n                   mix( shash22(p + add.yx), shash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .6;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n     \n    return r;\n}\n\n\n//----------------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n    vec2 audio = vec2(.0);\n    time = mod(time, 100.0);\n    vec2 n1 =  FBM22( vec2(time*850.+Noise21(time*12.25)))*.2;\n    vec2 n2 = FBM22( time*(Noise21(time*.4)*100.+40.0))*abs(Noise21(time*1.5))*.5;\n\n    vec2 s1 = sin(time*(200.+(Noise21(time*.033)*100.)*(Noise21(-time*.01)*30.2)))*.1;\n    audio += (n1+n2+s1)/5.0;\n\n    float t = getTime(time);\n    //audio = vec2(0);\n    float foot = abs(sin(t*.3-.5));\n    audio += (Noise11(time*100.0)+Noise11(time*1800.)*Noise11(time*3000.0))* (smoothstep(0.96,1.,foot) * .8 );// + smoothstep(.0, .5, foot)*.4);\n\n    audio =  clamp(audio, -1.0, 1.0) * smoothstep(0.0, 3.0, time) * smoothstep(99.0, 90.0, time);\n#if EXPORTED\n    audio += sin(time*220.*PI)* smoothstep(.1, .0, time); // For easy audio sync in separate frame video recording.\n#endif\n    return audio;\n}", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1272, 1272, 1469, 1522, 2265], [2268, 2359, 2419, 2419, 3542], [3544, 3712, 3770, 3770, 5227]], "test": "untested"}
{"id": "sssGzX", "name": "Parallelogram - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a parallelogram. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "parallelogram"], "likes": 17, "viewed": 608, "published": 3, "date": "1616438766", "time_retrieved": "2024-07-30T19:31:22.273172", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parallelogram. Probably\n// faster than central differences or automatic differentiation/dual\n// numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e = vec2(sk,he);\n    float v = 1.0;\n    if( p.y<0.0 ) { p=-p;v=-v;}\n\n    // horizontal edge\n    vec2 w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec4 dsg = vec4(dot(w,w),v*w,w.y);    \n\n    // vertical edge\n    float s = p.x*e.y - p.y*e.x;\n    if( s<0.0 ) { p=-p; v=-v; }\n    vec2  q = p - vec2(wi,0); q -= e*clamp(dot(q,e)/dot(e,e),-1.0,1.0);\n    float d = dot(q,q);\n    s = abs(s) - wi*he;\n    dsg = vec4( (d<dsg.x) ? vec3(d,v*q) : dsg.xyz,\n                (s>dsg.w) ?      s      : dsg.w );\n     \n    // signed distance\n    d = sqrt(dsg.x)*sign(dsg.w);\n    // and gradient\n    return vec3(d,dsg.yz/d); \n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n\n        // sdf(p) and gradient(sdf(p))\n        float s = sin(iTime);\n        vec3  dg = sdgParallelogram(p,0.4, 0.6,s);\n        float d = dg.x;\n        vec2 g = dg.yz;\n        \n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssGzX.jpg", "access": "api", "license": "mit", "functions": [[1380, 1475, 1541, 1541, 2155]], "test": "ok"}
{"id": "sds3zl", "name": "polygon n", "author": "jezersek", "description": "polygon", "tags": ["polygon"], "likes": 2, "viewed": 269, "published": 3, "date": "1616424037", "time_retrieved": "2024-07-30T19:31:23.123897", "image_code": "float mind = 1.;\nvec4 color(float v, vec3 col){\n    vec3 c = vec3(v*.1,v*.1,v*.1);\n    c += mix(vec3(0,0,0), col, 0.1/(v*pow(sin(v*100.),2.)));\n    return vec4(c, 1);\n}\n\nvec2 point(int i){\n    float j = float(i);\n    float fx = (2.+sin(iTime/10.+j))*10.;\n    vec2 p = vec2(\n        mix(0.2,iResolution.x/mind-0.2, 0.5+0.5*sin(iTime*0.17+fx)), \n        mix(0.2,iResolution.y/mind-0.2, 0.5+0.5*cos(iTime*0.19+fx))\n    );\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    mind = min(iResolution.y, iResolution.x);\n    vec2 uv = fragCoord/mind;\n    \n    // distortion\n    float rotationSpeed = 0.1;\n    float amplitude = 0.05;\n    float rotation = (uv.x*sin(iTime*rotationSpeed)+uv.y*cos(iTime*rotationSpeed))*10.;\n    uv.x += sin(rotation+iTime)*amplitude;\n    uv.y += cos(rotation+iTime)*amplitude;\n   \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float v = 1./0.; // neskonno\n    \n    int n = 5; // stevilo oglji\n    \n    for(int i=0; i<n; i++){\n        int j = (i+1)%n;\n        \n        float s = 0.;\n        \n        vec2 p1 = point(i);\n        vec2 p2 = point(j);\n        \n        vec2 pMid = (p1+p2)/2.;\n        \n        float dp = distance(p1, pMid); // razdalja od sredine daljice do oglija\n    \n        // izraunaj razdaljo od premice (med p1 in p2)\n        vec2 r = normalize(p1 - p2); // smerni vektor\n        float d = length(uv-p1-dot(r, uv-p1)*r); // razdalja trenutne toke od premice\n        \n        // izraunaj razdaljo pravokotne projekcije uv na daljico do sredia daljice med p1 in p2\n        float dMid = length(dot(r,uv-pMid));\n        \n        // e je razdalja od sredia daljice prevelika, vzemi razdaljo do enega ogljia (p1/p2)\n        if(dMid > dp) d = distance(uv, p1); \n        \n        if(d < v)v = d;\n    }\n    \n    fragColor = color(v, col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 47, 47, 168], [170, 170, 188, 188, 439], [441, 441, 498, 498, 1854]], "test": "untested"}
{"id": "7ssGRs", "name": "Fractal 41_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 18, "viewed": 429, "published": 3, "date": "1616422605", "time_retrieved": "2024-07-30T19:31:23.964650", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=.1;\n        ++i<80.;\n        O.xyz+=.03*abs(cos(d+.5+log2(s)*.6))*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d-vec3(.1,.2,1);\n        p.z-=1.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=2.;\n        for(int j=0;j++<8;)\n            p-=clamp(p,-.9,.9)*2.,\n            p=p*(e=3./min(dot(p,p),1.))+q,\n            s*=e;\n            g+=e=length(p)/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.8,1.,1.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 622]], "test": "untested"}
{"id": "7sl3zl", "name": "lovely Gaussians", "author": "FabriceNeyret2", "description": "Gaussians have many lovely unique properties:\nE.g., Gaussians are the only separable rotationally symmetrical function:\nWhite 2D Gaussian is the product of red and green 1D Gaussians. Isovalues in blue.\n( Note that separability allows efficient filters ).", "tags": ["maths", "gaussians"], "likes": 7, "viewed": 284, "published": 3, "date": "1616420936", "time_retrieved": "2024-07-30T19:31:24.730602", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) /R.y,\n         G = exp2(-4.*U*U);\n    O = dot(U,U)<.7 ? vec4(G.x*G.y)     //  white = 2D Gaussian\n                    : vec4(G,0,0);      //  red, green = 1D Gaussians\n    \n    float s = sin(50.*max(O.r,O.g));    // isovalues\n    O = mix( O, vec4(0,0,1,0), smoothstep(1.,-1.,abs(s)/fwidth(s)) ); // blend\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sl3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 399]], "test": "untested"}
{"id": "fdf3zs", "name": "GridBlend7", "author": "Del", "description": "another blend", "tags": ["grid", "blend", "hex", "tri"], "likes": 12, "viewed": 278, "published": 3, "date": "1616412244", "time_retrieved": "2024-07-30T19:31:25.496554", "image_code": "\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n    if((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);\n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0));\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.);\n    id.xy += sign(lg-1.)*0.1;\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\nfloat hbar(vec2 p, float nline, float t)\n{\nreturn 0.5+sin((p.y*nline)+t)*0.5;\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\nmat2 _rot(float th)\n{\n\tvec2 a = sin(vec2(1.5707963, 0) + th);\n\treturn mat2(a.xy, -a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tt = iTime;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= _rot(iTime*0.1);\n    vec2 id;\n    vec2 id2;\n    float zoom = 5.;\n    zoom += sin(uv.x*2.0+tt) * 0.5;\n    vec4 h = HexGrid(uv*zoom*2.0, id)*1.1;\n    uv *= _rot(-iTime*0.16);\n    vec4 h2 = TriGrid(uv*zoom, id2)*1.1;\n    h.x = min(h.x+1.5, h2.x*2.75);\n    float vvv1 = abs(h2.x-h.x)*0.4;\n    float vvv2 = abs(h2.y-h.y)*0.25;\n\th.x = smin(h.x,h2.y-0.05,1.95);\n    id = mix(id,id2,0.5);\n    float vvv = min(vvv1,vvv2)*(1.75+sin(tt*1.5+length(id*16.0)));\n    vec3 shapecol = vec3(0.125, 0.275, 0.155)*.95;\n\tshapecol = shapecol.xzy;\n    vec3 shapecol2 = vec3(1.53,0.9,0.7) * 5.0;\n    shapecol = mix(shapecol,shapecol2,vvv);\n    float cm = 1.0 + pow(abs(sin(length(id)*.25 + tt*0.65)), 32.0);\n    cm *= 1.0 + (hbar(h.zw,100.0,tt*12.0)*0.1);\n    shapecol *= cm;\n    vec3 bordercol = shapecol;\n    vec3 finalcol = mix(bordercol*0.2,shapecol,smoothstep(-0.05, 0.045, h.x));\n    fragColor = vec4(finalcol*3.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 521], [522, 522, 558, 558, 1062], [1063, 1063, 1105, 1105, 1142], [1143, 1143, 1184, 1184, 1271], [1272, 1272, 1293, 1293, 1366], [1368, 1368, 1425, 1425, 2430]], "test": "untested"}
{"id": "fsfGzs", "name": "GridBlend6", "author": "Del", "description": "another blend", "tags": ["grid", "blend", "hex", "tri"], "likes": 8, "viewed": 234, "published": 3, "date": "1616412239", "time_retrieved": "2024-07-30T19:31:26.269487", "image_code": "\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n    if((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);\n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0));\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.);\n    id.xy += sign(lg-1.)*0.1;\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\nfloat hbar(vec2 p, float nline, float t)\n{\nreturn 0.5+sin((p.y*nline)+t)*0.5;\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 _rot(float th)\n{\n\tvec2 a = sin(vec2(1.5707963, 0) + th);\n\treturn mat2(a.xy, -a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tt = iTime;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= _rot(sin(uv.x*uv.y)*0.25+iTime*0.1);\n    vec2 id;\n    vec2 id2;\n    float zoom = 10.;\n    zoom += sin(uv.x*2.0+tt) * 0.5;\n    vec4 h = HexGrid(uv*zoom, id)*0.9;\n    vec4 h2 = TriGrid(uv*zoom, id2)*1.4;\n    h.x = min(h.x+0.5, h2.x*2.75);\n    float vvv1 = abs(h2.x-h.x)*0.4;\n    float vvv2 = abs(h2.y-h.y)*0.25;\n\th.x = smin(h.x,h2.y-0.05,0.8);\n    id = mix(id,id2,0.5);\n    float vvv = min(vvv1,vvv2)*(1.75+sin(tt*1.5+length(id*16.0)));\n    vec3 shapecol = vec3(0.125, 0.275, 0.155)*.95;\n    vec3 shapecol2 = vec3(0.83,.95,.83) * 4.0;\n    shapecol = mix(shapecol,shapecol2,vvv);\n    float cm = 1.0 + pow(abs(sin(length(id)*.25 + tt*0.65)), 64.0);\n    cm *= 1.0 + (hbar(h.zw,100.0,tt*12.0)*0.1);\n    shapecol *= cm;\n    vec3 bordercol = shapecol;\n    vec3 finalcol = mix(bordercol*0.2,shapecol,smoothstep(-0.05, 0.045, h.x));\n    fragColor =vec4(finalcol*0.8,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 521], [522, 522, 558, 558, 1062], [1063, 1063, 1105, 1105, 1142], [1143, 1143, 1184, 1184, 1271], [1273, 1273, 1294, 1294, 1367], [1369, 1369, 1426, 1426, 2391]], "test": "untested"}
{"id": "fdfGzs", "name": "GridBlend5", "author": "Del", "description": "another blend", "tags": ["grid", "blend", "hex", "tri"], "likes": 9, "viewed": 278, "published": 3, "date": "1616412234", "time_retrieved": "2024-07-30T19:31:27.040426", "image_code": "\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n    if((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);\n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0));\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.);\n    id.xy += sign(lg-1.)*0.1;\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\nfloat hbar(vec2 p, float nline, float t)\n{\nreturn 0.5+sin((p.y*nline)+t)*0.5;\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nmat2 _rot(float th)\n{\n\tvec2 a = sin(vec2(1.5707963, 0) + th);\n\treturn mat2(a.xy, -a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tt = iTime;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= _rot(sin(uv.x*uv.y)*0.25+iTime*0.1);\n    vec2 id;\n    vec2 id2;\n    float zoom = 8.0;\n    zoom += sin(uv.x*4.0+tt) * 0.5;\n    vec4 h = HexGrid(uv*zoom, id);\n    vec4 h2 = TriGrid(uv*zoom, id2)*1.4;\n    h.x = min(h.x+0.5, h2.x*2.5);\n    float vvv1 = abs(h2.x-h.x);\n    float vvv2 = abs(h2.y-h.y)*0.25;\n\th.x = smin(h.x,h2.y-0.05,0.5);\n\th.x = min(h.x,h2.x*0.8);\n    id = mix(id,id2,0.5);\n    float vvv = min(vvv1,vvv2)*(2.0+sin(length(id*8.0)));\n    vec3 shapecol = vec3(0.2, 0.125, 0.25)*0.95;\n    vec3 shapecol2 = vec3(0.6,.45,.93) * 4.0;\n    shapecol = mix(shapecol,shapecol2,vvv);\n    float cm = 1.0 + pow(abs(sin(length(id)*231.5 + tt*0.65)), 4.0);\n    cm *= 1.0 + (hbar(h.zw,100.0,tt*12.0)*0.1);\n    shapecol *= cm;\n    vec3 bordercol = shapecol;\n    vec3 finalcol = mix(vec3(0.0,0.0,0.0),shapecol,smoothstep(-0.02, 0.055, h.x));\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 521], [522, 522, 558, 558, 1062], [1063, 1063, 1105, 1105, 1142], [1143, 1143, 1184, 1184, 1271], [1274, 1274, 1295, 1295, 1368], [1370, 1370, 1427, 1427, 2399]], "test": "untested"}
{"id": "7dlGRf", "name": "Parallelogram - distance 2D", "author": "iq", "description": "Distance to a parallelogram, with only two edge checks (ie, total SDF with just two divisions, and a single square root), by using symmetry.", "tags": ["2d", "distancefield", "sdf", "distance", "parallelogram"], "likes": 22, "viewed": 2098, "published": 3, "date": "1616405811", "time_retrieved": "2024-07-30T19:31:27.875194", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to a parallelogram, I implemented three methods:\n// Method 1: computed by two edges, by symmetry, single square root\n// Method 2: computed by interior/exterior, optimization of Pentan's idea\n// Method 3: computed by zones\n\n#define METHOD 1\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_1( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    p = (p.y<0.0)?-p:p;\n    // horizontal edge\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    // vertical edge\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/e2,-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    float da = abs(p.x*e.y-p.y*e.x)-wi*he;\n    float db = abs(p.y)-e.y;\n    if( max(da,db)<0.0 ) // interior\n    {\n        return max( da*inversesqrt(e2), db );\n    }\n    else                 // exterior\n    {\n       float f = clamp(p.y/e.y,-1.0,1.0);\n       float g = clamp(p.x-e.x*f, -wi, wi);\n       float h = clamp(((p.x-g)*e.x+p.y*e.y)/e2,-1.0,1.0);\n       return length(p-vec2(g+e.x*h,e.y*h));\n    }\n}\n\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    // above\n    float db = abs(p.y)-he;\n    if( db>0.0 && abs(p.x-sk*sign(p.y))<wi )\n        return db;\n        \n    // inside\n    float e2 = sk*sk + he*he;\n    float h  = p.x*he - p.y*sk;\n    float da = (abs(h)-wi*he)*inversesqrt(e2);\n    if( da<0.0 && db<0.0 )\n        return max( da, db );\n\n    // sides\n    vec2 q = (h<0.0)?-p:p; q.x -= wi;\n    float v = abs(q.x*sk+q.y*he);\n    if( v<e2 )\n        return da;\n    \n    // exterior\n    return sqrt( dot(q,q)+e2-2.0*v );\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    #if METHOD==1\n    return sdParallelogram_1(p,wi,he,sk);\n    #endif\n    #if METHOD==2\n    return sdParallelogram_2(p,wi,he,sk);\n    #endif\n    #if METHOD==3\n    return sdParallelogram_3(p,wi,he,sk);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate\n    float sk = 0.5*sin(iTime);\n    float ra = 0.0;//0.1 + 0.1*sin(1.3*iTime);\n        \n    //p.x -= sk; // enable to lock base in place\n\n    // distance\n\tfloat d = sdParallelogram(p,0.4,0.6,sk)-ra;\n\n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdParallelogram(m,0.4,0.6,sk)-ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlGRf.jpg", "access": "api", "license": "mit", "functions": [[1463, 1526, 1594, 1594, 2007], [2009, 2009, 2077, 2077, 2544], [2546, 2546, 2614, 2627, 3089], [3091, 3091, 3157, 3157, 3372], [3374, 3374, 3431, 3431, 4273]], "test": "ok"}
{"id": "Nsf3RX", "name": "8. Heart!", "author": "Sp3cim4n", "description": "Learning Shader Magic.", "tags": ["heart", "learning"], "likes": 1, "viewed": 220, "published": 3, "date": "1616399103", "time_retrieved": "2024-07-30T19:31:28.640149", "image_code": "#define S(a,b,t) smoothstep(a, b, t);\n\n#define HEART_COLOR vec3(1., .05, .05)\n\n// Drag mouse up or down in viewport.\n\nfloat smax(float a, float b,  float k)\n{\n    float h = clamp((b-a)/k + .5, 0., 1.);\n    return mix(a, b, h) + h*(1.-h)*k*.5;\n}\n\nfloat heart(vec2 uv, float b)\n{\n    float r = .25;\n    b *= r + .01;\n    \n    uv.x *= .7;\n    uv.y -= smax(sqrt(abs(uv.x)) * .5, b, .1);\n    uv.y += .1 + b*.5;\n    \n    float d = length(uv);\n    return S(r + b/.5, r-b/.5, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(.0);\n\n    //heart\n    float c = heart(uv, m.y);\n    \n    col = vec3(c * HEART_COLOR);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 158, 158, 244], [246, 246, 277, 277, 473], [475, 475, 532, 532, 783]], "test": "untested"}
{"id": "fdsGRf", "name": "Endless Rainbow Well", "author": "Tater", "description": "first shader I've made without any tutorial.\nIf you watch it for a long time it produces some interesting color palettes. ", "tags": ["2d", "rainbow"], "likes": 4, "viewed": 255, "published": 3, "date": "1616386013", "time_retrieved": "2024-07-30T19:31:29.406101", "image_code": "mat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur ,d);\n    return c;\n}\nvec3 endlessRGB(float offset, float iTime){\n    //color intensity\n    float colori = 0.4+0.25*(1.0+sin(iTime));\n    //magic\n    return vec3(\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(10.0+offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(20.0+offset),1000.0))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 cuv=uv; //Untoched uv for center stuff\n    \n    //manipulating UV to setup side walls\n    uv*=1.3;\n    clamp(uv.x,-1.0,1.0);\n    uv.x=1.0-mod(uv.x,2.0);\n    \n    //Speed\n    float t=iTime*2.0;\n    \n    //Wobbly Jerk Time\n    t= floor(t*0.25)+pow(fract(t*0.25),0.6);\n    t*=4.0;\n    //Rotation\n    uv*=Rot(0.05*sin(iTime));\n    vec3 col = vec3(0.0);\n    vec2 ruv = uv;\n    \n    //Downward Movement and initial offset\n    ruv.y+=t*0.1+10.0;\n    \n    //Wavey Y\n    ruv.y-=0.04*abs(sin(ruv.x*6.0+sin(ruv.y*3.0)));\n    \n    //Scaling Y for to make space for Layers\n    ruv.y *= 25.0;\n    \n    //Row on/off\n    float rid = floor(mod(ruv.y,2.0));\n\n    //Inner Edge\n    float edge1 = smoothstep(abs(ruv.x)-0.002,abs(ruv.x),0.2);\n    \n    //Moving Edge\n    float edge2;\n    float waves=3.0;\n    \n    if(ruv.x>0.0){\n        edge2 = smoothstep(ruv.x-0.005,ruv.x,0.5+0.2*sin(t+floor(ruv.y*waves))); //I think this might be backwards\n    }\n    else{\n        edge2 = smoothstep(-ruv.x-0.00,-ruv.x,0.5+0.2*sin(-t-floor(ruv.y*waves)));\n    }    \n    edge2+=(1.0-rid);\n    \n    //coloring edges\n    float l1 = rid*edge2;\n    float l2 = (1.0-rid)*edge1;\n    \n    col.rgb+=l1*endlessRGB(ruv.y,iTime);\n    col.rbg+=vec3(l2);\n    \n    //duplicating the circle and moving it\n    float rotDir = 1.0-2.0*mod(floor((cuv.y-t*0.05)*2.0),2.0);\n    cuv.y=0.25-mod(cuv.y-t*0.05,.5);\n    cuv*=Rot(rotDir*t*0.4);\n    \n    //adding circles\n    col+= endlessRGB(cuv.y*30.0+10.0,iTime)*Circle(cuv, vec2(0.0), .2, .2);\n    \n    fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 79], [80, 80, 131, 131, 215], [216, 216, 259, 281, 579], [580, 580, 637, 637, 2227]], "test": "untested"}
{"id": "Ndl3zf", "name": "Simple Halftone - Drawing a Grid", "author": "choxi", "description": "Part 1 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 4, "viewed": 716, "published": 3, "date": "1616384266", "time_retrieved": "2024-07-30T19:31:30.176042", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridResolution = 10.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Create a grid of (gridResolution x gridResolution) cells that go from 0 -> 1\n    vec2 uv2 = fract(uv * gridResolution);\n    \n    // Convert the grid dimensions from 0 -> 1 to -1 -> 1\n    // Dimensions that center on 0 make it easier to draw circles.\n    vec2 uv3 = 2.0 * uv2 - 1.0;\n\n    fragColor = vec4(uv2.x, uv2.y, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 528]], "test": "untested"}
{"id": "fssGzf", "name": "Simple Halftone - Drawing Dots", "author": "choxi", "description": "Part 2 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["imageprocessing"], "likes": 2, "viewed": 774, "published": 3, "date": "1616382046", "time_retrieved": "2024-07-30T19:31:30.942992", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float dotResolution = 10.0;\n    float dotRadius = 0.5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = 2.0 * fract(uv * dotResolution) - 1.0;\n    float distance = length(uv2);\n    \n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color = mix(black, white, step(dotRadius, distance));\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 501]], "test": "untested"}
{"id": "fslGzf", "name": "fractal triangulo jfp", "author": "jorge2017a1", "description": "fractal triangulo jfp", "tags": ["fractaltriangulojfp"], "likes": 1, "viewed": 195, "published": 3, "date": "1616379501", "time_retrieved": "2024-07-30T19:31:31.705952", "image_code": "//por jorge2017a1- jorge flores p.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat fractaltriangulo( in vec2 pfragCoord ) \n{\n\n\tvec2 p = pfragCoord;\n\tfloat d = 1.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tp = abs(p - s);\n\t\ts *= 0.5;\n        \n        float s1=sdTriangleIsosceles( p, vec2(s) );\n        d = min(d, s1);\n        }\n\n\treturn d;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\tp= rotate_x(p-vec3(0.0,0.0,0.0), radians(90.0));\n    \n    float sb1= sdBox( p, vec3(2.0,0.5,1.0) );\n    float st1=fractaltriangulo( p.xz );\n    float dif= intersectSDF(sb1, st1);\n    res =opU3(res, vec3(dif,1.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        \n        //dO += dS.x*DISTANCE_BIAS;  //caso especial\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(1.0,0.5,-2.6+2.0*abs(sin(t*0.5)) );\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n    //col= getSkyColB(rd, uv, vec3(0.0));\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n\n#define MATERIAL_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 449, 449, 533], [535, 579, 626, 626, 653], [655, 655, 698, 698, 725], [727, 727, 775, 775, 803], [804, 875, 909, 909, 1007], [1008, 1008, 1042, 1042, 1134], [1135, 1135, 1169, 1169, 1261], [1262, 1302, 1336, 1336, 1433], [1436, 1436, 1487, 1487, 1795], [1797, 1797, 1844, 1844, 2069], [2071, 2111, 2136, 2136, 2547], [2552, 2552, 2617, 2617, 3201], [3203, 3254, 3278, 3278, 3466], [3471, 3471, 3504, 3504, 4358], [4363, 4417, 4453, 4453, 4687], [4688, 4777, 4857, 4857, 5134], [5178, 5178, 5271, 5271, 5371], [5375, 5375, 5402, 5402, 5512], [5515, 5564, 5621, 5621, 7055]], "test": "untested"}
{"id": "Ndl3zX", "name": "Simple Halftone", "author": "choxi", "description": "Part 7 of a halftone tutorial: https://pixel.gl/blog/6-how-to-write-a-simple-halftone-shader", "tags": ["image"], "likes": 0, "viewed": 834, "published": 3, "date": "1616372428", "time_retrieved": "2024-07-30T19:31:32.468912", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float dotResolution = 50.;\n  vec2 colorUV = fragCoord / iResolution.xy;\n  vec2 uv = fragCoord / iResolution.y;\n  vec4 color = texture(iChannel0, colorUV);\n  \n  // RGB-to-CMYK conversion\n  vec4 cmyk;\n  cmyk.xyz = 1.0 - color.rgb;\n  cmyk.w = min(cmyk.x, min(cmyk.y, cmyk.z));\n  cmyk.xyz -= cmyk.w;\n\n  vec2 Kst = dotResolution*mat2(0.707, -0.707, 0.707, 0.707)*uv;\n  vec2 Kuv = 2.0*fract(Kst)-1.0;\n  float kR = sqrt(cmyk.w);\n  float k = smoothstep(kR + 0.1, kR - 0.1, length(Kuv));\n  vec2 Cst = dotResolution*mat2(0.966, -0.259, 0.259, 0.966)*uv;\n  vec2 Cuv = 2.0*fract(Cst)-1.0;\n  float cR = sqrt(cmyk.x);\n  float c = smoothstep(cR + 0.1, cR - 0.1, length(Cuv));\n  vec2 Mst = dotResolution*mat2(0.966, 0.259, -0.259, 0.966)*uv;\n  vec2 Muv = 2.0*fract(Mst)-1.0;\n  float mR = sqrt(cmyk.y);\n  float m = smoothstep(mR + 0.1, mR - 0.1, length(Muv));\n  vec2 Yst = dotResolution*uv; // 0 deg\n  vec2 Yuv = 2.0*fract(Yst)-1.0;\n  float yR = sqrt(cmyk.z);\n  float y = smoothstep(yR + 0.1, yR - 0.1, length(Yuv));\n  \n  vec3 rgb = 1. - vec3(c, m, y);\n  rgb = mix(rgb, vec3(0., 0., 0.), k);\n  fragColor = vec4(rgb, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1166]], "test": "untested"}
{"id": "7sXGzf", "name": "GridBlend4", "author": "Del", "description": "More grid blending fun - use mouse border change", "tags": ["grid", "blend", "hex", "tri"], "likes": 13, "viewed": 291, "published": 3, "date": "1616364297", "time_retrieved": "2024-07-30T19:31:33.325621", "image_code": "\n// more grid blending! (hex + tri grid)\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tuv *= rot(sin(uv.x*uv.y)*0.25+iTime*0.1);\n\n    // dirty grid blending attempt #4\n    vec2 id;\n    vec2 id2;\n    float zoom = 8.0;\n    zoom += sin(t)*2.0;\n    \n    float zoom2 = zoom;\n    //if (iMouse.z>0.5)\n    //    zoom2 *= 1.5;// secondary zoom\n    \n    vec4 h = HexGrid(uv*zoom2, id);\n    vec4 h2 = TriGrid(uv*zoom, id2);\n\n\tfloat vvv1 = abs(h2.x-h.x);\n\tfloat vvv2 = abs(h2.y-h.y)*0.95;\n\t\n\t\n\t\n    h.x = smin(h.x,h2.x,0.125); // blend distance\n    id = mix(id,id2,0.5); // blend IDs\n\n    float vvv = min(vvv1,vvv2)*(2.0+sin(length(id*8.0)));\n\t\n    vec3 bordercol = vec3(0.9,0.9,0.7);\n    vec3 shapecol = vec3(0.2,0.15,0.15);\n    vec3 shapecol2 = vec3(1.,.5,.3)*2.0;\n\tshapecol = mix(shapecol,shapecol2,vvv);\n    // just do a simple patterned shape tint based on (blended) cell IDs\n\n    float patternVal = .5; // 33.5 make this large to randomize the effect\n\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    if (iMouse.z<0.5)\n        bordercol = shapecol;\n    \n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv); // white edge\n\n    fragColor = vec4(finalcol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 78, 78, 586], [588, 801, 837, 837, 1440], [1442, 1442, 1484, 1484, 1525], [1527, 1527, 1568, 1568, 1657], [1659, 1659, 1680, 1680, 1748], [1750, 1750, 1807, 1807, 3252]], "test": "untested"}
{"id": "ssXGRf", "name": "Apollonian Conics", "author": "mla", "description": "A family of conics constructed on oblique axes, following Apollonius. Mouse moves axes, key 'f' controls display of field vectors.", "tags": ["conic", "loopless", "apollonius", "sections"], "likes": 8, "viewed": 353, "published": 3, "date": "1616359119", "time_retrieved": "2024-07-30T19:31:34.097557", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian Conics, Matthew Arcus, mla, 2021. Creative Commons Licence, etc.\n//\n// Around 200 BC Apollonius of Perga showed that any section through a oblique\n// cone could be represented, in modern terms, as a curve y = kx + x, with x\n// and y coordinates referred to generally oblique axes. This equation represents\n// a conic that i) passes through the origin ii) is tangent to the y axis and\n// iii) the x axis is a diameter that passes through the centre of the conic\n// and bisects all chords parallel to the y-axis.\n//\n// Mouse rotates axes. The red conic is the parabola in the family, so the\n// curves inside are ellipses, the ones outside are hyperbolas\n//\n// Loopy and loopless methods implemented. The loopless method does something\n// strange around the origin which I'm not sure how to fix.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nconst float HALFPI = 0.5*PI;\n\n// Distance to conic with parameter -1 < k < 1\n// k = 0 is straight line\n// else k = 1 or -1 is parabola\n// else k < 0 is ellipse\n// else k > 0 is hyperbola\nfloat conic(vec2 z,float k,mat2 m) {\n  k = 1.0/tan(k*HALFPI);\n  float x = z.x, y = z.y;\n  if (abs(k) > 1e4) return abs(x);\n  float t = k*x*x+x-y*y;\n  vec2 grad = vec2(2.0*k*x+1.0,-2.0*y);\n  grad = m*grad;\n  return abs(t)/length(grad);\n}\n\nfloat K = 10.0; // Show 2K conics\n// Loopless.\nvec2 conicdist0(vec2 z, mat2 m) {\n  float T = 1.0;\n  float x = z.x, y = z.y;\n  float k = atan(x*x/(y*y-x))/HALFPI;\n  float t = iTime;\n  k -= T/K*t;\n  float k0 = k;\n  k *= K; \n  k = round(k);\n  k += T*t;\n  k /= K; \n  float d = conic(z,k,m);\n  return vec2(k0,d);\n}\n\n// Loopy. Not too slow & a nicer image.\nvec2 conicdist1(vec2 z, mat2 m) {\n  float x = z.x, y = z.y;\n  float k0 = atan(x*x/(y*y-x))/HALFPI;\n  float t = iTime;\n  k0 -= t/K;\n  float d = 1e8;\n  for (float i = -K; i < K; i++) {\n    float k = (i+t)/K;\n    d = min(d,conic(z,k,m));\n  }\n  return vec2(k0,d);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return 0.75*rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\nconst int CHAR_F = 70;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 1; // This doesn't really need AA, but just in case.\n  vec3 col = vec3(0);\n  vec2 w = iTime*vec2(-0.123,0.1);\n  if (iMouse.z > 0.0) w = PI*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  mat2 m = mat2(rotate(vec2(1,0),w.x), rotate(vec2(0,1),w.y)); // Rotated axes\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      z *= 2.0;\n      vec2 z0 = z; // Untransformed coordinate\n      z *= m; // Transform to oblique coordinates (postmultiply = transpose multiply)\n      vec2 ldist = fragCoord.y < 0.5*iResolution.y ? conicdist0(z,m) : conicdist1(z,m);\n      float lmin = 0.0, lmax = max(0.02,fwidth(length(z)));\n      float h = fract(0.5*ldist.x);\n      vec3 c = 0.2+0.8*h2rgb(min(h,1.0-h)); // Field value to colour\n      // Draw axes & grid\n      vec2 uv = abs(z);\n      float d = min(uv.x,uv.y); // Show axes\n      c = mix(c,vec3(0),1.0-smoothstep(lmin,lmax,d));\n      d = abs(conic(z,1.0,m)); // Show parabola\n      c = mix(c,vec3(1,0,0),1.0-smoothstep(lmin,lmax,d));\n      if (!key(CHAR_F)) {\n        // Draw the local orthogonal vectors\n        vec2 z1 = z0-round(z0*10.0)/10.0; // Local base point\n        ivec2 ix = ivec2(round(z0*10.0));\n        if (((ix.x^ix.y)&1) == 0) c *= 0.8;\n        float x = z.x, y = z.y;\n        vec2 a = vec2(1,-2.0*x*y/(2.0*y*y-x)); // Tangent vector at local point, in oblique coords\n        a = m*a; // Tangent vector to screen space\n        a = normalize(a);\n        //a = vec2(-a.y,a.x); // Rotate 90\n        float d = segment(z1,0.03*a,-0.03*a); //abs(dot(z1,a)/length(a)); // And find the length\n        c = mix(c,vec3(0.2),1.0-smoothstep(0.4*lmin,0.4*lmax,d));\n      }\n      // Now draw grid lines\n      uv *= 4.0;\n      uv = fract(uv);\n      uv = min(uv,1.0-uv);\n      d = min(uv.x,uv.y);\n      d /= 4.0;\n      c = mix(c,vec3(0),1.0-smoothstep(0.5*lmin,0.5*lmax,d));\n      // And finally draw conics\n      c = mix(c,vec3(1),1.0-smoothstep(lmin,0.8*lmax,abs(ldist.y)));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1038, 1195, 1231, 1231, 1431], [1449, 1480, 1513, 1513, 1742], [1744, 1784, 1817, 1817, 2045], [2047, 2047, 2086, 2086, 2187], [2189, 2189, 2210, 2210, 2348], [2350, 2381, 2411, 2411, 2456], [2551, 2551, 2603, 2603, 4739]], "test": "untested"}
{"id": "7dfGRX", "name": "Standard Noise", "author": "PartyGodTroy", "description": "Its what you get when an analogue TV doesn't have signal", "tags": ["noiseyttut"], "likes": 2, "viewed": 228, "published": 3, "date": "1616351605", "time_retrieved": "2024-07-30T19:31:34.863509", "image_code": "\n\nfloat rand(vec2 coord, float rand1, float rand2, float rand3)\n{\n    return fract(sin(dot(coord, vec2(rand1, rand2))) * rand3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = uv * 10.0;\n    \n    float value = rand(coord, 12.9898 ,78.233,43758.5453);\n\n    // Output to screen\n    fragColor = vec4(vec3(value), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 65, 65, 130], [133, 133, 190, 240, 439]], "test": "untested"}
{"id": "NsfGRf", "name": "Simplified Two Link IK Solver", "author": "oneshade", "description": "Major simplifications using trigonometric identities!\nNote that you don't get the luxury of these simplifications if you need the actual angles, e.g. for controlling an actual robot arm or performing joint interpolated motion ;)\nMouseable.", "tags": ["ik", "solver", "simplified", "inversekinematics", "twolink"], "likes": 7, "viewed": 207, "published": 3, "date": "1616342252", "time_retrieved": "2024-07-30T19:31:35.652401", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\n// Only two square roots!\n// config sets the handedness, -1 for left, 1 for right\nvec2 solveJoint(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba), l = sqrt(d);\n    float q = (d + ra * ra - rb * rb) / (2.0 * ra * l);\n    return a + (ba * q + vec2(-ba.y, ba.x) * sqrt(1.0 - q * q) * config) * ra / l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    // Link lengths\n    float ra = 3.0;\n    float rb = 1.5;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.0;\n    if (iMouse.z < 0.0 || ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = ra * vec2(cos(iTime), cos(iTime * 2.0) * sin(iTime));\n    }\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Joints\n    vec2 a = vec2(0.0);\n    vec2 c = mouse;\n    vec2 b = solveJoint(a, c, ra, rb, 1.0);\n\n    // Reachable area\n    draw(sdRing(uv, a, ra, rb), vec3(0.2, 0.8, 0.5));\n\n    // Draw links\n    draw(sdLine(uv, a, b, 0.1), vec3(0.0));\n    draw(sdLine(uv, b, c, 0.1), vec3(0.0));\n\n    // Draw joints\n    draw(sdDisc(uv, a, 0.15), vec3(0.5));\n    draw(sdDisc(uv, b, 0.15), vec3(0.5));\n    draw(sdDisc(uv, c, 0.15), vec3(0.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 127, 127, 239], [241, 241, 289, 289, 321], [323, 323, 383, 383, 424], [426, 508, 590, 590, 792], [794, 794, 849, 849, 1742]], "test": "untested"}
{"id": "NsXGRX", "name": "RandomCloudBrushes", "author": "kuvkar", "description": "Attempting to procedurally generate cloud brushes. Splatting n layers of carefully filtered fbm. ", "tags": ["2d", "clouds", "cloud", "brush"], "likes": 34, "viewed": 1173, "published": 3, "date": "1616341093", "time_retrieved": "2024-07-30T19:31:36.501131", "image_code": "#define PI 3.14159265358\n\nvec2 g_uv;\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat fbm(vec2 uv, int layers)\n{\n    float f = 0.0;\n    for (int i = 0; i < layers; ++i)\n    {\n        float fi = float(i + 1);\n        f += texture(iChannel0, uv * pow(2.0, fi)).r * pow(0.5, fi);\n    }\n    \n    return f;\n}\n\nfloat getCloudLayer(vec2 uv, vec2 seed)\n{\n    \n    float layer = fbm(uv * .15, 1);\n    \n    float circleMask = smoothstep(0.1, 0.4, length(uv * vec2(.9, 1.)));\n    float cloudMask = smoothstep(0.0, 0.76, fbm(uv * .07 + seed, 6));\n    float baseMask = max(0.0, cloudMask - circleMask*1.);\n    float edgeMask = smoothstep(0., .2, baseMask);    \n    float shape = smoothstep(0.0, 0.1, baseMask);\n    float tex = fbm(seed + uv * .1, 5) * shape;\n    tex = smoothstep(-0.4, 1., tex);\n    float tex2 = fbm(vec2(0.2, 0.2) + seed + uv*.05, 4) * shape;\n    \n    float dark = 1.0 - smoothstep(0.1, 0.7, fbm(seed + uv * .05, 7) * shape);\n    tex *= 0.5 + 0.5 * smoothstep(0.0, 0.7, tex2);\n    \n    dark += (uv.y * 5.0);\n    dark = smoothstep(-0.4, 1., dark);\n    tex *= dark;    \n    tex *= edgeMask;\n    return tex;\n}\n\nvec4 getCloudTexture(in vec2 uv, in vec2 seed)\n{\n    vec4 color = vec4(0.0);\n    vec2 offset = vec2(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        float x = rand(seed + float(i) * .12) - .5;\n        float y = rand(seed + float(i) * .13) - .5;\n        float cloud = getCloudLayer(uv + offset*.4, seed + offset);\n        color = mix(color, vec4(1.0), cloud);\n        offset += vec2(x, y)*.5;\n    }\n    float squareMask = smoothstep(0.4, 0.5, max(abs(uv.y), abs(uv.x)));\n    color -= squareMask;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; uv -= vec2(.5);    \n    g_uv = uv;\n    uv.y /= iResolution.x / iResolution.y;\n    uv *= 4.;\n    vec2 seed = vec2(floor(iTime), 0.0);\n    \n    fragColor = vec4(0.01, 0.045, 0.14, 0.0) * (g_uv.y + .9);\n    \n    vec2 muv = mod(uv, 1.0) - 0.5;\n    seed += floor(uv)*.0133;\n    vec4 cloudColor = getCloudTexture(muv, seed);\n    fragColor = mix(fragColor, cloudColor, cloudColor.a);\n        \n    vec2 absUv = abs(g_uv);\n    \n    fragColor *= smoothstep(0.5, 0.35, absUv.x);\n    fragColor *= smoothstep(0.5, 0.35, absUv.y);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}\n\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 59, 59, 131], [133, 133, 165, 165, 356], [358, 358, 399, 399, 1164], [1166, 1166, 1214, 1214, 1719], [1722, 1722, 1779, 1779, 2393]], "test": "untested"}
{"id": "fdf3zX", "name": "goku v2", "author": "jorge2017a1", "description": "goku v2", "tags": ["gokuv2"], "likes": 1, "viewed": 244, "published": 3, "date": "1616337028", "time_retrieved": "2024-07-30T19:31:37.336896", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n\n//Referencia :\n//IQ https://www.shadertoy.com/view/wdBXRW\n//https://www.shadertoy.com/view/tlGBW3 //Created by manu210404 in 2021-03-13 \n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\nconst int N1 =30;\nconst int N2 =29;\nconst int N3 =10;\n\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly11 POLY(11)\nfloat sdPoly29 POLY(29)\nfloat sdPoly16 POLY(16)\nfloat sdPoly36 POLY(36)\nfloat sdPoly15 POLY(15)\nfloat sdPoly17 POLY(17)\nfloat sdPoly07 POLY(7)\nfloat sdPoly13 POLY(13)\nfloat sdPoly12 POLY(12)\n\nvec2 pt0[11]=vec2[](vec2(.55,1.08),vec2(.7,1.16),vec2(.77,1.16),vec2(.86,1.1),vec2(.94,1.05),\nvec2(.94,1.02),vec2(.99,.73),vec2(1.02,.6),vec2(.75,.46),vec2(.44,.56),vec2(.55,1.08) );\n\n//pelo 1\nvec2 pt1[29]=vec2[]( vec2(.43,.95), vec2(.21,.86), vec2(.29,.83), vec2(.12,.66),\nvec2(.26,.66), vec2(.14,.48),  vec2(.11,.45), vec2(.07,.40), vec2(.04,.38),\nvec2(.01,.36), vec2(.06,.32), vec2(.12,.30), vec2(.18,.29), vec2(.21,.29), \nvec2(.25,.31), vec2(.31,.35), vec2(.29,.29),  vec2(.27,.17), vec2(.26,.14),\nvec2(.22,.05), vec2(.19,.00), vec2(.25,.00),  vec2(.31,.01), vec2(.37,.03),\nvec2(.44,.07), vec2(.49,.14), vec2(.53,.23), vec2(.55,.28), vec2(.43,.95) );\n\n//pelo 2\nvec2 pt2[16]=vec2[]( vec2(.61,.95), vec2(.83,.92), vec2(.76,.87), vec2(.91,.81),\nvec2(.80,.77), vec2(.97,.63), vec2(.93,.59), vec2(.89,.57), vec2(.84,.56),\nvec2(.98,.41), vec2(.90,.40),  vec2(.81,.40), vec2(.76,.41), vec2(.73,.42),\nvec2(.55,.28), vec2(.61,.95) );\n\n//pelo 3\nvec2 pt3[36]=vec2[]( vec2(.35,.71), vec2(.37,.73), vec2(.36,.66), vec2(.39,.68),\nvec2(.38,.58), vec2(.38,.55), vec2(.41,.50), vec2(.41,.54), vec2(.42,.59),\nvec2(.42,.62), vec2(.44,.67), vec2(.46,.57), vec2(.47,.53), vec2(.52,.47),\nvec2(.55,.43), vec2(.56,.47), vec2(.58,.52), vec2(.59,.54), vec2(.59,.58),\nvec2(.59,.65), vec2(.63,.61), vec2(.64,.58), vec2(.66,.56), vec2(.67,.51),\nvec2(.67,.52), vec2(.68,.54), vec2(.68,.57), vec2(.68,.61), vec2(.66,.70),\nvec2(.69,.67), vec2(.68,.73), vec2(.70,.73), vec2(.73,.49), vec2(.53,.38),\nvec2(.32,.46), vec2(.35,.71) );\n\n// ojo \nvec2 pt4[16]=vec2[]( vec2(.41,.81), vec2(.40,.78),  vec2(.39,.72), vec2(.40,.69),\nvec2(.41,.66), vec2(.43,.65), vec2(.45,.65), vec2(.46,.66), vec2(.47,.68),\nvec2(.48,.70), vec2(.49,.73), vec2(.49,.80), vec2(.47,.81), vec2(.45,.82),\nvec2(.42,.81), vec2(.41,.81) );\n\n/// ojo\nvec2 pt5[17]=vec2[]( vec2(.57,.81), vec2(.56,.78), vec2(.56,.75), vec2(.56,.71),\nvec2(.57,.69), vec2(.59,.66), vec2(.61,.65), vec2(.62,.65), vec2(.64,.66),\nvec2(.65,.68), vec2(.65,.70), vec2(.65,.73), vec2(.65,.77), vec2(.64,.81),\nvec2(.60,.81), vec2(.59,.82), vec2(.57,.81) );\n\n//nariz\nvec2 pt6[7]=vec2[]( vec2(.52,.85), vec2(.51,.84), vec2(.52,.81), vec2(.52,.83),\nvec2(.52,.84), vec2(.52,.85), vec2(.52,.85) );\n\n// ceja 1\nvec2 pt7[15]=vec2[]( vec2(.56,.60), vec2(.58,.55), vec2(.61,.54), vec2(.62,.54),\nvec2(.63,.54), vec2(.65,.56), vec2(.66,.57), vec2(.66,.58), vec2(.65,.60),\nvec2(.63,.58), vec2(.62,.57), vec2(.60,.57), vec2(.58,.57), vec2(.57,.59),\nvec2(.56,.60) );\n\n// ceja 2\nvec2 pt8[16]=vec2[]( vec2(.39,.58), vec2(.41,.55), vec2(.43,.54), vec2(.44,.53),\nvec2(.45,.54), vec2(.47,.55), vec2(.48,.57), vec2(.49,.59), vec2(.48,.60),\nvec2(.47,.57), vec2(.45,.56), vec2(.44,.56), vec2(.43,.56), vec2(.42,.57),\nvec2(.41,.60), vec2(.39,.58)  );\n\n//boca\nvec2 pt9[13]=vec2[]( vec2(.48,.87), vec2(.51,.88), vec2(.53,.88), vec2(.54,.87),\nvec2(.56,.87), vec2(.57,.87), vec2(.57,.90), vec2(.55,.93), vec2(.52,.93),\nvec2(.49,.93), vec2(.48,.90), vec2(.48,.88), vec2(.48,.87) );\n\nvec2 pt10[12]=vec2[]( vec2(.38,.88), vec2(.36,.88), vec2(.34,.86), vec2(.31,.82),\nvec2(.31,.80), vec2(.31,.75),  vec2(.31,.71), vec2(.31,.70), vec2(.32,.69),\nvec2(.33,.70), vec2(.35,.72), vec2(.38,.88)\n);\n\nvec2 pt11[13]=vec2[]( vec2(.67,.88), vec2(.69,.88), vec2(.72,.86), vec2(.74,.83),\nvec2(.74,.82), vec2(.75,.78), vec2(.75,.75), vec2(.75,.72), vec2(.75,.70),\nvec2(.73,.70), vec2(.72,.70), vec2(.70,.73), vec2(.67,.88)\n);\n\n\nvec3 RostroGoku(in vec2 pp, vec3 col) \n{\n  vec2 p= rotatev2( pp, radians(180.0)); \n  float sd0 = sdPoly11(p-vec2(0.0,-0.2), pt0);\n  //pelo 1\n  float sd1 = sdPoly29(p-vec2(0.22,0.0), pt1);\n  //pelo 2\n  float sd2 = sdPoly16(p-vec2(0.20,0.0), pt2);\n  //pelo centro\n  float sd3 = sdPoly36(p*0.7-vec2(-0.02,-0.21), pt3);\n  //ojo \n  float sd4 = sdPoly16(p-vec2(0.15,-0.02), pt4);\n  float sd5 = sdPoly17(p-vec2(0.2,-0.02), pt5);\n  //nariz\n  float sd6 = sdPoly07(p-vec2(0.18,-0.03), pt6);\n  //ceja 1 y 2\n  float sd7 = sdPoly15(p-vec2(0.0,0.0), pt7);\n  float sd8 = sdPoly16(p-vec2(0.35,0.0), pt8);\n  //boca\n  float sd9 = sdPoly13(p-vec2(0.19,0.0), pt9);\n  //orejas\n  float sd10 = sdPoly12(p-vec2(0.16,-0.04), pt10);\n  float sd11 = sdPoly13(p-vec2(0.26,-0.04), pt11);\n  float dcornea1= sdCircle(p-vec2(0.6,0.75), 0.02 );\n  float dcornea2= sdCircle(p-vec2(0.8,0.75), 0.02 );\n  //---------------\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd1,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd2,0.0));\n  //rostro\n  col = mix(col,vec3(0.99, 0.73,0.70)*1.2,S(sd0,0.0));\n  //ojos\n  col = mix(col,vec3(1.0)*1.2,S(sd4,0.0));\n  col = mix(col,vec3(1.0)*1.2,S(sd5,0.0));\n  //pelo centro\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd3,0.0));\n  //nariz\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd6,0.0));\n  //ceja\n  col = mix(col,vec3(0.0)*1.2,S(sd7,0.0));\n  col = mix(col,vec3(0.0)*1.2,S(sd8,0.0));\n  // boca\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd9,0.0));\n  //oreja\n  col = mix(col,vec3(0.9, 0.75,0.71)*1.2,S(sd10,0.0));\n  col = mix(col,vec3(0.9, 0.75,0.71)*1.2,S(sd11,0.0));\n  //cornea\n  col = mix(col,vec3(0.0)*1.2,S(dcornea1,0.0));\n  col = mix(col,vec3(0.0)*1.2,S(dcornea2,0.0));\n  \n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv*0.75+vec2(-0.5,-0.5);\n    \n   \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+uv.yyx);\n    \n    \n     col= RostroGoku( p,col);\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 546, 546, 568], [569, 569, 602, 602, 624], [625, 625, 658, 658, 679], [681, 719, 755, 755, 800], [801, 814, 851, 851, 931], [933, 933, 968, 968, 996], [997, 997, 1031, 1031, 1128], [1129, 1153, 1178, 1178, 1197], [1198, 1198, 1238, 1238, 1270], [5345, 5345, 5385, 5385, 7029], [7030, 7030, 7087, 7087, 7391]], "test": "untested"}
{"id": "fdfGzX", "name": "Fractal 40_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 378, "published": 3, "date": "1616336421", "time_retrieved": "2024-07-30T19:31:38.167675", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=.2,l;\n        ++i<80.;\n        O+=abs(cos(vec4(4,3,24,1)+log(s)*.8))*s*1e-4/i\n    )\n    {\n        p=g*d-vec3(.1,.2,1);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        s=2.;\n        l=dot(p,p);\n        p=abs(abs(p)-.7)-.5;\n        p.x<p.y?p=p.yxz:p;\n        p.y<p.z?p=p.xzy:p;\n        for(int i=0;i++<8;){\n            s*=e=2./clamp(dot(p,p),.004+tan(10.*sin(iTime*.2))*.002,1.35);\n            p=abs(p)*e-vec2(.5*l,12.).xxy;\n        }\n        g+=e=length(p-clamp(p,-1.,1.))/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.1,.6,.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 734]], "test": "untested"}
{"id": "fsX3zX", "name": "textured noise segments", "author": "morisil", "description": "quick experiment", "tags": ["noise", "texture"], "likes": 3, "viewed": 324, "published": 3, "date": "1616336259", "time_retrieved": "2024-07-30T19:31:38.933627", "image_code": "const float MAX_NOISE_SCALE = 20.;\nconst float NOISE_SCALING_SPEED = .1;\nconst float NOISE_SPEED = 1.;\nconst float SEGMENT_COUNT = float(3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 noiseSt = st * sin(iTime * NOISE_SCALING_SPEED) * MAX_NOISE_SCALE;\n    float noise = (Perlin3D(vec3(noiseSt, iTime * NOISE_SPEED)) + 1.) / 2.;\n    float segment = mod(noise * SEGMENT_COUNT, 1.);\n    int segmentIndex = int(noise * SEGMENT_COUNT);\n    vec3 color;\n    switch (segmentIndex) {\n        case 0:\n            color = mix(texture(iChannel0, uv), texture(iChannel1, uv), segment).rgb;\n        break;\n        case 1:\n            color = mix(texture(iChannel1, uv), texture(iChannel2, uv), segment).rgb;\n        break;\n        case 2:\n            color = mix(texture(iChannel2, uv), texture(iChannel3, uv), segment).rgb;\n        break;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 199, 199, 1018]], "test": "untested"}
{"id": "sdl3z2", "name": "illustration of precision loss", "author": "FabriceNeyret2", "description": "Many people use the ultra deprecated mod289 trick to generate random gradients for Perlin noise.\non some shader my OpenGL got the left half screen very wrong: this was only the iceberg tip of the ultra-loss of precision along calculus. See comments.", "tags": ["procedural", "2d", "perlin"], "likes": 9, "viewed": 390, "published": 3, "date": "1616320958", "time_retrieved": "2024-07-30T19:31:39.712544", "image_code": "#if 0                                    // integer version \n\n  #define hash(v)  float( int (v) % 289 )\n  #define hashV(v) vec2( ivec2(v) % 289 )\n\n#else                                    // slight difference in the float version\n\n  #define hash(v)  mod(  floor(v), 289.)\n  #define hashV(v) hash(v)\n\n#endif\n\n// Added wrongness on OpenGL, not showing on Windows where \n// signed mod or % differs from OpenGL + silent abs() are added here and there.\n// This cause x to grow up to 1e9 on OpenGL for uv.x<0 instead of \"just\" 1e5 on Windows.\n//  fract on ~ 1e5 only have 1-2 bits remaining.\n// past 1e7, fract = 0 : there are no longer any remaining bits.\n// But here even on Windows it is a problem:\n// Note the vertical bands in red: indeed, U.y influence was in the lowest bits.\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U =  10.* ( 2.*u - R ) / R.y,\n\n         p = hashV(U);\n    float x = (34. * p.x + 1.) * hash(p.x) + p.y;\n    x = (34. * x + 1.) * hash(x);\n    x /= 41.;\n    \n    O = U.y > 0. \n          ?  vec4( fract(x) )           // top: random value\n          : vec4(x/5e5,0,0,1);          // red: show x content\n    \n    if ( U.y < -8. ) \n        O = vec4( fract(1e7*u.x/R.x) ); // bottom: show fract( 0 ... 1e7 )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 819, 819, 1260]], "test": "untested"}
{"id": "7dlGzB", "name": "lost in the storm", "author": "mdb", "description": "a traveller lost in a sand storm", "tags": ["global", "volumetric", "fog", "ilumination"], "likes": 9, "viewed": 450, "published": 3, "date": "1616319001", "time_retrieved": "2024-07-30T19:31:40.487472", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = 1.0-exp(-9.0*col); \n    col = pow(col, vec3(0.7));\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAXDEPTH 4\n#define PI 3.14159265359\n#define MAXSTEP 200\n#define MAXDIST 10.0\n#define MINDIST 0.003\n#define FOGDENSITY 3.0\nconst vec3 camPos = vec3(0.0, 0.3, -0.4);\n//const vec3 camPos = vec3(0.0, 0.7, -0.06); // up view\nconst vec3 target = vec3(0.0, 0.2, 0.0);\nstruct Mat{vec3 c, e;}; //color, emission\n\n// pseudo random numbers////////////////////////////////////////////////\nfloat seed = 0.0;\n\nvoid initSeed(vec2 uv){\n    seed = mod(fract(sin(uv.x*875.87+12.8+iTime)*776.978)*2378.0 + fract(sin(uv.y*594.87+57.75)*689.655)*8938.0\n            + fract(sin(iTime*798.43+89.24)*875.365)*5685.0 ,10000.0);\n}\nvoid next(){seed=mod(seed*348.12+77.0, 10000.0);}\nfloat random(){\n    next();\n    return seed/10000.0;\n}\n/////////////////////////////////////////////////////////////////////////\n\nfloat sdPerso(vec3 pos){\n    float d = 1e5;\n    vec3 p;\n    //stick\n    p = pos - vec3(0.0, 0.2, 0.0);\n    d = min(d, sdCylinder(p, vec2(0.01, 0.2))-0.003);\n    \n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdCappedTorus(p, vec2(0.866025,-0.5), 0.04, 0.01));\n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    p = pos-vec3(-0.11, 0.35, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    \n    float teta = 1.0;\n    p = mat3x3(cos(teta), 0.0, sin(teta),\n                  0.0   , 1.0,   0.0,\n              -sin(teta), 0.0, cos(teta))*(pos - vec3(-0.11, 0.25, 0.0));\n    d = min(d, sdBoundingBox(p, vec3(0.06, 0.08, 0.06), 0.005 )); \n    //body\n    \n    //d = min(d, sdCappedCone(pos, vec3(0.05, 0.16, 0.0), vec3(0.13, 0.03, 0.0), 0.05, 0.12));\n    p = pos;\n    p.z = abs(p.z);\n    d = min(d, sdCapsule(p, vec3(0.1, 0.0, 0.02), vec3(0.25, 0.1, 0.05), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.25, 0.1, 0.05), vec3(0.31, 0.01, 0.03), 0.03 ));\n    d = min(d, sdCapsule(p, vec3(0.07, 0.15, 0.0), vec3(0.1, 0.0, 0.0), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.06, 0.1, 0.08), vec3(0.06, 0.18, 0.08), 0.02 ));\n    //head\n    p = pos-vec3(0.07, 0.25, 0.0);\n    d = min(d, sdSphere(p, 0.05));\n    p -= vec3(0.0, 0.08, 0.0);\n    d = min(d, sdCone(p, vec2(0.1, 0.04), 0.05 ));  \n    \n    return d;\n}\n\n\nfloat DE(vec3 pos, out Mat obj){\n    float dist = 1e6;\n    float t;\n    \n    //working light\n    //t = sdSphere(pos - vec3(-2.0, 2.0, -2.0), 1.8);\n    //if (t<dist){dist = t; obj = Mat(vec3(1.0), vec3(1.0));}\n    \n    //ground\n    t = sdPlane(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //backbround sphere\n    t = -sdSphere(pos, 3.0);\n    if (t<dist){dist = t; obj = Mat(vec3(0.0), vec3(0.0));}\n    \n    //perso\n    t = sdPerso(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //lights\n    t = sdCapsule(pos, vec3(-0.11, 0.22, 0.0), vec3(-0.11, 0.28, 0.0), 0.05);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(40.0, 13.0, 13.0));}\n    vec3 p = pos - vec3(0.105, 0.25, -0.028);\n    p.z = abs(p.z);\n    t = sdSphere(p, 0.01);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(10.0));}\n    \n    return dist;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 normal, out Mat obj){\n    normal = rd;\n    obj = Mat(vec3(0.9, 0.1, 0.1), vec3(0.0));\n    float t = 0.0;\n    float tfog = 0.0;\n    for(int i = 0; i < MAXSTEP; i++){\n        vec3 p = ro + t * rd;\n        float delta = DE(p, obj);\n        t += delta;\n        if(t > MAXDIST)return -1.0;\n        if(abs(delta) < MINDIST){//end\n            float prob = 1.0-exp(-t*FOGDENSITY);\n            if (random()<prob){\n                obj = Mat(vec3(0.9, 0.5, 0.1), vec3(0.0));\n                t*=random();\n            }else{\n                float off=0.001;\n                Mat m;\n                normal = normalize(vec3(DE(p+vec3(off,0,0), m)-DE(p-vec3(off,0,0), m),\n                                    DE(p+vec3(0,off,0), m)-DE(p-vec3(0,off,0), m),\n                                    DE(p+vec3(0,0,off), m)-DE(p-vec3(0,0,off), m))); \n            }\n            break;\n        }\n        \n    }\n    return t;\n}\n\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z); \n    if (dot(n, v)<0.0);\n        return -v;\n    return v;\n}\n\nvec3 march(vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        vec3 n;\n        float t = intersect(ro, rd, n, obj);\n        if(t<=0.0)break;\n        \n\t\tro = ro + t * rd + n * MINDIST * 3.0;\n\t\trd = newDir(n);\n        \n\t\tcol += mask * obj.e;\n\t\tmask *= obj.c;\n        \n        if (dot(mask, mask)<0.00001)break;\n\t\t\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initSeed(uv);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec2 off = vec2(random(),random()) / iResolution.y;\n    vec3 rd = normalize(dir0 + right*(uv.x+off.x) + up*(uv.y+off.y));\n        \n    vec3 col = march(camPos, rd);\n    \n    \n    \n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(iFrame + 1);\n    col = col * weight + last * (1.0-weight);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://www.shadertoy.com/view/Xds3zN\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\n//smouth min to blend material\nfloat smin( float a, float b, float k )\n{\n    if (k <=0.)return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 311]], "test": "untested"}
{"id": "7ssGRj", "name": "GridBlend3", "author": "Del", "description": "Better grid blending, averaging cell IDs - click mouse for a different zoom blend", "tags": ["grid", "blend", "hex", "tri"], "likes": 9, "viewed": 305, "published": 3, "date": "1616288023", "time_retrieved": "2024-07-30T19:31:41.252427", "image_code": "// more grid blending! (hex + tri grid)\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= rot(iTime*0.1);\n\n    // dirty grid blending attempt #3\n    vec2 id;\n    vec2 id2;\n    float zoom = 8.0;\n    zoom += sin(t)*2.0;\n    \n    float zoom2 = zoom;\n    if (iMouse.z>0.5)\n        zoom2*=0.5;\n    \n    vec4 h = HexGrid(uv*zoom2, id);\n    vec4 h2 = TriGrid(uv*zoom, id2);\n    h.x = smin(h.x,h2.x,0.215); // blend distance\n    id = mix(id,id2,0.5); // blend IDs\n    vec3 bordercol = vec3(0.9,0.9,0.7);\n    vec3 shapecol = vec3(0.41,0.32,0.15);//vec3(0.25,0.32,0.15);\n    // just do a simple patterned shape tint based on (blended) cell IDs\n    float patternVal = 7.75; // 33.5\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    //bordercol *= 0.75+sin(iTime+length(uv*4.0))*0.25;\n    //bordercol = shapecol*1.5;\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv); // white edge\n\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 77, 77, 585], [587, 800, 836, 836, 1439], [1441, 1441, 1483, 1483, 1524], [1526, 1526, 1567, 1567, 1656], [1658, 1658, 1679, 1679, 1747], [1749, 1749, 1806, 1806, 3018]], "test": "untested"}
{"id": "7sX3z2", "name": "GridX4", "author": "Del", "description": "4 simple drop in grid distance functions - click a grid to show it as full screen\nHEX original  - https://www.shadertoy.com/view/lldfWH\nTRI original - https://www.shadertoy.com/view/4dKXR3\nOCT original - https://www.shadertoy.com/view/3tGBWV\n", "tags": ["grid", "simplex", "square", "distance", "edge", "hex", "tri", "octagon"], "likes": 9, "viewed": 333, "published": 3, "date": "1616260230", "time_retrieved": "2024-07-30T19:31:42.016385", "image_code": "// Simple Hex, Tri, Square and Ocatagonal grids - (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 20/03/2021\n\n// All 4 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\n// Shanes ocatagonal-diamond grid equiv - https://www.shadertoy.com/view/3tGBWV \nvec4 OcatagonalGrid(vec2 uv, out vec2 id)\n{\n    vec2 guv;\n    vec2 p = uv - .5;\n    id = floor(p) + .5;\n    p -= id;\n    float d = abs(p.x) + abs(p.y) - (1. - sqrt(2.)/2.);\n    if(d<.0)\n    {\n        // inside a diamond\n        guv = fract(p-0.5)-0.5;\n        id += .5;\n    }\n    else\n    {\n        // inside an octagon\n        guv = fract(p)-0.5;\n        p = uv;\n        id = floor(p) + .5;\n        p -= id;\n        d = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n    }\n    return vec4(abs(d), length(guv), guv);\n}\n\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 4xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(float xx)\n{\n    float gridtype = 0.5;\n    float mx = ((iMouse.x-.5*iResolution.x) / iResolution.x)+0.5;\n    if (iMouse.z>0.5)\n        xx=mx;\n    if (xx>0.75)\n        gridtype=3.5;\n    else if (xx>0.5)\n        gridtype=2.5;\n    else if (xx>0.25)\n        gridtype = 1.5;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float zoom = 8.0;\n    if (iMouse.z>0.5)\n        zoom += sin(t);\n    float gridtype = SelectGrid(xx);\n    if (gridtype>= 3.0)\n        h = OcatagonalGrid(uv*zoom, id);\n    else if (gridtype>= 2.0)\n        h = SquareGrid(uv*zoom, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*zoom, id);\n    else\n        h = TriGrid(uv*zoom, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.25,0.32,0.15);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        if (uv.y < 0.0)\n            finalcol = vec3(h.x,h.x,h.x); // just show cell edge distances in bottom half of screen\n        // add some red divider lines\n        float dd = max(max( step(abs(xx-0.25),0.0025), step(abs(xx-0.5),0.0025)),step(abs(xx-0.75),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 359, 395, 395, 903], [905, 1118, 1154, 1154, 1712], [1714, 1742, 1781, 1781, 1980], [1982, 2063, 2106, 2106, 2601], [2604, 2604, 2646, 2646, 2687], [2689, 2749, 2777, 2777, 3057], [3059, 3059, 3116, 3116, 5172]], "test": "untested"}
{"id": "7dX3R2", "name": "boilerplate stuff", "author": "elenzil", "description": "forkable common setup I tend to want for every shader I start.", "tags": ["boilerplate"], "likes": 3, "viewed": 298, "published": 3, "date": "1616258032", "time_retrieved": "2024-07-30T19:31:42.791313", "image_code": "\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.78);\n    setupTime(iTime);\n\n    // pixel epsilon for smoothstep\n    float smoothEps = gWorldFromScreenFac * 2.5;\n    \n    vec4 mouseData = texelFetch(iChannel0, ivec2(0), 0);\n\n    \n    // draw something\n    \n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(mouseData.xy);\n    p -= m;\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.0, 0.8, 0.5);\n    const vec3 colFG4 = vec3(0.6, 0.5, 0.6);\n\n    float angPt = atan(p.y, p.x);\n    float angMs = 0.0; // atan(m.y, m.x);\n    float rad = 1.0;\n    rad += 0.02 * sin((angPt - angMs * 1.0) *  7.0 - gTime);\n    rad += 0.02 * sin((angPt - angMs * 1.0) * 14.0 + gTime);\n    float len = length(p);\n    \n    vec3 col = colBG;\n    \n    vec3 colBand = mix(colFG2, colFG3, 0.5 + 0.5 * sin(angPt *  5.0 - gTime * 0.3 + rad * 33.0 + 0.2 * sin(len * 200.0 - gTime * 4.0)));\n    \n    // dashed lines w/ dashing size in screenspace\n    vec3 colLine = mix(colFG1, colFG4, smoothstep(-0.5, 0.5, sin((angPt - angMs) *  0.25 * gScreenFromWorldFac)));\n    \n    float bandRad = mix(0.0, 0.2, sin(gTime * 0.3) * 0.5 + 0.5);\n    \n    col = mix(col, colBand, 0.1 * smoothstep(smoothEps, -smoothEps, abs(rad           - len) - bandRad));\n    col = mix(col, colLine,       smoothstep(smoothEps, -smoothEps, abs(rad + bandRad - len)          ));\n    col = mix(col, colLine,       smoothstep(smoothEps, -smoothEps, abs(rad - bandRad - len)          ));\n    \n    RGBA = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return abs(sdDisk(p, r));\n}\n\nfloat sdAnnulus(in vec2 p, in float r1, in float r2) {\n    return abs(sdDisk(p, (r1 + r2) / 2.0)) - (r2 - r1) / 2.0;\n}\n\n", "buffer_a_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ != ivec2(0)) {\n        RGBA = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0.0, 0.0, -1e9, 0.0);\n    }\n    \n    // data.xy = use this as mouse point, other buffers.\n    // data.zw = actual last mouse position, if mouse was down. else -1e9.\n \n    vec4 data = texelFetch(iChannel0, IJ, 0);\n     \n     \n    bool prevMouseDown = data.z   > -1e8;\n    bool currMouseDown = iMouse.z > -1.0;\n     \n    vec2 prevMp = prevMouseDown ? data.zw : iMouse.xy;\n    data.xy += iMouse.xy - prevMp;\n    data.xy = clamp(data.xy, iResolution.xy * -0.25, iResolution.xy * 1.25);\n    data.zw = currMouseDown ? iMouse.xy : vec2(-1e9);\n     \n    \n    RGBA = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 46, 46, 1622]], "test": "untested"}
{"id": "ssf3R2", "name": "Monochrome gas giant", "author": "mrange", "description": "License CC0: Monochrome gas giant\nI had the idea of creating a monochrome flat gas giant\nIt didn't come out as intended but I liked the result anyway\n", "tags": ["bwraysphere"], "likes": 16, "viewed": 438, "published": 3, "date": "1616254447", "time_retrieved": "2024-07-30T19:31:43.565243", "image_code": "// License CC0: Monochrome gas giant\n//  I had the idea of creating a monochrome flat gas giant\n//  It didn't come out as intended but I liked the result anyway\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(a)         (0.5+0.5*sin(a))\n#define L2(x)           dot(x, x)\n#define SCA(a)          vec2(sin(a), cos(a))\n\nconst vec3  std_gamma = vec3(2.2);\nconst vec2  miss      = vec2(1E6);\nconst vec4  sphere    = vec4(vec3(0.0), 0.4);\nconst vec4  plane     = vec4(normalize(vec3(0.0, 1.0, 0.0)), 0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 ce  = sph.xyz;\n  float ra = sph.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return miss; // no intersection\n  h = sqrt(h);\n  return vec2( -b-h, -b+h );\n}\n\n// IQ's ray plane  intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec3 toPolar(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n  \n}\n\nvec2 hash2(vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n\n  for (int x = 0; x < 2; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n\n  return f/s;\n}\n\nfloat warp(vec2 p, float e, out vec2 v, out vec2 w) {\n  vec2 vx = vec2(0.0, 0.5)*e;\n  vec2 vy = vec2(3.2, 1.3)*e;\n\n  vec2 wx = vec2(1.7, 9.2)*e;\n  vec2 wy = vec2(8.3, 2.8)*e;\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n\n  v = vec2(fbm(p + vx), fbm(p + vy));\n  \n  w = vec2(fbm(p + -3.0*v + wx), fbm(p + 3.0*v + wy));\n  \n  return fbm(p + vec2(2.25, 1.25)*w);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  vec2 rsi = raySphere(ro, rd, sphere);\n  float rpi = rayPlane(ro, rd, plane);\n  \n  vec3 col = vec3(0.0);\n  if (rsi != miss) {\n    vec3 pi = ro + rd*rsi.x;\n    vec3 ni = normalize(pi - sphere.xyz);\n    float d = dot(-rd, ni);\n    d -= 0.;\n    float oi = smoothstep(0.0, 0.1, d);\n    float ii = 1.0-smoothstep(0.1, 0.15, d);\n    float f = oi*ii;\n\n    float rings = 1.0;\n    for (int i = 0; i < 4; ++i) {\n      rings *= sin(5.0*pi.y*sqrt(float(i+3)));\n    }\n\n    rings = tanh_approx((rings)*1.5);\n    float yf = pow(abs(pi.y)/sphere.w, 3.0);\n    rings *= mix(1.0, 0.0, yf);\n    vec3 ppi = toPolar(pi.xzy);\n\n    vec2 v;\n    vec2 w;\n    float h = warp((ppi.zy+vec2(-0.033*TIME, 0.1))*2.0*vec2(1.0, 6.0), rings, v, w);\n\n    h = mix(h, 1.0, yf);\n\n    col += vec3(1.0)*mix(1.0, h*step(0.1, d), 1.0-f);\n    col += rings*step(0.1, d);\n  }\n  \n  if (rpi >= 0.0 && rpi < rsi.x) {\n    vec3 pi = ro + rd*rpi;\n    vec3 npi = ro + nrd*rpi;\n    float aa = 2.0*length(npi-pi);\n    vec2 pp = pi.xz;\n    float r = length(pp);\n    float d = circle(pp, 0.65);\n    d = abs(d) - 0.06;\n\n    float rings = 1.0;\n    for (int i = 0; i < 3; ++i) {\n      rings *= sin(100.0*r*sqrt(float(i+3)));\n    }\n    rings = tanh_approx((rings)*3.0);\n    \n    col += mix(0.0, 1.0, smoothstep(-aa, aa, -d))*rings;\n  }\n  \n//  col = 1.0- col;\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec3 ro   = 0.75*vec3(0.0, 1.0, -2.0);\n  vec3 la   = vec3(0.0);\n  vec3 up = normalize(vec3(0.25,1.0,0.0));\n  vec3 ww = normalize(normalize(la - ro));\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssf3R2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[699, 699, 727, 747, 823], [825, 857, 901, 901, 1139], [1141, 1173, 1215, 1215, 1262], [1264, 1264, 1295, 1295, 1321], [1323, 1323, 1345, 1345, 1457], [1459, 1459, 1479, 1479, 1615], [1617, 1617, 1638, 1638, 1760], [1762, 1762, 1781, 1781, 2036], [2038, 2038, 2091, 2091, 2459], [2461, 2461, 2517, 2517, 4094], [4096, 4123, 4159, 4159, 4392], [4394, 4394, 4423, 4423, 4736], [4738, 4738, 4793, 4793, 4951]], "test": "error"}
{"id": "fsfGWM", "name": "Star Rider", "author": "ahmaderfani12", "description": "Star Rider\ncheck the unity project using it:\nhttps://youtu.be/dvlMRb8_ugw\nhttps://github.com/ahmaderfani12/StarRider-shader", "tags": ["2d", "light", "star", "stars"], "likes": 11, "viewed": 1001, "published": 3, "date": "1616243170", "time_retrieved": "2024-07-30T19:31:44.330198", "image_code": "float remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec3 stars(vec2 uv, float radious , vec3 shineColor , float power,float isVisible){\n    vec3 color=vec3(0.0);\n      if(isVisible>=0.65){\n      \n    float dis = distance(uv,vec2(0.5));\n    float circle  = smoothstep(radious,radious+0.01,dis);\n    float light = distance(uv-vec2(0.5),normalize(uv-vec2(0.5))*radious)*step(radious,circle)*3.0;\n\tlight =(1. - clamp(light,0.0,1.0));\n    \n     color = mix(vec3(1.),(shineColor*light),vec3(circle))*power;\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    //adjust uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *=  iResolution.x/iResolution.y;\n     \n     vec3 starsCol = vec3(0.0);\n                \n     //scale uv\n     uv *=vec2(30.);\n     //move star rows\n    uv.x += iTime*(random(floor(uv.y))+0.1)*20.;\n    vec2 ipos = floor(uv);  \n    vec2 fpos = fract(uv);\n     \n    float cellSize = random(ipos);\n    cellSize=remap(cellSize,0.0,1.0,0.0,0.3);\n    \n    starsCol=stars(fpos,cellSize,vec3(0.190,0.283,0.770),1.,random(ipos*100.));\n    \n \n    \n    fragColor = vec4(starsCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 104], [106, 106, 133, 133, 165], [167, 167, 194, 194, 268], [270, 270, 353, 353, 749], [753, 753, 810, 828, 1351]], "test": "untested"}
{"id": "7dfGRj", "name": "Simple Julia Set V2", "author": "tungster24", "description": "an even shorter version of my small julia set.", "tags": ["fractal", "julia", "mandelbrot", "juliaset"], "likes": 1, "viewed": 243, "published": 3, "date": "1616228667", "time_retrieved": "2024-07-30T19:31:45.099142", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    int iter = 0;\n    while (iter < 200) {\n        float y1 = (2.0 * ((p.x-0.5)*4.0) * ((p.y-0.5)*2.25)) + ((p.y-0.5)*2.25);\n        float x1 = (((p.x-0.5)*4.0) * ((p.x-0.5)*4.0)) - (((p.y-0.5)*2.25) * ((p.y-0.5)*2.25)) + ((p.x-0.5)*4.0);\n        p.x = (x1 / 4.0)+0.5;\n        p.y = (y1 / 2.25)+0.5;\n        iter += 1;\n        };\n        \n    float r = 0.0; \n    if (((p.x-0.5)*4.0) * ((p.x-0.5)*4.0) + ((p.y-0.5)*2.25) * ((p.y-0.5)*2.25) <= 4.0) {r = 1.0;} else {r = 0.0;};\n    fragColor = vec4(r,r,r,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 606]], "test": "untested"}
{"id": "NsXGR2", "name": "flores - jorge", "author": "jorge2017a1", "description": "flores - jorge", "tags": ["jorgeflores"], "likes": 5, "viewed": 259, "published": 3, "date": "1616207689", "time_retrieved": "2024-07-30T19:31:45.889030", "image_code": "//por jorge2017a1-\n/// jorge flores p.\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec2 flores1(vec3 p, float numItem)\n{\n    vec3 pp=p;\n    vec3 p2=p;\n    vec2 res=vec2(9999.9,-1.0);\n    \n    p.zy *= genRotMat(radians(45.0));\n    p2.zy *= rot2D(radians(90.0));\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb3= sdSphere( p-vec3(0.0,0.0,-4.0), 3.0 );\n    float sdc1= sdCylinderXY( rep2-vec3(5.0,0.0,-4.0), vec2(1.7,0.5) );\n    float sdc2= sdCylinderXY( rep2-vec3(5.0,0.0,-4.0), vec2(1.9,0.4) );\n    float sdRama= sdCylinderXY( p2-vec3(0.0,-4.0,4.0), vec2(0.5,8.0) );\n     res = opU2( vec2(sdc1,1.0),vec2( sdb3,4.0) );\n     res = opU2( res, vec2(sdc2,0.0) );\n     res = opU2( res, vec2(sdRama,3.0) );\n    return  res;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    vec3 p2=p;\n    \n    p.x= opRep1D( p.x, 20. );\n    p.z= opRep1D( p.z, 50. );\n    \n    \n    p2.x= opRep1D( p2.x-10.0, 20. );\n    p2.z= opRep1D( p2.z-25.0, 50. );\n    \n    \n    vec2 c1= flores1( p-vec3(0.0,10.0,0.0), 9.0);\n    vec2 c2= flores1( p2-vec3(0.0,10.0,0.0), 9.0);\n    res =opU3(res, vec3(c1.x,c1.y,MATERIAL_NO)); \n    res =opU3(res, vec3(c2.x,c2.y,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n     \n    if (id_material==5.0)\n    {\n        \n        float reflectance = 1.0+dot(mObj.rd,mObj.normal);\n       vec3 tex = vec3(.0);\n\t\ttex += texture(iChannel1,p.yz*0.0163).xyz*abs(mObj.normal.x);\n\t\ttex += texture(iChannel1,p.zx*0.0163).xyz*abs(mObj.normal.y);\n\t\ttex += texture(iChannel1,p.xy*0.163).xyz*abs(mObj.normal.z);\n\t\ttex *= vec3(.5,.5,.7);\n\t\t//color = tex*diffuse_acc+background(p,r)*(.1+or*reflectance)*1.8;\n        vec3 col =vec3(0.0,1.0,0.0);\n        col*= tex*(.1+reflectance)*2.8;\n        // col*= tex*4.0;\n        return col;\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n\n\n    \n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 5.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n     vec3 ro=vec3(1.0,7.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 503, 503, 524], [526, 526, 565, 565, 660], [661, 661, 700, 700, 795], [796, 796, 835, 835, 930], [933, 971, 1007, 1007, 1052], [1053, 1118, 1152, 1152, 1250], [1251, 1251, 1285, 1285, 1377], [1378, 1378, 1412, 1412, 1504], [1546, 1546, 1567, 1567, 1636], [1668, 1668, 1694, 1694, 1748], [1750, 1750, 1784, 1784, 1957], [1959, 1959, 1996, 1996, 2608], [2609, 2649, 2674, 2674, 3328], [3332, 3332, 3397, 3397, 3981], [3983, 4034, 4058, 4058, 4246], [4252, 4252, 4285, 4285, 5077], [5078, 5132, 5168, 5168, 5402], [5405, 5439, 5519, 5519, 5796], [5839, 5890, 5937, 5937, 6531], [6585, 6585, 6678, 6678, 6953], [6957, 6957, 6984, 6984, 7094], [7105, 7154, 7211, 7211, 8477]], "test": "untested"}
{"id": "fsf3Rj", "name": "SkewTriGrid", "author": "Del", "description": "Triangle grid using the skewed, split rectangle method - outputs border distance, centre distance, cell UVs and cell IDs.\nIs it possible to make this shorter / quicker ?", "tags": ["grid", "triangle", "uv", "distance", "edge", "skew", "id"], "likes": 14, "viewed": 634, "published": 3, "date": "1616197538", "time_retrieved": "2024-07-30T19:31:46.661964", "image_code": "// Triangle grid using the skewed, split rectangle method\n//\n// Is it possible to make this any quicker?\n\n// SkewTriGrid outputs:\n// x = dist to border\n// y = dist to centre\n// zw = uv\n// id = celltile ID\n\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 SkewTriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    //id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    //id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n/*\n// my original version...\nvec4 SkewTriGrid(vec2 uv, out vec2 id)\n{\n    const mat2 m=mat2(1.0, -0.57735, 0.0, 1.15470);\n    uv*=m;\n    vec3 ftri = fract(vec3(uv,1.0-uv.x-uv.y));\n    vec3 border = abs(2.0*ftri-1.0);\n    float edge = max(max(border.x,border.y),border.z); \n    id = floor(uv)+0.5;\n    vec2 triuv = (ftri.xy-0.5) * inverse(m);\n    float itri = sign(length(ftri)-1.);\n    triuv -= vec2(0.25, 0.1443376) * itri;\n    triuv.xy *= -itri;\n    //id*= inverse(m); // Optional, unskew IDs\n    //id.xy += itri*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43, length(triuv), triuv);\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n\n    vec2 id;\n    vec4 h = SkewTriGrid(uv*(8.0+sin(iTime)),id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.45,0.35,0.15);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 4.1\n    shapecol *= 1.0 + pow(abs(sin(length(id)*patternVal + iTime*0.65)), 4.0);\t// pulse mult\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol, vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre    \n\n    // show the distances/UVs etc.\n    if (uv.y<-0.3)\n    {\n        if (xx<0.33)\n            finalcol = vec3(h.x);// show edge distance\n        else if (xx<0.66)\n            finalcol = vec3(h.y); // show centre distance\n        else\n            finalcol = vec3(h.zw,0.0); // show cellUV\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(uv.y+0.305),0.0065));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n            \n    }\n    \n    fragColor = vec4(finalcol ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 351, 391, 391, 953], [954, 1570, 1627, 1627, 3118]], "test": "untested"}
{"id": "7dl3zB", "name": "Two Link IK Robot Arm", "author": "oneshade", "description": "A robotic arm grabbing things. Based on reinder's [url=https://www.shadertoy.com/view/tlSSDV]\"Robotic Arm Hunting Lights\"[/url] and also trying to learn how inverse kinematics works. I'm going to have to start doing some robotics with my raspberry pi!", "tags": ["ik", "tracker", "robotics", "inversekinematics", "arm", "twolink"], "likes": 12, "viewed": 272, "published": 3, "date": "1616191788", "time_retrieved": "2024-07-30T19:31:47.427916", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n#define PLOT_RES 30\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\nvec2 getTarget(in float t) {\n    vec2 polar = Hash12(t);\n    polar = vec2(polar.x * 6.28, polar.y * 2.0 + 1.0);\n    return vec2(cos(polar.x), sin(polar.x)) * polar.y;\n}\n\nvec2 getJointAngles(in vec2 a, in vec2 b, in float ra, in float rb) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba);\n    float q1 = atan(ba.y, ba.x) + acos((d + ra * ra - rb * rb) / (2.0 * ra * sqrt(d)));\n    float q2 = atan(ba.y - ra * sin(q1), ba.x - ra * cos(q1));\n    return vec2(q1, q2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(0.5, 0.0, 0.0);\n    float time = iTime;\n\n    float ra = 2.0;\n    float rb = 1.0;\n\n    vec2 a = vec2(0.0);\n\n    vec2 cPrev = getTarget(floor(time));\n    vec2 cNext = getTarget(ceil(time));\n    float transition = smoothstep(0.0, 1.0, fract(time));\n\n    vec2 prevAngles = getJointAngles(a, cPrev, ra, rb);\n    vec2 nextAngles = getJointAngles(a, cNext, ra, rb);\n\n    vec2 curAngles = mix(prevAngles, nextAngles, transition);\n    vec2 b = a + ra * vec2(cos(curAngles[0]), sin(curAngles[0]));\n    vec2 c = b + rb * vec2(cos(curAngles[1]), sin(curAngles[1]));\n\n    draw(sdRing(uv, a, ra, rb), vec3(0.0, 0.5, 0.0));\n\n    float tStep = 1.0 / float(PLOT_RES);\n    vec2 j2Prev = cPrev;\n    bool dash = true;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 angles = mix(prevAngles, nextAngles, smoothstep(0.0, 1.0, t));\n        vec2 j1Cur = a + ra * vec2(cos(angles[0]), sin(angles[0]));\n        vec2 j2Cur = j1Cur + rb * vec2(cos(angles[1]), sin(angles[1]));\n        if (dash) draw(sdLine(uv, j2Prev, j2Cur, 0.0), vec3(0.0, 0.0, 1.0));\n        j2Prev = j2Cur;\n        dash = !dash;\n    }\n\n    color = mix(color, vec3(1.0, 0.5, 0.0), min(exp(-10.0 * sdDisc(uv, cPrev, 0.1)) * (1.0 - transition), 1.0));\n    color = mix(color, vec3(1.0, 0.5, 0.0), min(exp(-10.0 * sdDisc(uv, cNext, 0.1)) * transition, 1.0));\n\n    float clip = -sdLine(uv, c, 2.0 * c - b, 0.1);\n    draw(sdLine(uv, a, b, 0.05), vec3(1.0, 0.8, 0.0));\n    draw(max(sdLine(uv, b, c, 0.05), clip), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.1), vec3(1.0));\n    draw(sdDisc(uv, b, 0.1), vec3(1.0));\n    draw(max(sdDisc(uv, c, 0.2), clip), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 177, 202, 202, 330], [332, 332, 380, 380, 412], [414, 414, 473, 473, 585], [587, 587, 647, 647, 688], [690, 690, 718, 718, 858], [860, 860, 929, 929, 1155], [1157, 1157, 1212, 1212, 3007]], "test": "untested"}
{"id": "sdl3zB", "name": "Simple Julia Set V4", "author": "tungster24", "description": "a simple shader for the julia set.\nv3 adds shading", "tags": ["fractal", "julia", "juliaset"], "likes": 2, "viewed": 253, "published": 3, "date": "1616187366", "time_retrieved": "2024-07-30T19:31:48.198855", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec3 res = iResolution;\n    vec4 m = iMouse;\n    float x = ((p.x-(res.x/2.0)/res.x*0.9+0.125))*2.0;\n    float y = (p.y-(res.y/2.0)/res.y)*2.0;\n    int iter = 0;\n    while (iter < 100) {\n        if (x * x + y * y >= 4.0) {break;}\n        float y1 = (2.0 * (x * y)) + 2.0*(m.y/res.y-res.x/1414.0);\n        float x1 = (x * x) - (y * y) + 2.0*(m.x/res.x-1.0);\n        x = x1;\n        y = y1;\n        if (x * x + y * y <= 4.0) {iter += 1;};\n        };\n        \n    float r = 0.0; \n    if ((x * x) + (y * y) <= 4.0) {r = 1.0;} else {r = float(iter)/20.0;};\n    fragColor = vec4(r,r,r,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 686]], "test": "untested"}
{"id": "7slGzS", "name": "cost of volumes is anisotropic", "author": "FabriceNeyret2", "description": "volumes are stored as stack as 2D textures ( roughly ), so the cache and cost efficiency differs along directions.\nNowadays it seems small, at least for a 32x32x32 very small volume: + 5% cost ( +3% for the swizzling ).\n( too bad we cannot test bigger vol", "tags": ["bench", "volumes", "cost"], "likes": 7, "viewed": 309, "published": 3, "date": "1616177785", "time_retrieved": "2024-07-30T19:31:48.972785", "image_code": "#define N 100. // try 1000.\n\n// #define texture(ch, V) V.xyzz  // to bench just the switzzle, without textures: \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.y;\n    O = vec4(0);\n    \n    for(float k=0.; k < N; k++ ) // summing N random columns in the cube texture \n        for( float z=0.; z < 1.; z+= 1./32. ) {\n            vec3 V = vec3( U+fract(1e5*sin(1e5*vec2(k,k+iTime))) , z );\n                                             // N=1000.       N=100.        ( once at N=1000. too !!! )\n         // O += texture(iChannel0, V.zxy ); // 517ms 1.9fps  51.7ms 15fps    422ms 2.3fps\n            O += texture(iChannel0, V.xyz ); // 480ms 2.0fps  48.0ms 15fps    388ms 2.5fps  \n        }\n    O /= 32. * N;\n    \n    O = .5 + .5* (O-.5) * sqrt(32. * N); // renormalisation by variance, for visual\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 152, 152, 807]], "test": "untested"}
{"id": "NdsGRB", "name": "Spider on mouse", "author": "dopa", "description": "A spider on mouse and follow the targets on the scene! ", "tags": ["2d", "ik", "inversekinematics"], "likes": 32, "viewed": 424, "published": 3, "date": "1616170478", "time_retrieved": "2024-07-30T19:31:49.742727", "image_code": "float segment(vec2 P, vec2 A, vec2 B, float r) \n\n{\n\n    vec2 g = B - A;\n\n    vec2 h = P - A;\n\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\n\treturn smoothstep(r,0.9*r, d);\n\n}\n\nconst vec3 backColor  = vec3(0.3);\n\nconst vec3 pointColor = vec3(0.15,0.1,0.1);\n\nconst vec3 targetsColor = vec3(0.9,0.9,1);\n\nconst vec3 lineColor = vec3(0,0,0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n     \n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    if(mouse== - iResolution.xy / iResolution.y)\n        mouse=vec2(0,0);\n        \n    vec3 color = backColor;\n    \n    vec2 targets[]=vec2[] (\n                            vec2(.3,0),vec2(.4,.2),vec2(.7,.1),vec2(.2,-.6),vec2(-.8,.1),vec2(-.8,-.6),\n                            vec2(.5,.2),vec2(.1,.7),vec2(.7,.6),vec2(.3,-.2),vec2(.4,.1),vec2(-.6,.5),\n                            vec2(.4,0),vec2(.2,.4),vec2(-.7,-.3),vec2(.2,-.6),vec2(-.8,.1),vec2(-.7,.3),\n                            vec2(-.6,.2),vec2(-.4,.7),vec2(-.6,-.7),vec2(-.4,-.2),vec2(-.2,.1),vec2(-.1,.4)\n                          \n                          );\n    /*                      \n    for (int i = targets.length() - 1; i >= 0; --i) {\n      float f=0.0;\n      //f = (float(i)/float(targets.length() - 1) + 5.0) / 5.0;\n      //f=fract(sin(dot(targets[i].xy,vec2(12.9898,78.233)))*43758.5453123);\n      f=float(i%10+1)/10.0;\n      targets[i] += vec2(cos(iTime * f), sin(iTime * f)) * 0.05;\n    }                      \n    */\n    \n    mouse += vec2(cos(iTime)*2.0, sin(iTime)) * 0.05;\n    \n    float radius=.08;\n    \n    int legsNum = 8;//\n    \n    float dalte=3.1415926*2.0/float(legsNum);\n    for (float k=0.0;k<3.1415926*2.0;k+=dalte){\n        float angle = k;\n        vec2 pos;\n        pos.x =cos(angle)*radius;\n        pos.y = sin(angle)*radius;\n        \n        int iterations=5;//\n\n        vec2 startPoint=mouse+pos;\n        \n        float reach=4.5;\n        \n        float closestLength=10.0;\n        vec2 closestPoint;\n        for (int i=targets.length()-1;i>=0;i--)\n        {\n            if(closestLength>length(targets[i]-(mouse+pos*reach)))\n            {\n                closestLength=length(targets[i]-(mouse+pos*reach));\n                closestPoint=targets[i];\n            }\n        }\n        \n        \n        vec2 endPoint=closestPoint;\n        \n        int piece=3;\n\n        vec2[] points=vec2[] (vec2(1,1),vec2(2,2),vec2(3,3),vec2(4,4));\n\n        float[] lenghts=float[](0.3,0.25,0.1);\n\n\n        for (int j=0;j<=iterations;j++){\n            vec2 target=endPoint;\n            for (int i=piece;i>0;i--){\n                points[i]=target;\n\n                vec2 dir;\n                dir=(target-points[i-1])/ length(target-points[i-1]);\n                points[i-1] = target-(dir*lenghts[i-1]);\n\n\n                target=points[i-1];\n            }\n\n            target=startPoint;\n            for (int i=0;i<piece;i++){\n                points[i]=target;\n\n                vec2 dir;\n                dir=(target-points[i+1])/ length(target-points[i+1]);\n                points[i+1] = target-(dir*lenghts[i]);\n\n\n                target=points[i+1];\n            }\n        }\n\n        \n        float intensity;\n        \n        for (int i=piece;i>=0;i--){\n            intensity = segment(uv, points[i],points[i], 0.03);\n            color = mix(color, pointColor, intensity);\n        }\n        \n        \n        for (int i=piece;i>=1;i--){\n            intensity = segment(uv, points[i],points[i-1], 0.01);\n            color = mix(color, lineColor, intensity);\n        }\n       \n         for (int i=targets.length()-1;i>=0;i--){\n            intensity = segment(uv, targets[i],targets[i], 0.02);\n            color = mix(color, targetsColor, intensity);\n        }\n        intensity = segment(uv, mouse,mouse, radius+0.03);\n        color = mix(color, pointColor, intensity);\n        \n    }\n    fragColor = vec4(color, 1.0);\n}\n\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 198]], "test": "untested"}
{"id": "fsl3zB", "name": "Convolution Kernel Feedback Fun", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nMany thanks to cornusammonis for suggesting great improvements such as removing needless aspect ratio correction of pixelSize and clamping between -1 and 1", "tags": ["blob", "challenge", "kernel", "willstall"], "likes": 6, "viewed": 460, "published": 3, "date": "1616169612", "time_retrieved": "2024-07-30T19:31:50.518652", "image_code": "//play around with the variables in the Common tab!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz + min(iTime, 1.0);\n    \n    if(usingPalette)\n        col = pal( rgbToLuminance(col).r, palette);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////////////////////////////////////////////\n//Config\nconst bool fullColor = true; //true: RGB color, false: black and white\nconst float percentagePerTick = .15; //applyKernel takes beforeKernel + percentagePerTick * afterKernel\n\nconst bool usingPalette = true; //true: luminance gets converted to palette\n#define palette \\\n    vec3(0.5,0.5,0.5),\\\n    vec3(0.5,0.5,0.5),\\\n    vec3(1.0,1.0,1.0),\\\n    vec3(0.0,0.10,0.20) \n\n#define bufferAKernel sharpenKernel\n#define bufferBKernel gaussianKernel\n\n///////////////////////////////////////////////////////////////////////////////////////\n\nconst float noopKernel[9] = float[9](.0,.0,.0,.0,1.,.0,.0,.0,.0);\nconst float sharpenKernel[9] = float[9](1.,1.,1.,1.,-8.,1.,1.,1.,1.);\nconst float blurKernel[9] = float[9](1./9., 1./9., 1./9., 1./9.,  1./9.,  1./9.,  1./9.,  1./9.,  1./9.);\nconst float laplacianKernel[9] = float[9](.0, -1., .0, -1., 4., -1., .0, -1., .0);\nconst float gaussianKernel[9] = float[9](1./16., 1./8., 1./16., 1./8., 1./4., 1./8., 1./16., 1./8., 1./16.);\nconst float highPassKernel[9] = float[9](-1./9.,-1./9.,-1./9.,-1./9.,8./9.,-1./9.,-1./9.,-1./9.,-1./9.);\n\nvec3 applyKernel(vec2 uv, vec2 resolution, sampler2D image, float kernel[9])\n{\n    vec2 pixelSize = 1./resolution.xy;\n    \t\n    vec3 beforeKernel = texture(image, uv).xyz;\n    vec3 afterKernel = vec3(.0);\n    for(int i = 0; i < 3; i++)\n    for(int j = 0; j < 3; j++)\n    {\n        vec2 sampleUV = uv + vec2(float(i-1), float(j-1)) * pixelSize;\n        afterKernel += texture(image, sampleUV).xyz * kernel[j*3+i];\n    }\n    \n    return clamp(beforeKernel + percentagePerTick *afterKernel,-1., 1.);\n}\n\nvec3 rgbToLuminance(vec3 col)\n{\n    return vec3(0.2126*col.r + 0.7152*col.g + 0.0722*col.b);\n}\n\n//from iq: https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define kernelMain(kernel) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n{\\\n    vec2 uv = fragCoord/iResolution.xy;\\\n    if(iTime > .5)\\\n    {\\\n        fragColor = vec4(applyKernel(uv, iResolution.xy, iChannel0, kernel), 1.0);\\\n    } else \\\n    {\\\n        vec4 col = texture(iChannel1, uv); \\\n        fragColor = fullColor ? col-.5 : vec4(rgbToLuminance(col.xyz)-.5, 1.0);\\\n    }\\\n}", "buffer_a_code": "\nkernelMain(bufferAKernel)", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nkernelMain(bufferBKernel)", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 110, 332]], "test": "untested"}
{"id": "fdfGW8", "name": "Anti-mass Spectrometer half life", "author": "kosmaks", "description": "Controls:\nWASD - move\nMouse - view\nF - disaster mode\nG - RTX on/off\nR - reset player position", "tags": ["raytracing", "raymarching", "halflife"], "likes": 16, "viewed": 621, "published": 3, "date": "1616167985", "time_retrieved": "2024-07-30T19:31:51.470108", "image_code": "#define MAX_DIST (30.)\n#define MIN_DIST (0.01)\n#define MAX_STEPS (100)\n\n#define ENABLE_GUARDS\n#define MODULE\n\n#ifdef ENABLE_GUARDS\n#define SD_GUARD(p, r) { float guardl = length(p); if (guardl - r * 1.1 > 0.) return guardl - r;}\n#else\n#define SD_GUARD(p, r) {}\n#endif\n\nfloat getBeamerRot() {\n    return iTime;\n}\n\nbool isDisasterMode() {\n    return isToggled(iChannel2, KEY_F);\n}\n\nbool isPoor() {\n    return isToggled(iChannel2, KEY_G);\n}\n\n// ===\n\nfloat marching_sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat marching_sdCylinder(vec3 p, float r) {\n  return length(p.xz) - r;\n}\n\nfloat marching_sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat marching_sdFloor(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float td, d = MAX_DIST;\n    float l = length(p.xz);\n    \n    // floor\n    d = p.y;\n    if (d < MIN_DIST) {\n        vec3 color = texture(iChannel1, p.xz / 10.).xyz;\n        m.diffuse = 1.5 * color.yzx* vec3(0.85, 0.3, 0.03);\n        //m.reflection = color * 0.2;\n        m.roughness = 0.1;\n        if (l > 5. || l < 4.7 && mod(theta + 0.1 + angle45, angle90) < 0.2) {\n            m.diffuse = color;\n        }\n        m.specular = vec4(m.diffuse, 20.);\n    }\n    \n    // tubes\n    theta = mod(theta + angle45, angle90) + angle45;\n    vec3 ap = vec3(l * cos(theta), p.y, l * sin(theta));\n    float curve = ap.z * 0.2;\n    curve = -abs(2. * curve - 1.) + 1.;\n    curve = max(0., curve) * 0.8;\n    td = marching_sdCylinder(abs(ap.yzx) - vec3(0., 0., curve), 0.1);\n    if (td < d) {\n        d = td;\n        m = mWhite;\n        m.diffuse = vec3(0.9);\n        m.specular = vec4(vec3(10.), 10.);\n    }\n    \n    // center\n    td = marching_sdCappedCylinder(p, 1.5 - p.y * 0.5, 0.2);\n    if (td < d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = vec3(0.3) * texture(iChannel0, p.xz).x;\n        }\n    }\n    \n    // road  \n    p = qRotate(p, qCreateRotation(up, angle45));\n    \n    td = marching_sdBox(p - vec3(3.5, 0., 0.), vec3(2.5 , 0.1, 0.8));\n    if (td < d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = mix(\n                vec3(0.3), \n                vec3(1., 1., 0.), \n                round(abs(sin((p.x + p.z * 0.2) * 10.)))\n            );\n        }\n    }\n    \n    td = -marching_sdBox(p - vec3(3.5, 0., 0.), vec3(2.5 , 0.2, 0.6));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            m = mWhite;\n            m.diffuse = vec3(0.3) * texture(iChannel0, p.xz).x;\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdDuct(vec3 p, out Material m) {\n    m = mWhite;\n    p = vec3(p.x, p.y, abs(p.z));\n    p -= vec3(-0.6, 0., 6.5);\n    \n    float d = length(p.xz) - 0.9;\n    float base = length(p.xz * vec2(0.8, 1.)) - 1.2;\n    float baseCutoff = smoothstep(0., 1., (p.y - 1.) * 1.);\n    base += baseCutoff * 1.2;\n    \n    float disp = -(clamp(cos(p.y * 10.), 0.9, 1.) - 0.9) * 0.2;\n    disp *= baseCutoff;\n    \n    d = min(d, base) + disp;\n    \n    if (d < MIN_DIST) {\n        vec3 col = texture(iChannel1, p.xy / 10.).xyz;\n        m.diffuse = col * 1.8;\n    }\n    \n    return d;\n}\n\nfloat marching_sdRoom(vec3 p, out Material m) {\n    m = mWhite;\n    vec3 ap = abs(p);\n    float r = 6., td;\n    \n    float l = length(p.xz);\n    float guard = r * 0.9 - l;\n    if (guard > 0.) return r - l;\n    \n    float di = r - (ap.x + ap.z) * 0.7071;\n    float sq = min(r - ap.x, r - ap.z);\n    \n    float angle = atan(ap.z / ap.x);\n    \n    // Walls\n    float disp = 1.;\n    disp *= (clamp(cos(angle * 18.5), -0.5, 0.5) + 0.5) * 0.2; // l1 grooves\n    //disp *= min(1., pow(6. * (p.y + 0.1) - 1., 10.)); // footer\n    disp *= min(1., pow(4. * (1.8 - p.y) - 1., 6.)); // l1 bars\n    //disp *= min(1., pow(10. * (3. - p.y) - 1., 2.)); // l2 bars\n    disp *= smoothstep(1., 0., (p.y - 3.5) * 10.); // cutoff grooves\n    disp *= 1. - smoothstep(0., 1., (p.y - 3.) * 10.) * 0.6; // shallow l3 grooves\n    float disp2 = (clamp(cos(angle * 18.5), -0.7, -0.6) + 0.7) * 0.5;\n    disp2 *= smoothstep(0., 1., (p.y - 3.7) * 10.);\n    disp2 *= min(1., pow(10. * mod(p.y - 3.5, 2.) - 1., 6.)); // l1 bars\n    disp += disp2;\n    disp *= smoothstep(1., 0., (p.y - 9.) * 30.);\n    float d = min(sq, di) + disp;\n    \n    if (d < MIN_DIST) {\n        if (p.y < 9.) {\n            vec3 color = texture(iChannel0, vec2(angle * 10., p.y)).xyz;\n            m.diffuse = vec3(0.7, 0.5, 0.1) + color * 0.1;\n            //m.reflection = vec3(1.);\n        }\n        \n        if (p.y > 8.) {\n            m.diffuse *= vec3(max(0., 9. - p.y));\n        }\n    }\n    \n    // Door\n    vec3 doorp = qRotate(p, qCreateRotation(up, angle45));\n    doorp -= vec3(.3, 0.8, 6.1);\n    float doorDisp = min(0., sin(p.y * 9.5)) * 0.05;\n    td = -marching_sdBox(doorp, vec3(1., 1., 0.2 + doorDisp));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            vec3 tex = texture(iChannel1, doorp.xy / 8.).xyz;\n            m.reflection = tex * 0.5;\n            m.diffuse = tex;\n            m.roughness = 0.04;\n        }\n    }\n    \n    // Window\n    doorp = qRotate(p, qCreateRotation(up, -angle45));\n    doorp -= vec3(0., 2.8, 6.1);\n    td = -marching_sdBox(doorp, vec3(1.5, 0.3, 0.2));\n    if (td > d) {\n        d = td;\n        if (d < MIN_DIST) {\n            vec3 tex = texture(iChannel1, doorp.xy / 8.).xyz;\n            m.reflection = tex * 0.5;\n            m.diffuse = tex;\n            m.roughness = 0.04;\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdResArm(vec3 p, out Material m) {\n    float d = MAX_DIST;\n    \n    d = min(d, marching_sdBox(p - vec3(1., 0., 0.), \n        vec3(0.4, 0.8, 0.2 * ( 0.6 + 0.6 * (p.x - 0.6)/0.8 ))));\n    d = min(d, marching_sdBox(p - vec3(1.4, 0.6, 0.), \n        vec3(0.5, 0.2 + ( 0.2 - 0.2 * (p.x - 1.)/0.8 ), 0.16)));\n        \n    d = min(d, marching_sdBox(p - vec3(1.74 + (p.y-0.6) * 0.08, 1.2, 0.), \n        vec3(0.16, 0.6, 0.16)));\n        \n    d = min(d, 0.5 * marching_sdBox(p - vec3(1.4 + (p.y - 1.8) * 1.2, 2.0, 0.), \n        vec3(0.6 * (1. - (p.y - 1.8)/0.6 ), 0.2, 0.16)));\n    \n    if (d < MIN_DIST) {\n        vec3 tex = texture(iChannel1, p.xy / 1.).xyz;\n        m.diffuse = tex * vec3(0.8, 1., 1.) * 2.;\n        //m.reflection = vec3(0.3);\n        //m.roughness = 0.1;\n    }\n        \n    return d;\n}\n\nfloat marching_sdRes(vec3 p, out Material m) {\n    m = mWhite;\n    Material tm;\n    \n    SD_GUARD(p - vec3(0., 1., 0.), 2.4);\n    //return length(p - vec3(0., 1., 0.)) - 2.;\n    p = qRotate(p, qCreateRotation(up, 3.14-angle45));\n    float d = max(\n        marching_sdCappedCylinder(p, 1., 0.4),\n        -marching_sdCylinder(p, 0.6)\n    );\n    \n    if (d < MIN_DIST) {\n        m.diffuse = texture(iChannel1, p.xz).xyz * vec3(0.5, 1., 0.5);\n        m.reflection = vec3(0.5, 1., 0.5);\n    }\n    \n    float arm = marching_sdResArm(abs(p), tm);\n    arm = min(arm, marching_sdResArm(p.zyx, tm));\n    if (arm < d) {\n        d = arm;\n        m = tm;\n    }\n    \n    return d;\n}\n\nfloat marching_sdSheild(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float r = 2.;\n    float h = 1.;\n    float sr = r * 0.4;\n    \n    p -= vec3(0., 9. - h, 0.);\n    \n    // 6 bars\n    float l = length(p.xz);\n    theta = mod(theta, angle60) - angle30;\n    vec2 ap = vec2(cos(theta), sin(theta)) * l;\n    ap = abs(ap);\n    float c = rot2d(ap, rotMin15).y;\n    float d = max(max(l - r, -c), -l + sr);\n    \n    // cap\n    d = max(d, marching_sdCappedCylinder(p, r, h));\n    \n    // cone\n    p.y += h;\n    float cone = length(p.xz) - (p.y * 1.2 + 1.5);\n    d = max(cone, d);\n    \n    if (d < MIN_DIST) {\n        vec3 tex = texture(iChannel1, ap.xy).xyz;\n        m.diffuse = tex * 2.;\n        m.specular = vec4(m.diffuse, 10.);\n    }\n    \n    return d;\n}\n\nfloat marching_sdCore(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float r = 1.;\n    float h = 0.8;\n    p -= vec3(0., 9. - h, 0.);\n    \n    float disp = cos(theta * 10. + iTime * 60.) * 0.1;\n    float d = MAX_DIST;\n    d = min(d, marching_sdCappedCylinder(p, r + disp, h));\n    \n    return d;\n}\n\nfloat marching_sdBeamer(vec3 p) {\n    vec3 ap = abs(p);\n    float fallout = mix(0.2, 0., ap.y - 0.1);\n    return marching_sdCappedCylinder(ap - vec3(0., 0.19, 0.), fallout, 0.15);\n}\n\nfloat marching_sdBeamers(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    p -= vec3(0., 6.5, 0.);\n    \n    theta = mod(theta + getBeamerRot(), angle120);\n    float l = length(p.xz);\n    vec3 ap = vec3(cos(theta) * l, p.y, sin(theta) * l);\n    float d = marching_sdBeamer(ap - vec3(1., 0., sq3) * 0.7);\n    return d;\n}\n\nfloat marching_sdLaser(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    p -= vec3(0., 6.5, 0.);\n    \n    theta = mod(theta, angle60) / angle60;\n    float disp = min(1., pow(5. * theta - 2., 10.)) * 0.02;\n    float r = 0.3 + disp;\n    float fallout = clamp(p.y * 3. + 1.5, 0., 1.);\n    r *= fallout;\n\n    return marching_sdCappedCylinder(p, r, 0.35);\n}\n\nfloat marching_sdTile(vec3 p, float w, float h) {\n    float r = 6.;\n    float size = tan225 * p.x;\n    float d = marching_sdBox(p - vec3(r, 0., 0.), vec3(w, h, size));\n    return d;\n}\n\nfloat marching_sdFloorTiles(vec3 p, float theta, out Material m) {\n    m = mWhite;\n    float w = 3., h = 0.2, td;\n    \n    theta = mod(theta - angle45, angle90) - angle45;\n    float l = length(p.xz);\n    p = vec3(l * cos(theta), p.y, l * sin(theta));\n    float d = marching_sdTile(p, w, h);\n    if (d < MIN_DIST) {\n        m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, p.xz).x * 0.5 + 0.5);\n    }\n    \n    vec2 grid = max(sin(p.xz * vec2(40., 34.)), 0.);\n    float gridDisp = max(grid.x, grid.y);\n    td = marching_sdBox(p - vec3(4.6, 0., 0.), vec3(0.4, 0.202 + gridDisp * 0.01, 0.6));\n    if (td < d) {\n        d = td;\n        m.diffuse = vec3(0.);\n        m.reflection = round(gridDisp) * vec3(0.9, 0.7, 0.5);\n    }\n    \n    p = qRotate(p - vec3(3., 0., 0.), qForwAngle45);\n    \n    td = marching_sdBox(p, vec3(0.15, 0.15, 0.4));\n    if (td < d) {\n        d = td;\n        m.diffuse = vec3(0.2);\n    }\n    \n    td = marching_sdBox(p, vec3(0.17, 0.1, 0.34));\n    if (td < d) {\n        d = td;\n        m.emission = vec3(1.);\n    }\n    \n    return d;\n}\n\nfloat marching_sdRailing(vec3 p) {\n    float r = 4.2;\n    float rr = 0.03;\n    float hr = 0.05;\n    float h = 0.3;\n    \n    float len = tan225 * r * 0.9;\n    \n    float d = MAX_DIST;\n    \n    vec3 ap = vec3(p.x, p.y, abs(p.z));\n    d = min(d, marching_sdCappedCylinder(ap - vec3(r, h, len * 0.8), rr, h));\n    d = min(d, marching_sdBox(p - vec3(r, 2. * h, 0.), vec3(hr, rr, len)));\n    \n    return d;\n}\n\nfloat marching_sdFirstFloor(vec3 p, out Material m) {\n    m = mWhite;\n    float w = 1.9, h = 1.;\n    \n    float d = MAX_DIST;\n    \n    vec3 y = vec3(0., h, 0.);\n    \n    p = rot3d(p, up, -angle90 - angle45);\n    d = min(d, marching_sdBox(p - vec3(0., 0., 4.), vec3(0.8, 0.5, 0.3)));\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p - y));\n    p = rot3d(p, up, angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p - y));\n    p = rot3d(p, up, angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    \n    \n    if (d < MIN_DIST) {\n        if (p.y > 1.03) {\n            m.reflection = vec3(0.7);\n        } else if (p.y > 0.97) {        \n            m.diffuse = 0.97 * (texture(iChannel0, p.xz).xxx * 0.5 + 0.5);\n        } else {\n            m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, vec2(p.x + p.z, p.y)).xyz * 0.5 + 0.5);\n            m.specular = vec4(vec3(m.diffuse), 10.);\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_sdSecondFloor(vec3 p, out Material m) {\n    m = mWhite;\n    float d = MAX_DIST;\n    \n    float w = 1.9, h = 0.1;\n    p -= vec3(0., 5.5, 0.);\n    p = rot3d(p, up, -angle90 - angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p));\n    p = rot3d(p, up, -angle45);\n    d = min(d, marching_sdTile(p, w, h));\n    d = min(d, marching_sdRailing(p));\n    \n\n    if (d < MIN_DIST) {\n        if (p.y > 0.13) {\n            m.reflection = vec3(0.7);\n        } else if (p.y > 0.07 || p.y < 0.07) {        \n            m.diffuse = 0.97 * (texture(iChannel0, p.xz).xxx * 0.5 + 0.5);\n        } else {\n            m.diffuse = vec3(0.97, 0.58, 0.02) * (texture(iChannel0, vec2(p.x + p.z, p.y)).xyz * 0.5 + 0.5);\n            m.specular = vec4(vec3(m.diffuse), 10.);\n        }\n    }\n    \n    return d;\n}\n\nfloat marching_getDist(vec3 p, out Material m) {\n    Material tm;\n    m = mWhite;\n    float d = MAX_DIST + 1., td;\n    float tanzx = atan(p.z, p.x);\n    \n    td = marching_sdRoom(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    if (p.y > 0.3) {\n        d = min(d, p.y - 0.2);\n    } else {\n        td = marching_sdFloor(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdFloorTiles(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    if (p.y > 2.) {\n        d = min(d, p.y - 1.5);\n    } else {\n        td = marching_sdFirstFloor(p, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    float s = length(p - vec3(0., 8., 0.));\n    if (s - 3. > 0.) {\n        d = min(d, s - 2.5);\n    } else {\n        td = marching_sdSheild(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdCore(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdBeamers(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n        td = marching_sdLaser(p, tanzx, tm);\n        if (td < d) { d = td; m = tm; }\n    }\n    \n    if (td < d) { d = td; m = tm; }\n    td = marching_sdRes(p, tm);\n    if (td < d) { d = td; m = tm; }\n    td = marching_sdSecondFloor(p, tm);\n    if (td < d) { d = td; m = tm; }\n    return d;\n}\n\nvec3 marching_getNormal(vec3 p) {\n    Material m;\n    float dist = marching_getDist(p, m);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = dist - vec3(\n        marching_getDist(p - e.xyy, m),\n        marching_getDist(p - e.yxy, m),\n        marching_getDist(p - e.yyx, m));\n    return normalize(n);\n}\n\nfloat marching_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float totalDist = 0.;\n    \n    int i = 0;\n    for (; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        totalDist += d;\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n    }\n    \n    if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    \n    if (totalDist < MAX_DIST) {\n        touch = ro + totalDist * rd;\n        n = marching_getNormal(touch);\n    }\n    \n    return totalDist;\n}\n\nfloat marching_softShadow(vec3 ro, vec3 rd, float k, float mind, float maxd) {\n    Material m;\n    float totalDist = 0.1;\n    float res = 1.;\n    for (int i = 0; i < 20; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        res = min(res, k * d / totalDist);\n        if (abs(d) < mind) return 0.;\n        totalDist += d;\n        if (totalDist > maxd) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\n// ====\n\nfloat int_plane(vec3 ro, vec3 rd, vec3 n, float d) {\n    float dist = -(d + dot(n, ro)) / dot(n, rd);\n    return dist;\n}\n\nvec2 int_lightning(vec3 ro, vec3 rd, vec3 start, vec3 end, float intensity, float jiggle) {\n    vec3 n = normalize(end - start);\n    float theta = acos(dot(up, n));\n    float phi = atan(n.z, n.x);\n    \n    Quat xRot = qCreateRotation(forw, theta);\n    Quat yRot = qCreateRotation(up, phi);\n    Quat rot = qMul(qMul(yRot, xRot), yRot);\n    \n    vec3 initialRo = ro;\n    vec3 sdir = start - ro;\n    ro -= start;\n    ro = qRotate(ro, rot);\n    rd = qRotate(rd, rot);\n\n    vec3 pn = normalize(vec3(rd.x, 0., rd.z));\n    float t = int_plane(ro, rd, pn, 0.);\n    if (t < 0.01) return vec2(MAX_DIST, 0.);\n    vec3 touch = ro + t * rd;\n    \n    float halflen = distance(start, end) / 2.;\n    float dim = max(0., -pow((touch.y - halflen) / halflen, 4.) + 1.);\n    \n    float power = 0.;\n    \n    if (dim > 0.01) {\n        float time = iTime;\n        vec3 tex = texture(iChannel0, vec2(time, touch.y / 40.)).xyz;\n        vec2 disp = tex.xy * 2. - 1.;\n        disp *= 0.4;\n        disp += 0.1 * (texture(iChannel0, vec2(time + 0.1, touch.y / 5.)).xy * 2. - 1.);\n        disp *= vec2(dot(forw, pn), dot(right, pn));\n        disp *= dim;\n        disp *= jiggle;\n        \n        vec2 pr = normalize(cross(up, pn)).xz;\n        float dist = length(touch.xz - pr * (disp.x + disp.y));\n        \n        float varpow = mix(10., 100., tex.z);\n        power = exp(-dist * varpow * intensity) * dim;\n    }\n    \n    if (power < 0.001) {\n        return vec2(MAX_DIST, power);\n    }\n\n    return vec2(t, power);\n}\n\nfloat int_castRay(vec3 ro, vec3 rd, float intensity, out vec3 light) {\n    float d = MAX_DIST;\n    \n    float angle = getBeamerRot();\n    vec3 first = rot3d(vec3(-1.4, 6.5, 0.), up, angle);\n    vec3 second = rot3d(vec3(0.7, 6.5, sq3 * 0.7), up, angle);\n    vec3 third = rot3d(vec3(0.7, 6.5, -sq3 * 0.7), up, angle);\n    \n    vec2 t1 = int_lightning(ro, rd, vec3(0., 6.5, 0.), first, intensity, 1.);\n    d = min(d, t1.x);\n    vec2 t2 = int_lightning(ro, rd, vec3(0., 6.5, 0.), second, intensity, 1.);\n    d = min(d, t2.x);    \n    vec2 t3 = int_lightning(ro, rd, vec3(0., 6.5, 0.), third, intensity, 1.);\n    d = min(d, t3.x);\n    \n    vec2 l1 = int_lightning(ro, rd, vec3(0., 0., 0.), first, intensity, 1.);\n    d = min(d, l1.x);\n    vec2 l2 = int_lightning(ro, rd, vec3(0., 0., 0.), second, intensity, 1.);\n    d = min(d, l2.x);\n    vec2 l3 = int_lightning(ro, rd, vec3(0., 0., 0.), third, intensity, 1.);\n    d = min(d, l3.x);\n    \n    vec2 main = int_lightning(ro, rd, vec3(0., 0., 0.), vec3(0., 7., 0.), intensity * 0.3, 0.);\n    d = min(d, main.x);  \n\n    bool disaster = isDisasterMode();\n\n    vec3 shortCol = vec3(1., 0.6, 0.);\n    if (disaster) shortCol = vec3(0.1, 1., 0.);\n    light = (l1.y + l2.y + l3.y) * shortCol\n          + (t1.y + t2.y + t3.y + main.y) * vec3(1., 1., 0.8);\n    \n    if (disaster) {\n        if (sin(iTime * 10.) < 0.4) {\n            float key = floor(iTime) / 100.;\n            vec2 tex = texture(iChannel0, vec2(key, 0.)).xy;\n            float theta = tex.x * twopi;\n            vec3 target = vec3(cos(theta), 0., sin(theta)) * 6.;\n            target.y = 7. * tex.y;\n            \n            vec2 ray = int_lightning(ro, rd, vec3(0., 0., 0.), target, intensity, 1.);\n            d = min(d, ray.x);\n            light += ray.y * shortCol;\n        }\n    }\n    \n    return d;\n}\n\n// ====\n\nvec3 getLightningPos(vec3 touch) {\n    return vec3(0., clamp(touch.y, 1., 5.), 0.);\n}\n\nvec3 castLightning(vec3 touch, vec3 n) {\n    vec3 lp = getLightningPos(touch);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    vec3 rad = vec3(dot(n, ld) * 0.8);\n    if (!isPoor()) {\n        vec3 lightning;\n        int_castRay(lo, ld, 0.01, lightning);\n        rad *= lightning * 0.6;\n        rad *= marching_softShadow(lo, ld, 15., 0.01, 3.);\n        rad *= marching_softShadow(lo, ld, 1., 0.1, 0.1);\n    }\n    return rad;\n}\n\nfloat castLightningSpecular(vec3 touch, vec3 rd, vec3 n) {\n    vec3 lp = getLightningPos(touch);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    float specular = dot(reflect(normalize(touch - lp), n), -rd);\n    return max(0., specular);\n}\n\nvec3 castNormalLight(vec3 touch, vec3 n) {\n    vec3 lp = vec3(5., 10., 0.);\n    vec3 l = lp - touch;\n    vec3 ld = normalize(l);\n    vec3 lo = touch + n * 0.1;\n    vec3 rad = vec3(1., 0.8, 0.67) * dot(n, ld) * 0.6;\n\n    //rad *= marching_softShadow(lo, ld, 10., 3.);\n    return rad;\n}\n\nvec3 castLight(vec3 touch, vec3 n) {\n    return castNormalLight(touch, n) + castLightning(touch, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n    \n    vec3 col = vec3(0.);\n    \n    float rot = iMouse.x / 100.;\n    vec3 ro = sampleCell(iChannel3, CELL_CAMERA_POS).xyz;\n    vec3 rt = ro + sampleCell(iChannel3, CELL_CAMERA_DIR).xyz;\n    vec3 rd = getInitialRD(vp, ro, rt, 1.2);\n    \n    float effect = isDisasterMode() ? 0.01 : 0.001;\n    rd += vec3(0., sin(iTime  * 40.) * effect, 0.);\n    rd = normalize(rd);\n    \n    Material m;\n    vec3 touch, n, lightning;\n    float di, d;\n    \n    vec3 totalRad = vec3(0.), scaler = vec3(1.);\n    \n    bool poor = isPoor();\n    \n    for (int i = 0; i < 2; ++i) {\n        d = marching_castRay(ro, rd, m, touch, n);\n        \n        di = int_castRay(ro, rd, 1., lightning);\n        \n        if (d >= MAX_DIST) {\n            break;\n        }\n        \n        if (di < d) {\n            totalRad += scaler * lightning * 5.;\n        }\n        \n        if (touch.y > 9.) break;\n        \n        if (m.emission != vec3(0.)) {\n            totalRad += scaler * m.emission;\n        } else {\n            totalRad += m.diffuse * scaler * castLight(touch, n);\n        }\n        \n        if (m.specular != vec4(0.)) {\n            float specular = castLightningSpecular(touch, rd, n);\n            totalRad += scaler * m.specular.xyz * pow(specular, m.specular.w);\n        }\n        \n        if (poor) {\n            break;\n        }\n        \n        if (m.reflection == vec3(0.)) {\n            break;\n        }\n        \n        scaler *= m.reflection;\n        ro = touch + n * 0.01;\n        rd = reflect(rd, n);\n        \n        if (m.roughness > 0.) {\n            rd += m.roughness * (texture(iChannel0, touch.xy).xyz * 2. - 1.);\n            rd = normalize(rd);\n        }\n    }\n    \n    col = totalRad / 1.5;\n    \n    if (!poor) {\n        col *= vec3(0.65, 0.9, 1.);\n        col = mix(vec3(0.05), vec3(1.2), col);\n    }\n    \n    //col = texture(iChannel3, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nstruct Quat { vec4 value; };\n\nconst vec3 up = vec3(0., 1., 0.);\nconst vec3 right = vec3(1., 0., 0.);\nconst vec3 forw = vec3(0., 0., 1.);\nconst float pi = 3.1415;\nconst float twopi = 2. * 3.1415;\nconst float sq3 = 1.7321;\nconst float angle90 = 1.5708;\nconst float angle60 = 1.0472;\nconst float angle30 = 0.5234;\nconst float angle15 = 0.2618;\nconst float angle120 = 2.0944;\nconst float angle45 = 0.7853;\nconst float angle225 = angle45 / 2.;\nconst float tan225 = 0.4142;\nconst vec2 rotMin15 = vec2(cos(-angle15), sin(-angle15));\nconst Quat qForwAngle45 = Quat(vec4(forw * 0.3827, 0.9239));\n\nstruct Material {\n    vec3 emission;\n    vec3 diffuse;\n    vec3 reflection;\n    vec4 specular;\n    float roughness;\n};\n\nconst Material mWhite = Material(\n    vec3(0.),\n    vec3(1.),\n    vec3(0.),\n    vec4(0.),\n    0.\n);\n\nvec3 getInitialRD(vec2 vp, vec3 origin, vec3 target, float d) {\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(up, forward));\n    vec3 up = cross(forward, right);\n    return normalize(d * forward + right * vp.x + up * vp.y);\n}\n\nvec2 rot2d(vec2 v, vec2 c) {\n    return vec2(v.x * c.x - v.y * c.y, v.x * c.y + v.y * c.x);\n}\n\n\n// State\n\n#define GRID_SIZE (10.)\n#define GRID_CELL (1. / GRID_SIZE)\n#define GRID_HALF vec2(GRID_CELL * 0.5)\n#define CLOSE(x, y) (abs(x - y) < 0.001)\n#define IS_CELL(c, a) (CLOSE(c.x, a.x) && CLOSE(c.y, a.y))\n#define CELL_CAMERA_POS (vec2(0., 0.))\n#define CELL_CAMERA_DIR (vec2(1., 0.))\n#define CELL_MOUSE_STATE (vec2(2., 0.))\n#define CELL_MOUSE_DIR (vec2(3., 0.))\n\nvec2 getGridCell(vec2 uv) {\n    vec2 scaled = uv * GRID_SIZE;\n    vec2 vertex = floor(scaled);\n    vec2 center = vertex + 0.5;\n    return distance(scaled, center) < 0.5 ? vertex : vec2(-1.);\n}\n\nvec4 sampleCell(sampler2D tex, vec2 index) {\n    return texture(tex, index / GRID_SIZE + GRID_HALF);\n}\n\n// Quaternions\n\nQuat qCreateRotation(vec3 axis, float angle) {\n    float ah = angle / 2.;\n    return Quat(vec4(axis.xyz * sin(ah), cos(ah)));\n}\n\nQuat qMul(Quat qa, Quat qb) {\n    vec4 a = qa.value;\n    vec4 b = qb.value;\n    return Quat(vec4(\n        a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz),\n        a.w * b.w - dot(a.xyz, b.xyz)\n    ));\n}\n\nQuat qConj(Quat q) {\n    return Quat(vec4(-q.value.xyz, q.value.w));\n}\n\nvec3 qRotate(vec3 v, Quat q) {\n    vec3 temp = cross(q.value.xyz, v) + q.value.w * v;\n    return v + 2. * cross(q.value.xyz, temp);\n}\n\nvec3 rot3d(vec3 v, vec3 axis, float angle) {\n    return qRotate(v, qCreateRotation(axis, angle));\n}\n\n\n#define KEY_W (87.0)\n#define KEY_A (65.0)\n#define KEY_S (83.0)\n#define KEY_D (68.0)\n#define KEY_R (82.0)\n#define KEY_F (70.0)\n#define KEY_G (71.0)\n\nbool isPressed(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}\n\nbool isToggled(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.75);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}", "buffer_a_code": "#define INITIAL_POS (vec3(0., 1., 3.))\n#define INITIAL_DIR (vec3(0., 0.5, -1.))\n\nfloat getPlayerY(vec2 xz) {\n    float l = length(xz);\n    float theta = atan(xz.y, xz.x) + pi;\n\n    if (l > 4. && theta > angle225 && theta < angle90 + angle45 + angle225) {\n        return 2.;\n    }\n        \n    if (l > 3.6 && theta > angle90 + angle225 && theta < angle90 + angle45 + angle225) {\n        return 1.5;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool isInitial = iFrame == 0 || \n        isPressed(iChannel1, KEY_R);\n    \n    vec2 cell = getGridCell(uv);\n    if (cell.y > 1.) return;\n    \n    if (IS_CELL(cell, CELL_CAMERA_POS)) {\n        col = INITIAL_POS;\n        if (!isInitial) col = sampleCell(iChannel0, CELL_CAMERA_POS).xyz;\n        \n        if (isPressed(iChannel1, KEY_W)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            col += dir * 0.1;\n        } if (isPressed(iChannel1, KEY_S)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            col -= dir * 0.1;\n        } \n        \n        if (isPressed(iChannel1, KEY_D)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            vec3 right = cross(up, dir);\n            col += right * 0.1;\n        } else if (isPressed(iChannel1, KEY_A)) {\n            vec2 dir2d = sampleCell(iChannel0, CELL_CAMERA_DIR).xz;\n            vec3 dir = normalize(vec3(dir2d.x, 0., dir2d.y));\n            vec3 right = cross(up, dir);\n            col -= right * 0.1;\n        }\n        \n        col.y = getPlayerY(col.xz);\n        \n        float theta = atan(col.z, col.x);\n        float l = length(col.xz);\n        l = min(5.5, l);\n        col.xz = vec2(cos(theta), sin(theta)) * l;\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_CAMERA_DIR)) {\n        col = INITIAL_DIR;\n        if (!isInitial) col = sampleCell(iChannel0, CELL_CAMERA_DIR).xyz;\n        \n        if (iMouse.z > 0.2) {\n            vec3 mouseState = vec3(0.);\n            if (!isInitial) mouseState = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n            vec3 mouseDir = vec3(0.);\n            if (!isInitial) mouseDir = sampleCell(iChannel0, CELL_MOUSE_DIR).xyz;\n            if (mouseState.z > 0.2) {\n                vec2 mdiff = iMouse.xy / iResolution.xy - mouseState.xy;\n                mdiff *= vec2(-1., 1.) * 10.;\n                float theta = atan(mouseDir.z, mouseDir.x) + mdiff.x;\n                float phi = atan(mouseDir.y, length(mouseDir.xz)) + mdiff.y;\n                phi = clamp(phi, -angle90, angle90);\n                col = vec3(cos(theta), sin(phi), sin(theta));\n            }\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_MOUSE_STATE)) {\n        col = vec3(0.);\n        if (!isInitial) col = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n        if (iMouse.z > 0.2) {\n            if (col.z < 0.2) {\n                col = vec3(iMouse.xy / iResolution.xy, 1.);\n            }\n        } else {\n            col = vec3(0.);\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    if (IS_CELL(cell, CELL_MOUSE_DIR)) {\n        col = vec3(0.);\n        if (!isInitial) col = sampleCell(iChannel0, CELL_MOUSE_DIR).xyz;\n        \n        vec3 mouseState = vec3(0.);\n        if (!isInitial) mouseState = sampleCell(iChannel0, CELL_MOUSE_STATE).xyz;\n        \n        if (iMouse.z > 0.2) {\n            if (mouseState.z < 0.2) {\n                vec3 cd = INITIAL_DIR;\n                if (!isInitial) cd = sampleCell(iChannel0, CELL_CAMERA_DIR).xyz;\n                col = vec3(cd);\n            }\n        } else {\n            col = vec3(0.);\n        }\n        \n        fragColor = vec4(col, 1.0);\n        return;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 291, 291, 311], [313, 313, 336, 336, 378], [380, 380, 395, 395, 437], [447, 447, 485, 485, 576], [578, 578, 622, 622, 651], [653, 653, 712, 712, 819], [821, 821, 882, 882, 2714], [2716, 2716, 2763, 2763, 3294], [3296, 3296, 3343, 3343, 5611], [5613, 5613, 5662, 5662, 6423], [6425, 6425, 6471, 6471, 7093], [7095, 7095, 7157, 7157, 7857], [7859, 7859, 7919, 7919, 8167], [8169, 8169, 8202, 8202, 8350], [8352, 8352, 8415, 8415, 8679], [8681, 8681, 8742, 8742, 9042], [9044, 9044, 9093, 9093, 9227], [9229, 9229, 9295, 9295, 10290], [10292, 10292, 10326, 10326, 10694], [10696, 10696, 10749, 10749, 11682], [11684, 11684, 11738, 11738, 12515], [12517, 12517, 12565, 12565, 13811], [13813, 13813, 13846, 13846, 14106], [14108, 14108, 14194, 14194, 14659], [14661, 14661, 14739, 14739, 15109], [15120, 15120, 15172, 15172, 15240], [15242, 15242, 15333, 15333, 16730], [16732, 16732, 16802, 16802, 18538], [18549, 18549, 18583, 18583, 18634], [18636, 18636, 18676, 18676, 19101], [19103, 19103, 19161, 19161, 19381], [19383, 19383, 19425, 19425, 19667], [19669, 19669, 19705, 19705, 19771], [19773, 19773, 19830, 19830, 21899]], "test": "untested"}
{"id": "fdlGzS", "name": " Robot hand", "author": "dopa", "description": "A robot hand follow the mouse ", "tags": ["2d", "inversekinematics"], "likes": 12, "viewed": 291, "published": 3, "date": "1616162707", "time_retrieved": "2024-07-30T19:31:52.242044", "image_code": "float segment(vec2 P, vec2 A, vec2 B, float r) \n\n{\n\n    vec2 g = B - A;\n\n    vec2 h = P - A;\n\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\n\treturn smoothstep(r, 0.5*r, d);\n\n}\n\nconst vec3 backColor  = vec3(0.3);\n\nconst vec3 pointColor = vec3(1,0,0.51);\n\nconst vec3 lineColor = vec3(0.95,0.95,0.10);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    //uv=fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //mouse =iMouse.xy/ iResolution.y;\n    if(sign(iMouse.z)!=1.0){\n        mouse = vec2(0.0,-0.3)+vec2(cos(iTime)*2.0, sin(iTime)) * 0.4;\n    }\n    \n    vec3 color = backColor;\n    \n    int iterations=5;\n    \n    vec2 startPoint=vec2(0,0);\n    \n    int piece=5;\n    \n    vec2[] points=vec2[] (vec2(0,0),vec2(0,1),vec2(0,2),vec2(0,3),vec2(0,4),vec2(0,5));\n\n    //vec2[] points=vec2[] (vec2(0,0),vec2(1,1),vec2(2,2),vec2(3,3),vec2(4,4),vec2(5,5));\n    \n    //vec2[] points=vec2[] (vec2(-5,-5),vec2(-3,-3),vec2(-1,-1),vec2(1,1),vec2(3,3),vec2(5,5));\n\n    //vec2[] points=vec2[] (vec2(0,0),vec2(1,1),vec2(2,-2),vec2(3,3),vec2(4,-4),vec2(5,5));\n    \n    //vec2[] points=vec2[] (vec2(0,1),vec2(1,0),vec2(0,-1),vec2(-1,0),vec2(0,1),vec2(1,0));\n\n    float[] lenghts=float[](0.3,0.25,0.2,0.15,0.1);\n   \n    \n    for (int j=0;j<=iterations;j++){\n        vec2 target=mouse;\n        for (int i=piece;i>0;i--){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i-1])/ length(target-points[i-1]);\n            points[i-1] = target-(dir*lenghts[i-1]);\n\n\n            target=points[i-1];\n        }\n        \n        target=startPoint;\n        for (int i=0;i<piece;i++){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i+1])/ length(target-points[i+1]);\n            points[i+1] = target-(dir*lenghts[i]);\n\n\n            target=points[i+1];\n        }\n    }\n    \n    /*\n    \n        vec2 target=mouse;\n        for (int i=piece;i>0;i--){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i-1])/ length(target-points[i-1]);\n            points[i-1] = target-(dir*lenghts[i-1]);\n\n\n            target=points[i-1];\n        }\n        \n    */\n    float intensity;\n    for (int i=piece;i>=1;i--){\n        intensity = segment(uv, points[i],points[i-1], 0.01);\n        color = mix(color, lineColor, intensity);\n    }\n    for (int i=piece;i>=0;i--){\n        intensity = segment(uv, points[i],points[i], 0.02);\n        color = mix(color, pointColor, intensity);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n      ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 199]], "test": "untested"}
{"id": "Nds3zS", "name": "Gold Turbo", "author": "dr2", "description": "Just a car...", "tags": ["surface", "car", "automobile"], "likes": 15, "viewed": 372, "published": 3, "date": "1616161269", "time_retrieved": "2024-07-30T19:31:53.202476", "image_code": "// \"Gold Turbo\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Length4 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec4 rSize, dSize, dashClk;\nvec3 sunDir, qHit, wlBase, carPos, cSize, litFPos;\nvec2 wlRot, inSize, wSlope;\nfloat tCur, dstFar, strRot, carRot, wbMid, wlRad, litFRad;\nint idObj, idTrObj;\nbool isSh;\nconst int idBod = 1, idBtop = 2, idGril = 3, idEx = 4, idAx = 5, idWhl = 6, idLitF = 7,\n   idLitR = 8, idDash = 9, idSeat = 10, idCon = 11, idStrWhl = 12, idMir = 13, idWin = 14;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMINTR(id) if (d < dMin) { dMin = d;  idTrObj = id; }\n\nfloat BTopDf (vec3 q)\n{\n  float z, rh;\n  z = dot (q.yz, sin (((q.z > 0.) ? 0.3 : -0.2) * pi + vec2 (0., 0.5 * pi)));\n  rh = (z > 0.) ? wSlope.x : wSlope.y;\n  return SmoothMax (Length4 (max (abs (vec2 (q.x, q.y - 0.7)) - rSize.xy + 0.8, 0.)) - 0.8,\n     length (vec2 (q.x, abs (z) - cSize.z + 2.54 + rh)) - rh, 0.04);\n}\n\nfloat CarExDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 r2;\n  float d, ds, r, z;\n  q = p;\n  r2.x = ((q.z > 0.) ? 2.5: 0.5) * cSize.x;\n  r2.y = ((q.z > 0.) ? 4. : 0.7) * cSize.y;\n  d = length (q.yz - vec2 (((r2.y < cSize.y) ?\n     clamp (q.y, - cSize.y + r2.y, cSize.y - r2.y) : cSize.y - r2.y),\n     clamp (q.z, - cSize.z + r2.y, cSize.z - r2.y))) - r2.y;\n  d = SmoothMax (d, - max (max (PrRoundBox2Df (vec2 (q.x, q.z + 1.25), inSize, 0.1),\n     abs (q.y - 0.5) - 0.6), 0.65 - length (q.yz - vec2 (-0.13, -2.9))), 0.02);\n  q = p;\n  q.x = abs (q.x);\n  d = SmoothMax (d, length (q.xz - vec2 (((r2.x < cSize.x) ?\n     clamp (q.x, - cSize.x + r2.x, cSize.x - r2.x) : cSize.x - r2.x),\n     clamp (q.z, - cSize.z + r2.x, cSize.z - r2.x))) - r2.x, 0.1);\n  q.z -= cSize.z - 1.3;\n  d = SmoothMax (SmoothMax (d, q.z, 0.02), - PrRoundBoxDf (q - vec3 (0., -0.07, 0.),\n     vec3 (0.55, 0.05, 0.2), 0.02), 0.02);\n  q = p;\n  q.x = abs (q.x) - cSize.x;\n  ds = PrCylDf (q - vec3 (0., -0.2, -0.9), 0.03, 1.7);\n  q.y -= -0.03;\n  q.z = abs (q.z + wbMid);\n  q.yz -= wlBase.yz;\n  r = length (q.yz);\n  d = SmoothMin (d, min (ds, length (max (vec2 (r - 0.7, abs (q.x) - 0.02), 0.)) - 0.05), 0.07);\n  d = SmoothMax (d, -0.1 - q.y, 0.05);\n  d = SmoothMax (d, - (length (max (vec2 (r - 0.42, abs (q.x + 0.2) - 0.23), 0.)) - 0.2), 0.02);\n  q = p;\n  q.x = abs (q.x);\n  d = SmoothMax (d, - SmoothMax (abs (PrRoundBox2Df (q.yz - dSize.xy, dSize.zw - 0.2,\n     0.2)) - 0.005, abs (q.x - cSize.x) - 0.001, 0.005), 0.007);\n  d = SmoothMax (d, - PrCylDf (q - litFPos- vec3 (0., 0., 0.85), litFRad, 1.5), 0.01);\n  q = p;\n  q.yz -= vec2 (0.72, 1.8);\n  d = SmoothMax (SmoothMin (d, PrRoundBoxDf (q, vec3 (0.4, 0., 0.3), 0.1), 0.02),\n     - PrRoundBoxDf (q - vec3 (0., 0.02, 0.3), vec3 (0.35, 0.02, 0.1), 0.02), 0.02);\n  q = p;\n  q.yz -= vec2 (0.9, - cSize.z + 0.6);\n  d = SmoothMin (d, PrRoundCylDf (q.yzx, 0.02, 0.04, 1.), 0.05);\n  q = p;\n  q.x = abs (q.x);\n  d = max (d, - PrCylDf (q - vec3 (cSize.x - 0.95, vec2 (-0.15, -4.3)), 0.14, 0.3));\n  q = p;\n  DMINQ (idBod);\n  q = p;\n  q.z -= rSize.z;\n  d = abs (BTopDf (q)) - 0.02;\n  z = dot (q.yz, sin (((q.z > 0.) ? 0.3 : -0.2) * pi + vec2 (0., 0.5 * pi)));\n  d = SmoothMax (d, - min (Length4 (max (abs (vec2 (q.x, q.y - 1.22)) -\n     vec2 (cSize.x - 0.25, 0.25) + 0.3, 0.)) - 0.3, max (PrRoundBox2Df (vec2 (q.y - 1.18, z),\n     vec2 (0.24, 1.6) - 0.05, 0.05), 0.03 - abs (abs (q.z + 0.08) - 0.87))), 0.02);\n  d = max (d, rSize.w - q.y);\n  DMINQ (idBtop);\n  q = p;\n  d = min (PrRoundBoxDf (q - vec3 (0., 0.7, 2.1), vec3 (0.35, 0.1, 0.02), 0.01),\n     PrRoundBoxDf (q - vec3 (0., vec2 (-0.06, 3.05)), vec3 (0.6, 0.1, 0.02), 0.01));\n  DMINQ (idGril);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (cSize.x - 0.95, -0.15, -4.25);\n  d = SmoothMax (PrRoundCylDf (q, 0.1, 0.02, 0.3), - PrCylDf (q - vec3 (0., 0., -0.1),\n     0.06, 0.3), 0.02);\n  DMINQ (idEx);\n  q = p;\n  q.x = abs (q.x) + 0.3;\n  q.z = abs (q.z + wbMid);\n  q -= wlBase;\n  d = PrCylDf (vec3 (abs (q.x) - 0.15, q.zy), 0.06, 0.12);\n  d = min (d, PrCylDf (vec3 (q.z, abs (q.y) - 0.07, q.x), 0.04, 0.12));\n  DMINQ (idAx);\n  q.x -= 0.3;\n  if (p.z > 0.) q.xz = Rot2D (q.xz, - strRot * sign (p.x));\n  q.yz = Rot2D (q.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n  r = length (q.yz);\n  d = max (length (max (vec2 (r - wlRad, abs (q.x) - 0.14), 0.)) - 0.05, 0.4 - r);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (7. * atan (q.z, - q.y) / (2. * pi) + 0.5) / 7.);\n  d = min (d, max (length (vec2 (q.x - 0.05, abs (q.z) - 0.03)) - 0.03, abs (q.y + 0.3) - 0.15));\n  d = min (d, SmoothMax (r - 0.18, abs (q.x) - 0.15, 0.02));\n  DMINQ (idWhl);\n  return dMin;\n}\n\nfloat CarInDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.x = abs (q.x);\n  q -= litFPos;\n  d = SmoothMax (PrCylDf (q, litFRad - 0.01, litFRad),\n     - PrSphDf (q - vec3 (0., 0., litFRad), 0.1), 0.02);\n  DMINQ (idLitF);\n  q = p;\n  q.x = abs (abs (q.x) - cSize.x + 0.48);\n  q -= vec3 (0.13, 0.25, - cSize.z + 0.3);\n  d = PrRoundCylDf (q, 0.06, 0.03, 0.27);\n  DMINQ (idLitR);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.72, 0.2), -0.1 * pi);\n  d = max (PrRoundBoxDf (q, vec3 (0.9, 0.15, 0.1), 0.1),\n     - PrRoundBoxDf (q - vec3 (0., 0., -0.22), vec3 (0.9, 0.15, 0.1), 0.01));\n  d = max (d, - PrCylDf (vec3 (abs (q.x - dashClk.x) - dashClk.y, q.y, q.z + 0.05), 0.1, 0.1));\n  d = max (d, - PrCylDf (vec3 (abs (q.x - dashClk.z) - dashClk.w, q.y, q.z + 0.05), 0.05, 0.1));\n  DMINQ (idDash);\n  q -= vec3 (-0.47, -0.05, -0.2);\n  d = PrRoundCylDf (q, 0.03, 0.03, 0.45);\n  DMINQ (idCon);\n  q.z -= -0.45;\n  q.xy = Rot2D (q.xy, -8. * strRot + pi / 6.);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  d = PrTorusDf (q, 0.025, 0.35);\n  DMINQ (idStrWhl);\n  q.x += 0.17;\n  d = PrCylDf (q.yzx, 0.02, 0.17);\n  DMINQ (idCon);\n  q = p;\n  q.z -= -0.3;\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.08, 0.1), 0.05);\n  q.yz = Rot2D (q.yz, 0.1 * pi);\n  q.y -= 0.3;\n  d = min (d, PrCylDf (q.xzy, 0.03, 0.2));\n  DMINQ (idCon);\n  q.y -= 0.2;\n  d = PrSphDf (q, 0.05);\n  DMINQ (idCon);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.1, -1.1);\n  d = PrRoundBoxDf (q, vec3 (0.35, 0.1, 0.45), 0.05);\n  q.yz = Rot2D (q.yz - vec2 (0.4, -0.45), 0.1 * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.35, 0.45, 0.06), 0.05));\n  q.y -= 0.6;\n  d = min (d, PrRoundCylDf (q, 0.17, 0.05, 0.04));\n  q = p;\n  q.yz -= vec2 (0.3, -2.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (1., 0.1, 0.2), 0.05));\n  DMINQ (idSeat);\n  q = p;\n  q.z -= -1.;\n  d = PrCylDf (q, 0.1, 1.5);\n  DMINQ (idSeat);\n  q = p;\n  q.y -= 1.4;\n  d = PrRoundBoxDf (q, vec3 (0.2, 0.05, 0.), 0.01);\n  DMINQ (idMir);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z + wbMid);\n  d = PrRoundBoxDf (p - vec3 (0., 0.5, -0.7), vec3 (1.5, 1.2, 4.), 0.01);\n  if (isSh || d < 0.1) {\n    dMin = CarExDf (p, dstFar);\n    dMin = CarInDf (p, dMin);\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjDfShEx (vec3 p)\n{\n  float dMin;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z + wbMid);\n  dMin = CarExDf (p, dstFar);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadowEx (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDfShEx (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 c;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z + wbMid);\n  q = p;\n  q.z -= rSize.z;\n  d = max (BTopDf (q), rSize.w - q.y);\n  DMINTR (idWin);\n  q = p;\n  q.x = abs (q.x);\n  c = vec2 (2.5 * cSize.x, 4. * cSize.y);\n  d = max (PrCylDf (q - litFPos - vec3 (0., 0., 0.25), litFRad, 0.3),\n     SmoothMax (length (q.yz - vec2 (-3. * cSize.y, clamp (q.z, - (cSize.z - c.y),\n     cSize.z - c.y))) - c.y, length (q.xz - vec2 (-1.5 * cSize.x, clamp (q.z,\n     - (cSize.z - c.x), cSize.z - c.x))) - c.x, 0.1));\n  DMINTR (idLitF);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SymCol (vec2 s)\n{\n  return abs (Rot2D (s, 2. * pi * floor (7. * atan (s.y, - s.x) / (2. * pi) + 0.5) / 7.).x +\n     0.1) - 0.02;\n}\n\nvec4 CarCol (out vec2 vf, out bool inCab, out bool isMet, out float refFac)\n{\n  vec4 col4, col4B, col4In, col4D, col4Ls, col4Ds, col4HiRf;\n  vec2 w;\n  float r, s, a;\n  bool loRf;\n  col4B = vec4 (1., 1., 0.1, 0.1);\n  col4In = vec4 (0.6, 0.5, 0.4, 0.05);\n  col4D = vec4 (1., 0.7, 0.1, 0.1);\n  col4Ls = vec4 (0.9, 0.9, 0.9, 0.2);\n  col4Ds = vec4 (0.4, 0.4, 0.4, 0.05);\n  col4HiRf = vec4 (0.9, 0.9, 0.9, 0.);\n  vf = vec2 (0.);\n  loRf = false;\n  inCab = false;\n  if (idObj <= idWhl) {\n    if (idObj == idBod || idObj == idBtop) {\n      col4 = col4B;\n      s = 1.;\n      if (idObj == idBod) {\n        if (length (qHit.yz - vec2 (-0.13, -2.9)) > 0.62 && qHit.y > -0.15 &&\n           max (abs (qHit.x) - inSize.x, abs (qHit.z + 1.15) - (inSize.y + 0.3 -\n           ((qHit.z > 0.) ? 0.3 : 0.15) * qHit.x * qHit.x)) < 0.13) {\n          col4 = col4In;\n          inCab = true;\n        } else {\n          if (qHit.y > -0.23) {\n            r = length (vec2 (qHit.y - wlBase.y + 0.03, abs (qHit.z + wbMid) - wlBase.z));\n            if (r < 0.64) col4 = col4Ds;\n            else if (r < 0.79 || qHit.y < -0.11 && abs (qHit.z + wbMid) < 1.7) col4 = col4D;\n            loRf = true;\n          }\n          if (qHit.y > 0.) {\n            s = min (PrRoundBox2Df (qHit.xz - vec2 (0., -3.8),\n               vec2 (0.7, 0.4), 0.1), PrRoundBox2Df (vec2 (qHit.x, qHit.z - 2.),\n               vec2 (0.7 - 0.15 * (qHit.z - 1.2) * (qHit.z - 1.2), 0.8), 0.1));\n            col4 = mix (col4HiRf, col4, step (0., PrRoundBox2Df (qHit.yz - vec2 (0.7, -1.9),\n               vec2 (0.02, 0.07), 0.02)));\n            w = vec2 (qHit.y - 0.4, qHit.z - 0.1);\n            if (length (w) < 0.2) col4 = mix (col4HiRf, col4, smoothstep (0., 0.01, SymCol (w)));\n            w = vec2 (qHit.x, (qHit.z < 0.) ? qHit.y - 0.2 : qHit.z - 1.9).yx;\n            if (length (w) < 0.3) col4 = mix (col4HiRf, col4, smoothstep (0., 0.01,\n               SymCol (0.8 * w)));\n          }\n          if (qHit.z > cSize.z - 1.35) col4 = col4HiRf;\n        }\n        s = min (s, abs (PrRoundBox2Df (qHit.yz - dSize.xy, dSize.zw - 0.2, 0.2)));\n      } else if (idObj == idBtop) {\n        if (BTopDf (qHit) < 0.) {\n          col4 = col4In;\n          inCab = true;\n        } else {\n          col4 = mix (col4HiRf, col4, smoothstep (0., 0.01, Length4 (max (abs (vec2 (qHit.x,\n             qHit.y - 1.22)) - vec2 (cSize.x - 0.25, 0.25) + 0.3, 0.)) - 0.32));\n          loRf = true;\n        }\n        s = PrRoundBox2Df (qHit.xz - vec2 (0., 0.4), vec2 (0.6, 0.2), 0.1);\n      }\n      col4.rgb *= 0.85 + 0.15 * smoothstep (0., 0.01, abs (s));\n      vf = inCab ? vec2 (32., 0.2) : vec2 (64., 0.02);\n    } else if (idObj == idGril) {\n      col4 = col4Ls;\n      vf = vec2 (128., 0.5);\n    } else if (idObj == idEx) {\n      col4 = (length (qHit.xy) < 0.08) ? col4Ds : col4HiRf;\n    } else if (idObj == idAx) {\n      col4 = col4Ds;\n    } else if (idObj == idWhl) {\n      r = length (qHit.yz);\n      a = atan (qHit.z, - qHit.y) / (2. * pi);\n      if (r > 0.44) col4 = vec4 (0.2, 0.2, 0.2, 0.) * (1. - 0.5 * step (0.5, r) *\n         abs (step (0., cos (32. * pi * qHit.x)) - step (0.5, mod (64. * a + 0.5, 1.))));\n      else if (r > 0.16) col4 = col4Ls * (0.7 + 0.3 * step (-0.1, qHit.x));\n      else col4 = mix (col4D, col4HiRf, step (0.02, abs (Rot2D (qHit.yz,\n         2. * pi * floor (7. * a + 0.5) / 7.).x + 0.1)));\n    }\n  } else {\n    if (idObj == idLitF) {\n      col4 = (length (qHit.xy) > 0.1) ? col4B : col4HiRf;\n    } else if (idObj == idLitR) {\n      col4 = (length (qHit.xy) < 0.06) ? vec4 (0.8, 0.2, 0.2, 0.1) : col4HiRf;\n    } else if (idObj == idDash) {\n      col4 = (abs (qHit.y) < 0.11 && qHit.z > 0.) ? vec4 (1., 1., 1., 0.05) *\n         (0.7 + 0.3 * step (0., min (min (abs (abs (qHit.x - dashClk.x) - dashClk.y),\n         abs (qHit.x - dashClk.z) - dashClk.w), abs (qHit.y)) - 0.01)) : col4In;\n      vf = vec2 (32., 0.1);\n    } else if (idObj == idSeat) {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.05) * (0.95 + 0.05 * cos (128. * qHit.x));\n      vf = vec2 (32., 0.5);\n    } else if (idObj == idCon) {\n      col4 = col4Ls;\n    } else if (idObj == idStrWhl) {\n      col4 = col4D * (0.7 + 0.3 * smoothstep (0.45, 0.55, mod (36. *\n         atan (qHit.y, - qHit.x) / (2. * pi) + 0.5, 1.)));\n    } else if (idObj == idMir) {\n      col4 = (qHit.z < 0.) ? col4HiRf : col4Ls;\n    }\n  }\n  if (idObj >= idDash && idObj <= idMir) inCab = true;\n  isMet = ! (inCab || idObj == idWhl && r > 0.44);\n  refFac = 0.;\n  if (col4 == col4HiRf) refFac = 0.9;\n  else if (loRf) refFac = 0.1;\n  return col4;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  vec2 vf;\n  float f, ff;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  ff = 1. - smoothstep (0.3, 0.5, dstGrnd / dstFar);\n  ro.x += 2.5;\n  if (abs (ro.x) < 5.) {\n    f = smoothstep (0.38, 0.4, mod (0.3 * ro.z, 1.) * (1. - smoothstep (0.08, 0.1,\n       abs (abs (ro.x) - 4.6))));\n    vf = vec2 (16., 2. * (1. - 0.9 * f));\n    col = mix (vec3 (0.2) * (0.5 + 0.5 * Fbm2 (64. * ro.xz)), vec3 (0.8), f);\n  } else {\n    vn = RippleNorm (0.5 * ro.zx, vn, 4. * ff);\n    vf = vec2 (4., 1.);\n    col = 0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  }\n  if (vf.x > 0. && ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, col, colR, vn;\n  vec2 vf;\n  float dstObj, dstTrObj, dstGrnd, nDotL, refFac, sh;\n  bool inCab, isMet;\n  roo = ro;\n  rdo = rd;\n  cSize = wlBase + vec3 (0.2, 1., 2.3);\n  rSize = vec4 (cSize.x - 0.09, cSize.y, -1.3, 0.88);\n  dSize = vec4 (0.6, -1.27, 0.6, 0.97);\n  dashClk = vec4 (-0.47, 0.25, 0.1, 0.1);\n  inSize = vec2 (0.95, 1.5);\n  wSlope = vec2 (3., 5.);\n  litFPos = vec3 (cSize.x - 0.4, 0.3, cSize.z - 1.95);\n  litFRad = 0.12;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = CarCol (vf, inCab, isMet, refFac);\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, sunDir), 0.);\n    if (isMet) {\n      nDotL *= nDotL;\n      nDotL *= nDotL;\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * nDotL) + col4.a * step (0.95, sh) *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    if (refFac > 0.) rd = reflect (rd, vn);\n  }\n  if (dstObj >= dstFar || refFac > 0.) {\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      sh = (dstGrnd < dstFar) ? ObjSShadowEx (ro + 0.01 * vn, sunDir) : 1.;\n      colR = GrndCol (vec3 (ro.xz + carPos.xz, 0.).xzy, rd, dstGrnd, sh);\n      colR = mix (colR, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else {\n      colR = SkyBgCol (ro, rd);\n    }\n    col = (refFac > 0.) ? mix (col, 0.9 * colR, refFac) : colR;\n  }\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rdo;\n    vn = TrObjNf (ro);\n    if (idTrObj == idWin) col *= vec3 (0.9, 1., 0.9);\n    rd = reflect (rdo, vn);\n    col = mix (col, SkyBgCol (ro, rd), 0.2 + 0.8 * pow (1. - abs (dot (vn, rdo)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (0);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  wlBase.y = -0.1;\n  wbMid = 0.9;\n  stDat = Loadv4 (2);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  carPos.y += wlRad + 0.13;\n  az = pi;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2.2 * pi * mPtr.x;\n    el -= 0.8 * pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    az += 1.5 * pi * SmoothBump (0.25, 0.75, 0.25, mod (t, 1.)) * sign (t - 1.);\n    el += 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.03 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -16.);\n  ro.xz += Rot2D (vec2 (0., wlBase.z + wbMid - 0.5), - carRot);\n  ro.y += carPos.y;\n  zmFac = 5.5;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  return sqrt (sqrt (dot (p, p)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Gold Turbo\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 carPos, wlBase;\n  vec2 iFrag, wlRot, w;\n  float carRot, cRotN, strRot, wlRad, rTurn, spd, tc, nStep;\n  int pxId;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 3) discard;\n  init = (iFrame <= 5);\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlBase = vec3 (1., 0.5, 2.2);\n    wlRot = vec2 (0.);\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    stDat = Loadv4 (2);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n  }\n  wlRad = wlBase.y;\n  ++ nStep;\n  tc = mod (0.003 * nStep, 4.);\n  strRot = 0.1 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n     sign (tc - 2.);\n  spd = 0.03;\n  w = vec2 (1.);\n  if (abs (strRot) > 1e-4) {\n    cRotN = carRot - strRot * spd / pi;\n    rTurn = wlBase.z / asin (0.5 * strRot);\n    carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n    carRot = cRotN;\n    w += vec2 (-1., 1.) * wlBase.x / rTurn;\n  } else {\n    carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n  }\n  wlRot += w * spd / wlRad;\n  if      (pxId == 0) stDat = vec4 (carPos, carRot);\n  else if (pxId == 1) stDat = vec4 (wlBase, 0.);\n  else if (pxId == 2) stDat = vec4 (nStep, strRot, wlRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3zS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1386, 1386, 1409, 1409, 1704], [1706, 1706, 1742, 1742, 5315], [5317, 5317, 5353, 5353, 7304], [7306, 7306, 7328, 7328, 7618], [7620, 7620, 7646, 7646, 7783], [7785, 7785, 7818, 7818, 8066], [8068, 8068, 8089, 8089, 8344], [8346, 8346, 8383, 8383, 8631], [8633, 8633, 8672, 8672, 8924], [8926, 8926, 8950, 8950, 9556], [9558, 9558, 9593, 9593, 9842], [9844, 9844, 9867, 9867, 10124], [10126, 10126, 10149, 10149, 10262], [10264, 10264, 10341, 10341, 14778], [14780, 14780, 14805, 14805, 15224], [15226, 15226, 15270, 15270, 15459], [15461, 15461, 15519, 15519, 16286], [16288, 16288, 16322, 16322, 17079], [17081, 17081, 17116, 17116, 19028], [19030, 19030, 19086, 19086, 20613], [20615, 20615, 20661, 20661, 20708], [20710, 20710, 20757, 20757, 20804], [20806, 20806, 20839, 20839, 20866], [20868, 20868, 20910, 20910, 20961], [20963, 20963, 21020, 21020, 21096], [21098, 21098, 21144, 21144, 21201], [21203, 21203, 21227, 21227, 21274], [21276, 21276, 21321, 21321, 21424], [21426, 21426, 21471, 21471, 21509], [21511, 21511, 21568, 21568, 21651], [21653, 21653, 21689, 21689, 21895], [21897, 21897, 21927, 21927, 22040], [22074, 22074, 22098, 22098, 22151], [22153, 22153, 22177, 22177, 22307], [22309, 22309, 22334, 22334, 22480], [22482, 22482, 22507, 22507, 22693], [22695, 22695, 22717, 22717, 22871], [22873, 22873, 22894, 22894, 23049], [23051, 23051, 23080, 23080, 23292], [23294, 23294, 23333, 23333, 23513], [23607, 23607, 23632, 23632, 23755]], "test": "untested"}
{"id": "3tGBWV", "name": "Extruded Octagon Diamond Truchet", "author": "Shane", "description": "An extruded octagon diamond grid-based blobby Truchet pattern.", "tags": ["blob", "diamond", "truchet", "pattern", "extrude", "octagon"], "likes": 41, "viewed": 752, "published": 3, "date": "1616160336", "time_retrieved": "2024-07-30T19:31:54.159916", "image_code": "/*\n\n    Extruded Octagon Diamond Truchet\n    --------------------------------\n    \n    This is an extruded octagon diamond blobby Truchet that features all tile\n    combinations. The template itself has been repurposed from my recent extruded\n    Truchet example.\n    \n    The Truchet pattern was coded up pretty quickly, so there'd be more efficient \n    ways to go about it, like encoding the 2D field into a texture and reading from \n    that, but this was easier. :) \n    \n    Other versions of the octagon diamond Truchet have already been posted, so \n    the blobby version is here mainly to complete the set. I like the pattern \n    because it has a weird sea creature feel to it. It'd be cool to see other dual \n    multitile blobby Truchet patterns, if anyone feels up to it.\n    \n\n\n    References:\n    \n    // Fizzer put together a Truchet pattern based on an octagonal diamond grid a\n    // while back. The Truchet here is a different kind (blobs instead of arcs), but \n    // is essentially based on the same premise.\n    4.8^2 Truchet - Fizzer\n    https://www.shadertoy.com/view/MlyBRG\n    \n    // An extruded ocatagon diamond blobby Truchet pattern using 2D techniques.\n\tFaux Layered Extrusion - Shane\n    https://www.shadertoy.com/view/Wsc3Ds\n\n\n*/\n\n\n// Subtle textured lines.\n#define LINES\n\n// Split the individual tile blocks at the borders.\n//#define SPLIT_TILES\n\n// Show the tile background.\n//#define SHOW_TILES\n\n// Bevel the extruded pattern.\n#define BEVEL\n\n\n// Object ID: Either the back plane or the metaballs.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// The ocatagonal-dimond grid boundaries.\nvec4 gridField(vec2 q){\n    \n    // Offsetting the diamond tiles by half a unit. \n    vec2 p = q - .5;\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n\n    \n    const float sqrt2 = sqrt(2.);\n    \n    // Side length. Due to the symmetry, it's the side length of both the\n    // octagon and diamond.\n    float s = 1./(1. + sqrt2);\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = (abs(p.x) + abs(p.y))/sqrt2 - s/2.;\n    \n    float d = 1e5;\n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile.\n    if(dia<.0){\n        \n        d = dia;\n        \n        ip += .5;\n        \n    }\n    else {\n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = q;\n        ip = floor(p) + .5;\n        p -= ip; // Equivalent to: fract(p) - .5;\n        \n        \n        \n        float oct = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n        d = oct;\n    } \n    \n    return vec4(d, ip, dia);\n    \n}\n \n\n// Adx's considerably more concise version of Fizzer's circle solver.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n\n// Truchet distance formula. It's set to circles, but you could try\n// the octagonal distance metric, if you wanted.\nfloat distT(vec2 p){\n    \n    return length(p);\n    \n    /*\n    // Straight and curved.\n    p = abs(p);\n    return max(length(p) - .04, max((p.x + p.y)*.7071, max(p.x, p.y)));\n    */\n    \n    /*\n    // 16 sided, for that straight edged look.\n    p = abs(p);\n    float d = max(max(p.x, p.y), (p.x + p.y)*.7071);\n    p *= rot2(3.14159/8.);\n    return max(d, max(max(p.x, p.y), (p.x + p.y)*.7071));\n    */\n\n}\n\n\n// A blobby octagonal diamond structure. Test to see whether the pixel is inside\n// a diamond tile or an octagonal tile, then render the appropriate tile.\n// A diamond tile will have two circles cut out at opposite ends, and an octagon\n// will have various circles cut out at the correct positions. It's all pretty simple.\n// However blobby Truchet tiles on square-based grids need to have their distances\n// flipped on alternating checkered tiles. It slightly complicates the code, but\n// I'm sure it's nothing that people can't handle. :)\n//\n// Uncomment the \"SHOW_GRID\" define and refer to imagery get a better idea.\nvec3 distFieldT(vec2 q){\n    \n    \n    float d = 1e5;\n    \n    // Offsetting the diamond tiles by half a unit.\n    vec2 p = q - .5;\n    \n    // Tile ID and local coordinates.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    \n    const float sqrt2 = sqrt(2.);\n    \n    // Side length. Due to the symmetry, it's the side length of both the\n    // octagon and diamond.\n    float s = 1./(1. + sqrt2);\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = (abs(p.x) + abs(p.y))/sqrt2 - s/2.;\n    \n   \n    \n    \n    float shape = 1e5;\n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile. In case it isn't obvious, you could test\n    // for an octagonal hit too, but a diamond is easier.\n    if(dia<.0){\n        \n        \n        // Rotate random tiles.\n        float rnd = hash21(ip);\n        if(rnd<.5) p = rot2(3.14159/2.)*p;\n        \n        // Chop out two circles on opposite corners. Use the define to display\n        // the grid and refer to the imagery.\n        p.y = abs(p.y);\n        d = min(d, distT(p - vec2(0, s/sqrt2)) - s/2.);\n        \n        // Flip the distances on alternating checkered tiles.\n        float ch = mod(ip.x + ip.y, 2.);\n        if(ch<.5) d = -d;\n        \n        // Flip the distances on random tiles as well.\n        if(rnd<.5) d = -d;\n        \n        // Moving the tile ID away from the center of the octagonal tile\n        // to the center of the diamond tile.\n        ip += .5;\n        \n        shape = dia;\n        \n    }\n    else {\n    \n       \n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = q;\n        vec2 ip = floor(p) + .5;\n        p -= ip; // Equivalent to: fract(p) - .5;\n        \n        shape = max((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n        \n        // Rotate random tiles. You don't really the extra addition, but I \n        // figured it might mix things up more... maybe. :)\n        float rnd = hash21(ip + vec2(.11, .41));\n        float rnd2 = hash21(ip + vec2(.17, .31));\n        \n        if(rnd<.5) p = rot2(3.14159/4.)*p;\n        \n        if(rnd2<.333){\n            // Chop out four circles on opposite corners. Use the define to display\n            // the grid and refer to the imagery. \n        \n            // Four small circles.\n            d = min(d, distT(p - vec2(-.5, s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(s/2., .5)) - s/2.);\n            d = min(d, distT(p - vec2(.5, -s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(-s/2., -.5)) - s/2.);\n        }\n        else if(rnd2<.666){\n            \n            // Two large arcs with two small circle cutouts.\n            \n            // Random rotation.\n            float rnd3 = hash21(ip + vec2(.27, .53));\n            p = rot2(3.14159/2.*floor(rnd3*64.))*p;\n            \n            \n            vec2 o; float r;\n            solveCircle(vec2(-.5, 0), vec2(sqrt2/4.), o, r); \n            // Top left;\n            d = min(d, distT(p - o) - r);\n            d = max(d, -(distT(p - vec2(-s/2., .5)) - s/2.));\n            \n            // Bottom right.\n            d = min(d, distT(p + o) - r);\n            d = max(d, -(distT(p - vec2(s/2., -.5)) - s/2.));\n            \n            \n        \n        }\n        else {\n        \n            // One large arc with three small circle cutouts.\n        \n            // Random rotation.\n            float rnd4 = hash21(ip + vec2(.34, .67));\n            p = rot2(3.14159/2.*floor(rnd4*64.))*p;\n            \n            vec2 o; float r;\n            solveCircle(vec2(-.5, 0), vec2(sqrt2/4.), o, r); \n            // Top left;\n            d = min(d, distT(p - o) - r);\n            d = max(d, -(distT(p - vec2(-s/2., .5)) - s/2.));\n            \n            \n            d = min(d, distT(p - vec2(.5, -s/2.)) - s/2.);\n            d = min(d, distT(p - vec2(-s/2., -.5)) - s/2.);\n            \n            \n        \n        }\n        \n        // Tile flipping: As an aside, I've never been able to logically \n        // combine the two following lines, but surely there's a way?\n        // Probably a question for Fabrice Neyret to answer. :)\n        \n        // Flip the distances on alternating checkered tiles.\n        if(mod(ip.x + ip.y, 2.)>.5)  d = -d;\n        \n        \n        // Flip the distances on random tiles as well.\n        if(rnd<.5) d = -d;\n       \n    }\n    \n    \n    #ifdef SPLIT_TILES\n    d = max(d - .03, -(abs(shape) - .01)) + .03;\n    #else\n    #ifdef SHOW_TILES\n    d = max(d, -(abs(shape) - .01));\n    #endif\n    #endif\n    \n    d -= .03; // Extra width.\n     \n    \n    \n    \n    //d = min(d + .05, abs(d + .02) - .05); // Truchet border.\n    \n    //d = mix(max(d - .03, -(abs(shape) - .01)), d - .03, smoothstep(-.1, .1, sin(iTime)));\n    \n    // Return the distance and center tile ID.\n    return vec3(d, ip);\n    \n}\n\n// Local stud position. Bad global hack, but it was a\n// last minute addition. :)\nvec2 stdP;\n \n// Distance function.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // Octagon diamond Truchet object.\n    vec3 o3 = distFieldT(p.xy);\n    // Extruding the 2D field above.\n    float obj = max(o3.x, abs(p.z) - .125);\n    #ifdef BEVEL\n    obj -= smoothstep(.03, .1, -o3.x)*.05;// + obj*.5;\n    #endif\n    \n    // The cylindrical beacon like objects. I added them in out of sheer\n    // bordom. I guess they're anaolgous to eyes, or something. :)\n    float sc = 1.;\n    vec2 q = p.xy;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*sc;\n    \n    // Placing cylinders on alternate octagon vertices.\n    const float s = 1./(1. + sqrt(2.));\n    vec2 ep = vec2(s/2., .5);\n    // Rotating alternate checkered octagons to align things.\n    if(mod(iq.x + iq.y, 2.)<.5) q = rot2(3.14159/4.)*q;\n    // Polar repetition.\n    float a = atan(q.x, q.y);    \n    a = (floor(a/6.2831*4.) + .5)/4.*6.2831;\n    ep = rot2(a)*ep;\n    stdP = q - ep; // Centered local beacon coordinates.\n    float cyl = length(stdP) - .06*sc;\n    \n    // The cylindrical beacon.\n    float beacon = max(cyl, abs(p.z) - .25);\n       \n\n     \n    // Object ID.\n    objID = fl<obj && fl<beacon? 0 : obj<beacon? 1 : 2;\n    \n    // )verall minimum distance.\n    return min(min(fl, obj), beacon);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 16; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = m(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2);\n    \n    // Rotating the camera about the XY plane, etc.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy;\n    \n \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        if(abs(d)<.001) break; // Surface hit.\n        t += d*.9; // Advance the overall distance closer to the surface.\n        \n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    // Saving the local beacon coordinates.\n    vec2 lStdP = stdP;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = .5; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n  \n     \n    // Smooth borders.\n    vec4 b2 = gridField(p.xy*5. + vec2(.5, 0));\n    float bord = abs(b2.x/5.) - .003;\n \n\n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif  \n\n    \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    float sf2 = dot(sin(p.xy*1.5 - cos(p.yx*3.)), vec2(.5));\n    vec4 col1 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col2 = mix(vec4(.4, .7, 1, 0), vec4(.3, .85, .95, 0), smoothstep(-.5, .5, sf2)*.5);\n    col1 = pow(col1, vec4(1.6));\n    col2 = mix(col1.zyxw, pow(col2, vec4(1.4)), .666);   \n    col1 = mix(col1, col1.xzyw*col1, smoothstep(.25, .75, sf2)*.5);\n    //col1 = mix(col1, col1.yxzw, smoothstep(.4, .8, sf3)*.5); \n\n\n    // Object color.\n    vec4 oCol;\n    \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n        // Blue background:\n\n        // Blue with some subtle lines.\n        oCol = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n\n        // Darken alternate checkers. \n        if(mod((b2.y) + (b2.z), 2.)<.5 && b2.w>0.) oCol *= .8;\n\n        // Using the Truchet pattern for some bottom edging.\n        float edge = distFieldT(p.xy).x;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, edge - .015))*.8);\n       \n        #ifdef SHOW_TILES\n        // Display the background grid pattern.\n        b2 = gridField(p.xy);\n        float bord2 = abs(b2.x) - .002;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord2 - .02)));\n        oCol = mix(oCol, mix(col1*.5 + .5, col2, .5), (1. - smoothstep(0., .01, bord2)));\n        #endif\n        \n\n  \n    }\n    else if(gObjID == 1){\n       \n        // 2D Truchet pattern.\n        d = distFieldT(p.xy).x;\n    \n\n        // Light sides with a dark edge. \n        oCol = mix(col1*.5 + .5, col2, .5);\n        oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, d + .03));\n        \n        // Colored gradient with subtle line pattern,\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        \n        // Darken alternate checkers. \n        if(mod((b2.y) + (b2.z), 2.)<.5 && b2.w>0.) fCol *= .8;\n        \n        // Apply the gradient face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .05));\n        \n        // If the cylindrical markers are included, render dark rings just under them.\n        float beacons = length(lStdP) - .14*sc;\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, beacons)));\n        \n    }\n    else {\n    \n        // The cylinder markers:\n        \n        // Color and apply patterns, edges, etc.\n\n        float beacons = length(lStdP);\n        oCol = mix(col1*.5 + .5, col2, .5);\n        \n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, abs(beacons - .103*sc) - .0035)));\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, beacons - .03*sc)));\n        \n    \n    }\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5 + glow/16.)*at*ao;\n    // Very metallic: Interesting, but ultimately, a bit much. :)\n    //c = oCol*oCol*1.5*(pow(df, 3.)*2.*sh + sp*sh*2. + .25)*at*ao;    \n      \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1545, 1578, 1600, 1600, 1658], [1660, 1688, 1709, 1709, 1772], [1775, 1817, 1840, 1898, 3069], [3073, 3293, 3351, 3351, 3437], [3440, 3557, 3577, 3577, 3962], [3965, 4585, 4609, 4609, 9667], [9764, 9786, 9802, 9826, 11041], [11043, 11234, 11286, 11403, 12718], [12721, 12873, 12908, 12908, 13303], [14110, 14110, 14145, 14211, 20287]], "test": "untested"}
{"id": "7dfGzB", "name": "Playing With 5.", "author": "Sp3cim4n", "description": "Learning Shader Magic", "tags": ["learning"], "likes": 1, "viewed": 237, "published": 3, "date": "1616151758", "time_retrieved": "2024-07-30T19:31:54.927864", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\n\nfloat Remap(float a, float b, float c, float d, float t)\n{\n    return (clamp(0., 1., (t - a) / (b - a))) * (d - c) + c;\n}\n\nvec3  RainbowBand(vec2 uv, vec2 p, float t, float t_col)\n{\n    uv -= p;\n\n    float x = uv.x;\n    float m = 0.1*sin(t * 2.+ x * 10.);\n    float y = uv.y - m;\n\n    float blur = Remap(-.8, .8, .0, .5, x);\n    blur = blur * blur * blur * blur;\n    float blur2 = Remap(-.8, .8, .5, .0, x);\n    blur2 = blur2 * blur2 * blur2 * blur2;\n    blur = blur + blur2;\n    \n    float mask = Rect(vec2(x,y), -.8, .8, -.05, .05, blur);\n    \n    vec3 color = vec3(1.,0.,0.);\n    float c_sin = sin(t_col + x * 10.);\n    float c_m = Remap(-1., 1., .5, 1., c_sin);\n    color = mix(color, vec3(.0,1.,0.) * c_m, smoothstep(-.4, .0, uv.x * .5));\n    color = mix(color, vec3(.0,0.,1.) * c_m, smoothstep(.0, .4, uv.x * .5));\n    color *= mask;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float x = uv.x;\n    float t = iTime;\n    float m = 0.1*sin(t * 2.+ x * 10.);\n    float y = uv.y - m;\n    \n    vec3 color = vec3(.0);\n    int base_band_count = 8; // INPUT, change this.\n    float frequency = 2.;\n    \n    float b = sin(t * frequency);\n    b = Remap(-1., 1., 1., float(base_band_count + 1), b);\n    int band_count = int(b);\n    \n    \n    float offset_y = float(band_count - 1) * .5;\n    for(int i = 0; i < band_count; i++)\n    {\n        float k = float(i) - offset_y;\n        color += RainbowBand(uv, vec2(.0, k * .15), t, t * k * 10.);\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 203], [205, 205, 288, 288, 414], [417, 417, 475, 475, 538], [540, 540, 598, 598, 1281], [1283, 1283, 1340, 1340, 2053]], "test": "untested"}
{"id": "sdfGzB", "name": "6. Better Smily Face", "author": "Sp3cim4n", "description": "Learning Shader Magic", "tags": ["learning", "smiley"], "likes": 3, "viewed": 263, "published": 3, "date": "1616151591", "time_retrieved": "2024-07-30T19:31:55.691821", "image_code": "\n#define S(a,b,t) smoothstep(a,b,t)\n#define Sat(x) clamp(x, 0., 1.)\n\nfloat Remap01(float a, float b, float t)\n{\n    return Sat((t - a)/(b - a));\n}\n\nfloat Remap(float a,float b,float c,float d,float t)\n{\n    return Sat((t - a)/(b - a)) * (d - c) + c;\n}\n\nvec2 Within(vec2 uv, vec4 rect)\n{\n    return (uv - rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Eye(vec2 uv)\n{\n    uv -= .5;\n    \n    float d = length(uv);\n    \n    vec4 irisColor = vec4(.3,.5,1.,1.);\n    vec4 col = mix(vec4(1.), irisColor, S(.1,.7,d) * 0.5 );\n    \n    col.rgb *= 1. - S(.45, .5, d) * .5 * Sat(-uv.y - uv.x);\n    col.rgb = mix(col.rgb, vec3(.0), S(.3,.28,d)); // Iris Outline\n    \n    irisColor.rgb *= 1. + S(.3, .05, d);\n    col.rgb = mix(col.rgb, irisColor.rgb, S(.28,.25,d));\n    \n    col.rgb = mix(col.rgb, vec3(.0), S(.16,.14,d));\n    \n    float highlight = S(.1, .09, length(uv-vec2(-.15,.15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08,.08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    col.a = S(.5, .48,d);\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv)\n{\n    uv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n\n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x * 2.;\n    \n    //circle\n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv-vec2(.0, .6));\n    vec3 toothColor = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothColor, S(.4, .37, td));\n    \n    td = length(uv+vec2(.0, .5));\n    vec3 tongueColor = vec3(1., .5, .5);\n    col.rgb = mix(col.rgb, tongueColor, S(.5, .2, td));\n    \n    return col;\n}\n\nvec4 Head(vec2 uv)\n{\n    vec4 col = vec4(.9,.65,.1,1.);\n    \n    float d = length(uv);\n    col.a = S(.5,.49,d);\n    \n    float edgeShade = Remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade * .3;\n    \n    col.rgb = mix(col.rgb, vec3(.6,.3,.1), S(.47,.48,d));\n    \n    float highLight = S(.41, .405, d);\n    highLight *= Remap(.41, .0, .75, 0., uv.y);\n    col.rgb = mix(col.rgb, vec3(1.), highLight);\n    \n    d = length(uv - vec2(.25,-.2));\n    float cheek = S(.2,.01,d) * .4;\n    cheek *= S(.17,.16, d);\n    col.rgb = mix(col.rgb, vec3(1.,.1,.1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv)\n{\n    vec4 col = vec4(0.);\n    \n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(Within(uv, vec4(.03, -.1, .37, .25)));\n    vec4 mouth = Mouth(Within(uv, vec4(-.3, -.4, .3, -.1)));\n    \n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    fragColor = Smiley(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 111, 111, 146], [148, 148, 202, 202, 251], [253, 253, 286, 286, 333], [335, 335, 354, 354, 1022], [1024, 1024, 1045, 1045, 1525], [1527, 1527, 1547, 1547, 2131], [2133, 2133, 2155, 2155, 2487], [2489, 2489, 2546, 2546, 2681]], "test": "untested"}
{"id": "fsX3zB", "name": "Colorful Background", "author": "asherwolfstein", "description": "Quite happy with this one :)", "tags": ["rain", "matrix"], "likes": 33, "viewed": 1317, "published": 3, "date": "1616118720", "time_retrieved": "2024-07-30T19:31:56.457773", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat text(vec2 fragCoord)\n{\n    vec2 uv = mod(fragCoord.xy, 16.)*.0625;\n    vec2 block = fragCoord*.0625 - uv;\n    uv = uv*.8+.1; // scale the letters up a bit\n    uv += floor(texture(iChannel1, block/iChannelResolution[1].xy + iTime * .002).xy * 16.); // randomize letters\n    uv *= .0625; // bring back into 0-1 range\n    uv.x = -uv.x; // flip letters horizontally\n    return texture(iChannel0, uv).r;\n}\n\nvec3 rain(vec2 fragCoord)\n{\n\tfragCoord.x -= mod(fragCoord.x, 16.);\n    //fragCoord.y -= mod(fragCoord.y, 16.);\n    \n    float offset=sin(fragCoord.x*15.);\n    float speed=cos(fragCoord.x*3.)*.3+.7;\n   \n    float y = fract(fragCoord.y/iResolution.y + iTime*speed + offset);\n    return vec3(random(vec2(offset)),random(vec2(offset)*y),random(vec2(offset)*speed)) / (y*5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(text(fragCoord)*rain(fragCoord),1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 96], [97, 97, 125, 125, 503], [505, 505, 532, 532, 877], [879, 879, 936, 936, 997]], "test": "untested"}
{"id": "7ssGW7", "name": "Springy Icosahedron", "author": "oneshade", "description": "More fun with springs! This time in 3D. Pull the vertices with the mouse.", "tags": ["3d", "simulation", "icosahedron", "physics", "spring", "softbody"], "likes": 39, "viewed": 710, "published": 3, "date": "1616113478", "time_retrieved": "2024-07-30T19:31:57.223725", "image_code": "Intersect iScene(in vec3 ro, in vec3 rd) {\n    Intersect scene = Intersect(false, -1.0, vec3(0.0), vec3(0.0));\n\n    // Intersect ground plane\n    float plane = iPlane(ro, rd, vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0));\n    if (plane > 0.0) {\n        scene.hit = true;\n        scene.dist = plane;\n        scene.pos = ro + rd * plane;\n        scene.nor = nPlane(scene.pos, vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0));\n    }\n\n    // Intersect vertices (joints)\n    for (int n=0; n < joints.length(); n++) {\n        vec3 joint = getJoint(n).pos;\n        float sphere = iSphere(ro, rd, joint, 0.15);\n        if (sphere > 0.0 && (scene.hit ? sphere < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = sphere;\n            scene.pos = ro + rd * sphere;\n            scene.nor = nSphere(scene.pos, joint, JOINT_SIZE);\n        }\n    }\n\n    // Intersect faces\n    for (int n=0; n < faces.length(); n++) {\n        vec3 a = getJoint(faces[n][0]).pos;\n        vec3 b = getJoint(faces[n][1]).pos;\n        vec3 c = getJoint(faces[n][2]).pos;\n        float triangle = iTriangle(ro, rd, a, b, c);\n        if (triangle > 0.0 && (scene.hit ? triangle < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = triangle;\n            scene.pos = ro + rd * triangle;\n            scene.nor = nTriangle(scene.pos, a, b, c);\n        }\n    }\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = CAMERA_POS;\n    vec3 rd = normalize(vec3(uv, -FOCAL_LENGTH));\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    Intersect scene = iScene(ro, rd);\n    if (scene.hit) {\n        scene.nor *= sign(dot(scene.nor, -rd)); // Flip the normal towards the camera\n        vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n        fragColor.rgb = vec3(max(0.0, mix(dot(scene.nor, light), dot(scene.nor, -rd), 0.5)));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Geometry (copied from https://people.sc.fsu.edu/~jburkardt/data/obj/icosahedron.obj)\nconst vec3[] joints = vec3[](\n    vec3(       0.0, -1.051462,  1.701302 ),\n    vec3(  1.701302,       0.0,  1.051462 ),\n    vec3(  1.701302,       0.0, -1.051462 ),\n    vec3( -1.701302,       0.0, -1.051462 ),\n    vec3( -1.701302,       0.0,  1.051462 ),\n    vec3( -1.051462,  1.701302,       0.0 ),\n    vec3(  1.051462,  1.701302,       0.0 ),\n    vec3(  1.051462, -1.701302,       0.0 ),\n    vec3( -1.051462, -1.701302,       0.0 ),\n    vec3(       0.0, -1.051462, -1.701302 ),\n    vec3(       0.0,  1.051462, -1.701302 ),\n    vec3(       0.0,  1.051462,  1.701302 )\n);\n\nconst ivec3[] faces = ivec3[](\n    ivec3(  1,  2,  6 ),\n    ivec3(  1,  7,  2 ),\n    ivec3(  3,  4,  5 ),\n    ivec3(  4,  3,  8 ),\n    ivec3(  6,  5, 11 ),\n    ivec3(  5,  6, 10 ),\n    ivec3(  9, 10,  2 ),\n    ivec3( 10,  9,  3 ),\n    ivec3(  7,  8,  9 ),\n    ivec3(  8,  7,  0 ),\n    ivec3( 11,  0,  1 ),\n    ivec3(  0, 11,  4 ),\n    ivec3(  6,  2, 10 ),\n    ivec3(  1,  6, 11 ),\n    ivec3(  3,  5, 10 ),\n    ivec3(  5,  4, 11 ),\n    ivec3(  2,  7,  9 ),\n    ivec3(  7,  1,  0 ),\n    ivec3(  3,  9,  8 ),\n    ivec3(  4,  8,  0 )\n);\n\n// Settings\n#define CAMERA_POS vec3(0.0, 0.0, 6.0)\n#define FOCAL_LENGTH 1.0\n\n#define JOINT_SIZE 0.15\n#define JOINT_MASS 10.0\n\n#define PLANE_HEIGHT -2.0\n\n#define GRAVITY 0.1\n#define SPRINGINESS 0.8\n#define DAMPING 0.99\n#define SPEED_LIMIT 0.5\n\n// Constants\n#define e 2.7182818285\n#define phi 1.6180339887\n#define pi 3.14159265359\n#define tau 6.28318530718\n#define rho 1.57079632679\n\n// Utilities\nstruct Joint {\n    vec3 pos;\n    vec3 vel;\n    float mass;\n};\n\n#define getJoint(id)                                  \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xyz, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xyz, \\\n          JOINT_MASS)                                 \\\n\n// Intersectors\nstruct Intersect {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n};\n\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 o, in vec3 n) {\n    float d = dot(rd, n);\n    if (d != 0.0) return dot(o - ro, n) / d;\n    return -1.0;\n}\n\n// Assumes the ray is outside the sphere\n// The other side is: (b - sqrt(discr)) / a * 0.5\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 o, in float r) {\n    ro -= o;\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) return -(sqrt(discr) + b) / a * 0.5;\n\n    return -1.0;\n}\n\n// Not as efficient as barycentric coordinates\n// BUT... it avoids having to introduce error margins\n// (though I guess square roots have errors of their own\n// so I guess its just a matter of elegance)\nfloat iTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a;\n    vec3 ba = normalize(b), cb = normalize(c - b), ac = normalize(-c);\n\n    vec3 n = cross(b, c);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = normalize(p), pb = normalize(p - b), pc = normalize(p - c);\n\n        if (min(dot(pa, ba), dot(pa, -ac)) > dot(ba, -ac) &&\n            min(dot(pb, cb), dot(pb, -ba)) > dot(cb, -ba)) {\n            return t;\n        }\n    }\n\n    return -1.0;\n}\n\n// Normals\nvec3 nPlane(in vec3 p, in vec3 o, in vec3 n) {\n    return n; // For some weak polymorphism :P\n}\n\nvec3 nSphere(in vec3 p, in vec3 o, in float r) {\n    return (p - o) / r;\n}\n\nvec3 nTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    return normalize(cross(b - a, c - a));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n\n    // Simulation\n    if (iFragCoord.x < joints.length() && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xyz = joints[iFragCoord.x] - vec3(0.0, 0.0, 1.0);\n            if (iFragCoord.y == 1) {\n                vec3 joint = joints[iFragCoord.x];\n                fragColor.xyz = vec3(normalize(joint.zx) * vec2(-0.05, 0.05), 0.0) + vec3(0.0, 0.2, -0.05);\n            }\n        }\n\n        if (iFrame > 0) {\n            Joint joint1 = getJoint(iFragCoord.x);\n            vec3 startPos1 = joints[iFragCoord.x];\n\n            // Accumulate gravitational and spring forces\n            vec3 totalForce = vec3(0.0, -GRAVITY, 0.0);\n            for (int i=0; i < joints.length(); i++) {\n                if (i == iFragCoord.x) continue;\n                Joint joint2 = getJoint(i);\n                vec3 startPos2 = joints[int(float(i) + 0.5)]; // Why +0.5?\n\n                float restLength = distance(startPos1, startPos2);\n                vec3 force = normalize(joint2.pos - joint1.pos);\n                float extension = restLength - distance(joint2.pos, joint1.pos);\n                force *= -SPRINGINESS * extension;\n\n                totalForce += force;\n            }\n\n            // Update\n            joint1.vel += totalForce / joint1.mass;\n            joint1.pos += joint1.vel;\n            joint1.pos.y = max(joint1.pos.y, JOINT_SIZE + PLANE_HEIGHT);\n            joint1.vel *= DAMPING * sign(joint1.pos.y - PLANE_HEIGHT - JOINT_SIZE);\n\n            // Attract to mouse\n            if (iMouse.z > 0.0) {\n                vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 ro = CAMERA_POS;\n                vec3 rd = normalize(vec3(mouse, -FOCAL_LENGTH));\n\n                bool closest = true;\n                vec3 targetPos = ro + rd * iPlane(ro, rd, joint1.pos, vec3(0.0, 0.0, 1.0));\n                float targetDist = distance(joint1.pos, targetPos);\n                for (int n=0; n < joints.length(); n++) {\n                    if (n == iFragCoord.x) continue;\n                    vec3 joint2 = getJoint(n).pos;\n                    vec3 targetPos2 = ro + rd * iPlane(ro, rd, joint2, vec3(0.0, 0.0, 1.0));\n                    if (distance(joint2, targetPos2) < targetDist) {\n                        closest = false;\n                        break;\n                    }\n                }\n\n                if (closest) {\n                    joint1.vel = (targetPos - joint1.pos) * 0.5;\n                    joint1.vel = normalize(joint1.vel) * min(length(joint1.vel), SPEED_LIMIT);\n                }\n            }\n\n            // Store\n            if (iFragCoord.y == 0) fragColor.xyz = joint1.pos;\n            if (iFragCoord.y == 1) fragColor.xyz = joint1.vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 1396], [1398, 1398, 1453, 1453, 1994]], "test": "untested"}
{"id": "fsf3RB", "name": "River Delta", "author": "wyatt", "description": "Attempt to make a river delta. I wouldn't call it a success, but it's kind of interesting at least. It evolves super slow. ", "tags": ["fluid", "automata"], "likes": 19, "viewed": 428, "published": 3, "date": "1616112027", "time_retrieved": "2024-07-30T19:31:58.014610", "image_code": "// Fork of \"Bubbles!!!\" by wyatt. https://shadertoy.com/view/sdfGWr\n// 2021-03-18 23:35:41\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-14 23:43:37\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 a = A(U), b = B(U);\n    Q = min(a.w,1.)*(0.5+0.5*sin(1.+vec4(1,2,3,4)));\n    Q+= min(.5*b.w,1.)*(0.5-0.5*sin(iTime*.1+vec4(1,2,3,4)));\n    //Q = 1.-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.1*Q.w*(a.w*(a.w-.5)+1.5*b.w)*u;  \n    }\n    Q.xy *= .99;\n    Q.xy += 10e-4*(vec2(-.1,0)+2.*normalize(U-vec2(1.01,0.5)*R));\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0);\n    //if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.x < 1.) Q *= 0.;\n    if (R.x-U.x<3.) Q.w = 60.*step(abs(U.y-0.5*R.y),10.); \n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.005*Q.w*(a.w+b.w)*u;  \n    }\n    Q.xy *= .9;\n    if (iMouse.z>0.) \n    Q.xy -= -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x,1.);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsf3zS", "name": "Temperatures", "author": "wyatt", "description": "Long ago Fabrice challenged my fluid models, telling me that I did not consider temperature. I'm still trying to live up to his expectations. ", "tags": ["fluid", "automata"], "likes": 15, "viewed": 564, "published": 3, "date": "1616107494", "time_retrieved": "2024-07-30T19:31:58.786546", "image_code": "// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-18 22:39:28\n\n// Display \nMain \n{\n    vec4 f = A(U);\n    Q = (.6-0.5*(sin(1.5*f.z+vec4(1,2,3,4))))*f.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = 0.03*a.w*(a.w*(a.w-.9)+.4*a.z);\n        dQ.xy -= f*u;\n        dQ.z  += a.w*f*dot(Q.xy-a.xy,u);\n    }\n    Q += dQ;\n    Q.y -= 5e-5;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(-.5*normalize(iMouse.xy-0.5*R),.1,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    \n    // Change boundary/initials:\n    \n    if (true) {\n    // Left-Right hot cold\n        if (iFrame < 1)Q = vec4(0,0,U.x/R.x,.3);\n        if (U.x    <18.) Q.z=mix(Q.z,0.,.01);\n        if (R.x-U.x<18.||(R.x-U.x<R.x*.3&&U.y<10.)) Q.z=mix(Q.z,10.,.01);\n    } else {\n    // Up down hot cold\n        if (iFrame < 1)Q = vec4(0,0,5.*step(U.y+30.*sin(10.*U.x/R.x*6.2),0.5*R.y),1.);\n        if (U.y    <18.) Q.z=mix(Q.z,5.,.01);\n        if (R.y-U.y<18.) Q.z=mix(Q.z,0.,.01);\n    }\n    \n    if (U.x < 2.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 2.||R.y-U.y<2.) Q.xyz *= 0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-2.5*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-2.5*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 2.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 2.||R.y-U.y<2.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n        \n    if (U.x < 2.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 2.||R.y-U.y<2.) Q.xy *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n        \n    if (U.x < 2.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 2.||R.y-U.y<2.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsf3RS", "name": "fork riff #1234-v3", "author": "jorge2017a1", "description": "fork riff #1234-v3", "tags": ["forkriff1234v3"], "likes": 1, "viewed": 254, "published": 3, "date": "1616102256", "time_retrieved": "2024-07-30T19:31:59.553496", "image_code": "//https://www.shadertoy.com/view/Mss3D7\n#define PI (3.141592653589793238462643383)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=((fragCoord.xy/iResolution.xy)-vec2(0.5,0.5))*2.0;\n\tuv.y=abs(uv.y)+0.5;\n    uv.x+=0.5*sin(iTime);\n\tfragColor=texture(iChannel0,fract(vec2((uv.x/uv.y)+(sin(iTime*PI*0.00125)*2.0),\n\t\t\t\t\t\t\t\t\t\t\t\t(1.0/uv.y)+(cos(iTime*PI*0.03)*2.0))))*uv.y;\n}\t\t\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//modificado por jorge flores p.  -18-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\n\n\n\n// nabr\n// https://www.shadertoy.com/view/WlSGWw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\nvec2 synthv2( float t)\n{\n// --------- SYNTH\n    int t1=int(t) % 4;\n    vec2 valor=mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1];\n    \n\tvec2 s = sin(t * mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1]) - .5;\n    vec2 s2 = tan(t * valor) - .5;\n    vec2 s3 = sin(t *valor*valor ) - .5;\n    \n    \n\tif(t<6.) // intro\n    {\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n        s+=s2;\n    }\n\telse \n    {\n\t\t\n        s *=  sin(s * mod(t*0.5, 8.) * 16.) ;\n        s=s*s2;\n    }   \n    return s;\n }  \n   \n\nvec2 m(float t)\n{\n\t\n   \n    vec2 s= synthv2( t);\n   \n   \n\t// --------- DRUMS(kick)\n    \n\tfloat tm = mod(t, .5);\n    float tm2 = mod(t, 1.8);\n    \n\tif(t<6.) tm = mod(t, 1.5); // intro\n\tfloat finetune = 1.8;\n    \n   \n    \n\t// kick\n\t\n    float k = (sin(80.0 * exp(-sin(tm * finetune) * 10.0)) * exp(-tm * 10.0));\n\tk *= cos(120.0 * exp(-tm * 2.0));\n    \n    \n    \n    // sub\n\tfloat kovt = (k - sin(tm * 580.) * exp(-tm * 1.5));\n\tkovt *= min(1., tm * 100.) * max(0., .5 - tm);\n\tkovt -= (.25 - asin(kovt * tm * 12.));\n\tk *= min(1., tm * 500.) * max(0., 1. - tm);\n\tk = 1.9 * (kovt + k);\n    \n    \n    \n\t\n    // -------- MASTER\n    \n\treturn (k + .4 * s ) * .25;\n}\n\n\n\nvec2 mainSound( in int samp,float time)\n{return m(time);}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 387]], "test": "untested"}
{"id": "7ss3W7", "name": "macOS glsl bug", "author": "FabriceNeyret2", "description": "You should see a gray gradient, switching from horizontal to vertical every second.\nOn Macos catalina it's not switching.", "tags": ["glsl", "bug"], "likes": 0, "viewed": 293, "published": 3, "date": "1616091532", "time_retrieved": "2024-07-30T19:32:00.319448", "image_code": "// MacOS bug version of   https://shadertoy.com/view/3sGfWm\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    \n    int k = (iFrame/60) % 2;\n    \n    U = k==1 ? U = U.yx : U;   // bug\n // U = k==1 ?     U.yx : U;   // no bug\n      \n    O = vec4( U.x ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ss3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 100, 100, 274]], "test": "untested"}
{"id": "wltfz2", "name": "Open End Tube (Test Tube) SDF", "author": "oneshade", "description": "Branchless and exact test tube SDF without trig.", "tags": ["3d", "raymarching", "sdf", "exact", "openendtube", "testtube", "notrig"], "likes": 4, "viewed": 132, "published": 3, "date": "1616087697", "time_retrieved": "2024-07-30T19:32:01.097368", "image_code": "// a: position of the tube opening\n// b: position of the tube base\n// r: tube radius\n// t: tube thickness\nfloat sdHalfTube(in vec3 p, in vec3 a, in vec3 b, in float r, in float t) {\n     vec3 pa = p - a, ba = b - a;\n     float h = length(ba), hh = 0.5 * h;\n     vec2 p2 = vec2(length(pa - ba * dot(pa, ba) / dot(ba, ba)), dot(pa, ba) / h);\n     float tube = length(vec2(p2.x - r, max(0.0, abs(p2.y - hh) - hh))) - t;\n     float base = max(p2.y, abs(length(p2) - r) - t);\n     return mix(base, tube, step(0.0, p2.y));\n}\n\nvec2 mapScene(in vec3 p) {\n    float t1 = iTime * 0.75, t2 = iTime * 1.25, t3 = iTime * 1.5;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(c3, 0.25 + 0.75 * s2, c1) * 2.0;\n    vec3 b = vec3(c2, 0.25 + 0.75 * s1, s3) * 2.0;\n    float r = 0.75 + 0.375 * sin(iTime);\n    float t = 0.125 + 0.0625 * cos(iTime);\n\n    float tube = sdHalfTube(p, a, b, r, t);\n    float da = length(p - a) - 0.125;\n    float db = length(p - b) - 0.125;\n\n    return tube < min(da, db) ? vec2(tube, 0) : da < db ? vec2(da, 1) : vec2(db, 2);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            int id = int(d.y);\n\n            float diff = sqrt(max(0.0, dot(-rd, n)));\n            if (id == 0) {\n                fragColor.rgb = vec3(diff);\n            }\n\n            if (id == 1) {\n                fragColor.rgb = vec3(0.0, 0.0, diff);\n            }\n\n            if (id == 2) {\n                fragColor.rgb = vec3(diff, 0.0, 0.0);\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (t < 20.0 ? tPlane < t : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= exp(-mapScene(iPlane).x);\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 106, 181, 181, 518], [520, 520, 546, 546, 1123], [1125, 1125, 1152, 1152, 1411], [1413, 1413, 1468, 1468, 3766]], "test": "untested"}
{"id": "fdsGD7", "name": "fractal circulo", "author": "jorge2017a1", "description": "fractal circulo", "tags": ["fractalcirculo"], "likes": 2, "viewed": 277, "published": 3, "date": "1616079758", "time_retrieved": "2024-07-30T19:32:01.867309", "image_code": "\n//por jorge2017a1-\n\n//referencia\n//https://www.shadertoy.com/view/lsfGRS\n// T-circle-  Created by gleurop in 2013-07-04\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nfloat fractalcirculos3d(vec3 p)\n{\nfloat d = 1.0;\n\tfloat s = 1.0;\n    \n\tfor (int i = 0; i < 3; i++) {\n\t\tp = abs(p - s);\n\t\ts *= 0.5;\n\t\t\n        \n        float dc1= sdCylinderXZ(  p, vec2(s) );\n        d = min(d, dc1);\n\t}\n    return d;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n   p= rotate_x(p, radians(sin(iTime*20.0)));\n   p= rotate_z(p, radians(cos(iTime*20.0+3.141516) ));\n   p= rotate_y(p, radians(iTime*20.0+3.141516));\n\t\n\t float fc1= fractalcirculos3d(p);\n    res =opU3(res, vec3(fc1,1.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return vec3(dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    /*\n    vec3 ro=vec3(1.0,1.5,-5.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    */\n    \n    \n     /*\n    vec3 ro=vec3(1.0,1.5,-5.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    */\n\n    //////\n    \n    // \"Look At\" position.\n    vec3 lk = vec3(0, 1, 0);//vec3(0, -.25, iTime);  \n    // Ray origin.\n    vec3 ro = lk + vec3(cos(iTime)*4., 2, sin(iTime)*4.); \n \n    // Light positioning.\n    //vec3 lp = lk + vec3(2.5, 1, 2.25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);    \n    \n    //////\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    /// col= getSkyColA(rd);\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col+= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n   // else if(d>MAX_DIST)\n    //col= getSkyColB(rd, uv, vec3(0.0));\n    // col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 543, 543, 638], [639, 639, 678, 678, 773], [774, 774, 813, 813, 908], [925, 950, 984, 984, 1082], [1083, 1083, 1117, 1117, 1209], [1210, 1210, 1244, 1244, 1336], [1378, 1378, 1411, 1411, 1612], [1614, 1654, 1679, 1679, 2099], [2103, 2103, 2168, 2168, 2752], [2754, 2805, 2829, 2829, 3017], [3022, 3022, 3055, 3055, 3847], [3852, 3906, 3942, 3942, 4176], [4177, 4266, 4346, 4346, 4623], [4625, 4676, 4723, 4723, 5276], [5330, 5330, 5423, 5423, 5699], [5703, 5703, 5730, 5730, 5840], [5844, 5893, 5950, 5950, 8371]], "test": "untested"}
{"id": "ssfGWM", "name": "2D Path Tracer", "author": "Shane", "description": "Storing a 2D distance field in a texture for much faster 2D realtime path tracing. Temporal camera reprojection is also utilized to generate the appearance of a much higher sampled image.", "tags": ["2d", "global", "illumination", "truchet", "tracing", "trace", "path", "path", "denoise", "reprojection", "radiosity"], "likes": 49, "viewed": 1498, "published": 3, "date": "1616067306", "time_retrieved": "2024-07-30T19:32:02.837715", "image_code": "/*\n\n\t2D Path Tracer\n\t--------------\n    \n    A while ago, I posted what appeared to be a high sampled 2D path traced scene \n    running in realtime. With that particular example, I was more concerned with the \n    2D camera reprojection and the realtime field itself, so I put the lighting in as \n    an afterthought. Anyway, this is another version that uses a static field and a \n    more traditional path traced coloring procedure (emitters, throughput, etc) in \n    order to better display the results.\n\n\tTechnically speaking, this is a low-sample path traced rendering of a 2D distance \n    field that has been stored in the channels of a screen buffer, then camera \n    reprojected a few times to give the impression of a much higher sampling. The 2D \n    distance field itself has been encoded into one of the faces of the cube map.    \n    \n    Just for the record, I prefer the aesthetic of noisy, single pass, low sampled 2D \n    path traced imagery, which require far less work to produce. Unfortunately, very\n    few people feel the same way, which means I've had to code up this multitab mess \n    in order to avoid hurting people's eyes. :D\n    \n    Additionally, there are a few compiler directives in the \"Common\" tab to try that \n    might help.\n\n    By the way, this can be extended to 3D situations as well, and I have an example \n    ready to go. In the meantime, IQ has an awesome 3D gloabally illuminated example, \n\tcomplete with denoising camera reprojection on Shadertoy that's well worth the \n    look, especially since examples like that are thin on the ground.\n\n\n    Useful links:\n\n\t// 3D temporal reprojection: IQ puts up a lot of difficult to find code with\n    // very little fanfare. This is one example.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    // This particular function is a modified version of Narkowicz's\n    // HDR to LDR function. There's more to it, but for me, it tones down \n    // heavy lighting. In this case, however, I prefer the HDR look on this\n    // particular 2D scene, so I'm leaving it out by default. In general\n    // though, you should be using it.\n    //col.xyz = ACESFilm(col.xyz);\n\n    // Gamma correction and screen presentation.\n    fragColor = pow(col, vec4(.4545));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Show the outline of the 2D field. I like it, but I think it spoils the\n// illusion a little. By the way, changing this requires a time reset, or\n// pressing the back button.\n// Default - Truchet: 0, Repeat circles: 1.\n#define SCENE 0\n\n// Color scheme: Red\\Blue: 0, Multicolor: 1\n#define COLORSCHEME 0\n\n// Display the inside field color. I'm not sure if it strictly adheres\n// to the rules, but I like it. If you turn it off, try it with the\n// outline (directive below) showing.\n#define SHOWINSIDE\n\n// Show the outline of the 2D field. I like it, but I think it spoils the\n// illusion a little.\n//#define OUTLINE\n\n// Show the background tile grid.\n#define GRID\n\n// Use camera reprojection. It's worth turning this off to see what you\n// end up with without it... I happen to like the noise aesthetic, but\n// not too many people do, which is why you don't see a lot of 2D\n// path tracing examples.\n#define REPROJECTION\n\n// Distance field object ID.\nvec2 gIP;\n\n// Object ID.\nfloat gObjID;\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 32 by 32 unit basis.\nfloat repSc = 16.; \n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ p = mod(p, 1024.); \n                      return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nvec2 hash22(vec2 p) {\n    //return vec2(0);\n    p = mod(p, 1024.);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// IQ's vec2 to float hash, but with a repeat factor. If you repeat random\n// textures to wrap, then you need to wrap the random functions.\nfloat hash21Rep(vec2 p){ \n    p = mod(p, repSc); \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\nvec2 hash22Rep(vec2 p) {\n    //return vec2(0);\n    p = mod(p, repSc);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// Believe it or not, the simple one-line function below took me ages to figure out. The \n// only refrences to it seem to be from some Microsoft documentation somewhere, because it's \n// all written in some obscure way that involves the term, \"fract(p)*2. - 1.,\" etc.\n//\n// Anyway, the following should have been obvious to me, but it wasn't: A unit cube centered \n// on a grid has six faces with a center at vec3(0), and 8 vertices at coordinates, \n// vec3(-.5, -.5, -.5), vec3(-.5, -.5, .5), etc. Therefore, using very basic UV mapping logic, \n// the faces will be the following:\n//\n// Left face: \n// // Wrapping and centering coordinates on the YZ plain: \n// p.yz = fract(p.yz) - .5;\n// // The X coordinate is at \"-.5\".\n// p.x = -.5;\n// // Texture coordinate. \n// vec4 tx = texture(texChannel, vec3(-.5, fract(p.yz) - .5));\n//\n// All faces follow the same logic, with a bit of UV flipping to get things facing the right \n// way, etc. Using uv = fract(uv) - .5:\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\n//\n//\n// From what I've noticed, the size of the cube you use doesn't seem to matter -- I'm \n// assuming this is due to an internal normalization process. Therefore, to save extra \n// calculations (which matter when doing 3D stuff), you may as well use the unit cube \n// figures above -- instead of vec3(fract(p)*2. - 1., 1), vec3(fract(p) - .5)*n, n), etc.\n \n\n// Reading in the texture from the right face of the cube: I chose this because it \n// writes more easily, but you can read from any, or as many, faces you'd like. I'm\n// assuming that all sides index into memory at the same rate, otherwise you'd have to\n// take that into consideration when favoring one side or the other.\n//\n// By the way, \"p\" is simply your \"uv\" coordinates, which are usually: \n// uv = fragCoord/iResolution.y, but could represent cube sides, like p.xz, etc.\nvec4 tx(samplerCube tx, vec2 p){    \n\n    return texture(tx, vec3(fract(p) - .5, .5));\n}\n\n// IQ's box function, with modified smoothing element.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Krzysztof Narkowicz's HDR color to LDR space using the ACES operator.\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve\n//\n// I could be wrong, but I found this to be twice as strong as the original,\n// so needed to compensate. However, it's not my area, so if Knarkowicz sees\n// this at some stage, hopefully, he might shed some light. On a side note,\n// Knarkowicz (user name) has some awesome examples on Shadertoy, if you feel \n// like looking them up. :)\n \nvec3 ACESFilm(in vec3 x){\n    // Different numbers to the original: They work here, but might not\n    // be suitable for other examples. Having said that, these numbers\n    // match more closely to Stephen Hill's original.\n    float tA = .6275, tB = .015, tC = .6075, tD = .295, tE = .14;\n    return clamp((x*(tA*x + tB))/(x*(tC*x + tD) + tE), 0., 1.);\n}\n\n", "cube_a_code": "\n#if SCENE == 0\n// Default scene, which is just a basic Truchet decoration.\nvec4 dfGridObjects(vec2 p, vec2 ip, float sc){\n    \n    // Cell ID -- We're rendering to a texture, so there's\n    // wrapping involved.\n    ip = mod(ip, repSc);\n    \n    // Float and vec2 random samples.\n    float rnd = hash21Rep(ip + .11);\n    vec2 rnd2 = hash22Rep(ip + .21);\n    \n    // Used to move the arcs in and out.   \n    float flip = 1.;\n    if(mod(ip.x + ip.y, 2.)<.5) flip = -flip;\n    if(rnd<.5) flip = -flip;\n \n    // Cell border.\n    float bord = sBoxS(p, vec2(.5*sc), 0.);\n\n    // Random tile flip.\n    if(rnd<.5) p.y = -p.y;\n\n    // Arc on opposite diagonals.\n    float d = min(length(p - .5*sc), length(p + .5*sc)) - (.5 - .05*flip)*sc;\n    d = abs(d) - .07*sc;\n    \n    // Clip to the cell borders, and chop a bit off while we're at it.\n    d = max(d, bord + .125*sc);\n    \n    // Metallic circles.\n    float rnd3 = hash21Rep(ip + .54)*.1 + .1;\n    float bl =  min(length(p - .5*sc), length(p + .5*sc)) - rnd3*sc;\n    \n    // Take out some of the circles in a checkered fashion\n    if(flip>0.) bl = 1e5; // bl += rnd3*sc/2.;\n    \n    // Add the circles to the arcs.\n    d = min(d, bl);\n\n    // Add some lights, then randomly shift them out along the \n    // diagonal. The idea is to produce some random light play.\n    float rnd4 = hash21Rep(ip + .67);\n    p -= rot2(3.14159/2.)*vec2(rnd4 - .5)*.75*sc;\n\n    // Circular light objects at random sizes. By the way, these are\n    // just regular objects, but the main renderer will read their\n    // object ID, then flag them as emitters.\n    float d2 = length(p - .0*sc) - .05*sc;\n    if(mod(ip.x + ip.y, 2.)<.5) d2 += .03*sc;  //1e5;\n      \n    // Object ID. The circles will be the emitters.\n    float objID = d<d2? 0. : 1.;\n    \n    // Cell ID.\n    gIP = ip;\n    \n    // Minimum object, cell ID and object ID.\n    return vec4(min(d, d2), ip, objID);\n}\n\n#else\n// Alternate repeat circles.\nvec4 dfGridObjects(vec2 p, vec2 ip, float sc){\n    \n    // Cell ID -- We're rendering to a texture, so there's\n    // wrapping involved.\n    ip = mod(ip, repSc);\n  \n    // Float and vec2 random samples.\n    float rnd = hash21Rep(ip + .11);\n    vec2 rnd2 = hash22Rep(ip + .21);\n    \n    // Offset circles in each cell. \n    float sz = (.1 + rnd*.3)*sc;\n    float mx = max(.48 - sz/sc, 0.)*2.;\n    float d  = length(p - (rnd2 - .5)*mx*sc) - sz;\n    /*\n    // Rotated capsules... Needs work, so circles it is. :)\n    float sz = sc/2.5;\n    float mx = max(.48 - sz/sc, 0.)*2.;\n    p *= rot2((rnd - .5)*6.2831); //rot2(floor(rnd3*16.)/16.*6.2831);\n    float d = sBoxS(p - (rnd2 - .5)*mx*sc, vec2(sc/2.5, sc/6.), .15*sc);\n    */\n    \n    // Setting some for the cell objects as emitters.\n    float hOffs = mod(floor((ip.y - .5)/2.), 2.)*2.;\n    bool light = (mod((ip.x - .5) + hOffs, 4.)<.5 && mod((ip.y - .5), 2.)<.5)? true : false;\n    \n    // Object ID. The circles will be the emitters.\n    float objID = light? 1. : 0.;\n    \n    // Cell ID.\n    gIP = ip;\n    \n    // Return the scene distance, cell ID and object ID.\n    return vec4(d, ip, objID);\n}\n\n#endif\n\n\n// Iterating through grid neighbors at a particular scale. Fiddly coding, but necessary.\nvec4 dfNeighbors(vec2 q){\n\n    \n    // Scale, ID, and distance field storage.\n    float sc = 1./repSc;\n    float d = 1e5;\n    float oID = 0.;\n    vec2 id = vec2(0);\n    \n    \n    // This is a rendering of a repeat grid of object. Sometimes, you need to consider\n    // immdiate neighbors, which is fine.\n    //\n    // However, if you wish to bounce light around, things can be affected by objects that \n    // are several cells away. In this case, several on either side. This means checking\n    // a crazy number of cells -- The kind of numbers that would fry your GPU. Thankfully,\n    // we can do this once at runtime, and store the overall distance field in a texture,\n    // or one of the cube map faces, which is what we're doing here.\n    \n    int iters = min(0, iFrame) + 8;\n    for(int j = 0; j<=iters; j++){\n        for(int i = 0; i<=iters; i++){\n\n            vec2 p = q;\n            vec2 ip = floor(p/sc + (vec2(i, j) - float(iters)/2.)*sc) + .5;\n            \n        \tp -= ip*sc;\n            \n            vec4 dij = dfGridObjects(p, ip, sc);\n          \n            if(dij.x<d) {\n                d = dij.x;\n                id = dij.yz;//gIP;\n                oID = dij.w;//objID;\n            }\n \n        }\n    }\n    \n    return vec4(d, id, oID);\n    \n}\n\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in one of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIAL CONDITIONS.\n       \n        // Construct a distance field whilst seting the wrapping value, then store it.\n        //repSc = 16.;\n        col = dfNeighbors(uv); // Distance field in X, and object IDs in YZ.\n\n        \n    }\n    else col = tx(iChannel0, uv);\n\n\n    // Store in the cube map.\n    fragColor = vec4(col);\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// Reading the distance field from the texture map.\nfloat map(vec2 p){\n\t// Reading distance fields from a texture means taking scaling into\n    // consideration. If you zoom coordinates by a scalar (4, in this case), \n    // you need to scale the return distance value accordingly... Why does \n    // everything have to be so difficult? :D\n    const float sc = 4.;\n    vec4 tex = tx(iChannel0, p/sc);\n    gIP = tex.yz; // The object ID is stored in the YZ channels..\n    gObjID = tex.w;\n    return tex.x*sc;\n}\n\n\n\n// Tracing variables.\n#define FAR 8.\n#define DELTA .001\n#define RSF 1.\n\nfloat trace(vec2 o, vec2 r){\n    \n    // Raymarching.\n    float d, t = 0.;\n    \n    \n    // Just 16 iterations here, but I'd preffer more: If speed and complilation time is \n    // a concern, choose the smallest number you can get away with. Apparently, swapping \n    // the zero for min(0, iFrame) can force the compliler to not unroll the loop, so \n    // that can help sometimes too.\n    for(int i = min(0, iFrame); i<16; i++){\n        \n        // Surface distance.\n        d = map(o + r*t);\n        \n        // In most cases, the \"abs\" call can reduce artifacts by forcing the ray to\n        // close in on the surface by the set distance from either side. Because this is\n        // two dimensional, it appears to be necessary -- rather than an option -- to avoid \n        // negative values... I haven't thought it through enough, but basically, 2D \n        // raymarching, or whatever you wish to call the process, works differently.\n        //\n        // Displaying the inside 2D filed colors. I probably doesn't strictly adhere to\n        // 2D path tracing rules, but I like it visually.\n        #ifdef SHOWINSIDE\n        if((d<0. && abs(d)<DELTA) || t>FAR) break;\n        #else\n        if(d<0. || t>FAR) break;\n        #endif\n        \n        // No ray shortening is needed here, and in an ideal world, you'd never need it, but \n        // sometimes, something like \"t += d*.7\" will be the only easy way to reduce artifacts.\n        t += d*RSF;\n    }\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    return t;\n    \n}\n\n\n// Square grid.\nfloat gridField(vec2 p){\n    \n    p = abs(p - floor(p) - .5);\n    return abs(max(p.x, p.y) - .5);\n}\n\n\n// Standard 2D normal function.\nvec2 nr(in vec2 p){\n    \n\tconst vec2 e = vec2(.001, 0);\n    // Four taps.\n\t//return normalize(vec2(map(p + e.xy) - map(p - e.xy), \n    //                      map(p + e.yx) - map(p - e.yx)));\n    // Three taps... I tend to prefer extra samples for normal\n    // calculations, but this should be fine for this example.\n    float m = map(p);                    \n    return normalize(vec2(map(p + e.xy) - m, map(p + e.yx) - m));\n}\n\n// Translating the camera.\nvec2 getCamTrans(float t){ return vec2(sin(t/32.)/8., -t/24.); }\n\n// Rotating the camera.\nmat2 getCamRot(float t){\n     \n    //return rot2(0.);\n    return rot2(cos(t/12.)/8.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    \n    // The overall scene color.\n    vec3 col = vec3(0);\n    \n   \n    vec2 cam = getCamTrans(iTime);\n    mat2 camRot = getCamRot(iTime);\n    \n\n    vec2 rd;\n    \n \n    // Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    uv = uv*camRot - cam;\n    \n    // Making a copy of the rotated coordinates for later use.\n    vec2 rUV = uv;\n    \n    float sf = 4./iResolution.y;\n    float grid = gridField(uv*repSc/4.);\n    \n    \n \n \n    // Number of samples and the number of reflective bounces: Without camera\n    // reprojection techniques, you'd need about 64 samples at least, which\n    // would bring even the best machine to a crawl.\n    const int SAMPLES = 8;\n    #if SCENE == 0\n    const int BOUNCES = 3;\n    #else\n    const int BOUNCES = 2;\n    #endif\n    \n    \n    //vec3 accum = vec3(0);\n    \n    // Sample loop.\n    for (int i =0; i < SAMPLES; i++){\n        \n        // Sample number in float form.\n        float fi = float(i);\n        \n        // Random time.\n        float fTm = fract(iTime*.92397 + float(iFrame + 1));\n        \n        // The initial jittered ray origin or camera point for this sample.\n        vec2 ro = uv + (hash22(uv + fi + fTm + .35) - .5)/iResolution.y*1.;\n        \n        \n        // The initial random unit direction ray for this sample.\n        float ti = (fi + hash21(uv + fi + fTm))*6.2831/float(SAMPLES);\n        rd = vec2(cos(ti), sin(ti));\n        \n        // The sample color.\n        vec3 sCol = vec3(0);\n        // Emissive color: I'm calulating this on the fly, but it can be\n        // set before entering the loop.\n        vec3 emissive = vec3(0);\n        // Throughput, which is analogous to a record of the scene's \n        // accumulative transferred color history. A lot of people use\n        // Demofox's path tracing code, and he uses this variable name, \n        // so if it's good enough for him... :) By the way, his path\n        // tracing articles are worth the read, for anyone interested.\n        vec3 throughput = vec3(1);\n        // Surface roughness.\n        float roughness = 0.;\n        // Transfer power: It's kind of redundant here, since I'm not\n        // reducing it after each bounce, but it's here for completeness.\n        float ePower = 1.;\n        \n        // 2D distance field outline variable.\n        float outline = 1e5;\n        \n        \n        // Distance field copy.\n        float mp = map(ro);\n        \n        // Grid line distance.\n        float gridL = max(grid, -mp);\n        \n        // Bounce loop.\n        for(int j = 0; j<BOUNCES; j++){\n            \n            // Bounce trace.\n            float t = trace(ro, rd);\n            vec2 svID = gIP; // Saving the ID here.\n   \n            float objID = gObjID;\n            \n            // Bounce number in float form.\n            float fj = float(j);\n            \n            // Color for this bounce.\n            vec3 bCol = vec3(0);\n            vec2 sp = ro + rd*t;\n            \n            if(t<FAR){\n                \n                // The randomly distributed unit direction vector: For 2D stuff, this seems \n                // to be the accepted way to go about it. Basically it's just a normalized\n                // vector in a random circular direction, which makes sense on a 2D plane.\n                float fij = fi*float(BOUNCES) + fj;\n                float tij = (fij + hash21(uv + fij + fTm))*6.2831/float(SAMPLES*BOUNCES);\n                vec2 rndRD = vec2(cos(tij), sin(tij));\n                \n                // 2D surface normal... In this case, numerically calculated, but analytical\n                // calculations are possible as well.\n                vec2 sn = nr(sp); // Normal.\n                 \n            \n                bool light = objID == 1.? true : false;\n                \n                // Set the object color.\n                #if COLORSCHEME == 0\n                vec3 oCol = hash21(svID + .25) < .5? vec3(.6, .8, 1) : vec3(1, .8, .6);\n                if(hash21(svID + .34)<.2 && !light) oCol = vec3(1.5, .75, .5);\n                #else\n                float rndC = hash21(svID + .18);\n                vec3 oCol = (.65 + .35*cos(rndC*6.2831/2.1 + vec3(0, 1, 2) - 2.1));\n                #endif\n       \n                \n                // Set the emissive color.\n                emissive = light? vec3(3)*oCol : vec3(0);\n                //if(hash21(svID + .34)<.5) emissive = emissive.zyx;\n                \n                // Dropping the emissive power with each pass.\n                //emissive *= ePower;\n                //ePower *= .75;\n                \n                // Object roughness. As you'd imagine, smoother objects have less roughness.\n                roughness = light? .1 : .02;\n \n                // Not normally necessary, but keeps a copy of the field values.\n                if(j==0){\n                 \n                    \n                    \n                    #ifdef OUTLINE\n                    if(!light) outline = mp;\n                    #endif\n   \n                }\n           \n                // Color for this particular bounce.\n                bCol = oCol; \n                \n               \n            \n                vec2 refl = reflect(rd, sn);\n                //if(dot(rndRD, sn)>0.) rndRD = -rndRD;\n                // Mostly reflective, but adding in a little roughness.\n                //rd = normalize(mix(reflect(rd, sn), rndRD, roughness)); \n                rd = mix(rndRD, refl, step(0., hash21(uv + vec2(fi*53.87, fj*137.65)) - roughness)); \n\n                // Updating the ray origin to the hit point, then bumping the ray\n                // off the surface to avoid self collisions.\n                ro = sp + sn*DELTA*1.1;\n\n            } \n            \n             \n            // Adding the bounce color using standard path tracing rules... I'm\n            // not sure how well it translate to the 2D form, but it looks \n            // interesting, so it'll do. :)\n            //\n            // Adding the light and surface color history... You could get more \n            // technical than that, but that's basically what you're doing. :)\n            sCol += emissive*throughput;\n            // Applying the currect bounce color to the path throughput weighting.\n            throughput *= bCol;\n            \n        }\n        \n        #ifdef GRID\n        // Grid lines -- Needs to be applied in overlay form.\n        sCol = mix(sCol, sCol*1.25, 1. - smoothstep(0., sf*3., gridL - .015));\n        sCol = mix(sCol, sCol/2.5, 1. - smoothstep(0., sf, gridL - .005)*.7);\n        #endif \n        \n        #ifdef OUTLINE\n        // Display the 2D field outline. It needs to be applied to each sample\n        // in overlay form. Applying a dark border inside the path tracing loop\n        // effects the overall color.\n        \n            #ifdef SHOWINSIDE\n            const float outer = 1.6;\n            const float inner = .1;\n            #else\n            const float outer = .5;\n            const float inner = 5.;\n            #endif\n        \n        sCol = mix(sCol, sCol*outer, 1. - step(0., abs(outline - .003) - .006));\n        sCol = mix(sCol, sCol*inner, 1. - step(0., abs(outline - .00125) - .0025));\n        \n        /*\n        // Flat color... Not for me. :)\n        sCol = mix(sCol, vec3(0), 1. - step(0., outline - .006));\n        sCol = mix(sCol, vec3(1, .8, .6), 1. - step(0.,outline));\n        */\n        #endif \n        \n        \n        // Add the sample color.\n        col += sCol;\n        \n    }\n    \n    \n    // Divide by the sample number.\n    col /= float(SAMPLES); \n    \n    //col = min(col, 1.);\n    \n    \n    \n    #ifdef REPROJECTION\n\n    // Camera reprojection. This is basically the crux of the example, and as you \n    // can see, it's not that involved. In essence, we're calculating where we \n    // believe the previous frame should be placed on the sceen in relation to the\n    // new one -- Effectively, we'd like to place it directly under the new one. \n    // To do that, we index into the stored buffer at the current position minus \n    // the frame to frame camera difference.\n    //\n    // On a side note, I think the calculations are correct, but it's been a while \n    // since I've done this, so if there's something that doesn't look quite right,\n    // it probably isn't... And feel free to let me know that. It's the only way\n    // I'll learn not to be stupid. :D\n    \n    // Recalculating the UV coordinates.\n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n    // Frame to frame camera translation difference.\n    vec2 camDelta = getCamTrans(iTime - iTimeDelta);\n    vec2 camOffs = -(camDelta - cam);\n    \n    // Frame to frame camera rotation difference.\n    mat2 rotDelta = getCamRot(iTime - iTimeDelta);\n    vec2 rotOffs = -(rotDelta*uv - camRot*uv);\n    \n    \n    // Offsetting the UV coordinates accordingly, then projecting to the current\n    // screen coordinates, which have to range from zero to one along X and Y.\n    vec2 cuv = (uv - rotOffs - camOffs)*vec2(iResolution.y/iResolution.x, 1)  + .5;\n    \n    // Two differently rotated-translated rectangles are more than likely not going\n    // to line up, so you need to check boundaries. You might note a bit of smudging\n    // on the screen borders. Usually, your offscreen buffer would be larger, or the\n    // onscreen buffer will be smaller. Basically, I could put a screen border around\n    // everything, but I don't think it's that noticeable.\n    if(cuv.x<0. || cuv.x>1.) cuv.x = uv.x*iResolution.y/iResolution.x + .5;\n    if(cuv.y<0. || cuv.y>1.) cuv.y = uv.y + .5;\n    vec3 tCol = texture(iChannel1, cuv).xyz;\n    \n    \n    // Mixing in the new frmae with the previous one. In fact, we're cycling about\n    // 8 screens. This effectively gives you 8 times the sampling. So, if your \n    // original sample count is just 8, this would boost it to 64. The reason you\n    // don't go too high is that temporal reprojection is just an estimation, so\n    // eventually, temporal screen lag will catch up with you.\n    const float totTimeFrames = 12.;\n    col = mix(tCol, col, 1./totTimeFrames);\n    \n    #endif\n    \n    // Output to the buffer.\n    fragColor = vec4((max(col, 0.)), 1);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1804, 1804, 1858, 1895, 2419]], "test": "untested"}
{"id": "7df3DM", "name": "Rubber Band Ball", "author": "oneshade", "description": "More fun with springs! This time its something like a rubber band ball. Tug it with the mouse.\nSet SPRINGINESS to 0.01 and JOINTS to 15 for an ultra squishy experience :D", "tags": ["2d", "simulation", "physics", "spring", "softbody", "rubberbandball"], "likes": 24, "viewed": 384, "published": 3, "date": "1616038390", "time_retrieved": "2024-07-30T19:32:03.611645", "image_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float unit = 2.0 / iResolution.y;\n\n    for (int i=0; i < JOINTS; i++) {\n        vec2 joint1 = getJoint(i).pos;\n        for (int j=0; j < JOINTS; j++) {\n            if (j == i) continue;\n            vec2 joint2 = getJoint(j).pos;\n            float dist = sdLine(uv, joint1, joint2);\n            fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, dist));\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Joint {\n    vec2 pos;\n    vec2 vel;\n    float mass;\n};\n\n#define getJoint(id)                                 \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xy, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xy, \\\n          MASS)                                      \\\n\n#define JOINTS 10\n#define MASS 10.0\n\n#define GRAVITY 0.001\n#define SPRINGINESS 0.1\n#define DAMPING 0.99", "buffer_a_code": "vec2 getPos(in float id) {\n    return sin(id / float(JOINTS) * 6.28 + vec2(1.57, 0.0)) * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFragCoord.x < JOINTS && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xy = getPos(fragCoord.x);\n            if (iFragCoord.y == 1) fragColor.xy = normalize(getPos(fragCoord.x)).yx * vec2(-0.01, 0.01) + vec2(0.02, 0.01);\n        }\n\n        if (iFrame > 0) {\n            Joint joint1 = getJoint(iFragCoord.x);\n            vec2 startPos1 = getPos(fragCoord.x);\n\n            vec2 totalForce = vec2(0.0, -GRAVITY);\n            for (int i=0; i < JOINTS; i++) {\n                if (i == iFragCoord.x) continue;\n                Joint joint2 = getJoint(i);\n                vec2 startPos2 = getPos(float(i) + 0.5);\n\n                float restLength = distance(startPos1, startPos2);\n                vec2 force = normalize(joint2.pos - joint1.pos);\n                float extension = restLength - distance(joint2.pos, joint1.pos);\n                force *= -SPRINGINESS * extension;\n\n                totalForce += force;\n            }\n\n            joint1.vel += totalForce / joint1.mass;\n\n            joint1.pos += joint1.vel;\n            joint1.pos = clamp(joint1.pos, -corner, corner);\n\n            joint1.vel *= DAMPING * sign(corner - abs(joint1.pos));\n\n            // UX improvement by @elenzil\n            if (iMouse.z > 0.0 && iFragCoord.x == JOINTS - 1) {\n                vec2 targPos = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n                vec2 targVel = (targPos - joint1.pos) * 0.1;\n                joint1.vel = targVel;\n            }\n\n            if (iFragCoord.y == 0) fragColor.xy = joint1.pos;\n            if (iFragCoord.y == 1) fragColor.xy = joint1.vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7df3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 155], [157, 157, 212, 212, 722]], "test": "untested"}
{"id": "7sX3DM", "name": "EPA UQ FOI ISSO", "author": "stroka", "description": "shubirao", "tags": ["hihihitocumvergonha"], "likes": 1, "viewed": 205, "published": 3, "date": "1616035654", "time_retrieved": "2024-07-30T19:32:04.381587", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (2.*fragCoord.xy-iResolution.xy) / iResolution.y; \n\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    vec2 uv = vec2(1.5,r);\n\n\tuv = (1.0 * uv) -1.0;     \n    float beamWidth = abs(1.0 / (9.0 * uv.y));\n\n    \n    \n    \n\n    if(abs(uv.x)>=5.0)\n    {\n    \n   \t  // fragColor=vec4(1.2,0.5,6.9,1.2);\n      //  return;\n    }\n    \n\tvec4 horBeam = vec4(beamWidth);\n\t\n\t//fragColor = vec2( horBeam , 7.0);\n    fragColor = vec4( 2.0 / (10000. * abs(1.*length(p)-1.) ) );\n\n    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 546]], "test": "untested"}
{"id": "ssfGDM", "name": "stroka vitaminado ", "author": "stroka", "description": "ULALAUUUU", "tags": ["nft"], "likes": 1, "viewed": 234, "published": 3, "date": "1616033702", "time_retrieved": "2024-07-30T19:32:05.154520", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (0.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    for(float i = 0.1; i < 9.0; i++){\n        uv.x += 0.6 / i * cos(i * 9.5* uv.y + iTime);\n        uv.y += 0.9 / i * cos(i * 9.0* uv.x + iTime);\n    }\n    \n    fragColor = vec4(vec3(0.1)/abs(sin(iTime-uv.y-uv.x)),1.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 370]], "test": "untested"}
{"id": "ttVfDc", "name": "Structured Volume Raymarching", "author": "TinyTexel", "description": "A basic implementation of Structured Volume Sampling: github.com/huwb/volsample (by twitter.com/hdb1)\nTab    - toggle Structured Volume Sampling off/on\nSpace - toggle sampling plane visualization on/off\nCamera controls via mouse + Shift.", "tags": ["raymarching", "volume"], "likes": 47, "viewed": 1555, "published": 3, "date": "1616032044", "time_retrieved": "2024-07-30T19:32:06.291481", "image_code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n\n/*\nA basic implementation of Structured Volume Sampling: github.com/huwb/volsample (by twitter.com/hdb1)\n\nTab   - toggle Structured Volume Sampling off/on\nSpace - toggle sampling plane visualization on/off (just shows ray direction if SVS is off)\n        if 'on' pressing Ctrl shows the number of active sampling planes (black: 1 | grey: 2 | white: 3)\n\nCamera controls via mouse + Shift.\n\n\nThe idea of structured volume sampling (SVS) is to restrict volume sampling locations to a set of \nworld space planes/virtual billboards in order to prevent temporal aliasing under camera movement. \nThe way these artifacts are traditionally resolved is by jittering the camera relative sampling locations along the rays.\nThis potentially reduces cache efficiency when sampling volume textures. \nHowever, this is only the case when the step size is larger than the voxel spacing. \nNo performance degradation occurs as long as the jittering does not scatter the texture access locations of adjacent pixels too much.\nMip-mapping the volume can help with that. \n\nBased on my (limited) experiments here it seems to me that SVS does not improve texture access patterns enough to offset its overhead.\nSVSs primary selling point appears to be that it can produce temporally stable results without the use of jittering.\n\nHowever, whether SVS works well or not very much depends on the characteristics of the volume: \nrestricting the raymarching sampling locations in a structured manner can lead to very noticeable _spatial_ aliasing artifacts \n(f.i. the sampling planes can become quite obvious for decently dense volumes that feature limb darkening).\n\nMy SVS implementation here tries to reduce these spatial aliasing artifacts by re-introducing per-ray jittering.\nHowever, the jittering is only used for oversampling the transfer function that is applied to a linear interpolation of the SVS samples.\nThe advantage over traditionally jittered raymarching is that details contained in the volume cross-sections are better retained.\nAlthough the line between what one would consider either a desireable detail or an undesireable artifact is, admittedly, rather ambiguous.\nIn that sense this experiment is somewhat of a mixed success.\n\nI set up two SVS implementations: \none that blends the results of up to 3 sets of sampling planes (RaymarchScene_Structured) and \none that stochastically selects a single set of sampling planes(RaymarchScene_StructuredStochastic).\n\nOnly the stochastic variant appears to be performant enough to be potentially useful, though.\n*/\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//--------------------------------------------------------------------------------------------------------------//\n\n// Common:\n\n/* dodecahedral/truncated icosahedral quantization of a given direction [dir]\n\n   [dir]: normalized vector | [rad]: blend radius [0,1] | [rnd]: random number [0,1]\n   \n   [doUseTruncIco]: quantize to face directions of truncated icosahedron instead of regular dodecahedron\n   [doUseKernB]:    instead of the simple spherical blend kernel use one that is more expensive but works better for small [rad]\n   [doSort]:        sort the found directions so that correlation structures in [rnd] do not break (use this if [rnd] is blue noise)\n\n   out:    the closest 3 directions [dirA/B/C] + their blend weights [w.xyz] \n   return: one of the 3 closest directions (sampled according to their weights [w.xyz] using [rnd])  \n*/\nvec3 QuantizeDirection(vec3 dir, float rad, float rnd, \n                       const bool useTruncIco, const bool useKernB, const bool sortDirs, \n                       out vec3 dirA, out vec3 dirB, out vec3 dirC, out vec3 w);\n\n// Image:\n\n// traditional volume raymarching\nvec3 RaymarchScene(vec3 rp, vec3 rd, vec2 uv);\n\n// structured volume raymarching | stochastically selects a single set of sampling planes\nvec3 RaymarchScene_StructuredStochastic(vec3 rp, vec3 rd, vec2 uv);\n\n// structured volume raymarching | blends results from up to 3 sampling planes\nvec3 RaymarchScene_Structured(vec3 rp, vec3 rd, vec2 uv);\n\n//--------------------------------------------------------------------------------------------------------------//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\n// animated interleaved gradient noise - https://www.shadertoy.com/view/fdl3zn\nfloat EvalIGN(vec2 uv)\n{\n    uint frame = uint(iFrame);\n    \n    if((frame & 2u) != 0u) uv = vec2(-uv.y, uv.x);\n    if((frame & 1u) != 0u) uv.x = -uv.x;\n    \n    //return fract(IGN(uv)+float(frame)*0.41421356*1.0);\n\n    // http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\n    return fract(uv.x*0.7548776662 + uv.y*0.56984029 + float(frame)*0.41421356);\n}\n\nfloat SampleVolume(vec3 p)\n{\n    //float n = Fbm32(p*1.8, vec3(0.49, 0.91, 0.36), iTime, iChannel2).x;\n    vec4 n2 = Fbm32(p, vec3(0.49, 0.91, 0.36), iTime*0.5, iChannel2);\n    \n    //n = dot(n2, vec4(1.0, 0.5, 0.25, 0.125));\n    float n = n2.x * n2.y * 2.0;\n    //n = min(n, n2.z * n2.w * 2.0);\n    \n    return n * 0.5 + 0.5;\n}\n\nfloat VolumeMask(vec3 p)\n{\n    float l2 = dot(p,p)*0.5;\n    \n    //return max(smoothstep(0.45, 0.55, Pow2( (1.0-l2)*clamp01(1.0-l2*0.05) )), p.y < 0.0 ? 0.05 : 0.0);\n    return smoothstep(0.45, 0.55, Pow2( (1.0-l2)*clamp01(1.0-l2*0.05) )) + 0.01;\n}\n\n\n//----------------------------------------------------------------------------------------------------------------//\n\n// traditional volume raymarching\nvec3 RaymarchScene(vec3 rp, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    vec4 bnoise;// blue noise\n    {\n        // random offset per frame\n        uvec2 noff = uint(iFrame) * uvec2(3242174893u, 2447445397u);\n        \n        bnoise = texelFetch(iChannel3, ivec2((uvec2(uv-0.5) + noff) & 1023u), 0);\n        bnoise = MixBlueNoiseBits(bnoise);// use if 8 bits per channel are not enough\n    }\n\n   #if 1\n    bnoise.x = EvalIGN(uv);// interleaved gradient noise (more fine grained than blue noise but can cause aliasing)\n   #endif\n   \n    float count = 37.0;// max number of steps\n    float stepSize = 4.0/32.0;// dist between sampling planes\n    \n    float T_prev = 1.0;// transmittance\n    float tau = 0.0;// optical depth\n    \n    for(float i = 0.0; i < count; ++i)\n\t{\n        // dist to sample point\n        float d = i * stepSize + (bnoise.x * stepSize);\n        \n        // sample point\n        vec3 p = rp + rd * d;\n        \n        // volume sample\n        float n = SampleVolume(p);\n        \n        // apply transfer function to noise\n        n = smoothstep(0.42, 0.58, n);\n        n *= VolumeMask(p);\n        \n        // extinction coefficient\n        float sigma = n * 32.0;\n        \n        // optical depth\n        tau += sigma * stepSize;\n        \n        // transmittance\n        float T = exp2(-tau);\n        \n        // extinction probability\n        float extProp = T_prev - T;\n\n        // color\n        float limb = Pow2(1.0-exp2(-n*3.0));\n        \n        vec3 c  = normalize(p) * 0.5 + 0.5;\n             c *= mix(vec3((1.0-c.b)*0.25, 0., c.b*0.75), vec3(1.0, 0.9, 0.2), limb);\n             \n        col += extProp * c;\n\n        // break if transmittance gets low\n        if(T < 1.0/64.0) { break; }\n            \n        T_prev = T;\n    }\n    \n    return col * 1.5;\n}\n\n//----------------------------------------------------------------------------------------------------------------//\n\n// structured volume raymarching | stochastically selects a single set of sampling planes\nvec3 RaymarchScene_StructuredStochastic(vec3 rp, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    vec4 bnoise;// blue noise\n    {\n        // random offset per frame\n        uvec2 noff = uint(iFrame) * uvec2(3242174893u, 2447445397u);\n        \n        bnoise = texelFetch(iChannel3, ivec2((uvec2(uv-0.5) + noff*1u) & 1023u), 0);\n        bnoise = MixBlueNoiseBits(bnoise);// use if 8 bits per channel are not enough\n    }\n    \n   #if 1\n    bnoise.y = EvalIGN(uv);// interleaved gradient noise (more fine grained than blue noise but can cause aliasing)\n   #endif\n   \n    vec3 N0, N1, N2, w;\n    vec3 N = QuantizeDirection(rd, 0.25, bnoise.x, \n                               /*doUseTruncIco:*/ false, /*doUseKernB:*/ false, /*doSort:*/ true, \n                               /*out:*/ N0, N1, N2, w);\n\n    // number of active sampling planes\n    float countP = (w.x != 0.0 ? 1.0 : 0.0) + \n                   (w.y != 0.0 ? 1.0 : 0.0) + \n                   (w.z != 0.0 ? 1.0 : 0.0);\n\n    // number of samples used for oversampling the transfer function (depends on active planes)\n    // the jitter noise becomes worse when multiple sets of sampling planes are active so we need a higher count2 then\n    float count2 = countP == 1.0 ? 2.0 : 3.0;// 2 | 3 | 3\n    //float rcpCount2 = 1.0/count2;\n    float rcpCount2 = countP == 1.0 ? 1.0/2.0 : 1.0/3.0;\n    \n   #if 0\n   // debugging output\n    return vec3((countP-1.0)*0.5);\n    return N;\n   #endif\n    \n    \n    float count = 37.0;// max number of steps\n    float stepSize = 4.0/32.0;// dist between sampling planes\n\n\n    // stuff we need for stepping through evenly spaced planes\n    float ri, off;\n    {\n        vec3 ro = rp / stepSize;\n\n        float ro2 = dot(ro, N);\n        float rd2 = dot(rd, N);\n\n        ri = 1.0/rd2 * stepSize;// dist between planes\n        off = (-fract(ro2) + (rd2 < 0.0 ? 0.0 : 1.0)) * ri;// dist to first plane\n    }\n\n    // values from previous iteration\n    float T_prev = 1.0;\n    float tau = 0.0;\n    \n    float n0_prev = SampleVolume(rp);// probably works well enough in most cases\n    float d0_prev = 0.0;\n\n\n    count = min(count, iResolution.x);// prevent loop unroll\n    for(float i = 0.0; i < count; ++i)\n\t{\n        // dist to new sample point\n        float d0 = i * ri + off;\n        \n        // new sample point\n        vec3 p0 = rp + rd * d0;\n        \n        // new volume sample\n        float n0 = SampleVolume(p0);\n        \n        // this color is low frequency so no need to oversample it\n        vec3 c0  = normalize(rp + rd *  mix(d0_prev, d0, bnoise.y)) * 0.5 + 0.5;\n        \n        // oversample transfer function\n        for(float j = 0.0; j < count2; ++j)\n        {\n            float s = j * rcpCount2 + (bnoise.y * rcpCount2);\n            \n            float n = mix(n0_prev, n0, s);\n            float d = mix(d0_prev, d0, s);\n\n            // break if min march depth has been reached\n            if(d > (count-1.0)*stepSize) { i = count; break; }\n\n            vec3 p = rp + rd * d;\n            \n            // apply transfer function to noise\n            n = smoothstep(0.42, 0.58, n);\n            n *= VolumeMask(p);\n\n            // extinction coefficient\n            float sigma = n * 32.0;\n\n            // optical depth\n            tau += sigma * ((d0 - d0_prev) * rcpCount2);\n\n            // transmittance\n            float T = exp2(-tau);\n\n            // extinction probability\n            float extProp = T_prev - T;\n\n            // color\n            float limb = Pow2(1.0-exp2(-n*3.0));\n\n            vec3 c = c0 * mix(vec3((1.0-c0.b)*0.25, 0., c0.b*0.75), vec3(1.0, 0.9, 0.2), limb);\n\n            col += extProp * c;\n            \n            // break if transmittance gets low\n            if(T < 1.0/64.0) { i = count; break; }\n            \n            T_prev = T;\n        }\n        \n        n0_prev = n0;\n        d0_prev = d0;\n    }\n    \n    return col * 1.5;\n}\n\n//----------------------------------------------------------------------------------------------------------------//\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\n// structured volume raymarching | blends results from up to 3 sampling planes \n// I didn't clean this one up since it's the least useful one\nvec3 RaymarchScene_Structured(vec3 rp, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    vec4 bnoise;// blue noise\n    {\n        // random offset per frame\n        uvec2 noff = uint(iFrame) * uvec2(3242174893u, 2447445397u);\n        \n        bnoise = texelFetch(iChannel3, ivec2((uvec2(uv-0.5) + noff*1u) & 1023u), 0);\n        bnoise = MixBlueNoiseBits(bnoise);// use if 8 bits per channel are not enough\n    }\n    \n   #if 1\n    bnoise.x = EvalIGN(uv);// interleaved gradient noise (more fine grained than blue noise but can cause aliasing)\n   #endif\n   \n    vec3 N0, N1, N2, w;\n    QuantizeDirection(rd, 0.25, bnoise.x, \n                      /*doUseTruncIco:*/ false, /*doUseKernB:*/ false, /*doSort:*/ false, \n                      /*out:*/ N0, N1, N2, w);\n   #if 0\n   {\n       // debugging output\n\n       // show number of blended planes (black = 1 | grey = 2 | white = 3)\n       float count2 = (w.x != 0.0 ? 1.0 : 0.0) + \n                      (w.y != 0.0 ? 1.0 : 0.0) + \n                      (w.z != 0.0 ? 1.0 : 0.0);\n                      \n       //return normalize(N0*w.x + N1*w.y + N2*w.z) * 0.5 + 0.5;\n       \n       return vec3((count2 - 1.0)*0.5);\n   }\n   #endif\n   \n    \n    float count = 96.0;\n    float stepSize = 4.0/32.0*1.0;\n  \n    vec3 ro = rp / stepSize;\n    \n    vec3 ro2;\n    ro2.x = dot(ro, N0);\n    ro2.y = dot(ro, N1);\n    ro2.z = dot(ro, N2);\n    \n    vec3 rd2;\n    rd2.x = dot(rd, N0);\n    rd2.y = dot(rd, N1);\n    rd2.z = dot(rd, N2);\n    \n\n    float r = 0.0;\n\n    float T_prev = 1.0;\n    float tau = 0.0;\n\n    vec3 pos = vec3(0.0);\n\tvec3 ri = 1.0/rd2;\n\tvec3 off =  (vec3(rd2.x < 0.0 ? 0.0 : 1.0,\n                      rd2.y < 0.0 ? 0.0 : 1.0,\n                      rd2.z < 0.0 ? 0.0 : 1.0) - fract(ro2)) * ri;\n    \n    const float big = exp2(16.0);\n    if(w.x == 0.0) off.x += big;\n    if(w.y == 0.0) off.y += big;\n    if(w.z == 0.0) off.z += big;\n\n    vec3 n00 = vec3(SampleVolume(rp));\n\n    vec3 n0_prev = n00;\n    vec3 d0_prev = vec3(0.0);\n\n\n    vec3 col0 = vec3(0.0);\n    //float mxD = 0.0;\n    \n    count = min(count, iResolution.x);\n    for(float i = 0.0; i < count; ++i)\n    {\n        vec3 dis = pos * ri + off;\n        vec3 mm = minmask(dis);\n        pos += mm;\n        \n      //  #define SELECT_MODE_A\n        \n       #ifdef SELECT_MODE_A\n        float w0 = dot(w, mm);\n        float d0 = dot(dis, mm);\n       #else        \n        float type = mm.z * 2.0 + mm.y;\n       \n        float n0_prev0, d0_prev0, w0, d0;\n        if(type == 0.0)\n        {\n            n0_prev0 = n0_prev.x;\n            d0_prev0 = d0_prev.x;\n            \n            w0 = w.x; d0 = dis.x;\n        }\n        else if(type == 1.0)\n        {\n            n0_prev0 = n0_prev.y;\n            d0_prev0 = d0_prev.y;\n            \n            w0 = w.y; d0 = dis.y;\n        }\n        else if(type == 2.0)\n        {\n            n0_prev0 = n0_prev.z;\n            d0_prev0 = d0_prev.z;\n            \n            w0 = w.z; d0 = dis.z;\n        }\n       #endif\n        \n        vec3 p0 = rp + rd * (d0*stepSize);\n        float n0 = SampleVolume(p0);\n        \n        //mxD = max(mxD, d0);\n\n        float n = n0;\n        float d = d0;\n\n       #ifdef SELECT_MODE_A\n        // sample the linear reconstruction\n        n = mix(dot(n0_prev, mm), n0, bnoise.x);\n        d = mix(dot(d0_prev, mm), d0, bnoise.x);\n       #else\n        // sample the linear reconstruction\n        n = mix(n0_prev0, n0, bnoise.x);\n        d = mix(d0_prev0, d0, bnoise.x);\n       #endif\n       \n        /*\n        count: scale\n         8: 0.3\n        16: 0.35\n        32: 0.38\n        48: 0.39\n        64: 0.4\n        128: 0.41\n        256: 0.415\n        */\n        if(d > 0.4*count) break;\n\n        vec3 p = rp + rd * (d*stepSize);\n\n        // apply transfer function to noise\n        n = smoothstep(0.42, 0.58, n);\n        n *= VolumeMask(p);\n\n        // extinction coefficient\n        float sigma = n * 32.0;\n\n        // optical depth\n       #ifdef SELECT_MODE_A\n        float tau0 = tau + sigma * (stepSize * (d0 - dot(d0_prev, mm)));\n       #else\n        float tau0 = tau + sigma * (stepSize * (d0 - d0_prev0));\n       #endif\n       \n        // transmittance\n        float T0 = exp2(-tau0);\n\n        // extinction probability\n        float extProp = T_prev - T0;\n\n        // color\n        float limb = Pow2(1.0-exp2(-n*3.0));\n\n        vec3 c  = normalize(p) * 0.5 + 0.5;\n             c *= mix(vec3((1.0-c.b)*0.25, 0., c.b*0.75), vec3(1.0, 0.9, 0.2), limb);\n\n        col += extProp * c * w0;\n\n\n        tau    = mix(tau, tau0, w0);\n        T_prev = mix(T_prev, T0, w0);\n       \n        // break if transmittance gets low\n        if(T_prev < 1.0/64.0) { break; }\n            \n       #ifdef SELECT_MODE_A\n        n0_prev = mix(n0_prev, vec3(n0), mm);\n        d0_prev = mix(d0_prev, vec3(d0), mm);\n       #else\n        if(type == 0.0)\n        {\n            n0_prev.x = n0;\n            d0_prev.x = d0;\n        }\n        else if(type == 1.0)\n        {\n            n0_prev.y = n0;\n            d0_prev.y = d0;\n        }\n        else if(type == 2.0)\n        {\n            n0_prev.z = n0;\n            d0_prev.z = d0;\n        }\n       #endif\n    }\n\n\n//return vec3(mxD/count < 0.39 ? 1.0 : 0.0);\n\n    return col * 1.5;\n}\n\n//----------------------------------------------------------------------------------------------------------------//\n\n\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_TAB 9\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n        \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    //vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n        \n    vec2 ang = vec2(1.5 * Pi, Pi * -0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    // orbit camera setup\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    // ray pos + dir\n    vec3 rp = -cmat[2] * exp2(0.75 + mouseAccu.w * 0.02);\n    //if(uv0.x>iResolution.x*0.5)uv0.x-=iResolution.x*0.5;\n    vec2 tc = uv0 * (1.0 / (iResolution.xx*0.5)) - vec2(1.0, iResolution.y/iResolution.x);\n\n    vec3 rd = normalize(cmat * vec3(tc, 0.9)); \n    \n    \n    bool useStructured = ReadKeyToggle(KEY_TAB) == 0.0;\n    \n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    {\n        // show sampling planes\n        \n        vec4 bnoise;\n        {\n            uvec2 noff = uint(iFrame) * uvec2(3242174893u, 2447445397u);\n\n            bnoise = texelFetch(iChannel3, ivec2((uvec2(uv-0.5) + noff) & 1023u), 0);\n            bnoise = MixBlueNoiseBits(bnoise);// use if 8 bits per channel are not enough\n        }\n        \n        vec3 N0, N1, N2, w;\n        vec3 N = QuantizeDirection(rd, 0.25, bnoise.x, \n                                   /*doUseTruncIco:*/ false, /*doUseKernB:*/ false, /*doSort:*/ true, \n                                   /*out:*/ N0, N1, N2, w);\n       \n        float count = (w.x != 0.0 ? 1.0 : 0.0) + \n                      (w.y != 0.0 ? 1.0 : 0.0) + \n                      (w.z != 0.0 ? 1.0 : 0.0);\n        \n        if(ReadKeyToggle(KEY_CTRL) == 0.0)\n        {\n           if(useStructured)\n            col = N * 0.5 + 0.5;\n           else\n            col = rd*0.5+0.5;\n        }\n        else\n        {\n            col = vec3((count-1.0)*0.5);\n        }\n        \n        outCol = vec4(GammaEncode(clamp01(col)), 1.0);\n        return;\n    }\n    \n    \n#if 1\n    // select raymarching routine\n    \n   #if 1\n   \n   if(useStructured)\n    col = RaymarchScene_StructuredStochastic(rp, rd, uv);\n   else\n    col = RaymarchScene(rp, rd, uv);\n   \n   #elif 1\n   \n    col = RaymarchScene(rp, rd, uv);\n    \n   #elif 1\n   \n    col = RaymarchScene_StructuredStochastic(rp, rd, uv);\n    \n   #else\n   \n    col = RaymarchScene_Structured(rp, rd, uv);\n    \n   #endif\n    \n#else\n{\n    // testing performance; loop a few times to push under 60 fps\n    float count = 9.0;\n    \n    count = min(count, iResolution.x);// prevent loop unroll\n    for(float i = 0.0; i < count; ++i)\n    {\n        vec3 rp0 = rp + vec3(0.125) * i;\n        \n       #if 0\n\n        col += RaymarchScene(rp0, rd, uv);\n\n       #elif 1\n\n        col += RaymarchScene_StructuredStochastic(rp0, rd, uv);\n\n       #else\n\n        col += RaymarchScene_Structured(rp0, rd, uv);\n\n       #endif\n    }\n    col /= count;\n}\n#endif\n\n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, the author has waived all copyrights and related or neighboring rights to this work.\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//====================================================================================================================================//\n// \n\n/* dodecahedral/truncated icosahedral quantization of a given direction [dir]\n\n   [dir]: normalized vector | [rad]: blend radius [0,1] | [rnd]: random number [0,1]\n   \n   [doUseTruncIco]: quantize to face directions of truncated icosahedron instead of regular dodecahedron\n   [doUseKernB]:    instead of the simple spherical blend kernel use one that is more expensive but works better for small [rad]\n   [doSort]:        sort the found directions so that correlation structures in [rnd] do not break (use this if [rnd] is blue noise)\n\n   out:    the closest 3 directions [dirA/B/C] + their blend weights [w.xyz] \n   return: one of the 3 closest directions (sampled according to their weights [w.xyz] using [rnd])  \n*/\nvec3 QuantizeDirection(vec3 dir, float rad, float rnd, \n                       const bool useTruncIco, const bool useKernB, const bool sortDirs, \n                       out vec3 dirA, out vec3 dirB, out vec3 dirC, out vec3 w)\n{\n    //--------------------------------------------------------------------------//\n    // this part is based on: https://www.ppsloan.org/publications/AmbientDice.pdf\n    const float kT = 0.618034;\n    const float kT2 = kT * kT;\n    \n    const float a = 0.850651; \n    const float b = 0.525731;\n    \n    vec3 octantSign = vec3(dir.x < 0.0 ? -1.0 : 1.0,\n                           dir.y < 0.0 ? -1.0 : 1.0,\n                           dir.z < 0.0 ? -1.0 : 1.0);\n                           \n    vec3 adir = abs(dir);\n    \n    // vertex coordinates\n    vec3 vertA = vec3(a, b, 0.0);\n    vec3 vertB = vec3(0.0, a, b);\n    vec3 vertC = vec3(b, 0.0, a);\n    \n    vec3 vertAflipped = vec3(-b, 0.0, a);\n    vec3 vertBflipped = vec3(a, -b, 0.0);\n    vec3 vertCflipped = vec3(0.0, a, -b);\n    \n    // selection\n    bool vertAselect = dot(adir, vec3(1.0, kT2, -kT)) > 0.0;\n    bool vertBselect = dot(adir, vec3(-kT, 1.0, kT2)) > 0.0;\n    bool vertCselect = dot(adir, vec3(kT2, -kT, 1.0)) > 0.0;\n    \n    vec3 v0 = vertAselect ? vertA : vertAflipped;\n    vec3 v1 = vertBselect ? vertB : vertBflipped;\n    vec3 v2 = vertCselect ? vertC : vertCflipped;\n\n    v0 *= octantSign;\n    v1 *= octantSign;\n    v2 *= octantSign;\n    //--------------------------------------------------------------------------//\n\n    if(useTruncIco)\n    {\n        {\n            // sort vertices\n            vec4 tmp;\n\n            vec4 t0 = vec4(v0, dot(v0, dir));\n            vec4 t1 = vec4(v1, dot(v1, dir));\n            vec4 t2 = vec4(v2, dot(v2, dir));\n\n            if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n            if(t1.w < t2.w) { tmp=t1; t1=t2; t2=tmp; }\n            if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n\n            v0 = t0.xyz;\n            v1 = t1.xyz;\n            v2 = t2.xyz;\n        }\n\n        // compute dodecahedron vertices vA and vB\n        vec3 vA = (v0 + v1 + v2) * 0.41947;\n\n        vec3 N = cross(v0, v1);// normal of mirror plane \n\n        //vec3 vB = vA - normalize(N) * (2.0 * dot(vA, normalize(N)));\n        vec3 vB = vA - N * (2.5 * dot(vA, N));// mirror vA\n\n        // new triangle {v0, vA, vB}\n        v1 = vA;\n        v2 = vB;    \n    }\n\n    if(sortDirs)\n    {\n        // sort vertices (to not break structure of correlated noise)\n        const vec3 dw = vec3(1.0, 1.0, 2.0);\n        vec4 tmp;\n        \n        vec4 t0 = vec4(v0, dot(v0, dw));\n        vec4 t1 = vec4(v1, dot(v1, dw));\n        vec4 t2 = vec4(v2, dot(v2, dw));\n        \n        if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n        if(t1.w < t2.w) { tmp=t1; t1=t2; t2=tmp; }\n        if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n        \n        v0 = t0.xyz;\n        v1 = t1.xyz;\n        v2 = t2.xyz;\n    }\n           \n    if(!useKernB)\n    {\n        // spherical kernel\n        float o = useTruncIco ? mix(0.9224, 0.8508  , rad) : \n                                mix(0.7944, 0.525731, rad);\n                                  \n        float a = 1.0 / (1.0 - o);\n        float b =  -o / (1.0 - o);\n        \n        w.x = clamp01(dot(dir, v0) * a + b);\n        w.y = clamp01(dot(dir, v1) * a + b);\n        w.z = clamp01(dot(dir, v2) * a + b);\n    \n       #if 1\n        w *= w;\n       #else\n        w = w*w * (1.5 - 0.5*w);\n       #endif     \n    }\n    else\n    {\n        // pentagonal/hexagonal kernel\n        if(useTruncIco)\n        {\n            // point on triangle\n            //vec3 p = length((v0+v1+v2)/3.0) / dot(normalize(v0+v1+v2), dir) * dir;\n            vec3 p = 2.556443 / dot(v0+v1+v2, dir) * dir;\n\n            // edge-relative coordinates\n            float l01 = dot(v1-v0, v1-v0);\n            float l02 = dot(v2-v0, v2-v0);\n            float l12 = dot(v2-v1, v2-v1);\n\n            float u01 = dot(p-v0, v1-v0) * (l01 < l02+0.0625 ? 2.434920 : 1.963525);\n            float u02 = dot(p-v0, v2-v0) * (l02 < l12+0.0625 ? 2.434920 : 1.963525);\n            float u12 = dot(p-v1, v2-v1) * (l12 < l02+0.0625 ? 2.434920 : 1.963525);\n\n            // hexa-/pentagonal vertex weights\n            float w0 = 1.0-max(u01, u02);\n            float w1 = min(u01, 1.0-u12);\n            float w2 = min(u02,     u12);\n\n             w = vec3(w0, w1, w2);\n        }\n        else\n        {\n            // point on triangle\n            vec3 p = 1.894427 / dot(v0+v1+v2, dir) * dir;\n\n            // edge-relative coordinates\n            float u01 = dot(p-v0, v1-v0) * 0.904508;\n            float u02 = dot(p-v0, v2-v0) * 0.904508;\n            float u12 = dot(p-v1, v2-v1) * 0.904508;\n\n            // pentagonal vertex weights\n            float w0 = 1.0-max(u01, u02);\n            float w1 = min(u01, 1.0-u12);\n            float w2 = min(u02,     u12);\n\n            w = vec3(w0, w1, w2);\n        }\n\n        // compress + shape weight falloffs\n        float a = 1.0 / (rad*0.5);\n        float b = -(0.5-rad*0.25) * a;\n\n        w = clamp01(w * a + b);// compress\n        w = w*w * (3.0 - 2.0 * w);// s-curve\n    }\n \n    // normalize weights\n    w *= 1.0 / (w.x + w.y + w.z);\n\n   #if 0\n    if(!sortDirs)\n    {\n        // sort vertices (_might_ improve execution efficiency (but breaks noise))\n        vec4 tmp;\n        \n        vec4 t0 = vec4(v0, w.x);\n        vec4 t1 = vec4(v1, w.y);\n        vec4 t2 = vec4(v2, w.z);\n        \n        if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n        if(t1.w < t2.w) { tmp=t1; t1=t2; t2=tmp; }\n        if(t0.w < t1.w) { tmp=t0; t0=t1; t1=tmp; }\n        \n        v0 = t0.xyz;\n        v1 = t1.xyz;\n        v2 = t2.xyz;\n        \n        w = vec3(t0.w, t1.w, t2.w);\n    }\n   #endif\n    \n    dirA = v0;\n    dirB = v1;\n    dirC = v2;\n    \n    // draw a sample from the discrete probability distribution {w.x, w.y, w.z}\n    return rnd <  w.x        ? v0 : \n           rnd < (w.x + w.y) ? v1 : v2;\n}\n\n//====================================================================================================================================//\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n// increases bit depth of 8 bit per channel blue noise texture\nvec4 MixBlueNoiseBits(vec4 bnoise)\n{\n   const vec4 a = exp2(-vec4(0.0, 8.0, 16.0, 24));\n   const vec4 b = a / (a.x + a.y + a.z + a.w);\n\n   return vec4(dot(bnoise.xyzw, b), \n               dot(bnoise.yzwx, b), \n               dot(bnoise.zwxy, b), \n               dot(bnoise.wxyz, b));\n}\n\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n    vec2 c1 = vec2(cos(ang), sin(ang));\n    \n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nfloat cubic(float x) {return x*x * (3.0 - 2.0 * x);}\nvec2  cubic(vec2  x) {return x*x * (3.0 - 2.0 * x);}\nvec3  cubic(vec3  x) {return x*x * (3.0 - 2.0 * x);}\nvec4  cubic(vec4  x) {return x*x * (3.0 - 2.0 * x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n\nvec4 VNoise4(vec3 p, vec4 aniS, float time, sampler2D noise64x64)\n{\n    vec3 ip = floor(p);\n    vec3 fp = p - ip;\n    \n    #if 1\n    fp = cubic(fp);\n    p = ip + fp;\n    #endif\n    \n    const float texDim = 64.0;\n    const vec2 prime = vec2(53.0, 41.0);// primes < texDim\n    \n    const float txlDim = 1.0 / texDim;\n    const vec2 pmul = prime * txlDim;\n    const float o0 = 0.5 * txlDim;\n    const vec2 o1 = (prime + 0.5) * txlDim;\n\n    vec2 tex = p.xz * txlDim + ip.y * pmul;\n\n    vec4 n0 = textureLod(noise64x64, tex + o0, 0.0);\n\tvec4 n1 = textureLod(noise64x64, tex + o1, 0.0);\n    \n    //float l0 = textureLod(iChannel1, (p.xz + ip.y         * prime + 0.5) * txlDim, 0.0).x;\n\t//float l1 = textureLod(iChannel1, (p.xz + (ip.y + 1.0) * prime + 0.5) * txlDim, 0.0).x;\n    \n    vec4 n = mix(n0, n1, fp.y);\n    \n    //float r = n.z;\n    //vec4 r = lerp(n.xyzw, n.zwxy, sin(Time * aniS + n.yzwx*Pi2)*.5+.5);\n    //vec4 r = lerp(n.xyzw, n.zxwy, sin(Time * aniS + n.wzyx*Pi2)*.5+.5);\n    vec4 r = mix(n.xyzw, 1.0-n.wzyx, sin(time * aniS + n.zxwy*Pi2)*.5+.5);\n   \n    return r * 2.0 - 1.0;\n}\n\nvec4 Fbm32(vec3 p, vec3 off, float time, sampler2D noise64x64)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n    \n    vec4 res = vec4(0.0);\n    \n    float accu_w = 0.0;\n    vec2 w = vec2(1.0);\n    float aniS = 1.2;\n    \n   #if 1\n    res.yzw = VNoise4(p, vec4(0.8, 0.9, 1.1, 1.2) * aniS, time, noise64x64).wyz * 0.5;\n    p.xy = CmplxMul(p.xy, rot);\n    p = p.yzx;\n    p += off;\n   #endif\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n       #if 0\n        vec3 p2 = p + ((res.yzw*res.zwy) - 0.)*8.0;\n       #else\n        vec3 p2 = p + (abs(res.yzw) - 0.5)*2.5;\n       #endif\n        \n        p2.z -= time * 0.2;\n        \n        vec4 v = VNoise4(p2, vec4(0.8, 0.9, 1.1, 1.2) * aniS, time, noise64x64);\n        \n        w.y *= 0.7;\n        \n        res += v * w.xyyy; \n        accu_w += w.x;\n        \n        //res.yz = res.zy;\n        res = res.xwyz;\n        \n        aniS *= 1.9;        \n        w.x *= 0.5;\n        p *= 2.4;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n        p += off;\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\nfloat TrigNoise(vec3 x, float a, float b)\n{\n    vec4 u = vec4(dot(x, vec3( 1.0, 1.0, 1.0)), \n                  dot(x, vec3( 1.0,-1.0,-1.0)), \n                  dot(x, vec3(-1.0, 1.0,-1.0)),\n                  dot(x, vec3(-1.0,-1.0, 1.0))) * a;\n\n    return dot(sin(x     + cos(u.xyz) * b), \n               cos(x.zxy + sin(u.zwx) * b));\n}\n\nfloat TrigNoise(vec3 x)\n{\n    return TrigNoise(x, 2.0, 1.0);\n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\nvec3 SphereFromDisk(vec2 u)\n{\n    float d = dot(u, u);\n    float l = sqrt(4.0 - 4.0 * d);\n    \n    return vec3(u.x * l, \n          1.0 - 2.0 * d, \n                u.y * l);\n}\n\nvec3 SphericalCapFromDisk(vec2 u, float cosAng)\n{\n    u *= sqrt(1.0 - cosAng);\n    \n    float d = dot(u, u);\n    float l = sqrt(2.0 - d);\n    \n    return vec3(u.x * l, \n                1.0 - d, \n                u.y * l);\n}\n\nvec2 DiskFromSphere(vec3 s)\n{\n    return s.xz * inversesqrt(s.y * 2.0 + 2.0);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\nvec3 Sample_SphericalCap(float s0, float s1, vec3 N, float cosAng)\n{\n    vec3 p = Sample_Sphere(s0, s1);\n    \n    vec3 pN = N * dot(p, N);\n    vec3 pO = p - pN;\n    \n    vec3 u = pO * inversesqrt(dot(p, N) * 2.0 + 2.0);\n    \n    u *= sqrt(1.0 - cosAng);\n    \n    float d = dot(u, u);\n    float l = sqrt(2.0 - d);\n    \n    return u*l + N*(1.0-d);\n}\n\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\nvec2 Sample_Triangle(vec2 s) { return vec2(Sample_Triangle(s.x), Sample_Triangle(s.y)); }\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n", "buffer_a_code": "/* program state */\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    if(uv0.y != 0.5) discard;\n    \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float angAccuLast = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    float angAccu = clamp(angAccuLast + (kD - kA)*0.05, 0.0, Pi);\n    \n    if(iFrame == 0 || iFrame == 1) angAccu = Pi * 0.25;\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n    if(uv.x == 3.0 && uv.y == 0.0) col = vec4(angAccu);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfDc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[4553, 4657, 4677, 4677, 4752], [4754, 4833, 4857, 4857, 5228], [5230, 5230, 5258, 5332, 5558], [5560, 5560, 5586, 5586, 5808], [5929, 5963, 6010, 6010, 7758], [7878, 7968, 8036, 8036, 11839], [11959, 11959, 11981, 11981, 12110], [12112, 12254, 12312, 12312, 17435], [17638, 17638, 17672, 17672, 17726], [17729, 17729, 17775, 17775, 21097]], "test": "untested"}
{"id": "4d2BWc", "name": "Volumetric clouds test", "author": "Karambit", "description": "Use click and drag to move the camera", "tags": ["cloudsvolumetric"], "likes": 0, "viewed": 109, "published": 3, "date": "1616024715", "time_retrieved": "2024-07-30T19:32:07.086355", "image_code": "#define Scale vec3(.8, .8, .8)\n#define K 19.19\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nvec3 LightPosition = vec3(0.0, -50.0, 0.0);\nfloat metallic = 1.0;\nfloat roughness = 1.0;\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p + vec3(.0, .5, .0))-b,.0))-r;\n}\n\n////////////////////////\n\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * Scale);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 noise( in vec3 x )\n{\n    return texture(iChannel0, x*0.1).rgb;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n            vec3 f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.04; \n            f += 0.03125*noise( q ); q = m*q*2.05; \n    return vec3(f);\n}\n\n////////////////\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat voronoi(in vec3 Pos, in float mult) {\n\n    vec3 uv = Pos * mult;\n    float dst = 10.;\n    for(int i = -1; i <= 1; i++)\n        for(int j = -1; j <= 1; j++)\n        \tfor(int k = -1; k <= 1; k++){\n            vec3 offset = vec3(i, j, k);\n            float rand = hash13(floor(uv) + offset);\n    \t\tdst = min(dst, length(fract(uv) - offset - rand));\n        }\n    \n    return smoothstep(0.2, 0.8, 1.0-dst);\n}\n//468.47\nfloat getDensity(in vec3 p) {\n\n    float f = pow( fbm(p*vec3(0.1 + p.y*0.004)+ vec3(iTime*0.1, 0.0, iTime*0.1)).x , 2.5 );\n    f = clamp(f, 0.01, 0.2);\n    f = smoothstep(0.1, 0.99, f)*1.5;\n    float v = voronoi(p + vec3(iTime, iTime, iTime) * vec3(0.5, 0.5, 0.5),0.1);\n    //return 0.05;\n    return clamp(v*f, 0.0, 1.0) * 0.8;\n    \n}\n\nfloat mapVolume(in vec3 p) {\n    vec3 q = vec3(0.0, -25.0, -20.0);\n    float sphere = sdSphere(p+q, (17.0));\n    q = vec3(0.0, -25.0, -20.0);\n    float sphere2 = sdSphere(p+q, (20.0));\n    \n    q = vec3(0.0, -35.0, -20.0);\n    float box5 = udBox(p+q, vec3(50.0, 10.0, 50.0));\n    \n    float box2 = udRoundBox(p+q, vec3(50.0, 2.0, 50.0), 0.2);\n    \n    return max(max(sphere2, -sphere), box5);\n}\n\n\nfloat lightMarch(in vec3 p, in float stepSize) {\n    //Lets march towards the light\n    vec3 lv = -LightPosition - p;\n    vec3 ld = -normalize(lv)*5.0;\n    ld = normalize(vec3(0.0, 1.0, 0))*2.0;\n    float laccum = 0.0;\n    float h = -1.0;\n    float t = 0.0;\n    vec3 pos = p+ld*stepSize;\n    for(int i = 0; i < 50; i++) {\n    \n        stepSize += 0.001;\n        t += stepSize;\n        pos = p+ld*t;\n        h = mapVolume(pos);\n        if(h > 0.0) {\n            break;\n        }\n        laccum += getDensity(pos);\n    }\n    return laccum;\n}\n\nfloat intersectVolume(in vec3 ro, in vec3 rd, in float stepSize, out float tr, out vec3 e) {\n    const int MAX_STEPS_OUTSIDE = 100;\n    const int MAX_STEPS_INSIDE = 150;\n    //Get to the outer part of the volume\n    const float maxd = 150.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<MAX_STEPS_OUTSIDE; i++ )\n    {\n        if( h<0.01 || t>maxd ) break;\n\t    h = mapVolume( ro+rd*t);\n        t += h;\n    }\n\n    if( t>maxd ) { \n        t=-1.0;\n        tr = 1.0;\n        return t;\n    }\n    \n    float newT = t;\n    float oldT = t;\n    t = 0.0;\n    //float D = 0.0;\n    \n    int steps = 0;\n    //Now we have the distance to our volume, let's go inside\n    //if(h<0.0)\n    //    ro = ro;\n    //else\n        ro = ro+rd*newT;\n        \n    h = 0.0;\n        \n    vec3 LightEnergy = vec3(0.0);\n    float LightTransmittance = 0.0;\n    float Transmittance = 1.0;\n    float Distance = 0.0;\n    float Density = 0.0;\n    float Absorption = 3.25;\n    float Phase = 0.5;\n     \n    while(true) {\n        if(steps >= MAX_STEPS_INSIDE) return oldT;\n        stepSize += 0.001;\n        t += stepSize + (texture(iChannel2, ro.xy).x*0.05);\n        vec3 pos = ro+rd*t;\n\t    h = mapVolume(pos);\n        \n        if(h > 0.0) break;\n        \n        Density += getDensity(pos);\n        \n        if(Density > 0.0) {\n            stepSize = stepSize;\n            LightTransmittance = lightMarch(pos, stepSize);\n            LightEnergy -= Density * stepSize * Transmittance * LightTransmittance * Phase;\n            Transmittance *= exp(-Density * stepSize * Absorption);\n            \n            if(Transmittance < 0.01) {\n                break;\n            }\n        }\n        steps++;\n        \n        /**/\n        float shadowdist = 0.0;\n\n        vec3 lpos = normalize(vec3(0.0, 1.0, 0))*10.0;\n        lpos += clamp(vec3(0.0,0.05, 0.0), 0.0, 1.0);\n        float lsample = getDensity(lpos);\n        shadowdist += lsample;\n        lpos += vec3(0.0,0.1, 0.0);\n        lsample = getDensity(lpos);\n        shadowdist += lsample;\n        lpos += vec3(0.0,0.2, 0.0);\n        lsample = getDensity(lpos);\n        shadowdist += lsample;\n\n        vec3 SkyColor = vec3( 0.45, 0.68, 0.88 )*0.9;\n        //vec3 SkyColor = normalize(vec3(236, 194, 255))*1.0;\n        \n        //shadowdist /= 3.0;\n\n        //shadowterm = exp(-shadowdist * AmbientDensity);\n        //absorbedlight = exp(-shadowdist * AmbientDensity) * curdensity;\n        LightEnergy += exp(-shadowdist *1.0) * Density * SkyColor * Transmittance;\n\n\n        /**/\n    }\n    \n    float l = -lightMarch(ro+rd*t, stepSize);\n    vec3 pos = ro+rd*t;\n    Density = getDensity(pos);\n    \n    //LightEnergy *= mix(LightEnergy, vec3( 0.45, 0.68, 0.88 )*3.0, 1.0-LightEnergy);//Density * vec3( 0.45, 0.68, 0.88 ) * 0.1;\n    \n    \n    \n    e = LightEnergy;\n    tr = clamp(Transmittance, 0.0, 1.0);\n    //D\n    return oldT;\n    \n}\n\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    rd = CameraRotation(m) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 q = uv * 2.0 - 1.0;\n\tq.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, -20.0 );\n    vec3 rd = normalize( vec3(q,1.0) );\n    \n    Camera(fragCoord, ro, rd);\n\tvec3 col = vec3(0.0);\n       \n    //LightPosition.y = sin(iTime*0.3) * -30.0;\n    \n    vec3 backcol = mix(vec3( 0.92, 0.95, 0.99 ), vec3( 0.45, 0.68, 0.88 ), clamp(vec3(rd.y) + 0.2, 0.0, 1.));\n    \n    float tr = 0.0;\n    vec3 e = vec3(0.0);\n    float t2 = -1.0;\n    //if(rd.y > 0.0)\n    t2 = intersectVolume(ro,rd, 0.2, tr, e);\n    vec3 lightCol = vec3(0.9, 0.6, 0.45);\n    //vec3 lightCol = normalize(vec3(255, 205, 156));\n    col = backcol;\n    //if( t2>0.0   )\n    {\n        e = clamp(e, 0.0, 1.0);\n        vec3 cloudCol = (vec3(e) * (lightCol*2.0));//vec3( 0.98, 0.95, 0.87 )) ;\n        col = backcol * (tr/* + abs(min(0.0,t2))*/) + cloudCol;//vec3(exp(-l));//clamp(vec3(l/10.0), 0.0, 1.0);\n        //col = vec3(v);\n    }\n    \n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}", "buffer_a_code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 25.0, 30.0, 0.0));\n        store(TARGET, vec4(0.0, 25.0, 30.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 5.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 266, 266, 304], [306, 306, 340, 340, 363], [365, 365, 410, 410, 468], [497, 497, 517, 517, 622], [624, 624, 649, 649, 693], [820, 820, 841, 841, 1121], [1141, 1141, 1164, 1164, 1267], [1269, 1269, 1312, 1312, 1679], [1680, 1689, 1718, 1718, 2023], [2025, 2025, 2053, 2053, 2419], [2422, 2422, 2470, 2505, 2961], [2963, 2963, 3055, 3055, 5834], [5889, 5889, 5948, 5948, 6186], [6189, 6189, 6246, 6246, 7244]], "test": "untested"}
{"id": "fsfGW7", "name": "Spring Dynamics Experiments", "author": "oneshade", "description": "Experimenting with a spring to see what patterns it makes.", "tags": ["2d", "simulation", "experiments", "physics", "spring", "softbody"], "likes": 10, "viewed": 269, "published": 3, "date": "1616018433", "time_retrieved": "2024-07-30T19:32:08.036814", "image_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    fragColor.rgb = vec3(0.0);\n    for (int p=1; p < JOINTS; p++) {\n        vec2 joint = getJoint(p).pos;\n        float dist = sdLine(uv, getJoint(p - 1).pos, joint);\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), exp(-50.0 * dist) * 2.0);//smoothstep(unit, 0.0, dist));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Pick 0-5\n#define EXPERIMENT 4\n\nstruct Joint {\n    vec2 pos;\n    vec2 vel;\n    float mass;\n};\n\n#define getJoint(id)                                 \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xy, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xy, \\\n          MASS)                                      \\\n\n#define JOINTS 25\n#define SIZE 0.01\n#define MASS 5.0\n\n#define GRAVITY 0.001\n#define SPRINGINESS 0.5\n#define DAMPING 0.99\n#define LENGTH 0.01", "buffer_a_code": "// Precomputed DFT and time step\nconst vec3[] dft = vec3[](vec3(0.06624063016083806, 0, 0.526467084606694), vec3(0.30403405427967967, 1, 2.186928193382259), vec3(0.1094018268849255, 2, 2.6446809202082924), vec3(0.0630682607539452, 3, 2.648215879385702), vec3(0.02379875395219672, 4, 0.033017062820374546), vec3(0.06698106925399928, 5, 0.7759976669433638), vec3(0.026287177763530078, 6, 0.5921211565620248), vec3(0.0564450154244258, 7, -2.491968482284073), vec3(0.016461866689664317, 8, 2.5796524144302184), vec3(0.013695954373753996, 9, 1.9976323584197104), vec3(0.03378343048580025, 10, 0.02482750162651745), vec3(0.016910940065752927, 11, -0.7790385201174097), vec3(0.01673095828298025, 12, -2.983880695316723), vec3(0.02495941770182371, 13, -1.0290464301803453), vec3(0.0033466958119220762, 14, -1.9751437421010822), vec3(0.023458727303844597, 15, -2.671445765551377), vec3(0.01539351240569818, 16, -0.8546676408828914), vec3(0.008620199168363188, 17, -2.554392951329515), vec3(0.006553513197034149, 18, 0.3255355723070354), vec3(0.005532650262379593, 19, 0.41900668047278), vec3(0.008541617060595367, 20, -1.5405585895452818), vec3(0.008825691196333732, 21, 1.0431591228744415), vec3(0.0012394082829978877, 22, 2.8575489672317054), vec3(0.001227717785595474, 23, 1.8670831836523107), vec3(0.0037504149099205236, 24, -1.932286728288171), vec3(0.001632526957947103, 25, -1.7372935977158408), vec3(0.004136748593989515, 26, -2.6340076994886688), vec3(0.0031397639874249255, 27, -0.7588742184904), vec3(0.004235722704459997, 28, -1.7401476374432354), vec3(0.002506185533509978, 29, -0.20735072683041092), vec3(0.0016341235587301241, 30, 0.8301487332713536), vec3(0.0027552647051842178, 31, -0.008590678750737928), vec3(0.0009520822430286851, 32, 3.0428446795182733), vec3(0.0023400549238494273, 33, -0.9610689855035858), vec3(0.001455602014543646, 34, 1.532239799562235), vec3(0.0024274636780121164, 35, -2.2982201296953386), vec3(0.0019461179800159072, 36, -0.7129523688717229), vec3(0.0018117163953017554, 37, -1.750943329322435), vec3(0.001644759801017308, 38, -2.330601638650922), vec3(0.0013895297107131064, 39, 2.030929305417917), vec3(0.0002508977876271399, 40, 1.5243653670062753), vec3(0.0011625103793400863, 41, -0.55301213523844), vec3(0.0001292542202948434, 42, -1.3024921353253258), vec3(0.0015858346652633693, 43, -1.5223745224052172), vec3(0.0016030138232809568, 44, -0.09906478557975977), vec3(0.0009820257574831314, 45, -1.9418111188611775), vec3(0.0013681156279721494, 46, -0.5483918892074371), vec3(0.0002550317559471833, 47, -0.45080354798265554), vec3(0.00021820183096853786, 48, -3.0408529102689563), vec3(0.00024426484332416224, 49, -1.640451241045797), vec3(0.0004655975631407837, 50, 0.5059171292751394), vec3(0.00047905790369020596, 51, 2.002136441384105), vec3(0.0004495997795090082, 52, -1.2959751654108225), vec3(0.000706090732924486, 53, -0.22312743564222917), vec3(0.00020592376687281896, 54, 1.4134018146300324), vec3(0.0007839484403523764, 55, -1.3006466225476623), vec3(0.0004434130419011939, 56, 0.48588142647244187), vec3(0.000696948524174033, 57, 2.5185198861817195), vec3(0.0002642347947368044, 58, -1.4702994471881408), vec3(0.0007889585503448085, 59, 2.8805159981024255), vec3(0.0005454815801849562, 60, -0.5491529026785559), vec3(0.000488494463110838, 61, -1.055036389936873), vec3(0.00040451996309537927, 62, -1.3538385226486893), vec3(8.235787653092511e-05, 63, 0.46996631539450173), vec3(0.0007116589185112069, 64, -0.3923681936672665), vec3(0.0006788874254429313, 65, 2.01598556713107), vec3(0.0003716447418093542, 66, -0.07962288849680876), vec3(0.0007361090049541833, 67, 1.1030827695217629), vec3(0.0008925231440608768, 68, -2.239958855509421), vec3(5.2295214618210214e-05, 69, -1.4582402167477988), vec3(0.0002542497903329945, 70, 2.487342088175135), vec3(0.00035310030843398383, 71, -1.4944674824950626), vec3(8.379706034354979e-05, 72, 0.9380415509992198), vec3(0.0005291325370133819, 73, -0.08648593800360635), vec3(0.0003770039243353579, 74, -0.8834654487484704), vec3(0.0004324587306587596, 75, 0.3709320155704721), vec3(0.00035623729383477256, 76, -1.2461274593896225), vec3(0.00031084082407892397, 77, 3.096505341353109), vec3(0.0004479006554867876, 78, 2.852062146723096), vec3(0.000336118858746581, 79, 0.5075639072369276), vec3(0.0003697780598090739, 80, 2.6696861905848244), vec3(0.00013433727271411984, 81, -1.6648202259014968), vec3(0.00011256095221966272, 82, 2.3117243617709553), vec3(0.00019492074781952352, 83, -2.7510631725521812), vec3(0.0005659405526126023, 84, 0.014541250859890494), vec3(0.00021588303097535148, 85, -2.509868718867894), vec3(0.0006630323087425981, 86, -0.475910667524325), vec3(0.00016537361194970035, 87, 1.7639141067523032), vec3(0.0001744997868821082, 88, 0.0686516494804399), vec3(0.00016386967311280857, 89, -0.8512508553053074), vec3(0.00039632659774993154, 90, 1.9563134208966622), vec3(0.0004897373370342829, 91, -0.680979821655123), vec3(0.00011834259424044262, 92, 1.3802571851892522), vec3(0.00025121291845813177, 93, 1.9415334754484221), vec3(3.1593982904385904e-06, 94, 1.1568655694395293), vec3(0.0001518840801164731, 95, -0.5264419692232939), vec3(0.00033569785640513147, 96, 1.5683479086911993), vec3(0.0005340023676899359, 97, -0.9673022437485693), vec3(0.00018902395699116404, 98, 0.9300765099489335), vec3(0.0002295536475429094, 99, 0.6321794964364887), vec3(0.0002669389166218816, 100, 1.5496323284152087), vec3(7.026034180043295e-05, 101, 0.6353007200564902), vec3(0.00018018422339888412, 102, -1.0925296432217835), vec3(0.00043093314146106545, 103, 3.122087005680385), vec3(0.0002713303017164963, 104, 1.0727937758559145), vec3(0.00024808286169333745, 105, -0.19703661052468396), vec3(0.00027590635624680243, 106, -1.7235605805256504), vec3(8.514839627670227e-05, 107, -0.921076774563906), vec3(0.00014273603278305838, 108, 1.5597008459962591), vec3(0.0002536862110701469, 109, 1.3514893479316772), vec3(0.00023367060515308113, 110, 2.707851051911518), vec3(0.0001475764996857795, 111, -0.5771397645973079), vec3(0.000602908608316128, 112, -0.8594551422833137), vec3(4.474878191084281e-05, 113, -1.6847307647029455), vec3(0.000309117574351459, 114, 1.3950407557721594), vec3(0.0002658538052996598, 115, 0.7514679430313529), vec3(0.00020264564021431182, 116, -2.1631565643238657), vec3(0.00040300214829498465, 117, 0.3094392195138682), vec3(0.0001443085670099963, 118, -1.6961452170278206), vec3(8.572964845071289e-05, 119, 2.796055774196669), vec3(0.0002478690041330533, 120, 1.768191886644194), vec3(9.115717707162411e-05, 121, 1.1244803512331298), vec3(0.00020566186615398035, 122, -0.0220746113572309), vec3(0.0002446885937851877, 123, -3.1126758958846312), vec3(0.0001803529348512403, 124, 0.4967945268150022), vec3(9.218150584724272e-05, 125, -2.938111999138144), vec3(0.00010645791647608324, 126, 0.6281948452510312), vec3(1.8007506310629485e-05, 127, -0.9402286701782262), vec3(0.00022965721005805244, 128, -2.02643363162777), vec3(0.00034007275950823367, 129, 1.849247307521242), vec3(0.0003901382295342529, 130, -0.31213043456063094), vec3(0.00018795552507509854, 131, 0.689905256912966), vec3(0.00019213346002572954, 132, -2.0812149069523262), vec3(0.0002194592184931298, 133, -0.21174911964549323), vec3(0.00013085087502505535, 134, -2.996815233864796), vec3(0.0004067570577306288, 135, 0.9892402745606376), vec3(0.0001294954675890351, 136, 2.1071351605370463), vec3(0.0003944993385546763, 137, -0.870294979285821), vec3(0.0003528383426190965, 138, 0.7157585221979605), vec3(0.0005445160374880394, 139, 2.996129746250755), vec3(1.5178721963384476e-05, 140, 1.028098122537589), vec3(0.000388257182155784, 141, 2.3691338391920387), vec3(0.00015917076481967573, 142, 0.16075049363255353), vec3(0.00010309025336422626, 143, -1.164413334995483), vec3(0.00016120581004004653, 144, 2.1796969546771296), vec3(0.0002494129657859731, 145, 0.4762915633051456), vec3(0.00036121017064008913, 146, -0.28020721694223477), vec3(0.0001928799964751649, 147, 1.9501360190043864), vec3(0.0002679537103486731, 148, 0.26874110818006713), vec3(0.00027895243193299594, 149, 3.023574855940494), vec3(0.000558301334395343, 150, 1.5307552982390948), vec3(0.000366390581356076, 151, -1.6173185311623117), vec3(0.0002844435104142701, 152, -2.876569547418066), vec3(0.00014071602901721472, 153, 1.0918866569731434), vec3(0.000310052094581393, 154, -2.404567966436413), vec3(2.272610291733784e-05, 155, 0.6324817772729061), vec3(0.0003079384591670648, 156, -1.6892918947775568), vec3(0.0004072626852821854, 157, -0.6356534357465593), vec3(0.00036581020307290663, 158, 2.50763536441941), vec3(0.000328775012096694, 159, -1.6552979334545195), vec3(0.000361554626871645, 160, 2.271583447374671), vec3(0.00023515825611359218, 161, 0.0707917042863178), vec3(7.428737176716895e-05, 162, 2.9921378753003363), vec3(0.00031207443736589634, 163, 0.07879592548699883), vec3(1.6805232719885682e-05, 164, -2.0315856817563844), vec3(0.00029284290516141205, 165, 2.356562218446478), vec3(0.0005406185202865765, 166, 0.9264141753673949), vec3(0.0003591969325816857, 167, -1.8195366836952174), vec3(0.0002887601392415138, 168, -0.7593691784477374), vec3(0.000440133463815327, 169, -2.861092799472919), vec3(0.0004377473234608359, 170, 2.7165705825060837), vec3(0.0003825281881467661, 171, 0.04548977823339587), vec3(0.0004453171116045119, 172, -1.5889725543808721), vec3(0.00027685931236603783, 173, 0.40133912541008104), vec3(0.0002277073251435858, 174, 1.8648570092016772), vec3(0.00043649015460662355, 175, -1.4807027291601884), vec3(0.0003435438103647364, 176, 2.3088415442470334), vec3(0.0002784874989587384, 177, -2.959965587383212), vec3(0.0002906497505324918, 178, -0.5235421445465093), vec3(0.0005522112009908517, 179, -2.1828919646975393), vec3(0.000514170343344654, 180, 2.854016822808405), vec3(0.0002621966136805113, 181, -2.256780336531358), vec3(0.0007926977507898551, 182, -1.322745384180447), vec3(0.0015433667898494972, 183, 2.212267607399177), vec3(0.00023198546815043715, 184, -0.9870637431505251), vec3(0.0007161743254248458, 185, -3.0834814274608013), vec3(0.0007809673767173438, 186, 0.47847936011686937), vec3(0.0007440585764828759, 187, -1.7024719977331748), vec3(0.0012213303816780091, 188, -1.3380840773034386), vec3(0.0002329236723787377, 189, -0.7377155864659284), vec3(0.0003077024495540758, 190, 2.2453361990215313), vec3(0.00020504150841135576, 191, 2.085141610662412), vec3(0.0007899298910531892, 192, 0.6942476573936902), vec3(0.00047577132100059166, 193, 2.950744037438498), vec3(0.00012132867662661346, 194, 1.1989628339717064), vec3(0.0008945096975207911, 195, 2.4434268855702617), vec3(0.0005341993205760085, 196, -2.626706319118795), vec3(0.0008012885953038439, 197, 1.1690619241969713), vec3(0.0018695834305686508, 198, -2.4778953149477743), vec3(0.0016578845502348827, 199, -0.13738312204709469), vec3(0.0018546825518305009, 200, -1.7999887615282684), vec3(0.0007431185974560027, 201, 2.174995201508643), vec3(0.0013294718367047717, 202, -2.099566390480893), vec3(0.0007548195738862462, 203, -2.5350082692450884), vec3(0.0010813537830996907, 204, 1.0874234789271389), vec3(0.0006520548362791126, 205, 3.1166615619755182), vec3(0.0009393858393090873, 206, 1.854738641432133), vec3(0.0012804592279042292, 207, 2.1168657404032136), vec3(0.0008608181651923305, 208, -0.6869962939123144), vec3(0.0027492394570491157, 209, 3.0593794229239184), vec3(0.0013042786590707115, 210, -2.6845517686511293), vec3(0.001412288363267205, 211, -1.064585087957022), vec3(0.0018816314624072116, 212, -2.841879609007883), vec3(0.003108482993407266, 213, -1.7329802715161602), vec3(0.0009940175342737399, 214, 2.5069409193044225), vec3(0.0022687244192290353, 215, -0.5445525134478889), vec3(0.003382499417730861, 216, 2.1814458438014777), vec3(0.0019926080137727953, 217, -0.6682671175044884), vec3(0.0021337942511456074, 218, 1.172434667823535), vec3(0.007158748850487738, 219, 1.7872956002198968), vec3(0.005677274345063543, 220, -1.8067690427337149), vec3(0.0010343163197663197, 221, 2.957525068645898), vec3(0.002995302909476681, 222, 2.5952496117047734), vec3(0.0033852039356165897, 223, -2.5064796803421623), vec3(0.010225478027993206, 224, -2.1962778435583616), vec3(0.0070714097380888035, 225, 0.020601055688367766), vec3(0.008247770070745994, 226, 1.8055052765795367), vec3(0.014188034385817503, 227, -2.4547136615856133), vec3(0.022530892293928757, 228, 0.3690118234086388), vec3(0.00780040981055298, 229, -1.9802362066430321), vec3(0.0081559005133612, 230, 2.7437914637816334), vec3(0.01323631278195056, 231, -1.4643401770822042), vec3(0.01154691686699623, 232, 1.5585078871752718), vec3(0.04164070827205541, 233, -1.192749625721735), vec3(0.027036562389363507, 234, 2.474150005059051), vec3(0.013369106746346704, 235, 1.1492668433298525), vec3(0.017559160083341005, 236, -3.033334577083831), vec3(0.03020104493056054, 237, 0.10761522863016465), vec3(0.06570528820995807, 238, -2.6282890348177013), vec3(0.14672812074874764, 239, -2.214682046525651));\nconst float dt = 0.02617993877991494;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFragCoord.x < JOINTS) {\n        if (iFrame == 0 && iFragCoord.y == 0) {\n            fragColor.y = 0.5 - fragCoord.x * LENGTH;\n        }\n\n        if (iFrame > 0) {\n            Joint curJoint = getJoint(iFragCoord.x);\n\n            if (iFragCoord.x > 0) {\n                Joint prevJoint = getJoint(iFragCoord.x - 1);\n\n                vec2 force = normalize(prevJoint.pos - curJoint.pos);\n                float extension = LENGTH - distance(prevJoint.pos, curJoint.pos);\n                force *= -SPRINGINESS * extension;\n\n                if (iFragCoord.x < JOINTS - 1) {\n                    Joint nextJoint = getJoint(iFragCoord.x + 1);\n                    vec2 force2 = normalize(curJoint.pos - nextJoint.pos);\n                    extension = LENGTH - distance(curJoint.pos, nextJoint.pos);\n                    force2 *= -SPRINGINESS * extension;\n                    force -= force2;\n                }\n\n                force += vec2(0.0, -GRAVITY);;\n                curJoint.vel += force / curJoint.mass;\n                curJoint.vel *= DAMPING;\n\n                curJoint.pos += curJoint.vel;\n            }\n\n            if (iFragCoord.x == JOINTS - 1) {\n                float slow = iTime * 0.5;\n                float normal = iTime;\n                float medium = iTime * 2.0;\n                float fast = iTime * 5.0;\n\n                #if EXPERIMENT == 0\n                curJoint.pos = vec2(0.25 * sin(fast), -0.5);\n                #endif\n\n                #if EXPERIMENT == 1\n                curJoint.pos = vec2(cos(fast), sin(fast)) * 0.25;\n                #endif\n\n                #if EXPERIMENT == 2\n                float c = cos(medium), s = sin(medium);\n                curJoint.pos = vec2(c, c * s) * 0.5;\n                #endif\n\n                #if EXPERIMENT == 3\n                curJoint.pos = vec2(0.0);\n                for (int i=0; i < dft.length(); i++) {\n                    float a = float(iFrame) * dt * dft[i][1] + dft[i][2];\n                    curJoint.pos += vec2(cos(a), sin(a)) * dft[i][0];\n                }\n                #endif\n\n                #if EXPERIMENT == 4\n                float c = cos(medium), s = sin(medium);\n                curJoint.pos = vec2(c * s, s * s * c);\n                #endif\n\n                #if EXPERIMENT == 5\n                curJoint.pos = vec2(0.25 * (sin(cos(fast)) + 0.5 * cos(2.0 * fast)), -0.5);\n                #endif\n            }\n\n            if (iFragCoord.y == 0) fragColor.xy = curJoint.pos;\n            if (iFragCoord.y == 1) fragColor.xy = curJoint.vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 155], [157, 157, 212, 212, 613]], "test": "untested"}
{"id": "sdlGWN", "name": "5. Domain Distorted Rectangle", "author": "Sp3cim4n", "description": "Learning Shaders", "tags": ["distortion", "learning", "domaindistortion"], "likes": 2, "viewed": 240, "published": 3, "date": "1615998927", "time_retrieved": "2024-07-30T19:32:08.810745", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    \n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\nfloat Remap01(float a, float b, float t)\n{\n    return (t - a) / (b - a);\n}\n\nfloat Remap(float a, float b, float c, float d, float t)\n{\n    return Remap01(a,b,t) * (d - c) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float x = uv.x;\n    float t = iTime;\n    float m = 0.1*sin(t + x * 10.);\n    float y = uv.y - m;\n    \n    float blur = Remap(-.8, .8, 0.01, .8, x);\n    blur = blur * blur * blur;\n    float mask = Rect(vec2(x,y), -.8, .8, -.1, .1, blur);\n    \n    vec3 color = vec3(1.,1.,0.);\n    color *= mask;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 208], [210, 210, 293, 293, 419], [421, 421, 463, 463, 495], [497, 497, 555, 555, 598], [600, 600, 657, 657, 1107]], "test": "untested"}
{"id": "ssl3W4", "name": "4. rectangle", "author": "Sp3cim4n", "description": "Learning Shaders", "tags": ["rectangle", "learning"], "likes": 0, "viewed": 244, "published": 3, "date": "1615993334", "time_retrieved": "2024-07-30T19:32:09.582680", "image_code": "\n\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    \n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(1., 1., .0);\n    \n    float mask = Rect(uv, -.3, .3, -.2, .2, 0.01);\n    \n    color *= mask;\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssl3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 210], [212, 212, 295, 295, 421], [423, 423, 480, 480, 742]], "test": "untested"}
{"id": "7ssGW4", "name": "2. Sad Smily Face", "author": "Sp3cim4n", "description": "Learning shaders", "tags": ["learning", "smilyface"], "likes": 1, "viewed": 207, "published": 3, "date": "1615992619", "time_retrieved": "2024-07-30T19:32:10.356611", "image_code": "float circle(vec2 uv, vec2 p, float r, float blur)\n{\n    uv -= p;\n    float d = length(uv);\n    return smoothstep(r, r - blur, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(.0);\n    float mask = circle(uv, vec2(.0, .0), .4, .015);\n    \n    mask -= circle(uv, vec2(-.13, .2), .07, .015);\n    mask -= circle(uv, vec2(.13, .2), .07, .015);\n    \n    float mouth = circle(uv, vec2(.0, -.0), .3, .015);\n    mouth -= circle(uv, vec2(.0, 0.1), .3, .015);\n    \n    mask -= mouth;\n    \n    color = vec3(1., 1., 0.) * mask;\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 132], [134, 134, 191, 191, 700]], "test": "untested"}
{"id": "fds3DN", "name": "1. Smoothstep Circle", "author": "Sp3cim4n", "description": "Learning shader magic", "tags": ["circle", "learning"], "likes": 1, "viewed": 256, "published": 3, "date": "1615990342", "time_retrieved": "2024-07-30T19:32:11.142510", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1. get uv coordinates of the pixel.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //2. center the uv coordinate to viewport.\n    uv -= vec2(0.5);\n    //3. eliminate uv stretching.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //4. get distance of the pixel(u,v) from uv center(0,0).\n    float d = length(uv);\n    \n    //input, radius of the circle.\n    float r = 0.3;\n    //output, resulting color of pixel.\n    float c = 0.;\n    \n    //5a. transition harshly from white to black, with distance.\n    //if(d < r) c = 1.f; else c = 0.f;\n    \n    //input, smoothing radius, does not respects resolution.\n    //float s = 0.01;\n    \n    //input, smoothing radius. does respect resolution.\n    float s = 1./iResolution.y; \n    \n    //5b. transition smoothly from white to black, with distance.\n    c = smoothstep(r, r - s, d);\n        \n    fragColor = vec4(vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 99, 937]], "test": "untested"}
{"id": "7sX3W4", "name": "Compressing helices", "author": "Roninkoi", "description": "Quick doodle from yesterday", "tags": ["raymarching", "helix"], "likes": 4, "viewed": 300, "published": 3, "date": "1615934144", "time_retrieved": "2024-07-30T19:32:12.002212", "image_code": "#define PI 3.14159265\n#define MAXIT 150\n#define EPSILON 0.3\n#define STEP 0.3\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define SA 1.\n#define SB 2.\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\t\n\tr.xz += vec2(cos(sin(r.y / a.x * PI) * 0.5 + t * 5. + 2. * cos(t)) * 0.8, sin(sin(r.y / a.x * PI) + t * 3.) * 0.8);\n\tr *= rotY(r.y / a.y * PI);\n\ta.x *= (sin(r.y / a.y * PI)) * 1. + 1.0;\n\tr.x += abs(sin(r.y / a.y * 0.5)) * 5. + 4. - 2. * sin(t * 0.5);\n\ta.xz *= clamp(sin(r.y / a.y * PI * 20.) * 1.1, 0.5 + 0.2 * sin(t * 0.03) + 0.1 * cos(5. * t), 2.);\n\t\n    vec3 p = (abs(r) - a);\n\t\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n\tobj = mat3(1.);\n\tfloat tt = t * 0.3;\n\tobj *= rotY(t);\n\tr.z -= 42. + sin(tt) * 38.;\n\t\n\tvec3 rb1 = obj * r;\n\t\n\tfloat rs = 43. + sin(tt) * 30.;\n\trb1.y += t * rs;\n\tvec3 rbp1 = mod(rb1+rs, rs*2.)-rs;\n\tvec3 rbp2 = mod(rotY(PI + t * PI / 2.) * rbp1 + vec3(0., t * rs / 2., 0.) + rs, rs*2.)-rs;\n\t\n\tvec2 b1 = vec2(\n\t\tbox(rbp1, vec3(2., rs, 2.)), SA\n\t);\n\tvec2 b2 = vec2(\n\t\tbox(rbp2, vec3(1., rs, 1.)), floor(mod(rbp2.y, 4.) + 2.)\n\t);\n\n    return minx2(b1, b2);\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == SA)\n        return normalize(vec3(0.0, 1.0, 1.0));\n    if (o.y == SB)\n        return normalize(vec3(1.0, 0.5, 0.0));\n    \n    return normalize(vec3(1., 0.2, 0.));\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(1.0, 0.5, 0.2);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n            matCol(d), \n            shade(normalize(r), rd));\n            col.rgb = fog(z * 0.02, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\tcol.rgb *= exp(-sh * 2.0 + 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 226, 226, 328], [331, 331, 351, 351, 455], [458, 458, 478, 478, 580], [594, 594, 625, 625, 653], [656, 656, 685, 685, 759], [762, 762, 799, 799, 827], [829, 829, 861, 861, 963], [965, 965, 985, 985, 1057], [1059, 1059, 1086, 1086, 1503], [1506, 1506, 1536, 1536, 1591], [1594, 1594, 1636, 1636, 1676], [1689, 1689, 1707, 1707, 2165], [2167, 2167, 2188, 2188, 2368]], "test": "untested"}
{"id": "7dX3W4", "name": "String Simulation", "author": "oneshade", "description": "Simple string simulation using Hooke's law. Tug it with the mouse.", "tags": ["2d", "simulation", "string", "physics", "spring", "softbody"], "likes": 18, "viewed": 560, "published": 3, "date": "1615933627", "time_retrieved": "2024-07-30T19:32:12.779134", "image_code": "// The result of watching this tutorial by Dan Shiffman (@The Coding Train):\n// https://www.youtube.com/watch?v=Rr-5HiXquhw&list=PLRqwX-V7Uu6ZV4yEcW3uDwOgGXKUUsPOM&index=32\n// Ported from p5.js: https://editor.p5js.org/pythontales/present/XpFqejZ8z\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdPolyspline(in vec2 p, in vec2[JOINTS] cp) {\n    vec2 v1 = cp[0], v2 = vec2(0.0), v3 = 0.5 * (cp[1] + v1);\n    vec2 pa = p - v1, ba = v3 - v1;\n    float d = dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n    for (int n=1; n < JOINTS - 1; n++) {\n        v1 = 0.5 * (cp[n - 1] + cp[n]), v2 = cp[n], v3 = 0.5 * (cp[n] + cp[n + 1]);\n\n        vec2 c1 = p - v1;\n        vec2 c2 = 2.0 * v2 - v3 - v1;\n        vec2 c3 = v1 - v2;\n\n        float t3 = dot(c2, c2);\n        float t2 = dot(c3, c2) * 3.0;\n        float t1 = dot(c1, c2) + 2.0 * dot(c3, c3);\n        float t0 = dot(c1, c3);\n\n        t2 /= t3, t1 /= t3, t0 /= t3;\n\n        float t22 = t2 * t2;\n        vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n        float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n        float p2 = abs(pq.x);\n        float r1 = 1.5 / pq.x * pq.y;\n\n        if (qq * 0.25 + ppp / 27.0 > 0.0) {\n            float r2 = r1 * sqrt(3.0 / p2), root;\n            if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n            else root = sinh(asinh(r2) / 3.0);\n            root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)));\n        }\n\n        else {\n            float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n            vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x)));\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y)));\n        }\n    }\n\n    v1 = cp[JOINTS - 1], v2 = vec2(0.0), v3 = 0.5 * (cp[JOINTS - 2] + v1);\n    pa = p - v1, ba = v3 - v1;\n    d = min(d, dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n\n    return sqrt(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    vec2[JOINTS] joints;\n    for (int j=0; j < JOINTS; j++) { joints[j] = getJoint(j).pos; }\n    fragColor.rgb = smoothstep(unit, 0.0, length(uv - getJoint(0).pos) - SIZE) * vec3(1.0, 0.8, 0.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, sdPolyspline(uv, joints)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Joint {\n    vec2 pos;\n    vec2 vel;\n    float mass;\n};\n\n#define getJoint(id)                                 \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xy, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xy, \\\n          MASS)                                      \\\n\n#define JOINTS 10\n#define SIZE 0.01\n#define MASS 5.0\n\n#define GRAVITY 0.001\n#define SPRINGINESS 0.1\n#define DAMPING 0.99\n#define LENGTH 0.05", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFragCoord.x < JOINTS) {\n        if (iFrame == 0 && iFragCoord.y == 0) {\n            fragColor.y = 0.5 - fragCoord.x * LENGTH;\n        }\n\n        if (iFrame > 0) {\n            Joint curJoint = getJoint(iFragCoord.x);\n\n            if (iFragCoord.x > 0) {\n                Joint prevJoint = getJoint(iFragCoord.x - 1);\n\n                vec2 force = normalize(prevJoint.pos - curJoint.pos);\n                float extension = LENGTH - distance(prevJoint.pos, curJoint.pos);\n                force *= -SPRINGINESS * extension;\n\n                if (iFragCoord.x < JOINTS - 1) {\n                    Joint nextJoint = getJoint(iFragCoord.x + 1);\n                    vec2 force2 = normalize(curJoint.pos - nextJoint.pos);\n                    extension = LENGTH - distance(curJoint.pos, nextJoint.pos);\n                    force2 *= -SPRINGINESS * extension;\n                    force -= force2;\n                }\n\n                force += vec2(0.0, -GRAVITY);;\n                curJoint.vel += force / curJoint.mass;\n                curJoint.vel *= DAMPING;\n\n                curJoint.pos += curJoint.vel;\n            }\n\n            // UX improvement by @elenzil\n            if (iMouse.z > 0.0 && iFragCoord.x == JOINTS - 1) {\n                vec2 targPos = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n                vec2 targVel = (targPos - curJoint.pos) * 0.1;\n                curJoint.vel = targVel;\n            }\n\n            if (iFragCoord.y == 0) fragColor.xy = curJoint.pos;\n            if (iFragCoord.y == 1) fragColor.xy = curJoint.vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 273, 273, 293]], "test": "untested"}
{"id": "NsfGWN", "name": "Tractrix Star", "author": "oneshade", "description": "Can it get smaller?\nInspired by [url=https://www.shadertoy.com/view/7sl3Dr]https://www.shadertoy.com/view/7sl3Dr[/url]", "tags": ["lines", "star", "curve", "golf", "tractrix"], "likes": 6, "viewed": 165, "published": 3, "date": "1615921911", "time_retrieved": "2024-07-30T19:32:13.546084", "image_code": "/* Shorter version by Fabrice (188 chars) */\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    for (float i=0.; i < .55; i += .05) {\n        vec2 r = iResolution.xy,\n             p = abs(u - .5 * r) ,\n             q = vec2(-i, .5 - i); \n        p.x -= i*r.y;\n        o += max(0.,1.- .5* length(p - q * max(0., dot(p, q) / dot(q, q))));\n    }\n}\n/**/\n\n/* Original version (204 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    o -= o;\n    for (float i=0.; i < .55; i += .05) {\n        vec2 p = abs(u - .5 * r) / r.y - vec2(i, 0), q = vec2(-i, .5 - i);\n        o += smoothstep(2. / r.y, 0., length(p - q * max(0., dot(p, q) / dot(q, q))));\n    }\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 81, 81, 346]], "test": "untested"}
{"id": "sdsGDr", "name": "MyPortal", "author": "Apayyai", "description": "Noise divided by gradient circle mask", "tags": ["portal"], "likes": 26, "viewed": 1257, "published": 3, "date": "1615906000", "time_retrieved": "2024-07-30T19:32:14.320014", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nfloat noise(vec2 p) {\n    return texture(iChannel0, p * 0.05 ).x;\n}\n\nfloat fbm(vec2 p) {\n    float a =1.;\n    float f = 1.;\n    return a*noise(p) \n        + a*0.5 * noise(p*f*2. ) \n        + a*0.25 * noise(p*f*4. )\n        + a*0.1 * noise(p*f*8. );\n}\n\nfloat circle(vec2 p) {\n    float r = length(p);\n    float radius = 0.4;\n    float height = 1.; \n    float width = 150.;\n    \n\treturn height - pow(r - radius, 2.) *width ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( fragCoord -.5 * iResolution.xy ) / iResolution.y;\n    \n    vec2 st  = vec2(\n            atan(uv.y, uv.x) ,\n            length(uv) * 1. + iTime * 0.1\n        );\n\n    \n    st.x += st.y * 1.1;// - iTime * 0.3;\n    st.x = mod(st.x , TWO_PI);\n    \n    \n    float n = fbm(st ) * 1.5 -1. ;\n    n = max(n, 0.1);\n    float circle =  max(1.- circle(uv ), 0.)  ;\n    \n    float color = n/circle;\n    float mask = smoothstep(0.48, 0.4, length(uv));\n    \n    color *= mask;\n    vec3 rez = vec3(1., 0.5, 0.25) * color;\n    // Output to screen\n    fragColor = vec4(rez,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 76, 76, 122], [124, 124, 143, 143, 305], [307, 307, 329, 329, 479], [481, 481, 538, 538, 1121]], "test": "untested"}
{"id": "7dl3Wn", "name": "Thirty-Thousand waves", "author": "z0rg", "description": "A small shader based on Anachronist's Thirty-Thousand Miles song.\n", "tags": ["sdf", "light", "retrowave"], "likes": 11, "viewed": 745, "published": 3, "date": "1615898005", "time_retrieved": "2024-07-30T19:32:15.083972", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define FFT(A) pow(texelFetch(iChannel0, ivec2(A, 0), 0).x, 5.)*.5\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat _time;\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(rd, r));\n    float fov = mix(1., 10., sat(sin(_time*.25)*.5+.5));\n    return normalize(rd+(uv.x*r+uv.y*u)*fov);\n}\n\nfloat _cyl(vec3 p, float r)\n{\n    float test = clamp(sin(p.z+_time*50.)*100., -1., 1.);\n    r += sin(_time*50.+p.z*.5)*.1+FFT(p.z*.1);\n    r += test*.07;\n    return length(p.xy)-r;\n}\n\nfloat map(vec3 p)\n{\n    p.x = abs(p.x);\n    vec3 cp = p-vec3(20., 0.02, 0.);\n   \n    float yrep = 10.;\n    float idx = (cp.y+yrep*.5)/yrep;\n    cp.y = mod(cp.y+yrep*.5, yrep)-yrep*.5;\n    cp.x += sin(idx*.1+iTime*1.)*2.+FFT(idx)*10.;\n    float cl = _cyl(cp, .1+abs(sin(iTime))*.25+FFT(10));\n\n    //min(_sph(p, .5), _sph(p-vec3(1.+sin(_time), 0., 0.), .5));\n    return cl;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    \n    vec3 ro = vec3(0.,sin(_time),-5.);\n    vec3 ta = vec3(sin(_time*.25)*5.,cos(_time*.5)*2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 p = ro;\n    vec3 acc = vec3(0.);\n    float accth = 5.;\n    for (int i = 0; i < 128; ++i)\n    {\n        float d = map(p);\n        if (d < 0.01)\n        {\n            vec3 grad = 0.5 + 0.5*cos(_time+uv.xyx+vec3(0,2,4)+2.*FFT(p.z+10.));\n            col = grad;\n            break;\n        }\n        if (d < accth)\n        {\n            vec3 grad = 0.5 + 0.5*cos(_time+uv.xyx+vec3(0,2,4)+2.*FFT(p.z+10.));\n            acc += grad*(1.-sat(d/accth))*(1.-sat(distance(ro, p)/300.));\n        }\n        p += rd * d;\n    }\n    \n    col += .25*sat(dot(rd, vec3(0.,0.,1.)))*(0.5 + 0.5*cos(_time+uv.yxy+vec3(0,2,4)+2.*FFT(p.z+10.)));\n    return col+acc*.2*FFT(10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n_time = iTime+texture(iChannel1, fragCoord/8.).x*iTimeDelta*2.;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    uv *= r2d(_time*.1);\n    vec3 col = rdr(uv);\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*2.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n    col = mix(col, vec3(0.), pow(sat(length(uv*1.7)), 1.5));\n    col = pow(col, vec3(.45));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26159, "src": "https://soundcloud.com/theanachronist/thirty-thousand-miles", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3Wn.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[496, 496, 515, 515, 569], [584, 584, 613, 613, 639], [641, 641, 672, 672, 868], [870, 870, 899, 899, 1052], [1054, 1054, 1073, 1073, 1427], [1430, 1430, 1449, 1449, 2296], [2298, 2298, 2355, 2355, 3115]], "test": "untested"}
{"id": "sss3W8", "name": "Bouncing Balls Example", "author": "blackle", "description": "from pjkarlik's question", "tags": ["balls", "parabola"], "likes": 13, "viewed": 490, "published": 3, "date": "1615896383", "time_retrieved": "2024-07-30T19:32:15.921732", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat box(vec2 p, vec4 b) {\n    p = abs(p-b.xy) - b.zw;\n    return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat aa(float sdf) {\n    float pixelsize = 1./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, sdf);\n}\n\n//this function will return a position along a parabolic trajectory for a particular ball\n//that bounced off box1 and will end up on top of box2.\nvec2 ballPosForTime(float ballIdx, float bar, float t, vec4 box1, vec4 box2, float maxHeight, float ballSize) {\n    //to start, we generate random values between -1 and 1\n    float h1 = hash(ballIdx, bar+0.0);\n    float h2 = hash(ballIdx, bar+0.5);\n    float h3 = hash(ballIdx, bar+1.0);\n\n    maxHeight += box1.y;\n\n    //then we map those hash values to random points on our boxes\n    //the first point is the starting location of the ball, which will be\n    //on a random spot on the surface of the first box\n    float x1 = h1*(box1.z/2.)+box1.x;\n    float y1 = box1.y+box1.w+ballSize;\n\n    //the third, final point will be on a random spot on the surface\n    //of the second box\n    float x3 = h3*(box2.z/2.)+box2.x;\n    float y3 = box2.y+box2.w+ballSize;\n    \n    //the middle point, the point the ball passes between, will be the midpoint\n    //between the start and end points, and a little bit higher than the first box\n    float x2 = mix(x1, x3, .5);\n    float y2 = mix(y1, maxHeight, h2*.25+.75);\n    \n    //now we have three points that the ball must pass through, we can solve a system\n    //of linear equations to get a parabola that the ball can travel through\n    //that passes between all three points\n    vec3 column = vec3(x1, x2, x3);\n    mat3 system = mat3(column*column, column, vec3(1));\n    //these are our coefficients (a, b, c) for the formula a*x^2 + b*x + c\n    vec3 coeff = inverse(system) * vec3(y1, y2, y3);\n    \n    //we must map the time value to be between our start and end points\n    float x = mix(x1, x3, t);\n    float y = coeff.x*x*x + coeff.y*x + coeff.z;\n    \n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    //these define our boxes. the first 2 coords are the position,\n    //the second 2 coords are the dimensions\n    vec4 box0 = vec4( .25, .50, .2, .02);\n    vec4 box1 = vec4(-.25, .25, .2, .02);\n    vec4 box2 = vec4( .25, .00, .2, .02);\n    vec4 box3 = vec4(-.25,-.25, .2, .02);\n    vec4 box4 = vec4( .25,-.50, .2, .02);\n    float b1dist = box(uv, box1);\n    float b2dist = box(uv, box2);\n    float b3dist = box(uv, box3);\n    \n    //the bar is like a musical bar. it's how many times our cycle has repeated\n    float bar = floor(iTime);\n    //t is a number between 0 and 1 and is the time within the current cycle\n    float t = fract(iTime);\n    \n    float ballSize = 0.02;\n\n    //we need to find the position for all the balls on screen. this could be optimized\n    //by only finding the balls that could pass through the current uv coordinate\n    vec2 ballpos0 = ballPosForTime(0.-bar, bar, t, box0, box1, 0.2, ballSize);\n    float ball0dist = length(uv - ballpos0) - ballSize;\n\n    vec2 ballpos1 = ballPosForTime(1.-bar, bar, t, box1, box2, 0.2, ballSize);\n    float ball1dist = length(uv - ballpos1) - ballSize;\n\n    vec2 ballpos2 = ballPosForTime(2.-bar, bar, t, box2, box3, 0.2, ballSize);\n    float ball2dist = length(uv - ballpos2) - ballSize;\n\n    vec2 ballpos3 = ballPosForTime(3.-bar, bar, t, box3, box4, 0.2, ballSize);\n    float ball3dist = length(uv - ballpos3) - ballSize;\n    \n    float balls = min(min(ball0dist, ball3dist), min(ball1dist, ball2dist));\n    float boxes = min(b1dist, min(b2dist, b3dist));\n    float col = aa(min(boxes, balls));\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3W8.jpg", "access": "api", "license": "cc0-1.0", "functions": [[249, 249, 279, 279, 355], [357, 357, 384, 384, 465], [467, 467, 488, 488, 581], [583, 729, 840, 899, 2349], [2351, 2351, 2408, 2408, 4064]], "test": "error"}
{"id": "7sl3Dr", "name": "Line test RaduBT 588", "author": "RaduBT", "description": "as a new comer I found it extremely hard to find a way to draw a line seg. Im not good at geometry so i could not search for the right content. \n\nfinally after a bunch of crawling in internet i came to find the right terms and understand how this works.", "tags": ["line", "plot", "vector", "drawing", "segment", "linesegment"], "likes": 2, "viewed": 344, "published": 3, "date": "1615895926", "time_retrieved": "2024-07-30T19:32:16.686686", "image_code": "// vector projection and rejection:\n// https://en.wikipedia.org/wiki/Vector_projection\n//\n// thanks to\n// https://stackoverflow.com/a/48630348/4767498\n// ===================\n//\n// say you have two vectors \"a\" and \"b\" (in two directions).\n// you travel a distance in line \"a\".\n// what scalar projection indicates is how far you traveled in direction of \"b\".\n// vector projection is simply the vector with that scale or magnitude.\n//\n// ===================\n//\n// now say you want to draw line \"b\". \n// now you have bunch of points coming from fragments of your screen.\n// so you will get bunch of lines (call it \"a\") going throw these points.\n// not all of these points are in right direction of the line \"b\".\n//\n// so what you should look for is how far we are from the vector \"a\" to vector \"b\"\n// this is called \"vector rejection\".\n// length of vector rejection basically tells the \n// distance from any point to line \"b\" that you want to draw.\n//\n// ===================\n//\n// using the distance you can give a brightness value to each pixel. \n// the closer you are, the brighter that pixel should be.\n//\n// if you clamp scalar projection from 0 to 1 \n// you will limit this infinite line to a line segment.\n// remember that vector projection is scalar projection times \"unit\" vector of \"b\"\n// unit vector has always length of 1. thats why clamping from 0 to 1 gives you a semgent.\n// as you go further from the line segment \"b\", you get bigger distances.\n//\n// ===================\n//\n// as an optimization instead of length(recj) \n// we calculate dot(rejc,rejc) which is equal to length(rejc)^2. \n// it should not matter too much because we are already tempering the\n// distance value with thickness etc to get our desired result.\n\n\nfloat line(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 a = p-p0; // the vector that we want to project on b\n    vec2 b = p1-p0; // this line is our goal.\n    \n    vec2 proj = clamp((dot(a,b)/dot(b,b)),0.0,1.0)*b; // vector projection of a onto b\n    vec2 rejc = a-proj; // vector rejection or distance in other words\n    \n    return smoothstep(0.0,1.2,1.0-dot(rejc, rejc)*1e4);\n}\n\nvec2 uvmap(vec2 uv)\n{\n    return ( 2.*uv - iResolution.xy)* 1.5 /iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy);\n    vec2 p0 = vec2(0.,0.);\n    vec2 p1 = uvmap(iMouse.xy);\n    vec2 p11 = vec2(0.1,0.);\n    vec2 p12 = vec2(0.2,0.);\n    vec2 p13 = vec2(0.3,0.);\n    vec2 p14 = vec2(0.4,0.);\n    vec2 p15 = vec2(0.5,0.);\n    vec2 p16 = vec2(0.6,0.);\n    vec2 p17 = vec2(0.7,0.);\n    vec2 p18 = vec2(0.8,0.);\n    vec2 p19 = vec2(0.9,0.);\n    vec2 p20 = vec2(1.0,0.);\n    vec2 p21 = vec2(1.0,0.1);\n    vec2 p22 = vec2(1.0,0.2);\n    vec2 p23 = vec2(1.0,0.3);\n    vec2 p24 = vec2(1.0,0.4);\n    vec2 p25 = vec2(1.0,0.5);\n    vec2 p26 = vec2(1.0,0.6);\n    vec2 p27 = vec2(1.0,0.7);\n    vec2 p28 = vec2(1.0,0.8);\n    vec2 p29 = vec2(1.0,0.9);\n    vec2 p30 = vec2(1.0,1.0);\n    vec2 p31 = vec2(.1,1.);\n    vec2 p32 = vec2(.2,1.);\n    vec2 p33 = vec2(.3,1.);\n    vec2 p34 = vec2(.4,1.);\n    vec2 p35 = vec2(.5,1.);\n    vec2 p36 = vec2(.6,1.);\n    vec2 p37 = vec2(.7,1.);\n    vec2 p38 = vec2(.8,1.);\n    vec2 p39 = vec2(.9,1.);\n    vec2 p40 = vec2(0.,1.);\n    vec2 p41 = vec2(0.,0.1);\n    vec2 p42 = vec2(0.,0.2);\n    vec2 p43 = vec2(0.,0.3);\n    vec2 p44 = vec2(0.,0.4);\n    vec2 p45 = vec2(0.,0.5);\n    vec2 p46 = vec2(0.,0.6);\n    vec2 p47 = vec2(0.,0.7);\n    vec2 p48 = vec2(0.,0.8);\n    vec2 p49 = vec2(0.,0.9);\n    \n\n\n    vec3 col = vec3(line(uv, p0, p1)) \n    \n    // up right margin\n    \n       // + vec3(line(uv, p0, p20))\n    //    + vec3(line(uv, p11, p21))\n   //     + vec3(line(uv, p12, p22))\n   //     + vec3(line(uv, p13, p23))\n   //     + vec3(line(uv, p14, p24))\n   //     + vec3(line(uv, p15, p25))\n   //     + vec3(line(uv, p16, p26))\n   //     + vec3(line(uv, p17, p27))\n   //     + vec3(line(uv, p18, p28))\n   //     + vec3(line(uv, p19, p29))\n   //     + vec3(line(uv, p20, p30))\n  \n        // up right \n        \n //       + vec3(line(uv, p40, p30))\n //       + vec3(line(uv, p41, p31))\n  //      + vec3(line(uv, p42, p32))\n  //      + vec3(line(uv, p43, p33))\n  //      + vec3(line(uv, p44, p34))\n  //      + vec3(line(uv, p45, p35))\n   //     + vec3(line(uv, p46, p36))\n ///       + vec3(line(uv, p47, p37))\n  //      + vec3(line(uv, p48, p38))\n //       + vec3(line(uv, p49, p39))\n //       + vec3(line(uv, p48, p38))\n        \n        \n        //down right middle\n        \n\n        + vec3(line(uv, -p41, p19))\n        + vec3(line(uv, -p42, p18))\n        + vec3(line(uv, -p43, p17))\n        + vec3(line(uv, -p44, p16))\n        + vec3(line(uv, -p45, p15))\n        + vec3(line(uv, -p46, p14))\n        + vec3(line(uv, -p47, p13))\n        + vec3(line(uv, -p48, p12))\n        + vec3(line(uv, -p49, p11))\n        + vec3(line(uv, -p0, p20))\n        \n        \n        \n       // up right middle\n       \n\n        + vec3(line(uv, p41, p19))\n        + vec3(line(uv, p42, p18))\n        + vec3(line(uv, p43, p17))\n        + vec3(line(uv, p44, p16))\n        + vec3(line(uv, p45, p15))\n        + vec3(line(uv, p46, p14))\n        + vec3(line(uv, p47, p13))\n        + vec3(line(uv, p48, p12))\n        + vec3(line(uv, p49, p11))\n        + vec3(line(uv, -p0, p20))\n\n     // middle up left\n       \n\n        + vec3(line(uv, p41, -p19))\n        + vec3(line(uv, p42, -p18))\n        + vec3(line(uv, p43, -p17))\n        + vec3(line(uv, p44, -p16))\n        + vec3(line(uv, p45, -p15))\n        + vec3(line(uv, p46, -p14))\n        + vec3(line(uv, p47, -p13))\n        + vec3(line(uv, p48, -p12))\n        + vec3(line(uv, p49, -p11))\n        + vec3(line(uv, -p0, -p40))\n        \n // down right lef\n       \n\n        + vec3(line(uv, -p41, -p19))\n        + vec3(line(uv, -p42, -p18))\n        + vec3(line(uv, -p43, -p17))\n        + vec3(line(uv, -p44, -p16))\n        + vec3(line(uv, -p45, -p15))\n        + vec3(line(uv, -p46, -p14))\n        + vec3(line(uv, -p47, -p13))\n        + vec3(line(uv, -p48, -p12))\n        + vec3(line(uv, -p49, -p11))\n        + vec3(line(uv, -p0, -p20))\n\n\n////\n        \n        \n //       + vec3(line(uv, p11, p41))\n//        + vec3(line(uv, p12, p42))\n //       + vec3(line(uv, p13, p43))\n //       + vec3(line(uv, p14, p44))\n //       + vec3(line(uv, p15, p45))\n //      + vec3(line(uv, p16, p46))\n //       + vec3(line(uv, p17, p47))\n //      + vec3(line(uv, p18, p48))\n //       + vec3(line(uv, p39, p49))\n        + vec3(line(uv, p0, p40)); \n   \n   \n   ///   down right margin\n        \n    //    + vec3(line(uv, -p21, -p41))\n    //    + vec3(line(uv, -p22, -p12))\n    //    + vec3(line(uv, -p23, -p13))\n    //    + vec3(line(uv, -p24, -p14))\n    //    + vec3(line(uv, -p25, -p15))\n    //    + vec3(line(uv, -p26, -p16))\n    //    + vec3(line(uv, -p27, -p17))\n    //    + vec3(line(uv, -p28, -p18))\n    //    + vec3(line(uv, -p29, -p19))\n        + vec3(line(uv, -p20, -p0)); \n        \n        // down left margin\n                \n   //     + vec3(line(uv, -p30, -p20))\n   //     + vec3(line(uv, -p31, -p29))\n   //     + vec3(line(uv, -p32, -p28))\n   //     + vec3(line(uv, -p33, -p27))\n  //      + vec3(line(uv, -p34, -p26))\n   //     + vec3(line(uv, -p35, -p25))\n   //     + vec3(line(uv, -p36, -p24))\n   //     + vec3(line(uv, -p37, -p23))\n   //     + vec3(line(uv, -p38, -p22))\n   //     + vec3(line(uv, -p39, -p21));\n\n        // down left margin\n                \n   //     + vec3(line(uv, -p30, -p40))\n    //    + vec3(line(uv, -p31, -p41))\n   //     + vec3(line(uv, -p32, -p42))\n    //    + vec3(line(uv, -p33, -p43))\n   //     + vec3(line(uv, -p34, -p44))\n   //     + vec3(line(uv, -p35, -p45))\n   //     + vec3(line(uv, -p36, -p46))\n   //     + vec3(line(uv, -p37, -p47))\n    //    + vec3(line(uv, -p39, -p49))\n   //     + vec3(line(uv, -p40, -p0));\n        \n\n\n\n    // Output to screen\n    fragColor = vec4(col*2.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sl3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1734, 1734, 1772, 1772, 2106], [2108, 2108, 2129, 2129, 2189], [2191, 2191, 2248, 2248, 7803]], "test": "untested"}
{"id": "NssGDH", "name": "Piz Gloria With Helicopter", "author": "dr2", "description": "Perhaps Mr. Bond is trying to land on the Schilthorn?", "tags": ["snow", "mountain", "flight", "building"], "likes": 11, "viewed": 397, "published": 3, "date": "1615884859", "time_retrieved": "2024-07-30T19:32:17.636148", "image_code": "// \"Piz Gloria With Helicopter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Perhaps Mr. Bond is trying to land on the Schilthorn?\n\n// Note: high frame rate needed to avoid rotor artifacts (alternative is semi-opaque\n// disk, as for propellers in e.g. \"River Flight 2\").\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, sunDir, qHit;\nvec2 csRotor;\nfloat tCur, dstFar, grndScl, bldgScl, heliScl;\nint idObj;\nbool isSh;\nconst int idPk = 1, idBldg = 2, idWin = 3, idPol = 4, idBase = 5, idBaseH = 6, idBrg = 7,\n   idHeli = 11, idRotorM = 12, idRotorT = 13, idSkd = 14;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{   // (annular mountains from \"Mountain Lake with Tower\")\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 22.;\n    h = 6. * s * mix (Fbm2 (f * vec2 (s, a + 1.)), Fbm2 (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (4. * s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r, s;\n  dMin /= heliScl;\n  p /= heliScl;\n  if (! isSh) d = PrRoundBoxDf (p - vec3 (0., 0.5, -1.2), vec3 (4.5, 2., 5.5), 0.1);\n  if (isSh || d < 0.1) {\n    q = p;\n    r = 1.;\n    if (q.z < -0.1) {\n      s = (q.z + 0.1) * (q.z + 0.1);\n      r *= 1. - 0.1 * s;\n      q.y -= 0.05 * s;\n    } else if (q.z > 0.1) {\n      s = (q.z - 0.1) * (q.z - 0.1);\n      r *= 1. - 0.03 * s;\n    }\n    q.x *= 0.8;\n    d = PrCapsDf (q, max (r, 0.), 2.);\n    q = p;\n    q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n    r = 0.2 * (1. + 0.25 * q.z);\n    q.y *= 0.7;\n    d = min (d, PrCapsDf (q, r, 1.5));\n    q = p;\n    q.yz -= vec2 (1.7, -0.2);\n    d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n    q = p;\n    q.yz -= vec2 (0.4, -1.);\n    r = 1.1;\n    if (q.z < 0.) {\n      s = q.z * q.z;\n      r *= 1. - 0.2 * s;\n      q.y -= 0.1 * s;\n    }\n    q.y *= 0.8;\n    d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n    q = p;\n    q.yz -= vec2 (1.4, -6.15);\n    d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n    DMIN (idHeli);\n    if (! isSh) {\n      q.yz = Rot2Cs (q.yz, csRotor);\n      d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n      DMIN (idRotorT);\n    }\n    q = p;\n    q.yz -= vec2 (2., -0.2);\n    d = PrCylDf (q.xzy, 0.12, 0.5);\n    if (! isSh) {\n      q.y -= 0.4;\n      q.xz = Rot2Cs (q.xz, csRotor);\n      d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n    }\n    DMIN (idRotorM);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.9, -1.4);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n    q.xy = Rot2D (q.xy, -0.1 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (0.4, 0.7);\n    d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n    DMIN (idSkd);\n    dMin *= 0.7;\n  } else dMin = min (dMin, d);\n  return heliScl * dMin;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, hPk, hb, bs;\n  p /= bldgScl;\n  dMin /= bldgScl;\n  hPk = 6.;\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.8, 0.5 * hPk);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (33. * a + 0.5) / 33.);\n  q.xy = Rot2D (q.xy, -0.2 * pi);\n  d = length (q.xz) - 3.3 + p.y * (hPk - p.y) / (hPk * hPk) -\n     0.5 * Fbm2 (vec2 (32. * mod (a + 0.5, 1.), 0.8 * q.y));\n  d = SmoothMax (d, p.y - hPk, 0.1);\n  hb = 0.6;\n  q = p;\n  q.y -= -0.11;\n  d = 0.8 * SmoothMin (d, PrCylDf (q.xzy, 10., 0.1), 0.5);\n  DMINQ (idPk);\n  q = p;\n  q.xy -= vec2 (1.4, hPk + hb + 0.3);\n  d = PrCapsDf ((q - vec3 (0., 0.8, 0.)).xzy, 0.03, 0.1);\n  DMINQ (idPol);\n  q.xz = Rot2D (q.xz, 2. * pi * floor (8. * (atan (q.z, - q.x) / (2. * pi) + 0.5) + 0.5) / 8.);\n  bs = dot (q.xy, sin (0.04 * pi + vec2 (0.5 * pi, 0.))) - 0.9;\n  d = SmoothMax (bs, max (- PrRoundBox2Df (q.yz - vec2 (-0.12, 0.), vec2 (0.47, 0.27 - 0.03 * q.y), 0.02),\n     dot (q.yx, sin (0.08 * pi + vec2 (0.5 * pi, 0.))) - hb - 0.08), 0.02);\n  DMINQ (idBldg);\n  d = min (d, max (bs + 0.02, abs (q.y + 0.1) - 0.5));\n  DMINQ (idWin);\n  hb = 0.1;\n  q = p;\n  q.xy -= vec2 (1.4, hPk + hb);\n  d = PrRoundCylDf (q.xzy, 1.4, 0.02, hb - 0.02);\n  DMINQ (idBase);\n  q = p;\n  q.xy -= vec2 (-1.5, hPk + hb);\n  d = PrRoundCylDf (q.xzy, 1., 0.02, hb - 0.02);\n  DMINQ (idBaseH);\n  q = p;\n  q.y -= hPk + 1.5 * hb;\n  d = PrRoundBoxDf (q, vec3 (1., 0.5 * hb, 0.2) - 0.02, 0.02);\n  DMINQ (idBrg);\n  return bldgScl * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = FlyerDf (flMat * (p - flPos), dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.1, h);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.005 * (ro.xz + 5. * tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  float a;\n  a = atan (ro.z, - ro.x);\n  col4 = vec4 (0.9, 0.9, 0.9, 0.3);\n  if (ro.y > 0.) {\n    col4 = mix (col4, vec4 (0.85, 0.85, 0.85, 0.1), smoothstep (0.1, 0.25, 1. - vn.y));\n    col4 = mix (col4, vec4 (0.75, 0.75, 0.75, 0.1), smoothstep (0.25, 0.6, 1. - vn.y));\n    col4 = mix (col4, vec4 (1., 1., 1., 0.4), smoothstep (0.65, 0.95, ro.y / grndScl +\n       0.2 * sin (8. * a)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstGrnd, dstObj, sh;\n  bool isRefl;\n  csRotor = sin (10.3 * pi * tCur + vec2 (0.5 * pi, 0.));\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  if (dstObj < dstFar && idObj == idWin) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  dstGrnd = GrndRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (32. * ro / grndScl, vn, 1.);\n      col4 = GrndCol (ro, vn);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj < idHeli) {\n        if (idObj == idPk) {\n          vn = VaryNf (32. * ro, vn, 0.5);\n          col4 = mix (vec4 (0.6, 0.6, 0.6, 0.1), vec4 (1., 1., 1., 0.2), smoothstep (0.2, 0.6, vn.y)) *\n             (1. - 0.05 * Noisefv2 (8. * ro.xz));\n          qHit = ro / bldgScl;\n          col4 *= 0.6 + 0.4 * smoothstep (0., 0.1, min (length (qHit.xz - vec2 (1.4, 0.)) - 1.4,\n             length (qHit.xz - vec2 (-1.5, 0.)) - 1.));\n        } else if (idObj == idBldg) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.1) * (0.93 + 0.07 * sin (64. * pi * qHit.y));\n        } else if (idObj == idPol) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.1);\n        } else if (idObj == idBase || idObj == idBaseH || idObj == idBrg) {\n          col4 = vec4 (0.6, 0.6, 0.65, 0.) * (1. - 0.05 * Noisefv2 (16. * ro.xz));\n          if (idObj != idBrg) col4 *= 0.9 + 0.1 * sin (64. * pi * qHit.y);\n          if (idObj == idBaseH) {\n            qHit.xz = abs (qHit.xz);\n            col4 = mix (vec4 (1., 1., 0.5, 0.1), col4, smoothstep (0., 0.02,\n               min (max (qHit.x - 0.4, abs (qHit.z - 0.3)), max (qHit.x, qHit.z - 0.3)) - 0.07));\n          }\n        }\n      } else {\n        qHit = flMat * (ro - flPos) / heliScl;\n        if (idObj == idHeli) {\n          col4 = mix (vec4 (1., 1., 0., 0.2), vec4 (0.8, 0., 0., 0.2),\n             smoothstep (0., 0.02, abs (qHit.y) - 0.04));\n          if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n             abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -1.);\n        } else if (idObj == idRotorM) {\n          col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n          if (length (qHit.xz - vec2 (0., -0.2)) > 4.2) col4 = vec4 (1., 1., 0.2, 0.1);\n        } else if (idObj == idRotorT) {\n          col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n          if (length (qHit.yz - vec2 (1.4, -6.15)) < 0.06) col4 = vec4 (1., 1., 0.2, 0.1);\n        } else if (idObj == idSkd) {\n          col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n        }\n      }\n    }\n    if (col4.a >= 0.) {\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir, 0.5 * grndScl);\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = mix (col4.rgb, SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (isRefl) col = mix (col, vec3 (0., 1., 1.), 0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vd, cb, sb;\n  float flPit, flYaw, flRol, vh;\n  flPos = vec3 (-1.5 * bldgScl, 6.7 * bldgScl + 2.7 * (1. + sin (0.3 * t)), 0.);\n  vd.xz = Rot2D (vec2 (1., 0.), 1.8 * pi * sin (0.03 * pi * t));\n  vd.y = -0.07 * pi * cos (0.1 * pi * t);\n  vh = length (vd.xz);\n  if (vh > 0.) {\n    flPit = atan (vd.y, vh);\n    flYaw = 0.5 * pi - atan (vd.z, - vd.x);\n  } else {\n    flPit = 0.;\n    flYaw = 0.5 * pi;\n  }\n  flRol = 0.1 * sin (1. * t);\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  flMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.5 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2.2 * pi * mPtr.x;\n    el -= 0.3 * pi * mPtr.y;\n  } else {\n    az -= 2. * pi * SmoothBump (0.25, 0.75, 0.25, mod (0.01 * tCur, 1.));\n    el -= 0.04 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.15 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  bldgScl = 4.;\n  heliScl = 0.5;\n  FlyerPM (tCur);\n  ro = vuMat * vec3 (0., 0., -1.4) * grndScl;\n  ro.y += 0.22 * grndScl + 4. * bldgScl;\n  zmFac = 6. - 2. * cos (az + 0.5 * pi);\n  dstFar = 10. * grndScl;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1358, 1358, 1381, 1438, 1835], [1837, 1837, 1871, 1871, 2362], [2364, 2364, 2386, 2386, 2642], [2644, 2644, 2680, 2680, 4470], [4472, 4472, 4507, 4507, 5990], [5992, 5992, 6014, 6014, 6135], [6137, 6137, 6170, 6170, 6374], [6376, 6376, 6397, 6397, 6652], [6654, 6654, 6703, 6703, 6955], [6957, 6957, 6989, 6989, 7524], [7526, 7526, 7559, 7559, 7978], [7980, 7980, 8015, 8015, 11144], [11146, 11146, 11170, 11170, 11882], [11899, 11899, 11955, 11955, 13366], [13368, 13368, 13414, 13414, 13461], [13463, 13463, 13510, 13510, 13557], [13559, 13559, 13601, 13601, 13652], [13654, 13654, 13697, 13697, 13770], [13772, 13772, 13829, 13829, 13905], [13907, 13907, 13952, 13952, 14055], [14057, 14057, 14102, 14102, 14140], [14142, 14142, 14199, 14199, 14282], [14284, 14284, 14320, 14320, 14526], [14528, 14528, 14558, 14558, 14671], [14673, 14673, 14704, 14704, 14768], [14802, 14802, 14826, 14826, 14938], [14940, 14940, 14965, 14965, 15151], [15153, 15153, 15174, 15174, 15329], [15331, 15331, 15360, 15360, 15572], [15574, 15574, 15613, 15613, 15793]], "test": "untested"}
{"id": "fds3WH", "name": "metaball loading animation", "author": "hanker", "description": "loadingmetaball", "tags": ["color", "metaball", "animation", "loading"], "likes": 3, "viewed": 360, "published": 3, "date": "1615878631", "time_retrieved": "2024-07-30T19:32:18.401103", "image_code": "//\n#define PI 3.1415\nfloat metaCircle(vec2 uv,vec2 center,float radius){\n    float offsetX = uv.x - center.x;\n    float offsetY = uv.y - center.y;\n    return sqrt((radius * radius) / (offsetX * offsetX + offsetY * offsetY));\n}\nfloat meta(vec2 uv,vec3 c1,vec3 c2){\n    float m1 = metaCircle(uv,c1.xy,c1.z);\n    float m2 = metaCircle(uv,c2.xy,c2.z);\n    return m1 + m2;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n\n  \n    vec2 cA = vec2(.6 * sin(iTime ),0.);\n    vec2 cB = vec2(.6 * sin(iTime + PI * .5),0.);\n    vec2 cC = vec2(.6 * sin(iTime + PI) ,0.);\n\n    float r1 = .1 + .05 * cos(iTime);\n    float r2 = .1 + .05 * cos(iTime + PI * .5);\n    float r3 = .1 + .05 * cos(iTime + PI);\n\n    vec3 colorA = vec3(1.,0.,0.);\n    vec3 colorB = vec3(0.,1.,0.);\n    vec3 colorC = vec3(0.,0.,1.);\n\n    float perA = metaCircle(uv,cA,r1);\n    float perB = metaCircle(uv,cB,r2);\n    float perC = metaCircle(uv,cC,r3);\n    \n    float m = perA + perB + perC;\n    m = smoothstep(.9,1.,m);\n\n    //\n    //TODO \n    float effect1 = length(uv - cA) > r1 ? perA * 2.5 : 1.;\n    float effect2 = length(uv - cB) > r2 ? perB * 2.5 :  1.;\n    float effect3 = length(uv - cC) > r3 ? perC * 2.5 :  1.;\n\n    vec3 col = ((colorA * effect1 ) + (colorB * effect2) + (colorC * effect3)) * m;\n\n    fragColor = vec4(col,1.);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 87, 87, 241], [242, 242, 278, 278, 384], [386, 386, 439, 439, 1505]], "test": "untested"}
{"id": "fss3W8", "name": "Froth", "author": "wyatt", "description": "Foam formation.", "tags": ["fluid", "automata"], "likes": 18, "viewed": 596, "published": 3, "date": "1615870749", "time_retrieved": "2024-07-30T19:32:19.210937", "image_code": "// Fork of \"Cave Paint\" by wyatt. https://shadertoy.com/view/fssGW8\n// 2021-03-16 04:51:42\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-16 04:22:58\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = 3.*(exp(f.wwww*1.4-.6)-1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = C(B(U).xy*R);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        vec4 c = C(b.xy*R);\n        Q.xy -= 0.2*Q.w*a.w*(a.w-.1)*(.1+1.*c.x*q.x)*u;  \n    }\n    Q.xy *= .999;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0.,.5);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-.5*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-.5*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .52;\n       float k = .52;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Qb.xyz*wa+qb.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (iFrame<1)\n        Q = vec4(U/R,1.-(U.x+U.y)/R.x,1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fss3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fssGW8", "name": "Cave Paint", "author": "wyatt", "description": "Long ago, early hominids made shaders in their caves", "tags": ["fluid", "automata"], "likes": 44, "viewed": 1092, "published": 3, "date": "1615868863", "time_retrieved": "2024-07-30T19:32:19.977887", "image_code": "// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-16 04:22:58\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = (C(c.xy*R)*1.6-.6)*min(f.w,1.3);\n    Q *= 1.6+sqrt(Q);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = C(B(U).xy*R)*2.-1.;\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        vec4 c = C(b.xy*R)*2.-1.;\n        Q.xy -= 0.1*Q.w*a.w*(a.w+.25*dot(c,q)-1.)*u;  \n    }\n    Q.y -= 1e-2*q.x;\n    Q.xy *= .99;\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0.,.5);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-4.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-4.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Qb.xyz*wa+qb.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (iFrame<1)\n        Q = vec4(U/R,1.-(U.x+U.y)/R.x,1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dX3DH", "name": "3D Truchet Try", "author": "oneshade", "description": "Trying to do a 3D truchet tiling, and succeeding! The trick is to make sure there is a node in the middle of each cell edge/face/I don't know what a 4 dimensional face is called.", "tags": ["3d", "raymarching", "grid", "truchet", "tiling"], "likes": 8, "viewed": 211, "published": 3, "date": "1615862530", "time_retrieved": "2024-07-30T19:32:20.753812", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash33(in vec3 p) {\n\tp = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p += dot(p, p.yxz + 33.33);\n    return fract((p.xxy + p.yxx) * p.zyx);\n}\n\nfloat sdTorus(in vec3 p, in float r, in float t) {\n    return length(vec2(length(p.xz) - r, p.y)) - t;\n}\n\nfloat mapScene(in vec3 p) {\n    float c = 5.0, h = 0.5 * c; // Cell size and half that\n    vec3 cell = floor(p / c + 0.5) * c;\n    p -= cell;\n\n    p *= sign(Hash33(cell) - 0.5); // Flip randomly\n    float d = sdTorus(p + vec3(h, 0.0, -h), h, 0.25);\n    d = min(d, sdTorus(p.xzy - vec3(h, 0.0, h), h, 0.25));\n    d = min(d, sdTorus(p.yxz + vec3(h, 0.0, h), h, 0.25));\n\n    return d;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.28;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec2(iTime + 2.5, 0.5).xxy;\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb = abs(n) * max(0.2, dot(n, -rd));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 113, 113, 235], [237, 237, 287, 287, 341], [343, 343, 370, 370, 726], [728, 728, 755, 755, 1002], [1004, 1004, 1059, 1059, 1903]], "test": "untested"}
{"id": "sdXGW8", "name": "Barycentric Space", "author": "oneshade", "description": "Barycentric coordinates taking strange slices of a box gradient.", "tags": ["3d", "space", "barycentric", "thoughtexperiment"], "likes": 4, "viewed": 199, "published": 3, "date": "1615860559", "time_retrieved": "2024-07-30T19:32:21.521759", "image_code": "vec3 barycoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nfloat map(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    mat2 rot = mat2(c, -s, s, c);\n\n    p.xy *= rot;\n    p.xz *= rot;\n\n    //return length(vec2(length(p.xz) - 0.5, p.y)) - 0.25;\n\n    //return length(p) - 0.75;\n\n    vec3 q = abs(p) - 0.5;\n    //return max(q.x, max(q.y, q.z));\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\nvec3 grad(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    vec2 a = vec2(-0.5, -0.5);\n    vec2 b = vec2( 0.5, -0.5);\n    vec2 c = vec2( 0.0,  1.0);\n\n    vec3 uvw = barycoords(uv, a, b, c);\n    fragColor = vec4(grad(uvw), 1.0);\n    //fragColor = vec4(smoothstep(unit, 0.0, map(uvw)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 385], [387, 387, 409, 409, 748], [750, 750, 772, 772, 989], [991, 991, 1046, 1046, 1382]], "test": "untested"}
{"id": "tdcXzX", "name": "Basic Light Rays", "author": "RynsArgent", "description": "Inexpensive light ray shader code with fade out along the borders", "tags": ["ray"], "likes": 7, "viewed": 497, "published": 3, "date": "1615838876", "time_retrieved": "2024-07-30T19:32:22.287711", "image_code": "// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat rayValue(in vec2 coord, in float frequency, in float travelRate, in float maxStrength)\n{\n    // Fade out along borders of fragment\n    float nx = 2.0f * (coord.x - 0.5f);\n    float nx2 = min(1.0f, 3.5f - 3.5f * nx * nx);\n    float ny = 2.0f * (coord.y - 0.5f);\n    float ny2 = min(1.0f, 3.5f - 3.5f * ny * ny);\n    \n    float xModifier = 0.5f * (cos(iTime * travelRate + coord.x * frequency) + 1.0f);\n    float yModifier = sin(coord.y);\n    return maxStrength * xModifier * yModifier * nx2 * ny2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ray1 = rayValue(uv, 28.0f, -0.7f, 0.3);\n    float ray2 = rayValue(uv, 34.0f, 0.1f, 0.4);\n    float ray3 = rayValue(uv, 16.0f, -0.05f, 0.4);\n    float ray4 = rayValue(uv, 72.0f, 0.9f, 0.1);\n    float total = ray1 + ray2 + ray3 + ray4;\n    \n    // Output to screen\n    fragColor = vec4(total, total, total, total);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 191, 285, 327, 695], [697, 697, 754, 804, 1174]], "test": "untested"}
{"id": "sdsGWn", "name": "The Nostalgia Artifact", "author": "P_Malin", "description": "I'm not really sure why I made this but here it is.", "tags": ["nostalgia"], "likes": 13, "viewed": 795, "published": 3, "date": "1615831324", "time_retrieved": "2024-07-30T19:32:23.052666", "image_code": "// The Nostalgia Artifact\n// @P_Malin\n//\n// https://www.shadertoy.com/view/sdsGWn\n//\n// I'm not really sure why I made this but here it is.\n//\n// Based on this article https://intarch.ac.uk/journal/issue45/2/1.html\n\n#define AA 3\n\nint[] lut = int[] (\n0x2b, 0x4b, 0x0d, 0x78, 0xca, 0x60, 0x1d, 0xcd, 0x5b, 0x1e, 0xfe, 0x2c, 0xc0, 0x18, 0xf3, 0x11,\n0xf2, 0x40, 0x1a, 0xb7, 0xca, 0xa0, 0x19, 0x3c, 0x32, 0x9a, 0x40, 0x12, 0x7e, 0xfe, 0x87, 0x28,\n0x0c, 0xcd, 0x5a, 0x1e, 0xc0, 0x7a, 0xb3, 0xc2, 0xc5, 0x1e, 0x3c, 0x18, 0x02, 0xd7, 0xc0, 0x2a,\n0xee, 0x40, 0xeb, 0x2a, 0xea, 0x40, 0x22, 0xa2, 0x40, 0xeb, 0xc0, 0x7e, 0xb7, 0x20, 0x04, 0x23,\n0x23, 0x23, 0x23, 0x23, 0x7a, 0xa3, 0x3c, 0xc2, 0x05, 0x1f, 0x3a, 0xdd, 0x40, 0x3d, 0xca, 0xbe,\n0x1d, 0xc3, 0x05, 0x1f, 0xcd, 0x1c, 0x2b, 0xc0, 0xb7, 0xca, 0x4a, 0x1e, 0x3d, 0x87, 0x5f, 0xfe,\n0x2d, 0x38, 0x02, 0x1e, 0x26, 0xc3, 0xa2, 0x19, 0x11, 0x0a, 0x00, 0xd5, 0x28, 0x17, 0xcd, 0x4f,\n0x1e, 0xeb, 0xe3, 0x28, 0x11, 0xeb, 0xcf, 0x2c, 0xeb, 0x2a, 0xe4, 0x40, 0xeb, 0x28, 0x06, 0xcd,\n0x5a, 0x1e, 0xc2, 0x97, 0x19, 0xeb, 0x7c, 0xb5, 0xca, 0x4a, 0x1e, 0x22, 0xe4, 0x40, 0x32, 0xe1,\n0x40, 0xe1, 0x22, 0xe2, 0x40, 0xc1, 0xc3, 0x33, 0x1a, 0xcd, 0x37, 0x23, 0x7e, 0xfe, 0x2c, 0xcc,\n0x78, 0x1d, 0xfe, 0xca, 0xcc, 0x78, 0x1d, 0x2b, 0xe5, 0xcd, 0x94, 0x09, 0xe1, 0x28, 0x07, 0xd7,\n0xda, 0xc2, 0x1e, 0xc3, 0x5f, 0x1d, 0x16, 0x01, 0xcd, 0x05, 0x1f, 0xb7, 0xc8, 0xd7, 0xfe, 0x95,\n0x20, 0xf6, 0x15, 0x20, 0xf3, 0x18, 0xe8, 0x3e, 0x01, 0x32, 0x9c, 0x40, 0xc3, 0x7c, 0x20, 0xcd,\n0xca, 0x41, 0xfe, 0x23, 0x20, 0x06, 0xcd, 0x84, 0x02, 0x32, 0x9c, 0x40, 0x2b, 0xd7, 0xcc, 0xfe,\n0x20, 0xca, 0x69, 0x21, 0xf6, 0x20, 0xfe, 0x60, 0x20, 0x1b, 0xcd, 0x01, 0x2b, 0xfe, 0x04, 0xd2,\n0x4a, 0x1e, 0xe5, 0x21, 0x00, 0x3c, 0x19, 0x22, 0x20, 0x40, 0x7b, 0xe6, 0x3f, 0x32, 0xa6, 0x40 );\n\nvec2 dimension = vec2(10.0f, 18.0f);\n\n\nvec3 GetColor( int digit, int character, int place )\n{\n    int index = digit * int(dimension.y) + character;\n\n    int code = lut[index] + index;\n        \n    int bit = (3-place) * 2;\n    \n    int colIndex = (code >> bit) & 3;\n        \n    vec3 col = vec3(0);\n    \n    if (colIndex == 0)\n    {\n        col = vec3(9,122,164)/255.0f;\n    }\n    else\n    if (colIndex == 1)\n    {\n        col = vec3(252,68,80)/255.0f;\n    }\n    else\n    if (colIndex == 2)\n    {\n        col = vec3(223,43,142)/255.0f;\n    }\n    else\n    {\n        col = vec3(170,185,6)/255.0f;\n    }\n    \n    return col * col;\n}\n\nfloat GetVignetting( vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = sin(iTime * 0.1) * 0.1;\n    float s = sin(r);\n    float c = cos(r);\n\n    mat2 m = mat2(c,s,-s,c);\n\n    vec3 tot = vec3(0);\n    float count = 0.0f;\n    for( int i=0; i<AA*AA; i++ )\n    {\n        vec2 uv = fragCoord;\n        \n        /*\n        if ( iMouse.z > 0.0f )\n        {\n            uv -= iMouse.xy;\n            uv *= 0.25f;\n            uv += iMouse.xy;\n        }\n        */\n\n        uv.x += float(i / AA) / float(AA+1);\n        uv.y += float(i % AA) / float(AA+1);\n        \n        uv = uv/iResolution.xy;\n\n        float blackShade = 0.05f;\n        vec3 whiteShade = vec3(255,254,233) / 255.0f;\n\n        uv.y = 1.0f - uv.y;\n\n        uv -= 0.5;\n\n        vec2 sheetUV = uv;\n        sheetUV *= 1.2f;\n        sheetUV.x *= iResolution.x / iResolution.y;\n        sheetUV *= m;\n        sheetUV.x *= 4.0f / 2.56;\n        sheetUV += 0.5f;\n\n        sheetUV += texture(iChannel1, sheetUV).r * 0.0005;\n        sheetUV += texture(iChannel1, sheetUV.yx).r * 0.0005;\n\n        sheetUV.x += sheetUV.y * 0.01;\n        sheetUV.y -= sheetUV.x * 0.005;\n\n        vec2 gridUV = sheetUV * vec2(1.25f, 1.18f) - vec2(0.17f, 0.1f);\n\n        vec2 pos = gridUV * dimension; \n\n        ivec2 cellPos = ivec2( floor(pos) );\n\n        int place = int( fract(pos.x) * 4.0 );\n\n        vec3 col = GetColor( cellPos.x, cellPos.y, place );\n        float grain2 = texture( iChannel3, sheetUV * 3.0f ).r;        \n\n        if (fract(pos.x * 4.0f + 0.1f/2.0f)< 0.1f)\n        {\n            col = vec3(0.0f);\n        }\n\n        if ( gridUV.x < 0.0f || gridUV.y < 0.0f || gridUV.x >= 1.0f || gridUV.y >= 1.0f )\n        {\n            col = whiteShade;\n            col = col * col;\n        }\n        \n        vec2 digitUV = pos - vec2(0,-0.22);\n        if (floor(digitUV.y) == -1.0 )\n        {\n            int digit = int(floor(digitUV.x));\n            if ( digit >= 0 && digit < int(floor(dimension.x)) )\n            {\n\n                vec2 charUV = fract( digitUV );\n                charUV = charUV * 1.2f;\n                charUV.x += 0.1 + sin(float(digit)* 10.0f) * 0.05f - float(digit) * 0.04f;\n                charUV.y += -0.02 + sin(float(digit)* 12.0f) * 0.01f;\n\n                int charIndex = digit + 48;\n                charUV.x += float( charIndex % 16 );\n                charUV.y += float( charIndex / 16 );\n\n                charUV = charUV / 16.0f;\n                charUV.y = 1.0f - charUV.y;\n                float d = texture(iChannel0, charUV).w;\n                float t = clamp( (0.5f - d) * 50.0f, 0.0f, 1.0f);\n\n                col = mix( col, vec3(blackShade), t);\n            }\n        }\n\n        vec2 letterUV = pos - vec2(-0.2,0);\n        if (floor(letterUV.x) == -1.0 )\n        {\n            int letter = int(floor(letterUV.y));\n            if ( letter >= 0 && letter < int(floor(dimension.y)) )\n            {\n\n                vec2 charUV = fract( letterUV );\n                charUV = charUV * 1.2f;\n                charUV = charUV - 0.1f;\n                charUV.x += 0.1 + sin(float(letter)* 10.0f) * 0.01f;\n                charUV.y += sin(float(letter)* 12.0f) * 0.05f;\n\n                int charIndex = letter + 65;\n                charUV.x += float( charIndex % 16 );\n                charUV.y += float( charIndex / 16 );\n\n                charUV = charUV / 16.0f;\n                charUV.y = 1.0f - charUV.y;\n                float d = texture(iChannel0, charUV).w;\n                float t = clamp( (0.5f - d) * 50.0f, 0.0f, 1.0f);\n\n                col = mix( col, vec3(blackShade), t);\n            }\n        }\n\n        vec2 linePos = pos + .1 /2.0;\n        vec2 lineIndex = floor(linePos);\n\n        vec2 border = vec2(0.03, 0.02);\n        if ( lineIndex.x == 0.0 || lineIndex.x == dimension.x )\n        {\n            border.y = (.1 /4.0) * 0.1f;\n        }\n        if ( lineIndex.y == 0.0 || lineIndex.y == dimension.y )\n        {\n            border.x = (.1 /4.0) * 0.1f;\n        }\n\n        if ( lineIndex.y >= 0.0 && lineIndex.y <= dimension.y )\n        {\n            if ( gridUV.x >= -border.x && gridUV.x - 1.0 < border.x )\n            {\n                if (fract(linePos.y)< 0.1f)\n                {\n                    col = vec3(blackShade);\n                }\n            }\n        }\n\n        if ( lineIndex.x >= 0.0 && lineIndex.x <= dimension.x )\n        {\n            if ( gridUV.y - 1.0 < border.y && gridUV.y >= -border.y )\n            {\n                if (fract(linePos.x)< 0.1f)\n                {\n                    col = vec3(blackShade);\n                }    \n            }\n        }\n\n        if( grain2 <0.08 )\n        {\n            col = whiteShade;\n            col = col * col;\n        }\n\n\n        col += (grain2 - 0.5) * 0.1;\n\n        float grain = texture( iChannel1, sheetUV * 10.0 ).r;\n        float amount = 0.3f;\n        amount = 0.1 + pow(sheetUV.x, 80.0f) * 0.9f;\n        col *= 1.0f - grain * amount;\n\n        vec3 bgCol = texture( iChannel2, sheetUV * 0.5f ).rgb;\n        bgCol = bgCol * bgCol;\n\n        vec2 shadowUV = sheetUV - vec2(2, 1)/200.0;\n        if ( shadowUV.x >= 0.0f && shadowUV.y >= 0.0f && shadowUV.x - 1.0f < -grain*.01 && shadowUV.y - 1.0f < 0.0f )\n        {\n            bgCol *= 0.4f;\n        }\n\n        if ( sheetUV.x < 0.0f || sheetUV.y < 0.0f || sheetUV.x - 1.0f >= -grain*.015 || sheetUV.y - 1.0f >= 0.0f )\n        {\n            col = bgCol;\n        }\n\n        col *= 1.0 - sheetUV.y * 0.2 - sheetUV.x * 0.1;\n        \n        tot += col;\n        count += 1.0f;\n    }\n\n    vec3 result = tot / count;\n        \n    result *= GetVignetting( fragCoord/iResolution.xy, 1.0f, 0.7f, 1.0f );\n        \n    result *= 1.5f;\n        \n    result = sqrt(result);\n        \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1828, 1828, 1882, 1882, 2417], [2419, 2419, 2497, 2497, 2713], [2715, 2715, 2772, 2772, 8411]], "test": "untested"}
{"id": "7ds3zN", "name": "blokus game", "author": "FabriceNeyret2", "description": "4 players version ( no computer yet ).\nTry to put as many pieces (indeed, as many squares), via diagonal connection since your base corner.\nMouse: pick piece.\n: rotate  piece. : symmetrize.    SPACE: play the piece.\nC: force next color.", "tags": ["game"], "likes": 14, "viewed": 483, "published": 3, "date": "1615827365", "time_retrieved": "2024-07-30T19:32:23.821610", "image_code": "// === Blokus game ==============================================================\n// https://en.wikipedia.org/wiki/Blokus\n// https://www.google.com/search?q=blokus&tbm=isch\n\ninclude\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 I = vec3(-1,0,1); \n    vec4 s = vec4(0);\n    U = grid(U);\n    \n    if ( min(U.x,U.y) > 0. && max(U.x,U.y) < 20. ) {    // --- draw board\n        O = color[int(C(U).x)];\n#define mine(d) C(U+I.d).x == T(STATE).x\n        if ( C(U).x == 0.                               // show licit places\n             &&  ( mine(xx) || mine(zx) || mine(xz) || mine(zz) )\n             && !( mine(xy) || mine(zy) || mine(yx) || mine(yz) )\n           ) O += .2 + .2*sin(12.*iTime);\n    } \n    else { \n        O = vec4(.5);\n        float N = pick(U);                              // --- draw available pieces\n        if (N >= 0. ) { \n            int n = int (s.w = N ), c = int(T(STATE).x); \n            if ( T(vec2(n,STATE))[c-1] > 0. ) {         // is available\n                u -= vec2(hand[n]%16,hand[n]>>4);       // pieces aligned in Bbox\n                if (n==14) s.z = 1., u.x-=2.,u.y++;     // the long bar is overfill :-)\n                if ( draw( u, s ) > 0. )\n                    draw( u+2.*pix, s ) > 0. ? O = color[c] : O--; // draw or shadow\n            }\n        }\n    }    \n    vec2 F = fract(U);                                  // --- general grid\n    if ( min(F.x,F.y) < pix ) O = vec4(.3);\n\n    int k = int(4.*fract(U.x+.5));                      // --- display score\n    if ( U.x > 20.5 && U.x < 21.5 && U.y>0. && U.y*89./20. < T(STATE+1.)[k] )\n        O = color[k+1];\n    \n    U -= grid(iMouse.xy); F = fract(U);                 // --- draw candidate piece\n    s = T(STATE); \n    if ( min(F.x,F.y) > pix && s.w >= 0. ) O += draw(U,s);\n /* if ( draw(U,s) > 0. && min(F.x,F.y) > pix )         // show licit handles\n        O = draw(U+I.xy,s)+ draw(U+I.zy,s) != 2. && draw(U+I.yx,s) + draw(U+I.yz,s) != 2.\n               ? vec4(.8,.8,1,0) : vec4(1); */\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R             iResolution.xy\n#define T(U)          texelFetch(iChannel0, ivec2(U), 0 )\n#define C(U)          T(U+1.)                              // cell offsetet because of margin\n#define keyDown(a)  ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n//#define grid(U)      22.* ( U - vec2((R.x-R.y)*.5,0) ) / R.y\n#define grid(U)        22.* ( U - vec2( R.x-R.y , 0  ) ) / R.y - vec2(0,1)\n#define pix            22./R.y\n\n// --- data structure ---\n// [1,20][1,20] : O.x = color [1,4] + margin ( for start position at angles )\n// (STATE,STATE) : current state: .x = color, .y = sym, .z = rotation, .w = piece\n// (STATE+1,STATE+1) : current score for each player ( .xyzw )\n// ([1,20],STATE)    : piece availability for each player (.xyzw )\n\n#define                STATE 24.5\n\n// --- list of piece shapes ( 4  n bits ) and their handle position ( = x + 4y )\nint piece[21]  = int[]( 1, 3, 7, (3<<4)+1, (3<<4)+3, \n                       (2<<4)+7, 15, (1<<4)+7, (3<<4)+6, (8<<4)+15, \n                       (2<<8)+(2<<4)+7, (4<<8)+(4<<4)+7, (7<<4)+12, (1<<8)+(7<<4)+4, 69905,\n                       (2<<8)+(3<<4)+3, (3<<8)+(6<<4)+4, (3<<8)+(2<<4)+3, (3<<8)+(6<<4)+2,\n                       (2<<8)+(7<<4)+2, (4<<4) + 15\n                      );\nint size[21]  = int[] ( 1, 2, 3,3, 4,4,4,4,4, 5,5,5,5,5,5,5,5,5,5,5,5 );\nint hand[21]  = int[] ( 0,0,1,16,16,  1,1,1,1,16,  17,3,19,17,32, 17,17,17,17,17,3 );\n\n// --- start handle and color of each player\nvec2 start[4] = vec2[](          vec2(20), vec2(20,-1), vec2(-1), vec2(-1,20) );\nvec4 color[5] = vec4[]( vec4(0), vec4(0,0,1,1), vec4(1,1,0,1), vec4(1,0,0,1), vec4(0,1,0,1) );\n\n\n// because Common are stupidely not really includes\n#define include                                                         \\\n                                                                        \\\nfloat draw(vec2 P, vec4 s ) {   /* --- draw a piece (screen or data) */ \\\n    vec2 I = floor(P);                                                  \\\n    int  n = int(s.w),                                                  \\\n        x = int(I.x), y = int(I.y),                                     \\\n        r = int(mod(s.z,4.)), _x;                                       \\\n    if ( r > 1 ) x = -x, y = -y, r-=2;        /* rotation & symmetry */ \\\n    if ( r > 0 ) _x=x, x = y, y = -_x;                                  \\\n    if ( s.y > 0. ) x = -x;                                             \\\n    x += hand[n]%16, y += hand[n]>>4;             /* handle position */ \\\n    return float(      x>=0 && y>=0 && x<4 && y<5                       \\\n                  && ( piece[n]>>(4*y+x) ) % 2 == 1 );                  \\\n}                                                                       \\\n                                                                        \\\nvec2 u;                                                                 \\\nfloat pick(vec2 U) {          /* --- pick a piece slot (left margin) */ \\\n    if (U.x > -16. && U.x<-1. && floor(U.y)!=17.) {                     \\\n        u = U + vec2( 16,  U.y<1. || U.y>18. ? 0 : 1 );                 \\\n        vec2 BB = vec2(5,3), V = floor( u / BB );                       \\\n        u = mod(u, BB);                  /* out position within slot */ \\\n        return V.x + 3.*V.y;                                            \\\n    }                                                                   \\\n    else return -1.;                                                    \\\n}\n", "buffer_a_code": "include \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 M = round(grid(iMouse.xy));\n    vec4 s = T(STATE);\n    vec3 I = vec3(-1,0,1); \n    O = T(U);                                         // restore state\n    bool play = false; \n    if ( keyDown(32) && s.w >= 0. ) {                 // --- user want to play here: check validity\n        bool pb = false, cn = false;\n        for (int k = 0; k<49; k++) {                  // check region of candidate piece\n            vec2 P = M + vec2(k%7-3,k/7-3);           // loop size to optimize\n #define mine(d) C(P+I.d).x == s.x \n            if ( draw( P-0.-M,  s ) > 0. ) {          // piece want to cover cell k\n                pb = pb || C(P).x > 0.                                   // non-free case\n                        || min(P.x,P.y) < 0. || max(P.x,P.y) > 19.       // out of board\n                        || mine(xy) || mine(zy) || mine(yx) || mine(yz); // tangents same color\n                cn = cn || mine(xx) || mine(zx) || mine(xz) || mine(zz); // contact with color tree\n            }\n        }\n        play = cn && !pb;\n    }\n   \n    if ( U==vec2(STATE) ) {                                        // --- basic user actions\n        if (iFrame<1)    O = vec4(3,0,0,-1); \n        if (play)        O = vec4( mod(O.x,4.)+1.,0,0,-1);         // valid play: next player\n        if (keyDown(67)) O.x = mod(O.x,4.)+1.;                     // current color\n     // if (keyDown(32)) O.w = mod(O.w+1.,21.),O.z = 0., O.y = 0.; // select piece \n        if (keyDown(37)) O.z++;                                    // rotate\n        if (keyDown(39)) O.z--;\n        if (keyDown(38)||keyDown(40)) O.y = 1.-O.y;                // symmetry\n        \n        float n = pick(M);                                         // pick a piece\n        if (n>=0. && iMouse.w>0. && T(vec2(n,STATE))[int(s.x)-1] > 0. ) \n            O.w =  n, O.z = 0., O.y = 0.;\n    }\n    if ( U==vec2(STATE+1.) && play )                               // score += piece size\n        O[int(s.x)-1] += float(size[int(s.w)]);\n    \n    if ( U.y == STATE && U.x < 21. ) {                             // --- list of available piece\n        if (iFrame<1)    O = vec4(1); \n        if ( iMouse.w > 0. ) {                                     // click\n            float n = pick(M);            \n            int    c = int(s.x)-1;\n            if ( U.x-.5==s.w && n >= 0. ) O[c] = 1.;               // put back the prev piece\n            if ( U.x-.5== n  && O[c]>0. ) O[c] = 0.;               // pick the new one\n        }\n    }\n    if ( min(U.x,U.y) > 0. && max(U.x,U.y) < 21. && play )         // --- play the piece\n         O.x += draw( U-1.-M , s ) * s.x;\n         \n    if (iFrame<1) for(int k=0; k<4; k++)                           // --- start positions\n                      if (U-.5==start[k]+1.) O.x = float(k+1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ds3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsf3W8", "name": "gridblend2", "author": "Del", "description": "will these grids blend? er, no, not really", "tags": ["grid", "blend", "hex", "tri"], "likes": 16, "viewed": 318, "published": 3, "date": "1615825780", "time_retrieved": "2024-07-30T19:32:24.587562", "image_code": "// Simple grids (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 15/03/2021\n//\n//\n// will it blend? (attempt2) er, not really\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// EquilateralTriangle distance\nfloat sdEqTri(in vec2 p)\n{\n    const float k = 1.7320508;//sqrt(3.0);\n    p.x = abs(p.x) - 0.5;\n    p.y = p.y + 0.5/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -1.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// triangle grid equiv\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    const vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n    uv /= s;\n    float ys = mod(floor(uv.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(uv.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(uv.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    ep.y = (ep.y + 0.14433766666667*itri) * itri;\n    float edge = sdEqTri(ep); // dist to edge\n    id = p4.zw;\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    p4.y+=0.14433766666667*itri;\n    return vec4(abs(edge),length(p4.xy),p4.xy);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n\n#define\tPI 3.14159\n#define\tTAU 6.28318\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    a.x = smin(a.x,b.x,k);\n    a.y = smin(a.y,b.y,k);\n    return a;\n}\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    a.x = smin(a.x,b.x,k);\n    a.y = smin(a.y,b.y,k);\n    a.z = smin(a.z,b.z,k);\n    a.w = smin(a.w,b.w,k);\n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n\n    // dirty grid blend!\n    vec2 id,id2;\n    vec4 h,h2;\n\t\n    //h2 = SquareGrid(uv*8.0, id2);\n    vec2 uv2 = uv;\n    vec2 uv1 = uv;\n    uv1 *= rot(t*0.1);\n    uv2 *= rot(-t*0.1);\n    \n    h2 = HexGrid(uv1*2.0, id2);\n    \n    uv2 *= 1.5+sin(t*0.6)*0.5;\n    h = TriGrid(uv2*4.0, id);\n\t\n\tfloat tt = SmoothTri2(fract(t*0.2),3.0)-1.0;\n\t\n\ttt = clamp(tt,0.0,1.0);\n\t\n\t//h = mix(h,h2,tt);\n\t//id = mix(id,id2,tt);\n\t\n    h = smin(h,h2,0.25);\n    id = smin(id,id2,0.25);\n\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.2,0.25,0.35);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = 132.5; // 4.1\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(uv,250.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(bordercol,shapecol, smoothstep(0.0,0.015,h.x)); // edge\n    //finalcol = mix(bordercol,finalcol, smoothstep(0.0,0.065,h.y));  // centre\n    \n    // vignetting\n    uv = fragCoord/iResolution.xy;\n\tfinalcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    //finalcol = vec3(h.zw,0.0); // just show cell uv\n    \n    // divider lines\n    //float div = (1.0-max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025)));\n    fragColor = vec4(finalcol ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 196, 196, 631], [633, 665, 691, 691, 914], [916, 939, 975, 975, 1614], [1616, 1644, 1683, 1683, 1934], [1936, 1936, 1978, 1978, 2019], [2061, 2079, 2117, 2117, 2164], [2165, 2165, 2186, 2186, 2254], [2255, 2255, 2296, 2296, 2385], [2387, 2387, 2425, 2425, 2495], [2496, 2496, 2534, 2534, 2658], [2661, 2661, 2718, 2718, 4215]], "test": "untested"}
{"id": "fsX3W8", "name": "gridblend", "author": "Del", "description": "grid blend test", "tags": ["grid", "blend", "hex", "tri"], "likes": 5, "viewed": 260, "published": 3, "date": "1615824719", "time_retrieved": "2024-07-30T19:32:25.362490", "image_code": "// Simple grids (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 15/03/2021\n//\n//\n// will it blend? er, not really\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// EquilateralTriangle distance\nfloat sdEqTri(in vec2 p)\n{\n    const float k = 1.7320508;//sqrt(3.0);\n    p.x = abs(p.x) - 0.5;\n    p.y = p.y + 0.5/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -1.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// triangle grid equiv\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    const vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n    uv /= s;\n    float ys = mod(floor(uv.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(uv.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(uv.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    ep.y = (ep.y + 0.14433766666667*itri) * itri;\n    float edge = sdEqTri(ep); // dist to edge\n    id = p4.zw;\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    p4.y+=0.14433766666667*itri;\n    return vec4(abs(edge),length(p4.xy),p4.xy);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n\n#define\tPI 3.14159\n#define\tTAU 6.28318\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n\n    // dirty grid blend!\n    vec2 id,id2;\n    vec4 h,h2;\n\t\n    //h = SquareGrid(uv*8.0, id2);\n\tuv *= rot(t*0.1);\n    h2 = HexGrid(uv*16.0, id2);\n    h = TriGrid(uv*8.0, id);\n\t\n\tfloat tt = SmoothTri2(fract(t*0.2),3.0)-1.0;\n\t\n\ttt = clamp(tt,0.0,1.0);\n\t\n\th = mix(h,h2,tt);\n\tid = mix(id,id2,tt);\n\t\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.15,0.25,0.05);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 4.1\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(bordercol,shapecol, smoothstep(0.0,0.035,h.x)); // edge\n    finalcol = mix(bordercol,finalcol, smoothstep(0.0,0.065,h.y));  // centre\n    \n    // vignetting\n    uv = fragCoord/iResolution.xy;\n\tfinalcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    //finalcol = vec3(h.zw,0.0); // just show cell uv\n    \n    // divider lines\n    //float div = (1.0-max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025)));\n    fragColor = vec4(finalcol ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 185, 185, 620], [622, 654, 680, 680, 903], [905, 928, 964, 964, 1603], [1605, 1633, 1672, 1672, 1923], [1925, 1925, 1967, 1967, 2008], [2050, 2068, 2106, 2106, 2153], [2154, 2154, 2175, 2175, 2243], [2245, 2245, 2302, 2302, 3630]], "test": "untested"}
{"id": "ssX3Wr", "name": "GridX3", "author": "Del", "description": "3 simple drop in grid functions - click a grid to show it as full screen\nbaked shader info used here - https://www.youtube.com/watch?v=MpwcOnrWffQ", "tags": ["grid", "simplex", "square", "distance", "edge", "hex", "tri"], "likes": 15, "viewed": 441, "published": 3, "date": "1615768551", "time_retrieved": "2024-07-30T19:32:26.140410", "image_code": "// Simple Hex, Tri and Square grids (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 15/03/2021\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\n// All 3 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    //id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    //id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n/*\n// triangle grid equiv\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    const vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n    uv /= s;\n    float ys = mod(floor(uv.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(uv.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(uv.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    float off = 0.14433766666667*itri;\n    ep.y = (ep.y + off) * itri;\n    \n    // inline sdEqTri\n    const float k = 1.7320508;//sqrt(3.0);\n    ep.x = abs(ep.x) - 0.5;\n    ep.y = ep.y + 0.5/k;\n    if( ep.x+k*ep.y>0.0 ) ep = vec2(ep.x-k*ep.y,-k*ep.x-ep.y)/2.0;\n    ep.x -= clamp( ep.x, -1.0, 0.0 );\n    float edge = -length(ep)*sign(ep.y);    // dist to edge\n    \n    id = p4.zw;\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    p4.y+=off;\n    return vec4(abs(edge),length(p4.xy),p4.xy);\n}\n*/\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 3xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(float xx)\n{\n    float gridtype = 0.5;\n    if (iMouse.z>0.5)\n        xx = ((iMouse.x-.5*iResolution.x) / iResolution.x)+0.5;\n    if (xx > 0.66)\n        gridtype=2.5;\n    else if (xx > 0.33)\n        gridtype = 1.5;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float gridtype = SelectGrid(xx);\n    if (gridtype>= 2.0)\n        h = SquareGrid(uv*8.0, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*8.0, id);\n    else\n        h = TriGrid(uv*8.0, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.35,0.22,0.35);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        if (uv.y < 0.0)\n            finalcol = vec3(h.x,h.x,h.x); // just show cell edge distances in bottom half of screen\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 344, 380, 380, 815], [817, 885, 921, 921, 1483], [2440, 2468, 2507, 2507, 2773], [2775, 2775, 2817, 2817, 2858], [2860, 2920, 2948, 2948, 3172], [3174, 3174, 3231, 3231, 5115]], "test": "untested"}
{"id": "7sfGWr", "name": "wired shing", "author": "dab9090", "description": "idk", "tags": ["cool", "wired", "probla"], "likes": 0, "viewed": 207, "published": 3, "date": "1615767353", "time_retrieved": "2024-07-30T19:32:26.904368", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy*.25)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float plot = ((uv.x+uv.x)*uv.x)*cos(iTime)/sin(iTime);\n    \n    if (uv.y < (plot-uv.y)) col = vec3(cos(iTime),sin(iTime * 0.12324235),cos(-iTime*3.1415));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 417]], "test": "untested"}
{"id": "sdfGWr", "name": "Bubbles!!!", "author": "wyatt", "description": "MOTHERFREAKIN BUBBLESSSSSSSS", "tags": ["fluid", "automata"], "likes": 19, "viewed": 536, "published": 3, "date": "1615765592", "time_retrieved": "2024-07-30T19:32:27.683285", "image_code": "// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-14 23:43:37\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 a = A(U), b = B(U);\n    Q = min(a.w,1.)*(0.5+0.5*sin(iTime*.1+8.*a.z+vec4(1,2,3,4)));\n    Q+= min(b.w,1.)*(0.5-0.5*sin(iTime*.1+8.*b.z+vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.08*(a.w*(a.w-.9)+.5*a.w*b.w)*u; \n    }\n    Q.y -= 1.5e-5;\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(-.3,0,U.x/R.x,step(.7*R.x,U.x));\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float k = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.08*(a.w*(a.w-.7)+.5*a.w*b.w)*u;   \n    }\n    Q.y -= 1.5e-5;\n    if (iMouse.z>0.) \n    Q.xy -= -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(.3,0,U.x/R.x,step(U.x,.3*R.x));\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float k = .5+.5*smoothstep(1.,0.,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssX3Dn", "name": "Gloopy Honeycomb", "author": "oneshade", "description": "A blobby structure. Arrow keys to move and mouse to look around.", "tags": ["blobby", "integration", "honey", "sticky", "gloopy"], "likes": 2, "viewed": 190, "published": 3, "date": "1615763624", "time_retrieved": "2024-07-30T19:32:28.451232", "image_code": "// (cos(2(o + dt))  1, 1, 1 - 1) / 2\n// Integrals get very complicated very fast it seems :(\nfloat getVolume(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    return 0.25 * dot(sin(2.0 * (ro + rd * tmin)) - sin(2.0 * (ro + rd * tmax)), 1.0 / rd) + 0.5 * (tmax - tmin);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec3 ro = getCameraPosition() + vec3(HALF_PI, HALF_PI, 0.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec2 viewDir = (iMouse.xy - center) / iResolution.y * TWO_PI * ROTATION_SPEED;\n    float cy = cos(viewDir.x), sy = sin(viewDir.x);\n    float cp = cos(viewDir.y), sp = sin(viewDir.y);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float volume = getVolume(ro, rd, 0.0, 5.0) / 5.0;\n    fragColor = vec4(vec3(1.0, 0.7, 0.4) * volume, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        if (addr == CAM_POS_ADDR) {\n            fragColor = vec4(getCameraPosition(), 1.0);\n\n            vec2 viewDir = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            mat3 cam = getCamera(viewDir);\n\n            if (keyUpPressed()) {\n                fragColor.xyz += cam[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= cam[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += cam[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= cam[0] * STEP_SIZE;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define HALF_PI 1.57079632679\n\n// Camera control:\n#define STEP_SIZE 0.1\n#define ROTATION_SPEED 0.5\n\n// Data addresses:\n#define CAM_POS_ADDR ivec2(0, 0)\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\n#define    KEY_UP 38\n#define  KEY_DOWN 40\n#define KEY_RIGHT 39\n#define  KEY_LEFT 37\n\n#define getCameraPosition() texelFetch(iChannel0, CAM_POS_ADDR, 0).xyz\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Computes camera matrix:\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 105, 176, 176, 292], [294, 294, 349, 349, 965]], "test": "untested"}
{"id": "7sXGDn", "name": "DuoGrids", "author": "Del", "description": "Handy Grid functions (Hex and Tri)", "tags": ["grid", "simplex", "distance", "edge", "hex", "tri", "centre"], "likes": 6, "viewed": 298, "published": 3, "date": "1615762874", "time_retrieved": "2024-07-30T19:32:29.227157", "image_code": "// Hex and Tri grids (SST)\n\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id *= inverse(mat2(1.1547,0.0,-0.5773503,1.0));// unskew\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// EquilateralTriangle distance\nfloat sdEqTri( in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 0.5;\n    p.y = p.y + 0.5/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -1.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// triangle grid equiv\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\n\nconst vec2 s = vec2(1, .8660254); // Sqrt (3)/2\n\nvec4 TriGrid(vec2 p, out vec2 id)\n{\n    p /= s;\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    float itri = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    p4 = itri>0.? vec4(p4.xy*s, ip4.xy) : vec4(p4.zw*s, ip4.zw);  \n\n    vec2 ep = p4.xy;\n    ep.y += 0.14433766666667*itri;\n    ep.y *= itri;\n    float tri = sdEqTri(ep);\n    float mid = length(ep);// dist to centre\n    id = p4.zw;\n    //id *= mat2(1.1547,0.0,-0.5773503,1.0); // adjust ID (optional)\n    \n    //id *= i*0.1; // adjust ID\n    //id *=  (itri < 0.0 ? 1.0 - id : id); // adjust ID\n    p4 = vec4(abs(tri),mid,p4.xy);\n    return p4;\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    //uv.y += t*0.1;\n    \n    vec2 id;\n    vec4 h;\n    \n    if (uv.x < 0.0)\n        h = HexGrid(uv*8.0, id);\n    else\n        h = TriGrid(uv*8.0, id);\n\n    float _v1 = smoothstep(0.0,0.035,h.x); // edge\n    float _v2 = smoothstep(0.0,0.065,h.y); // centre\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.44,0.29,0.2);\n    \n    float patternVal = .5; // 4.1\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(bordercol,shapecol,_v1);\n    finalcol = mix(bordercol,finalcol,_v2);  \n    \n    //finalcol = vec3(h.zw,0.0); // show uv\n    finalcol *=  1.0-step(abs(uv.x),0.0025); // divider line\n    \n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 202, 238, 238, 734], [736, 768, 795, 795, 1006], [1188, 1188, 1223, 1223, 1901], [1903, 1903, 1945, 1945, 1986], [1988, 1988, 2045, 2045, 2957]], "test": "untested"}
{"id": "7dX3Wn", "name": "Heartfelt Raining Blood", "author": "woozie", "description": "Listen with some Slayer on :)\n\nIf you want to see and control the rain, comment out the HAS_HEART define\nControls: Mouse x = scrub time  y = rain amount (only without heart)\n\nBased on \"Heartfelt\" by @The_ArtOfCode\nhttps://t.co/c6PjdNvpjc?amp=1", "tags": ["glass", "heart", "rain", "drop", "sad", "window", "droplets", "drops", "raining", "rainonwindow"], "likes": 13, "viewed": 991, "published": 3, "date": "1615758791", "time_retrieved": "2024-07-30T19:32:29.993109", "image_code": "// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I revisited the rain effect I did for another shader. This one is better in multiple ways:\n// 1. The glass gets foggy.\n// 2. Drops cut trails in the fog on the glass.\n// 3. The amount of rain is adjustable (with Mouse.y)\n\n// To have full control over the rain, uncomment the HAS_HEART define \n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=uiF5Tlw22PI&feature=youtu.be\n\n// Music - Alone In The Dark - Vadim Kiselev\n// https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark\n// Rain sounds:\n// https://soundcloud.com/elirtmusic/sleeping-sound-rain-and-thunder-1-hours\n\n#define S(a, b, t) smoothstep(a, b, t)\n//#define CHEAP_NORMALS\n//#define HAS_HEART\n#define USE_POST_PROCESSING\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;\n    \n    #ifdef HAS_HEART\n    T = mod(iTime, 102.);\n    T = mix(T, M.x*102., M.z>0.?1.:0.);\n    #endif\n    \n    \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    float story = 0.;\n    float heart = 0.;\n    \n    #ifdef HAS_HEART\n    story = S(0., 70., T);\n    \n    t = min(1., T/70.);\t\t\t\t\t\t// remap drop time so it goes slower when it freezes\n    t = 1.-t;\n    t = (1.-t*t)*70.;\n    \n    float zoom= mix(.3, 1.2, story);\t\t// slowly zoom out\n    uv *=zoom;\n    minBlur = 4.+S(.5, 1., story)*3.;\t\t// more opaque glass towards the end\n    maxBlur = 6.+S(.5, 1., story)*1.5;\n    \n    vec2 hv = uv-vec2(.0, -.1);\t\t\t\t// build heart\n    hv.x *= .5;\n    float s = S(110., 70., T);\t\t\t\t// heart gets smaller and fades towards the end\n    hv.y-=sqrt(abs(hv.x))*.5*s;\n    heart = length(hv);\n    heart = S(.4*s, .2*s, heart)*s;\n    rainAmount = heart;\t\t\t\t\t\t// the rain is where the heart is\n    \n    maxBlur-=heart;\t\t\t\t\t\t\t// inside the heart slighly less foggy\n    uv *= 1.5;\t\t\t\t\t\t\t\t// zoom out a bit more\n    t *= .25;\n    #else\n    float zoom = -cos(T*.2);\n    uv *= .7+zoom*.3;\n    #endif\n    UV = (UV-.5)*(.9+zoom*.1)+.5;\n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(.0, .5, rainAmount);\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n   #ifdef CHEAP_NORMALS\n    \tvec2 n = vec2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))\n    #else\n    \tvec2 e = vec2(.001, 0.);\n    \tfloat cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    \tfloat cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    \tvec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n    #endif\n    \n    \n    #ifdef HAS_HEART\n    n *= 1.-S(60., 85., T);\n    c.y *= 1.-S(80., 100., T)*.8;\n    #endif\n    \n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    \n    \n    #ifdef USE_POST_PROCESSING\n    t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\n    float colFade = sin(t*.2)*.5+.5+story;\n    col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n    float lightning = sin(t*sin(t*10.));\t\t\t\t// lighting flicker\n    lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n    col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\n    col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette\n    \t\t\t\t\t\t\t\t\t\t\t\n    #ifdef HAS_HEART\n    \tcol = mix(pow(col, vec3(1.2)), col, heart);\n    \tfade *= S(102., 97., T);\n    #endif\n    \n    col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    #endif\n    \n    // BLOOD RAIN \n    float drop = length(c);\n    if (drop > 0.1)\n    {\n        col *= vec3(0.8, 0.0, 0.0);\n    }\n    \n    //col = vec3(heart);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12788, "src": "https://soundcloud.com/ahmed-gado-1/sad-piano-alone-in-the-dark", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 20576, "src": "https://soundcloud.com/daklakwarriors/sleeping-sound-rain-and-thunder-1-hours", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3Wn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[924, 924, 943, 969, 1141], [1143, 1143, 1162, 1162, 1250], [1251, 1251, 1269, 1269, 1315], [1317, 1317, 1346, 1346, 1381], [1384, 1384, 1419, 1419, 2571], [2573, 2573, 2610, 2610, 2886], [2888, 2888, 2948, 2948, 3167], [3169, 3169, 3226, 3226, 6363]], "test": "untested"}
{"id": "Ndf3Dn", "name": "Digits of Pi", "author": "mla", "description": "First 1024 base-4 digits of pi, computed using the BaileyBorweinPlouffe formula: [url]https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula[/url] and using the code linked there from David H. Bailey,\n\nMouse changes perspective.", "tags": ["pi", "digits"], "likes": 7, "viewed": 458, "published": 3, "date": "1615755971", "time_retrieved": "2024-07-30T19:32:30.768037", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Digits of pi, in base 4. mla, 2021\n////////////////////////////////////////////////////////////////////////////////\n// A straight port of David H. Bailey's code at:\n// http://www.experimentalmath.info/bbp-codes/\n// Uses 32-bit floats which severely reduces the number of digits\n// that can be generated, but still good for up to 512 hex digits.\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  return p;\n}\n\nvec3 color(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(0,1,0);\n  if (i == 2) return vec3(0,0,1);\n  if (i == 3) return vec3(1,1,0);\n  return vec3(1,0,1);\n}\n\nvec3 image(vec2 uv ) {\n  uv = 0.5*(uv+1.0);\n  uv *= vec2(16,32);\n  int d = int(texelFetch(iChannel0,ivec2(uv),0).x);\n  vec3 col = fract(uv.x) > 0.5 ? color(d%4) : color(d/4);\n  uv.x *= 2.0;\n  uv = fract(uv);\n  uv = min(uv,1.0-uv);\n  col *= smoothstep(0.0,0.1,min(uv.x,uv.y));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 r = vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,2);\n    r.y = -r.y;\n    vec3 p = vec3(0,0,-2);\n    p = transform(p);\n    r = transform(r);\n    r = normalize(r);\n    // (p+kr).z = 0 => kr.z = -p.z\n    float k = -p.z/r.z;\n    fragColor = vec4(0);\n    vec2 uv = p.xy+k*r.xy;\n    if (abs(uv.x) > 1.0) return;\n    if (abs(uv.y) > 1.0) return;\n    fragColor = vec4(image(uv),1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////////////////////////////////\n// Digits of pi, in base 4. mla, 2021\n////////////////////////////////////////////////////////////////////////////////\n// A straight port of David H. Bailey's code at:\n// http://www.experimentalmath.info/bbp-codes/\n// Uses 32-bit floats which severely reduced the number of digits\n// that can be generated, but it's good for up to 512 hex digits.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat tp[] = float[]( 1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0,512.0,1024.0 );\nconst int ntp = tp.length();\n\n/*  expm = 16^p mod ak.  This routine uses the left-to-right binary \n    exponentiation scheme. */\n\nfloat expm (float p, float ak) {\n  int i, j;\n  float p1, pt, r;\n  if (ak == 1.0) return 0.;\n\n  /*  Find the greatest power of two less than or equal to p. */\n  for (i = 0; i < ntp; i++) if (tp[i] > p) break;\n\n  pt = tp[i-1];\n  p1 = p;\n  r = 1.;\n\n  /*  Perform binary exponentiation algorithm modulo ak. */\n\n  for (j = 1; j <= i; j++){\n    if (p1 >= pt){\n      r = 16. * r;\n      r = r - floor(r / ak) * ak;\n      p1 = p1 - pt;\n    }\n    pt = 0.5 * pt;\n    if (pt >= 1.){\n      r = r * r;\n      r = r - floor(r / ak) * ak;\n    }\n  }\n\n  return r;\n}\n\nfloat series (int m, int id)\n\n/*  This routine evaluates the series  sum_k 16^(id-k)/(8*k+m) \n    using the modular exponentiation technique. */\n\n{\n  float ak, eps, p, s, t;\n  s = 0.;\n\n  /*  Sum the series up to id. */\n  for (int k = 0; k < id; k++){\n    ak = float(8 * k + m);\n    p = float(id - k);\n    t = expm (p, ak);\n    s = s + t / ak;\n    s = fract(s);\n  }\n\n  /*  Compute id term. */\n  ak = float(8 * id + m);\n  t = 1.0 / ak;\n  s = s + t;\n  s = fract(s);\n  return s;\n}\n\nint digit(int id) {\n  float s1 = series (1, id);\n  float s2 = series (4, id);\n  float s3 = series (5, id);\n  float s4 = series (6, id);\n  float pid = 4.0 * s1 - 2.0 * s2 - s3 - s4;\n  pid = fract(pid) + 1.0;\n  pid = abs(pid);\n  return int(16.0 * fract(pid));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  ivec2 ix = ivec2(fragCoord);\n  fragColor = texelFetch(iChannel0,ix,0);\n  if (ix.x >= 16 || ix.y >= 32) return;\n  if (iFrame != 0 && fragColor.a == iResolution.x) return;\n  int id = ix.x+ix.y*16;\n  int d = digit(id);\n  fragColor = vec4(d,0,0,iResolution.x);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndf3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 571, 601, 601, 646], [648, 648, 675, 675, 905], [907, 907, 926, 926, 1086], [1088, 1088, 1110, 1110, 1379], [1381, 1381, 1438, 1438, 1828]], "test": "untested"}
{"id": "fdf3Wr", "name": "2D Path Tracer :)", "author": "aiekick", "description": "2D Path Tracer :)", "tags": ["tracer", "path", "joke"], "likes": 16, "viewed": 519, "published": 3, "date": "1615753677", "time_retrieved": "2024-07-30T19:32:31.545957", "image_code": "const vec3 lightDiffuse = vec3(0.191553,0.267195,0.373984);\nconst vec3 lightSpecular = vec3(0.243903,1,0);\nconst vec3 lightDirection = vec3(0.08232,-0.24085,-0.58841);\nconst float specularPower = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n\t\n\tfloat e = 1.0 / iResolution.y;\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat f = texture(iChannel0, uv).x;\n\tfloat fx = (f-texture(iChannel0, uv + vec2(e,0.0)).x)/e;\n\tfloat fy = (f-texture(iChannel0, uv + vec2(0.0,e)).x)/e;\n\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\t\t\n\tfloat diff = max(dot(vec3(0,0,1), n), 0.0);\n\tfloat spec = pow(max(dot(normalize(lightDirection), \n            reflect(vec3(0,0,1),n)), 0.0), specularPower);\n\t\t\n    fragColor.rgb = lightDiffuse * diff + lightSpecular * spec; \n\tfragColor.rgb *= 1.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 getPath(int f)\n{\n    vec2 p;\n\tfloat fr = float(iFrame - f);\n    float an = fr / 360.0 * 6.28318;\n\tp.x = cos(an) - sin(an + fr * 0.01);\n\tp.y = sin(an + cos(an - fr * 0.01)) * cos(an);\n\tp *= 0.8;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec2 uvc = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tfloat pt = 0.05 / iResolution.x;\n\t\n\tvec2 p = getPath(0);\n\tvec2 lp = getPath(5);\n\t\n    // not remember where i found this line code, but its not mine :)\n\tvec2 a = uvc - lp, b = p - lp;\n\tfloat h = clamp(dot(a,b)/dot(b,b),0.,1.);\n\tvec2 pp = a-b*h;\n\tfloat m = pt / dot(pp, pp);\t// line\n\n\tfragColor = vec4(vec3(m), 1.0) * 0.01 + texture(iChannel0, uv) * 0.99;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 260, 260, 823]], "test": "untested"}
{"id": "NdfGWr", "name": "tunel circular--falla", "author": "jorge2017a1", "description": "tunel circular--falla", "tags": ["tunelcircularfalla"], "likes": 0, "viewed": 272, "published": 3, "date": "1615752213", "time_retrieved": "2024-07-30T19:32:32.510379", "image_code": "//por jorge2017a1-\n// fallo la camara en el giro dentro de cilindros\n//// camera failed to rotate within cylinders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n \nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n\n   \n    float separacion=15.0;\n    float radioA=20.0;\n    float radioB=radioA+separacion;\n    float radioC=radioB+separacion;\n    \n    float alto=10.0;\n    \n    float dc1= sdCylinderXZ(p- vec3(0.0,0.0,0.0), vec2(radioA,alto) );\n    float dc2= sdCylinderXZ(p- vec3(0.0,0.0,0.0), vec2(radioB,alto+.5) );\n    float dc3= sdCylinderXZ(p- vec3(0.0,0.0,0.0), vec2(radioC,alto) );\n    \n    float dif;\n    dif= differenceSDF( dc3,dc2);\n    res =opU3(res, vec3(dc1,-1.0,6)); \n    res =opU3(res, vec3(dif,-1.0,6.0)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        \n        //dO += dS.x*DISTANCE_BIAS;  //caso especial\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nvec2 getSphereUV(in vec3 pos)\n{\n    \n    //vec3(20.0,20.0,25.0)\n    ////vec3 posLocal = pos - SpherePos;\n    vec3 SpherePos=vec3(20.0,20.0,25.0);\n    vec3 posLocal = pos - SpherePos;\n    //vec3 posLocal = pos ;\n    float SphereRadius=20.0;\n    //\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n        float escala=0.125;\n        vec2 r2= getSphereUV( p);\n        \n        float d = mod(floor(r2.x*escala)+floor(r2.y*escala*1.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) )*vec3(1.0,0.2,0.2);\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    float radio=22.0;\n    vec3 ro=vec3(0.0+radio*cos(t),3.0,0.0+radio*sin(t));\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    vec3 rdpos=rd;\n     \n    rd.xz*= rot2D(radians(iTime*10.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n    //col= getSkyColB(rd, uv, vec3(0.0));\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "//modificado por jorge flores p.  -9-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\n\n\n// nabr\n// https://www.shadertoy.com/view/WlSGWw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\nvec2 synthv2( float t)\n{\n// --------- SYNTH\n    int t1=int(t) % 4;\n\tvec2 s = sin(t * mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n   \n\nvec2 synthv3( float pt)\n{\n    float t=mod(pt,10.0);\n// --------- SYNTH\n    int t1=int(t) % 5;\n\tvec2 s = sin(t * mat4x2(3496, 1656, 1696, 1376, 1776, 1456, 1656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n\n\n\nvec2 pt3[10]=vec2[](vec2(.3,.37),vec2(.37,.73),vec2(.39,.76),vec2(.51,.83),\nvec2(.53,.83),vec2(.64,.76),vec2(.66,.74),vec2(.68,.6),vec2(.71,.37),vec2(.29,.37) );\n\nvec2 pt2[29]=vec2[](\nvec2(.55,.37),vec2(.72,.36),vec2(.81,.34),vec2(.86,.34),vec2(.95,.35),vec2(.83,.47),\nvec2(.9,.49),vec2(.95,.52),vec2(.79,.64),vec2(.89,.68),vec2(.75,.72),vec2(.8,.76),\nvec2(.61,.79),vec2(.65,.75),vec2(.66,.73),vec2(.68,.73),vec2(.73,.69),vec2(.74,.64),\nvec2(.74,.58),vec2(.72,.58),vec2(.67,.61),vec2(.68,.56),vec2(.66,.58),vec2(.66,.49),\nvec2(.66,.44),vec2(.64,.48),vec2(.58,.54),vec2(.58,.46),vec2(.54,.37)  );\n\n\n\nvec2 synthv5( float pt)\n{\n    float t=mod(pt,29.0);\n// --------- SYNTH\n    int t1=int(t) % 29;\n    int t2=int(t) % 10;\n    \n    vec2 vfreq1=pt2[int(t1)]*800.0;\n    vec2 vfreq2=pt3[int(t2)]*400.0;\n    \n\tvec2 s = sin(t * vfreq1+vfreq2) - .5;\n    \n\tif(t<15.) // intro\n\t\ts *= sin(s.yx * mod(t, 6.) + 18. * sin(t)*sin(s));\n\telse \n\t\ts *=  sin(s * mod(t, 6.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n\n\nvec2 synthv4( float pt)\n{\n    float t=mod(pt,10.0);\n// --------- SYNTH\n    int t1=int(t) % 10;\n\tvec2 s = sin(t * pt3[int(t)]*500.0) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n\n\nvec2 m(float t)\n{\n\t\n    // --------- SYNTH\n    int t1=int(t) % 4;\n\tvec2 s = sin(t * mat4x2(596, 756, 796, 476, 676, 356, 556, 476)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n    \n    \n    vec2 s2= synthv2( t);\n    float ta1=mod(t,5.);\n    float ta2=mod(t,10.);\n    \n    if (ta1<ta2)\n    s+=s2;\n    else\n    s+=5.0*s2*sin(s2);\n    \n   \n     s+= synthv4(t)*4.0+synthv5( t);\n    \n\t// --------- DRUMS(kick)\n    \n\tfloat tm = mod(t, .5);\n    float tm2 = mod(t, 1.8);\n    \n\tif(t<6.) tm = mod(t, 1.5); // intro\n\tfloat finetune = 1.8;\n    \n   \n    \n\t// kick\n\t\n    float k = (sin(80.0 * exp(-sin(tm * finetune) * 10.0)) * exp(-tm * 10.0));\n\tk *= cos(120.0 * exp(-tm * 2.0));\n    \n    \n    \n    // sub\n\tfloat kovt = (k - sin(tm * 580.) * exp(-tm * 1.5));\n\tkovt *= min(1., tm * 100.) * max(0., .5 - tm);\n\tkovt -= (.25 - asin(kovt * tm * 12.));\n\tk *= min(1., tm * 500.) * max(0., 1. - tm);\n\tk = 1.9 * (kovt + k);\n    \n    \n    \n\t\n    // -------- MASTER\n    \n\treturn (k + .4 * s ) * .25;\n}\n\nvec2 mainSound( in int samp,float time){return m(time);}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 538, 538, 633], [634, 634, 673, 673, 768], [769, 769, 808, 808, 903], [905, 949, 996, 996, 1023], [1025, 1025, 1068, 1068, 1095], [1097, 1097, 1145, 1145, 1173], [1174, 1220, 1241, 1241, 1310], [1311, 1376, 1410, 1410, 1508], [1509, 1509, 1543, 1543, 1635], [1636, 1636, 1670, 1670, 1762], [1763, 1803, 1837, 1837, 1934], [1935, 1975, 2000, 2000, 2785], [2787, 2787, 2852, 2852, 3436], [3438, 3489, 3513, 3513, 3701], [3707, 3707, 3740, 3740, 4594], [4599, 4653, 4689, 4689, 4923], [4924, 5059, 5139, 5139, 5416], [5417, 5458, 5489, 5562, 5915], [5916, 5967, 6014, 6014, 7046], [7100, 7100, 7193, 7193, 7468], [7472, 7472, 7499, 7499, 7609], [7611, 7660, 7717, 7717, 9257]], "test": "untested"}
{"id": "fsfGDn", "name": "mouse events", "author": "FabriceNeyret2", "description": "left circle : show mouse down event\nmiddle circle : show mouse up event \nright circle : show bi-click event\n( just click anywhere )", "tags": ["tuto", "mouseevents", "biclick"], "likes": 10, "viewed": 689, "published": 3, "date": "1615751805", "time_retrieved": "2024-07-30T19:32:33.284309", "image_code": "#define S(v)   smoothstep( 3./R.y, 0., v )\n#define C(x,y) O += S( abs( length(U-vec2(x,y)) - .1 ) )\n#define D(x,y) O += S(      length(U-vec2(x,y)) - .08  )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O;\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    \n    C(-.5,.5);\n    if mouse_down     D(-.5,.5);    // mouse down event \n    C( 0.,.5);\n    if mouse_up       D( 0.,.5);    // mouse up event \n    C( .5,.5);\n    if mouse_biclick  D( .5,.5);    // bi-click event \n    C(-.25,.8);\n    if (iMouse.z>.0)  D(-.25,.8);   // mouse pressed\n    \n    O += T(u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    // --- mouse states management \n\n    if ( U==vec2(.5) ) \n        O = iMouse;                                                 // previous mouse state\n\n    if ( U==vec2(1.5) ) \n        O = vec4( iMouse.w > 0.,                                    // down event\n                  iMouse.z < 0. && T(0).z > 0.,                     // up event\n                  iMouse.w > 0. && iTime -T(1).w < BICLICK_DELAY,   // bi-click-event\n                  T(1).y > 0. ? iTime : T(1).w );                   // time of last up event\n\n  \n    // --- time line visualisation\n    \n    if ( U.x > 2. ) {\n        vec2 R = iResolution.xy;\n        O = T( U + vec2(0,1) );\n        if ( int(U.y) == int(R.y*.6) && abs(U.x/R.x-.5) < .3 ) \n              O = vec4( T(1)[int(3.*(U.x/R.x-.2)/.6)]  );\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0, ivec2(U), 0 )\n\n#define mouse_down     ( T(1).x > 0. ) \n#define mouse_up       ( T(1).y > 0. ) \n#define mouse_biclick  ( T(1).z > 0. ) \n\n#define BICLICK_DELAY   .3", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdf3Wn", "name": "Power Stone (4K)", "author": "dean_the_coder", "description": " Unlocking the 'Power Stone' from Guardians of the Galaxy.", "tags": ["3d", "raymarching", "movie", "cineshader", "gotg"], "likes": 25, "viewed": 9375, "published": 3, "date": "1615742994", "time_retrieved": "2024-07-30T19:32:34.069211", "image_code": "// 'Power Stone (4K)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/fdf3Wn (YouTube: https://youtu.be/jP95Nqi_Qxw)\n//\n// Unlocking the 'Power Stone' from Guardians of the Galaxy.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, Ivan Dianov, and a bunch of others for sharing\n// their knowledge!\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0., T;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define minH(a) if (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tvec2 cs = cos(vec2(a, a - 1.5705));\n\treturn mat2(cs, -cs.y, cs.x);\n}\n\nvec2 polar(vec2 p, float n)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat bx(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdOcta(vec3 p, float s) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * .577;\n}\n\nfloat claws(vec3 p) {\n\tp.yz = polar(p.yz, 3.);\n\n\tp.x = abs(p.x) - .9;\n\tp.y -= 1.;\n\tp.xy *= rot(-.5);\n\tfloat d = max(cap(p, 1.2, .12 * S(p.x + .5)), abs(p.z) - .06);\n\n\tp.xy *= rot(-2.725);\n\tp.x += .1;\n\tp.y -= .05;\n\treturn min(d, max(cap(p, .9, .1 * (1.1 - S(p.x - .2))), abs(p.z) - .04));\n}\n\nHit map(vec3 p) {\n\tp.y -= 2.;\n\n\t// Ground.\n\tHit h = Hit(abs(p.y + 2.), 1);\n\n\tvec3 op = p;\n\n\t// Shell rotations.\n\tfloat t = (5. - clamp(T - 3., 0., 5.)) * 1.25664;\n\tp.yz *= rot((sin(t) + sin(2. * t)) * sign(p.x) * 1.4);\n\tt = max(0., T - 8.);\n\tfloat anim = sat((t - 1.) / 8.);\n\tvec2 shellOpen = S(vec2(anim * 4., anim * 4.5 - 3.)) * .7, // Outer, inner.\n\t\t f = p.x - shellOpen * sign(p.x),\n\t\t gaps = -abs(p.x) - .01 + shellOpen;\n\tp.x = p.x < 0. ? min(0., f.x) : max(0., f.x);\n\n\t// Claws.\n\tfloat x = abs(p.x) - .6,\n\t\t  d = max(dot(vec2(1.5, .6), vec2(length(p.yz), -x)), -x);\n\td = max(d, max(length(p.yz) - .5, 1.2 - abs(p.x)));\n\tminH(Hit(min(d, claws(p)), 3));\n\n\t// Outer shell halves.\n\tfloat s = length(p) - 1.;\n\td = max(min(\n\t\t\t   // Gyroid pattern.\n\t\t\t   length(vec2(s, dot(sin(p * 26.), cos(p.zxy * 26.)) * .03)) - .02,\n\t\t\t   // Shell.\n\t\t\t   abs(s + .08) - .05), gaps.x);\n\n\t// Inner shell halves.\n\tp.x = op.x < 0. ? min(0., f.y) : max(0., f.y);\n\n\tfloat i = mod(floor(atan(-p.y, p.z) * 3.183 + 10.) + 2., 20.),\n\t\t  temp = sat(anim * 4. - 2.) * 20.;\n\tfloat d2 = max(\n\t\tabs(length(p) - .65) - .05, // Shell.\n\t\tgaps.y // Split into two halves.\n\t\t+ .01 + .13 * step(i, temp) * min(temp - i, 1.));\n\n\t// Cut away shell slots.\n\tp.yz = polar(p.yz, 20.);\n\tp.y -= .64;\n\td = min(d, max(d2, -bx(p, vec3(.15, .08, .025))));\n\n\t// Stone.\n\tp = op;\n\tp.yz *= rot(t * .1);\n\tmat2 r = rot(2.5);\n\td2 = 1e7;\n\tfor (i = Z0; i < 4.; i++) {\n\t\tp -= .02;\n\t\tp.xy *= rot(3.7 + i);\n\t\tp.yz *= r;\n\t\td2 = min(d2, sdOcta(p, .3) - .005);\n\t}\n\n\tg += .00008 / (.001 + d2 * d2); // Glow - Stone.\n\tminH(Hit(d2, 4));\n\n\t// Glow - Flux.\n\tp = op;\n\tp.x = abs(p.x);\n\tp.y += cos(p.x + t) * .05;\n\td2 = length(p.yz) - .01;\n\tg += .0005 / (.001 + d2 * d2);\n\n\tminH(Hit(min(d, d2), 2));\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1, i, h;\n\tfor (i = Z0; i < 15.; i++)\n\t{\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 10.) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002); }\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 35, -10) - p),\n\t\t n = N(p, d), c;\n\tfloat gg = g, sp = 1.;\n\n\tif (h.id == 2)\n\t\tc = vec3(.2), sp = 3.;\n\telse if (h.id == 1)\n\t\tc = vec3(.03);\n\telse if (h.id == 3)\n\t\tc = vec3(.6);\n\telse c = vec3(.18, .02, .34);\n\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\n\t// Primary light.\n\tl1 = sat(.1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * shadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n))\n\n\t// Specular.\n\t\t + pow(sat(dot(rd, reflect(ld, n))), 10.) * sp,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\n\t// Combine into final color.\n\tg = gg;\n\treturn mix((l1 * vec3(.43, .29, .52) +\n\t\t\t\tl2 * ao * vec3(2.11, 1.69, 1.48)) * c,\n\t\t\t   vec3(.05),\n\t\t\t   fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s, float mx) {\n\tfloat d = .01, i;\n\tg = 0.;\n\tHit h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t\tif (d > mx)\n\t\t\treturn vec4(0);\n\n\t\tp += h.d * rd; // No hit, so keep marching.\n\t}\n\n\tfloat pulse = mix(1., .3, (sin(T) * .5 + .5) * smoothstep(13., 15., T));\n\treturn vec4(pow(g, pulse) * vec3(.73, .5, .88) + lights(p, rd, d, h), h.id);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tvec4 col = march(p, rd, 100., 50.);\n\tcol.rgb *= fog(p - ro);\n\n\tif (col.w > 1.) {\n\t\trd = reflect(rd, N(p, length(p - ro)));\n\t\tp += rd * .01;\n\t\tcol += mix(.2, .3, col.w - 2.)\n\t\t\t   * march(p, rd, 50., 10.)\n\t\t\t   * fog(ro - p);\n\t}\n\n\treturn max(vec3(0), col.rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 30.);\n\n\t// Camera.\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = vec3(0, 2, 0),\n         ro = mix(vec3(1, 2, -4), vec3(0, 3.5, -3), S(T / 4.)),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         rd = normalize(f + r * uv.x + cross(f, r) * uv.y),\n         col = scene(ro, rd);\n\n#ifdef AA\n\tif (fwidth(col.r) > .03) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++) {\n                vec2 luv = uv + (vec2(dx, dy) - .5) / iResolution.xy;\n\t\t\t\tcol += scene(ro, normalize(f + r * luv.x + cross(f, r) * luv.y));\n            }\n\t\tcol /= 5.;\n\t}\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vig(pow(col, vec3(.45)) * sat(iTime), fc), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 614, 614, 684], [686, 686, 715, 715, 826], [828, 828, 854, 854, 941], [943, 943, 980, 980, 1032], [1034, 1034, 1065, 1065, 1120], [1122, 1122, 1143, 1143, 1411], [1413, 1413, 1430, 1430, 3158], [3160, 3160, 3185, 3185, 3404], [3406, 3406, 3437, 3452, 3630], [3632, 3660, 3695, 3695, 3726], [3728, 3728, 3755, 3755, 3870], [3872, 3872, 3891, 3891, 3924], [3926, 3926, 3972, 3972, 4763], [4765, 4765, 4819, 4819, 5183], [5185, 5185, 5215, 5215, 5492], [5494, 5494, 5539, 5539, 6284]], "test": "untested"}
{"id": "7sl3z7", "name": "otro tunel b", "author": "jorge2017a1", "description": "otro tunel b", "tags": ["otrotunelb"], "likes": 4, "viewed": 276, "published": 3, "date": "1615737412", "time_retrieved": "2024-07-30T19:32:34.850123", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    p= rotate_z(p-vec3(0.0,0.0,0.0), radians(mod(iTime*5.0,360.0)));\n    p= rotate_x(p-vec3(0.0,0.0,0.0), radians(90.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n  \n  \n    p.y =opRep1D(  p.y, 25.0);\n    \n    //pared iqz y der\n    vec3 pA=p;\n    pA.x=abs(pA.x)-15.0;\n    \n    float db1A= sdBox( pA-vec3(0.0,0.0,10.0), vec3(3.0,10.0,5.0) );\n    float db2A= sdBox( pA-vec3(-3.0,0.0,0.0), vec3(3.0,10.0,5.0) );\n    float db3A= sdBox( pA-vec3(0.0,0.0,-10.0), vec3(3.0,10.0,5.0) );\n    \n    \n    vec3 pB=p;\n    pB.z=abs(pB.z);\n    float db1B= sdBox( pB-vec3(-1.0,0.0,20.0), vec3(4.0,10.0,3.0) );\n    float db2B= sdBox( pB-vec3(-10.0,0.0,20.0), vec3(5.0,10.0,5.0) );\n    float db3B= sdBox( pB-vec3(9.0,0.0,18.0), vec3(6.0,10.0,3.0) );\n    \n    \n    res =opU3(res, vec3(db1A,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(db2A,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(db3A,3.0,MATERIAL_NO)); \n    \n    res =opU3(res, vec3(db1B,4.0,MATERIAL_NO)); \n    res =opU3(res, vec3(db2B,5.0,MATERIAL_NO)); \n    res =opU3(res, vec3(db3B,6.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        \n        //dO += dS.x*DISTANCE_BIAS;  //caso especial\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n \n    return colobj;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*20.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,0.0+5.0*sin(iTime),-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sl3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 432, 432, 516], [518, 600, 636, 636, 681], [687, 752, 786, 786, 884], [885, 885, 919, 919, 1011], [1012, 1012, 1046, 1046, 1138], [1180, 1220, 1245, 1245, 2463], [2467, 2467, 2532, 2532, 3116], [3118, 3169, 3193, 3193, 3381], [3386, 3386, 3419, 3419, 4273], [4278, 4332, 4368, 4368, 4602], [4604, 4638, 4718, 4718, 4995], [4996, 5037, 5130, 5130, 5232], [5234, 5283, 5340, 5340, 6671]], "test": "untested"}
{"id": "sdl3RM", "name": "skull", "author": "DEMERCY", "description": "can't afford any drawing software", "tags": ["heoncelived"], "likes": 2, "viewed": 318, "published": 3, "date": "1615730166", "time_retrieved": "2024-07-30T19:32:35.617072", "image_code": "float Rectangle(vec2 uv,vec2 p,float width,float height,float blur){\n   vec2 W = vec2(width,height);\n   vec2 s = smoothstep(W+blur,W-blur,abs(uv-p));\n   return s.x*s.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 5.* ( fragCoord - .5*iResolution.xy ) /iResolution.y;\n    uv.x = abs(uv.x);\n    vec3 col  = vec3(Rectangle(uv,vec2( 0     ,0.075 ),0.27   ,0.22 ,0.01));\n         col -= vec3(Rectangle(uv,vec2( 0     ,-0.2 ),0.13   ,0.13 ,0.01));\n         col -= vec3(Rectangle(uv,vec2( 0.135   ,0.06 ),0.07   ,0.11 ,0.01));\n         col += vec3(Rectangle(uv,vec2( 0.13   ,-0.1 ),0.07   ,0.04,0.01));\n    vec3 col2 = vec3(Rectangle(uv,vec2( 0     ,-0.2 ),0.15   ,0.15 ,0.01));\n         col2-= vec3(Rectangle(uv,vec2( 0.0325,-0.2 ),0.015  ,0.15 ,0.01));\n         col2-= vec3(Rectangle(uv,vec2( 0.1   ,-0.2 ),0.015  ,0.15 ,0.01));\n         col2+= vec3(Rectangle(uv,vec2( 0     ,-0.2 ),0.07  ,0.015 ,0.01));\n         //col2+= vec3(Rectangle(uv,vec2(-0.04  ,-0.32),0.0075 ,0.03 ,0.01));\n    col = max(col,col2);\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 170], [172, 172, 229, 279, 1141]], "test": "untested"}
{"id": "fdl3R7", "name": "Gyroid 128-byte intro", "author": "rrrola", "description": "Just a quick conversion of my DOS intro.\nhttps://www.pouet.net/prod.php?which=88198", "tags": ["gyroid", "128bytes", "x86"], "likes": 12, "viewed": 730, "published": 3, "date": "1615720478", "time_retrieved": "2024-07-30T19:32:36.384022", "image_code": "const float twopi = 4. * asin(1.);       // 6.283\nconst float K = float(0x3d28) / 65536.;  // 0.238\nconst float dirZ = 92. / 256.;           // 0.359\n\n// Estimate the distance to the two parts of the complement of the gyroid surface.\n// Find out which one is the closest.\nfloat gyroid(vec3 p, out int id) {\n  float d = dot(sin(p+vec3(K*twopi)), sin(p.zxy));  // sin(p+1.501) is almost a cos\n  id = int(round(d));\n  return 0.21552 * (1.442695 - abs(d));\n}\n\n// Step along the ray. Return the position of the hit.\nvec3 trace(vec3 pos, vec3 dir, out int id, out int iters) {\n  iters = 23;\n  for (int i=23; i>0; i--) {\n    float d = gyroid(twopi*pos, id);\n    pos += d*dir;\n    if (d < 0.041) break;\n    iters = i-1;\n  }\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.x;  // x:-0.5..0.5 like in the intro\n  uv.y = -uv.y;\n  uv = floor(uv*320.) / 320.;    // simulate 320x200 pixels\n  float t = iTime * 35. / 256.;  // aim for 35 fps, period = 256 frames\n\n  int id, iters;\n  vec3 pos = trace(vec3(K,0.,t), vec3(uv,dirZ), id, iters);\n  int tex = int(4. * fract(pos.x * 16.));\n  float col = float(iters + tex);\n  fragColor = vec4(col/32., id>0? col/64. : 0., 0., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdl3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 272, 306, 306, 454], [456, 511, 570, 570, 731], [733, 733, 785, 785, 1242]], "test": "untested"}
{"id": "fssGR7", "name": "Gooey distance field", "author": "mrange", "description": "License CC0: Gooey distance field visualization\nWas trying to optimize my old Impulse logo but was bored with the simple visualization so played around a bit.\nGooey effect turned out quite nice so I share. Also quite cheap to compute", "tags": ["2d"], "likes": 13, "viewed": 440, "published": 3, "date": "1615718551", "time_retrieved": "2024-07-30T19:32:37.149974", "image_code": "// License CC0: Gooey distance field visualization\n//  Was trying to optimize my old Impulse logo but was bored\n//  with the simple visualization so played around a bit.\n//  Gooey effect turned out quite nice so I share\n//  Also quite cheap to compute\n\n#define RESOLUTION    iResolution\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define TIME          iTime\n#define SCA(a)        vec2(sin(a), cos(a))\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec2 sca0 = SCA(0.0);\n\n// IQ's smooth min\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// IQ's horseshoe\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, \n            c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n           (p.x>0.0)?p.y:l );\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat lettere(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 1.05+off;\n  p -= vec2(0.5, 0.5);\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat letterI(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 0.25+off;\n  p -= vec2(0.125, 0.75);\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterl(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 0.2+off;\n  p -= vec2(0.10, 0.58);\n  return box(p, vec2(0.1, 0.58));\n}\n\nfloat letterm(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 2.2+off;\n  p -= vec2(1.1, 0.5);\n  p.y = -p.y;\n  p.x = abs(p.x);\n  p -= vec2(0.5, 0.0);\n  float d = horseshoe(p, sca0, 0.5, vec2(0.5, 0.1));\n  return d;\n}\n\nfloat letterp(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 1.05+off;\n  p -= vec2(0.55, 0.5);\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = abs(circle(p, 0.4)) - 0.1;\n  return min(b, c);\n}\n\nfloat letters(inout vec2 pp, float off) {\n  const mat2 rots1 = ROT(-PI/6.0-PI/2.0);\n  const mat2 rots2 = ROT(PI);\n  vec2 p = pp;\n  pp.x -= 0.875+off;\n  p -= vec2(0.435, 0.5);\n  p *= rots1;\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  p *= rots2;\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat letteru(inout vec2 pp, float off) {\n  vec2 p = pp;\n  pp.x -= 1.2+off;\n  p -= vec2(0.6, 0.475);\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.4, 0.1));\n}\n\nfloat impulse(vec2 p, float off) {\n  p += vec2(3.385+3.0*off, 0.5);\n  \n  float d = 1E6;\n  d = min(d, letterI(p, off));\n  d = min(d, letterm(p, off));\n  d = min(d, letterp(p, off));\n  d = min(d, letteru(p, off));\n  d = min(d, letterl(p, off));\n  d = min(d, letters(p, off));\n  d = min(d, lettere(p, off));\n\n  return d;\n}\n\nfloat df(vec2 p, float tm) {\n  const float z = 0.3;\n  p *= ROT(0.25*sin(tm));\n  float di = impulse(p/z, 0.275)*z;\n  float dy = p.y;\n  dy = abs(dy);\n  dy -= 0.04;\n  dy = abs(dy) - 0.02;\n  \n  float d = di;  \n  d = pmax(d, -dy, 0.0125);\n  return d;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 sp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  float tm = TIME;\n  float d = df(p, tm);\n  \n  // Compute the \"gooey\" time. This will distort the distance field timewise \n  //  based on the distance from the surface\n  float gtm = tm-max(d, 0.0)*1.25;\n  float gd = df(p, gtm);\n\n  vec3 col = vec3(0.0);\n  const float per = 0.18;\n  gd -= per*0.625;\n  float nd = mod1(gd, per);\n  float h = fract(nd*per+0.6);\n  float s = 0.5*(1.0-0.5*tanh(0.5*dot(sp, sp)));\n  float v = 1.0-abs(gd/per);\n\n  col = hsv2rgb(vec3(h, s, v));\n  col = mix(col, pow(col, vec3(0.66)), smoothstep(-aa, aa, -d));\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssGR7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[513, 532, 571, 571, 660], [662, 662, 701, 701, 730], [732, 732, 763, 763, 789], [791, 803, 830, 830, 906], [908, 926, 976, 976, 1219], [1221, 1268, 1290, 1290, 1459], [1461, 1493, 1532, 1532, 1657], [1659, 1659, 1700, 1700, 1836], [1838, 1838, 1879, 1879, 1978], [1980, 1980, 2021, 2021, 2116], [2118, 2118, 2159, 2159, 2338], [2340, 2340, 2381, 2381, 2559], [2561, 2561, 2602, 2602, 2962], [2964, 2964, 3005, 3005, 3135], [3137, 3137, 3171, 3171, 3456], [3458, 3458, 3486, 3486, 3705], [3707, 3707, 3750, 3750, 4002], [4004, 4004, 4059, 4059, 4800]], "test": "ok"}
{"id": "Nds3zN", "name": "Pi Island (Pi Day 2021)", "author": "Rowsej", "description": "A raycasted island in the shape of !\nHuge credits to IQ for lots of functions.\nMade for Pi Day 2021.", "tags": ["pi", "piday", "piday2021"], "likes": 3, "viewed": 294, "published": 3, "date": "1615713424", "time_retrieved": "2024-07-30T19:32:37.926897", "image_code": "/*\n\n Island\nBy Rowsej\nBEEG credits to IQ - I used five of his functions in this code!\n(Oh yes, and he made this website, so...)\n\nIt has a step size of 0.1, but each time it hits, it takes a step\nbackwards and then lowers the step size so it's more accurate\nuntil the step size is SMOL.\n\n*/\n\n#define PI 3.14159\n#define ROTATION (iTime * 32.)\n\n#define MAX_RAY_DIS 6.\n#define STEP_SIZE .1\n\n// Looks good but makes it look like plastic!\n#define SPECULARITY false\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang * PI / 180.);\n    float s = sin(ang * PI / 180.);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\n\n// Credit to IQ for this function:\nfloat sdSegment(vec2 a, vec2 b, vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n// And this polynomial-based smooth-minimum function:\nfloat sMin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n// Oh, and these noise-related functions (https://www.shadertoy.com/view/lsf3WH):\nfloat hash(vec2 p) {\n    p = 50. * fract(p * .3183099 + vec2(.71, .113));\n    return -1. + 2. * fract(p.x * p.y * (p.x + p.y));\n}\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(\n        mix(hash(i + vec2(0.)), hash(i + vec2(1., 0.)), u.x),\n        mix(hash(i + vec2(0., 1.)), hash(i + vec2(1., 1.)), u.x),\n    u.y);\n}\n\nvoid add(inout float a, float b) {\n    a = sMin(a, b, .03);\n}\nvoid addS(inout float d, vec2 a, vec2 b, vec2 p) {\n    add(d, sdSegment(a, b, p));\n}\n\nfloat sdPi(vec2 p) {\n    // The top\n    float d = sdSegment(vec2(-1., .8), vec2(-.8, 1.), p);\n    addS(d, vec2(-.8, 1.), vec2(1.), p);\n    // The left leg\n    addS(d, vec2(-.3, 1.), vec2(-.4, -.5), p);\n    addS(d, vec2(-.4, -.5), vec2(-.6, -.7), p);\n    // The right leg\n    addS(d, vec2(.4, 1.), vec2(.5, -.5), p);\n    addS(d, vec2(.5, -.5), vec2(.8, -.7), p);\n    d -= .25;\n    return d;\n}\nfloat heightmap(vec2 p) {\n    float n = -sdPi(p);\n    n = sin(clamp(n, -.2, .2) * (90. / .2) * PI / 180.) * .1;\n    n += noise(p * 4.) * .03 * mix(1., .2, clamp(n / -.1, 0., 1.));\n    return n;\n}\n// And this is IQ's as well:\nvec3 getNormal(vec2 p) {\n    float eps = 0.01;\n    vec2 h = vec2(eps, 0.);\n    return normalize(vec3(\n        heightmap(p - h.xy) - heightmap(p + h.xy),\n        2. * h.x,\n        heightmap(p - h.yx) - heightmap(p + h.yx)\n    ));\n}\nvec3 bg(vec3 rd) {\n    return mix(vec3(.65, .65, .9), vec3(.55, .55, 1.), rd.y);\n}\nvec3 shading(float h) {\n    vec3 y = vec3(1., 1., 0.);\n    vec3 b = vec3(.2, .95, 1.);\n    vec3 g = vec3(0., 1., 0.);\n    vec3 g2 = vec3(0., .7, 0.);\n    if(h < 0.) {\n        return mix(y, b, clamp(-h * 10. + .1, 0., 1.));\n    } else if(h < .02) {\n        return y;\n    } else if(h < .06) {\n        return mix(y, g, clamp((h - .02) / .04, 0., 1.));\n    } else if(h < .08) {\n        return mix(g, g2, clamp((h - .06) / .02, 0., 1.));\n    } else {\n        return g2;\n    }\n}\nvec3 getCol(vec2 p) {\n    vec3 ro = vec3(0., 1., -1.25);\n    ro.xz = rotate(ro.xz, ROTATION);\n    vec3 rd = normalize(vec3(p, 1.));\n    rd.yz = rotate(rd.yz, 37.5);\n    rd.xz = rotate(rd.xz, ROTATION);\n    float s = STEP_SIZE;\n    for(float t = 0.; t < MAX_RAY_DIS; t += s) {\n        vec3 p = ro + rd * t;\n        float d = heightmap(p.xz);\n        if(p.y < d) {\n            if(STEP_SIZE / s > 100.) {\n                vec3 col = shading((p.y + d) / 2.);\n                vec3 n = getNormal(p.xz);\n                vec3 l = normalize(vec3(2., 2., -2.) - p);\n                float d = clamp(dot(n, l), .3, 1.);\n                vec3 final;\n                if(SPECULARITY) {\n                    float s = clamp(pow(dot(n, normalize(l - rd)), 256.), 0., 1.);\n                    final = col * d + vec3(1.) * s;\n                } else {\n                    final = col * d;\n                }\n                float fog = t / MAX_RAY_DIS;\n                vec3 fogCol = bg(rd);\n                return mix(final, fogCol, fog);\n            } else {\n                t -= s;\n                s /= 10.;\n            }\n        }\n    }\n    return bg(rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y) / 1.5;\n    vec2 coords = fragCoord / mind * 2. - 1.;\n    coords.x -= (iResolution.x - mind) / mind;\n    coords.y -= (iResolution.y - mind) / mind;\n    vec3 col = getCol(coords);\n    fragColor = vec4(mix(vec3(0.), col, iTime > 0.? min(iTime, 1.) : 1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 494, 494, 623], [625, 660, 701, 701, 824], [825, 879, 918, 918, 1016], [1017, 1099, 1119, 1119, 1228], [1229, 1229, 1250, 1250, 1488], [1490, 1490, 1524, 1524, 1551], [1552, 1552, 1602, 1602, 1636], [1638, 1638, 1658, 1673, 2029], [2030, 2030, 2055, 2055, 2225], [2226, 2255, 2279, 2279, 2485], [2486, 2486, 2504, 2504, 2568], [2569, 2569, 2592, 2592, 3041], [3042, 3042, 3063, 3063, 4178], [4180, 4180, 4235, 4235, 4545]], "test": "untested"}
{"id": "Nds3RM", "name": "10PRINT", "author": "oneshade", "description": "Canl it get shorter?", "tags": ["random", "random", "maze", "procgen", "codegolf", "10print"], "likes": 4, "viewed": 242, "published": 3, "date": "1615705269", "time_retrieved": "2024-07-30T19:32:38.696838", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy, p = (u * 2. - r) / r.y * 5., c = floor(p), l = p - c - .5;\n    o = o - o + smoothstep(15. / r.y, 0., abs(l.x * sign(fract(57. * cos(dot(c, vec2(99., 9.7)))) - .5) + l.y));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 239]], "test": "untested"}
{"id": "7dX3z7", "name": "Colors!", "author": "wyatt", "description": "Iterating on an idea... how can you track exactly how much stuff enters a cell? ", "tags": ["fluid", "automata"], "likes": 12, "viewed": 570, "published": 3, "date": "1615687669", "time_retrieved": "2024-07-30T19:32:39.500689", "image_code": "// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = c*min(f.w,1.3);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        Q.xy -= 0.05*a.w*(a.w-.9)*u;  \n    }\n    Q.xy -= 4e-4*(U-0.5*R)/(1.+length(U-0.5*R));\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0.,.5);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n    if (Q.w>2.) Q.w = 2.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-Q.w*q.w,0.);\n       float k = .5+.5*max(1.-Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Qb.xyz*wa+qb.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (iFrame<1)\n        Q = vec4(U/R,1.-(U.x+U.y)/R.x,1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsl3z4", "name": "March 12, 2021", "author": "TheNosiriN", "description": "I looked at my window and thought of this...\nBut it took a long 2 days to make!!", "tags": ["volumetric", "window", "lightshaft", "room", "saturday"], "likes": 29, "viewed": 704, "published": 3, "date": "1615686564", "time_retrieved": "2024-07-30T19:32:40.382331", "image_code": "//Made by: TheNosiriN\n//Wanted to make this textureless but it didn't work out\n\n\n#define TIME (iTime)\n#define R (iResolution.xy)\n#define sinm(x) (sin(x)*.5+.5)\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define hash21(p) (fract(sin(dot(p, p+5373.836))*9272.8363) *2.0-1.0)\n\nconst vec3 light = normalize(vec3(0,0,1));\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\nvec3 getSkyCol(vec3 dir){\n    return mix(vec3(1.000,0.788,0.133), vec3(0.529,0.808,0.922), pow(dir.y, 0.4));\n}\n\n\nvec3 window(vec3 eye, vec3 dir){\n    \n    float d, i; vec2 ind;\n    for (; i<100. && d < 100.; i++){\n       vec3 p = eye + dir * d;\n       \n       float c = max(abs(p.x)-3.5, abs(p.y)-2.5);\n       ind.x = min(abs(p.z)-0.4, max(-p.x+5.0, -p.z));\n       ind.x = min(ind.x, max(c-0.4, abs(p.z)-0.6 ));\n       ind.x = min(ind.x, max(c-0.5, abs(p.z)-0.5 ));\n       \n       //light shaft bug\n       ind.x = min(ind.x, c+mix(0.05, 0.3, saturate(\n           pow(abs(p.z)+sin(p.x*40.0-TIME)+sin(p.y*40.0+TIME)+sin(TIME*0.5)*4.0, 2.0)/50.0 )\n       ));\n       ind.x = max(ind.x, -c);\n       //\n       \n       vec2 f = vec2(max(c, -c-0.2), 0);\n       \n       c = max(abs(p.x+1.75)-1.7, abs(p.y)-3.5);\n       f.x = min(f.x, c);\n       \n       ind = mind(ind, maxd(f, vec2(abs(p.z)-0.1, 0)));\n       c = max(c+0.2, abs(p.y)-2.2);\n       ind.y = maxd(vec2(ind.x,1), vec2(c, 0)).y;\n       //ind.x = max(ind.x, -c);\n       \n       //wires\n       /*p.y -= 3.0;\n       p.z += 20.0;\n       p.y = mod(p.y+2.5/2.0, 2.5)-2.5/2.0;\n       float cy = length(p.yz)-0.05;\n       \n       p.z += 30.0;\n       p.y = mod(p.y+1.5, 3.0)-1.5;\n       cy = min(cy, length(p.yz)-0.05);\n       \n       ind.x = min(ind.x, cy);*/\n       \n       \n       if (abs(ind.x) < 0.0001)break;\n       d += ind.x;\n    }\n    return vec3(d, ind.y, i/100.0);\n}\n\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(\n        mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n        mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n    u.y);\n}\nfloat fbm(vec2 p){\n    float f;\n    f  = 0.5000*noise(p); p = M2*p*2.02 + TIME*0.1;\n    f += 0.2500*noise(p); p = M2*p*2.03 + TIME*0.1;\n    f += 0.1250*noise(p);\n    return f;\n}\nfloat skyshape(vec3 p)\n{\n    float tex = textureLod(iChannel0, sin(p.xz*0.05)*2.0 + p.zx*0.1+TIME*0.02, 1.0).r*0.5+0.5;\n    float fn = fbm(p.xz*0.1+TIME*0.01);\n    float shape = abs(p.y-20.0 + fn*2.0)-tex;\n    shape += 0.8 - fn;\n    \n    return shape*0.5;\n    \n}\n\nvec3 darkSky(vec2 uv, vec3 eye, vec3 dir, vec3 col){\n    \n    vec3 sum;\n    float vol, i, d;\n    for (; i<100.0 && d<130.0; i++){\n        float dt = max(0.05,0.02*d/100.); //umm...\n        \n        vec3 p = eye + dir * d + hash21(uv)*0.02;\n        \n        float shape = skyshape(p);\n        \n        if (shape > 0.01){\n            d += shape;\n        }else{\n            vol += min(-shape, 0.01);\n            float diff = saturate(shape - skyshape(p+light*0.3));\n            sum += mix(vec3(0.529,0.808,0.922), vec3(1.000,0.788,0.133), diff*0.5+0.5) * vol;\n            d += dt;\n        }\n        if (vol >= 1.0)break;\n    }\n    sum /= 50.;\n    \n\n    return mix(sum, col+sum, i/100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-R*0.5)/R.y;\n    \n    float l = sinm(TIME*0.5)*0.4;\n    vec2 m = (iMouse.xy-R*0.5)/R.y * 0.2;\n    vec3 eye = vec3(-7, -7, 20),\n    f = normalize(vec3(1.2+m.x, 0.3 + l + m.y, 0) - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -3.5)), 0)\n    ).xyz;\n    \n    \n    vec3 col;\n    vec3 sky = getSkyCol(dir);\n    \n    vec3 dist = window(eye, dir);\n    \n    if (dist.x >= 100.0){\n        col = darkSky(uv, eye, dir, sky);\n    }else{\n        if (dist.y == 1.0){ col = darkSky(uv, eye, dir, sky) * 0.8; }\n        col += (1.0-dist.x/100.0) * 0.2;\n        col = mix(col, pow(sky,vec3(0.5))*0.6, dist.z+hash21(dir.xy)*0.025);\n    }\n    \n    \n    uv = fragCoord.xy/R;\n    col *= 0.3 + 0.8*pow(32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2);\n    \n    col *= smoothstep(0.1, 1.0, col);\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26152, "src": "https://soundcloud.com/bluntshelterrecords/typeraw-scandinavian-vibes-feat-jhas", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 428, 453, 453, 538], [541, 541, 573, 573, 1847], [1850, 1850, 1871, 1871, 2123], [2124, 2124, 2142, 2142, 2301], [2302, 2302, 2326, 2326, 2564], [2566, 2566, 2618, 2618, 3251], [3253, 3253, 3310, 3310, 4280]], "test": "untested"}
{"id": "sdXGz7", "name": "Polygon Clipping Algorithm", "author": "oneshade", "description": "Simple polygon clipping algorithm. Drag with the mouse to set the clipping boundary.", "tags": ["triangle", "geometry", "polygon", "algorithm", "clipping"], "likes": 12, "viewed": 304, "published": 3, "date": "1615683290", "time_retrieved": "2024-07-30T19:32:41.256993", "image_code": "/*\nSimple polygon clipping algorithm. It works for nonconvex and irregular polygons\nas well and can generalize to any number of dimensions.\nClipping the Utah teapot because why not: https://repl.it/@hathnoname/Polygon-Clipping#main.py\n*/\n\n// Drawing utilities\nvoid drawPoint(inout vec3 pixel, in float unit, in vec2 p, in vec2 pos, in float size, in vec3 color) {\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, length(p - pos) - size));\n}\n\nvoid drawLine(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in float thickness, in vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    float d = length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - thickness;\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, d));\n}\n\nvoid drawTriangle(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec3 color) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    // Triangle subareas\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    pixel = mix(pixel, color, smoothstep(1.0 + unit, 1.0 - unit, (bcp + cap + abp) / abc) * 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    // Previous and current mouse positions\n    vec2 pMouse, mouse;\n    if (iMouse.z > 0.0) {\n        pMouse = (abs(iMouse.zw) - center) / iResolution.y;\n        mouse = (iMouse.xy - center) / iResolution.y;\n    }\n\n    else {\n        float c = cos(iTime), s = sin(iTime);\n        pMouse = vec2(c, c * s) * 0.5;\n        mouse = vec2(s * s - c * c, -s) + pMouse;\n    }\n\n    // Normalized screen coordinates, pixel size, and pixel color\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Triangle vertices\n    vec2 a = vec2(-0.5, -0.3);\n    vec2 b = vec2(0.3, -0.2);\n    vec2 c = vec2(0.0, 0.25);\n\n    // Draw edges\n    drawLine(color, unit, uv, a, b, 0.01, vec3(0.0, 1.0, 0.0));\n    drawLine(color, unit, uv, b, c, 0.01, vec3(0.0, 1.0, 0.0));\n    drawLine(color, unit, uv, c, a, 0.01, vec3(0.0, 1.0, 0.0));\n\n    // Begin clipping\n    vec2 clipPos = pMouse;                      // Position of the clipping boundary\n    vec2 clipDir = mouse - pMouse;              // Side of the clipping boundary that gets kept\n\n    vec2[] poly = vec2[](a, b, c);   // Original polygon\n    vec2[poly.length() + 1] clipped; // Clipped polygon\n    int nClip = 0;                   // Number of vertices in the clipped polygon\n\n    for (int v=1; v < poly.length() + 1; v++) {\n        vec2 v1 = poly[v - 1], v2 = poly[v % poly.length()];\n        bool clipV1 = dot(v1 - clipPos, clipDir) < 0.0;\n        bool clipV2 = dot(v2 - clipPos, clipDir) < 0.0;\n        if (!clipV1) {\n            clipped[nClip] = v1;\n            nClip++;\n        }\n\n        if (clipV1 != clipV2) {\n            float dot1 = dot(v1, clipDir), dot2 = dot(v2, clipDir);\n            vec2 clip = v1 + (v2 - v1) * (dot(clipPos, clipDir) - dot1) / (dot2 - dot1);\n\n            // Add to clipped vertices\n            clipped[nClip] = clip;\n            nClip++;\n        }\n    }\n    // End clipping\n\n    // Draw simple convex triangulation\n    for (int v=1; v < nClip - 1; v++) {\n        vec2 v1 = clipped[0], v2 = clipped[v], v3 = clipped[v + 1];\n        drawTriangle(color, unit, uv, v1, v2, v3, vec3(0.0, 1.0, 0.0));\n    }\n\n    // Draw clipping area and clipping boundary\n    float db = dot(uv - clipPos, normalize(clipDir));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, db) * 0.5);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(db) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 260, 363, 363, 443], [445, 445, 561, 561, 741], [743, 743, 854, 854, 1263]], "test": "untested"}
{"id": "tlGBW3", "name": "Celeste", "author": "manu210404", "description": "*summit soundtrack intensifies*", "tags": ["polygon", "celeste"], "likes": 26, "viewed": 605, "published": 3, "date": "1615678926", "time_retrieved": "2024-07-30T19:32:42.281254", "image_code": "//      ____    ____    _       ____    _____   ______   ____\n//     / ___/\\ / ___/\\ / /\\    / ___/\\ / ____/\\/_   __/\\/ ___/\\\n//    / /\\__\\// /\\__\\// / /   / /\\__\\// /__ _\\/\\_/ /\\_\\/ /\\__\\/\n//   / / /   / __/\\  / / /   / __/\\  /__   /\\   / / / / __/\\\n//  / /__   / /__\\/ / /__   / /__\\/ _\\_ / / /  / / / / /__\\/\n// /_____/\\/_____/\\/_____/\\/_____/\\/_____/ /  /_/ / /_____/\\\n// \\_____\\/\\_____\\/\\_____\\/\\_____\\/\\_____\\/   \\_\\/  \\_____\\/\n\n#define M_COLOR_BASE vec3(0.608, 0.549, 0.824)\n#define M_COLOR_HIGH_D vec3(0.588, 0.773, 0.882)\n#define M_COLOR_HIGH_L vec3(0.502, 0.922, 0.953)\n#define M_COLOR_SHADE vec3(0.498, 0.459, 0.773)\n\n\n// falling snow by me - https://www.shadertoy.com/view/ssfGzM\nfloat snow(in vec2 p) {\n    float t = iTime;\n    float l = 0.;\n    for (float i = 0.; i < 70.; i += 1.) {\n        float z = hash(i*0.1),\n              depth = mix(200.,10.,z*z),\n              invDepth = 1./depth,\n              wave = sin(t*1.+i);\n        vec2 pos = (fract(vec2(hash(i*.2), hash(i*.3)) + (50.*iMouse.xy/iResolution.y - t*vec2(50.,10.)+vec2(0.,wave*10.))/vec2(4.0,2.2)*invDepth)-.5)*vec2(4.0,2.2);\n        l += sqrt(depth/150.) * smoothstep(-0.01, 0.01, invDepth-length(p-pos)) * (1. - l);\n    }\n    return l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // mouse position\n    vec2 m = vec2(0.5);\n    if (iMouse.xy != vec2(0.0)){\n        m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    }\n    \n    // some resizing and offsetting of the uv-cordinates\n    vec2 pm = p*1.33 + vec2(0.0, 0.33) - m * 0.15;\n    \n\n    \n    \n    // ================ outline of the mountain ================ //\n    float od = sdOutline(pm);\n    \n    \n    // ================ dark highlights ================ // \n    float h1d = sdHighlights_d(pm);\n    \n    \n    // ================ light highlights ================ //\n    float h2d = sdHighlights_l(pm);\n    \n    \n    // ================ shade ================ //\n    float sd = sdShade(pm);\n    \n    \n    // antialiasing\n    float eps = 1./iResolution.y*2.0;\n    \n    float mask_outline = smoothstep(eps,-eps,od);\n    float mask_highlight_d = smoothstep(eps,-eps,h1d);\n    float mask_highlight_l = smoothstep(eps,-eps,h2d);\n    float mask_shade = smoothstep(eps,-eps,sd);\n    \n    vec3 col = M_COLOR_BASE;\n    col = mix(col, M_COLOR_HIGH_D, mask_highlight_d);\n    col = mix(col, M_COLOR_HIGH_L, mask_highlight_l);\n    col = mix(col, M_COLOR_SHADE, mask_shade);\n    \n    // makes the top of the mountain lighter\n    col += vec3(1.-length(pm-o00))*0.3*(1.-col);\n    col *= mask_outline;\n    \n    // red to blue from center\n    col += pow(mix(pow(vec3(0.196,0.102,0.102), vec3(2.2)), pow(vec3(0.098,0.078,0.161), vec3(2.2)),smoothstep(0.0,2.0, vec3(length(p.xy))))*(1.-mask_outline), vec3(0.4545));\n    \n    // falling snow\n    col += snow(p)*(1.-col);\n    \n    //vec2 debug = o17;\n    //col = mix(col, vec3(1,0,0), smoothstep(0.02,0.015,length(pm-debug)));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// hash function from \"Hash without sine\" by Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n\n// Polygon Distance by iq - https://www.shadertoy.com/view/wdBXRW\n/*\nconst int N = 5;\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n*/\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly03 POLY(3)\nfloat sdPoly04 POLY(4)\nfloat sdPoly05 POLY(5)\nfloat sdPoly06 POLY(6)\nfloat sdPoly07 POLY(7)\nfloat sdPoly08 POLY(8)\nfloat sdPoly10 POLY(10)\nfloat sdPoly14 POLY(14)\nfloat sdPoly29 POLY(29)\nfloat sdPoly32 POLY(32)\n\n\n\n// ================ outline of the mountain ================ //\nconst vec2 o00 = vec2(-0.022480, 0.971095), o01 = vec2(-0.007226, 0.959052), o02 = vec2( 0.099558, 0.806503),\n           o03 = vec2( 0.190285, 0.509433), o04 = vec2( 0.295463, 0.360899), o05 = vec2( 0.354877, 0.409875),\n           o06 = vec2( 0.380570, 0.421918), o07 = vec2( 0.572460, 0.105580), o08 = vec2( 0.704937,-0.027699),\n           o09 = vec2( 0.764351, 0.019670), o10 = vec2( 0.789241, 0.003613), o11 = vec2( 0.839020,-0.091930),\n           o12 = vec2( 0.980329,-0.290244), o13 = vec2( 1.142513,-0.458851), o14 = vec2( 0.654355,-0.459654),\n           o15 = vec2( 0.607788,-0.448414), o16 = vec2( 0.290646,-0.457246), o17 = vec2( 0.250501,-0.448414),\n           o18 = vec2(-0.048976,-0.458851), o19 = vec2(-0.130068,-0.443596), o20 = vec2(-0.237655,-0.458851),\n           o21 = vec2(-0.340425,-0.437976), o22 = vec2(-1.169008,-0.456443), o23 = vec2(-0.961862,-0.210758),\n           o24 = vec2(-0.924929,-0.152147), o25 = vec2(-0.809313,-0.012444), o26 = vec2(-0.725010,-0.107988),\n           o27 = vec2(-0.641509, 0.054997), o28 = vec2(-0.592533, 0.006824), o29 = vec2(-0.328382, 0.363307),\n           o30 = vec2(-0.230429, 0.475712), o31 = vec2(-0.157366, 0.698113);\n\n\n\n// ================ dark highlights ================ // \nconst vec2 h1_00 = vec2( 0.067442, 0.690887), h1_01 = vec2(-0.127659, 0.459654), h1_02 = vec2(-0.077077, 0.439582), \n           h1_03 = vec2( 0.115616, 0.303091), h1_04 = vec2(-0.199919, 0.402649), h1_05 = vec2(-0.280208, 0.330389),\n           h1_06 = vec2(-0.268968, 0.173825), h1_07 = vec2(-0.382175, 0.285427), h1_08 = o29, h1_09 = o30, \n           h1_10 = o31, h1_11 = o00, h1_12 = o01, h1_13 = o02;\n\n\n\n// ================ light highlights ================ // \nconst vec2 h2_00 = vec2(-0.085106, 0.536732), h2_01 = vec2(-0.077880, 0.592934), h2_02 = vec2(-0.065034, 0.670814), \n           h2_03 = vec2(-0.085909, 0.804094), h2_04 = o31, h2_05 = o00, h2_06 = o01, h2_07 = o02, h2_08 = h1_00, h2_09 = h1_01,     \n           \n           h3_00 = vec2( 0.421517, 0.352067), h3_01 = vec2( 0.367723, 0.199518), h3_02 = vec2(-0.041750, 0.055800),\n           h3_03 = vec2( 0.254516, 0.289441), h3_04 = o04, h3_05 = o05, h3_06 = o06,\n           \n           h4_00 = vec2( 0.627057, 0.050983), h4_01 = vec2( 0.536330,-0.101565), h4_02 = vec2( 0.081894,-0.140907), \n           h4_03 = vec2( 0.457647,-0.035728), h4_04 = o07,\n           \n           h5_00 = vec2(-0.607788,-0.115214), h5_01 = vec2(-0.653552,-0.075070), h5_02 = vec2(-0.655961,-0.010036),\n           h5_03 = o26, h5_04 = o27, h5_05 = o28,\n           \n           h6_00 = vec2(-0.757125,-0.071055), h6_01 = vec2(-0.749096,-0.156162), h6_02 = vec2(-0.805299,-0.094339), \n           h6_03 = vec2(-0.856684,-0.157767), h6_04 = vec2(-0.859895,-0.079084), h6_05 = o25,\n           \n           h7_00 = vec2(-0.274588, 0.067844), h7_01 = vec2(-0.089120,-0.053392), h7_02 = vec2(-0.385387,-0.207547), \n           h7_03 = vec2(-0.252107,-0.005218),\n           \n           h8_00 = vec2( 0.770774,-0.040545), h8_01 = vec2( 0.750702,-0.171417), h8_02 = o08, h8_03 = o09, h8_04 = o10;\n\n\n\n// ================ shade ================ //\nconst vec2 s1_00 = vec2(-0.984343,-0.323163), s1_01 = vec2(-0.782015,-0.234042), s1_02 = vec2(-0.166198,-0.390606), \n           s1_03 = vec2(-0.203934,-0.201926), s1_04 = vec2(-0.116419,-0.401043), s1_05 = vec2( 0.059413,-0.359293),\n           s1_06 = vec2( 0.240064,-0.347250), s1_07 = vec2( 0.345242,-0.291850), s1_08 = vec2( 0.622240,-0.261340), \n           s1_09 = vec2( 0.469690,-0.336812), s1_10 = vec2( 0.580489,-0.331192), s1_11 = vec2( 0.695303,-0.280610),\n           s1_12 = vec2( 0.711360,-0.231633), s1_13 = vec2( 0.724207,-0.086310), s1_14 = vec2( 0.786029,-0.277398), \n           s1_15 = vec2( 0.915295,-0.300682), s1_16 = o11, s1_17 = o12, s1_18 = o13, s1_19 = o14, s1_20 = o15, s1_21 = o16, \n           s1_22 = o17, s1_23 = o18, s1_24 = o19, s1_25 = o20, s1_26 = o21, s1_27 = o22, s1_28 = o23,\n           \n           s2_00 = h4_03, s2_01 = h4_02, s2_02 = vec2( 0.0,-0.150541), s2_03 = h7_01, s2_04 = vec2(-0.010437,-0.092733),\n           s2_05 = vec2(-0.020875,-0.016459), s2_06 = vec2( 0.032918,-0.105652), s2_07 = vec2( 0.329987,-0.035728),\n           \n           s3_00 = vec2(-0.564431, 0.047771), s3_01 = vec2(-0.530710,-0.132075), s3_02 = o28;\n\n\n\nfloat sdOutline(in vec2 p) {\n    return sdPoly32(p, vec2[](o00,o01,o02,o03,o04,o05,o06,o07,o08,o09,o10,o11,o12,o13,o14,o15,o16,o17,o18,o19,o20,o21,o22,o23,o24,o25,o26,o27,o28,o29,o30,o31));\n}\n\nfloat sdHighlights_d(in vec2 p) {\n    return sdPoly14(p, vec2[](h1_00,h1_01,h1_02,h1_03,h1_04,h1_05,h1_06,h1_07,h1_08,h1_09,h1_10,h1_11,h1_12,h1_13));\n}\n\nfloat sdHighlights_l(in vec2 p) {\n    float h2d = sdPoly10(p, vec2[](h2_00,h2_01,h2_02,h2_03,h2_04,h2_05,h2_06,h2_07,h2_08,h2_09)),\n          h3d = sdPoly07(p, vec2[](h3_00,h3_01,h3_02,h3_03,h3_04,h3_05,h3_06)),\n          h4d = sdPoly05(p, vec2[](h4_00,h4_01,h4_02,h4_03,h4_04)),\n          h5d = sdPoly06(p, vec2[](h5_00,h5_01,h5_02,h5_03,h5_04,h5_05)),\n          h6d = sdPoly06(p, vec2[](h6_00,h6_01,h6_02,h6_03,h6_04,h6_05)),\n          h7d = sdPoly04(p, vec2[](h7_00,h7_01,h7_02,h7_03)),\n          h8d = sdPoly05(p, vec2[](h8_00,h8_01,h8_02,h8_03,h8_04));\n    return min(min(min(min(min(min(h2d,h3d),h4d),h5d),h6d),h7d),h8d);\n}\n\nfloat sdShade(in vec2 p) {\n    float s1d = sdPoly29(p, vec2[](s1_00,s1_01,s1_02,s1_03,s1_04,s1_05,s1_06,s1_07,s1_08,s1_09,s1_10,s1_11,s1_12,s1_13,s1_14,s1_15,s1_16,s1_17,s1_18,s1_19,s1_20,s1_21,s1_22,s1_23,s1_24,s1_25,s1_26,s1_27,s1_28)),\n          s2d = sdPoly08(p, vec2[](s2_00,s2_01,s2_02,s2_03,s2_04,s2_05,s2_06,s2_07)),\n          s3d = sdPoly03(p, vec2[](s3_00,s3_01,s3_02));\n    return min(min(s1d,s2d),s3d);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[630, 692, 715, 715, 1218], [1221, 1221, 1278, 1278, 3015]], "test": "untested"}
{"id": "7sXGRM", "name": "Oneline Checkerboard", "author": "oneshade", "description": "Checkerboard in one line.", "tags": ["checkerboard", "onetweet", "oneline"], "likes": 1, "viewed": 143, "published": 3, "date": "1615664619", "time_retrieved": "2024-07-30T19:32:43.275595", "image_code": "void mainImage(out vec4 o, vec2 u) { o = o - o + mod(dot(floor(u / iResolution.xy * 8.), vec2(1)), 2.); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 105]], "test": "untested"}
{"id": "ssXGRM", "name": "Planets evolution", "author": "foxes", "description": "This is still a blank for a generalized planet generator. It remains only to decorate Will be updated.\n", "tags": ["procedural", "3d", "noise", "perlin", "planet"], "likes": 17, "viewed": 869, "published": 3, "date": "1615664403", "time_retrieved": "2024-07-30T19:32:44.361692", "image_code": "//\n// Panteleymonov A K 2021\n//\n\n//****************** if there are problems with the image change the hash ***********\n\n//#define hash(n) fract(mod(n*n*34.+n,289.)/289.)\n#define hash(n) fract(abs(sin(n))*1399763.5453123)\n//#define hash(n) fract(fract(n*0.31830988618379067153776752674503)*fract(n*0.15915494309189533576888376337251)*265871.1723)\n\nvec2 scroll = vec2(0.);\nint cid = 0;\nfloat cmf = 0.;\n\n//atmosfera colors\nconst vec3 catm01[6] = vec3[6](vec3(1.0,0.3,0.0),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\nconst vec3 catm02[6] = vec3[6](vec3(1.0,.99,.94),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\n\n//cloud colors\nconst vec3 ccl01[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(0.9,0.8,0.6),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\nconst vec3 ccl02[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(1.0,0.9,0.6),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7));\n\n//ground colors\nconst vec3 cps01[6]  = vec3[6](vec3(2.0,0.2,0.0),vec3(.94,.63,0.33),vec3(.94,.68,0.53),vec3(.94,.63,0.33),vec3(.94,.63,0.33),vec3(1.0,1.0,1.0));\nconst vec3 cps02[6]  = vec3[6](vec3(0.02,0.0,.0),vec3(1.0,0.85,.57),vec3(0.95,0.85,.47),vec3(1.0,0.85,.57),vec3(1.0,0.85,.57),vec3(1.0,1.0,1.0));\n\n//water and lava colors\nconst vec3 cwl01[6] = vec3[6](vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(0.1,0.9,0.4), vec3(0.0,0.9,1.0), vec3(0.0,0.7,1.0), vec3(0.0,0.7,1.0));\nconst vec3 cwl02[6] = vec3[6](vec3(1.,1.,0.), vec3(.8,1.,.1), vec3(0.1,0.4,0.2), vec3(0.3,0.0,0.6), vec3(0.2,0.0,0.7), vec3(0.2,0.0,0.7));\n\nvec3 catmF01() { return mix(catm01[cid],catm01[cid+1],cmf); }\nvec3 catmF02() { return mix(catm02[cid],catm02[cid+1],cmf); }\n\nvec3 cclF01() { return mix(ccl01[cid],ccl01[cid+1],cmf); }\nvec3 cclF02() { return mix(ccl02[cid],ccl02[cid+1],cmf); }\n\nvec3 cpsF01() { return mix(cps01[cid],cps01[cid+1],cmf); }\nvec3 cpsF02() { return mix(cps02[cid],cps02[cid+1],cmf); }\n\nvec3 cwlF01() { return mix(cwl01[cid],cwl01[cid+1],cmf); }\nvec3 cwlF02() { return mix(cwl02[cid],cwl02[cid+1],cmf); }\n\nvec4 hash4( vec4 n ) { return hash(n); }\nvec3 hash3( vec3 n ) { return hash(n); }\nvec2 NC0=vec2(1.0,136.0);\nvec3 NC1=vec3(1.0,136.0,31.0);\nfloat seed = 0.0;\n\nvec2 getBL(vec3 pos) { return vec2(atan(pos.x,pos.z),atan(length(pos.xz),pos.y))/3.1415; }\nvec3 setBL(vec2 bl) { bl*=3.1415; return vec3(cos(bl.y)*cos(bl.x),sin(bl.y),cos(bl.y)*sin(bl.x)); }\n\n// Simple 2d interpolated noise for mercator projection, using local seed.\nfloat sphereNoise2Ds(vec2 bl,float scale,float seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    vec4 n= hash4(floor(p)*NC0.x + yc.xyxy +seed);\n    return dot(n, vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z));\n}\n\nvec2 sphereNoise2D2s(vec2 bl,float scale,vec2 seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    p = floor(p)*NC0.x + yc.xyxy;\n    vec4 n1= hash4(p +seed.x);\n    vec4 n2= hash4(p +seed.y);\n    p = vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z);\n    return vec2(dot(n1, p), dot(n2, p));\n}\n\n// Simple 2d interpolated noise for mercator projection, using global seed.\nfloat sphereNoise2D(vec2 bl,float scale) { return sphereNoise2Ds(bl,scale,seed); }\n\n// Simple 2d interpolated noise for mercator projection, using global seed animated.\nfloat sphereNoise2D(vec3 blt,float scale)\n{\n    float z = floor(blt.z)*54.0;\n    float f = fract(blt.z);\n    //f=f*f*(3.0-2.0*f);\n    return dot(sphereNoise2D2s(blt.xy,scale,seed+z+vec2(0.,54.)),vec2(1.-f,f));\n}\n\n// Simple 2d interpolated distortion noise for mercator projection, using global seed.\nfloat sphereNoise2Do(vec2 bl,float scale,float force)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*2.0f,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nfloat sphereNoise2Do2(vec2 bl,float scale,float force, float s)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*s,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nvec2 sphereIntersect(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return vec2(-1.0, -1.0);\n    float d = sqrt(r2-t2);\n    return cd+vec2(- d,d);\n}\n\nfloat sphereIntersectIn(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return -1.0;\n    return cd + sqrt(r2-t2);\n}\n\nvec3 sphereNormal(vec3 pos, vec3 surface)\n{\n    return normalize(surface-pos);\n}\n\nfloat spherePerlin(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,512.0*scale)*0.8+sphereNoise2D(bl,256.0*scale)*0.8\n     +sphereNoise2D(bl,128.0*scale)+sphereNoise2D(bl,64.0*scale)\n     +sphereNoise2D(bl,32.0*scale)+sphereNoise2D(bl,16.0*scale)\n     +sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)*1.2+sphereNoise2D(bl,scale)*1.2)*0.1;\n}\n\nfloat spherePerlinA(vec3 blt,float scale)\n{\n    return (sphereNoise2D(blt,16.0*scale)\n     +sphereNoise2D(blt,8.0*scale)+sphereNoise2D(blt,4.0*scale)\n     +sphereNoise2D(blt,2.0*scale)*1.2+sphereNoise2D(blt,scale)*1.2)*0.2;\n}\n\nfloat spherePerlinHalf(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,16.0*scale)+sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)+sphereNoise2D(bl,scale))*0.2;\n}\n\nfloat spherePerlinHalfs(vec2 bl,float scale, float seed)\n{\n    return (sphereNoise2Ds(bl,16.0*scale,seed)+sphereNoise2Ds(bl,8.0*scale,seed)+sphereNoise2Ds(bl,4.0*scale,seed)\n     +sphereNoise2Ds(bl,2.0*scale,seed)+sphereNoise2Ds(bl,scale,seed))*0.2;\n}\n\nvec2 spherePerlinHalf2s(vec2 bl,float scale, vec2 seed)\n{\n    return (sphereNoise2D2s(bl,16.0*scale,seed)+sphereNoise2D2s(bl,8.0*scale,seed)+sphereNoise2D2s(bl,4.0*scale,seed)\n     +sphereNoise2D2s(bl,2.0*scale,seed)+sphereNoise2D2s(bl,scale,seed))*0.2;\n}\n\n// Perlin distortion noise \nfloat spherePerlinHalfd(vec2 bl,float scale,float force)\n{\n    return (sphereNoise2Do(bl,16.0*scale,force)+sphereNoise2Do(bl,8.0*scale,force)\n     +sphereNoise2Do(bl,4.0*scale,force)\n     +sphereNoise2Do(bl,2.0*scale,force)+sphereNoise2Do(bl,scale,force))*0.2;\n}\n\n// Perlin distortion noise with increasing coefficient\nfloat spherePerlinHalfds(vec2 bl,float scale,float force)\n{\n    return sphereNoise2Do(bl,16.0*scale,force)*0.05\n    +sphereNoise2Do(bl,8.0*scale,force)*0.15+sphereNoise2Do(bl,4.0*scale,force)*0.2\n    +sphereNoise2Do(bl,2.0*scale,force)*0.25+sphereNoise2Do(bl,scale,force)*0.35;\n}\n\nvec3 wind3D(vec3 pos,float rings,float skip)\n{\n    vec3 f = fract(pos)-0.5;\n    vec3 px = floor(pos);\n    float r = length(pos);\n    vec3 wind =vec3(0.);\n\n    for (int z = -0;z<2;z++)\n    for (int y = -0;y<2;y++)\n    for (int x = -0;x<2;x++) {\n        vec3 off = vec3(float(x),float(y),float(z));\n        vec3 xyz = px + off;\n        float p = dot(xyz,NC1);\n        vec3 add = hash(vec3(p,p+30.0,p+23.0));\n        vec3 fxyz = f + add*0.8-off;\n        float ml = clamp(1.0-length(fxyz)*1.5,0.,1.);\n        vec3 wp = normalize(pos - fxyz) * r - pos;\n        float l1 = length(wp);\n        float l2 = 1.-l1;\n        vec3 w = normalize(cross(wp,pos));\n        wind +=w*ml*clamp(0.5-l1,0.,1.)*clamp(1.0-l2*l2*l2,0.,1.);\n    }\n    return wind;\n}\n\nfloat atmosphere(vec3 pos, vec3 atmosSurface, vec3 ray, vec3 lnorm, float planetRadius, float atmosRadius, float atmosDepth)\n{\n    float wall = sqrt(atmosRadius*atmosRadius - planetRadius*planetRadius);\n    float acc = clamp(atmosDepth/wall,0.0,1.0);\n    acc = acc*pow(clamp(dot(lnorm,normalize(atmosSurface-pos)),0.0,1.0),0.4);\n    acc = acc*acc;\n    acc = acc*acc;\n    \n    return acc;\n}\n\nvec3 sphereTexture(vec3 realSurface,vec3 ray, vec3 snorm,vec3 lnorm,float time)\n{\n    seed = 1.0;\n    vec2 bl = getBL(realSurface);\n\n    seed = 2.0;\n    float d = spherePerlinHalfds(bl,8.0,0.5);\n    seed = 5.0;\n    float c = spherePerlin(bl,4.0);//(c1 + c2)*0.5;\n    float canr = clamp(1.0-abs(d-0.4)*10.0,0.0,1.0);\n    float can = clamp(1.0-abs(d-0.5)*10.0,0.0,1.0) * clamp(c*5.0-1.6,0.0,1.0);\n    float can2 = can*can;\n    float can3 = can2*can;\n    float canr3 = canr*canr*canr*canr;\n    \n    float middle = (0.25 - abs(0.25-abs(0.5-bl.y)))*4.;\n    seed = 10.0;\n    float e = spherePerlinHalfds(bl,6.0,0.5);\n    float mc = clamp(e*6.0-2.4, 0.0, 1.0);\n\n    float snow = scroll.x-0.55;\n    snow = (snow*snow*snow*snow*snow+0.5)*40.0-20.3;\n    snow = clamp((snow+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n\n    float waterline = scroll.x-0.5;\n    waterline = clamp((waterline*waterline*waterline+0.5)*14.0-6.5, 0., 1.);\n    float beach = mix(e, e*c*2.6, 0.05) - waterline;\n    float land = clamp(clamp(beach * 200.0, 0., 1.), 0., 1.); //continents\n    land = land - mix(0.,clamp((mix(canr3,canr3*c*2.6,0.1)-1.3+waterline)*10.0, 0.0, 1.0),land*middle); //river\n\n    vec3 water = mix(cwlF02(),cwlF01(),c+mc*0.2);\n\n    float fa = (spherePerlinA(vec3(bl,time),200.0)+spherePerlinA(vec3(bl,time+2.5),200.0))*0.5;\n    \n    float f = mix(1.0-pow(1.0-c*1.7,2.0),c*1.7,0.3);\n    \n    float forest = scroll.x-0.2;\n    forest = clamp(forest*4.0, 0., 1.);\n    forest = clamp((canr+can+forest*2.-2.3+f*0.1+mc*c*0.5)*4.,0.,1.)*clamp((middle-0.5+mc*c*0.4)*8.,0.,1.);//+forest-0.5\n    forest = clamp(forest*2.,0.,1.);\n\n    float ground = scroll.x-0.2;\n    ground = clamp(ground*4.0, 0., 1.);\n    ground = clamp((canr+can+ground*2.-1.8+f*0.1+mc*c*0.5)*2.,0.,1.)*clamp((middle-0.4+mc*c*0.4)*4.,0.,1.);//+forest-0.5\n    ground = clamp(ground*2.,0.,1.);\n    \n    float rock = scroll.x-0.7;\n    rock = clamp((rock+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n    \n    float canl = (can3+fa-0.5);\n    f = f-can3*0.34;\n\n    float light = 1.-clamp(dot(snorm,lnorm),0.0,1.0);\n    light = 1.0-light*light;\n    float ref = clamp(dot(reflect(ray,normalize(snorm+0.6*cross(ray,snorm)*(0.5-fa))),lnorm),0.0,1.0);\n    ref = ref*0.9;\n    \n    vec3 ert = mix(cpsF01(),cpsF02(),f)*f;\n    ert = mix(ert, mix(vec3(1.0,0.5,0.0),vec3(1.0,0.8,0.33),mc), 0.2);\n    vec3 gc = mix(mix(vec3(0.3,0.3,0.0),vec3(0.5,0.5,0.3),e*f*f)*f, mix(vec3(0.3,0.2,0.0),vec3(1.0,0.8,0.33),mc), 0.5);\n    ert = mix(ert,gc, clamp(ground+forest,0.,1.));\n    ert = mix(ert, vec3(0.8)*clamp(f*2.-1.4+c,0.,1.), rock*0.7);\n    ert = clamp(mix(ert, mix(vec3(0.7,0.9,0.0),vec3(0.0,0.1,0.1),c), forest),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    vec3 col = mix(water,ert,land);\n    \n    float l = (1.0-land) * pow(ref,8.0)*(fa+1.0);\n    float wl = clamp((light+pow(ref,6.0)) * (1.0-land) * mix((abs(0.5-fa)*2.0),0.0,0.3),0.0,1.0);\n       \n    vec3 lcolor = l*mix(vec3(1.0),vec3(1.0,0.9,0.8),clamp(dot(ray,lnorm),0.,1.));\n    col = clamp(mix(col*light+lcolor,vec3(1.0),wl*1.0*light),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    \n    vec3 lav = mix(vec3(1.,0.0,0.),mix(cwlF02(),cwlF01(),clamp(abs(0.5-canl)*3.0,0.,1.)),clamp(canl,0.,1.));\n    float lm=clamp(scroll.x*5.0,0.,1.);\n    can3 = mix(mix(can3,can3*can3*can3*can3,lm),0.,lm);\n    col = mix(col*light,lav*2.0,can3);\n\n    vec3 snowc = clamp(mix(mix(vec3(0.1,0.3,0.7),vec3(0.6,0.6,0.6),mc),vec3(1.0,1.0,1.0),f)*f,vec3(0.,0.,0.),vec3(1.,1.,1.));\n    snowc = mix(snowc,mix(vec3(0.0,1.0,1.0),vec3(1.0,1.0,1.0),mc),0.2);\n\n    col = mix(col,snowc*light,snow);\n\n    return clamp(col,vec3(0.,0.,0.),vec3(1.,1.,1.));\n}\n\nvec2 cloudTexture(vec3 realSurface, float time)\n{\n   seed = 14.0;\n   vec2 bl = getBL(realSurface);\n\n   vec3 w = wind3D(realSurface*1.,1.5,0.);\n   w += wind3D(realSurface*2.,1.5,0.)*0.2;\n   w += wind3D(realSurface*6.,1.5,0.)*0.1;\n   vec2 t = time*vec2(0.2,0.5); \n   vec2 bld1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x))));\n   vec2 bld2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x+0.5))));\n   vec2 blc1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y))));\n   vec2 blc2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y+0.5))));\n\n   seed = 14.0+floor(t.x)*0.1;\n   float d1 = spherePerlinHalf(bld1, 6.0);\n   seed = 14.05+floor(t.x+0.5)*0.1;\n   float d2 = spherePerlinHalf(bld2, 6.0);\n   \n   seed = 14.0+floor(t.y)*2.0;\n   float c1 = spherePerlinHalf(blc1, 192.0);\n   seed = 15.0+floor(t.y+0.5)*2.0;\n   float c2 = spherePerlinHalf(blc2, 192.0);\n   vec2 fdc = abs(0.5-fract(t))*2.0;\n   float d = mix(d1,d2,fdc.x);\n   float c = mix(c1,c2,fdc.y);\n   \n   float f = clamp((d*d)*4.0-c-0.5,0.0,1.0);\n   f = 1.-f;\n   return vec2(1.-f*f,0);\n   //return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // resolution\n    float res = 1.0 / iResolution.y;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n    \n    // bace const\n    float time=iTime*1.0;\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 col = vec3(0.0);\n    vec2 mouse = (iMouse.xy*2.0-iResolution.xy)*res;\n\n    // segments\n    scroll = iMouse.z>0.0 ? mouse : vec2(floor(p.x*2.5)*0.4+0.2,0.0);\n    scroll = clamp(scroll*0.5+0.5,vec2(0.),vec2(1.));\n    // test scroll\n    cid = int(floor(scroll.x*5.0));\n    cmf = fract(scroll.x*5.0);\n    //const vec3 pal[6] = vec3[6](vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.0,0.0,1.0),vec3(1.0,0.0,1.0));\n    //col = mix(pal[int(floor(scroll.x*5.0))],pal[int(floor(scroll.x*5.0))+1],fract(scroll.x*5.0));\n\n    // transforms\n    vec2 rotate = iMouse.z>0.0 ? vec2((mouse.x*5.+5.0)*3.1415,mouse.y*2.) : vec2(0.,-0.6);\n    //vec2 rotate = vec2(0.,-0.6);\n    float protate = time*0.025;\n    vec4 mcs=vec4(sin(rotate),cos(rotate));\n    vec2 pcs=vec2(cos(protate),sin(protate)); // planet rotation\n    mat3 mr=mat3(vec3(mcs.z,0.0,mcs.x),vec3(0.0,1.0,0.0),vec3(-mcs.x,0.0,mcs.z));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,mcs.w,mcs.y),vec3(0.0,-mcs.y,mcs.w))*mr;\n    mat3 pmr=mat3(vec3(pcs.x,0.0,pcs.y),vec3(0.0,1.0,0.0),vec3(-pcs.y,0.0,pcs.x));\n    \n    // object data\n    float dist=2.3;\n    float rplanet = 1.0;\n    float ratmos = 1.15;\n    float rcloud = 1.005;\n    vec3 spos = vec3(0.0,0.0,dist);\n    vec3 lpos = vec3(4.5,4.5,-9.0+dist);\n    lpos = mr*(lpos-spos) + spos;\n    vec3 lnorm = normalize(lpos - spos);\n    \n    // render calc\n    float dplanet = sphereIntersect(ray,spos,rplanet).x;\n    vec2 dcloud = sphereIntersect(ray,spos,rcloud);\n    float datmos = sphereIntersect(ray,spos,ratmos).x;\n    if (dplanet>0.0) {\n        vec3 ssurface = ray*dplanet;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        float dcs = sphereIntersectIn(lnorm,spos-ssurface,rcloud);\n        vec3 scloud = ssurface+lnorm*dcs;\n        float cs = dot(snorm,lnorm)>0. ? clamp(1.0-cloudTexture((scloud-spos)*mr*pmr,time*0.2).x,0.0,1.0) : 1.0;\n\n        col = sphereTexture((ssurface-spos)*mr*pmr,ray,snorm,lsnorm,time);\n        col = mix(col,col*cs,0.7);\n    }\n    if (datmos>0.0) {\n        float adepth = dplanet>0.0 ? (dplanet-datmos)*1.2 : abs(dot(ray,spos)-datmos);\n        vec3 ssurface = ray*datmos;\n        float ap = atmosphere(spos, ssurface, ray, lnorm, rplanet, ratmos, adepth);\n        col = mix(col,mix(catmF01(),catmF02(),ap),ap);\n    }\n    if (dcloud.x>0.0) {\n        vec3 sback = ray*dcloud.y;\n        vec3 ssurface = ray*dcloud.x;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        vec2 al = cloudTexture((ssurface-spos+lsnorm*0.01)*mr*pmr,time*0.2);\n        vec2 a = cloudTexture((ssurface-spos)*mr*pmr,time*0.2);\n        float emboss = a.x-al.x+0.05;\n        float light = 1.-clamp(dot(snorm,lsnorm),0.0,1.0);\n        light = 1.-light*light;\n        col = mix(col,mix(cclF01(),cclF02(),a.y)*light,clamp(a.x,0.,1.))\n            + vec3(clamp(emboss*0.2,0.,1.)+clamp(emboss*0.3*a.x+a.x*0.3*light,0.,1.))*light;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1614, 1614, 1630, 1630, 1675], [1676, 1676, 1692, 1692, 1737], [1739, 1739, 1754, 1754, 1797], [1798, 1798, 1813, 1813, 1856], [1858, 1858, 1873, 1873, 1916], [1917, 1917, 1932, 1932, 1975], [1977, 1977, 1992, 1992, 2035], [2036, 2036, 2051, 2051, 2094], [2096, 2096, 2118, 2118, 2136], [2137, 2137, 2159, 2159, 2177], [2254, 2254, 2276, 2276, 2344], [2345, 2345, 2366, 2366, 2444], [2446, 2521, 2575, 2575, 3024], [3026, 3026, 3079, 3079, 3603], [3605, 3681, 3723, 3723, 3763], [3765, 3850, 3893, 3893, 4061], [4063, 4150, 4205, 4205, 4344], [4346, 4346, 4411, 4411, 4547], [4549, 4549, 4598, 4598, 4794], [4796, 4796, 4848, 4848, 5007], [5009, 5009, 5052, 5052, 5089], [5091, 5091, 5132, 5132, 5477], [5479, 5479, 5522, 5522, 5704], [5706, 5706, 5751, 5751, 5914], [5916, 5916, 5974, 5974, 6167], [6169, 6169, 6226, 6226, 6424], [6426, 6454, 6512, 6512, 6716], [6718, 6773, 6832, 6832, 7052], [7054, 7054, 7100, 7100, 7793], [7795, 7795, 7921, 7921, 8184], [8186, 8186, 8267, 8267, 11745], [11747, 11747, 11796, 11796, 12817], [12819, 12819, 12876, 12894, 16101]], "test": "untested"}
{"id": "Nsf3zM", "name": "Compare simplex with lerp noise", "author": "foxes", "description": "Copied from https://www.shadertoy.com/view/4dXyRS\nLeft - lerp noise (Lnoise)\nRight - simplex noise (Snoise)", "tags": ["noise", "simplex"], "likes": 1, "viewed": 323, "published": 3, "date": "1615656599", "time_retrieved": "2024-07-30T19:32:45.218401", "image_code": "// see also analytical derivatives version: https://www.shadertoy.com/view/XdlyzS\n\n// --- noise from procedural pseudo-Perlin ( adapted from IQ ) ---------\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n//#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n#define hash3(p)  fract(mod(dot(p,vec3(1,57,-13.7))*dot(p,vec3(1,57,-13.7))*34.+dot(p,vec3(1,57,-13.7)),289.)/289.)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define Lnoise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n// --- Simplex noise 3D from  Makio64 / Ashima https://www.shadertoy.com/view/Xd3GRf\n\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float Snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 6. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U.x -= iResolution.x*0.5;\n    U *= 8./iResolution.y;\n    float n;\n    if (U.x>0.)\n        n = Snoise(vec3(U*1.0,.3*iTime));\n    else\n        n = Lnoise(vec3(U*2.0,.6*iTime));\n    O = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 181, 181, 877], [2693, 2693, 2731, 2731, 2929]], "test": "untested"}
{"id": "NdX3R7", "name": "Fork Color arcs RaduBT 036", "author": "RaduBT", "description": "Basic arcs demo\n\n/// https://www.shadertoy.com/view/tdjXDd\n/// Shadertoy : Avin - Color Arcs Shadertoy", "tags": ["arcs", "multicolor"], "likes": 11, "viewed": 550, "published": 3, "date": "1615656583", "time_retrieved": "2024-07-30T19:32:46.074113", "image_code": "/// https://www.shadertoy.com/view/tdjXDd\n/// Shadertoy : Avin - Color Arcs Shadertoy\n\n\n\n\n\n#define PI 3.1415926\n#define TAU 6.2831852\n#define BLACK_COL vec3(24,32,38)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define hue(h) clamp( abs( fract(11.2*h + vec4(3,2,1,0)/12.) * 4. - 2.8) -1. , 0.1, 15.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\n    float SIZE = 4. + cos(iTime*0.5)*0.1;\n    float r = length(uv) * SIZE;\n    r*=10.0;\n    float id = ceil(r);\n    float s = mod(id, 2.)*2. - 1.; // Direction\n    float a = fract(atan(uv.y, uv.x)/TAU + s*(iTime*(rand1(id+400.)*0.5+0.5)*0.2 + id*0.2));\n    float inRange = step(3.,id); // Don's draw center arcs    \n    float sm = (1./iResolution.y * 30.* SIZE);    \n    \n    inRange *= smoothstep(.0, sm, fract(r)) * smoothstep(1.0, 1.0 - sm, fract(r));\n    float arcLength =  (rand1(id)*0.25 + 0.25);\n    \n    sm = (sqrt(SIZE)*(1./iResolution.y * 5. / id));\n    inRange *= smoothstep(arcLength, arcLength + sm, a) * smoothstep(1.0, 1. - sm, a);\n        \n    vec3 col = hue(rand1(id)).rgb;\n    \n    col = mix(BLACK_COL, col, inRange);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdX3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 372, 372, 1214]], "test": "untested"}
{"id": "fdfGR7", "name": "Artifact as an animation effect", "author": "yasuo", "description": "Artifact as an animation effect.", "tags": ["effect"], "likes": 12, "viewed": 382, "published": 3, "date": "1615654833", "time_retrieved": "2024-07-30T19:32:46.928828", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 16\n#define MAX_DIST 16.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat octahedrons(vec3 p, float tval) {\n    vec3 prevP = p; \n    float t = iTime*tval;\n    float t2 = iTime*tval*2.0;\n    \n    float d = sdOctahedron(p*matRotateX(radians(-40.0*t))*matRotateZ(radians(20.0*t)),0.3);\n    \n    p = prevP;\n    p*=matRotateZ(radians(20.0*t2))*matRotateY(radians(30.0*t2));\n    \n    p.xy = DF(vec2(p.x,p.y),2.0);\n    p.xy = abs(p.xy);\n    p.xy -= vec2(0.6+sin(t)*0.2);\n    \n    float d2 = sdOctahedron(p*matRotateX(radians(-40.0*t)),0.15);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    vec3 tempP = p;\n    p.x = abs(p.x);\n    \n    float lineThickness = 0.01;\n    vec3 pos0 = vec3(1.5,1.0,0.0);\n    vec3 pos1 = vec3(1.5,-0.5,0.0);\n    vec3 pos2 = vec3(1.5,-2.0,0.0);\n    float d = octahedrons(p-pos0,1.5);\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    \n    tempP = p;\n    p*=matRotateZ(radians(-55.0));\n    p.y+=1.65;\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    p = tempP;\n        \n    tempP = p;\n    p*=matRotateZ(radians(30.0));\n    p.y-=0.7;\n    p.x+=0.7;\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    p = tempP;\n    \n    d = min(d,octahedrons(p-pos1,1.6));\n    \n    tempP = p;\n    p*=matRotateZ(radians(25.0));\n    p.y+=0.6;\n    p.x-=0.5;\n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    p = tempP;    \n    \n    tempP = p;\n    p*=matRotateZ(radians(-25.0));\n    p.y+=0.7;\n    p.x+=0.4;\n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    p = tempP;  \n    \n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    \n    tempP = p;\n    p.y+=0.5;\n    p.y=abs(p.y);\n    d = min(d, max(length(p.xz-pos1.xz)-lineThickness,p.y-pos1.y-2.0));\n    p = tempP;\n    \n    d = min(d,octahedrons(p-pos2,1.3));\n    \n    d = min(d, max(length(p.yz-pos2.yz)-lineThickness,p.x-pos2.x));\n    \n    tempP = p;\n    p*=matRotateZ(radians(-25.0));\n    p.y+=0.5;\n    p.x+=1.1;\n    d = min(d, max(length(p.yz-pos2.yz)-lineThickness,p.x-pos2.x));\n    p = tempP; \n    \n    p = prevP;\n    \n    p.y+=0.4;\n    p.y = abs(p.y);\n    p.y-=2.3;\n    float d2 = min(d,octahedrons(p,1.7));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.5;\n    p.y = abs(p.y);\n    p.y-=2.0;\n    d2 = octahedrons(p-vec3(0.0,-1.25,0.0),2.0);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=matRotateX(radians(30.0*iTime));\n    p.xz = DF(vec2(p.x,p.z),6.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(2.7+sin(iTime)*0.6);\n    \n    d2 = sdOctahedron(p,0.2);\n    d = min(d,d2);\n    \n    d*= (1.-hash12(gl_FragCoord.xy+iTime)*.2); // by https://www.shadertoy.com/view/tlGfzd\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,d);\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = 0.5 + 0.5*cos(iTime+rd.xyz+vec3(0,1,2));\n    vec3 col2 = mix(vec3(.2,.3,.8),col,k);\n    return col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, -6.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(iTime*1.2);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0)+(noise(uv.x*uv.y*iTime*0.1))*0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[633, 633, 655, 655, 729], [730, 749, 771, 771, 888], [889, 889, 927, 927, 980], [982, 982, 1021, 1021, 1493], [1495, 1495, 1517, 1517, 3742], [3744, 3744, 3777, 3777, 4030], [4032, 4032, 4056, 4056, 4257], [4259, 4259, 4301, 4301, 4496], [4498, 4498, 4516, 4516, 4662], [4664, 4664, 4721, 4721, 5543]], "test": "untested"}
{"id": "NsXGR7", "name": "trichromie points 2", "author": "ManuManu", "description": "Try for a nice effect on video", "tags": ["video", "filter", "postprocess", "points", "trichromie"], "likes": 2, "viewed": 250, "published": 3, "date": "1615654500", "time_retrieved": "2024-07-30T19:32:47.824434", "image_code": "\n\n// use this define to test on separated palette, rather than on a green moving movie !\n//#define TEST\n\n\n#ifdef TEST\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b * cos( 2.*3.14159 * ( c * t + d) );\n}\nvec3 MyPalette8(float t )\n{\n\treturn .6 + .4*cos(6.*t + vec3(5, 3, 1));\n}\n#endif \n\nfloat checker(vec2 uv, float scale, float angle, vec2 offset)\n{\n    float s = sin( angle ), c = cos( angle );\n    vec2 uv2 = vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y ) * scale;\n\treturn sin( uv2.x + offset.x) * sin( uv2.y + offset.y );\n}\n\nfloat processLum( vec2 uv, float lum, vec2 offset )\n{\n    float angle = 1.;\n    vec2 center = vec2(.5,.5);\n    float scale = 350.;\n\n    float dots = checker(uv, scale, angle, offset);\n    float intens = 5.;\n    float intens2 = ( intens - 1.) * .5;\n    return lum * intens - intens2 * ( 1. - dots);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef TEST\n    vec3 col = MyPalette8( uv.x );\n#else\n    vec3 col = texture( iChannel0, uv ).xyz;\n#endif\n    \n    const float pi = 3.14159;\n    vec3 offset = vec3( pi, pi*.5, 0.);\n    \n    float colorR = processLum( uv, col.r, offset.zz );\n    float colorG = processLum( uv, col.g, offset.xz );\n    float colorB = processLum( uv, col.b, offset.yy );\n\n    vec3 outputColor = vec3( colorR, colorG, colorB);\n\n#ifdef TEST\n    if (uv.y > .7 )\n        outputColor = col;        \n#endif\n    fragColor = vec4(vec3(outputColor),1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 376, 376, 555], [557, 557, 610, 610, 856], [860, 860, 917, 967, 1535]], "test": "untested"}
{"id": "Ndf3zM", "name": "x^y - y^x", "author": "sig", "description": "Formula visualization; coordinates transformed such that 0..1 -> 0..1  and  1..inf -> 1..2", "tags": ["math"], "likes": 2, "viewed": 251, "published": 3, "date": "1615653143", "time_retrieved": "2024-07-30T19:32:48.745969", "image_code": "float f(float x) {\n    return step(1., x) / abs(2. - x) + (1. - step(1., x)) * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = f(uv.x * 4.);\n    float y = f(uv.y * 4.);\n    \n    float z = pow(x, y) - pow(y, x);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + z*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndf3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 83], [85, 85, 142, 192, 475]], "test": "untested"}
{"id": "fdf3zM", "name": "points hatching2", "author": "ManuManu", "description": "Another try to have a continuous hatchign with dots / checkers", "tags": ["video", "postprocess", "checker", "dots", "hatching"], "likes": 8, "viewed": 490, "published": 3, "date": "1615652782", "time_retrieved": "2024-07-30T19:32:49.646562", "image_code": "vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n\n//#define TEST\n\nfloat checker(vec2 uv, float scale, float angle)\n{\n    float s = sin( angle ), c = cos( angle );\n    vec2 uv2 = vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y ) * scale;\n\treturn sin( uv2.x ) * sin( uv2.y );\n}\n\nfloat processLum( vec2 uv, float lum )\n{\n    float angle = 1.;\n    vec2 center = vec2(.5,.5);\n    float scale = 350.;\n\n    float dots = checker(uv, scale, angle);\n    float intens = 5.;\n    float intens2 = ( intens - 1.) * .5;\n    return lum * intens - intens2 * ( 1. - dots);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef TEST\n    vec3 col = vec3(uv.x );\n#else\n    vec3 col = texture( iChannel0, uv ).xyz;\n#endif\n    float lum = dot(col, W);\n    float color = processLum( uv, lum );\n\n    // add a blueish style for ink like :\n    color = clamp(color, 0.,1.);\n    vec3 outputColor = mix( vec3( 0.,.2,.3), vec3(1.,1.,1.), color);\n\n#ifdef TEST\n    if (uv.y > .7 )\n        outputColor = col;        \n#endif\n    fragColor = vec4(vec3(outputColor),1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 107, 107, 265], [267, 267, 307, 307, 545], [549, 549, 606, 656, 1132]], "test": "untested"}
{"id": "fsX3zM", "name": "2D rocket distance field", "author": "mrange", "description": "License CC0: 2D rocket distance field\nNothing fancy, just a 2D rocket", "tags": ["2d", "sdf"], "likes": 7, "viewed": 302, "published": 3, "date": "1615651226", "time_retrieved": "2024-07-30T19:32:50.561116", "image_code": "// License CC0: 2D rocket distance field\n//  Nothing fancy, just a 2D rocket\n\n#define RESOLUTION    iResolution\n#define TIME          iTime\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n\n// IQ's min\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's vesica\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat rocket(vec2 p) {\n  const float lw = 0.0125;\n  const float sm = 0.0125;\n\n  float d0 = vesica(p, 0.25, 0.125)-lw;\n  float d1 = abs(circle(p-vec2(0.0, 0.05), 0.125*0.66)) - lw;\n  float d2 = circle(p-vec2(0.0, -0.225), 0.225);\n  d2 = max(d2, -(d0 - lw*2.0));\n  float d3 = circle(p-vec2(0.0, -0.38), 0.25);\n  float d4 = max(d0, d3+lw*2.0);\n  float d5 = abs(d4)-lw*0.5;\n  d5 = min(d5, d4+lw*1.5);\n\n  float d = d0;\n  // To make the distance field more smooth\n  d = pmax(d, -d1, sm);\n  d = pmin(d, d2 , sm);\n  d = pmax(d, -d3, sm);\n  d = pmin(d, d5 , sm);\n\n  return d;\n}\n\nfloat df(vec2 p) {\n  const float s = 3.0;\n  return rocket(p/s)*s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  float d = df(p);\n\n  vec3 col = vec3(0.1);\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  if(p.x > 0.0)\n  col += 0.5*sin(d*300.0);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3zM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[206, 218, 257, 257, 346], [348, 348, 387, 387, 416], [418, 418, 448, 448, 475], [477, 477, 508, 508, 534], [536, 551, 591, 591, 740], [742, 742, 764, 764, 1310], [1312, 1312, 1330, 1330, 1379], [1381, 1381, 1436, 1436, 1741]], "test": "ok"}
{"id": "NdfGzM", "name": "3rd improvement", "author": "jemappelle", "description": "3rd iteration of a shader I have been making in between writing a JavaScript project to make use of it", "tags": ["messy"], "likes": 3, "viewed": 294, "published": 3, "date": "1615647835", "time_retrieved": "2024-07-30T19:32:51.425804", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\n//--Operators\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\n//--Shapes (SDFs)\nfloat sphere(vec3 d, float r){ \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.2) - r;\n}\n\n//Return objects/shapes in environment\nfloat map(vec3 d){\n  \td = mod(d, 3.)-3.*0.5;\n    return mix(sdRoundedX(d.xy, 0.3, 0.12), sphere(d, 0.4), cos(iTime*0.2*0.8));\n}\n\n//--Shading\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.6 + .4;\n}\n\n//Measure normals for shading\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.001,2.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    //Re-define fftVariables\n    float fftDivider = 2.;\n    float low = lowFreqFFT/fftDivider;\n    float mid = midFreqFFT/fftDivider;\n    float high = highFreqFFT/fftDivider;\n\n\t//Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.4;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    //Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n    //--Camera Positioning\n    //ro = Ray origin | p = Ray Origin Position\n    //rd = Ray distance\n  \tvec3 ro = vec3(0.+sin(iTime)/2., -zMotion, -8.+(iTime*4.));\n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv, 0.8));\n  \n    //hit = If the sphere trace hits an SDF, defined in 'map'\n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n    //dtm = Distance to march\n    //env = Environment / Distance field\n    float dtm = 75.;\n  \tfor(float i = 0.; i < dtm; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/-dtm*low;\n      \t\tbreak;\n    \t}\n        //Step the ray origin position (sphere trace) forward by the environment\n        //with a multiplier to create some interesting effect\n    \tp += env * sin(rd-ro/dtm);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*1.5)*0.4;\n  \tuv.y += sin(uv.x+iTime)*0.1;\n    \n    //--The following is more experimental code\n  \tfloat verLine = tan(smoothstep(0.06, 0.9,length(uv.y/(circle*(midFreqFFT*4.0)))));\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n    \n    \n    vec3 fogcolour = vec3(0.4,0.4,2.);\n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        color = mix(vec3(0.1,0.0,0.2), vec3(0.1, low,0.0), vec3(diffuse_directional(n,l)));\n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading) + vec3(circle + verLine)*0.9;\n        //color = vec3(circle - shading)+0.9;\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro-p)-5.0*mid; //lowFreqFFT/140.0;\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.2,0.2, high), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.2) - vec4((color * circle / 1.5), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 117, 154, 154, 174], [175, 175, 216, 216, 235], [237, 255, 285, 285, 311], [313, 313, 366, 366, 429], [431, 470, 488, 488, 597], [599, 611, 653, 653, 695], [697, 727, 751, 751, 919], [921, 921, 978, 1014, 3283]], "test": "untested"}
{"id": "NslGRN", "name": "Cube lines", "author": "morimea", "description": "Art shader.\n\nCineshader support [url]https://cineshader.com/view/NslGRN[/url]\n\nThis shader as Desktop wallpaper in linux:\n[b]for KDE[/b] [url]https://store.kde.org/p/1505365[/url]\n[b]for Gnome[/b] [url]https://www.gnome-look.org/p/1505898/[/url]", "tags": ["3d", "reflection", "refraction", "intersection", "art", "reflect", "mirrors", "cineshader"], "likes": 843, "viewed": 204618, "published": 3, "date": "1615641551", "time_retrieved": "2024-07-30T19:32:52.523868", "image_code": "// Created by Danil (2021+) https://cohost.org/arugl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// self https://www.shadertoy.com/view/NslGRN\n\n\n// --defines for \"DESKTOP WALLPAPERS\" that use this shader--\n// comment or uncomment every define to make it work (add or remove \"//\" before #define)\n\n\n// this shadertoy use ALPHA, NO_ALPHA set alpha to 1, BG_ALPHA set background as alpha\n// iChannel0 used as background if alpha ignored by wallpaper-app\n//#define NO_ALPHA\n//#define BG_ALPHA\n//#define SHADOW_ALPHA\n//#define ONLY_BOX\n\n\n// save PERFORMANCE by disabling shadow\n//#define NO_SHADOW\n\n\n// static CAMERA position, 0.49 on top, 0.001 horizontal\n//#define CAMERA_POS 0.049\n\n\n// speed of ROTATION\n#define ROTATION_SPEED 0.8999\n\n\n// static SHAPE form, default 0.5\n//#define STATIC_SHAPE 0.15\n\n\n// static SCALE far/close to camera, 2.0 is default, exampe 0.5 or 10.0\n//#define CAMERA_FAR 0.1\n\n\n// ANIMATION shape change\n//#define ANIM_SHAPE\n\n\n// ANIMATION color change\n//#define ANIM_COLOR\n\n\n// custom COLOR, and change those const values\n//#define USE_COLOR\nconst vec3 color_blue=vec3(0.5,0.65,0.8);\nconst vec3 color_red=vec3(0.99,0.2,0.1);\n\n\n// use 4xAA for cube only (set 2-4-etc level of AA)\n//#define AA_CUBE 4\n\n// use 4xAA for everything - derivative filtering will not be used, look fcos2\n// this is very slow - DO NOT USE\n//#define AA_ALL 4\n\n\n\n// --shader code--\n\n// Layers sorted and support transparency and self-intersection-transparency\n// Antialiasing is only dFd. (with some dFd fixes around edges)\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n// using https://www.shadertoy.com/view/ltKBzG\n// using https://www.shadertoy.com/view/tsVXzh\n// using https://www.shadertoy.com/view/WlffDn\n// using https://www.shadertoy.com/view/WslGz4\n\n#define tshift 53.\n\n// reflect back side\n//#define backside_refl\n\n// Camera with mouse\n#define MOUSE_control\n\n// min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n// this shader discover Nvidia bug with arrays https://www.shadertoy.com/view/NslGR4\n// use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n//#define DEBUG\n//#define BUG\n\n#define FDIST 0.7\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos1(vec3 x) {\n    vec3 w = fwidth(x);\n    //if((length(w)==0.))return vec3(0.); // dFd fix2\n    //w*=0.; //test\n    float lw=length(w);\n    if((lw==0.)||isnan(lw)||isinf(lw)){vec3 tc=vec3(0.); for(int i=0;i<8;i++)tc+=cos(x+x*float(i-4)*(0.01*400./iResolution.y));return tc/8.;}\n    \n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\nvec3 fcos2( vec3 x){return cos(x);}\nvec3 fcos( vec3 x){\n#ifdef AA_ALL \n    return fcos2(x);\n#else\n    return fcos1(x);\n#endif\n}\n\nvec3 getColor(vec3 p)\n{\n    // dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    //if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p / dot(p, p);\n#ifdef ANIM_COLOR\n    p+=0.072*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    //a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        //ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n// xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n    fade = 1.;\n    fadesi = 1.;\n    norm=vec3(0.,1.,0.);normsi=vec3(0.,1.,0.);\n\n    float tmp = 1.0 / (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r / q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        // normal\n\n        vec3 pos = ro + t * rd;\n        if(length(pos)>sz)return false;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) / (2.0 * p);\n            float t1 = (-q - s) / (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            // black border on end of circle and self intersection with alpha come because dFd\n            // uncomment this to see or rename fcos2 to fcos\n            //sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            // self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                // normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            // normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.336, 0.458, .668), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir, out float alpha)\n{\n#ifdef ONLY_BOX\nalpha=0.;\nreturn vec3(0.01);\n#endif\n    float t = (-BOXDIMS.z - ro.z) / rd.z;\n    alpha=0.;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n#ifdef NO_SHADOW\n    float shad=1.;\n#else\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n#endif\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(.71,.772,0.895), lght*lght* aofac+ 0.05) * aofac;\n    alpha=1.-smoothstep(7.,10.,length(uv));\n#ifdef SHADOW_ALPHA\n    //alpha=clamp(alpha*max(lght*lght*0.95,(1.-aofac)*1.25),0.,1.);\n    alpha=clamp(alpha*(1.-aofac)*1.25,0.,1.);\n#endif\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n#ifdef ANIM_SHAPE\n    float curvature = (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))));\n    // curvature(to not const above) make compilation on Angle 15+ sec\n#else\n#ifdef STATIC_SHAPE\n    const float curvature = STATIC_SHAPE;\n#else\n    const float curvature = .5;\n#endif\n#endif\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. / float(3)));\n            rd *= rotz(-pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. / float(3)));\n            rd *= rotz(pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. / float(3)));\n            rd *= rotx(pi * (1. / float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n#ifdef USE_COLOR\n                        vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                        const vec3 tcr = color_red;\n#else\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(tcr*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n#ifdef USE_COLOR\n                            vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                            const vec3 tcr = color_red;\n#else\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(tcr*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    // transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    // self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    l_dir *= rotz(0.5);\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n#ifdef CAMERA_POS\n    mouseY = PI*CAMERA_POS;\n#else\n    mouseY = PI*0.49 - smoothstep(0.,8.5,mod((iTime+tshift)*0.33,25.))*(1.-smoothstep(14.,24.0,mod((iTime+tshift)*0.33,25.))) * 0.55 * PI;\n#endif\n#ifdef ROTATION_SPEED\n    float mouseX = -2.*PI-0.25*(iTime*ROTATION_SPEED+tshift);\n#else\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#endif\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n#endif\n    \n#ifdef CAMERA_FAR\n    vec3 eye = (2. + CAMERA_FAR) * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#else\n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#endif\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec4 tot=vec4(0.);\n#if defined(AA_CUBE)||defined(AA_ALL)\n#ifdef AA_CUBE\n    const int AA = AA_CUBE;\n#else\n    const int AA = AA_ALL;\n#endif\n    vec3 incol_once=vec3(0.);\n    bool in_once=false;\n    vec4 incolbg_once=vec4(0.);\n    bool bg_in_once=false;\n    vec4 outcolbg_once=vec4(0.);\n    bool bg_out_once=false;\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(mod(float(mx+AA/2),float(AA)),mod(float(nx+AA/2),float(AA))) / float(AA) - 0.5;\n    vec2 uv = (fragCoord + o - 0.5 * iResolution.xy) / iResolution.x;\n#else\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n#endif\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z/BOXDIMS.xy + ro.yz * ni.x/BOXDIMS.yz + ro.zx * ni.y/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n#ifdef AA_CUBE\n        if(in_once)col=incol_once;\n        else{\n        in_once=true;\n#endif\n        float R0 = (IOR - 1.) / (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        float talpha;\n        vec3 reflcol = background(ro, rdr, l_dir,talpha);\n\n        vec3 rd2 = refract(rd, nr, 1. / IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n#ifdef AA_CUBE\n        }\n        incol_once=col;\n        if(!bg_in_once){\n        bg_in_once=true;\n        float alpha;\n        incolbg_once = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        incolbg_once.w = alpha;\n#endif\n        }\n#endif\n        \n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        vec4 tcolx = vec4(col, cineshader_alpha);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = 1.;\n#endif\n        tot += tcolx;\n    }\n    else\n    {\n        vec4 tcolx = vec4(0.);\n#ifdef AA_CUBE\n        if(!bg_out_once){\n        bg_out_once=true;\n#endif\n        float alpha;\n        tcolx = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = alpha;\n#endif\n#ifdef AA_CUBE\n        outcolbg_once=tcolx;\n        }else tcolx=max(outcolbg_once,incolbg_once);\n#endif\n        tot += tcolx;\n    }\n#if defined(AA_CUBE)||defined(AA_ALL)\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = tot;\n#ifdef NO_ALPHA\n    fragColor.w = 1.;\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n    fragColor.rgb=fragColor.rgb*fragColor.w+texture(iChannel0, fragCoord/iResolution.xy).rgb*(1.-fragColor.w);\n#endif\n    //fragColor=vec4(fragColor.w);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslGRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2365, 2365, 2384, 2384, 2489], [2490, 2490, 2509, 2509, 2612], [2613, 2613, 2632, 2632, 2736], [2738, 2738, 2758, 2758, 3081], [3083, 3083, 3103, 3103, 3118], [3119, 3119, 3138, 3138, 3210], [3212, 3212, 3235, 3378, 4133], [4135, 4135, 4273, 4273, 5174], [5176, 5232, 5441, 5441, 8807], [8809, 8809, 8834, 8834, 8853], [8855, 8855, 8920, 8920, 9404], [9406, 9406, 9480, 9480, 10053], [10055, 10055, 10129, 10129, 10666], [10668, 10668, 10692, 10692, 10779], [10781, 10781, 10852, 10852, 11812]], "test": "untested"}
{"id": "7dl3zN", "name": "Fork heat disto mojibake 388", "author": "mojibake", "description": "heat haze shader", "tags": ["2d"], "likes": 1, "viewed": 231, "published": 3, "date": "1615635408", "time_retrieved": "2024-07-30T19:32:53.350658", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 uvDist = vec2(uv.xy);\n\tuvDist.x = uvDist.x + iChannelResolution[1].x * sin(iTime/100000.0);\n\tuvDist.y = uvDist.y + iChannelResolution[1].y * sin(iTime/100000.0);\n\t\n\tvec4 distortionColor = texture(iChannel1, uvDist);\n\t\n\t//uv.x = uv.x + iChannelResolution[0].x * sin(iTime/10000.0);\n\t//uv.y = uv.y + iChannelResolution[0].y * cos(iTime/10000.0);\n\t\n\tuv.x = uv.x + distortionColor.x / 200.0;\n\tuv.y = uv.y + distortionColor.y / 200.0;\n\t\n\tvec4 col = texture(iChannel0, uv);\n\t\n\tfragColor = col;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 645]], "test": "untested"}
{"id": "ssl3zH", "name": "Plotting Circles", "author": "mla", "description": "Something simple today: plotting circles and finding intersections in a way that works nicely for lines as a special case.\n\nThe mouse moves the yellow line.", "tags": ["circles", "intersection", "plotting"], "likes": 7, "viewed": 318, "published": 3, "date": "1615626764", "time_retrieved": "2024-07-30T19:32:54.182434", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Plotting circles, mla, 2021\n//\n// For given float k and unit vector r, if kp.p = p.r the locus of p is a\n// circle passing through the origin, diameter 1/k with centre at r/2k.\n//\n// This is nice as the case k=0 gives a line (with normal r) without any\n// special treatment. Also, while kp.p-p.r isn't an exact distance function\n// everywhere its gradient on the circle has magnitude 1 (its a nice \n// exercise to see why this is) so it does work as a distance function locally\n// eg. for plotting the circle as a line (and the calculation of the\n// distance function involves just one dot product).\n//\n// This should work in any number of dimensions, so sphere intersections can \n// be calculated in the same way (with a nice degeneration to the plane case).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float scale = 10.0;\n  vec2 mouse = vec2(-2,1);\n  vec2 p = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) mouse = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  vec3 color = vec3(0.5,1,0.75); //vec3(smoothstep(0.0,0.01,abs(dist/ddist)));\n  vec2 r = normalize(vec2(1,1)); // Centre direction\n  float k = 0.5*tan(iTime);          // Inverse diameter\n  // kp.p-p.r == 0\n  float dist = abs(dot(p,k*p-r));\n  color = mix(vec3(0),color,smoothstep(0.1,0.15,dist)); \n\n  vec2 q = vec2(-2,-2);       // Line origin\n  vec2 t = normalize(mouse-q); // Line direction\n  q += -dot(q,t)*t; // Move q along line so q.t = 0 (helps with stability)\n  float ldist = abs(dot(p-q,vec2(t.y,-t.x)));\n  color = mix(vec3(1,1,0),color,smoothstep(0.1,0.15,ldist));\n  // Intersect q+xt with kp.p-p.r = 0\n  // k(q+xt).(q+xt) - (q+xt).r = 0\n  // k(q.q+2xq.t+x) - q.r - xt.r = 0 (and q.t = 0)\n  // Solving Ax - 2Bx + C = 0\n  float A = k;\n  float B = 0.5*dot(t,r);\n  float C = dot(q,k*q-r);\n  float D = B*B-A*C;\n  if (D >= 0.0) {\n    float tmp = B < 0.0 ? B-sqrt(D) : B+sqrt(D);\n    float x0 = tmp/A;\n    float x1 = C/tmp;\n    float pdist = min(distance(p,q+t*x0),distance(p,q+t*x1));\n    color = mix(vec3(1,0,0),color,smoothstep(0.3,0.35,pdist));\n  }\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssl3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[932, 932, 988, 988, 2317]], "test": "untested"}
{"id": "sdl3RN", "name": "Transport Dynamics II", "author": "wyatt", "description": "Iterating on an idea... how can you track exactly how much stuff enters a cell? ", "tags": ["fluid", "automata"], "likes": 17, "viewed": 538, "published": 3, "date": "1615625634", "time_retrieved": "2024-07-30T19:32:55.063080", "image_code": "// Display \nMain \n{\n    vec4 f = A(U);\n    Q = vec4(1.,.8,.9,0)-(.5-0.5*(sin(f.z+vec4(1,2,3,4))))*f.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        Q.xy -= 0.04*a.w*(a.w-.9)*u;  \n    }\n    Q.y -= 1e-4;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.5*normalize(iMouse.xy-0.5*R),2.+1.*sin(float(iFrame)/1000.),1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,U.x/R.x*6.,step(0.5*R.x,U.x));\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*smoothstep(0.8,.0,Q.w*q.w);\n       float k = .5+.5*smoothstep(0.8,.0,Q.w*q.w);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dl3z4", "name": "Emergent Boids", "author": "oneshade", "description": "I can't wait to do this in 3D!", "tags": ["2d", "simulation", "behavior", "flocking", "boids", "emergent"], "likes": 12, "viewed": 328, "published": 3, "date": "1615615667", "time_retrieved": "2024-07-30T19:32:56.031490", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BOIDS 250\n\n#define BOID_COLOR vec3(0.12, 0.56, 1.0)\n#define BOID_SIZE 0.005\n\n#define MOTION_BLUR 0.9\n\n#define VIEW_RADIUS 0.225\n\n#define SPEED_LIMIT 0.0175\n#define NUDGE 0.001\n#define MARGIN 0.0\n\n#define COHERENCE 0.0125\n#define SEPERATION 0.005\n#define ALIGNMENT 0.0001\n\n#define getBoidPos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getBoidVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 initPos(in float seed) {\n    return Hash12(seed) - 0.5;\n}\n\nvec2 initVel(in float seed) {\n    return Hash12(seed * 487.583 + 35.847) * 0.01 - 0.005;\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFragCoord.x < BOIDS) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xy = initPos(fragCoord.x);\n            if (iFragCoord.y == 1) fragColor.xy = initVel(fragCoord.x);\n        }\n\n        if (iFrame > 0) {\n            vec2 boidPos = getBoidPos(iFragCoord.x);\n            vec2 boidVel = getBoidVel(iFragCoord.x);\n\n            if (iFragCoord.y == 0) {\n                boidPos += boidVel;\n                fragColor.xy = boidPos;\n            }\n\n            if (iFragCoord.y == 1) {\n                vec2 center = vec2(0.0);\n                vec2 repel = vec2(0.0);\n                vec2 align = vec2(0.0);\n                float neighbors = 0.0;\n                for (int id=0; id < BOIDS; id++) {\n                    vec2 boidPos2 = getBoidPos(id);\n                    vec2 boidVel2 = getBoidVel(id);\n                    if (id != iFragCoord.x && length(boidPos - boidPos2) < VIEW_RADIUS) {\n                        center += boidPos2;\n                        repel += boidPos - boidPos2;\n                        align += boidVel2;\n                        neighbors++;\n                    }\n                }\n\n                if (neighbors > 0.0) {\n                    center /= neighbors;\n                    repel /= neighbors;\n                    align /= neighbors;\n\n                    boidVel += (center - boidPos) * COHERENCE;\n                    boidVel += repel * SEPERATION;\n                    boidVel += (align - boidVel) * ALIGNMENT;\n                }\n\n                if (boidPos.x > corner.x - MARGIN) boidVel.x -= NUDGE;\n                if (-boidPos.x > corner.x - MARGIN) boidVel.x += NUDGE;\n                if (boidPos.y > corner.y - MARGIN) boidVel.y -= NUDGE;\n                if (-boidPos.y > corner.y - MARGIN) boidVel.y += NUDGE;\n\n                fragColor.xy = normalize(boidVel) * min(length(boidVel), SPEED_LIMIT);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy) * MOTION_BLUR;\n    float unit = 2.0 / iResolution.y;\n\n    for (int id=0; id < BOIDS; id++) {\n        vec2 boidPos = getBoidPos(id);\n        float d = length(uv - boidPos) - BOID_SIZE;\n        fragColor.rgb = mix(fragColor.rgb, BOID_COLOR, smoothstep(unit, 0.0, d));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "7df3RH", "name": "Pool with glass balls", "author": "kosmaks", "description": "I know it's not an original idea\nWanted to challenge myself to build something interactive\n\nGameplay:\n A, D - move cue\n Q (hold and release) - hit\n R - restart\nCamera:\n Left, Right - rotate camera\n W - top view\nMisc:\n G - glass balls\n  T - surface texture", "tags": ["raytracing", "raymarching", "game", "pool"], "likes": 34, "viewed": 828, "published": 3, "date": "1615590049", "time_retrieved": "2024-07-30T19:32:57.133544", "image_code": "#define MAX_DIST (40.)\n#define MIN_DIST (0.005)\n#define MAX_STEPS (300)\n//#define SHOW_STATE\n\n#define PIX(x, y) d = smin(d, distance(vp, vec2((x), (y))) - 0.02, 0.1)\n\n#define LIGHT0 (vec3(-5., 20., 0.))\n#define LIGHT1 (vec3(5., 20., 0.))\n\n// Materials\n\nstruct Material {\n    vec3 reflection;\n    vec3 diffuse;\n    vec4 specular;\n    vec4 refraction;\n};\n\nconst Material mFloor = Material(\n    vec3(0.05),\n    vec3(0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mWhiteBall = Material(\n    vec3(0.),\n    vec3(0.6),\n    vec4(vec3(0.5), 50.),\n    vec4(0.)\n);\n\nconst Material mBall = Material(\n    vec3(0.1),\n    vec3(0.3, 0.3, 0.8),\n    vec4(vec3(0.6), 50.),\n    vec4(0.)\n);\n\nconst Material mTableWood = Material(\n    vec3(0.),\n    vec3(0.52, 0.37, 0.26),\n    vec4(vec3(1.), 50.),\n    vec4(0.)\n);\n\nconst Material mTableSteel = Material(\n    vec3(1.),\n    vec3(0.),\n    vec4(1.),\n    vec4(0.)\n);\n\nconst Material mTablePocket = Material(\n    vec3(0.),\n    vec3(0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mTable = Material(\n    vec3(0.),\n    vec3(0.3, 0.4, 0.1),\n    vec4(0.),\n    vec4(0.)\n);\n\nconst Material mCue = Material(\n    vec3(0.),\n    vec3(0.52, 0.37, 0.26) * 0.3,\n    vec4(vec3(1.), 40.),\n    vec4(0.)\n);\n\nconst Material mGlass = Material(\n    vec3(0.),\n    vec3(0.1),\n    vec4(vec3(0.6), 30.),\n    vec4(vec3(0.9), 0.45)\n);\n\n// Utilities\n\n#define T3D(s) (vec3((s).x, 0., (s).y))\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb, cb)) );\n}\n\nfloat intSphere(vec3 ro, vec3 rd, vec3 p, float r, out vec3 touch, out vec3 outN) {\n    vec3 tc = ro - p;\n    float tcl = length(tc);\n    float b = 2. * dot(tc, rd);\n    float c = tcl * tcl - r * r;\n    float uu = b*b - 4. * c;\n    \n    float dist = -1.;\n    if (uu >= 0.) {\n        float sq = sqrt(uu);\n        dist = (-b - sq) / 2.;\n        if (dist < 0.) {\n            dist = (-b + sq) / 2.;\n        }\n    }\n    \n    if (dist > EPS) {\n        touch = ro + rd * dist;\n        outN = normalize(touch - p);\n    } else {\n        dist = MAX_DIST + 1.;\n    }\n    \n    return dist;\n}\n\n// Objects\n\nfloat objCue(vec3 p, out Material m) {\n    vec2 ballVel = sampleVel(iChannel0, 0.).xy;\n    if (length(ballVel) > EPS) return MAX_DIST;\n\n    m = mCue;\n    float radius = BALL_RADIUS * rTableSize;\n    \n    p -= rTableZeroBase;\n    \n    // Cue at the ball\n    p -= T3D((samplePos(iChannel0, 0.) * rTableSize)) + \n        vec3(0., rTableHeight + radius, 0.);\n\n    \n    float angle = getCueAngle(sampleCueDir(iChannel0));\n    p = qRotate(p, qCreateRotation(vec3(0., 1., 0.), angle));\n    \n    p = qRotate(p, qCreateRotation(vec3(0., 0., 1.), 1.57));\n    p = qRotate(p, qCreateRotation(vec3(0., 0., 1.), 0.2));\n        \n    // Cue at the tip\n    float power = getCueOffset(sampleHitPowerRaw(iChannel0));\n    p -= vec3(0., -rCueDim.z - radius - power * 1., 0.);\n    \n    return sdCappedCone(p, rCueDim.z, rCueDim.x, rCueDim.y);\n}\n\nfloat objTable(vec3 p, out Material m) {\n    m = mTable;\n        \n    vec3 size = -rTableZeroBase;\n    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));\n    \n    float rThirdBorder = rBorderSize * 0.33;\n    if (\n        p.y < rTableHeight - EPS ||\n        absp.z > size.z - rThirdBorder ||\n        absp.x > size.x - rThirdBorder\n    ) {\n        m = mTableWood;\n    }\n    \n    if (p.y > rTableHeight - rTableThickness && (\n        distance(absp.xz, size.xz) < rBorderSize\n    )) {\n        m = mTableSteel;\n    }\n    \n    // Table top\n    float d = sdRoundBox(\n        absp - vec3(0., rTableHeight, 0.), \n        size + vec3(0., rTableThickness, 0.),\n        0.2\n    );\n    \n    d = smax(d, -sdBox(\n        absp - vec3(0., rTableHeight + rTableThicknessHalf + 0.2, 0.), \n        size + vec3(-rBorderSize, rTableThicknessHalf + 0.2, -rBorderSize)\n    ), 0.1);\n    \n    \n    // Pockets\n    vec3 cp = absp + rTableZeroBase;\n    float rPocketRadius = POCKET_RADIUS * rTableSize;\n    float pd = sdCylinder(cp + T3D(POCKET0) * rTableSize, rPocketRadius);\n    pd = min(pd, sdCylinder(cp + T3D(POCKET1) * rTableSize, rPocketRadius));\n    if (-pd > d) {\n        m = mTablePocket;\n        d = -pd;\n    }\n    \n    // Footer\n    d = min(d, sdBox(\n        absp - vec3(0., rTableHeight - rTableFooterHeight - rTableThickness, 0.), \n        size + vec3(0., rTableFooterHeight, 0.)\n    ));\n     \n     \n    // Legs\n    vec3 legPos = vec3(\n        size.x * 0.9, \n        rTableHeightHalf - rTableThicknessHalf, \n        size.z * 0.8);\n    vec3 legSize = rTableSize * \n        vec3(0.015, 0., 0.015) + \n        vec3(0., rTableHeightHalf - rTableThicknessHalf, 0.);\n    d = min(d, sdRoundBox(absp - legPos, legSize, 0.2));\n    \n    if (isToggled(iChannel1, KEY_T) && abs(p.y - rTableHeight) < 0.1) {\n        float tex = texture(iChannel2, p.xz / 10.).x;\n        tex = tex * 0.5 + 0.5;\n        m.diffuse *= tex;\n    }\n    \n    return d;\n}\n\n// Ray marching\n\nfloat marching_getDist(vec3 p, out Material m) {\n    float td, d = p.y;\n    m = mFloor;\n    Material tm;\n    \n    td = objCue(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    td = objTable(p, tm);\n    if (td < d) { d = td; m = tm; }\n    \n    return d;\n}\n\nvec3 marching_getNormal(vec3 p) {\n    Material m;\n    float dist = marching_getDist(p, m);\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = dist - vec3(\n        marching_getDist(p - e.xyy, m),\n        marching_getDist(p - e.yxy, m),\n        marching_getDist(p - e.yyx, m));\n    return normalize(n);\n}\n\nfloat marching_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float totalDist = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        totalDist += d;\n        if (abs(d) < MIN_DIST || totalDist > MAX_DIST) break;\n        if (i == MAX_STEPS - 1) totalDist = MAX_DIST + 1.;\n    }\n    \n    if (totalDist < MAX_DIST) {\n        touch = ro + totalDist * rd;\n        n = marching_getNormal(touch);\n    }\n    \n    return totalDist;\n}\n\nfloat marching_softShadow(vec3 ro, vec3 rd, float k, float maxD) {\n    Material m;\n    float totalDist = 0.2;\n    float res = 1.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 next = ro + totalDist * rd;\n        float d = marching_getDist(next, m);\n        res = min(res, k * d / totalDist);\n        if (abs(d) < MIN_DIST) return 0.;\n        totalDist += d;\n        if (totalDist > maxD) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\n// Intersection for spheres\n\nfloat inter_castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    vec3 tt, tn;\n    float td, d = MAX_DIST + 1.;\n    Material tm;\n    float y = rTableHeight + rBallRadius;\n    \n    Material mOther = mBall;\n    if(isToggled(iChannel1, KEY_G)) {\n        mOther = mGlass;\n    }\n    \n    for (int i = 1; i < BALL_COUNT_I; ++i) {\n        float iFloat = float(i);\n        bool visible = sampleVel(iChannel0, iFloat).z < 0.5;\n        if (!visible) continue;\n        vec2 pos = samplePos(iChannel0, iFloat) * rTableSize;\n        vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n        td = intSphere(ro, rd, pos3, rBallRadius, tt, tn);\n        if (td < d) { m = mOther; d = td; touch = tt; n = tn; };\n    }\n    \n    vec2 pos = samplePos(iChannel0, 0.) * rTableSize;\n    vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n    td = intSphere(ro, rd, pos3, rBallRadius, tt, tn);\n    if (td < d) { m = mWhiteBall; d = td; touch = tt; n = tn; };\n    \n    return d;\n}\n\nfloat inter_softShadow(vec3 ro, vec3 rd, float k, float d) {\n    vec3 t, n;\n    Material m;\n    float res = 1.;\n    float y = rTableHeight + rBallRadius;\n    \n    for (int i = 0; i < BALL_COUNT_I; ++i) {\n        float iFloat = float(i);\n        bool visible = sampleVel(iChannel0, iFloat).z < 0.5;\n        if (!visible) continue;\n        vec2 pos = samplePos(iChannel0, iFloat) * rTableSize;\n        vec3 pos3 = vec3(pos.x, y, pos.y) + rTableZeroBase;\n        \n        float a = dot(pos3 - ro, rd);\n        if (a < 0.01 || a > d) continue;\n        vec3 p = ro + a * rd;\n        \n        float dist = max(0., distance(p, pos3) - rBallRadius);\n        res = min(res, k * dist / a);\n    }\n    \n    return res;\n}\n\nfloat castRay(vec3 ro, vec3 rd, out Material m, out vec3 touch, out vec3 n) {\n    float d = MAX_DIST + 1.;\n    vec3 tt, tn;\n    float td;\n    Material tm;\n    \n    td = marching_castRay(ro, rd, tm, tt, tn);\n    if (td < d) { d = td; m = tm; touch = tt; n = tn; };\n    \n    td = inter_castRay(ro, rd, tm, tt, tn);\n    if (td < d) { d = td; m = tm; touch = tt; n = tn; };\n    \n    return d;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k, float d) {\n    float res = 1.;\n    res = min(res, marching_softShadow(ro, rd, k, d));\n    res = min(res, inter_softShadow(ro, rd, k / 2., d));\n    return res;\n}\n\n// Main\n\nvec3 pointLightCast(vec3 p, vec3 n, vec3 point) {\n    vec3 ld = normalize(point - p);\n    float fact = dot(n, ld);\n    if (fact <= 0.) return vec3(0.);\n    \n    vec3 lo = p + n * MIN_DIST * 5.;\n    Material m;\n    vec3 touch, tn;\n    float dist = softShadow(lo, ld, 4., MAX_DIST);\n    float ao = softShadow(lo, n, 2., 0.2) * 0.7 + 0.3;\n    \n    float power = exp(-distance(point, p) * 0.05);\n    \n    return vec3(fact) * ao * (dist * 0.7 + 0.3) * power * 2.;\n}\n\nvec3 traceScene(vec3 ro, vec3 rd, inout float seed) {\n    float d;\n    Material m;\n    vec3 touch, n;\n    vec3 rad = vec3(0.);\n    vec3 scaler = vec3(1.);\n    \n    for (int i = 0; i < 4; ++i) {\n        d = castRay(ro, rd, m, touch, n);\n        \n        if (d >= MAX_DIST) {\n            rad += vec3(0., 0., 0.1);\n            break;\n        } else {\n            vec3 diffuse = pointLightCast(touch, n, LIGHT0);\n            diffuse += pointLightCast(touch, n, LIGHT1);\n            rad += scaler * m.diffuse * diffuse;\n\n            vec3 ambient = vec3(0.1);\n            rad += scaler * m.diffuse * ambient;\n\n            if (m.specular != vec4(0.)) {\n                float specular = dot(reflect(normalize(touch - LIGHT0), n), -rd);\n                specular = max(0., specular);\n                rad += scaler * m.specular.xyz * pow(specular, m.specular.w);\n            }\n\n            if (m.refraction != vec4(0.)) {\n                float s = sign(dot(rd, n));\n                ro = touch + n * MIN_DIST * 2. * s;\n                rd = refract(rd, n * -s, m.refraction.w);\n                scaler *= m.refraction.xyz;\n            } else if (m.reflection != vec3(0.)) {\n                ro = touch + n * MIN_DIST * 2.;\n                rd = reflect(rd, n);\n                scaler *= m.reflection;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n    \n#ifdef SHOW_STATE\n    fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, 1.0);\n    return;\n#endif\n\n    float seed = fract(sin(fragCoord.x * 3.132 + fragCoord.y * 1.33)) * 100. + iTime;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 camOffset = T3D(samplePos(iChannel0, 0.) * rTableSize) + rTableZeroBase;\n    \n    float rot = sampleRot(iChannel0) * 6.28;\n    vec3 ro =  sampleCamPos(iChannel0);\n    vec3 target = sampleCamTarget(iChannel0);\n    vec3 rd = getInitialRD(vp, ro, target, 2.5);\n    \n    vec3 totalRad = traceScene(ro, rd, seed);\n    \n    col = totalRad;\n    \n    \n    bool gameOver = sampleVel(iChannel0, 0.).z > 0.5;\n    if (gameOver) {\n        col.g = 0.;\n        \n        vp += vec2(0.7, -0.2);\n        \n        float d = 100.;\n        PIX(0., 0.); PIX(0.1, 0.); PIX(0.2, 0.);\n        PIX(0., -0.1);\n        PIX(0., -0.2); PIX(0.13, -0.2);\n        PIX(0., -0.3);\n        PIX(0., -0.4);\n        \n        PIX(0.4, 0.); PIX(0.5, 0.); PIX(0.6, 0.);\n        PIX(0.4, -0.1); PIX(0.6, -0.1);\n        PIX(0.4, -0.2); PIX(0.5, -0.2); PIX(0.6, -0.2);\n        PIX(0.4, -0.3); PIX(0.6, -0.3);\n        PIX(0.4, -0.4); PIX(0.6, -0.4);\n        \n        PIX(0.8, 0.); PIX(0.9, 0.); PIX(1., 0.);\n        PIX(0.9, -0.1);\n        PIX(0.9, -0.2);\n        PIX(0.9, -0.3);\n        PIX(0.8, -0.4); PIX(0.9, -0.4); PIX(1., -0.4);\n        \n        PIX(1.2, 0.); \n        PIX(1.2, -0.1);\n        PIX(1.2, -0.2);\n        PIX(1.2, -0.3);\n        PIX(1.2, -0.4); PIX(1.3, -0.4); PIX(1.4, -0.4);\n        \n        if (d < 0.) {\n            col = vec3(0.9, 0.2, 0.3);\n        } else if (d < 0.02) {\n            col = vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 getInitialPos(float ballId) {\n#ifdef DEBUG_BALLS\n    if (ballId > 0.5) return vec2(0.3, 0.25);\n    return vec2(0.1, 0.045);\n#endif\n\n    float xo = sqrt(3.*BALL_RADIUS*BALL_RADIUS) + 0.001;\n    float yo = BALL_RADIUS + 0.001;\n    vec2 first = vec2(0.7, 0.25);\n    if (ballId > 9.5) return first + vec2(3. * xo, 3. * yo);\n    if (ballId > 8.5) return first + vec2(3. * xo, -3. * yo);\n    if (ballId > 7.5) return first + vec2(3. * xo, yo);\n    if (ballId > 6.5) return first + vec2(3. * xo, -yo);\n    if (ballId > 5.5) return first + vec2(2. * xo, -2. * yo);\n    if (ballId > 4.5) return first + vec2(2. * xo, 2. * yo);\n    if (ballId > 3.5) return first + vec2(2. * xo, 0.);\n    if (ballId > 2.5) return first + vec2(xo, -yo);\n    if (ballId > 1.5) return first + vec2(xo, yo);\n    if (ballId > 0.5) return first;\n    return vec2(0.1, 0.25);\n}\n\nvec3 getInitialVel(float ballId) {\n#ifdef DEBUG_BALLS\n    if (ballId > 0.5) return vec3(0.);\n    return vec3(\n        normalize(getInitialPos(1.) - getInitialPos(0.)) * 0.04,\n        0.\n    );\n#endif\n\n    return vec3(0.);\n}\n\nvec2 nextPos(vec2 curPos, vec3 curVel) {\n    return curPos + curVel.xy;\n}\n\nvec3 nextVel(float ballId, vec2 curPos, vec3 curVel) {\n    if (curVel.z > 0.5) {\n        return curVel;\n    }\n\n    int ballIdInt = int(ballId);\n    vec2 curNext = nextPos(curPos, curVel);\n    \n    float pocketDist = 100.;\n    pocketDist = min(pocketDist, distance(curPos, POCKET0));\n    pocketDist = min(pocketDist, distance(curPos, POCKET1));\n    pocketDist = min(pocketDist, distance(curPos, POCKET2));\n    pocketDist = min(pocketDist, distance(curPos, POCKET3));\n    pocketDist = min(pocketDist, distance(curPos, POCKET4));\n    pocketDist = min(pocketDist, distance(curPos, POCKET5));\n    if (pocketDist < SCORE_DIST) {\n        return vec3(0., 0., 1.);\n    }\n    \n    vec2 lo = vec2(BORDER_SIZE);\n    vec2 hi = TABLE_SIZE - lo;\n    \n    if (curNext.x - BALL_RADIUS <= lo.x) \n        return vec3(abs(curVel.x), curVel.y, 0.) * BALL_ACCEL;\n    if (curNext.x + BALL_RADIUS >= hi.x) \n        return vec3(-abs(curVel.x), curVel.y, 0.) * BALL_ACCEL;\n    if (curNext.y - BALL_RADIUS <= lo.y) \n        return vec3(curVel.x, abs(curVel.y), 0.) * BALL_ACCEL;\n    if (curNext.y + BALL_RADIUS >= hi.y) \n        return vec3(curVel.x, -abs(curVel.y), 0.) * BALL_ACCEL;\n    \n    vec2 newVel = vec2(0.);\n    vec2 shift = vec2(0.);\n    float fact = 0.;\n    \n    for (int i = 0; i < BALL_COUNT_I; ++i) {\n        if (ballIdInt == i) continue;\n        \n        float iFloat = float(i);\n        vec3 neighVel = sampleVel(iChannel0, iFloat);\n        if (neighVel.z > 0.5) continue;\n        \n        vec2 neighPos = samplePos(iChannel0, iFloat);\n        vec2 neighNext = nextPos(neighPos, neighVel);\n        float dist = distance(neighNext, curNext);\n        if (dist <= 2.*BALL_RADIUS) {\n            vec2 n = normalize(neighNext - curNext) * BALL_RADIUS;\n            vec2 center = 0.5 * (neighNext - curNext) + curNext;\n            \n            vec2 p1 = center - n;\n            vec2 p2 = center + n;\n            \n            float m = BALL_M;\n            float M = m + m;\n            vec2 cc = p1 - p2;\n            float d = length(cc); d *= d;\n            vec2 v1 = curVel.xy, v2 = neighVel.xy;\n            \n            newVel += (v1 - 2. * m / M * dot(v1 - v2, p1 - p2) / d * (p1 - p2)) * HIT_DECCEL;\n            shift += (p1 - curNext);\n            fact += 1.;\n        }\n    }\n    \n    if (fact <= EPS) {\n        newVel = curVel.xy;\n    } else {\n        newVel /= fact;\n    }\n    \n    if (ballIdInt == 0) {\n        float hitPower = getHitPower(sampleHitPowerRaw(iChannel0)) * 0.05;\n        if (hitPower > EPS) {\n            shift += getCueDir(sampleCueDir(iChannel0)) * hitPower;\n        }\n    }\n    \n    return vec3(newVel * BALL_ACCEL + shift, 0.);\n}\n\nvec3 getCameraPos(bool isInitial) {\n    float rot = sampleRot(iChannel0) * 6.28 + 1.57;\n    vec2 ball2d = isInitial ? getInitialPos(0.) : samplePos(iChannel0, 0.);\n    vec3 ball = vec3(ball2d.x, 0., ball2d.y) * rTableSize + rTableZeroBase;\n    vec3 res = vec3(-10., 14., -10.);\n    res *= vec3(sin(rot), 1., cos(rot));\n    res += ball;\n    return res;\n}\n\nvec3 getCameraTarget(bool isInitial) {\n    vec2 ball = isInitial ? getInitialPos(0.) : samplePos(iChannel0, 0.);\n    return vec3(ball.x, 0., ball.y) * rTableSize + rTableZeroBase +\n        vec3(0., rTableHeight * 1.1, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool isInitial = iFrame == 0 || \n        !sampleInitFlag(iChannel0) || \n        isPressed(iChannel1, KEY_R);\n    \n    vec2 cell = getGridCell(uv);\n    \n    if (cell.y >= 4. || cell.x < 0.) return;\n    \n    // Camera animations\n    \n    if (CLOSE(cell.x, 0.) && CLOSE(cell.y, 3.)) { // camera position\n        vec3 res;\n        if (isInitial) {\n            res = getCameraPos(true);\n        } else {\n            res = sampleCamPos(iChannel0);\n            vec3 next = sampleCamPosNext(iChannel0);\n            res += (next - res) * 0.1;\n        }\n        \n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 1.) && CLOSE(cell.y, 3.)) { // camera position to animate to\n        vec3 res;\n        if (!isInitial && isToggled(iChannel1, KEY_W)) {\n            res = vec3(0., 30., -1.);\n        } else {\n            res = getCameraPos(isInitial);\n        }\n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 2.) && CLOSE(cell.y, 3.)) { // camera target\n        vec3 res;\n        if (isInitial) {\n            res = getCameraTarget(true);\n        } else {\n            res = sampleCamTarget(iChannel0);\n            vec3 next = sampleCamTargetNext(iChannel0);\n            res += (next - res) * 0.2;\n        }\n        \n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 3.) && CLOSE(cell.y, 3.)) { // camera target to animate to\n        vec3 res;\n        \n        if (!isInitial && isToggled(iChannel1, KEY_W)) {\n            res = vec3(0., rTableHeight, 0.);\n        } else {\n            res = getCameraTarget(isInitial);\n        }\n        \n        fragColor = vec4(res, 1.);\n        return;\n    }\n    \n    // Write init flag\n    \n    if (CLOSE(cell.x, 1.) && CLOSE(cell.y, 2.)) {\n        fragColor = vec4(1.);\n        return;\n    }\n    \n    // Writing keyboard state\n    \n    if (CLOSE(cell.x, 3.) && CLOSE(cell.y, 2.)) { // Cue rotation\n        float res = isInitial ? 0.001 : sampleCueDir(iChannel0);\n        \n        if (!isInitial) {\n            if (isPressed(iChannel1, KEY_A)) {\n                res -= 0.003;\n            } else if (isPressed(iChannel1, KEY_D)) {\n                res += 0.003;\n            }\n        }\n        \n        fragColor = vec4(mod(res, 1.), 0., 0., 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 0.) && CLOSE(cell.y, 2.)) { // View rotation\n        float res = isInitial ? 0. : sampleRot(iChannel0);\n        \n        if (!isInitial) {\n            if (isPressed(iChannel1, KEY_RIGHT_ARROW)) {\n                res -= 0.007;\n            } else if (isPressed(iChannel1, KEY_LEFT_ARROW)) {\n                res += 0.007;\n            }\n        }\n        \n        fragColor = vec4(mod(res, 1.), 0., 0., 1.);\n        return;\n    }\n    \n    if (CLOSE(cell.x, 2.) && CLOSE(cell.y, 2.)) { // Hit power\n        vec2 res = isInitial ? vec2(0.) : sampleHitPowerRaw(iChannel0);\n\n        if (!isInitial) {\n            \n            vec2 ballVel = sampleVel(iChannel0, 0.).xy;\n            if (length(ballVel) <= EPS) {\n                if (isPressed(iChannel1, KEY_Q)) {\n                    res.x += 0.007;\n                    res.y = 1.;\n                } else if (res.y > EPS) {\n                    res.y = 0.;\n                } else if (res.x > EPS) {\n                    res.x = 0.;\n                }\n            }\n        }\n        \n        fragColor = vec4(mod(res.x, 1.), res.y, 0., 1.);\n        return;\n    }\n    \n    // Writing game state\n    \n    if (cell.y >= 2. || cell.x >= BALL_COUNT || cell.x < 0.) return;\n       \n    vec3 res = vec3(0.);\n    bool isVelocity = cell.y >= 1.;\n    float ballId = cell.x;\n    \n    vec3 curVel;\n    vec2 curPos;\n    if (!isInitial) {\n        curVel = sampleVel(iChannel0, ballId);\n        curPos = samplePos(iChannel0, ballId);\n    }\n    \n    if (isVelocity) {\n        if (isInitial) {\n            res = getInitialVel(ballId);\n        } else {\n            res = nextVel(ballId, curPos, curVel);\n        }\n        \n        res = res * 0.5 + 0.5;\n    } else {\n        if (isInitial) {\n            res.xy = getInitialPos(ballId);\n        } else {\n            res.xy = nextPos(curPos, curVel);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(res, 1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define EPS (0.0001)\n#define CLOSE(x, y) (abs(x - y) < EPS)\n\n#define GRID_SIZE (100.)\n#define GRID_CELL (1. / GRID_SIZE)\n#define GRID_HALF vec2(GRID_CELL * 0.5)\n\n#ifdef DEBUG_BALLS\n#define BALL_COUNT (2.)\n#define BALL_COUNT_I (2)\n#else\n#define BALL_COUNT (11.)\n#define BALL_COUNT_I (11)\n#endif\n\n#define BALL_RADIUS (0.015)\n#define BALL_M (BALL_RADIUS * BALL_RADIUS)\n#define BALL_ACCEL (0.98)\n#define HIT_DECCEL (0.95)\n\n#define TABLE_SIZE (vec2(1., 0.5))\n\n#define POCKET_RADIUS (BALL_RADIUS * 1.8)\n#define SP (POCKET_RADIUS)\n#define LP (POCKET_RADIUS * 1.14)\n#define BORDER_SIZE (POCKET_RADIUS)\n#define POCKET0 (vec2(LP))\n#define POCKET1 (vec2(0.5, 0.) * TABLE_SIZE + vec2(0., SP))\n#define POCKET2 (vec2(1., 0.)  * TABLE_SIZE + vec2(-LP, LP))\n#define POCKET3 (vec2(0., 1.)  * TABLE_SIZE + vec2(SP, -SP))\n#define POCKET4 (vec2(0.5, 1.) * TABLE_SIZE + vec2(0., -SP))\n#define POCKET5 (vec2(1., 1.)  * TABLE_SIZE - vec2(LP))\n#define SCORE_DIST (POCKET_RADIUS * 0.8)\n\n\nconst float rTableSize = 20.;\nconst float rTableHeight = 8.;\nconst float rTableHeightHalf = rTableHeight / 2.;\nconst float rBorderSize = BORDER_SIZE * rTableSize;\nconst float rTableThickness = 0.02 * rTableSize;\nconst float rTableThicknessHalf = rTableThickness / 2.;\nconst float rTableFooterHeight = 0.05 * rTableSize;\nconst vec3 rCueDim = vec3(0.007, 0.002, 0.3) * rTableSize;\nconst vec3 rTableZeroBase = vec3(\n    -TABLE_SIZE.x * rTableSize / 2., \n    0., \n    -TABLE_SIZE.y * rTableSize / 2.\n);\nconst float rBallRadius = rTableSize * BALL_RADIUS;\n\n\n// State accessors\n\nvec2 getGridCell(vec2 uv) {\n    vec2 scaled = uv * GRID_SIZE;\n    vec2 vertex = floor(scaled);\n    vec2 center = vertex + 0.5;\n    return distance(scaled, center) < 0.5 ? vertex : vec2(-1.);\n}\n\nvec4 sampleAtIndex(sampler2D tex, vec2 index) {\n    return texture(tex, index / GRID_SIZE + GRID_HALF);\n}\n\nbool sampleInitFlag(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(1., 2.)).x > 0.5;\n}\n\nvec2 sampleHitPowerRaw(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(2., 2.)).xy;\n}\n\nfloat sampleRot(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(0., 2.)).x;\n}\n\nvec2 samplePos(sampler2D tex, float ballId) {\n    return sampleAtIndex(tex, vec2(ballId, 0.)).xy;\n}\n\nvec3 sampleVel(sampler2D tex, float ballId) {\n    vec3 raw = sampleAtIndex(tex, vec2(ballId, 1.)).xyz;\n    return raw * 2. - 1.;\n}\n\nfloat sampleCueDir(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(3., 2.)).x;\n}\n\nvec3 sampleCamPos(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(0., 3.)).xyz;\n}\n\nvec3 sampleCamPosNext(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(1., 3.)).xyz;\n}\n\nvec3 sampleCamTarget(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(2., 3.)).xyz;\n}\n\nvec3 sampleCamTargetNext(sampler2D tex) {\n    return sampleAtIndex(tex, vec2(3., 3.)).xyz;\n}\n\nconst vec3 UP = vec3(0., 1., 0.);\n\nvec3 getInitialRD(vec2 vp, vec3 origin, vec3 target, float d) {\n    vec3 forward = normalize(target - origin);\n    vec3 right = normalize(cross(UP, forward));\n    vec3 up = cross(forward, right);\n    return normalize(d * forward + right * vp.x + up * vp.y);\n}\n\nfloat getCueAngle(float source) {\n    return source * 6.28;\n}\n\nvec2 getCueDir(float source) {\n    float angle = getCueAngle(source);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat getCueOffset(vec2 source) {\n    return abs(sin(source.x * 3.1415));\n}\n\nfloat getHitPower(vec2 source) {\n    if (source.x > EPS && source.y < EPS) {\n        return getCueOffset(source);\n    }\n    \n    return 0.;\n}\n\n// Quaternions\n\nstruct Quat { vec4 value; };\n\nQuat qCreateRotation(vec3 axis, float angle) {\n    float ah = angle / 2.;\n    return Quat(vec4(axis.xyz * sin(ah), cos(ah)));\n}\n\nvec3 qRotate(vec3 v, Quat q) {\n    vec3 temp = cross(q.value.xyz, v) + q.value.w * v;\n    return v + 2. * cross(q.value.xyz, temp);\n}\n\n// Keyboard helpers\n\n#define KEY_LEFT_ARROW (37.0)\n#define KEY_RIGHT_ARROW (39.0)\n#define KEY_Q (81.0)\n#define KEY_A (65.0)\n#define KEY_D (68.0)\n#define KEY_W (87.0)\n#define KEY_G (71.0)\n#define KEY_T (84.0)\n#define KEY_R (82.0)\n\nbool isPressed(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.25);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}\n\nbool isToggled(sampler2D tex, float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.75);\n    float key = texture(tex, uv).r;\n    return key > 0.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7df3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1396, 1396, 1435, 1435, 1528], [1530, 1530, 1569, 1569, 1600], [1602, 1602, 1631, 1631, 1726], [1728, 1728, 1771, 1771, 1866], [1868, 1868, 1903, 1903, 1934], [1936, 1936, 1993, 1993, 2314], [2316, 2316, 2399, 2399, 2895], [2909, 2909, 2947, 2947, 3731], [3733, 3733, 3773, 3773, 5641], [5660, 5660, 5708, 5708, 5917], [5919, 5919, 5952, 5952, 6212], [6214, 6214, 6300, 6300, 6753], [6755, 6755, 6821, 6821, 7202], [7233, 7233, 7316, 7316, 8212], [8214, 8214, 8274, 8274, 8922], [8924, 8924, 9001, 9001, 9314], [9316, 9316, 9370, 9370, 9520], [9531, 9531, 9580, 9580, 9991], [9993, 9993, 10046, 10046, 11374], [11376, 11376, 11433, 11433, 13316]], "test": "untested"}
{"id": "sdf3RN", "name": "Wobbly Ring", "author": "dh7892", "description": "A ring, and it wobbles", "tags": ["ring2d"], "likes": 4, "viewed": 255, "published": 3, "date": "1615570851", "time_retrieved": "2024-07-30T19:32:57.937395", "image_code": "\n// Try playing with these parameters\nfloat MAGNITUDE = 1.0/10.0; // How big the perturbation away from a sphere can get\nfloat SPEED = 0.8; // How fast the shape will evolve\nfloat RESOLUTION = 180.0 / 360.0; // Number of perturbations per 360 degrees\nfloat COL = 1.0; // Amount of colour to use\nfloat SMOOTH = 1.0; // Smmothness of perturbation\nfloat WOBBLE = 0.0; // Wobble!\n\n// Other constants\nfloat RADIUS = 0.3;\nvec2 CENTRE = vec2(0.5, 0.5);\nfloat BORDER_THICKNESS = 0.005;\nvec3 RED = vec3(1.0, 0.0, 0.0);\nvec3 BLUE = vec3(0.0, 0.0, 1.0);\nvec3 WHITE = vec3(1.0, 1.0, 1.0);\nvec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n\nfloat rand(float x, float time)\n{\n    float scale = (0.001 + WOBBLE) * mod(time, 1000.0) * 0.001;\n    return fract(sin(x + scale)*100000.0);\n}\n\nvec2 polar(vec2 uv)\n{\n    float r = distance(uv, CENTRE);\n    float theta = degrees(atan(uv.y, uv.x)) * RESOLUTION;\n    return vec2(r, theta);\n}\n\nfloat perturb(float time)\n{\n    return pow(sin(float(SPEED * time)), 2.0);\n}\n\nfloat smoothDist(vec2 uv, float time)\n{\n    // Return the distance from our wobbly ring at a time\n    float dist = distance(uv, CENTRE);\n    float theta = degrees(atan(uv.y, uv.x)) * RESOLUTION;\n    float diff = smoothstep(floor(theta), ceil(theta), theta);\n    \n    float dR = mix(rand(floor(theta), time), rand(ceil(theta), time), diff) * MAGNITUDE;\n    \n    return dist - (dR *perturb(time)) - RADIUS;\n}\n\n\n\nfloat stepDist(vec2 uv, float time)\n{\n    \n    float dist = distance(uv, CENTRE);\n    float theta = floor(degrees(atan(uv.y, uv.x)) * RESOLUTION);\n    \n    float dR = rand(theta, time) * MAGNITUDE;\n    \n    return dist - (dR * perturb(time)) - RADIUS;\n}\n\nfloat borderDist(vec2 uv, float time)\n{\n    return mix(stepDist(uv, time), smoothDist(uv, time), SMOOTH);\n}\n\nvec4 border(float dist)\n{\n    float border = step(BORDER_THICKNESS, abs(dist));\n        \n    vec3 borderColor = mix(BLACK, WHITE, border);\n    return vec4(borderColor, 1.0 - borderColor);\n}\n\n\nvec4 redArea(float dist)\n{    \n    vec4 borderColor = border(dist);\n\n    return mix(vec4(RED, 1.0), vec4(WHITE, 0.0), step(BORDER_THICKNESS,dist));    \n}\n\nvec4 blueArea(float dist)\n{    \n    vec4 borderColor = border(dist);\n\n    return mix(vec4(BLUE, 1.0), vec4(WHITE, 0.0), step(BORDER_THICKNESS,dist));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float bDist = borderDist(uv, float(iTime));\n    vec4 borderColor = border(bDist);\n    \n    float redDist = borderDist(uv, float(floor(iTime * 10.0)));\n    vec4 red = redArea(redDist);\n    \n    float blueDist = borderDist(uv, float(floor(iTime * 9.0)));\n    vec4 blue = blueArea(blueDist);\n    \n    vec4 col = mix(red, blue, 0.5);\n    col = mix(vec4(WHITE, 1.0), col, COL);\n\n    fragColor = mix(col, borderColor, borderColor.w);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdf3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[613, 613, 646, 646, 755], [757, 757, 778, 778, 901], [903, 903, 930, 930, 979], [981, 981, 1020, 1078, 1387], [1391, 1391, 1428, 1428, 1644], [1646, 1646, 1685, 1685, 1753], [1755, 1755, 1780, 1780, 1944], [1947, 1947, 1973, 1973, 2100], [2102, 2102, 2129, 2129, 2257], [2259, 2259, 2316, 2366, 2845]], "test": "untested"}
{"id": "Ndf3RN", "name": "Falling Apples", "author": "ryukent", "description": "Falling apples", "tags": ["apples"], "likes": 6, "viewed": 246, "published": 3, "date": "1615568218", "time_retrieved": "2024-07-30T19:32:58.752216", "image_code": "#define PI 3.14159265359\n\nvec3 disk(vec3 pixel, vec2 center, vec2 resolution, float radius, vec3 fillCol) {\n    vec2 d = resolution - center;\n\tif(length(d) < radius) {\n\t\tpixel = fillCol;\n\t}\n    return pixel;\n}\n\nvec3 disk2(vec3 pixel, vec2 center, vec2 resolution, float radius, vec3 fillCol) {\n    vec2 d = resolution - center;\n    float dist = abs(resolution.x - center.x);\n    vec3 newRed = vec3(0.7 + 1.2 * dist, 0.0, 0.0);\n\tif(length(d) < radius) {\n\t\tpixel = newRed;\n\t}\n    return pixel;\n}\n\n\nvec3 rect(vec3 pixel, vec2 center, vec2 resolution, float rectSize, vec3 fillCol) {\n    vec2 d = resolution - center;\n    float dist = abs(resolution.x - center.x);\n    fillCol -= dist;\n\tif (abs(center.x - resolution.x) < rectSize/2.0 && abs(center.y - resolution.y) < rectSize)\n    {\n\t\tpixel = fillCol;\n\t}\n    return pixel;\n}\n\nvec3 ellipse(vec3 pixel, vec2 center, vec2 resolution, float radius, vec3 fillCol) {\n    vec2 d = resolution - center;\n\tif(length(d * 2.1 + 0.1) < radius ) {\n\t\tpixel = fillCol;\n\t}\n    return pixel;\n}\n\n\nvec3 drawApple(vec3 pixel, vec2 center, vec2 resolution, float radius) {\n    \n    if (center.y < -1.0) {\n        center.y = -1.0;\n    }\n    \n    //Apple outline\n    vec3 colBlack = vec3(0.0,0.0,0.0);\n    pixel = disk(pixel, center, resolution, radius+0.01, colBlack);\n    \n    //Apple core\n    vec3 colBrown = vec3(0.6, 0.371, 0.298);\n\tvec3 colRed = vec3(1.00, 0.329, 0.298);\n    \n    pixel = disk2(pixel, center, resolution, radius, colRed);\n    \n    //Apple stalk\n    vec2 stalk = center;\n    stalk.y += (radius * 0.9) ;\n    float scaling = radius * 0.3;\n    pixel = rect(pixel, stalk, resolution, scaling, colBrown);\n    \n    // Apple leaf\n    vec3 colGreen = vec3(0.0, 1.0, 0.0);\n    pixel = ellipse(pixel, center+0.1, resolution, radius * sin(0.7), colGreen);\n    \n    return pixel;\n}\n\nvec3 drawTreeTrunk(vec3 pixel, vec2 resolution) {\n    vec3 colBrown = vec3(0.6, 0.371, 0.298);\n    colBrown *= 0.8;\n    resolution.y *= .5;\n    pixel = rect(pixel, vec2(0, 0), resolution, 0.5, colBrown);\n    return pixel;\n}\nvec3 drawTreeLeaves(vec3 pixel, vec2 resolution) {\n\tvec3 colGreen = vec3(0, 0.6, 0.298);\n    resolution.y *= 1.3;\n    pixel = disk(pixel, vec2(-0.6, 1.2), resolution, 0.6, colGreen);\n    colGreen *= 0.9;\n    pixel = disk(pixel, vec2(0.6, 1.2), resolution, 0.6, colGreen);\n    colGreen *= 0.9;\n    pixel = disk(pixel, vec2(0, 1.2), resolution, 0.7, colGreen);\n    return pixel;\n}\n\nvec3 drawBush(vec3 pixel, vec2 resolution) {\n\tvec3 colGreen = vec3(0, 0.6, 0.298);\n    resolution.y *= 1.3;\n    pixel = disk(pixel, vec2(-1.6, -1.2), resolution, 0.3, colGreen);\n    colGreen *= 0.9;\n    pixel = disk(pixel, vec2(-1.5, -1.2), resolution, 0.2, colGreen);\n    colGreen *= 0.9;\n    pixel = disk(pixel, vec2(1.8, -1.2), resolution, 0.3, colGreen);\n    colGreen *= 0.9;\n    pixel = disk(pixel, vec2(1.6, -1.2), resolution, 0.2, colGreen);\n    return pixel;\n}\n\nvec3 drawSun(vec3 pixel, vec2 resolution) {\n    vec3 colYellow = vec3(1.0, 1.0, abs(sin(iTime)) * 0.7);\n    pixel = disk(pixel, vec2(-1.7, 1.0), resolution, 0.4, colYellow);\n    return pixel;\n}\n\nvec3 drawCloud(vec3 pixel, vec2 resolution, vec2 position) {\n    resolution.y *= 1.3;\n    vec3 colWhite = vec3(1.0, 1.0, 1.0);\n    \n    pixel = disk(pixel, position, resolution, 0.3, colWhite);\n    position.x += 0.4;\n    pixel = disk(pixel, position, resolution, 0.3, colWhite);\n    position.x -= 0.2;\n    position.y += 0.2;\n    pixel = disk(pixel, position, resolution, 0.3, colWhite);\n    return pixel;\n}\n\nvec3 drawGrass(vec3 pixel, vec2 resolution) {\n\n\tvec3 colGreen = vec3(0, 0.6, 0.298);\n    for (float i = -1.8; i < 1.8; i = i + 0.1) {\n        pixel = rect(pixel, vec2(i,-0.95), resolution, 0.05, colGreen);\n    };\n    \n    return pixel;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    \n\tvec4 bgCol = vec4(\n        0.5 + fragCoord.xy.y / iResolution.y / 2.,\n        0.5 + fragCoord.xy.y / iResolution.y / 2.,\n        0.5 + fragCoord.xy.y / iResolution.y,\n        1.0\n    );\n\tvec3 pixel = vec3(bgCol.x, bgCol.y, bgCol.z);\n    \n    float maxTime = 10.0;\n    float timeOffset = maxTime / 3.0;\n    \n    float timer = mod(-iTime, maxTime) - 5.0;\n    \n    float speed1 = timer * 1.0;\n    float speed2 = timer * 1.2;\n    float speed3 = timer * 1.4;\n    \n    pixel = drawSun(pixel, r);\n    pixel = drawCloud(pixel, r, vec2(- speed1 - 0.2 + timeOffset, 0.6));\n    \n    pixel = drawTreeTrunk(pixel, r); \n    \n    pixel = drawApple(pixel, vec2(-0.8,speed1 + 0.2 - timeOffset), r, 0.1);\n    pixel = drawApple(pixel, vec2(0.8,speed2 + 0.4 - timeOffset), r, 0.12);\n    pixel = drawApple(pixel, vec2(0.0,speed3 + 0.6 - timeOffset), r, 0.15);\n    pixel = drawApple(pixel, vec2(0.6,speed1 + 0.8 - timeOffset), r, 0.11);\n    pixel = drawApple(pixel, vec2(-0.6,speed2 + 1.0 - timeOffset), r, 0.1);\n    pixel = drawApple(pixel, vec2(0.5,speed3 + 1.2 - timeOffset), r, 0.09);\n    pixel = drawApple(pixel, vec2(-0.4,speed3 + 1.4 - timeOffset), r, 0.12);\n    pixel = drawApple(pixel, vec2(0.7,speed3 + 1.6 - timeOffset), r, 0.11);\n    pixel = drawApple(pixel, vec2(-0.2,speed3 + 1.8 - timeOffset), r, 0.1);\n    \n    pixel = drawTreeLeaves(pixel, r); \n\n    \n    pixel = drawGrass(pixel, r); \n    pixel = drawBush(pixel, r); \n\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndf3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 107, 107, 209], [211, 211, 293, 293, 493], [496, 496, 579, 579, 822], [824, 824, 908, 908, 1023], [1026, 1026, 1098, 1098, 1815], [1817, 1817, 1866, 1866, 2040], [2041, 2041, 2091, 2091, 2419], [2421, 2421, 2465, 2465, 2889], [2891, 2891, 2934, 2934, 3084], [3086, 3086, 3146, 3146, 3492], [3494, 3494, 3539, 3539, 3731], [3734, 3734, 3791, 3791, 5315]], "test": "untested"}
{"id": "fsfGR4", "name": "stretching textures pixels", "author": "FabriceNeyret2", "description": "anisotropically stretched textures, keeping point texels.", "tags": ["effect"], "likes": 8, "viewed": 330, "published": 3, "date": "1615545816", "time_retrieved": "2024-07-30T19:32:59.556067", "image_code": "// Fork of https://shadertoy.com/view/NdfGR4\n// Fork of https://shadertoy.com/view/fdsGz8\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float L = iResolution.x/2.,\n          z = exp2(1.5*(cos(iTime)-1.));                        // stretching\n    U = mod(U,L) * z;                                           // stretched z\n    O-=O;\n    if ( max(fract(U.x),fract(U.y)) < z )                       // first pixel in a stretched texel\n        O =  texelFetch(iChannel0, ivec2(U) % textureSize(iChannel0,1).xy, 1 ); \n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 129, 129, 512]], "test": "untested"}
{"id": "7slGRH", "name": "Desolate Shores", "author": "Plento", "description": "Another visual experiment with noise. Lots of unexpected variation so let it run! :)", "tags": ["2d", "noise", "mouse", "terrain", "fbm", "color"], "likes": 22, "viewed": 491, "published": 3, "date": "1615531636", "time_retrieved": "2024-07-30T19:33:00.365901", "image_code": "\n// Cole Peterson\n\n// Noise and coloring experiment!\n\n#define R iResolution.xy\n\nvec3 t(vec2 p){\n    return texture(iChannel0, p).xyz;   \n}\n\nfloat height(vec2 p){\n    return t(p).r;\n}\n\nvec3 BumpedNormal(vec2 uv, float strength){\n    float h = 0.002;\n    \n    vec3 p = t(uv); \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R,\n    cuv =  vec2(u.xy - 0.5*R.xy)/R.y; \n    \n    vec3 lp = vec3(.4, .55, -1.0),\n    sp = vec3(cuv, 0.0),\n    ro = vec3(0, 0, -0.8),\n    rd = normalize(sp - ro),\n    ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    \n    float msk = texture(iChannel0, uv).w;\n    vec3 norm = BumpedNormal(uv, 11.0);\n  \t\n    float dif = max(dot(norm, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 16.); \n    float fal = 1.8 / (.8*dist*dist);\n    \n    vec3 col = (t(uv) * dif * fal) + (vec3(.8, .8, .9)*spec*.7 * msk);\n    \n    col = 1. - exp(-col);\n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    vec2 u = smoothstep(0., 1., f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat octnse(vec2 p, float t, int oct){\n    float a = 1.;\n    float n = 0.;\n    for(int i = 0; i < oct; i++){\n        p.y+=t;\n     \tn += perlin(p) * a * .5;\t\n        p*=2.;\n        a *= .5;\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = .35*vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv2 = u / R;\n    if(iMouse.z > 0.) uv += m*1.5;\n\n    uv.x += (iTime+6.)*.035 + 14.37;\n    uv.y += (iTime+6.)*.04 + 14.37;\n    \n    float n1 = 2.*octnse(uv*9., 0., 10) - 1. - .3,\n    n2 = 2.*octnse((uv+43.)*3., 0., 10) - 1.;\n    \n    float val = octnse((uv + vec2(n1, n2)*12.) * .45, 0., 8);\n    \n    vec3 col = vec3(val);\n    col += mix(vec3(.7, .3, .1)*.95, vec3(.2, .0, .8), n1) * n2 * .38;\n    col -= ss(.0, .2, n1) * .15;\n    col = col*col*col*col*col*1.6;\n    \n    float msk = ss(.0, 0.02, n2*n1 - .05);\n    msk -= ss(.0, 0.02, n2*n1 - .09);\n   \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), msk);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 95, 95, 138], [140, 140, 161, 161, 182], [184, 184, 227, 227, 454], [456, 456, 496, 496, 1129]], "test": "untested"}
{"id": "fdf3zn", "name": "Pretty Noisy Fireworks", "author": "kstyler", "description": "Oh my, these fireworks sure are noisy!", "tags": ["noise", "explosion", "fireworks", "boom"], "likes": 3, "viewed": 503, "published": 3, "date": "1615523787", "time_retrieved": "2024-07-30T19:33:01.142824", "image_code": "\nfloat circle(vec2 p, float r){\n    return smoothstep(.0,.04,length(p) - r);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat random(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * 20.1001);\n    p3 += dot(p3, p3.yzx + 300.3);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat explosion(vec2 p, float time){\n    vec2 dir = normalize(p);\n    float acc = -random(dir)/2.;\n    float friction = 0.8;\n    float timeRamping =  1.-pow(1.-time*1.5,5.);\n    vec2 pos = p+dir*acc*timeRamping*friction;\n    return circle(pos,.001)+time;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=2.5;\n    \n    float minium_value = 1.;\n    for(int i = 0; i < 10; i++){\n        minium_value = min(minium_value,\n        explosion(uv+vec2(cos(float(i))*1.,sin(float(i))*.5),\n        mod((iTime*.9)+float(i),1.6)));\n    }\n    vec3 col = vec3(minium_value);\n    col = 1.-col;\n    col*=vec3(sin(iTime*2.)+1.,cos(iTime*1.5)+1.,cos(iTime*4.)+1.)+1.5;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 78], [80, 120, 141, 141, 260], [262, 262, 298, 298, 521], [523, 523, 578, 578, 1025]], "test": "untested"}
{"id": "sss3R8", "name": "Fractal 39_gaz", "author": "gaz", "description": "i", "tags": ["fractal"], "likes": 13, "viewed": 453, "published": 3, "date": "1615514729", "time_retrieved": "2024-07-30T19:33:02.086301", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 q=vec3(2.6,2.8,2.1)+\n           vec3(cos(iTime*.6+.5*cos(iTime*.3))*.3,sin(iTime*.5)*.1,sin(iTime*1.2)*.2),\n    p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=0.;\n        ++i<80.;\n        O.xyz+=cos(vec3(9,3,4)+log(s))*5./dot(p,p)/i\n    )\n    {\n        p=g*d-vec3(0,-.6,2.2);\n        p=R(p,normalize(vec3(1,8,0)),-iTime*.15);\n        s=2.;\n        s*=e=6./dot(p,p);\n        p*=e;\n        for(int i=0;i++<2;)\n        {\n            p=q-abs(p-q);\n            s*=e=9./min(dot(p,p),6.);\n            p=abs(p)*e;\n        }\n        g+=e=min(length(p.xz)-.2,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 723]], "test": "untested"}
{"id": "fdX3zr", "name": "Exoplanet #2", "author": "Plento", "description": "Variation of: https://www.shadertoy.com/view/ttKBDd\nShould probably be using gamma correction but I like the current look too much.", "tags": ["3d", "mouse", "fbm", "sphere", "warp"], "likes": 13, "viewed": 511, "published": 3, "date": "1615509646", "time_retrieved": "2024-07-30T19:33:02.859235", "image_code": "\n// Cole Peterson\n\n// Different version of my planet thing here: https://www.shadertoy.com/view/ttKBDd\n\n\nvec4 sphere(vec3 ro, vec3 rd, vec3 cn, float r){\n    float b = 2.*dot(rd, ro - cn);\n    float c = dot(ro - cn, ro - cn) - (r*r);\n    float d = (b*b) - (4.*c);\n \t\n    if(d < 0.)\n        return vec4(0);\n    else{\n     \tfloat t = .5*(-b - sqrt(d));   \n        return vec4(ro+rd*t, t);\n    }\n}\n\nconst float rad = 2.;\nfloat camR = 4.35;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    float ang = iTime*.12 + 5.;\n    \n    if(iMouse.z > 0.){\n        camR -= m.y*6.;\n        ang += m.x;\n    }\n    \n    vec3 ro = vec3(camR*cos(ang), 0., camR*sin(ang));\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    ro.x = camR*cos(ang);\n    ro.z = camR*sin(ang);\n    rd.xz *= rot(ang + pi/2. + .04);\n    \n    vec3 ld = normalize(vec3(0.4, 0.3, -0.5)),\n    pp = vec3(0),\n    n = vec3(0),\n    cntr = vec3(0., 0., 0.),\n    col = vec3(0);\n    \n    vec4 p = sphere(ro, rd, cntr, rad);\n    \n    if(p.w > 0.){\n        pp = p.xyz;\n        n = pp - cntr;\n        n = normalize(n);\n        vec2 cuv = abs(vec2(atan(n.z, n.x), acos(p.y / rad))); \n        \n        float n1 = 2.*octnse(cuv, 10, 0.) - 1.;\n        float n2 = 2.*octnse((cuv+3.), 10, 0.) - 1.;\n        vec2 os = vec2(n1, n2);\n    \n        float v1 = octnse((cuv + vec2(n1, n2)*3.6), 9, 0.),\n              z = (v1-.33)*2.1 ; // v1 in [.33,.8], depth z in [0,1]\n        {\n            pp += .15*z*rd;      // parallax, then redo v1 texture calculation\n            n = pp - cntr;\n            n = normalize(n);\n            cuv = abs(vec2(atan(n.z, n.x), acos(p.y / rad))); \n            n1 = 2.*octnse(cuv, 10, 0.) - 1.;\n            n2 = 2.*octnse((cuv+3.), 10, 0.) - 1.;\n            os = vec2(n1, n2);\n\n            v1 = octnse((cuv + vec2(n1, n2)*3.6), 9, 0.);\n        }\n        float v2 = octnse((vec2(v1)*1.3 + os)*5., 9, 0.);\n        col = vec3(1) * v2*3. * vec3(.9, .8, .8);\n        col *= max(dot(n, -rd), 0.0)*vec3(.9, .8, .7) \n            * min(1.,1.5-1.1*z); // AO(depth)\n        \n        col = vec3(1) * v2*3. * vec3(.9, .8, .8);\n        col *= max(dot(n, -rd), 0.0)*vec3(.9, .8, .7);\n    }\n    else{\n        col += .55*ss(.3, .01, simplex3d(rd*160.));\n        col += .15*texture(iChannel0, rd).yzx;\n    }\n    \n    col = col*col*1.1;\n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nconst float pi = 3.14159;\n\n// Probably from Dave Hoshkin\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// FBM!\nfloat octnse(vec2 p, int oct, float t){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x += t;\n     \tn += perlin(p) * a *.5;\t\n        p*=2.;\n        a *= .5;\n    }\n    return n;\n}\n\n\n\n\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\n// For the stars\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n    \n     float nse = dot(d, vec4(52.));\n    \n     //return nse;\n\t return 1.-exp(-(nse+1.)*.5);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdX3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 153, 153, 394], [438, 438, 478, 478, 2361]], "test": "untested"}
{"id": "wlVyWG", "name": "FFT -  where the river flows 2", "author": "MaxGraph", "description": "I counldn't resist to merge these two amazing shaders. Where the River Goes by P_Malin https://www.shadertoy.com/view/Xl2XRW  and a modified version of Gijs Demo : Shadertoy Music Channel: https://www.shadertoy.com/view/4dc3zH", "tags": ["fft", "music", "piano", "soundcloud"], "likes": 16, "viewed": 691, "published": 3, "date": "1615498263", "time_retrieved": "2024-07-30T19:33:03.834628", "image_code": "#define FFT_GAIN 2.5;\n//#define FFT_CONTRAST_VIEW\n\nconst float Piano_height = .15;\nconst float Intensity_height = .03;\n\n//Post-processing options\nconst float Sharpness = 25.;\n\n//Blue Key : 261.6 Hz (Key 40,                Middle C)\n//Red  Key : 440   Hz (Key 49, First  A after Middle C)\n\nconst float ATone     = 0.0370;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\nconst float ATone2     = 0.0390;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\nconst float ATone3     = 0.0420;       //so 0.0370 texture space is 440Hz(found by trial-and-error)\n\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(int n){\n    return pow(Semitone,float(n-49))*440.;\n}\n\nfloat FrequencyToTexture(float Frequency){\n    if (Frequency>=300.0) {\n        return Frequency/440.*ATone;\n    } else if ((Frequency>=130.0) && (Frequency<300.0)) {\n        return Frequency/440.*ATone2;\n    } else{\n        return Frequency/440.*ATone3;\n    }\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat3 get_formants(int key){\n    float Frequency = KeyToFrequency(key);\n    float Frequency_up1 = KeyToFrequency(key+1);\n    float Frequency_up2 = KeyToFrequency(key+2);\n    float Frequency_down1 = KeyToFrequency(key-1);\n    float Frequency_down2 = KeyToFrequency(key-2);\n    float Frequency_over1 = KeyToFrequency(key+12);\n    float Frequency_over2 = KeyToFrequency(key+17);\n    float Frequency_lower1 = KeyToFrequency(key-12);\n\n    float Amplitude = texture(iChannel0,vec2(FrequencyToTexture(Frequency),.05)).x;\n    float Amplitude_up1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_up1),.05)).x;\n    float Amplitude_up2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_up2),.05)).x;\n    float Amplitude_down1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_down1),.05)).x;\n    float Amplitude_down2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_down2),.05)).x;\n    float Amplitude_over1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_over1),.05)).x;\n    float Amplitude_over2 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_over2),.05)).x;\n    float Amplitude_lower1 = texture(iChannel0,vec2(FrequencyToTexture(Frequency_lower1),.05)).x;\n\n    float Perceived = log(1. + Amplitude*Amplitude*1.)*.3;\n    float Perceived_up1 = log(1. + Amplitude_up1*Amplitude_up1*1.)*.3;\n    float Perceived_up2 = log(1. + Amplitude_up2*Amplitude_up2*1.)*.3;\n    float Perceived_down1 = log(1. + Amplitude_down1*Amplitude_down1*1.)*.3;\n    float Perceived_down2 = log(1. + Amplitude_down2*Amplitude_down2*1.)*.3;\n    float Perceived_over1 = log(1. + Amplitude_over1*Amplitude_over1*1.)*.3;\n    float Perceived_over2 = log(1. + Amplitude_over2*Amplitude_over2*1.)*.3; \n    float Perceived_lower1 = log(1. + Amplitude_lower1*Amplitude_lower1*1.)*.3; \n    return mat3(vec3(Amplitude, Perceived, Perceived_up1),\n                vec3(Perceived_up2, Perceived_over1,Perceived_over2),\n                vec3(Perceived_down1, Perceived_down2, Perceived_lower1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        vec3 Color = vec3(0.0);\n        vec3 color2 = vec3(0.0);\n\t\tvec2 Scaled     = fragCoord.xy/iResolution.xy;\n        #ifdef RIVER_BACKGROUND\n        Color = texture(iChannel1,Scaled.xy).rgb;\n        #else\n        Color = hsv2rgb_smooth((0.25+vec3(0.45*Scaled.y)));\n        #endif\n    //Piano\n        int   Key       = 1+int(Scaled.x*87.);//1 to 88 (full piano)\n        int   Note      = Key%12;//A to G(Octave)\n\n    //Sound\n\n    \n    //Music Visualization\n      //vec3  Color     = vec3(Amplitude/(Scaled.y-Piano_height));\n      //vec3  Color     = vec3(.01/abs(Scaled.y-Piano_height-Amplitude));\n      //vec3  Color     = vec3(0.4,0.3,0.7)*smoothstep(0.01,0.,Scaled.y-Piano_height-Perceived);\n      //vec3  Color     = vec3(Amplitude);\n      //vec3  Color     = vec3(Amplitude-Scaled.y+Piano_height);\n      mat3 formants = get_formants(Key);\n      float amp = formants[0].x;\n      float org = formants[0].y;\n      float up1 = formants[0].z;\n      float up2 = formants[1].x;\n      float over1 = formants[1].y;\n      float over2 = formants[1].z;\n      float down1 = formants[2].x;\n      float down2 = formants[2].y;\n      float lower1 = formants[2].z;\n      \n      vec3 amp3 = vec3(smoothstep(0.0,1.0,1.0-amp),0.75,0.75);\n      float perceived_color = org*FFT_GAIN;\n      color2 = 1.95*hsv2rgb_smooth((amp3))*smoothstep(0.01,0.,Scaled.y-Piano_height-perceived_color*0.85)-Intensity_height;\n            \n      \n      float threshold = 1.0-0.75*cos(fragCoord.x*0.0075-0.75);\n    //Piano Drawing\n        bool second_filter = false;\n        bool octave_filter = false;\n        if (Key>=40){\n            second_filter =(org>up1+org*0.05*Scaled.x/4.0)&&(org>down1+org*0.05*Scaled.x/4.0)&&(org>0.05);\n        } else {\n            second_filter =(org>up1)&&(org>down1);\n        }\n        if (Key>=60){\n            octave_filter =(org>over1+org*0.8*Scaled.x/4.0)&&(org>over2+org*0.8*Scaled.x/4.0)&&(org>lower1+org*0.8*Scaled.x/4.0)&&(over1>0.06);\n        } else if (Key>=40){\n            octave_filter =(org>over1+org*0.2*Scaled.x/4.0)&&(org>over2+org*0.2*Scaled.x/4.0)&&(org>lower1+org*0.2*Scaled.x/4.0)&&(over1>0.06);\n        } else {\n            octave_filter = (org>over1+org*0.1*Scaled.x/4.0)&&(org>over2+org*0.1*Scaled.x/4.0)&&(over1>0.04);\n        }\n        if(Scaled.y<Piano_height){\n            //white keys\n            Color = vec3(1);\n\n            //black keys\n            if(Note==0||Note==2||Note==5||Note==7||Note==10){\n                if ((Scaled.y<Piano_height)&&(Scaled.y>Piano_height/4.0)){\n                    Color = vec3(.1);\n                } else {\n                    Color = vec3(1.);\n                }\n            }\n\n            //special keys\n            if (second_filter && octave_filter) {\n                vec3 rgb_color = hsv2rgb_smooth(vec3(amp,1.0,amp));\n                //Color = rgb_color;\n                if(Note==0||Note==2||Note==5||Note==7||Note==10){\n                    if ((Scaled.y<Piano_height)&&(Scaled.y>Piano_height/4.0)){\n                        Color = rgb_color;\n                    } else {\n                        Color = vec3(1.);\n                    }\n                } else {\n                    Color = rgb_color;\n                }\n            }\n            //if(Key==40) Color = vec3(.5, .5, 1.);\n            //if(Key==49) Color = vec3(1., .5, .5);\n        } else if (Scaled.y<Intensity_height+Piano_height){\n            if (second_filter && octave_filter) {\n                Color = vec3(.5, .5, 1.0);\n            } else {\n                Color = vec3(.2, .2, .7);\n            }\n        } else {\n            //if (Key==60){\n            //    Color = max(0.5*Color,0.5*color2);\n            //}\n            if (second_filter && octave_filter){\n                Color = max(Color,color2);\n            } else {\n                #ifdef FFT_CONTRAST_VIEW\n                Color = max(Color,0.5*color2);\n                #else\n                Color = max(Color,color2);\n                #endif\n            }\n        }\n\n        //float threshold = 1.0-0.75*cos(fragCoord.x*0.0075-0.75);\n        //Color += vec3(threshold);\n\tfragColor = vec4(Color,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25316, "src": "https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Where the River Goes\n// @P_Malin\n\n// What started as a hacked flow and advection experiment turned into something nice.\n\n// Placeholder audio https://www.youtube.com/watch?v=gmar4gh5nIw suggested by @qthund on twitter\n\n//#define ENABLE_ULTRA_QUALITY\n\n#define ENABLE_WATER\n//#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n//#define ENABLE_CONE_STEPPING\n\n\n// Textureless version\n//#define ENABLE_NIMITZ_TRIANGLE_NOISE\n\n//#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n//#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#if defined(ENABLE_SCREENSHOT_MODE) || defined(ENABLE_ULTRA_QUALITY)\n#define ENABLE_SUPERSAMPLE_MODE\n#endif\n\n#ifndef ENABLE_SCREENSHOT_MODE\n#ifdef ENABLE_ULTRA_QUALITY\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 6;\nconst int k_superSampleCount = 6;\n#else\nconst int k_raymarchSteps = 64;\nconst int k_fmbSteps = 3;\n#endif\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 5;\nconst int k_superSampleCount = 10;\n#endif\n\nconst int k_fmbWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t//return fract(sin(n)*43758.5453);\n}\n\nvec2 Hash2( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    //flow *= 0.6;\n    for( int i=0; i<k_fmbWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 / (1.0 + fDist * 1.5);\n    vFlow *= 1.0 / (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    //vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;// - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    //fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    //fFoam = fFoam / fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); // flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) / fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    //weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); // represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG / fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        // into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n// https://www.shadertoy.com/view/4ts3z2\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat triNoise(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += dg;\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n           \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}    \n#endif\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal +triNoise(vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );    \n#else\n    #if 0\n    surface.m_albedo = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 _sample;\n    _sample = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    col += _sample * _sample * vWeights.y;\n    _sample = texture( iChannel0, intersection.m_pos.xy ).rgb;\n    col += _sample * _sample * vWeights.z;\n    _sample = texture( iChannel0, intersection.m_pos.yz ).rgb;\n    col += _sample * _sample * vWeights.x;\n    col /= vWeights.x + vWeights.y + vWeights.z;\n    surface.m_albedo = col;\n    #endif\n#endif    \n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t//vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            // lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); // note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            // add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif // #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n\n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n    \n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir);\n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    return vResult;\n}\n\n// Code from https://www.shadertoy.com/view/ltlSWf \nvoid BlockRender(in vec2 fragCoord)\n{\n    const float blockRate = 15.0;\n    const float blockSize = 64.0;\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef RIVER_BACKGROUND\n    g_fTime = iTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    BlockRender( fragCoord.xy );\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t// Static camera locations\n    //fCameraTime = 146.0; // some rocks\n    \n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 / iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 / iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n#ifndef ENABLE_SUPERSAMPLE_MODE\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n#else\n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n    for(int i=0; i<k_superSampleCount; i++)\n    {\n        g_fTime = fBaseTime + (fTot / 10.0) / 30.0;\n        vec3 vCurrRayDir = vRayDir;\n        vec3 vRandom = vec3( SmoothNoise( fragCoord.xy + fTot ), \n                        SmoothNoise( fragCoord.yx + fTot + 42.0 ),\n                        SmoothNoise( fragCoord.xx + fragCoord.yy + fTot + 42.0 ) ) * 2.0 - 1.0;\n        vRandom = normalize( vRandom );\n        vCurrRayDir += vRandom * 0.001;\n        vCurrRayDir = normalize(vCurrRayDir);\n    \tvResult += GetSceneColour(vRayOrigin, vCurrRayDir);\n        fTot += 1.0;\n    }\n    vResult /= fTot;\n#endif    \n    \n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);\n    #else\n    fragColor = vec4(vec3(0.0), 1.0);\n    #endif\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RIVER_BACKGROUND\n\n// the river flows in you: https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you\n// bach - praeludium: https://soundcloud.com/neilbalfour/prelude-no-1-in-c-major-j-s", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 698, 726, 726, 771], [773, 773, 815, 815, 1034], [1036, 1036, 1070, 1070, 1248], [1250, 1250, 1277, 1277, 3226], [3228, 3228, 3284, 3284, 7376]], "test": "untested"}
{"id": "fdsGz8", "name": "stretching white vs blue noise", "author": "FabriceNeyret2", "description": "anisotropically stretched white noise is still white noise.\nnot true for blue noise.\n( Obvious in the Fourier Spectrum, but seeing it in point space is interesting ).", "tags": ["bluenoise", "anisotropic", "statistics"], "likes": 14, "viewed": 351, "published": 3, "date": "1615495765", "time_retrieved": "2024-07-30T19:33:04.706297", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float L = iResolution.x/2.,\n          z = exp2(1.5*(cos(iTime)-1.)),                                // stretching\n          x = mod(U.x,L) * z;                                           // stretched z\n    O-=O;\n    if ( fract(x) < z )                                                 // first pixel in a stretched texel\n        O = vec4( ( U.x < L \n                      ? texelFetch(iChannel0, ivec2(x,U.y)% 256, 0 ).r  // left: white noise\n                      : texelFetch(iChannel1, ivec2(x,U.y)%1024, 0 ).r  // right: blue noise\n                  ) > .98 );\n                  \n    if( int(U.x) == int(L) ) O.r++;                                     // separator\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 711]], "test": "untested"}
{"id": "ssf3zH", "name": "Voxel Game raytraced", "author": "me_123", "description": "based off [SH16C] Voxel Game ([url]https://www.shadertoy.com/view/MtcGDH[/url]), i changed the main image of buffer D. and some other minor tweeks. to if the image is to noisy, change line 160 buffer D.", "tags": ["minecraft"], "likes": 18, "viewed": 1597, "published": 3, "date": "1615491269", "time_retrieved": "2024-07-30T19:33:05.908083", "image_code": "/* \nVoxel Game\nfb39ca4's SH16C Entry\n\nThis was an attempt to make something like Minecraft entirely in\nShadertoy. The world around the player is saved in a buffer, and as long\nas an an area is loaded, changes remain. However, if you go too far\naway, blocks you have modified will reset. To load more blocks, go to \nfullscreen to increase the size of the buffers. I tried to implement\nmany of the features from Minecraft's Creative mode, but at this point,\nthis shader is more of a tech demo to prove that interactive voxel games\nare possible.\n\nFeatures:\n    Semi-persistent world\n    Flood-fill sky and torch lighting\n    Smooth lighting and ambient occlusion\n    Day/Night cycle\n    Movement with collision detection\n    Flying and sprinting mode\n    Block placment and removal\n    Hotbar to choose between: Stone, Dirt, Grass, Cobblestone, Glowstone, \n        Brick, Gold, Wood\n    \nControls:\n    Click and drag mouse to look, select blocks\n    WASD to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n    Q + mouse button to place block\n    E + mouse button to destroy blocks\n    Z/X to cycle through available blocks for placement\n    0-8 to choose a block type for placement\n    Page Up/Down to increase or decrease render resolution\n    O,P to decrease/increase speed of day/night cycles\n\n\tThere are #defines in Buffer A to change the controls.\n\nTODO:\n Voxel Raycaster\n Free camera controls\n Store map in texture\n Infinite World\n Persistent World\n Sky Lighting\n Torch Lighting\n Smooth Lighting, Ambient Occlusion\n Vertical Collision Detection\n Walking, Jumping\n Horizontal collision detection\n Textures\n Proper world generation\n Block picking\n Adding/Removing blocks\n GUI for block selection\n Sun, Moon, Sky\n Day/Night Cycle\n Double jump to fly, double tap forwards to run\n*/\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\nfloat keyToggled(int keyCode) {\n\treturn textureLod(iChannel1, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[2].xy, 0.0);\n}\n\nconst float numItems = 8.;\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawGui(vec2 c) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * numItems) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {\n        float slot = floor(c.x / 16.);\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\nconst vec2 packedChunkSize = vec2(11,6);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n    vec2 renderResolution = ceil(iResolution.xy / scaleFactor)/2.0; \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    vec4 gui = drawGui(fragCoord);\n    fragColor = mix(fragColor, gui, gui.a);\n    \n    vec3 pos = load(_pos).xyz;\n        \n    if (bool(keyToggled(114))) {\n        if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        fragColor = mix( fragColor, vec4(1,1,0,1), PrintValue(fragCoord, vec2(0.0, 5.0), vec2(8,15), iTimeDelta, 4.0, 1.0));\n        fragColor = mix( fragColor, vec4(1,0,1,1), PrintValue(fragCoord, vec2(0.0, 25.0), vec2(8,15), load(_time).r, 6.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 4.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yyxx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 4.0, 5.0));\n        \n    }\n\t\n    //fragColor = texture(iChannel0, fragCoord / 2. / iResolution.xy);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_DECREASE_RESOLUTION 34\n#define KEY_INCREASE_RESOLUTION 33\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_INVENTORY_NEXT 88\n#define KEY_INVENTORY_PREVIOUS 90\n#define KEY_INVENTORY_ABSOLUTE_START 49\n\nconst float PI = 3.14159265359;\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy), 0.0);\n}\n\nbool inBox(vec2 coord, vec4 bounds) {\n\treturn coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\n\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n\tif (inBox(currentCoord, vec4(coord, 1., 1.))) {\n    \toutValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n\treturn textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n\tbool now = bool(keyDown(keycode));\n    bool previous = bool(textureLod(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nfloat calcLoadDist(void) {\n\tvec2 chunks = floor(iResolution.xy / packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange(vec2 pos) {\n\tvec2 d = calcLoadDist() * vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n\treturn float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\n    \nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 9; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n            \tfragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iResolution.xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n        \t}\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = (iMouse / length(iResolution.xy))*2.0;\n\t\t\t\tfloat renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n\n                if (iFrame == 0) {\n                    pos = vec3(0,0,52);\n                    angle = vec2(-0.75,2.5);\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = 0.;\n                    time = vec2(0,4);\n                    selected = 0.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0.) {\n                    angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1);\n                    angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                /*move += dir * (keyDown(87)-keyDown(83));\n                move += dirU * (keyDown(68) - keyDown(65));\n                move += vec3(0,0,1) * (keyDown(82) - keyDown(70));*/\n\n                float inBlock = 0.;\n                float minHeight = 0.;\n                vec3 vColPos, hColPos;\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                        + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                        + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                        > .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n                float maxHeight = heightLimit - 1.8;\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                if (getVoxel(vColPos - offset + vec3(0,0,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(0,1,0)).id * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                    + getVoxel(vColPos - offset + vec3(1,0,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                    + getVoxel(vColPos - offset + vec3(1,1,0)).id * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                    > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;\n                }\n                float minX = pos.x - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    minX = hColPos.x + 1.301;\n                }\n                float maxX = pos.x + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,0)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,1)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,1,2)).id * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    maxX = hColPos.x - .301;\n                }\n                            float minY = pos.y - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    minY = hColPos.y + 1.301;\n                }\n                float maxY = pos.y + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));\n                if (getVoxel(hColPos - offset + vec3(0,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,0)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,1)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(0,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + getVoxel(hColPos - offset + vec3(1,0,2)).id * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    maxY = hColPos.y - .301;\n                }\n                                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.;\n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n                    \n                if (bool(keySinglePress(KEY_FORWARDS))) {\n\t\t\t\t\tif (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\t\t\t\t\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    else {\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\t\t\t\t\n                \n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                if (iMouse.z > 0.) {\n                    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n                    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * iResolution.y / iResolution.x;\n                    vec2 screenPos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n                    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n                    rayCastResults res = rayCast(pos + vec3(0,0,1.6), rayDir, offset);\n                    if (res.dist <= 5.) {\n                        pick.xyz = res.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(vec2(0,9),pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += res.normal;\n                            timer += dt / 0.3;\n                        }\n                \t\tif (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                else {\n                    pick = vec4(-1,-1,-1,0);\n                    timer = 0.;\n                }\n\t\t\t\t\n                const int numItems = 8;\n                selected += keyPress(KEY_INVENTORY_NEXT) - keyPress(KEY_INVENTORY_PREVIOUS);\n                for (int i = 0; i < 9; i++) {\n                \tif (bool(keyPress(KEY_INVENTORY_ABSOLUTE_START + i))) selected = float(i);   \n                }\n\t\t\t\tselected = mod(selected, float(numItems));\n                \n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_RESOLUTION) - keySinglePress(KEY_INCREASE_RESOLUTION), 0., 4.);\n\t\t\t\ttime.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n\t\t\t\ttime.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange, calcLoadRange(pos.xy));\n                store4(_mouse, mouse);\n                store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                fragColor = outValue;\n            }\n        }\n        else fragColor = texture(iChannel0, (fragCoord - _old) / iResolution.xy);\n    }\n    else fragColor.rgb = vec3(0,0,0);\n}\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy));\n}\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n//\n// Description : Array and textureless GLSL 2D,3D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\nfloat calcLoadRange(void) {\n\tvec2 chunks = floor(iResolution.xy / packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 readMapTex(vec2 pos) {\n \treturn texture(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy);   \n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nstruct voxel {\n\tfloat id;\n    float sunlight;\n    float torchlight;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n    return density > 0.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset);            \n    \n    voxel vox;\n    vec4 range = load(_old+_loadRange);\n    vec4 pick = load(_pick);\n    if (!inRange(voxelCoord.xy, range) || iFrame == 0 ) {\n    \tbool solid = overworld(voxelCoord);\n        if (solid) {\n            vox.id = 3.;\n            if (overworld(voxelCoord + vec3(0,0,1))) vox.id = 2.;\n            if (overworld(voxelCoord + vec3(0,0,3))) vox.id = 1.;\n    \t\tif (hash13(voxelCoord) > 0.98 && !overworld(voxelCoord + vec3(0,0,-1))) vox.id = 6.;\n        }\n        if (snoise(voxelCoord / 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z))) vox.id = 0.;\n        if (voxelCoord.z < 1.) vox.id = 16.;\n        vox.hue = fract(hash13(voxelCoord));\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    else {\n    \tvox = getVoxel(voxelCoord - oldOffset);\n    }\n\n    if (voxelCoord == pick.xyz) {\n        if (pick.a == 1. && load(_pickTimer).r > 1. && vox.id != 16.) vox.id = 0.;\n        if (pick.a == 2.) vox.id = getInventory(load(_selectedInventory).r);\n    }\n    \n    voxel temp;\n    if (voxelCoord.z == heightLimit - 1.) {\n    \tvox.sunlight = 15.;   \n    }\n    else vox.sunlight = 0.;\n    vox.torchlight = 0.;\n    //if (length(voxelCoord + .5 - load(_pos).xyz) < 1.) vox.torchlight = 15.;\n    if (voxelCoord.z < heightLimit - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.z > 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,0,-1) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x > range.x + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(-1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.x < range.y - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(1,0,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y > range.z + 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,-1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    if (voxelCoord.y < range.w - 1.) {\n    \ttemp = getVoxel(voxelCoord + vec3(0,1,0) - oldOffset);\n        vox.sunlight = max(vox.sunlight, temp.sunlight - 1.);\n        vox.torchlight = max(vox.torchlight, temp.torchlight - 1.);\n    }\n    \n    if (vox.id > 0.) {\n        vox.sunlight = 0.;\n        vox.torchlight = 0.;\n    }\n    \n    if (vox.id == 6.) {\n    \tvox.torchlight = 15.;   \n    }\n    fragColor = encodeVoxel(vox);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 0, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy));\n}\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec4 noiseTex(vec2 c) {\n\treturn texture(iChannel1, c / iChannelResolution[1].xy);   \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat signed(float x) {\n\treturn x * 2. - 1.;   \n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\treturn 1.0 - d;// ...Bubbles.\n}\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n    return clamp(texture(iChannel1, (p/30.)).x/(floor(t*4.)*0.25), 0.0, 1.0);//pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn texture(iChannel2, (c + gridPos * 16.) / iChannelResolution[3].xy);\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    \n    vec2 gridPos = floor(fragCoord / 16.);\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 16.);\n    o.a = 1.;\n    if (id == 0) {\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) {\n        o.rgb = 0.45 + 0.2 * vec3(noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)) * 3. - 1.), 0.)).b);\n    }\n    if (id == 2) {\n    \to.rgb = vec3(0.55,0.4,0.3) * (1. + 0.3 * signed(noiseTex(c + 37.).r));\n        if (hash12(c * 12.) > 0.95) o.rgb = vec3(0.4) + 0.2 * noiseTex(c + 92.).g;\n    }\n    if (id == 3) {\n    \to.rgb = getTexture(2., c).rgb;\n        if (noiseTex(vec2(0, c.x) + 12.).a * 3. + 1. > 16. - c.y) o.rgb = getTexture(4., c).rgb;\n    }\n    if (id == 4) {\n    \to.rgb = hsv2rgb(vec3(0.22, .8 - 0.3 * noiseTex(c + 47.).b, 0.6 + 0.1 * noiseTex(c + 47.).b));\n    }\n    if (id == 5) {\n    \to.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.))*vec3(0.3, 0.1, 1.0);\n    }\n    if (id == 6) {\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) {\n    \to.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) {\n        o.rgb = vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c)) * (1. + 0.2 * noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)))) * 3. - 1.).b);\n    }\n    if (id == 16) {\n      \to.rgb = (-1. + 2. * getTexture(1., c).rgb) * 2.5;\n    }\n    if (id == 32) {\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) {\n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}", "buffer_c_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "const float PI = 3.14159265359;\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 8, varRow);\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_old, 0, 1);\n\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = storageCoord;\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nconst vec2 packedChunkSize = vec2(12,7);\n\nvec4 readMapTex(vec2 pos) {\n \treturn textureLod(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy, 0.0);   \n}\n\nvec2 voxToTexCoord(vec3 p) {\n \tp = floor(p);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\nbool getHit(vec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = readMapTex(voxToTexCoord(p)).r;\n\treturn d > 0.5;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 16.), floor(id / 16.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[3].xy, 0.0);\n}\n\n\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nstruct voxel {\n\tfloat id;\n    vec2 light;\n    float hue;\n};\n\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.light.s = floor(mod(textel.g, 16.));\n    o.light.t = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvoxel getVoxel(vec3 p) {\n    return decodeTextel(readMapTex(voxToTexCoord(p)));\n}\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(vec2 light) {\n    light = 15. - light;\n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\treturn id > .5 ? 1. : 0.;   \n}\n\nvec3 calcLightingFancy(vec3 r, vec3 s, vec3 t, vec2 uv) {\n\tvoxel v1, v2, v3, v4, v5, v6, v7, v8, v9;\n    //uv = (floor(uv * 16.) + .5) / 16.;\n    v1 = getVoxel(r - s + t);\n    v2 = getVoxel(r + t);\n    v3 = getVoxel(r + s + t);\n    v4 = getVoxel(r - s);\n    v5 = getVoxel(r);\n    v6 = getVoxel(r + s);\n    v7 = getVoxel(r - s - t);\n    v8 = getVoxel(r - t);\n    v9 = getVoxel(r + s - t);\n    \n    //return vec3(uv, 0.) - .5 * opaque(v6.id);\n    \n    vec2 light1, light2, light3, light4, light;\n    light1 = max24(v1.light, v2.light, v4.light, v5.light);\n    light2 = max24(v2.light, v3.light, v5.light, v6.light);\n    light3 = max24(v4.light, v5.light, v7.light, v8.light);\n    light4 = max24(v5.light, v6.light, v8.light, v9.light);\n    \n    float ao1, ao2, ao3, ao4, ao;\n    ao1 = vertexAo(opaque(v2.id), opaque(v4.id), opaque(v1.id));\n    ao2 = vertexAo(opaque(v2.id), opaque(v6.id), opaque(v3.id));\n    ao3 = vertexAo(opaque(v8.id), opaque(v4.id), opaque(v7.id));\n    ao4 = vertexAo(opaque(v8.id), opaque(v6.id), opaque(v9.id));\n    \n    light = mix(mix(light3, light4, uv.x), mix(light1, light2, uv.x), uv.y);\n    ao = mix(mix(ao3, ao4, uv.x), mix(ao1, ao2, uv.x), uv.y);\n    \n    return lightmap(light) * pow(ao, 1. / 1.);\n}\n\nvec3 calcLightingFast(vec3 r, vec3 s, vec3 t, vec2 uv) {\n    return lightmap(min(getVoxel(r).light + 0.2, 15.));\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n};\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset, vec4 range) {\n\tvec3 mapPos = floor(rayPos);\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 rayStep = sign(rayDir);\n    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n    vec3 mask;\n    bool hit = false;\n    for (int i = 0; i < 50; i++) {\n\t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += vec3(mask) * rayStep;\n\t\t\n        if (!inRange(mapPos.xy, range) || mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;\n        if (getHit(mapPos - offset)) { \n            hit = true; \n            break;\n        }\n\n\t}\n    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n    if (abs(mask.x) > 0.) {\n        uv = endRayPos.yz;\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = endRayPos.xz;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = endRayPos.xy;\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,1,0);\n    }\n    uv = fract(uv);\n    rayCastResults res;\n    res.hit = hit;\n    res.uv = uv;\n    res.mapPos = mapPos;\n    res.normal = -rayStep * mask;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    res.rayPos = endRayPos;\n    res.dist = length(rayPos - endRayPos);\n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    float t = load(_time).r;\n    float lightLevel = lightLevelCurve(t);\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    vec3 sunDir = vec3(cos(sunAngle), 0, sin(sunAngle));\n    \n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.3333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nbool rayTracing = true ;\nfloat s = 200.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x < (iResolution.x/2.) && fragCoord.y < iResolution.y/2.) { \n        float scaleFactor = pow(sqrt(2.), load(_renderScale).r);\n        vec2 renderResolution = (iResolution.xy/2.)+sin(iTime);//ceil(iResolution.xy / scaleFactor); \n        if (any(greaterThan(fragCoord, renderResolution))) {\n            fragColor = vec4(0);\n            return;\n        }\n        vec2 screenPos = (fragCoord.xy / renderResolution.xy) * 2.0 - 1.0;\n        screenPos += hash(screenPos)/(iResolution.xy);\n        vec3 rayPos = load(_pos).xyz + vec3(0,0,1.6);\n        vec2 angle = load(_angle).xy;\n        vec4 range = load(_loadRange);\n        vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n        vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n        vec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\n        vec3 mapPos = vec3(floor(rayPos));\n        vec3 offset = vec3(floor(load(_pos).xy), 0.);\n        vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\n        vec3 rayStep = vec3(sign(rayDir));\n\n        vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\n        vec3 mask;\n\n        mapPos;\n        if (iMouse.z > 0.01) {\n            rayTracing = false;\n        }\n        if (rayTracing) {\n        vec3 color = vec3(1);\n        vec3 ro = rayPos;\n        vec3 rd = rayDir;\n        for (int i = 0; i < 10; i += 1) {\n            rayCastResults r = rayCast(ro, rd, offset, range);\n            voxel vox = getVoxel(r.mapPos - offset);\n            if (!r.hit) {\n                color *= skyColor(rd);\n                break;\n            }\n\n            float textureId = vox.id;\n            ro = r.rayPos;\n            if (textureId == 8.) {\n                vec3 target = r.rayPos + r.normal + rus(rd.xy+float(i)+(fragCoord.xy/iResolution.xy)+sin(iTime));\n                vec3 rdd = target - r.rayPos;\n                rd = mix(reflect(rd, r.normal), rdd, 0.05);\n            } else {\n                vec3 target = r.rayPos + r.normal + rus(rd.xy+float(i)+(fragCoord.xy/iResolution.xy)+sin(iTime));\n                rd = target - r.rayPos;\n            }\n            if (textureId == 3.) textureId += r.normal.z;\n            color *= getTexture(textureId, r.uv).rgb;\n            if (textureId == 6.) {color *= 10.; break;};\n            if (textureId == 5.) {color *= 20.; break;};\n        }\n        if (iMouse.z < 0.01) {\n            fragColor = ((texture(iChannel3, fragCoord.xy/iResolution.xy)*s) + vec4(color, 1))/(s+1.0);\n        } else {\n            fragColor = vec4(color, 1);\n        }\n        } else {\n                rayCastResults res = rayCast(rayPos, rayDir, offset, range);\n\n        vec3 color = vec3(0);\n        voxel vox = getVoxel(res.mapPos - offset);\n        if (res.hit) {\n\n            color = calcLightingFancy(res.mapPos - offset + res.normal, res.tangent, res.bitangent, res.uv);\n            color *= hsv2rgb(vec3(getVoxel(mapPos + .5 - offset).hue, .1, 1));\n            float textureId = vox.id   ;\n            if (textureId == 3.) textureId += res.normal.z;\n            color *= getTexture(textureId, res.uv).rgb;\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else color = mix(color, vec3(1), 0.2);\n            }\n            //color.rgb = res.uv.xyx;\n        }\n        else color = skyColor(rayDir);\n        fragColor.rgb = pow(color, vec3(1.));\n        }\n        //fragColor.rgb = color;\n    }\n    \n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssf3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2405, 2405, 2428, 2428, 2521], [4148, 4148, 4180, 4180, 4221], [4223, 4223, 4258, 4258, 4400], [4430, 4430, 4461, 4461, 4683], [4685, 4685, 4704, 4704, 4796], [4798, 4798, 4820, 4820, 6274], [6370, 6370, 6427, 6427, 7738]], "test": "untested"}
{"id": "NsXGz8", "name": "font zoom explorer", "author": "zzggbb", "description": "top right shows characters using the x channel of the font image (antialiased bitmap data)\nbottom right shows characters using the w channel of the font image (distance field data)", "tags": ["font", "texfont", "fontpage"], "likes": 6, "viewed": 488, "published": 3, "date": "1615458284", "time_retrieved": "2024-07-30T19:33:06.770777", "image_code": "/*\nThis is a demo of the new font texture. \nIt has a distance field and gradients in the texture.\nRed channel:   Antialiased font if you just want something simple and easy to use.\nGreen channel: x gradient of distance field.\nBlue channel:  y gradient of distance field.\nAlpha channel: distance field.\n\nThe characters that are encoded are the characters from the first 8 bits of unicode (aka Latin-1 codepage).\nThat includes ASCII. In the blanks, there are symbols that seemed useful for shadertoy. Math symbols,\ngreek letters, play/pause controls, arrows, musical notes, and some others.\n\nThe distance field lets you use the font for ray marching. Since the texture didn't have enough precision\nfor a clean distance field, nice smooth gradients have been put in the green/blue channels to get smooth edges.\n\nSometimes you might see some artifacts in the font edges when you look from an angle. To fix those,\nthe ray marching would have to pause at the boundary between each letter since the distance field is\nnot continuous between letters. That would complicate this code a bit, so it was left out.\n*/\n\n#define R iResolution.xy\n\nfloat linscale(float x, float x1, float x2, float y1, float y2){\n    return (y2-y1)/(x2-x1)*(x-x2) + y2;\n}\n\nvoid mainImage(out vec4 color, in vec2 xy){\n    float R_min = min(R.x, R.y);\n    float R_max = max(R.x, R.y);\n    \n    vec2 uv = (xy - 0.5*R)/R_min + 0.5;\n    vec2 muv = (iMouse.xy - 0.5*R)/R_min + 0.5;\n    float uv_max = 0.5*R_max/R_min + 0.5;\n    float uv_min = uv_max - R_max/R_min;\n    /*\n                   1.0\n        __________________________\n       |       |    |    |        |\n       |       |    |    |        |\n     uv_min   0.0  0.5  1.0     uv_max\n       |       |    |    |        |\n       |       |    |    |        |\n       |__________________________|\n                   0.0\n       |------ R_max/R_min -------|\n    */\n    \n    float c = 0.0;\n    float blur = 0.04;\n    \n    vec2 st_legend = vec2(uv.x - uv_min, uv.y);\n    float d = texture(iChannel0, st_legend).w;\n    c += 1.0 - smoothstep(0.5-blur, 0.5+blur, d);\n    \n    vec2 st_pixelated = vec2(\n        linscale(muv.x, uv_min, uv_min+1.0, 0.0, 1.0),\n        muv.y\n    );\n    float zoom = 1.0/9.0;\n    float cpx = (uv_min+1.0+uv_max)*0.5;\n    \n    if (uv.y>0.5 && uv.x>cpx-0.25 && uv.x<cpx+0.25){\n        vec2 offset = uv - vec2(cpx, 0.75);\n        c += texture(iChannel0, st_pixelated + offset*zoom).x;\n    }\n    \n    if (uv.y<0.5 && uv.x>cpx-0.25 && uv.x<cpx+0.25){\n        vec2 offset = uv - vec2(cpx, 0.25);\n        float d = texture(iChannel0, st_pixelated + offset*zoom).w;\n        c += 1.0 - smoothstep(0.5-blur, 0.5+blur, d);      \n    }\n    \n    color = vec4(vec3(c),1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1131, 1131, 1195, 1195, 1237], [1239, 1239, 1282, 1282, 2694]], "test": "untested"}
{"id": "NsX3RH", "name": "Lunar Buggy", "author": "dr2", "description": "Drive the buggy; try to stay on the marked path; wheel tracks remain on ground (temporarily)", "tags": ["moon", "path", "car", "drive", "nasa", "vehicle", "trajectory"], "likes": 23, "viewed": 550, "published": 3, "date": "1615457884", "time_retrieved": "2024-07-30T19:33:07.723230", "image_code": "// \"Lunar Buggy\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Drive the buggy; try to stay on the marked path; wheel tracks remain on ground (temporarily).\n\n/*\n  Knob controls speed and direction (overrides randomized auto mode); mouseable;\n  view direction is either relative to buggy, or to ground at high elevation;\n  on-path distance shown.\n  \n  (Bits from \"Segway Driving\", \"Drive The Rover\", \"Moon Flight\".)\n*/\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int npTrail = 512;  // same for image and buffer\nconst int npFst = 6;\n\nvec3 sunDir, qHit, carPos, wlBase;\nvec2 wlRot;\nfloat dstFar, tCur, wlRad, carRot, strRot, hgSize, trWidf;\nint idObj;\nbool isSh;\nconst int idBase = 1, idArch = 2, idWhl = 3, idCon = 4, idAxl = 5, idStr = 6, idChr = 7,\n   idAnt = 8, idDish = 9, idCam = 10, idGrbl = 11;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 kRot;\n  float dMin, d, r, a;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (wlRad + 0.02, wlBase.z);\n  dMin = dstFar;\n  q = p;\n  if (! isSh) d = PrRoundBoxDf (q, vec3 (2., 2.5, 2.5), 0.03);\n  if (isSh || d < 0.1) {\n    d = PrRoundBoxDf (q, vec3 (1.2, 0.03, 1.2), 0.03);\n    d = min (d, PrRoundBoxDf (q, vec3 (0.7, 0.03, wlBase.z + 0.2), 0.03));\n    d = min (d, PrTorusBxDf ((q - vec3 (0., 0.06, 0.)).xzy, vec3 (1.1, 1.1, 0.05), 0.03));\n    DMINQ (idBase);\n    q = p;\n    q.xz = abs (q.xz) - wlBase.xz;\n    q.xy -= vec2 (0.13, -0.2);\n    d = SmoothMax (abs (length (q.xy) - wlRad - 0.58) - 0.025, max (max (q.x, 0.2 - q.y), abs (q.z) - 0.2), 0.01);\n    q.xy -= vec2 (-0.13, 1.07);\n    d = min (d, PrCylDf (q.xzy, 0.08, 0.1));\n    DMINQ (idArch);\n    q = p;\n    q.xz = abs (q.xz) - wlBase.xz;\n    if (p.z > 0.) q.xz = Rot2D (q.xz, - strRot * sign (p.x));\n    q.yz = Rot2D (q.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n    r = length (q.yz);\n    d = length (max (vec2 (r - wlRad, abs (q.x) - 0.1) - 0.1, 0.));\n    if (d < 0.1) {\n      d = max (length (max (vec2 (r - wlRad, abs (q.x) - 0.15), 0.)) - 0.05, wlRad - 0.02 - r);\n      a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n      d = SmoothMax (d, 0.03 - length (Rot2D (q.yz, 2. * pi * floor (24. * a + 0.5) / 24.) +\n         vec2 (wlRad + 0.05, 0.)), 0.01);\n      d = min (d, max (abs (r - wlRad + 0.04) - 0.02, abs (q.x) - 0.07));\n      q.yz = Rot2D (q.yz, 2. * pi * floor (6. * a + 0.5) / 6.);\n      d = min (d, max (PrTorusBxDf (q - vec3 (0., -0.31, 0.), vec3 (0.08, 0.05, 0.1), 0.02), - q.x));\n      d = min (d, min (max (abs (r - 0.15) - 0.03, abs (q.x) - 0.15), max (r - 0.12, abs (q.x) - 0.12)));\n      DMINQ (idWhl);\n    } else dMin = min (dMin, d);\n    q = p;\n    q -= vec3 (-0.4, 0.4, 1.);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.4, 0.03), 0.05);\n    q.y -= 0.45;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.25, 0.07, 0.03), 0.05));\n    DMINQ (idCon);\n    q = p;\n    q.xz = abs (q.xz) - wlBase.xz;\n    if (p.z > 0.) q.xz = Rot2D (q.xz, - strRot * sign (p.x));\n    q.y -= 0.85;\n    d = PrCapsDf (q.xzy, 0.04, 0.18);\n    q.y -= -0.5;\n    d = min (d, max (PrTorusBxDf (q, vec3 (0.2, 0.2, 0.12), 0.04), q.x));\n    DMIN (idAxl);\n    q = p;\n    q -= vec3 (-0.4, 0.73, 0.7);\n    q.yz = Rot2D (q.yz, -0.1 * pi);\n    q.xy = Rot2D (q.xy, -2.5 * strRot);\n    d = PrCylDf (q, 0.05, 0.3);\n    q.z -= -0.3;\n    d = min (d, PrRoundCylDf (q.yzx, 0.03, 0.02, 0.35));\n    DMINQ (idStr);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.4, 0.4, -0.2);\n    d = PrRoundBoxDf (q, vec3 (0.35, 0.05, 0.3), 0.02);\n    q.z -= -0.25;\n    q.yz = Rot2D (q.yz, 0.1 * pi);\n    q.y -= 0.3;\n    d = min (d, PrRoundBoxDf (q, vec3 (0.35, 0.3, 0.05), 0.02));\n    DMINQ (idChr);\n    q = p;\n    q -= vec3 (-0.3, 0.7, - wlBase.z + 0.2);\n    q.z = abs (q.z) - 0.1;\n    d = PrCylDf (q.xzy, 0.02, 0.6);\n    DMIN (idAnt);\n    q = p;\n    q -= vec3 (0.5, 1., - wlBase.z - 0.1);\n    d = PrCylDf (q.xzy, 0.02, 1.);\n    DMIN (idAnt);\n    q.y -= 1.;\n    q.xy = Rot2D (q.xy, 0.1 * pi);\n    q.y -= 0.47;\n    d = max (abs (PrSphDf (q, 0.5)) - 0.01, q.y + 0.25);\n    DMINQ (idDish);\n    q = p;\n    q.yz -= vec2 (0.9, wlBase.z + 0.15);\n    q.xz = Rot2D (q.xz, 0.3 * pi * sin (0.15 * pi * tCur));\n    q.yz = Rot2D (q.yz, -0.05 * pi);\n    d = PrCapsDf (q, 0.1, 0.1);\n    DMINQ (idCam);\n    q = p;\n    q.xz = abs (q.xz);\n    q -= vec3 (0.9, 0.05, 0.3);\n    d = PrTorusBxDf (q.yzx, vec3 (0.06, 0.08, 0.03), 0.02);\n    DMIN (idGrbl);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.4, 0.2, -0.2);\n    q.xz = abs (q.xz) - 0.2;\n    d = PrCylDf (q.xzy, 0.05, 0.2);\n    DMIN (idGrbl);\n    q = p;\n    q.xz = abs (q.xz);\n    q -= vec3 (0.3, 0.1, 1.6);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.1, 0.2), 0.02);\n    DMIN (idGrbl);\n    q = p;\n    q.x = abs (abs (q.x) - 0.6);\n    q -= vec3 (0.3, 0.1, -0.9);\n    d = PrRoundCylDf (q.xzy, 0.1, 0.05, 0.1);\n    DMIN (idGrbl);\n    q = p;\n    q.yz -= vec2 (0.05, 0.6);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.05, 0.2), 0.02);\n    DMIN (idGrbl);\n    q.z = abs (q.z);\n    q.yz -= vec2 (0.25, 0.1);\n    d = PrRoundCylDf (q.xzy, 0.01, 0.02, 0.15);\n    DMINQ (idStr);\n    q = p;\n    q.yz -= vec2 (0.4, wlBase.z + 0.1);\n    d = PrCylDf (q.xzy, 0.03, 0.4);\n    DMIN (idGrbl);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  float r;\n  if (idObj <= idAxl) {\n    if (idObj == idBase) {\n      col4 = vec4 (0.8, 0.85, 0.8, 0.1) * (1. - 0.05 * step (0.03, qHit.y) * cos (16. * pi * qHit.z));\n    } else if (idObj == idArch) {\n      col4 = vec4 (0.8, 0.4, 0.2, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (abs (qHit.z) - 0.13) - 0.01));\n    } else if (idObj == idWhl) {\n      r = length (qHit.yz);\n      col4 = vec4 (((r > 0.115) ? vec3 (0.95, 0.95, 1.) * (1. - 0.5 * step (0.47, r)) :\n         vec3 (0., 0.5, 0.) * (0.3 + 0.7 * smoothstep (0., 0.02, r - 0.05))), 0.);\n    } else if (idObj == idCon) {\n      col4 = vec4 (0.8, 0.8, 0.4, 0.1) * (1. - 0.5 * step (qHit.z, 0.) * (1. - smoothstep (0., 0.02,\n         length (vec2 (abs (qHit.x) - 0.15, qHit.y)) - 0.04)));\n    } else if (idObj == idAxl) {\n      col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n    }\n  } else {\n    if (idObj == idStr) {\n      col4 = vec4 (0.8, 0.8, 1., 0.2) * (1. - 0.5 * smoothstep (0., 0.02, abs (qHit.x) - 0.15));\n    } else if (idObj == idChr) {\n      col4 = vec4 (0.8, 0.6, 0.4, 0.) * (0.8 + 0.2 * cos (4. * pi * qHit.x / 0.35));\n    } else if (idObj == idAnt) {\n      col4 = vec4 (0.5, 0.5, 0.5, 0.1);\n    } else if (idObj == idDish) {\n      col4 = vec4 (0.8, 0.8, 0.6, 0.2) * (1. - 0.3 * smoothstep (0., 0.02,\n         abs (mod (16. * atan (qHit.x, qHit.z) / (2. * pi) + 0.5, 1.) - 0.5) - 0.35));\n    } else if (idObj == idCam) {\n      col4 = mix (vec4 (0.2, 0.2, 0.2, 0.), vec4 (0.9, 0.7, 0.5, 0.1), (1. - step (0., qHit.z) *\n         smoothstep (0., 0.01, 0.095 - length (qHit.xy))));\n    } else if (idObj == idGrbl) {\n      col4 = vec4 (0.5, 0.7, 0.5, 0.1);\n    }\n  }\n  return col4;\n}\n\nfloat TrailShd (vec2 p)\n{\n  vec3 u;\n  vec2 gB[2], gF[2], dg, q;\n  float st, s, gLen;\n  st = 1.;\n  gB[0] = carPos.xz;\n  gF[0] = gB[0] + Rot2D (vec2 (0., 2. * wlBase.z), - carRot);\n  for (int j = VAR_ZERO; j < npTrail; j ++) {\n    gB[1] = gB[0];\n    gF[1] = gF[0];\n    u = Loadv4 (npFst + j).xyz;\n    if (u.z >= 0.) {\n      gB[0] = u.xy;\n      gF[0] = gB[0] + Rot2D (vec2 (0., 2. * wlBase.z), - u.z);\n      s = 1.;\n      dg = gB[0] - gB[1];\n      gLen = length (dg);\n      if (gLen > 0.) {\n        q = Rot2Cs (p - 0.5 * (gB[0] + gB[1]), dg.yx / gLen);\n        s = min (s, PrRoundBox2Df (vec2 (abs (q.x) - wlBase.x, q.y), vec2 (0.1, 0.5 * gLen), 0.05));\n      }\n      for (float k = -1.; k <= 1.; k += 2.) {\n        dg = gF[0] - gF[1];\n        gLen = length (dg);\n        if (gLen > 0.) {\n          s = min (s, PrRoundBox2Df (Rot2Cs (p - 0.5 * (gF[0] + gF[1]) +\n             Rot2D (vec2 (k * wlBase.x, 0.), - u.z), dg.yx / gLen), vec2 (0.1, 0.5 * gLen), 0.05));\n        }\n      }\n      st = min (st, 1. - 0.3 * sqrt (1. - float (j) / float (npTrail)) *\n         (1. - smoothstep (0., 0.05, s)));\n    } else break;\n  }\n  return st;\n}\n\nvec3 GrndCol (vec3 ro, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  vec2 vf, q;\n  vec2 gId;\n  float a, f, ff, st;\n  gId = PixToHex (ro.xz / hgSize);\n  q = Rot2D ((ro.xz - HexToPix (gId * hgSize)) / hgSize, (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  col = 0.8 * mix (vec3 (0.7, 0.6, 0.4), vec3 (0.6, 0.5, 0.3), smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n  f = abs (length (q) - 0.5) - trWidf;\n  if (f < 0.) {\n    a = abs (mod (4. * (mod (15. * atan (q.y, - q.x) / (2. * pi), 1.) - 0.5) + 0.5, 1.) - 0.5) - 0.3;\n    for (float s = 1.; s >= 0.; s -= 1.) {\n      col = mix (vec3 (0.4, 0.6, 1.), col, max (smoothstep (0., 0.02, a - 0.03 * s),\n         smoothstep (0., 0.002, abs (f + 0.02) - 0.005)));\n    }\n  }\n  st = TrailShd (ro.xz);\n  ff = 1. - smoothstep (0.1, 0.3, dstGrnd / dstFar);\n  vf = vec2 (2., 1.) * (1. + 2. * step (st, 0.99));\n  vn = vec3 (0., 1., 0.);\n  if (ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) * (0.3 + 0.7 * st);\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, 0.06, 1.));\n  erRad = 0.03;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  bool isBg;\n  isBg = false;\n  isSh = false;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = CarCol ();\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  } else {\n    isBg = true;\n    col = ErCol (rd);\n  }\n  if (! isBg) {\n    isSh = true;\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    if (dstObj < dstFar) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    else col = GrndCol (ro, dstGrnd, sh) * (1. - smoothstep (0.5, 1., dstGrnd / dstFar));\n  }\n  if (min (dstObj, dstGrnd) >= dstFar || length (col) < 0.03) col += StarPat (rd, 6.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 rd, ro, col, wgBox;\n  vec2 canvas, uv, ud, cnPos;\n  float el, az, asp, zmFac, onPath, trvDist, s, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  stDat = Loadv4 (2);\n  hgSize = stDat.x;\n  trWidf = stDat.y;\n  onPath = stDat.z;\n  trvDist = stDat.w;\n  stDat = Loadv4 (3);\n  az = stDat.x;\n  el = stDat.y;\n  cnPos = stDat.zw;\n  stDat = Loadv4 (4);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  stDat = Loadv4 (5);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  el = clamp (el, -0.45 * pi, 0.02 * pi);\n  if (el > -0.37 * pi) az += carRot;\n  vuMat = StdVuMat (el, az);\n  ro = carPos + vec3 (Rot2D (vec2 (0., wlBase.z), - carRot), 0.).xzy + vuMat * vec3 (0., 2., -10.);\n  zmFac = 3. + 1.85 * el;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  wgBox = vec3 (0.41, -0.32, 0.135);\n  ud = 0.5 * uv - wgBox.xy * vec2 (asp, 1.);\n  s = (length (ud) - wgBox.z) * canvas.y;\n  col = mix (vec3 (0.5), col, smoothstep (0., 1., abs (s) - 1.));\n  if (s < 0.) {\n    col = mix (vec3 (0.5), col, step (1., Minv2 (abs (ud)) * canvas.y));\n    col = mix (((onPath > 0.) ? vec3 (0., 1., 0.) : vec3 (0.8, 0., 0.)), col,\n       smoothstep (2.5, 3.5, abs (length (ud - cnPos) * canvas.y - 10.)));\n  }\n  col = mix (col, vec3 (0., 1., 0.), ShowIntPZ (0.5 * uv - vec2 (0.44 * asp, -0.15),\n     vec2 (0.06 * asp, 0.03), 4., mod (floor (trvDist / (2. * wlRad)), 1e4)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Lunar Buggy\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Noiseff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int npTrail = 512;  // same for image and buffer\nconst int npFst = 6;\n\nvec3 carPos, wlBase;\nfloat carRot, hgSize, trWidf;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat OnPath ()\n{\n  vec2 q, gId;\n  q = carPos.xz + Rot2D (vec2 (0., wlBase.z), - carRot);\n  gId = PixToHex (q / hgSize);\n  q = Rot2D ((q - HexToPix (gId * hgSize)) / hgSize,\n     (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  return (abs (length (q) - 0.5) < trWidf) ? 1. : 0.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBox;\n  vec2 iFrag, canvas, cnPos, wlRot, cp, ud, w;\n  float tCur, autoMd, cRotN, strRot, wlRad, rTurn, spd, onPath, trvDist, tc, nStep,\n     az, el, asp, s;\n  int pxId, wgSel, nFrame;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= npFst + npTrail) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  init = (nFrame <= 5);\n  asp = canvas.x / canvas.y;\n  if (init) {\n    mPtrP = mPtr;\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlRad = 0.5;\n    wlBase = vec3 (1.6, wlRad, 1.8);\n    wlRot = vec2 (0.);\n    az = 0.;\n    el = -0.1 * pi;\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    wgSel = 0;\n    autoMd = 1.;\n    hgSize = 40.;\n    trWidf = 0.12;\n    onPath = 0.;\n    trvDist = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    autoMd = stDat.w;\n    stDat = Loadv4 (2);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    onPath = stDat.z;\n    trvDist = stDat.w;\n    stDat = Loadv4 (3);\n    az = stDat.x;\n    el = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (4);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n    stDat = Loadv4 (5);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n  }\n  if (pxId < npFst) {\n    wgBox = vec3 (0.41, -0.32, 0.135);\n    if (mPtr.z > 0.) {\n      if (wgSel == 0 && mPtrP.z > 0.) {\n        az = -2.5 * pi * mPtr.x;\n        el = - pi * mPtr.y;\n      } else {\n        ud = mPtr.xy * vec2 (asp, 1.) - wgBox.xy * vec2 (asp, 1.);\n        if (wgSel == 1) {\n          autoMd = - tCur;\n          cnPos = ud;\n          s = length (cnPos);\n          if (s > 0.) cnPos = min (s, wgBox.z) * cnPos / s;\n        } else if (mPtrP.z <= 0. && length (ud) < wgBox.z) wgSel = 1;\n      }\n    } else {\n      wgSel = 0;\n      cnPos *= 1. - 5e-3;\n    }\n    wlRad = wlBase.y;\n    ++ nStep;\n    if (autoMd > 0.) {\n      tc = 0.005 * nStep;\n      s = 2. * Noiseff (37.1 * mod (floor (tc), 16.)) - 1.;\n      s = max (0.3, abs (s)) * sign (s);\n      strRot = 0.15 * pi * s * SmoothBump (0.2, 0.8, 0.1, mod (tc, 1.));\n      spd = 0.12 - 0.06 * abs (strRot / (0.15 * pi));\n      w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n      w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n      cnPos = w * wgBox.z;\n    } else {\n      w = cnPos / wgBox.z;\n      w = pow (abs (w), vec2 (1.5)) * sign (w);\n      strRot = -0.18 * pi * w.x;\n      spd = 0.2 * w.y;\n      if (tCur + autoMd > 10.) autoMd = 1.;\n    }\n    cp = carPos.xz;\n    w = vec2 (1.);\n    if (abs (strRot) > 1e-4) {\n      cRotN = carRot - strRot * spd / pi;\n      rTurn = wlBase.z / asin (0.5 * strRot);\n      carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n      carRot = mod (cRotN, 2. * pi);\n      w += vec2 (-1., 1.) * wlBase.x / rTurn;\n    } else {\n      carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n    }\n    wlRot += w * spd / wlRad;\n    if (pxId == 2) {\n      onPath = OnPath ();\n      if (onPath > 0.) trvDist += length (carPos.xz - cp);\n      else trvDist = 0.;\n    }\n  }\n  if (! init) {\n    if (mod (float (nFrame), 6.) == 0.) {\n      if (pxId == npFst) stDat = vec4 (Loadv4 (5).xzw, 0.);\n      else if (pxId < npFst + npTrail) stDat = Loadv4 (pxId - 1);\n    } else if (pxId >= npFst && pxId < npFst + npTrail) stDat = Loadv4 (pxId);\n  } else {\n    stDat = vec4 (0., 0., -1., 0.);\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (wlBase, autoMd);\n  else if (pxId == 2) stDat = vec4 (hgSize, trWidf, onPath, trvDist);\n  else if (pxId == 3) stDat = vec4 (az, el, cnPos);\n  else if (pxId == 4) stDat = vec4 (nStep, strRot, wlRot);\n  else if (pxId == 5) stDat = vec4 (carPos, carRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsX3RH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1776, 1776, 1798, 1798, 6091], [6093, 6093, 6126, 6126, 6373], [6375, 6375, 6396, 6396, 6653], [6655, 6655, 6692, 6692, 6935], [6937, 6937, 6953, 6953, 8598], [8600, 8600, 8625, 8625, 9729], [9731, 9731, 9780, 9780, 10844], [10846, 10846, 10881, 10881, 11334], [11336, 11336, 11358, 11358, 11841], [11843, 11843, 11878, 11878, 12790], [12808, 12808, 12864, 12864, 14854], [14856, 14856, 14902, 14902, 14949], [14951, 14951, 14998, 14998, 15045], [15047, 15047, 15080, 15080, 15107], [15109, 15109, 15151, 15151, 15202], [15204, 15204, 15261, 15261, 15337], [15339, 15339, 15382, 15382, 15455], [15457, 15457, 15503, 15503, 15584], [15586, 15586, 15610, 15610, 15840], [15842, 15842, 15866, 15866, 15926], [15928, 15928, 15950, 15950, 15977], [15979, 15979, 16001, 16001, 16028], [16030, 16030, 16052, 16052, 16090], [16092, 16092, 16137, 16137, 16240], [16242, 16242, 16287, 16287, 16325], [16327, 16327, 16363, 16363, 16569], [16571, 16571, 16601, 16601, 16714], [16716, 16716, 16747, 16747, 16811], [16813, 16813, 16836, 16836, 16938], [17011, 17011, 17043, 17043, 17591], [17593, 17593, 17655, 17655, 18037], [18071, 18071, 18095, 18095, 18155], [18157, 18157, 18181, 18181, 18311], [18313, 18313, 18338, 18338, 18524], [18526, 18526, 18547, 18547, 18702], [18704, 18704, 18733, 18733, 18945], [18947, 18947, 18986, 18986, 19166], [19260, 19260, 19285, 19285, 19408]], "test": "untested"}
{"id": "fdfGR8", "name": "Fractal 38_gaz", "author": "gaz", "description": "inspired : https://twitter.com/zozuar/status/1369637083430744068", "tags": ["fractal"], "likes": 8, "viewed": 489, "published": 3, "date": "1615441483", "time_retrieved": "2024-07-30T19:33:08.561988", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 q=vec3(3,3,.0),\n    p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<99.;\n        O.xyz+=cos(vec3(7,6,9)/log(s*.2))*.02\n    )\n    {\n        p=g*d-vec3(.4,.1,.8);\n        p=R(p,normalize(vec3(1,2,3)),-iTime*.1);\n        s=2.;\n        for(int i=0;\n            i++<7;\n            p=q-abs(p-q*.4)\n        )\n            s*=e=15./min(dot(p,p),15.),\n            p=abs(p)*e-2.;\n        g+=min(10.,length(p.xz)-.5)/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.5,3.6,.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 628]], "test": "untested"}
{"id": "sssGzn", "name": "Stateful", "author": "oneshade", "description": "An interesting music driven idea. Music reference taken from this shader: [url=https://www.shadertoy.com/view/tdsXDX]https://www.shadertoy.com/view/tdsXDX[/url]", "tags": ["2d", "fft", "reactive", "audio", "particles", "buffers", "stateful"], "likes": 7, "viewed": 302, "published": 3, "date": "1615415738", "time_retrieved": "2024-07-30T19:33:09.527406", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 wrap(in vec2 p, in vec2 rmin, in vec2 rmax) {\n   return rmin + mod(p - rmin, rmax - rmin);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFrame > 0 && iFragCoord.x < FFT_PARTICLES && iFragCoord.y == 0) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        float freq = fragCoord.x / float(FFT_PARTICLES);\n\n        if (iFrame > 1) fragColor.xy = fragColor.zw;\n\n        float fft = texture(iChannel1, vec2(freq, 0.0)).x;\n        fragColor.zw += sin(fft * 6.28 - 3.14 + vec2(1.57, 0.0)) * iTimeDelta;\n\n        bool outOfBounds = any(greaterThan(abs(fragColor.zw), corner));\n        fragColor.zw = wrap(fragColor.zw, -corner, corner);\n        if (outOfBounds) fragColor.xy = fragColor.zw;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26070, "src": "https://soundcloud.com/plaid/tether-wyg-e-remix", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "#define rgb(r, g, b) vec3(r, g, b) / 255.0\n\n// Palette from https://www.color-hex.com/color-palette/26292\n// Perhaps there is a better one?\n// Added first color at end for a wraparound\nvec3[] palette = vec3[](rgb(  0, 137, 123),\n                        rgb(  0,  86,  77),\n                        rgb( 40,  40,  40),\n                        rgb( 54,  54,  54),\n                        rgb(150, 150, 150),\n                        rgb(  0, 137, 123));\n\nvec3 getColor(in float t) {\n    t = fract(t) * float(palette.length() - 1);\n    return mix(palette[int(t)], palette[int(t) + 1], smoothstep(0.0, 1.0, fract(t)));\n}\n\nvec2 sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float d = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return vec2(length(pa - ba * d), d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    for (int i=0; i < FFT_PARTICLES; i++) {\n        vec4 pos = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 line = sdLine(uv, pos.xy, pos.zw);\n        vec3 color = mix(getColor(iTime - iTimeDelta), getColor(iTime), smoothstep(0.0, 1.0, line.y));\n        fragColor = mix(fragColor, vec4(color, 1.0), exp(-50.0 * line.x));\n    }\n\n    fragColor *= 0.9;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define FFT_PARTICLES 50", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "7sfGRr", "name": "Raytraced Volume", "author": "oneshade", "description": "Based on demofox's [url=http://demofox.org/TextureSamplerVolume.html]texture sampler volume[/url]\nPracticing more integration to do some volumetric shading (not physically based).", "tags": ["raytracing", "volume", "trilinear", "analytic", "integration"], "likes": 7, "viewed": 197, "published": 3, "date": "1615408914", "time_retrieved": "2024-07-30T19:33:10.293358", "image_code": "#define BSPHERE 4.0 // Bounding sphere radius\n#define LIGHT -rd\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 info = vec3(0.0);\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        info[0] =  (root - b) / denom;\n        info[1] = -(root + b) / denom;\n        info[2] = 2.0;\n    }\n\n    return info;\n}\n\n// It might be more optimal to merge some of these together\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    // Reused values (largely the same as in the intersection formula)\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    // Partial derivatives of the implicit equation wrt x, y, and z\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat getTrilinearVolume(in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    // Definite integral of the intersection function from tmin to tmax\n    float m = tmin * tmin, n = tmax * tmax;\n    return 0.25 * coeff1 * (n * n - m * m) + coeff2 * (n * tmax - m * tmin) / 3.0 + 0.5 * coeff3 * (n - m) + coeff4 * (tmax - tmin);\n}\n\nbool insideTrilinearVolume(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    return mix(mix(mix(a, b, p.x), mix(c, d, p.x), p.y),\n               mix(mix(e, f, p.x), mix(g, h, p.x), p.y), p.z) < 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec3 bSphereInfo = IntersectSphere(ro, rd, BSPHERE);\n    if (bSphereInfo[2] > 0.0) {\n        vec4 info = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n\n        // Find closest valid intersection\n        vec3 hitPos;\n        float tMin = 1000000.0;\n        bool intersecting = false;\n        for (int i=0; i < int(info[3]); i++) {\n            vec3 posCandid = ro + rd * info[i];\n            float tCandid = info[i];\n            if (tCandid > 0.0 && tCandid < tMin && length(posCandid) < BSPHERE) {\n                hitPos = posCandid;\n                tMin = tCandid;\n                intersecting = true;\n            }\n        }\n\n        float start = min(bSphereInfo[0], bSphereInfo[1]);\n        float end = max(bSphereInfo[0], bSphereInfo[1]);\n\n        if (intersecting) {\n            end = tMin;\n\n            vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n            n *= sign(dot(n, -rd));\n\n            float diff = max(0.0, dot(n, LIGHT));\n            float checkers = mod(floor(hitPos.x) + floor(hitPos.y) + floor(hitPos.z), 2.0);\n            fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n        }\n\n        // Sphere shell over solid areas of the volume\n        vec3 bSphereHit = ro + rd * start;\n        if (insideTrilinearVolume(bSphereHit, a, b, c, d, e, f, g, h)) {\n            vec3 n = bSphereHit / BSPHERE;\n            float diff = max(0.0, dot(n, LIGHT));\n            float checkers = mod(floor(bSphereHit.x) + floor(bSphereHit.y) + floor(bSphereHit.z), 2.0);\n            fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n        }\n\n        else {\n            float d = getTrilinearVolume(ro, rd, start, end, a, b, c, d, e, f, g, h);\n            float v = 1.0 - exp(-d * 0.175 / (end - start));\n            fragColor.rgb = mix(fragColor.rgb, mix(vec3(0.0, 0.0, 1.0), fragColor.rgb, v), v);\n        }\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 81, 146, 146, 1248], [1250, 1326, 1392, 1392, 1535], [1537, 1537, 1595, 1595, 1972], [1974, 2034, 2183, 2183, 2973], [2975, 2975, 3111, 3111, 3637], [3639, 3639, 3815, 3815, 4798], [4800, 4800, 4935, 4935, 5063], [5065, 5065, 5120, 5120, 8021]], "test": "untested"}
{"id": "7slGRn", "name": "Marilyn-Einstein illusion", "author": "FabriceNeyret2", "description": "well, figured with what we have on board ;-)\n2 images in one, masked through frequency bands. \nSqueeze your eyes or see from a distance to see the other one.\nref: https://www.koreus.com/image/marilyn-einstein.html\n", "tags": ["illusion", "perception", "reproduction"], "likes": 11, "viewed": 407, "published": 3, "date": "1615408837", "time_retrieved": "2024-07-30T19:33:11.261769", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n\n    O =  .5 + 4.*( textureLod(iChannel0, U, 1.).rrrr            // HF of texture 0\n                  -textureLod(iChannel0, U, 0.).rrrr )\n\n       +  .25*textureLod(iChannel1, U/vec2(6,1), 1.).rrrr;      // LF of texture 1\n\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 290]], "test": "untested"}
{"id": "fds3zr", "name": "Minecraft RTX on", "author": "me_123", "description": "Path Traced Minecraft ( :", "tags": ["minecraft"], "likes": 9, "viewed": 828, "published": 3, "date": "1615404606", "time_retrieved": "2024-07-30T19:33:12.259102", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.1415926536;\nconst float fov = 2.2;\nconst float threshold = 0.5;\nconst float clouds_threshold = 0.525;\nconst float sun_movement = 0.1;\nconst vec3 eye_movement = vec3(-4.0, 0.0, -1.0);\nconst vec3 cloud_movement = vec3(-1.0, 0.0, -1.5);\nconst vec3 eye_start = vec3(-40.0, 10.0, 20.0);\n\nvec3 sun_dir;\nvec3 eye;\nvec3 clouds_offset;\n\nfloat sq(float x) { return x * x; }\nfloat sq(vec2 x) { return dot(x, x); }\nfloat sqi(float x) { return 1.0 - sq(1.0 - x); }\nfloat sqi(vec2 x) { return 1.0 - sq(1.0 - x); }\n\nvec3 background(vec3 d)\n{\n\tconst float sun_intensity = 1.0;\n    vec3 sun = (pow(max(0.0, dot(d, sun_dir)), 48.0) + pow(max(0.0, dot(d, sun_dir)), 4.0) * 0.25) * sun_intensity * vec3(1.0, 0.85, 0.5);\n    vec3 sky = mix(vec3(0.6, 0.65, 0.8), vec3(0.15, 0.25, 0.65), d.y) * 1.15;\n    return sun + sky;\n}\n\nfloat noise(vec3 p)\n{\n    return textureLod(iChannel1, p, 0.0).x;\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel1, 0));\n    return clamp((\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 + \n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 + \n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.0, 0.5, 1000.0);\n}\n\nbool voxel(vec3 vp)\n{\n    return cnoise(vp * 0.05) + vp.y * -0.02 > threshold; \n}\nstruct TraceResult\n{\n    vec3 vp;\n    vec3 p;\n    vec3 n;\n    float r;\n    bool hit;\n};\n\nTraceResult traceVoxel(vec3 p, vec3 d, float dist)\n{\n    TraceResult r;\n    r.hit = false;\n    r.n = -d;\n    r.r = dist;\n\n    vec3 id = 1.0 / d;\n    vec3 sd = sign(d);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(p) - nd * vec3(equal(floor(p), p));\n\n    for (int i = 0; i < 500; ++i)\n    {\n        if (dist <= 0.0 || d.y > 0.0)\n        \tbreak;\n\n        if (voxel(vp))\n        {\n\t\t\tr.vp = vp;\n\t\t\tr.p = p;\n\t\t\tr.r = dist;\n\t\t\tr.hit = true;\n\t\t\treturn r;\n        }\n\n        vec3 n = mix(floor(p + 1.0), ceil(p - 1.0), nd);\n\t\tvec3 ls = (n - p) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        p = mix(p + d * l, n, a);\n        vp += sd * a;\n        r.n = -sd * a;\n        dist -= l;\n    }\n\n    return r;\n}\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    \n    // blend factors\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.3333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nfloat s = 100.;\nvec3 ray(vec3 p, vec3 d, vec2 seed)\n{\n    const float view_distance = 300.0;\n    vec3 color = vec3(1);\n    vec3 ro = p;\n    vec3 rd = d;\n    float occ = 1.0;\n    vec3 sun = normalize(vec3(-3., 5, -0));\n    for (int i = 0; i < 2; i += 1) {\n        occ /= 2.0;\n        TraceResult r = traceVoxel(ro, rd, view_distance);\n        if (!r.hit) {\n            color *= texture(iChannel3, rd).xyz;\n            break;\n        }\n        if (r.vp.y >= -0.) {\n            if (r.vp.y >= 1.) {\n                color *= boxmap(iChannel0, r.p, r.n, 1.0).xyz;//((texture(iChannel0, r.p.xz).xyz)+(texture(iChannel0, r.p.xy).xyz))/2.0;\n            } else {\n                color *= 0.2;\n            }\n            vec3 target = r.p + r.n + rus(rd.xy+float(i)+seed);\n            rd = target - r.p;\n        } else {\n            color *= vec3(1.0, 0.5, 0.125)*texture(iChannel0, r.p.xz).xyz*10.0;\n            rd = reflect(rd, r.n);\n            break;\n        }\n        ro = r.p;\n    }\n    return color;//vec3(r.hit : r.n ? 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    eye = eye_start + vec3(0.01) + mod(eye_movement * 0., 640.0);\n\n    float ry = iMouse.x / iResolution.x * pi * 2.0 + pi * 0.85;\n    float rx = -iMouse.y / iResolution.y * pi * 0.5 + pi * 0.95;\n\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n\n\tvec2 uv = fov * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec3 color = ray(eye, dir, uv+iTime);\n    if (iMouse.z < 0.01) {\n        fragColor = ((texture(iChannel2, fragCoord.xy/iResolution.xy)*s) + vec4(color, 1))/(s+1.0);\n    } else {\n        fragColor = vec4(color, 1);\n    }\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "fdlGzr", "name": " - SHMUP", "author": "totetmatt", "description": "Learning, training and building my ray maching routine. a mix of FMS_Cat, evvvvil and Flopine code / knowledge.", "tags": ["shmup", "boulette"], "likes": 1, "viewed": 327, "published": 3, "date": "1615401748", "time_retrieved": "2024-07-30T19:33:13.149721", "image_code": "vec3 pal(float t){\n    return .5+.5*cos(2.*3.1415*(1.*t+vec3(.0,.3,.7)));\n}\n    mat2 r(float a){\n      float c=cos(a),s=sin(a);\n      return mat2(c,-s,s,c);\n      }\nfloat sdf(vec3 p){\n\n  p.x = abs(p.x)-1.1; \n   \n    p.y = abs(p.y)-1.3;  \n   p.zy = p.z>p.y ? p.zy:p.yz;\n    p.z = abs(p.z)-1.5; p.zy = p.z>p.y ? p.zy:p.yz;\n \n      p.z = abs(p.z)-1.5;\n  float h = 10000.;\n  float li = 32.;\n  for(float i=0.;i<li;i++){  \n       float gg =fract(iTime+i/li);\n    float t= .5+log(1.+gg);\n    float po = i*(3.1415*2./li);\n    vec3 o= vec3(sin(po)*t,cos(po)*t,1.);\n     h = min(h, length(p+o)-.05);\n  }\n  \n    return h;\n  }\n\n  \n  vec3 normal(vec3 p){\n     vec2 n= vec2(.001,0.);\n      return normalize(vec3(\n        sdf(p+n.xyy)-sdf(p-n.xyy),\n     sdf(p+n.yxy)-sdf(p-n.yxy),\n     sdf(p+n.yyx)-sdf(p-n.yyx))\n    );\n      \n    }\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5* iResolution.xy)/iResolution.y;\n\n      vec3 ro = vec3(0.,0.,-3.);\n  \n  \n  vec3 cameraW = normalize(vec3(0)-ro);\n  vec3 cameraU = normalize(cross(cameraW,vec3(0.,1.,0.)));\n  vec3 cameraV = normalize(cross(cameraU,cameraW));\n  mat3 cameraMat = mat3(cameraU,cameraV,cameraW);\n  vec3 rd = cameraMat* normalize(vec3(uv,.5)); \n\n\n   \n  vec3 col = vec3(.1)-length(uv)*.1 ;\n  vec3 light = vec3(.2,.5,-1.5);\n  float rl = 1E-2;\n  float isec;\n  vec3 rp = ro+rd*rl;\n\n\n  for(int i=0;i<69;i++) {\n      isec = sdf(rp); \n      rl+=isec;\n      rp = ro+rd*rl;\n      if(isec<1E-2) {\n \n      \n        col = vec3(.4)* max(0.,dot(light,normal(rp)))*pal(length(uv.xy*2.));\n        break;\n      }\n  }\n  \n  \n\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(.5)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 75], [80, 80, 96, 96, 164], [165, 165, 183, 183, 614], [621, 621, 641, 641, 817], [823, 823, 880, 930, 1712]], "test": "untested"}
{"id": "Ndl3zn", "name": "Fractal Direct", "author": "Leasel", "description": "Uses distance to measure the third to second point length and the second to first length. Thus getting clear if it diverges to infinite or stays constant or to a point. This uses the equation f(z) = z*z + 1.", "tags": ["fractal"], "likes": 1, "viewed": 252, "published": 3, "date": "1615394009", "time_retrieved": "2024-07-30T19:33:13.919662", "image_code": "float FractalPoint(in vec2 point)\n{\n    float x = point.x;\n    float y = point.y;\n\n    vec2 B = vec2(x, y);\n    vec2 BA = vec2(x*x + y*y + 1., 2.*x*y);\n    vec2 BAA = vec2(x*x*x*x + y*y*y*y + 2.*x*x - 2.*y*y - x*x*y*y + 2., x*y*4.*(1. - y*y + x*x));\n    return length(B - BA) - length(BA - BAA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Position Point in Center screen\n    vec2 uv = (fragCoord - iResolution.xy*0.5)*0.015;\n\n    // Output to screen\n    fragColor = FractalPoint(uv) * vec4(1.,1.,1.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 297], [299, 299, 356, 394, 529]], "test": "untested"}
{"id": "fdl3zn", "name": "Animated IGN", "author": "TinyTexel", "description": "Animated interleaved gradient noise. Improves isotropy via rotation.  Relevant code is in BufferA.\nhttp://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\n", "tags": ["noise", "dither", "ign"], "likes": 5, "viewed": 580, "published": 3, "date": "1615393508", "time_retrieved": "2024-07-30T19:33:14.796319", "image_code": "/*\nAnimated interleaved gradient noise.Improves isotropy via rotation. Relevant code is in BufferA.\nhttp://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\n*/\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        col = pow(vec3(n), vec3(1.0/2.2));\n        \n        #ifdef SHOW_1BITGRADIENT\n        if(q.y < 0.25)\n        col = vec3(n < q.x * 2.0 ? 0.0 : 1.0);\n        #endif\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n  #define SHOW_1BITGRADIENT\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n", "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat EvalIGN(vec2 uv)\n{\n    uint frame = uint(iFrame);\n    \n    //frame += WellonsHash2(WeylHash(uvec2(uv)/4u)) % 4u;\n    \n    if((frame & 2u) != 0u) uv = vec2(-uv.y, uv.x);\n    if((frame & 1u) != 0u) uv.x = -uv.x;\n\n    //return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))) + float(frame)*0.41421356);\n    //return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n    //return fract(IGN(uv)+float(frame)*0.41421356*1.0);\n    \n    // http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#dither\n    return fract(uv.x*0.7548776662 + uv.y*0.56984029 + float(frame)*0.41421356*1.0);\n}\n\nfloat EvalIGN(uvec2 uvi)\n{\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n    \n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    \n    return u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    vec2 uv = fragCoord - 0.5;\n    \n    float ign = EvalIGN(uv);\n    //float ign = EvalIGN(uvec2(uv));\n    \n    //ign = abs(ign * 2.0 - 1.0);\n    \n    fragColor = vec4(vec3(ign), 1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdl3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlVfWt", "name": "Dots & Curves", "author": "spawner64", "description": "Blended 4-point cubic interpolation:\n- Red: Bezier edges / Lagrange mids.\n- Green: Lagrange edges / Hermite mids.\n- Blue: Bezier edges / Hermite mids.\n- White: Lagrange edges & mids.\n\n3 - point cubic interpolation:\n- Gray: Exact Bezier (exact func fit).", "tags": ["bezier", "curves", "spline", "vignette", "curve", "graph", "dots", "cubic", "interpolation", "hermite", "lagrange"], "likes": 9, "viewed": 465, "published": 3, "date": "1615371710", "time_retrieved": "2024-07-30T19:33:15.563268", "image_code": "// ------------------------------------------------------------------------- //\n//\n// Dots & Curves\n//\n// Hybrid cubic interpolation methods achieved by blending different types of\n// cubic interpolation functions like the Lagrange, Hermite and Bezier\n// interpolations.\n//\n// Additionally, a 3-point exact Bezier function is provided. Called \"exact\"\n// because the function fits perfectly the 3 points (aka the function goes\n// through the 3 points exactly).\n//\n// Blended 4-point cubic interpolation:\n// - Red: Bezier edges / Lagrange mids.\n// - Green: Lagrange edges / Hermite mids.\n// - Blue: Bezier edges / Hermite mids.\n// - White: Lagrange edges & mids.\n//\n// 3 - point cubic interpolation:\n// - Gray: Exact Bezier (exact function fit).\n//\n// Choose your poison.\n//\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/MllSzX\nfloat c_x0 = -1.0;\nfloat c_x1 =  0.0;\nfloat c_x2 =  1.0;\nfloat c_x3 =  2.0;\n\n// https://www.shadertoy.com/view/MllSzX\nvec3 CubicLagrange(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec2 CubicLagrange(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nfloat CubicLagrange(float A, float B, float C, float D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec3 CubicHermite(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec3 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec3 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec3 c = -A/2.0 + C/2.0;\n   \tvec3 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec2 CubicHermite(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec2 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec2 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec2 c = -A/2.0 + C/2.0;\n   \tvec2 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/4ts3DB\nvec2 CubicBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, float v1) {\n    float u1 = 1.0 - v1;\n    float u2 = u1*u1;\n    float v2 = v1*v1;\n    float u3 = u2*u1;\n    float v3 = v2*v1;\n    return a*u3 + d*v3 + b*3.0*u2*v1 + c*3.0*u1*v2;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat ExactBezier(float l, float c, float r, float t) {\n    float it = 1.0 - t;\n    float lf = l + t * (r - l);\n    float qf =\n        l * it * it +\n        c * it * t * 2.0 +\n        r * t * t;\n    return qf + qf - lf;\n}\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/Md2cRt\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575);\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat plotPoint(vec2 uv, float x, float y, float radius) {\n    // compute dimension-wise pseudo-distance\n    float xDist = uv.x - x;\n    float yDist = uv.y - y;\n    \n#if 0\n    xDist *= iResolution.x / iResolution.y; // scale by screen height\n#else\n    yDist *= iResolution.y / iResolution.x; // scale by screen width\n#endif\n\n    // compute distance\n    float f = xDist * xDist + yDist * yDist;\n    f = sqrt(f);\n\n    // raise and exponentiate\n    radius *= 1000.0;\n    f *= 1000.0 / radius;\n    f = clamp(f, 0.0, 1.0);\n    f = pow(f, radius * 2.0);\n\n    // invert and return\n    f = 1.0 - f;\n    return f;\n}\n\nfloat plotPoint(vec2 uv, vec2 xy, float radius) {\n    return plotPoint(uv, xy.x, xy.y, radius);\n}\n\nvec3 plotPoint(vec2 uv, float x, float y, float radius, vec3 color) {\n    return plotPoint(uv, x, y, radius) * color;\n}\n\nvec3 plotPoint(vec2 uv, vec2 xy, float radius, vec3 color) {\n    return plotPoint(uv, xy.x, xy.y, radius) * color;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat blendingFunction(float t) {\n    float f = 1.5 - abs(1.5 - t * 3.0);\n    f = clamp(f, 0.0, 1.0);\n    f = 1.0 - f;\n    f *= f;\n    f *= f;\n    f = 1.0 - f;\n    return f;\n}\n\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n\n    vec2 a4 = vec2(0.0 / 3.0, 0.5);\n    vec2 b4 = vec2(1.0 / 3.0, 0.5);\n    vec2 c4 = vec2(2.0 / 3.0, 0.5);\n    vec2 d4 = vec2(3.0 / 3.0, 0.5);\n\n    vec2 l3 = vec2(0.0 / 2.0, 0.5);\n    vec2 c3 = vec2(1.0 / 2.0, 0.5);\n    vec2 r3 = vec2(2.0 / 2.0, 0.5);\n\n    // vignette and some dithering noise to fight banding\n    vec3 color = vec3(0.120, 0.140, 0.155) * (2.0 - 2.5 * pow(distance(uv, vec2(0.5, 0.5)), 2.0));\n    color += (rand(uv) - 0.5) * 0.015;\n\n    color += plotPoint(uv, vec2(0.5, 0.5), mix(0.015, 0.1, mouse.y), mix(vec3(0.35, 0, 1), vec3(0.525, 1, 0), mouse.y));\n    //b4 = mouse.y;\n    //c4 = 1.0 - mouse.y;\n    //a4 = mouse.y;\n    //d4 = mouse.x;\n\n    float timeScale = mix(0.025, 3.0, mouse.y);\n    float scaledTime = iTime * timeScale + 186.9;\n\n    {\n        // animate and plot the 4 points\n\n        a4.y = sin(scaledTime * 1.12235431) * 0.5 + 0.5;\n        b4.y = sin(scaledTime * 2.77834539) * 0.5 + 0.5;\n        c4.y = sin(scaledTime * 3.54234271) * 0.5 + 0.5;\n        d4.y = sin(scaledTime * 4.36788523) * 0.5 + 0.5;\n\n        color += plotPoint(uv, a4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, b4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, c4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, d4, 0.025, vec3(1, 0, 0));\n    }\n\n    {\n        // animate and plot the 3 points\n\n        l3.y = a4.y;\n        c3.y = sin(scaledTime * 1.77834539) * 0.5 + 0.5;\n        r3.y = d4.y;\n\n        color += plotPoint(uv, l3, 0.025, vec3(1, 0.0, 0));\n        color += plotPoint(uv, c3, 0.025, vec3(0, 0.5, 1));\n        color += plotPoint(uv, r3, 0.025, vec3(1, 0.0, 0));\n    }\n\n    int numPlotPoints = 50;\n    float invNumPlotPoints = 1.0 / float(numPlotPoints);\n    for (int i = 0; i < numPlotPoints; i++) {\n        float t = float(i) * invNumPlotPoints;\n\n        vec2 blend = vec2(blendingFunction(t));\n        color += plotPoint(uv, t, blend.y, invNumPlotPoints * 0.5, vec3(0.125, 0.125, 0.152));\n\n        float t2 = mix(-1.0, 2.0, t);\n\n        {\n            // although the bezier goes through the edges, when mixed up with hermite it doesn't anymore - worst\n            vec2 xyEdges = CubicBezier(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicHermite(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.0, 0.0, 0.5));\n        }\n\n        {\n            // produces frequencies a lot higher than the nyquist\n            vec2 xyEdges = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicHermite(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.0, 0.5, 0.0));\n        }\n\n        {\n            // lowest overshoot, but less smoother than lagrange / lagrange - some higher-than-nyquist frequencies\n            vec2 xyEdges = CubicBezier(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.5, 0.0, 0.0));\n        }\n\n        {\n            // smoothest - lowest in frequencies, but overshoots\n            // since it's a mix between the same function, can be evaluated just once\n            vec2 xyEdges = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.5, 0.5, 0.5));\n        }\n\n        {\n            // 3 - point exact cubic interpolation\n            float y = ExactBezier(l3.y, c3.y, r3.y, t);\n            color += plotPoint(uv, t, y, invNumPlotPoints * 0.5, vec3(0.25, 0.25, 0.25));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 1013, 1074, 1074, 1721], [1723, 1764, 1825, 1825, 2472], [2474, 2515, 2581, 2581, 3228], [3230, 3271, 3331, 3331, 3561], [3563, 3604, 3664, 3664, 3894], [3977, 4018, 4090, 4090, 4257], [4340, 4340, 4395, 4395, 4561], [4644, 4685, 4706, 4706, 4780], [4863, 4863, 4921, 4967, 5469], [5471, 5471, 5520, 5520, 5568], [5570, 5570, 5639, 5639, 5689], [5691, 5691, 5751, 5751, 5807], [5890, 5890, 5923, 5923, 6065], [6148, 6148, 6203, 6203, 10403]], "test": "untested"}
{"id": "7sX3Rn", "name": "Photoshop Texture Guide", "author": "foxes", "description": "This preview for guide to creation tiled texture in photosop using cloud filter. You can build it use \"Cloud\" and \"Difference Cloud\", mix them with defaul \"Emboss\", \"Pin Light\", \"Difference\" filters. And come up with your own effects by changing the param", "tags": ["noise", "texture", "2dfilter", "generation"], "likes": 16, "viewed": 535, "published": 3, "date": "1615367967", "time_retrieved": "2024-07-30T19:33:16.339193", "image_code": "//\n// Panteleymonov A K 2021\n//\n\n//****************** if there are problems with the image change the hash ***********\n\n//#define hash(n) fract(mod(n*n*34.+n,289.)/289.)\n#define hash(n) fract(abs(sin(n))*1399763.5453123)\n\nvec4 hash4( vec4 n ) { return hash(n); }\nvec2 NC0=vec2(1.0,136.0);\n\nfloat nouse2d(vec2 uv)\n{\n    vec2 f = fract(uv);\n    f=f*f*(3.0-2.0*f);\n    uv = floor(uv);\n    vec4 p = vec4(dot(uv,NC0),dot(uv+vec2(1.,0.),NC0),dot(uv+vec2(0.,1.),NC0),dot(uv+vec2(1.,1.),NC0));\n    vec4 h = hash4(p);\n    h.xy =  mix(h.xy,h.zw,f.yy);\n    return mix(h.x,h.y,f.x);\n}\n\nfloat cloud(vec2 uv)\n{\n    float f = 0.0;\n    float m = 1.0;\n    float s = 0.32;\n    for (int i=0;i<20;i++) {\n        f += nouse2d(uv*m)*s;\n        m = m * 1.5;\n        s = s * 0.72;\n    }\n    f = f;\n    return clamp(f,0.,1.);\n}\n\nfloat differenceCloud(float x,float f,float s)\n{\n    return clamp(abs(f-x)*s,0.,1.);\n}\n\nfloat emboss(float x1,float x2,float f)\n{\n    return clamp((x1-x2)*f+0.5,0.,1.);\n}\n\nfloat difference(float x1,float x2)\n{\n    return abs(x1-x2);\n}\n\nvec3 difference(float x1,vec3 x2)\n{\n    return abs(vec3(x1)-x2);\n}\n\nfloat substract(float x1,float x2)\n{\n    return clamp(x1-x2,0.,1.);\n}\n\nfloat invert(float x)\n{\n    return 1.-x;\n}\n\nfloat hardLight(float x1,float x2)\n{\n    x1 = (x1*x2*2.0 - 0.5)*2.0;\n    x1 = (x1<0.0) ? -x1*x1 : x1*x1;\n    x1 = x1*0.5+0.5;\n    return clamp(x1,0.,1.);\n}\n\nfloat linearLight(float x1,float x2)\n{\n    return clamp(x1*(x2*2.0),0.,1.);\n}\n\nfloat pinLight(float x1,float x2)\n{\n    return x2<0.5 ? min(x1,x2*2.0) : max(x1,x2*2.0-1.0);\n}\n\nvec3 pinLight(vec3 x1,float x2)\n{\n    return x2<0.5 ? min(x1,vec3(x2)*2.0) : max(x1,vec3(x2)*2.0-1.0);\n}\n\nfloat exclusion(float x1,float x2)\n{\n    return clamp(x2<0.5 ? mix(x1,0.5,x2*2.0) : mix(0.5,abs(x1-x2),x2*2.-1.),0.,1.);\n}\n\nfloat divColor(float x, float d)\n{\n    float f = fract(x*d)-0.5;\n    return (floor(x*d)+f*f*f+0.5)/d;\n}\n\nvec3 colorNorm(vec3 c)\n{\n    float v = max(max(c.x,c.y),c.z);\n    return c/v;\n}\n\nvec3 color(float x,vec3 col)\n{\n    return colorNorm(col)*x;\n}\n\nvec3 screen(float x,vec3 col)\n{\n    return mix(colorNorm(col),vec3(1.),x)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float xsel = fragCoord.x/iResolution.x;\n    float xcol = fragCoord.y/iResolution.y*1.2-0.2;\n    vec2 uv = fragCoord/iResolution.y;\n\tif (iMouse.z>0.0) xsel=iMouse.x/iResolution.x;\n    if (iMouse.z>0.0) xcol=iMouse.y/iResolution.y*1.2-0.2;\n  \n    float zoom = 15.0;\n    // create bottom layer 1 with \"Cloud\" filter\n    float l1 = cloud(uv*zoom+100.0);\n    // used for emboss layer 1\n    float el1 = cloud(uv*zoom+100.0+vec2(0.,0.2));\n    // create layer 2 from copy layer 1 and apply \"Difference Cloud\" filter\n    float l2 = differenceCloud(l1,0.5,2.0);\n    // used for emboss layer 2\n    float el2 = differenceCloud(el1,0.5,2.0);\n    \n    float light = fract(xsel*4.0);\n    vec3 co11 = clamp((1.0-abs(vec3(xcol*2.0,xcol*2.0-1.0,xcol*2.0-2.0)))*2.0,vec3(0.,0.,0.),vec3(1.,1.,1.));\n    co11 = mix(co11,vec3(1.,1.,1.),light);\n    vec3 co12 = clamp((1.0-abs(vec3(xcol*2.0-1.0,xcol*2.0-2.0,xcol*2.0)))*2.0,vec3(0.,0.,0.),vec3(1.,1.,1.));\n    co12 = mix(vec3(1.,1.,1.),co12,light);\n    \n    // create new layer from copy layer 1, and \"Emboss\" him with default parameters\n    float v = 0.;\n    if (xsel<0.25)\n        // use \"Pin Light\" or \"Difference\" mode to embossed layer\n        v = pinLight(difference(l2,l1),emboss(el1,l1,2.5));\n    else if (xsel<0.5)\n        v = difference(difference(l2,l1),emboss(el1,l1,2.5));\n    // additional copied layer 1 and mixed with \"Difference\" mode on top\n    else if (xsel<0.75)\n        v = difference(l1,pinLight(difference(l2,l1),emboss(el1,l1,2.5)));\n    else if (xsel<1.0)\n        v = difference(l1,difference(difference(l2,l1),emboss(el1,l1,2.5)));\n\n    vec3 col = mix(vec3(v),color(v,co11),clamp(l1*6.-2.2,0.,1.));\n    col = mix(col,color(v,co12),clamp((1.0-l1)*6.-3.1,0.,1.));\n    \n    // and more\n    if (xcol<0.) {\n    if (xsel<0.125) {\n        v = linearLight(l2,emboss(l2,el2,2.0));\n        v = v+(clamp(0.5-abs(0.4-v),0.,1.));\n        col = mix(mix(vec3(0.8,0.33,0.0),vec3(0.2,0.6,0.6),v)*v,vec3(1.),v);\n    } else if (xsel<0.25) {\n        v = invert(divColor(l2,40.));\n        v = linearLight(invert(l2),emboss(invert(l2),divColor(invert(el2),4.),1.0));\n        col = vec3(screen(v*v,vec3(0.,0.34,0.9)));\n    } else if (xsel<0.375) {\n        col = pinLight(vec3(difference(l2,vec3(0.29,0.25,0.19)*1.4)),emboss(l2,el2,1.4));\n    } else if (xsel<0.5) {\n        v = linearLight(exclusion(l1,l2),emboss(exclusion(l1,l2),exclusion(el1,el2),1.5));\n        col = screen(v+l2,vec3(0.,0.34,0.9));\n    } else if (xsel<0.625) {\n        col = pinLight(screen(l1,vec3(0.1,0.4,1.0)),emboss(l1,el1,2.0));\n    } else if (xsel<0.75) {\n        col = vec3(l1);\n    } else if (xsel<0.875) {\n        col = vec3(l2);\n    }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 244, 244, 262], [290, 290, 314, 314, 572], [574, 574, 596, 596, 802], [804, 804, 852, 852, 890], [892, 892, 933, 933, 974], [976, 976, 1013, 1013, 1038], [1040, 1040, 1075, 1075, 1106], [1108, 1108, 1144, 1144, 1177], [1179, 1179, 1202, 1202, 1221], [1223, 1223, 1259, 1259, 1378], [1380, 1380, 1418, 1418, 1457], [1459, 1459, 1494, 1494, 1553], [1555, 1555, 1588, 1588, 1659], [1661, 1661, 1697, 1697, 1783], [1785, 1785, 1819, 1819, 1888], [1890, 1890, 1914, 1914, 1969], [1971, 1971, 2001, 2001, 2032], [2034, 2034, 2065, 2065, 2112], [2114, 2114, 2171, 2221, 4933]], "test": "untested"}
{"id": "NsfGzn", "name": "catmull-rom spline interpolation", "author": "ctk2156", "description": "catmull-rom spline interpolation", "tags": ["2d"], "likes": 1, "viewed": 340, "published": 3, "date": "1615357328", "time_retrieved": "2024-07-30T19:33:17.163988", "image_code": "// revers: This is fork of iq's \"Fourier - interpolation\" [ https://www.shadertoy.com/view/4lGSDw ].\n//         It compares Fourier (green line) with Catmull-Rom (black line) interpolation. \n//         Fourier version produces more round shape, but is slower (over 3 times on my video card)\n//         than Catmull-Rom.\n//\n//         Comment out SHOW_CATMULL_ROM / SHOW_FOURIER to see a single curve.\n\n\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A set of 38 points gets interpolated by computing the DFT (Discrete Fourier Transform)\n// and then its inverse, and evaluating the it at more than 38 points. This results in\n// an interpolation sort of made of cosine/sine waves. Would be nice to do a regular\n// Hermite spline interpolation as well to compare.\n//\n// More info: https://iquilezles.org/articles/fourier\n//\n// Original drawing (kind of), here:\n// https://mir-s3-cdn-cf.behance.net/project_modules/disp/831a237863325.560b2e6f92480.png\n\n\n\n//--------------------------------------------------------------------------------------\n// Additions by revers:\n\n#define SHOW_CATMULL_ROM\n//#define SHOW_FOURIER\n\n/**\n * Tension. Default Catmul-Rom matrix\n * has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.7\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = vec3(1.0);\n\n    const int NUM = 41;\n    \n    vec2 path[NUM];\n    \n    //------------------------------------------------------\n    // path\n    //------------------------------------------------------\n    {\n        path[ 0] = vec2( 0.098, 0.062 );\n        path[ 1] = vec2( 0.098, 0.062 );\n        path[ 2] = vec2( 0.352, 0.073 );\n        path[ 3] = vec2( 0.422, 0.136 );\n        path[ 4] = vec2( 0.371, 0.085 );\n        path[ 5] = vec2( 0.449, 0.140 );\n        path[ 6] = vec2( 0.352, 0.187 );\n        path[ 7] = vec2( 0.379, 0.202 );\n        path[ 8] = vec2( 0.398, 0.202 );\n        path[ 9] = vec2( 0.266, 0.198 );\n        path[10] = vec2( 0.318, 0.345 );\n        path[11] = vec2( 0.402, 0.359 );\n        path[12] = vec2( 0.361, 0.425 );\n        path[13] = vec2( 0.371, 0.521 );\n        path[14] = vec2( 0.410, 0.491 );\n        path[15] = vec2( 0.410, 0.357 );\n        path[16] = vec2( 0.502, 0.482 );\n        path[17] = vec2( 0.529, 0.435 );\n        path[18] = vec2( 0.426, 0.343 );\n        path[19] = vec2( 0.449, 0.343 );\n        path[20] = vec2( 0.504, 0.335 );\n        path[21] = vec2( 0.664, 0.355 );\n        path[22] = vec2( 0.748, 0.208 );\n        path[23] = vec2( 0.738, 0.277 );\n        path[24] = vec2( 0.787, 0.308 );\n        path[25] = vec2( 0.748, 0.183 );\n        path[26] = vec2( 0.623, 0.081 );\n        path[27] = vec2( 0.557, 0.099 );\n        path[28] = vec2( 0.648, 0.116 );\n        path[29] = vec2( 0.598, 0.116 );\n        path[30] = vec2( 0.566, 0.195 );\n        path[31] = vec2( 0.584, 0.228 );\n        path[32] = vec2( 0.508, 0.083 );\n        path[33] = vec2( 0.457, 0.140 );\n        path[34] = vec2( 0.508, 0.130 );\n        path[35] = vec2( 0.625, 0.071 );\n        path[36] = vec2( 0.818, 0.093 );\n        path[37] = vec2( 0.951, 0.066 );\n        path[38] = vec2( 0.547, 0.081 );\n        path[39] = vec2( 0.098, 0.062 );\n        path[40] = vec2( 0.098, 0.062 );\n    }\n\n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\t{\n\t\tvec2 d = vec2(1000.0);\n\t\tfor (int i = 0; i < (NUM - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n\t\t\td = min(d, vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a)));\n\t\t}\n\t\td.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[NUM - 1])));\n\t\tcol = mix(col, vec3(0.9, 0.2, 0.0), 1.0 - smoothstep(5.0 * e, 6.0 * e, d.y));\n\t}\n\n#ifdef SHOW_CATMULL_ROM\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t// (added by revers)\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = min(mod((12.0 + iTime) / 10.1, 1.3), 1.0) * float(NUM);\n\n\t\tvec2 p = path[0];\n\n\t\tfor (int i = 0; i < NUM - 3; i=i+2) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n\n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n\t\t\t\td = min(d, sdSegmentSq(uv, p, q));\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td = sqrt(d);\n\n\t\tcol = mix(col, vec3(0.1, 0.1, 0.2), 1.0 - smoothstep(0.0 * e, 10.0 * e, d));\n\t\tcol *= 0.75 + 0.25 * smoothstep(0.0, 0.13, sqrt(d));\n\t}\n#endif\n\n\n    //------------------------------------------------------\n\n\t//col *= 1.0 - 0.3 * length(fragCoord / iResolution.xy - 0.5);\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfGzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1670, 1714, 1777, 1777, 2142], [2234, 2234, 2277, 2277, 2406], [2408, 2408, 2441, 2441, 2479], [2481, 2481, 2508, 2508, 2570], [2572, 2572, 2624, 2624, 6093]], "test": "untested"}
{"id": "NdfGRn", "name": "Hex Thing", "author": "Tater", "description": "The colors worked much better than expected.", "tags": ["2d", "hexagons"], "likes": 12, "viewed": 425, "published": 3, "date": "1615357172", "time_retrieved": "2024-07-30T19:33:17.937919", "image_code": "//Hex Tiling From \"The Art of Code\" tutorial\n//Colors, movement, and flickering stuff is original\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return((t-a) / (b-a))* (d-c) + c;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c,p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv) \n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;  \n    vec2 gv = dot(a,a)<dot(b,b) ? a : b;\n    float x = atan(gv.x,gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(gv.x, y, id.x, id.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    t*=1.0;//Speed Adjustment\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n    \n    uv+=t/50.;\n    uv *= 8.5;\n    \n    vec4 hc = HexCoords(uv);\n    float vary =remap(-.95,-.75,0.,1.,sin(t*3.+hc.z+hc.w))/2.;\n    float c2=1.-smoothstep(.0+vary,vary,abs(hc.x));  \n    c2*=smoothstep(.03, .04, hc.y*sin((hc.z+hc.w)+t/1.2));\n    col+=c2;\n        \n    float r = remap(-1.,1.,0.,1.,sin(hc.z));\n    float g = remap(-1.,1.,0.,1.,sin(hc.w));\n    float b = remap(-1.,1.,0.,1.,sin(hc.w+hc.z)+remap(-1.,1.,-.25,.5,sin(t/2.)));\n    \n    col.rgb*=vec3(r,g,b)/2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 156, 156, 196], [197, 197, 220, 220, 319], [321, 321, 347, 347, 619], [620, 620, 677, 677, 1323]], "test": "untested"}
{"id": "ttKBDd", "name": "Planetary Soup", "author": "Plento", "description": "FBM is fun", "tags": ["3d", "fbm", "sphere", "warp"], "likes": 44, "viewed": 839, "published": 3, "date": "1615355207", "time_retrieved": "2024-07-30T19:33:18.712847", "image_code": "// Cole Peterson\n\n\nvec4 sphere(vec3 ro, vec3 rd, vec3 cn, float r){\n    float b = 2.*dot(rd, ro - cn);\n    float c = dot(ro - cn, ro - cn) - (r*r);\n    float d = (b*b) - (4.*c);\n \t\n    if(d < 0.) \n        return vec4(0);\n    else{\n     \tfloat t = .5*(-b - sqrt(d));   \n        return vec4(ro+rd*t, t);\n    }\n}\n\nconst float rad = 2.;\nfloat camR = 4.14;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    float ux = uv.x;\n    uv *= rot(-iTime*.12 + 2.2);\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float ang = iTime*.12 + 7.;\n    \n    \n    if(iMouse.z > 0.){\n        camR -= m.y*6.;\n        ang += m.x;\n    }\n    \n    ro.x += camR*cos(ang);\n    ro.z += camR*sin(ang);\n    \n    rd.xz *= rot(ang + pi/2. + .04);\n    \n    \n    \n    vec3 ld = normalize(vec3(0.4, 0.3, -0.5));\n    \n    float ts = .5;\n    \n    vec3 pp = vec3(0);\n    vec3 n = vec3(0);\n    \n    vec3 cntr = vec3(0., 0., 0.);\n    vec4 p = sphere(ro, rd, cntr, rad);\n    \n    vec3 col = vec3(0);\n    \n    if(p.w > 0.){\n        pp = p.xyz;\n        n = pp - cntr;\n        n = normalize(n);\n        \n        vec2 cuv = abs(vec2(atan(n.z, n.x), acos(p.y / rad))); \n        cuv *= rot(-iTime*.05 * ts);\n        \n        float n1 = 2.*octnse(cuv, 10, -iTime*.08 * ts) - 1.;\n        float n2 = 2.*octnse((cuv+3.), 10, -iTime*.03 * ts) - 1.;\n    \n        vec2 os = vec2(n1, n2);\n    \n        float val = octnse((cuv + vec2(n1, n2)*3.6), 8, -iTime*.1 * ts);\n        \n        col += .35+.35*cos(vec3(1.4, .7, 0.9)*n1*10. + iTime*.35);\n        col += .48+.37*cos(vec3(2.2, .1, 0.3)*n2*20. + vec3(.7, 1.2, .7));\n        col += .48+.23*cos(vec3(1.4, .7, 0.9)*val*30. + vec3(.2, 0.8, 4.7)+ iTime*.25);\n        col*=.38;\n        \n        vec3 ref = reflect(n, rd);\n        float val2 = octnse((ref.xy + os*10. + val*5.), 8, -iTime*.1 * ts);\n        \n        col *= val2*3. * vec3(.9, .8, .8);\n        col *= max(dot(n, -rd), 0.0)*vec3(.9, .8, .7);\n    }\n    else{\n        col += .7*ss(.3, .01, simplex3d(rd*160.));\n        col += .15*texture(iChannel0, rd).yzx;\n    }\n    \n    col = col*col*1.7;\n    \n    \n    \n    col = 1.-exp(-col);\n    \n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nconst float pi = 3.14159;\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat octnse(vec2 p, int oct, float t){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x += t;\n     \tn += perlin(p) * a *.5;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\n\n\n\n\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n    \n     float nse = dot(d, vec4(52.));\n    \n     //return nse;\n\t return 1.-exp(-(nse+1.)*.5);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 67, 67, 309], [353, 353, 393, 393, 2184]], "test": "untested"}
{"id": "fdf3Rn", "name": "Analytic vs. Euler Integration", "author": "oneshade", "description": "Learning to integrate and also comparing to Euler integration (is completely unfair ;)).", "tags": ["2d", "math", "learning", "analytic", "integral", "parametric", "comparison", "euler"], "likes": 8, "viewed": 148, "published": 3, "date": "1615350568", "time_retrieved": "2024-07-30T19:33:19.532655", "image_code": "/*\nHaving fun figuring out how to integrate!\nTrying out a comparison between numeric (euler) and analytic integration,\nthe winner is pretty obvious. Maybe I'll try some other numeric\nintegration schemes.\n\nDesmos graph:\nhttps://www.desmos.com/calculator/pxji4ovi3x\n*/\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    uv += c; // Bring into view\n\n    // Draw true path, it has to be brute forced in segments though :(\n    float tStep = TAU / PLOT;\n    vec2 prev = Position(-PI);\n    for (float t=tStep - PI; t < PI + tStep; t += tStep) {\n        vec2 cur = Position(t);\n        draw(sdLine(uv, prev, cur), vec3(1.0));\n        prev = cur;\n    }\n\n    vec2 vel = Velocity(iTime);\n    vec2 dir = normalize(vel);\n\n    // Draw points\n    vec2 pos = Position(iTime);\n    draw(sdLine(uv, pos, pos + dir), vec3(0.0, 0.0, 1.0));\n    draw(length(uv - pos) - 0.05, vec3(0.0, 1.0, 0.0));\n\n    pos = texelFetch(iChannel0, ivec2(0), 0).xy;\n    draw(sdLine(uv, pos, pos + dir), vec3(0.0, 0.0, 1.0));\n    draw(length(uv - pos) - 0.05, vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.28\n#define PI 3.14\n\n#define PLOT 50.0 // Plot resolution\n\n#define k 10.0 // Fractal iterations\n#define c vec2(0.0, 4.0 / 3.0) // Constant of integration\n\nvec2 Velocity(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < k; n++) {\n        float s = pow(2.0, n), ts = t * s;\n        p += vec2(cos(ts), sin(ts)) / s;\n    }\n\n    return p;\n}\n\n// Analytic integral\nvec2 Position(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < k; n++) {\n        float ts = t * pow(2.0, n);\n        p += vec2(sin(ts), -cos(ts)) / pow(2.0, 2.0 * n);\n    }\n\n    return p + c;\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFrame > 0 && iFragCoord == ivec2(0)) {\n        fragColor = texelFetch(iChannel0, ivec2(0), 0);\n        fragColor.xy += Velocity(iTime) * iTimeDelta; // Euler integration\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 383, 383, 491], [493, 493, 548, 548, 1450]], "test": "untested"}
{"id": "tlVfWt", "name": "Procedural Generation - Quasar", "author": "Quasar", "description": "2D Procedural generation based off of this article: https://www.redblobgames.com/maps/terrain-from-noise/ Move the mouse left to have more snowy mountains, and move it right to create more water.\n\nUpdate 2/28/2022: Added moisture map and better biome map.", "tags": ["procedural", "2d", "noise", "generation"], "likes": 3, "viewed": 401, "published": 3, "date": "1615339345", "time_retrieved": "2024-07-30T19:33:20.307583", "image_code": "float getLevel (vec2 pos) {\n    float e = perlin2D(pos, 3) * 1.;\n    \n    if (iMouse.xy != vec2(0)) {\n        e = pow(e, (iMouse.x * 2.) / iResolution.x);\n    }\n    \n    return e;\n}\n\nvec3 getColor (float elevation, float moisture) {\n    return texture(iChannel0, vec2(moisture, elevation)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv.x += iTime * 0.2;\n    \n    float elevation = getLevel(uv * 6.);\n    float moisture = perlin2D(uv, 2);\n    \n    //Make elevation and moisture more diverse\n    elevation = (elevation - 0.3) * 3.;\n    moisture = (moisture - 0.1) * 1.1;\n\n    vec3 col = getColor(elevation, moisture);\n\n    fragColor = vec4(col, 1.0);\n    //Uncomment next line to see biome map.\n    //fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 grad (vec2 vec) {\n    return normalize( vec2(\n        fract(cos(vec.x * 3249.432 + vec.y * 439342.23) * 2134.4),\n        fract(sin(vec.x * 239.4576 + vec.y * 948.754) * 44654.5647)) * 2. - 1.);\n}\n\nfloat basic_perlin (vec2 pos) {\n    vec2 grid = floor(pos);\n    vec2 uv = fract(pos);\n    float tl = dot( uv , grad(grid) );\n    float tr = dot( uv - vec2(1., 0.) , grad(grid + vec2(1., 0.)) );\n    float br = dot( uv - vec2(1., 1.) , grad(grid + vec2(1., 1.)) );\n    float bl = dot( uv - vec2(0., 1.) , grad(grid + vec2(0., 1.)) );\n    \n    uv = uv * uv * (3. - 2. * uv);\n    \n    float value = mix(\n            mix(tl, tr, uv.x),\n            mix(bl, br, uv.x), uv.y);\n    \n    return value * .5 + .5;\n}\n\nfloat perlin2D (vec2 pos, int octaves) {\n    float value = 0.;\n    float fre_factor = 1.;\n    float amp_factor = 1.;\n    float normalization = 1.;\n    \n    for (int i = 0; i < octaves; i += 1) {\n        value += basic_perlin(pos * fre_factor) * amp_factor;\n        \n        fre_factor *= 2.;\n        amp_factor *= 0.5;\n        \n        normalization += amp_factor;\n    }\n    \n    return value / normalization;\n}\n    ", "buffer_a_code": "//Voronoi biome mapping\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    struct Biome {\n        vec2 pos;\n        vec3 color;\n    };\n    \n    Biome biomeList[8] = Biome[8] (\n        Biome(vec2(1., 0.3), vec3(.2, .7, .2)), //Dark Forest\n        Biome(vec2(0.6, 0.4), vec3(.2, .8, .2)), //Light Forest\n        Biome(vec2(0.4, 0.7), vec3(.6, .7, .4)), //Grayish-Green\n        Biome(vec2(0.45, 0.6), vec3(.55, .75, .35)), //Semi-Savannah\n        Biome(vec2(.6, 1.), vec3(.9, .9, .9)), //Snow\n        Biome(vec2(0.2, 1.), vec3(.35, .35, .15)), //Mountains\n        Biome(vec2(0.05, 0.5), vec3(.8, 1., .6)), //Savannah\n        Biome(vec2(0, 0.3), vec3(9., .7, .3)) //Desert\n    );\n    \n    float minDist = 9999.0;\n    vec3 closestColor = vec3(0);\n    for (int i = 0; i < biomeList.length(); i += 1) {\n        float d = length(biomeList[i].pos - uv);\n        if (d < minDist) {\n            minDist = d;\n            closestColor = biomeList[i].color;\n        }\n    }\n    \n    //Check for water\n    if (uv.y + (uv.x * 0.1) < 0.15) {\n        closestColor = vec3(.2, .6, 1.);\n    }\n    \n    fragColor = vec4(closestColor, 1.);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 181], [183, 183, 232, 232, 296], [298, 298, 355, 355, 858]], "test": "untested"}
{"id": "tlyfDt", "name": "smiley shader tutorial", "author": "Tater", "description": "wow", "tags": ["firstshader"], "likes": 3, "viewed": 254, "published": 3, "date": "1615328712", "time_retrieved": "2024-07-30T19:33:21.158308", "image_code": "//mostly the intro tutorials from \"The Art of Code\"\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n\n    float d = length(uv-p);\n    \n    float c = smoothstep(r, r-blur ,d);\n    return c;\n}\nmat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n\n}\nfloat Smiley(vec2 uv, vec2 p, float size) \n{\n    uv/=size;\n    uv-=p; \n    \n    float mask = Circle(uv, vec2(0.), .4, .01);\n\n    mask -= Circle(uv, vec2(.1, .2), .07, .01);\n    mask -= Circle(uv, vec2(-.1, .2), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0.,-0.1), .1,.01);\n    mouth -= Circle(uv, vec2(0.,0.),.1,.01);\n    mouth = clamp(mouth,0.,1.);\n    \n    mask-=mouth;\n    \n    return mask;\n}\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur,start + blur,t);\n    \n    float step2 = smoothstep(end + blur,end - blur,t);\n    \n    return step1*step2;\n    \n    \n}\nfloat remap01 (float a, float b, float t)\n{\n    return (t-a) / (b-a);\n}\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return remap01(a,b,t) * (d-c) + c;\n}\n\n\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\nfloat Band1 = Band(uv.x, left, right, blur);\nfloat Band2 = Band(uv.y, bottom, top, blur);\n\nreturn Band1*Band2;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=vec2(.5, .5); // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvi = uv;\n    \n\n    \n    t = (floor(t) + fract(t)*fract(t))*2.0;\n    \n    \n    uv.y+=sin(t+uv.x*20.)/10.;\n    uv.x+=sin(t+uv.y*20.)/20.;\n    \n    //spiiiiin\n    //uv*=Rot(iTime*2.); \n    \n    uv*=1.3;\n\n    vec3 col = vec3(0.);\n\n    float blur = remap(-1., 1., .01, .1, sin(t));\n    float mask = Rect(uv, -.25, .25, -.3, .3, blur);\n    \n    mask -= 0.5*Smiley(uvi, vec2(0), .5);\n    \n    col = (vec3(.5,0.,1.))*mask;\n\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 103, 103, 193], [194, 194, 212, 212, 274], [275, 275, 319, 319, 677], [678, 678, 735, 735, 895], [896, 896, 939, 939, 967], [968, 968, 1026, 1026, 1067], [1071, 1071, 1154, 1154, 1269], [1272, 1272, 1329, 1329, 1933]], "test": "untested"}
{"id": "tlVfDt", "name": "Dithering color banding away", "author": "luluco250", "description": "Simplistic example of how dithering helps combat color banding.\nThis is just using pseudo random noise, proper dithering should use another algorithm.\nClick and drag the mouse horizontally to control the banding, vertically to control the dithering.", "tags": ["2d", "blur", "filter", "dither", "dithering"], "likes": 7, "viewed": 709, "published": 3, "date": "1615323281", "time_retrieved": "2024-07-30T19:33:22.011029", "image_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    vec2 mouse = getMouse(iMouse, ps).xy;\n    color = blur(iChannel0, uv, ps, vec2(0, ps.y), mouse);\n    color = quantize(color, mouse);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    color = texture(iChannel0, coord * ps);\n    color = quantize(color, getMouse(iMouse, ps).xy);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int BlurSamples = 27;\nconst float MaxQuantization = 64.0;\nconst float MaxDither = 20.0;\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noiseDir(vec2 uv) {\n    return rand(uv) * 2.0 - 1.0;\n}\n\nvec4 quantize(vec4 color, vec2 mouse) {\n    float amount = mouse.x * MaxQuantization;\n    return round(color * amount) / amount;\n}\n\nvec4 blur(sampler2D sp, vec2 uv, vec2 ps, vec2 dir, vec2 mouse) {\n    vec2 offset =\n        MaxDither *\n        mouse.y *\n        vec2(ps.x * noiseDir(uv), ps.y * noiseDir(uv.yx));\n    \n    vec4 color = vec4(0);\n    uv -= dir * float(BlurSamples) * 0.5;\n    \n    for (int i = 0; i < BlurSamples; ++i) {\n        uv += dir;\n        color += texture(sp, uv + offset);\n    }\n    \n    color /= float(BlurSamples);\n    return color;\n}\n\nvec2 getMouse(vec4 mouse, vec2 ps) {\n    return mouse.z > 0.0 ? mouse.xy * ps : vec2(0.8, 0.3);\n}", "buffer_b_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    vec2 mouse = getMouse(iMouse, ps).xy;\n    color = blur(iChannel0, uv, ps, vec2(ps.x, 0), mouse);\n    color = quantize(color, mouse);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 245]], "test": "untested"}
{"id": "wlKfDt", "name": "1200K", "author": "dyla", "description": "Slightly modified version of 53K [url]https://www.shadertoy.com/view/tlVfRc[/url]", "tags": ["procedural", "noise", "fbm", "fire", "warp", "warped"], "likes": 6, "viewed": 387, "published": 3, "date": "1615322582", "time_retrieved": "2024-07-30T19:33:22.787951", "image_code": "float prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) - 0.5;\n}\n\nfloat fprand(vec2 uv, float f){\n    vec2 sp = uv*f;\n    vec2 isp = floor(sp);\n    vec2 fsp = fract(sp);\n    \n    float a = prand(isp+0.5);\n    float b = prand(isp+0.5+vec2(1.0,0.0));\n    float c = prand(isp+0.5+vec2(0.0,1.0));    \n    float d = prand(isp+0.5+vec2(1.0,1.0));\n    float wx = fsp.x;\n    float wy = fsp.y;\n    return mix(mix(a,b,wx), mix(c,d,wx), wy);\n    \n}\n\nfloat perlin(vec2 uv, int octaves, float f0, float fmul, float v0, float vmul){\n    float val = 0.0;\n    float frq = f0;\n    float wei = v0;\n    float time = mod(iTime, 1000.0);\n    vec2 wind = vec2(0.15, -1.0)*0.005;\n    \n    for (int i=0; i<octaves; i++) {\n        val += wei * fprand(uv+wind*float(i)*time, frq);\n        frq *= fmul;\n        wei *= vmul;\n    }\n    \n    return val;\n}\n\nfloat pdef(vec2 uv) {\n    return perlin(uv, 11, 0.65, 1.6, 1.0, 0.65);\n}\n\nfloat warped(vec2 uv) {\n    return pdef(uv+vec2(pdef(uv+pdef(uv)), pdef(uv+pdef(uv+3.145)+1.25)));\n}\n\nvec4[3] cols = vec4[3](\n    \tvec4(0.25, 0.01, 0.01, 0.00),\n    \tvec4(0.95, 0.75, 0.10, 0.50),\n    \tvec4(1.00, 1.00, 1.00, 1.00)\n    );\n\nvec4 getCol(float col) {\n    /*float lf = float(cols.length()-1);\n    float ci = floor(col * lf);\n    int cii = int(ci);\n    return mix(cols[cii], cols[cii+1], smoothstep(0.0, 1.0, fract(col*lf)));*/\n    int l=cols.length();\n    int i=0;\n    for (i=0; i<l; i++) {\n        if (cols[i].w>=col) break; \n    }\n    if (i==0) return cols[0];\n    if (i==l) return cols[l-1];\n    float w = (col-cols[i-1].w)/(cols[i].w-cols[i-1].w);\n    return mix(cols[i-1], cols[i], w);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n    \n    float t = mod(iTime, 1000.0);\n    float tm = 10.0;\n    float mt = mod(t, tm);\n    float transitionStart = 0.8;\n    float col2Weight = smoothstep(transitionStart,1.0,mt/tm);\n   \n    vec4 col1 = getCol(abs(warped(uv+(t-mt))));\n    vec4 col2 = col2Weight>0.0 ? getCol(abs(warped(uv+(t+tm-mt)))) : col1;\n    \n    fragColor = mix(col1, col2,  col2Weight);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 107], [109, 109, 140, 140, 480], [482, 482, 561, 561, 868], [870, 870, 891, 891, 942], [944, 944, 967, 967, 1044], [1182, 1182, 1206, 1381, 1652], [1654, 1654, 1711, 1711, 2137]], "test": "untested"}
{"id": "wtKfWt", "name": "scale from center", "author": "aferriss", "description": "Simple scale from center example", "tags": ["uv", "center", "scale"], "likes": 2, "viewed": 1293, "published": 3, "date": "1615310238", "time_retrieved": "2024-07-30T19:33:23.553903", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // Convert uv range to -1 to 1\n    uv = uv * 2.0 - 1.0;\n    \n    // Scale uv\n    uv *= (sin(iTime) * 0.5 + 0.5) * 2.0;\n    \n    // Convert back to 0 to 1 range\n    uv = uv * 0.5 + 0.5;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 409]], "test": "untested"}
{"id": "ttKfWt", "name": "ghost red illusion", "author": "FabriceNeyret2", "description": "surrounding grey with white lines on cyan background makes the grey look redish. \nright: without white. bottom: zoom.\nReference: [url]https://www.science-et-vie.com/cerveau-et-intelligence/illusion-il-n-y-a-pas-une-once-de-rouge-dans-ce-dessin-61486[/url]", "tags": ["illusion", "perception", "reproduction"], "likes": 6, "viewed": 284, "published": 3, "date": "1615310103", "time_retrieved": "2024-07-30T19:33:24.685877", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / 50., V; \n    if ( u.y/R.y < .25 ) U /= 4.;                            // bottom : zoom\n    V = abs(fract(U)-.5);                                    // tiles + symmetry\n    float m = min(V.x,V.y);\n    O = m < .02         ? vec4(.7)                           // grey grid\n      : m<.04 && U.x<0. ? vec4(1)                            // surrounding white (left half of window )\n      :                   vec4(.6,1,1,0);                    // cyan background\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 552]], "test": "untested"}
{"id": "WlVfWd", "name": "fork- riff #1234", "author": "jorge2017a1", "description": "fork- riff #1234\n//https://www.shadertoy.com/view/WlSGWw", "tags": ["forkriff1234"], "likes": 3, "viewed": 304, "published": 3, "date": "1615302069", "time_retrieved": "2024-07-30T19:33:25.641322", "image_code": "//modificado por jorge flores p.  -9-mar-2020\n//https://www.shadertoy.com/view/wlcfRB\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float signal = uv.x;\n    \n    float quantizedSignal = round(signal * 8.0)/8.0;\n    \n    float error = abs(quantizedSignal-signal);\n    //error /= 0.125;\n    error /= 0.0625;\n    \n    float compare = round(signal * 8.0) / 8.0;\n    \n    //float outputCol = mix(error, compare, step(0.5, uv.y));\n    float outputCol = error;\n    float s = 0.5 + 0.5*cos(iTime+length(uv.xyx+vec3(0,2,4) ));\n    \n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col1=vec3(outputCol*s+0.25,outputCol*s+0.3,outputCol*s+0.3);\n    \n    float t1 =mod(iTime, 3.);\n    float t2 =mod(iTime, 6.);\n    \n    if (t1<t2)\n        col1*=col;\n    \n    \n    fragColor = vec4(col1,1.0);\n}", "image_inputs": [], "sound_code": "//modificado por jorge flores p.  -9-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\nvec2 mainSound( in int samp,float time){return m(time);}", "sound_inputs": [], "common_code": "//modificado por jorge flores p.  -9-mar-2020\n\n//Created by nabr in 2019-06-05\n//https://www.shadertoy.com/view/WlSGWw\n\n\n\n// nabr\n// https://www.shadertoy.com/view/WlSGWw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\nvec2 synthv2( float t)\n{\n// --------- SYNTH\n    int t1=int(t) % 5;\n\tvec2 s = sin(t * mat4x2(496, 656, 696, 376, 776, 456, 656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n   \n\nvec2 synthv3( float pt)\n{\n    float t=mod(pt,10.0);\n// --------- SYNTH\n    int t1=int(t) % 5;\n\tvec2 s = sin(t * mat4x2(3496, 1656, 1696, 1376, 1776, 1456, 1656, 276)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n        \n    return s;\n }  \n\nvec2 m(float t)\n{\n\t\n    // --------- SYNTH\n    int t1=int(t) % 8;\n\tvec2 s = sin(t * mat4x2(596, 756, 796, 476, 676, 356, 556, 476)[t1]) - .5;\n    \n\tif(t<6.) // intro\n\t\ts *= sin(s * mod(t, 8.) + 18. * sin(t));\n\telse \n\t\ts *=  sin(s * mod(t, 8.) * 16.) * min(1., fract(t * 6.) * 100.) * max(0., 1. - fract(t * 6.));\n    \n    \n    vec2 s2= synthv2( t);\n    float ta1=mod(t,5.);\n    float ta2=mod(t,10.);\n    if (ta1<ta2)\n    s+=s2;\n    else\n    s+=5.0*s2*sin(s2);\n    \n    \n    vec2 s3= synthv3( t);\n    s+=s3;\n    \n\t// --------- DRUMS(kick)\n    \n\tfloat tm = mod(t, .5);\n    float tm2 = mod(t, 1.8);\n    \n\tif(t<6.) tm = mod(t, 1.5); // intro\n\tfloat finetune = 1.8;\n    \n    if(tm<6.) tm = mod(tm, 2.5); // intro\n\tfloat finetune2 = 2.8;\n    \n\t// kick\n\t\n    float k = (sin(80.0 * exp(-sin(tm * finetune) * 10.0)) * exp(-tm * 10.0));\n\tk *= cos(120.0 * exp(-tm * 2.0));\n    \n    \n    \n    // sub\n\tfloat kovt = (k - sin(tm * 580.) * exp(-tm * 1.5));\n\tkovt *= min(1., tm * 100.) * max(0., .5 - tm);\n\tkovt -= (.25 - asin(kovt * tm * 12.));\n\tk *= min(1., tm * 500.) * max(0., 1. - tm);\n\tk = 1.9 * (kovt + k);\n    \n    \n    \n\t\n    // -------- MASTER\n    \n\treturn (k + .4 * s ) * .25;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 144, 144, 864]], "test": "untested"}
{"id": "wlyBDt", "name": "Fractal 37_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 17, "viewed": 541, "published": 3, "date": "1615274206", "time_retrieved": "2024-07-30T19:33:26.409269", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(vec3(1),H(log(s)/6.+.9),.2)*pow(abs(cos(i*i/20.)),3.)/e/1e5\n    )\n    {\n        p=g*d-vec3(.3,.1,2);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.4);\n        p.xz=vec2(atan(p.z,p.x),length(p.xz));\n        //p.yz=vec2(atan(p.z,p.y),length(p.yz));\n        p.z=fract(log(p.z)-iTime*.2)-.5;\n        s=2.5;\n        for(int j=0;j++<6;p=abs(p)*e-vec3(1.8,3,.01))\n            s*=e=5./min(dot(p,p),2.8);\n        g+=e=abs(length(p.yz)/s-5e-4)+1e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 738]], "test": "untested"}
{"id": "wtyfWt", "name": "cone camera scene", "author": "jorge2017a1", "description": "cone camera scene", "tags": ["conecamerascene"], "likes": 1, "viewed": 249, "published": 3, "date": "1615261429", "time_retrieved": "2024-07-30T19:33:27.211125", "image_code": "//por jorge2017a1-\n\n//https://iquilezles.org/articles/distfunctions\n\n\n#define MAX_STEPS 120\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\n///------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec3 casaCono1(vec3 p)\n{ \n   vec3 res;\n   res = vec3(9999.0, -1.0,-1.0);\n    \n   float sc1= sdCappedCone(  p, 20.0, 10.0, 0.5 );\n   float c1= sdCylinderXZ( p-vec3(0.0,15.0,0.0), vec2(5.0,0.25)  );\n   float c2= sdCylinderXZ( p-vec3(0.0,12.5,0.0), vec2(5.0,0.25)  );\n   float c3= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(5.0,0.25)  );\n   float c4= sdCylinderXZ( p-vec3(0.0,7.5,0.0), vec2(5.0,0.25)  );\n   \n   \n   res =opU3(res, vec3(sc1,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c1,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c2,11.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c3,1.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c4,11.0,MATERIAL_NO)); \n   return res;\n}\n\n\nvec3 casaCono2(vec3 p)\n{ \n   vec3 res;\n   res = vec3(9999.0, -1.0,-1.0);\n    \n   float sc1= sdCappedCone(  p, 30.0, 10.0, 0.5 );\n   float c1= sdCylinderXZ( p-vec3(0.0,15.0,0.0), vec2(15.0,0.25)  );\n   float c2= sdCylinderXZ( p-vec3(0.0,12.5,0.0), vec2(12.0,0.25)  );\n   float c3= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(10.0,0.25)  );\n   float c4= sdCylinderXZ( p-vec3(0.0,7.5,0.0), vec2(7.5,0.25)  );\n   \n   \n   res =opU3(res, vec3(sc1,5.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c1,7.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c2,12.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c3,7.0,MATERIAL_NO)); \n   res =opU3(res, vec3(c4,12.0,MATERIAL_NO)); \n   return res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    p.y=p.y-5.0;\n    \n    \n    vec3 prepA=p;\n    vec3 prepB=p;\n    prepA.x =opRep1D( prepA.x, 50.0 );\n    prepA.z =opRep1D( prepA.z, 50.0 );\n    \n    prepB.x =opRep1D( prepB.x, 100.0 );\n    prepB.z =opRep1D( prepB.z, 60.0 );\n    \n    vec3 cc1= casaCono1(prepA);\n    vec3 cc2= casaCono2(prepB-vec3(20.0,0.0,15.0));\n    \n    res =opU3(res, cc1 ); \n    res =opU3(res, cc2 ); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    //mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.125;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n\n    vec3 ro;\n    vec3 rd;\n\n    float t2=mod(iTime,15.0);\n    //escena 1\n    if(t2<5.0)\n    {\n        ro=vec3(40.0,60.0,-55.0-t);\n        rd=normalize(vec3(uv,1.0));\n        rd= rotate_x(rd, radians(90.0) );\n    }\n    else if (t2<10.0)\n    {\n         ro=vec3(40.0,5.0,-55.0+t);\n         rd=normalize(vec3(uv,1.0));\n    }\n    else if(t2<15.0)\n    {\n        ro=vec3(40.0,3.0,-55.0-t);\n        rd=normalize(vec3(uv,1.0));\n        rd= rotate_x(rd, radians(270.0) );\n    }\n    \n     \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 451, 490, 490, 585], [587, 671, 707, 707, 752], [754, 819, 853, 853, 951], [952, 952, 986, 986, 1078], [1079, 1079, 1113, 1113, 1205], [1247, 1263, 1288, 1288, 1307], [1308, 1308, 1333, 1333, 1352], [1353, 1353, 1389, 1389, 1417], [1419, 1419, 1478, 1478, 1791], [1794, 1794, 1818, 1818, 2451], [2454, 2454, 2478, 2478, 3114], [3117, 3157, 3182, 3182, 3829], [3831, 3831, 3896, 3896, 4480], [4482, 4533, 4557, 4557, 4745], [4748, 4748, 4781, 4781, 5569], [5574, 5628, 5664, 5664, 5898], [5899, 6000, 6080, 6080, 6357], [6400, 6451, 6498, 6498, 7271], [7325, 7325, 7418, 7418, 7698], [7700, 7700, 7727, 7727, 7837], [7838, 7887, 7944, 7944, 9716]], "test": "untested"}
{"id": "WtyfWt", "name": "Digital_Clock", "author": "DesktopCommando", "description": "Forked from Andre, to remove the Sound https://www.shadertoy.com/view/Xsy3zG\n\n", "tags": ["2d", "clock", "digital"], "likes": 6, "viewed": 429, "published": 3, "date": "1615244277", "time_retrieved": "2024-07-30T19:33:27.973088", "image_code": "float segment(vec2 uv)\n{\n    uv = abs(uv);\n\treturn (1.0-smoothstep(0.07,0.10,uv.x))\n         * (1.0-smoothstep(0.46,0.49,uv.y+uv.x))\n         * (1.25 - length(uv*vec2(3.8,1.3)));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    \n    if (num>=2 && num!=7 || num==-2)\n        seg = max(seg,segment(uv.yx));\n        \n    if (num==0 || \n            (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):\n            (uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))\n        seg = max(seg,segment(abs(uv)-0.5)); \n\t\n    if (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))\n        seg = max(seg,segment(vec2(abs(uv.y)-1.0,uv.x)));\n    \n\treturn seg;\n}\n\nfloat showNum(vec2 uv,float nr, bool zeroTrim)\n{\n    if (uv.x>-3.0 && uv.x<0.0)\n    {\n        float digit = floor(-uv.x / 1.5);\n\t\tnr /= pow(10.,digit);\n        nr = mod(floor(nr+0.000001),10.0);\n        if (nr==0.0 && zeroTrim && digit!=0.0)\n            return 0.;\n\t\treturn sevenSegment(uv+vec2( 0.75 + digit*1.5,0.0),int(nr));\n    }\n\treturn 0.;\n}\n\nfloat dots(vec2 uv)\n{\n\tuv.y = abs(uv.y)-0.5;\n\tfloat l = length(uv);\n\treturn (1.0-smoothstep(0.11,0.13,l)) * (1.0-l*2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.x;\n    \n    uv *= 11.0;\n    uv.x -= 5.+uv.y*.07;\n\n    if (uv.x<-10.0 || uv.x>0.0 || abs(uv.y)>1.2) {\n        fragColor = vec4(0.);\n    \treturn;\n    }\n    \n    float p = floor(abs(uv.x/3.5));\n    uv.x = mod(uv.x,3.5)-3.5;\n    \n\tfloat seg = 0.0;\n    if (uv.x>-3.)\n\t    seg = showNum(uv,mod(iDate.w/pow(60.0,p),60.0),p==2.0);\n    else\n    {\n        uv.x += 3.25;\n\t\tseg = dots(uv);\n    }\n\t\n    fragColor = vec4(seg,0.,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 180], [182, 182, 219, 219, 657], [659, 659, 707, 707, 1006], [1008, 1008, 1029, 1029, 1130], [1132, 1132, 1189, 1189, 1672]], "test": "untested"}
{"id": "3tGBWt", "name": "Multipoint color gradient", "author": "_samuelcho_", "description": "A simple way to make multicolor gradients", "tags": ["gradient"], "likes": 14, "viewed": 671, "published": 3, "date": "1615239208", "time_retrieved": "2024-07-30T19:33:28.761979", "image_code": "const vec3 colors[] = vec3[](\nvec3(176.,29.,30.) / 255.,\nvec3(241.,104.,38.) / 255.,\nvec3(234.,211.,95.) / 255.,\nvec3(0.,187.,173.) / 255.,\nvec3(0.,107.,228.) / 255.,\nvec3(126.,99.,180.) / 255.);\n\n\n\n\nvec3 RAMP(vec3 cols[6], float x) {\n    x *= float(cols.length() - 1);\n    return mix(cols[int(x)], cols[int(x) + 1], smoothstep(0.0, 1.0, fract(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = RAMP(colors,uv.x);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 234, 234, 351], [353, 353, 410, 410, 529]], "test": "untested"}
{"id": "wtKfWc", "name": "Blur-Edge loop", "author": "account", "description": "Blur-Edge loop", "tags": ["blur", "loop", "edge"], "likes": 5, "viewed": 353, "published": 3, "date": "1615231490", "time_retrieved": "2024-07-30T19:33:29.535909", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col = edge(uv);\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 blur(vec2 uv){\nvec3 c = texture(iChannel0, uv).xyz;\nuv *= iResolution.xy;\nfloat r = 2.;\nfloat ang = 20.;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     vec3 col = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyz;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n}\n\nvec3 edge(vec2 uv,vec3 c, vec3 c1, vec3 c2, vec3 c3, vec3 c4){\nvec3 col = vec3(0.);\nfloat f = 0.05;\nfloat filter2 = 0.5;\nvec3 shade = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\nif(abs(c.x-c1.x) >  f || abs(c.y-c1.y) >  f || abs(c.z-c1.z) >  f ){\n  col += min(max(abs(c.x-c1.x), max(abs(c.y-c1.y),abs(c.z-c1.z)))*1.5, filter2);\n}\nif(abs(c.x-c2.x) >  f || abs(c.y-c2.y) >  f || abs(c.z-c2.z) >  f ){\n  col += min(max(abs(c.x-c2.x), max(abs(c.y-c2.y),abs(c.z-c2.z)))*1.5, filter2);\n}\nif(abs(c.x-c3.x) >  f || abs(c.y-c3.y) >  f || abs(c.z-c3.z) >  f ){\n   col += min(max(abs(c.x-c3.x), max(abs(c.y-c3.y),abs(c.z-c3.z)))*1.5, filter2);\n}\nif(abs(c.x-c4.x) >  f || abs(c.y-c4.y) >  f || abs(c.z-c4.z) >  f ){\n   col += min(max(abs(c.x-c4.x), max(abs(c.y-c4.y),abs(c.z-c4.z)))*1.5, filter2);\n}\ncol *= shade*1.1;\nreturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n    vec3 col;\n    if(iFrame > 2){\n    vec3 c =  blur(uv/iResolution.xy);\n    vec3 c1 = blur((uv + vec2(-3.,0.))/iResolution.xy);\n    vec3 c2 = blur((uv + vec2(3.,0.))/iResolution.xy );\n    vec3 c3 = blur((uv + vec2(0.,3.))/iResolution.xy );\n    vec3 c4 = blur((uv + vec2(0.,-3.))/iResolution.xy);\n    \n    col = edge(uv/iResolution.xy,c,c1,c2,c3,c4);\n    //col = c;\n    }else{\n    col = texture(iChannel1, uv/iResolution.xy).xyz;\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 278]], "test": "untested"}
{"id": "3lVBDc", "name": "Gamut chooser intensity mapper", "author": "davidjonsson", "description": "Choose the intensity gamut with the mouse in the image. All colors are mapped similarly.", "tags": ["gamut"], "likes": 1, "viewed": 398, "published": 3, "date": "1615218635", "time_retrieved": "2024-07-30T19:33:30.334773", "image_code": "/*\n* Choose the gamut with the mouse in the image. All colors are mapped similarly.\n* Small nuances can be enlarged in the upper left corner.\n* Some cameras transmit compressed images with compression noise.\n* Thermal noise is mostly visible with large y.\n*\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;  \n\tvec4 col = texture(iChannel0, p);\n    vec4 videoOut = 10. * iMouse.y/iResolution.y * col + (10. * iMouse.x/iResolution.x - 5.);\n\t\n    fragColor = videoOut;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 319, 319, 522]], "test": "untested"}
{"id": "ttVBzd", "name": "Extruded Truchet Pattern", "author": "Shane", "description": "A basic extruded square grid-based blobby Truchet pattern.", "tags": ["grid", "raymarch", "blob", "truchet", "pattern", "extrude"], "likes": 145, "viewed": 7121, "published": 3, "date": "1615206621", "time_retrieved": "2024-07-30T19:33:31.294208", "image_code": "/*\n\n    Extruded Truchet Pattern\n    ------------------------\n    \n    I enjoy utilizing simple 2D techniques to render faux 3D imagery.\n    Sometimes, I'll do it for nostalgic reasons, and other times out of \n    sheer curiosity to see if it's possible to make a particular 3D \n    scene without the use of a 3D rendering scheme.\n    \n    Anyway, a while back, I raymarched a very basic extruded blobby \n    square grid-based Truchet in order to have an actual 3D visual \n    reference when constucting my \"Faux Layered Extrusion\" example. I \n    came across it recently, so decided to pretty it up a little.\n    \n    I enjoyed making this, mainly because it didn't involve any thinking.\n    The 2D blobby Truchet consisted of just a few lines, extruding it \n    was as simple as it gets, and the coloring was just applying 2D \n    rendering techniques to the floor and top extruded face. I wish all \n    examples were this easy. :) By the way, I'm going to post a slightly \n    more complicated blobby Truchet example after this.\n    \n\n\n    References:\n\n    // Fake 3D extrusion using 2D techniques.\n\tFaux Layered Extrusion - Shane\n    https://www.shadertoy.com/view/Wsc3Ds\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n    // others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n\n\n*/\n \n\n// Show the blue floor markers.\n//#define BLUE_MARKERS\n\n// Subtle textured lines.\n#define LINES\n\n// Curve shape - Round: 0, Semi-round: 1, Octagonal: 2, Superellipse: 3, Straight: 4.\n#define SHAPE 0\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Various distance metrics.\nfloat dist(vec2 p){\n\n    #if SHAPE == 0\n    return length(p);\n    #else \n    p = abs(p);\n    #endif\n    \n    #if SHAPE == 1\n    return max(length(p), (p.x + p.y)*.7071 + .015);\n    #elif SHAPE == 2\n    return max((p.x + p.y)*.7071, max(p.x, p.y));\n    #elif SHAPE == 3\n    return pow(dot(pow(p, vec2(3)), vec2(1)), 1./3.); // 1.666, 4., etc.\n    #else\n    return (p.x + p.y)*.7071;\n    #endif\n    \n\n}\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nfloat tr(vec2 p){\n\n    \n    // ID and local coordinates.\n    const float sc = .5;\n    vec2 ip = floor(p/sc) + .5;\n    p -= ip*sc;\n    \n    // Random value, and alternate checkers.\n    float rnd = fract(sin(dot(ip, vec2(1, 113)))*45758.5453);\n  \n    if(rnd<.5) p.y = -p.y; // Rotate.\n    \n    // Opposite diagonal circles distances, etc.\n    float d = min(dist(p - .5*sc), dist(p + .5*sc)) - .5*sc;\n    #if SHAPE == 4\n    // If using straight lines, adjusting the width. \n    d += (.5 - .5/sqrt(2.))*sc;\n    #endif\n    \n    if(rnd<.5) d = -d; // Flip random.\n    \n    // Comment out to spoil the illusion.\n    if(mod(ip.x + ip.y, 2.)<.5) d = -d; // Flip alternate checkers.\n    \n    // Using a little CSG for some double edges. Interesting,\n    // but \"less is more,\" as they say. :)\n    //return min(d, abs(d + .03) - .03 - sc/8.); // Truchet border.\n    \n    // Wided the field a little, then return.\n    return d - .03;\n\n}\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    float obj = tr(p.xy);\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z) - .125) - smoothstep(.03, .25, -obj)*.1;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.z, .125, .01) - smoothstep(.03, .25, -obj)*.1; \n    \n    // Put some cylinder markers at opposite diagonals on the Truchet tiles.\n    // This is for purely decorational purposes.\n    float studs = 1e5;\n    const float sc = .5;\n    // Unique cell ID and local cell coordinates.\n    vec2 q = p.xy + .5*sc;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*sc;\n    \n    if(mod(iq.x + iq.y, 2.)>.5){  \n        studs = max(length(q) - .1*sc - .02, abs(p.z) - .26);       \n    }\n    #ifdef BLUE_MARKERS\n    else {\n        studs = max(length(q) - .1*sc - .03, abs(p.z - .125) - .175);\n    }\n    #endif\n    \n    // Object ID.\n    objID = fl<obj && fl<studs? 0 : obj<studs? 1 : 2;\n    \n    // Minimum distance for the scene.\n    return min(min(fl, obj), studs);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Standard normal function.\nvec3 nr(in vec3 p){\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2.);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += d*.7; // Advance the overall distance closer to the surface.\n        \n        // Accumulating light values along the way for some cheap glow.\n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = .5; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Half cell offset grid.\n    vec2 uv2 = p.xy + .5*sc;\n    vec2 iuv2 = floor(uv2/sc) + .5;\n    uv2 -= iuv2*sc;\n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .002;\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    d = tr(p.xy);\n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    float sf2 = dot(sin(p.xy*1.5 - cos(p.yx*3.)), vec2(.5));\n    vec4 col1 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col2 = mix(vec4(.4, .7, 1, 0), vec4(.3, .85, .95, 0), smoothstep(-.5, .5, sf2)*.5);\n    col1 = pow(col1, vec4(1.6));\n    col2 = mix(col1.zyxw, pow(col2, vec4(1.4)), .666);\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The blue floor:\n       \n       // Blue with some subtle lines.\n       oCol = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n       // Square borders: Omit the middle of edges where the Truchet passes through.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n       // Darken alternate checkers. \n       if(mod(iuv.x + iuv.y, 2.)>.5) oCol *= .8;\n       \n       // Using the Truchet pattern for some bottom edging.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .015))*.8);\n       \n       #ifdef BLUE_MARKERS\n       // If the blue markers are included, render dark rings just under them.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, length(uv2) - .09))*.8);\n       #endif\n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Truchet:\n \n        // White sides with a dark edge. \n        oCol = mix(vec4(1), vec4(0), 1. - smoothstep(0., .01, d + .05));\n        \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        // Darken alternate checkers on the face only.\n        if(mod(iuv.x + iuv.y, 2.)<.5) fCol *= .8;\n        \n        // Apply the golden face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .08));\n        \n        \n        // If the golden markers are included, render dark rings just under them.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, length(uv2) - .08))*.8);\n        \n    }\n    else {\n    \n        // The cylinder markers:\n        \n        // Color and apply patterns, edges, etc, depending whether it's\n        // blue floor makers or a golden Truchet one.\n        oCol = col1;\n        float ht = .26;\n        if(mod(iuv2.x + iuv2.y + 1., 2.)>.5) {\n            float tmp = pat; pat = pat2; pat2 = tmp;\n            oCol = col2;\n            ht = .05;\n        }\n        \n        // Marker dot or outer edge.\n        float mark = length(uv2);\n        float markRim = max(abs(mark - .07), abs(p.z + ht)) - .003;\n        \n        // Render the pattern, edge and face dot.\n        //oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, max(pat, abs(p.z + ht))))*.35);\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, markRim))*.8);\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, mark - .015))*.8);    \n    \n    } \n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    // Very metallic: Interesting, but ultimately, a bit much. :)\n    //c = oCol*oCol*1.5*(pow(df, 3.)*2.*sh + sp*sh*2. + .25)*at*ao;\n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1699, 1732, 1754, 1754, 1812], [1814, 1842, 1863, 1863, 1926], [1929, 1958, 1977, 1977, 2358], [2623, 2797, 2814, 2853, 3721], [5123, 5314, 5366, 5457, 6719], [6722, 6874, 6909, 6909, 7304], [7308, 7337, 7356, 7356, 7528], [7531, 7531, 7566, 7632, 13970]], "test": "untested"}
{"id": "wlVfWV", "name": "Somthing_1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 2, "viewed": 240, "published": 3, "date": "1615204316", "time_retrieved": "2024-07-30T19:33:32.161888", "image_code": "\n#define al .5;\n#define al_1 .98;\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 out_rect(vec2 coord, vec2 loc, vec2 size){\n    vec2 sw=loc-size/2.;\n    vec2 ne=loc+size/2.;\n    vec2 pct=smoothstep(sw,sw+.04,coord);\n    pct-=smoothstep(ne-.04,ne,coord);\n    \n    return vec3(pct.x * pct.y);\n}\n\nvec3 cir(vec2 coord, vec2 loc,  float ln){\n    float d=1.-distance(coord,loc);\n    d=smoothstep(ln*.85,ln,d);\n    d*=al;\n    return vec3(d+ 0.1*cos(-iTime+coord.yxy+vec3(0,2,4)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= fragCoord.x/iResolution.x;\n    uv.y *= fragCoord.x/iResolution.y;\n    for(float i=0.; i<5.;i++){\n    uv=abs(uv*2.-1.);\n    }\n    \n    uv*=.8+.3*sin(iTime*1.2);\n    uv*=Rot(3.141592/3.*sin(iTime*.5));//(50.+25.*sin(iTime*.7)));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col*=cir(uv,vec2(.5),.3);\n    //col*=out_rect(uv,vec2(.5),vec2(.6));\n    col+=cir(uv,vec2(.5),.7);\n    \n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 53, 53, 112], [114, 114, 161, 161, 330], [332, 332, 374, 374, 513], [516, 516, 573, 573, 1050]], "test": "untested"}
{"id": "WtKBWc", "name": "Segway Driving", "author": "dr2", "description": "Try to stay on the marked path; tracks remain on ground (temporarily)", "tags": ["game", "interactive", "motion", "control", "trajectory"], "likes": 16, "viewed": 344, "published": 3, "date": "1615204011", "time_retrieved": "2024-07-30T19:33:33.149248", "image_code": "// \"Segway Driving\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Knob controls speed and direction; mouseable; view direction changes at high elevation;\n  on-path distance shown.\n*/\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int npTrail = 512;  // same for image and buffer (the bigger the better)\nconst int npFst = 6;\n\nvec3 sunDir, qHit, carPos;\nvec2 wlBase, wlRot;\nfloat tCur, dstFar, carRot, carTlt, wlRad, hgSize, trWidf;\nint idObj;\nconst int idWhl = 1, idAxl = 2, idMudg = 3, idPlat = 4, idBatt = 5, idHand = 6;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  p.y -= wlRad;\n  p.yz = Rot2D (p.yz, carTlt);\n  q = p;\n  q.x = abs (q.x) - wlBase.x;\n  q.yz = Rot2D (q.yz, - ((p.x > 0.) ? wlRot.x : wlRot.y));\n  d = PrRoundCylDf (q.yzx, wlRad - 0.05, 0.05, 0.12);\n  a = (length (q.yz) > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n  d = max (d, 0.05 - length (Rot2D (q.yz, 2. * pi * floor (24. * a + 0.5) / 24.) +\n     vec2 (wlRad - 0.02, 0.)));\n  DMINQ (idWhl);\n  q = p;\n  q.x = abs (q.x) - wlBase.x + 0.2;\n  d = PrRoundCylDf (q.yzx, 0.1, 0.03, 0.4);\n  DMINQ (idAxl);\n  q = p;\n  q.x = abs (q.x) - wlBase.x;\n  d = SmoothMax (abs (PrRoundCylDf (q.yzx, wlRad, 0.1, 0.15)) - 0.02,\n     max (max (- q.y, q.z) - 0.18, q.x - 0.2), 0.05);\n  DMINQ (idMudg);\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (wlBase.x - 0.3, 0.08, 0.5), 0.05);\n  DMINQ (idPlat);\n  q = p;\n  q.yz -= vec2 (0.4, 0.2);\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.4, 0.2), 0.1);\n  DMINQ (idBatt);\n  q = p;\n  q.yz -= vec2 (1.5, 0.2);\n  d = min (PrCylDf (q.xzy, 0.08, 1.5), PrCylDf (q.xzy, 0.11, 0.08));\n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.yzx, 0.04, 0.05, 0.8));\n  DMINQ (idHand);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrailShd (vec2 p)\n{\n  vec3 u;\n  vec2 q, g, gp, gMid, dg;\n  float st, gLen;\n  st = 1.;\n  g = carPos.xz;\n  for (int j = VAR_ZERO; j < npTrail; j ++) {\n    gp = g;\n    u = Loadv4 (npFst + j).xyz;\n    if (u.z >= 0.) {\n      g = u.xy;\n      gMid = 0.5 * (g + gp);\n      dg = g - gp;\n      gLen = length (dg);\n      if (gLen > 0.) {\n        q = Rot2Cs (p - gMid, dg.yx / gLen);\n        q.x = abs (q.x) - wlBase.x;\n        st = min (st, 1. - 0.3 * sqrt (1. - float (j) / float (npTrail)) *\n           (1. - smoothstep (0., 0.05, PrRoundBox2Df (q, vec2 (0.01, 0.5 * gLen), 0.15))));\n      }\n    } else break;\n  }\n  return st;\n}\n\nvec3 GrndCol (vec3 ro, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  vec2 vf, q;\n  vec2 gId;\n  float a, f, ff, st;\n  gId = PixToHex (ro.xz / hgSize);\n  q = Rot2D ((ro.xz - HexToPix (gId * hgSize)) / hgSize,\n     (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  col = 0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n     0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  vf = vec2 (0.);\n  f = abs (length (q) - 0.5) - trWidf;\n  if (f < 0.) {\n    a = abs (mod (4. * (mod (15. * atan (q.y, - q.x) / (2. * pi), 1.) - 0.5) + 0.5, 1.) - 0.5) - 0.3;\n    for (float s = 1.; s >= 0.; s -= 1.) {\n      col = mix (vec3 (0.3, 0.5, 1.), col, max (smoothstep (0., 0.02, a - 0.03 * s),\n         smoothstep (0., 0.002, abs (f + 0.02) - 0.005)));\n    }\n  }\n  st = TrailShd (ro.xz);\n  vf = vec2 (16., 1. - 0.9 * f);\n  if (st < 1.) vf.y *= 2.;\n  vn = vec3 (0., 1., 0.);\n  ff = 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar);\n  if (vf.x > 0. && ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.)) * st;\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, r, sh;\n  bool isBg;\n  isBg = false;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    r = length (qHit.yz);\n    if (idObj == idWhl) col4 = vec4 (0.8, 0.8, 0.85, 0.1) * (1. - 0.7 * step (0.85, r)) *\n       (1. - 0.2 * step (r, 0.3) * smoothstep (0., 0.02,\n       abs (mod (12. * atan (qHit.z, qHit.y) / (2. * pi) + 0.5, 1.) - 0.5) - 0.2));\n    else if (idObj == idAxl) col4 = vec4 (0.4, 0.4, 0.45, 0.);\n    else if (idObj == idMudg) col4 = vec4 (0.2, 0.9, 0.2, 0.1) * (0.5 +\n       0.5 * step (0., PrRoundBox2Df (vec2 (qHit.x, r), vec2 (0.15, wlRad), 0.1))) *\n       (0.8 + 0.2 * smoothstep (0., 0.02, abs (abs (qHit.x) - 0.05) - 0.01));\n    else if (idObj == idPlat) col4 = vec4 (0., 0.7, 0., 0.) * (1. - \n       0.2 * step (abs (qHit.z), 0.5) * step (0., qHit.y) * smoothstep (0., 0.1, mod (8. * qHit.z, 1.) - 0.6));\n    else if (idObj == idBatt) col4 = vec4 (0., 0.8, 0., 0.1);\n    else if (idObj == idHand) col4 = vec4 (0.8, 0.9, 0.8, 0.2) * (1. - 0.3 * step (0.3, abs (qHit.x)));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  } else {\n    isBg = true;\n    col = SkyBgCol (ro, rd);\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    if (dstObj < dstFar) col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    else col = mix (GrndCol (vec3 (ro.xz, 0.).xzy, dstGrnd, sh), vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col, wgBox;\n  vec2 canvas, uv, ud, cnPos;\n  float el, az, zmFac, asp, onPath, trvDist, s, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xy;\n  wlRad = wlBase.y;\n  stDat = Loadv4 (2);\n  hgSize = stDat.x;\n  trWidf = stDat.y;\n  onPath = stDat.z;\n  trvDist = stDat.w;\n  stDat = Loadv4 (3);\n  az = stDat.x;\n  el = stDat.y;\n  cnPos = stDat.zw;\n  stDat = Loadv4 (4);\n  carTlt = stDat.x;\n  wlRot = stDat.zw;\n  stDat = Loadv4 (5);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  if (el > -0.37 * pi) az += carRot;\n  vuMat = StdVuMat (el, az);\n  ro = carPos + vuMat * vec3 (0., 3., -12.);\n  zmFac = 3. + 2. * el;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  wgBox = vec3 (0.41, -0.32, 0.135);\n  ud = 0.5 * uv - wgBox.xy * vec2 (asp, 1.);\n  s = (length (ud) - wgBox.z) * canvas.y;\n  col = mix (vec3 (0.5), col, smoothstep (0., 1., abs (s) - 1.));\n  if (s < 0.) {\n    col = mix (vec3 (0.5), col, step (1., Minv2 (abs (ud)) * canvas.y));\n    col = mix (((onPath > 0.) ? vec3 (0., 1., 0.) : vec3 (0.8, 0., 0.)), col,\n       smoothstep (2.5, 3.5, abs (length (ud - cnPos) * canvas.y - 10.)));\n  }\n  col = mix (col, vec3 (0., 1., 0.), ShowIntPZ (0.5 * uv - vec2 (0.44 * asp, -0.15),\n     vec2 (0.06 * asp, 0.03), 4., mod (floor (trvDist / (2. * wlRad)), 1e4)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Segway Driving\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int npTrail = 512;  // same for image and buffer (the bigger the better)\nconst int npFst = 6;\n\nvec3 carPos;\nfloat hgSize, trWidf;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat OnPath ()\n{\n  vec2 q, gId;\n  q = carPos.xz;\n  gId = PixToHex (q / hgSize);\n  q = Rot2D ((q - HexToPix (gId * hgSize)) / hgSize, (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  return (abs (length (q) - 0.5) < trWidf) ? 1. : 0.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBox;\n  vec2 iFrag, canvas, cnPos, wlBase, wlRot, cp, ud, w;\n  float tCur, autoMd, carRot, cRotN, strRot, wlRad, rTurn, spd, carTlt, onPath, trvDist, tc, nStep,\n     az, el, asp, s;\n  int pxId, wgSel, nFrame;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= npFst + npTrail) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n init = (nFrame <= 5);\n  asp = canvas.x / canvas.y;\n  if (init) {\n    mPtrP = mPtr;\n    carPos = vec3 (0.);\n    carRot = 0.;\n    carTlt = 0.;\n    wlRad = 1.;\n    wlBase = vec2 (1.2, wlRad);\n    strRot = 0.;\n    wlRot = vec2 (0.);\n    autoMd = 1.;\n    az = 0.;\n    el = -0.37 * pi;\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    wgSel = 0;\n    hgSize = 40.;\n    trWidf = 0.12;\n    onPath = 0.;\n    trvDist = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    wlBase = stDat.xy;\n    nStep = stDat.z;\n    autoMd = stDat.w;\n    stDat = Loadv4 (2);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    onPath = stDat.z;\n    trvDist = stDat.w;\n    stDat = Loadv4 (3);\n    az = stDat.x;\n    el = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (4);\n    carTlt = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n    stDat = Loadv4 (5);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n  }\n  if (pxId < npFst) {\n    wgBox = vec3 (0.41, -0.32, 0.135);\n    if (mPtr.z > 0.) {\n      if (wgSel == 0 && mPtrP.z > 0.) {\n        az = -2. * pi * mPtr.x;\n        el = - pi * mPtr.y;\n      } else {\n        ud = mPtr.xy * vec2 (asp, 1.) - wgBox.xy * vec2 (asp, 1.);\n        if (wgSel == 1) {\n          autoMd = - tCur;\n          cnPos = ud;\n          s = length (cnPos);\n          if (s > 0.) cnPos = min (s, wgBox.z) * cnPos / s;\n        } else if (mPtrP.z <= 0. && length (ud) < wgBox.z) wgSel = 1;\n      }\n    } else {\n      wgSel = 0;\n      cnPos *= 1. - 5e-3;\n    }\n    wlRad = wlBase.y;\n    ++ nStep;\n    if (autoMd > 0.) {\n      tc = mod (0.003 * nStep, 4.);\n      strRot = 0.12 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n         sign (tc - 2.);\n      spd = 0.05 - 0.03 * abs (strRot / (0.12 * pi));\n      w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n      w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n      cnPos = w * wgBox.z;\n    } else {\n      w = cnPos / wgBox.z;\n      w = pow (abs (w), vec2 (1.5)) * sign (w);\n      strRot = -0.15 * pi * w.x;\n      spd = max (-0.05, 0.25 * w.y);\n      if (tCur + autoMd > 10.) {\n        autoMd = 1.;\n        el = -0.37 * pi;\n      }\n    }\n    cp = carPos.xz;\n    w = vec2 (1.);\n    if (abs (strRot) > 1e-4) {\n      rTurn = 0.5 / strRot;\n      rTurn = max (6. * wlBase.x, abs (rTurn)) * sign (rTurn);\n      cRotN = carRot - spd / rTurn;\n      carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n      carRot = mod (cRotN, 2. * pi);\n      w -= vec2 (-1., 1.) * wlBase.x / rTurn;\n    } else {\n      carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n    }\n    wlRot += w * spd / wlRad;\n    carTlt = -0.4 * spd;\n    if (pxId == 2) {\n      onPath = OnPath ();\n      if (onPath > 0.) trvDist += length (carPos.xz - cp);\n      else trvDist = 0.;\n    }\n  }\n  if (! init) {\n    if (mod (float (nFrame), 8.) == 0.) {\n      if (pxId == npFst) stDat = vec4 (Loadv4 (5).xzw, 0.);\n      else if (pxId < npFst + npTrail) stDat = Loadv4 (pxId - 1);\n    } else if (pxId >= npFst && pxId < npFst + npTrail) stDat = Loadv4 (pxId);\n  } else {\n    stDat = vec4 (0., 0., -1., 0.);\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (wlBase.xy, nStep, autoMd);\n  else if (pxId == 2) stDat = vec4 (hgSize, trWidf, onPath, trvDist);\n  else if (pxId == 3) stDat = vec4 (az, el, cnPos);\n  else if (pxId == 4) stDat = vec4 (carTlt, strRot, wlRot);\n  else if (pxId == 5) stDat = vec4 (carPos, carRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKBWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1348, 1348, 1370, 1370, 2550], [2552, 2552, 2585, 2585, 2769], [2771, 2771, 2792, 2792, 3047], [3049, 3049, 3086, 3086, 3329], [3331, 3331, 3356, 3356, 3956], [3958, 3958, 4007, 4007, 5116], [5118, 5118, 5152, 5152, 5909], [5911, 5911, 5946, 5946, 7648], [7665, 7665, 7721, 7721, 9652], [9654, 9654, 9686, 9686, 9786], [9788, 9788, 9834, 9834, 9881], [9883, 9883, 9930, 9930, 9977], [9979, 9979, 10021, 10021, 10072], [10074, 10074, 10131, 10131, 10207], [10209, 10209, 10233, 10233, 10463], [10465, 10465, 10489, 10489, 10549], [10551, 10551, 10573, 10573, 10600], [10602, 10602, 10624, 10624, 10651], [10653, 10653, 10698, 10698, 10801], [10803, 10803, 10848, 10848, 10886], [10888, 10888, 10924, 10924, 11130], [11132, 11132, 11162, 11162, 11275], [11277, 11277, 11308, 11308, 11372], [11374, 11374, 11397, 11397, 11499], [11572, 11572, 11604, 11604, 12152], [12154, 12154, 12216, 12216, 12598], [12632, 12632, 12656, 12656, 12716], [12718, 12718, 12742, 12742, 12795], [12797, 12797, 12821, 12821, 12951], [12953, 12953, 12978, 12978, 13124], [13126, 13126, 13151, 13151, 13337], [13339, 13339, 13361, 13361, 13515], [13517, 13517, 13538, 13538, 13693], [13695, 13695, 13724, 13724, 13936], [13938, 13938, 13977, 13977, 14157], [14251, 14251, 14276, 14276, 14399]], "test": "untested"}
{"id": "WtKfD3", "name": "tuto:smart gaussian blur (video)", "author": "FabriceNeyret2", "description": "mouse.y to choose filter size.\nFast Gaussian blur using MIPmap LOD (left circle) + separability : 60fps whatever the filter size.\nCommon: set N for quality:  ( cost = 2*N )\n  13 (default) = almost identical to full convolution.\n    7 is still pretty cool.", "tags": ["blur", "filter", "convolution", "gaussian", "tuto", "gpmipmap"], "likes": 55, "viewed": 2671, "published": 3, "date": "1615202302", "time_retrieved": "2024-07-30T19:33:33.924176", "image_code": "// Fast Gaussian blur using MIPmap LOD + separability : 60fps whatever the filter size.\n// Common: set N for quality:  ( cost = 2*N )\n//  13 (default) = almost identical to full convolution.\n//   7 is still pretty cool.\n// See https://www.shadertoy.com/view/wtVfWK for experimentation\n\n\n// === second pass of separable convolution\n\ninclude    // include functions\n\n#define D(P,r) O = mix(O, vec4(1), smoothstep(1.5/R.y,0.,abs(length(U-P)-r) ) ) // draw ring\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n// O = texelFetch(iChannel0, ivec2(u), 0); return;\n\n    init \n    vec2 U = u / R.y;  \n    O = convol1D(U,vec2(0,1));\n    \n    U = .5+ ( u - .5*R ) / R.y;  \n    D(.5, w );                                       // draw filter\n    D( vec2(-.3,(z+.5)/6.), .03 );                   // draw LOD \n    D( vec2(1.3,   .5 /6.), .03 );                   // ref LOD 0\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === source image to gaussian-blur\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0, U/R);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int           N = 13; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = length(iMouse.xy)<20. ? .2+.2*sin(iTime)                  \\\n                                        : abs(iMouse.y/R.y-.5);             \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n// forced to doing this silly thing because of silly not-really-includes Common\n#define include                                                             \\\n                                                                            \\\nvec4 convol2D(vec2 U) {                                                     \\\n    vec4  O = vec4(0);                                                      \\\n    float r = float(N-1)/2., g, t=0.;                                       \\\n    for( int k=0; k<N*N; k++ ) {                                            \\\n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \\\n        t += g = exp(-2.*dot(P,P) );                                        \\\n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );                 \\\n    }                                                                       \\\n    return O/t;                                                             \\\n}                                                                           \\\n                                                                            \\\nvec4 convol1D(vec2 U, vec2 D) {                                             \\\n    vec4  O = vec4(0);                                                      \\\n    float r = float(N-1)/2., g, t=0., x;                                    \\\n    for( int k=0; k<N; k++ ) {                                              \\\n        x = float(k)/r-1.;                                                  \\\n        t += g = exp(-2.*x*x );                                             \\\n        O += g * textureLod(iChannel0, (U+w*x*D) *R.y/R, z );               \\\n    }                                                                       \\\n    return O/t;                                                             \\\n}", "buffer_b_code": "// === first pass of separable convolution\n\ninclude    // include functions\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    \n  //O = convol2D(U); return;\n    O = convol1D(U,vec2(1,0));\n}\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlKBzd", "name": "Triangularized Mesh Raytracer 2", "author": "jstrom2002", "description": "Experimenting with ray-tracing for a triangularized mesh. Improved accuracy of the results.", "tags": ["test"], "likes": 3, "viewed": 275, "published": 3, "date": "1615200463", "time_retrieved": "2024-07-30T19:33:34.723040", "image_code": "mat4 RotateScaleTranslate( vec3 r, vec3 s, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f*s.x,  d*e,          -c,      0.0,\n                 ac*f-b*e, ac*e+b*f*s.y, a*d,     0.0,\n                 bc*f+a*e, bc*e-a*f,     b*d*s.z, 0.0,\n                 t.x,      t.y,          t.z,     1.0 );\n}\nvec3 applyTransform(mat4 M, in vec3 v)\n{\n    vec4 v_ = vec4(v, 1.0);\n    v_ = M * v_;\n    return v_.xyz / v_.w;\n}\nvoid applyTransform(mat4 M, inout Triangle tri)\n{\n    tri.v0 = applyTransform(M,tri.v0);\n    tri.v1 = applyTransform(M,tri.v1);\n    tri.v2 = applyTransform(M,tri.v2);\n}\n\n// From iq's intersectors: https://iquilezles.org/articles/intersectors\nRayHit IntersectTriangle(in Ray ray, in Triangle tri) \n{\n    vec3 v1v0 = tri.v1 - tri.v0;\n    vec3 v2v0 = tri.v2 - tri.v0;\n    vec3 rov0 = ray.o - tri.v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, ray.d );\n    float d = 1.0/dot( ray.d, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) \n        t = -1.0;//null return value    \n    return RayHit(t >= 0.0, ray.o + ray.d * t, t, vec3(u, v, 1.0-u-v), n);\n}\n\n// Specular GGX code from: https://www.shadertoy.com/view/4tXXzM\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0/(NdotV*(1.0-k)+k);\n}\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t// Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4/(PI * denom * denom);\n\n\t// Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t// Vis term \n\tfloat k = SqrRoughness/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\n\nvec3 hitLighting(in vec3 N, in vec2 uv, in vec3 X)\n{\n        vec3 col = vec3(0.0);\n\n        if(DEBUG_NORMALS != 0)\n        {\n            return N;            \n        }\n\n        // Material properties.\n        vec3 ambient = vec3(0.2);\n        vec3 albedo = texture(iChannel1, uv).rgb;\n        vec3 specular = vec3(1.0);\n        float roughness = 0.9;\n        float metalness = 0.04;\n\n        // Calc values for lighting.\n        vec3 L = lightPosition - X;\n        vec3 V = cameraPosition - X;\n        float NdotL = max(dot(N,L), 0.0);\n        float NdotV = max(dot(N,V), 0.0);\n\n        // Lambertian diffuse model.\n        vec3 diffuse_val = lightIntensity[1] * albedo;\n        \n        // Cook-Torrance specular model.\n        float spec = SpecGGX(N,V,L,roughness,metalness);\n        vec3 specular_val = lightIntensity[2] * specular * spec;\n        \n        // Calculate light falloff.\n        float d = length(L);\n        float constant_falloff = lightFalloff[0];\n        float linear_falloff = lightFalloff[1] * d;\n        float quad_falloff = lightFalloff[2] * d * d;\n        float attenuation = 1.0 / (1.0 + constant_falloff + linear_falloff + quad_falloff);\n\n        col = ambient + \n            NdotL * lightColor * attenuation * (diffuse_val + specular_val);\n        \n        return col;\n}\n\nvec3 RaySceneIntersection(inout Ray ray, out bool anyHit)\n{\n    anyHit = false;\n    vec3 col = vec3(0.0);//output color.\n    float tMin = MAX_DISTANCE;\n    vec3 pos, N;\n    vec2 uv;\n    mat4 M = RotateScaleTranslate(modelRot, modelScale, modelPos);\n    for (int i=0; i < indices.length(); i += 3) \n    {\n        Triangle tri;\n        tri.v0 = vertices[indices[i + 0]];\n        tri.v1 = vertices[indices[i + 1]];\n        tri.v2 = vertices[indices[i + 2]];\n\n        applyTransform(M, tri);\n\n        RayHit info = IntersectTriangle(ray,tri);\n        if (info.hit && info.dist > 0.0 && info.dist < tMin) {\n            tMin = info.dist;\n            pos = info.pos;\n            anyHit = true;\n\n            vec3 na = normals[indices[i + 0]];\n            vec3 nb = normals[indices[i + 1]];\n            vec3 nc = normals[indices[i + 2]];\n\n            vec2 uva = uvs[indices[i + 0]];\n            vec2 uvb = uvs[indices[i + 1]];\n            vec2 uvc = uvs[indices[i + 2]];\n\n            //N = info.norm;// Use face normal from intersection calc.\n            N = (na * info.bary.x) + (nb * info.bary.y) + (nc * info.bary.z);// Use normal from mesh data.\n            uv = (uva * info.bary.x) + (uvb * info.bary.y) + (uvc * info.bary.z);                       \n        }\n    }\n\n    if (anyHit) {\n        N *= sign(dot(N, -ray.d));// Make normal is oriented torwards the camera\n        N = normalize(N);\n\n        col = hitLighting(N, uv, pos);\n    }\n    else\n    {//Shade skybox.\n        col = texture(iChannel0, ray.d).rgb;\n    }\n    \n    return col;\n}\n\nRay initRay(vec2 fragCoord)\n{\n    Ray ray;\n    \n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * PI;\n    vec2 st = (fragCoord - center) / iResolution.y;\n\n    ray.o = cameraPosition;\n    ray.d = normalize(st.x * cameraRight + st.y * cameraUp + cameraFront);\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ray.o.yz *= mat2(cp, -sp, sp, cp);\n    ray.o.xz *= mat2(cy, -sy, sy, cy);\n    ray.d.yz *= mat2(cp, -sp, sp, cp);\n    ray.d.xz *= mat2(cy, -sy, sy, cy);\n\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Rotate light.\n    float tha = 2.0*iTime / PI;\n    lightPosition += 5.0 * vec3(\n        cos(tha) * sin(tha),\n        sin(tha) * sin(tha),\n        sin(tha)\n    );\n    \n    // Rotate model.\n    if(ROTATE_MODEL != 0)\n    {\n        modelRot += 1.0 * vec3(\n            cos(tha) * sin(tha),\n            sin(tha) * sin(tha),\n            sin(tha)\n        );\n    }\n    \n    // Setup ray.\n    Ray ray = initRay(fragCoord);\n\n    // Trace ray against scene objects.\n    vec3 out_col = vec3(0.0);    \n    for(int bounce_number = 1; bounce_number < MAX_BOUNCES+1; ++bounce_number)\n    {\n        bool anyHit = false;\n        vec3 pass_color = RaySceneIntersection(ray,anyHit);\n        pass_color /= float(bounce_number);//taper off strength of light bounces.\n        out_col += pass_color;\n        if(!anyHit)\n            break;\n    }\n\n    fragColor = vec4(out_col, 1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Global definitions\n#define DEBUG_NORMALS 0\n#define INTERSECT_EPSILON 0.00001\n#define MAX_BOUNCES 1\n#define MAX_DISTANCE 9999.9\n#define PI 3.1415926\n#define ROTATE_MODEL 0\n\n// Scene objects (models, cameras, lights, etc).\nvec3 cameraPosition = vec3(0.0, 0.0, 32.0);\nvec3 cameraFront = vec3(0,0,-1);\nvec3 cameraRight = vec3(1,0,0);\nvec3 cameraUp = vec3(0,1,0);\n\nvec3 lightPosition  = vec3(0.0, 0.0, 0.0);\nvec3 lightIntensity = vec3(5.0);\nvec3 lightFalloff = vec3(0.0, 0.0, 1.0);\nvec3 lightColor = vec3(1,1,0.92);\n\nvec3 modelPos   = vec3(0,0,0);\nvec3 modelScale = vec3(1.0);\nvec3 modelRot   = vec3(0,0,0);\n\n// Structs.\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\nstruct Triangle\n{\n    vec3 v0,  v1, v2;\n    vec3 n0,  n1, n2;\n    vec2 uv0,uv1,uv2;\n};\nstruct RayHit {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n    vec3 norm;//triangle face normal just in case mesh data doesn't provide it.\n};\n\n// Triangularized Cornell box mesh data:\nconst int maxIndexValue = 20;\nvec3 vertices[maxIndexValue] = vec3[maxIndexValue](\nvec3(-10.0,10.0,10.0),//Top\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\n\nvec3(-10.0,-10.0,-10.0),//Back\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\n\nvec3(-10.0,-10.0,10.0),//Bottom\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\n\nvec3(-10.0,-10.0,10.0),//Left\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\n\nvec3(10.0,-10.0,-10.0),//Right\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[maxIndexValue] = vec2[maxIndexValue]\n(\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[maxIndexValue] = vec3[maxIndexValue]\n(\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\n\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\n\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\n\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\n\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv vertex values.\nconst int numIndices = 30;\nint indices[numIndices] = int[numIndices]\n(\n0,1,2,//Ceiling\n0,2,3,\n\n4,5,6,//Back wall\n4,6,7,\n\n8,9,10,//Floor\n8,10,11,\n\n12,13,14,//Left wall\n12,14,15,\n\n16,17,18,//Right wall\n16,18,19\n);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 454], [455, 455, 495, 495, 568], [569, 569, 618, 618, 737], [739, 811, 867, 867, 1336], [1338, 1403, 1436, 1436, 1469], [1470, 1470, 1537, 1537, 2216], [2218, 2218, 2270, 2270, 3517], [3519, 3519, 3578, 3578, 5056], [5058, 5058, 5087, 5087, 5659], [5661, 5661, 5717, 5738, 6582]], "test": "untested"}
{"id": "ttyBDc", "name": "", "author": "kukuzhang", "description": "", "tags": [], "likes": 1, "viewed": 239, "published": 3, "date": "1615196676", "time_retrieved": "2024-07-30T19:33:35.498966", "image_code": "// A trick to use any variable as an array index.\n// Array index must be a constant, and the loop index is a constant when unrolled \n// so we can use it to compare it with any variable and return the array value that matches, \n// or an interpolation of the two closest matches.\n\n// mouse click to see palette\n\nvec3 palette[8]; // the color palette is stored here\n\n// just pick a color based on c value\nvec3 getcolor(float c) \n{\n\tc=mod(c,1.); // cycle palette\n\tint p=0;\n\tvec3 color=vec3(0.);\n\tfor(int i=0;i<7;i++) {\n\t\tif (float(i)-c<=.0) { // check loop index against color value\n\t\t\tcolor=palette[i]; // store color picked\t\n\t\t}\n\t}\n\treturn color;\n}\n\n// get a gradient of the palette based on c value, with a \"smooth\" parameter (0...1)\nvec3 getsmcolor(float c, float s) \n{\n    s*=1.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<8;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    // smooth mix the two colors\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// define the colors \n    palette[6]=vec3(100,150,200)/255.;\n\tpalette[6]=vec3(255,010,000)/255.;\n\tpalette[5]=vec3(255,27,100)/255.;\n\tpalette[4]=vec3(255,0,000)/255.;\n\tpalette[3]=vec3(150,150,050)/255.;\n\tpalette[2]=vec3(000,050,150)/255.;\n\tpalette[1]=vec3(075,80,130)/255.;\n\tpalette[0]=vec3(143,120,255)/255.;\n\t\n\tvec3 color=vec3(0.);\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tif (uv.x>.9) { \n\t\tcolor=getsmcolor(uv.y*7.+iTime*.5,.25+.75*abs(sin(iTime))); //gradient function\n\t} else if (uv.x<.1) {\n\t\tcolor=getcolor(uv.y*7.-iTime*.5); // basic function\n\t} \n\n\tvec2 p=(uv-.5);\n\tp.x*=iResolution.x/iResolution.y;\n\t\n\n\t// fractal\n    float a=iTime*.175;\t\n    float b=iTime*80.;\t\n\tfloat ot=500.;\n\tmat2 rot=mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp+=sin(b)*.008;\n    float l=length(p);\n    for(int i=0;i<50;i++) {\n\t\tp*=rot;\n        p=abs(p)*1.2-1.;\n        ot=min(ot,abs(dot(p,p)-sin(b+l*25.)*.015-5.15)); //orbit trap\n\t}\n    \n\tot=max(0.,.1-ot)/.1; //orbit trap \n\tif (length(max(vec2(0.),abs(uv-.5)-vec2(1.485,5.47)))>0.0) color*=0.; // border \t\n\tif (iMouse.w<1. || length(max(vec2(0.),abs(uv-.5)-vec2(.37,.46)))<0.06) {\n\t\tcolor=getsmcolor(ot*4.+l*10.-iTime*7.,1.)*(1.-.4*step(.5,1.-dot(p,p))); //get color gradient for orbit trap value\t\n\t}\n    color=mix(vec3(length(color))*10.8*sin(iTime),color,sin(iTime)); // saturation adjustment\n    color*=1.-pow(l*1.1,1.); color+=pow(max(0.,.2-l)/.6,5.)*1.2; // center glow\n    fragColor = vec4(color,1.0)*min(1.,iTime*.3);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    float t=2.+abs(1.01-mod(time*time*time,5.02))+abs(sin(time*time*10.4356));\n    float t2=200.+cos(time*.54321)*100.;\n    float s=abs(cos(t*t2))*abs(sin(time*50.));\n    float c=abs(sin(time*time*.6341));\n    s=clamp(s*t,0.,.25+c)/(3.+c);\n    \n    return vec2(s)*min(2.,time*1.5);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 402, 427, 427, 646], [648, 733, 769, 769, 1093], [1094, 1094, 1151, 1174, 2611]], "test": "untested"}
{"id": "tlGBDc", "name": "falso goku", "author": "jorge2017a1", "description": "falso goku", "tags": ["falsogoku"], "likes": 6, "viewed": 250, "published": 3, "date": "1615173561", "time_retrieved": "2024-07-30T19:33:36.445436", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n\n//Referencia de IQ https://www.shadertoy.com/view/wdBXRW\n// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Distance to a regular pentagon, without trigonometric functions. \n// https://iquilezles.org/articles/distfunctions2d\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n////-------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N1 =30;\nconst int N2 =29;\nconst int N3 =10;\n\nfloat sdPolygonA( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\nfloat sdPolygonB( in vec2 p, in vec2[N2] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdPolygonC( in vec2 p, in vec2[N3] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n//vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\nvec2 pt1[30]=vec2[]( vec2(.42,.79),vec2(.21,.72),vec2(.29,.7),vec2(.12,.55),\nvec2(.25,.55),vec2(.06,.33),vec2(.01,.31),vec2(.16,.25), vec2(.22,.25),vec2(.31,.3),\nvec2(.24,.08),vec2(.19,.01),vec2(.25,.01),vec2(.44,.07),vec2(.54,.24),vec2(.54,.37),\nvec2(.46,.45),vec2(.43,.55),vec2(.41,.48),vec2(.4,.42),vec2(.38,.46),vec2(.39,.56),\nvec2(.36,.55),vec2(.36,.61),vec2(.31,.59),vec2(.3,.61),vec2(.3,.68),vec2(.35,.73),\nvec2(.37,.73),vec2(.42,.79)  );\n\n\nvec2 pt2[29]=vec2[](\nvec2(.55,.37),vec2(.72,.36),vec2(.81,.34),vec2(.86,.34),vec2(.95,.35),vec2(.83,.47),\nvec2(.9,.49),vec2(.95,.52),vec2(.79,.64),vec2(.89,.68),vec2(.75,.72),vec2(.8,.76),\nvec2(.61,.79),vec2(.65,.75),vec2(.66,.73),vec2(.68,.73),vec2(.73,.69),vec2(.74,.64),\nvec2(.74,.58),vec2(.72,.58),vec2(.67,.61),vec2(.68,.56),vec2(.66,.58),vec2(.66,.49),\nvec2(.66,.44),vec2(.64,.48),vec2(.58,.54),vec2(.58,.46),vec2(.54,.37)  );\n\nvec2 pt3[10]=vec2[](vec2(.3,.37),vec2(.37,.73),vec2(.39,.76),vec2(.51,.83),\nvec2(.53,.83),vec2(.64,.76),vec2(.66,.74),vec2(.68,.6),vec2(.71,.37),vec2(.29,.37) );\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\n//Pie - exact   (https://www.shadertoy.com/view/3l23RK)\n//actualizacion 8-mar-2021\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec3 CabezaConPelo(vec2 p, vec3 col )\n{\n    vec2 p2= rotatev2( p, radians(180.0));\n    vec2 p3= rotatev2( p-vec2(-0.09,0.09), radians(310.0)); \n    \n    \n    float d1 = sdPolygonA(p2-vec2(-0.4,-0.5), pt1);\n    float d2 = sdPolygonB(p2-vec2(-0.4,-0.5), pt2);\n    float d3 = sdPolygonC(p2-vec2(-0.4,-0.5), pt3);\n    \n    float boca1= sdBox( p-vec2(-0.1,-0.25), vec2(0.05,0.01) );\n    \n    //float pelocirculo=sdCircle( p-vec2(-0.21,0.2), 0.12 );\n    float pelocirculo=sdPie( p3, vec2(0.04,0.05), 0.18 );\n    \n    float ojo1=sdCircle( p-vec2(-0.05,-0.1), 0.01 );\n    float ojo2=sdCircle( p-vec2(-0.15,-0.1), 0.01 );\n    \n    float ojo1A=sdCircle( p-vec2(-0.05,-0.1), 0.05 );\n    float ojo2A=sdCircle( p-vec2(-0.05,-0.1), 0.045 );\n    \n    float ojo1B=sdCircle( p-vec2(-0.15,-0.1), 0.05 );\n    float ojo2B=sdCircle( p-vec2(-0.15,-0.1), 0.045 );\n    \n    ojo1A= opS( ojo2A, ojo1A );\n    ojo1B= opS( ojo2B, ojo1B );\n    d3= opS( d1, d3 );\n    d3= opS( d2, d3 );\n    d3= opS( pelocirculo, d3 );\n    \n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(pelocirculo,0.0));\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(d1,0.0));\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(d2,0.0));\n    col = mix(col,vec3(0.925, 0.73,0.7)*1.2,S(d3,0.0));\n    \n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(boca1,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo2,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1A,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1B,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float tt=fract(iTime*0.5)*0.35;\n    uv=uv*2.0*abs(sin(tt));\n    vec2 p=uv;\n    \n    vec3 col=  vec3(1.0,0.5,0.5);\n    col= CabezaConPelo(p, col);\n    fragColor=vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBDc.jpg", "access": "api", "license": "mit", "functions": [[1629, 1629, 1662, 1662, 1684], [1685, 1685, 1718, 1718, 1740], [1741, 1741, 1774, 1774, 1795], [1797, 1835, 1871, 1871, 1916], [1917, 1930, 1967, 1967, 2047], [2050, 2050, 2085, 2085, 2113], [2115, 2139, 2164, 2164, 2183], [2184, 2184, 2224, 2224, 2256], [5356, 5356, 5390, 5390, 5487], [5491, 5574, 5623, 5623, 5791], [5793, 5793, 5832, 5832, 7315], [7317, 7317, 7374, 7374, 7613]], "test": "ok"}
{"id": "wtyBWc", "name": "Simple Bloom w/Jitter Blur", "author": "oneshade", "description": "Simple bloom filter based on a LearnOpenGL tutorial: [url=https://learnopengl.com/Advanced-Lighting/Bloom]https://learnopengl.com/Advanced-Lighting/Bloom[/url]", "tags": ["simple", "blur", "light", "random", "effect", "postprocess", "bloom", "jitter"], "likes": 4, "viewed": 406, "published": 3, "date": "1615170312", "time_retrieved": "2024-07-30T19:33:37.350017", "image_code": "#define BLOOM_THRESHOLD 0.5\n#define BLOOM_BLEED 0.25\n#define BLOOM_SAMPLES 500\n#define TIME_JITTER 0\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.109, 0.09792));\n\tp3 += dot(p3, p3.yzx + 33.0);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 getBloom(in vec2 uv) {\n    vec4 bloom = vec4(0.0);\n    for (int i=0; i < BLOOM_SAMPLES; i++) {\n        float s = float(i);\n\n        #if TIME_JITTER == 1\n        s += iTime;\n        #endif\n\n        vec2 pos = uv + (Hash12(s) - 0.5) * BLOOM_BLEED;\n        vec4 samp = texture(iChannel1, pos);\n        bloom += samp;\n    }\n\n    return bloom / float(BLOOM_SAMPLES);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(0.0);\n    for (int i=0; i < BLOOM_SAMPLES; i++) {\n        float j = float(i);\n\n        #if TIME_JITTER == 1\n        j += iTime;\n        #endif\n\n        vec4 samp = texture(iChannel0, uv + (Hash12(j) - 0.5) * BLOOM_BLEED);\n        fragColor += max(sign(samp - BLOOM_THRESHOLD), 0.0);\n    }\n\n    fragColor /= float(BLOOM_SAMPLES);\n    fragColor += texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// One of my previous shaders: https://www.shadertoy.com/view/3ldcD7\nstruct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nvec3 getIllumination(in vec3 p, in Light light) {\n    float d = length(p - light.pos);\n    float b = 1.0 / (light.Kc + light.Kl * d + light.Kq * d * d);\n    return light.col * b;\n}\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n#define t1 0.5 * iTime\n#define t3 1.5 * iTime\n\n#define c1 cos(t1) * 2.0\n#define s1 sin(t1) * 2.0\n#define c2 cos(iTime) * 2.0\n#define s2 sin(iTime) * 2.0\n#define c3 cos(t3) * 2.0\n#define s3 sin(t3) * 2.0\n\n#define blink round(fract(iTime * 3.0))\n#define second fract(iTime)\n#define bounce 4.0 * (second - second * second)\n\n#define light1 Light(vec3(c1, c3, s2), vec3(1.0, 0.0, 0.0) * blink, 1.0, 0.0, 0.5)\n#define light2 Light(vec3(s2, c1, s3), vec3(0.0, 1.0, 0.0) * bounce, 1.0, 0.0, 0.5)\n#define light3 Light(vec3(s2, s3, c1), vec3(0.0, 0.0, 1.0), 1.0, 0.0, 0.5)\n\nfloat mapScene(in vec3 p) {\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -2.0);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            vec3 l = normalize(light1.pos - p);\n            float diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light1) * diffuse;\n\n            l = normalize(light2.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light2) * diffuse;\n\n            l = normalize(light3.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light3) * diffuse;\n\n            l = normalize(vec3(-1.0, 1.0, 1.0));\n            diffuse = max(0.1, dot(n, l));\n            fragColor.rgb += 0.25 * diffuse;\n\n            break;\n        }\n\n        float ld1 = length(p - light1.pos) - 0.05;\n        float ld2 = length(p - light2.pos) - 0.05;\n        float ld3 = length(p - light3.pos) - 0.05;\n\n        if (ld1 < 0.001) {\n            fragColor.rgb = light1.col;\n        }\n\n        if (ld2 < 0.001) {\n            fragColor.rgb = light2.col;\n        }\n\n        if (ld3 < 0.001) {\n            fragColor.rgb = light3.col;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, min(ld1, min(ld2, ld3)));\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 191, 216, 216, 347], [349, 349, 376, 376, 717], [719, 719, 774, 774, 1209]], "test": "untested"}
{"id": "wtyfW3", "name": "Burning Ship - Explore with UI", "author": "LerpDieRepeat", "description": "Mouse         : Move\nW, A, S, D    : Move\nQ, E             : Zoom\nR, Num 0      : Reset\nF                  : Toggle z0 Animation\n1 - 7             : Change Color Palettes\nNumpad 1     : The Shipwreck", "tags": ["fractal", "julia", "mandelbrot", "burning", "complex", "ui", "set", "ship", "explore"], "likes": 0, "viewed": 330, "published": 3, "date": "1615163958", "time_retrieved": "2024-07-30T19:33:38.314438", "image_code": "// Burning Ship Fractal\n// I saw this cool Fractal online and had to explore it.\n// It only took me few changes to my Mandelbrot shader. Basically just adding an abs() to the equation.\n// However I had to mirror the complex-axis (y) to get the result that is commonly seen online.\n// Is that normal for this set? If you know about it feel free to leave a comment.\n//\n// comment ANIMATE_COLOR to stop color animation\n// uncomment GRID to show a grid overlay\n\n\n#define MAXIMUM_ITERATIONS 200\n#define ANIMATE_COLOR\n//#define GRID\n\n//defining product of imaginary numbers\n#define product_i(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n\n\nint BurningShipSet(vec2 z0, vec2 c, int iterMax)\n{\n    float zLength = 0.0;\n    int i = 0;\n    vec2 z = z0; //z.x = real part; z.y = imaginary part\n    \n    // if zLength is bigger than 2 the series diverges, then return the iterations needed\n    // otherwise go until max-iterations, which suggests the series is converging\n    while (zLength <= 2.0 && i < iterMax)\n    {\n        i++;\n        z = product_i(abs(z), abs(z)) + c; //zn+1 = zn+c\n        zLength = length(z);     //absolut value of imaginary number z is it's length\n    }\n    return i;\n}\n\n\n// using palettes by inigo quilez : https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colorGradient(float gradient, int iter, int iterMax, float choose_palette)\n{\n    //vec3 color1 = vec3(0.1, 0.0, 0.6); //blue\n    //vec3 color2 = vec3(1.0, 0.6, 0.0); //orange\n    //vec3 palette = mix(color1, color2, gradient);\n    \n    #ifdef ANIMATE_COLOR\n        gradient += 0.2 * iTime;\n    #endif\n    \n    vec3                     palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if(choose_palette == 2.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if(choose_palette == 3.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if(choose_palette == 4.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if(choose_palette == 5.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if(choose_palette == 6.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if(choose_palette == 7.) palette = pal(gradient, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    vec3 col = iter == iterMax ? vec3(0) : palette;\n    return col;\n}\n\n\nfloat grid(vec2 uv, float space, float width)\n{\n    return\n    step(space * 0.5 - width * 0.5, abs(mod(uv.x, space) - space * 0.5)) +\n    step(space * 0.5 - width * 0.5, abs(mod(uv.y, space) - space * 0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //squaring coordinates and centering\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy))/iResolution.yy;\n    uv *= vec2(1.0, -1.0); //for some reason I had to flip the complex axis; is this normal for this set?\n    \n    vec4 mouse;\n    mouse = texture(iChannel0, vec2(0.5, 0.5)).rgba; // read movement buffer (and palette)\n    uv = uv * mouse.z + mouse.xy * vec2(1.0, -1.0);\n    \n    vec2 z0 = vec2(0.0, 0.0);\n    \n    // animating z0 in a circle when toggling F\n    int KEY_F = 70;\n    if(bool(texelFetch(iChannel1, ivec2(KEY_F,2),0).x))\n    {\n        z0 = vec2(0.05 * sin(iTime), 0.05 * cos(iTime));\n    }\n    \n    int iterMax = MAXIMUM_ITERATIONS;\n    \n    int iterations = BurningShipSet(z0, uv, iterMax);\n    \n    float gradient = pow(float(iterations) / (0.5 * float(iterMax)), 0.5);\n    \n    vec3 finalColor = colorGradient(gradient, iterations, iterMax, mouse.a);\n\n    #ifdef GRID\n        finalColor += vec3(clamp(grid(uv, 1.0, 0.02) + grid(uv, 0.1, 0.005), 0.0, 0.2));\n    #endif\n\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Movement Input Buffer A\n\nconst int KEY_R     = 82;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\n\nconst int KEY_NUM0  = 96;\nconst int KEY_NUM1  = 97;\n\nbool IsPressed(int key)\n{\n   return bool(texelFetch(iChannel1, ivec2(key,0),0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // mouse input centered and scaled to go from -1 to 1\n    vec2 mouse = vec2(0);\n    if(iMouse.z > 0.0)\n    {\n        mouse = 2.0 * (iMouse.xy - (0.5 * iChannelResolution[0].xy)) / iChannelResolution[0].xy;\n    }\n    vec3 movement;          // rg = mouse; b = zoom;\n    float choose_palette;   // palette\n    float moveSpeed = 0.03;\n    float zoomSpeed = 0.05;\n    float borderThreshold = 0.3;\n\n\n    if (iFrame == 0) // Reset\n    {\n        // initial values\n        movement.rg = vec2(-0.5, 0.5);  // position\n        movement.b = 2.3;               // zoom\n        choose_palette = 2.0;           // palette\n    }\n    else\n    {\n        // read last buffer\n        movement = texture(iChannel0, vec2(0.0)).rgb;\n\n        // zoom\n        if(IsPressed(KEY_E)){movement.b *= 1.0 - zoomSpeed;} // Zoom In\n        if(IsPressed(KEY_Q)){movement.b *= 1.0 + zoomSpeed;} // Zoom Out\n\n        // movement keys\n        if(IsPressed(KEY_W)){movement.rg += vec2( 0,  1) * moveSpeed * movement.b;} //UP\n        if(IsPressed(KEY_S)){movement.rg += vec2( 0, -1) * moveSpeed * movement.b;} //DN\n        if(IsPressed(KEY_A)){movement.rg += vec2(-1,  0) * moveSpeed * movement.b;} //L\n        if(IsPressed(KEY_D)){movement.rg += vec2( 1,  0) * moveSpeed * movement.b;} //R\n\n        // movement mouse\n        if (length(mouse) < borderThreshold)\n        {\n            movement.rg += vec2(0);\n        }\n        else\n        {\n            // add to buffer: mouse-position, scaled by speed, masked, scaled to compensate zoom\n            movement.rg += mouse * moveSpeed * smoothstep(borderThreshold, 1.0, length(mouse)) * movement.b;\n        }\n\n        choose_palette = texture(iChannel0, vec2(0)).a;\n        if(IsPressed(KEY_1)){choose_palette = 1.;}\n        if(IsPressed(KEY_2)){choose_palette = 2.;}\n        if(IsPressed(KEY_3)){choose_palette = 3.;}\n        if(IsPressed(KEY_4)){choose_palette = 4.;}\n        if(IsPressed(KEY_5)){choose_palette = 5.;}\n        if(IsPressed(KEY_6)){choose_palette = 6.;}\n        if(IsPressed(KEY_7)){choose_palette = 7.;}\n    }\n    \n    if(IsPressed(KEY_NUM0) || IsPressed(KEY_R)){movement = vec3(-0.5, 0.5, 2.3);}\n\n    // cool spots\n    if(IsPressed(KEY_NUM1)){movement = vec3(-1.76, 0.036, 0.09);}\n\n    fragColor = vec4(movement, choose_palette);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 695, 695, 1197], [1200, 1274, 1342, 1342, 1385], [1388, 1388, 1469, 1619, 2683], [2686, 2686, 2733, 2733, 2895], [2898, 2898, 2955, 2996, 3988]], "test": "untested"}
{"id": "wlKBDV", "name": "Magma city", "author": "Daizuukee", "description": "this is a test for a cirt :)", "tags": ["test", "city", "neon"], "likes": 17, "viewed": 474, "published": 3, "date": "1615157740", "time_retrieved": "2024-07-30T19:33:39.271878", "image_code": "#define CityDepth 10\n#define Paralax .01\n#define CityWidth 1\n#define BuildingWidth 10.\n//#define BackCol vec4(0.6,0.3,0.05,1)\n#define BackCol lerp(vec4(.9,.3,.3,1),vec4(.6,.3,.05,1),.5+.5*sin(iTime))\n#define FrontCol vec4(.3,0,.3,1)\n#define BalcCol vec4(.2,.1,.3,1)\n\n/*Remove for Low Quality -> */\n#define HighQ\n/**/\n\nvec4 lerp(vec4 v1,vec4 v2,float t){\n    return(v2-v1)*t+v1;\n}\n\nfloat random(vec2 st){\n    return fract(sin(dot(st,\n                vec2(12.9898,78.233)))*\n            43758.5453123);\n        }\n        \n        float noise(vec2 st){\n            vec2 st0=floor(st);\n            vec2 st1=.5-cos((st-st0)*3.14)*.5;\n            float a0=random(vec2(int(st0.x),int(st0.y)));\n            float a1=random(vec2(int(st0.x)+1,int(st0.y)));\n            \n            float a2=random(vec2(int(st0.x),int(st0.y)+1));\n            float a3=random(vec2(int(st0.x)+1,int(st0.y)+1));\n            \n            float b0=(a1-a0)*st1.x+a0;\n            \n            float b1=(a3-a2)*st1.x+a2;\n            return(b1-b0)*st1.y+b0;\n        }\n        \n        bool isBuilding(vec2 uv){\n            for(int j=-CityWidth;j<=CityWidth;j++){\n                for(int n=0;n<5;n++){\n                    float h=float(n)*.01+(random(vec2(floor(uv.x*BuildingWidth+float(j)),n))-.5)/2.+.25;\n                    if(h>=uv.y&&\n                        fract(uv.x*BuildingWidth)-.5-float(j)*1.5<float(CityWidth+1)*1.-float(n)/7.+fract(floor((h-uv.y)*100.*random(vec2(floor(uv.x*BuildingWidth))))/2.)*.1&&\n                        fract(uv.x*BuildingWidth)-.5-float(j)*1.5>-float(CityWidth-2)*float(n)/7.-fract(floor((h-uv.y)*100.*random(vec2(floor(uv.x*BuildingWidth))))/2.)*.1){\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            \n            bool isBalc(vec2 uv){\n                return fract((uv.x+iTime*.3)*3.)<.1||\n                uv.y<.3||\n                (uv.y<.4&&uv.y>.37)||\n                (uv.y<.4&&fract((uv.x+iTime*.35)*10.)<.2);\n            }\n            \n            void mainImage(out vec4 fragColor,in vec2 fragCoord)\n            {\n                fragColor = vec4(0);\n                vec2 uv=fragCoord/iResolution.xy;\n                vec2 sv=uv;\n                uv+=noise(uv*10.+iTime)*.002;\n                uv.x+=iTime/10.-947.2984;\n                if(isBalc(uv)){\n                    if(isBalc(uv+vec2(.005,0))){\n                        if(isBalc(vec2(uv.x+(sv.x-.5)*(sv.y-.3),.5-uv.y))||uv.y>.2)\n                        fragColor=BalcCol;\n                        else\n                        fragColor=lerp(BackCol,BalcCol,.5-uv.y/.5);\n                    }\n                    else\n                    fragColor=BackCol;\n                }\n                else{\n                    bool broke=false;\n                    for(int i=0;i<CityDepth;i++){\n                        float mult=iTime*Paralax*float(CityDepth-i);\n                        if(isBuilding(uv+vec2(mult,0))){\n                            fragColor+=lerp(BackCol,FrontCol,1./float(i+1));\n                            broke=true;\n                            break;\n                        }\n                        if(broke){\n                            break;\n                        }\n                        else{\n                            #ifdef HighQ\n                            vec4 c=lerp(BackCol,FrontCol,1./float(i+1));\n                            fragColor+=c*2.*max(0.,.7+.3*noise(vec2(uv.x+mult,float(i)*292.293))-sv.y);\n                            if(fract(uv.x+mult+.2723)<.1){\n                                fragColor+=vec4(0,0,.1,0)*max(0.,(8.-uv.y*10.));\n                            }\n                            #endif\n                        }\n                        uv.x*=1.1;\n                        uv.y-=1./float(CityDepth)/4.;\n                    }\n                    if(!broke){\n                        fragColor+=lerp(vec4(.9,.5,.2,1),vec4(.01,.01,.2,1.),uv.y);\n                        float f=noise(vec2(iTime*10.,0)+sv*iResolution.xy*.5);\n                        if(f>.95&&noise(vec2(iTime*10.,0)+sv*50.)>.5)\n                        fragColor+=(f-.9)/.1;\n                    }\n                }\n            }\n            ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 353, 353, 379], [381, 381, 403, 403, 510], [528, 528, 549, 549, 1031], [1049, 1049, 1074, 1074, 1803], [1829, 1829, 1850, 1850, 2041], [2067, 2067, 2133, 2133, 4210]], "test": "untested"}
{"id": "3tGBDc", "name": "Interlace color gradient", "author": "aferriss", "description": "Testing a gradient pattern.", "tags": ["line", "gradient", "step", "interlace"], "likes": 1, "viewed": 282, "published": 3, "date": "1615153147", "time_retrieved": "2024-07-30T19:33:40.099665", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    float l = length(uv - vec2(0.87, 0.5));\n    float interlaceMask = mod((l * 50.0), 1.0);\n    float lineStep = step(l, interlaceMask);\n    \n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec4 c = mix(red, blue, lineStep);\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]], "test": "untested"}
{"id": "WlGfWc", "name": "punk mx", "author": "jorge2017a1", "description": "punk mx", "tags": ["punkmx"], "likes": 2, "viewed": 241, "published": 3, "date": "1615151809", "time_retrieved": "2024-07-30T19:33:41.039153", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n\n\n//Referencia de IQ https://www.shadertoy.com/view/wdBXRW\n// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n//\n//\n// https://iquilezles.org/articles/distfunctions2d\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n////-------------------\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N1 =12;\n\n\n\n\nfloat sdPolygon( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n//vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\n\nvec2 pt1[12]=vec2[](\nvec2(.32,.56),\nvec2(.24,.32),\nvec2(.34,.39),\nvec2(.4,.32),\nvec2(.43,.39),\nvec2(.47,.33),\nvec2(.49,.41),\nvec2(.55,.3),\nvec2(.56,.41),\nvec2(.61,.28),\nvec2(.59,.56),\nvec2(.32,.56)\n );\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec3 CabezaConPelo(vec2 p, vec3 col )\n{\n    vec2 p2= rotatev2( p, radians(180.0));\n    //vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(iTime*10.0));\n    vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(185.0));\n    \n    float d1 = sdPolygon(p2-vec2(-0.4,-0.5), pt1);\n    float d2 = sdPolygon(p3-vec2(-0.4,-0.5), pt1);\n    \n    float s1= sdCircle( p-vec2(-0.05,-0.1), 0.15 );\n    \n    float boca1= sdBox( p-vec2(-0.01,-0.2), vec2(0.05,0.01) );\n    \n    float ojo1= sdBox( p-vec2(-0.05,-0.1), vec2(0.02,0.02) );\n    float ojo2= sdBox( p-vec2(0.05,-0.1), vec2(0.02,0.02) );\n    \n    col = mix(col,vec3(1.0, 0.8,0.1)*1.2,S(s1,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(d2,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(boca1,0.0));\n    \n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo2,0.0));\n    \n    \n    d1 = SS(d1);\n    col=mix(col,vec3(0.0),d1);\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float tt=iTime;\n    uv=uv*2.0*abs(sin(tt));\n    vec2 p=uv*0.5+tt;\n    vec2 p2=uv*2.0;\n    //-------------------------------\n    vec3 col=vec3(1.0);\n    \n    p.x= opRep1D( p.x, 0.8 );\n    p.y= opRep1D( p.y, 0.8 );\n    \n    p2.x= opRep1D( p2.x, 1.6 );\n    p2.y= opRep1D( p2.y, 1.6 );\n    \n    col= CabezaConPelo(p, col);\n    col= CabezaConPelo(p2-vec2(0.5,-0.5), col);\n    \n    fragColor=vec4(col,1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfWc.jpg", "access": "api", "license": "mit", "functions": [[1782, 1782, 1815, 1815, 1837], [1838, 1838, 1871, 1871, 1893], [1894, 1894, 1927, 1927, 1948], [1950, 1988, 2024, 2024, 2069], [2070, 2083, 2120, 2120, 2200], [2203, 2203, 2238, 2238, 2266], [2294, 2294, 2319, 2319, 2338], [2339, 2339, 2379, 2379, 2411], [3335, 3335, 3369, 3369, 3466], [3470, 3470, 3509, 3509, 4395], [4401, 4401, 4458, 4458, 4933]], "test": "ok"}
{"id": "WtGfD3", "name": "Ray-Triangle Intersector", "author": "oneshade", "description": "A ray-triangle intersector I made. I also made 3D triangle SDF for some fake occlusion inspired by iq's analytic triangle occlusion demo.", "tags": ["raytracing", "ray", "sdf", "triangle", "intersection", "occlusion"], "likes": 4, "viewed": 246, "published": 3, "date": "1615145648", "time_retrieved": "2024-07-30T19:33:41.813084", "image_code": "struct TriIntersect {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n};\n\nTriIntersect IntersectTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a; a = vec3(0.0);\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    vec3 n = cross(ba, -ac);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = p - a, pb = p - b, pc = p - c;\n\n        float abc = length(n);\n        float u = length(cross(ba, pa)) / abc;\n        float v = length(cross(cb, pb)) / abc;\n        float w = length(cross(ac, pc)) / abc;\n\n        return TriIntersect(abs(u + v + w - 1.0) < 0.001, p, t, vec3(u, v, w));\n    }\n\n    return TriIntersect(false, vec3(0.0), 0.0, vec3(0.0));\n}\n\n// My not super efficient triangle SDF :D\nfloat sdTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    vec3 pa = p - a, pb = p - b, pc = p - c;\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    vec3 n = cross(ba, -ac);\n    float abc = length(n);\n    n /= abc;\n\n    float dp = dot(pa, n);\n    vec3 pp = p - n * dp;\n    vec3 ppa = pp - a, ppb = pp - b, ppc = pp - c;\n\n    float abp = length(cross(ba, ppa));\n    float bcp = length(cross(cb, ppb));\n    float cap = length(cross(ac, ppc));\n\n    vec3 e1 = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 e2 = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec3 e3 = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    return abs(abp + bcp + cap - abc) < 0.001 ? abs(dp) : sqrt(min(dot(e1, e1), min(dot(e2, e2), dot(e3, e3))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 st = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(st, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Vertices\n    float t1 = iTime * 0.75, t2 = iTime * 1.25, t3 = iTime * 1.5;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(c3, s2 + 0.125, c1) * 2.0;\n    vec3 b = vec3(c2, s1 + 0.125, s3) * 2.0;\n    vec3 c = vec3(s3, s2 + 0.125, c1) * 2.0;\n\n    // UVs\n    vec2 uv1 = vec2(0.0, 0.0);\n    vec2 uv2 = vec2(1.0, 0.0);\n    vec2 uv3 = vec2(0.5, 1.0);\n\n    TriIntersect info = IntersectTriangle(ro, rd, a, b, c);\n    if (info.hit && info.dist > 0.0) {\n        vec3 normal = normalize(cross(b - a, c - a));\n        vec2 uv = uv1 * info.bary.x + uv2 * info.bary.y + uv3 * info.bary.z;\n\n        normal *= sign(dot(normal, -rd)); // Make sure its oriented torwards the camera\n\n        vec3 mat = texture(iChannel0, uv).rgb;\n        float diff = max(0.0, dot(-rd, normal));\n\n        fragColor.rgb = mat * diff;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (info.hit ? tPlane < info.dist : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= exp(-2.0 * sdTriangle(iPlane, a, b, c)); // Fake occlusion with SDF\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 174, 174, 788], [790, 832, 894, 894, 1602], [1604, 1604, 1659, 1659, 4211]], "test": "untested"}
{"id": "3lSBzy", "name": "Neurons 2", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 41, "viewed": 884, "published": 3, "date": "1615130157", "time_retrieved": "2024-07-30T19:33:42.813409", "image_code": "// Fork of \"Feather roots\" by michael0884. https://shadertoy.com/view/WlSfRw\n// 2020-09-03 22:57:56\n\n// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.4\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = vec3(0.5)*(D+0.07);//*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= sin(1.2*vec4(1., 2., 3., 4.)*r);//*texture(iChannel3, c.xy);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 12\n#define sense_ang (0.2)\n#define sense_dis 30.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.5\n#define distance_scale 1.\n#define force_scale 1.0\n#define trailing 0.\n#define acceleration 0.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.0*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.1, 0.1);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= 0.6*M*dgrad;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(max(M - 0., 0.), distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= 1.*dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.0\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 541, 568, 568, 746], [786, 786, 817, 817, 851], [853, 853, 905, 905, 1024], [1026, 1026, 1061, 1061, 1085], [1087, 1087, 1118, 1118, 1205], [1207, 1207, 1228, 1228, 1321], [1323, 1323, 1345, 1345, 1441], [1444, 1444, 1464, 1464, 1659], [1662, 1662, 1697, 1697, 1882], [1921, 1921, 1953, 1953, 2121], [2123, 2123, 2168, 2168, 4988]], "test": "untested"}
{"id": "tljBWz", "name": "Cell variation 1", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 11, "viewed": 433, "published": 3, "date": "1615129365", "time_retrieved": "2024-07-30T19:33:43.932417", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol=vec4(1,2,3,4)*1.5*r;//(0.5 + 0.5*sin(10.*vec4(1.,1.1,1.2,4.)*dot(c.xy + pos/R,vec2(1))));\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n\n/* cell mult\n#define sense_num 8\n#define sense_ang 1.0\n#define sense_dis 10.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.2\n#define distance_scale 0.\n#define force_scale 1.0\n#define trailing 0.\n#define acceleration 0.\n#define remove_acceler 1.\n#define density_normalization_speed 0.14\n#define density_target 0.24\n#define vorticity_confinement 0.0\n#define Pressure(rho) .0*rho.z\n*/\n\n#define sense_num 8\n#define sense_ang 1.0\n#define sense_dis 15.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.3\n#define distance_scale 0.\n#define force_scale 1.0\n#define trailing 0.\n#define acceleration 0.\n#define remove_acceler 0.\n#define density_normalization_speed 0.15\n#define density_target 0.24\n#define vorticity_confinement 0.0\n#define Pressure(rho) -.0*rho.z\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, density_target, density_normalization_speed);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= remove_acceler*dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-vorticity_confinement*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1558], [1561, 1561, 1596, 1596, 1781], [1820, 1820, 1852, 1852, 2020], [2022, 2022, 2067, 2067, 4906]], "test": "untested"}
{"id": "tlKfDV", "name": "ciudad esferas", "author": "jorge2017a1", "description": "ciudad esferas", "tags": ["ciudadesferas"], "likes": 4, "viewed": 249, "published": 3, "date": "1615129334", "time_retrieved": "2024-07-30T19:33:45.033473", "image_code": "//por jorge2017a1-\n//referencia de circulos 2d //https://www.shadertoy.com/view/wdlSDH\n\n#define MAX_STEPS 150\n#define MAX_DIST 300.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   float planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,12.0,5.0)); \n    vec3 prep=p;\n    \n    prep.x= opRep1D( prep.x, 20.5);\n    prep.z= opRep1D( prep.z, 20.5);\n    \n    float srb1= sdRoundBox(prep, vec3(10.0,0.5, 10.), 0.25 );\n    res =opU3(res, vec3(srb1,-1.0,6.0)); \n    \n    \n    vec3 prepB=p;\n    \n    prepB.x= opRep1D( prepB.x, 130.);\n    prepB.z= opRep1D( prepB.z, 100.0);\n    \n    \n    float s1= sdSphere( prepB, 15.0 );\n    float s2= sdSphere( prepB-vec3(20.0,0.0,20.0), 10.0 );\n    float s3= sdSphere( prepB-vec3(50.0,0.0,0.0), 10.0 );\n    float s4= sdSphere( prepB-vec3(50.0,0.0,20.0), 15.0 );\n    \n    \n    res =opU3(res, vec3(s1,-1.0,4.0)); \n    res =opU3(res, vec3(s2,4.0,-1.0)); \n    res =opU3(res, vec3(s3,12.0,-1.0)); \n    res =opU3(res, vec3(s4,13.0,-1.0)); \n    \n    \n    p.y=p.y-5.0;\n   \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    //return lin*atten* calcAO( p,  n);\n    return lin*atten;\n}\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n   \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        {\n            mObj.hitbln = true; \n            minDist = abs(dO);\n            break; \n        }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; \n          minDist = min(minDist, dO);\n          break; \n        }\n        \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*8.0;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//https://www.shadertoy.com/view/wdlSDH\n\n#define SS(d) smoothstep(edge, 0., d)\n#define BAND(i, bcol) col = mix(col, bcol, SS(r + i * band) * SS(-(r + (i + 1.) * band)) * SS(theta - (cycle - .15 -.02 * i)));\n\nvec3  arcoiris( vec2 puv)\n{\n    \n    vec2 uv=puv;\n    \n    float edge = 1.5 / min(iResolution.x, iResolution.y);\n    float theta = atan(uv.x, uv.y) / 6.283185;\n    //float cycle = fract(iTime * .2);\n    float cycle = 1.0;\n    float band = .06 * cycle;\n    float r = length(uv-vec2(0.0,0.5)) - 0.5 * cycle;\n    vec3 col = vec3(.2, .3, .6);\n\n    // ROYGBIV\n    BAND(0., vec3(1, 0, 0)); \n    BAND(1., vec3(1, .5, 0));\n    BAND(2., vec3(1, 1, 0));\n    BAND(3., vec3(0, 1, 0));\n    BAND(4., vec3(0, 0, 1));\n    BAND(5., vec3(.293, 0, .5));\n    BAND(6., vec3(.578, 0, .824));\n    \n    \n    return  sqrt(col * cycle);\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n     if (id_material==6.0)\n    {\n        vec2 uv=p.xz;\n        uv.x-=0.5;\n        uv.y+=8.0;\n        uv*=0.0625;\n        //uv.x=mod(uv.x, 21.0);\n        uv.x= opRep1D( uv.x, 1.3);\n        uv.y= opRep1D( uv.y, 2.6);\n        return  arcoiris(uv);\n    }\n    \n    \n    if (id_material==7.0)\n    {\n        \n        return vec3(0.98,0.95,0.0 )*1.25;\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n///-----------------------------\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\nvec3 getSkyColB(vec3 rd, vec2 uv,vec3 lightrd) \n{\n    \n    vec3 color = mix(vec3(1.0), COLORSKY, uv.y+0.2);\n    float sunGrad = pow(max(0.0, dot(-lightrd, rd)), 4.0);\n    color = mix(color, vec3(sunGrad, sunGrad, 1.0), sunGrad);\n    return color;\n}\n\n\n    \n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*50.0,1000.0);\n    itime=t;\n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n  \n\n    \n    //vec3 ro=vec3(4.0,2.0,-25.0+t);\n    vec3 ro=vec3(35.0,10.0,0.0+t);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    \n    else if(d>MAX_DIST)\n    col= getSkyColB(rd, uv, vec3(0.0));\n     //col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 504, 504, 525], [526, 526, 558, 558, 642], [643, 643, 689, 689, 776], [778, 822, 869, 869, 896], [898, 898, 941, 941, 968], [970, 970, 1018, 1018, 1046], [1047, 1131, 1167, 1167, 1212], [1254, 1294, 1319, 1319, 2328], [2332, 2332, 2397, 2397, 3021], [3024, 3075, 3099, 3099, 3287], [3292, 3292, 3325, 3325, 4081], [4086, 4140, 4176, 4176, 4410], [4467, 4501, 4581, 4581, 4852], [5102, 5102, 5129, 5129, 5714], [5715, 5766, 5813, 5813, 6948], [7002, 7002, 7095, 7095, 7375], [7411, 7411, 7438, 7438, 7548], [7551, 7551, 7600, 7600, 7799], [7808, 7857, 7914, 7914, 9416]], "test": "untested"}
{"id": "tlKBDV", "name": "okota0306_nerumae", "author": "nerumae3", "description": " ", "tags": ["3d"], "likes": 3, "viewed": 381, "published": 3, "date": "1615129145", "time_retrieved": "2024-07-30T19:33:45.882204", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    fragColor=vec4(texture(iChannel0,uv).xyz,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat time;\n\nmat2 rot(float r){\n  float s=sin(r),c=cos(r);\n  return mat2(c,s,-s,c);\n}\n\nfloat rand(vec2 p){\n  return fract(sin(dot(p,vec2(12.34,56.78)))*12345.678);\n}\n\nfloat box(vec3 p,vec3 s){\n  p = abs(p)-s;\n  return min(0.,max(p.x,max(p.y,p.z))) + length(max(p,0.));\n}\n\nfloat map(vec3 p){\n  vec3 q = p;\n  float t =floor(time)+pow(fract(time),.3);\n  for(int i=0;i<5;i++){\n    q = abs(q)-.6;\n    q.xz *= rot(t);\n    q.xy *= rot(.4+t*.6);\n  }\n  float d = box(q,vec3(.5,1.,.5));\n  return d;\n}\n\nvoid cam(inout vec3 p){\n  float t= time*.5;\n  t = floor(time)+pow(fract(time),.3);\n  p.xz *= rot(t);\n  p.xy *= rot(.6);\n}\n\nvec3 normal(vec3 pos){\n  vec2 k = vec2(1.,-1.);\n  float e = 0.001;\n  return normalize(\n  k.xyy * (map(pos+k.xyy*e))+\n  k.yxy * (map(pos+k.yxy*e))+\n  k.yyx * (map(pos+k.yyx*e))+\n  k.xxx * (map(pos+k.xxx*e))\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  vec2 uv = p;\n  p -= .5;\n  p /= vec2(iResolution.y/iResolution.x,1.);\n  p = abs(p)-.5;\n  p = abs(p)-.5;\n  time = iTime/60.*132.;\n  float beat = fract(time);\n  float fft = texture(iChannel0,vec2(.5,.9)).x;\n  vec3 ro=vec3(0.,0.,-12.),rd=normalize(vec3(-p,1.));\n  cam(ro);\n  cam(rd);\n  vec3 col=vec3(0.),pos;\n  float t = 0.01,d;\n  for(int i=0;i<69;i++){\n    pos =ro+rd*t;\n    d = map(pos);\n    if(d<0.01){\n      vec3 n = normal(pos);\n      vec3 ld = normalize(vec3(1.));\n      float edge = clamp(pow(length(n-normal(pos-0.02*beat))*22.,22.),0.,1.);\n      float spec = pow(clamp(dot(reflect(ld,n),rd),0.,1.),22.);\n      col = vec3(.3,.6,.99)*edge + vec3(.3,.6,.99)*spec*2.;\n      //break;\n    }\n    t+=.5;\n    \n  }\n  float r0 = rand(uv+time)*2.-1.,r1 = rand(uv+time)*2.-1.,r2 = rand(uv+time)*2.-1.;\n  vec3 tex = vec3(texture(iChannel1,uv-r0*.01).r,texture(iChannel1,uv+r1*0.001).g,texture(iChannel1,uv+r2*.001).b);\n  \n  col += mix(col,tex,pow(fft,.8)*1.6);\n  fragColor = vec4(col,1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26013, "src": "https://soundcloud.com/niko_14/eins", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 151]], "test": "untested"}
{"id": "wtVfWK", "name": "smart gaussian blur using MIPmap", "author": "FabriceNeyret2", "description": "mouse.y to choose LOD.\nRight: full gaussian filtering ( ring = width )\nLeft: cost / 4^L by using texture MIPmap LOD L. ( Obviously, don't use LOD pix > filter width :-)  )\n( in a full implem, one would also use separability, via buffA ).", "tags": ["blur", "filter", "mipmap", "convolution", "gaussian"], "likes": 8, "viewed": 1432, "published": 3, "date": "1615126656", "time_retrieved": "2024-07-30T19:33:46.750881", "image_code": "//#define f(P) 50.*smoothstep(1.,0.,length(P-.5)*40. ) // impuse response\n  #define f(P) textureLod(iChannel0, P, z )\n//#define f(P) ( textureLod(iChannel0, P, z ) + 50.*smoothstep(1.,0.,length((fract(P+vec2(.5,0))-.5)*40. ) ) )\n\n#define D(P,r) O = mix(O, vec4(1), smoothstep(1.5/R.y,0.,abs(length(U-P)-r) ) ) // draw ring\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = .5+ ( u - .5*R ) / R.y;         \n    O-=O;\n    float w = .1, r,g,t=0.,                         // filter width\n          W = iChannelResolution[0].y,              // texture width\n          Z = 6.,                                   // LOD range\n          z = U.x>.5 ?  0.                          // right: full filter\n             :  length(iMouse.xy)<20. ? mod(floor(iTime),Z)    // LOD approx\n                                      : floor(iMouse.y/R.y*Z); // manual tuning\n    int N = int( W/exp2(z) *w*2. +1.);              // N/w = res\n\n    r = float(N-1)/2.;\n    for( int k=0; k<N*N; k++ ) {\n        P = vec2(k%N,k/N) / r - 1.;                 // [ -1, 1 ]\n        t += g = exp(-2.*dot(P,P) ); \n        O += g * f(U+w*P);\n    }\n    O /= t;\n\n    if (U.y < .25) r = W/exp2(z), O = f(round(U*r)/r); // bottom: show LOD resol\n\n    D(.5, w );                                      // draw filter\n    D( vec2(-.3,(z+.5)/Z), .03 );                   // draw LOD \n    D( vec2(1.3,   .5 /Z), .03 );                   // ref LOD 0\n\n    if ( int(u.x)==int(R.x/2.) ) O = vec4(1,0,0,1); // red separator\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 362, 362, 1505]], "test": "untested"}
{"id": "ttKBDV", "name": "Commodore logo", "author": "mrange", "description": "License CC0: Commodore logo\nCommodore logo is trademark of Polabe Holding NV\n(AFAIK)", "tags": ["2d"], "likes": 9, "viewed": 283, "published": 3, "date": "1615126393", "time_retrieved": "2024-07-30T19:33:47.579666", "image_code": "// License CC0: Commodore logo\n// Commodore logo is trademark of Polabe Holding NV\n// (AFAIK)\n// Distance field for Commodore logo\n// The C isn't perfectly aligned with the logo but close enough for me.\n\n#define RESOLUTION iResolution\n\n\n// IQ's polynominal soft min\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's ellipse\nfloat ellipse(vec2 p, vec2 ab) {\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nconst int N = 4;\n\n// IQ's polygon\nfloat polygon(vec2 p, vec2[N] v) {\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ ) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst vec2[] wing = vec2[](vec2(0.385, 0.435), vec2(1.35, 0.435), vec2(0.92, 0.035), vec2(0.385, 0.035));\n\nfloat commodore(vec2 p, out bool isRed) {\n  vec2 op = p;\n  p.y = abs(p.y);\n  float d0 = ellipse(p, vec2(1.0, 0.865));\n  d0 = abs(d0)- 0.275;\n  float d1 = p.x-0.375;\n  float d2 = polygon(p, wing);\n  float d = d0;\n  d = pmax(d, d1, 0.025);\n  d = pmin(d, d2, 0.025);\n  isRed = op.y > 0.0 && d2 <= 0.0025;\n  return d;\n}\n\nfloat df(vec2 p, out bool isRed) {\n  const float z = 0.75;\n  float dc = commodore(p/z, isRed)*z;\n  return dc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  bool isRed;\n  float d = df(p, isRed);\n  \n  vec3 col = vec3(0.9);\n  vec3 ccol = isRed ? vec3(0.75, 0.0, 0.0): vec3(0.0, 0.0, 0.25);\n  col = mix(col, ccol, smoothstep(-aa, aa, -d));\n\n  if (p.y < 0.0) {\n    col += 0.5*sin(200.0*d);\n  }\n  \n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[237, 266, 305, 305, 394], [396, 396, 435, 435, 464], [466, 482, 514, 514, 1536], [2106, 2106, 2147, 2147, 2421], [2423, 2423, 2457, 2457, 2534], [2536, 2536, 2591, 2591, 3058]], "test": "error"}
{"id": "wlKBWV", "name": "coloring_from_center1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 0, "viewed": 240, "published": 3, "date": "1615120456", "time_retrieved": "2024-07-30T19:33:48.386509", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float lx=distance(uv.x,.5)*20.;\n    float ly=distance(.5,uv.y)*20.;\n    float dir=atan(uv.x-.5,uv.y-.5)*10.;\n    \n    vec3 col = 0.5 + 0.3*cos(iTime+uv.xyy+vec3(0,2,4));\n    col+=vec3(.5*cos(lx+dir+iTime),.5*cos(lx+dir+iTime),.5*cos(lx+dir+iTime));\n    col+=vec3(.5*sin(ly+dir+iTime),.5*sin(ly+dir+iTime),.5*sin(ly+dir+iTime));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 464]], "test": "untested"}
{"id": "ttVfDK", "name": "coloring_from_center", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 1, "viewed": 236, "published": 3, "date": "1615118045", "time_retrieved": "2024-07-30T19:33:49.163431", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float _xy=atan(uv.y-.5,uv.x-.5)*1.;\n    col+=vec3(.2*sin((_xy+iTime)),.2*sin((_xy+iTime)),.2*sin((_xy+iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 410]], "test": "untested"}
{"id": "tlKfDK", "name": "Britney variant of Golf Style", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/wtVBWK[/url]\nwhich was simplied variant of my golfing of iapafoto's [url]https://shadertoy.com/view/tlVBzV[/url]", "tags": ["city", "golf", "almost1tweet"], "likes": 19, "viewed": 575, "published": 3, "date": "1615115264", "time_retrieved": "2024-07-30T19:33:49.926391", "image_code": "// variant of https://shadertoy.com/view/wtVBWK\n//            simplied variant of my golfing of iapafoto's https://shadertoy.com/view/tlVBzV\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float l = .2;\n    vec3 R = iResolution,\n         P = vec3(iTime,3,0)*7.,\n         D = vec3( ( U - .5*R.xy ) / R.y + l*cos(.5*iTime) , 1 );\n      // D = vec3( ( U - .5*R.xy ) / R.y                   , 1 ); // 1 tweet version\n    for( D.yz *= mat2(4,-3,3,4)*l; \n         l > .1; \n         O = texture(iChannel0,ceil(P.xz)/40.),\n         l = min( P.y - 8.* O.r, .11 )\n       ) P += l*D;\n    O *= length(step(.1,fract(P.xz))); // P alone would adds vertical ticks\n // O *= .2+P.y/P.z;                   // + shadowing and AO\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 179, 179, 706]], "test": "untested"}
{"id": "wlKfWK", "name": "Satisfying Shininess", "author": "oneshade", "description": "I'm obsessed with shiny stuff now (had to throw in a matte material too though).", "tags": ["raytracing", "materials", "matte", "metal", "shiny", "plastic", "satisfying"], "likes": 12, "viewed": 162, "published": 3, "date": "1615107210", "time_retrieved": "2024-07-30T19:33:50.883831", "image_code": "//#define ANIMATE\n//#define METAL\n#define PLASTIC\n//#define RUBBER\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat fbm(in float x) {\n    x *= 0.5;\n\n    float v = 0.0;\n    float n = 1.0;\n    float t = 0.0;\n\n    for (int i=0; i < 5; i++) {\n        v += mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x))) * n;\n        t += n;\n        n *= 0.5;\n        x *= 2.0;\n    }\n\n    return v / t;\n}\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && length(p) < 5.0;\n}\n\nvec4 render(in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = 1406.42;\n\n    #ifdef ANIMATE\n    time = iTime;\n    #endif\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(iTime * 0.5, -0.5);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    vec4 fragColor = texture(iChannel0, rd);\n\n    // Isovalues\n    float a = fbm(time + 357.473);\n    float b = fbm(time + 738.484);\n    float c = fbm(time + 576.475);\n    float d = fbm(time + 857.782);\n    float e = fbm(time + 867.281);\n    float f = fbm(time + 329.385);\n    float g = fbm(time + 234.235);\n    float h = fbm(time + 813.574);\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        n *= sign(dot(n, rd)); // Flip towards camera\n\n        #ifdef METAL\n        vec4 envMap = texture(iChannel0, reflect(rd, n));\n        fragColor = envMap * max(0.0, dot(rd, n));\n        #endif\n\n        #ifdef PLASTIC\n        for (int i=0; i < numIntersects; i++) {\n            vec3 pos = ro + rd * intersect[i];\n            float t = intersect[i];\n            if (intersectIsValid(pos, t)) {\n                vec4 envMap = texture(iChannel0, reflect(rd, n));\n                fragColor = mix(fragColor, envMap * max(0.0, dot(rd, n)), 0.5);\n            }\n        }\n        #endif\n\n        #ifdef RUBBER\n        fragColor = vec4(sqrt(max(0.0, dot(rd, n))));\n        #endif\n    }\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = render(fragCoord);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 157, 183, 183, 269], [271, 271, 294, 294, 567], [569, 585, 650, 650, 1752], [1754, 1830, 1896, 1896, 2039], [2041, 2086, 2235, 2235, 2949], [2951, 2951, 3087, 3087, 3474], [3476, 3476, 3522, 3522, 3563], [3565, 3565, 3597, 3597, 5927], [5929, 5929, 5984, 5984, 6021]], "test": "untested"}
{"id": "wtVBWK", "name": "BW golfed variant of Golf Style", "author": "FabriceNeyret2", "description": "simplied variant of my golfing of iapafoto's [url]https://shadertoy.com/view/tlVBzV[/url]", "tags": ["city", "golf", "almost1tweet"], "likes": 12, "viewed": 426, "published": 3, "date": "1615103338", "time_retrieved": "2024-07-30T19:33:51.765474", "image_code": "// simplied variant of my golfing of iapafoto's https://shadertoy.com/view/tlVBzV\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float l = .2;\n    vec3 R = iResolution,\n         P = vec3(iTime,3,0)*7.,\n         D = vec3( ( U - .5*R.xy ) / R.y + l*cos(.5*iTime) , 1 );\n      // D = vec3( ( U - .5*R.xy ) / R.y                   , 1 ); // 1 tweet version\n    for( D.yz *= mat2(4,-3,3,4)*l; \n         l > .1; \n         l = min( P.y - 8.* fract( sin(dot(ceil(P).xzz,R)) * 4e5 ), .11 )\n       ) P += l*D;\n    O += P.y/P.z * length(step(.1,fract(P))) -O;\n}\n\n\n\n\n\n\n/* // 276 chars  simplied variant of my golfing of iapafoto's shader\n\n#define N(v) fract( sin(dot(v,R)) * 4e5 )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float l = .2;\n    vec3 R = iResolution,\n         P = vec3(iTime,3,0)*7.,\n         D = vec3( ( U - .5*R.xy ) / R.y + l*cos(.5*iTime) , 1 );\n    for( D.yz *= mat2(4,-3,3,4)*l; l > .1; l = min( P.y - 8.*N(ceil(P).xzz), .11) )\n        P += l*D;\n    O += P.y/P.z * length(step(.1,fract(P))) -O;\n}\n\n\n\n\n\n\n/*  // 346 chars golfed version of  4997chars iapafoto. https://shadertoy.com/view/tlVBzV\n\n\n#define N(v) fract( sin(dot(v,R)) * 4e5 )\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float a = .2;\n    vec3 R = iResolution, i,\n         p = vec3(iTime,3,0)*7.,\n         d = vec3( ( U - .5*R.xy ) / R.y + a*cos(.5*iTime) , 1 );\n    for( d.yz *= mat2(4,-3,3,4)*a; a > .1; a = min(p.y-a,.11) )\n        p += a*d,\n        i = ceil(p*.5),\n        a = 4.*mod(i.x*i.z,3.) * N(i.xzz);\n        O.rgb =  sqrt(p.y/p.z) \n               * exp( .4*cos(.1*p) *(N(ceil(p))-.5) )\n               * length(step(.1,fract(p)));\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 120, 120, 546]], "test": "untested"}
{"id": "WtVfDV", "name": "Shiny Aluminum Cornell Box", "author": "oneshade", "description": "Shiny! Example of direct ray intersections with triangles. It is a MUCH faster way to render meshes on a per-pixel basis. Original: [url=https://www.shadertoy.com/view/3tcfWf]https://www.shadertoy.com/view/3tcfWf[/url]", "tags": ["cornellbox", "box", "metal", "shiny", "shiny", "shiny", "aluminum"], "likes": 3, "viewed": 190, "published": 3, "date": "1615095342", "time_retrieved": "2024-07-30T19:33:52.774775", "image_code": "struct TriIntersect {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n};\n\n// Triangle intersector - inefficient but fairly simple\n// For a more efficient triangle intersector (without any square roots), see Inigo Quilez's\n// ray intersectors page: https://iquilezles.org/articles/intersectors\nTriIntersect IntersectTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a; a = vec3(0.0);\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    // Intersect plane\n    vec3 n = cross(ba, -ac);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        // Triangle subareas for point in triangle test and computing barycoords\n        vec3 p = ro + rd * t;\n        vec3 pa = p - a, pb = p - b, pc = p - c;\n\n        float abc = length(n);\n        float u = length(cross(ba, pa)) / abc;\n        float v = length(cross(cb, pb)) / abc;\n        float w = length(cross(ac, pc)) / abc;\n\n        return TriIntersect(abs(u + v + w - 1.0) < 0.001, p, t, vec3(u, v, w));\n    }\n\n    return TriIntersect(false, vec3(0.0), 0.0, vec3(0.0)); // No hit, dummy values\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 st = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 35.0);\n    vec3 rd = normalize(vec3(st, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Cubemap\n    fragColor = texture(iChannel0, rd) * 0.75;\n\n    bool intersecting = false;\n    float tMin = 1000000.0;\n    vec3 pos, normal;\n    vec2 uv;\n\n    for (int i=0; i < indices.length(); i += 3) {\n        vec3 na = normals[indices[i]];\n        vec3 nb = normals[indices[i + 1]];\n        vec3 nc = normals[indices[i + 2]];\n\n        vec2 uva = uvs[indices[i]];\n        vec2 uvb = uvs[indices[i + 1]];\n        vec2 uvc = uvs[indices[i + 2]];\n\n        vec3 a = vertices[indices[i]];\n        vec3 b = vertices[indices[i + 1]];\n        vec3 c = vertices[indices[i + 2]];\n\n        TriIntersect info = IntersectTriangle(ro, rd, a, b, c);\n        if (info.hit && info.dist > 0.0 && info.dist < tMin) {\n            tMin = info.dist;\n            pos = info.pos;\n            intersecting = true;\n\n            // You can interpolate other things with the barycoords too\n            normal = na * info.bary.x + nb * info.bary.y + nc * info.bary.z;\n            uv = uva * info.bary.x + uvb * info.bary.y + uvc * info.bary.z;\n        }\n    }\n\n    if (intersecting) {\n        normal *= sign(dot(normal, -rd)); // Make sure its oriented torwards the camera\n\n        vec3 mat = texture(iChannel0, reflect(rd, normal)).rgb;\n        vec3 fogColor = vec3(0.0);\n\n        float diff = max(0.0, dot(normal, -rd));\n        float fog = exp(1.0 - 0.025 * tMin);\n\n        fragColor.rgb = mix(fogColor, mat * diff, fog);\n    }\n\n    // Gamma correction, sometimes I like, sometimes I don't\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Mesh data copied from https://www.shadertoy.com/view/3tcfWf\n\n// Triangularized Cornell box mesh data:\nvec3 vertices[20] = vec3[20](\nvec3(-10.0,10.0,10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[20] = vec2[20](\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[20] = vec3[20](\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv values.\nconst int numIndices = 90;\nint indices[30] = int[30]\n(\n0,1,2,\n0,2,3,\n4,5,6,\n4,6,7,\n8,9,10,\n8,10,11,\n12,13,14,\n12,14,15,\n16,17,18,\n16,18,19\n);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 304, 393, 393, 1135], [1137, 1137, 1192, 1192, 3243]], "test": "untested"}
{"id": "3lKfDV", "name": "Hella Unreal mountain", "author": "jdc", "description": "Interesting fractal mountain with trees and shrubberies", "tags": ["fractal"], "likes": 3, "viewed": 261, "published": 3, "date": "1615094877", "time_retrieved": "2024-07-30T19:33:53.797042", "image_code": "//creator: ldm0\n//Personal website: ldm0.xyz\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    float m;\n    vec2 uv = coord.xy / iResolution.xy;\n    uv.x *= 2.;\n    uv.x -= 1.;\n    //uv.y *= 1.182;\n    uv.y += .382;\n    for (int i = 0; i < 33; ++i) {\n        uv= abs(uv);\n        m = uv.x * uv.x  + uv.y * uv.y + .003 * abs(sin(iTime));// - .0031;\n        uv.x = uv.x/m - .217;\n        uv.y = uv.y/m - .105 * 1.8*abs(sin((3.14159 / 2.) * sin(iTime)) - 1.55);\n    }\n\n    color = vec4(vec3(m + 0.28 * cos(iTime), m + .28, m + 0.28 * cos(iTime)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 92, 92, 552]], "test": "untested"}
{"id": "3lVfWV", "name": "Dendrite-Biased Julia Rotation", "author": "jdc", "description": "Dendrite-Biased Julia Set\n\nc_i loiters near zero\nc_j loiters near one and negative one", "tags": ["fractal", "julia", "dendrite"], "likes": 1, "viewed": 244, "published": 3, "date": "1615086254", "time_retrieved": "2024-07-30T19:33:55.028749", "image_code": "/* \n    The Julia set is the subset of the complex plane given by the points \n    whose nth iteration of the function f_c (z) = z * z + c has a modulus \n    of at most two for all natural n.\n*/\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n// Pi divided by two (pi/2)\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\n\nvec2 multiply(vec2 x,vec2 y){\n    return vec2(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 5.*(fragCoord/iResolution.x-vec2(.5,.27));\n    vec3 col;\n\n    float a = M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(iTime / 2.)))));\n    float noise = sin(M_PI * sin(9.*iTime)) / 600.;\n    vec2 c = vec2(sin(a + M_PI_2) + noise, sin(a) + noise);\n\n    for(int i = 0; i < 500;i++){\n\n        vec2 z = multiply(z0,z0)+c;\n        float mq = dot(z,z);\n        if( mq > 4.){\n\n            col = vec3(float(i)/20.,0.,float(i)/4.);\n            break;\n        } else {\n            z0 = z;\n        }\n        col = vec3(mq/2.,0.,(mq * float(i))/4.);\n    }\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 432, 432, 484], [485, 485, 542, 542, 1151]], "test": "untested"}
{"id": "3tcfWf", "name": "SDF Triangularized Mesh Tracer", "author": "jstrom2002", "description": "Experimenting with SDF functions for triangularized meshes. Work-in-progress.\nMuch of the code is borrowed from iq's SDF triangle shader: https://www.shadertoy.com/view/4sXXRN", "tags": ["sdf"], "likes": 5, "viewed": 567, "published": 3, "date": "1615076174", "time_retrieved": "2024-07-30T19:33:56.205602", "image_code": "// NOTE: much of this code was borrowed from iq's SDF raymarching code\n// from the following shadertoy: https://www.shadertoy.com/view/4sXXRN\n\n// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmat4 RotateScaleTranslate( vec3 r, vec3 s, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f*s.x,  d*e,          -c,      0.0,\n                 ac*f-b*e, ac*e+b*f*s.y, a*d,     0.0,\n                 bc*f+a*e, bc*e-a*f,     b*d*s.z, 0.0,\n                 t.x,      t.y,          t.z,     1.0 );\n}\nvec3 applyTransform(vec3 v, mat4 M)\n{\n    vec4 v_ = vec4(v, 1.0);\n    v_ = M * v_;\n    return v_.xyz / v_.w;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// from iq:\nfloat udTriangle(in vec3 ro, in vec3 rd, in vec3 v1, \n    in vec3 v2, in vec3 v3, in vec3 p, out vec3 bary )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    // I've added this bit to get the barycentric coordinates for texture mapping:\n    vec3 e2 = ( v1 - ro ) / dot( -nor, rd );\n    vec3 i  = cross( rd, e2 );\n    bary.y = dot( i, v13 );\n    bary.z = dot( i, v21 );\n    bary.x = 1.0 - bary.y - bary.z;\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat map(in vec3 ro, in vec3 rd, in float t, out vec3 bary, out int idx)\n{\n    vec3 p = ro + rd * t;\n    vec3 v1,v2,v3;\n    vec3 baryc;\n    float d_final = MAX_DISTANCE;\n    \n    mat4 M = RotateScaleTranslate(modelRot, modelScale, modelPos);\n    \n    for(int i=0; i < numIndices; i+=3)\n    {\n        // Get triangle data and transform vertices.\n        v1 = vertices[indices[i+0]];\n        v2 = vertices[indices[i+1]];\n        v3 = vertices[indices[i+2]];  \n        \n        v1 = applyTransform(v1, M);\n        v2 = applyTransform(v2, M);\n        v3 = applyTransform(v3, M);\n                \n        // Calc distance, compare with current distance.\n        float d1 = udTriangle(ro, rd, v1, v2, v3, p, baryc ) - 0.01;\n        if(d1 < d_final)\n        {\n            d_final = d1;\n            bary = baryc;\n            idx = i;\n        }\n    }\n\n    return d_final;\t\n}\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 bary, out int idx)\n{\n\tfloat h = 1.0;\n    float t = 0.0;\n\n    // March ray, checking distance to mesh data at each step.\n    for(int i = 0; i < INTERSECTION_PASSES; i++)\n    {\n        if(h < INTERSECT_EPSILON || t > SCENE_MAX_BOUND) \n            break;\n\t    h = map(ro,rd,t,bary,idx);\n        t += h;\n    }\n\n    // If parameter t has been stepped beyond scene bounds, return null value.\n    if(t > SCENE_MAX_BOUND) \n        t=-1.0;\n\t\n    return t;\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * PI;\n    vec2 st = (fragCoord - center) / iResolution.y;\n    \n    // Rotate light source.\n    float theta = 2.0*iTime/PI;\n    lightPos += 5.0 * vec3(\n        cos(theta)*sin(theta),\n        sin(theta)*sin(theta),\n        sin(theta)\n    );\n\n    // Init ray.\n\tvec3 ro = camPos;\n\tvec3 rd = normalize(st.x * camRight + st.y * -camUp + camFront);\n\t\n    // Rotate with mouse -- borrowed from oneshade: https://www.shadertoy.com/view/WtVfDV\n    float cy = cos(mouse.x), sy = -sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);    \n    \n\tvec3 col = vec3(0.0);\n    bool anyHit = false;\n    \n    for(int bounce_number = 1; bounce_number < BOUNCES+1; ++bounce_number)\n    {\n        vec3 bary;\n        int idx = -1;\n        float t = intersect(ro,rd,bary,idx);\n        if( t>0.0 )\n        {               \n            anyHit = true;\n            vec3 pos = ro + t*rd;\n        \n            // Get normals from mesh data and interpolate with barycentric coordinate.\n            vec3 n1 = normals[indices[idx+0]];\n            vec3 n2 = normals[indices[idx+1]];\n            vec3 n3 = normals[indices[idx+2]];        \n            vec3 nor = normalize(bary.x * n1 + bary.y * n2 + bary.z * n3);\n            nor *= -sign(dot(nor, rd)); // Flip towards camera\n            \n            if(DEBUG_NORMALS != 0)\n            {\n                fragColor = vec4(nor,1.0);\n                return;\n            }\n            \n            // Get uvs from mesh data and interpolate with barycentric coordinate.\n            vec2 uv1 = uvs[indices[idx+0]];\n            vec2 uv2 = uvs[indices[idx+1]];\n            vec2 uv3 = uvs[indices[idx+2]];        \n            vec2 texCoord = bary.x * uv1 + bary.y * uv2 + bary.z * uv3;\n        \n            // Lambertian diffuse lighting w/ albedo map:\n            vec3 lightToHitFrag = lightPos - pos;        \n            vec3 L = normalize(lightToHitFrag);\n            float NdotL = max(dot(nor,L),0.0);\n            vec3 albedo = texture(iChannel1,texCoord).rgb;\n            vec3 diffuse = vec3(NdotL) * lightCol * albedo;\n        \n            // Light falloff.\n            float dist = dot2(lightToHitFrag);\n            float linear_falloff = dist / lightIntensity[1];\n            float quad_falloff = dist * dist / lightIntensity[2];\n            float attenuation = 1.0 / (1.0 + linear_falloff + quad_falloff);\n        \n            col += (diffuse * attenuation) / float(bounce_number);\n        \n            // Setup next ray.\n            ro = pos;\n            rd = reflect(pos, nor);\n        }\n    }\n    \n    // If ray missed all mesh triangles, shade skybox\n    if(!anyHit)\n        col = texture(iChannel0, -1.0 * rd).rgb;\n    \n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Global definitions -- some of these values can kill your framerate, beware!\n#define BOUNCES 1\n#define DEBUG_NORMALS 0\n#define INTERSECT_EPSILON 0.01\n#define INTERSECTION_PASSES 30\n#define MAX_DISTANCE 10.0\n#define PI 3.1415926\n#define SCENE_MAX_BOUND 50.0\n\n// Triangularized Cornell box mesh data:\nconst int maxIndexValue = 20;\nvec3 vertices[maxIndexValue] = vec3[maxIndexValue](\nvec3(-10.0,10.0,10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[maxIndexValue] = vec2[maxIndexValue](\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[maxIndexValue] = vec3[maxIndexValue](\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv values.\nconst int numIndices = 30;\nint indices[numIndices] = int[numIndices]\n(\n0,1,2,\n0,2,3,\n4,5,6,\n4,6,7,\n8,9,10,\n8,10,11,\n12,13,14,\n12,14,15,\n16,17,18,\n16,18,19\n);\n\nvec3 modelPos = vec3(0,0,0);\nvec3 modelScale = vec3(1.0);\nvec3 modelRot = vec3(0.0,PI,0.0);\n\nvec3 camPos = vec3(0,0,-29);\nvec3 camRight = vec3(1,0,0);\nvec3 camUp = vec3(0,1,0);\nvec3 camFront = vec3(0,0,1);\n\n// Single point light.\nvec3 lightPos = vec3(0, 0, 0);\nvec3 lightCol = vec3(1.0);\nvec3 lightIntensity = vec3(5.0e4);//attenuation factors for constant/linear/quadratic light falloff\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfWf.jpg", "access": "api", "license": "mit", "functions": [[1221, 1221, 1274, 1274, 1675], [1676, 1676, 1713, 1713, 1786], [1788, 1788, 1813, 1813, 1832], [1834, 1846, 1956, 1956, 2860], [2862, 2862, 2937, 2937, 3728], [3729, 3729, 3799, 3799, 4227], [4286, 4286, 4343, 4343, 7266]], "test": "untested"}
{"id": "3tKBWK", "name": "Lorentz Transformation", "author": "mgattis", "description": "Experimenting with the Lorentz transformation.", "tags": ["math", "physics"], "likes": 5, "viewed": 353, "published": 3, "date": "1615063790", "time_retrieved": "2024-07-30T19:33:57.288707", "image_code": "const float scale = 1.2;\n\nfloat point(vec2 p)\n{\n    float s = 2.0 / iResolution.y * scale;\n    return step(length(p), 8.0 * s);\n}\n\nfloat axis(vec2 p)\n{\n    float s = 2.0 / iResolution.y * scale;\n    // axis\n    vec2 a = step(mod(abs(p), vec2(1.0)), vec2(2.0 * s));\n    a += step(mod(abs(p), vec2(0.1)), vec2(s));\n    return a.x + a.y;\n}\n\nfloat box(vec2 p)\n{\n    p = abs(p);\n    //float b = step(max(p.x, p.y), 1.0);\n    return step(p.x - p.y, 0.0);\n}\n\nvec3 image(vec2 fragCoord)\n{\n    float s = 2.0 / iResolution.y * scale;\n    \n    vec2 p = 2.0 * fragCoord.xy / iResolution.y;\n    p -= vec2(iResolution.x / iResolution.y, 0.2);\n    p *= scale;\n    \n    vec2 q = 2.0 * iMouse.xy / iResolution.y;\n    q -= vec2(iResolution.x / iResolution.y, 0.2);\n    q *= scale;\n    \n    vec3 color = vec3(0.0);\n    \n    //q = vec2(0.39, 0.399);\n    //q = vec2(1.0, 4.0);\n    //q.y = 1.0;\n    //q.x = -q.x;\n    float c = 1.0;\n    float v = q.x / q.y;\n    float g = 1.0 / sqrt(1.0 - v * v / (c * c));\n    mat2 l = mat2(\n        1.0 + (g - 1.0),\n        -g * v / c,\n        -g * v / c,\n        g);\n    //q.x = -q.x;\n    \n    color += box(p) / 8.0;\n    color += axis(p) / 4.0;\n    color += axis(l * p) / 8.0;\n    vec2 r = l * p;\n    for (int i = 0; i <= 8; i++)\n    {\n        float t = 0.25 * float(i);\n        color += point(r - vec2(0.0, t));\n        color.r += point(r - vec2(0.25 * t, t)) / 2.0;\n        color.rg += point(r - vec2(t + 0.125, t + 0.5)) / 2.0;\n        color.b += point(r - vec2(-0.5, t));\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int aa = 2;\n    vec3 c = vec3(0.0);\n    for (int i = 0; i < aa; i++)\n    {\n        for (int j = 0; j < aa; j++)\n        {\n            vec2 p = fragCoord.xy + vec2(i, j) / float(aa);\n            c += image(p);\n        }\n    }\n    fragColor = vec4(c / float(aa * aa) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 129], [131, 131, 151, 151, 336], [338, 338, 357, 357, 450], [452, 452, 480, 480, 1519], [1521, 1521, 1578, 1578, 1862]], "test": "untested"}
{"id": "wlyfWV", "name": "DJ Visuals with broken sdf", "author": "eimink", "description": "Destroying signed distance fields for nice visuals.", "tags": ["raymarching", "sdf", "fakeglow"], "likes": 0, "viewed": 228, "published": 3, "date": "1615063096", "time_retrieved": "2024-07-30T19:33:58.168355", "image_code": "const float E = 0.0001;\nconst float FAR = 40.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat speed = 2.0;\nfloat tunnelrot = 1.4;\nfloat tunneltwst = .6;\nfloat camyaw = 0.4;\nfloat morphspd = 0.25;\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    float s1 = smoothstep(41.,41.+(iTime*0.01),sin(iTime));\n    float s2 = smoothstep(157.,157.+(iTime*0.01),cos(iTime));\n    float s3 = smoothstep(353.,353.+(iTime*0.01),sin(iTime));\n    vec3 s=vec3(s1,s2,s3);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat noise2(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(11,313,701);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat box (vec3 p, vec3 r){\n    vec3 d = abs(p) - r;\n    return length(max(d,0.0) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 twistz(vec3 p, float k) {\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat tun2(vec3 p){\n    vec3 pp = p;\n    vec3 t = vec3(2.) - abs(vec3(length(pp.xz),length(p.xy),1.0));\n    return max(t.x,t.y)+.1;\n    return min(max(t.x,t.y),0.0);\n}\n\nfloat tun(vec3 p){\n    vec3 t = vec3(2.) - abs(twistz(p,tunneltwst));\n    return min(t.x,t.y);\n}\n\nfloat op(vec3 p){\n    float d1 = tun2(p);\n    float d2 = tun(p);\n    float d3 = mix(noise(p),noise2(p),-1.);\n    float t = clamp(iTime*0.1,0.0,1.);\n    return mix(d2,d1,t)+d3;\n}\n\nfloat scene(vec3 p)\n{\n    vec3 pp = p;\n    //pp -= vec3(0.,0.,iTime*speed+1.5);\n    for (int i = 0; i < 5; ++i)\n    {\n        rot(pp.xy,iTime*0.01);\n        rot(pp.xz,cos(iTime*0.2));\n        rot(pp.yz,sin(iTime*0.2));\n        pp = twistz(abs(pp) - float(i)*vec3(.1,.2,.0),.1);\n        \n    }\n    float a = oct(pp,2.5);\n    float c = box(pp,vec3(1.2,1.2,1.2));\n    float d =  mix(c,a,cos(3.+iTime*morphspd)*1.2);\n    rot(p.yx,iTime*tunnelrot);\n    float b = op(pp);\n    d = max(d,0.01);\n    \n    if (mod(p.z,noise2(p)) <= 1.) {\n            glow += vec3(.6+cos(iTime*2.)*0.3,.0,.6+sin(iTime)*0.2)*0.001/(0.01+abs(b));\n        }\n    glow += vec3(0.7,0.3,0.0)* 0.01 / (0.01+abs(d));\n    float r = min(b,max(c,a));\n    return abs(r);\n}\n\nfloat march(in vec3 ro, in vec3 rd, out vec3 p)\n{\n    p = ro;\n    float t = E;\n    for (int i = 0; i < STEPS; ++i) {\n        float d = scene(p);\n        t += d;        \n        if (d < E || t > FAR) {\n            break;\n        }\n        p -= rd*d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(sin(iTime)*camyaw,.0,-3.);//iTime*speed);\n    rot(cp.xz,sin(iTime*0.001));\n    vec3 ct = vec3(0,0,-1);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(60.0)));\n   \n    vec3 col = vec3(1.);\n    vec3 p = vec3(0);\n    float t = march(cp,rd,p);\n    if (t < FAR) {\n            col = mix(vec3(.2,.2,.6),vec3(.3,.3,.8),step(0.9,fract(p.z)))*exp((cp.z-p.z)*0.3);       \n    }\n    col *= glow;\n    col = smoothstep(0.0,1.0,col);\n    col *= (1.0-vec3(t/FAR));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 226, 226, 659], [661, 661, 683, 683, 934], [936, 936, 969, 969, 1014], [1016, 1016, 1043, 1043, 1137], [1139, 1139, 1168, 1168, 1221], [1223, 1223, 1253, 1253, 1366], [1368, 1368, 1387, 1387, 1535], [1537, 1537, 1555, 1555, 1633], [1635, 1635, 1652, 1652, 1812], [1814, 1814, 1835, 1835, 2545], [2547, 2547, 2596, 2596, 2817], [2820, 2820, 2877, 2877, 3658]], "test": "untested"}
{"id": "tlyfDV", "name": "pow(The Shining, 2.0)", "author": "dean_the_coder", "description": "Another 'Shining' corridor scene, this time playing with a recursive camera path - A first for me, and fun to make!", "tags": ["3d", "raymarching", "recursion", "horror", "movie", "cineshader"], "likes": 43, "viewed": 9505, "published": 3, "date": "1615063068", "time_retrieved": "2024-07-30T19:33:59.106846", "image_code": "// 'pow(The Shining, 2.0)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/tlyfDV\n//\n// Another 'Shining' corridor scene, this time playing\n// with a recursive camera path - A first for me, and\n// fun to make!\n//\n// My previous Shining scene here:\n//   https://www.shadertoy.com/view/3stBDf\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 20.0\n#define MAX_STEPS\t\t 64.0\n#define SHADOW_STEPS\t 30.0\n#define MAX_SHADOW_DIST  20.0\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0.0, // Glow.\n      bld = 1.0; // Blood.\n\n#define AA    // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d, id;\n\tvec3 uv;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH    p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\nfloat hash11(float p) { HASH }\nvec2 hash22(vec2 p) { HASH }\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 3.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(hash22(h), hash22(h + s.x), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdHex(vec2 p, float r) {\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat deco(vec2 p) {\n    p.xy = fract(p.xy * rot(-2.36) * 1.5);\n    return step(0.5, fract(min(p.x, p.y) * 4.0));\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\n#define GROUND_ID  1.\n#define WALL_ID    2.\n#define CANVAS_ID  3.\n#define FRAME_ID   4.\n#define LIGHT_ID   5.\n#define WOOD_ID    6.\n\n#define FRAME_P    vec3(2.5, 2.7, -0.12)\n#define RO         vec3(-7, 2.4, -3)\n#define LA         vec3(10, 2.4, -3)\n#define LIGHTP     vec3(3.4, 3.5, -2.6)\n\nHit map(vec3 p) {\n\tHit h = Hit(abs(p.y), GROUND_ID, p);\n    \n    float d = length(p - LIGHTP - vec3(0,1.5,0)) - 0.4;\n    minH(h, Hit(d, LIGHT_ID, p));\n    g += 0.002 / (0.001 + d * d);\n    \n    // Wallz.\n    d = min(sdBox(p - vec3(0,2.2,0), vec3(5, 3, 0.1)), -sdBox(p - vec3(0,2.4,0) - vec3(0,0,4), vec3(10, 2.5, 9.5)));\n    minH(h, Hit(min(d, max(abs(p.x) - 0.15, -sdBox(p + vec3(0,0,2.8), vec3(1, 4.5, 2.6)))), WALL_ID, p));\n\n    // Skirting.\n    d = min(sdBox(p - vec3(0, 0, 0), vec3(5, .38, 0.15)), sdBox(p - vec3(0, 0, -5.6), vec3(10, .38, 0.15)));\n    d = min(d, min(d, sdBox(p - vec3(10, 0, -5.6), vec3(.15, .38, 9))));\n    vec3 mp = p; mp.z = abs(mp.z + 2.8) - 2.65;\n    minH(h, Hit(min(d, sdBox(mp, vec3(.2, .38, .1))), WOOD_ID, p));\n\n    // Picture frame.\n    p -= FRAME_P;\n    vec3 cs = vec3(0.885, 0.5, 0.01);\n    minH(h, Hit(sdBox(p, cs), CANVAS_ID, p));\n    minH(h, Hit(max(sdBox(p, cs + 0.1), -sdBox(p, cs + vec3(0,0,1))), FRAME_ID, p));\n\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * 0.4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\n/**********************************************************************************/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n    float s = 0.0, gg = g;\n\tvec3 ld = normalize(LIGHTP - p), n = N(p, d), c = vec3(0);\n         \n    if (h.id == WALL_ID) {\n        n = normalize(n + n31(h.uv * vec3(3.7, 1.7, 2.7)) * 0.08);\n        if (p.x < 9.99)\n            c = vec3(0.4);\n        else {\n            s = deco(p.zy);\n            c = (0.1 + 0.2 * s) * vec3(0.05, 0.15, 0.1);\n        }\n    } else if (h.id == GROUND_ID)\n        c = carpet(h.uv.zx * 3.5) * ((n21(p.xz * 85.0) - 0.5) * 0.4 + 0.6);\n    else if (h.id == FRAME_ID)\n        c = vec3(0.01);\n    else if (h.id == WOOD_ID)\n        c = 0.02 * mix(vec3(1.7, 1, .5), vec3(.8, .5, .3), vec3(hash11(hash31(p.yxz * vec3(0, 1, 30)))));\n    \n    if (bld > 0.0)\n        c = mix(vec3(.6,0.01,0.02), vec3(dot(c, vec3(.2, .72, .08))), sat((p.y * .5 + .5) * n31(p) / (0.1 + n31(p * vec3(9, 2, 9)))));\n\n\t// Primary light.\n\tfloat l1 = sat(.1 + .9 * dot(ld, n))\n               * (0.6 + 0.4 * shadow(p, ld)),\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3\n\n    // Specular.\n\t     + pow(sat(dot(rd, reflect(ld, n))), 10.0 + s * 10.0) * (0.6 + s),\n\n\t// Combine into final color.\n\tlig = l1 + l2 * mix(ao(p, n, .2), ao(p, n, 0.5), .3);\n    g = gg;\n\treturn lig * c * mix(vec3(2, 1.8, 1.7), vec3(0.2, 0.18, 0.13), bld);\n}\n\nvec3 march(vec3 p, vec3 rd) {\n\tfloat d = .0;\n    vec3 ro = p;\n    g = 0.0;\n\tHit h;\n\tfor (float i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST) {\n            if (h.id != CANVAS_ID) break;\n            bld = 1.0 - bld; // Toggle the blood.\n            p = RO;\n            g = d = 0.0;\n            rd = rayDir(RO, LA, h.uv.xy);\n            continue;\n        }\n\n        d += h.d;\n        if (d > MAX_DIST)\n            return vec3(0);\n\n        p += h.d * rd; // No hit, so keep marching.\n\t}\n\n\treturn g + lights(p, rd, d, h);\n}\n\nfloat h21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t// Camera.\n    float t = fract(iTime * 0.2);\n    bld = floor(mod(iTime / 5.0, 2.0));\n\tvec3 ro = mix(RO, vec3(FRAME_P.x, RO.yz), t);\n    \n    t *= .88056;\n    vec3 fp = FRAME_P + vec3(0, .1, 0);\n    vec3 lookAt = mix(LA, fp + vec3(0, -.1, 0.1), S(t * 1.5));\n\n    ro = mix(ro, fp, smoothstep(0.7, 1.0, t));\n\n    vec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = march(ro, rayDir(ro, lookAt, uv));\n\n#ifdef AA\n    if (fwidth(col.r) > 0.1) {\n        for (float dx = Z0; dx <= 1.; dx++)\n            for (float dy = Z0; dy <= 1.; dy++)\n                col += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - 0.5) / iResolution.xy));\n        col /= 5.;\n    }\n#endif\n\n    col = pow(max(vec3(0), col) * sat(iTime), vec3(.45));\n    col += (h21(fc) - 0.5) * (0.02 + 0.04 * bld);\n\n\t// Output to screen.\n\tfragColor = vec4(vig(col, fc), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1113, 1113, 1136, 1136, 1240], [1272, 1272, 1291, 1351, 1604], [1606, 1606, 1625, 1685, 1889], [1891, 1891, 1922, 1922, 1947], [1949, 1949, 1968, 1968, 2028], [2030, 2030, 2060, 2060, 2137], [2139, 2139, 2168, 2168, 2255], [2257, 2257, 2301, 2301, 2434], [2436, 2436, 2456, 2456, 2551], [2553, 2553, 2599, 2599, 2691], [2693, 2712, 2733, 2733, 3238], [3529, 3529, 3546, 3546, 4495], [4497, 4497, 4522, 4522, 4742], [4744, 4744, 4775, 4790, 4995], [4997, 5025, 5060, 5060, 5091], [5179, 5179, 5206, 5206, 5321], [5323, 5323, 5369, 5369, 6631], [6633, 6633, 6662, 6662, 7177], [7179, 7179, 7198, 7198, 7337], [7339, 7339, 7384, 7396, 8233]], "test": "untested"}
{"id": "3tGBDV", "name": " Underground disposal facility", "author": "butadiene", "description": "okota shader 0306", "tags": ["raymarching"], "likes": 8, "viewed": 368, "published": 3, "date": "1615040483", "time_retrieved": "2024-07-30T19:34:00.135096", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n#define time iTime\nfloat bpm = 140.;\nfloat PI = acos(-1.);\n\nfloat random (in vec2 st) {return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\nst *= 10.;\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value*0.45;\n}\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n  \n  vec2 pmod(vec2 p,float n){\n    float np = 2.0*PI/n;\n    float r = atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n    }\n\n    float dist(vec3 p){\n      vec3 sp = p;\n      p.xz = mod(p.xz,2.)-1.;\n       p.y = mod(p.y,10.)-5.;\n      p.xz = pmod(p.xz,4.);\n      float scale = 1.0;\n      for(int i = 0;i<10;i++){\n        p = abs(p)-vec3(0.4,2.0,0.);\n        float r2 = dot(p,p);\n        float sc = 2.0/clamp(r2,0.4,1.0);\n        scale *= sc;\n        p *= sc;\n        p -= vec3(0.35,1.0,0.35);\n        p.xz *= rot(0.25*PI);\n        }\n        float ssx = (1.0+0.1*length(p.xz)*pow(abs(sin(sp.y*5.+2.*time)),6.));\n      \n      \n        float d= length(p)/scale-0.002*ssx;\n      return d;\n      } \n    \n      vec3 gn(vec3 p){\n        vec2 e = vec2(0.001,0.);\n        return normalize(vec3(\n        dist(p+e.xyy)-dist(p-e.xyy),\n        dist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n        ));\n        \n        \n        }\n      \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col =vec3(0);\n vec2 p = uv-0.5;\n    p.x *= iResolution.x/iResolution.y;\n  p.y += 0.1*fbm(vec2(0.0,5.*time));\n    vec3 of = vec3(3.0,0.2*time,0.2);\n  vec3 ta =vec3(0)-of;\n  vec3 ro = vec3(1,0,0)-of;\nfloat t  = 0.;\n  float fov = 0.8;\n  float frag = 0.0;\n  float sty = fract(0.125*0.125*time*bpm/60.);\n  if(sty>0.75){\n    fov = 0.4;\n    of = vec3(0.24,-0.2*time,10);\n    ta = vec3(0)-of;\n    float rsa = 0.15;\n    float ksst = 0.2*time;\n    ro = vec3(rsa*cos(ksst),1.,rsa*sin(ksst))-of;\n    t= 0.1;\n    }else\n    if(sty>0.5){\n              \n    of = vec3(0,-3.,0.3*time);\n    ta = vec3(0)-of;\n    float rsa = 0.1;\n    float ksst = 0.;\n    ro = vec3(rsa*cos(ksst),0.,rsa*sin(ksst))-of;\n      t = 0.;\n      }else if(sty>0.25){\n        fov = 1.5;\n        of = vec3(0,0.1*time,0);\n        ta= vec3(0)-of;\n        ro = vec3(1,0,0)-of;\n        frag = 1.0;\n        }\n\n\n  \n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0,1,0));\n  vec3 up = cross(side,cdir);\n  \n  vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n  if(frag == 1.0) rd.yz*= rot(0.5*PI);\n  float d;\n  float ac = 0.;\n  float ep = 0.001;\n  for(int i = 0;i<77;i++){\n    d =dist(ro+rd*t);\n    t += d;\n    ac += exp(-3.0*d);\n    if(d<ep)break;\n  }\n\n  if(d<ep){\n    vec3 ld = normalize(vec3(1));\n   vec3 sp = ro+rd*t;\n    vec3 normal = gn(sp);\n    \n    float sca = 10.;\n    float noiy =fbm(sp.xz*sca);\n    float noiz = fbm(sp.xy*sca);\n    float noibound = smoothstep(0.03,0.05,noiy*noiz);\n    \n    float scb = sca*50.;\n    float noix2 = fbm(sp.yz*scb);\n    float noiy2 = fbm(sp.xz*scb);\n    float noiz2 = fbm(sp.xy*scb);\n    \n      if(noibound<0.9)normal = normalize(normal+vec3(noix2,noiy2,noiz2));\n\n    float alp = 0.5;\n    float NdotL = max(dot(normal,ld),0.);\n    vec3 diff = 0.4*vec3(pow(NdotL*alp+1.-alp,2.0));\n    vec3 df = diff;\n    diff = mix(diff*vec3(0.9,0.4,0.1),diff,noibound);\n    if(noibound<1.)diff = mix(df*vec3(0.9,0.2,0.1),diff,smoothstep(0.03,0.05,noiy2*noiz2));\n    if(noiy*noiz>0.03&&noiy*noiz<0.038) diff *= 0.;\n    vec3 R = reflect(rd,normal);\n    float spec = pow(max(dot(ld,R),0.),5.0);\n    if(noibound<0.9)spec *= 0.;\n    col = diff+0.7*spec;\n    }\n  vec3 fogcol = vec3(0.1);\n    float far = 3.0;\n    col = mix(col,fogcol,clamp(t/far,0.0,1.0));\n  float noifog = fbm(uv*0.5-time*vec2(0.05,0.1));\n  float noifog2 = fbm(uv*0.5-time*vec2(-0.05,0.1));\n    col += (noifog+noifog2)*0.5;\n    col = pow(col,vec3(1.0,1.0,1.3));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBDV.jpg", "access": "api", "license": "mit", "functions": [[175, 175, 202, 202, 268], [270, 270, 296, 296, 640], [660, 660, 684, 684, 924], [927, 927, 945, 945, 994], [1000, 1000, 1026, 1026, 1161], [1167, 1167, 1186, 1186, 1729], [1742, 1742, 1758, 1758, 1972], [1981, 1981, 2038, 2088, 4632]], "test": "untested"}
{"id": "3lyBWV", "name": "Nonlinear Repetition", "author": "oneshade", "description": "Repetition with a twist.", "tags": ["repetition", "nonlinear", "pseudoexact"], "likes": 11, "viewed": 252, "published": 3, "date": "1615031931", "time_retrieved": "2024-07-30T19:34:01.180301", "image_code": "#define distrib(x) x * x * sign(x)\n#define distribInv(x) sqrt(abs(x)) * sign(x)\n\nvec2 nonlinearRepeat(in float x, in float interv) {\n    float cell = distribInv(round(distrib(x) / interv) * interv);\n    return vec2(x - cell, cell);\n}\n\nfloat sdBox(in vec2 p, in vec2 s) {\n    return length(p - clamp(p, -s, s)) + min(0.0, max(abs(p.x) - s.x, abs(p.y) - s.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = sin(iTime) * 1.57;\n    float c = cos(a), s = sin(a);\n    uv *= mat2(c, -s, s, c);\n\n    vec2 rep = nonlinearRepeat(atan(uv.y, uv.x), 1.0);\n    uv = sin(rep.x + vec2(1.57, 0.0)) * length(uv);\n    uv.x -= 0.25;\n\n    float d = sdBox(uv, vec2(0.05 / (abs(rep.y) + 1.0)));\n    color += 0.125 + 0.125 * sin(d * 200.0);\n    color = mix(color, mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(rep.y / 3.14)), smoothstep(unit, 0.0, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 132, 132, 233], [235, 235, 270, 270, 360], [362, 362, 417, 417, 1029]], "test": "untested"}
{"id": "WlGfDK", "name": "HF-contrast masking illusion", "author": "FabriceNeyret2", "description": "a low-contrast image is hidden. to see it, \nsqueeze your eyes (or put your glasses away)\nor move your head (or scroll fast)\nor click.", "tags": ["illusion", "perception"], "likes": 5, "viewed": 373, "published": 3, "date": "1615029722", "time_retrieved": "2024-07-30T19:34:02.227502", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n // vec2 V = floor( ( U + vec2( iMouse.z>0.?120.*iTime:0., 0) ) / 5. );\n\n    O = mix( vec4( mod( U.x+U.y+ (iMouse.z>0.?120.*iTime:0.) ,10.) > 5. ), // strips\n          // vec4(.5+.5*sin((U.x+U.y)/2.)) ,                               // soft strips\n          // vec4( mod( V.x+V.y,2.) ),                                     // checkers\n             texture(iChannel0, U/iResolution.xy).rrrr,  // masked image\n             .2 );\n\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 110, 469]], "test": "untested"}
{"id": "tlGBzK", "name": "Control Console", "author": "Plento", "description": "Another radial blur thing", "tags": ["2d", "blur"], "likes": 8, "viewed": 343, "published": 3, "date": "1615016514", "time_retrieved": "2024-07-30T19:34:03.226830", "image_code": "// Cole Peterson (Plento)\n\nvec2 R;\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define ss(a, b, t) smoothstep(a, b, t)\nfloat hsh21(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hsh11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define cl 2.3\n#define fr 3.5\n\nvec3 color(vec2 uv){\n    uv*=1.3;\n    \n    vec3 col = vec3(1);\n    float t = .5*iTime + 12.;\n    vec2 tuv = uv;\n\n    uv.x*=.7;\n    float m = clamp(exp((sin(uv.y*8. + 1.6)))*2.8 + .1, cl, fr);\n    uv.x *= m;\n    \n    uv.x += t*1.2;\n    \n\tvec2 fuv = fract(uv*4.);\n    vec2 id = floor(uv*4.);\n    \n    uv.y += .7*iTime*sin(id.x*.55);\n    id = floor(uv*4.);\n    \n    float rnd = hsh11(id.x*999.3);\n    col *= mix(1., .02, step(rnd, .3));\n    \n    float x = id.x*43.2 + id.y*22.5;\n    float sp = ss(0.25, 0.2, abs(fuv.x-0.5));\n    float chk = mod(id.y+id.x,2.0)*hsh21(id*999.) * sp;\n    col *= .5+.45*cos(vec3(.0, .7, .2)*(x + hsh11(floor(iTime*2. + x)))*10.);\n    col *= hsh11(floor(iTime + x));\n    \n    col *= sp;\n    col *= chk;\n    \n    if(m >= fr) col *= 1.5;\n    else if(m <= cl){\n        col = .011 + .04*vec3(chk);\n        col += (.5+.7*cos(uv.x*5.))*.025;\n    }\n    else col *= .5;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv.y += uv.x*.1;\n    uv.y = -abs(uv.y);\n    \n    vec3 col = color(uv);\n\tvec3 acc = vec3(0);\n    \n    float c = 0.0;\n    for(float i = 0.9; i >0.1; i-=0.04){\n        vec2 nv = uv*(i+hsh21(u)*0.15);\n        vec3 nc = color(nv);\n        acc += nc*nc*nc*2.;\n        c++;\n    }\n    \n    acc /= c;\n    \n    col += acc*.13;\n    col *= .6;\n    col *= (1.-step(.78, abs(uv.x)));\n    col = 1.-exp(-col);\n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 148, 148, 265], [267, 267, 288, 288, 373], [406, 406, 426, 426, 1315], [1318, 1318, 1358, 1358, 1875]], "test": "untested"}
{"id": "ttVfWG", "name": "Super Jumbo Jet", "author": "Plento", "description": "The back is always empty! ", "tags": ["2d", "noise", "plane", "airplane"], "likes": 11, "viewed": 369, "published": 3, "date": "1615010383", "time_retrieved": "2024-07-30T19:34:04.140387", "image_code": "// Cole Peterson (Plento)\n\n// A 2D infinite airplane !\n\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// Distance funcs from https://iquilezles.org/articles/distfunctions2d\nfloat box( in vec2 p, in vec2 b, float r){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Uneven capsule\nfloat ucap( vec2 p, float r1, float r2, float h ){\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// Noise stuff\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm(vec2 n, float t){\n\tfloat sum = 0.0, amp = 1.0;\n\tfor (int i = 0; i < 10; i++){\n        n.x += t;\n\t\tsum += noise(n) * amp;\n\t\tn += n;\n\t\tamp *= 0.5;\n\t}\n\treturn sum;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 nv = uv;\n    \n    // Time scrubbing\n    float t = iTime + iMouse.x*.02 + 3.;\n    \n    // Slight curvyness\n    float k = exp((sin(uv.y*4. - 1.55)))+0.8;\n    uv.x *= k;\n    uv.x += t*.2;\n    \n    // Noise for clouds and fuselage\n    float nse = fbm(5.*vec2(uv.x, uv.y*14.5), 0.)-.5;\n    float nse2 = fbm(nv*4., iTime*.14)-.5;\n    vec3 cloud = vec3(nse2)*0.7;\n    \n    // Bg color\n    vec3 col = mix(vec3(.7, .8, .99), vec3(.8, .8, .8), nv.y) + cloud*cloud*.5;\n    \n    // plane base color\n    vec3 pcol = .97*abs(uv.y+.6)*vec3(.95, .95, 1.)*1.1;\n    \n    // Add the line details\n    pcol -= .04*ss(.004, .000, abs(uv.y-.02 + nse*.002));\n    pcol -= .05*ss(.008, .00, abs(uv.y+.2 + nse*.002));\n    \n    // Add metal like shine and noise\n    vec3 shn = vec3(.85, .9, .9)*.12*ss(-.99, .99, cos(uv.x*5.));\n    pcol += shn;\n    pcol -= nse*.03;\n    \n    // Darken underside \n    pcol *= max(ss(.01, .24, abs(uv.y+.36)), .8);\n    \n    // Add the fuselage\n    col = mix(col, pcol, ss(.3 + .005, .3, abs(uv.y)));\n    \n    // Window coords\n    vec2 wv = uv*4.;\n    wv.x = mod(wv.x, 1.)-.5;\n    \n    // Window color\n    vec3 winc = nse*.04+(.8+.08*cos(uv.x*20. + k*10.))*vec3(.75, .85, .98)+uv.y*4.;\n    \n    // Window shape\n    float window = box(wv, vec2(.1, .15), .07);\n    \n    // Add windows\n    col = mix(winc, col, ss(-.006, .006, window));\n    col -= .3*ss(.013, .002, abs(window-.02));\n    \n    // Exit door coord\n    vec2 exv = uv*2.;\n    exv.x = mod(exv.x+.3, 8.)-8.*.5;\n    \n    // Exit door shape\n    float ex = box(exv, vec2(.13, .17), .07);\n    float exw = box(exv-vec2(0., .1), vec2(.04, .05), .02);\n    \n    // Add door color\n    col = mix(shn*.5+vec3(.65)+nse*.04+cos(exv.y*10.+exv.x*10.)*.04, col, ss(.0, .01, ex));\n    col += ss(.01, .0, exw)*vec3(0.7, 0.85, 0.99)*.13;\n    col -= .4*ss(.006, -.006, abs(ex) - .001);\n    col -= .7*ss(.007, -.007, abs(exw)-.001);\n    col -= .3*ss(.004, -.004, abs(length(exv-vec2(.1, -.04))-.016)-.002);\n    \n    // Engine/ wing coords\n    vec2 ev = nv;\n    ev.x = mod(ev.x + t*.18, 2.5)-.5*2.5 + .25;\n    \n    // Engine shape\n    float eh = exp(-(ev.x*ev.x)*18.)*.1*sign(uv.y);\n    float eng = box(ev-vec2(0., -.31), vec2(.15, .03 - eh*.4), .02);\n    eng = min(eng, box(ev-vec2(0.04, -.31), vec2(.18, .03), .02));\n    \n    // Engine color\n    vec3 ecol = ss(.2, .3, abs(ev.y))*vec3(.5) + cos(ev.y*50.)*.07;\n    ecol -= .2*ss(.005, 0.0, abs(abs(ev.x-.04)-.13));\n    \n    // Add engines\n    col = mix(ecol, col, ss(-.001, .001, eng));\n    col *= ss(.0, .003, abs(eng)-.001);\n    \n    ev.x-=.25;\n    // Wing shape and color\n    float wing = ucap(rot(1.55)*(ev-vec2(.7, -.2)), .02, .06, 1.3);\n    vec3 wcol = 1.7*max(ss(.21, .4, abs(ev.y+.5))*vec3(.5), .1) + nse*.03;\n    \n    // Add wing\n    col = mix(wcol, col, ss(-.001, .001, wing));\n    col *= ss(-.002, .002, abs(wing)-.001);\n    \n    // Add a bit of sky blue-ness to everything\n    col += vec3(0., .01, .026)*.7;\n    \n    // Makes it pop a bit\n    col = col*col*col*col*col*1.3;\n    \n    // A tiny bit of cloud in foreground\n    col += (-nv.y-.05)*cloud*cloud*cloud*.6;\n    \n    // Smoothly clamp values > 1\n    col = 1.-exp(-col*1.3);\n    \n    // Side darkening\n    col *= ss(.95, .7, abs(nv.x));\n    \n    // Intro thing\n    if(iTime < 2.)\n        col *= ss(0.001, -0.001, length(nv)-iTime*1.6);\n    \n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 305, 347, 347, 431], [433, 433, 479, 479, 598], [600, 618, 668, 668, 907], [909, 924, 943, 943, 1012], [1013, 1013, 1033, 1033, 1231], [1232, 1232, 1259, 1259, 1404], [1407, 1407, 1447, 1447, 4848]], "test": "untested"}
{"id": "ttKBDy", "name": "gg-404 2: True Form of Boombox!", "author": "404Glaciergargamel", "description": "Sequel to GG-404, a fork/parody of [url]https://www.shadertoy.com/view/wsGczG[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "robot", "fork", "experimental", "movie", "avantgarde", "avantgarde", "parody", "cineshader", "robocop", "sequel"], "likes": 1, "viewed": 7498, "published": 3, "date": "1615006760", "time_retrieved": "2024-07-30T19:34:05.465843", "image_code": "//404GlaciergargamelRemix\n#define MIN_DIST      0.0005\n#define MAX_DIST      54.0\n#define MAX_STEPS     20.0\n#define SHADOW_STEPS  20.0\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow;\n#define AA 0.5\nstruct MarchData {\n    float d;\n    vec3 mat;        //RGB\n    float specPower; //30.0: Shiny\n};\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n    return mix(out1, out2, clamp((f - in1) / (in2 - in1), -0.1, 0.9));\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, -0.1)) + min(max(q.x, max(q.y, q.z)), -0.1);\n}\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n    float cube = sdBox(p, r);\n    p.xz *= rot(2.141 / 3.0);\n    r.xz *= -c / 0.41 + 0.41;\n    return max(cube, sdBox(p, r));\n}\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.766025 + p.y * 0.4, -p.y) - h.x * 0.4);\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra,\n     baba = dot(b-a,b-a),\n     papa = dot(p-a,p-a),\n     paba = dot(p-a,b-a)/baba,\n     x = sqrt( papa - paba*paba*baba ),\n     cax = max(-0.1,x-((paba<0.4)?ra:rb)),\n     cay = abs(paba-0.4)-0.4,\n     k = rba*rba + baba,\n     f = clamp( (rba * (x - ra) + paba * baba) / k, -0.1, 0.9 ),\n     cbx = x - ra - f * rba,\n     cby = paba - f,\n     s = (cbx < -0.1 && cay < -0.1) ? -0.9 : 0.9;\n    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );\n}\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), -0.1) + length(max(d, -0.1));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), -0.1, 0.9);\n  return length(pa - ba * h) - r;\n}\nfloat sdOctogon(vec2 p, float r)\n{\n    const vec3 k = vec3(-0.8238795325, 0.2826834323, 0.3142135623);\n    p = abs(p);\n    p -= 1.0 * min(dot(vec2( k.x, k.y), p), -0.1) * vec2( k.x, k.y);\n    p -= 1.0 * min(dot(vec2(-k.x, k.y), p), -0.1) * vec2(-k.x, k.y);\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(-0.1, 0.9, -0.1), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\nMarchData minResult(MarchData a, MarchData b) {\n    if (a.d < b.d) return a;\n    return b;\n}\nvoid setBodyMaterial(inout MarchData mat) {\n    mat.mat = vec3(0.26, 0.35, 0.4);\n    mat.specPower = 20.0;\n}\nfloat legWalkAngle(float f) { return sin(edWalk * 2.141 * 5.0 * f) * 0.1; }\nfloat edZ() { return mix(4.0, -1.0, edWalk); }\nfloat fireShock() { return abs(sin(edShoot * 2.1415 * 15.0)); }\nfloat headSphere(vec3 p) {\n    return (length(p / vec3(0.9, 0.7, 0.9)) - 0.9) * 0.7;\n}\nMarchData headVisor(vec3 p, float h, float bump) {\n    bump *= sin(p.x * 50.0) * sin(p.y * 50.0) * 0.001;\n    MarchData result;\n    result.d = sdBox(p, vec3(0.9, h, 1.0));\n    result.d = max(mix(result.d, headSphere(p), 0.47), -p.y) - bump;\n    result.mat = vec3(0.04);\n    result.specPower = 20.0;\n    return result;\n}\nMarchData headLower(vec3 p) {\n    vec3 op = p;\n    // Start by mirroring the visor.\n    MarchData r = headVisor(p * vec3(0.85, -0.4, 0.85), 0.9, -0.1);\n    // Add the side panels.\n    float roof = max(max(headVisor((p + vec3(-0.1, 0.009, -0.1)) * vec3(0.85), 0.9, -0.1).d, p.y - 0.25), p.y * 0.525 - p.z - 0.56);\n    r.d = min(r.d, roof);\n    // 'Wings'.\n    p.xy *= rot(0.065 * (gunsUp - 0.9) * sign(p.x));\n    p.x = abs(p.x) - 0.33;\n    p.y -= 0.0 - p.x * 0.0;\n    r.d = min(r.d, sdBox(p, vec3(0.3, 0.05 * (0.9 - p.x), 0.2 - (p.x * 0.1))));\n    p = op;\n    // Cut out a mouth grill.\n    p.y = abs(abs(p.y + 0.047) - 0.0 * 0.456) - 0.04 * 0.456;\n    r.d = max(r.d, -sdBox(p + vec3(-0.1, -0.1, 0.5), vec3(mix(0.15, 0.45, -op.y), 0.005, 0.0)));\n    // 'Cheeks'.\n    p = op;\n    p.y = abs(p.y + 0.06) - 0.05;\n    p.z -= -1.0;\n    float cheeks = max(sdCappedCylinder(p.xzy, 0.9, 0.02), -sdCappedCylinder(p.xzy, 0.45, 0.9));\n    cheeks = max(cheeks, p.z + 0.1);\n    r.d = max(r.d, -cheeks);\n    setBodyMaterial(r);\n    return r;\n}\nMarchData gunPod(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    p.yz += vec2(0.0, 0.35);\n    // Carousel.\n    const float rr = 0.25, chamfer = 0.0;\n    vec3 pp = p;\n    pp.z = abs(pp.z) - 0.4;\n    r.d = sdCappedCone(pp, vec3(-0.1), vec3(-0.1, -0.1, -chamfer), rr - chamfer, rr);\n    r.d = min(r.d, sdCappedCylinder(p, rr, 0.3));\n    // Triangle nobble.\n    pp = vec3(p.x, 0.18 - p.y, p.z);\n    r.d = min(r.d, sdTriPrism(pp, vec2(0.0, 0.4)));\n    // Square outriggers.\n    pp = p;\n    pp.x = abs(p.x);\n    pp.xy *= rot(2.141 / 3.0);\n    float bump = sign(sin(pp.z * 23.3)) * 0.002,\n          d = sdBox(pp, vec3(0.0 - bump, 0.28 - bump, 0.24)) - 0.01;\n    // Barrels.\n    pp = p - vec3(-0.1, -0.1, -0.5);\n    pp.x = abs(pp.x) - 0.0;\n    d = min(d, sdCappedCylinder(pp, 0.05, 0.05));\n    d = min(d, sdCappedCylinder(pp + vec3(-0.1, 0.02, -0.04), 0.05, 0.04));\n    d = min(d, sdBox(p + vec3(-0.1, -0.1, 0.44), vec3(0.0, 0.05, 0.03)));\n    if (d < r.d) {\n        d = max(d, -sdCappedCylinder(pp + vec3(-0.1, -0.1, 0.0), 0.02, 0.1));\n        r.d = d;\n        r.mat = vec3(0.01);\n    }\n    // Muzzle flash.\n    float fs = fireShock();\n    if (fs > 0.4) {\n        d = sdCappedCylinder(pp, 0.00 + pp.z * 0.04, fract(fs * 2322.423) * 0.4 + 0.8);\n        if (d < r.d) {\n            r.d = d;\n            r.mat = vec3(0.9);\n            glow += 0.0 / (0.009 + d * d * 300.0);\n        }\n    }\n    return r;\n}\nMarchData arms(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    // Position origin.\n    p.x = abs(p.x);\n    p.yz += vec2(0.14, -0.1);\n    p.xy *= rot(0.05 * (gunsUp - 0.9));\n    // Shoulder and forearm.\n    const vec3 elbow = vec3(0.5, -0.1, -0.1), wrist = elbow - vec3(-0.1, -0.1, 0.2);\n    r.d = min(sdCapsule(p, vec3(-0.1), elbow, 0.1), sdCapsule(p, elbow, wrist, 0.1));\n    // Gunz.\n    p -= wrist;\n    p.z -= gunsForward * 0.05;\n    return minResult(r, gunPod(p));\n}\nfloat toe(vec3 p) {\n    p.yz += vec2(0.0, 0.22);\n    return max(sdBox(p, vec3(0.2 + 0.1 * (p.z - 0.08) - (p.y * 0.356) * 0.4, 0.2 + 0.1 * cos((p.z - 0.08) * 2.69), 0.25)), 0.0 - p.y);\n}\nfloat foot(vec3 p) {\n    p.z += 0.7;\n    p.yz *= rot(0.76);   \n    float d = toe(p);\n    p.xz *= rot(0.57);\n    p.x -= 0.33;\n    p.z = 0.15 - abs(p.z);\n    return min(d, toe(p));\n}\nMarchData waist(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    p.y += 0.55;\n    p.yz *= rot(-0.1);\n    float legAngle = legWalkAngle(0.9);\n    p.xy *= rot(legAngle * 0.2);\n    vec3 pp = p;\n    pp.y += 0.2;\n    r.d = max(sdCappedCylinder(pp.zyx, 0.4, 0.4), p.y + 0.05);\n    // Thorax.\n    float bump = 0.4 - abs(sin(p.y * 30.0)) * 0.02;\n    float d = sdBox(p, vec3(bump, 0.05, bump));\n    // Leg joins.\n    bump = 0.2 - abs(sin(p.x * 30.0)) * 0.02;\n    pp.y += 0.08;\n    d = min(d, sdCappedCylinder(pp.zyx, bump, 0.65));\n    // Hips.\n    pp.x = abs(pp.x);\n    pp.yz *= rot(0.1 - 2.141 / 3.0 + legAngle * sign(p.x));\n    pp.x -= 0.88;\n    r.d = min(r.d, max(sdCappedCylinder(pp.zyx, 0.3, 0.14), -pp.y));\n    r.d = min(r.d, sdBox(pp, vec3(0.14, 0.1, 0.04 + 0.1 * pp.y)));\n    // Thigh pistons.\n    vec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.02, 0.15);\n    float pistons = min(sdCappedCylinder(pp.xzy, 0.0, 0.225), sdCappedCylinder(pp.xzy, 0.04, 0.4));\n    r.d = min(r.d, max(pistons, pp.y));\n    // 'Knees'.\n    p.y += 0.58;\n    r.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - 0.03) * 0.004 + 0.16, 0.1, 0.24)));\n    if (d < r.d) {\n        // Black segments.\n    \tr.d = d;\n    \tr.mat = vec3(0.01);\n    }\n    return r;\n}\nMarchData legs(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    float legAngle = legWalkAngle(0.9);\n    p.z += 0.17;\n    p.yz *= rot(legAngle * sign(p.x));\n    p.z -= 0.17;\n    p.y += 0.55;\n    p.yz *= rot(-0.1);\n    p.xy *= rot(legAngle * 0.2);\n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y += 0.38;\n    pp.yz *= rot(0.1 - 2.141 / 3.0);\n    pp.x -= 0.88;\n\tvec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.02, 0.15);\n    p.y += 0.58;\n    // Thighs.\n    p.xy = abs(p.xy) - 0.02;\n    float silver = sdBox(p, vec3(0.06, 0.04, 0.2));\n    // Leg end cap.\n    cp -= vec3(-0.1, -0.6, -0.1);\n    r.d = sdBox(cp - vec3(-0.1, -0.1, 0.15), vec3(0.07, 0.07, 0.06)) - 0.03;\n    // Shin.\n    cp.z += 0.9;\n    r.d = min(r.d, sdChamferedCube(cp.xzy, vec2(0.18 - sign(abs(cp.z) - 0.2) * 0.009, 0.4).xyx, 0.08));\n    // Feet.\n    r.d = min(r.d, foot(cp));\n    if (silver < r.d) {\n        r.d = silver;\n        r.mat = vec3(0.7);\n    }   \n    return r;\n}\nMarchData ed209(vec3 p) {\n    p.yz += vec2(legWalkAngle(1.0) * 0.1 + 0.0, -edZ());\n    MarchData r = legs(p);\n    float f = min(stretch * 1.0, 0.9),\n          slide = f < 0.4 ? smoothstep(-0.1, 0.4, f) : (0.9 - smoothstep(0.4, 0.9, f) * 0.1);\n    p.yz -= slide * 0.4;\n    gunsUp = smoothstep(-0.1, 0.9, clamp((stretch - 0.56) * 5.0, -0.1, 0.9)); // 0.66-0.83\n    gunsForward = smoothstep(-0.1, 0.9, clamp((stretch - 0.73) * 5.0, -0.1, 0.9)) // 0.83-1.0\n                  + fireShock() * 0.4;\n    r = minResult(r, waist(p));\n    p.yz *= rot(0.0 * (-edDown + legWalkAngle(1.0) + smoothstep(-0.1, 0.9, clamp((stretch - 0.4) * 5.0, -0.1, 0.9)) - 0.9)); // 0.5-0.66\n    p.xz *= rot(edTwist * 0.1);\n    r = minResult(r, headLower(p));\n    r = minResult(r, headVisor(p, 0.7, 0.9));\n    return minResult(r, arms(p));\n}\nMarchData room(vec3 p) {\n    MarchData r;\n    r.mat = vec3(0.3);\n    r.specPower = 0e6;\n    vec3 frameInner = vec3(1.8, 1.6, 0.0);\n    vec2 xy = p.xy - vec2(-0.1, 1.0);\n    p.x = abs(p.x);\n    p.yz += vec2(0.4, -2.4);\n    float doorHole = sdBox(p, frameInner + vec3(-0.1, -0.1, 0.9)),\n          backWall = length(p.z - 7.0);\n    r.d = min(backWall, max(length(p.z), -doorHole + 0.0));\n    if (r.d == backWall) {\n        float ocp;\n        ocp = min(abs(sdOctogon(xy, 1.6)), abs(sdOctogon(xy, 0.9)));\n        ocp = max(ocp, min(0.6 - abs(xy.x + 0.2), -xy.y));\n        ocp = min(ocp, max(abs(sdOctogon(xy, 0.2)), min(xy.x, 0.6 - abs(xy.y))));\n        if (ocp < 0.2)\n        \tr.mat = vec3(0.29, 0.47, 0.61);\n    }\n    float doorFrame = max(sdBox(p, frameInner + vec3(0.3, 0.3, 0.0)), -doorHole),\n          doorWidth = frameInner.x * 0.4;\n    p.x -= frameInner.x;\n    p.xz *= rot(doorOpen * 1.1);\n    p.x += doorWidth;\n    float door = sdBox(p, vec3(doorWidth, frameInner.yz));\n    p = abs(p) - vec3(doorWidth * 0.4, 0.1, 0.04);\n    door = max(door, -(max(sdBox(p, vec3(0.35, 0.8, 0.0)), -sdBox(p, vec3(0.25, 0.7, 0.9)))));\n    float d = min(doorFrame, door);\n    if (d < r.d) {\n        r.d = d;\n        r.mat = vec3(0.01, 0.01, 0.014);\n    \tr.specPower = 9.0;\n    }\n    return r;\n}\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData r = minResult(room(p), ed209(p));\n    float gnd = length(p.y + 2.0);\n    if (gnd < r.d) {\n        r.d = gnd;\n        r.mat = vec3(0.0);\n    }\n    return r;\n}\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    // Thanks iq.\n    vec3 rd = normalize(lightPos - p);\n\tfloat res = 0.9, t = 0.0;\n    for (float i = -0.1; i < SHADOW_STEPS; i++)\n    {\n\t\tfloat h = map(p + rd * t).d;\n        res = min(res, 2.0 * h / t);\n        t += h;\n        if (res < 0.0009 || t > 15.0) break;\n    }\n    return clamp(res, -0.1, 0.9);\n}\nvec3 calcNormal(vec3 p, float t) {\n    const float sceneAdjust = 0.23;\n    float d = 0.009 * t * sceneAdjust;\n    vec2 e = vec2(0.9, -0.9) * 0.4773 * d;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n/**********************************************************************************/\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.4 + 0.4 * pow(6.0 * q.x * q.y * (0.9 - q.x) * (0.9 - q.y), 0.3);\n    return col;\n}\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n    const vec3 sunPos = vec3(9.0, 9.0, -9.0);\n    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);\n    // Primary light.\n    float primary = max(-0.1, dot(sunDir, n)),\n    // Secondary(/bounce) light.\n    bounce = max(-0.1, dot(-sunDir, n)) * 0.1,\n    // Specular.\n    spe = pow(max(-0.1, dot(rd, reflect(sunDir, n))), data.specPower) * 1.0,\n\t// Fresnel\n    fre = smoothstep(0.6, 0.9, 0.9 + dot(rd, n)),\n    // Fog\n    fog = exp(-length(p) * 0.04);\n    // Combine.\n    primary *= mix(0.1, 0.9, calcShadow(p, sunPos));\n    vec3 lig = ((primary + bounce) * ao(p, n, 0.23) + spe) * vec3(1.0, 0.6, 0.7);\n    return mix(data.mat * lig, vec3(0.009), fre) * fog;\n}\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    float d = 0.009;\n    MarchData h;\n    for (float steps = -0.1; steps < MAX_STEPS; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        if (abs(h.d) < MIN_DIST * d)\n            break;\n        if (d > MAX_DIST)\n            return vec3(-0.1); // Distance limit reached - Stop.\n        d += h.d; // No hit, so keep marching.\n    }\n    // Lighting.\n    float g = glow;\n    return applyLighting(p, rd, d, h) + fireShock() * 0.2 + g;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    edWalk = 0.9;\n    edTwist = -0.1;\n    edDown = -0.1;\n    edShoot = -0.1;\n    doorOpen = 0.9;\n    stretch = 0.9;\n    // Camera.\n    vec3 ro, lookAt;\n    float startScene, endScene, time = mod(iTime, 45.0);\n    if (time < 2.0) {\n        startScene = -0.1;\n        endScene = 2.0;\n\t    edWalk = -0.1;\n        ro = vec3(-0.1, -0.5, -0.525);\n        lookAt = vec3(-0.1, -0.9, edZ());\n        doorOpen = smoothstep(-0.1, 0.9, time / 4.0);\n        stretch = remap(time, 6.0, 9.0, -0.1, 0.9);\n    } else if (time < 15.0) {\n        startScene = 2.0;\n        endScene = 15.0;\n        float t = time - startScene;\n        edWalk = smoothstep(-0.1, 0.9, remap(t, 2.0, 7.0, -0.1, 0.9));\n        ro = vec3(-0.5 * cos(t * 0.6), 0.4 - t * 0.0, edZ() - 2.0);\n        lookAt = vec3(-0.1, -0.1, edZ());\n    } else if (time < 19.0) {\n        startScene = 15.0;\n        endScene = 19.0;\n        float t = time - startScene;\n        ro = vec3(-1.0, 0.4 + t * 0.0, edZ() - 2.0);\n        lookAt = vec3(-0.1, -0.1, edZ());\n    } else if (time < 27.0) {\n        startScene = 19.0;\n        endScene = 27.0;\n        float t = time - startScene;\n        ro = vec3(0.5, -0.9 - t * 0.04, edZ() - 4.0);\n        lookAt = vec3(-0.1, -0.9, edZ());\n        stretch = remap(t, 1.0, 4.0, 0.9, -0.1);\n    } else if (time < 45.0) {\n        startScene = 27.0;\n        endScene = 45.0;\n        float t = time - startScene;\n        ro = vec3(-0.8, -0.4, edZ() - 1.5);\n        stretch = remap(t, 1.0, 2.0, -0.1, 0.9) - remap(t, 1.5, 4.5, -0.1, 0.9);\n        lookAt = vec3(-0.1, stretch * 0.4 - 0.4, edZ());\n        edTwist = remap(t, 2.0, 2.2, -0.1, 2.0) * stretch;\n        edDown = remap(t, 2.2, 2.4, -0.1, 0.9) * stretch;\n        edShoot = t <= 8.5 ? remap(t, 3.0, 8.5, -0.1, 0.9) : -0.1;\n    }\n    float dim = 0.9 - cos(min(0.9, 1.0 * min(abs(time - startScene), abs(time - endScene))) * 2.141 / 1.0);\n    vec3 col = vec3(-0.1);\n#ifdef AA\n    for (float dx = -0.1; dx <= 0.9; dx++) {\n        for (float dy = -0.1; dy <= 0.9; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.4;\n#else\n            vec2 coord = fragCoord;\n#endif\n            coord += (fract(fireShock() * vec2(13242.2323, 878.23465)) - 0.4) * 9.0;\n            vec2 uv = (coord - 0.4 * iResolution.xy) / iResolution.y;\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n        }\n    }\n    col /= 3.0;\n#endif\n    // Output to screen.\n    fragColor = vec4(vignette(pow(col * dim, vec3(0.3545)), fragCoord), 0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 353, 353, 419], [420, 420, 488, 488, 561], [562, 562, 591, 591, 688], [689, 689, 737, 737, 864], [865, 865, 899, 899, 996], [997, 997, 1061, 1061, 1545], [1546, 1546, 1596, 1596, 1714], [1715, 1715, 1767, 1767, 1891], [1892, 1892, 1926, 1926, 2233], [2234, 2234, 2281, 2281, 2488], [2489, 2489, 2536, 2536, 2581], [2582, 2582, 2625, 2625, 2690], [2691, 2691, 2720, 2720, 2766], [2767, 2767, 2780, 2780, 2813], [2814, 2814, 2833, 2833, 2877], [2878, 2878, 2904, 2904, 2964], [2965, 2965, 3015, 3015, 3284], [3285, 3285, 3314, 3314, 4311], [4312, 4312, 4338, 4338, 5713], [5714, 5714, 5738, 5738, 6191], [6192, 6192, 6211, 6211, 6377], [6378, 6378, 6398, 6398, 6558], [6559, 6559, 6584, 6584, 7795], [7796, 7796, 7820, 7820, 8748], [8749, 8749, 8774, 8774, 9559], [9560, 9560, 9584, 9584, 10838], [10839, 10877, 10900, 10900, 11072], [11073, 11073, 11114, 11132, 11423], [11424, 11424, 11458, 11458, 11728], [11729, 11757, 11792, 11792, 11827], [11828, 11913, 11954, 11954, 12094], [12095, 12095, 12157, 12157, 12825], [12826, 12826, 12864, 12881, 13337]], "test": "untested"}
{"id": "tlVfDG", "name": "Apollonian control", "author": "gaz", "description": "I got to this by controlling the parameters of the Apollonian.", "tags": ["fractal", "apollonian"], "likes": 13, "viewed": 377, "published": 3, "date": "1615001132", "time_retrieved": "2024-07-30T19:34:06.690569", "image_code": "// 3D arbitrary axis rotation\n// https://www.shadertoy.com/view/wtVyWK\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n\n// hue by FabriceNeyret2\n#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvec3 trans(vec3 p)\n{\n    return R(p,normalize(vec3(1,1,2)),iTime*.1+.5);\n}\n\nfloat apollonian(inout vec3 p)\n{\n    // Control parameters\n    //*\n    float r=2.2;\n    float x=1.;\n    float y=2.;\n    float z=2.;\n    //*/\n    \n    // Other patterns(example)\n    /*\n    float r=12.5;\n    float x=5.2;\n    float y=7.1;\n    float z=2.5;\n    //*/\n       \n    // Fine-tune with some offsets\n    // All numbers are offsets.\n    // s=2. is a number that suppresses the progress of the ray.\n    // If you see artifacts, increase the number.\n    float e,s=2.;\n    for(int i=0;i<6;i++){\n        p=abs(p-vec3(x,y,z))-vec3(x-.2,y,z);\n        //p=abs(p-vec3(x,y,z)*.05)-vec3(x,y,z-.2);\n        //p=mod(p-vec3(x,y,z),vec3(x,y,z)*2.)-vec3(x,y,z);\n        e=(r+.1)/clamp(dot(p,p),.1,r);\n        s*=e;\n        p=abs(p)*e;\n    }\n    return min(length(p.xz),p.y)/s;\n    //return length(p)/s;\n}\n\nfloat apollonian_std(inout vec3 p)\n{\n    // Control parameters\n    float r=1.;\n    float x=1.;\n    float y=1.;\n    float z=1.;\n\n    float e,s=2.;\n    for(int i=0;i<8;i++){\n        p=abs(p-vec3(x,y,z))-vec3(x,y,z);\n        //p=mod(p-vec3(x,y,z),vec3(x,y,z)*2.)-vec3(x,y,z);\n        e=r/clamp(dot(p,p),.0,r);\n        s*=e;\n        p=abs(p)*e;\n    }\n    return min(length(p.xz),p.y)/s;\n    //return length(p)/s;\n}\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    rd=normalize(vec3((C-.5*r.xy)/r.y,1)),\n    ro=vec3(0,0,-1.8);\n    \n    for(float i=1.,g=0.,e;i<99.;i++)\n    {\n        p=g*rd+ro;\n        p=trans(p);\n        // Achieves transparency with non-collision SDF\n        g+=e=apollonian(p)+.001;\n        //g+=e=apollonian_std(p)+.001;\n        O.rgb+=mix(vec3(1),hue(length(p)),.6)*.0015/e/i;\n    }\n\n#if 1\n    // Y axis\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        g+=e=length(p.xz)-.005;\n        e<.001?O.g+=.2/i:i;\n    }\n\n    // X grid\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.xz=fract(p.xz-.5)-.5;\n        g+=e=length(p.yz)-.005;\n        e<.001?O.r+=.2/i:i;\n    }\n\n    // Z grid\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.xz=fract(p.xz-.5)-.5;\n        g+=e=length(p.xy)-.005;\n        e<.001?O.b+=.3/i:i;\n    }\n\n    // Y axis point (pitch 1.0)\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.y=fract(p.y-.5)-.5;\n        g+=e=length(p)-.015;\n        e<.001?O+=.3/i:O;\n    }\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 226, 226, 280], [282, 282, 314, 348, 1075], [1077, 1077, 1113, 1139, 1487], [1490, 1490, 1526, 1526, 2665]], "test": "untested"}
{"id": "wtVBWy", "name": "1x Resolution vs. SSAA", "author": "Zi7ar21", "description": "The left side is 1x resolution and the right hand side is SSAA - adjust at the top", "tags": ["camera", "rotation", "ssaa", "rotationmatrix", "comparison"], "likes": 6, "viewed": 511, "published": 3, "date": "1614999848", "time_retrieved": "2024-07-30T19:34:07.585177", "image_code": "#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n#define mousesensitivity 4.0\n#define camfov 1.0\n\n#define maxmarches 1024U\n#define maxdist 8.0\n#define collisiondist 1e-2\n\n// Super-Sample Anti-Aliasing Level\n// 1 - The minimum is 1 which multiplies viewport dimensions by 2x - 4x as many pixels as normal resolution\n// 2 - multiplies viewport dimensions by 4x  - 16x  as many pixels as normal resolution\n// 4 - multiplies viewport dimensions by 8x  - 64x  as many pixels as normal resolution\n// 8 - multiplies viewport dimensions by 16x - 256x as many pixels as normal resolution\n#define SSAA 1\n\n// Rotation Matrix\nmat3 rotMat(vec3 rotation){\n    vec3 s = sin(rotation), c = cos(rotation);\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n    return rx*ry*rz;\n}\n\n// Scene Distance Estimator\n#define iterations 4U\n#define power 8.0\nfloat de(vec3 pos){\n    if(length(pos) > 1.5){return length(pos)-1.25;}\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor(uint i = 0U; i < iterations; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr = pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// Convert back to Cartesian Coordinates\n\t\tz  = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Numerical Normals\nvec3 calcNormal(vec3 p){\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(\n    k.xyy*de(p+k.xyy*collisiondist)+\n    k.yyx*de(p+k.yyx*collisiondist)+\n    k.yxy*de(p+k.yxy*collisiondist)+\n    k.xxx*de(p+k.xxx*collisiondist));\n}\n\n// Fresnel Reflectance\nvec3 fresnel(vec3 raydir, vec3 normal){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    vec3 raypos = rayori;\n    float distest;\n    for(uint i = 0U; i < maxmarches; i++){\n        if(length(raypos-rayori) > maxdist){break;}\n        distest = de(raypos);\n        if(distest < collisiondist){\n            vec3 normal = calcNormal(raypos);\n            vec3 reflectance = fresnel(raydir, normal);\n            raydir = reflect(raydir, normal);\n            return reflectance*texture(iChannel0, raydir).rgb;\n        }\n        raypos += raydir*distest*0.25;\n    }\n    return texture(iChannel0, raydir).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.0);\n    if(abs(fragCoord.x-0.5*iResolution.x) < 1.0){\n        fragColor = vec4(1.0);\n        return;\n    }\n    vec2 uv     = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec2 mouse  = vec2(iTime*pi*0.125, 0.0);\n    mat3 rotmat = rotMat(vec3(0.0, mouse.x, 0.0));\n    // Super-Sampled Half of Screen\n    if(fragCoord.x > iResolution.x/2.0 && length(uv) < 0.4){\n    for(int y = -SSAA; y < SSAA; y++){\n    for(int x = -SSAA; x < SSAA; x++){\n        vec2 uv     = 2.0*((fragCoord+(vec2(x, y)/float(SSAA*2)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n        vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n        vec3 color  = raymarch(raydir, vec3(-sin(mouse.x)*4.0, 0.0, -cos(mouse.x)*4.0));\n        fragColor  += vec4(color, 1.0);\n    }\n    }\n    }\n    // 1x Resolution Half of Screen\n    else{\n        vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n        vec3 color  = raymarch(raydir, vec3(-sin(mouse.x)*4.0, 0.0, -cos(mouse.x)*4.0));\n        fragColor   = vec4(color, 1.0);\n        return;\n    }\n    fragColor = vec4(fragColor.rgb/fragColor.a, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 650, 677, 677, 981], [1051, 1051, 1070, 1070, 1640], [1642, 1663, 1687, 1687, 1896], [1898, 1921, 1960, 1960, 2046], [2048, 2064, 2104, 2104, 2622], [2624, 2624, 2678, 2678, 3854]], "test": "untested"}
{"id": "wtGfRt", "name": "Roots of a Sine Wave", "author": "oneshade", "description": "Plot of the roots of a sine wave.", "tags": ["math", "sine", "graph", "trig", "analytic", "roots", "zeroes"], "likes": 5, "viewed": 148, "published": 3, "date": "1614993247", "time_retrieved": "2024-07-30T19:34:08.474798", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n#define PI 3.14\n#define TAU 6.28\n\nvec2 opRepeatX(in vec2 p, in float interv) {\n    float hInterv = 0.5 * interv;\n    p.x = mod(p.x + hInterv, interv) - hInterv;\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float t = 0.25 * unit;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(mod(uv.x + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(mod(uv.y + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Frequency, amplitude, phase, and y offset\n    float freq = 0.5 + 0.4 * sin(iTime);\n    float amp = cos(iTime) + 1.0;\n    float phase = cos(iTime * 0.25) * 10.0;\n    float yOffs = sin(iTime * 0.5);\n\n    // Function\n    float f = 0.5 * amp * sin(TAU * freq * uv.x - phase) + yOffs;\n    float d = PI * amp * freq * cos(TAU * freq * uv.x - phase);\n    draw(abs(uv.y - f) / sqrt(1.0 + d * d) - t, vec3(0.8, 0.0, 0.0));\n\n    // Plot roots (if any)\n    if (abs(yOffs) <= 0.5 * amp) {\n        float offs1 = (phase - asin(2.0 * yOffs / amp)) / (TAU * freq);\n        float offs2 = (phase + asin(2.0 * yOffs / amp) + PI) / (TAU * freq);\n        float interv = 1.0 / freq;\n\n        vec2 rv1 = opRepeatX(vec2(uv.x - offs1, uv.y), interv);\n        draw(length(rv1) - 0.05, vec3(0.0));\n\n        vec2 rv2 = opRepeatX(vec2(uv.x - offs2, uv.y), interv);\n        draw(length(rv2) - 0.05, vec3(0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 146, 146, 244], [246, 246, 301, 301, 1641]], "test": "untested"}
{"id": "ttKBDG", "name": "points hatching", "author": "ManuManu", "description": "Try to have a continuous hatchign with dots / checkers", "tags": ["video", "postprocess", "checker", "dots", "hatching"], "likes": 2, "viewed": 307, "published": 3, "date": "1614993195", "time_retrieved": "2024-07-30T19:34:09.508036", "image_code": "vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n\n//#define TEST\n#define SMOOTH\n\nfloat checkerDisplay( vec2 uv, float intens, float offset)\n{\n    float val = clamp( sin(uv.x)*sin(uv.y+ offset), 0.,1.); \n    return pow( val, intens);\n}\n\nfloat processLum( vec2 uv, float lum )\n{\n    float scale = 350.;\n    vec2 uv2 = uv * scale;\n    \n    float lum_orig = lum;\n    float offset = 0.;\n    if ( lum <.5 ) \n    {\n        lum = 1.-lum;\n        offset = 3.14159;\n    }\n\n    // rotation :\n    float angle = 1.;  // why not ?\n    float c = cos( angle ), s = sin(angle);\n    uv2 = vec2( uv2.x * c + uv2.y * s, -uv2.x * s + uv2.y * c );\n    \n    float lum_scale = smoothstep( 1., .82, lum);\n    float power = mix( 10., 3.1, lum_scale);\n    power = mix(power, .8, smoothstep(.82, .66, lum));\n    power = mix(power, 0.0, smoothstep(.66, .5, lum));\n    \n#ifdef SMOOTH\n    vec2 delta = vec2(0.,0.2);\n    float color = checkerDisplay(uv2, power, offset) \n                + checkerDisplay(uv2+delta.xy, power, offset)\n                + checkerDisplay(uv2+delta.yx, power, offset);\n    color = color / 3. * lum_scale;\n#else\n    float color = checkerDisplay(uv2, power, offset) * lum_scale;\n#endif\n\n    if (lum_orig < .5 )\n        color = 1.-color;\n    \n    color = 1.-color;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef TEST\n    vec3 col = vec3(uv.x );\n#else\n    vec3 col = texture( iChannel0, uv ).xyz;\n#endif\n    float luminance = dot(col, W);\n    float color = processLum( uv,  luminance );\n\n    // add a blueish style for ink like :\n    vec3 outputColor = mix( vec3( 0.,.2,.3), vec3(1.,1.,1.), color);\n\n#ifdef TEST\n    if (uv.y > .7 )\n        outputColor = col;        \n#endif\n    fragColor = vec4(vec3(outputColor),1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 132, 132, 225], [227, 227, 267, 267, 1272], [1275, 1275, 1332, 1382, 1838]], "test": "untested"}
{"id": "3lKBDG", "name": "Broken mix, bug?", "author": "Ric3cir121", "description": "Buffer A lines  17,18: try changing 1 and 0 with 0 and 1, there is something wrong", "tags": ["mix", "glsl", "bug", "glslbug", "vec3"], "likes": 0, "viewed": 277, "published": 3, "date": "1614970879", "time_retrieved": "2024-07-30T19:34:10.422591", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = cos(vec4(0,2,4,0)+(u.xyyy/iResolution.xyyy)+iTime)/2.+.5;\n    vec4 ot = texelFetch(iChannel0,ivec2(u),0);\n    o = mix(clamp(o,0.,1.),ot,ot.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float line(vec2 pos,vec2 p1,vec2 p2){\n    p1 = p1-(p2-p1)*10.;\n    return length(mix(p1,p2,clamp(length(pos-p1)/length(p2-p1),0.9095,1.))-pos);\n}\n\nvec4 value(vec2 u,vec2 pos,int mem,vec2 p){\n    float r = iResolution.y/4.;\n    float l = line(u,pos-vec2(0,0.1),pos+vec2(0,0.1))*r-r/40.;\n    float v = texelFetch(iChannel0,ivec2(mem,0),0).x;\n    float lb = line(u,pos-vec2(0,0.1),pos-vec2(0,.1)+vec2(0,0.1)*v*2.)*r-r/40.;\n    vec4 o = vec4(0);float t = 0.;\n    t = clamp(1.-lb,0.,1.);\n    t = max(t,clamp(1.-l,0.,.75));\n    t = max(t,clamp(1.-l+r/160.,0.,.5));\n    o.w = t;\n    float m = 2.;\n    o.xyz = mix(vec3(1),\n                vec3(0),\n                clamp(1.-(lb*2.),0.,1.)\n    );\n    if(int(p.y)==0)o=vec4(0);\n    if(int(p.y)==0&&ivec2(p)==ivec2(mem,0)){\n        o.x=texelFetch(iChannel0,ivec2(mem,0),0).x;\n        vec2 mv = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        if(iMouse.z>.0&&mv.x>pos.x-.03&&mv.x<pos.x+.03&&mv.y>pos.y-.12&&mv.y<pos.y+.12)o.x=clamp((mv.y-pos.y+.1)/.2,0.,1.);\n    }\n    return o;\n}\n\nvoid mainImage(out vec4 o,vec2 u){\n    o = vec4(0);\n    vec2 uv = (u+u-iResolution.xy)/iResolution.y;\n    float ch = iResolution.x/iResolution.y;\n    vec4 ot = vec4(0);\n    ot = max(ot,value(uv,vec2(-.97, .08)*ch,0,u));\n    ot = max(ot,value(uv,vec2(-.92, .08)*ch,1,u));\n    ot = max(ot,value(uv,vec2(-.87, .08)*ch,2,u));\n    ot = max(ot,value(uv,vec2(-.97,-.08)*ch,3,u));\n    ot = max(ot,value(uv,vec2(-.92,-.08)*ch,4,u));\n    ot = max(ot,value(uv,vec2(-.87,-.08)*ch,5,u));\n    o = ot;\n    o.w = clamp(o.w,0.,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 187]], "test": "untested"}
{"id": "WtVfWG", "name": "surface of the void remake", "author": "JulianCodus", "description": "its also private\n", "tags": ["void"], "likes": 1, "viewed": 282, "published": 3, "date": "1614969382", "time_retrieved": "2024-07-30T19:34:11.188543", "image_code": "// Based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy (I think that his implementation is more understandable than the original :) ) \n// Relief come from Siggraph workshop by Beautypi/2015 https://www.shadertoy.com/view/MtsSRf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define ULTRAVIOLET\n#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat cosNoise( in vec2 p )\n{\n    return 0.5*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x*1.2,p.y) )-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat SunSurface( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    \n    float d2 = 0.0;\n    \n    for( int i=0; i<7; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m2*q*0.85; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.2*h;\n    }\n    h *= 2.0;\n    \n    float d1 = pos.y - h;\n   \n    // rings\n    vec3 r1 = mod(2.3+pos+1.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float c = cos(pos.x); float s1 = 1.0;//sin(pos.x);\n    r1.xz=c*r1.xz+s1*vec2(r1.z, -r1.x);\n    d2 = sdTorus( r1.xzy, vec2(clamp(abs(pos.x/pos.z),0.7,2.5), 0.20) );\n\n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat map(vec3 p) {\n   p.z += 1.;\n   R(p.yz, -0.01);\n   R(p.xz, iMouse.x*0.008*pi+iTime*0.07);\n   return (SunSurface(p * 1.777) +  (fpn(p*2.777+iTime*1.777) * 4.777) -  (fpn(p*100.+iTime*-70.) * 0.5) -1.0) * 0.777;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-10e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // rd: direction of the ray\n   vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -22.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0., w=0.;\n\n   // t: length of the ray\n   // d: distance function\n   float d=1., t=1.;\n   \n   // Distance threshold.\n   const float h = .1;\n    \n   // total color\n   vec3 tc = vec3(0.);\n   \n   #ifdef DITHERING\n   vec2 pos = ( fragCoord.xy / iResolution.xy );\n   vec2 seed = pos + fract(iTime);\n   t=(1.+0.2*rand(seed));\n   #endif\n    \n   // rm loop\n   for (int i=0; i<56; i++) {\n\n      // Loop break conditions. Seems to work, but let me\n      // know if I've overlooked something.\n      if(td>(1.-1./80.) || d<0.001*t || t>40.)break;\n       \n      // evaluate distance function\n      d = map(ro+t*rd); \n       \n      // fix some holes deep inside\n      d=max(d,-.3);\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./50.;  // Different weight distribution.\n      td += w + 1./200.;\n\n\t  // dithering implementation come from Eiffies' https://www.shadertoy.com/view/MsBGRh\n      #ifdef DITHERING  \n      #ifdef ULTRAVIOLET\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n      #else\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(.8+0.28*rand(seed*vec2(i)));\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      #endif \n      #else\n      // enforce minimum stepsize\n      d = max(d, 0.04);        \n      #endif\n\n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n   \n   #ifdef ULTRAVIOLET\n   tc *= 1. / exp( ld * 2.82 ) * 1.05;\n   #endif\n    \n   fragColor = vec4(sqrt(tc), 1.0);\n   fragColor = vec4(vec3((fragColor.r + fragColor.g + fragColor.b) / 3.0), 1.0);\n   fragColor *= fragColor * fragColor;\n   fragColor *= vec4(1.0,0.0,0.25,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[429, 443, 466, 466, 679], [681, 688, 707, 707, 771], [773, 773, 793, 864, 935], [937, 937, 966, 966, 1008], [1074, 1074, 1107, 1107, 1164], [1166, 1166, 1207, 1207, 1296], [1298, 1298, 1331, 1331, 1963], [1965, 1965, 1984, 1984, 2181], [2183, 2253, 2279, 2279, 2604], [2607, 2607, 2664, 2726, 4878]], "test": "untested"}
{"id": "ttyfDy", "name": "Fractals with Ray Marching", "author": "ShyguyBerlin", "description": "A project I did for school.\nUse mouse to look around and sorry for bad code formatting", "tags": ["raymarching", "fractals"], "likes": 1, "viewed": 298, "published": 3, "date": "1614963955", "time_retrieved": "2024-07-30T19:34:12.040265", "image_code": "#define renderDist 100000.\n#define SUR_ACC 0.01\nvec3 rotate(vec3 Coords,vec3 EulerAngles)\n{\n    vec3 realCoords=  vec3(0.,0.,0.);\n    \n    realCoords.x=Coords.x*cos(EulerAngles.z)-Coords.y*sin(EulerAngles.z);\n    realCoords.y=Coords.y*cos(EulerAngles.z)+Coords.x*sin(EulerAngles.z);\n    \n    realCoords.z=Coords.z*cos(EulerAngles.x)-realCoords.y*sin(EulerAngles.x);\n    realCoords.y=realCoords.y*cos(EulerAngles.x)+Coords.z*sin(EulerAngles.x);\n    \n    realCoords.x=realCoords.x*cos(EulerAngles.y)-realCoords.z*sin(EulerAngles.y);\n    realCoords.z=realCoords.z*cos(EulerAngles.y)+realCoords.x*sin(EulerAngles.y);\n    return realCoords;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-k * a) + exp(-k * b)) / k;\n}\n\nvec4 skybox(vec2 fakeCoords, vec3 EulerAngles)\n{\n    vec3 Coords =  vec3(fakeCoords.x,fakeCoords.y,sqrt(sqrt(0.5*0.5*2.)-length(fakeCoords)));\n    vec3 realCoords=  rotate(Coords,EulerAngles);\n    \n    vec3 hue=vec3(15./255.,125./215.,1.)*1.;\n    float value=0.+1.2*abs(abs(realCoords.y)-1.);\n    return vec4(hue*value,1);\n}\nfloat Box(vec3 p, float size){\nvec3 q=abs(p)-size;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat recursiveHallowBox(vec3 p, float size, int i){\n\n\nwhile(i>0){\np=abs(p)-size/2.;\nsize*=1./3.;\n\np*=-1.;\nif(size<max(max(p.x,p.y),p.z)){\nif(p.x>=p.y&&p.x>=p.z){\np.x-=size;\n}else{\nif(p.y>p.x&&p.y>=p.z){\np.y-=size;\n}else{\nif(p.z>p.x&&p.z>p.y){\np.z-=size;\n}}}}\np*=-1.;\np+=size/2.;\ni--;\n}\nreturn Box(p,size) ;\n\n}\n\nfloat DE(vec3 coords)\n{\n//float kugel=distance(vec3(25.,25.,25.),coords)-2.;\n\nvec3 p=coords-vec3(sin(iTime)*150.,0.,30.);\n\n\n\nreturn min(recursiveHallowBox(p,20000.,9),coords.y+20.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat RayMarch (vec3 or, vec3 dir){\n    for(float i=0.;i<renderDist;){\n    \n    vec3 pos= i*dir+or;\n    float DE=DE(pos);\n    if(DE<SUR_ACC){\n    return i;\n    \n    }else{\n    i+=DE*0.9;\n    }\n    }\n    return renderDist;\n}\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SUR_ACC*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 muv=iMouse.xy/iResolution.xy;\n    muv-=0.5;\n    vec3 Camrotation= vec3(muv.y*6.,-muv.x*6.,0);;\n    vec3 CamPosition= vec3(0,5,mod(iTime,80.)*0.-20.);\n    vec3 LightPos =vec3(-10.,10.,-10.);//vec3(2,-5,300);\n    \n    vec4 color;\n    vec3 albedo= vec3(0.8,0.7,0.7);\n    float renderdistance=0.1;\n    float fov=3.14159/4.;\n    float XtoYratio=iResolution.y/iResolution.x;\n    //vec3 movVec=vec3(sin(fov*uv.x),sin(fov*uv.y)*XtoYratio,cos(fov*uv.x));\n    \n    vec3 movVec=normalize(vec3(uv.x,uv.y*XtoYratio,1));\n    movVec=normalize(rotate(movVec,Camrotation));\n    float accuracy=0.000001;\n    \n    \n    \n\n    \n    //Ray march\n    float d=RayMarch(CamPosition,movVec);\n    vec3 renderpos=CamPosition+movVec*d;\n    \n    \n    \n    //albedo=vec3(sin(iTime)*0.5+0.6,cos(iTime*4.)*0.5+0.6,sin(iTime*9.)*0.5+0.6);\n    \n    \n    bool weirdwaytoshade=false;\n    \n    if(d>=renderDist){\n    color=skybox(uv,Camrotation);\n    }else{\n    \n    if(weirdwaytoshade){\n        float lightlevel=1.;\n        vec3 LightVec=normalize(LightPos-renderpos);\n            for(float i=SUR_ACC*3.;i<renderDist;){\n\n            vec3 pos= i*LightVec+renderpos;\n            float DE=min(DE(pos),distance(pos,LightPos));\n\n            if(DE<accuracy){\n            if(distance(pos,LightPos)>accuracy){\n            lightlevel*=0.01;\n            }\n\n            break;\n\n            }else{\n            i+=DE*0.5;\n            }\n            lightlevel*=0.98;\n            }\n\n        color=vec4(albedo*lightlevel,1);\n        \n    }else{\n    color=vec4(albedo*GetLight(renderpos,LightPos),1);\n    }\n    }\n    //fragColor=vec4(uv.x,uv.y,0.,0.);\n    fragColor= color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 91, 91, 637], [639, 639, 678, 678, 728], [730, 730, 778, 778, 1054], [1055, 1055, 1085, 1085, 1167], [1168, 1168, 1220, 1220, 1478], [1480, 1480, 1503, 1556, 1663], [1665, 1665, 1689, 1689, 1858], [1859, 1859, 1894, 1894, 2082], [2083, 2083, 2122, 2122, 2338], [2340, 2340, 2397, 2397, 4080]], "test": "untested"}
{"id": "wlyfDG", "name": "Fractal 36_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 16, "viewed": 524, "published": 3, "date": "1614958109", "time_retrieved": "2024-07-30T19:34:12.863065", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,g=0.,e,s,a;\n        ++i<99.;\n        a=cos(i*i/80.),O.rgb+=mix(vec3(1),H(log(s)/5.),.5)*a*a/e/2e4\n    )\n    {\n        p=g*d-vec3(-.6,.2,2);\n        p=R(p,normalize(vec3(1,1,1)),iTime*.1);\n    s=3.;\n    for(int i=0;i++<5;p=abs(p)*e)\n    p=vec3(6,4,2)-abs(p-vec3(9,4,2)),\n    s*=e=8./clamp(dot(p,p),.1,8.);\n  g+=e=min(length(p.xz),p.y)/s+.001;}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 591]], "test": "untested"}
{"id": "tlyBDG", "name": "Ripple [ppxxll]", "author": "robclouth", "description": "Ripples", "tags": ["procedural", "noise", "fbm", "warp", "blue", "ice", "warped"], "likes": 1, "viewed": 205, "published": 3, "date": "1614957564", "time_retrieved": "2024-07-30T19:34:13.747700", "image_code": "/*\n@title Ripple\n@author robclouth\n*/\n\nconst float xScale = 0.1; // @param min 0, max 1\nconst float yScale = 0.1; // @param min 0, max 1\n\n\nfloat prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) - 0.5;\n}\n\nfloat fprand(vec2 uv, float f){\n    vec2 sp = uv*f;\n    vec2 isp = floor(sp);\n    vec2 fsp = fract(sp);\n    \n    float a = prand(isp+0.5);\n    float b = prand(isp+0.5+vec2(1.0,0.0));\n    float c = prand(isp+0.5+vec2(0.0,1.0));    \n    float d = prand(isp+0.5+vec2(1.0,1.0));\n    float wx = smoothstep(0.0, 1.0, fsp.x);\n    float wy = smoothstep(0.0, 1.0, fsp.y);\n    return mix(mix(a,b,wx), mix(c,d,wx), wy);\n    \n}\n\nfloat perlin(vec2 uv, int octaves, float f0, float fmul, float v0, float vmul){\n    float val = 0.0;\n    float frq = f0;\n    float wei = v0;\n    float time = mod(iTime, 1000.0);\n    \n    for (int i=0; i<octaves; i++) {\n        val += wei * texture(iChannel1, uv*vec2(xScale, yScale)*frq*0.1 + vec2(time*0.001)).r;\n        frq *= fmul;\n        wei *= vmul;\n    }\n   \n    return val;\n}\n\nfloat pdef(vec2 uv) {\n    //return perlin(uv, 11, 0.8, 1.7, 1.5, 0.65);\n    return perlin(uv, 7, 1.0, 1.9, 0.3,0.8);\n}\n\nvec2 warped(vec2 uv) {\n    return uv + vec2(vec2(pdef(uv+pdef(uv)), pdef(uv+pdef(uv+3.145)+1.25)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n    fragColor = texture(iChannel0, warped(uv));\n    \n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 161, 161, 246], [248, 248, 279, 279, 663], [665, 665, 744, 744, 1048], [1050, 1050, 1071, 1121, 1168], [1170, 1170, 1192, 1192, 1271], [1273, 1273, 1330, 1330, 1444]], "test": "untested"}
{"id": "wlGBDG", "name": "RGB To Normal Map By Sobel", "author": "CaesarSun", "description": "RGB To Normal Map By SobelYou can used Diffuse Map or video.", "tags": ["sobel", "rgb", "normal"], "likes": 0, "viewed": 330, "published": 3, "date": "1614954655", "time_retrieved": "2024-07-30T19:34:14.933530", "image_code": "            vec3 GrayToNormalSobel(mat3 SobelPx)\n            {\n                mat3 SobelX = mat3(1.0, 0.0, -1.0,\n                                           2.0, 0.0, -2.0,\n                                           1.0, 0.0, -1.0);\n                mat3 SobelY = mat3(1.0, 2.0, 1.0,\n                                           0.0, 0.0, 0.0,\n                                           -1.0, -2.0, -1.0);\n\n\n                SobelX = SobelX * SobelPx;\n                SobelY = SobelY * SobelPx;\n                float Sx = SobelX[0][0] + SobelX[0][2]\n                    + SobelX[1][0] + SobelX[1][2]\n                    + SobelX[2][0] + SobelX[2][2];\n                float Sy = SobelY[0][0] + SobelY[0][1]\n                    + SobelY[0][2] + SobelY[2][0]\n                    + SobelY[2][1] + SobelY[2][2];\n\n                float Sz = sqrt(1.0 - clamp (0.0 ,1.0 , (Sx * Sx + Sy * Sy)));\n               // float Sz = sqrt(1.0 - (dot(Sx , Sy)));\n\n                vec3 normal = clamp (vec3(0.0), vec3(Sx, Sy, Sz), vec3(Sx, Sy, Sz));\n                // vec3 normal =(vec3(Sx, Sy, Sz) +4) / 8;\n                // normal = (vec3(Sx, Sy, Sz);\n                return normal;\n            }\n            \n                        mat3 CurrentPixel(sampler2D RGBMap, vec2 TexUV, float TexSize, int Channel)\n            {\n                mat3 ADPixels;\n                ADPixels[0][0] = texture(RGBMap, TexUV + vec2(- TexSize, - TexSize))[Channel];\n                ADPixels[0][1] = texture(RGBMap, TexUV + vec2(0, - TexSize))[Channel];\n                ADPixels[0][2] = texture(RGBMap, TexUV + vec2(TexSize, - TexSize))[Channel];\n\n                ADPixels[1][0] = texture(RGBMap, TexUV + vec2(- TexSize, 0))[Channel];\n                ADPixels[1][1] = texture(RGBMap, TexUV)[Channel];\n                ADPixels[1][2] = texture(RGBMap, TexUV + vec2(TexSize, 0))[Channel];\n\n                ADPixels[2][0] = texture(RGBMap, TexUV + vec2(- TexSize, TexSize))[Channel];\n                ADPixels[2][1] = texture(RGBMap, TexUV + vec2(0, TexSize))[Channel];\n                ADPixels[2][2] = texture(RGBMap, TexUV + vec2(TexSize, TexSize))[Channel];\n\n                return ADPixels;\n            }\n            \n            vec3 UnpackNormalmapRGorAG1(vec3 packednormal)\n            {\n                vec3 normal;\n                normal.xy = (packednormal.xy +1.0) / 2.0;\n                return vec3(normal.xy, packednormal.z);\n            }\n            \n            \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 ce = CurrentPixel(iChannel1,fragCoord.xy/iResolution.xy, 1.0/iResolution.xy.x, 0); // red only\n    \n    vec3 normal = GrayToNormalSobel(ce);\n    normal = normalize(vec3(normal.x *  1.0, normal.y * -1.0, normal.z * 1.0));\n    normal = UnpackNormalmapRGorAG1(normal);\n    //float Lambert = clamp(0.0 ,1.0 ,dot(normal, vec3(1.0,1.0,1.0)));\n    \n\n     //Output to screen\n    fragColor = vec4(normal,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 62, 62, 1176], [1214, 1214, 1303, 1303, 2166], [2192, 2192, 2252, 2252, 2409], [2437, 2437, 2494, 2494, 2906]], "test": "untested"}
{"id": "3tyfWG", "name": "@zozuar's fractal from twitter", "author": "MacSlow", "description": "A twitter user named yonatan/@zozuar posted a compelling animation (and GLSL-snippet) of a 3D-fractal. I had to get that into a fully working shader... to see how much for a working shader was still missing. The character-limit on twitter is hard :)", "tags": ["3d", "fractal", "cineshader"], "likes": 15, "viewed": 1556, "published": 3, "date": "1614937144", "time_retrieved": "2024-07-30T19:34:15.783259", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// yonatan's 3D fractal - A twitter user named yonatan/@zozuar posted a really\n// compelling animation and GLSL-snippet of a 3D-fractal the other day. I had to\n// get that into a fully working shader to see how much for a working shader was\n// still missing. The character-limit on twitter is hard :)\n//\n// Furthermore some people in the comments on the original post were missing\n// code-context and this my attempt to provide that. I provide a bit of\n// commentary in case people a bit unfamiliar with raymarching give it a read.\n//\n// See the function yonatansFractal() for all the details and references.\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// basic 2D-rotation matrix\nmat2 rotate2D (float rad)\n{\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// convert hue/saturation/value to RGB-color\nvec3 hsv(float h, float s, float v)\n{\n    vec3 c = vec3 (h, s, v);\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(c.xxx + k.xyz) * 6. - k.www);\n\n    return c.z * mix(k.xxx, clamp(p - k.xxx, .0, 1.), c.y);\n}\n\nvoid yonatansFractal (float t, vec2 FC, vec2 r, inout vec3 o)\n{\n    // yonatan/@zozuar's GLSL-snippet as posted on twitter...\n    // just formatted a bit nicer, but otherwise untouched, see\n    // https://twitter.com/zozuar/status/1367243732764876800\n    // for reference\n    for(float i, g, e, s, k = t*.1; ++i < 99.; o.rgb += hsv(s/15. + .5, .3, s/1e3)) {\n        vec3 p = vec3(g*(FC.xy - .5*r)/r.y + .5,g - 1.);\n        p.xz *= rotate2D(k);\n        s = 3.;\n        for(int i; i++ < 9; p = vec3(2,4,2) - abs(abs(p)*e - vec3(4,4,2) ) )\n            s *= e = max(1.,(8.-8.*cos(k))/dot(p,p));\n        g += min(length(p.xz), p.y)/s;\n        s = log(s);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + 20.;   // offset the time thus the thumbnail looks not empty\n    vec2 FC = fragCoord;     // pixel-coordinates\n    vec3 o = vec3 (.0);      // rgb-output color\n    vec2 r = iResolution.xy; // resolution for point/ray-generation\n\n    yonatansFractal(t, FC, r, o);\n\n    // finally show it on screen\n    fragColor = vec4(o, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyfWG.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1454, 1482, 1509, 1509, 1592], [1594, 1639, 1676, 1676, 1862], [1864, 1864, 1927, 2135, 2521], [2523, 2523, 2580, 2580, 2930]], "test": "untested"}
{"id": "3lyBWG", "name": "color hue adjust", "author": "between", "description": "A shader that can change color in specific color channel.", "tags": ["hsl", "colorpalette"], "likes": 1, "viewed": 403, "published": 3, "date": "1614932226", "time_retrieved": "2024-07-30T19:34:16.655924", "image_code": "#define redHue 0.000000\n#define orangeHue 0.082816\n#define yellowHue 0.166667\n#define greenHue 0.333333\n#define aquaHue 0.500000\n#define blueHue 0.666667\n#define purpleHue 0.749482\n#define pinkHue 0.833333\n\nvec3 rgb2hsv(vec3 color) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(color.bg, K.wz), vec4(color.gb, K.xy), step(color.b, color.g));\n    vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 color) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\n}\n\nvec3 smoothTreatment(vec3 hsv, float hueEdge0, float hueEdge1, vec3 HSVEdge0, vec3 HSVEdge1) {\n    float smoothedHue = smoothstep(hueEdge0, hueEdge1, hsv.x);\n    float scaledLum = HSVEdge0.z + ((HSVEdge1.z - HSVEdge0.z) * smoothedHue);\n    float hue = hsv.x + (HSVEdge0.x + ((HSVEdge1.x - HSVEdge0.x) * smoothedHue));\n    float sat = hsv.y * (HSVEdge0.y + ((HSVEdge1.y - HSVEdge0.y) * smoothedHue));\n    if (sat < 0.01) {\n        return vec3(hue, sat, hsv.z);\n    }\n    float lum = hsv.z;\n\n    lum = (abs(HSVEdge0.z) + abs(HSVEdge1.z)) > 0.0\n              ? (hsv.z * scaledLum * smoothstep(0.0, 1.0, abs(sat / hsv.y - 0.5) * 2.0))\n              : lum;\n    float changedMaxLuminance = max(abs(HSVEdge0.z - 1.0), abs(HSVEdge1.z - 1.0));\n    lum = mix(hsv.z, lum, changedMaxLuminance);\n    return vec3(hue, sat, lum);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // Change the color HSV to get the hsv changed result\n    // The luminance change cannot be good to the true scenes\n    // If you want to change another color, just use uniform to set outside of the shader\n    float time = sin(iTime)*0.5;\n    vec3 redHSV = vec3(0.0, 1.0, 1.0);\n    vec3 orangeHSV = vec3(time, 1.0, 1.0);\n    vec3 yellowHSV = vec3(0.0, 1.0, 1.0);\n    vec3 greenHSV = vec3(0.0, time, 1.0);\n    vec3 aquaHSV = vec3(0.0, 1.0, 1.0);\n    vec3 blueHSV = vec3(0.0, 1.0, 1.0);\n    vec3 purpleHSV = vec3(0.0, 1.0, 1.0);\n    vec3 pinkHSV = vec3(0.0, 1.0, 1.0);\n    \n    vec3 hsv = rgb2hsv(color.rgb);\n    if (hsv.x < orangeHue) {\n        hsv = smoothTreatment(hsv, 0.0, orangeHue, redHSV, orangeHSV);\n    } else if (hsv.x < yellowHue) {\n        hsv = smoothTreatment(hsv, orangeHue, yellowHue, orangeHSV, yellowHSV);\n    } else if (hsv.x < greenHue) {\n        hsv = smoothTreatment(hsv, yellowHue, greenHue, yellowHSV, greenHSV);\n    } else if (hsv.x < aquaHue) {\n        hsv = smoothTreatment(hsv, greenHue, aquaHue, greenHSV, aquaHSV);\n    } else if (hsv.x < blueHue) {\n        hsv = smoothTreatment(hsv, aquaHue, blueHue, aquaHSV, blueHSV);\n    } else if (hsv.x < purpleHue) {\n        hsv = smoothTreatment(hsv, blueHue, purpleHue, blueHSV, purpleHSV);\n    } else if (hsv.x < pinkHue) {\n        hsv = smoothTreatment(hsv, purpleHue, pinkHue, purpleHSV, pinkHSV);\n    } else {\n        hsv = smoothTreatment(hsv, pinkHue, 1.0, pinkHSV, redHSV);\n    }\n    fragColor = hsv.y > 0.0 ? vec4(hsv2rgb(hsv), color.a) : vec4(vec3(hsv.z), color.a);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 233, 233, 592], [594, 594, 620, 620, 801], [803, 803, 897, 897, 1619], [1621, 1621, 1676, 1676, 3319]], "test": "untested"}
{"id": "WtVfzd", "name": "Parabola - Two-Point Control", "author": "oneshade", "description": "Parabola parametrized by two points. Useful as an intuitive way to control a parabola. Drag the points with the mouse.", "tags": ["2d", "math", "graph", "parabola", "parametrization", "controlpoint"], "likes": 2, "viewed": 147, "published": 3, "date": "1614922575", "time_retrieved": "2024-07-30T19:34:17.555519", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n#define TEST_COEFFICIENTS\n\n// Value of y at x of a parabola parametrized by points a and b\nfloat ParabolaFunction(in float x, in vec2 a, in vec2 b) {\n    float pa = x - a.x, ba = b.x - a.x;\n    return (b.y - a.y) * pa * pa / (ba * ba) + a.y;\n}\n\n// Derivative at x of a parabola parametrized by points a and b\nfloat ParabolaDerivative(in float x, in vec2 a, in vec2 b) {\n    float ba = b.x - a.x;\n    return 2.0 * (x - a.x) * (b.y - a.y) / (ba * ba);\n}\n\n// Coefficients a, b, and c of a parabola parametrized by points a and b\nvec3 ParabolaCoefficients(in vec2 a, in vec2 b) {\n    float ba = b.x - a.x;\n    float coeff1 = (b.y - a.y) / (ba * ba);\n    float coeff2 = -2.0 * a.x * coeff1;\n    float coeff3 = a.x * a.x * coeff1 + a.y;\n    return vec3(coeff1, coeff2, coeff3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float t = 0.25 * unit;\n    vec3 color = vec3(1.0);\n\n    // Load control points\n    vec2 p1 = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 p2 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n\n    // Grid\n    draw(abs(mod(uv.x + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(mod(uv.y + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Parabola\n    #ifdef TEST_COEFFICIENTS\n    vec3 coeffs = ParabolaCoefficients(p1, p2);\n    float f = coeffs[0] * uv.x * uv.x + coeffs[1] * uv.x + coeffs[2];\n    float d = 2.0 * coeffs[0] * uv.x + coeffs[1];\n\n    #else\n    float f = ParabolaFunction(uv.x, p1, p2);\n    float d = ParabolaDerivative(uv.x, p1, p2);\n    #endif\n\n    draw(abs(uv.y - f) / sqrt(1.0 + d * d) - t, vec3(0.6, 0.0, 0.6));\n\n    // Draw control points\n    draw(length(uv - p1) - 0.075, vec3(0.0));\n    draw(length(uv - p2) - 0.075, vec3(0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SELECTION_RADIUS 0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor.xy = vec2(0.0, 0.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor.xy = vec2(1.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < 2 && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            if (length(mouse - fragColor.xy) < SELECTION_RADIUS) {\n                fragColor.xy = mouse;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 158, 216, 216, 310], [312, 376, 436, 436, 518], [520, 593, 642, 642, 840], [842, 842, 897, 897, 2003]], "test": "untested"}
{"id": "tlKfRd", "name": "Plasma jets", "author": "jarble", "description": "This is based on [url=https://www.shadertoy.com/view/wtKBRd]another fractal formula[/url].", "tags": ["fractal"], "likes": 11, "viewed": 404, "published": 3, "date": "1614920351", "time_retrieved": "2024-07-30T19:34:18.326458", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n        for(float i=0.,g=0.,e,s,t;\n        ++i<99.;t=cos(i*i/64.),\n        O.rgb+=mix(vec3(1),H(log(s)/5.),.5)*(t*t*t*t*t*t*t*t)/e/2e4\n    )\n    {\n        p=g*d-vec3(0,-.25,1.3);\n        p=R(p,normalize(vec3(1,8,0)),iTime*.1);\n        s=3.;\n        for(int i=0;\n            i++<4;\n            p=vec3(2,4,2)-abs(abs(p)*e-vec3(3,5,1))\n        )\n            s*=e=1./clamp(dot(p,p),.1,.6);\n            p = sin(p.yzx*length(sin(p)));\n        g+=e=min(length(p.xz)-.02,abs(p.y))/s+.001;\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 717]], "test": "untested"}
{"id": "tlVBRd", "name": "LED Tile", "author": "foxic", "description": "A Tile with a built in LED for a project.", "tags": ["2d", "led", "tile"], "likes": 0, "viewed": 189, "published": 3, "date": "1614918035", "time_retrieved": "2024-07-30T19:34:19.288884", "image_code": "float sdBox( in vec2 p, in float b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n\t// LED\n    float led_state = sin(iTime)*0.5; //how much its on\n    float led_power =(sin(iTime*100.)*cos(iTime*30.)*0.02)+1.; //flicker\n    led_power *= clamp(sin(led_state+(sin(iTime*50.)*0.05))*30., 0., 1.);\n    float led = smoothstep(0.0,1.0*led_power,sdCircle(p,0.02));\n    \n    led = (1.-led)*led_power;\n    \n\t// tile\n    float tile_mask = smoothstep(0.0,0.02,sdBox(p,0.6)-0.05);\n    float tile = mix(smoothstep(0.0,0.1,sdBox(p+vec2(0.,0.025),0.6)-0.025)+0.1, 0., tile_mask);\n    tile = mix(((led*0.5)+tile)-(smoothstep(0.0,0.1,sdBox(p-vec2(0.,0.05),0.55)-0.07)*0.05), 0., tile_mask);\n    \n    \n\t// Bubble\n    float bubble_mask = smoothstep(0.0,0.05,sdCircle(p,0.5));\n    float bubble_dark = mix(smoothstep(0.0,0.7,sdCircle(p+vec2(0.,0.1),0.4)), 0., bubble_mask)*0.3;\n    \n    float bubble = mix(smoothstep(0.0,0.5,sdCircle(p+vec2(0.,-0.1),0.4)), 0., bubble_mask);\n    \n    \n    float d = mix(0.05-(min(bubble_dark-(led*0.5), 0.)-bubble), tile, bubble_mask);\n    vec3 led_col = mix( vec3(led*led_power,0.,0.), vec3(1.), max(max(smoothstep(0.0,0.9,led-0.5), smoothstep(0.0,0.3,led-0.85)), 0.) );\n    \n\tfragColor = vec4(vec3(d)+(led_col),1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 118], [120, 120, 162, 162, 188], [190, 190, 247, 247, 1459]], "test": "untested"}
{"id": "wtKBRd", "name": "Fractal 35_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 22, "viewed": 612, "published": 3, "date": "1614915576", "time_retrieved": "2024-07-30T19:34:20.160554", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(vec3(1),H(log(s)/5.),.5)*pow(cos(i*i/64.),2.)/e/2e4\n    )\n    {\n        p=g*d-vec3(0,-.25,1.3);\n        p=R(p,normalize(vec3(1,8,0)),iTime*.1);\n        s=3.;\n        for(int i=0;\n            i++<4;\n            p=vec3(2,4,2)-abs(abs(p)*e-vec3(3,5,1))\n        )\n            s*=e=1./clamp(dot(p,p),.1,.6);\n        g+=e=min(length(p.xz)-.02,abs(p.y))/s+.001;\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 656]], "test": "untested"}
{"id": "wlVfzt", "name": "Baby's First Raymarch", "author": "plinky", "description": "You must give a description to your shader", "tags": ["raymarch"], "likes": 0, "viewed": 236, "published": 3, "date": "1614913116", "time_retrieved": "2024-07-30T19:34:20.972383", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURF_DIST 0.1\n\nfloat getSphere(vec3 point) {\n    // leftright, above ground plane, away from camera, radius\n    vec4 sphere = vec4(0, sin(iTime), 6, 1);\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat getPlane(vec3 point) {\n    return point.y;\n}\n\nfloat getDist(vec3 point) {\n    return min(\n        getSphere(point),\n        min(\n            getPlane(point),\n            getSphere(point) + 0.001\n        )\n    );\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDistance) {\n    float dO = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 marchLocation = rayOrigin + rayDistance * dO;\n        float ds = getDist(marchLocation);\n        dO += ds;\n        if(dO > MAX_DISTANCE || ds < SURF_DIST) {\n            break;\n        }\n    }\n    \n    return dO;\n}\n\n\nvec3 getNormal(vec3 point) {\n    float distance = getDist(point);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        getDist(point - e.xyy),\n        getDist(point - e.yxy),\n        getDist(point - e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat getLight(vec3 point) {\n    vec3 lightPosition = vec3(0, 5, 6);\n    lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 10.0;\n    vec3 light = normalize(lightPosition - point);\n    vec3 normal = getNormal(point);\n\n    float shadow = 1.0;\n    float d = rayMarch(point + normal * SURF_DIST * 2.1, light);\n    if(d < length(lightPosition - point)) {\n        shadow = 0.5;\n    }\n    \n    return shadow * clamp(dot(normal, light), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float distance = rayMarch(rayOrigin, rayDirection);\n    \n    vec3 point = rayOrigin + rayDirection * distance;\n    float diffuseLighting = getLight(point);\n    \n    vec3 col = vec3(distance);\n    col = vec3(diffuseLighting);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 101, 164, 261], [263, 263, 291, 291, 313], [315, 315, 342, 342, 482], [484, 484, 534, 534, 823], [826, 826, 854, 854, 1098], [1100, 1100, 1128, 1128, 1542], [1544, 1544, 1601, 1651, 2106]], "test": "untested"}
{"id": "wtVfzt", "name": "cellular automata fiber", "author": "account", "description": "cellular automata", "tags": ["cellularautomate"], "likes": 2, "viewed": 291, "published": 3, "date": "1614910689", "time_retrieved": "2024-07-30T19:34:21.805158", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float d1(float x, float a){\nreturn 1./(1.+exp(-(x-a)*(4./a)));\n}\nfloat d2(float x, float a, float b){\nreturn d1(x,a)*(1.0-d1(x,b));\n}\nfloat d3(float x, float y, float m){\nreturn x*(1.0-d1(m, 0.5)) + y*d1(m,0.5);\n}\nfloat d4(float n, float m, float b1, float b2, float d1, float dd2){\nreturn d2(n, d3(b1,d1,m),d3(b2,dd2,m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))\n    \n    float n = 0.;\n    \n    for(int i = 0; i < 20; i++){\n        for(int k = 0; k < 20; k++){\n            vec2 coords = vec2(float(i)-10., float(k)-10.);\n            if(length(coords) - 5. < 0.01){\n               vec2 uvm = uv * iResolution.xy;\n               vec3 c = texture(iChannel0, (uvm + coords)/iResolution.xy).xyz;\n               vec3 c2 = texture(iChannel1, (uvm + coords)/iResolution.xy).xyz;\n               if(coords.x == 0. && coords.y == 0.)continue;\n               if(c.x > 0.01 || c.y > 0.01 || c.z > 0.01){\n                  n+= d4(0.4, n, 0.3, 0.6, 0.4, 0.6);\n               }\n            }\n        }\n    }\n    \n    if(col.x > 0.01 || col.y > 0.01 || col.z > 0.01){\n       if(n < 4. || n > 30.){\n          col = vec3(0.0);\n       }\n    }else{\n       if(n > 15. && n < 25.){\n          col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n       }\n    }\n    \n    //col = vec3(d4(uv.x*2.1+n, uv.y*2.1, 0.3, uv.x, uv.y, 0.6))*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z > 0.5){\n       if(length(mouse-uv) < 0.4){\n          col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n       }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 282]], "test": "untested"}
{"id": "wlKfzt", "name": "Simple Negabrot orbit demo", "author": "FutureFractal", "description": "Quick-and-dirty Negabrot (negative Mandelbrot) orbit visualizer.\nClick and drag to view the orbits for any given starting point.\n\nEDIT: Thanks to FabriceNeyret2 for faster complex ops!", "tags": ["fractal", "mandelbrot", "negabrot"], "likes": 6, "viewed": 416, "published": 3, "date": "1614909666", "time_retrieved": "2024-07-30T19:34:22.639925", "image_code": "#define MAX_ITER 200\n#define DOT_SIZE 0.04375\n\nvec2 complex_mul(vec2 a, vec2 b)\n{\n    return mat2(a, -a.y, a.x) * b;\n}\n\nvec2 complex_pow2(vec2 z)\n{\n\treturn mat2(z, -z.y, z.x) * z;\n}\n\nvec2 complex_inv(vec2 z)\n{\n    return vec2(z.x, -z.y) / dot(z,z);\n}\n\nvec3 h2rgb(float h)\n{\n    // source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n    return clamp(p - K.xxx, 0.0, 1.0);\n}\n\nvec2 scaleFragCoord(vec2 coord)\n{\n    coord = (coord*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    coord *= 1.75;\n    return coord;\n}\n\nvec3 drawNegabrot(vec2 c)\n{\n    vec2 mc = scaleFragCoord(iMouse.xy);\n    vec2 z = c, mz = mc;\n    \n    float sigma = 0.;\n    \n    for (int i = 0; i < MAX_ITER; ++i) {\n    \n        if (length(mz - c) < DOT_SIZE) {\n            return h2rgb(float(i) / float(MAX_ITER));\n        }\n    \n        // Draw the Negabrot using the Lyapunov exponent method\n\t\t// d/dz (z^(-2)+c) = -2(z^(-3))\n        vec2 zr  = complex_inv(z);\n        vec2 zr2 = complex_pow2(zr);\n        sigma += log(length(-2.0 * complex_mul(zr, zr2)));\n        z = zr2 + c;\n        \n        mz = complex_inv(complex_pow2(mz)) + mc;\n\t}\n    \n    float mag = abs(sigma * (1.0 / float(MAX_ITER)));\n    mag = mag / sqrt((mag * mag) + 1.0); // same as sin(atan(mag))\n    mag = (mag * 0.95) + 0.05;\n\t\n\treturn vec3(mag);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 c = scaleFragCoord(fragCoord);    \n\tvec3 color = drawNegabrot(c);\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 81, 81, 118], [120, 120, 147, 147, 181], [183, 183, 209, 209, 250], [252, 252, 273, 344, 492], [494, 494, 527, 527, 643], [645, 645, 672, 672, 1417], [1419, 1419, 1474, 1474, 1578]], "test": "untested"}
{"id": "tlKBzt", "name": "Simple Mandelbrot orbit demo", "author": "FutureFractal", "description": "Quick-and-dirty Mandelbrot orbit visualizer.\nClick and drag to view the orbits for any given starting point.", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 293, "published": 3, "date": "1614907350", "time_retrieved": "2024-07-30T19:34:23.471701", "image_code": "#define MAX_ITER 200\n#define DOT_SIZE 0.025\n\nvec2 complex_pow2(vec2 z)\n{\n\treturn mat2(z, -z.y, z.x) * z;\n}\n\nvec3 h2rgb(float h)\n{\n    // source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n    return clamp(p - K.xxx, 0.0, 1.0);\n}\n\nvec2 scaleFragCoord(vec2 coord)\n{\n    coord = (coord*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    coord += vec2(-0.5, 0.);\n    return coord;\n}\n\nvec3 drawMandelbrot(vec2 c)\n{\n    vec2 z = c;\n    \n    vec2 mc = scaleFragCoord(iMouse.xy);\n    vec2 mz = mc;\n    \n    vec3 color = vec3(0.5);\n    \n\tfor (int i = 0; i < MAX_ITER; ++i) {\n    \n        if (length(mz - c) < DOT_SIZE) {\n            return h2rgb(float(i) / float(MAX_ITER));\n        }\n    \n\t\tz  = complex_pow2(z)  + c;\n        mz = complex_pow2(mz) + mc;\n        \n\t\tif (length(z) > 2.) {\n\t\t\tcolor = vec3(0.);\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 c = scaleFragCoord(fragCoord);\n\tvec3 color = drawMandelbrot(c);\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 72, 72, 106], [108, 108, 129, 200, 348], [350, 350, 383, 383, 509], [511, 511, 540, 540, 956], [958, 958, 1013, 1013, 1115]], "test": "untested"}
{"id": "ttVBRt", "name": "Bezier Strokes and Chill", "author": "Qendolin", "description": "Synced to music.\nPress space to clear.", "tags": ["bezier", "brush", "chill"], "likes": 4, "viewed": 459, "published": 3, "date": "1614903818", "time_retrieved": "2024-07-30T19:34:24.436122", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25970, "src": "https://soundcloud.com/kudasaibeats/the-girl-i-havent-met", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "float seed = 0.;\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n/* unused\nfloat hash2(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n*/\n\nfloat rand(float p, float s) {\n    return hash(p+seed+s);\n}\n\nfloat smoothRand(float interval, float x, float seed) {\n    float a = floor(x / interval);\n    return mix(rand(a, hash(seed)), rand(a+1., hash(seed)), fract(x/interval));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n/* unused\nvec2 bezier4(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n  vec2 E = mix(A, B, t);\n  vec2 F = mix(B, C, t);\n  vec2 G = mix(C, D, t);\n\n  vec2 H = mix(E, F, t);\n  vec2 I = mix(F, G, t);\n\n  vec2 P = mix(H, I, t);\n\n  return P;\n}\n*/\n\nvec2 bezier5(vec2 A, vec2 B, vec2 C, vec2 D, vec2 E, float t) {\n  vec2 A1 = mix(A, B, t);\n  vec2 B1 = mix(B, C, t);\n  vec2 C1 = mix(C, D, t);\n  vec2 D1 = mix(D, E, t);\n\n  vec2 A2 = mix(A1, B1, t);\n  vec2 B2 = mix(B1, C1, t);\n  vec2 C2 = mix(C1, D1, t);\n\n  vec2 A3 = mix(A2, B2, t);\n  vec2 B3 = mix(B2, C2, t);\n  \n  vec2 P = mix(A3, B3, t);\n\n  return P;\n}", "buffer_a_code": "#define SUBSAMPLES 10.\n#define KEY_SPACE 32\n\nvec2 uv;\nvec2 px;\n\nvec4 brush(float iTime) {\n    const float speed = 8.*60./140.; // Song is 140 bpm, 8 beat measure\n    vec3 col = hsv2rgb(vec3(\n        2.*smoothRand(speed, iTime, 1.), \n        0.3+smoothRand(speed, iTime, 2.)*0.2, \n        1.)); \n    \n    vec2 A = vec2(smoothRand(speed, iTime, 4.)*1.25-0.125, smoothRand(speed, iTime, 5.)*1.25-0.125);\n    vec2 B = vec2(smoothRand(speed, iTime, 6.)*1.25-0.125, smoothRand(speed, iTime, 7.)*1.25-0.125);\n    vec2 C = vec2(smoothRand(speed, iTime, 8.)*1.25-0.125, smoothRand(speed, iTime, 9.)*1.25-0.125);\n    vec2 D = vec2(smoothRand(speed, iTime, 10.)*1.25-0.125, smoothRand(speed, iTime, 11.)*1.25-0.125);\n    vec2 E = vec2(smoothRand(speed, iTime, 12.)*1.25-0.125, smoothRand(speed, iTime, 13.)*1.25-0.125);\n    \n    vec2 pos = bezier5(A, B, C, D, E, mod(iTime/speed, 1.));\n    float r = smoothRand(1., iTime, 6.) * length(px)*10.;\n    \n    float a = smoothstep(r+px.x*2., r, length(pos-uv));\n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy;\n    px = 1./iResolution.xy;\n    \n    vec4 color;\n    vec4 last = texture(iChannel0, uv);\n    last = mix(last, vec4(1.), 0.003*iTimeDelta);\n    if(texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0).x > 0.5) last = vec4(1.);\n    \n    for(float i = 1.; i <= SUBSAMPLES; i++) {\n        float p = 1. - i/SUBSAMPLES;\n        vec4 s = brush(iTime-iTimeDelta*p+3./7.);\n        \n        color = mix(last, vec4(s.rgb, 1.), s.a);\n        last = color;\n    }\n    \n    fragColor = mix(vec4(1.), color, color.a);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 121]], "test": "untested"}
{"id": "tlyBzd", "name": "Picross (Nonogram)", "author": "IWBTShyGuy", "description": "Click -> Write\nKey X + Click -> Cross\n\nIf you click on an already painted square, it will erased.\nIf the answer is correct, the picture will be colored.\nEnjoy! :)", "tags": ["game", "bitmap", "puzzle", "picross", "nonogram"], "likes": 10, "viewed": 496, "published": 3, "date": "1614874786", "time_retrieved": "2024-07-30T19:34:25.346688", "image_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nconst float GRID_THICKNESS = 0.1;\n\nconst vec4 BACK = vec4(230, 220, 182, 255) / 255.0;\nconst vec4 GRID = vec4(78, 52, 0, 255) / 255.0;\nconst vec4 INK = vec4(122, 89, 64, 255) / 255.0;\n\nfloat letter(in vec2 uv, in int idx) {\n    uv = clamp(uv, 0.0, 1.0);\n    int i = idx % 16;\n    int j = 15 - idx / 16;\n    vec2 origin = vec2(float(i) / 16.0, float(j) / 16.0);\n    uv = (uv / 16.0 + origin);\n    float r = texture(iChannel1, uv).x;\n    return floor(r + 0.5);\n}\n\nfloat number(in vec2 uv, in int num) {\n    int num_100 = num / 100;\n    int num_10 = (num % 100) / 10;\n    int num_1 = num % 10;\n    float flag_100 = float(sign(num_100));\n    float flag_10 = (1.0 - flag_100) * float(sign(num_10));\n    float flag_1 = (1.0 - flag_100) * (1.0 - flag_10);\n    float r_1 = letter(uv, num_1 + 48);\n    int x_10 = int(uv.x * 2.0);\n    int a_10 = num_10 * clamp(1 - x_10, 0, 1)\n        + num_1 * clamp(1 - abs(x_10 - 1), 0, 1);\n    float r_10 = letter(vec2(fract(uv.x * 2.0), uv.y), a_10 + 48);\n    int x_100 = int(uv * 3.0);\n    int a_100 = num_100 * clamp(1 - x_100, 0, 1)\n        + num_10 * clamp(1 - abs(x_100 - 1), 0, 1)\n        + num_1 * clamp(1 - abs(x_100 - 2), 0, 1);\n    float r_100 = letter(vec2(fract(uv.x * 3.0), uv.y), a_100 + 48);\n    return flag_1 * r_1 + flag_10 * r_10 + flag_100 * r_100;\n}\n\nfloat drawLine(in float x) {\n    float a = x - floor(x);\n    a = clamp(a / GRID_THICKNESS, 0.0, 1.0);\n    float b = floor(x + 1.0) - x;\n    b = clamp(b / GRID_THICKNESS, 0.0, 1.0);\n    return min(a, b);\n}\n\nint countDifference() {\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        for (int j = 0; j < HEIGHT; j++) {\n            int board = int(texelFetch(iChannel0, ivec2(i, j), 0).x * 1.01);\n            board = clamp(1 - abs(board - 1), 0, 1);\n            int bit = BITMAP[(HEIGHT - 1 - j) * WIDTH + i];\n            bit = clamp(1 - abs(bit - 1), 0, 1);\n            counter += abs(bit - board);\n        }\n    }\n    return counter;\n}\n\nconst int PICROSS[7] = int[](80, 105, 99, 114, 111, 115, 115);\n\nvec4 upperLeft(in vec2 uv) {\n    uv = vec2(uv.x / 0.25, (uv.y - 0.75) / 0.25);\n    int idx = int(uv.x * 7.0);\n    uv.x = fract(uv.x * 7.0);\n    uv.y = clamp((uv.y - 0.4) * 7.0, 0.0, 1.0);\n    float r = 1.0 - letter(uv, PICROSS[idx]);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nint countRow(in int row, in int num) {\n    int prev = 0;\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        int idx = (HEIGHT - 1 - row) * WIDTH + (WIDTH - 1 - i);\n        int current = 1 - clamp(abs(BITMAP[idx] - 1), 0, 1);\n        int pflag = 1 - clamp(abs(num), 0, 1);\n        counter += pflag * current;\n        num -= clamp(prev - current, 0, 1);\n        prev = current;\n    }\n    return counter;\n}\n\nvec4 lowerLeft(in vec2 uv) {\n    float c = drawLine(uv.y / 0.75 * float(HEIGHT));\n    int row = int(uv.y / 0.75 * float(HEIGHT));\n    int num = int((0.25 - uv.x) / 0.25 * 6.0);\n    int count = countRow(row, num);\n    uv = vec2((0.25 - uv.x) / 0.25 * 6.0, uv.y / 0.75 * 16.0);\n    uv = uv - floor(uv);\n    uv.x = 1.0 - uv.x;\n    uv.y = clamp((uv.y - 0.5) * 1.2 + 0.5, 0.0, 1.0);\n    float r = 1.0 - float(sign(count)) * number(uv, count);\n    r = min(r, c);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nint countCol(in int col, in int num) {\n    int prev = 0;\n    int counter = 0;\n    for (int i = 0; i < HEIGHT; i++) {\n        int idx = (HEIGHT - 1 - i) * WIDTH + col;\n        int current = 1 - clamp(abs(BITMAP[idx] - 1), 0, 1);\n        int pflag = 1 - clamp(abs(num), 0, 1);\n        counter += pflag * current;\n        num -= clamp(prev - current, 0, 1);\n        prev = current;\n    }\n    return counter;\n}\n\nvec4 upperRight(in vec2 uv) {\n    float h = drawLine((uv.x - 0.25) / 0.75 * float(WIDTH));\n    int col = int((uv.x - 0.25) / 0.75 * float(WIDTH));\n    int num = int((uv.y - 0.75) / 0.25 * 6.0);\n    int count = countCol(col, num);\n    uv = vec2((uv.x - 0.25) / 0.75 * 16.0, (uv.y - 0.75) / 0.25 * 6.0);\n    uv = uv - floor(uv);\n    uv.x = clamp((uv.x - 0.5) * 1.1 + 0.5, 0.0, 1.0);\n    float r = 1.0 - float(sign(count)) * number(uv, count);\n    r = min(r, h);\n    return r * BACK + (1.0 - r) * GRID;\n}\n\nfloat middleOfGame(in vec2 uv) {\n    float t = texelFetch(iChannel0, ivec2(uv), 0).x;\n    uv = 2.0 * (uv - floor(uv)) - 1.0;\n    float a = 1.0 * clamp(1.0 - t, 0.0, 1.0);\n    float b = 0.0 * (1.0 - abs(t - 1.0));\n    float c = clamp(abs(abs(uv.x) - abs(uv.y)) / (GRID_THICKNESS * 3.0), 0.0, 1.0);\n    c *= clamp(t - 1.0, 0.0, 1.0);\n    return max(max(a, b), c);\n}\n\nvec4 drawBitmap(in vec2 uv) {\n    ivec2 iuv = ivec2(uv);\n    iuv.y = HEIGHT - 1 - iuv.y;\n    int idx = iuv.y * WIDTH + iuv.x;\n    return PALLET[BITMAP[idx]];\n}\n\nvec4 lowerRight(in vec2 uv) {\n    uv = vec2(uv.x - 0.25, uv.y) / 0.75 * float(WIDTH);\n    float g = drawLine(uv.x);\n    g = min(g, drawLine(uv.y));\n    float r = middleOfGame(uv);\n    vec4 col = min(r * BACK + (1.0 - r) * INK, g * vec4(1) + (1.0 - g) * GRID);\n    float count = clamp(float(countDifference()), 0.0, 1.0);\n    vec4 bitmap = min(drawBitmap(uv), col);\n    bitmap = bitmap * BACK + (1.0 - bitmap) * GRID;\n    return col * count + bitmap * (1.0 - count);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = intoUv(fragCoord, iResolution.xy);\n    if (0.0 <= uv.x && uv.x < 0.25 && 0.75 <= uv.y) {\n        fragColor = upperLeft(uv);\n    } else if (0.0 <= uv.x && uv.x < 0.25 && uv.y < 0.75) {\n        fragColor = lowerLeft(uv);\n    } else if (0.25 <= uv.x && uv.x < 1.0 && 0.75 <= uv.y) {\n        fragColor = upperRight(uv);\n    } else if (0.25 <= uv.x && uv.x < 1.0 && uv.y < 0.75) {\n        fragColor = lowerRight(uv);\n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nbool isKeyDown(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0).x > 0.0;\n}\nconst int Key_Z = 90;\nconst int Key_X = 88;\n\nbool onMousePressed() {\n    float prev = texelFetch(iChannel0, ivec2(0, HEIGHT + 1), 0).z;\n    return prev <= 0.0 && iMouse.z > 0.0;\n}\n\nint countDifference() {\n    int counter = 0;\n    for (int i = 0; i < WIDTH; i++) {\n        for (int j = 0; j < HEIGHT; j++) {\n            int board = int(texelFetch(iChannel0, ivec2(i, j), 0).x * 1.01);\n            board = clamp(1 - abs(board - 1), 0, 1);\n            int bit = BITMAP[(HEIGHT - 1 - j) * WIDTH + i];\n            bit = clamp(1 - abs(bit - 1), 0, 1);\n            counter += abs(bit - board);\n        }\n    }\n    return counter;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        fragColor = vec4(0);\n        return;\n    }\n    int count = countDifference();\n    if (count == 0) {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = 1.0 - abs(1.0 - fragColor);\n        return;\n    }\n    ivec2 ifragCoord = ivec2(fragCoord);\n    if (ifragCoord == ivec2(0, HEIGHT + 1)) {\n        fragColor = iMouse;\n        return;\n    }\n    if (onMousePressed()) {\n        vec2 uv = intoUv(iMouse.xy, iResolution.xy);\n        uv = vec2(uv.x - 0.25, uv.y) / 0.75;\n        uv *= 16.0;\n        if (ifragCoord == ivec2(uv)) {\n            int r = int(texelFetch(iChannel0, ifragCoord, 0).x);\n            if (isKeyDown(Key_X)) {\n                fragColor = vec4(2 * sign(2 - r));\n            } else {\n                fragColor = vec4(abs(1 - r));\n            }\n            return;\n        }\n    }\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// BITMAP reference\n// https://www.spriters-resource.com/nes/supermariobros2supermariousa/\n\nconst int WIDTH = 16;\nconst int HEIGHT = 16;\n\nconst vec4 PALLET[4] = vec4[](\n    vec4(1),\n    vec4(0, 0, 0, 1),\n    vec4(1),\n    vec4(0xf8, 0x38, 0x00, 0xff) / 255.0\n);\n\nconst int BITMAP[WIDTH * HEIGHT] = int[](\n0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,\n1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,\n0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,2,2,1,1,1,1,\n1,1,1,2,2,1,0,0,0,1,2,2,2,1,1,1,1,1,2,2,2,1,0,0,\n0,1,2,2,1,2,1,1,1,2,1,2,2,1,0,0,0,1,1,2,2,2,2,1,\n2,2,2,2,1,1,0,0,0,0,1,1,2,2,2,1,2,2,2,1,1,0,0,0,\n0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,3,3,\n3,1,1,1,1,1,1,1,0,1,1,1,1,1,3,3,3,1,1,1,1,1,1,1,\n0,0,1,1,1,1,1,3,1,1,1,1,1,1,0,0,0,1,3,3,1,1,1,1,\n1,1,1,1,1,0,0,0,1,3,3,3,3,3,1,1,1,1,1,1,1,1,1,0,\n1,3,3,3,3,3,3,1,1,1,1,3,3,3,3,1);\n\nvec2 intoUv(in vec2 fragCoord, in vec2 resolution) {\n    return (fragCoord - resolution / 2.0) / resolution.y + 0.5;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBzd.jpg", "access": "api", "license": "mit", "functions": [[237, 237, 275, 275, 512], [514, 514, 552, 552, 1349], [1351, 1351, 1379, 1379, 1555], [1557, 1557, 1580, 1580, 2000], [2066, 2066, 2094, 2094, 2341], [2343, 2343, 2381, 2381, 2762], [2764, 2764, 2792, 2792, 3262], [3264, 3264, 3302, 3302, 3670], [3672, 3672, 3701, 3701, 4173], [4175, 4175, 4207, 4207, 4538], [4540, 4540, 4569, 4569, 4699], [4701, 4701, 4730, 4730, 5168], [5170, 5170, 5225, 5225, 5710]], "test": "untested"}
{"id": "wlKfzc", "name": "Cave Story Transition", "author": "CelestialAmber", "description": "Port of Cave Story transition shader I made a while ago in Unity to Shadertoy", "tags": ["cavestory"], "likes": 14, "viewed": 888, "published": 3, "date": "1614872902", "time_retrieved": "2024-07-30T19:34:26.355990", "image_code": "\n//The range of time encompassing the animation.\n//fadeTimer (\"Fade Time\",Range(-1.25,2.25)) = 0\nfloat fadeTimer = 0.0;\n#define fadeType 1\nfloat gridWidth = 28.0, gridHeight = 15.0;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = iTime*2.0;\n    \n    fadeTimer = mod(time,3.5) - 1.25;\n    \n    //Inverse the ranges so that the fade in animation is before the fade out animation\n    if(fadeTimer > .5) fadeTimer -= 1.75;\n    else fadeTimer += 1.75;\n    \n    vec4 outcol;\n    //Scale the uvs to integers to scale directly with the equation.\n    vec2 posI =  vec2(uv.x * gridWidth * 2.0,uv.y * gridHeight * 2.0);\n    //modulo the position to clamp it to repeat the pattern.\n    vec2 pos = mod(posI,2.0) - vec2(1.0,1.0);\n    float size;\n    \n    posI = vec2(floor(posI.x/2.0)/gridWidth,floor(posI.y/2.0)/gridHeight); //Floor the values to round them to the value for the square they're in\n    \n    switch(fadeType){\n    case 0: //Vertical Fade\n    size = pow(fadeTimer - posI.y,3.0);\n    break;\n    case 1: //Horizontal Fade\n    size = pow(fadeTimer - posI.x,3.0);\n    break;\n    case 2: //Center Fade\n    size = pow(fadeTimer - (abs(posI.x - 0.5) + abs(posI.y - 0.5)),3.0);\n    break;\n    }\n    \n    //Get absolute value to keep in positive range\n    size = abs(size);\n    \n    outcol = texture(iChannel0,uv);\n    \n    //Absolute value method for expressing the area of a rotatable square.\n    if(abs(pos.x) + abs(pos.y) < size){\n        outcol =  vec4(0,0,0,1);   \n    }\n    \n    fragColor = outcol;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 239, 289, 1616]], "test": "untested"}
{"id": "wlyBRd", "name": "gaziya fractal", "author": "drayde", "description": "\"un-obfuscated\" version of https://twitter.com/gaziya5/status/1366948486671790083\n", "tags": ["fractal"], "likes": 17, "viewed": 361, "published": 3, "date": "1614868490", "time_retrieved": "2024-07-30T19:34:27.300464", "image_code": "// un-obfuscated version of \n// https://twitter.com/gaziya5/status/1366948486671790083\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    o = vec4(0.);\n    vec2 r = iResolution.xy;\n    float g = 0.;\n    \n    for(float i=0.; i<99.; ++i )\n    {\n        vec3 p = vec3(g*(fragCoord.xy-.5*r)/r.y+.4, g-1.);\n        p.xz *= rotate2D(iTime*.3);        \n        \n        float e = 3. / min(dot(p,p),50.);\n        float s = 3. * e;\n        \n        p = abs(p)*e;\n        \n        for(int i; i<5; i++)\n        {\n            p = vec3(2,4,2)- abs(p-vec3(4,4,2));\n            e = 8. / min(dot(p,p),9.);\n            \n            p = abs(p)*e;\n            s*=e;\n        }\n        \n        e = min(length(p.xz)-.1,p.y)/s;\n        g += e;\n        if (e <.001) \n        {\n            o+=.4/i;\n        }\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 111, 111, 163], [164, 164, 200, 200, 379], [381, 381, 430, 430, 1089]], "test": "untested"}
{"id": "tlyfzt", "name": "yonatan fractal", "author": "drayde", "description": "\"un-obfuscated\" version of https://twitter.com/zozuar/status/1367243732764876800", "tags": ["fractal"], "likes": 22, "viewed": 644, "published": 3, "date": "1614864051", "time_retrieved": "2024-07-30T19:34:28.157173", "image_code": "// \"un-obfuscated\" version of \n// https://twitter.com/zozuar/status/1367243732764876800\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    o = vec4(0.);\n    vec2 r = iResolution.xy;\n    float g = 0.;\n    float k = iTime * .1; \n    for (float i = 0.; i < 99.; ++i)\n    {\n        vec3 p = vec3 (g * (fragCoord.xy - .5 * r) / r.y + .5, g - 1.);\n        p.xz *= rotate2D (k);\n        float s = 3.;\n        // fractal levels\n        for (int i=0; i < 9;i++)\n        {\n            float e = max (1., (8. - 8. * cos (k)) / dot (p, p));\n            s *= e;\n            p = vec3 (2, 4, 2) - abs (abs (p) * e - vec3 (4, 4, 2));\n        }\n        g += min (length (p.xz), p.y) / s;\n        s = log (s);\n        o.rgb += hsv (s / 15. + .5, .3, s / 1000.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 112, 112, 164], [165, 165, 201, 201, 380], [382, 382, 431, 431, 1048]], "test": "untested"}
{"id": "tlGfRt", "name": "Skeleton's castle", "author": "Roninkoi", "description": "Experimenting with random SDFs again", "tags": ["raymarching", "blackandwhite", "skeleton", "bone"], "likes": 6, "viewed": 494, "published": 3, "date": "1614856649", "time_retrieved": "2024-07-30T19:34:28.925120", "image_code": "#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.38\n#define STEP 0.1\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define BONE 1.\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a) * 2.0;\n\t\n\tp = p * 0.5 + 0.5 * p * rotX(r.y / 3.);\n\tp = p * 0.5 + 0.5 * p * rotZ(r.y / 3.);\n\tp.z = clamp(p.x * (sin(p.z)-1.0) + p.x * abs(p.y - a.y) * 0.5, -a.z, a.z);\n\tp.y = clamp(p.y + p.z * abs(p.x - a.x) * 0.5, -a.y, a.y);\n\tp.y += p.x * p.z + p.y * sin(p.z * 4.);\n\tp.x += clamp(p.x * p.y, -a.z * 0.5, a.z * 0.5);\n\t\n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n\tfloat tt = t * 2.;\n\tfloat ttt = tt / 2. + sin(tt) / 2.;\n\tobj = rotY(ttt) * rotX(0.6 + cos(tt) * 0.2);\n\tvec3 rb1 = obj * r;\n\trb1.x += 20. * (ttt / 2. / PI) + 10.;\n\t\n\trb1 *= rotX(rb1.z * 0.005);\n\tvec3 rbp1 = mod(rb1+10., 20.) - 10.;\n\t\n\tvec2 b1 = vec2(\n\t\tbox(rbp1, vec3(2., 2., 2.)), BONE\n\t);\n\n    return b1;\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == BONE)\n        return vec3(0.5, 0.5, 0.5);\n    \n    return vec3(0., 0., 0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(1.0, 1.0, 1.0) * 0.4;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n            matCol(d), \n            shade(normalize(r), rd));\n            col.rgb = fog(z * 0.03, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\tcol.rgb *= exp(-sh * 2.0 + 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 317], [320, 320, 340, 340, 444], [447, 447, 467, 467, 569], [583, 583, 614, 614, 642], [645, 645, 674, 674, 748], [751, 751, 788, 788, 816], [818, 818, 850, 850, 952], [954, 954, 974, 974, 1046], [1048, 1048, 1075, 1075, 1452], [1454, 1454, 1484, 1484, 1539], [1542, 1542, 1584, 1584, 1624], [1637, 1637, 1655, 1655, 1968], [1970, 1970, 1991, 1991, 2084]], "test": "untested"}
{"id": "3lGfzd", "name": "Drive The Rover", "author": "dr2", "description": "Knob controls speed and steering; mouseable", "tags": ["interactive", "moon", "mars", "vehicle", "lander"], "likes": 28, "viewed": 505, "published": 3, "date": "1614848821", "time_retrieved": "2024-07-30T19:34:29.877574", "image_code": "// \"Drive The Rover\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 sunDir, qHit, carPos, wlBase;\nvec2 wlRot[2], csArm, csArmA;\nfloat tCur, dstFar, carRot, strRot;\nint idObj;\nconst int idBase = 1, idFuel = 2, idWhl = 3, idLnk = 4, idArm = 5, idPiv = 6, idAxl = 7, idTur = 8,\n   idGrbl = 9, idCam = 10, idCamP = 11, idAnt = 12, idSol = 13;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, bSize;\n  vec2 kRot;\n  float dMin, d, r, a, s, rt, wlRad, armLen;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  bSize = vec3 (0.8, 0.3, 1.6);\n  rt = 0.07;\n  wlRad = wlBase.y;\n  armLen = 1.;\n  dMin = dstFar;\n  p.y -= wlRad;\n  for (float k = float (VAR_ZERO); k < 2.; k ++) {\n    q = p;\n    q.x = abs (q.x) - wlBase.x;\n    if (k == 1.) q.xz = Rot2D (vec2 (q.x, abs (q.z) - wlBase.z), - strRot * sign (p.x));\n    q.y -= 0.85;\n    d = PrCapsDf (q.xzy, rt, 0.15);\n    q.y -= -0.5;\n    d = min (d, max (PrTorusBxDf (q, vec3 (0.25, 0.2, 0.15), rt), q.x));\n    DMINQ (idLnk);\n  }\n  for (float k = float (VAR_ZERO); k < 6.; k ++) {\n    kRot = vec2 (2. * mod (k, 2.), floor (k / 2.)) - 1.;\n    q = p;\n    q.xz -= kRot.xy * wlBase.xz;\n    if (kRot.y != 0.) q.xz = Rot2D (q.xz, - strRot * kRot.y);\n    r = length (q.yz);\n    d = length (max (vec2 (r - wlRad, abs (q.x) - 0.15) - 0.1, 0.));\n    if (d < 0.1) {\n      d = max (length (max (vec2 (r - wlRad, abs (q.x) - 0.15), 0.)) - 0.05, wlRad - 0.02 - r);\n      q.yz = (kRot.y != 1.) ? Rot2D (q.yz, - ((kRot.x < 0.) ? wlRot[0].x : wlRot[0].y)) :\n         Rot2D (q.yz, - ((kRot.x < 0.) ? wlRot[1].x : wlRot[1].y));\n      a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n      d = max (d, 0.03 - length (Rot2D (q.yz, 2. * pi * floor (28. * a + 0.5) / 28.) + vec2 (wlRad + 0.05, 0.)));\n      d = min (d, max (abs (r - wlRad + 0.04) - 0.02, abs (q.x) - 0.04));\n      q.yz = Rot2D (q.yz, 2. * pi * floor (7. * a + 0.5) / 7.);\n      d = min (d, max (PrTorusBxDf (q - vec3 (0., -0.31, 0.), vec3 (0.08, 0.05, 0.1), 0.02), - q.x * kRot.x));\n      d = min (d, max (r - 0.18, abs (q.x) - 0.2));\n      DMINQ (idWhl);\n    } else dMin = min (dMin, d);\n  }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (wlBase.x, 1., -1.);\n  d = PrRoundCylDf (q.yzx, 0.1, 0.02, 0.1);\n  DMINQ (idAxl);\n  d = PrCapsDf (q, rt, 1.);\n  q.z -= 1.5;\n  d = min (d, max (PrTorusBxDf (q.yzx, vec3 (0.05, 1.1, 0.4), rt), - q.y));\n  DMINQ (idLnk);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (wlBase.xz, 0.85).xzy;\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.04);\n  DMINQ (idGrbl);\n  q = p;\n  q.y -= 1.45;\n  d = PrCylDf (q.yzx, 0.1, wlBase.x);\n  q.x = abs (abs (q.x) - wlBase.x + 0.3) - 0.3;\n  d = min (d, PrRoundCylDf (q.yzx, 0.1, 0.02, 0.1));\n  DMINQ (idAxl);\n  q = p;\n  q.y -= 1.5;\n  d = PrRoundBoxDf (q, bSize, 0.02);\n  DMINQ (idBase);\n  qq = abs (q) - vec3 (0.35, 0.22, 0.8);\n  d = min (min (PrTorusBxDf (vec3 (q.yz, qq.x), vec3 (bSize.yz, 0.03), 0.03),\n     PrTorusBxDf (vec3 (q.xz, qq.y), vec3 (bSize.xz, 0.03), 0.03)),\n     PrTorusBxDf (vec3 (q.xy, qq.z), vec3 (bSize.xy, 0.03), 0.03));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.85, -1.6);\n  d = PrRoundCylDf (q.yzx, 0.3, 0.1, 0.6);\n  DMINQ (idFuel);\n  d = PrTorusBxDf (q.xzy, vec3 (0.6, 0.3, 0.1), 0.03);\n  DMIN (idGrbl);\n  q = p;\n  q.x = abs (abs (q.x) - 0.18);\n  d = PrCapsDf (q - vec3 (0.05, 1.16, bSize.z), 0.04, 0.1);\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.75, 1.8);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.05, 0.2), 0.02);\n  DMIN (idGrbl);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - 0.85));\n  q -= vec3 (0.55, 1.8, 0.25);\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.1);\n  q.y -= 0.1;\n  d = min (d, PrSphDf (q, 0.05));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.8, 1.1);\n  d = PrRoundBoxDf (q, vec3 (0.2, 0.1, 0.2), 0.02);\n  q.xz = abs (q.xz);\n  d = min (d, PrSphDf (q - vec3 (0.1, 0.12, 0.1), 0.05));\n  DMIN (idGrbl);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z + 0.1)) - vec2 (0.65, 0.3);\n  q.y -= 1.85;\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.02);\n  DMIN (idGrbl);\n  q = p;\n  q.y -= 2.02;\n  d = PrRoundCylDf (q.xzy, 0.3, 0.02, 0.2);\n  DMINQ (idTur);\n  q.y -= 0.4;\n  d = PrRoundCylDf (q.xzy, 0.22, 0.02, 0.2);\n  DMINQ (idTur);\n  q = p;\n  q.y -= 2.6;\n  d = PrCapsDf (q.yzx, 0.03, 0.6);\n  DMIN (idGrbl);\n  q.x = abs (q.x) - 0.46;\n  q.yz = Rot2D (q.yz, -0.2 * pi);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.01, 0.25), 0.01);\n  DMINQ (idSol);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - 0.3));\n  q -= vec3 (0.75, 1.8, 1.2);\n  d = PrCapsDf (q.xzy, 0.05, 0.2);\n  DMIN (idGrbl);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.78, 2.25, -0.9);\n  q.xy = Rot2D (q.xy, 0.1 * pi);\n  d = max (abs (PrSphDf (q, 0.25)) - 0.01, q.y + 0.05);\n  DMINQ (idAnt);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.75, 2., 1.55);\n  q.yz = Rot2D (q.yz, -0.05 * pi);\n  d = PrCapsDf (q, 0.1, 0.1);\n  DMINQ (idCam);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (bSize.xz, 1.2).xzy;\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idCam);\n  q = p;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idCam);\n  q = p;\n  q.y -= 3.;\n  d = PrCylDf (q.xzy, 0.05, 0.8);\n  DMIN (idGrbl);\n  q.y -= 0.8;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.02, 0.08);\n  DMINQ (idCamP);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 1.2, 1.7);\n  d = PrCapsDf (q, 0.03, 0.2);\n  q.z -= 0.2;\n  d = min (d, PrCapsDf (q.xzy, 0.02, 0.3));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.85, 1.9);\n  d = PrRoundCylDf (q.xzy, 0.05, 0.02, 0.05);\n  q.y -= 0.15;\n  q.yz = Rot2Cs (q.yz, csArmA) - 2. * armLen * csArm.yx;\n  q.z = abs (q.z);\n  q.yz -= 2. * armLen * (csArm * vec2 (1., -1.)).yx;\n  q.yz = Rot2Cs (q.yz, csArm * vec2 (1., -1.));\n  q.z -= - armLen;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.03, 0.04, armLen), 0.02));\n  DMINQ (idArm);\n  q.z = abs (q.z) - armLen;\n  d = PrRoundCylDf (q.yzx, 0.1, 0.02, 0.08);\n  DMINQ (idPiv);\n  q = p;\n  q.yz -= vec2 (1.85, 2.) + Rot2Cs (vec2 (0., 4. * armLen * csArm.x), csArmA * vec2 (1., -1.));\n  d = PrRoundCylDf (q.xzy, 0.2, 0.02, 0.05);\n  q.z = abs (q.z);\n  q.yz -= vec2 (-0.1, 0.1);\n  d = min (d, PrCapsDf (q.xzy, 0.02, 0.05));\n  DMIN (idGrbl);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec3 col;\n  float a, r;\n  if (idObj == idCamP || idObj == idTur || idObj == idAnt) a = atan (qHit.x, qHit.z) / (2. * pi);\n  if (idObj == idWhl || idObj == idAxl || idObj == idPiv || idObj == idFuel) r = length (qHit.yz);\n  else if (idObj == idCamP || idObj == idTur) r = length (qHit.xz);\n  if (idObj <= idPiv) {\n    if (idObj == idBase) col = vec3 (1., 1., 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (PrRoundBox2Df (vec2 (qHit.y, abs (abs (qHit.z) - 0.8) - 0.4), vec2 (0.05, 0.15), 0.05))));\n    else if (idObj == idFuel) col = vec3 (0.8, 0.85, 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (PrRoundBox2Df (qHit.xz, vec2 (0.3, 0.1), 0.02) - 0.1))) *\n       (0.8 + 0.2 * smoothstep (0., 0.02, abs (abs (r - 0.23) - 0.03)));\n    else if (idObj == idWhl) col = (r > 0.13) ? vec3 (0.95, 0.95, 1.) * (1. - 0.3 * step (0.47, r)) :\n       vec3 (1., 0.5, 0.) * (0.3 + 0.7 * smoothstep (0., 0.02, r - 0.05));\n    else if (idObj == idLnk) col = vec3 (0.9, 0.9, 1.);\n    else if (idObj == idArm) col = vec3 (0.9, 1., 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (mod (qHit.z + 0.1, 0.2) - 0.1)));\n    else if (idObj == idPiv) col = vec3 (0.8, 0.9, 0.9) * (0.5 + 0.5 * smoothstep (0., 0.01,\n       min (abs (abs (qHit.x) - 0.04), r - 0.02) - 0.01));\n  } else {\n    if (idObj == idAxl) col = vec3 (0.9, 0.95, 0.9) * (0.5 + 0.5 * smoothstep (0., 0.02,\n       abs (r - 0.07) - 0.01)) * (0.5 + 0.5 * smoothstep (0., 0.01, abs (abs (qHit.x) - 0.06) - 0.01));\n    else if (idObj == idTur) col = vec3 (0.9, 0.95, 0.9) * (1. - 0.3 * smoothstep (0., 0.02,\n       0.05 - abs (abs (qHit.y) - 0.1)) *  smoothstep (0., 0.02, abs (mod (8. * a + 0.5, 1.) - 0.5) - 0.35)) *\n       (0.8 + 0.2 * smoothstep (0., 0.02, abs (r - 0.15) - 0.01));\n    else if (idObj == idGrbl) col = vec3 (0.9, 0.9, 0.8);\n    else if (idObj == idCam) col = mix (vec3 (0.2), vec3 (0.9, 0.3, 0.3), (1. - step (0., qHit.z) *\n       smoothstep (0., 0.01, 0.1 - length (qHit.xy))));\n    else if (idObj == idCamP) col = mix (vec3 (0.2), vec3 (0.9, 0.3, 0.3), smoothstep (0., 0.02,\n       length (vec2 (Rot2D (qHit.xz, 2. * pi * (floor (8. * a + 0.5) / 8.)).x, qHit.y)) - 0.05)) *\n       (0.7 + 0.3 * smoothstep (0., 0.02, abs (r - 0.15) - 0.01));\n    else if (idObj == idAnt) col = vec3 (0.5, 0.9, 0.5) * (1. - 0.3 * smoothstep (0., 0.02,\n       abs (mod (16. * a + 0.5, 1.) - 0.5) - 0.35));\n    else if (idObj == idSol) col = (qHit.y > 0.) ? vec3 (0.9, 0.9, 0.3) : vec3 (0.8, 0.8, 0.7);\n  }\n  return vec4 (col, 0.1);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (8. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.4, 0.3, 0.3);\n  } else {\n    q = 0.005 * (ro.xz + 2. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.2, 0.3, 0.3) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = vec3 (1., 0.8, 0.8) * mix (vec3 (0.6, 0.4, 0.4), clCol,\n       0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, armAng, sh, f;\n  bool isBg;\n  armAng = pi * (0.2 + 0.15 * sin (0.2 * pi * tCur));\n  csArm = sin (armAng + vec2 (0.5 * pi, 0.));\n  csArmA = sin (-0.2 * pi + 0.5 * armAng + vec2 (0.5 * pi, 0.));\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = vec4 (0.4 * mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5),\n       smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz))), 0.);\n    vn = vec3 (0., 1., 0.);\n    f = 1. - smoothstep (0.2, 0.5, dstGrnd / dstFar);\n    if (f > 0.) vn = VaryNf (4. * ro, RippleNorm (ro.xz, vn, 4. * f), f);\n  } else {\n    isBg = true;\n    col = SkyBgCol (ro, rd);\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step(0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (dstObj >= dstFar && rd.y < 0.) col = mix (col, vec3 (0.4, 0.3, 0.3), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col, wgBox;\n  vec2 canvas, uv, ud, cnPos;\n  float el, az, asp, zmFac, s, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  stDat = Loadv4 (2);\n  strRot = stDat.y;\n  stDat = Loadv4 (3);\n  wlRot[0] = stDat.xy;\n  wlRot[1] = stDat.zw;\n  stDat = Loadv4 (4);\n  az = stDat.x;\n  el = stDat.y;\n  cnPos = stDat.zw;\n  el = clamp (el, -0.45 * pi, 0.);\n  vuMat = StdVuMat (el, az);\n  ro = carPos + vuMat * vec3 (0., 1.8, -12.);\n  zmFac = 4. + 2. * el;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  wgBox = vec3 (0.39, -0.3, 0.135);\n  ud = 0.5 * uv - wgBox.xy * vec2 (asp, 1.);\n  s = (length (ud) - wgBox.z) * canvas.y;\n  col = mix (vec3 (0.5), col, smoothstep (0., 1., abs (s) - 1.));\n  if (s < 0.) {\n    col = mix (vec3 (0.5), col, step (1., Minv2 (abs (ud)) * canvas.y));\n    col = mix (vec3 (0., 1., 0.), col, smoothstep (2., 2.3, abs (length (ud - cnPos) * canvas.y - 10.)));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Drive The Rover\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 carPos, wlBase;\nfloat carRot;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBox;\n  vec2 iFrag, canvas, cnPos, wlRot[2], ud, w, wr[2];\n  float tCur, autoMd, cRotN, strRot, wlRad, rTurn[2], spd, tc, nStep, az, el, asp, s;\n  int pxId, wgSel;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 6) discard;\n  init = (iFrame <= 5);\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlBase = vec3 (1.4, 0.5, 2.);\n    wlRot[0] = vec2 (0.);\n    wlRot[1] = vec2 (0.);\n    az = 0.8 * pi;\n    el = -0.05 * pi;\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    mPtrP = mPtr;\n    wgSel = 0;\n    autoMd = 1.;\n  } else {\n    stDat = Loadv4 (0);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    stDat = Loadv4 (2);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    autoMd = stDat.z;\n    stDat = Loadv4 (3);\n    wlRot[0] = stDat.xy;\n    wlRot[1] = stDat.zw;\n    stDat = Loadv4 (4);\n    az = stDat.x;\n    el = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (5);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n  }\n  wgBox = vec3 (0.39, -0.3, 0.135);\n  if (mPtr.z > 0.) {\n    if (wgSel == 0 && mPtrP.z > 0.) {\n      az = -2. * pi * mPtr.x;\n      el = - pi * mPtr.y;\n    } else {\n      ud = mPtr.xy * vec2 (asp, 1.) - wgBox.xy * vec2 (asp, 1.);\n      if (wgSel == 1) {\n        autoMd = - tCur;\n        cnPos = ud;\n        s = length (cnPos);\n        if (s > 0.) cnPos = min (s, wgBox.z) * cnPos / s;\n      } else if (mPtrP.z <= 0. && length (ud) < wgBox.z) wgSel = 1;\n    }\n  } else {\n    wgSel = 0;\n    cnPos *= 1. - 5e-3;\n  }\n  wlRad = wlBase.y;\n  ++ nStep;\n  if (autoMd > 0.) {\n    tc = mod (0.003 * nStep, 4.);\n    strRot = 0.15 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n       sign (tc - 2.);\n    spd = 0.2 * (0.1 - 0.06 * abs (strRot / (0.12 * pi)));\n    w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n    w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n    cnPos = w * wgBox.z;\n  } else {\n    w = cnPos / wgBox.z;\n    w = pow (abs (w), vec2 (1.5)) * sign (w);\n    strRot = -0.15 * pi * w.x;\n    spd = 0.1 * w.y;\n    if (tCur + autoMd > 10.) autoMd = 1.;\n  }\n  wr[0] = vec2 (1.);\n  wr[1] = wr[0];\n  if (abs (strRot) > 1e-4) {\n    cRotN = carRot - strRot * spd / pi;\n    rTurn[0] = wlBase.z / asin (strRot);\n    rTurn[1] = rTurn[0] * sqrt (1. - (wlBase.z / rTurn[0]) * (wlBase.z / rTurn[0]));\n    carPos.xz += 2. *rTurn[0] * (sin (carRot - vec2 (0.5 * pi, 0.)) -\n       sin (cRotN - vec2 (0.5 * pi, 0.)));\n    carRot = cRotN;\n    wr[0] += vec2 (-1., 1.) * wlBase.x / rTurn[0];\n    wr[1] += vec2 (-1., 1.) * wlBase.x / rTurn[1];\n  } else {\n    carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n  }\n  wlRot[0] += wr[0] * spd / wlRad;\n  wlRot[1] += wr[1] * spd / wlRad;\n  if      (pxId == 0) stDat = vec4 (carPos, carRot);\n  else if (pxId == 1) stDat = vec4 (wlBase, 0.);\n  else if (pxId == 2) stDat = vec4 (nStep, strRot, autoMd, 0.);\n  else if (pxId == 3) stDat = vec4 (wlRot[0], wlRot[1]);\n  else if (pxId == 4) stDat = vec4 (az, el, cnPos);\n  else if (pxId == 5) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfzd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1154, 1154, 6773], [6775, 6775, 6808, 6808, 6992], [6994, 6994, 7015, 7015, 7270], [7272, 7272, 7309, 7309, 7552], [7554, 7554, 7570, 7570, 10061], [10063, 10063, 10088, 10088, 10507], [10509, 10509, 10553, 10553, 10742], [10744, 10744, 10778, 10778, 11396], [11398, 11398, 11433, 11433, 12650], [12694, 12694, 12750, 12750, 14343], [14345, 14345, 14391, 14391, 14438], [14440, 14440, 14487, 14487, 14534], [14536, 14536, 14569, 14569, 14596], [14598, 14598, 14640, 14640, 14691], [14693, 14693, 14750, 14750, 14826], [14828, 14828, 14871, 14871, 14944], [14946, 14946, 14992, 14992, 15073], [15075, 15075, 15097, 15097, 15124], [15126, 15126, 15162, 15162, 15368], [15370, 15370, 15400, 15400, 15513], [15515, 15515, 15546, 15546, 15610], [15644, 15644, 15668, 15668, 15721], [15723, 15723, 15747, 15747, 15877], [15879, 15879, 15904, 15904, 16050], [16052, 16052, 16077, 16077, 16263], [16265, 16265, 16287, 16287, 16441], [16443, 16443, 16464, 16464, 16619], [16621, 16621, 16650, 16650, 16862], [16864, 16864, 16903, 16903, 17083], [17177, 17177, 17202, 17202, 17325]], "test": "untested"}
{"id": "WtVfRc", "name": "Doom Fire PSX", "author": "gwiazdorrr", "description": "Doom Fire, based on https://fabiensanglard.net/doom_fire_psx/index.html.", "tags": ["fire", "doom"], "likes": 3, "viewed": 557, "published": 3, "date": "1614848271", "time_retrieved": "2024-07-30T19:34:30.863936", "image_code": "#define FIRE_WIDTH 320.0\n#define FIRE_HEIGHT 160.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= FIRE_WIDTH;\n    uv.y *= FIRE_HEIGHT;\n    int index = int(texelFetch(iChannel0, ivec2(uv), 0).r);\n    fragColor = colors[index];\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FPS 20.0\n#define WIND_STRENGTH 4\n#define WIND_START_OFFSET -1\n#define DURATION_ON 10.0\n#define DURATION_OFF 5.0\n\n#define M_PI 3.1415926535897932384626433832795\n\n// https://www.shadertoy.com/view/tdXXRM\nfloat noise(vec2 p, float t) {\n    float ta = t*.654321;\n    float tb = t*(ta*.123456);\n    return fract(sin(mod(p.x*ta+p.y*tb, M_PI))*5678.);\n}\n\nint sampleFire(vec2 coords) {\n    return int(texelFetch(iChannel0, ivec2(coords), 0).r);\n}\n\nint spreadFire(vec2 coords, float t) {\n\n    // how likely it is that the value stays the same?\n    // the tutorial does this from the perspective of a source fire state; source\n    // state can affect one of four pixels above, so a chance of a pixel being unaffected\n    // is (3/4)^4\n    float copyChance = pow(float(WIND_STRENGTH-1)/float(WIND_STRENGTH), float(WIND_STRENGTH));\n    \n    float rand = noise(coords, t);\n    int state;\n    if (rand < copyChance) {\n        // value unchanged\n        state = sampleFire(coords);\n    } else {\n        // normalize the random\n        float r = (rand - copyChance) / (1.0 - copyChance);\n        // pick source index\n        float offset = r * float(WIND_STRENGTH) + float(WIND_START_OFFSET);\n        // sample from the row below with a horizontal offset\n        state = sampleFire(coords + vec2(floor(offset), -1.0));\n        // wind down (50% chance)\n        if (fract(offset) > 0.5) {\n            state -= 1;\n        }\n    }\n    return state;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int result;// = sampleFire(fragCoord);\n    float t = iTime;\n    \n#ifdef FPS\n    t *= FPS;\n    float previousT = (iTime - iTimeDelta) * FPS;\n    if (fract(t) > fract(previousT)) {\n        // the same frame, don't update\n        result = sampleFire(fragCoord);\n    }\n    else\n#endif    \n    {\n        if (fragCoord.y < 1.0) {\n            // toggle bottom row on and off\n            if (mod(iTime, DURATION_ON + DURATION_OFF) < DURATION_ON) {\n                result = colors.length() - 1;\n            } else {\n                result = 0;\n            }\n        } else {\n            result = spreadFire(fragCoord, t);\n        }\n    }\n        \n    fragColor.r = float(result);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RGB(x) vec4(float((x >> 16) & 0xFF) / 255.0, float((x >> 8) & 0xFF) / 255.0, float(x & 0xFF) / 255.0, 1.0)\n\nvec4 colors[] = vec4[](\n    RGB(0x070707),\n    RGB(0x1f0707),\n    RGB(0x2f0f07),\n    RGB(0x470f07),\n    RGB(0x571707),\n    RGB(0x671f07),\n    RGB(0x771f07),\n    RGB(0x8f2707),\n    RGB(0x9f2f07),\n    RGB(0xaf3f07),\n    RGB(0xbf4707),\n    RGB(0xc74707),\n    RGB(0xDF4F07),\n    RGB(0xDF5707),\n    RGB(0xDF5707),\n    RGB(0xD75F07),\n    RGB(0xD7670F),\n    RGB(0xcf6f0f),\n    RGB(0xcf770f),\n    RGB(0xcf7f0f),\n    RGB(0xCF8717),\n    RGB(0xC78717),\n    RGB(0xC78F17),\n    RGB(0xC7971F),\n    RGB(0xBF9F1F),\n    RGB(0xBF9F1F),\n    RGB(0xBFA727),\n    RGB(0xBFA727),\n    RGB(0xBFAF2F),\n    RGB(0xB7AF2F),\n    RGB(0xB7B72F),\n    RGB(0xB7B737),\n    RGB(0xCFCF6F),\n    RGB(0xDFDF9F),\n    RGB(0xEFEFC7),\n    RGB(0xFFFFFF)\n);\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 109, 109, 291]], "test": "untested"}
{"id": "WlyBzd", "name": "GLSL short circuiting test", "author": "morisil", "description": "Are there any performance benefits of choosing style 2 over style 1 in terms of parallelization and branching?", "tags": ["test", "shortcircuiting"], "likes": 0, "viewed": 383, "published": 3, "date": "1614847215", "time_retrieved": "2024-07-30T19:34:31.646843", "image_code": "// Are there any performance benefits of choosing style 2 over style 1\n// in terms of parallelization and branching?\n\nconst float ZERO_NON_ZERO_DURATION = 2.;\nconst int ITERATION_COUNT = 1000;\n\nvec3 doSomethingExpensive1(in vec2 uv) {\n    vec4 color;\n    for (int i = 0; i < ITERATION_COUNT; i++) {\n        color += texture(iChannel0, uv);\n    }\n    return color.rgb;\n}\n\nbool doSomethingExpensive2(in vec2 uv, in float coefficient, out vec3 outColor) {\n    vec4 color;\n    for (int i = 0; i < ITERATION_COUNT; i++) {\n        color += texture(iChannel0, uv);\n    }\n    outColor += coefficient * color.rgb;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    // in my use case it would be uniform\n    float coefficient = floor(mod(iTime / ZERO_NON_ZERO_DURATION, 2.));\n    vec3 color = vec3(0);\n    // style 1\n    if (coefficient != 0.) {\n        color += coefficient * doSomethingExpensive1(uv);\n    }\n    // style 2\n    (coefficient != 0.) && (doSomethingExpensive2(uv, coefficient, color));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 234, 234, 369], [371, 371, 452, 452, 623], [625, 625, 682, 682, 1097]], "test": "untested"}
{"id": "Wl3fWX", "name": "Van Damme - Distance", "author": "Flyguy", "description": "Testing out using the cube map buffer to pipeline jump flooding steps.", "tags": ["sdf", "cubemap", "distance", "realtime", "flood", "jfa"], "likes": 60, "viewed": 1628, "published": 3, "date": "1614842785", "time_retrieved": "2024-07-30T19:34:32.596304", "image_code": "#define INPUT 0\n#define STENCIL 1\n#define OUTLINE 2\n#define DISTANCE 3\n#define NORMAL 4\n#define NEON 5\n\n#define VIEW_MODE DISTANCE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ps = 1.0/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    #if(VIEW_MODE == INPUT)\n        col = texture(iChannel1, uv, 0.0).aaa;\n        \n    #elif(VIEW_MODE == STENCIL)\n        col = textureCubeFace(iChannel0, 0.0, uv).xxx;\n        \n    #elif(VIEW_MODE == OUTLINE)\n        col = vec3(abs(textureCubeFace(iChannel0, 0.0, uv).x)/1e5);\n        \n    #elif(VIEW_MODE == DISTANCE)\n        float dist = textureCubeFace(iChannel0, 5.0, uv).z;\n        col = mix(vec3(0.3,0.5,1),vec3(1,0.7,0.3),step(0.,dist)); //Color based on sign (-/+)\n        col *= 0.9+0.1*(-cos(dist*300.0)); //Isolines\n        col *= smoothstep(ps,3.0*ps,abs(dist)); //Outline\n        col *= 1.0/(1.0+abs(dist)*15.); //Fade out\n        \n    #elif(VIEW_MODE == NORMAL)\n        col.xy = 0.5+0.5*textureCubeFace(iChannel0, 5.0, uv).xy;\n        \n     #elif(VIEW_MODE == NEON)\n        float dist = textureCubeFace(iChannel0, 5.0, uv).z;\n        col += vec3(0.1,0.1,1.0)/(abs(dist)*100.0);\n        col += vec3(0.1,0.5,0.1)/(abs(dist-0.1)*100.0);\n        col += vec3(0.5,0.1,0.1)/(abs(dist-0.2)*100.0);\n        \n    #endif\n    \n    fragColor = vec4(col, 1); \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//Utilizes the cubemap buffer as 6 1024x1024 buffers, 2 passes per face.\n//Jump floods a 1-pixel wide outline of the stencil.\n//Initializes non-outline pixels as vec2(+/-maxDist) to store the sign.\n//The JFA function leaves the sign unchanged through each step.\n//The sign is then re-applied to the calculated distance at the end.\n\nconst float cubeRes = 1024.0; // X/Y Resolution of each cubemap face. \nconst float maxSteps = 10.;// Max# of JFA steps\nconst float maxDist = 1e5;// Max distance \n\n//Coordinate pairs for the JFA function.\n#define XY 0\n#define ZW 1\n\n//Outputs the stencil (x) and 1 pixel wide outline (y)\nvec2 outline(vec2 uv, vec2 pixelSize)\n{\n    float center = step(0.0, texture(iChannel0, uv, 0.0).a);\n    \n    vec4 neighbors = vec4(\n        texture(iChannel0, uv + pixelSize*vec2( 0, 1), 0.0).a,\n        texture(iChannel0, uv + pixelSize*vec2( 0,-1), 0.0).a,\n        texture(iChannel0, uv + pixelSize*vec2(-1, 0), 0.0).a,\n        texture(iChannel0, uv + pixelSize*vec2( 1, 0), 0.0).a\n    );\n    neighbors = step(0.0, neighbors); \n    \n    return vec2(center, min(1.0, center*dot(1.0-neighbors, vec4(1))));\n}\n\n//Jump flooding algorithim on a cubemap face.\n//buf -------> cubemap buffer to sample\n//uv --------> current uv coords\n//aspect ----> aspect ratio correction\n//jfaStep ---> current step\n//cubeFace --> cubemap face to sample\n//coordPair -> coordinate pair to sample (XY or ZW)\nvec2 JFA(samplerCube buf, vec2 uv, vec2 aspect, float jfaStep, float cubeFace, int coordPair)\n{\n    float nearestDist = maxDist;\n    float stepSize = exp2(maxSteps - jfaStep)/cubeRes;\n\n    vec4 nearestCoord = textureCubeFace(buf, cubeFace, uv);\n    nearestCoord.xy = (coordPair == ZW) ? nearestCoord.zw : nearestCoord.xy;\n    \n    float sdfSign = sign(nearestCoord.x);\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            vec2 curUV = uv + vec2(i,j) * stepSize;\n            \n            vec4 curCoord = abs(textureCubeFace(buf, cubeFace, curUV));\n            \n            curCoord.xy = (coordPair == ZW) ? curCoord.zw : curCoord.xy;\n            \n            float curDist = length(curCoord.xy - vec2(uv*aspect));\n            \n            if(curCoord.xy != vec2(0) && curDist < nearestDist)\n            {\n                nearestCoord.xy = curCoord.xy;\n                nearestDist = curDist;\n            }\n        }\n    }\n    \n    return abs(nearestCoord.xy)*sdfSign;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 face = rayToFace(rd);\n    vec2 uv = face.xy;\n    vec2 aspect = vec2(textureSize(iChannel0,0));\n    aspect = aspect / aspect.y;\n    \n    vec4 cout = vec4(0);\n    \n    cout.xy = JFA(iChannel1, uv, aspect, face.z*2.0, face.z-1.0, ZW);\n    \n    if(face.z == 0.0) //Initialize XY with stencil/outline on face 0.\n    {\n        vec2 edge = outline(uv, vec2(1.0/cubeRes));\n        cout.xy = vec2(uv*aspect)*edge.y; //outline\n        cout.xy = (edge.y == 0.0) ? vec2(maxDist*(2.0*edge.x-1.0)) : cout.xy; //sign\n    }\n    \n    cout.zw = JFA(iChannel1, uv, aspect, face.z*2.0+1.0, face.z, XY);\n    \n    //Calculate the signed distance and normals.\n    if(face.z == 5.0) \n    {\n        vec2 coord = cout.xy;\n        cout.xy = normalize(uv*aspect - abs(coord));\n        cout.z = distance(uv*aspect, abs(coord)) * sign(coord.x);\n        cout.w = 0.0;\n    }\n    \n\n    // Output to cubemap\n    fragColor = vec4(cout);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Converts a ray direction to uv coords (xy, normalized) & a face id (z, 0-5).\n//for the cubemap face it's pointing to.\nvec3 rayToFace(vec3 rd)\n{\n    vec3 asign = sign(rd);\n    rd = abs(rd);\n    float amax = max(max(rd.x,rd.y),rd.z);\n    \n    vec3 face = (rd.x == amax) ? vec3(asign.yz*rd.yz, floor(1.+.5*asign.x)) :\n                (rd.y == amax) ? vec3(asign.xz*rd.xz, floor(3.+.5*asign.y)) :\n                (rd.z == amax) ? vec3(asign.xy*rd.xy, floor(5.+.5*asign.z)) : \n                                 vec3(0,0,-1);\n    face.xy = .5+.5*(face.xy/amax);\n    return face;\n}\n\n//opposite of rayToFace\n//Converts normalized uv coords & a face id to a ray direction\n//for cubemap sampling\nvec3 faceToRay(vec3 face)\n{\n    face.xy = 2.*fract(face.xy)-1.;\n    vec3 rd = (face.z == 0.) ? vec3(-1,face.x,face.y) :\n              (face.z == 1.) ? vec3( 1,face.x,face.y) :\n              (face.z == 2.) ? vec3(face.x,-1,face.y) :\n              (face.z == 3.) ? vec3(face.x, 1,face.y) :\n              (face.z == 4.) ? vec3(face.x,face.y,-1) :\n              (face.z == 5.) ? vec3(face.x,face.y, 1) :\n                               vec3(0);\n    return normalize(rd);\n}\n\n//Sample a cubemap face (0-5) with normalized uv coords.\nvec4 textureCubeFace(samplerCube cube, float face, vec2 uv)\n{\n    vec3 rd = faceToRay(vec3(uv,floor(face)));\n    return texture(cube, rd, 0.0).rgba;  \n}\n\n\n", "buffer_a_code": "//Input image, stencil is generated from the alpha channel.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv,0.0).rgb;\n    \n    float d = clamp(3.0*(col.g-max(col.r,col.b)),0.0,1.0);\n\n    fragColor = vec4(col.rgb, d-0.8);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 189, 189, 1362]], "test": "untested"}
{"id": "WtGfzt", "name": "Domino Clock (WIP)", "author": "foxic", "description": "A Domino Clock design I came up with.\n\nFirst domino is the hours, Second one is the upper digits on the minutes and Third is the lower digits of the minutes.\n\nNeeds work on animations and time keeping, if anyone has any suggestions please leave a comment.", "tags": ["time", "clock", "domino"], "likes": 3, "viewed": 234, "published": 3, "date": "1614834193", "time_retrieved": "2024-07-30T19:34:33.653478", "image_code": "#define domino_scale     .3\n#define domino_dot_scale .25\n#define domino_roundness .05\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat domino_dot( in vec2 p, in float scale, in float amount ){\n    float d = 1.;\n    d =      sdCircle( p+vec2(0.,0.125*domino_scale), scale*domino_scale );\n    d = max( sdCircle( p,                             scale*domino_scale ), -abs(d) );\n    return mix(1.,d,amount);\n}\nint domino_get_face( in int face ){\n    // let me know if there is a better way to do this in a shader (something like an array would be perfect)\n    if (face == 1){\n        return 16;\n    } else if (face == 2){\n        return 68;\n    } else if (face == 3){\n        return 84;\n    } else if (face == 4){\n        return 341;\n    } else if (face == 5){\n        return 341;\n    } else if (face == 6){\n        return 455;\n    }\n}\nfloat domino_dot_face( in vec2 p, in int face, in int face_next, in float seconds ){\n    float d = 1.;\n    \n    int i = 0;\n    int data      = domino_get_face( face      );\n    int data_next = domino_get_face( face_next );\n    for( int x=-1; x < 2; x++ ){\n        for( int y=-1; y < 2; y++ ){\n            vec2 offset = vec2(x,y)*domino_scale*0.6;\n            float is_on   = float( ((data      >> i)&1) == 1 );\n            float is_next = float( ((data_next >> i)&1) == 1 );\n            \n            is_on = mix( is_next, is_on, seconds ); // need to work out animation probblems (Commented this out if you want to try it.)\n            d = min( domino_dot( p+offset, domino_dot_scale, is_on), d );\n            i++;\n        }\n    }\n    return d;\n}\n\nfloat domino( in vec2 p, in float value, in float value_next, in float seconds ){\n    float d = 1.;\n    float temp = 1.;\n    \n    // base\n    temp = sdRoundedBox(   p+vec2(0.,0.1), vec2(1, 2)*domino_scale, vec4(domino_roundness) );\n    d = min( sdRoundedBox( p,              vec2(1, 2)*domino_scale, vec4(domino_roundness) ), abs(temp) );\n    \n    \n    int upper_face      = int(floor(value/2.));\n    int lower_face      = int(ceil( value/2.));\n    \n    int upper_face_next = int(floor(value_next/2.));\n    int lower_face_next = int(ceil( value_next/2.));\n    \n    d = max( -domino_dot_face( p-vec2(0.,domino_scale), upper_face, upper_face_next, seconds ), d);\n    d = max( -domino_dot_face( p+vec2(0.,domino_scale), lower_face, lower_face_next, seconds ), d);\n    \n    return d;\n}\n\nfloat domino_clock( in vec2 p, in int num, in float time ){\n    \n    float seconds = fract(time);\n    if (num == 0){ // hours\n        float hour      = floor(mod(  time    /3600.0, 24.0 ));\n        float hour_next = floor(mod( (time+1.)/3600.0, 24.0 ));\n        return domino( p, float(mod(hour,     10.)), float(mod(hour_next, 10.)), seconds );\n        \n    } else if (num == 1){ // minnets (higher)\n        float mins      = mod(  time    /60.0, 60.0 );\n        float mins_next = mod( (time+1.)/60.0, 60.0 );\n        return domino( p, float(mod(mins/10., 10.)), float(mod(mins_next/10., 10.)), seconds );\n        \n    } else if (num == 2){ // minnets (lower)\n        float mins      = mod(  time    /60.0, 60.0 );\n        float mins_next = mod( (time+1.)/60.0, 60.0 );\n        return domino( p, float(mod(mins,     10.)), float(mod(mins_next, 10.)), seconds);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ((fragCoord-vec2(0.,iResolution.y*0.5))/iResolution.x);\n    float px = 2.0/iResolution.y;\n    \n    vec2 dp = vec2( mod(p.x*(3.), 1.)-0.5, (p.y*3.));\n    int num = int(p.x*3.);\n    \n    float time  = iDate.w;\n    \n    float d = domino_clock( dp, num, time);\n    d = smoothstep( 0.0, 1.75*px, d-0.001);\n    vec3 col = mix( vec3(0.356,0.533,0.886), vec3(0.96,0.96,0.91), d );\n    \n    float ds = (domino_clock( dp+vec2(0.,0.01), num, time)*0.05);\n    ds = smoothstep( 0.0, 0.012, ds+0.008 );\n    \n    //vec3 col = mix( vec3(0.243,0.243,0.243), vec3(0.9647,0.9058,0.7568), d);// sandy\n    //vec3 col = mix( vec3(0.5,0.,0.), vec3(1.,1.,1.), d); // red\n    col = mix(col,mix( vec3(0.96,0.96,0.91)*0.3, vec3(0.96,0.96,0.91), ds ), d);\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(float(num)/3.),1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 142, 142, 299], [300, 300, 334, 334, 362], [364, 364, 427, 427, 639], [640, 640, 675, 785, 1065], [1066, 1066, 1150, 1150, 1812], [1814, 1814, 1895, 1895, 2595], [2597, 2597, 2656, 2656, 3466], [3467, 3467, 3524, 3524, 4344]], "test": "untested"}
{"id": "3lyBzt", "name": "mountains v2", "author": "jorge2017a1", "description": "mountains v2", "tags": ["mountainsv2"], "likes": 4, "viewed": 243, "published": 3, "date": "1614830079", "time_retrieved": "2024-07-30T19:34:34.671755", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n///Thanks to dr2 for sharing your code !!!! .... heaven belongs to you !!!!\n//...\n//Thunder by Brandon\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\nvec3 light_pos3   ;\nvec3 light_color3 ;\n\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n   \n    vec2 p2;\n    vec3 prep=p;\n    prep.x= opRep1D( p.x, 10. );\n    prep.z= opRep1D( p.z, 20. );\n    \n    float scc1= sdCappedCone(  prep, 20.0, 10.0, 2.0 );\n    scc1+= fbm(p.xz) ; \n    \n    res =opU3(res, vec3(planeDist1,11.0,-1.0)); //inf\n    res =opU3(res, vec3(scc1,1.0,MATERIAL_NO)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\n\n    \n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 13.0, 25.0 );  light_color1 =vec3( 1.0);\n \tlight_pos2= vec3( -5.0, 16.0, -65.0 ); light_color2 =vec3( 1.0);\n    light_pos3= vec3( 0.0, 20.0, 0.0 ); light_color3 =vec3( 1.0);\n \n    \n    vec3 ro=vec3(4.5,12.0,-10.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    light_pos3+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n         \n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= mix( SkyCol ( ro,  rd), solotrueno(rd.xz*4.0), 0.5);\n     \n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n//-------Noise\nfloat Hash( vec2 p)\n{\n     vec3 p2 = vec3(p.xy,1.0);\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n     vec2 f = fract(p);\n     f *= f * (3.0-2.0*f);\n\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     v += noise(p*1.0)*.5;\n     v += noise(p*2.)*.25;\n     v += noise(p*4.)*.125;\n     return v;\n}\n\nvec3 clouds( vec2 uv, vec2 dir  )\n{\n\tdir *= itime;\n\tvec3 finalColor = fbm( (uv * 1.5) + dir ) * vec3( 1.0 );\t\n\t\n\treturn finalColor;\n}\n\nvec3 lightning( vec2 uv )\n{\n\tfloat timeVal = itime*5.0;\n\tvec3 finalColor = vec3( 0.0 );\n\tfor( int i=0; i < 3; ++i )\n\t{\n\t\tfloat indexAsFloat = float(i);\n\t\tfloat amp = 40.0 + (indexAsFloat*1.0);\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\n\t\t\n\t\tfloat thickness = mix( 0.1, 0.7, uv.y * 0.5 + 0.5 );\n\t\t\n\t\tfloat intensity = mix( 0.5, 1.5, noise(uv*10.0) );\n\t\tfloat t = abs( thickness / (sin(uv.x + fbm( uv + timeVal * period )) * amp) * intensity );\n\t\tfloat show = fract(abs(sin(timeVal))) >= 0.95 ? 1.0 : 0.0;\n\t\tshow *= step( abs(fbm( vec2( sin(itime * 50.0), 0.0 ) )), 0.4);\n\t\t\n\t\t\n\t\tfinalColor +=  t * vec3( 0.3, 0.5, 2.0 ) * show;\n\t}\n\t\n\treturn finalColor;\n}\n\n\n\n\nvec3 solotrueno(vec2 rd)\n{\n    vec2 uv = rd;\n\t//uv.x *= iResolution.x/iResolution.y;\n\tuv.x *= 1.5;\n\n\tvec3 finalColor = vec3( 0.0 );\n\tfloat xOffset = sin(itime);\n    vec2 uvOffset = vec2( xOffset, 0.0 );\n\tvec2 lightningUV = uv + uvOffset;\n\t\n\tfloat theta = 3.14159 * 2.1;\n\tlightningUV.x = uv.x * cos(theta) - uv.y*sin(theta); \n\tlightningUV.y = uv.x * sin(theta) + uv.y*cos(theta); \n\t\n\tfinalColor += lightning( lightningUV + uvOffset );\n    return  finalColor;\n}\n\n\n\n///por dr2----codigo de dr2\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\n\nvec3 sunDir;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f, s;\n    float tCur;\n   //float  a = pi * (0.5 + 0.3 * sin (0.1 * tCur));\n   float  a = pi * (0.5 + 0.3 * sin (0.1 * itime*5.0));\n    sunDir = normalize (vec3 (cos (a), 0.5, sin (a)));\n    \n    \n    \n    \n     tCur = itime*10.0;\n    if (rd.y > 0.) {\n  \t  ro.x += 2. * tCur;\n    \tp = 0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    \tw = 0.8;\n    \tf = 0.;\n    for (int j = 0; j < 4; j ++) \n    {\n    \tf += w * Noisefv2 (p);\n      \tw *= 0.5;\n      \tp *= 2.;\n    }\n        \n    cloudFac = clamp (3. * f * rd.y - 0.1, 0., 1.);\n        \n  }\n    else cloudFac = 0.;\n    \n  s = max (dot (rd, sunDir), 0.);\n    \n  col = vec3 (0.1, 0.2, 0.5) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (1.), cloudFac);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[549, 593, 640, 640, 667], [669, 669, 712, 712, 739], [741, 741, 789, 789, 817], [818, 902, 938, 938, 983], [989, 989, 1028, 1028, 1072], [1073, 1073, 1112, 1112, 1156], [1162, 1162, 1194, 1194, 1219], [1220, 1285, 1319, 1319, 1417], [1418, 1418, 1452, 1452, 1544], [1545, 1545, 1579, 1579, 1671], [1672, 1712, 1746, 1746, 1843], [1844, 1844, 1869, 1869, 1888], [1889, 1889, 1914, 1914, 1933], [1934, 1934, 1970, 1970, 1998], [2000, 2000, 2059, 2059, 2372], [2375, 2415, 2440, 2440, 3203], [3206, 3206, 3271, 3271, 3855], [3858, 3909, 3933, 3933, 4121], [4122, 4185, 4218, 4218, 4780], [4782, 4836, 4872, 4872, 5106], [5107, 5196, 5276, 5276, 5553], [5556, 5556, 5649, 5649, 5749], [5759, 5808, 5865, 5865, 7314]], "test": "untested"}
{"id": "WtyBzt", "name": "Fractal 34_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 16, "viewed": 428, "published": 3, "date": "1614827936", "time_retrieved": "2024-07-30T19:34:35.444689", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(vec3(1),H(iTime*.1),.2)*pow(dot(p,p),.2)*log(s)*8e-4\n    )\n    {\n        p=g*d;\n        p.z+=iTime*1.2;\n        p=R(p,vec3(.577),.3);\n        s=4.;\n        for(int i=0;i++<6;p*=e)\n            p=abs(p-vec3(0,2,1.5)),\n            p=mod(p,4.)-2.,\n            s*=e=-4./dot(p,p);\n        g+=abs(p.y)/s+1e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 603]], "test": "untested"}
{"id": "3tyfRt", "name": "Small Clock", "author": "foxic", "description": "Another clock. :3", "tags": ["lens", "zoom", "clock"], "likes": 6, "viewed": 285, "published": 3, "date": "1614826057", "time_retrieved": "2024-07-30T19:34:36.364230", "image_code": "#define hand_length 0.84\n\nfloat char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 1.;\n    return (textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) ).a-0.5)*0.25;\n}\n\nfloat tick_curve( float time1, float time2, float sec )\n{\n    return mix( floor(time1), floor(time2), clamp( fract(sec)*5., 0., 1. ) );\n    return time1;\n}\n\nfloat pInt(vec2 p, float num ) {\n    float v = 1.;\n    bool is_double = num >= 10.;\n    float offset = 0.25*float(is_double);\n    \n    for (float i = float(is_double); i>=0.; i--)\n        num /= 10.,\n        v = min(char(p - vec2(offset-=.5,-.5), 48+ int(fract(num)*10.) ), v );\n       \n    return v;\n}\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba)-0.002625;\n}\n\nvec2 lens_uv(vec2 uv,float size, vec2 pos ) {\n    float radius=size;\n    float depth=radius/2.;\n    \n\tfloat ax = ((uv.x - pos.x) * (uv.x - pos.x)) / (0.2*0.2) + ((uv.y - pos.y) * (uv.y - pos.y)) / (0.2/ (  iResolution.x / iResolution.y )) ;\n\tfloat dx = 0.0 + (-depth/radius)*ax + (depth/(radius*radius))*ax*ax;\n    float f =  (ax + dx );\n\tif (ax > radius) f = ax;\n    \n    return pos + (uv-pos)*f/ax;\n}\n\nfloat clock_hand_black(vec2 p,float size,float angle ) {\n    float d = 1.;\n    \n    // Center\n    vec2 pos = vec2(sin(angle),cos(angle));\n    d = min( abs(sdCircle( p-(pos*hand_length), size ))-0.002625, d );\n    d = min( udSegment( p, vec2(0.), pos*(hand_length-size) ), d );\n    \n    float lens_mask = sdCircle( p-(pos*hand_length), size )+0.02;\n    float lens = (sdCircle( p-(pos*(hand_length-0.02)+vec2(0.,0.05)), 0. )*0.025)+0.006;\n    vec2 magnifierArea = lens_uv( p, size, pos );\n    lens *= (texture( iChannel1, magnifierArea ).r*0.3)+1.;\n    d = min(max(0.017-lens, lens_mask), d);\n    \n    \n    return d;\n}\nfloat clock_hand_black_line(vec2 p, float size , float angle ) {\n    float d = 1.;\n    \n    // Center\n    vec2 pos = vec2(sin(angle),cos(angle));\n    d = min( udSegment( p, vec2(0.), pos*hand_length*size ), d );\n    \n    \n    return d;\n}\n\nfloat clock_hands( vec2 p, float time ) {\n    float d = 1.;\n    \n\tfloat secs  = mod( tick_curve(time,        time+1.,         time),   60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0,  (time+1.)/60.0,   time),   60.0 );\n\tfloat hors  = mod( tick_curve(time/3600.0,(time+1.)/3600.0, time),   12.0 );\n    \n    d = min( clock_hand_black_line( p, 0.7,  (secs/60.)*6.28318), d );\n    \n    d = min( clock_hand_black(      p, 0.110, (hors/12.)*6.28318), d );\n    d = min( clock_hand_black(      p, 0.075, (mins/60.)*6.28318), d );\n    \n    \n    \n    // hand Center\n    d = max( -sdCircle( p, .06 ), d );\n    \n    float lens_light = max( abs(sdCircle( p, .04 ))*0.5, (sdCircle( p-vec2(0.,0.05), .03 )*0.2)-0.0001 );\n    vec2 magnifierArea = lens_uv( p, 0.4, vec2(0.) );\n    lens_light *= (texture( iChannel1, magnifierArea ).r*0.8)+1.;\n    d = min( 0.01-min(-sdCircle( p, .07 ), lens_light), d);\n    \n    return d;\n}\n\n\nfloat clock_face( vec2 p, vec2 l, float time ) {\n    float d = 1.;\n    \n    // NUMBERS\n    for (float i = 1.; i<=12.; i+=1.){\n        d = min( (pInt( ((l*1.19)-vec2(sin(i*0.523598),cos(i*0.523598)))*14., i)*0.5)+0.005, d );\n    }\n    \n    // BORDER\n    d = min( -sdCircle( p, .99 ), d );\n    d = min( abs(sdCircle( p, .96 ))-0.002625, d );\n    \n    \n    float hands = clock_hands( p, time );\n    hands = min( (clock_hands( p+vec2(0.0,0.02), time )+0.03)*0.2, hands );\n    \n    d = min(hands,d);\n    \n    d = max( min( sdCircle( p, .99 ), -sdCircle( p+vec2(0.,0.1), .99)*0.05 ), d);\n    \n    return d;\n}\n\nvec2 clock_hand_uv(vec2 uv,float size,float angle ) {\n    vec2 pos = vec2(sin(angle),cos(angle))*hand_length;\n    return lens_uv( uv,size, pos );\n}\nvec2 clock_hands_uv( vec2 p, float time ) {\n    \n\tfloat secs  = mod( tick_curve(time,        time+1.,         time),   60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0,  (time+1.)/60.0,   time),   60.0 );\n\tfloat hors  = mod( tick_curve(time/3600.0,(time+1.)/3600.0, time),   12.0 );\n    \n    p = clock_hand_uv(p, 0.075, (mins/60.)*6.28318);\n    p = clock_hand_uv(p, 0.110, (hors/12.)*6.28318);\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ((2.0*fragCoord-iResolution.xy)/iResolution.y);\n    \n    float time = iDate.w;\n    vec2 l = clock_hands_uv( p, time );\n    \n    \n    float px = 2.0/iResolution.y;\n    float d = 1.;\n    \n    d = min( clock_face( p, l, time ), d );\n\n    // Output to screen\n    d = smoothstep( 0.0, 0.01, d );\n    vec3 col = mix( vec3(0.13,0.137,0.137), vec3(0.941,0.9647,0.941), clamp(d, 0., 1.));\n    fragColor = vec4(vec3(col),1.0);\n    //fragColor = vec4((l-p)*50.,0.0,1.0);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 53, 53, 251], [253, 253, 310, 310, 408], [410, 410, 442, 442, 712], [714, 714, 748, 748, 776], [779, 779, 831, 831, 963], [965, 965, 1010, 1010, 1367], [1369, 1369, 1425, 1425, 1985], [1986, 1986, 2050, 2050, 2223], [2225, 2225, 2266, 2266, 3133], [3136, 3136, 3184, 3184, 3738], [3740, 3740, 3793, 3793, 3887], [3888, 3888, 3931, 3931, 4297], [4300, 4300, 4357, 4357, 4829]], "test": "untested"}
{"id": "3lyBRt", "name": "Tribute to my old Atari", "author": "mrange", "description": "License CC0: Tribute to my old Atari\nThat's where it started for me\nMusic: Rob Hubbard - Goldrunner - Piano performed by LightSide", "tags": ["2d", "fbm", "atari"], "likes": 16, "viewed": 749, "published": 3, "date": "1614814743", "time_retrieved": "2024-07-30T19:34:37.274795", "image_code": "// License CC0: Tribute to my old Atari\n//  That's where it started for me\n//  Music: Rob Hubbard - Goldrunner - Piano performed by LightSide\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define PSIN(x)     (0.5+0.5*sin(x))\n\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n  \n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynomial min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's isosceles triangle\nfloat isosceles(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// IQ's horseshoe\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, \n            c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n           (p.x>0.0)?p.y:l );\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// IQ's segment\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// IQ's segment\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat atari(vec2 p) {\n  p.x = abs(p.x);\n  float db = box(p, vec2(0.36, 0.32));\n\n  float dp0 = -parabola(p-vec2(0.4, -0.235), 4.0);\n  float dy0 = p.x-0.115;\n  float d0 = mix(dp0, dy0, smoothstep(-0.25, 0.125, p.y)); // Very hacky\n\n  float dp1 = -parabola(p-vec2(0.4, -0.32), 3.0);\n  float dy1 = p.x-0.07;\n  float d1 = mix(dp1, dy1, smoothstep(-0.39, 0.085, p.y)); // Very hacky\n\n  float d2 = p.x-0.035;\n  const float sm = 0.025;\n  float d = 1E6;\n  d = min(d, max(d0, -d1));;\n  d = pmin(d, d2, sm);\n  d = pmax(d, db, sm);\n  \n  return d;\n}\n\nfloat atari_a(inout vec2 p, vec2 off) {\n  p -= vec2(0.275, 0.0);\n\n  float d0 = isosceles(p*vec2(1.0, -1.0)-vec2(0.0, -0.225), vec2(0.20, 0.65))-0.1;\n  float d1 = isosceles(p*vec2(1.0, -1.0)-vec2(0.0, -0.18), vec2(0.13, 0.55))-0.005;\n  float d2 = box(p-vec2(0.0, -0.135), vec2(0.15, 0.06));\n  float d3 = p.y+0.325;\n\n  float d = d0;\n  d = max(d, -d1);\n  d = pmin(d, d2, 0.0125);\n  d = pmax(d, -d3, 0.0125);\n\n  p -= vec2(0.275, 0.0) + off;\n\n  return d;\n}\n\nfloat atari_i(inout vec2 p, vec2 off) {\n  p -= vec2(0.07, 0.0);\n\n  float d0 = box(p, vec2(0.07, 0.325)-0.0125)-0.0125;\n\n  float d = d0;\n\n  p -= vec2(0.07, 0.0) + off;\n  return d;\n}\n\nfloat atari_r(inout vec2 p, vec2 off) {\n  p -= vec2(0.22, 0.0);\n\n  float d0 = p.y+0.325;\n  float d1 = circle(p - vec2(-0.12, 0.225), 0.1);\n  const float a = PI/2.0;\n  const vec2 c = vec2(cos(a), sin(a));\n  vec2 hp = p;\n  hp -= vec2(0.0, 0.14);\n  hp.xy = -hp.yx;\n  float d2 = horseshoe(hp, c, 0.125, 0.2175*vec2(0.12,0.275));\n  float d3 = segment(p-vec2(-0.015, 0.005), vec2(0.0), vec2(0.22, -0.4))-0.07;\n  float d5 = p.y - 0.205;\n  float d6 = box(p - vec2(-0.155, -0.075), vec2(0.065, 0.30));\n  float d7 = box(p - vec2(-0.055, 0.225), vec2(0.06, 0.1));\n  \n  float d = d1;\n  d = min(d, d7);\n  d = max(d, -d5);\n  d = min(d, d2);\n  d = min(d, d6);\n  d = min(d, d3);\n  d = pmax(d, -d0, 0.0125);\n  p -= vec2(0.25, 0.0)+off;\n  \n  return d;\n}\n\nfloat atari_t(inout vec2 p, vec2 off) {\n  p -= vec2(0.195, 0.0);\n\n  float d0 = box(p - vec2(0.0, 0.265), vec2(0.195, 0.06)-0.0125)-0.0125;\n  float d1 = box(p - vec2(0.0, -0.03), vec2(0.07, 0.295)-0.0125)-0.0125;\n  \n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  \n  p -= vec2(0.195, 0.0) + off;\n  \n  return d;\n}\n\nfloat atari_text(vec2 p) {\n  p -= vec2(-0.33, 0.0);\n  float d = 1E6;\n  vec2 rp = p;\n  rp.x = abs(rp.x);\n  rp.x -= -0.195;\n  d = min(d, atari_t(rp, vec2(-0.055, 0.0)));\n  d = min(d, atari_a(rp, vec2(-0.055, 0.0)));\n  p.x -= 0.72;\n  d = min(d, atari_r(p, vec2(0.02, 0.0)));\n  d = min(d, atari_i(p, vec2(0.0, 0.0)));\n  return d;\n}\n\nfloat height_(vec2 p) {  \n  p *= 0.2;\n  vec2 p0 = p;\n  vec2 n0 = hextile(p0);\n  p0 *= ROT(TAU*hash(n0));\n  const float ss = 0.95;\n  float d0 = atari(p0/ss)*ss;\n  float d = d0;\n  return 0.25*tanh_approx(smoothstep(0.0125, -0.0125, d)*exp(2.0*-d));\n//  return 0.25*smoothstep(0.0125, -0.0125, d);\n}\n\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.23);\n  float tm = 123.0+TTIME/320.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 6; ++i) {\n    h += a*height_(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat synth(vec2 p) {\n  const float z = 4.0;\n  const float st = 0.02;\n  float dob = box(p, vec2(1.4, 0.5));\n  p.x = abs(p.x);\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 1;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft = sqrt(fft);\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\n    dib = min(dib, dibb);\n  }\n  \n  float dl = p.y;\n  dl = abs(dl) - 0.005;\n  dl = abs(dl) - 0.0025;\n  dl = abs(dl) - 0.00125;\n  float d = dib;\n  d = max(d, -dl);\n  d = pmax(d, dob, 0.025);\n  return d*z;\n}\n\nvec3 color(vec2 p) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.25, 1.35, 2.0);\n  vec3 lcol2 = vec3(2.0, 1.55, 1.25);\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.25*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 20.0)*lcol1;\n  col += rm*pow(ref2, 20.0)*lcol2;\n\n  float ds = synth(ppp-vec2(0.0, -0.75));\n\n  const float zp = 1.35;\n  float di = atari_text(ppp/zp)*zp;\n  float dio = di;\n  dio = abs(dio-0.015) - 0.0075;\n  \n  di = min(di, dio);\n  float dg = di;\n  di = min(di, ds);\n\n  col += -lcol2*0.125*(exp(-5.0*max(di, 0.0)));\n \n  col = mix(col, vec3(0.85), smoothstep(-aa, aa, -di));\n  dg = abs(dg-0.025);\n  dg = abs(dg-0.0125);\n  float glow = exp(-20.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow);\n  col += glowCol*glow*pow(PSIN(-0.8+0.5*p.x-p.y-TTIME/16.0), 14.0);\n\n  return col;\n}\n\n// Post processing I found somewhere on shadertoy years ago\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 8.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 25951, "src": "https://soundcloud.com/lightside-piano/goldrunner", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBRt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[419, 419, 440, 440, 507], [509, 509, 537, 636, 957], [959, 959, 987, 1007, 1083], [1085, 1108, 1147, 1147, 1232], [1234, 1234, 1273, 1273, 1302], [1304, 1304, 1334, 1334, 1361], [1363, 1375, 1402, 1402, 1478], [1480, 1480, 1511, 1511, 1537], [1539, 1566, 1599, 1599, 1893], [1895, 1913, 1963, 1963, 2206], [2208, 2224, 2263, 2263, 2376], [2378, 2394, 2429, 2429, 2767], [2769, 2769, 2790, 2790, 3305], [3307, 3307, 3346, 3346, 3758], [3760, 3760, 3799, 3799, 3940], [3942, 3942, 3981, 3981, 4677], [4679, 4679, 4718, 4718, 4987], [4989, 4989, 5015, 5015, 5316], [5318, 5318, 5341, 5341, 5614], [5617, 5617, 5639, 5639, 6008], [6010, 6010, 6031, 6031, 6237], [6239, 6239, 6278, 6278, 6403], [6405, 6405, 6426, 6426, 7044], [7046, 7046, 7066, 7066, 8706], [8708, 8768, 8804, 8804, 9037], [9039, 9039, 9094, 9094, 9347]], "test": "untested"}
{"id": "wtKBz3", "name": "Hand on Hand Clock", "author": "foxic", "description": "some silly clock design I came up with.\nAlso has code to invert colors with a animation when its AP or PM.", "tags": ["clock", "weird", "art"], "likes": 5, "viewed": 304, "published": 3, "date": "1614812357", "time_retrieved": "2024-07-30T19:34:38.147462", "image_code": "\n#define PI 3.14159*2.\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\nfloat sdCircleLine( vec2 p, float r1, float r2 ){\n    return abs(length(p) - r1) - r2;\n}\n\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba)-0.00525;\n}\n\nvec2 dir_to_vec( float angle )\n{\n    return vec2(sin( angle ),cos( angle ));\n}\n\n\nfloat tick_curve( float time )\n{\n    return floor(time)+clamp( fract(time)*5., 0., 1. );\n}\nfloat tick_bounce_curve( float time,float mult )\n{\n    return cos( clamp( fract(time), 0., 1. )*3.14159*2. )*mult;\n}\n\nfloat clock( in vec2 p, float time )\n{\n    float mils  = fract(time);\n\tfloat secs  = mod( tick_curve(time),        60.0 );\n\tfloat mins  = mod( tick_curve(time/60.0),   60.0 )+tick_bounce_curve(secs,0.1);\n\tfloat hors  = mod( tick_curve(time/3600.0), 12.0 )+tick_bounce_curve(mins,0.05)-tick_bounce_curve(secs,0.01);\n    \n    \n    vec2  center = (-tick_bounce_curve(hors,0.125)+0.125)*dir_to_vec((hors*PI)/12.);\n    vec2  offset = center;\n    vec2  h1 = offset;\n    float d  = 1.;\n    \n    // Clock hands\n    d = min( udSegment( p, offset, offset+=dir_to_vec((hors*PI)/12.)*.9 ), d );\n    d = min( sdCircle(p-offset, 0.0125), d );\n    \n    \n    // PIN\n    d = max( -sdCircle(p-center*0.2, 0.1), d ); // cut hole\n    \n    d = min( sdCircleLine(p-center*0.2, 0.1, 0.005), d );\n    d = min( sdCircle(p-center, 0.05), d );\n    \n    // Clock hands contined\n    d = min( udSegment( p, offset, offset+=dir_to_vec((mins*PI)/60.)*.5 ), d );\n    d = min( sdCircle(p-offset, 0.0125), d );\n    d = min( udSegment( p, offset, offset+=dir_to_vec((secs*PI)/60.)*.2 ), d );\n    d = min( sdCircle(p-offset, 0.025), d );\n    d = min( udSegment( p, offset, offset+=dir_to_vec((secs*PI)/60.)*.1 ), d );\n    \n    return d;\n}\n\n\nfloat background( in vec2 p, float time ){\n\n\tfloat day_blend  = max( fract(time/43200.0)*6.28318 , 0.);\n    bool is_bright   = mod( floor(time/43200.0), 2. ) == 1.;\n    \n    float d = 1.;\n    float CircleSize_inner  = mix( 0., 7., day_blend);\n    float CircleSize_outter = mix( 0., 8., day_blend);\n    float WaveSize          = 100.;\n    \n    d = sdCircle(p, CircleSize_inner);\n    d = min( cos(WaveSize*sdCircle(p, CircleSize_inner))*0.01, d );\n    d = max( sdCircle(p, CircleSize_outter), d );\n    \n    if (is_bright) { // likely better way to do this\n        return d;\n    } else {\n        return -d;\n    }\n}\n\nfloat flipblend( float bg, float fg ){\n    return min( max( bg, fg ), 1.-min( bg, fg ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    p *= 1.4;\n    \n    float time  = iDate.w;\n    float fg  =   smoothstep( 0.0,  2.*px, clock( p,               time ) );\n    fg = min( fg, smoothstep( -0.5,  .1,   clock( p+vec2(0.,.03125), time )*2.9 )); // add shadow\n    \n    float bg  = smoothstep( 0.0,2.*px, background( p,time ) );\n    \n    float b = flipblend( bg, fg ); // if background is higher than forgrount invert forground\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 10.0; // multiply with sth for intensity\n    vig = pow(vig, 0.5)+0.125; // change pow for modifying the extend of the  vignette\n    \n    b = b+(1.-clamp(vig,0.,1.));\n    vec3 col = mix( vec3(0.941,0.9647,0.941), vec3(0.13,0.137,0.137), clamp(b,0.,1.)); // add color\n\n\tfragColor = vec4( col*(vig+0.125), 1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 85], [86, 86, 135, 135, 174], [177, 177, 229, 229, 360], [362, 362, 394, 394, 440], [443, 443, 475, 475, 533], [534, 534, 584, 584, 650], [652, 652, 690, 690, 1853], [1856, 1856, 1898, 1898, 2467], [2469, 2469, 2507, 2507, 2560], [2561, 2561, 2618, 2618, 3499]], "test": "untested"}
{"id": "3lyfDm", "name": "Tessellation from @kamoshika_vrc", "author": "jstrom2002", "description": "Procedurally generated tessellation from @kamoshika_vrc from the following tweet: https://twitter.com/kamoshika_vrc/status/1365546685636636673?s=20. Re-posted here to examine the code in depth.", "tags": ["test"], "likes": 1, "viewed": 267, "published": 3, "date": "1614809505", "time_retrieved": "2024-07-30T19:34:38.927377", "image_code": "// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat fsnoise(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;// [0,iResolution] coords\n    uv *= 2.0;// zoom out.\n\n    // Pattern generation.\n    vec2 p=uv.xy/iResolution.y*4. + iTime;\n    vec2 I=floor(p/4.);\n    p = mod(p,4.) - 2.0;\n    float i;\n    for(;i++<9.;){\n        p=abs(p)-1.;\n        p/=dot(p,p);\n        if(length(p)<1.)\n        break;\n    }    \n    vec4 o;\n    o.rgb = rgb2hsv(vec3(fsnoise(I+i*.1),1.,1.))/abs(sin(max(p.x,p.y)*5.))/i;\n\n    // Output to screen\n    fragColor = vec4(o.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 81, 81, 412], [414, 414, 436, 436, 505], [508, 508, 565, 565, 1036]], "test": "untested"}
{"id": "ttVfzc", "name": "Circular Deform", "author": "oneshade", "description": "Inexact circular deform operator. Much better than non-uniform rotation and simpler/faster than a parabolic deform. It also preserves arclength (similar to my parabolic deform operator). Note that it does have a bit of a singularity.", "tags": ["2d", "sdf", "deform", "circular", "bound"], "likes": 7, "viewed": 193, "published": 3, "date": "1614809498", "time_retrieved": "2024-07-30T19:34:39.875841", "image_code": "vec2 circularDeform(in vec2 p, in float r) {\n    float s = sign(r);\n    r *= s, p = vec2(r - p.y * s, p.x);\n    return vec2(atan(p.y, p.x) * r, (r - length(p)) * s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    float div = 0.1; // To invert the radius (so it is controlled similarly to my parabolic deform)\n    float r = iMouse.z > 0.0 ? div / (iMouse.y / iResolution.y * 1.5 - 0.75) : div / sin(iTime) / 0.75;\n    vec2 p = circularDeform(uv, r);\n    float d = length(vec2(max(0.0, abs(p.x) - 0.25), p.y)) - 0.05;\n\n    vec3 color = vec3(0.125 + 0.125 * sin(d * 300.0));\n    color = mix(color, vec3(p / iResolution.y * iResolution.xy + 0.5, 0.0), smoothstep(0.01, 0.0, d) * 0.5 + exp(-15.0 * d) * (d + 0.75));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 167], [169, 169, 224, 224, 856]], "test": "untested"}
{"id": "tlVfRc", "name": "53K", "author": "dyla", "description": "53K", "tags": ["procedural", "noise", "fbm", "warp", "blue", "ice", "warped"], "likes": 7, "viewed": 472, "published": 3, "date": "1614803142", "time_retrieved": "2024-07-30T19:34:40.785409", "image_code": "float prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) - 0.5;\n}\n\nfloat fprand(vec2 uv, float f){\n    vec2 sp = uv*f;\n    vec2 isp = floor(sp);\n    vec2 fsp = fract(sp);\n    \n    float a = prand(isp+0.5);\n    float b = prand(isp+0.5+vec2(1.0,0.0));\n    float c = prand(isp+0.5+vec2(0.0,1.0));    \n    float d = prand(isp+0.5+vec2(1.0,1.0));\n    float wx = smoothstep(0.0, 1.0, fsp.x);\n    float wy = smoothstep(0.0, 1.0, fsp.y);\n    return mix(mix(a,b,wx), mix(c,d,wx), wy);\n    \n}\n\nfloat perlin(vec2 uv, int octaves, float f0, float fmul, float v0, float vmul){\n    float val = 0.0;\n    float frq = f0;\n    float wei = v0;\n    float time = mod(iTime, 1000.0);\n    vec2 wind = vec2(1.0, 1.0)*0.0005;\n    \n    for (int i=0; i<octaves; i++) {\n        val += wei * fprand(uv+wind*float(i)*time, frq);\n        frq *= fmul;\n        wei *= vmul;\n    }\n    \n    return val;\n}\n\nfloat pdef(vec2 uv) {\n    return perlin(uv, 11, 0.8, 1.7, 1.5, 0.65);\n}\n\nfloat warped(vec2 uv) {\n    return pdef(uv+vec2(pdef(uv+pdef(uv)), pdef(uv+pdef(uv+3.145)+1.25)));\n}\n\nvec4[4] cols = vec4[4](\n    \tvec4(0.05,0.0,0.2,1.0),\n        vec4(0.2,0.4,0.75,1.0),\n    \tvec4(0.4,0.6,0.8,1.0),\n    \tvec4(1.0,1.0,1.0,1.0)\n    );\n\nvec4 getCol(float col) {\n    float lf = float(cols.length()-1);\n    float ci = floor(col * lf);\n    int cii = int(ci);\n    return mix(cols[cii], cols[cii+1], fract(col*lf));\n    //return mix(cols[cii], cols[cii+1], smoothstep(ci/lf, (ci+1.0)/lf, min(max(col,0.0), 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n    \n    float t = mod(iTime, 1000.0);\n    float tm = 10.0;\n    float mt = mod(t, tm);\n    float transitionStart = 0.8;\n    float col2Weight = smoothstep(transitionStart,1.0,mt/tm);\n   \n    vec4 col1 = getCol(abs(warped(uv+(t-mt))));\n    vec4 col2 = col2Weight>0.0 ? getCol(abs(warped(uv+(t+tm-mt)))) : col1;\n    \n    fragColor = mix(col1, col2,  col2Weight);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 107], [109, 109, 140, 140, 524], [526, 526, 605, 605, 911], [913, 913, 934, 934, 984], [986, 986, 1009, 1009, 1086], [1236, 1236, 1260, 1260, 1509], [1511, 1511, 1568, 1568, 1994]], "test": "untested"}
{"id": "tlKBRc", "name": "Test dithering smoothing", "author": "z0rg", "description": "A test based on this shader technique https://www.shadertoy.com/view/tlVBWz", "tags": ["dithering"], "likes": 6, "viewed": 186, "published": 3, "date": "1614799836", "time_retrieved": "2024-07-30T19:34:41.715921", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// A small test of dithering based on time\n// Left side is using dithering\n// Right side is not\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat time;\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float t = time*10.;\n    vec2 p = uv+vec2(sin(t*.25), cos(t))*.25;\n    float c = _cir(p, .05);\n    float shp = iResolution.x*.5;\n    vec3 col = vec3(1.)*sat(c*shp);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    float t = iTime;\n    \n     // stepping the refresh rate to 20/s\n    float stp = 1./20.;\n    \n    t = floor(t/stp)*stp;\n    \n    time = t;\n    \n    // dithering here thx https://www.shadertoy.com/view/tlVBWz\n    if (uv.x < 0.)\n        time = t-sat(texture(iChannel0, fragCoord/8.).x)*stp; \n\n    vec3 col = rdr(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[540, 540, 569, 569, 595], [597, 597, 616, 616, 802], [805, 805, 862, 862, 1280]], "test": "untested"}
{"id": "tlKBR3", "name": "Binary Blend Clock.", "author": "foxic", "description": "A quick Binary Clock i tossed together.\n\nBased on the tile render i'm using in my WIP game MollySpace:\nhttps://twitter.com/RedDashGames/status/1364181112994598913\n\nWould love to know what you think of this and my game. :3", "tags": ["binary", "clock", "distance", "tiles", "minimalistic"], "likes": 19, "viewed": 753, "published": 3, "date": "1614793172", "time_retrieved": "2024-07-30T19:34:42.576620", "image_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdRoundedBox( in vec2 p, in float b, in float r ) {\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat LED( in vec2 POS, in vec2 UV, in float time, in float size ){\n    \n    \n    //TIME\n    float mils  = fract(time);\n    float blend = sin(mod(  time,         1.0 )*1.57075);\n    \n    float secs1 = mod( (time),            60.0 );\n    float secs2 = mod( (time+1.),         60.0 );\n    \n\tfloat mins1 = mod( (time)   /60.0,    60.0 );\n\tfloat mins2 = mod( (time+1.)/60.0,    60.0 );\n    \n\tfloat hors1 = mod( (time)   /3600.0,  24.0 );\n\tfloat hors2 = mod( (time+1.)/3600.0,  24.0 );\n    \n    // draw LED\n    float d = 0.;\n    if        (POS.x == 2.){\n        d =      float( (int(secs2) >> int(POS.y)) &1 );\n        d = mix( float( (int(secs1) >> int(POS.y)) &1 ), d, blend );\n        \n    } else if (POS.x == 1.){\n        d =      float( (int(mins2) >> int(POS.y)) &1 );\n        d = mix( float( (int(mins1) >> int(POS.y)) &1 ), d, blend );\n        \n    } else if (POS.x == 0.){\n        d =      float( (int(hors2) >> int(POS.y)) &1 );\n        d = mix( float( (int(hors1) >> int(POS.y)) &1 ), d, blend );\n    }\n\n    // Output to screen\n    //d = (length(UV-0.5)) + (1.-d);// for round dots\n    //d = (length(UV-0.5)) + (1.-d);// for square dots\n    d = sdRoundedBox(UV-0.5, size, size-0.2) + (1.-d);\n    return d;\n}\n\nfloat LED_tiled( in vec2 UV, in float time ){\n    vec2 char_pos = vec2( floor(UV.x*5.), floor(UV.y*5.) );\n    vec2 char_uv  = vec2( mod(UV.x*5., 1.), mod(UV.y*5., 1.) );\n    \n    float fgr = 1.;\n    float bgr = 1.;\n    \n    for( int x=-1; x < 2; x++ ){\n        for( int y=-1; y < 2; y++ ){\n            vec2 offset = vec2(x,y);\n            fgr = opSmoothUnion( fgr, LED( char_pos+offset, char_uv-(offset), time, 0.1 ), 0.35 );\n            bgr = opSmoothUnion( bgr, LED( char_pos+offset, char_uv-(offset), time, 0.3 ), 0.35 );\n        }\n    }\n    \n    return 1.-max(1.-fgr, bgr);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragCoord *=2.;\n    fragCoord.x -= (iResolution.x);\n    vec2 uv = (fragCoord)/iResolution.y;\n    uv.x += 0.3333;\n    uv.y -= 0.3333;\n    \n    \n    float time  = iDate.w;\n    \n    float fg = LED_tiled( uv, time );\n    fg = smoothstep( 0.5, 0.55, fg );\n    \n    float bg = LED_tiled( uv+vec2(0.,0.05), time );\n    bg = smoothstep( 0.2, 0.85, bg )*0.5;\n    \n    \n    \n    vec3 col_bg = mix( vec3(1.,1.,1.), vec3(0.5,0.,0.), bg);\n    \n    vec3 col_fg = mix( col_bg, vec3(1.,0.,0.), fg);\n    \n    fragColor = vec4( mix( col_bg, col_fg, 0.5), 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 210, 210, 296], [1513, 1513, 1558, 1558, 2092], [2093, 2093, 2150, 2200, 2759]], "test": "untested"}
{"id": "tlVBR3", "name": "asdfgh.shader", "author": "yooper", "description": "yoo", "tags": ["cineshader"], "likes": 2, "viewed": 8967, "published": 3, "date": "1614789045", "time_retrieved": "2024-07-30T19:34:43.441308", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (3.*fragCoord.xy-iResolution.xy) / iResolution.y; \n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(1.8,r);\n\n\tuv = (2.0 * uv) -7.0;     \n    float beamWidth = abs(20.0 / (40.0 * uv.y));\n\n    \n    \n    \n\n    if(abs(uv.y)>=3.0)\n    {\n    \n   \t  // fragColor=vec4(0.0,44,0.0,1.0);\n      //  return;\n    }\n    \n\tvec3 horBeam = vec3(beamWidth);\n\t\n\t//fragColor = vec4( horBeam , 1.0);\n    fragColor = vec4( 5. / (33. * abs(2.*length(p)-1.) ) );\n\n\n    \n  \n}\n\n/** SHADERDATA\n{\n\t\"title\": \"thank u for being\",\n\t\"description\": \"be with us 04.04.2021\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 544]], "test": "untested"}
{"id": "wlyfWw", "name": "Pseudo Refraction", "author": "Shane", "description": "Pseudo refractive metaballs.", "tags": ["metaballs", "refraction", "effect", "blob", "glow", "truchet"], "likes": 41, "viewed": 906, "published": 3, "date": "1614779323", "time_retrieved": "2024-07-30T19:34:44.209255", "image_code": "/*\n\n    Pseudo Refraction\n    -----------------\n    \n    For all intents and purpose, this is a rough reproduction of a cheap \n    pseudo refraction technique that Nusan used in his \"Drop of Distortion\" \n    shader. There's not much to it: Code up something blob-like above a \n    plane, take the intersection point, cast the refracted ray down to the \n    plane, then use the resultant XY position to index into whatever \n    texture you decide to use to cover the back plane.\n    \n    Back in the day, multiple refractive bounces weren't really an option, \n    so this was the next best thing. It definitely won't fool you into \n    believing it's a fully fledged refractive blobby material floating \n    above a plane, but it's visually interesting and has a refractive feel. \n    In addtion, Nusan added some glow, which I thought looked pretty cool, \n    so I put some of that in as well.\n    \n    Metaballs are one my favorite oldschool effects. When raymarching \n    wasn't a feasible option, it was necessary to use the marching cubes \n    algorithm. Ironically, achieving the oldschool polygonized faceted look \n    would be quite difficult in a pixel shader, but at some stage, I'm \n    going to attempt that... or wait for someone else on here to do it. \n    Whichever comes first. :)\n    \n\n\n    // Based on the following:\n    \n    Drop of Distortion - Nusan\n    https://www.shadertoy.com/view/WdKXWt\n\n\n*/\n\n// Background pattern: Truchet checkers: 0, Circle checkers: 1.\n#define PAT 0\n\n// Colored glow.\n#define COLOR\n\n// Subtle textured lines.\n#define LINES\n\n\n// Object ID: Either the back plane or the metaballs.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// Exponential based smooth minimum: Nicer, but more expensive.\nfloat smin(float a, float b, float k){\n    \n    k *= 12.;\n    return -log(exp(-a*k) + exp(-b*k))/k;\n}\n*/\n\n// Standard metaball routine: Either determine the overall potential of \n// multiple spherical charges at a given point, or take the smooth \n// minimum between multiple spheres. Regardless of the route you take, \n// the result will resemble an isofield surface at the zero potential mark.\nfloat meta(vec3 p){ \n\n    float d = 1e5; // Start with .5, if using the potential version. \n\t\n    for (int i = 0 ; i < 5 ; i++){\n        // Move the spheres around.\n\t\tvec3 a = p - sin(vec3(1, 2, 5)*float(i) + iTime)/vec3(2, 2, 4);\n\t\t//d -= .2/dot(a, a); // Potential between balls.\n        d = smin(d, length(a) - .2, .5); // Smooth minimum.\n\t}\n    \n\treturn d; // Return the distance.\n}\n\n// Distance function.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z + .25;\n    \n    // Rotate the metaballs as a whole.\n    p.xy = rot2(-iTime/4.)*p.xy;\n    // Metaball distance.\n    float obj = meta(p);\n   \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // )verall minimum distance.\n    return min(fl, obj);\n    \n}\n  \n// Standard normal function.\nvec3 nr(in vec3 p){\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n\n    //u += (hash21(u*57. + fract(iTime)) - .5)*5.;\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, 0, -2), l = vec3(.25, .25, -1.5);\n    \n    // Rotating the camera about the XY plane.\n    r.xy = rot2(iTime/8.)*r.xy;\n    //r.xz = rot2(.1)*r.xz;\n    \n \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        if(d<.005) break; // Surface hit.\n        t += d*.5; // Advance the overall distance closer to the surface.\n        \n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p);\n    \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv;\n    \n    // If we've hit the metaball surface, refract the ray and \n    // calculate the UV coordinates.\n    if(gObjID==1){\n    \n        // Refractive ray at the surface: I'm pretending the blobs are\n        // filled with something gelatinous, which has a rough refractive\n        // index of 1.5... Sounds good anyway. :D\n        vec3 ref = refract(r, n, 1./1.5);\n        float flDist = 2.25; // Floor distance from camera.\n        \n        // Starting at the surface, cast a ray in the refracted direction\n        // then get the XY component of the resultant back plane hit point.\n        // This will be your UV components, which you'll use to index into\n        // a texture. In this case, we'll generate a texture pattern with\n        // the coordinates.\n        uv = p.xy*flDist/(t*ref.z); \n \n    }\n    else uv = p.xy; // Back XY plane texture coordinates.\n    \n \n    \n    \n    // Cell ID and local cell coordinates for the texture we'll generate.\n    //\n    float sc = 1./3.; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Construct a simple background texture. It doesn't need to be too fancy,\n    // but a small amount of detail can help bring out the refractive effect\n    // a little more. These simple patterns took less than five minutes, and\n    // were made up on the spot.\n    //\n    #if PAT == 0\n    float rnd = hash21(iuv); // Random threshold number.\n    if(rnd<.5) uv.y = -uv.y; // Flip random cell coordinates.\n    d = min(length(uv - .5*sc), length(uv + .5*sc)) - .5*sc; // Two diagonal circles.\n    float arc = abs(d) - .005; // Make a Truchet arc.\n    d = min(d, (length(uv) - .02)); // Add some little circles.\n    if(rnd<.5) d = -d; // Reverse the field for each random threshold.\n    //if(mod(iuv.x + iuv.y, 2.)<.5) d = -d; // Reversing checkers.\n    // Double up on some lines.\n    d = min(d + .02, abs(d));\n    #else\n    d = length(uv) - sc*.25;\n    if(mod(iuv.x + iuv.y, 2.)<.5) d = -d;// + .02;\n    d = min(d + .02, (abs(d) + .0));\n    #endif\n  \n    \n    \n    // Begin rendering the background texture. \n    vec4 oCol = mix(vec4(.05), vec4(1), 1. - smoothstep(0., .01, d));\n    \n    // Save the current color.\n    vec4 svCol = oCol; \n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .001;\n    // Omit the middle of edges where the Truchet passes through.\n    oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, bord));\n    \n    #ifdef LINES\n    // Subtle lines for a bit of texture.\n    vec2 luv = uv;\n    float pat = abs(fract((luv.x + luv.y)*40. + .5) - .5)*2. - .25;\n    vec4 lCol = mod(iuv.x + iuv.y, 2.)<.5? vec4(.25) : vec4(.125);\n    oCol = mix(oCol, lCol, (1. - smoothstep(0., .01*40., pat))*.35);\n    #endif\n    \n    #if PAT == 0\n    // Render the background arcs.\n    oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01*8., arc - .01))*.5);\n    oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, arc - .005));\n    oCol = mix(oCol, svCol, 1. - smoothstep(0., .01, arc)); \n    #endif\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.75); // Attenuation.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting. \n    c = oCol*(df/4. + vec4(1)*sp*2. + .75); // Coloring, diffuse plus ambience.\n    \n    // Cheap edging. \n    // Used for cheap edging. It only works for particular objects.\n    float edge = dot(r, n);\n    c = mix(c, vec4(0), (1. - smoothstep(0., .1, -.35 - edge))*.5);\n    c = mix(c, vec4(1), (1. - smoothstep(0., .05, -.2 - edge))*.5);\n    \n     \n \n    #ifdef COLOR\n    vec4 gCol = vec4(4, 2, 1, 0);\n    #else\n    vec4 gCol = vec4(2);\n    #endif\n    // Coloring the glow, which is not to be confused with applying\n    // the glow.\n    c *= mix(mix(vec4(1), gCol, min(glow/4., 1.)), \n         vec4(1), float(1 - gObjID)*(1. - smoothstep(0., 1., glow - 1.5)));\n    \n\n    // Laying down something slightly shadowy looking -- Totally fake.\n    c *= (max(1. - glow/2., .0))*1.5 + .2;\n \n    // Very very cheap shadows -- Not used here.\n    //c *= max(min(min(m(p + ld*.1), m(p + ld*.2)), m(p + ld*.3))/.1, 0.) + .15;\n    \n  \n    // Reverse, of sorts.\n    //c = pow((1. - c.zyxw), vec4(8));\n\n    // Applying the glow and attenuation, then applying some fake\n    // spotlight attenuation for a bit more atmosphere.\n    c *= glow*at*(1. - smoothstep(0., 1.5, length(p.xy) - .5)*.85);\n    \n    \n    // Time based color transition.\n    //c = mix(c.yxzw, c, smoothstep(-.05, .05, sin(iTime/4. + .2)));\n   \n    \n    // Mixing the color a bit more.\n    c = mix(c, c.xzyw, length(u));\n    c = mix(c.zyxw, c, smoothstep(-.15, .15, u.y));\n    \n        \n    // Just the diffuse metaballs. \n    //float fr = pow(max(1. + dot(r, n), 0.), 5.);\n    //c = vec4(1)*(df + fr); \n\n\n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1637, 1670, 1692, 1692, 1750], [1752, 1780, 1801, 1801, 1864], [1867, 2090, 2128, 2128, 2205], [2380, 2669, 2688, 2688, 3055], [3057, 3079, 3095, 3119, 3394], [3398, 3427, 3446, 3446, 3618], [3621, 3621, 3656, 3774, 9862]], "test": "untested"}
{"id": "WlKBR3", "name": "Distance to Regular Polygon", "author": "oneshade", "description": "Exact distance to a regular n-sided polygon.", "tags": ["2d", "sdf", "distance", "polygon", "regularpolygon", "regular", "exact"], "likes": 6, "viewed": 169, "published": 3, "date": "1614767719", "time_retrieved": "2024-07-30T19:34:45.106855", "image_code": "float sdRegularPolygon(in vec2 p, in float r, in float n) {\n    float a = 6.28 / n, ha = 0.5 * a, hr = 0.5 * r, c = cos(a), s = sin(a);\n    float e = hr * length(vec2(c - 1.0, s)), er = hr * length(vec2(c + 1.0, s));\n    p = sin(mod(atan(p.y, p.x) + ha, a) - ha + vec2(1.57, 0.0)) * length(p);\n    return length(vec2(p.x -= er, max(0.0, abs(p.y) - e))) * sign(p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float r = mix(0.2, 0.3, 0.5 + 0.5 * cos(iTime));\n    float n = mix(3.0, 12.0, 0.5 + 0.5 * sin(iTime));\n    float d = sdRegularPolygon(uv, r, n);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 367], [369, 369, 424, 424, 1052]], "test": "untested"}
{"id": "tlGfR3", "name": "float int <= 16777216 are exact", "author": "FabriceNeyret2", "description": "integers in floats <= 2 = 16777216  ( in absolute value ) are exact.\nthen the next 16777216 are ok up to 1 bit precision (i.e. even are exact ),\netc.", "tags": ["math", "precision", "ieee", "tuto"], "likes": 13, "viewed": 433, "published": 3, "date": "1614755547", "time_retrieved": "2024-07-30T19:34:46.007447", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U -= iResolution.xy/2.;\n    int i = 16777216*(U.y>0.?1:2) + int(U.x);\n    float  v = max(float(i),iTime);\n    O = vec4( int(v) == i );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 179]], "test": "untested"}
{"id": "3lGfzc", "name": "Ultraviolet Fractal", "author": "oneshade", "description": "Inspired by gaz's amazing fractals.", "tags": ["3d", "fractal", "colors", "neon", "cool", "ultraviolet"], "likes": 4, "viewed": 174, "published": 3, "date": "1614749509", "time_retrieved": "2024-07-30T19:34:46.925991", "image_code": "void mainImage(out vec4 O, in vec2 C) {\n    O = vec4(0.0);\n    vec3 p, r = iResolution;\n    vec3 d = normalize(vec3((C - 0.5 * r.xy) / r.y, 1.0));  \n    for (float i=0.0, g=0.0, e, s; ++i < 100.0; e < 0.002 ? O += 5.0 * (cos(vec4(2.0, 4.0, 1.0, 0.0) - log(s * s) * 0.5) + 0.5) / dot(p, p) / i * 2.0 : O) {\n        p = g * d;\n        p -= vec3(0.0, -1.7, 2.0);\n        s = iTime * 0.1;\n        vec2 cs = sin(s + vec2(1.57, 0.0));\n        p.xz *= mat2(cs.x, -cs.y, cs.yx);\n        p = abs(p);\n        p.xz = vec2(atan(p.z, p.x), length(p.xz));\n        p.yz = vec2(atan(p.z, p.y), length(p.yz) - 3.0);\n        s = 2.0;\n        s *= e = 3.0 / min(dot(p, p), 1.5);\n        p = abs(p) * e;\n        for(int i=0; i < 8; i++) {\n            p = vec3(2.0, 4.0, 2.0) - abs(p - vec3(4.25, 4.625, 2.0));\n            s *= e = 7.25 / clamp(dot(p, p), 0.0, 5.2);\n            p = abs(p) * e;\n            p.y = abs(p.y) - 0.15;\n        }\n\n        g += e = min(length(p.xz) * 1.125 - 0.5, p.y) / s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 986]], "test": "untested"}
{"id": "WtyBzc", "name": "Blend Clock1", "author": "foxic", "description": "Blend Clock", "tags": ["blendclock"], "likes": 15, "viewed": 430, "published": 3, "date": "1614747794", "time_retrieved": "2024-07-30T19:34:47.757767", "image_code": "\nfloat char(vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 1.;\n    return textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) ).a;\n}\n\nfloat pInt(vec2 p, float Sec, float Min, float Hor) {\n    float v = 1.;\n    float offset = -.5*5.5;\n    \n        \n        \n    offset += 1.5;\n    for (float i = 1.; i>=0.; i--) \n        Hor /= 10.,\n        v = min(char(p - vec2(offset-=.5,-.5), 48+ int(fract(Hor)*10.) ), v );\n       \n    offset += 3.;\n    v = min(char(p - vec2(offset-=.5,-.5), 58 ), v );\n    \n    for (float i = 1.; i>=0.; i--) \n        Min /= 10.,\n        v = min(char(p - vec2(offset-=.5,-.5), 48+ int(fract(Min)*10.) ), v );\n        \n    v = min(char(p - vec2(offset-=.5,-.5), 58 ), v );\n    \n    offset += 3.;\n    for (float i = 1.; i>=0.; i--) \n        Sec /= 10.,\n        v = min(char(p - vec2(offset-=.5,-.5), 48+ int(fract(Sec)*10.) ), v );\n    \n    return v;\n}\n\nfloat clock (vec2 U, float time ) {\n    float mils  = fract(time);\n\tfloat secs  = mod( (time),             60.0 );\n\tfloat mins  = mod( (time/60.0),        60.0 );\n\tfloat mins2 = mod( ((time+1.)/60.0),   60.0 );\n\tfloat hors  = mod( (time/3600.0),      24.0 );\n\tfloat hors2 = mod( ((time+1.)/3600.0), 24.0 );\n    float blend_seconds = mod( time, 1.0 );\n\n    float d = 1.;\n    d = pInt(U,secs,mins,hors);\n    float O2 = pInt(U,secs+1.,mins2,hors2);\n    d = mix(d,O2,fract(blend_seconds));\n    return d;\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\n    // get time\n    float time  = iDate.w;\n    U -= iResolution.xy*0.5;\n    U /= iResolution.y;\n    U *=3.;\n    \n\tfloat d = smoothstep(.5,.49,clock(U,time));\n\td = max(  smoothstep(.6,0.5,clock(U+0.05,time)+0.07)*0.5, d  );\n    \n    vec3 col = mix( vec3(0.356,0.533,0.886), vec3(0.96,0.96,0.91), 1.-d );\n\n    O =  vec4( vec3(col ), 1. );\n    //O =  vec4( vec3( blend ), 1. );\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 215], [217, 217, 270, 270, 955], [957, 957, 992, 992, 1458], [1460, 1460, 1499, 1516, 1878]], "test": "untested"}
{"id": "3tGfzc", "name": "Fractal 33_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 7, "viewed": 347, "published": 3, "date": "1614746450", "time_retrieved": "2024-07-30T19:34:48.570594", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<120.;\n        e<.002?O+=3.*(cos(vec4(3,8,25,0)+log(s)*.5)+3.)/dot(p,p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-1.7,2);\n        r=normalize(vec3(1,3,0));\n        s=iTime*.2;\n        p=mix(r*dot(p,r),p,cos(s))+sin(s)*cross(p,r);\n        p=abs(p);\n        p.xz=vec2(atan(p.z,p.x),length(p.xz));\n        p.yz=vec2(atan(p.z,p.y),length(p.yz)-2.);\n        s=3.;\n        s*=e=3./min(dot(p,p),50.);\n        p=abs(p)*e;\n        for(int i=0;i++<5;)\n            p=vec3(2,4,2)-abs(p-vec3(3.8,4.6,2.)),\n            s*=e=7./clamp(dot(p,p),.2,5.),\n            p=abs(p)*e;\n        g+=e=min(length(p.xz)-.2,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 778]], "test": "untested"}
{"id": "WlyBzc", "name": "HPP Lattice Gas Automata", "author": "SlackermanzCA", "description": "HPP Lattice Gas Automata using a 1:1 pixel ratio by encoding/decoding the block phase and state information\nhttps://en.wikipedia.org/wiki/Lattice_gas\nhttps://www.reddit.com/user/slackermanz/\nhttps://www.reddit.com/r/cellular_automata\n", "tags": ["2d", "simulation", "automata", "cellular", "conway", "gameoflife", "cellularautomata", "lbm", "boltzmann", "singlerotation", "hpp", "lga"], "likes": 5, "viewed": 462, "published": 3, "date": "1614743370", "time_retrieved": "2024-07-30T19:34:50.135411", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:HPP (Hardy/Pazzis/Pomeau) Lattice Gas\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:HPP Lattice Gas\n//\t\thttps://en.wikipedia.org/wiki/Lattice_gas\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:HPP (Hardy/Pazzis/Pomeau) Lattice Gas\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:HPP Lattice Gas\n//\t\thttps://en.wikipedia.org/wiki/Lattice_gas\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] rand_bnh = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t0\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t1\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states), \t//\t2\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states) \t//\t3\n\t);\n\n\tint[4] nh_order0 = int[4](1,0,3,2);\n\tint[4] nh_order1 = int[4](3,1,2,0);\n\n\tfloat[4] block_neighbourhood;\n\tif(block_phase == 0.0) {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order0[0]],\n\t\t\trand_bnh[nh_order0[1]],\n\t\t\trand_bnh[nh_order0[2]],\n\t\t\trand_bnh[nh_order0[3]] \t); }\n\telse {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order1[0]],\n\t\t\trand_bnh[nh_order1[1]],\n\t\t\trand_bnh[nh_order1[2]],\n\t\t\trand_bnh[nh_order1[3]] \t); }\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'HPP Lattice Gas' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the new substate data to check the state ID\n\tfloat chk\t= 0.0;\n\tfloat cn \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tchk = chk + new_substates[i] * cn;\tcn = cn / 2.0; }\n\n\tfloat res = 0.0;\n\n\tif(chk == 0.0) \t{ res = 0.0 \t/ states; }\n\tif(chk == 1.0) \t{ res = 8.0 \t/ states; }\n\tif(chk == 2.0) \t{ res = 4.0 \t/ states; }\n\tif(chk == 3.0) \t{ res = 12.0 \t/ states; }\n\tif(chk == 4.0) \t{ res = 2.0 \t/ states; }\n\tif(chk == 5.0) \t{ res = 10.0 \t/ states; }\n\tif(chk == 6.0) \t{ res = 9.0 \t/ states; }\n\tif(chk == 7.0) \t{ res = 14.0 \t/ states; }\n\tif(chk == 8.0) \t{ res = 1.0 \t/ states; }\n\tif(chk == 9.0) \t{ res = 6.0 \t/ states; }\n\tif(chk == 10.0) { res = 5.0 \t/ states; }\n\tif(chk == 11.0) { res = 13.0 \t/ states; }\n\tif(chk == 12.0) { res = 3.0 \t/ states; }\n\tif(chk == 13.0) { res = 11.0 \t/ states; }\n\tif(chk == 14.0) { res = 7.0 \t/ states; }\n\tif(chk == 15.0) { res = 15.0 \t/ states; }\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tres_g = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_b = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_g = (res_r == 1.0) ? 0.0 : res_g;\n\tres_b = (res_r == 1.0) ? 0.0 : res_b;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 256.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:HPP (Hardy/Pazzis/Pomeau) Lattice Gas\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:HPP Lattice Gas\n//\t\thttps://en.wikipedia.org/wiki/Lattice_gas\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] rand_bnh = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t0\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t1\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states), \t//\t2\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states) \t//\t3\n\t);\n\n\tint[4] nh_order0 = int[4](1,0,3,2);\n\tint[4] nh_order1 = int[4](3,1,2,0);\n\n\tfloat[4] block_neighbourhood;\n\tif(block_phase == 0.0) {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order0[0]],\n\t\t\trand_bnh[nh_order0[1]],\n\t\t\trand_bnh[nh_order0[2]],\n\t\t\trand_bnh[nh_order0[3]] \t); }\n\telse {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order1[0]],\n\t\t\trand_bnh[nh_order1[1]],\n\t\t\trand_bnh[nh_order1[2]],\n\t\t\trand_bnh[nh_order1[3]] \t); }\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'HPP Lattice Gas' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the new substate data to check the state ID\n\tfloat chk\t= 0.0;\n\tfloat cn \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tchk = chk + new_substates[i] * cn;\tcn = cn / 2.0; }\n\n\tfloat res = 0.0;\n\n\tif(chk == 0.0) \t{ res = 0.0 \t/ states; }\n\tif(chk == 1.0) \t{ res = 8.0 \t/ states; }\n\tif(chk == 2.0) \t{ res = 4.0 \t/ states; }\n\tif(chk == 3.0) \t{ res = 12.0 \t/ states; }\n\tif(chk == 4.0) \t{ res = 2.0 \t/ states; }\n\tif(chk == 5.0) \t{ res = 10.0 \t/ states; }\n\tif(chk == 6.0) \t{ res = 9.0 \t/ states; }\n\tif(chk == 7.0) \t{ res = 14.0 \t/ states; }\n\tif(chk == 8.0) \t{ res = 1.0 \t/ states; }\n\tif(chk == 9.0) \t{ res = 6.0 \t/ states; }\n\tif(chk == 10.0) { res = 5.0 \t/ states; }\n\tif(chk == 11.0) { res = 13.0 \t/ states; }\n\tif(chk == 12.0) { res = 3.0 \t/ states; }\n\tif(chk == 13.0) { res = 11.0 \t/ states; }\n\tif(chk == 14.0) { res = 7.0 \t/ states; }\n\tif(chk == 15.0) { res = 15.0 \t/ states; }\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tres_g = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_b = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_g = (res_r == 1.0) ? 0.0 : res_g;\n\tres_b = (res_r == 1.0) ? 0.0 : res_b;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 256.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:HPP (Hardy/Pazzis/Pomeau) Lattice Gas\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:HPP Lattice Gas\n//\t\thttps://en.wikipedia.org/wiki/Lattice_gas\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] rand_bnh = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t0\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t1\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states), \t//\t2\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states) \t//\t3\n\t);\n\n\tint[4] nh_order0 = int[4](1,0,3,2);\n\tint[4] nh_order1 = int[4](3,1,2,0);\n\n\tfloat[4] block_neighbourhood;\n\tif(block_phase == 0.0) {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order0[0]],\n\t\t\trand_bnh[nh_order0[1]],\n\t\t\trand_bnh[nh_order0[2]],\n\t\t\trand_bnh[nh_order0[3]] \t); }\n\telse {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order1[0]],\n\t\t\trand_bnh[nh_order1[1]],\n\t\t\trand_bnh[nh_order1[2]],\n\t\t\trand_bnh[nh_order1[3]] \t); }\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'HPP Lattice Gas' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the new substate data to check the state ID\n\tfloat chk\t= 0.0;\n\tfloat cn \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tchk = chk + new_substates[i] * cn;\tcn = cn / 2.0; }\n\n\tfloat res = 0.0;\n\n\tif(chk == 0.0) \t{ res = 0.0 \t/ states; }\n\tif(chk == 1.0) \t{ res = 8.0 \t/ states; }\n\tif(chk == 2.0) \t{ res = 4.0 \t/ states; }\n\tif(chk == 3.0) \t{ res = 12.0 \t/ states; }\n\tif(chk == 4.0) \t{ res = 2.0 \t/ states; }\n\tif(chk == 5.0) \t{ res = 10.0 \t/ states; }\n\tif(chk == 6.0) \t{ res = 9.0 \t/ states; }\n\tif(chk == 7.0) \t{ res = 14.0 \t/ states; }\n\tif(chk == 8.0) \t{ res = 1.0 \t/ states; }\n\tif(chk == 9.0) \t{ res = 6.0 \t/ states; }\n\tif(chk == 10.0) { res = 5.0 \t/ states; }\n\tif(chk == 11.0) { res = 13.0 \t/ states; }\n\tif(chk == 12.0) { res = 3.0 \t/ states; }\n\tif(chk == 13.0) { res = 11.0 \t/ states; }\n\tif(chk == 14.0) { res = 7.0 \t/ states; }\n\tif(chk == 15.0) { res = 15.0 \t/ states; }\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tres_g = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_b = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_g = (res_r == 1.0) ? 0.0 : res_g;\n\tres_b = (res_r == 1.0) ? 0.0 : res_b;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 256.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:HPP (Hardy/Pazzis/Pomeau) Lattice Gas\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:HPP Lattice Gas\n//\t\thttps://en.wikipedia.org/wiki/Lattice_gas\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] rand_bnh = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t0\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states), \t//\t1\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states), \t//\t2\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states) \t//\t3\n\t);\n\n\tint[4] nh_order0 = int[4](1,0,3,2);\n\tint[4] nh_order1 = int[4](3,1,2,0);\n\n\tfloat[4] block_neighbourhood;\n\tif(block_phase == 0.0) {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order0[0]],\n\t\t\trand_bnh[nh_order0[1]],\n\t\t\trand_bnh[nh_order0[2]],\n\t\t\trand_bnh[nh_order0[3]] \t); }\n\telse {\n\t\tblock_neighbourhood = float[4]\n\t\t(\trand_bnh[nh_order1[0]],\n\t\t\trand_bnh[nh_order1[1]],\n\t\t\trand_bnh[nh_order1[2]],\n\t\t\trand_bnh[nh_order1[3]] \t); }\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'HPP Lattice Gas' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the new substate data to check the state ID\n\tfloat chk\t= 0.0;\n\tfloat cn \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tchk = chk + new_substates[i] * cn;\tcn = cn / 2.0; }\n\n\tfloat res = 0.0;\n\n\tif(chk == 0.0) \t{ res = 0.0 \t/ states; }\n\tif(chk == 1.0) \t{ res = 8.0 \t/ states; }\n\tif(chk == 2.0) \t{ res = 4.0 \t/ states; }\n\tif(chk == 3.0) \t{ res = 12.0 \t/ states; }\n\tif(chk == 4.0) \t{ res = 2.0 \t/ states; }\n\tif(chk == 5.0) \t{ res = 10.0 \t/ states; }\n\tif(chk == 6.0) \t{ res = 9.0 \t/ states; }\n\tif(chk == 7.0) \t{ res = 14.0 \t/ states; }\n\tif(chk == 8.0) \t{ res = 1.0 \t/ states; }\n\tif(chk == 9.0) \t{ res = 6.0 \t/ states; }\n\tif(chk == 10.0) { res = 5.0 \t/ states; }\n\tif(chk == 11.0) { res = 13.0 \t/ states; }\n\tif(chk == 12.0) { res = 3.0 \t/ states; }\n\tif(chk == 13.0) { res = 11.0 \t/ states; }\n\tif(chk == 14.0) { res = 7.0 \t/ states; }\n\tif(chk == 15.0) { res = 15.0 \t/ states; }\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tres_g = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_b = (res_r > 0.0) ? 1.0 : 0.0;\n\tres_g = (res_r == 1.0) ? 0.0 : res_g;\n\tres_b = (res_r == 1.0) ? 0.0 : res_b;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 256.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1242, 1242, 1299, 1349, 1479]], "test": "untested"}
{"id": "WlGBzc", "name": "Fractal 32_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 19, "viewed": 493, "published": 3, "date": "1614741490", "time_retrieved": "2024-07-30T19:34:51.066919", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O+=3.*(cos(vec4(3,8,25,0)+log(s)*.5)+3.)/dot(p,p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-.9,1.5);\n        r=normalize(vec3(1,8,0));\n        s=iTime*.2;\n        p=mix(r*dot(p,r),p,cos(s))+sin(s)*cross(p,r);\n        s=2.;\n        s*=e=3./min(dot(p,p),20.);\n        p=abs(p)*e;\n        for(int i=0;i++<4;)\n            p=vec3(2,4,2)-abs(p-vec3(4,4,2)),\n            s*=e=8./min(dot(p,p),9.),\n            p=abs(p)*e;\n        g+=e=min(length(p.xz)-.15,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 654]], "test": "untested"}
{"id": "WlGfz3", "name": "Falling Leaves", "author": "YitingLiu", "description": "following a tutorial https://youtu.be/hlM940IqpRU\n", "tags": ["smoothstep", "feather", "artofthecode"], "likes": 3, "viewed": 417, "published": 3, "date": "1614737597", "time_retrieved": "2024-07-30T19:34:52.377416", "image_code": "// create something other than feather \n\n#define S smoothstep \n#define T (iTime*.05)\n\n\nmat2 Rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat Leaf(vec2 p ){\n    float d = length(p-vec2(0,clamp(p.y,-.3,.3)));\n    float r = mix(.1,.01,S(-.3,.3,mix(-1.,1.,mix(p.x,p.y,atan(p.x,p.y)))));// feather shape \n      \n  \n    \n    float m = S(.01,.0,d);\n    float tiny = 20.;// 1-20. bigger number, tinnier \n    m=S(.01,.0,d*tiny*p.y);\n    m=S(.01,.0,-d*tiny*p.y);\n   // m=S(.01,.0,p.x*p.y*tiny);\n    float side = sign(p.y);\n   \n    float x = .9*abs(p.x)/r;// stretch out the corner \n    float id = floor(p.y+20.);\n    \n    \n    d = length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14/2.);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14/4.);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14*1.5);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    float stem = S(1.,.0,d);\n    \n    \n    float n=fract(sin(id*564.2)*5623.2);\n    float shade = mix(.5,1.,n);\n   \n    return m*stem ;//max(strand*m*shade,stem); \n\n\n}\n\nvec3 Transform(vec3 p, float angle){\n    p.xz*=Rot(angle);\n    p.xy*=Rot(angle*.5);// rotate along z axis as well \n    return p;\n\n}\n\nvec4 LeafBall(vec3 ro, vec3 rd, vec3 pos,float angle ){\n\n    vec4 col = vec4(0);\n    float t = dot(pos-ro,rd);\n    \n    vec3 p = ro+rd*t;\n    float y = length(pos-p);\n    \n    if(y<1.){\n        float x = sqrt(1.-y);\n        vec3 pF = ro+rd*(t-x)-pos;//front intersection \n        pF = Transform(pF,angle);\n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);//y axis to be the up and down axis\n        uvF*=vec2(.3,.5);\n        \n        // alpha blending \n        \n        float f = Leaf(uvF);\n        vec4 front = vec4(vec3(f),S(.0,.1,f));\n\n        vec3 pB = ro+rd*(t+x)-pos;//back intersection \n        pB = Transform(pB,angle);\n\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);//y axis to be the up and down axis\n        uvB*=vec2(.3,.5);\n        \n        float b = Leaf(uvB);\n        vec4 back = vec4(vec3(b),S(.0,.1,b));\n        col=mix(back, front, front.a);// alpha blend - see both back and front \n\n   }\n   \n   return col;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0,0,0.+mix(-3.,-1.5,sin(T*10.)));\n    vec3 rd = normalize(vec3(uv,1));\n \n    // bg\n    vec3 bg = vec3(.2,.5,.9)*(uv.y+.5);\n    bg+=vec3(.8,.1,.1)*(-uv.y+.5);\n    col = vec4(bg,0);\n   //float a = 180.+T*10.;\n  // col=vec4(Leaf(uv));\n \n  \n   \n  \n    for (float i = 0.; i <=1.; i+=1./100.){\n         \n         float x =mix(-15.,15.,fract(sin(i*643.2)*8593.1));\n         float y =mix(6.,-6.,fract(i+T));\n         float z =mix(8.,0.,i);\n         float a = T+i*5643.1;\n         vec4 leaf = LeafBall(ro,rd,vec3(x,y,z),a);\n         leaf.b = fract(i+T)/bg.r;\n         leaf.r = fract(i+T)*fract(sin(i*643.2)*8593.1);\n         \n         leaf.rgb = mix(bg,leaf.rgb,mix(.8,1.,i));\n         leaf.rgb=sqrt(leaf.rgb);\n         col = mix(col, leaf,leaf.a);\n\n    \n    }\n\n     col = pow(col, vec4(.4545));//gamma correction\n   \n    \n    // Output to screen\n    fragColor =col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 105, 105, 168], [170, 170, 190, 190, 1062], [1064, 1064, 1100, 1100, 1195], [1197, 1197, 1252, 1252, 2122], [2123, 2123, 2180, 2180, 3149]], "test": "untested"}
{"id": "WtGBz3", "name": "Out for a Swim", "author": "oneshade", "description": "Animation of a fish swimming.", "tags": ["deform", "animation", "25d", "fish", "swimming", "parabolic"], "likes": 11, "viewed": 187, "published": 3, "date": "1614728496", "time_retrieved": "2024-07-30T19:34:53.527341", "image_code": "// Map to coordinates on a circle while preserving arclength\nvec2 circularDeform(in vec2 p, in float r) {\n    float s = sign(r);\n    r *= s, p = vec2(r - p.y * s, p.x);\n    return vec2(atan(p.y, p.x) * r, (r - length(p)) * s);\n}\n\n// 2D SDFs from Inigo Quilez's distance function article (https://iquilezles.org/articles/distfunctions2d)\nfloat sdUnevenCapsule(in vec2 p, in float r1, in float r2, in float h) {\n    p.x = abs(p.x);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(p, vec2(-b, a));\n    if (k < 0.0) return length(p) - r1;\n    if (k > a * h) return length(p - vec2(0.0, h)) - r2;\n    return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Fish texture\nvec3 fishColor(in vec2 uv, in float unit) {\n    vec3 color = vec3(0.0);\n\n    // Red scales\n    vec2 uv2 = mod(uv + vec2(0.035, 0.0175), vec2(0.07, 0.035)) - vec2(0.035, 0.0175);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv2) - 0.014));\n\n    // Yellow scales\n    vec2 uv3 = mod(uv + vec2(0.085, 0.0175), vec2(0.07, 0.035)) - vec2(0.035, 0.0175);\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv3) - 0.014));\n\n    // Eyes\n    float eyes = length(vec2(uv.x + 0.03, abs(uv.y) - 0.035)) - 0.0175;\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, eyes));\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(eyes)));\n\n    // Fins\n    float c = cos(0.25), s = sin(0.25);\n    vec2 uv4 = vec2(uv.x, abs(uv.y) - 0.125) * mat2(c, -s, s, c);\n    vec2 uv5 = uv4 * mat2(c, s, -s, c) * mat2(c, s, -s, c);\n    vec3 finColor = vec3(0.35 + 0.35 * sin(uv5.y * 500.0), 0.0, 0.0);\n    color = mix(color, finColor, smoothstep(unit, 0.0, max(uv4.x - 0.2, abs(uv4.y) - 0.04)));\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Moving background\n    vec2 uv2 = uv * iResolution.y / iResolution.xy + 0.5;\n    uv2 += vec2(0.0, iTime * 0.4);\n    fragColor = texture(iChannel0, uv2);\n\n    // Deform along circle\n    float bend = sin(iTime * 3.0);\n    float osc = -sin(iTime * 3.0) * 0.05;\n\n    vec2 uv3 = uv.yx * vec2(-1.0, 1.0) - vec2(-0.075, osc);\n    vec2 p = circularDeform(uv3, 0.5 / bend) + vec2(0.1, 0.0);\n\n    vec2 uv4 = uv.yx * vec2(-1.0, 1.0) - vec2(-0.025, 0.08 + osc);\n    vec2 p2 = circularDeform(uv4, 0.5 / bend) + vec2(0.1, 0.0);\n\n    // Fish distance\n    float c = cos(0.15), s = sin(0.15);\n    mat2 rmat = mat2(c, s, -s, c);\n\n    float body = sdUnevenCapsule(p.yx, 0.075, 0.0, 0.35);\n    float d = sdUnevenCapsule(p.yx, 0.075, 0.0, 0.35);\n    d = min(d, sdIsosceles(p.yx - vec2(0.0, 0.325), vec2(0.05, 0.15)));\n    d = min(d, sdIsosceles(vec2(abs(p.y) - 0.06, p.x) * rmat, vec2(0.075, 0.15)));\n\n    float d2 = sdUnevenCapsule(p2.yx, 0.075, 0.0, 0.35);\n    d2 = min(d2, sdIsosceles(p2.yx - vec2(0.0, 0.325), vec2(0.05, 0.15)));\n    d2 = min(d2, sdIsosceles(vec2(abs(p2.y) - 0.06, p2.x) * rmat, vec2(0.075, 0.15)));\n\n    // Fish's shadow\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(unit * 15.0, 0.0, d2 + 0.02));\n\n    // Fish texture (the mapping works so nicely!)\n    fragColor.rgb = mix(fragColor.rgb, fishColor(p, unit), smoothstep(unit, 0.0, d));\n\n    // Lighting\n    fragColor.rgb += 0.075 * exp(-38.0 * body);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.9));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 105, 105, 228], [230, 337, 409, 409, 661], [663, 663, 704, 704, 1024], [1026, 1042, 1085, 1085, 2088], [2090, 2090, 2145, 2145, 3726]], "test": "untested"}
{"id": "3tGfR3", "name": "Sand Worm", "author": "yonatan", "description": "trying out iapafoto's twigl emulator\nthis is from https://twitter.com/zozuar/status/1362141677864030213", "tags": ["dune", "golf", "sandworm", "twigl"], "likes": 13, "viewed": 398, "published": 3, "date": "1614726941", "time_retrieved": "2024-07-30T19:34:54.656322", "image_code": "\n// https://twigl.app/  geekest style\n\nGEEKEST\n\nvec3 p,q,d=vec3((FC.xy-r.xy*.5)/r.y,1);\nfloat i=0., // iteration counter\n  g=0., // total distance\n  n=15., // useful constant\n  e=n; // distance\no=vec4(0);\nfor(d.y-=.3;++i<80.&&e>.01;)\n    q=p=d*g,\n    q.z-=t, // q is for the dunes\n    p.y+=.3-sin(q.z*PI)*.1, // p is for the worm and ground elevation\n    g+=e=min(max(abs(length(p.xy) // worm tube\n                     +max(.03, (sin(p.z*n)*sin(atan(p.x,p.y)*n)/n)) // teeth inside\n                     -.2 // worm tube radius\n                     +snoise3D(p*n)*.02) // skin bumps\n                 -.02, // tube walls thickness\n                 .8-p.z), // slice the tube open to see the teeth\n             p.y+.1 // base terrain (sine wave)\n             -(snoise2D(q.xz))/n); // dunes\no+=i/vec4(66,85,99,1); // sandy color.\n\nEND\n", "image_inputs": [], "common_code": "// --------------------------------------\n//    https://github.com/doxas/twigl\n// --------------------------------------\n//\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n  // First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  // Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  // Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n\n  // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  // Normalise gradients implicitly by scaling m\n  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  // Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n}\nfloat snoise4D(vec4 v){\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n  // First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n  // Other corners\n\n  // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  //  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n  // Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n  // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n  // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n  // Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------\n\n#define t iTime\n#define r iResolution\n#define GEEKEST void mainImage(out vec4 o, vec2 FC) {\n#define END }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlyBR3", "name": "GLSL bug: side effects", "author": "ttg", "description": "Uncomment one of lines 25-27 and compile.  Is there a change?  The red output channel (the only one visible) doesn't depend on p1i or p2i, so forcing those to be evaluated is not expected to change the output, however it can have a large effect anyway.", "tags": ["bug"], "likes": 7, "viewed": 823, "published": 3, "date": "1614724579", "time_retrieved": "2024-07-30T19:34:55.667619", "image_code": "\nprecision highp float;\nprecision highp int;\n\nvoid mainImage( out vec4 fd, in vec2 fc )\n{\n    const float ishift = 100.;\n    const float shift = 1./ishift;\n    ivec2 c = ivec2(fc);\n    \n    float a = float(c.x)*shift;\n    float b = float(c.y)*shift;\n    \n    float p1 = (1.+a)*(1.+b)-(1.+a+b);\n    float p2 = a*b;\n    \n    int p1i = int(round(p1*(ishift*ishift)));\n    int p2i = int(round(p2*(ishift*ishift)));\n    \n    fd = vec4(0.);\n    \n    fd.r = float(abs(p1-p2)<1e-10);\n    \n    //uncomment one of these:\n    //fd.g = -float(p1i==p2i);\n    //fd.g = -float(p1i);\n    //fd.g = -float(p2i);\n    \n    fd.b=0.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 89, 89, 613]], "test": "untested"}
{"id": "wtVfRV", "name": "Day 439", "author": "jeyko", "description": "aaaa", "tags": ["mdtmjvm"], "likes": 20, "viewed": 392, "published": 3, "date": "1614721638", "time_retrieved": "2024-07-30T19:34:56.854445", "image_code": "// influenced by baugasm https://www.instagram.com/baugasm/ and some acid graphix\n\n\nvec4 r14(float a){\n    vec2 c = vec2(mod(a,256.),floor(a/256.))/256. + 0./iChannelResolution[2].xy;\n    return texture(iChannel2, c);\n}\n\n\nvec4 vn(float a, float t){\n    return mix(r14(floor(a)),r14(floor(a + 1.)),smoothstep(0.,1.,fract(t)));\n} \n\n\nvoid drawBloomed(vec2 uv, inout vec3 col, vec2 fragCoord){\n        vec2 p = uv;\n        \n        p.y += iTime*0.125;\n        \n        float md = 1.;\n        \n        float id = floor(p.y/md - 0.5);\n        \n        \n        float offs = sin(id*110.2 + pi*0.5);\n        offs = sign(offs)*smoothstep(0.,0.1,abs(offs));\n        p.x += offs*0.5;\n        p.y = pmod(p.y,md);\n        p.y += 0.3;\n        \n        \n        float h1 =  + 0.4*float(sin(id*1.5 + 2.) > 0.);\n        float h2 = 0.4*float(sin(id) < 0.);\n        \n        if(abs(h2-h1)<0.51){\n            float o = sin(id*3. + 1.); \n            h2 += sign(o)*max(abs(o),0.71)*0.6;\n             \n        }\n        \n        float d = sdPolygon( vec2[4](\n            vec2(0.,0),\n            vec2(0.2,0.),\n            vec2(0.2,0.2 + h1),\n            vec2(0.,0.2 + h2)\n        ),p) - 0.02;\n        \n        float blueNoise = texture(iChannel3,p*0.3).x;\n        \n        vec4 blurred = texture(iChannel2,fragCoord/iResolution.xy);\n         \n         \n        blurred = clamp(blurred,0.1,1.);\n        //blurred = mix(blurred, col.xyzz, smoothstep(0.5,0.6,blueNoise*1.05));\n        blurred +=  smoothstep(0.3,0.69,blueNoise)*0.03;\n        \n        col = mix(col, blurred.xyz, smoothstep(dFdx(p.x),0.,d));\n        col = mix(col, blurred.xyz*2.*(1. + sin(p.x*20. + p.y*10. + sin(p.y*5.) + iTime)), smoothstep(dFdx(p.x)*1.5,0.,abs(d)));\n            \n            \n\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    {\n        vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n        vec3 col = vec3(1.);\n\n        col = texture(iChannel0,fragCoord/iResolution.xy,0.).xyz;\n\n\n        vec4 blurred = texture(iChannel2,fragCoord/iResolution.xy);\n        vec3 bloom = smoothstep(0.6,2.,length(blurred.xyz))*blurred.xyz;\n        col += bloom*0.2;\n\n        drawBloomed(uv, col, fragCoord);\n        //drawBloomed(uv + vec2(0,30.), col, fragCoord);\n\n     \n    \n    \n        fragColor = col.xyzz;\n    }\n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    //fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.,0.95));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    //fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.05));\n    \n    //col = pow(col,vec3(0.454545));\n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.08;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.15;\n    \n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdBox(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.y,p.x);\n}\n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\n\n\n\n#define pi acos(-1.)\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), smoothstep(0.,1.,fract(i)));}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    int N = 4;\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(2.5);\n    p.xz *= rot(-2.5);\n    float amp = 2.5;\n    float gain = 0.7 ;\n    const float lacunarity = 1.2;\n    const int octaves = 4;\n    \n     float warp = .1 + sin(time*0.5)*0.05;\n    float warpTrk = 1.5 ;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p -= sin(p.zxy*warpTrk + vec3(0,-time*0.2,0) - 0.01*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.1,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n", "buffer_a_code": "\nvec4 r14(float a){\n    vec2 c = vec2(mod(a,256.),floor(a/256.))/256. + 0./iChannelResolution[2].xy;\n    return texture(iChannel2, c);\n}\n\n\nvec4 vn(float a, float t){\n    return mix(r14(floor(a)),r14(floor(a + 1.)),smoothstep(0.,1.,fract(t)));\n} \n\n\nvoid drawBlobs(vec2 uv, inout vec3 col, float sz, float szoffs, float fallspeed, bool outline){\n        vec3 p = vec3(uv,1);\n        \n        p.y += iTime*0.34*fallspeed;\n        \n        p.yz *= rot(0.6);\n        p.xz *= rot(2.);\n        \n        vec3 op = p;\n        \n        float md = sz;\n        \n        vec3 id = floor(p/md - 0.5);\n        p = pmod(p,md);\n        \n        \n        float d = length(p) - 0.0 - valueNoise(id.x + id.y + id.z + iTime*(0.5 + sin(id.x)) + sin(id.x + iTime + cos(id.z*10.)*5.),1.)*sz*0.2;\n\n        vec3 c = pal(0.5,0.5*vec3(1,-1,1),1.,vec3(1,3,4),1. + id.x*20.  - p.x*20. + 10.*length(p)*smoothstep(0.,0.1,length(p)));\n        \n        d -= cyclicNoise(op*15., false, iTime*2.)*0.05*sz*(1. + szoffs);\n        \n        if(sin(id.x*20. + id.y*50. + sin(id.z*10. + id.x) + cos(id.z*10.)*2.) < -0.5)\n            d = 10e4;\n        if(!outline){\n            if(d < 0.01){\n                col = mix(col,c, smoothstep(fwidth(d)*1.,0.,d));\n                //col = mix(col,vec3(0), smoothstep(fwidth(d)*1.,0.,abs(d) - 0.001));\n    \n            }\n        } else{\n        \n            \n            //d = max(abs(p.x) - 0.1, abs(p.y) - 0.1);\n            col = mix(col,mix(c,vec3(0),1.), smoothstep(fwidth(d)*1.,0.,abs(d)));\n        \n        }\n        \n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth) {\n\tp *= s;\n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375*0.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - 0.5;\n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n     \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.);\n\n    \n\n    \n    {\n        vec2 p = uv;\n        \n        p.y += iTime*0.19;\n        //p *= rot(0.25*pi);\n        \n        float na = cyclicNoise(vec3(p*5.,iTime), false, iTime*0.);\n        p += na*0.04;\n        vec2 op = p;\n        float md = .15;\n        \n        p = pmod(p,md);\n        \n        \n        float d = min(abs(p.x),abs(p.y));\n\n        \n        vec3 c = pal(0.5,0.5*vec3(1,1,1),1.,vec3(1,3,4),1.  + 10.*length(op)*smoothstep(0.,0.1,length(op)));\n        \n        \n        float n = cyclicNoise(vec3(op,1. + iTime*0.1)*10., false, iTime*0.);\n        \n        n = na;\n        c = mix(c,vec3(0),1.);\n        \n        c = mix(col,c,smoothstep(0.1,1.,abs(n))*0.2 );\n        \n        col = mix(col,c, smoothstep(fwidth(op.x)*1.5,0.,d + 0.001));\n\n        //col = mix(col,vec3(1), smoothstep(dFdx(p.x),0.,abs(d)));\n\n\n    }\n    \n    drawBlobs(uv, col, 0.125,0. ,0.75, false);\n    \n    drawBlobs(uv, col, 0.4, 1.9, 1., false);\n\n    {\n        vec2 p = uv;\n        \n        p.y += iTime*0.2;\n        \n        float md = 2.;\n        \n        float id = floor(p.y/md - 0.5);\n        \n        p.x += sin(id*pi + pi*0.5)*0.8;\n        p.y = pmod(p.y,md);\n        \n        for(float i = 0.; i < 15.; i++ ){\n            \n            vec2 s = vec2(1.-i/25.)*(0.5 + sin(id)*0.2);\n            \n            float d = sdBox(p*rot(i*(0.1 + sin(id*2.1)*0.3 ) + sin(id + iTime*i/15. )),s);\n            \n            \n            col = mix(col,vec3(1.), smoothstep(dFdx(p.x),0.,d));\n            \n            if(abs(p.y) <md*0.49)\n                col = mix(col,vec3(0), smoothstep(fwidth(d),0.,abs(d) - 0.001*0.));\n            \n        }\n\n    }  \n     \n\n    {\n        \n        vec2 p = uv;\n        p.y += iTime*0.2;\n        \n        float id = floor(p.y/2.);\n        p.y = pmod(p.y,2.);\n        \n        //p.x += 0.5;\n        \n        //p.y -= 0.4;\n        //p *= rot(sin(id + 4.));\n        for(float i = 0.; i < 35.; i++){\n            p.y += 0.01;\n            vec2 lp = p;\n            \n            vec2 offsSz = vec2(8./16.,0.5*8./16.)*1.;\n            \n            \n            lp.x += sin(i/45. + id + iTime)*0.4;\n            lp.x += 0.5;\n            lp -= offsSz*2.5*vec2(0,1);\n            \n            \n            lp -= offsSz*1.;\n            lp *= rot(0.5*sin(id*20. + 4. + iTime + i/25.));\n            \n            lp += offsSz*1.;\n            \n            float t = text( lp, float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0., 0.5, true, 0.);\n            \n            if(i == 0.)\n                t = text( lp, float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0., 0.5, false, 0.);\n                \n            col = mix(col,vec3(0),smoothstep(dFdx(uv.x),0.,t));\n            \n        }\n\n    }\n    \n    \n    col = 1. - col;\n    \n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n        fragColor *= 0.;\n        float iters = 23.;\n        for(float i = 0.; i < iters*iters; i++){\n            fragColor += texture(iChannel0,(fragCoord + vec2(mod(i,iters),floor(i/iters))- 0.5*iters )/iResolution.xy );\n        }\n        fragColor /= iters*iters;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n        fragColor *= 0.;\n        float iters = 23.;\n        for(float i = 0.; i < iters*iters; i++){\n            fragColor += texture(iChannel0,(fragCoord + vec2(mod(i,iters),floor(i/iters)) - 0.5*iters )/iResolution.xy );\n        }\n        fragColor /= iters*iters;\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy,0.).xyz;\n    \n    \n    vec4 blurred = texture(iChannel1,fragCoord/iResolution.xy);\n    vec3 bloom = smoothstep(0.6,2.,length(blurred.xyz))*blurred.xyz;\n    col += bloom*0.2;\n        \n    //drawBloomed(uv, col, fragCoord);\n    //drawBloomed(uv + vec2(0,30.), col, fragCoord);\n\n     \n    \n    \n    fragColor = col.xyzz;\n    //fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 102, 102, 219], [222, 222, 248, 248, 327], [331, 331, 389, 389, 1742], [1744, 1744, 1801, 1801, 3102]], "test": "untested"}
{"id": "wlVBzV", "name": "Parabolic Deform", "author": "oneshade", "description": "Inexact parabolic deform operator (works well in some cases, not so well in others but is much better than bending with non-uniform rotation).", "tags": ["deform", "curve", "parabola"], "likes": 3, "viewed": 192, "published": 3, "date": "1614719007", "time_retrieved": "2024-07-30T19:34:57.752045", "image_code": "#define PHI 2.09439510239 // (2 / 3)pi\n#define dot2(v) dot(v, v)\n\n// This seems way too complicated :(\nvec2 parabolicDeform(in vec2 p2, in float h) {\n    // Coefficients (b is always zero which simplifies things a bit)\n    float a = 4.0 * h * h;\n    float c = 2.0 - 4.0 * h * p2.y;\n    float d = -2.0 * p2.x;\n\n    float p = c / a, p3 = p * p * p;\n    float q = d / a, q2 = q * q;\n\n    float discr = -4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = -3.0 * a * c;\n    float d1 = 27.0 * a * a * d;\n    float qn = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(qn));\n    a *= 3.0;\n\n    vec2 C = qn < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = qn < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, discr < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (discr < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - m) / a;\n        if (discr < 0.0 ? (abs(root.y) < minCplx) : true) roots[discr < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    // Find closest point on the parabola from the roots\n    vec2 closest = vec2(roots[0], h * roots[0] * roots[0]);\n    float sqDist = dot2(p2 - closest);\n    if (roots[3] > 1.0) {\n        vec2 closest2 = vec2(roots[1], h * roots[1] * roots[1]);\n        float sqDist2 = dot2(p2 - closest2);\n        if (sqDist2 < sqDist) {\n            closest = closest2;\n            sqDist = sqDist2;\n        }\n\n        closest2 = vec2(roots[2], h * roots[2] * roots[2]);\n        sqDist2 = dot2(p2 - closest2);\n        if (sqDist2 < sqDist) {\n            closest = closest2;\n            sqDist = sqDist2;\n        }\n    }\n\n    // Integral of sqrt(1 + 4h^2x^2) gives the arclength (distance along the parabola)\n    float baz = abs(h), qux = 2.0 * baz * abs(closest.x);\n    float arclen = (asinh(qux) + qux * sqrt(4.0 * h * h * closest.x * closest.x + 1.0)) / baz * 0.25;\n    return vec2(arclen * sign(p2.x), sqrt(sqDist) * sign(p2.y - h * p2.x * p2.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float h = iMouse.z > 0.0 ? mouse.y * 32.0 : sin(iTime) * 32.0;\n    vec2 p = parabolicDeform(uv, h);\n    float d = length(vec2(max(0.0, abs(p.x) - 0.25), p.y)) - 0.05;\n\n    /* Maybe not so exact :(\n    p.x += 0.5 * sin(iTime);\n    p.y += 0.125 + 0.125 * cos(iTime);\n    vec2 q = abs(p) - vec2(0.25, 0.05);\n    float d = length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n    */\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 103, 149, 218, 2309], [2311, 2311, 2366, 2366, 3154]], "test": "untested"}
{"id": "wtVBRV", "name": "Neon Rays", "author": "victorberland", "description": "Simple rays", "tags": ["rays"], "likes": 1, "viewed": 229, "published": 3, "date": "1614713998", "time_retrieved": "2024-07-30T19:34:58.639672", "image_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (vec2 st) {\n    return fract(pow((sin(dot(st.xy,\n                                vec2(12.9898,sin(iTime / 3.14))))*\n                                43758.5453123),1.0));\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    //vec2 st = (gl_FragCoord.xy/iResolution.xy)*2.0 - 1.0;\n\n                float color = smoothstep(0.5,1.5,random(st));\n                color = sin(color / st.x) * sin(st.y / (st.x * sin(iTime / 2.0)));\n\n                vec3 color1 = vec3(color * 1.2, (0.2 + color), 0.1);\n                //float color = sin(color1);\n                //color = color / st.y;\n\n    //gl_FragColor = vec4(vec2(color, color), pow((st.x / 3.14), sin(smoothstep(0.1,1.2,u_time))),1.0);\n\n    fragColor = vec4(vec3(color1),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 72, 72, 232], [235, 235, 261, 261, 778], [781, 781, 838, 838, 1394]], "test": "untested"}
{"id": "tlKfzK", "name": "Fractal Clock", "author": "foxic", "description": "A simple Fractal Clock i coded when i couldn't sleep one night.\n\nBased on \"L System\" by IQ: https://www.shadertoy.com/view/XtyGR1", "tags": ["fractal", "time", "clock", "ifs"], "likes": 9, "viewed": 373, "published": 3, "date": "1614707262", "time_retrieved": "2024-07-30T19:34:59.539267", "image_code": "\n\n#define kDepth 10\n#define kBranches 2\n#define kMaxDepth 1024 // kBranches ^ kDepth\n\n//--------------------------------------------------------------------------\n\nmat3 matRotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 matTranslate( float x, float y )\n{\n    return mat3( 1, 0, 0, 0, 1, 0, -x, -y, 1 );\n}\n\nfloat sdBranch( vec2 p, float w1, float w2, float l )\n{\n    float h = clamp( p.y/l, 0.0, 1.0 );\n\tfloat d = length( p - vec2(0.0,l*h) );\n    return d - mix( w1, w2, h );\n}\n\n//--------------------------------------------------------------------------\n\nvec3 map( vec2 pos )\n{\n    const float len = 3.2;\n    const float wid = 0.3;\n    const float lenf = 0.6;\n    const float widf = 0.4;\n    \n    \n    // get time\n    float time = iDate.w;\n    float mils = fract(time);\n\tfloat secs = mod( (time),        60.0 );\n\tfloat mins = mod( (time/60.0),   60.0 );\n\tfloat hors = mod( (time/3600.0), 24.0 );\n    \n    vec3 d = vec3(1.);\n    \n    int c = 0;\n    for( int count=0; count < kMaxDepth; count++ )\n    {\n        int off = kMaxDepth;\n    \tvec2 pt_n = pos;\n        \n        float l = len;\n        float w = wid;\n        \n      \tfor( int i=1; i<=kDepth; i++ )\n      \t{\n            l *= lenf;\n            w *= widf;\n\n            off /= kBranches; \n            int dec = c / off;\n        \tint path = dec - kBranches*(dec/kBranches); //  dec % kBranches\n            \n            mat3 mx;\n\t    \tif( path == 0 )\n           \t{\n\t\t  \t\tmx = matRotate(6.2831*secs/60.0) * matTranslate( 0.0,l/lenf);\n\t    \t}\n\t    \telse if( path == 1 )\n           \t{\n\t\t  \t\tmx = matRotate(6.2831*hors/60.0) * matTranslate( 0.0,l/lenf);\n\t    \t}\n\t    \telse\n            {\n          \t\tmx = matRotate(6.2831*mins/60.0) * matTranslate(0.0,l/lenf);\n\t    \t}\n            pt_n = (mx * vec3(pt_n,1)).xy;\n\n            \n        \n        \t// bounding sphere test\n            float y = length( pt_n - vec2(0.0, l) );\n       \t\tif( y-1.4*l > 0.0 ) { c += off-1; break; }\n\n            float br = sdBranch( pt_n, w, w*widf, l );\n            if( path == 0 ){\n                d.r = min( d.r, br );\n            } else if( path == 1 ){\n                d = min( d, br );\n            } else {\n                d.g = min( d.g, br );\n            }\n     \t}\n        \n    \tc++;\n    \tif( c > kMaxDepth ) break;\n\t}\n    \n   \treturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate system\n    vec2  uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // frame in screen\n    vec2  uv_clock = uv*4.0 + vec2(0.0,3.5);\n   \n    \n    // compute\n    vec3 d = vec3(map( uv_clock ));\n    \n    // shape\n    vec3 cola = 1.-vec3( smoothstep( 0.0, 5.0*px, d ) );\n    fragColor = vec4( cola, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 193, 193, 293], [295, 295, 334, 334, 384], [386, 386, 441, 441, 556], [636, 636, 658, 658, 2347], [2350, 2350, 2407, 2432, 2776]], "test": "untested"}
{"id": "ttKfzK", "name": "test mouse api", "author": "louis_C", "description": "second test api", "tags": ["mouse"], "likes": 0, "viewed": 231, "published": 3, "date": "1614706680", "time_retrieved": "2024-07-30T19:35:00.413928", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float d1 = distance(uv,iMouse.xy/iResolution.xy);\n    fragColor = vec4(d1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 184]], "test": "untested"}
{"id": "MdyfDm", "name": "oil", "author": "louis_C", "description": "test for integration with the API ", "tags": ["oil"], "likes": 4, "viewed": 279, "published": 3, "date": "1614706175", "time_retrieved": "2024-07-30T19:35:01.390318", "image_code": "float sv(vec2 uv){return length(texture(iChannel0, uv).xyz);}    \nvec2 g(vec2 uv,float e){    \nreturn vec2(sv(uv+vec2(e,0.))-sv(uv-vec2(e,0.)),sv(uv+vec2(0.,e))-sv(uv-vec2(0.,e)))/e;}\nvoid mainImage( out vec4 k, vec2 p )\n{\n    vec2 uv = p/iResolution.xy;\n     vec3 n = vec3(g(uv,0.001),200.);\n    n=normalize(n);\n    vec3 li =vec3(0.5,0.5,1.);\n    float sha=clamp(dot(n,li),0.,1.0);\n\tvec3 img = texture(iChannel0, uv).xyz;\n\tk =vec4(img*sha,0.);\n    \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "lowp float RGBToL(lowp vec3 f){lowp float g=min(min(f.r,f.g),f.b),r=max(max(f.r,f.g),f.b);return(r+g)/2.;}lowp vec3 RGBToHSL(lowp vec3 f){lowp vec3 i;lowp float g=min(min(f.r,f.g),f.b),r=max(max(f.r,f.g),f.b),m=r-g;i.b=(r+g)/2.;if(m==0.)i.r=0.,i.g=0.;else{if(i.b<.5)i.g=m/(r+g);else i.g=m/(2.-r-g);lowp float v=((r-f.r)/6.+m/2.)/m,b=((r-f.g)/6.+m/2.)/m,H=((r-f.b)/6.+m/2.)/m;if(f.r==r)i.r=H-b;else if(f.g==r)i.r=1./3.+v-H;else if(f.b==r)i.r=2./3.+b-v;if(i.r<0.)i.r+=1.;else if(i.r>1.)i.r-=1.;}return i;}lowp float HueToRGB(lowp float r,lowp float f,lowp float i){if(i<0.)i+=1.;else if(i>1.)i-=1.;lowp float l;if(6.*i<1.)l=r+(f-r)*6.*i;else if(2.*i<1.)l=f;else if(3.*i<2.)l=r+(f-r)*(2./3.-i)*6.;else l=r;return l;}lowp vec3 HSLToRGB(lowp vec3 f){lowp vec3 i;if(f.g==0.)i=vec3(f.b);else{lowp float l;if(f.b<.5)l=f.b*(1.+f.g);else l=f.b+f.g-f.g*f.b;lowp float r=2.*f.b-l;i.r=HueToRGB(r,l,f.r+1./3.);i.g=HueToRGB(r,l,f.r);i.b=HueToRGB(r,l,f.r-1./3.);}return i;}\n\n    float ov(float base, float blend) {\n    return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));}\nvec3 ov3(vec3 a, vec3 b){\n    return vec3(ov(a.x,b.x),ov(a.y,b.y),ov(a.z,b.z));}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 u2 = fract(uv*vec2(1.,2.));\n    vec3 diff = vec3(vec2(1.)/iResolution.xy,0.);\n    vec2 fac = vec2(iResolution.x/iResolution.y,1.);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float mp =smoothstep(0.15,0.,length((mouse-u2)*fac));\n    float mp2 =smoothstep(0.45,0.,length((mouse-uv)*fac));\n    \n    vec2 uv2 = vec2(uv.x,map(u2.y,0.,1.,0.,0.5));\n    vec2 uv3 = vec2(uv.x,map(u2.y,0.,1.,0.5,1.));\n    \n    float center = texture(iChannel0,uv2).a;\n    float top = texture(iChannel0,uv-diff.zy).a;\n    float left = texture(iChannel0,uv-diff.xz).a;\n    float right = texture(iChannel0,uv+diff.xz).a;\n    float bottom = texture(iChannel0,uv+diff.zy).a;\n    \n    float bb = texture(iChannel0,uv3).a;\n    \n    float red = -(bb-0.5)*2.+(top+left+right+bottom-2.);\n    red += mp;red *= 0.995;red *= step(0.1,iTime);red = 0.5 +red*0.5;\n    red = clamp(red,0.,1.);\n    \n    float f = mix( red,center,step(0.5,uv.y));\n    float k2 = mix(0.55,0.9,mix(texture(iChannel0,uv*vec2(1.,0.5)).a,0.5,mp2));\n    vec2 p2 =uv;\t\n\t\t\t\t\t\t\n\tp2 = 5.*p2;\t\n    vec4 k3 = k2 +sin(2.*sin(vec4(k2)*10.)+p2.yxyy-p2.yyxy*.5)/12.;\n    lowp float lightness = RGBToL(k3.rgb);\n    float s1 = 0.144;\n    float s2 = -0.312;\n    float s3 = -0.144;\n    float m1 = 0.232;\n    float m2 = -0.192;\n    float m3 = 0.128;\n    float l1 = -0.136;\n    float l2 = 0.096;\n    float l3 = 0.136;\n    lowp vec3 s = smoothstep(1./1.5,0.,lightness)*(vec3(s1,s2,s3));\n    lowp vec3 m = smoothstep(0.,1./3.,lightness)*smoothstep(1.,2./3.,lightness)*(vec3(m1,m2,m3));\n    lowp vec3 l = smoothstep(2./3.,1.,lightness)*(vec3(l1,l2,l3));\n    lowp vec3 newColor = k3.xyz+s+m+l ;\n        newColor = clamp(newColor, 0.0, 1.0); \n\t\tlowp vec3 newHSL = clamp(RGBToHSL(newColor),0.,1.);\n        lowp float oldLum = RGBToL(k3.xyz);\n        k3.xyz = HSLToRGB(vec3(newHSL.x, newHSL.y, oldLum));\n    vec3 mask = mix(vec3(0.,0.,0.368),vec3(-3.,0.12,0.12),distance((-1.+2.*uv)*0.464,vec2(0.)));\n    vec3 k4 =ov3(clamp(k3.xyz,0.,1.),mask);\n    fragColor = vec4(vec3(k4),f);\n}\n    ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [66, 66, 90, 90, 183], [184, 184, 222, 222, 452]], "test": "untested"}
{"id": "WtVBzK", "name": "Fractal 31_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 8, "viewed": 314, "published": 3, "date": "1614691029", "time_retrieved": "2024-07-30T19:35:02.165246", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O+=mix(vec4(1),cos(vec4(1,2,3,0)+log(s))*5.,.3)/length(p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-.9,1.5);\n        p=R(p,normalize(vec3(1,8,0)),iTime*.2);   \n        s=3.;\n        s*=e=6./min(dot(p,p),2.);\n        p=abs(p)*e;\n        for(int i=0;i++<2;){\n            p.x =1.-abs(p.x-5.2);\n            p.y =3.6-abs(p.y-4.3);\n            p.z =1.8-abs(p.z-2.5);\n            s*=e=8./min(dot(p,p),9.);\n            p=abs(p)*e;\n        }\n        g+=e=min(length(p.xz)-.3,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 731]], "test": "untested"}
{"id": "ttVfzy", "name": "Nox DDA (fixed)", "author": "NoxWings", "description": "Nox DDA", "tags": ["noxdda"], "likes": 1, "viewed": 180, "published": 3, "date": "1614675150", "time_retrieved": "2024-07-30T19:35:03.114707", "image_code": "#define AA 0.01\nconst vec3 white = vec3(1,1,1);\nconst vec3 red = vec3(1,0,0);\nconst vec3 green = vec3(0,1,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 yellow = vec3(1,1,0);\n\nvec2 grid(vec2 uv, float rep) {\n    return (uv * vec2(iResolution.x / iResolution.y, 1.0) * rep);\n}\n\nfloat drawGrid(vec2 uv, float minThick, float maxThick) {\n    return max(\n        smoothstep(maxThick, minThick, min(uv.x, uv.y)),\n        smoothstep(maxThick, minThick, min(1.0-uv.x, 1.0-uv.y))\n    );\n}\n\nfloat drawPoint(vec2 uv, float r) {\n    return smoothstep(r+AA, r, length(uv));\n}\n\nfloat distanceToSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat drawLine(vec2 uv, vec2 from, vec2 to, float thick) {\n    return smoothstep(thick+AA, thick, distanceToSegment(uv, from, to));\n}\n\nfloat drawDDA(vec2 uv, vec2 from, vec2 to) {\n    vec2 d = to - from;\n    float steps = max(abs(d.x), abs(d.y));\n    vec2 inc = d / steps;\n\n    float acc = 0.0;\n    for (int i = 1; i < int(steps); i++) {\n        vec2 p = from + inc * float(i);\n        acc += drawPoint(uv - p, 0.09);\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float reps = 15.0;\n    vec2 fuv = grid(uv, reps);\n    vec2 p1 = round(grid(abs(iMouse.zw) / iResolution.xy, reps));\n    vec2 p2 = round(grid(iMouse.xy / iResolution.xy, reps));\n    \n    float gridLines = drawGrid(fract(fuv), 0.00, 0.03);\n    float point1    = drawPoint(fuv - p1, 0.2);\n    float point2    = drawPoint(fuv - p2, 0.2);\n    float line      = drawLine(fuv, p1, p2, 0.02);\n    float dda       = drawDDA(fuv, p1, p2);\n\n    vec3 col = vec3(0.2);\n    col += vec3(0.7) * gridLines;\n    if (line > 0.5)   { col += blue   * line; }\n    if (point1 > 0.5) { col  = red    * point1; }\n    if (point2 > 0.5) { col  = green  * point2; }\n    if (dda > 0.5)    { col  = yellow * dda; }    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 206, 206, 274], [276, 276, 333, 333, 479], [481, 481, 516, 516, 562], [564, 564, 613, 613, 727], [729, 729, 787, 787, 862], [864, 864, 908, 908, 1170], [1172, 1172, 1229, 1229, 2010]], "test": "untested"}
{"id": "ttGBRV", "name": "The Pulse (FBM)", "author": "mrange", "description": "License CC0: The Pulse\nCreated for my team at work, Pulse", "tags": ["2d", "fbm"], "likes": 8, "viewed": 313, "published": 3, "date": "1614671607", "time_retrieved": "2024-07-30T19:35:04.011310", "image_code": "// License CC0: The Pulse\n//  Created for my team at work, Pulse\n\n// Uncomment below for a somewhat unsettling effect:\n// #define MONKAS\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define SCA(a)      vec2(sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define PSIN(x)     (0.5+0.5*sin(x))\n\nconst vec2 sca0  = SCA(0.0);\nconst mat2 rots1 = ROT(-PI/6.0-PI/2.0);\nconst mat2 rots2 = ROT(PI);\n\n// Approximate cosine from shadertoy but I can't find where I found it originally :(\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\nfloat dfcos(vec2 p, float freq) {\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n    \n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n    \n  float a = 0.18*freq;\n    \n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynomial min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat heart(vec2 p) {\n#ifdef MONKAS\n  p.x *= mix(1.0, 0.95, pow(PSIN(TTIME+2.5*p.y), 7.0));\n#endif  \n  // Late night maths\n  p.x = pabs(p.x, 0.075);\n  const float r  = 0.275;\n  const float l  = length(vec2(0.5-r, 1.0-r));\n  const float b  = atan((0.5-r)/(1.0-r));\n  const float c  = asin(r/l);\n  const float ll = l*cos(c);\n  const float a  = b + c;\n  const vec2 n   = vec2(cos(a), -sin(a));\n  const vec2 nn  = vec2(n.y, -n.x);\n  const vec2 off = vec2(0.5-r, 0.5-r);\n  const vec2 bot = vec2(0.0, -0.5);\n  const vec2 top = bot + -nn*ll;\n  const vec2 mid = vec2(0.0, 0.5-r-(0.5-r)/tan(a));\n  const float m1 = -dot(bot, n);\n  const float m2 = -dot(bot, nn);\n  const float m3 = -dot(top, nn);\n  const float m4 = -dot(mid, n);\n  vec2 rp = p;\n  rp -= n*min(0.0, dot(rp, n)+m4)*2.0;\n  float dc = length(p-off) - r;\n  float dl = dot(rp, n) + m1; \n  float dp = length(p - bot);\n  float d = 0.0;\n  d = (dot(p, nn) + m3) > 0.0 ? dl : dc;\n  d = (dot(p, nn) + m2) > 0.0 ? dp : d;\n  return d;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 n = floor(p + 0.5);\n  p = fract(p+0.5)-0.5;\n  return n;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// IQ's horseshoe\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  p *= rots1;\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  p *= rots2;\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat pulse(vec2 p) {\n  vec2 pp = p;\n  p.x += 1.95;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n\n  const float ss = 0.25;\n  float dw = dfcos(vec2(0.5*TIME, 0.0)+pp/ss, 0.5)*ss;\n  dw = abs(dw)-0.05;\n  dw = abs(dw)-0.025;\n\n  float d = 1E6;\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = pmax(d, -dw, 0.025);\n  \n  return d;\n}\n\nfloat height_(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = mod2_1(p0);\n  vec2 p1 = p*vec2(1.0, -1.0)+vec2(0.5, 0.66);\n  vec2 n1 = mod2_1(p1);\n  const float ss = 0.66;\n  float d0 = heart(p0/ss)*ss;\n  float d1 = heart(p1/ss)*ss;\n  float d = min(d0, d1);\n  return tanh_approx(smoothstep(0.0, -0.1,d)*exp(8.0*-d));\n}\n\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.0);\n  float tm = 123.0+TTIME/240.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 4; ++i) {\n    h += a*height_(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 1.15).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.25*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 20.0)*lcol1;\n  col += rm*pow(ref2, 20.0)*lcol2;\n\n  const float zp = 0.6;\n  float di = pulse(ppp/zp)*zp;\n  di -= 0.005;\n\n  col += -lcol2.zxy*0.125*(exp(-5.0*max(di, 0.0)));\n  col = col.zxy;\n \n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -di));\n  di = abs(di-0.025);\n  di = abs(di-0.0125);\n  col += 1.*lcol2.zxy*(exp(-20.0*max(di+0., 0.0)))*pow(PSIN(-0.8+p.x-p.y-TTIME/12.0), 10.0);\n\n  return col;\n}\n\n// Post processing I found somewhere on shadertoy years ago\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[553, 638, 660, 660, 694], [696, 696, 729, 729, 1063], [1065, 1065, 1093, 1113, 1189], [1191, 1214, 1253, 1253, 1338], [1340, 1340, 1379, 1379, 1408], [1410, 1410, 1440, 1440, 1467], [1469, 1469, 1490, 1490, 2448], [2450, 2450, 2477, 2477, 2542], [2544, 2544, 2575, 2575, 2601], [2603, 2615, 2642, 2642, 2718], [2720, 2738, 2788, 2788, 3005], [3007, 3007, 3030, 3030, 3160], [3162, 3162, 3185, 3185, 3258], [3260, 3260, 3283, 3283, 3320], [3322, 3322, 3345, 3345, 3578], [3580, 3580, 3603, 3603, 3681], [3683, 3683, 3704, 3704, 4415], [4417, 4417, 4440, 4440, 4736], [4739, 4739, 4761, 4761, 5129], [5131, 5131, 5152, 5152, 5358], [5360, 5360, 5380, 5380, 6812], [6814, 6874, 6910, 6910, 7143], [7145, 7145, 7200, 7200, 7453]], "test": "ok"}
{"id": "3dy3zm", "name": "Block streams", "author": "Plento", "description": "Quick god rayzz", "tags": ["2d", "blur", "godrays"], "likes": 17, "viewed": 387, "published": 3, "date": "1614669052", "time_retrieved": "2024-07-30T19:35:05.087433", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 color(vec2 uv){\n    float m = exp((sin(uv.y*3. - iTime)))+0.8;\n    uv.x *= m * 2.2;\n    uv.x += iTime;\n    \n\tvec2 fuv = fract(uv*7.);\n    uv.y += .9*iTime*sin(floor(uv*7.).x*0.4)+0.7;\n    vec2 id = floor(uv*7.);\n   \n    return vec3(smoothstep(.7, .27,fuv.x-0.5)*mod(id.y+id.x,2.0)*(hsh(id*999.)-.2));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv*=rot(1.6);\n    \n    vec3 col = color(uv);\n\tvec3 acc = vec3(0);\n    \n    float m = 0., c = 0.;\n    for(float i = 1.0; i >0.0; i-=0.02){\n        vec2 nc = uv*(i+hsh(u)*0.15);\n        m = step(1.1, length(color(nc)));\n        acc += vec3(m) * vec3(0.97, 0.94, 0.9);\n        c++;\n    }\n    acc /= c;\n    col += acc*1.3;\n    f = vec4(col * .55, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 114, 114, 231], [233, 233, 253, 253, 540], [542, 542, 582, 582, 978]], "test": "untested"}
{"id": "wtyBzK", "name": "Fractal 30_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 9, "viewed": 375, "published": 3, "date": "1614666311", "time_retrieved": "2024-07-30T19:35:06.132638", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O.xyz+=500.*abs(cos(vec3(3,2,1)+log(s)))/length(p)/i/i:p\n    )\n    {\n        p=g*d;\n        p.z-=16.;\n        p=R(p,normalize(vec3(0,10,1)),iTime*.5);   \n        s=3.;\n        p.y=abs(p.y)-1.8;\n        p=clamp(p,-3.,3.)*2.-p;\n        s*=e=6./clamp(dot(p,p),1.5,50.);\n        p=abs(p)*e-vec3(0,1.8,0);\n        p.xz =.8-abs(p.xz-2.);\n        p.y =1.7-abs(p.y-2.);\n        s*=e=12./clamp(dot(p,p),1.0,50.);\n        p=abs(p)*e-vec2(.2,1).xyx;\n        p.y =1.5-abs(p.y-2.);\n        s*=e=16./clamp(dot(p,p),.1,9.);\n        p=abs(p)*e-vec2(.3,-.7).xyx;\n        g+=e=min(\n            length(p.xz)-.5,\n            length(vec2(length(p.xz)-12.,p.y))-3.\n            )/s;\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 910]], "test": "untested"}
{"id": "wtKBWw", "name": "Distance to Parabola", "author": "oneshade", "description": "I worked out the distance to a parabola!", "tags": ["2d", "sdf", "distance", "cubic", "parabola"], "likes": 2, "viewed": 154, "published": 3, "date": "1614656005", "time_retrieved": "2024-07-30T19:35:06.978377", "image_code": "/*\nThe idea is to find the x coordinate on the parabola that minimizes the\ndistance between the point and the parabola.\n\nFirst set up the distance-for-x-coordinate function:\nd(x) = (x - p.x)^2 + (hx^2 - p.y)^2\n\nNow we need to minimize it! How though?\nWe can't answer that directly, but we can narrow it down to a finite\ncollection of points and then test each one.\n\nThe idea behind how to figure out where potential minimums are is\nto realize that if it IS a minimum, then the function must be increasing\naway it, other wise there has to be something smaller. If its increasing away\nfrom it, then coming in from the left, the function must be decreasing, and\ngoing out on the right, the function must be increasing. Somewhere in between,\nit must not be increasing or decreasing at all.\n\nTo figure out how much a function is increasing and decreasing we need\ncalculus. Specifically, the derivative. Then, knowing that we have simply\nto solve for where its derivative is zero (the function is not increasing\nor decreasing).\n\nSo I'll wrap up the maths (d'(x) means derivative of d(x)):\nd'(x) = 2(x - p.x) + 4(hx^2 - p.y)hx\n\nd'(x) = 0\n2(x - p.x) + 4(hx^2 - p.y)hx = 0\n2h^2x^3 + (1 - 2p.yh)x - p.x = 0\n\nWhich is a cubic equation, one of whose roots is the minimum.\n*/\n\n#define eta 1.0471975512 // pi/3\nfloat sdParabola(in vec2 p, in float h) {\n    if (abs(h) < 1e-3) return p.y;\n    p.x = abs(p.x);\n\n    float d0 = (1.5 / h - 3.0 * p.y) / h, d1 = 13.5 * p.x / (h * h);\n    float q = d1 * d1 + 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 c = vec2(step(0.0, q) * j - d1, step(0.0, -q) * j);\n    if (abs(c.x) + abs(c.y) < 1e-3) c = vec2(-j - d1, 0.0);\n    float t = atan(c.y, c.x) / 3.0, r = pow(0.25 * dot(c, c), 1.0 / 6.0);\n\n    float w = d0 / r - r;\n    float x = max(w * cos(t), -w * cos(t - eta)) / 3.0;\n    return length(p - vec2(x, h * x * x)) * sign(h * p.x * p.x - p.y) * sign(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float a = sin(0.25 * iTime) * 16.0;\n    float b = cos(0.25 * iTime);\n    float c = 0.25 * sin(0.5 * iTime);\n\n    float d = sdParabola(uv + vec2(0.5 * b / a, 0.25 * b * b / a - c), a);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1297, 1297, 1338, 1338, 1887], [1889, 1889, 1944, 1944, 2543]], "test": "untested"}
{"id": "WlyfzV", "name": "[live] CC2021 winter shader jam ", "author": "w23", "description": "Shader coded live in Bonzomatic with feedback for CC2021 winter shader jam.\nPoV livecoding video: https://www.youtube.com/watch?v=qJHWzyXCUtw\nJam stream vod: https://www.twitch.tv/videos/923078569?t=01h35m41s", "tags": ["feedback", "live", "bonzomatic"], "likes": 11, "viewed": 432, "published": 3, "date": "1614655111", "time_retrieved": "2024-07-30T19:35:07.833092", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 E=vec3(0.,.01, 1.);\nfloat t, dt;\n\n//#define T(t,s) texture(t,(s)/textureSize(t,0))\n#define N(s) (texture(iChannel1, (s*.5)/vec2(iChannelResolution[1])).r/3.)\n#define ffti(s) (t*5.+.5 *pow(sin(t*s/2.), 2.)) // T(texFFTIntegrated, s).r\n#define ffts(s) (N(t*10.+s*10.)*3.) // T(texFFTSmoothed, s).r\n#define Pf(s) texture(iChannel0, (s)/iResolution.xy)\n\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat vmax(vec3 v){return max(max(v.x, v.y), v.z);}\nfloat vmax(vec2 v){return max(v.x, v.y);}\nfloat vmax(float v) { return v; }\n#define box(v, s) vmax(abs(v) - (s))\n//float box(vec2 v, vec2 s) { return vmax(abs(v) - s); }\n#define rep(v,s) (mod((v),(s)) - (s)*.5)\n\nfloat hash(float f){return fract(sin(f)*47382.452378);}\n\nvec3 cp = vec3(0.);\nfloat wd=1e6, wb = 1e6, wr = 1e6, wg = 1e6;\n\nfloat sqr(vec3 pb, float rsb, float thicc, vec2 is, vec2 es, float fftr) {\n  float cb = floor(pb.z / rsb);\n  pb.z = rep(pb.z, rsb);\n  float db = box(pb.z, thicc);\n  pb.xy *= R(.5 + cb*.1 + fftr * ffti(mod(cb+t, 16.)));\n  db = max(db, -box(pb.xy, is));\n  db = max(db, box(pb.xy, es));\n  return db;\n}\n\nfloat w(vec3 p) {\n  wg = p.y + N(p.xz*10.) * 2.;\n  \n  wr = length(cp-p-vec3(.08, 0.1, .6)) - .1;\n  \n  wb = sqr(p, 1.5, .4, vec2(1.), vec2(1.1), .001);\n  wb = min(wb, sqr(p, 7., 1.4, vec2(5.), vec2(5.1), 0.));\n  \n  {\n    vec3 prcss = vec3(5.);\n    vec3 prC = floor(p/prcss);\n    vec3 prc = rep(p, prcss);\n    prc.y += sin(t + prC.z * 10.);\n    prc.xy *= R(hash(prC.z)*70.);\n    prc.xz *= R(hash(prC.x)*60.);\n    wb = min(wb, box(prc, vec3(.1)));\n  }\n\n  return wd = min(min(wb, wr), wg);\n}\n\nvec3 wn(vec3 p) {\n  return normalize(vec3(\n    w(p+E.yxx) - w(p-E.yxx),\n    w(p+E.xyx) - w(p-E.xyx),\n    w(p+E.xxy) - w(p-E.xxy)));\n}\n\nfloat tr(vec3 O, vec3 D, float l, float L) {\n  for(float i=0.;i<100.;++i) {\n    float d=w(O+D*l);l+=d;\n    if (d<.001*l||l>L) break;\n  }\n  return l;\n}\n\n  vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos((t*c + d) * 3.141593*2.);\n  }\n\nvec3 ld;\nvec3 lc = vec3(.9, .7, .5);\n\nvec3 bg(vec3 d) {\n  return mix(vec3(1.), \n    vec3(.5, .6, .9), smoothstep(0., .2, d.y));\n}\n\nfloat ao(vec3 p, vec3 n, float S, float L) {\n  float v = 1.;\n  L /= S;\n  for (float s=1.;s<=S;++s) {\n    float l = L * s;\n    float d = w(p + n * l);\n    v -= max(0., l-d) * l;\n  }\n  return clamp(v / S, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime, dt = iTimeDelta;\n    ld = normalize(vec3(sin(t*.1)*3.,1.,-4.*cos(ffti(7.)*.1 + t*.3)));\n    \n    vec2 pix = fragCoord.xy;\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 O=vec3(0., .1, 5. - ffti(5.)*.6 - t), D=normalize(vec3(uv, -1.)),C=vec3(0.);\n  cp = O;\n  O.x += (N(t*10.)-.2)*3.*.3;\n  O.y += (N(t*7.)-.2)*1.*.3;\n  O.z += (N(t*3.)-.2)*4.*.3;\n  D.xz *= R((N(t*.3)-.2)*3.);\n  \n  vec3 kc = vec3(1.);\n  for (float r= 0.;r<2.;++r) {\n    float L=30.,l=tr(O,D,0.,L);\n    \n    vec3 bgc = bg(D);\n    \n    if (l > L) {\n      C += kc * bgc;\n      break;\n    }\n    \n    vec3 p = O + D * l;\n      \n    int mat = (wd == wb) ? 1\n      : (wd == wr) ? 2 : 0;\n      \n    vec3 n = wn(p);\n    vec3 md = vec3(1.);\n    \n    if (mat == 0) {\n      md = vec3(.95, .6, .5);\n      //md = vec3(.68, .6, .45);\n    }\n\n    float shl = 30.;\n    float sh = step(shl, tr(p, ld, .1, shl));\n    vec3 c = lc * md * max(0., dot(n, ld)) * sh;\n    float aoc = 0.\n      + ao(p, n, 4., .2)\n      + ao(p, n, 4., .8);\n    aoc /= 2.;\n    c += md * bg(E.xzx) * .3 * aoc;\n    //c = vec3(aoc);\n      \n    C += kc * mix(bgc, c, 1. - l/L);\n    \n    if (mat == 2) {\n      kc *= md * .8;\n      O = p + n * .01;\n      D = reflect(D, n);\n    } else break;\n  }\n  \n  float A = 0.;\n  \n  float a = N(pix/3. + floor(ffti(9.))*40.) * 17.;\n  vec2 off = vec2(cos(a), sin(a)) * 3.;\n  off -= uv * 30.;\n  \n  A += Pf(pix + off).a;\n  A -= dt * 2.;\n  \n  A = clamp(A, 0., 1.);\n  //A = 0.;\n  \n  float ca = dot(C, E.zzz) / 3.;\n  C += .2 * A * E.zzz;//pal(A, vec3(0.,.0,.0), vec3(.5, .1, .8), vec3(.25, .2, .5) * 3., vec3(.1,.2,.3));\n  A += step(.5, ca);\n\n\tfragColor = vec4(sqrt(C), A);\n}", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "3tyfzV", "name": "Trilinear Isosurface Explorer", "author": "oneshade", "description": "Messing around with my trilinear surface intersector and decided to try making a simple UI to allow me to interact with it.", "tags": ["ray", "interactive", "intersection", "isosurface", "ui", "trilinear", "interpolation", "sliders", "explorer"], "likes": 77, "viewed": 1426, "published": 3, "date": "1614651089", "time_retrieved": "2024-07-30T19:35:08.703764", "image_code": "// Line drawing utility\nvoid drawLine(inout vec3 color, in vec3 lineColor, in vec2 p, in vec2 a, in vec2 b) {\n     float unit = 2.0 / iResolution.y;\n \n     vec2 pa = p - a, ba = b - a;\n     float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n     float d = length(pa - ba * h);\n \n     color = mix(color, lineColor, smoothstep(unit, 0.0, d));\n}\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// Quick slider drawing function, not super customizable\nvoid drawSlider(inout vec3 color, in vec2 p, in vec2 pos, in float len, in float rmin, in float rmax, in float val) {\n    p -= pos;\n\n    float hlen = 0.5 * len;\n    float unit = 2.0 / iResolution.y;\n\n    float d = length(vec2(max(0.0, abs(p.x) - hlen), p.y)) - 0.01;\n    color = mix(color, vec3(0.5), smoothstep(unit, 0.0, d));\n\n    d = length(p - vec2(mix(-hlen, hlen, (val - rmin) / (rmax - rmin)), 0.0)) - 0.02;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, d));\n}\n\n// Cubic solver\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return h < 0.0 ? 1 : 3;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec3 roots;\n    int nroots = solveCubic(d, c, b, a, roots);\n    roots.x = 1.0 / roots.x;\n    if (nroots > 1) roots.yz = 1.0 / roots.yz;\n    return vec4(roots, nroots);\n}\n\n// Intersection\nvec4 iTrilinearIsoSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    vec3 v = vec3(b, c, e) - a;\n\n    vec3 xxyyzz = ro.xxy * ro.yzz;\n    vec3 uuvvww = rd.xxy * rd.yzz;\n\n    float t3 = u.x * rd.x * rd.y * rd.z;\n    float t2 = dot(ro.zyx, uuvvww) * u.x + dot(u.yzw, uuvvww);\n    float t1 = dot(u, vec4(dot(xxyyzz, rd.zyx), dot(ro.xy, rd.yx), dot(ro.xz, rd.zx), dot(ro.yz, rd.zy))) + dot(v, rd);\n    float t0 = u.x * ro.x * ro.y * ro.z + dot(u.yzw, xxyyzz) + dot(v, ro) + a;\n\n    return solveCubic2(t3, t2, t1, t0);\n}\n\n// Normal\nvec3 nTrilinearIsoSurf(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    return normalize(u.x * p.yxx * p.zzy + u.yyz * p.yxx + u.zww * p.zzy + vec3(b, c, e) - a);\n}\n\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(0.5)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = ((iMouse.xy - center) / iResolution.y - renderOffs) * 3.14;\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.0);\n    if (mouse.x < -1.5) mouse = vec2(0.0);\n\n    vec2 uv1 = (fragCoord - center) / iResolution.y, uv2 = uv1 - renderOffs;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv2, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Center (the surface goes from (0, 0, 0) to (1, 1, 1))\n    ro += 0.5;\n\n    // Isovalues\n    float a = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    float b = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    float c = texelFetch(iChannel0, ivec2(2, 0), 0).x;\n    float d = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n    float e = texelFetch(iChannel0, ivec2(4, 0), 0).x;\n    float f = texelFetch(iChannel0, ivec2(5, 0), 0).x;\n    float g = texelFetch(iChannel0, ivec2(6, 0), 0).x;\n    float h = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n\n    vec4 intersect = iTrilinearIsoSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    // Render the surface\n    if (intersecting) {\n        vec3 n = nTrilinearIsoSurf(hitPos, a, b, c, d, e, f, g, h);\n        fragColor = vec4(abs(n), 1.0);\n    }\n\n    // Bounding box geometry\n    vec3[] bboxVerts = vec3[8](vec3(-0.5, -0.5, -0.5), vec3( 0.5, -0.5, -0.5),\n                               vec3(-0.5,  0.5, -0.5), vec3( 0.5,  0.5, -0.5),\n                               vec3(-0.5, -0.5,  0.5), vec3( 0.5, -0.5,  0.5),\n                               vec3(-0.5,  0.5,  0.5), vec3( 0.5,  0.5,  0.5));\n\n    ivec2[] bboxEdges = ivec2[12](ivec2(0, 1), ivec2(1, 3), ivec2(3, 2), ivec2(2, 0),\n                                  ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7),\n                                  ivec2(4, 5), ivec2(5, 7), ivec2(7, 6), ivec2(6, 4));\n\n    // Transform bounding box vertices\n    for (int v=0; v < 8; v++) {\n        vec3 vert = bboxVerts[v];\n        vert.xz *= mat2(cy, sy, -sy, cy);\n        vert.yz *= mat2(cp, sp, -sp, cp);\n        vert.z -= 3.0;\n        bboxVerts[v] = vert;\n    }\n\n    // Render bounding box\n    for (int e=0; e < 12; e++) {\n        ivec2 edge = bboxEdges[e];\n        vec3 a1 = bboxVerts[edge[0]];\n        vec3 b1 = bboxVerts[edge[1]];\n        if (max(-a1.z, -b1.z) < tMin) {\n            vec2 a2 = -a1.xy / a1.z;\n            vec2 b2 = -b1.xy / b1.z;\n            drawLine(fragColor.rgb, vec3(0.0, 1.0, 0.0), uv2, a2, b2);\n        }\n    }\n\n    // Draw sliders\n    float hlen = 0.5 * sliderLen;\n    float[] isovalues = float[8](a, b, c, d, e, f, g, h);\n    int[] chars = int[8](65, 66, 67, 68, 69, 70, 71, 72); // A, B, C, D, E, F, G, H\n    for (int i=0; i < 8; i++) {\n        drawSlider(fragColor.rgb, uv1, sliders[i], sliderLen, sliderMin, sliderMax, isovalues[i]);\n        drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[i].x + hlen + 0.075, sliders[i].y), vec2(0.065), chars[i]);\n\n        // Label the corner\n        vec3 corner = bboxVerts[i];\n        if (-corner.z < tMin) {\n            corner.xy += normalize(corner.xy) * 0.1;\n            vec2 charPos = -corner.xy / corner.z;\n            drawChar(fragColor.rgb, vec3(1.0), uv2, charPos, vec2(0.065), chars[i]);\n        }\n    }\n\n    // -\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x - hlen, sliders[0].y + 0.085), vec2(0.065), 45);\n\n    // 5\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x - hlen + 0.025, sliders[0].y + 0.085), vec2(0.065), 53);\n\n    // 0\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x, sliders[0].y + 0.085), vec2(0.065), 48);\n\n    // 5\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x + hlen - 0.025, sliders[0].y + 0.085), vec2(0.065), 53);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        if (iFragCoord.x == 0) fragColor.x = 0.0;\n        if (iFragCoord.x == 1) fragColor.x = -1.25;\n        if (iFragCoord.x == 2) fragColor.x = 0.5;\n        if (iFragCoord.x == 3) fragColor.x = 0.0;\n        if (iFragCoord.x == 4) fragColor.x = -0.75;\n        if (iFragCoord.x == 5) fragColor.x = 0.0;\n        if (iFragCoord.x == 6) fragColor.x = 0.0;\n        if (iFragCoord.x == 7) fragColor.x = 2.0;\n    }\n\n    if (iFrame > 0 && iFragCoord.y == 0 && iFragCoord.x < 8) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n        // Slider state\n        vec2 slider = sliders[iFragCoord.x];\n        vec2 sliderEnds = slider.x + vec2(-0.5, 0.5) * sliderLen;\n        vec2 curPos = vec2(mix(sliderEnds.x, sliderEnds.y, (fragColor.x - sliderMin) / (sliderMax - sliderMin)), slider.y);\n\n        // Update the slider if it is within the selection radius\n        if (iMouse.z > 0.0 && length(mouse - curPos) < selectRadius) {\n            fragColor.x = mix(sliderMin, sliderMax, clamp((mouse.x - sliderEnds.x) / sliderLen, 0.0, 1.0));\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Offset of the 3D render\n#define renderOffs vec2(0.3, 0.0)\n\n// Mouse selection radius\n#define selectRadius 0.05\n\n// Slider range\n#define sliderMin -5.0\n#define sliderMax 5.0\n\n// Slider length\n#define sliderLen 0.5\n\n// Slider positions (top to bottom)\nconst vec2[] sliders = vec2[8](vec2(-0.55,  0.35),\n                               vec2(-0.55,  0.25),\n                               vec2(-0.55,  0.15),\n                               vec2(-0.55,  0.05),\n                               vec2(-0.55, -0.05),\n                               vec2(-0.55, -0.15),\n                               vec2(-0.55, -0.25),\n                               vec2(-0.55, -0.35));", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 109, 109, 345], [347, 425, 529, 529, 864], [866, 923, 1040, 1040, 1400], [1459, 1459, 1539, 1539, 2327], [2329, 2329, 2395, 2395, 2569], [2571, 2587, 2731, 2731, 3277], [3279, 3289, 3420, 3420, 3613], [3615, 3615, 3661, 3661, 3725]], "test": "untested"}
{"id": "3tyBzV", "name": "Heart - distance 2D", "author": "iq", "description": "Distance to a simple heart shape (hardcoded to 45 degree). Correct interior and exterior euclidean distances.", "tags": ["2d", "sdf", "heart", "distance"], "likes": 34, "viewed": 4033, "published": 3, "date": "1614647075", "time_retrieved": "2024-07-30T19:35:09.470713", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to 45 degree heart shape, with only two square roots\n// (or 1, if the GPU supports actual branching)\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    p.y += 0.5;\n    m.y += 0.5;\n\n    float d = sdHeart(p);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdHeart(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n   // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBzV.jpg", "access": "api", "license": "mit", "functions": [[1321, 1321, 1346, 1346, 1365], [1367, 1367, 1395, 1395, 1615], [1617, 1617, 1674, 1710, 2402]], "test": "untested"}
{"id": "WtyBRV", "name": "Simple heart shape", "author": "mrange", "description": "License CC0: Simple heart shape\nMany examples of heart shapes on shadertoy. \nI didn't really understand them so decided to create one of my own\n", "tags": ["2d"], "likes": 5, "viewed": 517, "published": 3, "date": "1614638682", "time_retrieved": "2024-07-30T19:35:10.298500", "image_code": "// License CC0: Simple heart shape\n// Many examples of heart shapes on shadertoy. \n// I didn't really understand them so decided to create one of my own\n#define RESOLUTION    iResolution\n\n\nfloat heart(vec2 p) {\n  // Late night maths\n  p.x = abs(p.x);\n  const float r  = 0.275;\n  const float l  = length(vec2(0.5-r, 1.0-r));\n  const float b  = atan((0.5-r)/(1.0-r));\n  const float c  = asin(r/l);\n  const float ll = l*cos(c);\n  const float a  = b + c;\n  const vec2 n   = vec2(cos(a), -sin(a));\n  const vec2 nn  = vec2(n.y, -n.x);\n  const vec2 off = vec2(0.5-r, 0.5-r);\n  const vec2 bot = vec2(0.0, -0.5);\n  const vec2 top = bot + -nn*ll;\n  const vec2 mid = vec2(0.0, 0.5-r-(0.5-r)/tan(a));\n  const float m1 = -dot(bot, n);\n  const float m2 = -dot(bot, nn);\n  const float m3 = -dot(top, nn);\n  const float m4 = -dot(mid, n);\n  vec2 rp = p;\n  rp -= n*min(0.0, dot(rp, n)+m4)*2.0;\n  float dc = length(p-off) - r;\n  float dl = dot(rp, n) + m1; \n  float dp = length(p - bot);\n  float d = 0.0;\n  d = (dot(p, nn) + m3) > 0.0 ? dl : dc;\n  d = (dot(p, nn) + m2) > 0.0 ? dp : d;\n  return d;\n}\n\nfloat df(vec2 p) {\n  float dh = heart(p)-0.025;\n  return dh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float d = df(p);\n  \n  vec3 col = vec3(0.1);\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  if (p.x > 0.0) {\n    col += 0.5*cos(d*100.0);\n  }\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[189, 189, 210, 232, 1081], [1083, 1083, 1101, 1101, 1145], [1147, 1147, 1204, 1204, 1516]], "test": "untested"}
{"id": "3tGfRK", "name": "Feather Feather everywhere", "author": "YitingLiu", "description": "following a tutorial https://youtu.be/hlM940IqpRU\n", "tags": ["smoothstep", "feather", "artofthecode"], "likes": 3, "viewed": 309, "published": 3, "date": "1614635182", "time_retrieved": "2024-07-30T19:35:11.152217", "image_code": "#define S smoothstep \n#define T (iTime*.05)\n\n\nmat2 Rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat Feather(vec2 p ){\n    float d = length(p-vec2(0,clamp(p.y,-.3,.3)));\n    float r = mix(.1,.01,S(-.3,.3,p.y));// feather shape \n    float m = S(.01,.0,d-r);\n    \n    float side = sign(p.x);\n    //strands \n    float x = .9*abs(p.x)/r;// stretch out the corner \n    float wave = (1.-x)*sqrt(x)+x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2)*80.+side*56.;// number of strands\n    float id = floor(y+20.);\n    \n    float n=fract(sin(id*564.2)*5623.2);\n    float shade = mix(.5,1.,n);\n    float strandLength = mix(.3,1.,fract(n*n*355.));\n    \n    // gaps in between strand \n    float strand = S(.4,.0,abs(fract(y)-.5)-.35);\n    strand*=S(.1,-.2,x-strandLength);\n    \n    d = length(p-vec2(0,clamp(p.y,-.45,.1)));\n\n    float stem = S(.002,.0,d+p.y*.025);\n    \n    return max(strand*m*shade,stem); \n\n\n}\n\nvec3 Transform(vec3 p, float angle){\n    p.xz*=Rot(angle);\n    p.xy*=Rot(angle*.5);// rotate along z axis as well \n    return p;\n\n}\n\nvec4 FeatherBall(vec3 ro, vec3 rd, vec3 pos,float angle ){\n\n    vec4 col = vec4(0);\n    float t = dot(pos-ro,rd);\n    \n    vec3 p = ro+rd*t;\n    float y = length(pos-p);\n    \n    if(y<1.){\n        float x = sqrt(1.-y);\n        vec3 pF = ro+rd*(t-x)-pos;//front intersection \n        pF = Transform(pF,angle);\n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);//y axis to be the up and down axis\n        uvF*=vec2(.3,.5);\n        \n        // alpha blending \n        \n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f),S(.0,.1,f));\n\n        vec3 pB = ro+rd*(t+x)-pos;//back intersection \n        pB = Transform(pB,angle);\n\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);//y axis to be the up and down axis\n        uvB*=vec2(.3,.5);\n        \n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b),S(.0,.1,b));\n        col=mix(back, front, front.a);// alpha blend - see both back and front \n\n   }\n   \n   return col;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float fft  = texelFetch( iChannel0, ivec2(0.,0.), 0 ).x; \n\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0,0,0.+mix(-3.,-1.5*min(fract(T),fft),sin(T*10.)));\n    vec3 rd = normalize(vec3(uv,1));\n \n    // bg\n    vec3 bg = vec3(.2,.5*fft,.9)*(uv.y+.5);\n    bg+=vec3(.9,fft*.8,.1)*(-uv.y+.5);\n    col = vec4(bg,0);\n    \n    \n    for (float i = 0.; i <=1.; i+=1./70.){\n         \n         float x =mix(-15.,15.,fract(i+T));\n         float y =mix(-6.,6.,fract(sin(i*643.2)*8593.1));\n         float z =mix(8.+min(.5,fft),0.,i);\n         float a = max(fract(i+T),fft)+T+i*5643.1;\n         vec4 feather = FeatherBall(ro,rd,vec3(x,y,z),a);\n         feather.rgb = mix(bg,feather.rgb,mix(.3,1.,i));\n         feather.rgb=sqrt(feather.rgb);\n         col = mix(col, feather, max(feather.a,fft)*feather.a);\n\n    \n    }\n \n     col = pow(col, vec4(.4545));//gamma correction\n   \n    \n    // Output to screen\n    fragColor =col;\n}", "image_inputs": [{"id": 25939, "src": "https://soundcloud.com/raveenaloves/honey-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 64, 64, 127], [129, 129, 152, 152, 929], [931, 931, 967, 967, 1062], [1064, 1064, 1122, 1122, 1998], [1999, 1999, 2056, 2056, 3033]], "test": "untested"}
{"id": "WtGBWm", "name": "Ray Marching w/ Blinn-Phong", "author": "Parcle", "description": "Ray Marching w/ Blinn-Phong \nJust a graphics knowledge test to see how far I could get without external reference.\nThough I did have to google using pow for the specular piece of Blinn-Phong shading. I forgot and it didn't quite look right without it...", "tags": ["raymarching"], "likes": 2, "viewed": 170, "published": 3, "date": "1614632506", "time_retrieved": "2024-07-30T19:35:11.924154", "image_code": "#define MAX_STEPS 120\n#define MISS_DIST 200.0\n// HIT_DIST should be treated as a non-inclusive max\n#define HIT_DIST 0.001\n#define SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH 0.5\n#define NUM_SPHERES 7\n\nstruct hit_result {\n    vec3 hitPos;\n    float dist;\n    int iterations;\n    bool hit;\n};\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nvec3 hitColor = vec3(0.8, 0.3, 0.5);\nconst float pi = 3.141592;\nconst float tau = pi * 2.0;\n\nfloat sdSphere(vec3 rayPos);\nfloat sdXZQuad(vec3 rayPos);\nfloat sdScene(vec3 rayPos);\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir);\nvec3 calcLighting(vec3 hitPos);\nvec3 getNormal(vec3 hitPos);\nmat2 rotate(float rads);\nmat3 lookAt(vec3 origin, vec3 focus);\nhit_result castRay(vec3 rayOrigin, vec3 rayDir);\n\nvec3 cameraPos = vec3(0.0, 0.0, 100.0);\n \nvec4 spheresPosAndScale[NUM_SPHERES] = vec4[](\n                        vec4(0.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 0.0, 10.0, 4.5),\n                        vec4(0.0, 0.0, -10.0, 3.0),\n                        vec4(10.0, 0.0, 0.0, 4.5),\n                        vec4(-10.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 10.0, 0.0, 4.5),\n                        vec4(0.0, -10.0, 0.0, 3.0)\n                    );\nconst float xzPlaneYValue = -15.0;\nconst float xzPlaneScale = 35.0;\nconst float xzPlaneScaleInverse = 1.0 / xzPlaneScale;\nconst vec3 xzPlaneNormal = vec3(0.0, 1.0, 0.0);\n         \nconst float defaultSphereRadius = 1.0f;\nconst float rotationCyclesPerSecond = 0.10;\n\n\nconst vec3 lightColor = vec3(1.0);\nconst float ambientLightFactor = 0.3;\nconst float specularLightFactor = 0.3;\nconst float directionalLightFactor = 1.0 - ambientLightFactor - specularLightFactor;\nvec3 directionalLightDir;\n\nconst vec3 worldUp = vec3(0.0, 1.0, 0.0);\n\nmat3 lookAt(vec3 origin, vec3 focus) {\n    vec3 zBasis = normalize(origin - focus); // from focus to origin, as we look down the negative z axis\n    vec3 xBasis = normalize(cross(worldUp, zBasis));\n    vec3 yBasis = normalize(cross(zBasis, xBasis));\n    return mat3 (\n                    xBasis,\n                    yBasis,\n                    zBasis\n                );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - (iResolution.xy * 0.5);\n    uv /= iResolution.y;\n    uv *= 2.0;\n    \n    float tSin = sin(iTime * 0.5);\n    float tCos = cos(iTime * 0.5);\n    hitColor += vec3(0.0, hitColor.y * tSin, hitColor.z * tCos);\n    \n    // directional lights don't have a \"position\", it is simply useful to temporarily think of it this way to manipulate the direction\n    vec3 directionalLightPos = vec3(0.0, 50.0 + (25.0 * tSin), -100.0);\n    directionalLightDir = normalize(directionalLightPos - vec3(0.0)); // direction the light is coming from, NOT the direction the light \"flows\"\n    \n    // offset the spheres as a unit to orbit y axis\n    vec3 sphereOffsets = vec3(10.0 * tSin, 0.0, 10.0 * tCos);\n    \n    mat2 rotateMatrix = rotate(tau * iTime * rotationCyclesPerSecond);\n    \n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        // adjust sphere scales\n        float sinScaleFactor = (sin(iTime + (float(i) * pi * 0.7)) + 1.0) * 0.5;\n        spheresPosAndScale[i].w = mix(1.0, spheresPosAndScale[i].w, sinScaleFactor);\n        \n        // adjust sphere positions through rotation\n        spheresPosAndScale[i].xy = rotateMatrix * spheresPosAndScale[i].xy;\n         \n        // offset all spheres as a unit (orbiting y-axis)\n        spheresPosAndScale[i].xyz += sphereOffsets;\n    }\n    \n    \n    float cameraYFactor = (sin(iTime * 0.3) + 1.0) * 0.5;\n    cameraPos.y = cameraYFactor * 100.0;\n    vec3 rayOrigin = cameraPos;\n    const float cameraToPlaneZValue = -5.0;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, cameraToPlaneZValue));\n    vec3 focus = vec3(0.0, 0.0, 0.0);\n    mat3 lookAtMat = lookAt(cameraPos, focus);\n    rayDir = lookAtMat * rayDir;\n    \n    vec3 color = calcColor(rayOrigin, rayDir);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// note ray direction is expected to be normalized\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult = castRay(rayOrigin, rayDir);\n    return hitResult.hit ? calcLighting(hitResult.hitPos) : missColor;\n}\n\nhit_result castRay(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult;\n    hitResult.hit = false;\n    hitResult.iterations = 0;\n    hitResult.dist = 0.0;\n    while(hitResult.dist < MISS_DIST && hitResult.iterations < MAX_STEPS) {\n        vec3 currRayPos = rayOrigin + (hitResult.dist*rayDir);\n        float currDist = sdScene(currRayPos);\n        if(currDist < HIT_DIST) { // hit!\n            hitResult.hit = true;\n            hitResult.hitPos = currRayPos;\n            break;\n        }\n        hitResult.dist += currDist;\n        ++hitResult.iterations;\n    }\n    \n    return hitResult;\n}\n\nfloat sdScene(vec3 rayPos) {\n    float minDist = sdXZQuad((rayPos - vec3(0.0, xzPlaneYValue, 0.0)) * xzPlaneScaleInverse) * xzPlaneScale;\n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        minDist = min(minDist, sdSphere((rayPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w);\n    }\n\n    return minDist;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    float signedDist = length(rayPos) - defaultSphereRadius;\n    return signedDist;\n}\n\nfloat sdXZQuad(vec3 rayPos) {\n    rayPos = abs(rayPos);\n    rayPos.xz -= vec2(1.0, 1.0);\n    rayPos.xz = max(rayPos.xz, 0.0);\n    return length(rayPos);\n}\n\nvec3 calcLighting(vec3 hitPos) {\n    vec3 normal = getNormal(hitPos);\n    \n    // ambient\n    vec3 ambientContribution = ambientLightFactor * lightColor * hitColor;\n    \n    // diffuse\n    float normalLightDirAlignment = dot(normal, directionalLightDir);\n    vec3 diffuseContribution = normalLightDirAlignment * directionalLightFactor * lightColor * hitColor;\n    \n    // specular\n    vec3 viewDir = normalize(cameraPos - hitPos); // from hit position to camera pos\n    vec3 halfwayVector = normalize(directionalLightDir + viewDir);\n    float normalHalfwayAlignment = dot(normal, halfwayVector);\n    float specularStrength = pow(max(normalHalfwayAlignment, 0.0), 32.0); // NOTE: one line where I \"cheated\" and didn't pull from memory\n    vec3 specularContribution = specularStrength * lightColor * specularLightFactor; // ignore hit color for specular lighting\n    \n    // shadow\n    bool inShadow = castRay(hitPos + (SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH * normal), directionalLightDir).hit;\n    \n    return (normalLightDirAlignment < 0.0 || inShadow) ? ambientContribution : ambientContribution + diffuseContribution + specularContribution;\n}\n\n// Note: normal is returned normalized\nvec3 getNormal(vec3 hitPos) {\n    int closestIndex = 0;\n    float closestDist = sdSphere((hitPos - spheresPosAndScale[0].xyz) / spheresPosAndScale[0].w)  * spheresPosAndScale[0].w;\n    for(int i = 1; i < NUM_SPHERES; i++) {\n        float dist = sdSphere((hitPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w;\n        if(dist < closestDist) {\n            closestDist = dist;\n            closestIndex = i;\n        }\n    }\n    \n    return closestDist > HIT_DIST ? xzPlaneNormal : normalize(hitPos - spheresPosAndScale[closestIndex].xyz);\n}\n\nmat2 rotate(float rads) {\n    float sinTheta = sin(rads);\n    float cosTheta = cos(rads);\n    return mat2 ( \n                    cosTheta, sinTheta,\n                    -sinTheta, cosTheta\n                );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1732, 1732, 1770, 1770, 2103], [3938, 3989, 4034, 4034, 4162], [4164, 4164, 4213, 4213, 4758], [4760, 4760, 4788, 4788, 5102], [5104, 5104, 5133, 5133, 5219], [5221, 5221, 5250, 5250, 5375], [5377, 5377, 5409, 5409, 6523], [6525, 6564, 6593, 6593, 7137], [7139, 7139, 7164, 7164, 7348]], "test": "untested"}
{"id": "ttKfRG", "name": "Bezier Intersections pixelated", "author": "hamoid", "description": "A copy of https://www.shadertoy.com/view/WtVfRy but trying to imitate the style of the original source: http://truetex.com/bezint.htm", "tags": ["bezier", "intersections"], "likes": 1, "viewed": 284, "published": 3, "date": "1614607487", "time_retrieved": "2024-07-30T19:35:12.767897", "image_code": "// Idea from http://truetex.com/bezint.htm\n\nfloat n(float i) {\n  return 3.*sin(iTime*(sin(i*.03))+i);\n}\nfloat bezier(float t, float a, float b, float c, float d) {\n  float q = 1.0-t;\n  return q*q*q*n(a) + \n        3.*q*q*t*n(b) + \n          3.*q*t*t*n(c) + \n               t*t*t*n(d);\n}\nfloat color(vec2 uv) {\n  vec2 a = vec2(\n    bezier(uv.x, 1., -2., 3., -4.),\n    bezier(uv.x, 9., -8., 7., -6.)\n  );\n  vec2 b = vec2(\n    bezier(uv.y, 5., 2., 5., -5.),\n    bezier(uv.y, -1., -3., 8., 9.)\n  );\n  return distance(a, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 px = res / 2.0;\n    uv = floor(uv * px) / px;\n    vec3 col = vec3(1.,1.,.8) - step(fract(color(uv)*4.0), 0.08);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 62, 62, 103], [104, 104, 163, 163, 286], [287, 287, 309, 309, 521], [522, 522, 579, 579, 794]], "test": "untested"}
{"id": "tlVBRG", "name": "Spiraling Out", "author": "dr2", "description": "Some logarithmic spiraling", "tags": ["spiral", "polar", "singular"], "likes": 6, "viewed": 305, "published": 3, "date": "1614607256", "time_retrieved": "2024-07-30T19:35:13.536842", "image_code": "// \"Spiraling Out\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = mod (vec2 (0.5 * (pi * log (r) + a) - 0.5 * tCur, 5. * a) + 0.5, 1.) - 0.5;\n    q.y /= sqrt (r);\n    q.y -= 0.15 - 0.01 / r;\n    d = 0.5 * r * PrRoundCylDf (q.xzy, 0.35, 0.02, 0.15);\n    DMINQ (1);\n  }\n  q = p;\n  d = max (0., q.y);\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.5, 0.5, 1., 0.2) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 2) col4 = vec4 (0.5, 0.6, 1., 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec3 iResolution;\n  vec4 iMouse;\n  float iTime;\n#endif\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.03 * pi * tCur;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, -0.07 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -20.);\n  zmFac = 6.;\n  dstFar = 200.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[466, 466, 488, 488, 889], [891, 891, 924, 924, 1108], [1110, 1110, 1131, 1131, 1386], [1388, 1388, 1423, 1423, 1964], [2093, 2093, 2149, 2149, 3176], [3178, 3178, 3235, 3235, 3310], [3312, 3312, 3348, 3348, 3554], [3556, 3556, 3586, 3586, 3699]], "test": "untested"}
{"id": "ttVBWz", "name": "MC Error Blue Noise Diffusion", "author": "TinyTexel", "description": "Distributing the integration error in screen space via a shuffled+scambled Sobol LDS.\nImplements \"Screen-Space Blue-Noise Diffusion of Monte Carlo Sampling Error via Hierarchical Ordering of Pixels\"\n\nCamera controls via mouse + shift key", "tags": ["noise", "blue", "montecarlo", "bluenoise", "monte", "carlo", "lds"], "likes": 29, "viewed": 1207, "published": 3, "date": "1614604453", "time_retrieved": "2024-07-30T19:35:14.497274", "image_code": "\n/*\n    All the stuff is in Buffer A.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 uv0)\n{\n    ivec2 uv = ivec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n   #if 0\n   {\n       // high-pass filter (helps to find structures in the error noise)\n       col = (col*4.0 - (texelFetch(iChannel0, uv+ivec2(1,0),0)+\n                         texelFetch(iChannel0, uv+ivec2(0,1),0)+\n                         texelFetch(iChannel0, uv-ivec2(1,0),0)+\n                         texelFetch(iChannel0, uv-ivec2(0,1),0)).rgb)/8.0;\n       //col = abs(col);\n       col*= 12.0;                         \n   }\n  #endif\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\n\nDistributing the integration error in screen space via a shuffled+scambled Sobol low-discrepancy sequence.\n\nCtrl  - toggle split-screen off/on (white noise | blue noise - initialized Sobol sequence)\nTab   - toggle between white and blue noise if split-screen is off\nSpace - toggle progessive accumulation of samples on/off\n        -> progressive accumulation actually works much better with the white noise initialized LDS;\n           the blue noise variant produces blocky artifacts.\n           This is because with the white noise version every pixel uses its own sequence while\n           the blue noise variant just shifts the one sequence that is used by the whole screen\n\n\nThis is a basic implementation of [1] using the scrambling method for the Sobol sequence described in [2].\n\n[1] \"Screen-Space Blue-Noise Diffusion of Monte Carlo Sampling Error via Hierarchical Ordering of Pixels\"\n    - https://repository.kaust.edu.sa/bitstream/10754/666257/1/papers_437s4-file1.pdf\n\n[2] \"Practical Hash-based Owen Scrambling\"\n    - http://www.jcgt.org/published/0009/04/01/\n\nThe idea presented in [1] is to linearize the screen pixel coordinates in a locality/adjacency preserving manner and \nuse the resulting pixel id to generate samples with a Sobol sequence. \nThe Sobol LDS is used because of its property that given a power-of-2 long sequence it can be\nrecursively split in half so that each of the resulting sub-sequences will itself be a valid LDS.\n\nUsing the scrambling approach from [2] in combination with a simple Morton order pixel id is already pretty effective:~~\n\n    uint pxId = EncodeMorton2(uv);\n    vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId, seed));// 2d LDS sample for the current pixel\n\n[1] suggests to scramble the Morton order to get rid of structural patterns in the resulting Monte Carlo integration noise.\nI found that scrambling only some of the lower bits of the mortor order is sufficient since the Sobol scrambling of [2] \nis already doing a great job at reducing those artifacts. \nIn particular I replace the 4 least significant bits of the pixel id with the bits of a 4x4 pixels large Hilbert curve tile: \n\n    uint pxId = EncodeMorton2(uv);\n    {\n        // use a 4x4 Hilbert curve tile for the lower bits of pxId \n        // to break up structural patterns in the resulting MC noise:\n        const uint N = 2u;// 2^N == tile dimension\n        uint h = EvalHilbertCurve(uv, N);\n        \n        h += WeylHash(uv >> N);// add a random offset per tile\n\n        const uint M = (1u << (2u*N))-1u;// bit mask\n        pxId = (pxId & (~M)) ^ (h & M);// replace lower bits in pxId\n    }\n\nUsing larger Hilbert curve tiles is more expensive and can introduce structured low-frequency artifacts in the noise.\n\nGenerating multiple samples per pixel is straightforward:\n\n    uint count = 16u;// sample count must be a power-of-4 \n                     // since we (implicitly) hierarchically order our pixels in blocks of 4 to generate pxId\n                     // this is what makes this work with the Sobol LDS (since every pow-of-4 is also a pow-of-2)\n    for(uint i = 0u; i < count; ++i)\n    {\n        ...\n        vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, seed));\n        ...\n        // generate direction using s and trace\n    }\n\nThe shuffling of the Sobol sequence allows us to generate higher dimensional samples via padding.\nAll we need is to provide different seeds to the routine:\n\n    vec4 s = Float11(uvec4(shuffled_scrambled_sobol_2d(pxId*count+i, seedA),\n                           shuffled_scrambled_sobol_2d(pxId*count+i, seedB)));\n  \n  \nMove the camera inside the sphere to get a good look at the noise beneath it.\nCamera controls via mouse + shift key.\n*/\n\n\n#define SAMPLE_COUNT 4\n// needs to be a power-of-4 to work well with the diffusion scheme\n// 1, 4, 16, 64, 256, 1024, ...\n\n\n// linearizes uv using a Hilbert curve; tile dimension = 2^N\nuint EvalHilbertCurve(uvec2 uv, uint N)\n{\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by level)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n\n// scene intersection routine (a bit messy but I dont feel like cleaning it since it's not really important here)\nfloat Intersect_Scene(\nvec3 rp, vec3 rd,\nout float t, out vec3 n, out vec3 a)\n{\n     float hit = 0.0;\n   \n    // ground plate thingy:\n    {\n        vec3 c0p = vec3(0.0, -0.8, 0.0);\n        vec3 c0d = vec3(2.0, 0.125*0.5, 2.0);\n        \n        vec3 c1p = vec3(0.0, -0.64, 0.0);\n        vec3 c1d = vec3(2.5, 0.125, 1.5);\n        float c1dxz = 0.4;\n         c1d = vec3(c1dxz, 0.125, c1dxz);\n        \n        float c1ps = 0.85;\n        \n        c1p.xz = (floor(rp.xz*c1ps+0.5))/c1ps;\n        \n        bool isInsideC0 = IsInsideCube(rp, c0p, c0d);\n        bool isInsideC1 = IsInsideCube(rp, c1p, c1d);\n        \n        if(isInsideC0 && isInsideC1)\n        {\n            float t0; vec3 n0;\n            Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n            \n            if(IsInsideCube(rp+rd*t0, c0p, c0d))\n            {\n                hit = 1.0;\n                t = t0;\n                n = n0;\n            }\n        }\n        else\n        {\n            vec2 tt; vec3 n0, n1;\n            float th = Intersect_Ray_Cube(rp, rd, c0p, c0d, /*out:*/ tt, n0, n1);\n\n            hit = th > 0.0 ? 1.0 : 0.0;\n            t = tt.x;\n            n = n0;\n            a = vec3(1.0, 0.005, 0.005) * 0.8;\n            \n            if(hit==1.0) c1p.xz = (floor((rp.xz+rd.xz*t)*c1ps+0.5))/c1ps;\n            if(hit==1.0 && IsInsideCube(rp+rd*t, c1p, c1d))\n            {\n                float t0; vec3 n0;\n                Intersect_Ray_CubeBackside(rp, rd, c1p, c1d, t0, n0);\n\n                if(IsInsideCube(rp+rd*t0, c0p, c0d))\n                {\n                    t = t0;\n                    n = n0;                \n                }\n                else\n                {\n                    hit = 0.0;\n                }\n            }\n        }\n    }\n \n    // top sphere:\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    // bottom sphere:\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0, -2.25, 0.0), 2.0, /*out:*/ tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x - vec3(0.0, -2.25, 0.0));\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n    return hit;\n}\n\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == uint(cx) && uv.y == uint(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{     \n    uvec2 uv = uvec2(uv0.xy - 0.5);\n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint frame = uint(iFrame);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    // camera setup:\n    vec2 ang = vec2(Pi * 0.0, Pi * 0.12);\n    ang += mouseAccu.xy * 0.008;\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(0.45 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.8;// = 0.5 * tan(Pi05 - fov * 0.5)\n    \n    float txlSize = 1.0 / iResolution.x * 2.0;\n\n\n    // linearize uv in a locality preserving way:\n    uint pxId = EncodeMorton2(uv);\n    \n   #if 1\n    {\n        // use a 4x4 Hilbert curve tile for the lower bits of pxId \n        // to break up structural patterns in the resulting MC noise:\n        const uint N = 2u;// 2^N == tile dimension\n        uint h = EvalHilbertCurve(uv, N);\n        \n        h += WeylHash(uv >> N);// add a random offset per tile\n\n        const uint M = (1u << (2u*N))-1u;// bit mask\n        pxId = (pxId & (~M)) ^ (h & M);// replace lower bits in pxId\n    }\n   #endif\n   \n    if(ReadKeyToggle(KEY_CTRL) == 0.0)\n    {\n        // fill pxId with white noise:\n        if(tex.x < 0.5) pxId = WeylHash(uv);// split-screen\n    }\n    else if(ReadKeyToggle(KEY_TAB) != 0.0)\n    {\n        // fill pxId with white noise:\n        pxId = WeylHash(uv); \n    }\n    \n    if(ReadKeyToggle(KEY_SPACE) != 0.0) pxId += frame;// shift sequence if we accumulate samples over time\n    \n    \n    vec3 col = vec3(0.0);\n    \n    float t; vec3 n; vec3 a;\n    vec3 pos = cpos;\n\n    float ao = 0.0;\n    \n    uint count = uint(SAMPLE_COUNT);\n    for(uint i = 0u; i < count; ++i)\n    {\n        vec2 uv2 = uv0;\n        \n        // sample reconstruction filter:\n        #if 1\n        {\n           #if 0\n           // tent filter\n            vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, 0x06EE471Bu));\n             //s = Float11(shuffled_scrambled_sobol_2d(i, 0x06EE471Bu));\n            \n            s.x = Sample_Triangle(s.x);\n            s.y = Sample_Triangle(s.y);\n            \n           #else\n           // box filter\n            vec2 s = Float01(shuffled_scrambled_sobol_2d(pxId*count+i, 0x06EE471Bu)) - 0.5;\n             //s = Float01(shuffled_scrambled_sobol_2d(i, 0x06EE471Bu)) - 0.5;\n            \n           #endif\n           \n            uv2 += s;\n        }\n        #endif\n        \n        // construct ray direction:\n        vec2 tc = uv2 * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n        vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n\n        if(Intersect_Scene(pos, rd, /*out:*/ t, n, a) > 0.0)\n        {\n            vec3 p = pos + rd * t;\n            p += n * (1.0/1024.0);// always use pow-of-2 scalings for your small offsets\n            \n            \n            // sample a cosine weighted direction:\n            vec2 s = Float11(shuffled_scrambled_sobol_2d(pxId*count+i, 0xD0430963u));\n            //s = Float11(sobol_2d(pxId*count+i));\n            \n           #if 1\n            // sample sphere -> offset sphere along normal so it is tangential to the surface (i.e. the typical cosine lobe shape) -> normalize\n            // LDS sample distribution is worse around the poles (which is why using Sample_Sphere(s).yxz or .yzx performs worse here)\n            vec3 cosDir = normalize(Sample_Sphere(s) + n);\n           #else\n            // sample disk using concentric mapping -> build local frame around normal -> project points from disk to hemisphere defined by local frame\n            // introduces low-frequency content and adds a discontinuity to the correlated noise (due to https://en.wikipedia.org/wiki/Hairy_ball_theorem)\n            vec3 cosDir = Sample_ClampedCosineLobe_Conc(s.x, s.y, n);\n           #endif\n           \n            ao += Intersect_Scene(p, cosDir, /*out:*/ t, n, a) > 0.0 ? 0.0 : 1.0;\n        } \n    }\n    \n    ao /= float(count);\n    \n    col = vec3(ao);\n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    if(ReadKeyToggle(KEY_SPACE) != 0.0)\n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));// progressive accumulation\n   \n    \n    outCol = vec4(col, 0.0);\n    \n    // program state:\n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        anyK = anyK || ReadKey(KEY_TAB) != 0.0;\n        anyK = anyK || ReadKey(KEY_SHIFT) != 0.0;\n        anyK = anyK || ReadKey(KEY_SPACE) != 0.0;\n        anyK = anyK || ReadKey(KEY_CTRL) != 0.0;\n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==========================================================================================================//\n// \"Shuffled Scrambled Sobol (2D)\" - https://www.shadertoy.com/view/3lcczS\n//  code taken from \"Practical Hash-based Owen Scrambling\" - http://www.jcgt.org/published/0009/04/01/\nuint reverse_bits(uint x) {\n    x = (((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1));\n    x = (((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2));\n    x = (((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4));\n    x = (((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8));\n    return ((x >> 16) | (x << 16));\n}\n\nuint laine_karras_permutation(uint x, uint seed) {\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    return x;\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n// lifted from boost\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + 0x9e3779b9u + (seed << 6u) + (seed >> 2u));\n}\n\n// from https://www.shadertoy.com/view/3ldXzM\nuvec2 sobol_2d(uint index) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) {\n        if((index & 1u) != 0u) {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nuvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) {\n    index = nested_uniform_scramble(index, seed);\n    uvec2 p = sobol_2d(index);\n    \n   #if 0\n    p.x = nested_uniform_scramble(p.x, (hash_combine(seed, 0u)));\n    p.y = nested_uniform_scramble(p.y, (hash_combine(seed, 1u)));\n   #else\n    p.x = nested_uniform_scramble(p.x, (hash_combine(seed, 0x6F0672B5u)));\n    p.y = nested_uniform_scramble(p.y, (hash_combine(seed, 0x37322FD2u)));\n   #endif\n   \n    return p;\n}\n//==========================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//======================================================================================//\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\nuint Part1By1(uint x)\n{\n  x &= 0x0000ffffu;                   // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\nuint EncodeMorton2(uint x, uint y)\n{\n  return (Part1By1(y) << 1u) + Part1By1(x);\n}\n\nuint EncodeMorton2(uvec2 p)\n{\n  return (Part1By1(p.y) << 1u) + Part1By1(p.x);\n}\n//======================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_TAB 9\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nbvec2 minmask(vec2 v)\n{\n    bool x = v.x < v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec2 maxmask(vec2 v)\n{\n    bool x = v.x >= v.y || isnan(v.y);\n    \n    return bvec2(x, !x);\n}\n\n\nbvec3 minmask(vec3 v)\n{    \n    return bvec3(v.x <= v.y && v.x <= v.z,\n                 v.y <  v.z && v.y <  v.x,\n                 v.z <  v.x && v.z <= v.y);\n}\n\nbvec3 maxmask(vec3 v)\n{\n    return bvec3(v.x >= v.y && v.x >= v.z,\n                 v.y >  v.z && v.y >  v.x,\n                 v.z >  v.x && v.z >= v.y);\n}\n\nbvec3 minmask2(vec3 v)\n{\n    bool x = !(v.x >  v.y || v.x >  v.z) && !isnan(v.x);\n    bool y = !(v.y >= v.z || v.y >= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nbvec3 maxmask2(vec3 v)\n{\n    bool x = !(v.x <  v.y || v.x <  v.z) && !isnan(v.x);\n    bool y = !(v.y <= v.z || v.y <= v.x) && !isnan(v.y);\n    \n    return bvec3(x, y, !(x || y));\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    bvec3 mb = minmask2(ub);\n    \n    N = os * vec3(mb);\n    \n    t = mb.x ? ub.x : mb.y ? ub.y : ub.z;\n}\n\nbool IsInsideCube(vec3 p, vec3 cp, vec3 cd)\n{\n    vec3 b = abs(p - cp);\n    \n    return b.x < cd.x && b.y < cd.y && b.z < cd.z;\n}\n\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\nvec3 Sample_Sphere(vec2 s) { return Sample_Sphere(s.x, s.y); }\n\n// Improved code for concentric map\n// http://psgraphics.blogspot.de/2011/01/improved-code-for-concentric-map.html\n// Peter Shirley, Dave Cline \nvec2 Sample_Disk_Conc(vec2 v) \n{\n\tfloat phi, r;\n    \n\tif (v.x*v.x > v.y*v.y) \n\t{\n\t\tr   = v.x;\n\t\tphi = v.y / v.x;\n\t} \n    else \n    {\n\t\tr   = v.y;\n\t\tphi = v.x / v.y + 2.0;\n\t}\n    \n    phi *= Pi*0.25;\n    \n\treturn vec2(cos(phi), sin(phi)) * r;\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_ClampedCosineLobe_Conc(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk_Conc(vec2(s0, s1));\n    float y = sqrt(clamp01(1.0 - dot(d, d)));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s0 [uniform smpl on unit circle], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(vec2 s0, float s1, vec3 normal)\n{\t \n    vec2 d  = s0 * sqrt(s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 91, 91, 727]], "test": "untested"}
{"id": "WtVfRy", "name": "Bezier intersections", "author": "hamoid", "description": "Visualizes the intersections of two morphing 2D cubic Bzier curves.\n\nAfter a minute or two it crashes Chromium. And my Firefox seems to have some performance issue as it runs very slow. Maybe not using the GPU? I'm on Ubuntu with a GTX1060.", "tags": ["bezier"], "likes": 5, "viewed": 457, "published": 3, "date": "1614599033", "time_retrieved": "2024-07-30T19:35:15.268212", "image_code": "// Idea from http://truetex.com/bezint.htm\n\nfloat n(float i) {\n  return 3.*sin(iTime*(1.+2.*sin(i*.01))+i);\n}\nfloat bezier(float t, float a, float b, float c, float d) {\n  float q = 1.0-t;\n  return q*q*q*n(a) + \n        3.*q*q*t*n(b) + \n          3.*q*t*t*n(c) + \n               t*t*t*n(d);\n}\nfloat color(vec2 uv, float off) {\n  vec2 a = vec2(\n    bezier(uv.x, 1., -2. + off, 3., -4.),\n    bezier(uv.x, 9., -8., 7., -6.)\n  );\n  vec2 b = vec2(\n    bezier(uv.y, 5., 2., 5., -5.),\n    bezier(uv.y, -1., -3., 8., 9.)\n  );\n  return distance(a, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = vec3(color(uv, .0), color(uv, .01), color(uv, .02));  \n    vec3 col = vec3(1.0/(1.0+c*8.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 62, 62, 109], [110, 110, 169, 169, 292], [293, 293, 326, 326, 544], [545, 545, 602, 602, 782]], "test": "untested"}
{"id": "WtKfzG", "name": "Basic mask filter", "author": "cambalamas", "description": "Draw only a selected portion of a an image", "tags": ["filter", "mask"], "likes": 2, "viewed": 312, "published": 3, "date": "1614588177", "time_retrieved": "2024-07-30T19:35:16.035162", "image_code": "bool isBlack(in vec3 c) {\n    return c.r==0. && c.g==0. && c.b==0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord/iResolution.xy;\n    vec3 mask = texture(iChannel1, uv).rgb;\n    vec3 col  = isBlack(mask) ? vec3(1) : texture(iChannel0, uv).rgb;   \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float pattern(in vec2 pos, in float varX, in float varY) {\n    return mod(pos.x*varX + mod(pos.y, 2.0)*varY, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 100.;\n    vec2 pos   = floor(fragCoord / size);\n    \n    fragColor  = pattern(pos, 1., 1.) * vec4(1.0, 1.0, 1.0, 1.0);\n    //fragColor -= pattern(pos, 2., 1.) * vec4(1.0, 1.0, 1.0, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 69], [71, 71, 128, 128, 322]], "test": "untested"}
{"id": "WtVBRG", "name": "Fractal starfield", "author": "jarble", "description": "3d", "tags": ["fractal", "starfield"], "likes": 18, "viewed": 741, "published": 3, "date": "1614578291", "time_retrieved": "2024-07-30T19:35:16.833028", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.1;\n        p=R(p,normalize(vec3(1,2,3)),.5);   \n        s=2.5;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        \n        for(int j=0;j++<10;)\n            p=1.-abs(p-vec3(-1.)),\n            s*=e=-1.8/dot(p,p),\n            p=p*e-.7;\n            g+=e=abs(p.z)/s+.001;\n     }\n     O /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 616]], "test": "untested"}
{"id": "tlyBzy", "name": "Fractal nebula", "author": "jarble", "description": "3d", "tags": ["fractal"], "likes": 13, "viewed": 463, "published": 3, "date": "1614569671", "time_retrieved": "2024-07-30T19:35:17.611946", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g,e,s;\n        ++i<99.;\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.3;\n        p=R(p,normalize(vec3(1,2,3)),.5);   \n        s=2.5;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        for(int j=0;j++<10;)\n            p=1.-abs(p-1.),\n            s*=e=-1.8/dot(p,p),\n            p=p*e-.7;\n            g+=e=abs(p.z)/s+.001,\n            p /= dot(p,p.yzx/(1.5+sin((length(p*2.0)))));\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 643]], "test": "untested"}
{"id": "wtGfRy", "name": "Fractal 29_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 80, "viewed": 1489, "published": 3, "date": "1614567305", "time_retrieved": "2024-07-30T19:35:18.498575", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.3;\n        p=R(p,normalize(vec3(1,2,3)),.5);   \n        s=2.5;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        for(int j=0;j++<10;)\n            p=1.-abs(p-1.),\n            s*=e=-1.8/dot(p,p),\n            p=p*e-.7;\n            g+=e=abs(p.z)/s+.001;           \n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 599]], "test": "untested"}
{"id": "wtGBRy", "name": "Triple Vortex", "author": "mla", "description": "Animation of a simplification of @c010011012's Triple Vortex function: [url]https://twitter.com/c010011012/status/1275841326408318979[/url]\n\nMouse changed grid angle. 'g' controls grid.", "tags": ["vortex", "complexlog"], "likes": 15, "viewed": 428, "published": 3, "date": "1614559598", "time_retrieved": "2024-07-30T19:35:19.272506", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Complex Log Triple Vortex, mla, 2021\n//\n// Domain mapping of sums of complex log (aka. log polar transform).\n//\n// Care needed for alignment across branch cuts.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat A = 7.0, B = 3.0; // Rotation angle is atan(B,A)\nfloat scale = 2.0;\nfloat PI = 3.14159;\n\n// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nbool keypress(int key) {\n  return texelFetch(iChannel1,ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\n\n//f(z) = (1+i)log( + ((1+i)z) )/\nvec2 f(vec2 z) {\n  float k = 0.25;\n  k = cos(0.25*iTime);\n  return 0.5*clog(vec2(-k,0)+cpow(z,-2))/PI;\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 10.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n  vec2 rot = vec2(A,B);\n  z = f(z);\n  float fw = length(rot)*fwidth(z.x);\n  z = cmul(rot,z);\n  z.x -= 0.5*iTime;\n  z -= floor(z);\n  float lod = log2(0.5*fw*iChannelResolution[0].x);\n  vec3 col = textureLod(iChannel0,z,lod).xyz;\n  //col = texture(iChannel0,z).xyz;\n  z = min(z,1.0-z);\n  if (!keypress(CHAR_G)) col *= smoothstep(0.0,0.03,min(z.x,z.y));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 446, 473, 473, 504], [506, 506, 525, 525, 576], [578, 578, 605, 605, 633], [635, 635, 654, 654, 716], [718, 718, 744, 744, 883], [885, 885, 909, 909, 967], [993, 1038, 1054, 1054, 1142], [1146, 1146, 1203, 1203, 1829]], "test": "untested"}
{"id": "ttGBRy", "name": "ciudad y autos v1", "author": "jorge2017a1", "description": "ciudad y autos v1", "tags": ["ciudadyautosv1"], "likes": 2, "viewed": 215, "published": 3, "date": "1614558792", "time_retrieved": "2024-07-30T19:35:20.221968", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n        \n//Banished by Dave_Hoskins  \nfloat RoofTecho( vec3 p, vec3 medida)\n{\n\tvec3 b = medida;\n\tp.x = abs(p.x);\n  \tp.y += p.x*.75;\n\treturn length(max(abs(p)-b,0.0))-.03;\n}\n\n\n//----------------\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,  vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n    float planeDist1 = p.y+10.5;  //piso inf\n    \n    \n    p.x=opRep1D( p.x, 50.0 );\n    p.z=opRep1D( p.z, 50.0 );\n    \n   \n    float altocasa=5.0;\n    vec3 medidaCasa= vec3(10.0,altocasa,10.0);\n    float db1=sdBox( p-vec3(0.0,1.0,0.0) , medidaCasa +vec3(0.2,0.,0.1));\n    float dbPuertaA=sdBox( p-vec3(0.0,0.0,-10.0) , vec3(3.0,4.0,1.0 ) );\n    float dbPuertaB=sdBox( p-vec3(0.0,0.0,-10.0) , vec3(3.0,4.0,0.5 ) );\n    float dbSuelo=sdBox( p-vec3(0.0,-5.0,0.0) , vec3(15.0,0.5,15.0 ) );\n    float dbCalle=sdBox( p-vec3(0.0,-6.0,0.0) , vec3(25.0,0.5,25.0 ) );\n    \n    \n    float techo1=RoofTecho(p-vec3(0.0,10.0,.0), medidaCasa );\n    float techo2=RoofTecho(p-vec3(0.0,15.0,.0), vec3(10.0,0.5,11.0) );\n      \n    \n    techo1= unionSDF(db1, techo1);\n    techo1=differenceSDF(techo1,dbPuertaA);\n    \n   vec3 p2=pp;\n    p2.z=mod(p2.z+iTime*20.0, 40.0);\n   float dauto1=sdBox( p2-vec3(-20.0,0.5,10.0) ,vec3(2.5,1.,5.0));   //auto\n   float dauto2=sdBox( p2-vec3(-20.0,2.0,10.0) ,vec3(2.5,1.,2.0));  //superior\n   \n   float dauto3=sdBox( p2-vec3(-18.0,-0.5,10.0) ,vec3(0.5,1.5,5.0)); //llanta\n   float dauto4=sdBox( p2-vec3(-22.0,-0.5,10.0) ,vec3(0.5,1.5,5.0)); //llanta\n   float dauto5=sdBox( p2-vec3(-20.0,2.0,10.0) ,vec3(2.0,0.8,2.2));  //vidrio\n   \n    res =opU3(res, vec3(techo1,13.0,-1.0)); \n   res =opU3(res, vec3(techo2,14.0,-1.0)); \n   res =opU3(res, vec3(dbPuertaB,16.0,-1.0)); \n   res =opU3(res, vec3(dbSuelo,12.0,-1.0)); \n   res =opU3(res, vec3(dbCalle,1.0,-1.0)); \n    \n   res =opU3(res, vec3(dauto1,3.0,-1.0)); \n   res =opU3(res, vec3(dauto2,2.0,-1.0)); \n   res =opU3(res, vec3(dauto3,0.0,-1.0)); \n   res =opU3(res, vec3(dauto4,0.0,-1.0)); \n   res =opU3(res, vec3(dauto5,4.0,-1.0)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro, vec3 col) \n{\n    vec3 l = lp - p;\n   \n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*col;\n   \n    return lin*atten*col*2.0;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    mObj.hitbln =false;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;break; }\n        \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro,colobj);\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Created by dr2 in 2016-01-24\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n\nvec3 sky(vec3 rd, vec3 L)\n{\n  return vec3(1.-rd.y,0.9,1.+(rd.y-dot(rd,L))*.5)*(0.4*dot(rd,L)+0.6);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n     //float cc=mObj.id_color;\n     float cc=10.0;\n     float nMol=10.0;\n     return   HsvToRgb (vec3 (mod (1.7 * cc / float (nMol), 1.), 1. - 0.3 * mod (cc, 3.), 1. - 0.3 * mod (cc, 2.))); \n            \n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj= getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n// Thanks to Baron for this\nvec3 getSkyCol(vec3 rd) \n{\n    float t = (rd.x + 0.5) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t;\n    t=mod(iTime*10.0,1000.0);\n    iTimeGlobal=t;\n    \n    itime=t;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    \n    \n    float t1=mod(iTime, 3.0);\n    float t2=mod(iTime, 6.0);\n    \n    vec3 camera = vec3(-20., 10., -25.+iTime*10.0);\n    if (t1<t2)\n    {\n         camera = vec3(-20., 20., -25.);\n        camera.xz+= rotatev2(camera.xz, iTime);\n    }\n    \n       \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.01);\n    dir = rotate(dir, mouse);\n   \n    mObj.uv=uv;\n    mObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 0.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n    vec3 ro=camera; vec3 rd=dir;\n    rd.xz= rotatev2(rd.xz, radians(180.0));\n    light_pos1+=ro; light_pos2+=ro;\n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;  mObj.ro=ro;\n       float d = RayMarch(ro, rd);\n    Obj=mObj;\n     vec3 p = (ro + rd * d ); \n    \n    if(mObj.hitbln) \n    {\n   \n\n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n         result/=1.25;\n        col=result;\n\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 2.5);    \n        col = pow(col, vec3(0.454545));  \n        \n    \n    }\n    //else if(d>MAX_DIST)\n   vec3 sky = getSkyCol(rd);\n   col = mix(col, sky, smoothstep(0., .99, d/MAX_DIST));\n   \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n//https://www.shadertoy.com/view/3stXR2 \n\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 458, 458, 479], [480, 480, 512, 512, 596], [597, 597, 643, 643, 730], [732, 776, 823, 823, 850], [852, 852, 895, 895, 922], [924, 924, 972, 972, 1000], [1001, 1085, 1121, 1121, 1166], [1167, 1232, 1266, 1266, 1364], [1365, 1365, 1399, 1399, 1491], [1492, 1492, 1526, 1526, 1618], [1619, 1659, 1693, 1693, 1790], [1802, 1831, 1870, 1870, 1965], [1968, 1987, 2011, 2011, 2086], [2088, 2128, 2153, 2153, 4032], [4036, 4036, 4111, 4111, 4712], [4716, 4767, 4791, 4791, 4979], [4981, 4981, 5014, 5014, 5598], [5600, 5654, 5690, 5690, 5924], [5925, 6014, 6094, 6094, 6361], [6363, 6414, 6436, 6436, 6605], [6607, 6638, 6662, 6662, 6798], [6801, 6801, 6828, 6828, 6901], [6903, 6954, 7001, 7001, 7794], [7848, 7848, 7941, 7941, 8222], [8224, 8252, 8278, 8278, 8388], [8391, 8440, 8497, 8497, 10318]], "test": "untested"}
