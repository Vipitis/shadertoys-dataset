{"id": "cstGRf", "name": "Shion Murasaki", "author": "michael0884", "description": "https://www.pixiv.net/en/artworks/87750892", "tags": ["catthink"], "likes": 3, "viewed": 287, "published": 3, "date": "1677623108", "time_retrieved": "2024-07-30T18:07:41.203458", "image_code": "//So essentially I trained a small image with embeddings(here its 16*16 by 16 embeddings), which after interpolation we pass through a neural net to get the output color\n//The ouput neural net is just a siren here\n//The embeddings are interpolated using the hacky C2 smooth interpolation, to fix the 0 nodes in the gradient we have 2 grids, one offset by half pixel\nvec3 model(vec4 e0_0 ,vec4 e0_1 ,vec4 e0_2 ,vec4 e0_3 ){\nvec4 e1_0=sin(4.0 * (mat4(-.286,-.272,-.332,.421,.189,-.035,.099,-.011,.115,-.019,.325,.155,-.044,.173,.245,.329)*e0_0+\n    mat4(-.410,.133,.218,.206,.207,-.089,.432,-.069,-.209,.066,-.272,.023,.264,-.196,.212,.466)*e0_1+\n    mat4(.078,-.053,-.361,-.036,.195,.017,-.059,.155,-.295,-.302,.199,-.013,-.283,-.142,.479,-.458)*e0_2+\n    mat4(.280,.129,.088,-.236,.238,.163,.044,-.148,-.265,-.097,.403,.353,-.162,.086,.168,-.160)*e0_3+\n    vec4(.071,-.002,-.051,-.001)));\nvec4 e1_1=sin(4.0 * (mat4(-.353,.004,-.099,.215,-.155,-.346,.023,-.084,-.028,.210,-.123,-.077,.061,.239,.038,.214)*e0_0+\n    mat4(.250,-.288,-.030,.231,-.147,-.110,.171,.245,-.230,.172,.137,.008,.063,-.216,-.075,-.308)*e0_1+\n    mat4(.182,.154,-.015,-.109,.250,-.230,-.111,.257,-.112,.262,-.105,.134,.304,.082,-.018,.078)*e0_2+\n    mat4(-.129,.244,.080,-.382,.025,-.205,-.118,-.169,.129,-.408,.130,-.355,.181,-.181,-.079,.277)*e0_3+\n    vec4(.106,.108,.174,.082)));\nvec4 e1_2=sin(4.0 * (mat4(-.011,.008,-.172,-.099,-.066,.035,.158,-.062,.180,.032,.311,.025,.129,-.088,-.076,.036)*e0_0+\n    mat4(.009,-.116,.145,-.051,-.169,.113,-.141,-.013,.026,.155,.334,.090,-.140,.055,.277,.021)*e0_1+\n    mat4(-.018,-.077,.190,-.070,-.091,.072,.179,.277,-.159,.111,.017,.097,.061,-.056,-.195,.012)*e0_2+\n    mat4(-.028,-.085,.426,.097,-.148,-.121,-.186,.126,.027,.077,.104,-.051,.106,-.107,.313,-.119)*e0_3+\n    vec4(-.149,-.267,.084,.280)));\nvec4 e1_3=sin(4.0 * (mat4(-.023,.090,.091,-.006,-.130,.032,-.363,-.046,.076,.326,-.068,.051,-.200,-.330,.003,-.006)*e0_0+\n    mat4(.142,-.147,-.112,-.133,.084,-.100,.106,.087,.102,-.299,-.112,.146,.003,-.189,.180,.030)*e0_1+\n    mat4(-.142,.154,.159,.291,.054,.092,-.012,-.040,-.045,-.316,.137,.291,-.052,.211,-.033,-.041)*e0_2+\n    mat4(.077,.089,.030,-.120,-.017,-.191,-.091,.144,-.008,-.180,.150,-.031,.043,-.358,-.141,-.031)*e0_3+\n    vec4(.224,.097,.354,-.143)));\nvec4 e2_0=sin(1.0 * (mat4(.469,.506,-.005,-.127,-1.539,-.762,-.299,.240,.074,-.460,-.826,-.424,-.446,.054,-.010,.212)*e1_0+\n    mat4(.872,-.204,-.049,.660,.447,.258,.108,-.357,.932,.119,.254,-.336,-.266,.603,.014,-.506)*e1_1+\n    mat4(-.913,-.033,.220,.067,-1.716,.021,.412,.018,-.519,.089,.151,-.837,.497,-.687,.266,-.433)*e1_2+\n    mat4(.002,.590,-.064,-.219,-.092,-.012,.181,-1.230,.404,-.714,.046,-.058,-.328,-.743,-.141,-.201)*e1_3+\n    vec4(-.616,.012,-.090,-.100)))+e1_0;\nvec4 e2_1=sin(1.0 * (mat4(-.048,.127,.296,-.058,.024,.033,-.075,-.045,-.130,.066,-.268,-.070,.030,-.014,-.651,.056)*e1_0+\n    mat4(-.638,-.114,.724,-.112,-.302,-.786,.580,-.651,.026,-.608,.440,.162,.110,-.029,-.877,.095)*e1_1+\n    mat4(.309,-.060,-.741,.103,.383,.208,-.755,-.065,-.130,-.153,-.868,-.343,.351,.864,1.073,-.325)*e1_2+\n    mat4(-.176,.315,1.508,.446,-.098,.033,-.549,.394,-.408,-.149,.309,-.049,-.141,.126,-.773,1.032)*e1_3+\n    vec4(.169,-.145,-.564,-.104)))+e1_1;\nvec4 e2_2=sin(1.0 * (mat4(.068,-.653,-.429,.085,-.319,-.089,.543,-.232,-.539,.400,.075,.095,-.759,-.217,-.372,-.016)*e1_0+\n    mat4(-.241,-.329,.281,.591,.044,-.802,-.271,-.038,.048,-.270,-.206,.339,-.665,.202,-.826,-.078)*e1_1+\n    mat4(.093,.047,.092,.160,.259,.193,-.338,-.080,-.233,.488,.289,-.051,-.248,-.217,.581,-.392)*e1_2+\n    mat4(-.582,-.198,-.486,.094,-.012,-.152,-.155,.055,-.284,-1.019,.406,-.249,-.423,.103,1.341,-.423)*e1_3+\n    vec4(-.298,-.261,-.275,.630)))+e1_2;\nvec4 e2_3=sin(1.0 * (mat4(.008,.637,-.068,-.040,-.222,.511,.218,-.218,-.051,.731,-.020,-.018,-.088,-.475,-.113,.090)*e1_0+\n    mat4(.208,-.954,-.385,-.146,-.296,-.236,.040,.005,.577,.488,.089,.380,-.377,.131,.162,.089)*e1_1+\n    mat4(.237,-1.248,-.483,.308,-.005,-.469,.285,.145,.202,.264,.168,.106,.204,-.420,.416,.025)*e1_2+\n    mat4(.493,-.792,-.193,.011,-.652,-1.031,.148,-.048,.040,.257,-.757,.029,-.499,.181,.174,-.910)*e1_3+\n    vec4(.030,-.482,-.172,.127)))+e1_3;\nvec4 e3_0=sin(1.0 * (mat4(-.064,-.154,-.072,-.054,.495,.161,-.021,-.108,1.034,.209,-.476,-.224,.366,.113,.042,-.297)*e2_0+\n    mat4(-1.130,1.032,-.384,-.361,-.825,.710,.388,.011,-.959,.308,.355,.229,.447,-.116,.101,.135)*e2_1+\n    mat4(.453,.182,.088,.228,.474,.002,-.031,-.302,.437,-.079,-.020,-.127,-.493,.269,.723,-.114)*e2_2+\n    mat4(-.976,.425,.226,-.135,.216,.198,.096,.287,-.712,.402,.000,-.842,.213,.187,-.616,-.785)*e2_3+\n    vec4(1.636,-2.393,-.481,-.351)))+e2_0;\nvec4 e3_1=sin(1.0 * (mat4(.077,.157,-.340,-.172,-.192,-.341,1.032,-.061,-.264,-1.237,1.556,-.615,-.124,-.352,.681,-.061)*e2_0+\n    mat4(-.446,-.957,-.355,1.564,-.278,-.562,-.667,1.344,-.193,.062,-1.200,.979,.060,-.160,.378,-.345)*e2_1+\n    mat4(-.194,-.696,.551,-.040,-.057,-.248,.674,-.258,-.004,-.365,.504,-.274,-.122,1.700,.086,1.030)*e2_2+\n    mat4(.128,.486,-.666,1.044,.143,-.440,.664,.135,-.713,.698,-.270,.975,1.032,.522,1.482,-.194)*e2_3+\n    vec4(-.053,-2.606,-.711,-1.360)))+e2_1;\nvec4 e3_2=sin(1.0 * (mat4(-.035,-.143,-.336,.274,.466,.395,.614,-.505,.441,.483,.559,-.534,.253,.480,.737,-.413)*e2_0+\n    mat4(-.427,-.289,-1.936,.160,-.869,.019,-.648,-.156,-.714,-.298,-.544,.133,.215,.462,.869,-.307)*e2_1+\n    mat4(-.347,.280,.615,-.433,.148,.607,.574,-.336,.116,.352,.411,-.210,.837,-.398,1.106,-.576)*e2_2+\n    mat4(-.458,-.502,.517,-.032,.331,.407,.463,-.366,.469,-.504,-.170,-.273,1.390,-.040,-.439,.226)*e2_3+\n    vec4(-.038,-.060,-.668,.008)))+e2_2;\nvec4 e3_3=sin(1.0 * (mat4(.501,.324,.106,.181,-1.386,.036,-.054,-.331,-1.858,.720,-.070,-.200,-1.118,.128,.085,.037)*e2_0+\n    mat4(1.412,-.118,-.268,.179,.886,-.353,.294,.347,1.363,-.195,.251,.328,-.992,.153,.015,-.015)*e2_1+\n    mat4(-.865,.220,.169,.165,-1.092,.097,.047,.100,-.772,.087,.010,-.084,-.892,.098,-.041,-.145)*e2_2+\n    mat4(.592,.369,-.032,-.039,-.811,-.310,-.175,-.118,.124,.156,-.239,.478,-.713,-.822,-.616,-1.132)*e2_3+\n    vec4(-.302,.143,.288,.000)))+e2_3;\nfloat e_0=dot(e3_0,vec4(-.058,.029,-.094,-.036))+\n    dot(e3_1,vec4(.001,.009,.036,-.019))+\n    dot(e3_2,vec4(-.049,-.074,-.035,.204))+\n    dot(e3_3,vec4(.090,.050,.059,.124))+\n    0.352;\nfloat e_1=dot(e3_0,vec4(-.034,-.024,-.160,-.039))+\n    dot(e3_1,vec4(-.065,.029,.070,-.005))+\n    dot(e3_2,vec4(-.038,-.065,-.042,.208))+\n    dot(e3_3,vec4(.100,.043,.050,.012))+\n    0.260;\nfloat e_2=dot(e3_0,vec4(-.017,-.035,-.203,-.048))+\n    dot(e3_1,vec4(-.207,.010,.063,.009))+\n    dot(e3_2,vec4(-.049,-.079,-.034,.205))+\n    dot(e3_3,vec4(.100,.040,-.135,.101))+\n    0.334;\nreturn vec3(e_0, e_1, e_2);} \n\n\nvec4 smoothSample(sampler2D ch, vec2 uv)\n{\n\tuv = uv*iResolution.xy + 0.5;\n\tvec2 iuv = floor(uv);\n\tvec2 fuv = fract(uv);\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/iResolution.xy;\n\treturn texture(ch, uv);\n}\n\nvec4 sampleEmbed(sampler2D ch, vec2 uv, int embed, float offset)\n{\n    vec2 pix = (1.0 - uv) * float(embed_texture-3) + 2.0 + vec2(embed, 0) * float(embed_texture + 2) + offset;\n    return smoothSample(ch, pix/iResolution.xy);\n}\n\nvec3 decode(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec3(0.0);\n    vec4 e0_0 = sampleEmbed(iChannel0, uv, 0, 0.0);\n    vec4 e0_1 = sampleEmbed(iChannel1, uv, 0, 0.0);\n    vec4 e0_2 = sampleEmbed(iChannel2, uv, 0, 0.5);\n    vec4 e0_3 = sampleEmbed(iChannel3, uv, 0, 0.5);\n    \n    return model(e0_0, e0_1, e0_2, e0_3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.0*((fragCoord - vec2(iResolution.x - iResolution.y, 0)*0.5)/iResolution.y - 0.5) + 0.49999;\n\n    //vec3 col = sampleEmbed(iChannel1, uv, 0).xyz;\n    vec3 col = decode(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed0[idx];\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed1[idx];\n}", "buffer_b_inputs": [], "common_code": "const int embed_texture = 32; \nconst int embed_channels = 4;\n\nconst vec4 embed0[1024] = vec4[](vec4(-.558,-.564,.328,.068),vec4(-.315,-.424,.931,-.373),vec4(.268,.188,.101,-.848),vec4(1.434,.306,.632,-.087),vec4(.163,.467,-.959,.583),vec4(.328,.350,-.643,.502),vec4(1.273,.190,-1.357,.255),vec4(.315,-1.483,-.684,-.545),vec4(.140,-1.289,-1.019,-.346),vec4(-1.497,1.659,.113,-.190),vec4(-2.239,.878,-1.183,-.360),vec4(-3.269,-.420,.057,.014),vec4(-2.879,1.154,-2.130,-.727),vec4(-2.944,1.323,-2.119,-1.435),vec4(.338,2.163,-1.203,.020),vec4(-1.612,-.640,-1.201,1.097),vec4(-.478,-1.192,-3.691,-1.384),vec4(-1.907,.703,-.648,-2.428),vec4(.253,-1.085,-2.085,-.180),vec4(1.462,-1.104,-1.163,-.745),vec4(-.132,.537,.453,1.045),vec4(1.526,1.048,.329,.617),vec4(.470,-.103,-.287,.518),vec4(.993,-.931,-.852,-.200),vec4(.259,-.426,.482,-.267),vec4(-.981,-.852,-.683,-.064),vec4(-.779,-.576,-.513,-.948),vec4(-.556,-.763,-.079,-.751),vec4(-.286,-1.014,-.101,-.377),vec4(-.137,-.893,-.465,-.415),vec4(.039,-.963,-.297,-.678),vec4(-2.516,-3.119,.625,-1.590),vec4(-.053,.033,.068,.496),vec4(-.075,.157,-.165,-.268),vec4(-.378,.575,-.537,.139),vec4(.370,.786,-.443,.495),vec4(.589,.612,-1.004,.275),vec4(.830,.545,-1.423,.138),vec4(.736,-.329,-.809,-.042),vec4(-1.000,-2.138,-2.295,-1.409),vec4(.986,-.501,.095,-1.771),vec4(-.090,-.828,-.675,-1.360),vec4(-.922,1.227,-.736,1.395),vec4(-3.775,.380,.179,1.878),vec4(-4.007,-.985,.406,-3.863),vec4(-2.855,-.927,-.135,-1.185),vec4(-3.261,.168,-2.724,-.434),vec4(-.696,-.007,-2.417,-.408),vec4(-1.635,.792,-1.215,.189),vec4(2.301,-.745,-1.629,2.649),vec4(5.056,-1.111,-2.737,-1.910),vec4(2.586,-2.244,-5.981,-3.840),vec4(.850,1.194,.430,1.143),vec4(-.891,-.378,-.238,1.553),vec4(.256,-.548,.069,.686),vec4(.299,-.828,-.140,-.628),vec4(-.372,-1.031,-.403,-.753),vec4(-.916,-.934,-.793,-1.151),vec4(-.506,-.439,-.220,-.926),vec4(-.552,-.934,.179,-.626),vec4(-.185,-1.202,.004,-.585),vec4(-.106,-.808,-.131,-.170),vec4(-.076,-.867,-.388,-.232),vec4(.368,1.674,1.273,1.617),vec4(-.016,.322,-.566,-.635),vec4(-.214,.391,-.658,-.364),vec4(-.416,.324,-.327,-.324),vec4(.394,.771,-.192,.342),vec4(.701,-.375,-2.405,.446),vec4(.871,.266,-1.817,.207),vec4(-1.189,.355,-.596,.053),vec4(-3.584,-.815,-2.237,-1.299),vec4(1.358,.241,-1.296,.910),vec4(-.425,-2.051,-.496,.075),vec4(.393,-3.509,1.689,-1.665),vec4(2.580,.880,-.026,-2.510),vec4(.736,.246,-1.302,1.097),vec4(.346,.242,-3.275,2.274),vec4(-1.616,-3.257,-3.680,-1.070),vec4(-.140,-.577,.501,-1.435),vec4(-.981,1.064,1.405,-.242),vec4(.023,-.057,1.929,.324),vec4(-1.044,.017,2.446,.543),vec4(-.325,1.199,-.035,-.627),vec4(.098,-1.483,-.116,.822),vec4(-1.530,.466,.503,3.041),vec4(-.232,-.520,-1.573,1.018),vec4(-.748,.118,-.556,.230),vec4(-.302,.196,-.724,.166),vec4(-.258,-1.514,-.682,-.787),vec4(.298,-1.082,.014,-.174),vec4(-.293,-.640,.302,-.683),vec4(-.357,-1.122,.221,-.889),vec4(-.348,-.696,.469,-1.092),vec4(.325,.270,.169,-.393),vec4(-1.218,-.776,1.468,-1.635),vec4(-.347,.865,-.863,-.430),vec4(-.616,.425,-.971,-.823),vec4(-.230,-.394,-.649,-.796),vec4(-.130,-.430,.112,-.478),vec4(-.130,-.215,-.267,-.183),vec4(1.031,1.060,-1.150,-.884),vec4(.434,.063,-.544,-1.300),vec4(-1.066,.862,3.136,-.332),vec4(-1.418,-1.334,-1.667,-1.452),vec4(.984,-.424,.885,.588),vec4(.501,.310,2.610,1.835),vec4(.378,.871,.293,-1.439),vec4(-.476,-.656,-1.896,-.983),vec4(-1.072,2.427,2.834,-3.451),vec4(-1.080,.168,.457,-.307),vec4(-.710,-1.130,.812,.222),vec4(-.638,.519,.796,.467),vec4(-.911,1.522,.429,-.596),vec4(1.119,1.344,.582,-1.283),vec4(.432,1.511,.696,-.730),vec4(-.281,.290,-.241,.363),vec4(-1.751,.391,-.111,.732),vec4(-1.196,.354,-.356,-.181),vec4(-.835,-.129,-.391,-.145),vec4(-1.336,-.418,-1.382,-.038),vec4(.072,-1.940,-.677,-.018),vec4(.561,-1.323,.363,.690),vec4(-.328,-1.118,-.175,.095),vec4(-.746,-1.635,-.064,-.968),vec4(.245,.298,.037,-.833),vec4(.680,.490,-.556,-.899),vec4(-.400,-.579,.181,-1.344),vec4(-.422,-.380,.245,-.843),vec4(-.410,-.172,-.683,-.769),vec4(-.308,-.425,-.405,-.997),vec4(-.784,.901,.041,-1.223),vec4(.796,-.554,1.147,1.134),vec4(-2.423,1.629,.580,2.043),vec4(-1.197,-.643,.167,-.939),vec4(-.486,1.466,-2.704,-.717),vec4(-3.071,-1.699,.241,.507),vec4(-.831,.750,.797,1.042),vec4(.608,.351,-.201,-1.714),vec4(-2.248,-1.882,2.515,-.376),vec4(-.440,-.461,2.202,-4.042),vec4(-.121,.776,-.730,-.804),vec4(3.557,.519,-.558,.181),vec4(-.861,1.295,.794,.600),vec4(-1.419,.725,1.502,-.300),vec4(.200,.136,.108,-.718),vec4(-.944,-.704,1.560,-1.867),vec4(-1.019,-.134,-.134,-2.297),vec4(-.542,-1.379,-.232,-1.770),vec4(-.476,.706,.975,.657),vec4(1.612,2.221,1.251,1.290),vec4(1.023,1.422,2.462,-1.807),vec4(1.313,.456,.265,-.739),vec4(-.981,.454,.365,-1.605),vec4(-.562,-.364,-.905,-.437),vec4(-1.673,.078,.590,-.800),vec4(.203,-1.141,.580,.493),vec4(.668,-.423,-.025,-.928),vec4(1.097,-.265,-.292,-.057),vec4(.271,-.282,-.976,-.475),vec4(-.188,-1.235,-.604,-.045),vec4(.104,-.562,-.488,-.609),vec4(-.073,-.524,-.999,-1.207),vec4(.710,.793,-.241,-.858),vec4(-1.439,1.243,.438,-1.359),vec4(-.255,2.589,.254,-1.574),vec4(-1.395,.478,.826,-2.794),vec4(-.329,.890,-.374,-1.458),vec4(.642,2.127,-2.332,-.422),vec4(.264,1.506,-.142,-1.488),vec4(-1.304,.782,.315,-.220),vec4(.524,.025,-.464,-2.587),vec4(-.111,.033,-1.343,-.294),vec4(.216,.279,-.917,-.923),vec4(-.589,1.034,-1.162,-.499),vec4(.101,-1.027,-.570,.547),vec4(2.128,-1.876,-1.250,2.831),vec4(-.269,-.712,.061,-.635),vec4(.539,-1.688,1.158,-.390),vec4(.575,.469,.978,-1.016),vec4(2.941,-2.970,-.512,-.947),vec4(-1.968,1.401,-.901,.054),vec4(.367,.820,.852,1.697),vec4(2.379,.428,.176,.790),vec4(-.205,.068,.423,-1.846),vec4(-.348,-.172,1.610,.325),vec4(.629,1.407,.027,.656),vec4(-.760,-.857,.355,1.185),vec4(1.233,-.635,.281,-.486),vec4(.827,-.007,-1.128,.055),vec4(.612,-.276,-.851,.393),vec4(1.069,.390,-2.122,1.670),vec4(.353,-.586,-.713,.029),vec4(.252,-.570,-.796,.110),vec4(-.602,-.956,-.761,-1.056),vec4(1.455,1.473,-1.179,.102),vec4(.671,2.434,1.059,-.849),vec4(-.009,-.064,.863,-.106),vec4(-1.252,2.804,.638,.107),vec4(1.437,.730,-.721,.276),vec4(-.343,-.766,-1.487,.885),vec4(-1.653,-2.493,.543,-1.597),vec4(.328,-3.410,-2.381,.018),vec4(.202,1.049,.672,-.523),vec4(.229,-.807,.363,-.162),vec4(.333,-.620,.206,.463),vec4(-1.118,.380,-.263,-.712),vec4(.343,-2.240,-3.633,.938),vec4(-.098,-.849,-.006,-.756),vec4(.816,1.170,-.951,2.138),vec4(2.669,-.594,1.345,.133),vec4(.810,-.396,.837,-.527),vec4(1.004,-.521,-.037,.168),vec4(.983,-.415,-1.630,.732),vec4(-1.691,-1.424,.670,.794),vec4(.746,-1.075,-.693,-.843),vec4(-.483,.976,-.708,1.366),vec4(1.270,.590,.300,.000),vec4(-1.596,-.947,.755,-.795),vec4(1.583,.243,.306,-.264),vec4(-.223,-.683,.222,-.951),vec4(-.368,-.339,-.743,-.534),vec4(-.380,.501,-1.891,-.352),vec4(-1.334,.855,-.098,-.832),vec4(.166,.495,-1.088,-.353),vec4(-.115,-.143,-.613,-.036),vec4(-.076,.206,-1.427,.254),vec4(-.918,-.289,-1.834,-4.779),vec4(-.839,.646,-2.341,.109),vec4(.973,1.322,-.376,-1.234),vec4(-.271,1.250,1.876,-3.872),vec4(.499,-.946,-1.681,-1.431),vec4(-.669,-.361,1.171,-.347),vec4(.817,.115,-.652,.446),vec4(-.150,-1.058,-2.478,1.709),vec4(-.411,.174,1.098,-.033),vec4(.636,-1.519,-2.323,-2.198),vec4(-.374,-1.481,-1.806,-.969),vec4(2.791,.942,-1.369,1.161),vec4(.678,-1.346,-.272,-.536),vec4(.770,.413,.808,-.037),vec4(-.717,.600,-1.418,.696),vec4(.516,.511,2.146,-.265),vec4(-.495,-2.233,.849,-1.160),vec4(-.454,.189,.180,-.921),vec4(-.993,-1.260,-.141,1.037),vec4(-2.061,-.283,2.529,-2.474),vec4(.286,2.071,-.990,1.941),vec4(-.420,-1.431,1.057,-1.544),vec4(-1.592,1.370,.740,1.224),vec4(-.758,1.199,.758,-3.249),vec4(.513,.673,.482,-3.541),vec4(-4.197,-1.881,-2.159,1.407),vec4(-.918,-.095,-.944,-.780),vec4(-.408,-.017,-1.685,-.261),vec4(.980,1.973,-.843,.652),vec4(.207,-.111,-.251,-.070),vec4(.825,.039,-.642,-.392),vec4(.625,.116,-.890,-.413),vec4(-1.573,2.994,7.263,3.844),vec4(-.203,-.173,-2.203,-1.999),vec4(-.275,1.258,.622,-.071),vec4(1.940,1.852,1.874,-.367),vec4(2.803,1.674,-.073,-1.928),vec4(-.983,.025,.789,1.620),vec4(-1.622,2.092,.043,-.270),vec4(.230,-.997,-.368,.821),vec4(-.683,-.828,.514,-.324),vec4(.032,1.940,.103,.465),vec4(-1.648,-.657,-.068,-.115),vec4(3.622,1.445,-.072,1.774),vec4(.364,.922,-.037,.914),vec4(.011,-.511,1.689,-.537),vec4(.144,.178,-.612,-.641),vec4(-.493,-.709,1.843,-1.338),vec4(-2.108,-3.073,1.944,-.067),vec4(-.224,-.152,1.241,-1.643),vec4(.154,.852,.947,.628),vec4(.474,.633,1.661,-1.745),vec4(.987,1.037,-.796,-1.468),vec4(-.404,-.585,.443,.790),vec4(-1.105,-1.889,1.639,-2.343),vec4(.612,.027,1.181,-3.629),vec4(.488,.182,-.722,-.261),vec4(1.127,-.513,-3.407,-1.116),vec4(3.796,-2.101,3.230,4.367),vec4(-4.583,2.427,-.977,-3.328),vec4(-1.035,-.365,.576,-.337),vec4(.691,-.581,.133,-.122),vec4(1.402,-.706,-.597,-.664),vec4(1.643,-1.242,1.470,-.170),vec4(7.597,-.691,-.107,4.401),vec4(-1.224,.731,-.579,-1.374),vec4(1.718,1.165,-.351,.906),vec4(-.584,.369,1.675,1.404),vec4(1.894,3.173,1.554,-1.777),vec4(.337,1.306,.406,1.090),vec4(-3.672,.539,-.209,.186),vec4(.506,-.380,.146,-.481),vec4(-.112,-.552,1.075,.576),vec4(1.842,1.489,.027,.103),vec4(-.928,-.478,2.416,-.126),vec4(-.418,-.489,-2.191,.691),vec4(.281,.873,-1.500,1.426),vec4(.167,.097,2.336,-.533),vec4(.525,-1.118,1.441,-.922),vec4(-1.151,-.555,.825,-.209),vec4(-1.504,-1.277,1.571,.308),vec4(1.821,-.930,.472,-1.317),vec4(-.068,.715,-.063,1.189),vec4(-1.607,.054,-.215,-1.448),vec4(1.282,.199,-.030,.348),vec4(1.293,1.322,1.659,.532),vec4(-1.318,-.219,.855,2.407),vec4(-1.196,-1.120,2.659,-1.183),vec4(.941,.553,-1.196,.873),vec4(-3.283,-1.594,-1.023,-2.123),vec4(.371,-.079,.476,.005),vec4(4.675,-1.595,-5.393,-.452),vec4(-.667,-.762,2.311,.260),vec4(.861,-.399,-1.177,.446),vec4(.894,-1.350,-1.410,.302),vec4(2.131,-1.534,-1.909,1.648),vec4(2.004,-2.317,-4.141,-1.014),vec4(-.801,1.224,.558,-.510),vec4(1.667,1.145,-2.563,1.434),vec4(-.745,.382,.925,2.075),vec4(-.912,1.062,-.045,2.057),vec4(-.874,.432,-2.054,-.682),vec4(-1.421,-2.424,1.254,-1.113),vec4(-.054,-.207,.162,-.444),vec4(.349,-.761,-1.060,1.027),vec4(.814,1.917,.025,-.143),vec4(-1.550,-1.085,1.626,.481),vec4(-2.460,1.644,-.023,-.602),vec4(.126,-1.225,-.501,2.684),vec4(-2.831,.603,-1.345,-.469),vec4(-2.990,.792,-.017,1.385),vec4(-.289,-.324,-.220,.650),vec4(-.535,-.306,1.797,1.037),vec4(-.455,-2.223,1.091,-.548),vec4(1.377,.267,-.875,-.532),vec4(-.847,-.313,.464,-.625),vec4(.733,.872,.373,-.221),vec4(.590,-.437,-.343,3.895),vec4(-.672,-.772,-.364,2.394),vec4(-1.275,1.784,-1.781,2.558),vec4(-.295,.355,1.030,-1.224),vec4(-1.677,-.342,3.109,-3.081),vec4(-2.371,2.082,-.202,.005),vec4(8.749,-2.575,-1.785,.559),vec4(.391,-1.384,2.863,1.441),vec4(.932,-.210,-1.305,.864),vec4(.836,-.157,-1.053,.614),vec4(.154,-.657,-.987,.828),vec4(.476,-1.196,-.962,.004),vec4(.808,.596,-.229,-.099),vec4(2.145,-.515,-.823,-.433),vec4(-1.451,1.659,.010,1.097),vec4(-.871,1.496,.820,1.770),vec4(-.300,.157,-1.796,-1.037),vec4(-.175,-.329,.697,.618),vec4(.763,-.347,-1.328,-1.840),vec4(.599,.650,.227,.810),vec4(1.040,-.961,-.292,.740),vec4(-.363,-.338,1.330,1.031),vec4(-.531,-2.701,-.560,.400),vec4(-.632,.810,.641,-1.486),vec4(-.625,-1.417,-.538,.636),vec4(-2.094,-1.186,-1.330,.920),vec4(1.143,-1.752,.971,.351),vec4(.450,1.754,1.265,.118),vec4(-1.926,-.511,1.549,-1.242),vec4(1.167,.458,-.165,-.686),vec4(-.173,.516,1.047,.028),vec4(.474,1.053,1.249,-.124),vec4(1.924,-.967,-1.446,3.459),vec4(-.338,-.065,-1.019,1.589),vec4(-.999,-.047,1.185,1.133),vec4(-.304,-.129,-1.228,-1.709),vec4(3.242,-1.449,1.292,-1.948),vec4(-.876,-2.421,-.781,1.794),vec4(-.524,-.332,1.416,.906),vec4(1.044,.124,.852,-1.369),vec4(.643,.751,-.414,.605),vec4(.651,.371,-.884,1.186),vec4(.169,.079,-.415,.559),vec4(.348,-1.722,-1.308,.503),vec4(.560,-.847,-.945,.428),vec4(.372,-.994,1.942,-1.672),vec4(-.984,3.455,1.536,.319),vec4(-1.249,1.398,.490,.146),vec4(.967,.528,-2.396,-.093),vec4(-1.138,-.490,-.575,.496),vec4(.455,.041,.560,.912),vec4(.983,-.143,-1.218,1.170),vec4(-1.105,1.089,-.286,-.033),vec4(-2.472,-2.451,-1.557,-1.210),vec4(-.898,-.685,.701,-.250),vec4(.267,-1.129,-1.348,.265),vec4(-.710,-1.101,-.965,.198),vec4(-.811,.085,1.100,1.057),vec4(-2.196,.857,.570,.364),vec4(-1.095,-2.120,-.616,.313),vec4(-.277,.682,1.643,.171),vec4(-.162,.068,-1.025,.156),vec4(.516,.622,.687,-.667),vec4(.377,.644,.718,1.351),vec4(1.166,-.759,-1.150,2.455),vec4(1.186,.219,-.539,.973),vec4(.330,.608,-.826,.476),vec4(.848,-.531,-2.125,-1.868),vec4(-1.402,1.325,.372,.623),vec4(-4.146,-.107,.212,1.056),vec4(-1.475,-1.840,-2.321,-.967),vec4(-.510,-.350,.939,-.411),vec4(.063,-.243,.685,-.763),vec4(.334,-.007,-.014,-.337),vec4(-.209,-1.442,-.578,-.108),vec4(1.507,.202,-.689,1.097),vec4(.419,-.915,-.971,-1.770),vec4(-1.748,-.230,-.775,-1.017),vec4(-.591,-1.242,1.257,.655),vec4(-.363,-.269,2.084,.631),vec4(2.537,-2.224,-.584,3.321),vec4(-.108,1.192,.140,-1.553),vec4(-1.068,.336,-.261,.353),vec4(-.629,.340,.654,-.807),vec4(.023,-1.535,-.837,-1.036),vec4(-.286,.523,-1.484,-2.327),vec4(-.788,-.206,-.121,-2.428),vec4(-1.714,-1.616,-.084,1.422),vec4(-1.380,-.526,.904,-.774),vec4(-3.411,.819,.700,-1.014),vec4(-.935,-1.126,1.485,.105),vec4(1.219,-1.434,-3.110,-.334),vec4(.732,-.968,.054,.410),vec4(1.026,.332,-.432,-.840),vec4(-.036,1.732,.351,1.086),vec4(-.567,-.448,2.403,-.733),vec4(-.807,-.592,-1.842,.969),vec4(-.398,.169,-.334,.267),vec4(-.562,.038,-.708,-.344),vec4(.589,-1.014,-1.076,1.915),vec4(.483,1.098,.439,-.915),vec4(-2.506,-1.511,-2.946,.394),vec4(-1.207,-3.963,-1.516,-.603),vec4(1.093,-1.047,-1.356,.637),vec4(-.045,-.519,-.408,-.739),vec4(.118,-1.140,.110,.178),vec4(.330,-1.306,-.949,.988),vec4(.350,-.344,-2.098,1.541),vec4(-.258,.314,1.581,.398),vec4(-.623,-1.175,-.330,-.606),vec4(-.290,-2.054,.496,-1.703),vec4(.852,-.859,.927,-1.299),vec4(3.550,-.831,2.416,1.442),vec4(-3.118,.663,-1.471,-1.706),vec4(-.633,-.639,.436,.139),vec4(.957,-.463,.403,.961),vec4(-1.216,.176,-1.027,-1.406),vec4(-.037,.925,.738,-2.419),vec4(1.317,-3.071,-2.160,-.919),vec4(-1.941,-.182,3.912,.147),vec4(-.510,-1.521,.347,-2.306),vec4(-2.542,-.952,.790,-1.636),vec4(-.324,-.258,-1.377,-.908),vec4(-1.774,-.206,.208,.402),vec4(-.597,-1.551,-.489,2.699),vec4(1.049,-1.175,1.861,-.122),vec4(1.390,.715,-.077,-.493),vec4(-.964,-.141,1.584,1.045),vec4(-1.134,-.598,2.374,-1.172),vec4(-.247,.687,.069,-.199),vec4(1.061,.857,1.186,-.658),vec4(1.803,-.168,1.013,1.989),vec4(-1.080,.190,-.684,1.530),vec4(.544,.559,.582,-.013),vec4(-1.660,-.453,-.243,.045),vec4(.254,-.138,-.780,-1.347),vec4(-.551,-.733,-.292,.036),vec4(.167,-.157,-.722,1.427),vec4(2.139,.508,-.384,1.983),vec4(-.619,.026,1.188,.098),vec4(-.208,-.339,-4.007,.074),vec4(-1.020,-1.057,-.596,.242),vec4(-.535,-1.129,1.330,-.916),vec4(.312,1.144,-.060,.058),vec4(1.306,-.625,-.306,1.560),vec4(.081,-.781,.407,-1.055),vec4(-1.827,1.069,-3.005,-.410),vec4(.465,.319,.914,.206),vec4(-2.171,1.704,1.624,.975),vec4(-1.712,-1.310,.493,1.103),vec4(.226,-2.063,.495,1.632),vec4(.157,-2.185,.328,1.130),vec4(.179,-1.853,.484,-1.269),vec4(1.289,-1.912,.321,-2.342),vec4(1.232,-.890,-1.095,.897),vec4(1.086,-.723,2.310,1.319),vec4(1.041,-2.080,-.246,.218),vec4(2.146,2.134,-.731,.094),vec4(.475,-1.398,-.668,-1.108),vec4(.443,.312,-.156,-1.385),vec4(-1.343,.823,4.659,-.177),vec4(1.138,.752,.334,.147),vec4(.867,.638,2.063,-.394),vec4(1.653,-.277,-3.180,.433),vec4(-3.242,-2.011,-1.723,-1.741),vec4(1.614,-.062,.633,.383),vec4(-.209,.321,.101,1.139),vec4(-.598,.242,.223,-.305),vec4(-3.119,-.566,-1.405,-1.075),vec4(-.127,-.935,-.703,-1.778),vec4(.506,-.113,.084,-.377),vec4(-1.236,1.426,1.231,-.911),vec4(1.093,.942,-3.386,1.528),vec4(-1.045,-.589,.414,.834),vec4(-.802,-.286,-.148,.073),vec4(.634,1.151,-.159,-1.377),vec4(.081,.155,-.523,3.706),vec4(-.627,.140,-2.467,-1.975),vec4(-1.923,-.132,.336,-2.471),vec4(-2.322,3.251,.284,-.891),vec4(-.522,.210,1.078,-1.059),vec4(-1.337,-.966,.727,-1.193),vec4(-1.311,-2.888,-1.371,.532),vec4(1.741,-1.067,.967,.832),vec4(2.647,-.499,-.824,-.001),vec4(-.115,-.383,.302,2.278),vec4(.168,-.041,.472,1.073),vec4(.696,.556,-1.533,.829),vec4(.992,.838,.617,.640),vec4(.755,-.298,-.583,1.181),vec4(.969,-1.321,1.071,-.657),vec4(1.161,2.388,1.211,-2.758),vec4(-1.245,1.593,3.569,-.584),vec4(.330,1.349,1.095,-.075),vec4(1.252,1.216,.256,.302),vec4(1.687,1.653,.570,.410),vec4(-1.067,1.951,-.940,1.092),vec4(1.492,-.403,.105,.882),vec4(1.495,-.080,-.066,1.636),vec4(-.892,-2.467,-.905,-1.720),vec4(-.125,.887,1.082,.694),vec4(-2.500,-.921,1.160,-1.688),vec4(-.929,.252,.701,-.353),vec4(-1.159,.695,.356,-1.080),vec4(3.286,-1.871,-2.337,.256),vec4(.242,-.371,-.789,1.671),vec4(-.323,.922,-1.348,1.467),vec4(-.484,-.130,1.136,1.840),vec4(-2.036,.505,-.167,-.339),vec4(-.927,1.547,.529,.988),vec4(-2.496,-.310,.554,.044),vec4(-.208,.572,-.299,.729),vec4(-.992,1.360,.213,1.994),vec4(-1.455,-1.564,-.761,-.151),vec4(.472,-.355,1.568,.004),vec4(-.764,-1.360,-.391,-.513),vec4(-1.043,.395,.238,.059),vec4(.322,.029,.644,-.822),vec4(-1.612,.504,1.019,.894),vec4(.269,.904,1.390,.477),vec4(.265,.485,1.747,1.097),vec4(1.430,1.140,.301,-.208),vec4(-2.632,.084,1.720,-.204),vec4(-.503,1.054,2.559,-2.033),vec4(.580,.727,1.318,-.451),vec4(-.411,.714,-.753,.385),vec4(-.435,-.618,.222,-.615),vec4(1.387,1.484,.881,1.241),vec4(-.163,.108,.963,1.414),vec4(-.756,.239,-.235,-1.902),vec4(4.920,.677,-4.710,-.203),vec4(-.438,1.163,-.883,-1.012),vec4(-.788,-1.019,-2.178,-2.456),vec4(-1.086,-.261,-.624,-.801),vec4(.449,.153,-.443,1.138),vec4(1.976,-1.054,2.239,-3.147),vec4(-1.544,-.144,-2.819,2.821),vec4(-1.124,-.363,-1.090,.696),vec4(.521,-1.538,.533,1.475),vec4(-.473,-.321,.767,-.611),vec4(-.451,-.979,1.485,-.716),vec4(-.091,2.760,.864,-1.669),vec4(-2.668,.629,.118,-.584),vec4(.053,-1.513,-2.894,-.380),vec4(1.471,1.131,1.877,-1.429),vec4(.535,-.467,2.230,.236),vec4(.396,-2.789,-1.431,2.262),vec4(-.236,.564,-.154,-.103),vec4(-.405,.521,-.668,-.871),vec4(-1.050,-1.679,-1.894,.075),vec4(.414,.362,1.063,.263),vec4(.003,-3.876,-1.737,1.772),vec4(.825,-.969,-3.107,1.086),vec4(1.009,-2.359,1.032,1.090),vec4(-1.384,-.670,-.033,-2.944),vec4(1.515,-.780,.664,2.461),vec4(-.481,1.250,1.762,1.134),vec4(1.243,1.201,-1.013,-1.934),vec4(-.431,.811,-.179,1.607),vec4(.016,.429,1.218,1.054),vec4(.552,.408,1.564,-.911),vec4(.686,1.011,1.291,-.001),vec4(1.758,-1.220,-.568,-2.091),vec4(-.271,-2.410,-.859,1.548),vec4(.862,.618,-.691,-.235),vec4(-1.962,-.265,-.506,1.121),vec4(2.546,-.219,-1.289,1.102),vec4(1.452,-.860,2.032,-2.960),vec4(-1.537,-1.651,-.877,2.314),vec4(-2.135,-.096,-.502,1.795),vec4(2.380,-1.032,1.518,1.344),vec4(-2.404,-.215,.093,-.567),vec4(2.040,-.003,-1.351,-.091),vec4(.752,1.764,1.501,-.731),vec4(.361,-.703,-1.375,-.131),vec4(-2.248,2.485,.252,.259),vec4(.639,-1.430,-.878,1.458),vec4(-.967,-.390,1.232,-.716),vec4(.897,.598,.936,1.014),vec4(-.622,-.080,-.012,-1.806),vec4(-1.275,.680,-.201,.921),vec4(.516,-.620,.549,-.544),vec4(-.335,1.420,-1.197,-2.464),vec4(2.090,-1.970,-.000,1.745),vec4(1.392,-.926,-.071,1.700),vec4(-.984,1.193,1.035,1.534),vec4(.633,.954,.007,-2.098),vec4(2.814,.447,2.483,2.531),vec4(.983,-.218,.954,2.413),vec4(1.545,-.724,.722,-.352),vec4(.651,1.116,-.478,.551),vec4(2.398,-.414,1.147,1.000),vec4(-1.812,.067,.878,-1.881),vec4(-1.256,3.135,-.750,-.199),vec4(.049,-1.370,-.773,-.069),vec4(-.206,-.456,1.143,-.341),vec4(1.555,-1.153,-.977,.446),vec4(-3.487,1.521,2.846,-1.717),vec4(-.427,.961,.083,.529),vec4(1.030,-.068,.530,-1.698),vec4(-1.514,.101,-2.670,-.173),vec4(-.216,-.253,-2.699,.063),vec4(-1.077,1.224,-1.204,.272),vec4(.953,.153,-.263,1.737),vec4(.086,1.138,-.030,2.197),vec4(-1.960,-1.873,-1.656,-1.929),vec4(-.636,-.742,.059,.391),vec4(.049,1.552,-.386,-1.608),vec4(1.692,.264,.476,.833),vec4(2.708,.575,-1.318,-.663),vec4(-.265,1.303,2.638,-.398),vec4(-.470,1.311,.488,-1.920),vec4(-.515,.706,-1.140,-.078),vec4(-.922,.227,-.789,-.843),vec4(-.417,.607,.413,-.108),vec4(1.754,.078,.718,1.556),vec4(.012,.704,1.721,-.527),vec4(-.032,.015,2.314,1.073),vec4(-1.057,1.775,.251,.898),vec4(-1.220,-.187,.220,-.041),vec4(.343,.578,-1.264,-.403),vec4(-.307,1.331,-.004,.151),vec4(1.098,-.272,-3.365,.041),vec4(.623,.589,-1.151,-.204),vec4(-.311,.754,.153,.255),vec4(.351,-.135,.891,2.260),vec4(1.920,.349,-1.957,-1.181),vec4(1.855,.990,.230,-.783),vec4(-.786,.364,-.271,.658),vec4(.565,.492,.261,.438),vec4(-.539,-.307,.331,-3.844),vec4(.735,.835,.233,-.601),vec4(-.141,1.550,-.823,-.612),vec4(-.004,.894,-2.659,.266),vec4(-1.002,-.742,.638,-1.115),vec4(-2.060,1.467,1.052,-3.414),vec4(.079,-.269,.306,-2.739),vec4(-1.116,-1.210,.842,1.643),vec4(-.315,-1.658,2.652,1.692),vec4(.631,1.489,-1.501,-1.613),vec4(-.431,-.265,-.117,-.448),vec4(-.343,1.459,-.159,-.294),vec4(-.613,2.415,1.071,.110),vec4(1.660,.582,1.774,-.260),vec4(-.522,-1.591,-3.066,.595),vec4(-1.723,-.860,-.238,2.243),vec4(.773,-1.210,.660,-1.320),vec4(-1.043,2.020,1.206,.260),vec4(-.021,-.281,1.010,-1.450),vec4(.625,-1.514,1.185,.385),vec4(1.768,-1.805,-1.054,1.396),vec4(.343,.286,.119,-1.007),vec4(1.068,2.399,.167,-.436),vec4(.780,1.216,.320,.380),vec4(-.951,-.022,-.497,.002),vec4(-.602,-.268,-.304,-.090),vec4(.901,.092,-1.644,-.283),vec4(.993,-.006,-.603,-.648),vec4(4.306,1.244,-1.781,-3.077),vec4(-.431,-.534,-1.912,-1.320),vec4(.344,.900,-.008,.206),vec4(-.832,.234,.803,-1.530),vec4(.831,.024,.366,-1.191),vec4(-2.385,1.028,-.904,2.247),vec4(.626,-.372,-.464,-1.023),vec4(-1.057,.182,-1.153,.822),vec4(.647,1.381,-1.382,.888),vec4(2.310,-1.267,.408,-.477),vec4(1.871,-1.541,-1.363,2.876),vec4(.278,-1.196,-.803,.171),vec4(.901,-.566,1.748,1.144),vec4(.081,-.163,.483,-1.839),vec4(.126,-.361,-1.344,.136),vec4(-.291,-2.592,-1.331,1.126),vec4(2.826,-1.339,.700,-.768),vec4(.076,.356,-1.240,-2.506),vec4(-.729,.068,.179,-.461),vec4(-1.296,-2.233,-2.706,.914),vec4(.145,-.707,.817,.880),vec4(-2.305,.331,-1.020,-.280),vec4(1.245,-1.028,1.561,1.162),vec4(.590,-1.977,.413,.407),vec4(1.075,-2.817,.507,.463),vec4(.308,-.892,.159,-.737),vec4(.199,1.861,1.384,.946),vec4(-.678,.770,.408,.228),vec4(.605,1.266,-.389,-.124),vec4(.526,.581,1.973,.324),vec4(-1.073,-1.406,-.333,-.220),vec4(-3.357,-.236,-.612,2.420),vec4(-.293,-.570,-1.036,.230),vec4(.787,-.183,.412,-.572),vec4(-.441,.260,-.531,-.568),vec4(.083,-.179,-.873,-.791),vec4(1.237,.360,-1.939,-.031),vec4(.493,-.193,.192,.296),vec4(-2.094,-.124,1.475,-1.165),vec4(-1.453,1.820,-.857,.167),vec4(.203,1.535,-1.190,.965),vec4(2.242,-2.246,-1.762,2.007),vec4(-.303,.382,-2.597,.862),vec4(-.863,.982,1.457,-1.056),vec4(1.128,-1.110,-.464,.024),vec4(.759,.094,3.220,.615),vec4(.174,.333,.251,-.031),vec4(.812,-1.003,.828,.326),vec4(1.382,-.461,-.100,-.049),vec4(-1.207,-1.555,.514,.815),vec4(.062,.617,.141,-2.175),vec4(-2.155,-.804,-.861,.037),vec4(1.076,-1.905,-2.037,.645),vec4(-1.122,-.820,-.102,1.351),vec4(.377,.606,1.629,-.359),vec4(.017,-.675,1.572,1.131),vec4(.245,-.740,.392,1.170),vec4(-.261,.393,-.220,-.496),vec4(-.971,1.028,-.764,.509),vec4(.242,-.142,.018,.225),vec4(-1.400,1.693,.380,-.030),vec4(.118,.572,-.097,-.371),vec4(-.895,-1.194,-3.068,2.926),vec4(-1.457,.446,1.177,-1.296),vec4(.420,-1.572,-2.111,4.226),vec4(-.567,1.576,-2.009,1.322),vec4(-.623,-.251,1.108,.131),vec4(1.506,-.780,-.193,-.114),vec4(1.504,.672,-.145,1.349),vec4(.244,-1.002,-1.192,1.078),vec4(1.389,-.234,-.084,.594),vec4(.217,-.758,.368,.006),vec4(-.481,-.357,1.919,-.624),vec4(.511,-2.181,-1.138,.431),vec4(-.915,-.954,1.676,.491),vec4(1.009,-.338,-.610,1.787),vec4(1.300,-.868,.468,-.424),vec4(.460,-.062,1.326,1.660),vec4(1.198,.052,.514,-.639),vec4(-1.747,-1.059,-.706,.484),vec4(.998,-1.515,1.385,-.183),vec4(-.637,-1.155,-1.554,-.170),vec4(1.062,1.509,.925,-2.086),vec4(-.198,.227,-.133,-.918),vec4(1.284,.518,-.527,-.783),vec4(.416,-2.711,-.819,1.102),vec4(.973,.241,.657,.964),vec4(.629,-.340,.110,3.161),vec4(-1.648,-.565,-.195,.789),vec4(.106,.447,.789,.071),vec4(.470,.449,.607,-.192),vec4(-.218,.113,-.073,-.387),vec4(.494,1.859,-2.122,1.377),vec4(.863,.080,-.119,.833),vec4(.645,2.114,-.451,.876),vec4(-1.783,-.530,-.091,-1.968),vec4(-.837,-.271,-.586,1.081),vec4(-.174,-1.424,.598,.203),vec4(-.854,-1.411,-1.928,-1.530),vec4(-2.097,.675,2.501,.614),vec4(-.145,-1.071,-1.059,-3.033),vec4(-.477,-.355,.791,-.224),vec4(-2.072,-.384,.159,-1.056),vec4(.722,.006,1.065,-.155),vec4(.233,.440,.725,.978),vec4(.799,1.112,-.149,-.852),vec4(-1.409,-.654,-.608,-3.213),vec4(-.141,-2.166,-.926,.218),vec4(.426,.181,1.123,.361),vec4(.584,-.447,-.188,1.488),vec4(-1.923,-1.687,1.369,-1.296),vec4(-.991,-.509,1.317,.740),vec4(.359,-1.687,-.403,-.763),vec4(-.558,.585,.108,.772),vec4(-.556,1.181,-3.180,1.306),vec4(2.205,-.232,-1.756,-.101),vec4(-.178,.777,-1.333,-.704),vec4(-2.877,-1.484,2.315,2.987),vec4(1.286,-.897,1.157,-.436),vec4(-.871,.609,-.501,.285),vec4(-.078,-1.585,-.450,1.088),vec4(-.072,.257,.406,.370),vec4(3.531,1.393,.722,-.139),vec4(-.110,-.014,-.276,-.686),vec4(.642,.704,.188,-.642),vec4(.891,1.199,-.489,1.167),vec4(-.060,1.459,-.633,.556),vec4(-.365,-.423,-.473,.912),vec4(-.749,.624,.002,-.227),vec4(.135,.773,1.504,2.618),vec4(-1.117,-1.121,-3.355,-1.550),vec4(.610,-1.180,-.090,-.770),vec4(.234,1.191,.906,-.198),vec4(-1.518,.311,2.515,-2.000),vec4(-.684,-.680,.697,1.964),vec4(1.058,.745,-1.274,.418),vec4(2.040,.208,.037,1.389),vec4(.308,.540,.046,2.095),vec4(-1.082,-2.164,.281,-.237),vec4(-1.488,-.800,.522,-1.739),vec4(-2.220,-1.377,-1.648,-.579),vec4(.813,.957,1.274,-.658),vec4(-.266,-1.516,2.368,-.740),vec4(-1.424,.489,-1.749,.820),vec4(.483,1.049,.566,-.777),vec4(-1.825,-1.356,-1.050,1.341),vec4(-.530,1.775,-.546,.848),vec4(.207,-2.300,-.389,.610),vec4(2.014,-1.329,-.587,.323),vec4(-2.104,.888,.631,-1.668),vec4(-.933,-.448,-1.392,1.134),vec4(-1.449,-.441,1.818,.456),vec4(-.232,.922,1.599,.743),vec4(1.982,-.109,.098,.067),vec4(1.329,-1.400,.008,-.973),vec4(.286,.340,.634,1.283),vec4(-.016,.559,.702,-3.679),vec4(-2.164,1.473,-.422,1.145),vec4(.850,-.507,-2.167,.348),vec4(.529,1.432,.427,.088),vec4(2.545,.033,.267,1.905),vec4(-1.539,-.562,-.629,-.833),vec4(-.459,1.223,-.941,.319),vec4(.939,.989,.939,-.527),vec4(1.349,.683,-.836,-.602),vec4(.833,.261,-.453,.226),vec4(-1.119,.890,-1.413,.021),vec4(1.953,1.702,-.573,-.549),vec4(-.101,.762,-.487,.772),vec4(-3.513,.041,.941,-1.778),vec4(-.617,.892,.455,-1.259),vec4(.676,1.465,.278,-.720),vec4(-.718,-1.348,-1.348,.923),vec4(.384,-1.518,1.255,.752),vec4(.170,-1.583,-.841,1.691),vec4(.011,1.275,-1.111,.007),vec4(.904,-.405,-1.294,-1.542),vec4(-.957,-.219,-.841,-1.269),vec4(-1.335,-.719,1.225,1.139),vec4(-1.219,-.579,-.587,.788),vec4(.542,-.158,-.645,1.414),vec4(.357,-.977,.242,2.266),vec4(1.605,-.739,-1.755,.051),vec4(.058,-1.732,-1.081,.903),vec4(-1.063,.503,-1.219,1.791),vec4(1.470,-.302,.428,2.333),vec4(-.054,-1.332,.628,1.817),vec4(-.436,-.799,.428,-1.329),vec4(-.035,.111,.091,1.379),vec4(.015,1.172,-.937,.682),vec4(1.373,-.663,.287,.420),vec4(-1.143,.577,-4.490,-2.876),vec4(2.128,-.687,.113,-.941),vec4(-1.248,-.332,.138,-.153),vec4(-1.524,1.332,2.133,-.129),vec4(.932,-.510,-.429,-1.252),vec4(1.794,2.207,-1.365,.740),vec4(-.120,2.007,1.173,.694),vec4(1.383,.256,-.824,-.248),vec4(-.774,-.587,1.971,.101),vec4(-.634,.438,-.558,.641),vec4(.167,.844,.798,.402),vec4(-.688,1.264,-2.400,-.758),vec4(-.847,.286,-.062,.759),vec4(1.131,-1.086,.429,1.638),vec4(.214,.026,.884,2.151),vec4(-.047,.228,.011,1.442),vec4(-.623,-.623,.362,-1.166),vec4(-.286,.093,1.331,.176),vec4(-.128,.030,1.994,-.374),vec4(1.269,.335,1.396,1.030),vec4(1.662,-2.582,3.047,-.002),vec4(-.761,-1.583,-3.842,.458),vec4(1.501,-1.390,-3.137,.678),vec4(-2.439,.422,1.569,-.120),vec4(1.585,.024,.156,-.019),vec4(1.683,-.888,-.070,1.077),vec4(.737,-.758,.789,.483),vec4(.321,.796,.692,1.391),vec4(-1.710,-1.030,.696,.960),vec4(-.533,.434,-.312,.896),vec4(1.507,1.850,2.137,1.489),vec4(2.280,.747,1.237,.713),vec4(1.601,-1.153,-.027,2.834),vec4(-.385,.989,.684,-1.353),vec4(.847,-.773,.318,.326),vec4(.494,-1.025,-.019,-.571),vec4(1.912,1.734,-3.901,1.867),vec4(-.195,2.990,-.813,1.753),vec4(.489,.454,-.669,.075),vec4(.038,-1.775,.731,-1.021),vec4(-.400,-.038,-1.415,.774),vec4(.990,-.988,1.515,.565),vec4(-1.458,2.067,-.330,.793),vec4(1.561,-1.377,-2.042,-.056),vec4(1.546,-1.142,-.158,.719),vec4(.696,-1.481,-1.233,-1.156),vec4(.288,.271,-.832,.096),vec4(-2.960,.868,.210,.022),vec4(1.078,-.220,-1.904,.458),vec4(.809,.486,-1.331,.292),vec4(-.634,.950,1.700,-3.087),vec4(.618,.028,.872,-.043),vec4(3.238,-1.666,2.643,.760),vec4(.262,-.333,-.392,-2.105),vec4(-.974,.069,-.994,-2.772),vec4(.576,-1.104,-.763,.066),vec4(.140,-3.050,-2.430,.336),vec4(.760,-1.460,-1.835,.754),vec4(-.122,-.839,.629,1.392),vec4(-.153,-.123,.279,1.303),vec4(-.844,-.230,.033,.626),vec4(.908,-.700,-.770,.940),vec4(.845,1.449,1.480,1.110),vec4(.269,.990,1.374,-1.025),vec4(.072,-.195,-1.746,1.229),vec4(-1.080,.678,-1.007,.281),vec4(-.302,-.091,-1.896,-1.015),vec4(-2.384,-.656,.243,-4.739),vec4(-.570,-.392,1.193,.875),vec4(1.527,.851,-1.661,1.389),vec4(2.421,3.924,-1.299,.364),vec4(1.001,1.255,-1.491,-.202),vec4(-2.564,-1.210,-.864,.185),vec4(1.327,1.999,2.821,-.845),vec4(1.008,-.507,.924,.050),vec4(.462,.608,-3.335,-.331),vec4(.432,-2.255,-.245,.565),vec4(-2.977,.247,1.881,-4.004),vec4(-.539,.822,-1.076,.408),vec4(-2.362,-.859,-2.004,.542),vec4(-1.151,.943,1.287,-.283),vec4(.763,1.670,2.037,-.909),vec4(.596,.179,.472,.096),vec4(1.103,-.366,-.029,1.031),vec4(-3.853,-.980,.290,.156),vec4(-1.947,.560,1.880,2.829),vec4(-1.603,-2.872,-.935,-3.244),vec4(-2.170,1.450,.930,-2.081),vec4(.129,-2.045,-1.335,1.109),vec4(.273,-1.956,-3.486,.450),vec4(-.365,-.721,.563,.805),vec4(-1.411,-.420,-1.340,-.117),vec4(-1.478,-1.074,.257,.782),vec4(.912,-1.891,-.267,1.114),vec4(.108,.204,-.892,.747),vec4(.890,-.769,-1.384,2.331),vec4(1.480,.574,.909,.356),vec4(3.455,-.235,.336,-.345),vec4(1.715,1.096,-.417,-.424),vec4(.796,.581,-1.107,1.313),vec4(.260,-.441,.505,-.134),vec4(-.466,-1.442,.637,1.671),vec4(-1.374,.093,-.644,.047),vec4(-.315,.431,1.955,1.192),vec4(1.044,1.031,-.357,1.067),vec4(.205,-.781,.320,-.054),vec4(.074,.837,-.974,.309),vec4(-2.056,-.714,.870,-1.878),vec4(.449,-1.733,.224,1.587),vec4(-1.158,.289,.093,-.646),vec4(.443,-1.388,-.561,.469),vec4(-.201,1.338,-1.591,1.628),vec4(.453,-.137,-1.632,-.476),vec4(-.124,-.189,.767,-1.772),vec4(-1.283,-.404,-1.456,-.426),vec4(.352,1.034,1.677,-1.103),vec4(.037,1.954,.961,-1.685),vec4(.566,-.179,-.754,-.263),vec4(-.474,.683,-.160,1.711),vec4(2.205,-.348,-.531,1.122),vec4(-.156,.275,-1.398,.528),vec4(.081,-.844,-.800,-.094),vec4(.151,.604,-.625,.119),vec4(.207,1.964,.860,.184),vec4(.508,-1.026,.817,1.314),vec4(.107,.016,.721,.420),vec4(2.010,-.026,.180,.338),vec4(-.452,.029,.220,-2.433),vec4(-.219,-.206,.090,.033),vec4(-1.395,-.434,.501,-1.584),vec4(-.026,.409,.368,-.356));\nconst vec4 embed1[1024] = vec4[](vec4(-.062,-.125,-.114,.596),vec4(.289,.227,-.275,.710),vec4(-.229,-.206,-.947,1.105),vec4(.451,.320,-.812,.789),vec4(-.200,.601,-1.074,.267),vec4(.126,.493,-1.102,.309),vec4(-.441,-.358,.221,.292),vec4(-.188,.319,1.432,1.184),vec4(.314,-.929,.085,-.263),vec4(.373,1.068,-.664,3.770),vec4(1.932,2.115,-.732,2.702),vec4(1.385,-.447,-1.445,.899),vec4(-.568,-1.500,-1.817,1.543),vec4(-.242,-.460,-1.446,-.901),vec4(-.449,1.663,-.315,-.578),vec4(-.858,2.913,-1.494,-3.079),vec4(-2.149,2.046,-2.165,-3.722),vec4(-5.272,.928,-3.454,-2.514),vec4(-1.506,-1.275,.076,1.442),vec4(-2.132,-.101,-1.621,.233),vec4(1.150,.983,-.563,1.641),vec4(1.103,.869,-.625,.381),vec4(.960,.036,-.584,.258),vec4(1.227,.332,-.326,.284),vec4(.887,.806,-.382,.091),vec4(.063,.864,.407,-.788),vec4(.472,.481,-.013,-.557),vec4(.024,-.367,.260,-.486),vec4(.531,-.027,.136,-.263),vec4(.216,-.027,-.267,-.391),vec4(.150,-.003,-.001,-.373),vec4(.355,-.247,.161,-.322),vec4(.181,.221,-.843,.554),vec4(.789,.120,-.857,.672),vec4(-.104,.709,-1.380,.784),vec4(-.395,.779,-.818,.655),vec4(-.437,.146,-.628,.158),vec4(-.527,-.433,-.436,.242),vec4(-.423,.016,-.461,.753),vec4(.965,-.921,1.419,.684),vec4(-1.658,.724,-.606,-.103),vec4(1.107,.426,.689,.280),vec4(3.407,.239,-.615,2.819),vec4(-1.084,2.184,-2.428,-1.335),vec4(-4.456,.407,-4.205,-3.709),vec4(.312,-.118,-2.783,.962),vec4(.683,.138,-.584,.063),vec4(.399,.745,.380,-1.804),vec4(.019,.860,-1.631,-2.137),vec4(.210,1.719,1.552,-1.351),vec4(-2.507,-.164,-.275,-2.148),vec4(-2.055,-4.188,.703,-2.293),vec4(.745,1.962,-1.405,-.200),vec4(2.035,.219,-1.902,-.467),vec4(.897,.362,-.826,.602),vec4(.904,.654,-.537,.137),vec4(.659,.007,-.599,.472),vec4(1.148,.732,-.656,-.389),vec4(.360,-.128,.051,-.646),vec4(.283,-.315,.091,-.421),vec4(.379,.172,-.363,-.474),vec4(.447,.138,-.525,-.472),vec4(.166,-.013,-.474,-.451),vec4(.617,-.409,.753,-.941),vec4(.171,-.602,-.701,.896),vec4(.701,.014,-1.164,.561),vec4(.812,.480,-.993,.438),vec4(-.575,.882,-1.298,.584),vec4(-.880,-.422,.140,.530),vec4(-.207,.669,.496,.485),vec4(-.384,1.388,.226,.041),vec4(.261,-.387,.117,-.672),vec4(1.104,1.090,-1.917,-1.631),vec4(-2.921,1.313,.773,.971),vec4(-.246,-1.261,-.423,-.996),vec4(1.751,.853,-.465,1.282),vec4(-.155,2.175,.920,1.825),vec4(1.108,1.733,-.988,-1.912),vec4(-2.403,-3.059,-.427,-2.839),vec4(-.240,-1.841,-1.471,-.552),vec4(1.117,-1.812,-.926,.443),vec4(.587,-1.274,.271,.566),vec4(1.818,.578,-.395,.781),vec4(.085,2.160,.269,-.420),vec4(2.313,1.924,-.983,-2.278),vec4(2.286,3.767,-1.265,.863),vec4(.619,.346,.119,-.290),vec4(-.483,-.138,-1.363,-.173),vec4(.500,.470,-1.480,-.968),vec4(.521,1.666,-.352,-2.335),vec4(.407,.207,.080,-1.045),vec4(.382,.167,-.916,-.537),vec4(.319,.066,-.380,-.291),vec4(.254,-.296,-.576,-.029),vec4(.890,-.297,-.632,.198),vec4(-.183,.580,1.062,-.576),vec4(.256,.331,-.983,.882),vec4(.736,-.277,-.927,.804),vec4(.972,.540,-.636,.307),vec4(.624,.533,.199,-.797),vec4(.071,.581,-.181,-.007),vec4(-.406,1.366,1.254,1.631),vec4(1.344,1.086,.728,1.608),vec4(2.554,1.288,-1.261,.311),vec4(3.967,.440,-.339,-2.020),vec4(-3.099,-.034,.295,.390),vec4(-1.427,-2.233,.936,1.436),vec4(-.385,-.087,.957,1.920),vec4(-4.036,.651,-.068,3.776),vec4(-1.505,-.544,.865,3.253),vec4(.279,-.759,1.796,2.033),vec4(-1.008,-1.438,.454,1.046),vec4(-1.187,.074,.110,1.159),vec4(-.587,1.057,-.734,1.418),vec4(.628,-.262,-1.779,.089),vec4(.047,-.475,.945,-.620),vec4(-1.609,-1.744,-.016,-.413),vec4(.071,.620,-.158,-.362),vec4(.622,.953,.084,-.926),vec4(.335,.454,-1.726,-1.329),vec4(-.970,.164,-1.216,-1.361),vec4(-.473,2.075,-.437,-1.960),vec4(.905,1.695,-.319,-.947),vec4(-1.006,.792,-.389,-.359),vec4(.515,.124,-.413,1.385),vec4(.846,.043,-.492,.698),vec4(1.012,.002,-.855,.731),vec4(-.142,-.961,-1.001,.148),vec4(1.112,.079,-.771,.237),vec4(.679,-.543,-.529,.712),vec4(.512,-.220,-.438,-.278),vec4(.596,-.057,.291,-.106),vec4(2.015,.830,2.281,-1.006),vec4(1.439,3.263,-.773,1.261),vec4(-1.191,-.312,1.611,-.176),vec4(-1.674,2.011,-1.960,2.491),vec4(-.294,.239,-2.371,.160),vec4(-.129,-.855,-.862,-.070),vec4(.722,-.395,.017,.061),vec4(.134,-1.429,1.074,2.093),vec4(-1.070,-1.142,2.382,-.752),vec4(-3.018,.104,1.148,.832),vec4(1.311,1.760,5.051,-.810),vec4(-.965,1.299,-.286,-.764),vec4(-.250,-.319,-1.512,1.186),vec4(-.104,-1.139,-.559,-.007),vec4(.203,-1.403,-.112,-1.176),vec4(1.713,1.150,.127,-.496),vec4(-.079,1.111,.859,-.618),vec4(-.496,-2.167,2.105,-1.475),vec4(-3.175,-.518,1.468,1.691),vec4(-1.908,.217,1.101,.365),vec4(-.006,.168,.055,.474),vec4(-.939,-1.147,.137,-.679),vec4(-1.885,.442,.922,-1.571),vec4(.402,.711,-.196,2.010),vec4(.841,.661,-.009,.696),vec4(.515,.787,-.473,1.108),vec4(.611,-.884,-1.027,.198),vec4(-.158,-.745,.775,.367),vec4(-.076,.483,-.427,-.556),vec4(.288,.080,-.548,-.418),vec4(-.199,-.969,-.927,.753),vec4(-1.769,.391,-1.200,.157),vec4(.040,-.583,-1.368,.345),vec4(-1.494,-.300,-.251,.680),vec4(1.653,.092,-1.260,1.550),vec4(-3.515,1.436,-.627,.030),vec4(-1.742,-.517,-2.943,-.414),vec4(.784,.420,.897,-2.095),vec4(-1.922,.864,.265,.236),vec4(.972,-1.762,-.757,.922),vec4(-2.018,-.887,-.116,-.831),vec4(-1.390,-.074,-.100,-2.558),vec4(.032,-.101,1.302,-.958),vec4(.193,-.947,-.174,-2.583),vec4(1.719,.642,1.779,1.290),vec4(.735,-.263,-.190,-.837),vec4(.572,2.556,-1.247,.156),vec4(-.908,-1.956,.203,.602),vec4(-.505,.213,2.026,-1.125),vec4(.858,3.416,-.057,1.269),vec4(1.033,-2.508,1.958,-.571),vec4(.065,-1.021,-.930,.640),vec4(-1.391,-2.064,.216,-.635),vec4(.163,-1.792,-.641,-.481),vec4(1.448,-.919,1.153,-.194),vec4(4.112,.241,1.342,2.152),vec4(.032,1.968,-.450,1.185),vec4(-.563,-.629,.146,.312),vec4(-.055,-.406,-.574,-.556),vec4(-.702,-.070,.360,.453),vec4(-.374,-.457,.035,-.389),vec4(-.460,-.008,-.711,-.037),vec4(-.536,-.351,-1.206,.638),vec4(-.831,-.553,.144,2.781),vec4(2.206,-.750,.418,1.952),vec4(-1.505,2.761,-.981,.849),vec4(-.580,.872,-2.331,4.156),vec4(.247,1.365,-3.777,2.550),vec4(1.381,-.526,-2.094,-.643),vec4(-.172,-.106,.323,-2.252),vec4(-.243,-1.387,-1.382,.111),vec4(-2.056,.509,.290,1.875),vec4(-2.454,-1.364,.585,-.689),vec4(-.294,1.645,-.302,-1.825),vec4(-.434,.361,2.162,.349),vec4(2.016,1.568,.400,-.220),vec4(-.188,-.543,-1.228,-1.332),vec4(3.448,2.582,2.392,1.462),vec4(-.364,1.920,-1.298,.448),vec4(-.874,-1.205,.434,1.181),vec4(-1.258,.924,-.936,-.668),vec4(1.222,.806,-.809,1.755),vec4(2.497,-.548,-.874,1.223),vec4(-.176,.936,-2.030,-.209),vec4(-1.371,2.004,-1.983,.245),vec4(.029,-.587,-.534,.629),vec4(1.664,-.117,.213,1.279),vec4(1.855,1.887,-.304,-1.401),vec4(-.666,-.314,-.497,.381),vec4(-.944,-.714,.671,1.612),vec4(.677,-1.904,.557,2.299),vec4(-.519,.055,.139,-.370),vec4(-.620,-.593,.217,-.276),vec4(-.785,-.397,-.250,-.123),vec4(-.208,.412,-.785,-.740),vec4(-.667,-1.016,-.375,-1.879),vec4(.498,-.097,-.745,-1.648),vec4(-1.298,.557,.448,-1.626),vec4(-1.270,-1.965,1.587,-1.077),vec4(-1.718,-1.469,.614,.497),vec4(.158,.165,-.353,-.785),vec4(-.408,.164,.646,-1.033),vec4(1.235,1.233,-.331,.823),vec4(-1.640,-.242,.560,-.841),vec4(-2.708,-1.500,-1.116,-.229),vec4(-2.473,2.010,-1.103,-.009),vec4(.732,-.014,1.264,-1.644),vec4(.084,-1.386,-1.015,-1.043),vec4(.961,-.260,.155,-.803),vec4(-1.933,-1.040,1.351,1.693),vec4(-2.867,-.035,-1.051,.322),vec4(-.271,-.570,.571,1.589),vec4(-.168,-.594,-1.856,.156),vec4(1.882,.372,-1.604,-1.049),vec4(-.048,-1.850,-1.384,.051),vec4(-.425,.305,.127,2.232),vec4(-.424,-1.669,2.204,-1.732),vec4(-1.469,-2.136,.425,.515),vec4(.920,-.005,1.521,-.535),vec4(-.930,1.733,.976,1.495),vec4(1.954,-3.038,1.489,3.780),vec4(1.759,.422,.442,2.146),vec4(.023,-.245,1.591,1.199),vec4(-.680,1.298,-.523,-.512),vec4(-.595,-1.247,.596,.113),vec4(-.568,-.593,.302,.039),vec4(-1.478,-1.170,.123,.578),vec4(4.055,6.707,-1.881,6.299),vec4(.321,-1.562,.180,-2.802),vec4(.237,-.655,-1.248,-1.271),vec4(.461,-2.347,-1.008,-1.727),vec4(-5.181,-1.754,-.652,-1.709),vec4(.040,.132,-.465,.612),vec4(.686,-1.032,-.344,1.118),vec4(-.592,-.502,1.144,-.178),vec4(-1.649,.299,-1.473,.646),vec4(-2.186,1.893,.595,1.604),vec4(-1.709,-2.055,-1.127,.225),vec4(.932,.489,1.011,-.431),vec4(-.123,-1.113,.323,-.385),vec4(.018,-.958,-.130,-.609),vec4(-.266,-.620,-.505,.882),vec4(.378,.526,.146,.744),vec4(-.779,-.117,1.249,.932),vec4(1.106,1.215,-2.564,.108),vec4(.538,.008,-.301,-.116),vec4(1.113,2.613,-3.051,-.657),vec4(.292,-1.633,-.614,1.353),vec4(2.502,-2.384,-1.694,-3.176),vec4(.639,-1.187,2.029,-.677),vec4(.021,-.158,3.702,-.096),vec4(-1.383,-1.358,1.493,2.084),vec4(1.740,-.713,.667,2.844),vec4(1.062,-2.167,3.063,1.969),vec4(1.033,-.235,-1.405,1.894),vec4(-.668,.719,-.765,1.897),vec4(1.445,.727,.279,.478),vec4(-.406,-.351,.558,-.903),vec4(-.993,2.127,.226,-.791),vec4(4.104,2.086,5.297,3.038),vec4(-.272,-.220,-.989,-1.842),vec4(1.110,-.164,-.759,.837),vec4(1.410,-.769,-1.524,-.822),vec4(-1.824,-3.440,-.933,-1.577),vec4(.461,2.460,1.349,2.474),vec4(.337,-.793,-1.118,-1.711),vec4(-1.817,-1.052,-2.348,-.246),vec4(-2.545,.555,-1.963,-.319),vec4(-.986,.198,.904,.738),vec4(-.115,-1.133,-.059,1.641),vec4(-2.213,-.384,-.287,-.767),vec4(1.897,-.743,-.058,-.385),vec4(.353,-2.261,1.548,-.468),vec4(-.698,-1.780,-.858,-.978),vec4(-1.922,-1.022,.413,1.009),vec4(1.637,.118,.259,-.385),vec4(-.624,1.289,-1.856,-.642),vec4(-.091,-.137,.673,.114),vec4(2.251,-.023,.073,.109),vec4(.944,-.988,-2.165,-.981),vec4(.836,-1.195,-1.825,1.850),vec4(1.090,-1.557,.137,-.443),vec4(1.169,-1.060,1.062,1.387),vec4(.228,.705,-.134,-.042),vec4(-.090,-.214,-3.412,-1.464),vec4(.411,-2.313,1.845,-.115),vec4(3.261,-2.097,3.285,2.808),vec4(-.709,-.168,1.510,1.331),vec4(1.832,.894,.884,-.620),vec4(1.369,.438,1.457,.414),vec4(-.864,1.406,1.100,-.997),vec4(.047,-1.984,3.830,-3.182),vec4(-.075,-.032,-.718,-.619),vec4(-1.948,1.850,-.352,.162),vec4(1.702,-2.412,-.403,.610),vec4(.023,-3.320,-.875,-.082),vec4(1.553,1.427,-.095,1.658),vec4(.634,.184,-.308,-1.662),vec4(-1.670,-.310,-.150,-1.208),vec4(-.569,-.650,-.644,-2.146),vec4(1.330,-1.001,1.679,.526),vec4(.683,-1.234,2.237,.970),vec4(-.298,-1.464,2.224,-1.194),vec4(2.107,.433,-.980,-.978),vec4(1.484,-.541,1.575,.181),vec4(2.078,-.190,2.686,1.210),vec4(1.718,-.760,2.268,-1.419),vec4(.014,-1.666,-.224,-1.082),vec4(-.609,.015,.721,.167),vec4(1.095,-.617,-.175,.346),vec4(.886,-1.617,-1.948,-.497),vec4(.569,-.471,-.019,.194),vec4(1.829,1.098,-.776,1.802),vec4(1.117,-.353,1.561,-1.357),vec4(1.576,-.439,.903,-.023),vec4(-.459,1.774,-.461,-.297),vec4(-2.970,.354,-5.433,-2.203),vec4(1.649,-.197,-.097,.681),vec4(.757,-5.256,3.149,3.704),vec4(1.496,-1.506,1.482,1.502),vec4(1.332,1.532,1.298,-1.867),vec4(1.452,1.598,1.016,-1.186),vec4(.944,1.456,1.333,-1.219),vec4(.065,-1.849,1.522,2.016),vec4(1.550,.137,-.219,-1.105),vec4(.028,-.896,-.165,.152),vec4(-1.883,-.125,.791,-.168),vec4(1.867,-.025,-.429,1.305),vec4(1.774,1.402,-3.396,.528),vec4(-.273,-.590,-1.135,-1.262),vec4(.147,.950,.910,-.580),vec4(-.709,.990,.357,-1.555),vec4(2.937,.830,-1.212,1.156),vec4(-1.195,1.188,-1.031,-.406),vec4(-.004,.731,-.960,-1.311),vec4(-1.199,-1.509,-.181,.265),vec4(1.710,-1.546,.059,-.409),vec4(1.035,-.474,-1.413,-1.626),vec4(.965,-2.250,1.364,-1.017),vec4(.381,-.168,1.596,1.000),vec4(-1.994,1.064,.443,-.474),vec4(.786,.242,1.048,.366),vec4(.612,-2.021,-2.111,-1.002),vec4(.887,-.775,.080,.343),vec4(.573,-.582,.070,.650),vec4(.585,.315,-.869,-.781),vec4(-1.921,-.000,-1.181,.751),vec4(-2.012,-.035,-.074,-2.668),vec4(-1.606,-.833,.121,-1.580),vec4(1.464,.563,.724,-2.248),vec4(-2.847,.611,-2.675,3.305),vec4(.215,1.715,.431,.049),vec4(.893,1.425,.061,-1.113),vec4(.845,1.775,.345,-1.862),vec4(1.095,1.621,.121,-1.360),vec4(2.331,1.557,.862,-.341),vec4(-.199,.453,2.088,-.739),vec4(.450,.542,-.470,2.501),vec4(-.541,-1.400,.184,.601),vec4(1.558,.563,-.560,1.197),vec4(.819,1.867,.040,.081),vec4(1.156,1.206,-1.746,-1.654),vec4(-.754,-.934,.562,-.843),vec4(-.599,-1.395,-.673,.316),vec4(2.540,1.221,1.719,-1.258),vec4(-.058,-1.350,.257,-3.071),vec4(1.048,.003,.339,-2.936),vec4(1.423,-.119,-2.266,-2.484),vec4(-.174,-.860,-1.127,-2.356),vec4(1.118,.504,-1.038,-2.024),vec4(1.078,.314,.768,.561),vec4(-.607,-.515,1.149,-1.769),vec4(-.736,-.927,.879,-1.089),vec4(.537,-.332,1.745,-.014),vec4(1.106,-.057,-1.198,.386),vec4(.849,-1.875,-1.470,.667),vec4(-.240,-1.147,-2.101,-1.666),vec4(.091,-.561,-1.146,-.441),vec4(-1.515,.048,-.672,-.480),vec4(-.589,-.504,-1.607,-.827),vec4(.989,-.625,3.178,2.400),vec4(-1.329,2.287,-1.262,.901),vec4(-1.837,-.084,-.819,2.491),vec4(.013,-.116,.479,-.566),vec4(-.025,1.254,-.039,-1.457),vec4(-.764,.815,-.201,-1.793),vec4(.612,1.623,-.148,-1.072),vec4(1.416,2.727,-.621,-1.333),vec4(1.402,1.806,-.412,-1.195),vec4(-.255,.717,-.335,.433),vec4(.346,-.683,.023,.206),vec4(-1.081,-.005,-.207,.866),vec4(2.552,-.148,-.753,-.843),vec4(-.735,.313,-.332,.159),vec4(-.391,.096,.101,-.140),vec4(-1.123,-1.283,1.834,-1.602),vec4(1.313,.620,1.489,.339),vec4(-3.141,-.010,.528,-.175),vec4(-.561,.531,-1.079,.128),vec4(.251,.926,.133,-1.500),vec4(-.796,.300,-.089,-.627),vec4(-1.029,1.335,-.185,.398),vec4(1.251,-.258,-2.328,-1.049),vec4(.226,-.814,-2.140,1.117),vec4(.681,.928,2.393,-.033),vec4(-.192,-.681,1.757,-.680),vec4(1.444,-.095,-.234,.408),vec4(-1.758,-1.904,-1.631,-1.676),vec4(-1.801,-.138,-.082,-1.629),vec4(-.426,-1.606,-1.573,-.555),vec4(.358,-.573,-2.175,-.239),vec4(.102,1.683,-.086,-1.107),vec4(-.043,-.819,1.029,2.768),vec4(1.054,.755,2.899,-.292),vec4(-2.037,.384,-.209,2.871),vec4(.991,-.467,.195,2.455),vec4(.613,.813,.604,-1.443),vec4(.993,1.379,.525,-1.669),vec4(3.025,2.998,-.243,-2.255),vec4(1.949,2.541,-.715,-3.727),vec4(.909,.277,-.296,2.174),vec4(2.923,1.086,-.229,-.327),vec4(-.087,.601,1.077,.280),vec4(2.438,-.671,-.002,.577),vec4(-2.901,-.287,-2.669,-1.286),vec4(.727,-.195,1.870,-.385),vec4(-.494,.251,-.089,-2.387),vec4(.198,-.522,.284,-1.425),vec4(.879,.483,.250,-2.149),vec4(-2.276,2.126,-.147,.574),vec4(.804,.930,-2.477,-1.044),vec4(-.006,2.371,.187,-1.519),vec4(-.717,-.165,.616,-2.783),vec4(-1.561,1.073,-1.692,-2.554),vec4(-.664,1.990,.907,.376),vec4(-.343,1.788,-.949,1.209),vec4(1.162,-.508,-1.277,.069),vec4(-.958,-2.307,-.177,-.773),vec4(-.638,-.239,-.589,.514),vec4(-1.200,-1.652,-2.830,-1.147),vec4(-2.039,-1.590,-.266,-1.355),vec4(-.213,-1.040,-2.110,-.971),vec4(-1.781,.270,-1.183,-1.481),vec4(.911,.949,.762,-.178),vec4(1.928,1.641,-.205,4.181),vec4(.393,.621,.745,4.068),vec4(-.068,-.021,.595,2.210),vec4(.243,-.358,.372,1.560),vec4(-1.224,-1.149,-2.255,-1.003),vec4(-.146,-.209,.267,-.855),vec4(2.736,2.928,-1.352,-2.949),vec4(-.765,.304,1.310,1.009),vec4(-.185,.469,1.386,-2.636),vec4(1.994,.494,-.915,1.254),vec4(1.693,.503,.110,.531),vec4(-1.517,-.069,-.842,.643),vec4(-2.973,.042,-1.364,-1.298),vec4(.572,2.336,.745,-.122),vec4(-.855,.162,.559,-1.324),vec4(-.703,2.050,1.959,.702),vec4(1.448,1.095,-.950,-.232),vec4(-.587,.121,-1.115,-1.537),vec4(-1.111,2.306,-1.568,-1.735),vec4(-.429,2.097,-.074,-1.875),vec4(-2.511,-.291,-.710,-2.722),vec4(.307,-1.342,-.052,-1.368),vec4(-.627,1.885,.885,-.527),vec4(1.728,-1.636,1.217,-1.148),vec4(.378,-.040,-.700,-1.576),vec4(-.115,-2.885,.075,1.736),vec4(-.735,.732,-.104,.476),vec4(-.705,.188,-.591,1.938),vec4(-1.493,-.178,-2.037,-1.869),vec4(-1.257,.817,-.785,-1.050),vec4(.649,-.767,.126,-2.364),vec4(1.608,-.736,-.866,-.163),vec4(-3.675,-.233,-.104,-2.134),vec4(-1.076,-.371,-1.269,2.637),vec4(.797,.230,.267,2.014),vec4(1.286,.575,-.757,-.315),vec4(-.222,.578,-1.832,-2.169),vec4(.070,.186,-3.868,-3.221),vec4(-.786,.472,-.142,-.897),vec4(-1.454,-.540,.391,1.496),vec4(.686,.660,-1.579,-.987),vec4(2.947,-.439,-.243,.602),vec4(-1.157,-.160,-1.180,.777),vec4(-.811,-2.211,-.794,-.366),vec4(-1.001,-2.147,2.231,5.857),vec4(.303,1.881,.682,-.712),vec4(.460,2.022,.098,.075),vec4(.325,1.367,2.783,1.057),vec4(-1.242,-1.979,-.241,-1.106),vec4(-.454,-.424,-.310,-.770),vec4(.412,.292,-.374,-1.531),vec4(-.891,2.258,-.637,-1.378),vec4(.136,-.092,1.428,-1.534),vec4(1.383,-1.546,1.387,-3.593),vec4(1.604,-1.650,1.726,-1.657),vec4(-.580,1.608,2.232,-.464),vec4(.244,-.756,.954,-.089),vec4(-.758,-1.068,-.764,2.215),vec4(.973,.107,-.316,-.141),vec4(-.152,-.226,2.670,1.412),vec4(-2.356,.102,-.691,-1.129),vec4(-1.271,-.630,.410,-.601),vec4(-.275,.230,-.513,.753),vec4(.180,.948,-1.942,-.372),vec4(.116,1.921,-.518,.913),vec4(-1.619,.221,-.413,.455),vec4(-.633,.297,.085,.276),vec4(-.723,.447,.006,1.061),vec4(2.973,.864,.550,-1.670),vec4(.174,1.158,-2.785,-.046),vec4(1.255,-.918,1.210,.449),vec4(.703,-.362,-1.153,.428),vec4(.546,.675,-.414,1.915),vec4(.838,.560,-1.027,.426),vec4(.282,-1.762,.799,.734),vec4(.268,-1.294,-2.635,.744),vec4(-.437,-.158,.448,.353),vec4(-.856,.435,-.634,1.478),vec4(1.064,-1.473,3.351,1.124),vec4(-2.153,-1.018,1.596,-.719),vec4(.289,-.261,-.295,-.716),vec4(-.971,-.270,.013,-.988),vec4(-1.275,.534,-1.308,-.426),vec4(-1.719,.403,-.053,-1.172),vec4(.097,.622,.992,-1.129),vec4(.520,.389,.531,-.311),vec4(1.244,1.987,1.137,.205),vec4(.017,-.420,1.573,-.733),vec4(-1.225,.119,.983,-.084),vec4(-.764,2.074,-.744,-.601),vec4(1.304,.459,.241,1.230),vec4(-.410,-1.686,2.779,.725),vec4(-.921,-1.878,.178,-.324),vec4(-1.644,-.009,-.987,-.201),vec4(1.044,.569,-.299,.769),vec4(-1.778,.170,1.012,.480),vec4(2.043,-.710,.355,2.478),vec4(-3.128,-1.713,-.166,1.467),vec4(.255,-1.797,3.456,-.664),vec4(-.336,.726,1.230,1.669),vec4(-.364,-5.484,3.978,2.309),vec4(1.983,1.902,-1.778,-2.158),vec4(-.337,-.471,1.022,.264),vec4(-2.086,-.204,-3.378,.466),vec4(2.428,1.500,2.353,1.853),vec4(.695,1.785,-.378,.521),vec4(1.887,-1.857,.075,.585),vec4(.480,.280,-1.964,-.277),vec4(.466,-1.547,-1.798,-.650),vec4(.068,-2.230,.724,.364),vec4(-.662,1.411,-.500,-.416),vec4(-.498,-.495,-3.188,1.372),vec4(-.491,-.902,-.465,-1.682),vec4(-.385,-.735,1.040,.870),vec4(-1.880,.130,-.443,-3.420),vec4(-1.646,-.837,-.833,-.919),vec4(-1.290,-.834,-.568,-2.542),vec4(1.226,-1.629,-.758,.655),vec4(.381,-.222,-.330,-1.185),vec4(1.513,-1.753,-.880,-.040),vec4(1.681,2.938,1.435,-2.275),vec4(.919,.580,1.149,-.097),vec4(.396,.271,-1.868,.150),vec4(-2.842,-1.260,.544,1.712),vec4(.136,-.344,.545,.837),vec4(-1.027,.222,-1.919,-2.617),vec4(.848,.163,.206,1.791),vec4(3.656,.217,.490,1.217),vec4(-.260,-1.348,-1.940,.778),vec4(2.544,-.740,-.786,1.003),vec4(-.542,-.498,.837,-1.881),vec4(.142,.348,.937,.385),vec4(-.092,-1.031,.288,.471),vec4(-.595,1.326,-.959,-1.069),vec4(.287,-.331,1.077,.950),vec4(-2.644,-1.472,-1.959,1.052),vec4(3.241,3.827,.723,.315),vec4(-.338,-.872,-.398,.887),vec4(1.755,.303,-.406,-1.273),vec4(.896,2.095,-.715,2.748),vec4(-.665,-1.501,1.731,3.820),vec4(.816,.103,.264,-2.460),vec4(2.023,.544,-1.860,1.534),vec4(.659,-.781,-1.435,.547),vec4(-1.042,.046,-1.350,-.644),vec4(-.590,-.862,1.517,1.376),vec4(-.355,.506,1.170,-1.087),vec4(-2.293,-.685,.290,-.883),vec4(.611,-.244,-.405,.749),vec4(-1.322,.069,.716,-1.415),vec4(-.467,.551,2.181,-1.199),vec4(-.039,.604,-.771,-.725),vec4(-1.085,.207,-.580,-.774),vec4(.596,-1.206,-.593,1.210),vec4(-1.663,1.075,.480,-.513),vec4(-1.813,-.904,-.116,.530),vec4(.373,.866,-3.290,-.594),vec4(1.697,-2.407,-1.381,-1.622),vec4(.423,.540,-.469,.819),vec4(1.752,1.263,-.423,-.475),vec4(1.700,.902,-.053,-.723),vec4(-.195,.526,.667,.364),vec4(-1.776,1.671,.274,-.456),vec4(-.071,-1.509,.708,1.623),vec4(.250,.534,.906,-1.594),vec4(.038,4.496,-4.448,-2.371),vec4(-.061,-1.406,-.637,.668),vec4(.882,-.179,-.245,.891),vec4(.397,.071,-1.910,-.043),vec4(-.130,.368,1.044,-.320),vec4(.395,.066,-1.190,.587),vec4(.373,1.450,-.246,1.425),vec4(1.557,3.555,.357,1.349),vec4(-1.407,1.996,-.907,-4.500),vec4(1.154,.447,-2.422,-.904),vec4(.166,.475,.753,.272),vec4(-.901,-1.616,-1.157,2.631),vec4(-2.247,.721,.720,-.858),vec4(.644,.742,.053,.029),vec4(-1.523,.269,-.760,1.461),vec4(1.148,1.530,2.213,-1.477),vec4(-.777,-.335,-.571,-.724),vec4(-.094,-1.314,1.295,-.680),vec4(.219,.138,-2.024,-1.185),vec4(.598,-.508,.881,-.400),vec4(.421,-.763,-.249,-.224),vec4(-.426,.139,.159,-.852),vec4(-.307,1.329,1.893,1.599),vec4(-.130,.269,-1.273,-.731),vec4(.272,1.081,-.565,-.510),vec4(.251,-1.159,1.486,-.337),vec4(-.180,.578,-.559,-1.324),vec4(.412,.054,.847,.788),vec4(1.222,-.455,-.787,.122),vec4(-.768,2.145,.278,-2.096),vec4(-.405,-.513,.282,.106),vec4(-.938,1.432,-1.113,-2.210),vec4(.950,2.541,-.711,-2.267),vec4(1.317,.186,-2.463,-4.041),vec4(.065,.003,-.512,.023),vec4(-.787,-.735,.081,1.220),vec4(-.406,.839,.448,.160),vec4(-.150,.184,-.965,2.762),vec4(-1.661,-1.592,-1.552,3.150),vec4(-1.740,-1.836,-.420,.904),vec4(.535,.172,.407,.924),vec4(.718,.015,-1.483,1.723),vec4(-.658,1.089,.872,.322),vec4(-1.028,1.558,.181,.812),vec4(-2.444,-2.097,1.628,.742),vec4(-1.351,-2.390,-1.392,-1.076),vec4(-1.913,-3.560,-.651,-.230),vec4(-.230,1.707,.457,1.130),vec4(1.900,-1.709,2.804,.817),vec4(-1.238,-.747,-.772,.307),vec4(-.560,-.387,.170,.689),vec4(.572,-1.103,.407,-1.466),vec4(-.900,-.076,-.822,-1.304),vec4(-.435,-.179,.014,-2.668),vec4(.509,-.370,.657,2.129),vec4(.889,-.008,-.637,2.045),vec4(-.286,-.332,-.682,.794),vec4(.782,1.150,.865,-.729),vec4(-.712,-1.563,.109,-.196),vec4(-1.916,-1.639,-.743,-.165),vec4(-.788,.347,.132,.476),vec4(-1.321,-8.356,2.130,5.404),vec4(.840,1.489,.126,-.378),vec4(.311,.590,-1.192,-.820),vec4(.280,.769,-2.117,-3.181),vec4(-1.613,-.423,-2.713,-2.562),vec4(1.773,-.948,2.103,2.341),vec4(-1.900,-.667,-1.555,-1.254),vec4(-1.116,1.439,.710,-.206),vec4(1.563,2.011,1.713,-1.795),vec4(-.533,2.077,.265,.136),vec4(.062,.909,-.358,.787),vec4(-3.024,1.346,-2.366,.349),vec4(.504,-1.215,-.959,.853),vec4(-2.120,3.074,1.715,.198),vec4(-1.337,.941,1.384,.877),vec4(-.512,-.017,1.391,.257),vec4(-2.500,1.169,2.390,1.135),vec4(.441,-1.966,1.803,-.084),vec4(-2.684,.265,-.982,2.124),vec4(-1.724,.322,-.678,-.075),vec4(.401,.018,-1.280,-1.595),vec4(-.740,.076,-.064,-.633),vec4(.115,-.262,.164,-1.874),vec4(-.291,.684,.122,-1.650),vec4(1.207,.666,-.239,-1.868),vec4(-1.842,-.354,2.295,.844),vec4(1.766,.710,-1.656,1.545),vec4(.331,-.547,-.025,1.279),vec4(-.824,.792,-.441,-.112),vec4(-2.010,-.202,-1.839,-2.787),vec4(-.460,.800,-1.122,.615),vec4(3.237,3.645,-.591,.292),vec4(-1.846,-.170,-.657,.336),vec4(1.071,1.013,-.675,.357),vec4(-.796,-.112,-.753,-.845),vec4(-.719,-.749,-1.121,-.599),vec4(-1.289,.535,-2.399,-3.185),vec4(-1.722,-1.037,-.239,-1.738),vec4(.145,.399,-.610,.116),vec4(.027,.432,.103,.702),vec4(.881,-.858,1.457,.897),vec4(-.458,1.950,-.511,-.736),vec4(-.859,.503,1.196,1.263),vec4(-.084,2.520,-1.926,-1.637),vec4(-2.548,-.347,.727,1.054),vec4(.384,3.974,-.685,-1.578),vec4(-1.145,.993,.019,-.285),vec4(-.161,.432,1.567,.545),vec4(-.067,.555,-.127,-1.059),vec4(.969,-3.255,-.811,-.003),vec4(.796,.007,-.278,1.801),vec4(.420,2.485,-1.771,1.324),vec4(1.414,.484,-1.704,-1.649),vec4(.109,-1.473,-.546,-1.480),vec4(1.532,-1.976,1.911,.099),vec4(-.748,-1.562,.450,-1.742),vec4(-.910,-.855,-.418,-1.204),vec4(-.475,.335,.887,-.254),vec4(.169,.562,-.101,1.749),vec4(-.810,.204,-.990,1.801),vec4(-.269,-1.629,-.458,.186),vec4(-.172,-.055,.057,-.076),vec4(2.788,4.031,1.088,-3.065),vec4(-.781,-.452,-1.394,.265),vec4(2.560,2.992,.312,.118),vec4(.573,.617,1.439,-1.891),vec4(-.397,1.608,-.455,.677),vec4(-.065,-.217,-1.103,-.288),vec4(1.404,-.437,2.899,2.613),vec4(-.163,1.403,.428,-1.398),vec4(-.689,-.875,.113,.593),vec4(-.732,1.861,-.058,-.855),vec4(1.367,2.180,.506,-.169),vec4(1.132,.730,-.705,-.259),vec4(-.752,.565,1.266,.951),vec4(-.441,-.430,.271,-.350),vec4(-.062,-.338,.814,1.093),vec4(-1.515,1.266,-.319,1.629),vec4(-2.489,.450,-.974,-2.101),vec4(-2.017,1.954,-.915,2.642),vec4(1.004,.319,-.213,.758),vec4(-1.132,2.955,-.622,-1.551),vec4(1.172,-1.160,.875,.219),vec4(-.179,.267,.954,1.310),vec4(2.477,2.245,-1.512,.230),vec4(.599,.563,1.110,-1.673),vec4(.400,-.287,.315,-.009),vec4(2.757,-.304,-1.332,.606),vec4(-1.006,-2.298,-2.554,.032),vec4(-.978,-2.195,.288,1.405),vec4(.646,-.033,-2.888,-.204),vec4(-.908,.685,-.318,1.611),vec4(-.610,.290,.723,.331),vec4(-.660,-.137,-.130,.100),vec4(.689,-.373,-1.874,1.060),vec4(-1.515,.161,-.918,.536),vec4(.300,-1.194,2.495,-1.685),vec4(1.241,-.168,-2.123,-.484),vec4(-.822,-1.055,-.889,.335),vec4(.763,1.002,-1.768,4.638),vec4(-1.116,-1.911,-1.873,-2.558),vec4(.622,-2.417,1.137,.102),vec4(.624,-1.172,.682,1.617),vec4(.089,-1.035,-.895,.450),vec4(-.594,-.796,.281,-.339),vec4(.138,-.532,.314,-.361),vec4(-5.398,-1.152,1.666,-1.109),vec4(-1.565,.590,-.931,-.542),vec4(-.811,-.079,2.270,.918),vec4(1.691,-.229,-.112,2.494),vec4(-.657,-1.001,-1.520,-1.958),vec4(.273,-.699,.671,.847),vec4(-.736,-.822,-.258,.528),vec4(-.372,-.274,1.313,1.406),vec4(1.256,1.309,-.077,1.567),vec4(.328,1.350,.663,2.693),vec4(1.168,1.427,1.370,-2.269),vec4(2.573,3.600,-2.814,1.628),vec4(.647,.965,1.264,1.226),vec4(-2.021,-2.050,-1.951,2.090),vec4(-1.032,-1.000,-.559,.305),vec4(-1.267,-1.520,-1.547,-.218),vec4(-.821,-2.385,-1.808,2.078),vec4(-1.066,-.035,1.495,.287),vec4(-.017,-.712,-.339,.771),vec4(1.191,-.548,-.437,-1.048),vec4(.148,.428,-1.631,.774),vec4(.272,.612,-1.157,.320),vec4(-.603,.481,-.710,2.695),vec4(.444,.811,.231,.968),vec4(.234,-.878,.084,.178),vec4(1.375,1.480,-.899,-.179),vec4(.225,-.202,-.652,1.129),vec4(-.912,.652,-2.823,2.915),vec4(.082,-.850,.123,1.592),vec4(-.077,.702,-1.732,.442),vec4(.612,-.086,-.588,.445),vec4(-.341,.556,-1.047,-.527),vec4(-1.945,1.485,.457,-.900),vec4(-1.499,-.556,.217,2.592),vec4(-1.519,.900,1.411,3.452),vec4(-.517,-.120,-.620,.939),vec4(.262,-1.561,1.019,.922),vec4(.350,-1.216,-.560,-1.409),vec4(-1.576,-.095,1.930,.956),vec4(2.125,-1.289,.757,1.939),vec4(-1.671,-.891,.175,-1.529),vec4(1.309,.847,-.003,-.014),vec4(-2.518,1.966,-1.214,-1.449),vec4(-.615,2.502,.617,-2.827),vec4(2.273,-.547,1.829,.614),vec4(.859,.721,1.396,-.420),vec4(-.247,-.291,1.782,-1.849),vec4(-.168,-.811,-1.069,1.466),vec4(-1.574,-.098,.141,1.028),vec4(-.924,.390,.733,.552),vec4(1.144,1.338,-2.450,-.855),vec4(-.346,1.192,-.513,-.694),vec4(.052,1.808,-1.434,-1.389),vec4(2.594,.461,.278,.880),vec4(1.169,2.434,1.575,.063),vec4(1.497,-.260,1.205,.450),vec4(-.785,-.396,-2.946,-1.899),vec4(-.537,-.598,-.206,1.279),vec4(.291,1.034,-.688,-2.478),vec4(.467,-.392,.068,-.816),vec4(-.326,-.713,-.098,-.817),vec4(-.628,-.409,-.154,-.627),vec4(.312,-.996,.350,.257),vec4(1.454,.136,-1.162,1.486),vec4(-1.766,-.965,.495,-1.002),vec4(-1.334,.112,1.871,.618),vec4(-2.236,-.672,.930,.070),vec4(-.612,-1.013,.287,1.307),vec4(.982,-1.702,-1.612,-2.692),vec4(1.092,-.350,.916,-.754),vec4(1.915,1.392,1.117,-2.412),vec4(2.144,.701,1.015,-1.277),vec4(.703,-.682,.219,1.695),vec4(-.771,-.671,-1.827,-.837),vec4(.353,.778,-2.729,1.817),vec4(1.114,.758,1.676,-2.555),vec4(.930,.462,1.399,-2.513),vec4(2.098,.260,.361,-.897),vec4(2.424,.139,1.131,.762),vec4(1.160,1.283,.667,-1.643),vec4(1.056,-1.659,-1.718,-3.380),vec4(-.967,-1.423,.295,-.875),vec4(.553,-1.009,-.303,.235),vec4(.770,1.037,-1.846,-.393),vec4(.728,1.670,-1.930,-.153),vec4(.473,-3.305,1.198,-.246),vec4(.242,-1.472,1.458,-1.107),vec4(-.352,.216,-.654,.471),vec4(.603,.858,-.441,3.235),vec4(.824,-1.013,-.149,.563),vec4(1.220,2.260,-.916,.413),vec4(-.151,-.301,.276,.447),vec4(-.445,1.285,2.010,-1.273),vec4(.477,1.233,-1.268,2.045),vec4(1.513,.737,-.131,.030),vec4(1.685,-1.265,-.564,.973),vec4(-1.340,-.168,-.108,-1.174),vec4(-2.356,-1.480,1.294,-.044),vec4(-1.094,.055,-1.423,.702),vec4(.776,-.498,-1.524,-.260),vec4(-.316,.183,.482,-.413),vec4(-1.241,1.375,1.380,2.204),vec4(-.176,.604,-.547,1.673),vec4(-.762,.828,.228,.562),vec4(2.381,-.372,.885,-.174),vec4(.679,.662,.523,-.809),vec4(-1.929,4.501,-.985,.725),vec4(-3.267,2.848,-1.803,.537),vec4(.137,.484,.951,.706),vec4(-.433,.047,.393,-1.392),vec4(.092,.342,-.111,-1.905),vec4(1.225,-.820,.568,-.512),vec4(.696,-.697,2.204,-.068),vec4(.625,-.112,.981,-.265),vec4(.245,-.826,-.289,-.430),vec4(-.879,.332,-.361,.621),vec4(1.258,-.764,.725,-.474),vec4(-1.053,-.667,1.292,-.332),vec4(-.044,.678,.743,1.239),vec4(.452,-1.059,1.401,-.489),vec4(1.526,.186,-1.146,.468),vec4(-3.123,.002,2.015,.216),vec4(1.075,.259,.778,.057),vec4(-.359,1.331,.746,-1.167),vec4(1.106,1.093,1.001,-.610),vec4(-.258,.075,.832,1.572),vec4(-1.255,.406,.559,-.327),vec4(-1.349,.659,-1.155,.505),vec4(-1.031,-.533,-.929,-4.141),vec4(-1.627,-3.337,-.872,.494),vec4(-1.501,1.079,-1.415,1.638),vec4(-.178,-.165,-2.841,-.074),vec4(1.763,.276,-.599,-2.219),vec4(-1.629,-1.545,-2.377,-1.330),vec4(-1.732,1.252,1.513,2.316),vec4(-.517,-1.634,.423,.275),vec4(-.565,.237,-.231,-.381),vec4(.154,-.489,.775,.054),vec4(.355,.595,3.847,-.858),vec4(-1.024,2.416,-.419,1.075),vec4(-1.745,.410,1.458,.359),vec4(-1.547,1.924,-.295,-2.558),vec4(-1.078,1.667,-.660,1.561),vec4(-.744,-.528,1.367,-.289),vec4(.966,.005,.312,-.632),vec4(-1.601,-.646,-.058,-.005),vec4(-.342,-.502,-.107,-1.715),vec4(-1.032,-.486,-.360,1.005),vec4(-.426,.499,1.114,3.091),vec4(-1.651,-1.391,-.791,2.315),vec4(-.129,.229,-.312,-1.898),vec4(.100,.681,-.381,.874),vec4(6.456,1.319,1.431,1.111),vec4(.504,.718,-.658,-.459),vec4(.595,1.393,1.488,-.788),vec4(.509,2.118,1.224,-1.688),vec4(.249,.149,-2.254,-.878),vec4(1.502,.290,-.379,1.987),vec4(-1.609,1.175,-1.940,-1.630),vec4(-.035,1.773,1.086,-.867),vec4(-2.016,-.677,-1.558,-.549),vec4(-2.337,.308,.976,-1.065),vec4(.726,1.901,.187,-.676),vec4(.512,-1.774,-2.214,2.340),vec4(.265,-.427,-3.775,.874),vec4(-.963,-1.803,-2.440,-.194),vec4(-.370,-.473,.257,-.365),vec4(2.767,2.018,-.758,-.409),vec4(-5.121,-1.903,-1.880,2.428),vec4(-3.793,-.824,-5.354,-.096),vec4(-1.401,-.736,.300,1.322),vec4(.054,3.446,3.285,.251),vec4(.596,1.124,.133,.534),vec4(.427,.326,-.394,.312),vec4(-2.157,2.918,-.191,1.421),vec4(.499,.011,1.401,.949),vec4(1.756,-2.082,.974,-.018),vec4(-.287,-.496,.497,-.582),vec4(.688,-.214,-.122,1.115),vec4(-1.916,-2.145,.145,2.785),vec4(-1.608,-1.156,-1.303,3.092),vec4(-1.239,-.387,-.521,-1.647),vec4(-.388,.903,-1.187,-.958),vec4(-.154,.996,.819,-.236),vec4(.543,-.371,-.246,-1.241),vec4(-1.067,.083,1.011,-1.877),vec4(.404,-1.273,-1.333,-.858),vec4(-.577,.533,-.299,-1.191),vec4(-.384,.114,-1.094,1.222),vec4(.334,-1.301,.376,-1.155),vec4(.881,.095,-.884,-.523),vec4(.627,.505,-.299,.170),vec4(1.691,-.873,-1.861,-.236),vec4(1.071,-1.449,.267,-.583),vec4(-.069,-.324,-.502,-.537),vec4(-.048,.604,.280,-.299),vec4(-.599,.242,-.108,1.228),vec4(-.915,.436,.682,1.473),vec4(1.637,-1.545,.317,.459),vec4(-.570,-.453,.204,.608),vec4(-.582,-.769,-1.152,.488),vec4(2.175,-1.311,-.707,-1.438),vec4(-.943,1.705,-1.230,-.765),vec4(1.854,-.074,.348,.402),vec4(.840,1.682,.038,-.463),vec4(2.260,.877,-1.426,-.522),vec4(.297,.295,1.116,-.031),vec4(.119,.181,-.906,.136),vec4(.287,1.153,1.305,.520),vec4(1.281,.161,1.321,.594),vec4(-.785,2.243,.105,1.478),vec4(.637,-.565,-.456,.192),vec4(-.684,.586,-1.092,-.289),vec4(.674,-.169,.328,.673),vec4(.370,.495,.102,-.915),vec4(-.458,1.019,-.819,.459));\nconst vec4 embed2[1024] = vec4[](vec4(-.361,1.090,.672,.748),vec4(-1.175,.104,.174,.694),vec4(-1.313,.407,.305,.289),vec4(-.523,1.378,.244,1.082),vec4(.263,1.478,.403,.287),vec4(-.340,1.172,1.100,.168),vec4(-.210,.956,1.040,1.199),vec4(-2.058,-.556,-.960,.829),vec4(-1.205,2.275,-.700,1.957),vec4(-3.505,-2.439,-.316,1.270),vec4(1.753,-1.559,1.350,-1.113),vec4(.199,-1.898,.333,-.462),vec4(-1.486,-2.956,2.685,.789),vec4(1.722,-.562,1.887,-.559),vec4(1.673,1.309,.857,1.283),vec4(-1.338,.460,1.189,.828),vec4(4.425,5.422,-1.864,-3.451),vec4(.542,.376,5.588,2.838),vec4(-1.716,1.170,.960,-.307),vec4(-5.921,-1.303,-1.748,-2.517),vec4(.712,.560,.120,-1.614),vec4(-1.507,-.405,-.654,-1.210),vec4(1.830,1.794,-.668,.332),vec4(-.430,.357,.366,-1.881),vec4(.773,-.575,.402,.179),vec4(-.299,1.235,.349,-.390),vec4(-.618,1.068,.567,-.322),vec4(-.922,.923,.988,-.603),vec4(-.846,-.861,.260,-.320),vec4(-.655,-1.259,.607,-.286),vec4(-1.081,-1.456,1.083,-1.019),vec4(-.078,-1.223,1.321,-1.623),vec4(-.227,.874,.134,-.327),vec4(-.422,.584,.469,.450),vec4(-1.602,.652,.194,.536),vec4(-.706,1.502,.354,.684),vec4(-.108,1.669,.317,.514),vec4(-.370,1.681,.736,.186),vec4(-.183,1.285,.623,.721),vec4(-.383,.113,-1.180,.884),vec4(-1.305,-1.396,-1.896,-.066),vec4(-.551,-.272,.958,-.595),vec4(1.059,-3.225,.284,1.369),vec4(-1.422,-.861,.390,-1.361),vec4(-1.589,1.760,.566,-2.549),vec4(-.876,.699,3.228,-.755),vec4(3.097,2.571,-3.545,-6.167),vec4(4.725,4.312,-3.865,-5.939),vec4(1.842,5.274,-1.369,-8.102),vec4(2.120,6.730,-6.396,-8.654),vec4(-.328,1.356,-2.464,.092),vec4(-1.372,2.647,-3.246,2.671),vec4(-1.997,.402,-.526,-.030),vec4(.560,1.097,.926,-1.846),vec4(.148,1.297,.527,-1.316),vec4(-.082,.230,.726,-1.476),vec4(.194,-.462,.458,-.406),vec4(-.187,.737,.911,-.483),vec4(-.900,.990,.462,-.578),vec4(-.900,.841,.469,-.639),vec4(-.554,-.790,.387,-.504),vec4(-.006,-.957,.486,-.430),vec4(.024,-1.124,.664,-.316),vec4(-.360,-1.066,.954,-.542),vec4(-.005,.123,.137,.585),vec4(-.101,.049,.288,.621),vec4(-.882,.799,.234,.750),vec4(-.337,1.005,.222,.413),vec4(-.615,1.184,.448,.637),vec4(.045,.822,-.541,.232),vec4(-.302,.757,-.774,.288),vec4(-1.241,-.154,-.630,-1.114),vec4(-3.067,-2.199,.069,3.338),vec4(1.466,2.733,-.902,-1.451),vec4(-.343,1.395,-.457,-.573),vec4(-.735,-.956,1.455,-.278),vec4(.522,-1.448,.261,.385),vec4(-.610,-.317,-.939,-1.790),vec4(-.957,-1.258,2.354,.264),vec4(-.628,-1.234,3.275,.123),vec4(1.198,-.944,1.213,1.316),vec4(.972,-.362,1.013,.484),vec4(-.976,-.637,1.599,.410),vec4(-.635,-.359,-.216,-.217),vec4(1.115,1.619,.275,.955),vec4(.684,2.901,-.610,-3.015),vec4(.458,.577,-.138,-1.987),vec4(-.360,-.007,.744,-.848),vec4(.260,-.467,.373,-.590),vec4(.475,-.886,.677,-.683),vec4(-1.248,-.651,-.076,-1.169),vec4(.132,-.652,.202,-.960),vec4(-.187,-.370,.280,-.956),vec4(-.043,-.799,.042,-.385),vec4(.054,-.770,-.235,.105),vec4(-.283,-.956,-.500,.391),vec4(.318,.253,.295,-.047),vec4(.516,-.354,-.270,-.236),vec4(-.456,.654,.412,.750),vec4(-1.147,.784,-.371,-.595),vec4(-2.102,.424,-.814,-.884),vec4(-.251,-.055,-1.146,.495),vec4(.714,-1.153,-1.348,1.893),vec4(2.558,.695,-2.086,-.770),vec4(-.922,-1.118,3.411,1.599),vec4(.445,1.141,.209,-.811),vec4(-1.317,1.845,-1.129,-1.275),vec4(-.270,1.931,.482,-1.024),vec4(-1.490,-1.014,1.284,1.873),vec4(-.262,1.243,-.550,-.853),vec4(.092,1.659,-1.052,-1.434),vec4(-.989,-.091,.182,.530),vec4(.179,-1.520,.924,-.316),vec4(.208,1.502,1.607,-.901),vec4(-.818,-1.876,.077,-1.121),vec4(.617,-3.233,-1.175,.704),vec4(.486,-1.933,-.334,.438),vec4(-1.583,-.410,2.215,1.332),vec4(-3.369,-3.590,1.858,5.336),vec4(-.390,-.280,-.177,.288),vec4(-.423,.119,-.587,-.546),vec4(1.028,-.455,-.274,-.437),vec4(-.261,.720,.166,-.403),vec4(.317,.082,.090,-1.104),vec4(.562,-.352,-.405,-1.566),vec4(-.875,-.339,-.704,-.072),vec4(-.794,.077,-.235,-.808),vec4(-.565,.736,-.273,-1.282),vec4(.506,-.430,-1.219,-1.291),vec4(-.153,-.537,-1.367,-.891),vec4(-.663,-.273,-1.106,-1.200),vec4(.346,.037,-.347,-1.076),vec4(2.808,-.373,.867,-.236),vec4(.363,-.417,-.182,-.216),vec4(2.050,2.043,-3.977,1.255),vec4(.036,-.291,.041,.803),vec4(-.066,-1.463,-.380,-.971),vec4(-.232,.678,1.918,-1.606),vec4(.007,-1.099,-1.223,-1.727),vec4(-2.366,2.227,.002,-.600),vec4(-2.375,1.658,1.041,-1.357),vec4(-2.644,1.287,1.043,1.003),vec4(-1.440,-.047,1.295,.297),vec4(-.934,-2.157,1.073,.248),vec4(.566,-1.799,1.038,.784),vec4(.210,-1.925,.009,1.027),vec4(.117,-.147,1.245,.977),vec4(1.717,.847,.551,.933),vec4(1.106,1.045,.392,-.069),vec4(.912,1.703,-.193,.369),vec4(.959,.944,-.095,-1.441),vec4(-1.430,-.754,1.662,1.047),vec4(.423,-.392,.845,.617),vec4(-.033,1.903,-.044,1.111),vec4(.642,1.011,-1.195,1.628),vec4(-1.169,.408,-.290,-1.078),vec4(.184,-1.314,-.145,-.269),vec4(-.425,-.327,-.295,-.229),vec4(-1.101,.352,.060,-.386),vec4(-1.263,.604,.002,-.689),vec4(1.188,.348,-.572,-.927),vec4(1.285,.213,-.627,-.299),vec4(.434,-.267,-.452,-.372),vec4(.300,.058,-.408,-.830),vec4(-1.219,-1.003,3.723,1.004),vec4(.485,-.367,.432,-1.247),vec4(.609,1.043,1.536,-1.253),vec4(-1.770,1.881,1.544,-.220),vec4(-.125,-1.467,.216,-1.235),vec4(1.991,-1.761,-.088,-1.183),vec4(-1.944,-1.254,.540,-.935),vec4(-.626,-1.266,-.584,1.120),vec4(-1.110,1.841,.460,.125),vec4(-.870,.266,1.359,-.294),vec4(-.517,-1.032,-.280,.199),vec4(1.504,.484,.143,.214),vec4(.128,.235,.275,.053),vec4(.475,.195,.795,-.596),vec4(.386,.042,.377,1.341),vec4(-.497,-.990,.197,-.908),vec4(.528,-.250,-.908,.184),vec4(-.467,.535,-2.323,-1.274),vec4(-.767,.786,.644,1.491),vec4(.590,.584,.912,3.335),vec4(1.549,-2.267,1.258,1.780),vec4(.304,-1.537,2.011,-1.838),vec4(.314,-1.034,-.176,-.411),vec4(-1.636,-1.309,.357,1.497),vec4(-.026,-1.623,-1.368,-.007),vec4(-.348,.601,-.902,-.640),vec4(-.364,.310,.546,-.467),vec4(-1.097,-.871,.480,-.500),vec4(.463,-.192,-.388,.105),vec4(.124,.145,-.647,.030),vec4(-.173,-.290,-.300,-.047),vec4(-.243,1.990,-.296,.426),vec4(5.905,4.953,-4.126,-2.994),vec4(.723,.138,.814,-.139),vec4(1.397,-.596,2.337,-.054),vec4(2.661,.424,1.102,-.040),vec4(-1.357,-1.666,2.874,.100),vec4(.308,.654,-1.208,-.018),vec4(1.698,-3.210,.820,-1.301),vec4(-1.136,.686,-2.272,.953),vec4(-1.011,3.130,.749,-.001),vec4(-.210,-.795,1.357,-1.108),vec4(-.194,-1.727,2.114,.992),vec4(.320,-.426,-1.221,-.316),vec4(-.764,-1.101,2.967,-4.060),vec4(1.060,.811,-1.116,2.001),vec4(-.759,1.978,-.732,-.511),vec4(-1.847,-.063,.617,.276),vec4(1.018,-.257,-2.163,.084),vec4(-.473,-3.333,-.761,.963),vec4(-.438,1.443,-.274,-2.858),vec4(1.851,-1.706,1.562,2.019),vec4(.481,-.550,.971,1.556),vec4(.891,.374,-.700,1.543),vec4(-.988,-1.451,1.278,.376),vec4(.452,-.814,.022,-.020),vec4(.439,1.415,-.871,1.008),vec4(-2.067,-.317,-.546,.522),vec4(-.926,-.900,.110,.315),vec4(.099,-.202,-.208,.115),vec4(.478,-.442,-.153,.344),vec4(-.385,-.385,-.349,-.044),vec4(.067,.761,-.190,.357),vec4(.899,.623,-1.435,.196),vec4(-1.743,.391,1.327,2.853),vec4(1.418,-1.738,.251,-1.255),vec4(.888,-1.663,1.060,-.127),vec4(-1.926,1.469,3.013,-.086),vec4(.224,-2.124,2.369,2.607),vec4(-.456,1.960,-1.265,-1.251),vec4(.821,-1.785,-.802,-.882),vec4(1.139,-.225,-.166,.003),vec4(.590,-.414,.646,1.567),vec4(-2.624,-1.407,.600,2.386),vec4(.505,-.879,-.573,-1.395),vec4(-.834,-1.247,-1.355,-.548),vec4(.263,.398,.374,1.896),vec4(-.474,1.377,-.035,.232),vec4(-.964,1.878,-2.522,1.254),vec4(3.299,2.261,1.511,-1.768),vec4(.679,.330,-.596,.413),vec4(.341,-1.117,-1.497,.011),vec4(-.957,-.121,2.137,-2.796),vec4(1.684,-.822,-.621,-.604),vec4(1.004,-.492,-1.957,-.627),vec4(.285,-.068,-.376,-.626),vec4(.337,-.037,-.241,-.899),vec4(.225,1.220,1.305,.945),vec4(-.575,-.574,.180,.749),vec4(-2.206,-2.274,.074,-1.813),vec4(-1.700,-1.912,.409,1.638),vec4(-.640,-.760,-.326,.199),vec4(-.605,-.401,.223,.186),vec4(-.249,-.249,-.013,-.043),vec4(-.165,.230,-.300,.265),vec4(-.059,.152,.634,1.622),vec4(1.376,1.605,.190,.416),vec4(1.087,-.711,-1.509,-2.976),vec4(-.892,-.183,1.013,.483),vec4(-.455,.416,1.479,-.141),vec4(.141,-.654,.854,.188),vec4(-1.302,-1.423,-1.183,-1.777),vec4(3.850,1.863,1.359,.208),vec4(.653,.282,.394,.736),vec4(.220,-.049,.127,1.811),vec4(-2.094,-2.744,.882,-.015),vec4(.694,-.371,-1.680,-1.221),vec4(2.108,.239,.670,1.504),vec4(-1.624,1.926,.208,.903),vec4(2.372,.140,-.627,-.564),vec4(.116,-.433,-1.981,.810),vec4(.022,-.934,-1.113,-.787),vec4(1.056,-1.550,1.099,1.464),vec4(.520,.016,-2.722,-1.180),vec4(-.795,.702,1.501,-.935),vec4(-.584,.426,-.103,1.171),vec4(-1.346,-.477,-1.003,-.956),vec4(1.638,-1.221,-.527,-.347),vec4(.311,1.406,.819,.963),vec4(-.327,2.686,-.940,-.414),vec4(-.195,.041,-.807,.562),vec4(-1.760,-1.482,-1.212,3.429),vec4(.401,-.963,-1.996,.240),vec4(5.240,3.923,-1.291,-.649),vec4(-.865,.733,-.073,-.157),vec4(-.971,.564,.412,-.294),vec4(-.890,.809,-.826,.048),vec4(.321,.357,-1.613,.836),vec4(.194,-.199,.151,-.413),vec4(-.036,-1.103,-.327,-.452),vec4(1.983,1.110,.724,2.523),vec4(.043,.205,.193,-.078),vec4(-.240,.198,.624,.513),vec4(1.373,-.693,.496,1.382),vec4(1.408,-.017,-.334,-1.360),vec4(-.899,.176,-.983,-1.451),vec4(.315,-1.460,-.023,.027),vec4(.697,-.010,.650,-.721),vec4(-.616,-.439,-.364,.062),vec4(-.552,-2.172,.829,.370),vec4(-.239,.983,-.312,-.045),vec4(1.104,-1.504,-.734,.464),vec4(1.189,-1.314,-2.081,-.007),vec4(.600,-1.434,-2.608,-.488),vec4(.130,-2.041,-.140,.792),vec4(.602,-.168,.044,-.475),vec4(.434,-.123,1.245,1.049),vec4(.685,.771,.338,1.681),vec4(-1.137,.330,.628,-.484),vec4(1.474,-.183,-1.108,-.503),vec4(-.424,1.875,1.264,-2.329),vec4(-.020,3.118,-1.448,-.539),vec4(-3.823,-1.707,1.303,3.227),vec4(-3.054,-1.262,-3.549,1.868),vec4(1.326,-.326,-4.348,-.996),vec4(4.834,7.697,-7.073,6.389),vec4(-.943,.468,1.158,-.819),vec4(-.851,1.328,-.612,.282),vec4(-.579,.381,-1.663,.511),vec4(-.021,1.074,-1.821,1.389),vec4(2.619,-.303,.077,-1.467),vec4(-1.955,-.571,.883,2.017),vec4(2.216,-.907,-.422,.641),vec4(1.891,-.939,-.748,-1.077),vec4(.501,-1.721,-.878,-.185),vec4(.864,.132,-2.031,-1.511),vec4(-2.339,-.567,-.587,.418),vec4(-2.325,-.398,.984,-.655),vec4(.400,-.978,-1.417,-1.741),vec4(.412,-.290,-1.496,.895),vec4(-.733,-.888,1.823,.157),vec4(-.545,-.048,-1.353,-.538),vec4(-1.137,.593,.247,-.208),vec4(-.840,-1.053,.240,.315),vec4(.112,-1.009,-.574,1.839),vec4(.354,.329,-1.113,-.264),vec4(.115,-1.626,.120,.050),vec4(-.830,-.138,-1.773,-.682),vec4(.758,-.211,3.113,-1.236),vec4(-.242,.166,3.151,-.246),vec4(1.403,-1.213,.991,.723),vec4(1.158,-1.602,-2.837,.456),vec4(-1.312,2.615,-2.422,.914),vec4(1.265,1.379,-.001,2.003),vec4(-.893,1.263,-5.742,-2.869),vec4(-.558,.246,3.908,-2.946),vec4(.591,1.894,.319,1.293),vec4(-9.139,-3.778,-6.059,7.673),vec4(-.339,1.411,-.046,-.443),vec4(-.439,.842,-.839,-.724),vec4(-.077,.169,-1.841,.070),vec4(-.082,.426,-.841,.262),vec4(.884,-.421,-.364,-4.034),vec4(-1.317,.538,.206,2.570),vec4(1.385,-1.819,-.920,1.011),vec4(-.007,-2.430,-.723,-.686),vec4(-1.036,-.051,-1.258,.131),vec4(-1.566,1.259,-2.437,-3.958),vec4(-.023,-.679,1.929,.245),vec4(-.565,-.669,.507,1.430),vec4(1.264,-.110,-1.565,-1.373),vec4(-.839,-.236,.321,2.507),vec4(-2.030,-.337,-1.271,.965),vec4(-.991,-.147,-.358,1.724),vec4(-.560,-.347,-.289,-.443),vec4(-1.893,-2.090,.639,1.545),vec4(-1.173,-.932,.490,-.254),vec4(.375,-1.875,.049,-.010),vec4(-.551,.148,-.573,-.392),vec4(-1.402,.385,-2.445,-.529),vec4(-1.282,.574,1.947,-.132),vec4(.589,-.491,2.621,-1.258),vec4(.997,-1.203,-.687,3.682),vec4(.604,-.903,-1.869,1.647),vec4(1.681,-1.491,-.695,1.708),vec4(3.527,-.652,-.398,.597),vec4(-.498,.856,-1.313,-1.571),vec4(.486,1.896,1.057,.052),vec4(-3.217,-2.521,.103,-4.815),vec4(-3.815,2.846,-3.184,5.149),vec4(.738,-.178,-.350,-.072),vec4(1.042,.000,-.549,-.120),vec4(.139,.521,-.962,-.581),vec4(-.319,-.326,-.397,.664),vec4(-1.296,-2.261,-.240,-4.241),vec4(1.176,1.514,.004,3.680),vec4(.267,-.981,-.151,1.783),vec4(1.634,.714,.853,1.194),vec4(2.508,-.666,-1.489,-1.184),vec4(.286,-3.639,.929,.929),vec4(-.002,1.216,1.329,-2.599),vec4(-.255,-.889,.699,1.754),vec4(1.249,.325,-1.114,-.944),vec4(1.893,.035,.252,.945),vec4(.410,.420,-2.607,-1.378),vec4(1.781,1.246,-.732,-.382),vec4(-.034,.468,2.302,-.476),vec4(.099,-.354,1.131,-.014),vec4(-1.267,-1.208,.466,.308),vec4(.129,-.793,-.923,.312),vec4(.178,-.422,-.477,-1.687),vec4(-1.371,1.687,-.098,-.354),vec4(1.160,.158,1.136,.029),vec4(-.343,-.798,1.052,-1.985),vec4(1.109,-.417,1.316,4.936),vec4(-.091,-.627,-1.867,1.493),vec4(1.715,-.976,-.701,.317),vec4(.090,-.643,-1.195,-.423),vec4(-1.811,-.677,-.186,2.495),vec4(1.304,.970,.246,-2.159),vec4(-2.505,-1.826,1.156,-1.322),vec4(.800,1.254,.034,-.260),vec4(-.419,.059,.042,-.397),vec4(.589,.347,-.433,-.694),vec4(.281,.187,-1.066,-1.531),vec4(-.799,-1.137,-1.444,.902),vec4(-1.670,-2.933,-2.934,2.229),vec4(.022,1.035,.153,.389),vec4(1.096,-.446,.833,.571),vec4(-1.975,1.692,.984,1.131),vec4(2.468,-1.934,-.538,.632),vec4(-.135,.644,-2.389,-1.751),vec4(-.220,-.575,.506,.820),vec4(-.907,-1.306,-.374,1.293),vec4(-1.753,1.296,-1.025,-.908),vec4(1.025,-.538,.276,-1.705),vec4(.802,-.190,1.897,-.752),vec4(.191,1.305,.060,-3.276),vec4(.634,.524,.684,-2.599),vec4(-1.199,1.072,.842,-.297),vec4(.664,.021,.854,-.443),vec4(-1.032,-.480,-.721,-.684),vec4(-.867,.672,-2.849,.854),vec4(-.463,1.644,-.117,.699),vec4(.066,.136,.478,-1.292),vec4(1.584,-.507,2.658,-1.412),vec4(1.710,-.557,-.884,-.079),vec4(.918,-2.259,.097,.717),vec4(-.596,-1.631,.042,-.487),vec4(.923,-1.241,-.392,-.068),vec4(-1.070,.286,-1.537,1.865),vec4(-.153,-.667,-2.736,.335),vec4(-4.323,-4.177,-.499,-.061),vec4(1.176,.573,-1.436,2.423),vec4(1.732,.248,-1.557,-.539),vec4(1.114,.105,-1.093,-.579),vec4(-.219,-.176,-1.241,-.542),vec4(-1.719,.731,.100,.083),vec4(-.466,.560,.757,.387),vec4(-.415,2.032,1.708,-1.616),vec4(-.031,.356,.413,.837),vec4(-2.335,.489,.105,1.063),vec4(2.208,.596,-2.076,1.490),vec4(.683,.428,-2.382,-1.198),vec4(.736,-.152,-1.895,-.198),vec4(-2.301,-.403,-1.600,.149),vec4(-1.389,-.321,1.231,1.720),vec4(2.269,-1.398,.861,-1.255),vec4(-1.439,.495,-.732,-2.535),vec4(2.426,-1.021,1.665,.014),vec4(4.275,.728,.311,-2.402),vec4(.113,.065,.191,-.684),vec4(-1.402,-.162,1.538,-2.212),vec4(-.191,.839,1.958,-.530),vec4(.089,-.207,2.327,.415),vec4(-.894,-.319,-2.271,.238),vec4(.233,-.831,.937,.638),vec4(1.604,-1.053,1.870,-.846),vec4(-.557,-1.244,2.672,-.886),vec4(.861,-1.088,.785,-.437),vec4(-.864,-.392,2.588,-1.754),vec4(1.938,.680,2.440,1.123),vec4(-1.316,-1.161,-3.001,-2.762),vec4(2.120,2.029,-3.192,2.869),vec4(.662,-1.982,-1.894,1.218),vec4(-4.607,-.955,-.408,-1.208),vec4(-.998,.046,-.157,-.996),vec4(-1.075,-.083,.441,-1.350),vec4(.189,.278,.209,-.221),vec4(-1.449,-1.586,2.215,1.513),vec4(.993,.676,-.522,-1.194),vec4(-1.230,1.755,1.832,-.354),vec4(-.984,.325,-3.301,-2.887),vec4(-1.595,-.998,-.325,1.378),vec4(.859,1.181,.180,1.433),vec4(.422,-.377,.457,1.139),vec4(-.298,-1.541,-.452,-.752),vec4(-.723,-.283,-1.716,.227),vec4(-.626,.969,-1.796,.449),vec4(-1.138,.448,-1.115,-2.061),vec4(-.885,.729,-1.383,-1.102),vec4(1.147,.266,-.201,-.693),vec4(1.977,.017,-.179,-1.507),vec4(1.391,.339,-3.774,-3.681),vec4(1.731,-.039,1.887,-1.270),vec4(.567,-.073,3.163,1.058),vec4(.029,.720,-1.046,-.204),vec4(.040,-.449,.303,-.697),vec4(1.533,.948,.777,.552),vec4(-.877,-.458,2.625,.494),vec4(2.093,-.821,2.779,-3.042),vec4(.222,-1.406,1.674,-1.683),vec4(-.412,.382,2.035,-.473),vec4(.172,-1.114,.862,-.265),vec4(-4.170,-.890,4.645,1.599),vec4(-1.971,-.273,.441,.514),vec4(-.315,.125,-.389,1.107),vec4(1.675,-.305,-1.697,-.462),vec4(-2.749,-2.126,2.836,-3.607),vec4(-1.910,2.015,1.348,-1.693),vec4(-2.720,1.643,-1.559,-1.061),vec4(.639,.441,.275,-.372),vec4(1.261,.137,-.919,-.593),vec4(-1.358,.530,1.625,-.498),vec4(.557,-.074,-.366,-1.030),vec4(1.189,-1.610,-.989,-.397),vec4(-.956,-.292,.035,.387),vec4(-.977,-.569,2.102,1.095),vec4(1.190,.473,-2.716,-.123),vec4(.963,-1.076,-2.977,-.313),vec4(-1.407,-1.089,1.090,-.319),vec4(-2.152,-.195,.597,-1.475),vec4(-1.531,-.169,-.712,-1.841),vec4(1.075,.904,.043,-.480),vec4(-1.672,-.368,-1.366,1.298),vec4(.367,.759,.299,.048),vec4(1.789,.649,.380,-.352),vec4(-.335,1.679,-.215,.007),vec4(-1.277,-.503,-1.303,.311),vec4(.850,-.052,.123,-1.051),vec4(.600,.278,.772,-.065),vec4(-.575,.551,1.126,-1.056),vec4(-.743,-.758,.831,-1.989),vec4(.710,-1.174,1.384,-2.090),vec4(1.154,.258,.569,1.157),vec4(-.667,-1.189,-.170,.198),vec4(.681,.124,.290,-1.008),vec4(-.711,1.636,-.316,-2.493),vec4(-.478,1.555,-1.033,.280),vec4(-.088,.949,.574,-1.244),vec4(1.270,3.043,2.488,-2.607),vec4(-2.987,-2.465,2.326,2.124),vec4(-1.372,-.311,.671,-.751),vec4(3.178,-1.529,1.018,.073),vec4(.163,-.597,-.935,1.605),vec4(-.550,1.897,-.960,-1.084),vec4(-.255,-.686,1.669,1.520),vec4(-.491,-1.489,1.124,1.251),vec4(-.763,-.762,-.046,.290),vec4(-1.768,-3.360,.328,-.487),vec4(.011,.725,.192,1.407),vec4(-.367,-.214,1.110,2.049),vec4(-1.026,.824,-.174,-1.066),vec4(-.928,.155,-1.265,-.515),vec4(.032,-.102,2.197,-.132),vec4(-1.702,.370,1.250,-1.170),vec4(1.570,1.392,-1.531,2.310),vec4(.914,1.271,-.840,-.290),vec4(-.568,.196,.999,-1.286),vec4(-1.084,.169,.603,-1.206),vec4(.511,.664,1.186,-.814),vec4(2.049,-.231,.296,1.720),vec4(-1.345,.009,.757,-.571),vec4(-.488,1.157,1.510,-.709),vec4(-.872,-.547,.202,.637),vec4(1.248,-.651,1.116,.365),vec4(.249,1.683,.009,-.301),vec4(-.932,.125,1.437,-.087),vec4(1.915,.027,-1.018,1.477),vec4(1.348,1.863,-2.703,-2.156),vec4(-2.208,.738,-2.452,-1.904),vec4(5.845,4.495,-1.467,2.792),vec4(4.186,-.350,3.583,1.204),vec4(.463,-1.796,-1.143,-.894),vec4(-.511,.140,-1.171,-1.168),vec4(.011,-.829,.409,.183),vec4(-1.004,-.064,.666,.646),vec4(-.738,2.250,.470,2.365),vec4(.320,-1.017,-.425,.120),vec4(.038,-.160,-.374,1.607),vec4(3.057,-1.243,-1.961,.439),vec4(-4.089,-.059,-1.887,-1.640),vec4(.358,-1.437,1.799,.829),vec4(-.298,-2.880,.167,-1.068),vec4(.095,-1.030,1.348,-.655),vec4(1.556,.421,.459,-1.725),vec4(-.809,.914,-1.680,-.012),vec4(-2.296,2.026,.087,-.462),vec4(-1.264,-1.215,-1.653,-.473),vec4(1.397,1.867,1.643,-.883),vec4(-.700,2.197,-.728,1.073),vec4(.167,-.499,1.607,1.768),vec4(-.532,1.931,-3.017,-.301),vec4(-1.724,-.841,-.303,.791),vec4(1.223,1.337,2.192,-.305),vec4(.098,-1.222,-1.118,1.324),vec4(-.704,-1.749,.227,2.465),vec4(-.552,.256,.485,-1.646),vec4(.061,1.802,1.486,.539),vec4(-.635,1.162,-.241,1.896),vec4(1.603,-.623,-.050,1.001),vec4(1.305,.640,-.946,-.211),vec4(3.092,1.686,-2.460,-1.128),vec4(1.851,6.047,-2.510,.575),vec4(.602,-1.105,-1.260,2.932),vec4(.999,-.463,.169,-1.720),vec4(1.312,.419,-.656,-.664),vec4(.354,.298,-.981,.306),vec4(.505,-.342,-.292,.066),vec4(-2.130,1.517,-1.099,.035),vec4(-.178,-1.483,.742,.096),vec4(-2.215,-2.801,-.629,1.045),vec4(-.200,-.665,-1.680,.713),vec4(-2.718,2.212,.364,-1.152),vec4(-1.259,.374,1.260,-2.409),vec4(-.272,-1.706,-.605,-.337),vec4(-.676,.001,-.206,-.266),vec4(.415,.399,-.084,-.254),vec4(-1.579,1.611,-1.500,-.341),vec4(-1.826,-.019,-.031,.270),vec4(-1.908,.047,1.210,-2.475),vec4(-.929,.414,-1.607,1.388),vec4(-.061,-3.038,-.529,.104),vec4(2.290,.858,1.599,-1.183),vec4(-1.678,1.415,.386,-.556),vec4(-.078,-.427,.165,.343),vec4(-.271,-.652,-.058,-.397),vec4(-.366,-2.672,-.214,1.851),vec4(-.118,-.404,.007,2.170),vec4(2.324,-1.401,.318,.958),vec4(.734,-.793,-1.121,1.958),vec4(-3.939,-2.570,3.918,1.554),vec4(.984,-.413,-.482,.234),vec4(-1.263,2.621,-2.169,-1.648),vec4(1.698,2.097,-.293,.200),vec4(4.290,.805,-6.824,-5.882),vec4(-.880,-2.086,-2.070,.407),vec4(-.082,.329,-1.053,-.021),vec4(.764,-.737,.278,.406),vec4(-.453,.107,.098,.461),vec4(.390,-.162,-.562,.848),vec4(-.308,.273,1.319,.820),vec4(-.732,-1.946,.024,.817),vec4(-1.655,.894,-1.019,-.176),vec4(-3.345,-2.043,.389,3.573),vec4(-.132,-.422,-1.543,-1.716),vec4(1.313,.991,.410,-1.140),vec4(.435,-.989,-.304,-.166),vec4(1.091,.186,2.162,-1.364),vec4(1.155,-.094,1.006,2.425),vec4(-2.364,-.183,-.067,.054),vec4(-2.189,.904,-.339,-3.033),vec4(-.265,-.522,1.621,.639),vec4(-.314,1.538,-1.121,1.597),vec4(-.815,1.310,-1.067,-.523),vec4(.065,1.231,2.187,-.402),vec4(-.254,.024,-1.157,2.188),vec4(-.939,-.527,.295,.537),vec4(-1.583,.683,-.285,-1.968),vec4(.969,.291,.914,1.614),vec4(1.018,-1.668,-.102,1.909),vec4(.524,-.770,.848,.365),vec4(-.149,-1.438,-.400,1.116),vec4(-2.057,1.563,1.043,2.341),vec4(1.771,.301,-.749,-.121),vec4(.255,-1.902,-.301,.174),vec4(2.645,-.101,.043,.465),vec4(1.656,11.241,-7.591,-3.465),vec4(-1.314,1.521,-.984,.442),vec4(-.207,.307,-1.118,-1.860),vec4(2.264,1.765,-2.108,-2.124),vec4(.658,-1.586,.017,-.108),vec4(-.225,-.047,.732,.264),vec4(1.672,.342,-.423,-.049),vec4(.123,-1.012,.647,1.345),vec4(.387,1.077,.518,.657),vec4(1.896,.567,-2.180,1.574),vec4(.468,1.313,-3.178,1.167),vec4(.465,1.307,.369,-1.182),vec4(-.785,-1.887,1.219,.111),vec4(.406,.206,1.854,-.761),vec4(.261,.090,.186,1.079),vec4(1.783,-1.683,-.038,1.894),vec4(-.138,-2.078,-.873,1.194),vec4(-.558,1.445,2.054,-.322),vec4(-.199,-.028,.739,.884),vec4(-1.173,-.040,-.710,-.905),vec4(.178,1.052,1.354,.685),vec4(-.863,.885,.047,1.044),vec4(-1.095,-.243,.304,1.009),vec4(.083,-.836,.067,.353),vec4(-1.826,.584,-.766,1.585),vec4(2.133,-3.349,-.290,2.421),vec4(.745,-.868,.021,.488),vec4(1.192,-.916,-.451,2.911),vec4(-1.939,-.828,-.301,1.310),vec4(.936,-.434,-.651,-1.380),vec4(-.230,-2.998,-.186,3.839),vec4(-1.574,-.985,-.095,.360),vec4(2.826,7.631,4.128,5.487),vec4(.450,1.127,-.745,-.980),vec4(-1.466,1.020,.449,-1.139),vec4(.876,.421,.565,-2.445),vec4(-.341,1.077,2.152,-.598),vec4(.243,2.023,.504,-2.337),vec4(2.841,.708,.581,1.037),vec4(.125,-1.076,-1.654,-.989),vec4(2.711,.133,-3.067,.834),vec4(.463,-.032,-1.042,-.910),vec4(-1.813,1.336,.527,-1.718),vec4(-.835,.485,-.113,-1.705),vec4(.188,-.193,1.426,-.585),vec4(-.050,-.111,-.223,-1.073),vec4(-.096,.174,-.798,-1.148),vec4(-.249,.277,-.093,.398),vec4(.150,2.119,.184,1.814),vec4(-1.693,.463,-.498,.141),vec4(-.774,.915,.164,-.625),vec4(-1.195,.381,.283,-1.006),vec4(2.513,.517,-.632,-2.330),vec4(-2.965,-1.737,2.685,2.474),vec4(-.066,-1.010,-.929,1.706),vec4(.523,.187,-1.045,-.395),vec4(-1.146,-.352,-.325,1.547),vec4(1.165,-1.070,-.742,.955),vec4(1.092,-1.073,-.702,.780),vec4(2.433,-2.562,-.885,1.995),vec4(-.132,.586,-.168,.311),vec4(2.235,-.011,-1.565,-.295),vec4(-.860,-.759,-.621,1.125),vec4(1.941,2.324,.348,-2.356),vec4(-1.666,1.074,4.491,4.399),vec4(-.474,.879,-.160,-.174),vec4(-.840,.929,.308,-1.215),vec4(-2.716,.098,.933,-2.590),vec4(-1.302,.750,1.258,-1.260),vec4(-.000,3.129,-.956,.225),vec4(-.206,2.825,-.154,.761),vec4(-.666,-1.651,.535,.283),vec4(1.179,.485,-1.272,1.227),vec4(-3.278,-.207,3.228,.206),vec4(-.683,.811,.038,.232),vec4(-.971,1.277,.473,-2.848),vec4(-.359,-.166,-.405,2.047),vec4(.840,2.161,-.034,.233),vec4(-1.492,1.239,-2.977,1.872),vec4(-.914,-1.378,-2.829,1.890),vec4(-1.851,1.577,1.602,1.167),vec4(-1.744,1.317,.263,.278),vec4(2.609,1.551,-2.582,-2.324),vec4(-1.505,-.728,.191,-.069),vec4(1.261,.142,-.386,-2.236),vec4(-.160,.882,-.197,1.978),vec4(1.626,-.099,-1.579,.808),vec4(-1.074,.455,-1.368,.595),vec4(.495,1.721,-.701,-.781),vec4(.331,-1.393,1.692,-1.114),vec4(.492,.261,1.052,.580),vec4(-.143,-.557,.260,.490),vec4(.303,1.426,1.162,-.539),vec4(-.780,1.213,.571,.470),vec4(-2.288,-1.455,1.737,-.167),vec4(-.213,-.637,1.052,-2.084),vec4(-10.041,-4.234,.637,-.171),vec4(-.482,-1.435,-.125,-.087),vec4(-.386,.836,.614,-.806),vec4(-.188,.417,.462,-.341),vec4(-.592,.851,.573,-2.728),vec4(1.201,.465,.792,-1.700),vec4(-.988,1.770,-1.235,2.018),vec4(-.097,1.309,.385,.244),vec4(.557,1.182,-2.305,-1.899),vec4(-1.307,-.033,-4.036,-.550),vec4(-.152,.772,.085,.505),vec4(-1.276,2.168,-.214,1.052),vec4(1.453,-.693,-1.360,2.270),vec4(-1.425,-.117,-2.320,.379),vec4(1.668,2.588,-.786,-.984),vec4(-.801,.571,-2.520,.549),vec4(.927,.750,-1.662,.396),vec4(-.055,2.902,-.669,-.049),vec4(-.199,-.507,-.319,.179),vec4(-.102,.652,-.250,-.462),vec4(.295,-.392,.466,-1.255),vec4(-.630,-.768,-2.076,1.277),vec4(.815,.512,-1.621,-1.076),vec4(.537,-1.769,.491,.270),vec4(2.075,-.111,1.550,-.066),vec4(-.780,-1.556,-1.404,.379),vec4(.473,-.623,1.156,-.763),vec4(-.087,-.724,.868,-.696),vec4(.705,.158,1.737,-.699),vec4(-.250,1.461,.981,-1.079),vec4(-.428,-.197,.158,.698),vec4(.796,-.855,-1.933,-.425),vec4(-2.533,4.717,1.213,-1.598),vec4(-2.646,-1.363,1.684,-2.114),vec4(.232,-1.382,-1.402,.368),vec4(-.891,.764,-.277,-.910),vec4(-.491,-1.150,-1.425,2.051),vec4(.874,-1.651,-.838,.745),vec4(.032,.948,-1.225,-1.693),vec4(.080,1.364,2.779,1.057),vec4(.211,3.026,-1.570,1.032),vec4(-2.194,-2.971,-1.335,-.236),vec4(-1.461,.286,-.312,.849),vec4(-.217,.633,-.677,-1.308),vec4(.751,1.012,-1.723,1.477),vec4(-1.706,-2.146,-.997,1.885),vec4(.363,1.824,-1.339,1.378),vec4(-.042,1.030,-1.888,.988),vec4(-.925,-.081,-.516,.674),vec4(-.348,1.030,-.265,.517),vec4(-.053,.293,1.767,.846),vec4(1.450,-.163,.598,1.216),vec4(.874,3.409,-1.537,-2.501),vec4(.388,-1.357,.156,-.395),vec4(1.539,-.032,-2.081,2.322),vec4(-.093,-1.537,-.803,.745),vec4(.652,-1.519,.526,.142),vec4(-.742,-1.302,1.134,-.134),vec4(.486,.507,-.625,.386),vec4(.429,-1.243,-.001,-.556),vec4(-.875,-.912,1.196,.587),vec4(1.473,.090,1.084,.084),vec4(1.571,2.240,-.168,.607),vec4(-1.534,1.971,.150,-.601),vec4(.574,-.231,-.316,-.325),vec4(10.608,10.784,-12.461,-8.449),vec4(-.427,-1.800,.243,-.575),vec4(-1.379,-.274,-.861,.769),vec4(-.131,-2.499,.527,-.217),vec4(-.296,-2.436,.924,.829),vec4(-.629,.139,-1.028,.002),vec4(.014,-.582,-.098,.717),vec4(.567,-.411,.458,1.348),vec4(1.899,.151,-.438,.982),vec4(-2.224,-.546,.509,1.543),vec4(-1.222,-.660,.800,.495),vec4(1.413,.251,-.929,-.076),vec4(.095,.228,.581,.559),vec4(.964,1.847,-1.322,.362),vec4(.228,-.191,-1.762,.852),vec4(-2.962,.325,.519,-.650),vec4(-1.577,1.522,-.831,-.529),vec4(-2.298,.288,-1.114,.517),vec4(.237,-.091,.441,1.423),vec4(-2.710,.287,.303,.525),vec4(-1.618,.621,-1.801,2.890),vec4(.559,.857,.363,1.135),vec4(1.586,-2.258,-.977,.549),vec4(.513,-2.608,-.538,-.009),vec4(.709,-.446,2.221,2.063),vec4(-.399,-.661,.238,.352),vec4(1.356,.445,-1.624,.706),vec4(.061,1.147,-.339,-.743),vec4(.468,-2.233,1.694,1.732),vec4(.911,-2.011,.041,.109),vec4(-.388,1.721,-1.546,.040),vec4(-2.452,-9.478,-6.826,-.410),vec4(-.664,4.336,-.418,-2.977),vec4(-1.352,-1.286,-.989,1.217),vec4(1.930,2.335,-2.618,-2.442),vec4(-.793,-1.600,-.360,-1.538),vec4(-.853,-.398,1.202,.565),vec4(-1.038,-.066,.310,2.259),vec4(.551,.489,.484,-1.034),vec4(1.243,.588,.264,-.027),vec4(2.254,1.448,-1.328,-.647),vec4(-.945,-1.390,-.758,.744),vec4(-2.570,-1.430,-.396,3.349),vec4(.210,.526,-2.140,.825),vec4(-.749,1.637,-2.157,.046),vec4(1.018,-1.490,-1.315,-.952),vec4(-.026,-.104,-1.315,.898),vec4(-.482,1.525,-.604,.288),vec4(-1.257,-.061,-1.631,-.525),vec4(-2.092,2.420,-1.167,.431),vec4(-.725,3.953,-1.804,-1.972),vec4(1.163,1.697,.451,-.844),vec4(1.906,1.153,.107,3.576),vec4(.048,.300,-.670,1.827),vec4(-.766,-.614,.313,-.335),vec4(.796,-1.565,-.275,.163),vec4(.956,-1.084,-.457,1.458),vec4(.603,.034,.081,2.544),vec4(1.028,-1.317,.477,.404),vec4(.755,-1.893,-.297,-.569),vec4(.716,-1.482,-.205,.061),vec4(1.272,.359,-.223,.504),vec4(-1.872,-.906,1.647,6.420),vec4(-.348,.626,1.501,4.127),vec4(-.635,4.866,.300,-4.680),vec4(-1.001,.035,-.234,.991),vec4(-.095,.075,-.111,1.725),vec4(.989,.295,.958,1.006),vec4(2.232,1.352,1.754,1.375),vec4(-.084,1.203,1.420,-.847),vec4(-1.780,-1.239,-.144,2.214),vec4(-.509,-1.076,-.293,-2.056),vec4(.531,-1.033,.930,.061),vec4(.330,1.145,.715,.636),vec4(-.232,-1.128,-1.367,-.052),vec4(.567,-.703,.697,.826),vec4(-.265,-2.181,.049,.705),vec4(-.013,.473,-2.461,1.302),vec4(1.618,-2.106,.282,-.242),vec4(1.517,-3.042,1.010,2.091),vec4(-.863,-2.279,2.253,-1.064),vec4(.808,-.706,-.784,.461),vec4(.183,-1.472,1.093,-1.101),vec4(-.354,-3.175,-.213,.370),vec4(-.316,1.334,-.042,.199),vec4(.585,.684,-1.003,.978),vec4(-1.929,-.049,-.827,-.422),vec4(.885,1.869,-2.919,-2.127),vec4(-.337,1.093,-.565,-.893),vec4(-.020,.786,-.406,-.049),vec4(.254,.297,.026,2.005),vec4(.851,-.187,.658,.852),vec4(1.463,-.385,.569,.140),vec4(-1.186,-.592,-.131,.311),vec4(-2.216,-.060,-.103,1.472),vec4(-2.890,-11.033,9.225,5.196),vec4(2.533,1.423,-3.534,.241),vec4(.441,.839,.180,2.940),vec4(1.077,-1.983,1.850,-.137),vec4(-.378,2.324,.887,.668),vec4(-.149,.228,.409,.451),vec4(-.777,2.119,-1.876,-1.157),vec4(-.549,-2.800,3.549,1.785),vec4(-.155,-1.437,.240,-.187),vec4(.387,-.254,-.612,-1.123),vec4(-.658,-.500,-1.867,.184),vec4(1.219,-1.436,-.240,-.634),vec4(-.306,-.878,2.510,.766),vec4(.117,-2.989,.416,1.118),vec4(.374,-2.899,-1.060,-1.302),vec4(-.802,-.025,-.985,-1.223),vec4(1.169,-1.937,-1.562,-1.047),vec4(.722,-2.116,1.338,.983),vec4(2.530,-1.183,.201,-1.568),vec4(1.612,-.711,-1.013,-.017),vec4(-1.614,.804,1.869,.693),vec4(.476,-1.793,.323,-.554),vec4(.879,1.011,-.199,1.373),vec4(-.092,-.057,.311,.465),vec4(.714,1.270,-.170,.008),vec4(-1.280,1.174,-2.463,.012),vec4(-1.436,.262,.952,-.186),vec4(.911,1.421,1.829,.421),vec4(.634,.167,.322,.192),vec4(-.298,1.141,.244,-1.202),vec4(.692,.593,.006,.887),vec4(1.009,.365,.454,1.559),vec4(-.189,-.836,-2.492,-.922),vec4(-6.281,-1.992,2.361,10.488),vec4(.731,-.388,.321,.072),vec4(1.077,-1.423,.446,-.001),vec4(-.752,1.434,-2.819,-2.463),vec4(.686,-.348,-.367,2.080),vec4(.171,1.375,-1.330,-.270),vec4(-.730,-.042,1.732,-.212),vec4(.010,-1.197,-1.435,.250),vec4(-.010,-.185,1.208,.422),vec4(-.312,-.382,.662,.868),vec4(-.352,.207,.475,-1.549),vec4(-.654,-.920,2.178,-.893),vec4(1.587,-2.071,.524,.282),vec4(1.103,-1.119,-.155,-1.504),vec4(1.728,-.784,4.172,-1.207),vec4(-1.429,-1.140,-2.401,3.633),vec4(.062,-1.197,-.674,3.998),vec4(1.364,-.865,-3.077,-.458),vec4(.693,-.593,.129,.588),vec4(-3.020,.412,.167,-.982),vec4(1.675,-1.937,-3.238,-2.262),vec4(-.418,-.340,-.866,.102),vec4(2.761,3.305,-2.534,-1.055),vec4(.713,-.077,-.941,.727),vec4(-.018,.985,-.935,.899),vec4(-1.816,.184,2.181,.538),vec4(1.042,1.945,.555,-2.057),vec4(-.012,1.594,.233,-.120),vec4(.333,.754,-.703,.887),vec4(-.090,2.125,-.603,.484),vec4(.804,.927,.623,1.280),vec4(-1.134,-.851,1.914,-2.164),vec4(11.469,-6.254,-2.649,12.001),vec4(1.514,3.441,2.807,-4.875),vec4(2.476,2.687,-.571,-.332),vec4(1.490,.537,-.561,3.885),vec4(2.395,.040,1.384,-1.394),vec4(2.071,-5.063,-2.879,-2.305),vec4(-1.316,-1.330,.041,-.311),vec4(.961,2.440,4.051,-6.111),vec4(1.182,1.904,1.798,2.499),vec4(-1.070,1.893,2.032,-1.756),vec4(-1.854,.748,-2.228,-1.009),vec4(.470,.495,4.662,1.001),vec4(-.167,-5.803,2.265,1.756),vec4(-3.013,-.811,-1.793,-1.203),vec4(-1.513,.496,4.124,-1.670),vec4(2.069,2.707,-.300,1.970),vec4(10.028,.825,-.753,2.366),vec4(3.589,3.281,.613,-3.160),vec4(-4.225,17.226,.653,-1.894),vec4(2.876,1.157,-4.995,1.246),vec4(.407,.177,-1.710,-5.894),vec4(-1.694,-3.571,2.175,3.456),vec4(-.854,-1.159,-1.761,.531),vec4(1.647,2.792,-.602,1.558),vec4(.889,-.486,1.201,-2.591),vec4(.507,1.044,-2.202,3.738),vec4(-2.455,1.073,.811,-.616),vec4(1.273,1.021,-2.413,.555),vec4(-.814,1.963,-1.465,1.237),vec4(.350,1.382,.620,.137),vec4(4.158,3.442,-2.729,-6.800),vec4(3.892,3.280,-14.020,2.483));\nconst vec4 embed3[1024] = vec4[](vec4(-.066,.065,1.077,1.614),vec4(.464,1.366,.815,1.471),vec4(.160,.467,.167,1.053),vec4(-.050,.964,-.530,.634),vec4(.700,.128,-.136,.815),vec4(1.014,.804,-.205,.648),vec4(.750,.957,-.314,.416),vec4(-1.030,1.411,.011,.630),vec4(-.684,1.497,-2.896,-2.817),vec4(-1.390,-.863,-1.999,-1.533),vec4(-1.585,-4.750,-2.495,3.536),vec4(2.114,-.955,-2.650,1.281),vec4(.801,-5.721,-.198,-1.722),vec4(2.032,-6.808,-3.994,1.935),vec4(5.130,1.339,5.267,2.286),vec4(-2.724,.896,3.761,4.357),vec4(2.675,-3.818,.412,3.648),vec4(5.349,-2.244,1.540,10.076),vec4(-1.898,-.694,.217,4.702),vec4(2.051,-1.218,-.991,.780),vec4(1.096,-1.039,-1.796,1.715),vec4(-1.576,-.506,-2.167,-.267),vec4(-.464,-.613,.190,.085),vec4(.650,-.885,.010,1.295),vec4(1.216,.156,-.807,1.757),vec4(-.050,.660,-.620,.305),vec4(-.309,.450,-.682,.048),vec4(-.625,.111,.053,-.080),vec4(-.378,.766,-.129,.621),vec4(.182,.542,-.500,-.109),vec4(.919,.514,-.688,.220),vec4(.708,.216,-.456,.023),vec4(-.446,-.054,-.395,2.212),vec4(-.099,.282,.047,1.686),vec4(.487,.573,-.047,.965),vec4(.476,.441,-.738,.353),vec4(.666,.918,.053,.655),vec4(.892,.519,-.215,1.032),vec4(1.175,1.159,.042,.485),vec4(-.068,2.344,-.156,-.811),vec4(-.757,1.403,.890,-.379),vec4(1.127,.101,-.263,1.721),vec4(.165,-2.866,-1.668,.706),vec4(.720,-2.033,-2.198,-1.707),vec4(-.832,-.391,.130,1.807),vec4(2.287,-1.876,-.520,2.590),vec4(.799,-1.698,-.516,1.839),vec4(3.147,-3.120,-3.405,.502),vec4(-1.822,-.934,3.194,7.587),vec4(-2.411,1.790,4.345,2.330),vec4(.603,1.293,2.476,1.181),vec4(2.703,.797,.358,.027),vec4(-.441,-1.002,-1.314,-.652),vec4(2.378,-.513,-.482,-.172),vec4(.766,-.402,-.658,-.768),vec4(.374,-.425,-.303,.934),vec4(.855,.129,-.569,1.500),vec4(-.122,.445,-.760,.059),vec4(-.789,.180,-.549,-.402),vec4(-.303,.353,.008,.354),vec4(-.332,.594,.002,.501),vec4(.527,.600,-.223,.226),vec4(.649,.682,-.206,.086),vec4(.722,.556,-.307,.384),vec4(-.181,.292,.048,1.006),vec4(-.219,.172,-.121,.901),vec4(.079,-.226,-.788,.810),vec4(.813,.933,-.247,.848),vec4(1.114,1.225,-.089,.698),vec4(.840,1.124,-.189,.346),vec4(1.388,.047,-.427,-.465),vec4(.577,1.144,-.357,-.454),vec4(-1.439,.255,-.045,-1.562),vec4(.403,1.169,-.661,-.152),vec4(1.124,1.291,.720,-1.001),vec4(1.751,.748,.398,-.299),vec4(2.500,-.077,-1.998,-.761),vec4(-.759,.135,1.404,1.408),vec4(-.789,.736,1.094,-.394),vec4(-.240,-1.188,1.756,.483),vec4(1.649,.767,-.475,-3.050),vec4(.812,.071,-.122,-.124),vec4(2.653,1.439,-1.594,.923),vec4(-.410,-.592,-1.056,.517),vec4(-.647,-.653,-3.200,-.447),vec4(-1.384,-.429,-.218,-1.571),vec4(-.472,.071,-.360,-.134),vec4(.607,-.443,-.617,1.458),vec4(-.044,.066,-.435,1.210),vec4(.192,.240,-.227,.922),vec4(-.796,1.274,-.858,.420),vec4(.279,1.076,.082,1.224),vec4(-.107,.440,.012,1.136),vec4(.123,.718,.094,.511),vec4(-.244,.687,.113,.147),vec4(-.211,1.152,.073,-.339),vec4(.153,.034,-.927,1.138),vec4(.005,-.066,-.668,.263),vec4(-.128,.115,-.931,1.011),vec4(.753,1.508,-.373,-.137),vec4(.516,1.551,-.091,.078),vec4(1.948,.617,-.088,.976),vec4(1.575,1.056,-.561,1.206),vec4(.085,-1.777,-.405,-2.120),vec4(-.344,-.038,1.018,-.564),vec4(-.441,.444,-.090,-.869),vec4(-.259,1.526,2.149,-2.576),vec4(.117,1.818,1.139,-.914),vec4(-3.558,1.453,.176,.668),vec4(-1.660,.548,-1.963,-2.113),vec4(1.493,1.532,-.903,-.388),vec4(-.753,2.486,.070,1.098),vec4(.123,2.400,1.095,.775),vec4(.394,1.080,-.700,.420),vec4(-.588,.591,-1.064,-.156),vec4(1.340,-.588,.017,-1.298),vec4(-.140,.034,.860,-.977),vec4(.246,.312,-1.225,.434),vec4(2.354,2.289,5.194,-1.750),vec4(-1.285,.514,1.430,-.164),vec4(.149,-.819,.659,-.060),vec4(.307,.704,.742,.666),vec4(1.371,.216,-1.653,.111),vec4(.264,1.089,-.262,1.386),vec4(.534,.792,-.322,1.324),vec4(-.569,.119,-.021,.005),vec4(-.440,.212,.581,.010),vec4(.099,-.063,.773,.265),vec4(.145,.691,-1.219,-.023),vec4(.011,.536,-1.131,-.107),vec4(.189,.724,-.890,.380),vec4(.698,.721,-.410,.185),vec4(.586,2.239,-.455,-.431),vec4(3.090,-1.673,-.751,.590),vec4(.711,.460,1.299,.657),vec4(.963,.181,-1.867,-.093),vec4(.749,-.118,-.381,-1.816),vec4(.029,-.354,-1.047,.758),vec4(.100,-.355,-.193,-.132),vec4(.364,.713,.789,1.440),vec4(-.834,.635,-.583,.885),vec4(-.175,.634,-1.046,1.519),vec4(-.649,-.477,-.427,-1.045),vec4(-1.216,.634,.225,.442),vec4(-.049,1.426,-1.339,-1.009),vec4(-1.202,-1.035,-.251,-1.241),vec4(-1.170,-.200,1.277,.600),vec4(-1.071,.934,-.543,.149),vec4(-.182,.514,-1.257,-.381),vec4(.092,-1.170,-.958,-.881),vec4(-1.059,1.028,.417,-.755),vec4(.803,2.436,1.506,1.475),vec4(-.189,1.321,1.584,.107),vec4(1.546,-.177,-.473,-1.228),vec4(1.938,2.409,-.285,-.694),vec4(1.498,.592,-1.795,1.619),vec4(-.914,.126,-.701,-.590),vec4(-.444,-.064,-1.011,1.034),vec4(-1.350,-.730,.064,-.220),vec4(-1.684,.362,.542,-.582),vec4(-.269,.070,-1.117,-.331),vec4(-.143,-.319,-1.157,.139),vec4(-.623,-.535,-.803,.243),vec4(.299,.464,-.308,.930),vec4(2.406,-1.119,-1.248,.991),vec4(1.907,.084,-2.802,-2.460),vec4(-1.324,-.510,-.265,-3.096),vec4(-1.375,.008,-1.942,.729),vec4(-2.205,-.034,-4.503,1.619),vec4(1.007,-1.747,-2.974,.726),vec4(.468,-1.578,.572,-.052),vec4(-1.414,2.260,-1.287,.621),vec4(-.277,.050,-2.034,.749),vec4(-1.591,1.139,2.522,.453),vec4(-.255,.686,.780,-1.669),vec4(-.268,-.410,1.349,-2.157),vec4(-1.221,.749,-.414,.871),vec4(-.994,1.475,-.110,-.834),vec4(-.491,1.529,-1.101,.749),vec4(-.933,.598,-1.165,-.025),vec4(-.746,-.184,.182,1.039),vec4(1.282,-.628,-.916,-.642),vec4(.184,1.958,1.012,-.498),vec4(-2.239,1.691,1.133,2.576),vec4(-2.789,.165,.896,-.001),vec4(-2.102,-.581,-.450,1.628),vec4(-1.557,-.497,.086,1.388),vec4(-.952,3.591,1.234,.039),vec4(-.181,-1.581,-2.516,-2.570),vec4(-.027,-.201,-.790,1.435),vec4(-1.287,-.281,-.122,.106),vec4(-.739,.437,1.001,1.108),vec4(-.721,.964,-.265,.604),vec4(-.726,.079,-.578,.718),vec4(-.893,-.078,-.438,.115),vec4(1.401,-1.813,-1.580,.738),vec4(5.331,-2.179,-.843,.635),vec4(-.093,-.278,-.180,-1.258),vec4(.667,-1.664,.081,.093),vec4(-1.234,-2.043,-1.149,-.603),vec4(-.935,1.697,.530,3.449),vec4(.772,-.871,-1.269,.084),vec4(.787,.336,.863,-.838),vec4(-1.715,-.104,.668,-.935),vec4(.995,.807,.841,.858),vec4(-.007,-.035,2.144,.694),vec4(1.218,-.507,1.352,.215),vec4(1.903,-1.038,1.742,-.026),vec4(-1.612,1.388,3.037,2.285),vec4(.707,1.597,-2.525,-1.094),vec4(1.032,.076,-.422,1.749),vec4(-.191,.246,-.381,.448),vec4(.022,1.336,-.612,-.180),vec4(1.460,-.178,-.732,-.416),vec4(1.106,1.362,-.915,.419),vec4(-1.155,.447,-.635,-.081),vec4(.054,-1.305,-1.762,2.224),vec4(-.833,-1.358,-.255,.691),vec4(-2.329,-.211,.867,-.683),vec4(1.297,.867,-1.475,-4.544),vec4(-2.092,-1.054,-4.355,-1.108),vec4(-.588,.888,-.426,1.595),vec4(.191,.793,-.210,1.064),vec4(-.045,-1.285,-.592,.542),vec4(.496,.922,.410,.936),vec4(-.799,.919,-.012,.646),vec4(-1.154,-.349,-.401,.516),vec4(-.303,-.904,-1.736,.913),vec4(3.222,-.379,1.833,1.726),vec4(-.015,-.949,-.652,-.397),vec4(.091,-2.564,1.809,.213),vec4(-.188,.605,.397,.189),vec4(-2.396,-.762,.904,-.800),vec4(.533,-1.246,1.147,2.855),vec4(-.034,.486,-.525,1.089),vec4(-.447,.283,1.690,.822),vec4(1.690,.577,.518,3.186),vec4(-.884,-1.266,.774,2.523),vec4(2.706,-.992,1.420,-.029),vec4(.313,.517,.974,-.014),vec4(-1.667,1.098,.519,-.089),vec4(1.089,.616,-2.105,.852),vec4(1.903,.345,-.663,1.116),vec4(4.537,.352,3.163,2.137),vec4(-2.027,1.142,.508,-1.173),vec4(-.382,-.707,-.769,-.966),vec4(.866,1.523,-1.964,2.072),vec4(-.682,-.865,-.229,-1.029),vec4(.833,-1.356,-1.299,-1.344),vec4(-2.319,-.664,.888,-.003),vec4(-1.819,-.641,-.565,.684),vec4(-1.350,-.865,-.573,.395),vec4(-1.664,.561,-.866,-1.237),vec4(-1.881,2.226,-.658,-.079),vec4(.166,.215,-1.696,.096),vec4(1.390,-.635,-.931,.355),vec4(.135,1.616,.539,.203),vec4(-.489,.845,.360,.764),vec4(-.815,.307,-.492,.848),vec4(1.054,.982,2.303,2.107),vec4(.910,-.410,.995,2.022),vec4(-.723,.153,1.646,-.347),vec4(-1.927,.269,1.244,.955),vec4(-1.291,1.493,.492,.435),vec4(-1.358,-1.710,2.884,.198),vec4(.597,.478,-1.648,1.442),vec4(.996,-2.514,-2.551,-.617),vec4(.352,1.445,.477,.014),vec4(.171,1.364,-1.401,1.032),vec4(-.781,.049,.816,.094),vec4(1.975,-.390,.114,1.687),vec4(.585,.230,1.736,-1.829),vec4(-1.160,.606,-1.690,1.458),vec4(-.746,-.622,-.743,-.953),vec4(.303,-1.646,-1.036,.921),vec4(.167,1.165,-.595,1.127),vec4(.554,-.012,.284,-.770),vec4(.221,-.493,-.136,-.831),vec4(-.880,.232,.121,1.991),vec4(-2.207,-.327,-.194,.049),vec4(2.891,-.990,-.552,1.473),vec4(-1.464,.613,-1.970,1.307),vec4(-1.713,-.010,-1.614,.479),vec4(.832,1.075,.315,-1.191),vec4(.340,.757,-1.595,.233),vec4(-.646,-3.302,-4.129,-3.422),vec4(.185,-1.012,-.696,-1.232),vec4(-2.603,-1.482,1.538,1.358),vec4(-.533,.555,.010,-1.221),vec4(.378,1.392,.738,-.129),vec4(.893,1.367,.692,.608),vec4(1.368,.226,-3.381,-.371),vec4(.739,-.439,-.760,.216),vec4(.100,-.317,1.259,.057),vec4(1.115,-1.159,-.851,-.352),vec4(.643,.956,2.664,.044),vec4(-.939,.401,1.794,.786),vec4(-.208,-.800,-.478,-1.073),vec4(-.357,-1.800,-.134,.092),vec4(1.869,3.641,.548,-1.199),vec4(.485,-.100,-.629,-.258),vec4(-.333,.257,-.661,.478),vec4(.068,-1.584,.976,-.020),vec4(.845,1.478,.771,-1.349),vec4(-.536,-.424,-2.192,1.435),vec4(-.717,-1.136,-.098,-.453),vec4(-1.107,-.690,-.544,1.554),vec4(-.383,.900,-.095,.837),vec4(1.884,.750,-.632,.502),vec4(-1.068,-2.089,.266,1.065),vec4(1.180,-.262,-2.708,-.050),vec4(-.591,-1.103,.162,1.056),vec4(.311,-.332,.120,1.030),vec4(-1.358,.009,.229,1.844),vec4(.060,2.855,-1.300,.555),vec4(1.322,.386,-.308,.654),vec4(1.176,-1.190,.470,.470),vec4(.223,3.293,1.081,-4.084),vec4(1.138,-.618,-1.449,-5.305),vec4(-4.746,-4.640,-1.064,3.970),vec4(-.296,1.236,-.404,-.461),vec4(.861,.848,1.141,-1.089),vec4(1.872,1.607,.992,-.402),vec4(2.438,1.251,-.493,.092),vec4(1.288,.667,-.786,-.454),vec4(-.352,.265,.313,1.350),vec4(1.383,-1.289,-.230,-1.528),vec4(-.370,-.367,.910,-.772),vec4(.184,-.221,1.282,.791),vec4(1.521,-2.431,-.412,-.562),vec4(-1.029,.121,1.904,.448),vec4(.235,-.032,.267,2.604),vec4(.233,-.393,.797,-.820),vec4(.334,.368,-1.488,.724),vec4(-1.346,.037,.279,-.353),vec4(1.276,-.906,-.488,-.544),vec4(.104,-1.229,-1.676,.688),vec4(-.703,-1.959,-1.148,-.318),vec4(-1.037,-1.881,.009,-1.502),vec4(-1.260,-.284,-.204,2.566),vec4(2.752,-.030,-.611,.194),vec4(-1.869,-.346,-.640,.840),vec4(2.543,.983,-.722,.074),vec4(-.329,1.992,2.251,.113),vec4(-.145,.314,-1.838,.902),vec4(1.909,-.255,-1.571,.222),vec4(.920,.241,-1.965,.247),vec4(2.405,-.022,-1.132,1.118),vec4(-.507,2.997,1.882,-2.998),vec4(-1.552,-.983,.334,1.483),vec4(.545,1.672,-1.832,.837),vec4(-6.397,.425,-2.034,-11.357),vec4(.858,.853,.455,-.292),vec4(.626,1.323,.295,-.773),vec4(1.970,1.210,.751,-.192),vec4(1.255,.675,.546,-.051),vec4(-.144,.285,-.848,-.719),vec4(-1.625,2.460,.363,-.309),vec4(1.610,-.838,-.499,-1.400),vec4(.428,-2.252,-.663,-.367),vec4(.745,-1.967,-1.757,1.047),vec4(2.275,-.051,.169,-.721),vec4(-2.114,.202,-.470,1.071),vec4(-.237,-1.485,-.573,1.276),vec4(.784,1.811,.302,.875),vec4(-.635,-1.435,-2.148,-.066),vec4(-1.495,.682,.828,.955),vec4(-1.276,.603,1.144,-.328),vec4(1.375,-1.175,.031,.770),vec4(-2.379,.787,-2.526,-2.733),vec4(-.167,.976,-.185,-.649),vec4(2.474,1.871,1.572,.851),vec4(1.650,.419,-.679,.774),vec4(-.673,1.022,-.222,.821),vec4(2.129,.782,-1.558,-1.196),vec4(-1.349,1.657,3.051,-.773),vec4(.150,-1.594,-1.810,1.424),vec4(.548,.164,-.490,-1.234),vec4(1.350,1.025,1.513,-.461),vec4(1.190,-1.022,-1.953,.773),vec4(-.208,3.102,.787,.701),vec4(-.496,-.248,-2.918,1.896),vec4(.525,.473,-3.162,-2.999),vec4(-2.725,7.362,-2.634,3.994),vec4(-.218,.769,-.437,.590),vec4(.268,.846,.065,.399),vec4(.852,.448,.514,-.179),vec4(1.145,.303,.031,-.120),vec4(-.588,.499,-3.916,-1.691),vec4(-1.045,.546,-.361,-.363),vec4(.083,-.201,-.906,.988),vec4(-.786,-.244,-3.275,-.694),vec4(1.602,-1.148,-.342,-.644),vec4(.997,.018,.368,.451),vec4(-2.021,-.615,1.474,1.497),vec4(-.472,-1.704,.667,.424),vec4(1.618,1.980,-1.511,-.559),vec4(2.068,-1.060,-1.599,-.094),vec4(-1.914,1.207,1.185,-2.812),vec4(.507,-1.168,-.011,-2.147),vec4(1.180,-.184,3.211,.852),vec4(1.808,.424,1.108,-.277),vec4(-.817,.292,-.017,-1.309),vec4(.902,-.029,.290,-.981),vec4(.336,-1.038,.289,.339),vec4(-.337,1.269,1.017,1.978),vec4(-1.071,-.210,-3.429,-1.488),vec4(-1.595,1.829,1.266,-1.020),vec4(1.849,-3.295,-1.413,2.374),vec4(.613,.576,-.239,-.482),vec4(.067,-.866,1.225,-1.325),vec4(.937,.299,.940,.843),vec4(.158,2.820,-.262,.204),vec4(.466,.739,2.072,-1.442),vec4(2.518,-2.994,-5.315,1.252),vec4(-.708,1.626,-1.405,5.335),vec4(-1.032,1.523,-.996,-.645),vec4(-.430,.591,.116,.317),vec4(.910,.136,1.691,.212),vec4(1.540,2.909,.764,-2.181),vec4(-3.201,3.080,-1.925,-6.111),vec4(-1.175,.230,-1.915,.257),vec4(-1.269,.304,-2.227,1.364),vec4(-.785,.233,-1.183,-.568),vec4(.620,.841,-.368,-2.835),vec4(.531,-.645,2.769,.063),vec4(-1.504,-.281,1.144,1.225),vec4(-.567,-.061,1.659,1.978),vec4(-.645,-.415,-.595,.516),vec4(-.020,-1.530,-.090,-1.077),vec4(.064,-.928,1.483,.760),vec4(.836,-1.904,.723,-.326),vec4(1.427,-1.586,-.003,.314),vec4(.701,-1.210,.684,.401),vec4(.778,-1.722,1.784,.092),vec4(2.889,.549,.968,.603),vec4(-.386,-.961,-1.269,-1.591),vec4(.074,.789,.210,.783),vec4(-1.363,.046,-2.164,-2.733),vec4(-.259,.567,-.242,-1.968),vec4(-1.148,-.188,1.810,.716),vec4(-.420,.864,.892,1.292),vec4(-1.252,-.799,-.245,-.682),vec4(.783,.758,2.017,.788),vec4(.477,-.220,-.891,-1.398),vec4(-.049,-.377,.899,-2.180),vec4(-2.615,3.857,-.533,-.488),vec4(.765,-4.232,-6.449,3.509),vec4(1.777,.219,.994,-.465),vec4(1.113,.917,1.294,-.690),vec4(.735,1.700,1.513,-1.137),vec4(-.083,1.116,.522,-1.323),vec4(1.804,-.456,-.852,.857),vec4(.917,-1.231,-1.017,.349),vec4(-.804,.014,-2.487,.699),vec4(-.395,.675,-1.204,-.009),vec4(-.354,-.380,.084,-1.036),vec4(-1.317,-.631,1.510,-.424),vec4(-.635,-.966,-.131,-.126),vec4(.252,-.794,3.045,1.433),vec4(-2.644,.992,-1.357,-.854),vec4(1.255,1.062,.023,-3.219),vec4(-.004,1.052,1.573,-.305),vec4(2.811,2.288,.141,-.055),vec4(2.166,.597,2.594,1.856),vec4(-3.829,1.196,1.774,-.267),vec4(-1.221,1.308,2.560,-1.036),vec4(-.005,-.044,.808,-2.829),vec4(-1.387,.766,1.544,-.814),vec4(-.759,.845,.884,.687),vec4(-.165,.150,-1.333,-.847),vec4(1.688,.952,-.680,-1.777),vec4(-2.293,-1.611,4.190,-.751),vec4(-1.814,.554,-.670,-1.119),vec4(-1.111,-.426,-.605,.241),vec4(.776,1.769,1.520,.371),vec4(1.011,.138,-3.493,-2.388),vec4(-1.294,-2.544,-5.508,-3.181),vec4(-1.085,.906,-1.840,-.244),vec4(-4.901,.303,-3.116,1.522),vec4(-1.926,1.000,.987,1.501),vec4(-.822,1.119,.323,.756),vec4(.975,1.338,.907,-1.185),vec4(-1.811,.813,-2.343,-1.709),vec4(2.433,-1.714,.707,-1.383),vec4(.968,-.908,-1.198,-.659),vec4(2.644,-1.946,-.766,-.610),vec4(-1.748,-.665,-2.076,.286),vec4(-.703,-1.053,2.195,.145),vec4(-1.694,-.934,-.002,-2.270),vec4(-.655,-1.012,-2.448,1.116),vec4(.510,-.476,.459,-.246),vec4(-1.564,.408,.325,-1.834),vec4(-1.941,1.064,-.509,-1.420),vec4(-2.737,2.172,.703,.881),vec4(1.568,.210,.942,.915),vec4(-1.319,2.636,3.527,.641),vec4(-3.115,5.521,5.470,-3.240),vec4(-.818,-1.023,-.116,-.461),vec4(-.726,.244,1.292,-.200),vec4(-.153,-.554,2.330,.288),vec4(1.917,-.337,-.528,-.556),vec4(-.083,.232,-.966,-.553),vec4(.699,1.254,.049,-.516),vec4(-3.556,-3.287,1.399,1.454),vec4(-.397,-.129,.615,-.009),vec4(-1.567,1.303,-.563,.266),vec4(.233,.753,.773,.112),vec4(1.992,.170,.928,4.450),vec4(-.992,1.011,-.444,3.612),vec4(-.728,-.077,-1.779,.744),vec4(-.902,-2.118,-2.793,-.465),vec4(1.953,-.354,.273,1.898),vec4(.556,-.105,2.287,.178),vec4(.517,2.556,5.408,.805),vec4(.729,.437,-.398,-.053),vec4(-1.132,.126,.437,.381),vec4(1.195,-1.151,.703,-1.361),vec4(-.031,2.212,-2.787,-.463),vec4(-.276,-.701,-.762,1.851),vec4(-2.119,-1.674,1.371,-1.651),vec4(-1.269,.410,-.095,-2.595),vec4(.810,-.422,.178,2.044),vec4(-.132,1.265,.105,.578),vec4(.919,-1.093,-1.082,-1.970),vec4(-1.606,-.946,1.774,-1.044),vec4(-.880,.139,.835,-1.695),vec4(1.582,.316,1.869,1.552),vec4(.334,3.635,1.874,.771),vec4(1.767,.108,2.239,-1.234),vec4(1.159,.467,1.344,.489),vec4(1.808,-1.165,-.010,1.771),vec4(-.887,1.840,.477,-1.009),vec4(.823,1.388,-.968,.568),vec4(.162,-.018,-.497,-1.054),vec4(.452,.909,-1.984,.752),vec4(-2.785,-1.093,-.585,1.377),vec4(.774,-1.064,1.293,-.144),vec4(-.284,.971,-.250,.170),vec4(.237,.192,.007,-.433),vec4(2.168,-.945,-.529,.821),vec4(1.974,.217,1.281,1.418),vec4(.057,.615,.178,1.518),vec4(-1.589,-.445,-.899,-.878),vec4(2.551,-.512,-1.578,.173),vec4(1.364,1.260,4.353,-.360),vec4(-1.571,1.538,-.319,-1.342),vec4(.617,-.264,-2.151,-.450),vec4(.515,-.243,.446,1.384),vec4(.781,-1.258,-.895,-1.427),vec4(-1.044,-1.224,-.991,.207),vec4(.724,-1.211,1.726,-.943),vec4(-2.694,-.970,1.945,-1.863),vec4(-1.592,-1.475,.787,-2.104),vec4(-.123,-3.117,-.444,1.944),vec4(-1.210,-1.050,.399,-.189),vec4(-.195,.890,.013,.885),vec4(.424,-.977,1.065,-1.573),vec4(.753,-.027,2.696,2.402),vec4(-.387,-1.504,-2.597,-.312),vec4(1.713,-.572,.223,.859),vec4(-.459,.881,2.221,.319),vec4(-.304,-1.148,1.785,.395),vec4(-.418,-.518,.669,1.111),vec4(-.536,1.123,.020,-.272),vec4(.691,-.105,.398,-.115),vec4(1.441,.376,-2.034,.057),vec4(-.351,-.216,-.645,.919),vec4(-1.961,.071,-.025,1.582),vec4(-.627,-.288,1.703,-2.046),vec4(1.787,.449,.439,-1.430),vec4(-1.864,.206,-1.600,-1.207),vec4(.262,-.247,-.233,.312),vec4(1.175,-1.670,-1.407,-.375),vec4(.167,2.564,.731,.060),vec4(7.055,-1.274,2.104,3.115),vec4(4.573,-1.011,2.020,-.701),vec4(2.024,1.950,2.248,-1.693),vec4(-2.392,-.429,-2.901,-.088),vec4(.079,1.463,-1.502,1.636),vec4(-1.079,1.239,-1.170,-1.398),vec4(-.195,-1.277,-.808,4.443),vec4(-1.182,.289,.922,-2.646),vec4(-.580,-.686,1.421,.205),vec4(-3.526,-.907,-2.432,.896),vec4(-3.131,-1.486,1.010,.704),vec4(.036,-.476,1.347,.878),vec4(1.215,-.556,1.548,-1.501),vec4(1.414,-.154,-1.056,-3.221),vec4(1.041,-.013,2.328,1.675),vec4(.312,.408,.408,1.856),vec4(-.917,-.457,2.922,.953),vec4(-.355,-.345,-1.745,-3.072),vec4(-.403,-1.820,-.712,1.849),vec4(-2.503,-.652,2.925,.010),vec4(-1.043,-1.798,.247,-.201),vec4(1.448,1.200,2.450,-.085),vec4(.030,1.429,2.360,2.148),vec4(.707,-.872,-1.666,-.029),vec4(-6.015,-.804,.159,-1.146),vec4(-3.531,-2.838,-.203,.087),vec4(-2.300,.322,.928,-.920),vec4(-1.816,.565,1.010,1.400),vec4(1.397,.721,1.734,-.363),vec4(-.480,.017,-2.603,-1.762),vec4(-.790,.074,-.010,1.387),vec4(3.327,-1.379,-.681,-2.267),vec4(-2.679,6.399,7.136,3.105),vec4(1.804,3.529,1.879,-1.542),vec4(2.856,-.803,1.088,-.167),vec4(-.714,-1.614,-1.531,1.124),vec4(.113,1.364,-1.227,1.845),vec4(-.781,2.788,-1.710,.534),vec4(-1.530,-.064,-1.089,1.551),vec4(-1.651,.510,1.462,-1.620),vec4(.037,1.374,.363,-.838),vec4(-2.742,.809,-1.178,-1.552),vec4(.555,.384,.938,3.367),vec4(1.833,-.670,2.944,2.624),vec4(1.950,-.692,1.207,-.225),vec4(-.326,.256,2.368,1.003),vec4(-1.732,-.645,.358,.799),vec4(-.092,-1.141,1.516,1.151),vec4(-.489,.887,.215,2.020),vec4(.386,-.145,3.913,-2.093),vec4(-.366,-1.906,-.863,.827),vec4(-.095,.267,.506,.148),vec4(1.515,.909,-.473,-2.454),vec4(-1.606,.180,-.314,.042),vec4(.148,1.153,-1.006,-1.617),vec4(.486,.376,-1.268,-.331),vec4(-4.407,-.959,.479,-1.140),vec4(-.878,1.366,-.328,.027),vec4(.180,-2.492,-2.574,1.987),vec4(-.867,-2.192,.430,1.285),vec4(2.808,4.135,2.724,-1.616),vec4(-.404,-.343,.442,.013),vec4(4.507,-.322,.314,-1.035),vec4(1.238,1.878,.186,-.116),vec4(-5.727,-7.078,-4.412,8.104),vec4(-.553,-.238,-1.232,-1.424),vec4(2.962,2.478,3.401,-.620),vec4(.767,-.355,-.674,.426),vec4(-2.255,.503,.772,.980),vec4(-.962,-.049,-3.107,1.083),vec4(.261,-.119,.949,-.595),vec4(-1.243,-2.115,-.136,-.133),vec4(.929,3.055,1.233,-1.905),vec4(.615,.151,-1.704,1.549),vec4(.630,2.914,2.955,-.309),vec4(1.758,-1.197,-.807,.991),vec4(.434,-2.051,.479,-2.521),vec4(-.363,.182,-.782,.009),vec4(.542,-1.070,.909,-.579),vec4(-3.100,1.095,1.738,1.188),vec4(.799,.589,.552,-.089),vec4(1.447,-2.491,.417,1.179),vec4(1.284,.635,-.586,1.159),vec4(.268,-1.545,-1.154,-.050),vec4(.111,-.007,-.867,.420),vec4(3.769,1.444,.082,.440),vec4(1.317,.159,-.165,2.184),vec4(-2.980,.881,.058,-.232),vec4(-.677,-.412,4.088,-1.048),vec4(-.810,-.473,.603,-.632),vec4(-.716,.508,-1.269,-.273),vec4(-.834,-1.316,.799,-.347),vec4(2.771,1.473,1.151,-.409),vec4(-.582,-.276,.333,.162),vec4(1.585,-1.286,1.970,-.115),vec4(.335,-.297,1.187,-.675),vec4(1.766,-1.206,-3.824,7.621),vec4(1.848,.825,2.853,-.443),vec4(.799,.772,1.385,.294),vec4(1.919,-.856,.112,-3.733),vec4(-.961,-.114,1.865,-1.093),vec4(-1.380,-1.380,.749,-.411),vec4(.341,.074,1.343,-.262),vec4(-.463,.699,-.644,-.191),vec4(2.885,-1.989,-2.054,.378),vec4(3.623,.266,-.985,-2.382),vec4(-1.430,-.516,-3.844,-3.708),vec4(.134,.088,1.530,.609),vec4(-.134,-.676,1.165,-1.239),vec4(-.492,.867,-.923,-.691),vec4(.147,-.885,.443,-.775),vec4(.274,.690,.073,.497),vec4(-.968,-.267,.397,-.170),vec4(-.863,.915,-.770,3.854),vec4(.225,-1.334,1.482,1.082),vec4(.279,-1.529,.619,.680),vec4(-.516,-.897,-.644,.273),vec4(.565,-.703,.150,.871),vec4(1.352,1.066,.944,1.053),vec4(1.745,1.319,1.199,1.247),vec4(1.138,.573,-.268,.954),vec4(-.161,.608,.783,.834),vec4(.534,-.407,.054,.862),vec4(-.501,-2.173,-1.012,-1.256),vec4(-.224,3.088,4.740,-1.342),vec4(.426,-1.098,.736,.978),vec4(-1.849,-.477,1.430,-1.446),vec4(.068,-.119,-.348,-.174),vec4(10.813,-1.127,.462,10.596),vec4(-.154,1.866,.777,-.074),vec4(1.550,.917,1.108,-.995),vec4(1.186,1.811,2.110,-.836),vec4(1.028,-.848,-.203,-.909),vec4(.930,1.553,1.267,1.370),vec4(.929,-.924,.465,.353),vec4(-.622,.154,-2.631,1.564),vec4(.912,.986,.118,-1.038),vec4(2.069,-.734,.741,1.149),vec4(1.598,-.319,2.250,3.131),vec4(.346,-2.326,-.483,1.298),vec4(-.621,.586,-.159,.258),vec4(.136,.225,-.659,-1.104),vec4(-.325,-.765,.358,-1.652),vec4(-.715,-.762,1.880,.107),vec4(-.093,-1.143,-2.373,1.082),vec4(-.738,-1.433,-1.145,.562),vec4(.953,-3.497,-2.581,2.700),vec4(-.326,-1.442,.728,2.086),vec4(.828,-.849,.104,-1.721),vec4(.002,1.242,1.737,.026),vec4(2.120,1.189,.891,1.125),vec4(1.038,.481,2.921,.915),vec4(1.113,.409,-1.576,1.436),vec4(-.099,.543,.640,.601),vec4(.222,-.236,.714,-.078),vec4(-.408,-1.887,-1.132,1.614),vec4(-1.462,1.046,1.126,-.142),vec4(-2.426,-2.793,-.777,.310),vec4(-.432,.179,-.301,1.018),vec4(3.010,-1.208,-.307,1.839),vec4(1.261,-3.490,-1.745,6.492),vec4(.953,.900,.842,-.802),vec4(.606,.912,.777,-.819),vec4(1.434,1.394,1.013,-.703),vec4(1.832,-.453,-.321,-1.898),vec4(.424,1.261,1.595,.831),vec4(.299,.085,.610,-1.557),vec4(.148,-.091,.792,-2.446),vec4(1.891,-.929,.470,.164),vec4(2.123,6.222,9.175,7.001),vec4(.806,-1.047,.452,.132),vec4(2.193,-.178,1.350,1.107),vec4(-1.645,.728,1.602,1.384),vec4(-1.975,-1.319,-.550,.354),vec4(-1.606,.206,-1.210,.140),vec4(-2.148,4.430,.145,.513),vec4(-.918,-1.747,-.833,1.267),vec4(-.651,.328,-1.474,.235),vec4(.614,-.257,-.824,-.872),vec4(.352,1.125,-1.592,1.623),vec4(1.765,-1.214,1.223,-1.323),vec4(-.201,-.507,1.401,.691),vec4(1.777,1.776,.183,.268),vec4(1.817,1.699,.978,.701),vec4(-.457,-1.539,.282,.737),vec4(2.435,1.333,-1.694,-1.436),vec4(-1.237,1.110,-.337,.451),vec4(-.715,-1.900,-1.157,.129),vec4(-.856,-.530,.537,-.492),vec4(-1.712,.780,.556,.879),vec4(.456,1.573,1.443,1.353),vec4(-.742,-1.697,-1.144,.395),vec4(-2.173,4.209,-3.163,3.334),vec4(-2.278,.263,-.412,-.803),vec4(1.980,.595,.478,.878),vec4(1.175,.750,.180,.225),vec4(5.212,.490,2.822,2.046),vec4(.907,.326,-.216,.003),vec4(1.865,1.637,-1.686,-.434),vec4(.786,.805,-.284,-.713),vec4(1.401,-.696,-.278,-1.015),vec4(-4.191,4.097,-1.378,-1.147),vec4(-.917,-.607,.589,.925),vec4(-.647,-.195,1.094,2.104),vec4(.137,1.002,-.990,.470),vec4(1.457,.830,-1.339,-.230),vec4(1.239,-.619,1.788,3.476),vec4(-1.073,.693,.667,-1.916),vec4(-.353,-1.222,1.805,2.175),vec4(-.851,-1.976,-2.228,-1.382),vec4(-1.537,-.258,-1.049,-1.031),vec4(-.686,2.062,.666,-.940),vec4(.159,.564,.230,-1.369),vec4(2.457,-.582,.091,-1.398),vec4(1.738,.296,.070,2.592),vec4(-1.036,1.319,.466,-1.410),vec4(-1.143,-1.744,-.780,-.328),vec4(-.551,-1.291,-2.072,1.418),vec4(-.698,.953,-.180,-.338),vec4(-.820,-.921,-.891,-.159),vec4(-.720,.515,.143,-1.113),vec4(1.477,.686,.202,-.817),vec4(4.059,-1.229,-1.190,.288),vec4(3.278,-.674,-.892,-2.205),vec4(-1.704,4.351,.819,1.562),vec4(.585,-1.439,-2.346,.248),vec4(-.250,.976,-.211,-.706),vec4(.894,1.222,1.487,-.779),vec4(-.519,-.534,.488,.393),vec4(-.270,.764,.943,-.064),vec4(1.048,.724,-.962,.246),vec4(-.180,.950,.611,.016),vec4(.854,-.353,.179,2.606),vec4(.913,2.407,-1.115,-1.139),vec4(1.401,1.361,1.956,2.843),vec4(2.263,-.735,2.468,3.000),vec4(-.843,-.640,-.967,1.614),vec4(.629,-.080,-1.321,-3.477),vec4(.453,.311,2.976,1.502),vec4(-1.708,-.870,1.261,1.244),vec4(.096,-.582,.348,.000),vec4(.030,1.460,-.771,1.161),vec4(-.778,-1.260,.463,.180),vec4(-.075,2.184,-1.391,.379),vec4(-3.004,1.597,3.956,.543),vec4(1.164,-1.260,-.039,-1.624),vec4(-.445,-.858,-.060,.625),vec4(.145,.757,1.126,.508),vec4(-.203,-1.770,1.647,-.907),vec4(-.984,-1.023,-.141,.924),vec4(-.528,-.689,-.216,2.265),vec4(-.942,-1.693,-1.920,-1.802),vec4(-.716,-.320,-.561,1.626),vec4(-.045,.148,-.744,-.275),vec4(-1.513,-.285,-.870,-.505),vec4(-1.815,1.124,-1.901,1.215),vec4(.072,.886,2.314,-2.992),vec4(-8.742,-5.208,-7.374,-.204),vec4(.098,-.425,-2.529,-1.627),vec4(-1.240,-1.158,.418,-.654),vec4(-.096,.021,.860,-.541),vec4(-1.615,2.076,-.767,-.430),vec4(1.031,.503,-1.375,-1.741),vec4(-2.116,.326,1.112,1.375),vec4(-1.337,-1.243,.203,.926),vec4(-.113,-.046,-1.790,.004),vec4(-.844,2.079,2.479,2.175),vec4(-.300,-1.093,1.056,.939),vec4(3.220,-2.740,-1.757,1.526),vec4(-2.321,-.078,.779,2.365),vec4(1.536,-1.418,1.489,-.184),vec4(-2.200,.526,-.154,.829),vec4(-.289,-.694,2.944,.460),vec4(2.584,.482,-.858,-2.352),vec4(2.492,2.832,.796,1.763),vec4(-1.675,-.710,1.437,-2.237),vec4(-1.156,2.884,2.122,3.144),vec4(-3.056,3.255,2.677,.968),vec4(-.398,-1.354,1.549,-.757),vec4(-1.602,-.278,-2.456,1.303),vec4(.194,1.070,.601,-.076),vec4(-1.742,-.061,-.238,.638),vec4(-.969,-1.671,.387,2.320),vec4(1.192,.028,-3.242,-2.557),vec4(1.871,-1.310,.039,-.397),vec4(.136,-.986,-.005,.715),vec4(-.616,.002,-.239,-.401),vec4(.744,3.193,1.814,-1.525),vec4(5.386,6.763,5.325,-4.128),vec4(2.340,1.744,1.480,-.434),vec4(-.026,-.332,2.587,-1.453),vec4(2.435,.439,-.271,-2.162),vec4(-.286,-1.568,-5.461,-3.089),vec4(-.044,-.177,-1.656,-2.311),vec4(.681,.555,-2.699,.007),vec4(.167,.242,-2.188,.516),vec4(-.214,-.576,-.960,-.407),vec4(.315,-.543,.110,-.967),vec4(.381,.092,-1.229,-.228),vec4(.088,-1.038,-.257,-2.129),vec4(.130,-.330,.164,-.257),vec4(.971,.067,.833,-.457),vec4(3.151,-.739,-.711,-.400),vec4(2.461,.103,-.060,.244),vec4(1.673,-1.745,-.489,-.119),vec4(1.722,.004,-.069,-.996),vec4(1.232,-.001,-.507,-.886),vec4(-.457,-.257,-.169,-.253),vec4(-1.648,1.849,-.427,.743),vec4(-.913,.230,1.138,1.402),vec4(.236,1.269,1.043,.465),vec4(-.147,.023,-.476,.305),vec4(-.123,.213,-2.639,-.069),vec4(1.123,1.651,-1.425,1.555),vec4(-1.480,.597,-1.054,-.626),vec4(-1.488,-1.747,.965,1.767),vec4(-.958,-1.164,.120,-2.391),vec4(-.472,-.745,.273,.328),vec4(1.195,-1.185,1.252,.425),vec4(1.167,1.771,3.973,-2.724),vec4(.097,3.352,1.544,.598),vec4(3.934,-.466,5.964,2.335),vec4(-.292,-.551,1.166,.952),vec4(.380,-1.012,-.342,1.570),vec4(-.395,.888,1.314,.289),vec4(.906,.249,2.323,-.497),vec4(-.689,.707,-.214,.585),vec4(.144,.134,2.505,.653),vec4(.647,-1.360,1.243,.252),vec4(.214,-.794,1.331,-1.250),vec4(-1.308,-2.775,.696,.729),vec4(-.807,.576,1.206,-.934),vec4(.048,-.361,.840,-.443),vec4(-2.153,.828,.487,-1.261),vec4(-1.618,-1.024,1.404,.246),vec4(-1.403,-1.106,-1.525,.591),vec4(.902,-.301,.158,-1.237),vec4(-.989,-.674,-.534,-1.334),vec4(.504,-.582,.879,.326),vec4(-1.135,-.389,-1.065,.560),vec4(.505,-1.395,.461,1.241),vec4(-.034,-.474,.711,2.330),vec4(.372,1.561,1.260,.982),vec4(.412,.962,-.715,-.194),vec4(.143,2.139,2.680,.525),vec4(-.458,1.162,1.153,1.212),vec4(-.323,.524,-.407,-.853),vec4(1.406,.549,.233,-.525),vec4(-1.460,.048,-.307,-.365),vec4(-.492,.970,-1.929,-.421),vec4(-.770,1.155,.206,.796),vec4(2.049,.940,2.552,-.218),vec4(6.652,9.851,7.135,4.845),vec4(-6.918,.524,-3.180,-1.721),vec4(2.610,-1.028,-1.264,.664),vec4(1.839,-.043,-1.735,-1.332),vec4(2.169,-.244,2.524,-1.317),vec4(.096,1.090,.212,-1.012),vec4(.215,1.305,2.289,.998),vec4(3.812,-.050,-3.136,-.819),vec4(.422,-.352,-1.318,.002),vec4(1.329,-1.290,1.356,1.348),vec4(-1.047,-.825,-1.308,1.357),vec4(-1.186,2.313,-.638,.581),vec4(-.221,.359,1.215,-.138),vec4(.936,.304,.797,.008),vec4(-.148,-.133,1.635,-.263),vec4(-2.088,.620,1.310,-2.356),vec4(-1.983,-.111,-.478,.193),vec4(1.175,.105,-.535,-.538),vec4(.047,.377,.756,-.980),vec4(-1.335,-1.679,-.768,1.093),vec4(.043,1.516,1.307,1.739),vec4(-.037,-1.233,1.376,.471),vec4(2.461,.440,2.204,2.466),vec4(2.397,1.660,1.062,1.724),vec4(.301,-.064,1.279,.477),vec4(-2.735,.247,1.761,.334),vec4(-2.033,-.155,-.223,.878),vec4(-1.727,.884,.719,.935),vec4(-2.918,.386,-1.223,-.740),vec4(.552,1.406,-.587,-1.109),vec4(-1.720,-1.402,-.565,1.121),vec4(-.307,-.898,-2.385,.404),vec4(.484,2.303,6.324,1.217),vec4(1.289,5.762,9.189,-.541),vec4(.659,-1.319,-.844,-.312),vec4(.929,.107,-.389,-2.221),vec4(1.515,-1.833,.286,1.554),vec4(-.242,.380,1.151,.015),vec4(2.003,.423,-.192,1.655),vec4(.619,.976,1.909,1.887),vec4(1.224,2.059,1.738,.275),vec4(.650,-2.116,-.032,.177),vec4(-.011,-1.154,1.142,.644),vec4(-.392,1.484,.697,-1.533),vec4(.235,.765,-.145,-1.499),vec4(-1.332,.090,-.066,.021),vec4(.983,-2.912,-1.124,1.661),vec4(-2.114,-2.382,-1.371,.598),vec4(1.106,-.941,.825,.303),vec4(-1.876,.343,-1.107,2.785),vec4(.257,.209,1.326,.721),vec4(-.811,-.407,-.962,.839),vec4(-1.406,1.268,-.603,1.006),vec4(-.729,-2.407,.468,-.897),vec4(-1.449,.053,1.455,.430),vec4(.075,-1.864,-4.649,1.324),vec4(1.343,.133,-.594,1.602),vec4(.148,-1.286,-.428,.568),vec4(-1.629,-4.027,.956,-.337),vec4(-1.259,1.339,.200,-1.020),vec4(-.827,.149,-.622,-1.516),vec4(-.532,1.050,-2.232,-.901),vec4(-.404,.656,-2.554,.362),vec4(-.400,.781,.487,.027),vec4(1.563,.179,5.407,1.327),vec4(-7.605,-13.920,-8.188,-4.630),vec4(7.792,.279,3.552,4.493),vec4(1.019,-1.262,2.462,.807),vec4(1.653,.690,1.159,-.276),vec4(-1.221,-2.129,-2.196,5.026),vec4(-5.025,-2.589,-2.026,-1.400),vec4(.402,-4.767,-1.406,-1.779),vec4(1.041,3.911,5.082,4.542),vec4(3.547,2.288,.095,-2.253),vec4(1.328,-.673,-1.531,-2.944),vec4(-3.779,.243,-.563,-2.313),vec4(-1.784,3.158,-3.318,-5.717),vec4(-.852,-2.861,-3.818,-.441),vec4(-3.759,.760,1.442,-.219),vec4(-2.968,-2.233,-.034,2.137),vec4(-3.161,2.743,-.593,3.269),vec4(-4.166,-1.399,-4.911,.458),vec4(9.626,-3.264,2.673,21.279),vec4(.003,-7.420,-3.048,-7.865),vec4(-1.999,.407,.259,1.372),vec4(-1.381,.346,-2.105,3.104),vec4(-1.432,5.574,3.440,-3.327),vec4(-.566,-.082,.365,1.410),vec4(3.409,-1.586,-2.646,4.143),vec4(1.706,-.405,-1.769,2.006),vec4(-4.585,-3.528,2.183,-1.935),vec4(.809,.361,-3.722,-.342),vec4(.307,2.524,-.741,-2.462),vec4(-.981,.575,-.053,-2.897),vec4(.787,2.141,1.925,1.003),vec4(.548,-5.110,-2.008,3.816),vec4(6.396,-8.594,-10.884,.933));\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed2[idx];\n}", "buffer_c_inputs": [], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed3[idx];\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cstGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 366, 422, 422, 6718], [6722, 6722, 6764, 6764, 6979], [6981, 6981, 7047, 7047, 7209], [7211, 7211, 7233, 7233, 7569], [7571, 7571, 7628, 7628, 7850]], "test": "untested"}
{"id": "csd3zX", "name": "Handy SDF", "author": "dean_the_coder", "description": "A cut-down version of the GLSL SDF code for the hand I made in my Terminator 2 shader (https://www.shadertoy.com/view/mdt3D7) - Hopefully someone might find it 'handy'. :)", "tags": ["3d", "raymarching", "hand", "fingers"], "likes": 37, "viewed": 468, "published": 3, "date": "1677620503", "time_retrieved": "2024-07-30T18:07:42.213757", "image_code": "// 'Handy SDF' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/csd3zX\n//\n// Based on my Terminator 2 shader: https://www.shadertoy.com/view/mdt3D7\n//\n// Most component SDFs based on iq's awesome examples.\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 bend(vec3 p) {\n\tfloat c = cos(-.3 * p.x),\n\t      s = sin(-.3 * p.x);\n\tp.xz *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p) {\n\tvec2 d = abs(vec2(length(p.yz), p.x)) - vec2(.06, .15);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tr *= 1. - p.x / h * .14;\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tri(vec3 p, vec3 a, vec3 c) {\n\tconst vec3 b = vec3(.06, 0, 0);\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot3(ba * sat(dot(ba, pa) / dot3(ba)) - pa), dot3(cb * sat(dot(cb, pb) / dot3(cb)) - pb)), dot3(ac * sat(dot(ac, pc) / dot3(ac)) - pc)) : dot(n, pa) * dot(n, pa) / dot3(n));\n}\n\n// Simple articulated bone.\nfloat bone(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xz *= rot;\n\tfloat d = cap(p, h, r);\n\tp.x -= h;\n\treturn d;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n// SDF of the hand.\nfloat sdf(vec3 p) {\n\tfloat d, l,\n\t      curl = 1. - iMouse.y / R.y;\n\tp.xy *= rot(1.8 - iMouse.x / R.x);\n\tvec3 r,\n\t     q = p + vec3(.25, -.1, .07);\n\tq.xy *= mat2(.49757, .86742, -.86742, .49757);\n\td = bone(q, mat2(.98007, -.19867, .19867, .98007), .42, .04 - .07 * S(.1, .5, q.x));\n\tq.yz *= mat2(.16997, -.98545, .98545, .16997);\n\td = smin(d, bone(q, rot(.3 * curl - .5), .26, -.025), .04);\n\tfloat h = cyl(q);\n\td = smin(d, bone(q, mat2(.995, -.09983, .09983, .995), .22, -.03 - .065 * S(.1, .25, q.x) * S(.05, -.08, q.z)), .02);\n\tp = bend(p);\n\tr = vec3(.37, .47 - S(.1, -.4, p.x) * .15, .12);\n\td = smin(d, box(p, r - .12), .16);\n\tp.x -= r.x;\n\tcurl = S01(curl * (1. + step(p.y, 0.) * .3));\n\td = smin(d, tri(p, vec3(0, r.y - .12, 0), vec3(0, .12 - r.y, 0)), .05);\n\td -= .12;\n\tp.xz *= rot(-.2 - curl * .63);\n\tl = 1. + step(0., p.y) * .1 + step(.25, p.y) * .2;\n\tp.y = -abs(p.y);\n\tp.xz -= .05;\n\tq = p;\n\tq.y += r.y * .5 - .12;\n\tq.xy *= mat2(.9998, -.02, .02, .9998);\n\tmat2 r1 = rot(-.7 * curl),\n\t     r2 = rot(-1.4 * curl);\n\td = smin(d, bone(q, r1, .32 * l, .105), .06);\n\td = smin(d, bone(q, r2, .17 * l, .09), .01);\n\td = smin(d, bone(q, r1, .13 * l, .08), .01);\n\tq = p;\n\tq.y += r.y - .12;\n\tq.z += .07;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\td = smin(d, bone(q, r1, .19 * l, .105), .06);\n\td = smin(d, bone(q, r2, .13 * l, .09), .01);\n\td = smin(d, bone(q, mat2(1, 0, 0, 1), .12 * l, .08), .01);\n\treturn min(h, d) - .01;\n}\n\n\n// Calculate a normal.\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\n// Simple ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p);\n\n\treturn sat(min2(ao / h));\n}\n\n// Set the color.\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec3 l,\n\t     ld = normalize(vec3(0, -10, -6) - p);\n\tfloat _ao = ao(p, n), fre = S(1., .7, 1. + dot(rd, n));\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\tl.xy = .1 + .9 * l.xy;\n\tl *= .1 + .9 * _ao;\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), 1e2);\n\treturn sum2(l.xy) * vec3(1, 1.11, 1.5) * fre;\n}\n\n// Simple ray marhcing loop.\nvec3 march(vec3 p, vec3 rd) {\n\tfloat d = 0.;\n\tfor (float i = min(iTime, 0.); i < 64.; i++) {\n        // Background.\n\t\tif (d > 64.)\n            return vec3(length(rd.xy) * .2);\n        \n\t\tfloat h = sdf(p);\n\t\tif (abs(h) < 1e-4) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\treturn pow(max(vec3(0), lights(p, rd, N(p, d))), vec3(.4545));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = 0.0;\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tfloat st = S(0., 15., t);\n\tvec3 lookAt = vec3(0, 0.3, 0),\n\t     ro = vec3(.5, .001, -2);\n\tfragColor = vec4(march(ro, rayDir(ro, lookAt, uv)), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csd3zX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[566, 566, 586, 586, 610], [612, 612, 632, 632, 666], [668, 668, 688, 688, 708], [710, 710, 730, 730, 756], [758, 758, 797, 797, 879], [881, 881, 900, 900, 967], [969, 969, 988, 988, 1083], [1085, 1085, 1112, 1112, 1183], [1185, 1185, 1204, 1204, 1316], [1318, 1318, 1355, 1355, 1433], [1435, 1435, 1470, 1470, 1930], [1932, 1960, 2014, 2014, 2077], [2079, 2079, 2123, 2123, 2259], [2261, 2281, 2300, 2300, 3701], [3704, 3727, 3752, 3752, 3957], [3959, 3988, 4014, 4014, 4142], [4144, 4162, 4200, 4200, 4507], [4509, 4538, 4567, 4567, 4865], [4867, 4867, 4912, 4912, 5112]], "test": "untested"}
{"id": "cdd3zX", "name": "Catthink LARGE", "author": "michael0884", "description": "cathink", "tags": ["catthink"], "likes": 12, "viewed": 353, "published": 3, "date": "1677618876", "time_retrieved": "2024-07-30T18:07:43.968067", "image_code": "//So essentially I trained a small image with embeddings(here its 32*32 by 16 embeddings), which after interpolation we pass through a neural net to get the output color\n//The ouput neural net is just a siren here\n//The embeddings are interpolated using the hacky C2 smooth interpolation, to fix the 0 nodes in the gradient we have 2 grids, one offset by half pixel\nvec3 model(vec4 e0_0 ,vec4 e0_1 ,vec4 e0_2 ,vec4 e0_3 ){\nvec4 e1_0=tanh((mat4(.049,.170,.528,.166,-.818,-.165,.747,-.393,.501,-.286,.043,.417,-.122,-.555,.155,-.775)*e0_0+\n    mat4(-.343,-.392,-.428,-.159,1.213,.203,.511,.124,-1.147,-.328,.058,.238,.073,.198,-.280,.710)*e0_1+\n    mat4(.159,.081,-.214,.302,-.438,-.048,.123,-.459,-1.120,.543,.079,-.699,-.546,-.191,.176,-.444)*e0_2+\n    mat4(-.136,.038,1.018,-.545,-1.497,.019,-.810,.149,.049,.087,-.153,.091,.180,-.287,-.451,.007)*e0_3+\n    vec4(.300,-.309,-.058,-.381)))+e0_0;\nvec4 e1_1=tanh((mat4(.121,.642,-.069,-.272,-1.078,.318,.380,.817,.099,-.397,.228,-.600,-.332,.898,.680,.665)*e0_0+\n    mat4(-.810,-.569,-.622,-.043,-.179,.202,-.156,.036,.448,.568,-.684,-.724,-.005,1.258,.454,-.484)*e0_1+\n    mat4(.032,.016,.172,-.025,.003,-.194,-.474,-.080,-.051,.315,-.645,.330,.151,-.700,-.525,.043)*e0_2+\n    mat4(-.673,-1.015,.091,.327,.325,.103,.389,-.587,-.867,.002,-.838,-.455,-.330,.241,-.616,.834)*e0_3+\n    vec4(-.458,-.356,.248,.021)))+e0_1;\nvec4 e1_2=tanh( (mat4(.245,-.086,-.557,-.907,-.750,-.859,-1.018,.139,.212,-.447,.696,-.276,-.387,-.562,-.316,.254)*e0_0+\n    mat4(.046,.480,.433,-.871,.738,-.077,.877,1.333,-.342,-.208,-.425,-.478,-.780,.162,.467,-.169)*e0_1+\n    mat4(-.201,-.389,.493,-.375,-.224,-.372,-.248,-1.298,-.303,.240,-.217,.150,-1.293,.066,-.150,-1.017)*e0_2+\n    mat4(.472,-.166,-1.073,.774,-.416,.159,.195,-.531,-.035,.623,1.044,.238,.723,-.094,1.012,.772)*e0_3+\n    vec4(-.288,-.156,-.031,-.144)))+e0_2;\nvec4 e1_3=tanh( (mat4(.087,-.675,-.397,-.155,-.391,1.112,.422,.500,-1.061,-.703,-.284,.044,-.726,-.886,.387,.836)*e0_0+\n    mat4(-.407,-.025,-.715,-.619,-.703,.463,-.889,-.662,.276,.110,.018,1.440,.048,-1.209,-.414,.574)*e0_1+\n    mat4(.384,.352,.294,-.256,.655,-.164,-.312,.828,-.144,.175,-.219,.538,.064,.195,.523,-.681)*e0_2+\n    mat4(-.099,.684,-.621,.106,.126,-.264,-.009,-.257,.089,.988,-.989,-1.041,.402,.621,.181,-.802)*e0_3+\n    vec4(-.031,-.155,.727,-.228)))+e0_3;\nvec4 e2_0=tanh(1.0 * (mat4(-.478,.219,.119,.171,.560,-.387,.318,-.490,-.164,.224,.240,-.008,.017,.139,.236,-.097)*e1_0+\n    mat4(-.358,.101,-.334,.099,.036,.141,.109,-.297,-.433,.058,.110,.639,-.100,.257,-.015,.104)*e1_1+\n    mat4(.267,.157,.186,.086,.073,-.151,.303,.944,-.098,-.058,-.057,.078,-.009,-.008,.004,-.768)*e1_2+\n    mat4(.486,-.051,.137,-.208,.119,.225,-.073,.572,.293,-.130,.157,.263,-.203,-.064,-.414,.390)*e1_3+\n    vec4(.268,-.104,.176,-.463)))+e1_0;\nvec4 e2_1=tanh(1.0 * (mat4(.387,.056,-.229,-.042,.060,.371,.055,-.147,.185,-.101,.492,-.137,.013,.043,.092,-.087)*e1_0+\n    mat4(-.946,-.667,-.343,-.429,.815,-.544,.258,-.273,1.215,.297,-.294,-.162,-1.239,-.078,.115,-.158)*e1_1+\n    mat4(-.750,-.115,-.065,.162,.438,.185,.594,-.234,.100,-.176,-.762,-.267,.383,-.011,-.180,.098)*e1_2+\n    mat4(.676,.131,.225,.114,-.778,.427,.037,-.199,.236,-.221,.005,-.086,-.956,.145,.351,-.318)*e1_3+\n    vec4(.402,.156,.442,.386)))+e1_1;\nvec4 e2_2=tanh(1.0 * (mat4(.152,-.075,-.159,.040,-.360,.119,-.224,-.060,.948,.097,.977,-.038,.171,.062,.637,-.737)*e1_0+\n    mat4(.142,.586,-.478,-.507,-.544,-.409,1.006,.294,.165,-.596,.306,-.096,1.073,-.041,-.418,-.419)*e1_1+\n    mat4(-1.193,.266,-.152,.361,-.304,-.235,-.146,-.179,-.440,-.415,-.290,-.605,1.047,.244,-.199,-.653)*e1_2+\n    mat4(-.145,-.410,.507,.275,.270,.252,-.339,-.386,.359,.346,.215,.440,.628,.723,-.655,-.498)*e1_3+\n    vec4(.246,-.226,-.173,.121)))+e1_2;\nvec4 e2_3=tanh(1.0 * (mat4(.522,.202,.372,.975,-.290,-.074,-.927,-.104,.190,-.025,.157,-.248,.144,.151,.446,-.455)*e1_0+\n    mat4(.168,-.727,-.486,-.500,.646,.003,.023,-.260,.520,-.023,.489,.042,-.164,-.580,-.139,-.069)*e1_1+\n    mat4(-.511,.041,-.512,.239,-.004,-.190,-.103,.323,.967,-.625,-.331,-.113,-.093,-.096,.298,-.154)*e1_2+\n    mat4(.031,-.545,.242,.232,.067,-.645,-.105,.683,-.054,.041,.059,-.358,.175,.247,.327,-.699)*e1_3+\n    vec4(-.188,.217,.296,.286)))+e1_3;\nvec4 e3_0=tanh(1.0 * (mat4(.021,-.920,.649,.343,.030,.180,-.216,.042,.227,-.010,-.264,.445,.018,.749,-.355,-.239)*e2_0+\n    mat4(.064,-1.218,.492,.152,-.509,-.176,-.098,-.002,-.380,-.657,.380,-.221,-.087,-.082,.050,.263)*e2_1+\n    mat4(.134,1.001,-.269,.125,-.008,.603,-.335,-.596,-.342,-.204,.369,.370,.155,-.227,.246,.099)*e2_2+\n    mat4(-.027,.022,-.029,-.114,-.020,.408,-.215,.076,-.051,-.847,.325,-.334,.228,.102,.083,-.220)*e2_3+\n    vec4(.094,-.394,.698,-.189)))+e2_0;\nvec4 e3_1=tanh(1.0 * (mat4(.234,-.060,-.372,-.082,-.267,.114,-.187,-.264,-.371,-.396,.516,-.319,.130,.238,.014,-.048)*e2_0+\n    mat4(-.573,-.438,.107,.574,-.040,-.579,-.138,.247,.315,-.267,-.034,.170,-.278,-.056,-.035,.331)*e2_1+\n    mat4(.104,.101,-.079,.085,.232,.693,-.087,-.402,.221,.379,-.245,.308,.202,-.497,.086,-.270)*e2_2+\n    mat4(.281,-.562,-.199,-.153,.266,.467,-.126,-.039,-.436,-.362,.064,.207,-.400,.882,.385,.275)*e2_3+\n    vec4(.453,.143,.788,.425)))+e2_1;\nvec4 e3_2=tanh(1.0 * (mat4(-.195,-.225,-.232,-.370,-.541,-.075,.131,-.846,-.568,.328,.173,.091,-.210,-.353,.207,-.425)*e2_0+\n    mat4(-.647,-.131,-.302,-.387,.173,.228,.112,.097,-.295,-.235,-.164,-.354,-.105,-.114,-.491,-.141)*e2_1+\n    mat4(-1.035,.185,.124,-.906,-.312,-.077,-.213,-.068,-.515,-.069,-.367,-.650,-.042,-.217,-.100,-.572)*e2_2+\n    mat4(.217,-.075,.397,-.340,.042,-.112,-.231,-.482,.217,.221,-.368,.332,.213,.320,.316,-.158)*e2_3+\n    vec4(-.467,.016,.034,.005)))+e2_2;\nvec4 e3_3=tanh(1.0 * (mat4(.193,-.304,-.411,-.025,-.406,-.111,.308,.000,.347,.131,-.086,-.281,.364,.250,.473,-.065)*e2_0+\n    mat4(-.029,.207,-.989,-.393,-.440,-.085,-.269,-.421,.073,-.003,-.000,.005,.225,-.311,.172,-.025)*e2_1+\n    mat4(.051,.101,.550,.082,.309,.059,.600,-.019,-.011,-.347,-.237,-.005,-.275,.012,-.231,-.177)*e2_2+\n    mat4(-.585,.283,.075,-.095,.346,-.249,.115,.123,-.253,.206,-.614,-.273,.150,.310,-.504,-.175)*e2_3+\n    vec4(-.016,.015,.484,.549)))+e2_3;\nfloat e_0=dot(e3_0,vec4(.044,-.165,.138,-.158))+\n    dot(e3_1,vec4(.125,.120,-.013,.107))+\n    dot(e3_2,vec4(-.103,-.089,.028,-.063))+\n    dot(e3_3,vec4(-.083,.001,.095,.063))+\n    0.221;\nfloat e_1=dot(e3_0,vec4(.090,-.182,.094,-.169))+\n    dot(e3_1,vec4(.099,.122,.024,.130))+\n    dot(e3_2,vec4(-.122,-.065,.072,-.068))+\n    dot(e3_3,vec4(-.110,.039,.074,.018))+\n    0.152;\nfloat e_2=dot(e3_0,vec4(.128,-.207,.038,-.172))+\n    dot(e3_1,vec4(.039,.119,.065,.133))+\n    dot(e3_2,vec4(-.133,-.047,.116,-.064))+\n    dot(e3_3,vec4(-.116,.073,.044,-.050))+\n    0.144;\nreturn vec3(e_0, e_1, e_2);} \n\nvec4 smoothSample(sampler2D ch, vec2 uv)\n{\n\tuv = uv*iResolution.xy + 0.5;\n\tvec2 iuv = floor(uv);\n\tvec2 fuv = fract(uv);\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/iResolution.xy;\n\treturn texture(ch, uv);\n}\n\nvec4 sampleEmbed(sampler2D ch, vec2 uv, int embed, float offset)\n{\n    vec2 pix = (1.0 - uv) * float(embed_texture-3) + 2.0 + vec2(embed, 0) * float(embed_texture + 2) + offset;\n    return smoothSample(ch, pix/iResolution.xy);\n}\n\nvec3 decode(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec3(0.0);\n    vec4 e0_0 = sampleEmbed(iChannel0, uv, 0, 0.0);\n    vec4 e0_1 = sampleEmbed(iChannel1, uv, 0, 0.0);\n    vec4 e0_2 = sampleEmbed(iChannel2, uv, 0, 0.5);\n    vec4 e0_3 = sampleEmbed(iChannel3, uv, 0, 0.5);\n    \n    return model(e0_0, e0_1, e0_2, e0_3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.0*((fragCoord - vec2(iResolution.x - iResolution.y, 0)*0.5)/iResolution.y - 0.5) + 0.49999;\n\n    //vec3 col = sampleEmbed(iChannel1, uv, 0, 0.0).xyz;\n    vec3 col = decode(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec4 embed0[1024] = vec4[](vec4(-.284,-.013,.267,.287),vec4(-1.006,1.136,.315,.739),vec4(-.889,1.669,.850,1.907),vec4(-3.445,-.514,.418,-1.387),vec4(1.042,1.519,-2.311,1.533),vec4(-2.818,2.769,-.520,-4.607),vec4(.659,.917,4.930,.450),vec4(-2.822,-2.766,-.733,-1.380),vec4(-.132,-.295,.364,-1.140),vec4(.774,-.823,-.205,.164),vec4(-1.712,-2.403,-1.816,-1.628),vec4(2.989,2.074,1.378,2.933),vec4(-.895,-.546,-.315,3.003),vec4(.807,2.262,-.267,.443),vec4(-.580,-2.203,1.355,.769),vec4(-.283,1.052,.602,-.094),vec4(2.093,-.834,-3.115,-1.293),vec4(3.800,1.730,-1.192,3.004),vec4(-2.004,-.263,-2.293,1.441),vec4(-.114,1.688,-1.722,-1.892),vec4(-.713,-1.535,2.930,-1.564),vec4(-.422,-.146,2.223,2.163),vec4(1.354,2.978,-2.573,.786),vec4(-.302,.677,1.980,.433),vec4(.092,-.006,1.652,.037),vec4(-.685,-.127,-2.154,.931),vec4(-.086,-.083,1.747,-2.055),vec4(.019,-1.930,.578,2.152),vec4(-.397,.512,-.621,-1.345),vec4(1.743,-.210,2.646,3.159),vec4(1.279,.729,-.376,-3.520),vec4(1.382,1.525,.959,-.396),vec4(-1.287,1.258,.857,.845),vec4(-.600,1.155,.994,1.082),vec4(-1.928,1.616,1.043,.734),vec4(-1.763,.255,.237,.321),vec4(-1.622,1.080,-.528,-3.743),vec4(-1.324,1.963,-1.923,5.185),vec4(.833,2.370,3.550,-2.862),vec4(.598,1.623,3.022,-1.457),vec4(-.376,-.968,.854,-1.420),vec4(.311,-.698,-.996,.496),vec4(-2.371,-.474,.154,-2.109),vec4(.708,1.062,-.077,1.654),vec4(.330,.045,.539,2.029),vec4(-.143,1.588,-1.482,-1.504),vec4(-.967,.813,3.308,.063),vec4(1.029,-.775,.664,-.522),vec4(.179,-1.113,-2.149,.133),vec4(-.124,1.628,-1.596,.516),vec4(.176,.475,-1.728,1.588),vec4(.377,1.232,-.042,-3.233),vec4(.968,-.591,1.916,1.561),vec4(-2.913,-1.266,.656,-3.699),vec4(.012,2.584,1.428,-1.339),vec4(-1.906,-1.355,.772,.701),vec4(-.549,2.005,.961,-.672),vec4(-.703,.749,-1.354,-1.791),vec4(-.857,-.771,-1.091,.894),vec4(-.265,-.247,2.905,.799),vec4(.306,.548,.163,1.214),vec4(.822,.317,-.861,1.749),vec4(.296,-.162,.317,.649),vec4(.529,.135,-.903,1.349),vec4(-.291,.612,1.949,.678),vec4(-.667,.002,.454,1.298),vec4(-.973,.834,-.344,-.270),vec4(-1.619,2.249,2.988,-1.661),vec4(-5.308,-.235,-3.288,-3.210),vec4(1.509,-1.360,2.541,4.535),vec4(-1.623,.894,-.781,-.495),vec4(-.880,1.399,1.089,-.683),vec4(1.946,1.889,2.744,-1.793),vec4(-.749,-2.768,.093,-.250),vec4(-.772,-.635,-.742,-1.342),vec4(-1.182,1.074,.860,1.124),vec4(-2.090,.037,-2.456,-1.169),vec4(-1.205,-.032,-.095,1.358),vec4(1.044,.651,-.426,-.691),vec4(1.165,.332,-.292,-.333),vec4(1.340,-.033,-1.385,.419),vec4(2.571,1.384,-.217,.668),vec4(-.602,-.740,-.572,-.856),vec4(-1.646,.769,1.151,-1.427),vec4(1.831,.306,4.866,.997),vec4(-1.792,.404,-2.303,-3.617),vec4(-.206,2.009,1.784,-.166),vec4(-.723,1.266,1.957,2.580),vec4(.258,.186,-.026,-1.072),vec4(-1.092,.199,-.708,.017),vec4(.245,-.699,-1.187,1.773),vec4(-1.132,-.455,2.795,-.856),vec4(-1.361,.500,.693,.063),vec4(-.392,.164,-1.681,2.040),vec4(.574,1.354,-.627,1.254),vec4(-.217,-2.112,.929,-.580),vec4(-1.845,.358,2.050,1.439),vec4(-.695,.827,1.492,2.125),vec4(-1.336,-1.955,-.195,.952),vec4(-3.551,1.456,-4.840,1.765),vec4(5.483,-2.532,-2.038,-1.968),vec4(1.381,-1.626,2.022,4.756),vec4(.525,-.390,-.044,.567),vec4(-.542,.595,-.737,-.835),vec4(-1.238,-.233,-.077,1.379),vec4(.572,.779,.900,.048),vec4(.232,-1.445,1.399,1.646),vec4(.232,1.558,-2.302,.981),vec4(-.378,.868,.007,-2.167),vec4(.576,.189,1.040,-1.751),vec4(2.436,-.344,-.157,-1.044),vec4(3.608,.477,-.076,-.015),vec4(.981,-.318,.145,-.084),vec4(.585,-.829,-.771,.186),vec4(.689,-.098,-.875,-.189),vec4(1.427,-.006,-1.438,.342),vec4(.581,-.958,2.790,-1.035),vec4(-2.088,-1.616,-1.603,.083),vec4(.805,.743,3.628,-2.576),vec4(-1.264,-.230,1.466,.852),vec4(.951,1.656,.055,-1.841),vec4(-2.418,-1.666,-.356,.123),vec4(-2.115,-.757,-.544,-.154),vec4(-1.472,-.995,2.971,-.537),vec4(-2.487,.105,1.583,1.003),vec4(-.551,.194,.159,-1.120),vec4(-.116,.873,.991,.306),vec4(-1.147,.036,-1.343,.461),vec4(-1.164,1.047,1.993,1.790),vec4(-1.425,.044,2.446,.698),vec4(.937,1.072,.948,3.279),vec4(-2.191,2.430,1.757,-1.950),vec4(-.689,-2.905,.831,-4.480),vec4(-.912,-.541,-.478,-.691),vec4(.786,.936,-1.454,1.772),vec4(.290,-.124,-1.765,1.268),vec4(1.347,-.932,-1.513,-.872),vec4(-.006,-.903,1.368,1.819),vec4(1.648,.560,-1.218,-.481),vec4(1.636,-.058,-1.432,2.356),vec4(.864,.345,-1.101,-1.205),vec4(1.504,-.245,-.129,.580),vec4(2.754,.116,-.691,-.244),vec4(1.859,.040,-1.004,-.259),vec4(.547,-.527,-.220,-.273),vec4(.915,-1.362,-1.375,.886),vec4(.251,-.700,-1.634,.768),vec4(.545,-.236,-.733,-.495),vec4(2.671,.171,2.125,-2.410),vec4(.864,.248,-2.478,.395),vec4(.629,1.047,1.869,-.911),vec4(-.398,1.115,-1.003,1.621),vec4(-2.107,.429,-1.492,1.259),vec4(.030,.663,-.155,-.961),vec4(-2.959,.005,-3.424,-3.622),vec4(-1.427,-.725,-.496,1.086),vec4(-.299,.647,.255,-.592),vec4(-.363,.498,-.343,-1.010),vec4(-.315,-.429,.308,-1.280),vec4(.226,.773,-.937,.198),vec4(-2.705,-.239,1.309,1.310),vec4(-1.657,1.422,1.305,.856),vec4(-1.071,5.001,-2.635,-5.333),vec4(-2.566,-2.522,2.206,-2.252),vec4(.733,.469,2.140,-4.169),vec4(.371,-.888,.103,-1.045),vec4(-.899,-1.081,-.605,-.073),vec4(-1.349,.645,-.843,.562),vec4(.547,1.246,-2.414,-1.373),vec4(.527,2.947,.345,-1.509),vec4(-.349,-2.247,.221,-.128),vec4(.442,1.635,-.454,1.155),vec4(.785,-.146,-.366,-1.596),vec4(.930,.190,-.752,.217),vec4(1.597,-.200,-1.538,-.194),vec4(.913,-.407,-1.005,-.282),vec4(1.482,.101,-.807,-.739),vec4(1.773,.502,-1.156,-1.127),vec4(.657,-.447,-.592,-.246),vec4(.546,.102,-.714,.017),vec4(-.341,.169,-.344,-.950),vec4(1.032,1.083,-.956,.813),vec4(1.593,1.213,-.590,1.904),vec4(1.642,1.309,-1.680,2.743),vec4(.196,-.348,1.574,.913),vec4(-1.552,-.153,-.870,.724),vec4(-1.294,-1.111,-.650,2.100),vec4(-1.578,-2.876,-2.647,-.268),vec4(-.202,-.112,-1.829,-4.183),vec4(-1.918,-.925,1.340,-.024),vec4(.917,-.950,.180,2.491),vec4(-.262,-.677,-.917,-.691),vec4(-1.399,1.996,1.652,-1.092),vec4(-2.877,-.402,2.963,.049),vec4(-.390,1.835,-.854,-.888),vec4(-1.575,-.930,-1.385,-.689),vec4(-1.170,-.836,1.651,-2.267),vec4(-2.374,-.855,1.547,-1.419),vec4(1.038,-1.338,-1.331,1.522),vec4(1.416,1.077,-.098,-.417),vec4(-1.789,-.184,-.658,2.494),vec4(.769,.613,.425,-.859),vec4(-.392,1.594,-.795,-.309),vec4(.668,.319,-1.674,-2.355),vec4(-.206,1.145,.448,.747),vec4(-.535,.257,.399,.434),vec4(.732,.367,-.392,-.927),vec4(.161,-.294,-.432,.203),vec4(.727,-.049,-.782,-.074),vec4(.759,.246,.071,-1.367),vec4(.604,.046,-.091,-.269),vec4(.668,.671,-.700,.573),vec4(-.254,1.243,.152,-.701),vec4(1.723,.951,-.578,1.624),vec4(1.138,.612,2.179,-2.543),vec4(-1.021,-2.096,.678,2.409),vec4(.893,1.356,1.505,-.081),vec4(.326,-1.864,-1.133,1.896),vec4(-1.848,-.845,-1.683,-.935),vec4(-1.101,-.944,1.126,-2.558),vec4(-.706,.082,1.158,1.218),vec4(-1.135,.702,.161,.393),vec4(1.098,.844,1.992,3.449),vec4(-1.144,-1.236,-.882,-.942),vec4(-1.701,2.125,-4.395,-1.340),vec4(1.492,2.250,.562,3.025),vec4(1.590,-.631,-1.692,1.233),vec4(-.909,-1.404,.044,.351),vec4(-.584,-1.746,.078,.316),vec4(-2.204,-.857,-.643,-.553),vec4(.407,.596,.414,1.662),vec4(-.217,-.375,.807,2.460),vec4(-.253,1.040,-1.101,.767),vec4(-1.064,1.278,.141,.049),vec4(-1.555,.857,.865,-1.154),vec4(.215,1.649,-1.990,-.304),vec4(2.025,-.543,-1.612,.013),vec4(.542,.243,-.292,-.427),vec4(1.512,.149,.049,-.980),vec4(.840,.418,-.055,-.422),vec4(1.295,-.615,-.926,-.593),vec4(1.015,-.055,-.400,.136),vec4(.235,.234,-.097,.433),vec4(.139,1.236,-.881,-.670),vec4(.250,1.255,.092,-2.049),vec4(1.466,.483,-.716,-.169),vec4(1.524,.008,-1.722,-.090),vec4(.480,.988,.513,-2.206),vec4(.225,.531,1.835,-2.479),vec4(1.433,-.605,.222,1.294),vec4(1.173,-1.486,-.656,2.043),vec4(-.381,.081,-.064,.291),vec4(-1.442,-.993,-.236,-.960),vec4(-2.058,-.122,1.183,-2.696),vec4(-2.058,.096,1.791,-.519),vec4(-.942,1.459,.474,-1.214),vec4(-4.029,-6.877,-5.439,-.949),vec4(.386,-3.252,-2.089,-.657),vec4(.155,-1.399,-.948,-.008),vec4(-1.276,-.669,1.763,-.622),vec4(-.888,2.708,.416,-.298),vec4(.646,-.227,-.074,.356),vec4(.347,-.539,-.619,.141),vec4(-1.100,-1.026,.879,1.490),vec4(2.484,-1.610,-.737,-1.607),vec4(-.308,.174,-.989,-.888),vec4(-2.002,-.449,.178,-.872),vec4(-.196,-.526,1.305,-.224),vec4(1.886,1.041,-.624,1.022),vec4(1.116,.217,-1.102,-.400),vec4(1.656,.052,-.191,-.509),vec4(.833,1.256,.194,.058),vec4(.484,.883,.072,-.951),vec4(.815,-.107,-.334,.227),vec4(-.629,1.840,.615,-1.389),vec4(-.603,-.352,.594,-.732),vec4(.916,-.559,.120,-.090),vec4(1.338,1.344,1.097,-.351),vec4(-2.366,.540,.740,-1.329),vec4(-1.510,.933,1.124,-.131),vec4(-1.728,3.095,1.225,.157),vec4(-1.464,-1.099,-.052,.521),vec4(-.877,-.782,-.333,1.640),vec4(-.930,.104,.495,-2.023),vec4(1.573,1.403,-.517,1.105),vec4(-.130,1.166,-1.418,1.570),vec4(-1.970,.301,-.047,.989),vec4(.831,.203,.717,1.229),vec4(-1.448,-2.555,-1.613,1.334),vec4(2.914,-.928,-2.392,3.994),vec4(-.940,-.238,1.393,.259),vec4(1.664,1.076,-.474,-.043),vec4(-1.664,-.043,.280,-.398),vec4(.898,-1.394,-.354,.529),vec4(-.101,-.411,.911,.125),vec4(-2.569,-2.182,1.816,.022),vec4(-.312,.222,-2.279,.316),vec4(.702,.855,-.757,.350),vec4(.018,.049,.589,.367),vec4(-.501,.018,.099,-.090),vec4(.924,-1.003,.458,.369),vec4(.761,.150,-.272,-.936),vec4(1.129,-.446,-.783,1.269),vec4(.901,-.452,-.181,.344),vec4(.768,-.331,.041,-.416),vec4(-.490,-.615,-.113,.003),vec4(.685,-.550,-.007,.210),vec4(-.435,-.592,-.310,-.351),vec4(.448,.624,1.898,.263),vec4(2.082,.905,-1.250,-.405),vec4(-2.537,-.241,.948,-.914),vec4(2.678,2.414,1.927,2.015),vec4(1.064,1.610,.574,.304),vec4(3.282,-.229,-3.759,-1.522),vec4(-.740,1.718,.191,-.654),vec4(-1.682,-1.188,1.509,-.556),vec4(-3.037,.308,.283,-2.286),vec4(-2.436,.541,1.091,-1.926),vec4(.280,.956,-.096,-.105),vec4(2.305,-.349,-.974,.419),vec4(.509,-.137,-.934,1.120),vec4(.066,-.248,-1.586,2.029),vec4(-.988,-.662,1.863,1.573),vec4(-2.013,-.923,1.090,2.573),vec4(.264,-.981,.272,2.207),vec4(-.173,-.443,-1.966,.396),vec4(-.325,.587,-2.035,1.110),vec4(-.018,-.064,-.623,.526),vec4(-.310,-1.019,-.283,.153),vec4(.094,.838,-1.412,-.567),vec4(-1.199,-1.335,-.688,-.352),vec4(-1.069,-2.015,-1.578,-.976),vec4(1.972,1.120,.747,-2.238),vec4(.389,-1.070,-.411,.200),vec4(.485,-.365,-.990,.569),vec4(.165,-.014,-.034,-.310),vec4(-.335,-.840,.462,-.998),vec4(.323,-.318,.063,-.049),vec4(.599,-.262,-.488,.877),vec4(1.115,-1.346,-.378,.860),vec4(-.415,1.495,-.255,-.332),vec4(3.003,-1.090,-3.142,-1.935),vec4(-1.837,-.143,-.287,-.119),vec4(-.253,.610,1.841,1.579),vec4(-.458,1.026,1.008,-.099),vec4(2.448,-.647,-2.221,-.325),vec4(-.438,-.366,1.747,1.465),vec4(-.334,-.303,-.466,.182),vec4(-.187,.540,1.466,-.034),vec4(1.276,1.100,1.219,.904),vec4(.356,.369,1.907,-1.819),vec4(.865,-.271,-1.011,-2.073),vec4(-1.370,-.573,-1.099,-.461),vec4(-.370,-.093,-.532,1.211),vec4(-.792,-.018,.050,.510),vec4(-1.276,.454,1.667,-1.502),vec4(.782,-.874,1.310,.725),vec4(.519,.215,1.863,-.661),vec4(-1.155,-1.630,1.010,.555),vec4(.168,-.718,-2.643,.561),vec4(2.043,2.077,-1.900,1.439),vec4(1.104,-.506,.817,-2.026),vec4(1.467,.689,.269,-1.284),vec4(2.262,.220,.715,.262),vec4(2.077,.268,-.171,-.691),vec4(.270,.461,-1.182,-.562),vec4(.591,.376,-.792,-.193),vec4(-.463,-.523,.106,-.786),vec4(-1.152,-.241,-.063,-.798),vec4(.223,.185,-.375,-.007),vec4(-.314,-2.054,.185,.491),vec4(-.355,-.933,1.458,.613),vec4(-.583,-1.031,-2.038,.317),vec4(-.298,-1.863,-.520,1.150),vec4(2.596,-.003,-2.146,-1.430),vec4(-.385,-.845,-.938,-1.015),vec4(2.466,-.747,-1.086,1.016),vec4(2.182,-.712,.613,1.088),vec4(1.397,.790,1.197,-1.111),vec4(-.849,.124,-1.208,-1.559),vec4(-.880,-.197,-1.746,-.385),vec4(-1.439,-.384,1.632,-4.294),vec4(-3.117,-.605,1.775,-1.586),vec4(-.774,-.597,.350,.478),vec4(.595,-.929,-1.235,3.180),vec4(.031,-.830,.361,1.116),vec4(1.067,-.121,1.222,-.612),vec4(.493,-.699,-.228,-1.498),vec4(3.046,.123,-.806,-.541),vec4(-.399,-.968,-.575,.280),vec4(.752,.781,-1.272,-1.121),vec4(-.614,-.026,-1.153,.264),vec4(-.320,.630,-1.152,-1.017),vec4(-.506,-.800,-.859,-.151),vec4(.759,-.879,-.222,-.099),vec4(.762,-1.772,-.535,-.270),vec4(-.077,-.611,-.136,.990),vec4(.488,.106,-1.014,-.203),vec4(.888,.269,-.455,-.189),vec4(.713,.502,.352,-1.134),vec4(.030,.389,.047,-.386),vec4(1.016,.942,-.727,-.205),vec4(-.117,-1.695,.022,1.242),vec4(.141,-1.480,-.101,-.889),vec4(1.065,-2.539,-.498,.065),vec4(-1.155,.296,-.085,-1.865),vec4(-.570,.294,-1.326,-.330),vec4(1.367,-.546,.662,1.160),vec4(.740,-1.211,-.293,2.101),vec4(-.590,.101,.825,-1.095),vec4(-1.734,-1.779,-.737,.245),vec4(-.402,-2.622,.790,-.901),vec4(-1.461,-1.353,-1.280,.280),vec4(-2.324,-.458,-.793,1.026),vec4(.246,.504,.452,.453),vec4(.534,-1.020,.237,-1.758),vec4(.528,-.297,1.098,2.289),vec4(.731,-.099,1.124,-.188),vec4(-1.495,1.321,.950,1.798),vec4(-1.089,1.209,3.289,1.195),vec4(.609,-.312,1.434,.351),vec4(1.422,-.265,.088,.889),vec4(1.679,-1.277,.118,.350),vec4(.881,-1.077,-.454,-.754),vec4(-.736,.034,-.136,-1.154),vec4(.762,-.832,-.445,-1.237),vec4(2.428,.099,.801,-.486),vec4(.704,-1.040,.082,-.467),vec4(-.545,-.470,-.642,.437),vec4(1.369,-.228,.097,-.805),vec4(.827,-.868,-.754,-.128),vec4(.532,-.615,-.428,-.004),vec4(-.603,-.615,-.666,-.227),vec4(1.551,1.268,-1.061,1.096),vec4(2.311,.357,-.584,-.271),vec4(1.540,.399,.048,-1.434),vec4(1.346,-.022,-.587,-.117),vec4(.525,-.731,-.896,-1.383),vec4(.471,.391,-.620,-.485),vec4(1.260,.194,-.791,-.354),vec4(2.219,-.154,.264,-1.855),vec4(1.340,-1.833,-1.303,.616),vec4(-.184,-1.202,-.309,.611),vec4(1.097,3.956,.676,-1.442),vec4(1.867,.342,-.210,-1.681),vec4(1.519,1.525,1.271,-.604),vec4(.199,2.807,-.209,-.649),vec4(-.480,-.935,.043,.045),vec4(.317,-2.878,.982,1.498),vec4(-1.275,-1.047,-1.319,1.854),vec4(.368,-1.709,-.534,1.485),vec4(1.248,.585,-.675,.149),vec4(-.826,-.356,.203,1.488),vec4(-.231,-.031,-1.064,.071),vec4(-.368,-.437,.017,-.432),vec4(-.411,-.316,-.271,-1.311),vec4(-.404,-.105,-.332,-1.419),vec4(1.078,-.214,.211,-1.829),vec4(1.049,-.497,.079,.564),vec4(1.536,-.076,-.393,.576),vec4(-.261,.025,-.458,-.104),vec4(-.012,.031,-.355,-.213),vec4(-.910,-.988,-.201,-.265),vec4(.317,-1.128,-.966,.915),vec4(-.350,-1.501,-.456,-.323),vec4(1.139,1.176,1.195,-1.671),vec4(1.766,-.329,-.169,1.101),vec4(1.585,-.193,-.509,.097),vec4(2.185,.379,-1.082,1.320),vec4(1.974,-.070,-.562,-.190),vec4(1.205,-.069,-.679,.065),vec4(.759,-.787,-.086,.240),vec4(1.063,.126,-1.018,-.792),vec4(-1.120,.551,.366,-2.726),vec4(1.640,-.021,-1.179,.943),vec4(.434,-.046,.258,1.434),vec4(-.167,.383,-.266,-.027),vec4(1.464,.608,1.115,-1.228),vec4(1.055,.006,.975,-2.209),vec4(-.913,-.601,1.060,-1.108),vec4(.968,.066,-.269,-.849),vec4(.490,-.202,-.291,-.167),vec4(.088,-1.818,-3.071,2.064),vec4(.681,.514,-.261,-.755),vec4(-.315,-.952,.514,-.486),vec4(.887,-2.067,-.332,-.662),vec4(.201,-.458,-.325,1.078),vec4(-.715,.353,-.170,.038),vec4(.331,.069,-.601,.853),vec4(-.425,-1.189,.080,-.096),vec4(1.391,-.944,.171,-.068),vec4(-.354,.287,-.067,1.766),vec4(-1.329,-.603,-1.607,2.240),vec4(-1.764,-.438,-.859,.236),vec4(-.106,-1.345,-.643,.689),vec4(-1.639,-1.606,.660,-.971),vec4(-1.344,-.770,.895,-1.317),vec4(.431,-.901,-.345,.479),vec4(.791,-.590,-.391,.145),vec4(1.481,-.069,-.078,-.688),vec4(1.017,-.366,-.285,.215),vec4(1.214,-1.141,-.134,1.142),vec4(.164,-.183,-.178,.299),vec4(.513,-.036,-.500,-.213),vec4(-.755,-.557,-.237,-.081),vec4(.236,.402,.880,-1.056),vec4(1.157,-.085,.901,.071),vec4(.824,.528,.793,-.544),vec4(.504,.542,.529,.162),vec4(.226,.319,.792,-.418),vec4(-.734,-.720,.273,-1.670),vec4(.236,.188,-.365,-.485),vec4(2.551,-.515,.668,-.183),vec4(-.470,-.275,-1.571,.657),vec4(-.589,-.347,-.593,.161),vec4(-.819,.051,.763,-1.597),vec4(1.161,.980,.125,-.865),vec4(.253,1.073,-1.123,-.679),vec4(-1.004,-.469,-.875,-1.179),vec4(-1.455,.398,-1.276,-1.944),vec4(-2.010,-.326,.891,-1.627),vec4(.454,-.723,1.101,-.985),vec4(-.599,-.342,-.331,.303),vec4(-.460,.319,.578,.007),vec4(-2.074,.044,1.197,-.719),vec4(-1.671,-.142,.031,.437),vec4(-2.198,.027,.344,.186),vec4(.247,-.617,-.401,2.388),vec4(-3.001,.018,-.098,.121),vec4(-.792,-1.327,.471,-.113),vec4(2.021,.053,-.399,.752),vec4(.942,-.502,-.908,.122),vec4(1.546,-.254,-.684,-1.029),vec4(1.635,-1.399,-.968,-.252),vec4(.230,-.524,.160,-.076),vec4(.513,.560,-.544,.044),vec4(1.231,1.171,1.123,.018),vec4(.436,-.590,-.081,.089),vec4(1.152,-1.107,-.783,.230),vec4(.443,-.685,-.707,-.106),vec4(.512,-.103,-1.297,-.161),vec4(.504,-.037,-.321,-1.792),vec4(-.564,.076,-1.229,.446),vec4(.563,.208,.805,.628),vec4(4.930,.868,-2.007,.546),vec4(-.422,-1.231,.058,-1.479),vec4(-.167,-.099,-.137,1.347),vec4(-.600,.314,1.174,-1.791),vec4(-.114,-.006,.398,.572),vec4(-.387,-.755,-.709,-.201),vec4(1.297,1.194,-.114,-.739),vec4(1.573,.732,.436,-.296),vec4(3.949,.519,1.320,.135),vec4(.517,-.321,.611,-1.267),vec4(1.519,.387,-.536,-1.274),vec4(-1.267,1.281,-1.294,-2.931),vec4(-3.721,-.762,-.643,.204),vec4(-1.058,-2.522,-.448,-.195),vec4(-1.812,-2.561,1.394,2.514),vec4(-1.893,-1.224,1.393,.188),vec4(-4.118,-1.574,1.115,-.668),vec4(1.433,-.653,.498,1.096),vec4(.912,.429,1.282,-.073),vec4(-.285,1.412,.458,-.098),vec4(.214,-.218,.988,-2.534),vec4(.367,.122,.270,-.837),vec4(1.643,-.086,-.111,.358),vec4(-.461,.530,.794,-1.133),vec4(.918,1.331,.387,.754),vec4(-.105,1.173,.317,-.028),vec4(.497,.924,-.863,-.369),vec4(.871,-.716,-.149,-.846),vec4(.646,.013,.049,-.012),vec4(.765,-.352,-.444,-.268),vec4(1.276,-.721,.126,.330),vec4(-.180,1.402,-.608,.331),vec4(-2.979,.609,-.058,-1.734),vec4(-.830,-.328,.989,-.415),vec4(-.841,-.502,1.339,-.756),vec4(.137,-.549,1.108,-.107),vec4(-.588,-1.231,.629,-.178),vec4(1.132,-1.304,-.436,-.685),vec4(1.411,-.558,-1.031,-.664),vec4(.083,.516,-.688,-.894),vec4(.563,-.574,-.656,.602),vec4(.894,1.011,-.525,.779),vec4(-.441,-1.035,.892,.069),vec4(-.387,-1.098,.366,.720),vec4(-1.108,-.447,.281,-1.025),vec4(-2.440,-3.815,-1.604,1.180),vec4(-2.199,-1.652,1.386,-2.319),vec4(.394,-.155,-.126,.019),vec4(.064,.174,.140,-.441),vec4(1.930,1.633,-1.435,1.167),vec4(-.682,.437,.048,.298),vec4(-.474,.395,.414,.289),vec4(.191,-.414,-.231,-.537),vec4(.279,-.670,.547,.047),vec4(.167,1.047,.164,.004),vec4(1.709,1.543,-2.214,1.355),vec4(-1.469,-2.512,-2.168,1.040),vec4(.026,-.987,-3.541,2.181),vec4(.223,-.058,-.205,-1.524),vec4(-.229,1.455,.419,-1.777),vec4(1.731,.722,.120,-.395),vec4(.061,.655,.097,-1.846),vec4(.235,1.339,1.014,-1.810),vec4(1.110,.040,-.286,-.074),vec4(1.075,2.206,-2.912,-.429),vec4(-1.017,.580,-.302,.051),vec4(-.051,1.271,.132,-.522),vec4(-.705,.387,.470,.181),vec4(.290,-.205,-1.188,-.129),vec4(.703,-.344,-1.189,1.317),vec4(-.391,-.804,-1.100,1.459),vec4(-.002,-.881,1.215,.468),vec4(-.636,-.577,.866,.429),vec4(-.108,.689,-.453,-.056),vec4(.101,1.281,-.094,1.422),vec4(.925,.340,1.503,.554),vec4(-.044,-.598,1.183,-.521),vec4(-1.266,-2.889,-1.626,3.259),vec4(-2.342,-2.035,-1.182,.199),vec4(-1.588,-.378,-.290,.055),vec4(-1.353,-3.026,-1.901,.645),vec4(.750,-.036,-.026,.802),vec4(2.013,-.993,.934,.589),vec4(.771,.166,.660,-1.288),vec4(-.299,-.327,1.792,-1.485),vec4(.037,.176,.243,-1.875),vec4(.174,.884,-.955,2.186),vec4(1.398,1.152,2.322,-.114),vec4(.867,1.079,1.259,-2.132),vec4(2.760,-.003,.343,-1.261),vec4(.484,.930,-1.324,-.346),vec4(-.165,-1.024,.348,-.880),vec4(.727,.253,.453,-2.781),vec4(-1.503,-.269,.983,-2.576),vec4(.021,-.758,-.559,-2.078),vec4(-.189,-.268,-.891,-.716),vec4(-2.961,-2.131,-1.669,1.023),vec4(-.353,.014,-1.195,-.972),vec4(-1.692,.003,-2.066,-.578),vec4(.038,.060,-.784,-.188),vec4(-1.098,-.412,-.721,.936),vec4(-1.148,-.537,-.262,.314),vec4(.269,-.649,.042,.630),vec4(.944,-1.515,-1.017,.943),vec4(-.735,-1.655,-.141,-.896),vec4(.448,-1.345,.879,.687),vec4(-.251,-.900,-.355,2.467),vec4(.127,.176,.409,.095),vec4(.145,-.519,1.213,-.565),vec4(.330,-1.138,1.914,-1.383),vec4(-1.768,-1.930,-.231,.251),vec4(.554,-1.384,.886,-.594),vec4(-.933,-.327,.250,-.395),vec4(-1.491,-1.963,.630,-.823),vec4(-.263,.987,-.106,-.988),vec4(.075,.437,.927,.565),vec4(.104,-.089,-.977,-.945),vec4(-.804,-.836,.434,-1.058),vec4(-.423,-.181,-.169,-1.527),vec4(-2.179,-.813,-.459,.613),vec4(-.670,.401,.285,1.267),vec4(-.523,.718,-.652,-.251),vec4(-1.639,-1.985,-2.083,-2.285),vec4(-4.327,-.116,1.363,.932),vec4(-.831,2.350,.128,2.758),vec4(1.543,2.051,-.230,1.774),vec4(-.305,1.572,-.381,1.425),vec4(.482,1.450,-1.126,.371),vec4(2.801,3.281,-1.779,1.794),vec4(-.843,-.942,1.288,-.646),vec4(-.263,.750,-.763,-.395),vec4(-.690,.340,.192,-.314),vec4(-.040,-.092,-.685,-.018),vec4(.166,-.693,-1.064,.746),vec4(-.020,-1.144,-1.225,.992),vec4(-.212,-1.927,-.009,-.332),vec4(1.560,-2.397,.259,-1.065),vec4(.274,-1.206,-.380,.586),vec4(.333,-1.690,.227,.955),vec4(-.754,-1.033,-.518,1.522),vec4(-.069,-.446,.798,-.035),vec4(.450,.732,.308,.903),vec4(.379,.211,.334,.433),vec4(-1.178,.072,.655,-.521),vec4(-.372,.128,.455,-.957),vec4(.235,1.305,1.800,1.478),vec4(-1.572,-.962,.693,-.037),vec4(-.215,-.063,.243,.591),vec4(.466,.469,2.396,1.436),vec4(-.299,-.257,.924,2.043),vec4(-.203,-1.294,1.099,2.634),vec4(.524,1.409,-.598,.154),vec4(-1.827,3.049,-.403,-1.394),vec4(-.628,1.726,.069,-.843),vec4(.695,.370,.983,1.516),vec4(1.187,-.096,-1.060,-.390),vec4(.665,-.081,.260,.497),vec4(.409,.917,.654,1.791),vec4(-.343,.260,-.727,-1.238),vec4(-1.160,-.250,-.492,1.094),vec4(-4.875,.659,-2.695,2.518),vec4(-1.913,2.631,.130,.093),vec4(.241,1.985,1.557,-.862),vec4(-.475,.465,-.357,1.053),vec4(-.616,-.185,.113,-.498),vec4(.183,.044,-.095,.155),vec4(-.040,-.440,-.101,.477),vec4(-.389,-1.522,.468,-.613),vec4(-.753,-.451,-.026,-.561),vec4(.177,-.055,-.332,.174),vec4(1.326,-1.572,-1.373,1.043),vec4(-.485,.214,1.419,1.454),vec4(.312,-.100,.219,.444),vec4(-1.583,.491,.564,1.132),vec4(.125,-.079,.804,1.130),vec4(-.802,-.305,.934,-.515),vec4(-.345,-.827,.715,-1.462),vec4(.246,-.584,.940,.039),vec4(-1.160,.328,.097,-.583),vec4(-.305,.732,.444,-.561),vec4(-1.152,.813,.590,-.972),vec4(-.396,-.421,-.116,-.840),vec4(-1.097,-1.851,-1.394,.781),vec4(1.855,-1.161,1.688,.666),vec4(.858,-1.485,-.345,.922),vec4(-.166,-.790,.582,1.222),vec4(.380,-1.200,.202,-.398),vec4(.075,.029,-.094,-1.507),vec4(.348,.107,-1.044,-1.386),vec4(-.375,-.647,-.998,-1.089),vec4(-1.448,.523,.215,-.950),vec4(1.064,.530,-.901,1.121),vec4(-3.234,-.481,.071,-.514),vec4(-3.732,.537,.726,-1.657),vec4(.135,2.610,2.456,5.453),vec4(.817,1.532,.014,.596),vec4(-.202,.399,.054,-.269),vec4(.167,.007,-.496,.208),vec4(.669,.408,-.619,.522),vec4(-.370,.181,-.566,.930),vec4(-.416,-.124,.963,-.350),vec4(.228,-.269,-.363,.714),vec4(-.481,-.184,-.555,.989),vec4(-.968,.544,-.699,.510),vec4(.157,.568,-.107,.541),vec4(.228,-.223,-.291,.060),vec4(.644,-.239,.121,.274),vec4(.016,.129,.673,.300),vec4(-.467,-.404,.909,.176),vec4(-.411,1.212,-.603,-.601),vec4(-.521,.903,1.029,-.955),vec4(.196,.784,1.537,-.604),vec4(-.104,-.337,.619,-.540),vec4(-.640,-.695,-1.117,.627),vec4(1.066,-.231,-.985,.905),vec4(-1.039,-.420,-.330,.533),vec4(1.090,-.345,.538,-.498),vec4(.147,.426,.446,-1.188),vec4(.438,.232,-.751,.408),vec4(1.316,-1.111,-.528,.360),vec4(.416,.534,-.471,-.378),vec4(1.425,1.189,-.885,.546),vec4(1.083,-.388,.124,-.137),vec4(1.321,1.161,-.964,-.476),vec4(-.891,-.495,-.672,.318),vec4(-2.575,-.806,.027,-.141),vec4(-1.173,1.648,1.097,-.824),vec4(2.181,.132,.593,1.257),vec4(.271,-.294,-.007,-.366),vec4(-.070,.178,.242,.086),vec4(-.232,.384,.139,.005),vec4(-.324,.284,.126,.631),vec4(.326,.099,.640,.208),vec4(-.340,-1.354,.332,-.211),vec4(-1.167,-.088,-.002,.114),vec4(-.286,.877,-.257,-1.180),vec4(.633,.577,-.478,.117),vec4(1.261,-.199,-.973,1.001),vec4(.530,-.929,-.669,-.065),vec4(.508,-1.420,.272,-.709),vec4(-.034,-.241,.667,-.212),vec4(-.063,.431,.162,-.758),vec4(-.425,.427,-.506,.526),vec4(-.409,-.099,.540,-.366),vec4(-.027,.205,.233,-.078),vec4(.417,-.330,-1.501,.542),vec4(.668,-.427,-1.165,1.007),vec4(.577,-.127,-.282,.083),vec4(-.355,.144,.409,-1.001),vec4(.741,-.862,-1.354,-.324),vec4(-.588,-.164,.577,-.290),vec4(1.064,1.534,-.113,-.095),vec4(.719,.263,-.392,.012),vec4(-.004,-.295,1.301,-.609),vec4(.785,.048,-.412,-.975),vec4(-1.120,-1.119,-.502,-.621),vec4(-1.806,-.448,-.698,-.502),vec4(-.224,-.273,-.193,.830),vec4(-.662,1.063,-.549,2.937),vec4(-.697,-1.033,-2.554,1.704),vec4(.230,-.285,-.677,-.009),vec4(-.316,-.638,-.310,.045),vec4(-1.351,-.825,.002,-.159),vec4(.033,.381,.217,.659),vec4(-.548,-.181,-.134,.477),vec4(-.245,-.170,.120,.493),vec4(.582,-.115,-.660,-.313),vec4(-1.097,-.052,-.573,-.526),vec4(1.349,-.223,-1.005,.718),vec4(1.411,.121,-.524,.004),vec4(1.280,-.967,-.616,.438),vec4(-.130,-1.664,.014,1.764),vec4(-.723,-.575,.670,.394),vec4(-.719,.420,.705,-1.585),vec4(-1.227,-.521,.611,-.671),vec4(-1.358,-.140,.957,-1.484),vec4(-.882,-.025,.729,.137),vec4(.595,.701,.250,-.900),vec4(.300,.244,-.131,-.547),vec4(-.278,-.246,-.055,-.375),vec4(-.713,.258,.219,-.501),vec4(.526,.133,-.394,.034),vec4(1.093,.271,-.737,-.374),vec4(.504,-.630,-.273,.688),vec4(.749,.849,-.295,.423),vec4(-.511,-.492,-1.275,.141),vec4(1.234,.894,.416,-.773),vec4(-1.429,-.414,-.950,-1.252),vec4(-1.505,.288,-.224,-1.288),vec4(-1.727,.739,-2.709,-.819),vec4(-.511,-.614,-.936,5.032),vec4(.935,.045,-1.800,1.867),vec4(-.923,.667,-1.512,.515),vec4(-.586,.076,-.361,.042),vec4(.156,.406,-1.085,.532),vec4(-.180,-.371,-.593,.941),vec4(1.019,.356,-.456,.673),vec4(.290,-.376,-.652,.433),vec4(.649,.031,-1.055,-.102),vec4(.407,.159,-.840,-.180),vec4(.301,-.595,-.465,-.472),vec4(.427,-.920,-.550,1.140),vec4(.963,-.219,-.217,.167),vec4(.074,-.058,-.111,.641),vec4(-.608,-.524,.587,.683),vec4(1.297,1.078,-.812,.689),vec4(-.904,.460,.790,-1.095),vec4(-.192,.915,-.143,-.649),vec4(-.260,.258,.500,-.012),vec4(-.315,.113,-.338,-.380),vec4(-.432,-.225,.464,-.930),vec4(.613,-.585,-.310,-.440),vec4(.166,-.439,-.485,.907),vec4(-.487,.147,-.256,-.581),vec4(-.570,-.219,-.152,-1.055),vec4(.200,-.281,-.269,-.111),vec4(-.411,-.081,.834,-.293),vec4(.375,.187,.205,-.495),vec4(.400,-.134,-.228,-1.197),vec4(.824,1.458,.424,1.620),vec4(-.018,.456,.528,-.325),vec4(-.742,-.484,-1.050,-1.147),vec4(3.079,2.176,5.339,3.001),vec4(1.161,1.060,-.913,-.450),vec4(.181,-.046,-.501,1.394),vec4(-.390,-.046,-.666,.499),vec4(-.454,-.749,-.902,.877),vec4(-.239,-.024,-1.003,.874),vec4(.783,.386,-1.209,.768),vec4(.046,.241,-.719,-.728),vec4(.634,-.094,-.732,-.283),vec4(.848,-.909,-.542,-.681),vec4(.566,-1.067,-1.027,1.935),vec4(.164,-.643,-.798,.803),vec4(.901,.639,.492,-1.537),vec4(-.884,-.225,-.157,.291),vec4(.646,-.208,.107,.674),vec4(-.091,-.212,-.586,-.028),vec4(-.715,1.157,-1.149,.411),vec4(-1.038,-.104,-.174,.274),vec4(.600,-.926,.682,.028),vec4(-.043,.060,1.274,.271),vec4(-.975,-.764,.359,.538),vec4(.438,.310,.984,-.701),vec4(.211,.597,.183,-.454),vec4(-.373,.852,.790,-.744),vec4(-.511,1.005,.130,-.832),vec4(.154,.393,-.164,-.233),vec4(-1.027,.296,.290,-.497),vec4(-.544,-.059,.233,-1.348),vec4(-.128,-.946,-.298,-.695),vec4(1.351,.211,-1.035,-.042),vec4(-3.902,-.013,1.076,-.562),vec4(.831,.433,1.375,.279),vec4(-2.744,5.138,4.780,-.815),vec4(2.247,.872,-.332,.379),vec4(-.248,-.153,-.742,-.136),vec4(.921,.690,.699,-.735),vec4(-1.311,-.701,1.164,.067),vec4(.053,1.084,.774,-.978),vec4(-.578,.478,-.316,-1.009),vec4(.003,.416,.233,-1.544),vec4(.786,-.251,-.281,-.817),vec4(.929,-.714,-1.194,1.329),vec4(1.650,-.234,-.810,.367),vec4(1.429,.116,-.472,.136),vec4(1.152,.057,-.849,-1.828),vec4(1.395,-.405,-.532,-.807),vec4(.328,-.066,-.131,.269),vec4(-.106,.599,.106,-.365),vec4(-.323,.909,.475,-1.450),vec4(-.472,.733,.273,-.148),vec4(.841,.365,.058,.574),vec4(.021,.307,1.113,.063),vec4(1.148,.191,-.110,-.272),vec4(-.853,.042,-.128,-1.578),vec4(-.740,-.367,-.048,-.256),vec4(.694,-.437,-.657,1.151),vec4(1.037,-.100,-.359,-.178),vec4(-.771,-.112,-.286,.307),vec4(-.216,.158,.394,.441),vec4(-.477,.025,-.480,-.021),vec4(-.552,-.417,-1.483,.490),vec4(-1.120,.302,-1.469,-.196),vec4(-2.784,-3.275,.538,-.292),vec4(2.231,1.368,-2.264,.677),vec4(.041,.992,1.558,-1.418),vec4(1.160,.095,-2.505,-1.728),vec4(.081,-.379,-.534,-1.251),vec4(-.706,-.774,.449,-2.062),vec4(-1.051,.610,-.111,-1.269),vec4(.136,.314,-.854,-.411),vec4(-.528,.193,-.328,-.211),vec4(.476,.088,-.655,-.566),vec4(.181,.019,-.428,-.027),vec4(.673,.329,-.792,.006),vec4(1.141,-.155,-1.001,-.352),vec4(2.216,.092,-.531,-.665),vec4(1.366,-.041,-1.148,-.567),vec4(-.023,.055,.531,-.212),vec4(-.027,-.129,.040,-.059),vec4(-1.960,-.173,-.306,-.536),vec4(-.845,1.280,-.204,-.221),vec4(.907,1.164,.835,-1.006),vec4(.200,.652,-.020,-1.168),vec4(.157,-.312,-.503,-.123),vec4(.713,.221,1.203,-.438),vec4(.515,.585,.494,-1.397),vec4(.055,.313,-.973,-1.076),vec4(.124,-.198,-.731,-.738),vec4(-.472,-.707,-.193,1.815),vec4(-1.282,-.096,-.301,.928),vec4(.790,-.238,-.537,.476),vec4(-.626,-.538,-1.401,.808),vec4(-1.084,-.061,.445,-.274),vec4(-.559,.324,-.226,-.126),vec4(-1.843,-1.114,2.807,-3.132),vec4(-.927,-3.293,-.101,-1.720),vec4(1.007,.517,.030,-.001),vec4(.507,-.024,-.993,-1.468),vec4(-.312,-.302,-.722,-.631),vec4(-.834,-1.349,.007,-1.113),vec4(-.555,1.112,-.699,.084),vec4(-.034,.490,-.283,-2.259),vec4(.799,.138,-.481,-.466),vec4(.166,-.473,-.548,.589),vec4(-.928,-.255,-.125,.374),vec4(.517,.639,-1.015,-.583),vec4(2.272,-.047,-.230,-.285),vec4(2.004,.596,.344,-.929),vec4(.718,-.187,.033,-.270),vec4(.098,.460,-.726,.312),vec4(.654,-.457,-.278,1.413),vec4(-.489,-.190,-.441,.159),vec4(-1.170,.442,-.566,.820),vec4(.813,.698,1.368,1.383),vec4(.212,.915,.235,-1.762),vec4(-.229,-.167,-.292,-.377),vec4(-.529,-.064,.895,-.106),vec4(.693,.529,2.080,.833),vec4(.554,.071,.582,.083),vec4(-.034,-.169,-.670,-1.687),vec4(-.113,-.520,-1.272,-.071),vec4(-.342,-.316,1.232,.181),vec4(.553,-.440,-.764,1.917),vec4(-.058,.597,-1.990,-.887),vec4(-.630,-.838,.718,-.667),vec4(-.333,-.031,-.575,.148),vec4(.430,-.813,1.032,-.124),vec4(.343,-1.134,-.892,-.035),vec4(.058,-.608,2.169,-.249),vec4(.952,-1.654,-.986,.096),vec4(-.307,.038,-.719,.010),vec4(-.874,1.408,-1.940,-.379),vec4(1.897,.843,-.087,.087),vec4(-.456,.684,.826,-2.437),vec4(1.632,-.292,-.561,.959),vec4(-1.238,.577,.229,.002),vec4(-.200,.267,.015,.157),vec4(-.862,-.219,-.606,1.204),vec4(-1.374,.082,.055,-.458),vec4(1.015,.241,1.211,-.246),vec4(-.395,-1.374,1.116,-.089),vec4(-.958,.216,-.941,.272),vec4(-.758,.535,.747,.005),vec4(1.471,.092,-.283,-.312),vec4(-1.727,.635,-.008,-1.255),vec4(1.511,.261,1.114,.599),vec4(.108,.168,.847,-.347),vec4(.982,1.166,.372,.162),vec4(-.482,.635,.598,-1.113),vec4(-.850,.200,.421,-.061),vec4(-.578,-.835,-1.079,-1.082),vec4(-.550,.112,.533,.528),vec4(.173,-.482,1.161,-.546),vec4(-.730,.032,-.287,1.371),vec4(-1.521,-1.847,-.228,-1.700),vec4(-.883,-.962,-2.489,.760),vec4(-.633,.005,.334,1.069),vec4(2.088,-.462,-1.577,-1.790));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed0[idx];\n}", "buffer_a_inputs": [], "buffer_b_code": "const vec4 embed1[1024] = vec4[](vec4(.255,-2.904,-1.530,-.630),vec4(.178,-1.281,-1.063,-.060),vec4(1.165,-.734,-1.347,-.090),vec4(.714,-1.149,-.427,-.722),vec4(3.159,-1.389,1.472,-3.701),vec4(-3.704,4.504,-8.493,-2.826),vec4(5.624,.499,3.461,1.463),vec4(1.309,-.015,.492,2.679),vec4(1.958,-2.222,.057,-.201),vec4(-.815,-1.909,-1.094,-.803),vec4(.282,2.636,-.343,.571),vec4(1.950,.194,-2.784,-.564),vec4(-1.197,-.749,-1.417,-2.123),vec4(1.809,-.586,1.111,.317),vec4(1.036,-.961,-1.831,-.402),vec4(1.726,2.945,.720,.109),vec4(2.282,.676,1.265,.650),vec4(-.412,2.707,-.980,-2.219),vec4(-1.279,.890,-.459,-2.663),vec4(2.287,-.763,3.175,.953),vec4(-1.059,1.794,-5.088,.679),vec4(4.338,.763,-.824,-2.392),vec4(-.480,-.232,.116,3.003),vec4(-.217,.787,-1.723,-2.692),vec4(-.014,-1.931,-.095,-2.908),vec4(1.367,-1.446,-.726,.110),vec4(.006,-.209,.628,1.557),vec4(.669,1.037,.205,-.108),vec4(.204,-.662,-1.032,-.815),vec4(.569,-3.470,-1.030,-.709),vec4(1.243,-2.336,-.576,.880),vec4(.357,-1.221,-1.924,-1.730),vec4(-.121,-.873,-1.060,.004),vec4(.057,-.890,-.865,-.349),vec4(.501,-1.220,-.868,.362),vec4(2.026,.407,-.528,-1.050),vec4(-1.090,-2.580,3.031,.421),vec4(-4.305,-1.299,-.447,4.420),vec4(-.133,.519,-1.396,-1.700),vec4(.944,.200,.135,-.011),vec4(.706,-1.476,-.820,.043),vec4(.721,-1.377,.365,1.031),vec4(-1.995,1.020,.070,-.610),vec4(.678,-.108,-2.056,.097),vec4(-.122,-2.156,-.481,-1.181),vec4(-.247,-.844,-.947,.718),vec4(.502,-.211,-.880,.153),vec4(-.085,2.518,-.806,-.207),vec4(-.805,1.209,.344,-.710),vec4(.632,3.487,1.676,-1.533),vec4(.157,3.136,-2.368,-2.254),vec4(.538,-.842,1.711,-.933),vec4(-.166,.821,-3.373,-.160),vec4(.962,-.048,.530,.233),vec4(-.092,-.958,-.147,2.242),vec4(-.421,-.156,-.823,-1.482),vec4(.237,.057,.573,-1.332),vec4(2.074,-.154,.842,.272),vec4(.270,.441,-.953,-1.323),vec4(1.314,1.161,.616,.132),vec4(1.199,-2.305,-.243,1.301),vec4(3.203,.482,-.952,-1.736),vec4(1.467,-.913,2.341,.185),vec4(.324,.380,.636,.706),vec4(1.413,-1.299,-.828,.376),vec4(1.886,-1.290,-.741,-.198),vec4(1.210,-1.312,-.850,-1.744),vec4(2.039,-.033,1.073,-2.310),vec4(1.950,2.664,-1.324,-4.485),vec4(2.882,1.338,-1.000,-4.809),vec4(-1.552,-.534,-.200,-.217),vec4(-.021,.865,-.176,-1.298),vec4(1.272,-.626,1.089,-1.521),vec4(-.073,.138,-1.147,.138),vec4(-1.103,1.438,-3.340,-.407),vec4(-2.860,-.613,-.610,-.239),vec4(2.971,-.238,-.962,3.149),vec4(-2.622,-1.173,-.783,-.072),vec4(.094,-.028,-.499,.308),vec4(.163,1.569,.487,.147),vec4(-.566,2.097,1.522,.290),vec4(-1.271,.960,.355,-1.219),vec4(.049,2.096,.472,-2.126),vec4(-.064,-.558,-.906,-.563),vec4(.276,3.004,-2.993,-2.821),vec4(.194,-2.769,1.999,-2.412),vec4(.993,1.233,.052,-.061),vec4(-.089,.098,-1.105,.710),vec4(.823,-.693,1.277,.478),vec4(-1.546,.294,.577,-2.305),vec4(.898,.000,-1.188,-1.999),vec4(.180,.632,.638,1.470),vec4(.905,-.996,1.110,.927),vec4(-1.371,-1.939,-1.772,-.806),vec4(1.338,.468,-1.358,-.329),vec4(-.126,-.645,.035,.184),vec4(1.239,-1.051,-1.211,-.583),vec4(1.922,-2.937,-.198,-.892),vec4(1.704,-3.662,-2.361,-.056),vec4(1.250,-1.210,.632,-2.153),vec4(.528,-4.548,-1.521,-.660),vec4(2.599,-2.698,1.735,-.970),vec4(.551,-1.368,-.765,-.033),vec4(-1.427,.080,-1.701,1.182),vec4(-.704,-.810,.564,-.802),vec4(.639,-1.385,.796,.876),vec4(-2.717,-.859,-1.578,-.957),vec4(-2.353,-2.442,.002,.662),vec4(2.188,1.058,-.798,.745),vec4(-1.516,.524,.978,.106),vec4(-.482,.267,1.114,1.971),vec4(-.810,.991,.239,.401),vec4(-1.056,.957,.326,.306),vec4(-.923,1.241,.614,-.623),vec4(-.402,1.902,1.149,-.393),vec4(-.525,.773,.338,-1.547),vec4(-.805,3.823,-1.011,-.475),vec4(-.054,-.846,1.233,-.506),vec4(2.596,2.129,.129,.174),vec4(2.486,1.026,.164,3.338),vec4(.567,-.641,.563,-.574),vec4(-.726,-1.036,-.151,-1.760),vec4(-2.333,-.188,-1.980,-2.077),vec4(.720,-.535,-1.111,-.523),vec4(-1.061,-1.106,.802,-1.867),vec4(-1.019,-.226,.033,-1.788),vec4(-.716,-.881,-.849,-.622),vec4(.960,-.139,.327,2.362),vec4(1.385,-.616,-.848,-.593),vec4(2.652,-1.329,-.373,-1.889),vec4(-.639,.965,-4.434,2.573),vec4(1.050,1.889,-2.921,1.392),vec4(-.633,-.780,-2.399,-.311),vec4(1.971,.439,-1.529,2.085),vec4(1.689,-.868,-.143,-.089),vec4(1.373,-2.113,.487,-.721),vec4(1.531,-1.127,-.813,1.445),vec4(.957,1.134,-1.693,-.090),vec4(2.015,.565,-.913,-.114),vec4(-.278,-1.871,-.872,-1.826),vec4(-.346,1.673,-.523,-.668),vec4(.414,.974,-1.169,1.436),vec4(-.799,.695,.225,.223),vec4(-1.127,1.829,1.096,1.288),vec4(-1.419,.844,.581,.286),vec4(-.641,1.278,.778,-.123),vec4(-.719,2.477,.040,-.348),vec4(-.585,1.754,1.126,-.491),vec4(-1.066,2.275,-1.881,-.275),vec4(.808,-.559,.659,-2.069),vec4(1.896,.174,.643,1.149),vec4(-2.095,-.908,-1.278,-1.359),vec4(1.033,.826,.841,.701),vec4(-.402,-.346,.774,-1.590),vec4(-.837,1.409,-1.599,-.317),vec4(1.023,.393,-.206,-.071),vec4(2.228,-1.144,.357,-3.216),vec4(-.255,-.987,-1.367,-1.719),vec4(2.657,.384,-.026,.327),vec4(.128,-.105,.020,-.288),vec4(2.595,.357,-1.137,-.993),vec4(.494,.165,-1.834,.105),vec4(-6.142,-.412,-.510,1.886),vec4(3.433,-1.679,5.480,-6.668),vec4(2.192,-1.237,-.354,-.684),vec4(1.578,-.467,.106,-1.727),vec4(1.251,1.415,.692,-1.283),vec4(.824,.867,.610,-.264),vec4(1.305,-.567,.522,.938),vec4(.127,-1.172,.760,.216),vec4(-.468,2.367,-1.969,-.813),vec4(1.864,1.132,.277,.419),vec4(-.439,2.003,.399,.437),vec4(.739,1.226,.471,1.483),vec4(-1.722,1.219,.668,.937),vec4(-1.121,1.060,.784,1.337),vec4(-1.358,.592,1.130,.118),vec4(-1.192,.988,1.588,-.346),vec4(-.445,1.792,.785,-.912),vec4(.058,1.536,.402,.232),vec4(-.480,1.803,.783,.201),vec4(-.416,1.065,-.825,-2.591),vec4(.045,-1.369,.345,-1.151),vec4(-.441,1.273,-3.499,-.732),vec4(.123,-.813,-.276,-.353),vec4(.833,.689,-.075,-1.385),vec4(-1.213,-.537,-2.054,-1.204),vec4(2.376,-1.545,-.860,.944),vec4(.721,-1.130,-1.529,.933),vec4(.083,.746,-.318,1.527),vec4(-.653,.074,-1.523,.611),vec4(-2.225,.860,-.273,-1.208),vec4(1.761,-.566,-.441,.180),vec4(1.375,-2.373,.033,-.797),vec4(3.257,1.920,.539,-4.626),vec4(3.434,.176,2.827,.690),vec4(.108,-.903,.888,-.619),vec4(.089,-.055,.940,2.159),vec4(1.086,-2.272,-3.043,1.793),vec4(-.137,-2.312,-1.381,1.037),vec4(.166,.430,-1.185,.267),vec4(-.567,-1.735,-.955,1.117),vec4(.945,2.371,.038,.731),vec4(-.235,2.127,-1.774,-.056),vec4(-.490,.414,-.222,-1.396),vec4(.045,.737,.285,.088),vec4(-.713,.877,.601,.994),vec4(-.525,1.501,1.320,-1.192),vec4(.236,1.083,1.120,-.379),vec4(-.609,-.148,.016,.796),vec4(-.167,.744,.407,-.327),vec4(.358,.905,.178,-.584),vec4(.023,.476,.513,1.198),vec4(1.176,-.001,.865,-.552),vec4(-1.042,.777,-1.459,.165),vec4(3.214,1.639,3.082,.789),vec4(.620,-.866,1.219,1.695),vec4(-.127,-.558,1.212,.580),vec4(3.004,1.435,-1.546,2.451),vec4(-.369,1.257,-1.877,1.708),vec4(-1.719,-.630,-.104,-1.636),vec4(-.826,-.707,1.565,-.252),vec4(1.643,1.101,-1.851,.202),vec4(-.781,-1.616,-.097,.593),vec4(5.739,-1.635,2.575,-5.908),vec4(-3.001,.594,-2.411,2.067),vec4(2.127,-.057,-.676,.808),vec4(-.171,-1.640,-.229,-.510),vec4(1.401,-1.497,-1.285,-.211),vec4(.013,-1.618,-.583,.148),vec4(1.659,-1.296,-.499,-.241),vec4(-.518,.369,-3.020,-2.044),vec4(1.492,.545,-2.516,.195),vec4(1.358,-1.292,-2.941,1.823),vec4(-1.057,-.773,.590,-.134),vec4(.448,2.301,-1.072,1.502),vec4(-.361,.222,-2.025,-.584),vec4(.919,.119,.576,.366),vec4(-.370,1.280,1.004,1.921),vec4(-.519,.896,1.001,-.073),vec4(.375,.657,1.520,-.343),vec4(.695,.803,.482,.146),vec4(.551,1.183,.598,-.889),vec4(-.293,.442,.478,.388),vec4(-.373,.549,1.645,-.892),vec4(1.489,.701,.003,.371),vec4(1.113,-2.022,.293,.421),vec4(1.060,1.421,.495,.845),vec4(1.237,.810,1.243,1.721),vec4(1.351,.587,.294,-1.099),vec4(-.612,-.976,.283,-2.421),vec4(.010,-.216,-1.331,-.789),vec4(.142,-.438,.295,.592),vec4(-1.609,-.733,.027,.613),vec4(.275,2.247,1.063,-.490),vec4(-.403,1.227,.501,-.599),vec4(-3.428,1.198,1.776,4.072),vec4(1.541,-.435,4.917,-1.062),vec4(1.180,-.492,-1.972,1.940),vec4(-.834,-1.615,.100,.498),vec4(-.406,-1.178,.102,.758),vec4(1.645,-2.243,.467,-.931),vec4(-.739,-1.833,-.942,-1.143),vec4(-3.162,-1.157,-.991,-1.259),vec4(.784,.209,-1.058,1.466),vec4(.455,-.913,-.664,-.153),vec4(1.637,-.346,-1.487,1.617),vec4(-1.438,1.086,.469,-3.362),vec4(.715,-1.598,-.304,-.275),vec4(1.650,.220,.223,1.323),vec4(.183,-.429,.936,-.256),vec4(.042,1.461,1.160,.470),vec4(-.281,1.328,1.523,.510),vec4(.116,.365,.107,-.329),vec4(1.140,1.604,1.150,1.044),vec4(-1.388,-.771,-.228,-.682),vec4(.558,-.384,-.041,.558),vec4(1.871,-1.016,-.539,.483),vec4(.388,.166,-1.397,-2.070),vec4(1.653,.374,-1.066,-2.461),vec4(.371,.611,-1.326,-3.186),vec4(1.309,1.136,.551,-2.147),vec4(-1.052,-.483,-1.013,-2.107),vec4(.399,-.244,.152,-.046),vec4(2.750,-1.053,-.406,.940),vec4(1.142,1.055,-.441,-1.694),vec4(1.326,1.026,1.808,-1.320),vec4(.385,-.531,.579,-1.914),vec4(.180,.266,2.969,-1.248),vec4(3.904,.242,.888,.747),vec4(-.957,-1.729,-.383,-.182),vec4(1.241,.139,-.836,-1.731),vec4(.321,-.385,.880,-1.355),vec4(-.330,-.884,-1.405,-2.121),vec4(.159,-.138,-1.687,2.144),vec4(-3.304,1.176,-.428,-.220),vec4(1.879,.867,-1.600,1.260),vec4(.228,-.748,-1.890,-.490),vec4(-.818,-.800,-.890,-1.349),vec4(-1.293,-1.356,-.537,-.390),vec4(.786,-.395,-1.141,-.629),vec4(1.020,.697,1.490,.055),vec4(-.326,.005,.486,-1.171),vec4(-.437,.530,.729,-.305),vec4(-1.010,.038,.468,.293),vec4(-.211,1.556,-.612,.719),vec4(-.414,1.002,.898,-.763),vec4(-.245,.086,-.594,.475),vec4(-.747,-2.669,-.096,-1.029),vec4(2.310,1.646,-2.322,2.532),vec4(-.446,-1.319,-1.932,1.112),vec4(1.736,-.371,-1.896,-2.433),vec4(.250,-.653,-1.288,-2.461),vec4(.444,-.404,.599,.148),vec4(.909,-1.498,.047,-.528),vec4(.177,.775,.308,.784),vec4(-2.024,.202,-1.832,-.756),vec4(-1.298,-.199,-.648,-1.195),vec4(2.614,-.501,1.199,-2.644),vec4(-.206,-1.427,.039,.175),vec4(.894,-.173,.561,.170),vec4(.861,-.417,-.093,.357),vec4(.129,-1.871,-.854,-2.680),vec4(2.043,.828,-.305,-.818),vec4(.548,-.922,-.237,-2.385),vec4(1.473,.352,-.507,.547),vec4(.340,-.559,-.280,-1.735),vec4(-2.816,-1.077,-2.518,1.899),vec4(2.384,-.022,.715,.907),vec4(3.349,1.683,-2.105,.777),vec4(1.378,.835,-.882,-.480),vec4(.022,.096,-1.712,-.341),vec4(1.773,1.747,.204,.967),vec4(-.440,.593,.110,-.246),vec4(-.143,.845,.614,-.481),vec4(-.621,1.108,.440,-.252),vec4(-1.866,-.087,.546,.499),vec4(-.649,.451,.207,.837),vec4(-.082,1.293,.540,-.996),vec4(.180,-.421,-.187,-.642),vec4(-3.600,-.817,-2.085,-1.420),vec4(3.827,.977,-1.064,3.735),vec4(1.234,-.185,-.350,.178),vec4(-.426,-.474,-1.399,-.753),vec4(.761,-.880,-.600,-.614),vec4(.456,-1.385,-1.430,1.350),vec4(.324,-.814,1.760,1.086),vec4(1.231,-.079,.694,.660),vec4(-.901,-1.478,.341,-.221),vec4(-.877,-1.462,-.992,-2.202),vec4(.372,-.940,-2.027,.475),vec4(2.224,-1.203,-.290,-1.421),vec4(.712,.569,1.311,1.267),vec4(.588,-.100,.678,-.125),vec4(-.549,-.757,-.072,-.891),vec4(-.126,-1.027,1.470,.781),vec4(1.735,-.296,.912,.754),vec4(.196,-.915,-1.038,.531),vec4(1.038,.799,-.923,.594),vec4(.657,.725,-1.155,-1.383),vec4(-.018,.315,-.497,-.690),vec4(-.901,.012,2.022,1.250),vec4(-1.278,.089,.392,1.085),vec4(-1.882,.893,.739,.413),vec4(.170,-1.262,-.709,.253),vec4(-.930,.418,2.257,.907),vec4(-.829,.458,.987,.530),vec4(-1.533,.339,-.043,.823),vec4(-1.013,.668,.859,.955),vec4(-.768,.821,.879,.906),vec4(-1.916,.614,.382,-.492),vec4(-.407,.461,.207,-2.092),vec4(-2.445,1.346,-3.476,-1.063),vec4(-.788,.327,-1.218,1.804),vec4(2.330,-.708,-1.206,2.562),vec4(1.369,.177,-.053,.997),vec4(-.655,-.701,-.934,1.072),vec4(-2.908,-1.367,.609,.058),vec4(.519,-.851,.089,2.510),vec4(.545,-.702,-1.288,.296),vec4(1.950,2.785,-1.039,-.933),vec4(-1.165,-.533,-.960,-.089),vec4(-.800,1.054,-.912,.411),vec4(-1.955,-1.046,1.448,.176),vec4(2.102,.128,-1.546,.094),vec4(2.794,.110,-.583,1.870),vec4(.421,-.973,-.997,.853),vec4(-.752,.279,-2.135,.409),vec4(.671,-2.360,-1.491,.766),vec4(1.124,-1.213,1.094,-.784),vec4(2.414,.872,1.747,-1.188),vec4(-.495,-.450,1.274,.847),vec4(-.180,.949,1.470,-.930),vec4(-1.507,1.551,.397,-1.197),vec4(-1.663,.878,-.099,-.011),vec4(-1.185,.782,.038,.298),vec4(-.547,.248,-.421,.551),vec4(-.602,.884,1.395,1.272),vec4(-1.221,.742,.534,.552),vec4(-1.550,.338,.925,.967),vec4(-.791,.538,.662,.481),vec4(-1.047,.043,.425,1.835),vec4(-.999,.048,.172,1.071),vec4(-1.051,1.101,.283,.859),vec4(-1.507,-.234,-.790,.947),vec4(-.608,1.203,.597,2.534),vec4(-1.557,1.878,-.132,1.895),vec4(-.605,1.879,1.772,-.874),vec4(-.474,.698,-.985,.177),vec4(.278,.693,1.358,-1.492),vec4(.381,2.211,-.412,-2.901),vec4(.115,1.300,-1.461,-2.085),vec4(-1.092,-.863,-1.132,-1.463),vec4(.994,1.173,-.890,.645),vec4(2.121,.243,-.574,1.328),vec4(-.140,-.666,-.783,.383),vec4(-.454,-.493,-.934,.139),vec4(-.324,-.931,-.752,.050),vec4(.292,.895,-1.321,.287),vec4(2.433,1.650,-.353,1.141),vec4(.342,.002,-.766,.213),vec4(.616,.501,-.570,-.327),vec4(-2.073,-1.340,-1.916,1.437),vec4(-.019,.230,.526,.151),vec4(-1.470,1.269,-.073,.032),vec4(-1.356,.377,.204,.682),vec4(-1.169,.625,1.228,-1.372),vec4(-.364,1.590,1.617,-.290),vec4(-.904,.976,.067,.405),vec4(-1.132,1.270,1.474,-.028),vec4(-1.462,.476,.875,.534),vec4(-.884,.886,.721,.481),vec4(.520,1.477,1.482,.637),vec4(-.203,1.036,1.044,-.248),vec4(-1.857,.079,.266,.398),vec4(-2.032,.549,1.983,-.509),vec4(-.575,1.333,1.046,.312),vec4(-1.078,.912,.831,.692),vec4(-.677,-.367,.447,.722),vec4(.297,.673,1.137,-.626),vec4(-.900,-.127,.324,.949),vec4(-.488,.892,.533,-1.234),vec4(-1.548,2.146,-2.113,-.057),vec4(-1.067,.001,1.337,-3.567),vec4(.762,.038,1.498,-1.872),vec4(2.192,-.138,1.452,-.070),vec4(-.258,-.927,-.364,-.116),vec4(.872,.344,.575,-.147),vec4(.484,.414,-.496,-.461),vec4(.970,.017,-.419,-.667),vec4(1.616,-.974,-.974,-.864),vec4(1.749,-.717,.616,-.916),vec4(-.209,-.727,.564,.037),vec4(.521,-1.710,.067,1.243),vec4(-.234,.328,.778,-.804),vec4(-.142,.995,1.646,.176),vec4(-.994,.365,.717,1.590),vec4(-1.147,-.133,.347,.953),vec4(-.515,.200,-1.403,2.456),vec4(-.757,-.204,-.145,1.105),vec4(-.387,.176,1.684,.262),vec4(-1.335,-.065,.744,.847),vec4(-.891,1.002,.770,1.485),vec4(-.371,.632,.590,.791),vec4(-.911,1.711,.569,.311),vec4(-.649,.900,1.707,-.523),vec4(.157,1.075,.368,-.360),vec4(-.286,1.900,.459,.224),vec4(.620,1.806,.908,-.058),vec4(.190,-.014,.675,1.085),vec4(.449,.268,.911,-.029),vec4(-.435,-.484,.434,.350),vec4(.395,.350,1.240,1.213),vec4(-.029,2.104,1.336,.074),vec4(-.900,1.304,-1.705,-1.114),vec4(-1.790,1.644,-.672,-1.081),vec4(-1.746,.733,-1.722,-.263),vec4(-.460,-.887,1.239,-.287),vec4(.182,-1.434,1.384,1.118),vec4(-.104,-.421,-.801,-.433),vec4(-.091,-1.446,.954,2.468),vec4(.434,-1.112,.395,.504),vec4(1.730,-.836,1.232,.463),vec4(1.292,-2.019,-.253,1.864),vec4(.269,-1.168,.114,1.535),vec4(-.277,.866,-1.872,-.451),vec4(-.075,.090,-.833,-.035),vec4(.472,1.733,.340,.614),vec4(1.724,2.101,1.391,-.661),vec4(-.784,1.659,1.236,-.780),vec4(-.138,1.055,.857,-.069),vec4(-.156,.468,-1.578,.316),vec4(-1.321,.209,.574,.274),vec4(-1.394,.336,.482,1.529),vec4(-.679,.472,.774,1.603),vec4(-.690,1.255,.189,1.088),vec4(-.858,.262,-.310,-.709),vec4(-.631,1.067,.078,.944),vec4(.539,.907,1.537,-.315),vec4(-.310,1.370,1.019,-.873),vec4(.245,1.358,.828,-.603),vec4(-.204,.406,.269,-.607),vec4(.317,.931,-.146,.370),vec4(.189,-.311,.156,1.255),vec4(.010,1.266,.682,.272),vec4(.119,.372,.916,.715),vec4(.248,.553,.708,-.682),vec4(-.527,.265,-.064,-.730),vec4(-.468,.696,.278,-.858),vec4(.593,.788,1.555,-1.300),vec4(-1.329,.192,1.057,-.179),vec4(-.593,-.031,-1.102,-.110),vec4(.533,-.921,.916,-1.288),vec4(.871,.324,-.128,.348),vec4(.008,-.149,.551,-.135),vec4(-1.324,-1.329,-.608,.965),vec4(-.674,-.756,-.398,-.931),vec4(-.489,-.375,-.163,-.756),vec4(-.587,.298,.011,-.698),vec4(.446,1.983,.904,.862),vec4(-1.308,1.612,-.618,.674),vec4(-1.565,-.065,-1.590,.688),vec4(-1.010,1.422,-1.196,-1.298),vec4(.780,.576,.578,2.444),vec4(-3.358,-1.479,1.967,2.388),vec4(-.230,-1.009,2.896,.369),vec4(.526,-.725,3.083,-.186),vec4(.683,-1.303,.822,.921),vec4(-1.108,.366,.413,.283),vec4(-.928,.800,1.116,.777),vec4(-1.000,.333,.839,.095),vec4(-.447,-.527,.139,.521),vec4(.237,-.241,.953,.210),vec4(-1.089,-.378,.089,-.787),vec4(-.187,.296,-.298,.557),vec4(1.720,.579,.522,.495),vec4(1.370,-.465,.203,-.137),vec4(.035,.992,-.252,-.993),vec4(.223,.208,-.398,-.474),vec4(.862,.443,.687,.030),vec4(.277,.853,.110,-.452),vec4(-1.004,-.609,.942,-1.018),vec4(-.676,-.280,-.167,-1.173),vec4(-.376,.465,.044,-1.309),vec4(-.148,-.900,2.267,-1.033),vec4(.133,-1.052,.982,1.188),vec4(.378,.178,.111,-.941),vec4(-.381,.840,-1.010,1.545),vec4(-.960,-.244,-.825,-.735),vec4(.492,1.132,.765,-.476),vec4(1.067,.263,1.015,1.135),vec4(-.118,-1.315,-1.117,1.403),vec4(.112,-1.369,-.185,1.124),vec4(-1.109,.082,1.796,.384),vec4(-1.204,-1.110,.295,.855),vec4(-.681,1.292,2.922,.914),vec4(-.311,-.236,1.709,1.217),vec4(-.042,-2.869,2.727,4.900),vec4(.704,-3.913,-.033,1.405),vec4(-.614,-3.891,1.530,1.861),vec4(-2.287,-.978,.764,2.655),vec4(-2.278,-1.098,-1.370,.064),vec4(-.310,.892,.203,-.702),vec4(-.647,-.790,-.305,-.152),vec4(-2.284,-.997,.852,.874),vec4(.532,.890,-.071,1.244),vec4(.752,1.056,-.916,-1.241),vec4(.748,1.452,-.275,.256),vec4(.530,-.701,-.413,-.714),vec4(-.955,-.868,.404,-1.231),vec4(1.365,1.125,.960,-.228),vec4(.235,.798,-.791,1.378),vec4(.146,-.042,.276,.242),vec4(.056,.167,-.051,-.083),vec4(.069,.133,.122,-.907),vec4(.793,-1.257,1.335,1.822),vec4(2.712,.614,-2.311,-1.595),vec4(1.550,-.184,.623,1.401),vec4(-.220,1.304,-1.242,2.472),vec4(-.168,1.420,-1.793,2.784),vec4(.052,-.085,.054,1.759),vec4(.961,.895,-.179,.793),vec4(.330,-1.077,.321,-.222),vec4(1.048,.210,1.062,-1.030),vec4(.608,.086,1.329,-.761),vec4(1.064,.728,1.155,-.441),vec4(.272,1.022,1.122,-.381),vec4(-.421,.458,-.014,-.477),vec4(-1.918,-1.762,1.415,.421),vec4(-1.234,-2.343,-.073,5.101),vec4(-2.358,-2.598,-.495,.416),vec4(-.395,-1.262,.558,.744),vec4(-.907,.022,.407,.740),vec4(-.524,-1.383,2.671,.315),vec4(.092,.508,.935,.311),vec4(.617,1.625,1.147,.648),vec4(-.388,1.304,2.274,-.168),vec4(-.662,1.048,1.579,.301),vec4(.051,-.855,2.119,.931),vec4(-.196,-1.746,1.693,-.519),vec4(-.977,.777,.097,-2.019),vec4(.766,2.669,-1.579,-.902),vec4(-.710,1.009,-.855,-.379),vec4(-.815,.123,.282,-.300),vec4(1.246,-.210,.157,.513),vec4(-.039,.324,1.355,1.268),vec4(.066,.675,.528,.888),vec4(-.835,2.038,-.019,.505),vec4(.452,1.856,-1.927,-.378),vec4(.799,.594,-.138,1.573),vec4(.012,.098,-.515,-.329),vec4(-1.142,-.291,-.509,-.967),vec4(-.779,1.497,-1.795,1.003),vec4(.363,.785,.117,.082),vec4(.107,.769,-.941,-.515),vec4(-.149,-1.087,.677,-.837),vec4(-.389,-.726,.112,-.227),vec4(1.038,.637,.694,1.548),vec4(1.155,.723,.824,-.312),vec4(1.136,-.644,.709,.633),vec4(-.070,-1.260,1.236,-.143),vec4(1.673,-.087,.143,2.364),vec4(-1.326,-1.741,-1.299,2.312),vec4(-.832,-1.218,-1.254,1.432),vec4(-.635,.455,-.845,-.536),vec4(-1.396,-.459,.872,-.409),vec4(-.455,.180,1.221,-1.005),vec4(-.539,.070,1.235,-.460),vec4(-1.225,.170,.810,-.441),vec4(-1.880,-.033,.216,.173),vec4(1.610,1.147,1.560,-.003),vec4(2.715,1.065,.272,1.028),vec4(.983,.602,.633,1.200),vec4(.709,-.086,.327,-.145),vec4(-.551,-.373,-.490,-.565),vec4(-.862,.630,-.394,-.067),vec4(-1.861,.476,-.998,.213),vec4(-.560,.236,2.175,.585),vec4(-.816,.218,1.841,.558),vec4(.795,1.104,.419,-1.146),vec4(-1.603,1.772,-1.347,.143),vec4(.327,1.086,-.702,.753),vec4(.315,2.149,.761,-.097),vec4(.518,.709,-.626,1.658),vec4(-.197,1.510,-.119,-.684),vec4(.457,1.730,-.440,.343),vec4(.560,.561,-.794,.137),vec4(1.040,-.261,.417,-.734),vec4(-.685,-.858,.468,.909),vec4(.327,-.703,.691,-.508),vec4(1.309,.208,-.701,.007),vec4(.802,-.743,.819,.598),vec4(.115,-1.654,.384,-.124),vec4(-.862,-2.189,-.896,-.948),vec4(1.282,-1.458,.966,.035),vec4(.436,-1.469,1.001,-.619),vec4(.415,-.988,.295,-.193),vec4(-.508,-.376,-1.137,-.021),vec4(.516,1.043,.262,.215),vec4(-2.960,-1.866,-.207,-.895),vec4(-1.873,-1.609,.725,.632),vec4(-.559,.440,1.135,.082),vec4(-1.451,.366,.125,-.642),vec4(-2.531,.487,.291,-1.440),vec4(-.628,.410,.699,-1.368),vec4(.262,-.555,1.183,1.013),vec4(-.829,2.651,-.800,1.167),vec4(.337,1.338,1.382,-.761),vec4(1.406,.203,.198,.143),vec4(1.006,-.518,-1.191,-.057),vec4(.661,.769,-.019,.777),vec4(-.569,-1.100,.003,-1.623),vec4(-3.045,2.103,-3.048,3.202),vec4(-1.058,-.981,-2.133,.963),vec4(.205,-.670,-.840,.273),vec4(.284,-.060,-.820,1.417),vec4(.358,.223,-1.078,1.309),vec4(.007,1.258,-.740,-.874),vec4(-.457,.809,-.077,-1.350),vec4(.079,.217,.245,-.674),vec4(-.198,-1.135,.054,.627),vec4(.479,-.001,-1.058,.706),vec4(.253,.253,-1.487,1.130),vec4(.602,-.446,.422,.788),vec4(.935,-.409,.077,.111),vec4(1.484,-.537,1.464,-.523),vec4(.783,-.841,2.684,-1.196),vec4(.987,-.651,1.004,.442),vec4(.622,-.801,.239,-.905),vec4(1.006,-.468,-.552,-1.791),vec4(-.541,-.030,-.871,.331),vec4(-1.635,-.770,-.398,-1.880),vec4(.071,-.973,.382,-1.254),vec4(.956,.307,.748,.168),vec4(-2.443,-1.145,-1.020,-1.562),vec4(-.387,.077,-1.791,.188),vec4(-.867,1.068,-.179,-.584),vec4(.755,2.717,.343,-1.501),vec4(-.814,-.830,.041,-1.369),vec4(.327,1.014,-.905,-.120),vec4(-.305,.827,-1.519,.145),vec4(-.055,-.287,-.002,-.218),vec4(.225,1.447,.044,.281),vec4(.712,.912,-.089,-.154),vec4(4.912,2.071,-4.683,.540),vec4(-1.916,1.908,-1.146,1.205),vec4(-.125,-2.915,-.420,2.901),vec4(.596,.703,-.214,.982),vec4(-.383,.297,-.896,.782),vec4(.677,.524,-.072,.716),vec4(.401,.342,-.217,.331),vec4(-.667,.183,-.465,.450),vec4(.033,.430,-.540,.373),vec4(.459,-.632,-.798,1.172),vec4(.169,-.276,-1.061,1.880),vec4(.886,-.512,-.501,.749),vec4(.986,.352,.611,-.739),vec4(.911,-.417,.681,.337),vec4(.122,-1.244,.959,-1.076),vec4(-.805,-.935,1.680,-.756),vec4(-.522,-1.888,.465,-.710),vec4(.186,-1.032,-1.243,-.339),vec4(1.536,.493,-.244,.481),vec4(1.206,.041,-.098,1.056),vec4(-.570,.139,.197,.467),vec4(.888,-1.090,.480,-1.500),vec4(1.388,2.211,-.191,-2.318),vec4(3.650,.038,.485,.934),vec4(-1.478,-1.466,.932,1.114),vec4(-.933,.955,-1.385,-1.435),vec4(.023,.297,-.081,-1.322),vec4(.205,.368,.613,.837),vec4(-.144,.409,-.346,1.360),vec4(.056,2.422,.336,1.657),vec4(-.073,.647,.891,-.152),vec4(-1.558,1.073,.283,1.347),vec4(.516,-1.213,-2.328,-1.854),vec4(1.087,-.370,-2.377,-.981),vec4(.664,2.990,4.825,-.054),vec4(1.894,-.183,.815,2.518),vec4(.929,-.228,-.263,1.749),vec4(.150,.126,-.711,.466),vec4(.698,.519,-.395,.131),vec4(.505,1.004,-.528,-.265),vec4(-.938,-.881,-.435,-.305),vec4(.260,-.012,-.837,-.379),vec4(.133,.297,-.457,.097),vec4(.662,.208,-.395,.648),vec4(.111,-.724,-1.526,1.487),vec4(.171,1.455,.557,.016),vec4(.384,.236,-.519,2.164),vec4(.360,.132,-.649,1.338),vec4(-.443,-.450,.154,-1.062),vec4(1.121,.749,.900,.636),vec4(.329,.389,.642,-.345),vec4(-.185,-.342,-.053,-.627),vec4(.788,.974,.760,-.627),vec4(-.770,-.010,-.352,-2.681),vec4(-.417,-.393,-.703,-1.831),vec4(-.129,.321,.037,-.698),vec4(1.296,.801,1.745,-.125),vec4(1.529,.681,1.574,1.158),vec4(.325,1.420,-.262,-.701),vec4(-.449,-.193,-.040,1.263),vec4(-.015,.734,-.451,2.127),vec4(-1.135,-.270,-.397,2.663),vec4(1.118,-.244,-.213,2.232),vec4(-.923,.134,-.188,.496),vec4(1.360,-1.152,-1.872,-1.827),vec4(1.979,-1.107,-3.573,-1.245),vec4(-3.135,-.323,6.504,-2.989),vec4(1.563,-2.921,.412,2.525),vec4(.235,-.597,-1.258,1.750),vec4(.516,.571,-.820,.648),vec4(.424,.530,-.528,.667),vec4(.207,.679,-.258,-.239),vec4(.638,-.027,-.774,.428),vec4(.223,.602,-.517,.350),vec4(-.866,.590,-.560,-.450),vec4(-.362,.818,.620,.963),vec4(.023,.607,.531,-.059),vec4(-.353,.486,.360,-.804),vec4(-.236,1.244,1.436,.545),vec4(-.820,.181,.897,1.424),vec4(-.415,.208,.678,.531),vec4(.955,.140,.357,.917),vec4(1.391,1.441,1.516,-2.116),vec4(.309,.372,.860,-.002),vec4(.715,.124,.026,-.012),vec4(-.173,-.692,-.059,-1.338),vec4(.038,-.170,-.073,-2.023),vec4(.939,.056,.109,-.001),vec4(.191,.111,-.247,.715),vec4(1.368,.860,.751,-.205),vec4(.457,.934,.577,1.105),vec4(.933,.209,.595,-2.203),vec4(.430,-.032,-.230,.221),vec4(.755,1.080,-.151,2.689),vec4(.963,-.020,-.424,1.535),vec4(-.318,-1.247,-1.423,-1.713),vec4(.573,-1.458,-.940,-1.690),vec4(1.139,-.703,-1.807,-2.282),vec4(1.147,.953,3.411,-2.578),vec4(1.324,-.179,-1.242,-.754),vec4(.762,-.025,-.379,-.427),vec4(.715,1.128,-.322,.462),vec4(-.621,.645,-1.000,.453),vec4(.708,.387,-.430,.541),vec4(.379,.548,-.284,.807),vec4(-.097,-.283,-.239,-.717),vec4(-.220,1.302,.757,-.569),vec4(-.399,1.459,-.046,1.146),vec4(.037,.672,.415,1.325),vec4(.295,.431,.457,.655),vec4(-.117,.026,.307,.198),vec4(-.548,.437,.160,.201),vec4(.874,1.540,.817,.638),vec4(-.676,-1.187,-1.023,2.055),vec4(-1.222,.116,-.775,-.606),vec4(-.765,-.786,-.236,.365),vec4(.538,.161,-.285,.659),vec4(1.074,-.573,.235,.896),vec4(.264,-.087,-.197,-.473),vec4(.064,.247,-.643,.018),vec4(.417,.403,.422,.260),vec4(.764,.162,.008,.093),vec4(1.307,-.574,.680,-.122),vec4(.961,.896,.197,-.630),vec4(.533,.507,-.095,-1.060),vec4(.136,.146,-.362,.172),vec4(.185,-1.126,.317,-.161),vec4(.141,.226,1.620,-1.106),vec4(-.581,-2.071,-.442,-.507),vec4(1.423,-.502,-.866,-2.320),vec4(-1.867,4.652,-.070,-2.251),vec4(1.013,-.047,-1.461,.227),vec4(.516,1.350,-.722,.816),vec4(-.122,.565,-.339,.026),vec4(.908,.784,-.714,.813),vec4(.273,.344,-.380,-.641),vec4(1.025,.045,-.389,.398),vec4(-.179,.821,.210,-.106),vec4(-.575,.222,-.166,.609),vec4(.067,.802,.705,.328),vec4(-.426,1.119,.743,.128),vec4(.447,.990,.809,-.159),vec4(-.066,-.149,-.295,.891),vec4(.370,.709,.177,.053),vec4(.630,1.118,.276,.088),vec4(.681,-.401,-.323,-.691),vec4(-1.241,-1.307,-.249,.284),vec4(.416,-.556,.166,.381),vec4(.627,-.596,-.552,.911),vec4(1.302,.760,.385,.684),vec4(-.333,-.342,-.634,-.114),vec4(.257,.140,-.407,-.615),vec4(.305,.571,-.827,-.288),vec4(.059,.391,.107,.401),vec4(.622,.857,.622,1.110),vec4(.692,.091,.545,.129),vec4(.031,.374,.161,-.811),vec4(.151,-.081,.314,-.552),vec4(1.823,.277,.438,.908),vec4(.667,1.758,.936,-.158),vec4(.712,-.922,-1.015,-2.541),vec4(.602,-2.575,-.286,-4.841),vec4(-2.440,.007,-1.192,1.470),vec4(.779,.892,1.114,3.233),vec4(.816,1.082,-.068,-.327),vec4(.648,1.342,-.493,.764),vec4(.835,1.407,.000,.577),vec4(.786,.376,-.006,.253),vec4(-.240,.909,1.221,-.799),vec4(-.121,1.159,.958,.439),vec4(.075,1.129,.945,-.100),vec4(-.720,.848,.840,-.479),vec4(1.647,1.217,-.562,.205),vec4(-.275,.500,-.251,.845),vec4(-.238,-.641,.230,1.001),vec4(-.011,1.494,.597,-.930),vec4(.277,-.379,-.976,1.091),vec4(.765,.484,.783,-.237),vec4(.027,-.206,-1.459,.538),vec4(.704,.286,-.403,.366),vec4(.935,-.131,-.942,-1.057),vec4(.122,-.321,-.281,-1.405),vec4(.598,1.151,-.473,-.039),vec4(.229,-.154,-.544,-.338),vec4(.869,.192,-.098,.287),vec4(.269,-.074,.005,.133),vec4(.711,.533,1.346,.175),vec4(.751,.464,.957,.166),vec4(.016,1.177,.665,.048),vec4(.755,.923,.389,.606),vec4(-.354,-.589,.089,.030),vec4(.724,-.364,1.704,-.046),vec4(-1.918,.517,-.724,-1.374),vec4(.681,-1.511,-1.822,-1.091),vec4(1.234,-.005,5.988,3.381),vec4(1.594,.710,.502,1.092),vec4(.633,.845,.587,.358),vec4(-.048,-.308,-.964,.875),vec4(-.911,.587,.579,.506),vec4(-.456,.839,.144,.651),vec4(-.960,.981,.177,.489),vec4(-.750,-.038,.253,1.109),vec4(-.655,.314,.269,.634),vec4(1.082,1.311,-.034,-.307),vec4(1.086,.864,.320,-.050),vec4(.521,-.151,-.006,-.039),vec4(-1.030,-.966,.460,1.171),vec4(.071,-.335,.369,.964),vec4(.420,.185,.071,-.193),vec4(.187,.338,.493,-.722),vec4(-.305,-1.241,-.120,.627),vec4(1.170,.831,.188,.597),vec4(1.439,-.222,.594,-.690),vec4(.827,.288,.132,-.649),vec4(.792,.099,-.086,-.237),vec4(-.378,-.180,-.030,.118),vec4(.577,1.127,-.324,.341),vec4(.830,.235,.229,-1.052),vec4(.341,.551,-.201,-.509),vec4(-.280,1.566,-.558,-.332),vec4(.610,.821,.420,-.060),vec4(.070,.820,-.107,-.805),vec4(-.166,1.029,.010,.307),vec4(-.368,-.596,.151,-.073),vec4(-.530,-.260,-1.850,-.903),vec4(-.235,1.853,1.425,-2.390),vec4(1.240,-.664,.241,1.035),vec4(.590,1.287,-.281,-.379),vec4(-.341,.756,-.474,.937),vec4(-1.318,.277,-.279,1.046),vec4(-.323,1.573,.380,1.161),vec4(-.576,1.868,1.685,-.280),vec4(.141,1.415,1.257,.021),vec4(.300,.307,.186,1.029),vec4(-.503,-.234,-.765,1.604),vec4(-.488,-.845,-.067,1.165),vec4(.287,-.448,-.134,.792),vec4(.176,-1.049,.031,.166),vec4(-.716,.100,-.071,.872),vec4(-.370,.383,.051,-.288),vec4(.109,.416,.472,-.328),vec4(-.275,1.326,-.119,.847),vec4(.465,1.153,-.056,.083),vec4(1.453,-.306,-.127,1.358),vec4(.531,-.013,.151,.069),vec4(.027,.267,-.429,-.363),vec4(1.776,.580,.679,-.214),vec4(1.079,.166,.498,1.262),vec4(.980,.969,.484,-.180),vec4(-.363,-.327,-.447,-.612),vec4(-1.006,.062,-.139,-1.277),vec4(-1.752,.989,-1.180,-.577),vec4(1.284,.183,-.629,.622),vec4(.989,1.938,.642,-.808),vec4(-.789,.165,-.024,.105),vec4(-.026,1.813,-1.097,.475),vec4(1.856,-1.496,-.419,1.374),vec4(4.966,1.581,-3.741,-3.208),vec4(1.877,-.231,.132,2.482),vec4(.167,-.437,.493,.578),vec4(.156,.856,.127,.820),vec4(-.681,.841,-.336,.780),vec4(.184,2.518,1.331,.100),vec4(.607,1.696,1.186,.215),vec4(-.035,.488,.869,.773),vec4(-.578,.657,.526,.721),vec4(.189,1.373,.884,.814),vec4(-.615,-.734,.040,1.562),vec4(.097,-.719,-.253,-.575),vec4(-.248,-.669,.454,-.702),vec4(-.444,.263,-.308,-.335),vec4(.529,1.396,1.044,-.091),vec4(.580,.720,-.102,.671),vec4(-.795,1.390,-.502,.341),vec4(1.344,1.051,.782,1.019),vec4(1.665,-.235,.563,-.575),vec4(.051,-.042,.042,.071),vec4(-.306,.721,-.487,-.352),vec4(.484,.691,.200,.361),vec4(1.277,.091,-1.121,-1.545),vec4(.705,.117,-.667,-.614),vec4(.077,-.064,.142,.073),vec4(-1.044,-.359,-.877,-.908),vec4(-1.533,-.318,-.841,-.222),vec4(-.155,-.729,-1.401,-.253),vec4(-.071,.508,-1.243,.341),vec4(-.716,-.680,.331,.111),vec4(1.864,-1.969,-1.369,-.514),vec4(1.730,-1.935,-.333,1.115),vec4(-1.721,-.506,-.584,.265),vec4(.264,.395,-2.269,.087),vec4(1.023,-2.124,.697,1.104),vec4(-2.224,-.217,-.919,.575),vec4(.789,2.256,-1.446,.766),vec4(1.802,-.169,-.471,.793),vec4(.170,-.622,-1.708,-.837),vec4(-2.257,.973,-1.311,.537),vec4(.580,-1.200,1.320,-.488),vec4(-.511,-2.687,-.659,.359),vec4(.980,-.228,-.102,.740),vec4(-1.109,-.234,-.078,-.958),vec4(.531,-.894,1.096,-.949),vec4(1.826,.464,-.960,-.481),vec4(1.171,-1.753,.626,.490),vec4(-1.256,-1.673,-.513,-.528),vec4(-.337,1.289,.043,-1.266),vec4(-.249,-.190,-.985,-3.043),vec4(-.878,.103,-1.152,.323),vec4(-.320,1.306,-.910,-.495),vec4(.593,-1.506,-.035,-.376),vec4(.047,.895,1.654,-.330),vec4(-.974,-.003,-.280,.267),vec4(-.376,.338,.664,1.324),vec4(.488,.102,-.746,-.380),vec4(-.925,-.095,.738,.648),vec4(-.352,-.152,-.256,.254),vec4(.378,-.273,-.680,-.127),vec4(-2.130,2.461,-.338,.832),vec4(-1.552,-1.576,-2.135,-.511),vec4(.448,-.111,-1.346,.683));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed1[idx];\n}", "buffer_b_inputs": [], "common_code": "const int embed_texture = 32; \nconst int embed_channels = 4; ", "buffer_c_code": "const vec4 embed2[1024] = vec4[](vec4(.834,-.544,2.945,-.253),vec4(.045,.606,.457,-.073),vec4(1.109,-.168,.196,.383),vec4(1.243,-.406,.771,-5.169),vec4(.300,-4.738,1.452,2.246),vec4(4.414,-9.005,-.261,2.089),vec4(2.073,-2.333,-1.711,-1.462),vec4(4.551,-2.260,3.058,1.886),vec4(.813,-1.443,-.252,-1.296),vec4(-1.578,-.636,-.117,1.115),vec4(1.516,-.664,.640,1.697),vec4(-.977,-.025,-2.467,-.960),vec4(-1.070,-.870,.898,.022),vec4(1.445,-.010,4.549,-1.751),vec4(-.475,1.768,3.113,2.945),vec4(2.423,1.610,-3.250,.158),vec4(3.552,.125,-2.226,3.007),vec4(3.174,-3.031,-4.461,-1.858),vec4(-3.110,-.523,-.419,1.998),vec4(1.552,-2.656,-.622,-.186),vec4(.352,.567,1.494,.876),vec4(.797,1.485,-3.648,-7.015),vec4(.374,.787,-2.273,-3.434),vec4(-1.565,.763,1.776,-.149),vec4(2.256,3.204,.369,2.470),vec4(.377,.240,1.608,-1.275),vec4(-1.367,-.146,1.268,-2.178),vec4(.949,.067,3.811,.365),vec4(-.016,-.353,.366,.605),vec4(-1.112,-.276,.044,-.776),vec4(-.707,.224,-.066,.347),vec4(2.847,4.148,3.183,-1.848),vec4(.815,1.323,1.034,.349),vec4(.732,.155,1.529,.161),vec4(1.366,-.506,-.402,-.750),vec4(1.617,.254,-.867,-.640),vec4(-1.839,.809,-.341,-1.815),vec4(-2.300,3.233,-2.904,.728),vec4(.766,-6.301,1.793,4.260),vec4(1.473,-1.773,1.687,.357),vec4(1.063,.939,-1.453,.104),vec4(.090,.116,.937,.207),vec4(2.775,-.523,1.001,1.277),vec4(.334,1.745,-.146,1.860),vec4(-.743,.506,-1.390,-2.573),vec4(3.256,-1.453,.826,-.761),vec4(.488,1.740,-3.573,1.136),vec4(1.283,2.874,1.363,-.589),vec4(-.329,-.417,-.987,1.280),vec4(1.799,.517,-2.478,-2.868),vec4(-.046,.724,.705,1.506),vec4(-1.247,-2.477,-1.548,1.873),vec4(-1.723,2.488,.448,-.250),vec4(.674,3.045,-.641,-.291),vec4(-1.714,-.628,-1.461,-3.768),vec4(1.060,.435,-1.810,-1.339),vec4(.128,-.980,1.037,-1.079),vec4(1.073,1.575,.442,.436),vec4(-.342,.249,1.241,-1.748),vec4(3.017,.994,.043,1.704),vec4(1.205,1.559,1.132,1.781),vec4(-.720,-1.104,.137,.413),vec4(2.080,-3.178,-.366,.861),vec4(-4.689,-.920,-3.680,-3.556),vec4(.896,-.105,-1.212,-1.425),vec4(.856,.177,-1.578,-1.252),vec4(1.410,.490,-.328,-.366),vec4(-.700,.385,-1.382,-3.575),vec4(-1.084,.308,1.784,-.033),vec4(-4.735,3.100,6.026,5.623),vec4(.655,.406,-.857,.514),vec4(2.646,-.419,1.312,1.235),vec4(.855,.472,2.157,.583),vec4(2.205,-.418,.233,.064),vec4(.986,-.185,1.785,.877),vec4(1.976,.790,-.496,1.764),vec4(.517,-.360,-.165,-2.168),vec4(.582,-2.445,.490,.249),vec4(-.114,.729,-1.384,-.108),vec4(-.284,2.410,-.153,.989),vec4(-1.038,.782,-1.481,-1.396),vec4(.545,1.190,-.033,.022),vec4(-2.016,1.448,1.842,1.111),vec4(.778,-.101,-2.297,2.403),vec4(-1.268,1.790,-1.587,-1.275),vec4(1.057,4.266,2.064,.320),vec4(-.720,-1.419,1.777,-.697),vec4(-.538,3.606,-2.474,1.724),vec4(1.607,-1.401,.603,-1.002),vec4(1.476,.454,-.949,1.015),vec4(-.650,-.178,1.529,-2.077),vec4(-.091,-.563,.084,.634),vec4(-.464,-.908,.530,1.053),vec4(.381,-2.394,.352,-1.304),vec4(-.143,-.594,-.332,.426),vec4(2.748,-3.631,2.885,1.974),vec4(1.592,1.193,-.802,-1.395),vec4(1.720,.654,.525,-1.885),vec4(1.071,1.655,.637,-2.146),vec4(-.106,-2.236,1.722,-1.694),vec4(-1.991,.119,-3.700,1.208),vec4(.089,-1.808,-2.332,-2.210),vec4(1.944,-4.311,2.524,.375),vec4(-.555,1.007,-.543,-.703),vec4(-.868,.360,.491,1.211),vec4(.349,1.771,2.533,1.061),vec4(-.742,-2.485,-.071,-2.487),vec4(.016,.649,1.565,.101),vec4(-.382,-.325,-1.174,-1.170),vec4(.825,-1.844,1.765,2.491),vec4(-.617,1.995,.222,1.420),vec4(-1.307,.053,-.975,.586),vec4(-.843,1.147,.436,.420),vec4(.320,1.543,1.145,.118),vec4(-.663,1.548,-.174,1.384),vec4(.013,2.120,-.715,1.133),vec4(-.682,.424,-.528,-1.317),vec4(1.726,2.456,.603,2.035),vec4(.997,-.140,-2.839,-.083),vec4(.681,1.964,-1.764,.148),vec4(.255,-.952,2.382,-.841),vec4(.483,.734,.710,-.554),vec4(.846,-1.095,1.482,.132),vec4(-1.181,2.023,1.041,1.434),vec4(-1.244,.558,1.060,2.142),vec4(.741,-3.191,.198,.645),vec4(.204,-2.865,.634,-.182),vec4(-1.268,1.335,-.882,.093),vec4(2.266,2.665,-.489,-1.007),vec4(1.750,.678,.541,-2.175),vec4(.641,4.060,1.015,-1.817),vec4(-.775,-3.101,-1.015,3.172),vec4(1.659,-4.693,3.546,1.717),vec4(1.262,-.346,.535,2.873),vec4(-.828,-.795,.954,-.184),vec4(1.599,-.354,-.808,-1.325),vec4(3.508,-4.193,1.191,.387),vec4(1.239,-2.707,-.038,.951),vec4(1.297,2.171,1.763,.297),vec4(-1.196,1.644,-1.690,-1.876),vec4(1.377,-1.586,1.464,1.309),vec4(-1.333,.646,-.062,.221),vec4(-.801,.822,-.291,1.229),vec4(-.955,.028,1.326,2.022),vec4(-.452,.067,.971,-.065),vec4(-.990,.693,.931,-.185),vec4(-.597,.653,-.552,-.460),vec4(-1.776,.636,-.925,-.670),vec4(-.738,-.167,.519,1.678),vec4(1.697,3.118,-.649,1.251),vec4(-.588,-.491,-.051,-.866),vec4(1.916,-.093,-1.316,.201),vec4(.177,1.652,-1.256,1.486),vec4(-1.258,.689,1.570,-1.738),vec4(1.170,1.183,-.468,1.702),vec4(-.077,3.785,-.143,1.939),vec4(-.736,.776,-.545,-.881),vec4(-1.169,-1.518,-1.362,.202),vec4(1.004,.410,.731,.133),vec4(.924,-.936,-1.104,.908),vec4(1.225,2.214,.399,-1.410),vec4(-.480,1.149,-1.698,-3.117),vec4(-2.455,2.283,-2.140,-.545),vec4(2.128,-2.955,.835,-1.252),vec4(1.513,.771,-4.698,2.167),vec4(-1.347,-.139,.769,1.559),vec4(-.397,-2.390,2.210,-.470),vec4(1.823,-1.119,1.733,-1.010),vec4(1.166,.594,-1.033,-.937),vec4(1.728,1.355,-.906,-2.053),vec4(.894,-1.769,-2.682,-1.261),vec4(-1.293,-.715,1.169,.613),vec4(1.562,1.142,.095,.414),vec4(-2.830,-.153,-1.825,-.198),vec4(.424,1.279,-.378,1.691),vec4(-1.709,.317,1.032,-.972),vec4(-.922,.255,.766,.040),vec4(-.834,.193,.853,-.634),vec4(-1.674,.418,.002,-.658),vec4(-.872,.455,-.188,-.417),vec4(-.581,-.119,.103,.737),vec4(.233,1.835,.057,1.338),vec4(-1.324,-2.267,-1.093,-1.564),vec4(-1.251,-.970,-.118,-1.021),vec4(1.060,.452,-3.556,-.939),vec4(.971,-1.328,.058,.459),vec4(-.200,-2.151,1.465,-.767),vec4(.202,.212,1.127,-.896),vec4(.658,.371,-.601,.466),vec4(-.143,-.409,.674,.313),vec4(.114,1.663,1.769,.817),vec4(2.992,2.975,3.861,-1.362),vec4(-2.255,-1.620,-2.944,-5.331),vec4(-.625,1.533,-.538,-.748),vec4(-2.295,3.503,3.375,1.672),vec4(2.406,.205,2.390,-.603),vec4(.839,-2.302,.321,.206),vec4(-.710,-.760,.665,.024),vec4(.848,1.913,-2.170,-.233),vec4(1.929,2.173,-1.422,.548),vec4(.595,-1.754,1.222,-.703),vec4(.935,-.254,-1.268,.659),vec4(-.050,-4.093,.204,-.391),vec4(-1.830,-2.373,1.197,.496),vec4(-2.214,-.230,1.733,-.367),vec4(-1.815,.265,-.370,.190),vec4(-1.057,.256,-.982,.343),vec4(.067,.626,.004,.069),vec4(-.474,.558,-.076,.075),vec4(-1.238,-.427,.699,-.507),vec4(-.234,-.067,1.254,.296),vec4(-.413,.018,.425,.329),vec4(.058,.511,-.449,.087),vec4(-.580,1.595,.421,.663),vec4(-.543,-.440,1.486,-.554),vec4(-1.138,-3.812,.699,-.978),vec4(2.881,-.482,-1.164,.335),vec4(.274,-.501,1.358,1.259),vec4(-2.034,-.599,-.679,-.242),vec4(-1.638,-.161,-.089,-.564),vec4(.948,-.965,.023,1.868),vec4(1.571,-.025,1.515,1.610),vec4(-.223,.543,1.021,.054),vec4(4.752,-1.538,3.112,-1.908),vec4(-3.960,-.487,-3.618,-4.561),vec4(-1.756,4.437,2.189,-1.992),vec4(-1.175,-4.900,-3.994,-2.254),vec4(2.447,-4.972,3.548,-1.352),vec4(.293,.149,.680,.515),vec4(-1.232,-.302,-.669,.285),vec4(-.111,-1.581,1.919,-1.128),vec4(-1.481,-3.375,-1.137,-1.348),vec4(-1.078,1.613,-.195,-1.539),vec4(-1.253,.584,1.171,-2.276),vec4(.112,.865,-1.063,-.244),vec4(.293,.037,.799,1.946),vec4(-.772,-.163,2.539,-.776),vec4(-.869,-.075,-.423,-.257),vec4(-.959,.090,-1.285,.329),vec4(-.300,.379,-.261,.180),vec4(-.230,.568,.577,.241),vec4(-.470,.110,.462,.738),vec4(.336,-.438,.217,.957),vec4(.379,.058,.015,1.697),vec4(.399,.589,-.077,1.187),vec4(-1.523,-1.007,.420,.354),vec4(1.042,-2.117,.212,-1.132),vec4(.124,1.077,.472,.885),vec4(-1.276,.600,.052,1.918),vec4(.509,2.615,1.530,-.227),vec4(.554,.371,.956,1.515),vec4(.166,-.895,-.785,1.207),vec4(1.649,-.240,-.884,2.980),vec4(-.185,-.726,1.051,.790),vec4(1.927,-1.486,.116,-.828),vec4(1.191,1.378,-1.604,-4.590),vec4(3.530,6.262,-11.986,7.612),vec4(-.868,-2.191,-1.115,.625),vec4(1.693,.728,.447,1.593),vec4(.942,-1.502,.906,-.476),vec4(1.391,.533,-.457,1.131),vec4(-.179,.407,1.338,.030),vec4(-.467,-2.753,-3.103,-1.780),vec4(1.519,-.504,.103,-1.001),vec4(1.308,1.778,-1.435,1.034),vec4(1.874,-.111,1.178,-.508),vec4(1.975,4.037,1.008,-2.416),vec4(.745,1.492,-1.535,-.396),vec4(.930,-.189,.968,2.397),vec4(-.157,-1.246,-1.826,.462),vec4(-.216,-.936,-1.408,.167),vec4(-.298,.912,-.422,.511),vec4(-.502,.697,-.826,.521),vec4(-2.335,-.125,.260,-.320),vec4(1.210,.315,-.706,.870),vec4(-.340,1.189,.024,1.036),vec4(-.594,-.065,.407,-.303),vec4(-.164,-1.252,1.972,.348),vec4(-.590,.328,1.217,-.691),vec4(-.330,.044,-.405,-2.068),vec4(-.011,1.118,-.878,-3.907),vec4(2.716,1.333,-1.896,-.037),vec4(2.904,.056,.543,1.324),vec4(-.896,.242,-1.066,.481),vec4(.770,.605,.560,.720),vec4(-.872,-.231,.894,-.197),vec4(-1.213,-1.483,2.186,.362),vec4(-1.851,-2.471,2.429,7.810),vec4(2.507,.928,2.728,-7.048),vec4(.452,3.367,-1.340,-.537),vec4(1.449,-.319,1.077,-.082),vec4(.759,.879,.704,.229),vec4(-.952,-.854,.915,-.018),vec4(1.750,-.690,-1.651,-.770),vec4(1.897,-.310,-.167,.102),vec4(.711,1.077,1.212,.125),vec4(3.382,.587,-.756,1.037),vec4(2.019,-.058,-.572,.263),vec4(.707,2.592,-.637,-1.869),vec4(.723,3.259,-.790,-2.236),vec4(.195,2.459,-.590,-1.181),vec4(-1.562,-.921,-.958,.143),vec4(-.595,.024,-.088,.999),vec4(-.468,.385,-.200,.193),vec4(-.314,.465,-.351,.808),vec4(-1.745,.455,-.236,.091),vec4(-1.363,-.645,-.163,-.825),vec4(1.150,1.059,-.171,.327),vec4(-1.566,-.313,.401,1.001),vec4(.507,-.708,-4.489,-.710),vec4(-.058,-.280,1.550,-1.720),vec4(.848,.213,-.909,-3.284),vec4(-3.178,2.070,1.695,-.464),vec4(2.018,1.132,-.853,-1.752),vec4(2.266,-.608,2.529,-1.453),vec4(.803,.025,1.281,-.142),vec4(.771,-1.626,1.149,-.396),vec4(-1.201,-.223,.238,-.155),vec4(-.147,.548,-1.121,1.031),vec4(.647,-2.113,-1.012,1.443),vec4(-.683,1.197,1.891,-.719),vec4(.684,-.937,.838,-.836),vec4(.011,-1.936,.819,-.990),vec4(-1.303,1.393,.161,-.788),vec4(-.366,1.217,.098,-1.335),vec4(1.742,2.188,-.196,1.089),vec4(-1.188,.232,2.673,2.299),vec4(-.598,-4.171,2.423,.269),vec4(2.582,-.901,.312,-.199),vec4(1.236,1.023,-.044,.195),vec4(-.601,2.287,1.006,.747),vec4(-1.558,2.562,2.234,-3.265),vec4(1.233,2.408,.521,.643),vec4(-.646,-.370,-.239,.913),vec4(-.513,-.623,1.059,.627),vec4(-1.498,-.123,.444,.056),vec4(-.497,1.012,-.596,.787),vec4(-1.722,.256,-.834,.333),vec4(-.518,.684,-.583,.378),vec4(.290,-1.340,-.424,.449),vec4(-1.188,-2.022,-1.240,2.008),vec4(-.090,-1.901,-.879,-.465),vec4(.667,.649,.996,.129),vec4(-.965,1.410,.278,-2.999),vec4(-2.537,1.302,-1.232,-1.279),vec4(.883,3.223,-.320,-1.725),vec4(.522,-1.519,-.270,-1.136),vec4(-.028,-1.585,-.866,1.067),vec4(-.640,.059,.191,.227),vec4(-2.343,.289,-.211,-1.081),vec4(-.129,3.500,-.151,-.331),vec4(-1.100,5.510,-.554,-1.375),vec4(.491,2.415,1.273,.250),vec4(1.549,-.256,1.193,1.100),vec4(.316,-3.298,1.305,-.485),vec4(-.288,-.285,-.882,-1.310),vec4(2.040,-.097,-.604,-1.667),vec4(1.166,-.558,1.115,-1.650),vec4(.047,1.677,-.916,-1.207),vec4(.732,.883,.628,2.513),vec4(.631,.644,-.394,2.979),vec4(-.512,-.129,-.779,.204),vec4(1.670,-.883,.740,.680),vec4(1.209,-.278,.520,.876),vec4(-.403,-3.687,.386,-.062),vec4(.609,-.955,.174,.526),vec4(-.730,-1.225,.723,-.007),vec4(-.260,.106,.529,.532),vec4(-.985,.797,-.473,.653),vec4(.251,1.180,-1.081,.588),vec4(-.421,1.700,.614,.897),vec4(-.377,-1.268,.300,.815),vec4(-.564,-3.919,-1.114,.758),vec4(-1.714,-1.734,2.220,.111),vec4(1.083,.400,1.388,.767),vec4(1.618,1.514,.300,-1.384),vec4(2.301,5.026,.846,-1.545),vec4(1.927,1.397,1.718,-.352),vec4(-.514,1.357,-1.494,.086),vec4(1.626,2.450,-1.795,1.255),vec4(-1.009,-.750,-1.631,-.230),vec4(-.738,1.244,.553,-2.373),vec4(-.796,2.526,-.181,-.386),vec4(2.816,1.235,-.651,2.270),vec4(1.622,-.394,-1.100,3.383),vec4(.720,-1.053,.234,.316),vec4(.767,-.664,.848,-.366),vec4(2.068,-.312,-1.481,-.696),vec4(.908,-.072,-.751,.441),vec4(.087,-.462,-.564,1.143),vec4(-2.033,.041,4.717,2.562),vec4(-1.267,.355,1.898,-.123),vec4(-2.227,1.041,-.581,-.746),vec4(-1.455,-.160,-.545,-.749),vec4(-2.495,1.055,-.616,-.272),vec4(-1.455,.319,-.295,.156),vec4(-1.973,.541,-.069,-.823),vec4(-.206,-.342,1.780,.076),vec4(.234,-.476,.798,1.157),vec4(-.327,-.861,1.057,.033),vec4(-.647,-.042,.147,.127),vec4(.161,.663,-.644,.443),vec4(-.505,.130,.868,.269),vec4(-.628,-.449,1.202,-.434),vec4(-1.277,1.435,-.510,-.902),vec4(.971,.261,2.690,-.260),vec4(-.859,-.487,1.185,-1.170),vec4(-.701,1.506,1.095,-1.818),vec4(-.430,.609,-1.504,.775),vec4(-.847,-.091,.902,.450),vec4(-1.244,1.939,-.468,-.467),vec4(-1.234,1.332,1.516,.323),vec4(-.098,.254,.022,.282),vec4(-1.522,1.553,.491,.597),vec4(-1.249,2.728,.702,-1.035),vec4(-2.130,-1.135,-.384,-1.551),vec4(-.236,-2.318,.311,-1.436),vec4(.491,-.700,-.187,-.685),vec4(.429,-.896,-1.178,-2.572),vec4(-1.829,1.960,-.161,.236),vec4(.025,1.435,-.093,.294),vec4(.211,1.071,-.312,.428),vec4(2.098,-.926,.138,-1.420),vec4(.928,.024,-.917,-.924),vec4(-.604,.170,.957,-.334),vec4(-1.520,.528,-1.076,-.511),vec4(-1.314,1.065,.294,.462),vec4(-.480,1.103,.118,1.053),vec4(-.609,.557,.706,.635),vec4(-.135,.732,-.641,1.306),vec4(-.058,-.068,-1.296,.949),vec4(-.250,.347,-.383,.881),vec4(-.688,.115,-.036,.601),vec4(-.623,-.107,-.349,.017),vec4(-.672,.130,-.986,-.316),vec4(-1.428,.784,-1.006,.147),vec4(-.449,.970,.515,-.134),vec4(-.969,1.479,-.482,-.075),vec4(-.308,.062,.688,-.794),vec4(-.915,.073,-.310,-.123),vec4(-.630,-.020,-.136,.552),vec4(-.905,.823,.301,.254),vec4(.487,-1.103,-1.002,.787),vec4(.352,-1.385,-.806,.937),vec4(2.184,-.500,-.395,.800),vec4(.846,-.877,2.135,-1.006),vec4(-1.328,-.223,-.225,-.875),vec4(-3.353,3.507,-.296,5.549),vec4(.493,-.522,2.214,-.605),vec4(3.132,-.148,.352,.951),vec4(1.385,-.942,2.181,-.925),vec4(-1.779,-.676,1.387,-1.339),vec4(1.755,-3.207,1.415,.286),vec4(1.412,-.103,-.057,.880),vec4(.913,.528,-.348,.636),vec4(-1.609,-.499,-.797,-1.740),vec4(-1.825,1.304,.324,-1.055),vec4(-.226,.556,-.204,-.465),vec4(-2.539,.023,.711,-.672),vec4(-1.286,1.096,.402,.497),vec4(.149,.011,.523,.798),vec4(.203,-.210,.819,.881),vec4(.121,.132,-.511,.772),vec4(-1.793,.027,-.677,.365),vec4(-1.242,.480,-1.026,.980),vec4(-.172,-.272,-.897,-.210),vec4(-.573,-.699,-.775,1.033),vec4(-1.350,.684,.837,-1.736),vec4(-1.080,1.990,-.859,.238),vec4(-.685,1.085,-1.219,1.064),vec4(-.292,.725,-1.218,.785),vec4(.637,.701,-.283,-.158),vec4(.425,.355,1.114,1.644),vec4(-1.016,.215,.190,1.395),vec4(-2.331,-.117,-.423,1.567),vec4(.069,.716,.881,.477),vec4(-.975,-1.424,.474,-.854),vec4(.614,1.197,.401,.391),vec4(.169,.229,.114,2.071),vec4(-1.784,-2.688,1.747,-4.769),vec4(1.452,-.270,-3.605,-1.123),vec4(-1.021,-1.139,-.527,-.602),vec4(-.284,-2.587,-.765,-.163),vec4(.976,-1.791,-1.632,1.785),vec4(1.619,.876,-1.769,.150),vec4(.601,-1.486,-.374,-1.948),vec4(.887,1.703,.143,-.167),vec4(1.685,-.223,.453,.762),vec4(.763,1.250,.852,.838),vec4(.976,.620,.708,1.384),vec4(-1.887,.372,-.178,.272),vec4(-1.671,-.794,.369,-.551),vec4(.196,.026,1.466,-.226),vec4(.121,-1.849,.743,-.025),vec4(.234,.521,.292,1.111),vec4(-1.792,-.119,-.727,.466),vec4(-1.692,-.270,-.391,-.431),vec4(-2.205,-.060,-.556,-.337),vec4(-.417,.771,-.347,.784),vec4(-1.244,.433,.282,.708),vec4(-1.110,.332,-.307,-.019),vec4(-.095,.247,-.111,.711),vec4(-1.250,-.547,-1.219,.353),vec4(.254,.594,.615,.395),vec4(1.395,.910,.160,.040),vec4(.430,.511,-.435,.862),vec4(-.929,-.227,-.799,.607),vec4(-.090,.467,.630,1.750),vec4(-.730,.743,.011,-.161),vec4(-.461,.504,.282,.404),vec4(-1.207,-1.045,-.236,.655),vec4(3.242,-2.972,-.327,1.746),vec4(-1.612,.396,1.730,.471),vec4(.542,-1.501,-.170,-1.278),vec4(.567,-3.133,.282,-1.031),vec4(-.006,-1.114,.773,-2.530),vec4(-.407,-1.221,.707,-.457),vec4(-.935,-.807,.605,-.196),vec4(-.195,-1.508,-.583,-1.617),vec4(-.038,-.251,-1.159,-1.358),vec4(.635,-.191,-1.264,.214),vec4(-1.039,.321,-2.616,-.883),vec4(-1.162,-.649,-.013,.344),vec4(-.980,.304,.040,.083),vec4(.914,-.288,-.495,.698),vec4(.953,-.984,.112,.041),vec4(-.757,-1.895,.358,-.576),vec4(-1.629,-.765,.994,-.803),vec4(.666,.680,1.139,.361),vec4(-.606,1.138,.126,1.239),vec4(-2.132,-.020,-.264,.101),vec4(-.722,-.419,-.579,.681),vec4(-1.277,.367,-.212,-.031),vec4(-.899,-.711,-.811,-.156),vec4(-.860,.561,.030,-.113),vec4(.878,1.401,-.422,-.182),vec4(-.373,1.240,-.938,.009),vec4(-.863,.171,-.627,-.296),vec4(.652,.900,-1.297,.413),vec4(-.506,.024,-.157,-.378),vec4(.446,-.093,.132,-.172),vec4(1.335,.342,.000,.553),vec4(.724,-.438,.523,-.718),vec4(2.324,.952,.466,-.024),vec4(-1.400,1.508,-.963,.122),vec4(.480,-.915,-.330,-.007),vec4(2.460,-1.238,.993,.176),vec4(.675,-1.236,1.413,.342),vec4(.116,1.013,.158,1.108),vec4(-.518,.441,.813,.347),vec4(1.005,.629,-.217,-1.047),vec4(-.775,.202,-.009,-1.471),vec4(.017,-.014,1.382,-.294),vec4(.118,.083,1.985,.180),vec4(-.196,.048,1.455,.151),vec4(-3.264,-1.233,.373,-1.100),vec4(2.287,-2.533,1.030,.140),vec4(-1.105,-2.706,.458,1.032),vec4(-1.937,-3.334,1.080,-1.074),vec4(-1.205,-2.503,1.369,-1.424),vec4(1.700,-.362,1.500,.759),vec4(-1.192,-.284,1.650,-1.232),vec4(-1.290,2.693,1.462,-.514),vec4(.198,1.009,.500,-.284),vec4(-2.059,-.064,-.612,-.120),vec4(-2.813,.140,-.563,-1.523),vec4(-1.557,.358,.055,-.845),vec4(-1.659,-1.039,-1.340,.534),vec4(.090,.902,-1.216,1.387),vec4(.019,-.119,.516,-.349),vec4(.052,-.565,.340,-.072),vec4(-.184,-.271,-.551,-.447),vec4(-.701,.261,-.025,-.082),vec4(-.753,.302,.902,.917),vec4(-1.579,.185,.492,-.248),vec4(1.268,.633,-.391,.621),vec4(-2.741,.676,-3.334,9.053),vec4(1.829,1.747,-2.183,2.649),vec4(2.312,1.406,-1.988,.448),vec4(.110,2.703,-2.150,.786),vec4(.123,-.072,-.819,-.357),vec4(-.124,-.416,-.153,-.714),vec4(.742,-.491,.256,-.479),vec4(.520,.588,-.427,.535),vec4(-.552,.157,.454,-.255),vec4(-1.016,-.828,.411,.041),vec4(.764,-.254,-.806,-.541),vec4(1.709,.782,.158,.267),vec4(1.729,.504,.282,-.603),vec4(-.832,-5.165,2.490,.733),vec4(.670,-2.258,1.814,2.334),vec4(1.342,-1.271,.525,2.821),vec4(-2.025,-.523,1.536,-.566),vec4(-2.804,.241,2.074,-1.390),vec4(.962,-.760,.320,-.515),vec4(-1.513,.520,-.185,-1.150),vec4(.213,.739,-.045,.400),vec4(1.973,.709,-.401,1.158),vec4(.069,2.201,-.412,1.029),vec4(1.226,1.054,-.760,.465),vec4(.399,-.933,.152,.374),vec4(-.037,.099,.669,.796),vec4(.152,1.153,.687,.657),vec4(-1.159,.459,.311,1.252),vec4(-.870,-.318,-.558,.142),vec4(.243,-.298,-.200,.195),vec4(-.205,-.983,1.499,.170),vec4(-.515,1.119,.734,.591),vec4(-4.771,-1.796,-8.085,4.772),vec4(-.465,.049,.785,1.844),vec4(.024,.637,-1.165,-.004),vec4(.051,-.070,.304,.069),vec4(1.114,.392,-.357,1.616),vec4(.011,.072,-.423,-.775),vec4(-1.592,-1.638,-.516,.839),vec4(-1.031,-2.934,1.095,-.511),vec4(.895,-.432,.814,.746),vec4(-.560,-1.205,1.755,.134),vec4(-.506,1.021,2.010,-.020),vec4(-.472,1.592,-1.331,1.127),vec4(-.053,-.158,1.879,.164),vec4(.116,-2.306,2.085,-.976),vec4(.598,-5.165,3.267,3.978),vec4(-1.315,.043,1.374,1.454),vec4(.520,.768,-.518,.286),vec4(1.730,.541,-.806,.591),vec4(-.432,-1.754,-2.279,-1.206),vec4(1.845,-.332,.518,1.701),vec4(.744,-.274,.779,.159),vec4(.746,.144,1.125,-.187),vec4(-.012,-.881,.863,-.722),vec4(.180,1.270,.962,-.390),vec4(.950,.599,-.914,-1.264),vec4(.457,.392,-1.133,-1.306),vec4(.518,-.063,-1.168,.706),vec4(-2.018,-4.039,-2.720,-2.495),vec4(-2.450,-.088,.137,.030),vec4(-.263,-.615,.090,2.181),vec4(.284,.339,-1.335,-.025),vec4(1.000,-2.408,-2.555,.241),vec4(5.380,-4.449,4.641,4.161),vec4(.436,2.369,-.077,.937),vec4(.769,1.471,-.094,-.084),vec4(-.281,.445,-.131,.510),vec4(-.428,.213,-.548,-.040),vec4(.280,-.341,.327,.741),vec4(.806,.744,.668,-.060),vec4(-.535,.414,.702,.583),vec4(-1.183,.845,-.512,-.080),vec4(.234,.603,.434,.055),vec4(.886,-1.197,-.253,.514),vec4(1.381,-.498,1.219,.021),vec4(.787,-.248,1.372,.253),vec4(.809,-1.754,1.267,.098),vec4(.335,-1.944,1.009,-.731),vec4(1.059,-1.257,.431,1.618),vec4(.095,-1.927,-.358,-.205),vec4(2.039,.428,-.577,.975),vec4(.256,.033,.476,-.007),vec4(-.515,-.261,-1.248,.097),vec4(1.954,-.174,-2.232,.947),vec4(-.457,-.688,.230,-.494),vec4(.963,.257,.633,-.945),vec4(-1.623,.575,-.441,-.563),vec4(-.303,.896,1.663,.352),vec4(.586,-.534,2.022,1.360),vec4(-.509,-.236,1.035,1.336),vec4(1.042,-.823,-.734,1.007),vec4(1.456,.821,.183,.054),vec4(.707,-.998,-.193,-.402),vec4(-1.666,.055,-.509,.315),vec4(-2.538,.361,.747,-3.816),vec4(-2.245,-7.493,-2.584,7.588),vec4(1.876,-.707,-.336,-1.921),vec4(1.113,.869,.342,-.935),vec4(-1.161,-.736,-.409,-.879),vec4(-.111,.353,.007,-.784),vec4(.294,-.474,-2.140,-1.396),vec4(.004,.092,-1.095,-.990),vec4(-.689,-.929,.083,-1.619),vec4(1.119,-.159,1.437,-.685),vec4(.099,.337,-1.908,.927),vec4(-.785,-.795,.467,-.398),vec4(-1.373,-.563,.770,-.539),vec4(1.393,-.140,.216,.372),vec4(-.064,-.940,1.272,.936),vec4(.172,-1.642,-.173,.126),vec4(.946,-1.746,1.031,.393),vec4(-.524,-1.011,.788,-.913),vec4(-.861,-2.661,.666,-1.036),vec4(-.277,-.350,.896,1.900),vec4(1.486,-1.959,2.265,-.108),vec4(1.300,-.519,-.839,-.508),vec4(-.707,.769,-.045,-1.379),vec4(-3.323,.710,.309,-1.950),vec4(-.977,.468,.608,-1.710),vec4(-1.590,1.982,-1.420,-.671),vec4(1.220,.898,-2.165,-2.143),vec4(-.031,-.176,-1.194,.021),vec4(.022,.266,.361,-.091),vec4(-.787,-1.647,-1.639,1.229),vec4(-.839,-.014,-1.700,1.115),vec4(-.426,-1.798,-.689,-.525),vec4(-.985,-.438,-1.950,.178),vec4(3.234,-4.124,11.239,6.847),vec4(1.075,1.258,-2.591,4.154),vec4(-3.022,2.622,-2.673,.257),vec4(-.659,-.055,.303,-1.925),vec4(.271,-.301,-.341,-.325),vec4(-.519,.368,.072,-.400),vec4(-.705,-.186,.249,-1.092),vec4(-.006,-.762,.564,-.635),vec4(.294,-.361,.147,-1.341),vec4(1.025,.391,-.728,-.311),vec4(-.105,-.979,.382,-1.419),vec4(.822,.093,.087,.185),vec4(.133,-.648,-.084,-.561),vec4(-1.457,.569,.415,-.109),vec4(-.339,-.550,.192,-.152),vec4(-1.511,-1.973,.077,-1.078),vec4(.488,-1.809,.749,-.147),vec4(-1.322,-2.329,1.602,-1.504),vec4(.197,-.993,1.003,-.167),vec4(-1.425,-2.260,.224,.078),vec4(.056,-.947,.429,-.654),vec4(2.816,2.179,-.573,.805),vec4(1.052,.652,.072,-.401),vec4(-.554,-.078,.946,.764),vec4(-.171,-.770,-.092,.098),vec4(-.267,-2.783,-.760,3.214),vec4(-1.913,-.815,1.300,-.512),vec4(-.430,.146,-3.213,-1.070),vec4(.021,1.677,-.745,-.307),vec4(.661,.240,-.772,-.465),vec4(-.297,.728,-1.093,-.152),vec4(.396,2.096,-1.880,1.176),vec4(.002,1.871,-1.187,-.800),vec4(2.493,-2.627,3.477,2.351),vec4(-3.195,.554,-2.301,-2.905),vec4(.282,-1.085,-1.966,-.496),vec4(.069,-.245,-1.412,-.146),vec4(.178,.422,.195,-.622),vec4(.247,.648,.417,-.197),vec4(.465,.825,.848,-.485),vec4(1.051,1.103,-.178,-.272),vec4(.218,.487,-.610,-.477),vec4(-.490,-.313,.435,.786),vec4(.466,-.381,-.343,-.274),vec4(-.435,.198,-.252,-.554),vec4(-.617,-.505,.516,-.153),vec4(.506,-.711,1.867,-.226),vec4(-.341,-.296,.504,-.929),vec4(.532,-.186,1.174,.207),vec4(-.197,-1.347,2.306,-.069),vec4(.730,-.902,1.046,-.283),vec4(-.266,-1.924,-.853,-.500),vec4(-2.645,-1.408,.650,-.568),vec4(-.605,-1.765,.827,-.041),vec4(-.105,-.105,.862,.893),vec4(-1.352,-.933,1.463,-1.623),vec4(.315,1.840,.167,.194),vec4(-.497,3.681,.553,.928),vec4(-.616,.915,-.101,-1.015),vec4(-1.392,2.405,-1.263,-1.710),vec4(-.160,-.029,1.215,-1.074),vec4(-1.322,-.270,.040,-.272),vec4(1.467,.696,-.696,.426),vec4(.075,-.131,-1.589,-1.290),vec4(-.139,-.126,2.534,-.993),vec4(-.287,-.534,1.681,-.953),vec4(-.517,.704,.768,-.800),vec4(.407,-.942,-1.446,-.749),vec4(-1.351,-.308,-2.021,.461),vec4(-1.174,-.549,-.404,-1.071),vec4(-.150,.732,-.166,-.482),vec4(-.902,.164,.443,-.554),vec4(-.812,.448,.354,-.538),vec4(-.616,.379,.008,.084),vec4(-.499,.361,-.010,-.252),vec4(.453,.412,-.376,.061),vec4(.723,.094,-.642,.010),vec4(.978,.842,-.984,.288),vec4(1.000,.156,.347,.786),vec4(-1.097,-.065,.188,.531),vec4(1.111,.513,-.017,1.606),vec4(.665,-1.248,-.648,-.768),vec4(-2.079,-.891,.042,-1.051),vec4(-1.162,-.979,-.383,.751),vec4(-.520,-.160,.242,-.335),vec4(-1.155,-1.076,.608,-.857),vec4(-.179,-1.697,1.595,-.400),vec4(1.382,.003,-.512,-.090),vec4(1.703,.692,-2.066,-.196),vec4(-1.717,.773,.181,-.284),vec4(1.698,.185,.626,2.601),vec4(1.032,.878,-.380,1.919),vec4(.104,.310,-.779,-.555),vec4(.933,.331,-2.278,-1.249),vec4(-.131,-.141,-1.176,-.149),vec4(.461,.779,1.281,.902),vec4(1.187,.995,-.960,-2.208),vec4(-.166,.288,1.064,-1.525),vec4(1.449,-.100,1.698,-2.782),vec4(-1.091,1.891,-2.415,-1.446),vec4(-.142,.097,.695,-1.200),vec4(-.949,.437,-.319,.137),vec4(-.763,.205,.610,-.460),vec4(.727,.751,-.287,-.537),vec4(-.443,.949,-.106,.190),vec4(-.996,-.390,-.474,-.619),vec4(-1.093,-.081,-.742,-.350),vec4(-1.583,.028,-.773,.238),vec4(-1.314,.517,-1.164,.112),vec4(.598,1.218,-.455,.080),vec4(-.452,.357,.373,.599),vec4(.265,1.006,-.405,.326),vec4(-1.568,.575,.738,-.580),vec4(-.445,.234,-1.365,-.439),vec4(-.949,-2.004,.871,-1.109),vec4(-.684,-.328,.471,.119),vec4(.863,-.349,.687,-.315),vec4(.892,-.191,-.433,-.318),vec4(-.256,-1.557,1.470,-.344),vec4(.415,.185,-.103,-.829),vec4(-.190,1.032,-.234,-.694),vec4(.704,-.138,.716,-.214),vec4(-.227,.619,-.345,-.208),vec4(.173,-.041,-.728,-.686),vec4(.520,1.431,.541,1.534),vec4(.084,.919,-.033,.140),vec4(-.263,-.542,-.549,-2.016),vec4(-3.871,-.339,-.558,-.937),vec4(-.302,.660,.680,-2.287),vec4(.238,.954,.586,-1.050),vec4(1.131,-.265,1.271,1.842),vec4(-5.140,1.756,4.252,-.809),vec4(-.997,-.037,.373,-.326),vec4(-1.391,-.385,.480,-1.283),vec4(-.347,.444,-.316,.023),vec4(.812,.716,-.034,-.649),vec4(.551,.149,-.633,-.458),vec4(-.208,-.071,.889,-1.119),vec4(-.281,1.525,-.562,-.080),vec4(-1.276,.340,-.981,.012),vec4(.205,1.031,-.728,1.035),vec4(-.122,-.040,1.040,.399),vec4(-.172,-.372,-.038,-.001),vec4(.406,-.439,-.115,.527),vec4(.687,-.101,.023,.394),vec4(-.684,.403,.240,.343),vec4(.442,.238,.737,-.243),vec4(.386,-.380,-.468,-.505),vec4(-.442,-.892,-.322,-.947),vec4(1.254,-.093,-.029,-.447),vec4(.634,.772,-.256,-.065),vec4(-.669,.385,.212,-.933),vec4(-1.248,-.105,.220,-1.789),vec4(-.355,.050,.420,-.391),vec4(.232,.356,-.906,-.179),vec4(-.031,1.941,-.578,.239),vec4(.110,-.293,.152,.024),vec4(-.406,-.287,.979,-.393),vec4(-.672,.119,-.541,-.975),vec4(-2.999,-.749,-1.639,-2.679),vec4(-2.098,.894,-.701,-3.170),vec4(.012,-1.379,-.169,-.568),vec4(-1.639,1.265,-1.584,.524),vec4(2.148,.505,1.134,2.504),vec4(-.102,.744,.408,-.497),vec4(-.356,.708,.147,-.010),vec4(.811,.958,-.131,.140),vec4(1.425,1.115,-.326,.178),vec4(.003,.111,.275,-.740),vec4(-1.012,-1.183,.427,.125),vec4(.256,-.106,.604,.217),vec4(-.971,.111,.258,.276),vec4(.335,.207,.542,.627),vec4(.009,.024,.092,.148),vec4(-.421,-.395,.199,.616),vec4(-.545,-1.059,.863,.636),vec4(-.389,.507,-.106,.278),vec4(-.006,-.388,.169,-.468),vec4(.162,-.665,-.029,-.277),vec4(-1.090,-.246,.720,-.107),vec4(.133,-1.045,.388,-1.466),vec4(.939,-.502,-.616,-.562),vec4(-.334,-.194,-.070,-.763),vec4(-.257,.979,-.677,-.063),vec4(-.921,.571,-.460,-.228),vec4(-1.158,.007,-.606,.003),vec4(.255,-.168,-.685,.549),vec4(.190,-.177,-.503,.159),vec4(-1.448,-.347,-.485,.214),vec4(1.505,-.545,.489,.671),vec4(.616,.580,.652,-.184),vec4(-2.062,.760,-1.992,-.428),vec4(3.501,-1.302,.109,-1.226),vec4(-.227,-1.994,-1.004,-.221),vec4(-.277,-.684,-.287,.085),vec4(-2.230,-.075,.775,-1.013),vec4(.503,1.046,.582,-1.078),vec4(-.218,1.124,-.652,-.155),vec4(-.849,.695,-.220,-1.158),vec4(.156,1.239,.781,-.123),vec4(-1.520,-1.250,-.620,-.314),vec4(-.341,-.160,-.001,-.126),vec4(-.183,.250,-.464,.348),vec4(.119,-.392,.280,.535),vec4(-.052,-.658,.652,.285),vec4(-.496,-.744,-.018,.511),vec4(-1.226,-.740,.086,.407),vec4(-2.279,-.872,-.310,.037),vec4(-2.416,-.948,1.274,-.646),vec4(.357,.615,-.758,.213),vec4(-.769,-.585,.186,-1.147),vec4(.629,-.417,.230,.041),vec4(1.036,-.278,-.195,-.578),vec4(1.088,-.852,-.170,-.803),vec4(.402,.439,.951,.942),vec4(-.546,-.068,.736,.359),vec4(-.240,.758,-.935,-.037),vec4(.353,.811,-.537,-.405),vec4(1.468,.020,-1.182,.093),vec4(.180,-.279,-.593,.310),vec4(.656,.049,-.547,-.102),vec4(-.381,-.741,1.041,-.126),vec4(.276,.115,.333,-.625),vec4(-.208,-1.536,.652,-2.261),vec4(1.800,-1.656,5.001,.538),vec4(2.954,1.934,2.566,-1.812),vec4(-1.753,1.215,-3.848,-2.570),vec4(-.004,-.456,-2.675,.606),vec4(-.094,.550,.702,.010),vec4(.040,.460,-.841,-.285),vec4(-.693,.309,-.382,-.300),vec4(-.753,-.371,-.095,-.106),vec4(-.706,.241,-.395,.231),vec4(-.808,-.343,-.659,.458),vec4(-.378,-.468,-.092,.028),vec4(-.292,-.125,.108,.750),vec4(-.394,.288,.161,.781),vec4(-1.084,-.667,-.318,.721),vec4(-2.662,-.349,.749,-.026),vec4(-1.353,-.022,.604,1.056),vec4(-2.619,-1.383,.618,-.324),vec4(-1.135,-.753,.077,-.534),vec4(-.090,.056,.077,.150),vec4(-.178,-1.016,.035,-.002),vec4(-1.252,-1.066,-.401,-.576),vec4(.179,-.690,.155,-.299),vec4(-.786,-1.329,.035,-.523),vec4(-.479,-.369,.367,.043),vec4(1.599,1.064,-.354,.281),vec4(.034,.214,.563,-.320),vec4(-.481,-.522,1.286,-.305),vec4(1.068,.401,.340,.961),vec4(.488,.762,.356,.862),vec4(-.396,-.350,1.465,.394),vec4(-.523,-.835,-.077,-.369),vec4(1.623,-.378,1.855,-.333),vec4(2.556,1.366,4.620,-2.930),vec4(2.932,.647,1.138,1.630),vec4(-.699,6.143,1.806,5.725),vec4(-.333,.412,.965,2.297),vec4(.618,.690,.626,.401),vec4(1.325,.863,-.140,-.078),vec4(-.424,-.063,-.311,.256),vec4(-1.092,.481,-1.951,1.019),vec4(.352,-.527,.214,.778),vec4(-1.145,-1.391,.085,-.096),vec4(-.890,-.146,.278,-.170),vec4(-.808,1.108,-.016,-.329),vec4(-2.008,-.424,.830,.695),vec4(-2.941,-.738,.477,-.285),vec4(-2.063,.092,1.973,1.113),vec4(.267,.706,-.111,1.453),vec4(.473,.664,-.058,1.091),vec4(.638,.978,-.108,-.534),vec4(-.628,.143,-.750,-.413),vec4(-1.541,-.021,-.680,.012),vec4(.199,.829,.176,-.537),vec4(-.584,-.043,.876,-.696),vec4(-.636,-.610,-1.646,-.450),vec4(.741,1.429,-1.039,1.205),vec4(1.223,1.245,-.470,.149),vec4(.024,-.401,.119,-.192),vec4(.542,-.606,1.193,-.635),vec4(.738,.596,.722,1.013),vec4(1.046,-.064,.623,-.998),vec4(1.891,1.566,2.561,1.069),vec4(.585,1.465,-.576,.048),vec4(-.103,1.743,-.361,.843),vec4(2.910,3.991,.699,.933),vec4(3.192,8.412,-.019,1.142),vec4(-1.212,1.680,5.506,11.508),vec4(-1.501,.107,1.725,-.699),vec4(1.209,.811,1.189,.936),vec4(2.145,.274,-.915,-.096),vec4(.548,.411,-.361,.381),vec4(2.351,-1.049,.855,2.801),vec4(-.468,-1.513,-2.003,1.270),vec4(-.036,-.185,.347,.759),vec4(-1.305,1.915,-.177,.164),vec4(-.254,-2.113,-1.097,1.232),vec4(-2.360,-2.255,-1.250,-.045),vec4(-.618,-1.138,-2.419,1.063),vec4(.736,-2.358,.173,1.585),vec4(-1.195,1.461,1.957,1.072),vec4(1.179,-.835,-1.932,.367),vec4(1.145,-.042,-1.285,.646),vec4(-.335,.748,-.558,.628),vec4(1.002,1.161,-1.082,.040),vec4(.772,.425,-.731,.500),vec4(-1.981,-.704,-.112,-.508),vec4(1.103,.544,-2.133,.945),vec4(-1.579,.329,.278,.615),vec4(-1.360,.663,.184,-1.531),vec4(.760,-.240,-.115,1.300),vec4(-.569,-1.253,.233,-1.773),vec4(.854,1.031,.456,1.439),vec4(-.928,-.225,1.186,-1.707),vec4(3.399,.618,.121,.075),vec4(.551,.713,-.516,-.507),vec4(.698,.910,.203,1.007));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed2[idx];\n}", "buffer_c_inputs": [], "buffer_d_code": "const vec4 embed3[1024] = vec4[](vec4(-3.721,1.032,-1.290,.228),vec4(-2.708,1.004,-3.012,.808),vec4(-.284,2.124,-2.980,-.312),vec4(-.569,1.830,-.050,1.393),vec4(-2.307,1.905,-2.519,-.035),vec4(-6.008,9.009,1.701,4.591),vec4(-2.488,1.860,-1.921,-2.905),vec4(-4.297,-1.598,-2.083,-.090),vec4(1.987,-.778,-.341,-2.709),vec4(-.777,3.334,-1.375,.102),vec4(-3.213,-1.426,.805,.767),vec4(-1.083,-1.376,.374,1.282),vec4(1.384,.602,-4.387,-2.200),vec4(1.517,-1.344,1.761,-.608),vec4(-3.034,-1.661,-1.520,.827),vec4(-3.630,4.000,-2.795,-3.583),vec4(6.080,2.922,4.112,2.196),vec4(-.102,1.418,1.269,1.495),vec4(-3.206,-3.530,-3.396,3.470),vec4(.617,3.067,-.501,-1.309),vec4(.120,5.465,-.644,.710),vec4(-.850,3.418,2.125,-2.223),vec4(.019,-.958,-2.433,.844),vec4(-5.489,2.412,.587,-.097),vec4(-3.386,1.824,1.807,-.744),vec4(1.885,1.395,-1.688,-.771),vec4(-1.138,-.434,1.494,1.959),vec4(2.520,.085,-.021,.440),vec4(.007,-3.639,-.069,.041),vec4(2.067,-.380,1.542,1.047),vec4(-3.325,.782,-3.483,-1.896),vec4(-1.072,2.567,-1.069,2.592),vec4(-2.696,.640,-2.488,.609),vec4(-3.025,.209,-2.802,.723),vec4(-1.244,.542,-2.455,1.060),vec4(-1.586,.548,-1.159,1.970),vec4(-.570,2.352,-2.000,2.728),vec4(-3.763,-.862,.926,2.090),vec4(1.291,3.062,3.139,-1.285),vec4(.838,-.874,.881,-.481),vec4(.572,-1.927,1.004,.121),vec4(.827,.092,-.979,.093),vec4(1.135,.630,-1.181,.196),vec4(-1.696,-1.195,-.262,1.700),vec4(1.185,-2.134,.244,.532),vec4(-1.583,-.405,.358,-.071),vec4(-1.352,-.192,-1.455,-.476),vec4(-1.156,-.288,.802,-.489),vec4(1.833,1.391,1.057,2.226),vec4(-.480,-.089,-1.033,.898),vec4(2.297,-1.780,-.723,5.005),vec4(.030,4.869,-1.815,-2.403),vec4(-1.017,1.602,-1.108,-.199),vec4(-1.158,-.462,1.100,.207),vec4(.823,-.746,-3.403,-.473),vec4(-.332,1.244,-.884,-.525),vec4(-2.008,1.430,.688,-.304),vec4(.416,1.927,-1.500,-.990),vec4(1.496,-.524,-.173,-.520),vec4(.311,1.268,-.336,.610),vec4(.012,-1.715,-1.036,1.471),vec4(-.095,-.734,-2.592,-.852),vec4(-.852,-1.263,1.305,1.311),vec4(2.950,3.567,-1.379,1.260),vec4(-.461,1.852,-1.276,.154),vec4(-.823,.683,-1.258,.812),vec4(-1.901,-.328,-2.129,1.767),vec4(-.770,.104,-.136,.432),vec4(-1.199,3.564,2.984,2.208),vec4(-.554,2.100,-5.676,1.012),vec4(-2.839,-2.253,4.259,-.274),vec4(2.832,-2.305,-1.021,.064),vec4(-.105,-1.310,.223,.271),vec4(1.488,.101,-1.818,-.719),vec4(-.478,1.135,-.581,.585),vec4(.620,.050,-.721,1.403),vec4(1.527,.771,2.229,-1.531),vec4(-1.261,-.582,-.485,-.617),vec4(-1.153,1.031,-.324,-3.996),vec4(-.427,.757,-.785,.246),vec4(-.173,-.395,.316,1.048),vec4(-.261,-.843,1.212,-1.255),vec4(1.023,-.705,.743,1.952),vec4(-1.079,2.147,-1.452,-1.520),vec4(-.321,.820,-1.816,.410),vec4(.440,.552,1.362,.573),vec4(-2.761,.633,-1.186,.133),vec4(.264,-1.913,-.816,1.869),vec4(.027,.689,-.223,-.007),vec4(.709,1.836,.211,1.011),vec4(-1.852,.102,.171,-1.142),vec4(1.693,2.366,-1.945,.482),vec4(.914,1.712,-1.646,2.040),vec4(.485,-.313,-.459,-1.131),vec4(-1.031,.542,-1.501,.722),vec4(2.143,-1.389,1.072,-.084),vec4(-.193,1.866,-.675,1.376),vec4(-.504,.279,-.131,1.504),vec4(-2.993,-.113,-.405,.263),vec4(-2.189,2.351,-2.750,-.003),vec4(-5.047,.452,-3.789,-.964),vec4(-2.153,-.099,7.059,.797),vec4(-1.194,-1.521,.685,1.196),vec4(.387,-.584,.625,1.080),vec4(1.470,-.212,-.366,2.768),vec4(-.813,-1.876,1.022,1.121),vec4(.707,-.434,-2.037,.770),vec4(-.640,.037,-1.105,1.740),vec4(.417,1.729,.904,-.089),vec4(-.095,1.243,1.309,-1.156),vec4(-.113,-.213,-.697,-.566),vec4(.529,.167,-.387,.025),vec4(-.056,-.604,.223,.057),vec4(-1.020,-1.663,-.021,-.476),vec4(.173,-.515,-.962,-.143),vec4(-.876,-.832,-.582,-1.555),vec4(-1.660,1.136,.030,-.219),vec4(.695,-.123,-.143,2.013),vec4(-.679,1.334,3.000,.144),vec4(1.286,-1.141,.698,-.508),vec4(.690,2.754,-.645,-.505),vec4(1.493,-.439,-.091,2.805),vec4(.051,.409,-.374,-.693),vec4(.858,.526,-.740,.648),vec4(-.390,.859,-1.217,.476),vec4(.360,-.182,.080,1.036),vec4(-2.139,-1.536,-1.176,1.040),vec4(.101,1.837,-1.663,1.026),vec4(.428,1.897,-.494,-.761),vec4(.109,1.185,.129,1.458),vec4(-.999,.700,.339,1.082),vec4(-4.483,.450,-2.673,.240),vec4(-.025,-2.142,2.336,-1.534),vec4(.390,-1.669,2.565,-.681),vec4(1.500,-.913,-.208,-.570),vec4(.605,1.167,2.806,-.255),vec4(.142,-2.203,-.617,.400),vec4(-.316,1.232,1.872,.690),vec4(-.875,-2.103,-.406,.469),vec4(1.111,-.400,-1.952,.798),vec4(-2.346,-.344,-1.793,-.792),vec4(-.641,-.670,2.171,.691),vec4(.682,.829,-.965,-.222),vec4(-.248,1.573,-.186,-.191),vec4(.037,.579,.928,-.172),vec4(-.679,-.466,.302,.021),vec4(-.122,.267,-1.775,-.078),vec4(.268,-.556,-.012,-.462),vec4(-.179,-1.164,.252,-1.406),vec4(-1.838,1.368,.553,.512),vec4(.776,.577,.269,-.214),vec4(-.981,1.523,-.543,-.033),vec4(-1.371,.311,-.679,-.024),vec4(-3.504,-1.287,-.922,2.123),vec4(.443,-.507,-3.330,.640),vec4(-1.241,-.898,1.199,1.464),vec4(3.476,-.219,-.087,1.190),vec4(-1.116,-.788,-.073,1.055),vec4(-1.907,-.842,-.449,.142),vec4(-.306,-1.484,-1.016,.122),vec4(-.874,.730,-.179,1.907),vec4(-.118,2.462,2.993,.931),vec4(-.545,1.205,-1.083,1.500),vec4(-3.545,-.833,-4.910,-6.555),vec4(-3.775,.195,-1.820,-4.060),vec4(.132,1.097,-2.281,.981),vec4(.747,-1.639,-1.891,-.085),vec4(-.280,-.533,-.021,-1.722),vec4(.300,-.624,-.815,.175),vec4(2.047,-1.307,-.966,-2.908),vec4(-.431,-.111,-.945,-.621),vec4(-.449,.287,-.196,.007),vec4(-.106,1.169,-1.650,-.121),vec4(2.293,-.705,1.247,.787),vec4(-1.337,-.688,.077,.173),vec4(.956,.406,.005,.249),vec4(-.570,-.111,.734,-.241),vec4(-.201,-.850,.804,-.239),vec4(-.009,-.045,-.257,.612),vec4(-.236,.138,.225,1.260),vec4(.380,.568,-.345,-2.111),vec4(-2.282,3.319,-.165,-.063),vec4(.954,.424,-2.471,.889),vec4(-.444,1.573,-.210,1.269),vec4(-.583,-.640,-.544,1.632),vec4(-.300,.077,-1.689,-1.916),vec4(1.101,.599,-.682,.175),vec4(2.146,-.182,-1.856,1.085),vec4(2.367,-.321,1.457,-.510),vec4(.616,.718,1.631,.548),vec4(-.404,.025,.487,-.272),vec4(-3.045,-1.472,-.068,-4.706),vec4(2.020,-.037,-1.179,2.956),vec4(-.998,2.049,1.495,-.050),vec4(-3.242,1.267,2.127,2.878),vec4(-3.572,-2.012,.297,-1.021),vec4(-.666,-.469,-.584,.726),vec4(1.542,-.453,-.830,.682),vec4(-1.201,-.115,-.646,-.157),vec4(-.087,-.794,.813,.250),vec4(1.473,-.156,.319,-1.795),vec4(-.782,2.018,.784,.344),vec4(1.120,-2.264,-.290,1.345),vec4(.584,.479,1.648,.426),vec4(.197,-.155,-1.147,-.624),vec4(-.034,-.967,-1.163,.208),vec4(.076,.672,-.373,1.303),vec4(-.073,.116,.465,-.460),vec4(-.765,-.847,.765,.036),vec4(-.622,-.870,.709,-.035),vec4(-.660,-.817,.276,.163),vec4(-.913,-.395,.296,.427),vec4(-1.352,-.938,.138,.186),vec4(-1.300,1.134,-1.163,-1.499),vec4(.860,-.456,-2.203,.420),vec4(3.249,2.018,1.559,3.252),vec4(.525,.599,1.141,.382),vec4(1.031,1.670,.389,1.429),vec4(2.411,2.330,-.940,-.013),vec4(.237,1.343,4.821,-.746),vec4(-.360,1.908,.031,-.056),vec4(1.675,.212,-.522,-.872),vec4(-.578,.743,-.721,.819),vec4(.672,4.431,5.533,-.278),vec4(-4.974,4.992,1.266,.532),vec4(-.645,.416,2.612,-.620),vec4(-1.044,1.945,1.658,-1.682),vec4(3.209,-1.602,-.941,4.117),vec4(-1.153,.178,-.320,.020),vec4(-.247,.214,-1.329,.499),vec4(-.126,-.454,.052,-.453),vec4(1.340,1.600,.116,.041),vec4(.406,2.197,-.497,2.170),vec4(-.639,.953,-.723,1.629),vec4(-1.639,-.183,-2.092,.759),vec4(-.516,-.904,-.110,2.030),vec4(1.537,-1.455,.511,-.655),vec4(1.646,1.015,.145,-1.007),vec4(.189,.470,-.065,1.758),vec4(.164,.183,.421,.180),vec4(-.877,-.984,.026,-.086),vec4(-.543,-1.314,.159,-.451),vec4(-.030,-.405,.011,-.904),vec4(-1.018,-.776,.460,.706),vec4(-.685,.335,.095,.047),vec4(.026,.420,.985,.282),vec4(1.400,.610,.475,.145),vec4(-.661,-.407,-2.319,-.162),vec4(1.206,-.062,.047,2.698),vec4(-1.021,.663,.201,.913),vec4(-1.494,1.594,-1.361,-.171),vec4(.660,2.574,-1.562,-.034),vec4(2.073,2.467,-.602,1.015),vec4(-2.016,-.460,-.759,.474),vec4(-.886,1.171,-.879,.026),vec4(3.766,-3.931,-1.119,-1.126),vec4(-7.473,-1.549,13.314,4.105),vec4(-1.330,.453,-7.007,-.430),vec4(-3.866,1.540,.656,-2.431),vec4(-.271,1.204,-.119,.253),vec4(-1.938,-1.146,-.159,.265),vec4(-1.430,.009,.087,.060),vec4(-1.981,.952,-.875,.742),vec4(.030,-.332,.252,.116),vec4(.045,-.013,-1.403,2.495),vec4(.324,-1.479,-1.132,3.193),vec4(.548,.604,-1.657,2.863),vec4(-2.126,1.776,-1.141,3.270),vec4(-2.967,.446,.426,.222),vec4(1.418,1.578,.174,-1.165),vec4(-.010,.377,-.507,.186),vec4(.270,.270,.700,1.204),vec4(.168,-1.283,-.564,-.840),vec4(-.042,-1.304,-.394,-.857),vec4(-.792,-.358,.177,-.707),vec4(-1.426,-.390,.809,.559),vec4(.396,-.583,.455,-.561),vec4(.800,1.211,1.320,-1.186),vec4(-2.492,.177,.144,-1.306),vec4(-1.376,1.173,-.378,-.399),vec4(-3.126,-.573,-1.058,-.929),vec4(-1.220,.287,.228,.313),vec4(.787,.928,-.079,-.268),vec4(-.397,.417,1.012,1.011),vec4(.075,-.456,-1.538,.143),vec4(.431,1.607,-1.483,.171),vec4(.012,.900,-1.466,-.754),vec4(-1.134,3.156,-2.850,3.515),vec4(-2.406,-.253,1.282,-5.718),vec4(3.501,.597,2.707,1.519),vec4(2.055,-.229,-.250,.325),vec4(-.098,.043,1.395,.562),vec4(-.906,1.823,.662,.690),vec4(-.853,-1.515,-.476,-.695),vec4(-.295,-2.808,2.329,-.424),vec4(.630,-2.277,.851,.251),vec4(-.555,-1.141,-1.175,3.200),vec4(1.031,-.187,-1.123,5.085),vec4(-.813,2.379,-1.267,1.973),vec4(-1.194,1.215,.243,3.105),vec4(-.225,1.525,-.814,.705),vec4(.557,1.156,-.355,-2.030),vec4(.435,.668,-.091,-.351),vec4(.121,-.314,.830,.351),vec4(-.117,-.369,.402,-.484),vec4(.137,-.460,.353,-.873),vec4(-.405,-.783,.505,-1.481),vec4(-.753,-2.434,.719,-1.319),vec4(.519,1.822,.425,-1.131),vec4(1.856,2.214,-1.239,-.812),vec4(.722,.219,-1.208,3.033),vec4(-1.289,2.641,-1.276,1.555),vec4(-1.456,.516,-.850,-.356),vec4(-.175,1.455,-.093,2.151),vec4(.753,-.049,-2.340,1.484),vec4(-.892,-1.445,-1.543,.262),vec4(.321,.942,-.363,-.056),vec4(-.771,-.996,1.141,.664),vec4(-2.679,-1.952,.036,2.263),vec4(.040,.309,-1.200,-.492),vec4(-.001,3.579,.435,1.410),vec4(2.439,1.302,1.680,.103),vec4(1.993,-.641,.091,.960),vec4(.455,-.910,-.909,.690),vec4(1.422,-1.252,-.493,.409),vec4(.789,-1.759,-.397,.479),vec4(-.091,.569,-1.810,1.840),vec4(-.282,.183,.074,1.757),vec4(1.166,1.442,-.551,-.205),vec4(1.251,-1.261,-2.722,6.172),vec4(-1.346,.697,-1.630,4.881),vec4(.854,3.505,-.703,3.557),vec4(-.638,-.562,-3.434,3.117),vec4(1.205,1.801,.642,-2.377),vec4(.893,.430,.971,-.533),vec4(.576,.360,1.270,.450),vec4(-.554,-.613,.621,-.010),vec4(-.608,.395,1.286,-.344),vec4(.344,-.744,.866,-.866),vec4(-.112,-.178,.486,-1.022),vec4(-3.920,-2.498,-1.741,-5.240),vec4(.035,2.463,-.082,2.171),vec4(2.169,.857,-.454,7.445),vec4(-1.337,2.203,-1.784,-.552),vec4(-4.267,1.741,-1.480,-.378),vec4(-.065,-.286,.062,1.122),vec4(-.772,.098,-1.655,.446),vec4(-.103,.063,-.904,1.843),vec4(-.896,.915,.065,.540),vec4(-2.711,.689,-1.061,.514),vec4(.952,1.572,1.566,.241),vec4(3.471,1.104,1.937,1.191),vec4(.145,-.706,.820,.209),vec4(-.022,-1.291,.401,.861),vec4(1.045,.799,2.295,.646),vec4(.113,.451,.214,1.032),vec4(-1.398,.743,.281,-.499),vec4(.925,-.271,-.225,.360),vec4(-.106,-1.835,2.011,.650),vec4(1.602,.785,-.806,.142),vec4(.517,-.736,-.735,-1.960),vec4(1.112,1.069,-.374,-1.009),vec4(-.169,-.206,.176,2.124),vec4(-.192,.603,-.882,2.149),vec4(.977,3.564,-.389,1.275),vec4(.508,.410,1.506,-1.399),vec4(.438,.002,.781,-1.190),vec4(-.160,-.077,.436,-.872),vec4(.247,-.185,.929,-.385),vec4(-.891,-.505,.353,-.954),vec4(-.670,-.196,.246,-.193),vec4(.115,.328,.240,-.873),vec4(-.544,-2.550,-3.683,-3.203),vec4(-3.645,2.081,-2.892,2.640),vec4(1.110,-1.533,.089,6.054),vec4(1.927,3.915,-1.241,2.904),vec4(.290,1.474,-.259,2.028),vec4(.750,.776,-1.583,2.080),vec4(-1.024,.663,-1.935,-.290),vec4(-2.045,-.584,-.306,-1.167),vec4(-1.494,-1.446,-2.115,1.108),vec4(1.685,-.358,1.121,1.480),vec4(-.155,.408,2.830,1.605),vec4(1.081,1.082,-.860,.362),vec4(-.445,-1.432,-.389,1.343),vec4(.020,-.003,-.420,.652),vec4(.210,-.184,-.626,.363),vec4(-1.682,2.894,-.588,-.824),vec4(-.479,2.550,-.062,.456),vec4(-.629,.816,-1.045,.256),vec4(1.024,-.386,-1.095,.477),vec4(-1.268,-1.795,-.637,-1.598),vec4(-.389,.025,.690,-.697),vec4(-.330,-.163,.455,-.809),vec4(-.122,.376,-2.051,-.532),vec4(-.076,.527,-1.794,-.045),vec4(.538,-.428,.163,.930),vec4(.440,-.762,.339,-.267),vec4(.409,1.395,-.116,-1.385),vec4(.150,-.366,.441,-.749),vec4(.193,-.655,.239,-.264),vec4(-.355,-.020,.091,.194),vec4(-.196,.319,-.148,-.288),vec4(1.604,.809,.105,.746),vec4(1.142,-1.276,-.000,.173),vec4(.078,2.105,-2.282,-1.603),vec4(.007,.240,-2.233,.031),vec4(1.555,-.352,-1.580,2.170),vec4(.802,-.485,-2.015,1.272),vec4(-1.440,-1.350,-.365,-.457),vec4(-.963,.168,.130,1.358),vec4(.073,-.616,.000,.721),vec4(.872,.583,1.865,.041),vec4(1.180,.669,-3.319,.129),vec4(-.983,-2.167,-3.019,-.599),vec4(.518,1.464,-5.193,.277),vec4(-.446,2.567,.128,-2.220),vec4(.756,.241,-.418,-.062),vec4(2.571,-.350,-.011,.578),vec4(3.267,1.522,.003,1.445),vec4(1.656,1.419,-.377,.159),vec4(1.265,1.576,-1.372,-.210),vec4(2.352,-.693,-1.698,-.541),vec4(-.766,-3.268,1.715,1.203),vec4(-.583,-2.114,.446,-.844),vec4(-1.054,-.277,.197,-.072),vec4(.290,.975,-1.386,.119),vec4(.240,-.321,-1.583,-.357),vec4(.415,-.185,-1.233,-.839),vec4(-.643,-.178,-.307,.466),vec4(-.674,-.635,1.623,-.891),vec4(-.515,.108,1.593,-.089),vec4(.651,-.035,.405,-1.055),vec4(.869,-.645,-.113,-1.769),vec4(1.528,.158,-.568,-1.861),vec4(-.307,-.501,.074,-.082),vec4(.379,.019,.379,-.018),vec4(.386,-1.096,.949,.131),vec4(-.227,-.081,.077,-1.486),vec4(.978,.079,.149,-.656),vec4(.398,1.188,-.784,-.420),vec4(.296,.196,.155,.125),vec4(.869,-.085,1.063,-1.389),vec4(-.331,2.156,-.864,-2.621),vec4(-.803,.832,-1.817,-.513),vec4(-.224,-.200,.710,-1.343),vec4(.097,.773,-.114,-.075),vec4(2.724,4.213,.106,1.713),vec4(.858,-1.568,-.117,1.035),vec4(-.475,-.032,-.035,1.821),vec4(-2.252,.264,-1.244,.902),vec4(-1.798,.663,.412,.963),vec4(-1.314,-1.101,-.527,1.070),vec4(-.410,.433,1.039,.928),vec4(-.737,.460,2.979,-.384),vec4(-.294,-.111,-.377,.228),vec4(-1.014,-1.407,-.946,1.072),vec4(-1.111,-1.611,.648,-.131),vec4(.563,.480,.505,-.234),vec4(.550,-.333,-.207,.080),vec4(.003,.312,-.618,-.206),vec4(.082,-.505,.531,-1.121),vec4(-.325,-.600,1.956,-.604),vec4(.164,.525,1.317,1.130),vec4(-.286,-.361,.808,-.365),vec4(-.026,-.860,2.084,-.440),vec4(-.255,.046,.546,-1.241),vec4(-.384,-1.617,.042,-.170),vec4(-.017,-1.357,1.063,.307),vec4(-.018,-.746,.212,.958),vec4(-.205,-1.017,-.161,.755),vec4(.216,-.630,.370,.912),vec4(.491,-.862,.230,.170),vec4(-.151,.058,-.105,-.111),vec4(.141,.986,-.818,.867),vec4(-.423,.380,-.323,-.110),vec4(-1.798,.144,-1.224,-1.159),vec4(-1.959,-1.034,-1.365,.024),vec4(-2.164,1.499,-.066,.162),vec4(-2.434,-2.742,.426,-1.621),vec4(1.029,.308,-1.929,1.056),vec4(-.525,-.616,-1.879,1.113),vec4(.835,.886,-.363,.456),vec4(.267,-.295,-.837,.288),vec4(.239,-.762,-.339,.567),vec4(.452,-.375,-1.061,-.923),vec4(-.738,-.683,-.804,-.355),vec4(1.034,.543,-.670,-.216),vec4(.578,-.172,-.576,-.655),vec4(.333,-.196,.191,-.932),vec4(.242,.402,.470,-.283),vec4(.239,1.064,1.294,-.109),vec4(.350,.551,-.141,-.220),vec4(1.117,-.244,.494,-.174),vec4(.454,-.179,.912,-.144),vec4(1.315,-.510,1.578,.400),vec4(.398,-.698,1.403,.980),vec4(.716,-1.150,1.033,-.278),vec4(-1.220,-.293,1.282,.354),vec4(.247,-1.049,.522,-.682),vec4(-1.490,-1.361,.149,-.410),vec4(-.977,-.179,-.317,-1.245),vec4(-.021,.122,-.119,.615),vec4(-.721,-1.137,-.103,-1.270),vec4(.169,.182,.322,-.418),vec4(1.013,.363,-.297,1.086),vec4(1.041,1.905,.209,.948),vec4(.913,1.745,-1.845,.920),vec4(-1.475,.112,-.762,.262),vec4(-1.832,.029,-.942,-1.037),vec4(-1.586,.266,1.825,-.116),vec4(-1.845,3.200,5.848,-.085),vec4(-2.679,1.716,2.983,2.950),vec4(1.225,.200,1.085,2.001),vec4(-.302,.609,-.441,1.716),vec4(.521,-.286,.260,.667),vec4(-.635,-.971,-.511,1.527),vec4(-.609,.161,-.716,.399),vec4(.079,1.019,-.762,.815),vec4(-.231,.170,-1.098,1.258),vec4(-.516,-.506,.227,.522),vec4(-1.154,.176,-.560,.125),vec4(-.132,1.049,.584,-.854),vec4(-.582,-.378,.013,-.163),vec4(1.446,1.083,-.666,-1.888),vec4(2.092,-.685,1.102,.381),vec4(1.733,-1.042,2.453,-.066),vec4(.515,-2.770,1.446,-.524),vec4(.739,-1.536,1.696,.118),vec4(.219,-1.034,1.236,-.466),vec4(-.435,-.776,-.155,-.547),vec4(.858,-1.139,.311,-.900),vec4(.925,-.833,1.159,-.213),vec4(.264,.833,-.962,-.016),vec4(-.158,.988,.503,-.789),vec4(-.666,-.280,-1.622,-1.560),vec4(-.060,.094,-.739,-.802),vec4(-.847,-.333,-.908,.455),vec4(-1.425,-.190,-1.016,.262),vec4(-.454,-.026,-.304,-.221),vec4(1.650,.399,.762,-.148),vec4(-.071,-.742,.552,1.120),vec4(-.044,-1.343,.294,-.320),vec4(1.204,-1.793,1.751,-1.403),vec4(-10.220,-.410,-4.898,1.004),vec4(-3.383,.222,-2.028,.711),vec4(-1.407,-1.409,.618,.764),vec4(-1.472,-1.104,-1.003,-.095),vec4(-.468,.154,-1.000,-.419),vec4(-.140,-.149,-.264,-.654),vec4(.572,-1.111,.625,.073),vec4(.113,-.348,-1.082,.703),vec4(-.149,-.416,-.937,-.461),vec4(.124,.891,-.451,.163),vec4(-1.033,-.377,-.156,-1.349),vec4(-.599,-.262,-1.005,-.802),vec4(2.142,-1.521,-.562,.827),vec4(3.046,.407,1.918,-2.423),vec4(2.501,-.690,1.915,-3.915),vec4(-1.129,-1.157,2.239,-1.244),vec4(1.234,-2.709,1.638,1.176),vec4(-.108,-.615,.811,-1.026),vec4(.607,-1.106,.566,.086),vec4(-.374,-.211,1.154,-.648),vec4(-1.059,-.759,1.080,.109),vec4(.757,.899,1.428,-1.942),vec4(.092,-.373,.792,-.323),vec4(.300,1.317,.318,-.202),vec4(.337,.509,-.704,.606),vec4(-.246,.614,.143,-.061),vec4(-1.079,-.499,-.093,.585),vec4(-1.008,-.770,-.311,.751),vec4(-.835,-.492,-.541,.497),vec4(-.222,-.402,-.036,.548),vec4(.246,-.463,-.354,-.791),vec4(.000,.225,-.865,-1.893),vec4(.778,-.277,8.758,-4.709),vec4(2.263,.763,4.538,-.992),vec4(.406,-.975,1.089,.510),vec4(.230,.073,.930,1.250),vec4(1.034,1.276,.391,.913),vec4(-.675,.452,-.144,1.214),vec4(-.889,-.675,.080,.757),vec4(-1.583,-.565,-.225,1.152),vec4(-1.237,-1.513,-.546,1.309),vec4(-.500,-.088,.376,1.889),vec4(-.551,-.697,-.067,1.271),vec4(-.699,-1.312,.095,1.031),vec4(-.177,-1.339,1.265,-.904),vec4(4.990,-1.012,2.233,1.958),vec4(4.967,-1.601,2.361,.510),vec4(3.729,-1.919,.905,1.364),vec4(.431,1.050,1.587,-1.680),vec4(.045,.646,1.091,.507),vec4(.743,.868,2.150,-1.814),vec4(-.629,-.577,1.743,-.562),vec4(-.405,-.118,.310,.035),vec4(-.430,1.141,2.208,.718),vec4(-.099,.971,-.654,-.251),vec4(-1.091,-.330,-.695,-.102),vec4(-.544,.738,.081,-.499),vec4(-.682,.042,-.804,-1.287),vec4(-.968,-1.957,-1.543,-1.176),vec4(-.805,.259,-1.276,.117),vec4(-1.493,-.424,-.929,.268),vec4(-.684,-.854,-.888,.275),vec4(1.279,1.384,.265,.008),vec4(.931,.397,-.083,.136),vec4(-5.949,-1.199,4.051,-6.413),vec4(-1.051,-1.318,-.278,-.861),vec4(.090,-.663,.262,.579),vec4(-.379,-.144,-.382,.468),vec4(.964,1.328,-.331,.798),vec4(-.597,-.435,-.503,1.153),vec4(-.863,.354,-1.580,1.097),vec4(.063,-1.114,.990,.942),vec4(.788,-.817,1.998,1.384),vec4(.780,-1.245,.953,-.166),vec4(1.158,-2.823,1.001,-.438),vec4(1.831,-.113,-.071,-.582),vec4(-.040,-.459,.216,-.486),vec4(1.219,-1.492,2.410,.319),vec4(5.512,-.796,1.062,-.026),vec4(1.000,-2.636,1.794,-.707),vec4(-.658,.848,1.577,.072),vec4(-2.611,-1.920,-.080,-2.456),vec4(.233,-.790,-.346,-1.753),vec4(-.778,-.058,-.024,-.935),vec4(-.530,.650,-1.089,.462),vec4(-.669,.752,-1.590,.230),vec4(.854,1.818,-.524,.365),vec4(-1.032,-.543,-.078,-.430),vec4(-.749,-.742,-.571,.094),vec4(.772,.315,1.718,1.355),vec4(.190,.871,2.972,1.357),vec4(.778,2.173,-.988,-.902),vec4(-1.318,-.320,-1.363,.756),vec4(.519,1.970,-.779,-.001),vec4(.374,1.123,.956,-.355),vec4(.703,1.069,2.029,.843),vec4(-.067,.641,2.242,-18.313),vec4(-.595,1.520,-1.031,-.623),vec4(-.875,-.750,-.210,-.465),vec4(-.325,-.362,-.986,-.113),vec4(.171,.506,-.465,1.013),vec4(-.085,1.223,.533,.202),vec4(-1.026,-.205,.191,.240),vec4(2.347,.233,.180,.123),vec4(2.366,.093,.134,.743),vec4(.629,-.365,.126,.347),vec4(.343,.084,.053,.702),vec4(1.471,-1.518,2.167,-1.315),vec4(.167,.530,1.266,-.769),vec4(-1.445,1.071,.931,-.659),vec4(.621,1.208,.141,-.327),vec4(-.208,-.510,-.585,-1.151),vec4(-.075,.019,.196,-.032),vec4(-.962,-2.387,-.271,-.723),vec4(-.663,2.420,1.193,-1.509),vec4(-2.446,.483,-1.555,-.705),vec4(-.595,1.275,.505,-.899),vec4(-.686,-.803,-.930,.729),vec4(.084,1.629,-1.046,-.689),vec4(-.306,.681,-1.558,.478),vec4(.115,.312,-.347,-.543),vec4(-1.993,.435,-.929,-1.053),vec4(-1.485,-1.013,-.896,-.654),vec4(-1.184,-3.735,3.342,2.550),vec4(-.517,-4.045,2.611,.444),vec4(-.596,-2.502,1.000,.049),vec4(-.435,-1.196,-.008,1.617),vec4(.952,1.023,-.887,.266),vec4(-1.625,3.931,1.874,1.135),vec4(.724,1.266,1.045,-5.279),vec4(-.050,-.738,-.081,-.855),vec4(.353,.297,.095,.191),vec4(.075,.394,-.203,.285),vec4(-.036,1.693,-.687,.182),vec4(-.863,.872,-1.033,.395),vec4(.031,.146,-.417,.081),vec4(.045,-1.915,-.023,.673),vec4(-.069,-1.998,-.560,1.052),vec4(.514,.073,.149,.863),vec4(-.272,-.366,.634,.920),vec4(.446,-.537,.282,.303),vec4(-.401,-.863,-.064,.269),vec4(-.849,-.515,.387,.710),vec4(-.931,1.085,.590,-1.368),vec4(-1.092,.735,1.116,-.902),vec4(-1.948,.400,-.754,-.544),vec4(-1.271,.247,-.804,-1.614),vec4(-1.508,1.079,.443,-.248),vec4(.262,.242,-.085,-.739),vec4(-.184,.972,-.196,.633),vec4(1.651,.528,.478,1.169),vec4(1.705,.996,1.250,1.811),vec4(1.772,-.916,1.064,2.654),vec4(.258,-1.706,-.081,.741),vec4(-1.115,-1.469,-.175,.283),vec4(-.076,.215,1.035,-.045),vec4(-.016,-.517,-1.261,.621),vec4(.612,-.532,-.527,1.581),vec4(-.254,.071,-.747,.285),vec4(-.661,-3.318,1.794,1.471),vec4(-8.862,3.811,-8.476,4.122),vec4(-1.075,.118,1.753,-1.011),vec4(-.545,-.091,-3.404,-2.766),vec4(-.068,-.585,-.010,-.737),vec4(.501,1.398,.510,.459),vec4(-.163,.663,-.157,.660),vec4(-.801,-.031,-.347,.362),vec4(-.787,1.300,.636,-.265),vec4(-2.935,.252,1.374,-.966),vec4(.889,1.081,-.245,.411),vec4(.635,-.218,.078,.708),vec4(-.572,-1.746,-.949,.247),vec4(-.562,-1.048,-.695,.201),vec4(.698,1.102,.404,-.443),vec4(-.603,.334,.525,-.362),vec4(-.231,.874,.514,-1.180),vec4(-.943,.610,1.027,-.745),vec4(-.987,1.031,-.331,.120),vec4(-.763,1.626,-.043,-.486),vec4(-2.026,.611,-1.076,.547),vec4(-1.772,1.050,-.027,.399),vec4(.335,-.235,.923,.025),vec4(.087,-.413,.623,-.338),vec4(-.330,-1.144,-3.434,-.743),vec4(.253,1.176,-.612,-.554),vec4(1.530,-.359,-.598,2.090),vec4(-1.319,.223,-2.271,1.021),vec4(-3.003,-1.509,-1.093,-.956),vec4(-.077,.760,.601,-.445),vec4(.828,.638,.116,-.054),vec4(.352,-.961,-.332,.473),vec4(-.086,-4.204,-.718,.073),vec4(-.256,.946,1.286,-.451),vec4(-4.861,2.158,-2.854,2.559),vec4(.090,.777,2.700,-1.344),vec4(2.254,-1.396,1.782,.318),vec4(.318,-.175,.061,.588),vec4(.386,.482,-.017,.474),vec4(.466,.628,-.210,.023),vec4(-1.404,-1.048,.265,-.461),vec4(-.511,-.251,-.324,-.055),vec4(-.082,.376,-.113,.693),vec4(-.735,.002,-1.240,.436),vec4(-.304,-1.195,-1.718,-1.108),vec4(-.906,-.129,.597,.678),vec4(-.044,.496,-1.423,-.859),vec4(.066,.381,.108,-1.095),vec4(.656,.989,-1.927,-1.194),vec4(-.909,.580,.628,-1.111),vec4(-2.037,1.331,1.396,-.032),vec4(-1.321,.841,.713,-1.477),vec4(-.365,1.920,-.688,-1.688),vec4(-.741,.895,-1.089,1.069),vec4(-.756,-.270,-.985,-.857),vec4(.181,-.291,-1.416,-1.359),vec4(.719,.755,-.736,-1.298),vec4(-1.066,.728,.989,-1.448),vec4(-1.064,1.078,.354,-1.331),vec4(-.627,.375,-1.037,-.235),vec4(-.717,.786,-3.270,.215),vec4(.294,.271,-.950,-.285),vec4(-.446,-.186,-1.213,-.003),vec4(-1.162,1.053,.649,.246),vec4(-1.288,1.037,.852,1.925),vec4(-3.975,1.692,-2.299,1.618),vec4(-1.922,1.619,-1.282,1.826),vec4(-.745,2.132,-1.081,1.561),vec4(1.110,-1.459,.438,.595),vec4(.477,-.609,-1.226,.176),vec4(.476,.281,.906,.643),vec4(.354,.808,.574,.345),vec4(-.568,.332,.600,.261),vec4(-.321,.378,-.059,-.069),vec4(-.558,-.137,-.283,.194),vec4(-.368,.171,-.620,.252),vec4(-.015,.865,-.605,.683),vec4(-.196,.494,-.423,-.109),vec4(.053,-.299,.942,-.338),vec4(1.106,1.489,-.071,-.503),vec4(.899,.682,-.702,.642),vec4(-1.536,-.962,-1.000,.615),vec4(-.733,1.984,-.162,.203),vec4(.230,.576,.411,.293),vec4(-.711,.936,-.127,.693),vec4(-.336,.341,-.094,-.242),vec4(.885,1.561,.188,-.476),vec4(1.314,-1.055,-1.172,.228),vec4(.024,.825,-.394,-1.053),vec4(.803,1.956,-.355,-1.455),vec4(.161,-.767,-1.856,-.511),vec4(.210,-1.430,1.239,1.317),vec4(.077,.184,.062,.778),vec4(-1.140,.201,-.245,.408),vec4(-1.431,.882,.725,-.630),vec4(.734,.988,.360,-1.679),vec4(.963,.108,-.839,.379),vec4(-.870,1.066,-2.458,1.171),vec4(-1.628,1.440,-.109,1.201),vec4(-2.998,3.283,1.152,3.781),vec4(.951,.064,-1.226,-.803),vec4(.020,-1.615,-.272,-.815),vec4(.052,-.093,-.444,.409),vec4(-.631,.884,.402,.369),vec4(.129,.612,-.157,.117),vec4(-1.263,.257,-.546,.272),vec4(-.089,.409,-.747,.094),vec4(-.757,-.218,-.179,1.262),vec4(.648,.038,.728,.618),vec4(.051,-.624,1.581,.054),vec4(-.093,-.075,1.016,.175),vec4(.816,.744,.091,.576),vec4(1.127,.978,.702,-.549),vec4(1.240,.922,-.634,.195),vec4(-.459,.291,-.351,.285),vec4(-1.341,-.285,-.781,-.044),vec4(.786,.216,.568,.601),vec4(-.101,-.729,.197,-.185),vec4(1.505,1.310,-.162,-.174),vec4(.393,-.307,-.505,-.812),vec4(-1.605,-.538,-.584,-.340),vec4(-.702,.092,-.566,-.179),vec4(.805,.164,.310,-1.261),vec4(.899,.783,-.526,-.019),vec4(-.781,-.464,.144,-.049),vec4(.421,-3.362,.813,-1.085),vec4(.003,-1.150,.616,-.029),vec4(.640,-1.532,.102,-.741),vec4(1.392,-1.164,-1.209,-2.428),vec4(-.175,.302,-1.021,2.922),vec4(-3.029,.286,-.650,.323),vec4(-8.176,1.746,-2.344,5.182),vec4(3.154,.679,.003,-2.908),vec4(.978,1.369,-.761,-1.433),vec4(-.054,-.357,.135,.525),vec4(-.126,.934,-.439,.784),vec4(.332,.731,-.107,-.054),vec4(.458,.669,-.429,.070),vec4(.168,.422,.449,-.021),vec4(-.299,-.597,.819,-.006),vec4(-.822,-.527,.355,.080),vec4(-.659,-.605,.130,-.153),vec4(-.512,-1.025,.617,-.006),vec4(.420,.041,.236,-.169),vec4(.094,-.284,.126,-.026),vec4(-.013,-.021,.511,.385),vec4(.158,-.159,.004,-.272),vec4(-1.542,-.862,-1.182,-.421),vec4(-.422,.334,-.200,.499),vec4(.030,.911,.555,.506),vec4(.971,-.548,.683,-.365),vec4(-.566,-.101,.386,-.234),vec4(-1.267,-.086,-.043,.098),vec4(-.913,-.640,-.279,-.402),vec4(.157,.161,.067,-.119),vec4(-.080,.613,.117,.523),vec4(-.516,-.137,-.327,.381),vec4(.599,-.012,-.415,-.661),vec4(.070,-.168,.043,-.872),vec4(-1.515,-1.031,.382,.794),vec4(-2.404,-1.998,-1.277,-1.742),vec4(-.852,2.794,-1.440,2.532),vec4(-4.496,-.420,-1.580,2.213),vec4(-1.129,1.705,-.385,1.884),vec4(1.904,-.569,.388,-1.103),vec4(-.005,-.471,-.141,-.137),vec4(.353,.247,-.091,.293),vec4(.557,.141,-.293,.423),vec4(.630,.049,-.306,.232),vec4(-.243,-.122,-.871,.437),vec4(.283,.183,.606,-.691),vec4(-.321,-.579,.512,-1.221),vec4(-.200,-.531,1.041,-.729),vec4(-.490,-1.011,.483,-.838),vec4(-.247,-.883,-.351,-.670),vec4(-.090,-.511,-.070,-.048),vec4(.282,.835,.058,-.697),vec4(.174,.413,.778,.087),vec4(.455,.481,-.491,-1.105),vec4(-.269,.236,-.399,-.341),vec4(.543,.065,.895,-.372),vec4(.002,-.543,-.313,-.556),vec4(.676,-.305,-.368,-.747),vec4(-.322,-.184,-.430,.272),vec4(-1.201,-.236,-.518,.131),vec4(-.728,.152,-.830,.323),vec4(-.268,.281,-.217,.405),vec4(.022,.072,.640,.454),vec4(-.428,-.571,.331,.886),vec4(.136,.824,.244,.626),vec4(.338,-.029,.157,-.034),vec4(-1.106,-2.298,.525,.020),vec4(-1.540,.128,1.229,.072),vec4(-4.927,-.641,-.522,2.719),vec4(-4.335,1.435,-1.917,2.350),vec4(-4.482,1.219,1.959,-1.035),vec4(-2.521,.362,-.965,-.734),vec4(-.816,-2.917,.226,.140),vec4(-.121,-.917,-.273,1.084),vec4(-.114,-1.563,-.383,1.102),vec4(-.224,-1.422,.234,.594),vec4(.264,.133,-.379,.351),vec4(-.682,-.922,.651,-.234),vec4(-.815,-1.255,.296,.059),vec4(-.247,-.787,.032,-.786),vec4(-.588,-.308,.325,-1.179),vec4(-.368,-.135,-.335,-.924),vec4(.050,-.266,-.780,-.523),vec4(.618,.699,-.646,.352),vec4(.493,1.054,.414,-.291),vec4(-.047,.271,.591,.509),vec4(-.237,.477,.819,-.341),vec4(.493,-.018,.625,-.170),vec4(.328,-.156,-.329,-.423),vec4(.229,-.173,-.916,-.303),vec4(1.045,.672,.059,-.282),vec4(.217,-.089,-.493,-.031),vec4(-.344,.181,-.483,.768),vec4(-.402,.946,-.468,-.218),vec4(-1.082,-.727,-.140,.423),vec4(-.576,-.737,-.461,.175),vec4(-.100,.755,.079,.620),vec4(-.165,-.393,.047,-.063),vec4(-1.165,.001,1.113,-.462),vec4(-.936,.165,2.056,-.014),vec4(-6.024,-.183,.460,-.286),vec4(-5.500,1.927,-1.796,5.889),vec4(.457,1.688,.933,-2.173),vec4(-2.126,-.082,-.993,.322),vec4(-2.747,-1.001,.763,.519),vec4(-.501,-1.078,-.119,1.369),vec4(-.762,-1.027,.246,1.842),vec4(.009,.177,.213,1.244),vec4(.189,.023,-.066,.609),vec4(.228,.606,.164,-.166),vec4(.117,.339,-.076,-.674),vec4(-.229,-.200,-.339,-.461),vec4(.400,-.323,-.223,-.038),vec4(.738,-.140,-.324,-.822),vec4(-1.033,-.537,.474,-.467),vec4(-.555,-.531,-.079,1.031),vec4(1.571,1.895,.241,.069),vec4(-.258,.738,.772,-.167),vec4(-.970,.150,.171,.288),vec4(.343,1.377,-.201,-.022),vec4(-.227,.359,-.176,.643),vec4(-.409,-.303,-.689,-.239),vec4(.268,1.101,-.768,.262),vec4(.514,.656,-.512,-.088),vec4(-.190,-.160,-.560,-.371),vec4(.178,-.335,-.401,-.356),vec4(-.424,-.002,.057,.540),vec4(.807,.516,-1.857,-.383),vec4(-.498,-1.243,-1.259,-.336),vec4(.124,-.075,.834,-.145),vec4(-.284,-.536,.113,.625),vec4(-.789,1.014,1.024,-.048),vec4(.735,3.048,-.965,2.259),vec4(2.517,1.667,.599,1.928),vec4(1.261,.397,1.115,.281),vec4(1.257,-.627,.774,.896),vec4(-.382,-1.300,.925,.840),vec4(-1.134,-.922,.243,.309),vec4(-.783,-.209,.109,1.717),vec4(.167,.464,.032,.338),vec4(.832,-.289,-.047,-1.171),vec4(1.284,-.746,-.015,-1.087),vec4(.315,-.826,-.241,-.431),vec4(-.042,-1.288,-.049,.093),vec4(-1.296,-.573,.240,-.131),vec4(-.367,-1.140,.786,-1.040),vec4(-1.141,-1.538,.951,1.218),vec4(.436,.662,.686,1.315),vec4(-.208,.220,.681,1.021),vec4(-1.244,-.531,-.355,.141),vec4(-1.267,1.187,-.838,.778),vec4(.850,.800,.209,.601),vec4(-2.249,-1.247,.189,.341),vec4(-.992,-.534,-.551,-.701),vec4(-.681,.841,-.881,-.579),vec4(-.145,.343,-.650,-.371),vec4(-1.056,.366,-.363,-.439),vec4(-2.174,-.405,-.708,-.119),vec4(.141,-.004,-.621,-.550),vec4(.352,1.213,-.774,-.149),vec4(-.274,-.140,-1.122,-1.303),vec4(-.104,-1.495,-1.307,-3.147),vec4(.251,.632,-.996,.080),vec4(-.458,-.715,-2.350,.068),vec4(6.656,1.500,2.591,.897),vec4(1.837,9.540,-3.235,6.684),vec4(-9.834,.549,-7.284,-6.673),vec4(.935,-.994,1.089,.317),vec4(-.813,-1.410,.874,.636),vec4(-1.832,.722,-.125,.472),vec4(1.106,-.988,-.330,.231),vec4(.724,.420,2.832,.037),vec4(-1.632,1.133,3.044,-.552),vec4(-.960,1.045,1.764,2.914),vec4(-.944,-.312,.010,3.230),vec4(.177,.696,-1.247,1.058),vec4(.954,.937,-2.459,-2.465),vec4(.175,-1.330,-1.108,-.262),vec4(1.602,.499,.062,2.103),vec4(-1.881,-.536,-.752,.926),vec4(-1.347,-1.063,-.273,1.395),vec4(1.116,.135,-1.338,1.734),vec4(-.207,.326,-1.978,-.295),vec4(.815,-.245,1.132,-1.017),vec4(-1.571,.551,.133,1.091),vec4(-1.385,-.332,-.565,.688),vec4(-.804,-.188,-.983,.632),vec4(-2.847,1.595,-1.353,-.331),vec4(.634,1.635,-.336,-.732),vec4(-.977,-.238,-.766,-.245),vec4(-.117,-.605,-.546,.418),vec4(-.290,.891,-1.259,.247),vec4(.354,.024,-.608,-.554),vec4(-1.626,-.236,-.893,-1.992),vec4(-.168,-.089,-.654,.642),vec4(.834,.323,.096,.177));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed3[idx];\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdd3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 366, 422, 422, 6724], [6727, 6727, 6769, 6769, 6984], [6986, 6986, 7052, 7052, 7214], [7216, 7216, 7238, 7238, 7574], [7576, 7576, 7633, 7633, 7860]], "test": "untested"}
{"id": "cst3zX", "name": "Collecting some github stars", "author": "mrange", "description": "CC0: Collecting some github stars\nDo I get the senior dev job now?\n\nAnother meme shader\n", "tags": ["github"], "likes": 26, "viewed": 335, "published": 3, "date": "1677617850", "time_retrieved": "2024-07-30T18:07:44.800840", "image_code": "// CC0: Collecting some github stars\n// Do I get the senior dev job now?\n\n// Another meme shader\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float cw = 0.05;\nconst float bw = 0.5*cw*23.0/32.0;\nconst float br = cw*3.0/32.0;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagram(vec2 p, float r) {\n  const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n  return length(p)*sign(p.y);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 rgbb  = 1.0/vec3(255.0);\n  const vec3 bgcol = pow(rgbb*vec3(14.0, 17.0, 23.0), vec3(2.0));\n  const vec3 fgcol = pow(rgbb*vec3(24.0, 27.0, 34.0), vec3(2.0));\n  const vec3 locol = pow(rgbb*vec3(40.0, 68.0, 42.0), vec3(2.0));\n  const vec3 hicol = pow(rgbb*vec3(132.0, 210.0, 91.0), vec3(2.0));\n  float aa = 2.0/RESOLUTION.y;\n  float aaa = cw;\n  vec2 cp = p;\n  vec2 np = mod2(cp, vec2(cw));\n  \n  vec3 col = bgcol;\n  \n    if (abs(np.y) < 13.0) {\n    \n    np.x += TIME*10.0;\n    float nep = mod1(np.x, 24.0);\n    float nh0 = hash(nep+123.4);\n    float nh1 = fract(8667.0*nh0);\n  \n    vec2 ep = np*cw;\n    float r = mix(0.25, 0.5, nh0)*1.0; \n    float pt = mix(0.5, 1.0, nh1);\n  \n    float ft = mod(TIME+pt*nh1, pt);\n    ep.y -= -mix(2.0, 1.0, nh1)*(ft-pt*0.5)*(ft-pt*0.5)+r-0.5+0.125;\n    ep *= ROT(2.0*mix(0.5, 0.25, nh0)*TIME+TAU*nh0);\n\n    float ed = hexagram(ep, 0.5*r);\n    ed = abs(ed)-0.05;\n    \n    float cd = box(cp, vec2(bw-br))-br;\n  \n    vec3 ecol = mix(fgcol, hicol, smoothstep(aaa, -aaa, ed));\n    \n    col = mix(col, ecol, smoothstep(aa, -aa, cd)); \n  }\n  \n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cst3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 451, 490, 490, 615], [617, 703, 739, 739, 833], [835, 953, 980, 980, 1056], [1058, 1118, 1140, 1140, 1188], [1190, 1308, 1341, 1341, 1570], [1572, 1572, 1602, 1602, 2716], [2718, 2718, 2775, 2775, 2951]], "test": "untested"}
{"id": "csdGzX", "name": "Mesh Gradient ChatGPT Test#3", "author": "sasa42", "description": "Hi. Can you generate me a Shadertoy Shader with an mesh gradient which you can change with mouse input.", "tags": ["mouseinput", "meshgradient"], "likes": 1, "viewed": 267, "published": 3, "date": "1677616741", "time_retrieved": "2024-07-30T18:07:45.864995", "image_code": "// Shadertoy Shader by ChatGPT\n// Mesh gradient with mouse input control\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Define the size of the mesh and the number of segments\n    vec2 meshSize = vec2(3.0, 3.0);\n    vec2 segments = vec2(30.0, 30.0);\n\n    // Calculate the position of the current pixel in normalized coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Calculate the position of the current pixel in mesh coordinates\n    vec2 meshCoord = uv * meshSize;\n\n    // Calculate the color of the current pixel based on the distance from the center of the mesh\n    vec2 center = meshSize / 2.0;\n    float dist = distance(meshCoord, center);\n    vec3 color = vec3(dist);\n\n    // Use the mouse position to adjust the mesh gradient\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 gradient = vec2(mouse.x, mouse.y);\n    meshCoord -= gradient;\n\n    // Calculate the segment size\n    vec2 segmentSize = meshSize / segments;\n\n    // Calculate the segment index of the current pixel\n    vec2 segmentIndex = floor(meshCoord / segmentSize);\n\n    // Calculate the position of the current pixel relative to its segment\n    vec2 segmentCoord = fract(meshCoord / segmentSize);\n\n    // Calculate the four corners of the current segment\n    vec2 bottomLeft = segmentIndex * segmentSize;\n    vec2 bottomRight = bottomLeft + vec2(segmentSize.x, 0.0);\n    vec2 topLeft = bottomLeft + vec2(0.0, segmentSize.y);\n    vec2 topRight = bottomLeft + segmentSize;\n\n    // Calculate the distances between the current pixel and the four corners\n    float distBL = distance(meshCoord, bottomLeft);\n    float distBR = distance(meshCoord, bottomRight);\n    float distTL = distance(meshCoord, topLeft);\n    float distTR = distance(meshCoord, topRight);\n\n    // Calculate the weights for each corner based on the distance\n    float weightBL = 1.0 - (distBL / dist);\n    float weightBR = 1.0 - (distBR / dist);\n    float weightTL = 1.0 - (distTL / dist);\n    float weightTR = 1.0 - (distTR / dist);\n\n    // Calculate the final color of the current pixel by interpolating between the four corner colors\n    color = mix(color, vec3(1.0), weightBL);\n    color = mix(color, vec3(0.0), weightBR);\n    color = mix(color, vec3(1.0, 0.0, 0.0), weightTL);\n    color = mix(color, vec3(0.0, 1.0, 0.0), weightTR);\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 129, 191, 2371]], "test": "untested"}
{"id": "dd33zf", "name": "Neural Catthink", "author": "michael0884", "description": "cathink", "tags": ["catthink"], "likes": 17, "viewed": 387, "published": 3, "date": "1677613163", "time_retrieved": "2024-07-30T18:07:47.103683", "image_code": "//So essentially I trained a small image with embeddings(here its 16*16 by 16 embeddings), which after interpolation we pass through a neural net to get the output color\n//The ouput neural net is just a siren here\n//The embeddings are interpolated using the hacky C2 smooth interpolation, to fix the 0 nodes in the gradient we have 2 grids, one offset by half pixel\n\nvec3 model(vec4 e0_0 ,vec4 e0_1 ,vec4 e0_2 ,vec4 e0_3 ){\nvec4 e1_0=sin(4.0 * (mat4(.527,-.002,.021,-.100,-.161,-.179,.073,-.049,.328,-.260,-.225,-.095,.408,-.169,-.197,.413)*e0_0+\n    mat4(.397,-.003,.097,.322,.306,-.231,.051,-.331,.188,.247,-.080,.151,-.016,.142,-.219,.218)*e0_1+\n    mat4(.224,-.139,.078,.275,-.150,-.036,.002,.491,-.217,.071,-.142,.475,.318,.016,.006,.108)*e0_2+\n    mat4(-.182,-.152,-.144,-.330,.142,.144,.054,.035,.514,.058,.001,-.077,-.477,-.194,-.155,-.010)*e0_3+\n    vec4(.040,-.415,.291,.234)))+e0_0;\nvec4 e1_1=sin(4.0 * (mat4(-.146,-.119,.053,-.060,.057,.017,-.118,.055,.008,.149,-.044,.134,-.082,.015,-.017,.075)*e0_0+\n    mat4(-.163,-.070,-.155,.047,-.122,-.194,.003,-.269,-.238,-.160,-.106,-.119,-.084,-.300,.092,.038)*e0_1+\n    mat4(-.038,.074,-.121,.121,-.016,.118,.006,.054,.237,-.134,.292,-.108,-.040,-.359,.079,.281)*e0_2+\n    mat4(-.067,.027,-.096,.045,-.195,-.000,-.144,.101,-.097,-.278,.016,-.174,.071,-.031,-.048,.135)*e0_3+\n    vec4(.008,-.153,-.121,.323)))+e0_1;\nvec4 e1_2=sin(4.0 * (mat4(.286,-.063,-.151,.113,-.419,.446,.013,.047,-.177,.190,.048,-.135,-.311,-.242,.126,-.058)*e0_0+\n    mat4(.011,.064,-.056,.095,.132,-.285,-.083,-.341,.171,.365,.100,-.263,-.056,-.328,-.040,-.092)*e0_1+\n    mat4(.004,.118,.187,-.034,.066,.182,.147,.077,-.641,-.329,-.157,-.142,-.107,-.124,.212,-.200)*e0_2+\n    mat4(-.388,.233,.199,-.083,-.149,-.280,.123,-.030,.235,.083,.185,-.031,-.105,-.009,-.117,.061)*e0_3+\n    vec4(-.143,.182,.384,-.179)))+e0_2;\nvec4 e1_3=sin(4.0 * (mat4(.124,-.086,.072,.009,.171,-.126,-.018,-.156,-.206,.110,.189,-.177,.341,.125,.054,-.085)*e0_0+\n    mat4(-.037,-.005,-.107,.025,.175,-.030,-.293,-.064,-.009,-.117,.160,.165,.045,.087,-.172,-.198)*e0_1+\n    mat4(-.262,-.228,-.008,-.429,.050,.034,-.028,-.203,.017,.123,-.041,.110,.292,-.204,-.006,-.206)*e0_2+\n    mat4(.054,-.129,.100,-.145,.140,-.055,-.266,-.133,.245,-.064,-.182,-.100,.256,-.037,.130,-.077)*e0_3+\n    vec4(-.085,-.237,.031,-.084)))+e0_3;\nvec4 e2_0=sin(1.0 * (mat4(-.544,.278,.160,.029,-.488,-.502,.492,.003,-.272,.674,.120,-.438,-.529,.453,-.339,-.155)*e1_0+\n    mat4(.201,-.128,-.210,-.512,.322,.324,-.099,-.308,-.637,-.257,-.296,-.443,-.408,.180,.192,.159)*e1_1+\n    mat4(.734,.119,.101,.499,.292,.603,.039,.609,-.081,.066,.178,.396,.160,.534,.171,-.336)*e1_2+\n    mat4(.564,.505,-.222,-.265,.517,-.273,-.205,.505,.222,-.474,.480,-.215,.314,.136,.599,.617)*e1_3+\n    vec4(.192,-.544,-.075,.055)))+e1_0;\nvec4 e2_1=sin(1.0 * (mat4(-.277,.214,-.388,.009,.321,.317,-.297,-.027,-.450,.443,-.344,.139,-.611,-.056,-.193,.186)*e1_0+\n    mat4(-.027,.249,-.139,.024,-.507,.013,.192,-.108,.118,.167,.008,.159,-.537,-.297,-.183,-.772)*e1_1+\n    mat4(.050,-.340,.384,-.157,.254,-.016,-.019,.167,-.183,-.481,-.208,-.521,.293,-.438,-.005,-.042)*e1_2+\n    mat4(.074,-.716,.249,.075,.733,-.428,.425,.008,-.059,-.640,.270,.062,-.224,.217,-.056,-.250)*e1_3+\n    vec4(-.040,.110,-.369,-.273)))+e1_1;\nvec4 e2_2=sin(1.0 * (mat4(.230,-.000,-.004,.095,-.417,.058,-.145,.053,.654,.001,-.033,-.055,-.063,.268,.353,.314)*e1_0+\n    mat4(-.058,.125,.019,-.589,-.146,.632,-.155,-.466,.118,.436,.249,.061,.510,.189,-.619,-.388)*e1_1+\n    mat4(-.304,.351,-.332,.828,.235,-.301,.630,.591,-.133,.019,-.206,.061,.217,.091,-.492,.168)*e1_2+\n    mat4(.088,-.118,-.077,.171,-.056,.128,-.430,.089,-1.279,-.092,-.634,-.710,-.301,.696,.071,.158)*e1_3+\n    vec4(.068,-.045,.345,.490)))+e1_2;\nvec4 e2_3=sin(1.0 * (mat4(.361,-.338,.293,.357,.346,-.032,-.454,-.572,-.012,.299,.545,.248,.146,.064,.306,.005)*e1_0+\n    mat4(.131,.657,-.250,.047,-.306,.159,.271,.380,.284,.649,-.247,.304,.390,.447,.270,-.208)*e1_1+\n    mat4(.266,-.078,.156,-.670,-.210,.679,.508,.469,.060,.067,-.084,-.089,-.108,-.033,.941,-.405)*e1_2+\n    mat4(-.389,.502,.643,-.005,.027,-.162,-.278,-.283,-.404,.134,-.482,-.204,.687,.036,-.089,-.007)*e1_3+\n    vec4(.324,.084,.084,.101)))+e1_3;\nfloat e_0=dot(e2_0,vec4(-.064,-.128,-.040,-.097))+\n    dot(e2_1,vec4(-.106,.071,-.176,.033))+\n    dot(e2_2,vec4(.054,.077,.067,.080))+\n    dot(e2_3,vec4(.124,.042,.085,-.046))+\n    0.429;\nfloat e_1=dot(e2_0,vec4(-.062,-.117,-.061,-.106))+\n    dot(e2_1,vec4(-.116,.080,-.182,.059))+\n    dot(e2_2,vec4(.063,.069,.071,.085))+\n    dot(e2_3,vec4(.127,.045,.092,-.052))+\n    0.368;\nfloat e_2=dot(e2_0,vec4(-.067,-.108,-.076,-.120))+\n    dot(e2_1,vec4(-.114,.091,-.184,.100))+\n    dot(e2_2,vec4(.070,.063,.080,.097))+\n    dot(e2_3,vec4(.128,.046,.098,-.052))+\n    0.329;\nreturn vec3(e_0, e_1, e_2);} \n\nvec4 smoothSample(sampler2D ch, vec2 uv)\n{\n\tuv = uv*iResolution.xy + 0.5;\n\tvec2 iuv = floor(uv);\n\tvec2 fuv = fract(uv);\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/iResolution.xy;\n\treturn texture(ch, uv);\n}\n\nvec4 sampleEmbed(sampler2D ch, vec2 uv, int embed, float offset)\n{\n    vec2 pix = (1.0 - uv) * float(embed_texture-3) + 2.0 + vec2(embed, 0) * float(embed_texture + 2) + offset;\n    return smoothSample(ch, pix/iResolution.xy);\n}\n\nvec3 decode(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec3(0.0);\n    vec4 e0_0 = sampleEmbed(iChannel0, uv, 0, 0.0);\n    vec4 e0_1 = sampleEmbed(iChannel1, uv, 0, 0.0);\n    vec4 e0_2 = sampleEmbed(iChannel2, uv, 0, 0.5);\n    vec4 e0_3 = sampleEmbed(iChannel3, uv, 0, 0.5);\n    \n    return model(e0_0, e0_1, e0_2, e0_3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*((fragCoord - vec2(iResolution.x - iResolution.y, 0)*0.5)/iResolution.y - 0.5) + 0.49999;\n\n    //vec3 col = sampleEmbed(iChannel1, uv, 0).xyz;\n    vec3 col = decode(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec4 embed0[576] = vec4[](vec4(.403,.387,-.818,.295),vec4(-1.782,1.013,-2.410,1.784),vec4(-.511,.633,-1.332,-.349),vec4(-1.417,1.115,-2.641,2.941),vec4(-1.131,-1.100,1.909,2.146),vec4(.090,.052,.376,-1.168),vec4(.372,-.380,.702,-1.270),vec4(.936,-1.082,-.297,1.269),vec4(.130,-1.758,-.227,.943),vec4(3.396,-1.789,.264,.620),vec4(-1.410,-1.530,-1.419,-.413),vec4(-.173,-.209,-.516,1.569),vec4(1.823,.963,-.561,.057),vec4(-.395,-.357,.313,.408),vec4(-3.064,-1.635,-1.901,.098),vec4(-1.073,.970,-.633,-.673),vec4(-2.746,1.694,2.354,-1.816),vec4(3.433,-.353,-3.276,1.071),vec4(1.223,1.941,-.199,-1.420),vec4(-.533,-.441,1.125,-.655),vec4(.681,.856,-.192,-.217),vec4(1.266,-.245,-1.110,-.891),vec4(-2.355,.009,-.089,.800),vec4(-.184,-.229,.596,-.272),vec4(-1.098,.831,-2.273,1.475),vec4(-2.019,.361,-.787,1.320),vec4(-.594,1.542,-1.955,.451),vec4(.056,-2.337,-4.012,-.727),vec4(-.962,1.471,.856,-.000),vec4(.863,1.387,.475,-.667),vec4(-.246,-.618,.045,.828),vec4(-.543,-.238,.063,-.625),vec4(1.194,.980,.433,-1.515),vec4(-.320,1.072,.752,1.237),vec4(.260,-.450,.535,-.242),vec4(-.279,-.365,-1.163,.672),vec4(.899,-.029,-1.239,.815),vec4(-1.226,.778,-.183,.243),vec4(.271,-.914,-1.215,-.567),vec4(-.926,1.265,-1.183,.047),vec4(-1.079,-.958,-1.822,-.600),vec4(-1.180,.397,1.422,-.937),vec4(.155,.315,-1.380,1.230),vec4(.049,-.725,-.452,-.650),vec4(-.815,-.793,-.333,.436),vec4(-.361,-.519,1.112,.715),vec4(-.804,.801,.757,-.419),vec4(-.317,2.358,1.503,-1.536),vec4(.058,1.529,-.934,-2.482),vec4(-.921,1.665,-.224,-1.529),vec4(.610,.953,1.187,1.376),vec4(-2.041,2.391,-1.123,1.541),vec4(1.327,-1.048,1.261,-2.412),vec4(-.216,-.247,.795,-.346),vec4(-1.106,-.818,1.288,.362),vec4(-.124,-.979,-1.915,.918),vec4(.697,.499,-.442,-2.014),vec4(1.061,-.447,1.366,.550),vec4(-.952,.214,-.156,-1.100),vec4(1.273,.497,-.394,-.000),vec4(-.320,-.166,.004,.094),vec4(.685,.395,.129,.184),vec4(.606,.612,-2.249,-.532),vec4(-1.562,-.491,.103,-.552),vec4(.312,.914,-1.597,2.699),vec4(-1.550,-1.495,-.547,-1.131),vec4(.260,-.452,-.410,.067),vec4(-1.444,-1.859,-2.657,1.440),vec4(.270,.289,-.621,-1.509),vec4(.591,.913,.100,-.015),vec4(-1.674,.865,.926,-.784),vec4(.282,-.496,1.219,-.196),vec4(1.249,.311,.558,-.383),vec4(2.253,.260,-.015,-.967),vec4(3.789,.085,.114,-1.410),vec4(.123,-2.007,2.880,-.686),vec4(-.264,-.354,-.330,.145),vec4(-1.237,1.217,1.523,-1.034),vec4(.486,.780,.429,.810),vec4(-1.079,.611,-.608,-1.697),vec4(2.544,.397,-1.736,.278),vec4(1.248,-.204,.417,-1.561),vec4(.502,.866,-.520,.535),vec4(.943,.883,-.875,.658),vec4(.500,-.024,-.189,.415),vec4(-.335,.146,.007,.950),vec4(.487,1.137,-1.006,.078),vec4(.889,.746,-.826,.306),vec4(1.620,.398,.634,1.311),vec4(-.854,-1.474,-.454,.489),vec4(-1.979,.234,-1.304,.241),vec4(-1.639,-2.304,-1.110,-.511),vec4(1.190,.568,-.415,-1.664),vec4(-1.474,.590,.323,-.288),vec4(1.903,1.202,.601,-.535),vec4(.217,1.859,-2.346,.344),vec4(2.720,.624,-.562,1.152),vec4(.601,1.298,-.641,.489),vec4(-2.058,-.330,-1.039,-1.114),vec4(-.992,-1.263,.054,-.341),vec4(.446,-1.098,1.631,-.765),vec4(.190,.240,1.107,-.374),vec4(-1.438,-.155,.319,.684),vec4(-.333,-.397,.284,-.711),vec4(-.087,-.053,.355,.048),vec4(-.373,-.164,-.082,1.108),vec4(.804,.262,-.124,.114),vec4(.578,.191,-.895,.337),vec4(.503,-.017,-.288,.305),vec4(-.027,-.360,-.128,.647),vec4(.435,-.324,-.779,.681),vec4(1.013,1.396,-.253,.589),vec4(-.188,-2.608,.580,-1.018),vec4(-.026,.775,-.556,-1.064),vec4(-.699,.057,-.151,.795),vec4(1.194,.367,-.886,-.779),vec4(-.039,-.168,-.201,-1.034),vec4(-.086,.892,.837,.347),vec4(-.588,-1.252,-.417,.991),vec4(-.855,-.767,-.266,-.687),vec4(1.015,1.293,-4.386,2.780),vec4(.876,1.072,-2.005,-.782),vec4(-.325,-1.959,-.467,-.039),vec4(.132,-.379,-.115,.137),vec4(.574,.190,-1.011,-.805),vec4(.157,-.699,.693,-.582),vec4(-.243,-.625,-.682,.047),vec4(.918,.657,-2.094,.756),vec4(-.376,.277,.905,.360),vec4(.320,-.519,.073,-.196),vec4(.655,.438,.012,-.128),vec4(.222,.217,-.511,-.305),vec4(.707,.492,-.500,-.177),vec4(.246,.468,-.118,.025),vec4(-.172,-.598,-.471,.188),vec4(.499,-.688,.295,-.038),vec4(-.142,-.473,1.317,-.575),vec4(.395,-1.361,.074,-.895),vec4(-.137,.756,.837,-.167),vec4(1.371,.889,-.121,-.829),vec4(.224,-.371,-.662,-1.658),vec4(.898,-1.819,.164,-1.371),vec4(-.895,.407,-.312,-1.637),vec4(-1.268,-.822,.211,.832),vec4(-2.202,1.855,1.292,2.129),vec4(-.360,-2.155,.719,2.872),vec4(.041,-1.635,-1.286,.082),vec4(-.065,-.483,-2.065,-.247),vec4(.264,.706,-1.144,-.751),vec4(.635,-1.226,-.267,-1.514),vec4(.836,-1.205,2.328,.470),vec4(1.127,.160,-2.502,-1.584),vec4(.619,-.868,-3.150,-.602),vec4(-1.671,.218,2.256,-1.197),vec4(-.099,-.037,-.504,-1.140),vec4(-.029,.343,-.951,.358),vec4(.357,.976,-.400,-.352),vec4(1.030,1.189,-.158,-.827),vec4(-.540,-1.608,.700,-.122),vec4(-1.480,-1.256,-.908,.111),vec4(-.092,-1.344,-1.489,-1.048),vec4(-.312,-1.103,-2.469,-.246),vec4(-.317,-.246,-3.416,.563),vec4(-1.409,-.199,.455,3.178),vec4(-.888,.048,-.596,-.593),vec4(-.825,.521,.337,-.197),vec4(.842,-2.275,-.764,-.202),vec4(-2.155,.860,.689,1.489),vec4(-2.322,.876,.171,.821),vec4(-1.142,.949,.133,-.829),vec4(.274,.662,-1.527,-.928),vec4(-1.513,-.365,-1.399,.464),vec4(-.821,-.697,-.216,2.326),vec4(-.444,-.600,-.676,.178),vec4(-.344,-1.830,1.114,-1.452),vec4(.954,-1.649,-1.655,-1.530),vec4(.637,.001,-2.416,-.256),vec4(-1.801,-1.055,.224,-.589),vec4(-1.110,-.165,.324,.159),vec4(-.829,-.104,.472,.292),vec4(.130,.875,-.234,-.192),vec4(-.959,-.045,.462,-1.107),vec4(-1.679,-1.677,-.024,.581),vec4(1.635,.642,-.546,-.533),vec4(.827,-2.555,-2.257,.803),vec4(2.254,1.417,-3.171,1.224),vec4(-.109,-.489,-1.175,.264),vec4(-1.782,-.108,1.421,1.792),vec4(-.893,.236,1.045,.773),vec4(-.291,.004,1.252,.055),vec4(.553,2.306,-.577,-.122),vec4(-1.061,-.931,-1.261,.348),vec4(-.232,-.960,-.094,-1.523),vec4(-1.170,-1.093,.412,-.539),vec4(.190,-.364,-.849,-.075),vec4(1.978,1.190,.249,-1.588),vec4(2.076,.688,.476,-1.833),vec4(-.831,-.392,-.140,-.635),vec4(-.803,1.068,-.523,.628),vec4(.921,-.419,-.816,.651),vec4(.993,-.318,.450,-.113),vec4(-1.124,.441,-1.203,-.667),vec4(-1.279,-1.078,-1.910,.498),vec4(-1.048,.066,-.898,.193),vec4(-.688,.244,-.301,.028),vec4(-.454,-.765,.065,-.587),vec4(-1.536,-.589,1.518,-.061),vec4(1.994,-1.275,-.267,.496),vec4(1.173,-.513,.332,.596),vec4(1.124,-1.197,-1.259,-.282),vec4(.335,1.051,.068,.012),vec4(1.229,1.569,.491,.140),vec4(.111,.062,-.922,-.508),vec4(-1.665,.494,-.425,-.548),vec4(-.613,1.253,-1.389,.072),vec4(.035,.515,.176,.865),vec4(.238,.155,-1.032,.774),vec4(-1.890,.398,-.321,-.033),vec4(-1.229,1.137,-1.397,-.317),vec4(1.445,.071,-1.777,.901),vec4(-2.138,.107,-1.677,2.130),vec4(.096,.190,-.689,.621),vec4(.263,.100,-.998,.664),vec4(-.053,-.418,-.288,-.650),vec4(.001,.310,-.682,-.517),vec4(-.435,-.382,-.576,-.304),vec4(-.109,.042,-.146,-.529),vec4(.703,.150,-.638,-.589),vec4(-.565,.267,-.157,-.769),vec4(-.890,.162,.036,-.651),vec4(.173,.106,-.182,-.373),vec4(-1.147,-1.100,.410,-1.587),vec4(-.940,-1.206,.306,-1.211),vec4(-1.677,.004,-.133,1.130),vec4(.574,-.177,-1.273,.549),vec4(-.802,-1.576,.108,-1.681),vec4(-.401,-.054,.218,.181),vec4(-.631,-.099,-.149,.687),vec4(-.310,-.554,-.723,-1.415),vec4(1.981,1.091,.603,-.958),vec4(-.408,.610,.375,-.345),vec4(.565,-.698,.118,-.248),vec4(1.050,-1.205,-.467,.279),vec4(-.944,.604,-.015,-.051),vec4(-1.397,-.650,-.125,-.724),vec4(-.382,.551,-.821,-.408),vec4(-.356,-.107,-.383,-.261),vec4(.799,-.526,-.308,.172),vec4(-.662,-.034,-.999,-.137),vec4(-.621,.362,-.121,-1.221),vec4(-.568,-.389,-.116,-1.064),vec4(-.254,-.082,-.197,-1.071),vec4(-.280,-1.131,-.545,-.758),vec4(-.032,.811,.118,-.168),vec4(.598,-.179,-.147,.725),vec4(1.077,-.152,-.302,.245),vec4(.852,-.611,-.527,-.195),vec4(.177,.302,-1.520,.277),vec4(.081,.844,-.287,.735),vec4(.059,.314,.574,.675),vec4(-1.039,.465,-.040,.703),vec4(.583,1.290,-1.167,-.308),vec4(-.200,.219,-1.223,-.343),vec4(.541,-.079,.268,1.065),vec4(-.193,-1.094,.379,-1.574),vec4(-1.222,.393,.589,-1.771),vec4(-.027,-1.176,1.526,-1.198),vec4(-.469,-1.371,1.261,-.076),vec4(.195,-.127,-.752,.489),vec4(.211,-.522,-1.036,.373),vec4(1.170,.085,-1.532,.602),vec4(-.422,.494,.481,.063),vec4(.669,.506,-.803,.143),vec4(.172,.336,.414,-1.039),vec4(-.105,.726,-.299,-.902),vec4(-.629,1.016,-.398,-.651),vec4(-.523,.910,-.315,-.269),vec4(.332,.638,-.881,-.165),vec4(-.348,.616,-.547,-.287),vec4(-.551,.539,-.537,.672),vec4(-.283,1.282,.089,.268),vec4(-.847,.746,.325,.653),vec4(.100,-.300,-.244,.393),vec4(1.382,.068,-.730,-.584),vec4(1.425,.072,-.448,-.693),vec4(-.518,-.662,-.049,-.227),vec4(1.417,-.228,-.188,.607),vec4(-.309,-.139,1.137,-.197),vec4(-2.699,.361,.101,3.413),vec4(.763,-1.136,1.581,-2.490),vec4(-.094,-.273,.489,-.716),vec4(.540,-.234,-.602,.986),vec4(.515,-1.417,-.817,1.282),vec4(.420,-1.375,.379,.194),vec4(.524,.264,-.454,.014),vec4(.691,.413,1.056,.047),vec4(.349,1.122,-.167,-.517),vec4(-1.243,-.462,1.167,-2.605),vec4(.798,.863,2.322,-1.504),vec4(-.289,.962,2.125,-1.458),vec4(.317,.639,-.196,-.448),vec4(-1.324,.439,-.718,-.387),vec4(.299,1.070,.234,.583),vec4(.239,-1.379,1.852,-.103),vec4(-1.221,-.888,.684,.460),vec4(-.148,1.619,-.150,1.269),vec4(-.327,.853,.608,.784),vec4(.243,-.275,.603,.456),vec4(.402,-.121,.552,.345),vec4(1.981,1.042,.320,-1.253),vec4(.454,-.715,-.283,.169),vec4(-.736,.306,1.305,.238),vec4(-.224,-.334,-.132,-1.156),vec4(.521,.469,-.557,-.327),vec4(-.052,-.446,-.710,.276),vec4(1.424,.522,-.781,.217),vec4(-1.271,.965,.752,-.871),vec4(-1.987,1.480,-.404,.214),vec4(.248,.357,.951,.540),vec4(1.147,1.526,-.965,.531),vec4(.418,2.111,-.183,-.154),vec4(-1.316,-.246,.731,-2.218),vec4(-3.244,-1.822,1.651,-3.307),vec4(-.669,-1.266,.681,-1.190),vec4(-1.695,.807,-.904,-.781),vec4(.641,.153,.252,.118),vec4(-1.704,1.033,.224,-.295),vec4(-.259,.539,.195,-.662),vec4(.140,.413,-.104,-.659),vec4(-.652,.034,-.260,.458),vec4(.049,-.499,.774,1.399),vec4(1.077,.301,1.262,.916),vec4(1.145,-.204,1.699,-.610),vec4(-.257,-.661,.767,-.140),vec4(.112,.008,1.166,-.109),vec4(-.804,.961,-.809,.105),vec4(-.198,-.105,.348,-.952),vec4(.780,-.451,-.997,-.044),vec4(.947,.492,-1.044,.094),vec4(-.569,.578,-.359,-.579),vec4(-.652,-.149,-1.771,.462),vec4(-.242,-.760,.399,-1.177),vec4(.228,.314,-.297,-.053),vec4(-.289,.070,.623,.392),vec4(-1.233,.017,1.826,-.510),vec4(-1.455,.196,.698,-1.074),vec4(-1.033,-1.572,.134,-1.299),vec4(.248,-.298,.281,-1.361),vec4(.553,.906,-.616,-.621),vec4(-.408,1.044,-.620,-.096),vec4(.515,2.451,.536,-.353),vec4(-1.335,.351,-.572,.417),vec4(.633,1.082,-1.071,.457),vec4(2.146,-.269,.383,-1.093),vec4(3.162,-.871,-.283,-1.219),vec4(-.636,-.055,.246,-.095),vec4(-1.213,-.131,-1.076,.606),vec4(-1.627,.102,-1.100,.470),vec4(-.852,.500,.609,.937),vec4(.983,1.788,-.236,.661),vec4(.958,.254,-.783,-4.071),vec4(.941,-2.015,.277,-.406),vec4(1.956,-1.402,.711,-.070),vec4(1.625,.323,-.645,-.257),vec4(-.093,.079,-1.062,.473),vec4(.861,.782,-.949,1.452),vec4(.867,-.673,.495,.045),vec4(-.153,-.880,.790,-.151),vec4(-.991,-1.574,1.150,-.425),vec4(-1.161,-.503,1.307,-1.076),vec4(-.335,.904,1.627,-.813),vec4(-2.240,-.485,2.036,-1.478),vec4(-.930,1.752,-.236,-.210),vec4(-1.137,1.319,.502,-.464),vec4(-.722,-.195,.639,-1.742),vec4(-.078,-.801,.106,-1.601),vec4(.916,-.796,-1.040,-.188),vec4(-1.786,-.757,.099,1.010),vec4(-.846,-.473,1.453,.470),vec4(-.665,-.096,-.157,.602),vec4(-.331,-1.803,2.091,-.526),vec4(.707,-.438,.421,-2.253),vec4(1.219,-.290,-.981,-1.714),vec4(.961,-.482,-1.137,-.014),vec4(2.091,1.429,-3.730,1.522),vec4(1.464,.524,-.067,-2.592),vec4(2.056,-.348,.356,-.754),vec4(1.724,-.911,-.046,-.967),vec4(.659,.648,-1.032,-.153),vec4(.649,.349,-.730,-.475),vec4(-.333,-.293,-.657,.648),vec4(-.151,-.952,.175,-.602),vec4(-.894,.360,.661,-.926),vec4(-.109,1.284,-.529,-.780),vec4(-1.534,-1.982,.868,-.478),vec4(-1.771,-.502,1.220,-1.253),vec4(-.532,.151,2.536,-1.529),vec4(-1.653,.595,1.739,-.817),vec4(-.655,.986,.563,-.901),vec4(-1.184,.860,.269,-1.647),vec4(-.384,.595,-1.201,-1.213),vec4(-.672,2.621,.651,-2.091),vec4(.964,.911,-1.884,.181),vec4(.492,.307,.058,.048),vec4(.665,1.192,-1.570,.236),vec4(.323,.608,-1.240,.723),vec4(.927,-.006,-.770,-.369),vec4(.368,-.367,.428,-.203),vec4(-.466,.362,-1.146,.550),vec4(-.394,.979,-1.469,1.937),vec4(.540,-1.146,.208,-1.139),vec4(1.873,.020,.637,-.427),vec4(.966,-.015,.211,.057),vec4(.203,.721,.127,.277),vec4(-.035,.663,-.594,.003),vec4(.852,-.326,-.975,.930),vec4(.574,.283,-.770,.218),vec4(-1.243,-.215,-.518,.885),vec4(-.884,-.257,-.032,.045),vec4(-.519,-.536,1.076,.116),vec4(-1.786,-.256,.707,-.508),vec4(-.984,.365,-.358,.598),vec4(-.275,.515,-.824,-.045),vec4(.149,.610,.200,.278),vec4(-.145,.467,.428,-.091),vec4(.300,1.100,-.453,1.155),vec4(.022,-.135,-.723,1.866),vec4(-.360,.885,-1.862,1.051),vec4(.800,-.018,-.806,-.261),vec4(1.701,-.330,-.918,-.496),vec4(-.383,.241,-.947,.648),vec4(.430,.230,-.840,.073),vec4(-.825,2.713,-.818,-.299),vec4(-1.762,1.823,-2.582,-1.665),vec4(-1.449,.132,1.973,1.633),vec4(1.160,-.648,.503,-.406),vec4(1.272,-.355,-.285,.063),vec4(1.008,-.537,-.123,-.052),vec4(-.552,-.705,.768,-.297),vec4(-.182,.252,-1.227,1.225),vec4(.647,-.037,-.868,-.085),vec4(.034,.009,-.907,.039),vec4(.122,.164,-.655,.717),vec4(.352,.650,1.003,.354),vec4(.668,-.192,-.289,.039),vec4(-.075,-1.047,-.193,-.879),vec4(-1.214,-.169,-.111,-.584),vec4(-.316,-.131,-.430,-.248),vec4(-.086,-.138,.316,-.437),vec4(-.238,.300,.495,.345),vec4(-1.362,.302,-.053,.614),vec4(-.452,-.204,-.597,-.316),vec4(-.499,.589,-.405,.111),vec4(.280,.228,-.798,.448),vec4(.265,.510,-1.409,-.246),vec4(.879,1.510,1.641,-.406),vec4(-.345,.665,.501,.100),vec4(-.625,1.200,-1.850,-1.998),vec4(-.272,-1.683,.883,1.216),vec4(.502,-.261,.545,-.273),vec4(.202,-.802,-.571,-.585),vec4(-.044,-.081,.449,-1.222),vec4(.576,-.446,.803,-.221),vec4(.695,-.770,-.995,-.436),vec4(-.214,.573,-.657,-.275),vec4(.007,-.071,-.899,-.140),vec4(.025,-.109,-.635,-.647),vec4(-.244,.013,.457,-.166),vec4(-.960,.303,-.124,.319),vec4(1.082,1.109,-.718,-.803),vec4(.233,.493,-.087,-1.525),vec4(.086,.749,1.137,-.886),vec4(-.514,-.091,.503,.485),vec4(-.441,.357,.101,.653),vec4(-.043,.420,-.608,1.217),vec4(-.610,.339,-.546,.825),vec4(-.417,.806,-.686,.529),vec4(.091,.561,.092,-.115),vec4(.470,.655,-.411,.383),vec4(.964,-.773,-.037,-.414),vec4(-.707,.730,-1.139,.886),vec4(-.148,2.126,-.587,-.857),vec4(1.186,-1.569,.960,-.555),vec4(.282,-.393,-.039,-.261),vec4(.125,-1.072,-.526,-.467),vec4(.357,-.772,-.691,-.771),vec4(.674,.247,.016,-.005),vec4(.899,-.013,.724,.009),vec4(.134,-.017,-.079,-.477),vec4(.095,.205,-.345,-.757),vec4(-.139,.291,-.843,-.088),vec4(.278,.660,-.767,.124),vec4(.478,.262,.087,-1.253),vec4(-.457,.068,.291,-2.032),vec4(-.422,.163,.009,-.396),vec4(-.411,.369,.166,.250),vec4(-.380,.753,-1.256,.531),vec4(.018,.103,-.464,.721),vec4(.467,.970,-.074,-.597),vec4(.389,.640,-.180,-1.211),vec4(-.946,.431,.248,.413),vec4(.019,.897,.683,.792),vec4(.018,-.075,.711,.489),vec4(1.711,-.924,.061,-.161),vec4(.523,2.742,-3.160,.735),vec4(-.749,.907,1.028,-.631),vec4(.604,-1.449,.094,-.212),vec4(1.369,-.311,-.026,.139),vec4(.498,-.068,1.472,-.826),vec4(.527,-.118,-.988,-.820),vec4(.287,-.195,.261,-.392),vec4(-.204,-.331,.117,.024),vec4(-.641,-.223,.118,-.252),vec4(-.754,-.241,.261,-.276),vec4(.334,.088,-.261,.063),vec4(.481,.196,.022,-.321),vec4(.105,-.033,1.278,-.321),vec4(-.492,.258,.687,-.264),vec4(-.674,.562,-.561,-.268),vec4(-.111,.357,-.678,-.428),vec4(-.223,.837,-1.079,.354),vec4(-.464,.025,-.925,1.406),vec4(-.366,.074,-.993,.522),vec4(-.327,-.618,-.460,-.213),vec4(.053,1.064,.138,-.275),vec4(-.296,-.129,.641,1.105),vec4(.212,.434,.229,.707),vec4(.473,-.460,2.634,.311),vec4(2.221,3.112,-.010,-1.064),vec4(-3.068,.606,-.419,.005),vec4(-1.490,-2.182,-.624,.450),vec4(1.520,-.457,-.150,.399),vec4(.903,.471,.390,-.380),vec4(.292,.066,.241,-.670),vec4(.171,.105,.340,-1.231),vec4(.458,.166,.259,-.835),vec4(-.156,-.623,.179,-.884),vec4(-.085,.116,.697,-.793),vec4(-.232,-.172,.604,-.557),vec4(.727,-.599,1.079,-.579),vec4(.998,-.260,.293,-.232),vec4(-1.763,-.947,-1.012,1.570),vec4(-1.204,-.461,-1.324,.516),vec4(-.044,1.670,-.490,-.360),vec4(.518,1.465,-1.356,.242),vec4(-.163,-.388,.509,.927),vec4(-.390,.064,-.169,.909),vec4(-1.171,-.926,-.140,.621),vec4(-.723,.703,-.111,.353),vec4(.305,-.294,-.232,.661),vec4(.715,-.626,.328,.509),vec4(-.822,-1.469,2.725,-.519),vec4(.923,.148,.365,-.923),vec4(-.686,-.779,-.744,.055),vec4(.499,.350,.408,.192),vec4(2.862,-2.266,.776,1.310),vec4(1.068,-1.036,-.007,-1.360),vec4(.576,-.717,-1.343,-2.952),vec4(-1.364,1.392,-.351,-.480),vec4(-.219,.290,-.608,-.210),vec4(-2.350,-.961,-.210,.607),vec4(-.878,.517,-1.125,-1.123),vec4(-1.027,.513,.025,.141),vec4(.032,.371,-1.027,.993),vec4(.410,.472,.883,-1.708),vec4(1.105,-.222,-.356,-.111),vec4(.661,.790,.507,-.467),vec4(.393,1.344,-2.147,1.105),vec4(-.197,-.477,.278,.593),vec4(1.095,-.064,-.893,1.218),vec4(.656,.013,-.738,1.793),vec4(-.559,-.041,-.405,1.232),vec4(.375,.475,.260,-.874),vec4(-1.759,.816,-.754,-.312),vec4(.204,-.560,.371,-1.498),vec4(-.613,-.780,2.450,-.730));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed0[idx];\n}", "buffer_a_inputs": [], "buffer_b_code": "const vec4 embed1[576] = vec4[](vec4(-1.326,-1.313,1.901,1.417),vec4(-.158,-.696,1.197,-.167),vec4(2.284,1.197,.587,-.052),vec4(.626,-2.749,-1.881,1.786),vec4(-.001,.750,-1.258,2.258),vec4(-2.462,-.751,.056,-2.277),vec4(1.357,.710,1.414,-1.469),vec4(-1.663,.249,-2.191,-1.714),vec4(-1.305,.627,-1.121,-1.358),vec4(1.451,-.424,.330,1.567),vec4(-.997,-.517,.199,-1.002),vec4(-.438,.375,1.775,.876),vec4(.008,.376,-1.160,-.020),vec4(1.698,-1.372,1.627,1.938),vec4(-1.026,.638,2.417,-.353),vec4(-.122,-.699,.126,-.107),vec4(-1.446,-2.720,-.513,1.744),vec4(-.020,-.302,1.805,-.920),vec4(-1.212,.767,1.178,.088),vec4(.892,.966,2.735,-1.473),vec4(-.940,-.544,.162,-1.895),vec4(.256,.209,.749,-.119),vec4(-1.799,1.126,-.989,-.642),vec4(1.326,.216,-.490,-.921),vec4(-.085,-.923,1.161,-.080),vec4(-1.202,-.545,1.607,-.015),vec4(.897,1.422,1.268,.387),vec4(1.079,-2.723,-.036,-.024),vec4(2.542,.986,.766,1.821),vec4(.364,-.912,-.196,-1.985),vec4(.722,.668,1.754,-2.830),vec4(-.097,1.117,2.254,-.830),vec4(-.113,-.143,-.698,-.493),vec4(.362,.110,2.287,.851),vec4(-1.403,.277,-1.314,.573),vec4(2.087,.735,-.782,.410),vec4(-.330,1.205,-2.313,-1.366),vec4(-.851,.297,1.875,.276),vec4(-1.337,-.145,1.547,1.251),vec4(1.095,.336,.957,-.508),vec4(1.436,.315,-.034,-.817),vec4(.381,-.106,1.315,1.025),vec4(-.435,-.599,2.538,.601),vec4(.676,-.833,-.857,1.105),vec4(-.312,.887,1.516,-1.024),vec4(-.613,.438,1.326,1.080),vec4(1.942,.365,-.351,-.568),vec4(-.333,-.957,-1.015,-.878),vec4(-.640,-1.830,1.483,.784),vec4(-1.172,-1.076,1.973,1.328),vec4(-.523,-.011,3.381,3.189),vec4(.682,1.258,-1.711,1.609),vec4(.988,-.732,-.694,1.712),vec4(2.519,.452,.049,-.973),vec4(-.707,-.558,-1.005,.881),vec4(1.173,1.027,.981,-1.048),vec4(1.466,1.077,-.259,-.089),vec4(-1.495,-3.069,-.695,1.806),vec4(-1.358,.775,-1.077,.504),vec4(-.557,.241,-.100,1.124),vec4(.186,2.000,-.007,.517),vec4(-1.695,1.209,-1.273,.708),vec4(.417,.823,-.211,1.827),vec4(1.938,1.808,1.463,-.892),vec4(-.839,-.533,.127,-2.351),vec4(.688,.206,1.040,2.111),vec4(1.389,-.078,.539,-.048),vec4(-.581,-.492,.738,1.760),vec4(.192,-.168,-.449,-.600),vec4(-.446,1.338,.238,-.421),vec4(.473,2.076,.441,-.166),vec4(-.695,-.522,1.027,-.086),vec4(.880,-.430,1.585,1.854),vec4(.028,-.648,.901,1.346),vec4(.247,-.068,-.472,2.242),vec4(1.286,-2.346,-.799,.476),vec4(1.430,-.536,.796,-.887),vec4(-1.539,-.163,-.845,1.473),vec4(.092,.230,-.470,-.924),vec4(-.424,1.060,-.633,-1.657),vec4(.706,1.139,.961,.480),vec4(-1.673,-.939,-1.821,.729),vec4(-1.037,.073,.358,.714),vec4(-1.596,-.123,-.193,.067),vec4(-.256,1.714,-.217,-.184),vec4(.061,1.615,.534,.515),vec4(.520,.980,-1.297,-.812),vec4(1.197,-.716,1.064,.749),vec4(-.310,-1.876,.950,.576),vec4(-.708,-.024,1.140,-.807),vec4(.130,.095,.963,.531),vec4(-1.472,-2.783,-.545,1.163),vec4(-.401,1.701,.270,-.321),vec4(-1.049,2.457,-1.320,-.978),vec4(-.332,.143,.866,.939),vec4(1.090,-.518,1.294,-1.633),vec4(-.431,-.520,2.492,1.619),vec4(.137,1.821,3.920,.132),vec4(1.008,.825,-2.160,.237),vec4(.435,.934,-.222,.035),vec4(-.314,.509,-.302,-.123),vec4(-1.133,-.232,-.377,-.403),vec4(-.467,.198,1.722,-.778),vec4(1.946,.422,-1.438,-1.122),vec4(-1.773,-.939,1.286,-.281),vec4(-.602,1.463,-1.144,-.082),vec4(-.632,.633,-.026,.419),vec4(.069,.593,-.646,.288),vec4(-.146,1.249,-.072,.074),vec4(-.391,1.597,.774,-.105),vec4(-.580,.669,.490,.280),vec4(-.068,.253,.777,.679),vec4(-.113,.747,.906,1.035),vec4(.244,-.776,-.131,-.351),vec4(.015,-1.086,.460,-.097),vec4(.092,-.492,-1.118,-.753),vec4(.513,-1.187,-.966,.427),vec4(-1.284,.182,2.833,-1.141),vec4(1.561,1.113,1.700,-1.289),vec4(.831,-.216,.869,.178),vec4(1.866,2.196,1.500,-.976),vec4(-2.077,-1.659,-1.867,-.331),vec4(-.908,.002,.521,-1.617),vec4(-1.581,-.820,.504,-1.269),vec4(-.523,-.512,1.153,-2.497),vec4(.067,-.050,2.582,.356),vec4(.856,-2.122,2.623,.220),vec4(.161,-1.976,2.281,-.591),vec4(.130,1.376,.203,.293),vec4(-1.059,.670,-1.517,-.858),vec4(-.421,.292,-.623,-.267),vec4(1.336,1.008,-.497,.001),vec4(-.024,.924,-.234,.261),vec4(.266,.755,.154,.252),vec4(-.104,-.247,-1.152,.715),vec4(.819,.221,-1.277,1.058),vec4(.624,-1.940,.160,-.368),vec4(-1.037,-1.172,-.033,.719),vec4(-1.068,.156,-.755,.640),vec4(-.555,-1.674,-.522,-.684),vec4(-.300,-.504,-.410,-2.220),vec4(.195,-2.116,.214,.448),vec4(-.954,-.427,-.250,-1.079),vec4(.347,.910,1.976,1.827),vec4(-3.332,-2.460,-3.258,1.375),vec4(.886,.624,1.656,.581),vec4(.965,-.571,-.445,-2.270),vec4(1.535,.125,.230,-.846),vec4(-.770,.576,.728,.004),vec4(-1.841,-1.132,.118,-.096),vec4(1.269,-1.204,.433,-.566),vec4(.168,.237,1.653,-.734),vec4(-.983,.154,.382,1.114),vec4(1.501,.804,-.575,.441),vec4(1.601,.770,-1.103,-.000),vec4(.731,.765,.131,-.236),vec4(.043,.490,-.231,.622),vec4(.279,-1.141,.393,1.659),vec4(.479,-.199,-.981,1.326),vec4(-.115,1.259,1.669,-.386),vec4(-1.527,.591,-.779,-.505),vec4(1.564,1.013,.044,-1.607),vec4(-2.478,-.476,.687,-.861),vec4(-.289,-.243,1.368,-.749),vec4(1.316,.185,.888,-.534),vec4(-.537,-.293,1.220,.568),vec4(1.467,-2.122,1.662,1.051),vec4(-1.419,-1.034,-1.524,.389),vec4(-.356,1.210,1.689,1.183),vec4(.510,.390,.018,-.897),vec4(.592,.749,.201,-1.208),vec4(-1.043,-.390,1.442,-1.527),vec4(-1.348,.946,1.917,-.975),vec4(-1.558,.643,1.518,-.462),vec4(.738,-1.686,1.989,-.257),vec4(.665,-1.421,1.563,.665),vec4(-1.633,1.703,-.103,-2.148),vec4(.628,.540,-.138,1.031),vec4(1.598,.358,.440,.948),vec4(.419,.653,.505,.269),vec4(-.419,.664,-.041,-.088),vec4(-.202,.507,-.467,.218),vec4(.353,1.019,-1.933,.381),vec4(-.506,-.071,-.103,-.672),vec4(.267,1.052,.158,-.552),vec4(.970,-.374,.267,1.838),vec4(-1.278,.763,1.369,-1.452),vec4(-1.356,.173,-.296,-.804),vec4(-1.891,-1.496,.552,.356),vec4(-.753,1.173,2.698,-.900),vec4(1.328,.650,1.390,-.916),vec4(.741,.157,.328,1.627),vec4(.886,-.794,-.958,-.938),vec4(2.022,-.082,1.897,-1.041),vec4(.783,-1.116,2.350,-.599),vec4(-.243,-1.211,.160,-.500),vec4(1.644,-.756,.661,-.907),vec4(2.447,.508,-1.245,-1.060),vec4(-.265,-.383,-.697,1.241),vec4(.151,-.822,.485,.655),vec4(.954,.086,.113,1.346),vec4(1.239,.019,.292,.619),vec4(-.316,.309,.458,.337),vec4(.164,1.036,.437,.059),vec4(.019,.518,-.030,-.095),vec4(.221,.797,-1.531,.467),vec4(.749,.405,-.606,-.693),vec4(-.248,-1.813,.303,-.748),vec4(-.430,-.670,1.392,-2.082),vec4(-.658,.048,1.359,-.450),vec4(-2.966,-.402,-.146,.321),vec4(2.058,-1.098,.643,.300),vec4(2.402,1.296,-.245,-.923),vec4(.528,-.534,-.916,.559),vec4(1.290,1.618,-.201,-.589),vec4(.866,1.155,1.130,-1.352),vec4(.134,-1.118,1.014,-1.519),vec4(1.586,-1.869,.572,-1.468),vec4(-.195,-2.356,1.251,-1.403),vec4(-.900,-.387,-1.145,-1.447),vec4(-.063,.424,-1.255,-.230),vec4(.285,1.356,-.858,-.785),vec4(.019,.648,-.668,-.379),vec4(.152,1.457,-.881,.878),vec4(-.173,.871,-.599,1.181),vec4(.321,-.048,.586,.597),vec4(-.583,.496,.230,.794),vec4(-.568,-.193,.416,.953),vec4(.918,1.010,.658,.385),vec4(.098,1.052,-.277,-.021),vec4(.659,.137,-.387,-.729),vec4(-.279,1.008,-2.544,-.447),vec4(-.321,1.857,-.784,.027),vec4(.514,1.727,.312,-.053),vec4(1.325,.269,-.671,.304),vec4(-.818,.016,-.894,1.507),vec4(-2.149,-.224,-.761,.554),vec4(-.492,-.311,.434,-.928),vec4(.691,-.723,1.452,.477),vec4(.887,.399,-.273,-.289),vec4(1.701,-1.179,.369,-.362),vec4(.858,-2.362,.618,-1.627),vec4(-1.157,-1.280,.319,-.245),vec4(.790,-.287,.349,.093),vec4(1.859,-.376,1.174,.713),vec4(.461,.810,-.600,-.210),vec4(.265,.668,-.957,-.062),vec4(-1.387,-.123,-.162,1.202),vec4(-.033,.550,-1.138,-.968),vec4(.157,.656,.128,.927),vec4(-.914,.714,-.341,.731),vec4(1.081,.469,-.180,.734),vec4(.211,.423,-.637,.548),vec4(-1.509,.408,.203,.809),vec4(-1.416,1.450,.604,-.366),vec4(-2.007,.613,-.392,.407),vec4(.724,.478,-.799,-.056),vec4(.552,-.023,-.606,-.332),vec4(-.147,.222,.059,-.200),vec4(-1.569,-.058,-.816,.924),vec4(-.326,.834,-1.678,-.301),vec4(-.901,-.564,-.698,-.236),vec4(-2.455,-.956,-.816,-.157),vec4(.623,.489,-.282,-.725),vec4(1.940,.410,-.170,-.993),vec4(.148,.637,-.388,-1.075),vec4(.273,-1.155,.713,-.712),vec4(-.634,-1.095,.523,-.631),vec4(.699,-1.179,.450,-.976),vec4(-1.573,-.829,-.208,-.475),vec4(.039,.645,-.547,.768),vec4(1.099,.186,-.180,.336),vec4(-.311,-.281,-.722,-.505),vec4(.289,.637,-.311,.416),vec4(1.294,.530,-.164,.765),vec4(.943,.903,.575,.845),vec4(.857,.524,.847,.782),vec4(-.142,.986,-.519,.486),vec4(.563,1.265,-.609,.881),vec4(-.009,-.366,-.971,-.060),vec4(.341,-.364,-.577,-.131),vec4(-.953,.154,-.302,.462),vec4(-.411,-.202,-2.049,-.289),vec4(-.567,-.198,-1.604,.388),vec4(-.321,.556,-1.113,-.619),vec4(.166,.728,-.311,-.434),vec4(-.753,-.135,.661,.017),vec4(-1.148,.949,-.269,-1.681),vec4(-.161,.764,.066,-.272),vec4(-.377,-.286,1.270,-.708),vec4(.139,2.820,.333,-1.846),vec4(.696,1.047,.341,-1.067),vec4(-.785,-.667,.576,.371),vec4(.801,-.391,.244,.143),vec4(.115,-.320,1.133,.705),vec4(-.050,-.585,-.433,1.060),vec4(-.919,.445,-.490,-.446),vec4(1.671,1.492,1.737,.216),vec4(.648,.676,2.106,-.346),vec4(1.255,.563,.768,-.135),vec4(-1.859,-.117,.199,.639),vec4(.015,.907,-1.374,.003),vec4(-1.345,.936,-.778,-.538),vec4(.051,.439,.609,1.169),vec4(.642,1.585,-.401,.867),vec4(-1.159,-.396,.821,.020),vec4(-1.541,-.548,-.112,.788),vec4(-1.258,-.764,-1.181,-.261),vec4(-.763,-.049,.602,-.490),vec4(-1.397,.481,1.242,1.020),vec4(-.677,-.307,-.092,.102),vec4(-.251,-.415,.773,-1.144),vec4(-2.297,-.847,-.340,1.321),vec4(-.282,-.878,-.575,-.411),vec4(-.032,-.744,1.457,.510),vec4(.804,-.233,.581,-.223),vec4(1.685,-.606,-.711,1.135),vec4(-.134,.194,-.824,-1.100),vec4(-2.222,-.560,-1.950,-.453),vec4(-1.160,-1.102,-.600,-.851),vec4(-.560,-1.279,-2.320,1.141),vec4(1.768,.840,-.452,-1.580),vec4(3.209,.465,1.160,-1.101),vec4(-.947,-.582,-1.440,-.522),vec4(-.453,.076,-.438,1.716),vec4(-2.346,-.209,.102,1.514),vec4(-.515,1.212,-.686,-.594),vec4(.172,.398,-2.228,-.584),vec4(1.263,.006,-.640,-.047),vec4(-.959,.009,-.261,.602),vec4(-1.980,-.243,-.147,.071),vec4(-1.764,-.938,1.462,1.398),vec4(-.627,-.956,1.061,1.440),vec4(-.617,-.452,.248,-.075),vec4(-1.437,-.065,.812,.096),vec4(.087,-.266,-.344,-1.158),vec4(-.433,-.324,.354,1.919),vec4(-.502,-1.000,-.865,-.896),vec4(.265,-.943,.510,.159),vec4(.353,-.616,-.055,.441),vec4(-.981,1.362,-1.513,-1.690),vec4(-1.638,-.625,.410,.628),vec4(-.930,-.427,.173,-.224),vec4(-.189,-.915,.447,.892),vec4(.557,.002,-1.445,1.790),vec4(2.052,.202,-.217,.693),vec4(1.338,.019,-.333,-.822),vec4(1.214,-.934,-.778,1.142),vec4(-.321,-.057,.805,.581),vec4(2.020,-.285,-.293,.444),vec4(-1.300,.443,-1.436,-1.422),vec4(.060,.124,-1.304,-1.093),vec4(-1.020,.134,-.614,-.622),vec4(-.218,1.429,-.722,.007),vec4(.564,-.001,-.987,1.407),vec4(.645,.809,-.977,1.036),vec4(-.119,.637,-1.671,1.160),vec4(-1.381,1.054,-2.143,.653),vec4(.482,-.429,.174,.380),vec4(.160,-1.909,1.103,-.686),vec4(.167,-.738,-.046,.622),vec4(.534,-.941,-1.145,-.455),vec4(-2.008,-1.142,-.272,-.258),vec4(.431,-1.030,-.395,-.398),vec4(-.302,-.725,.292,-.492),vec4(-.471,-.315,.063,-2.729),vec4(.003,1.005,-.749,-3.483),vec4(.364,-.000,-.289,-1.063),vec4(2.698,-.724,-.668,.574),vec4(.452,-.305,-.590,.214),vec4(-1.562,-.666,.078,.610),vec4(.742,-.033,-.757,.778),vec4(.859,-.525,1.052,.412),vec4(.629,.982,-.430,-.792),vec4(.007,1.026,-.331,-1.797),vec4(.864,1.742,1.207,-.094),vec4(-1.585,-1.211,.413,.356),vec4(.537,-.197,-.331,1.067),vec4(-1.514,-.240,-1.125,1.182),vec4(-.420,-.201,-.679,.438),vec4(-.602,.975,-2.207,-1.200),vec4(.444,.763,-1.106,-.034),vec4(-1.548,.928,-.227,1.142),vec4(.129,1.656,-.755,-.070),vec4(3.458,-.913,-1.022,1.669),vec4(-.136,-.361,-.749,.746),vec4(.661,-.668,-.160,-.343),vec4(-.274,-.606,-.800,.007),vec4(-.509,-.314,-.005,-.720),vec4(-1.123,.815,.508,.100),vec4(-1.234,1.338,.578,-1.228),vec4(-.160,.903,.562,-.874),vec4(1.436,-.118,-.026,-.715),vec4(.420,-.116,-1.026,-.598),vec4(.832,.290,.396,.503),vec4(.236,.295,.694,-.606),vec4(-1.343,-.497,1.653,-.350),vec4(-1.064,-.132,-.362,-.509),vec4(-.888,-.753,.357,-.480),vec4(2.592,-.917,-.899,-.597),vec4(.771,-.789,-2.292,.639),vec4(-1.924,-1.782,.353,-.062),vec4(-.772,-.299,-.509,-.173),vec4(.154,-.944,-.037,-.078),vec4(2.305,-1.147,-.523,.550),vec4(-.360,.063,-1.077,-.742),vec4(-.282,.409,-.783,-.443),vec4(-.925,-.863,.446,-.048),vec4(-.799,-1.072,1.914,2.058),vec4(-.400,-1.882,.129,2.426),vec4(1.220,.387,.506,.295),vec4(-.766,-.074,.124,.126),vec4(-1.267,.199,-.645,.316),vec4(.991,-.322,.211,-.132),vec4(.198,.317,.442,-.028),vec4(-.813,.293,-.785,-1.865),vec4(-1.414,.157,.141,-.827),vec4(-.247,1.090,-.258,-.786),vec4(.196,.563,.561,-.081),vec4(-.470,-.058,-.425,-1.217),vec4(1.088,.865,1.025,-1.120),vec4(-.828,-.392,1.098,-.701),vec4(.839,-.363,.828,.117),vec4(-.868,-.635,.731,.371),vec4(-.543,.005,1.227,-.768),vec4(-1.195,-.376,-2.356,-.231),vec4(.675,.296,-1.578,-1.529),vec4(-.895,-.352,-1.633,.905),vec4(-.793,-.416,-1.991,-.273),vec4(.459,-.279,-2.168,-.310),vec4(.786,.708,-1.137,-.846),vec4(-.081,.806,-.177,-.652),vec4(-.008,-.329,-.302,.542),vec4(1.126,.323,-.474,-.268),vec4(-1.113,-1.116,.657,2.569),vec4(.063,.937,.375,-.266),vec4(-.550,.477,-.706,-1.001),vec4(-1.134,-.556,-.878,-.428),vec4(.232,.744,-1.701,-.572),vec4(.049,1.325,-.076,.345),vec4(.148,1.314,-.632,.294),vec4(-.763,.545,.118,.240),vec4(.107,.202,.522,-.065),vec4(.438,1.109,.384,-.253),vec4(.266,-.597,.771,.655),vec4(1.937,-1.645,.184,.383),vec4(.694,-.059,.984,-.218),vec4(-.800,-.659,-.275,-1.209),vec4(.747,-.244,-.506,-.228),vec4(.281,.114,.454,.554),vec4(-.498,1.154,-.847,-.655),vec4(-.625,1.502,.097,.189),vec4(.887,1.538,.731,-.781),vec4(-1.110,.363,-.967,-.224),vec4(-2.556,-.920,-1.197,.118),vec4(-.835,-.129,-.002,1.146),vec4(-.255,.005,-.206,-.653),vec4(-.808,1.948,.192,.999),vec4(-.308,-.953,.539,2.778),vec4(.148,.978,-.618,-.022),vec4(-1.043,-.140,-.422,-.655),vec4(-.734,1.174,-.830,-.607),vec4(-1.112,.069,-.500,.550),vec4(-1.071,.073,-.205,.276),vec4(.169,.953,-.053,.062),vec4(-1.311,.770,-1.231,.494),vec4(.200,.715,-.253,.344),vec4(-.839,.451,-.318,.445),vec4(.047,.549,-.657,-1.031),vec4(.236,-1.332,-1.474,-.065),vec4(-.414,-.291,-1.398,-1.089),vec4(.229,-.293,-.393,-.114),vec4(-.655,.517,-.420,-.543),vec4(-.521,-.241,-.493,-.785),vec4(-1.794,.042,1.032,-1.114),vec4(.127,.710,-.201,-1.067),vec4(.014,.152,1.137,.518),vec4(-1.206,-.579,-.394,.101),vec4(-.429,.716,-.321,-.880),vec4(1.011,-.205,-.139,1.976),vec4(-1.585,-.599,.022,-1.367),vec4(-.105,.850,1.178,.837),vec4(2.139,.409,-.363,.327),vec4(.919,.781,-.414,-.502),vec4(-.252,-.264,-1.579,-1.132),vec4(-.544,-1.101,.780,.154),vec4(-.615,1.474,-.761,.341),vec4(-1.177,.646,-.080,.153),vec4(-.322,.385,-.816,.347),vec4(-.980,.515,-.761,.291),vec4(.425,-.363,-.691,-.295),vec4(-.622,-.243,-.785,-.321),vec4(.433,-.093,-.891,-.245),vec4(.123,-.057,-.721,.406),vec4(.603,.713,-.360,-1.837),vec4(-.390,-.178,.208,-1.251),vec4(-.969,.556,-.721,-1.868),vec4(-.608,-.035,.627,-.806),vec4(.081,.052,-.562,-.639),vec4(1.051,.267,-.882,-.343),vec4(-.364,.205,.195,-.241),vec4(.037,-.751,.398,.005),vec4(-.079,-.670,.089,.002),vec4(-.021,-.116,-1.181,1.189),vec4(.590,-.939,2.145,-1.485),vec4(1.461,1.012,.480,-.221),vec4(.468,.208,-.901,.324),vec4(.325,-.090,-.293,-.273),vec4(-.314,-1.251,-1.511,-.328),vec4(-1.542,.469,-.039,1.246),vec4(-.393,1.007,-.623,-.098),vec4(-.024,.903,-.061,-.015),vec4(1.281,.406,-.139,-.304),vec4(.781,.234,-.444,-.208),vec4(.442,.019,-.917,-.422),vec4(.960,-.624,-.722,.243),vec4(.120,-.131,-.389,-.118),vec4(.012,.913,-.290,-1.284),vec4(1.088,1.182,-.039,-1.112),vec4(.106,.406,.204,-.957),vec4(-.079,.502,-.340,-1.075),vec4(-.057,.162,.296,-1.251),vec4(.378,-.486,.661,-.568),vec4(1.013,-.949,-1.523,-.371),vec4(.418,-.691,.361,.507),vec4(-.089,-.481,-.025,-1.273),vec4(1.067,-.886,.335,.148),vec4(-.825,-2.701,.585,-.324),vec4(-1.642,-2.601,3.023,-1.243),vec4(-2.366,1.997,.687,-.857),vec4(-.064,.847,-.085,.181),vec4(.568,-.526,-.768,-.117),vec4(.854,-.950,-.451,.398),vec4(-.390,.919,-.232,.218),vec4(-2.039,.309,-1.083,.489),vec4(-1.148,-.072,-.056,.627),vec4(1.130,.037,.158,.648),vec4(1.098,-.057,.179,.821),vec4(.628,.478,-.079,.057),vec4(1.064,-.393,.270,.697),vec4(1.981,.024,.200,.213),vec4(.946,.627,.371,-.971),vec4(.447,.009,.868,-.564),vec4(-.590,.040,.798,.802),vec4(-.616,-.253,-.820,-.771),vec4(-.816,-.138,.210,-1.493),vec4(.514,-.021,.206,-.759),vec4(.709,-.651,-.892,-.330),vec4(.218,-.079,-1.282,-.356),vec4(-1.495,-.781,.119,-1.435),vec4(.036,-1.271,-.242,.431),vec4(1.210,.116,-1.195,-1.655),vec4(1.874,-.584,-.349,-1.182),vec4(1.604,-1.596,.105,-.198),vec4(.525,1.233,-1.580,-.573),vec4(.875,.322,1.434,-1.016),vec4(.866,1.285,2.355,.083),vec4(-.745,.631,-3.096,-.134),vec4(-.722,-1.513,-.666,-1.197),vec4(.253,1.922,-.504,.041),vec4(-1.116,-.051,.696,-.402),vec4(-.665,.632,-.286,.676),vec4(-1.774,.543,.327,-.343),vec4(.275,.073,.771,.654),vec4(.704,-1.560,-1.353,-.031),vec4(-1.160,-.784,-.770,1.175),vec4(-1.912,-1.488,-.957,.319),vec4(1.214,.892,.117,-.998),vec4(-.049,-.045,-.310,.428),vec4(1.330,.002,.528,-.780),vec4(-.341,.590,-.348,.514),vec4(1.178,-.045,.519,.067),vec4(-.127,-.590,1.001,-.229),vec4(-1.915,-.812,-.457,1.305),vec4(-.737,-.816,-1.899,-1.293),vec4(1.509,1.124,-.058,.761));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed1[idx];\n}", "buffer_b_inputs": [], "common_code": "const int embed_texture = 24; \nconst int embed_channels = 4; ", "buffer_c_code": "const vec4 embed2[576] = vec4[](vec4(-3.039,-.752,1.539,1.991),vec4(-1.027,-2.205,-.346,-.210),vec4(.783,-.697,-.788,-1.575),vec4(-.935,-3.107,-.181,-1.142),vec4(3.970,-6.789,2.045,-6.281),vec4(-1.834,4.422,-1.534,2.010),vec4(-.326,-.273,2.266,2.049),vec4(-1.739,-.101,-2.263,.156),vec4(-.815,-.841,.888,-2.329),vec4(1.827,-.536,2.344,-8.265),vec4(2.913,-3.649,1.953,.477),vec4(-5.858,1.060,.124,.288),vec4(.642,-.353,.587,.433),vec4(-.738,.333,-.357,.845),vec4(1.049,-1.005,-.487,-.174),vec4(.115,-3.800,-1.079,-1.340),vec4(.466,1.050,-1.834,-1.069),vec4(-.118,-1.030,.924,1.256),vec4(.832,-.883,.055,-1.074),vec4(-2.542,3.200,2.220,-2.956),vec4(1.582,-1.782,3.682,.014),vec4(1.730,-.149,-.130,-1.880),vec4(1.398,-.994,-1.158,1.116),vec4(3.100,-4.674,11.568,.164),vec4(-1.453,-2.216,-.804,-.531),vec4(-.915,-2.357,-.442,-.626),vec4(.195,-.256,-1.275,-.736),vec4(.847,-2.272,.452,-2.143),vec4(-.426,-2.866,-.533,1.830),vec4(.683,1.736,1.746,.592),vec4(-2.500,-.429,-.011,.227),vec4(.653,-1.607,1.508,.616),vec4(-.289,.284,-1.070,-1.128),vec4(-.714,-.218,1.033,-.772),vec4(.984,-1.462,.560,-2.220),vec4(-1.674,-1.292,-.837,-.992),vec4(-.451,.407,-.550,.829),vec4(.822,-.222,.964,1.338),vec4(.832,.215,.352,.234),vec4(-1.487,.028,-1.022,-1.250),vec4(.875,-1.904,-.595,1.272),vec4(-1.740,-.196,-1.078,.032),vec4(-1.049,-.585,-.546,-.800),vec4(-1.224,-.649,.121,-.982),vec4(-.941,-.389,1.701,.031),vec4(.233,-.441,-.799,-.978),vec4(-.574,-.258,1.582,-.694),vec4(-2.340,.188,-3.781,-2.775),vec4(.243,-2.723,-.171,-1.387),vec4(.339,-2.522,-.552,-.382),vec4(.187,-2.620,.045,-2.755),vec4(3.929,1.095,-1.773,-3.382),vec4(1.635,-1.376,1.008,.786),vec4(-.478,-.340,.945,-.771),vec4(-.814,.582,.186,-.716),vec4(-.771,.447,-.787,-.616),vec4(-.777,-1.988,-1.113,-.454),vec4(-1.012,-1.145,.580,-.737),vec4(-.005,-.064,-.234,-.324),vec4(.371,-.883,-.545,-1.960),vec4(.060,.226,-.933,.307),vec4(.090,-.060,-.419,.198),vec4(-.408,-.992,1.509,.837),vec4(-.957,.460,-.015,-2.818),vec4(-.963,-.644,.411,1.760),vec4(-1.379,2.340,-1.606,-.899),vec4(-.593,.296,-.759,-.907),vec4(.264,-.707,.420,-1.056),vec4(-.607,-.013,-.704,-1.741),vec4(-.816,.040,1.372,-1.005),vec4(-.142,-.627,-.318,-1.824),vec4(.317,.839,.599,-.591),vec4(-.582,-1.643,1.780,-.786),vec4(-1.692,-1.014,1.924,-.440),vec4(-1.483,-.824,1.372,-.043),vec4(.384,1.468,.497,-.365),vec4(.822,.071,-.768,-.072),vec4(-.729,.038,.258,-.453),vec4(.264,-.053,.939,2.326),vec4(.396,1.074,.296,-1.137),vec4(-1.821,3.515,-.170,-.651),vec4(.583,-.815,.537,-1.238),vec4(.275,.041,-.201,-.122),vec4(.361,-.056,-.287,-1.510),vec4(.054,.137,-.630,-.140),vec4(.289,.960,-.065,-.562),vec4(.425,.247,.082,-.748),vec4(1.960,-1.382,.182,-1.536),vec4(-.638,-.264,-1.118,-.485),vec4(1.905,-.108,-.450,.017),vec4(.042,-1.898,-1.568,-2.116),vec4(-1.233,.683,-.357,-.477),vec4(1.025,-.714,-1.651,-1.483),vec4(-1.484,-.957,.429,.870),vec4(-.911,-.967,.281,-1.085),vec4(-2.616,3.613,-1.017,-2.560),vec4(-2.062,-.941,.315,-1.997),vec4(-2.268,.625,.722,-.556),vec4(-1.480,.252,1.781,1.364),vec4(-1.861,-2.198,-.140,-1.815),vec4(-1.019,-.955,.035,.497),vec4(-.181,.565,-.554,1.380),vec4(1.408,-.094,.591,-.133),vec4(.972,-.904,1.964,1.456),vec4(.290,1.106,-.210,-1.058),vec4(.188,1.799,.863,.055),vec4(.531,-.161,-.707,-.602),vec4(.557,-.402,-.570,-.167),vec4(-.102,.318,-.710,.163),vec4(.244,.885,-.275,-.456),vec4(.252,.941,.195,.139),vec4(.433,-.723,-.089,-.560),vec4(1.006,-.241,-.229,-1.652),vec4(-.140,-1.588,.009,-.582),vec4(.178,-.068,1.183,-1.100),vec4(.816,1.601,.080,-2.547),vec4(-.125,.012,-.931,-.306),vec4(-.350,-1.012,.489,-1.075),vec4(-1.154,1.149,1.079,-1.730),vec4(1.921,-.036,-2.512,1.157),vec4(.045,-2.413,1.985,-.627),vec4(-.993,-.919,-.891,1.295),vec4(.920,.404,-2.257,.372),vec4(-1.299,-.302,.374,-1.327),vec4(-.907,2.316,.622,-1.680),vec4(1.714,-.249,1.968,-1.051),vec4(-1.397,-.533,.438,-.302),vec4(-.787,.550,-.091,-1.683),vec4(.705,-.529,-.109,-.612),vec4(-.170,1.552,-1.479,-1.134),vec4(.321,.081,.055,-.240),vec4(.260,.358,-.313,.653),vec4(.380,-.199,-.645,.168),vec4(.329,-.287,-.081,.390),vec4(.487,-1.046,.207,.430),vec4(-.201,-.167,-.629,.418),vec4(-.437,-.312,-.301,.088),vec4(.742,.473,.201,-.551),vec4(-.063,-.081,.519,2.183),vec4(-.753,.926,1.091,.578),vec4(.526,-.487,.083,.838),vec4(-.736,-.968,.824,1.191),vec4(-1.575,1.237,.199,1.157),vec4(-2.803,-2.421,.854,2.071),vec4(-.177,-4.686,2.090,9.628),vec4(-.246,-1.071,-1.953,-1.353),vec4(.090,.626,.970,.141),vec4(-.297,.082,.915,-.811),vec4(-1.394,-.553,2.148,-1.530),vec4(-.326,.720,1.241,-.309),vec4(.356,-.654,.841,-1.068),vec4(1.868,-1.006,1.213,-2.868),vec4(-.790,-1.850,.471,-2.617),vec4(-.427,1.148,-.159,.473),vec4(-.454,.808,-.656,-.591),vec4(-.018,.819,-.551,.550),vec4(.459,-.626,-.494,.528),vec4(.170,.241,-.221,.814),vec4(-.851,1.081,-.265,1.255),vec4(-.044,-.648,.199,.355),vec4(-.220,.193,.467,.978),vec4(-.737,.107,-1.283,-.570),vec4(-.082,.127,-.478,-2.151),vec4(-.299,1.218,.170,.152),vec4(-1.806,-.468,-1.230,1.992),vec4(-1.497,.023,-1.078,-.941),vec4(-.256,-2.452,-.860,.385),vec4(4.556,.189,-.793,-2.775),vec4(.201,1.644,-1.771,-1.400),vec4(-1.498,.882,-.573,-.480),vec4(-1.049,.386,1.232,.299),vec4(-.270,-.443,1.261,1.162),vec4(1.514,-.356,-.133,-.775),vec4(-.233,-.375,-1.332,-1.643),vec4(.473,-1.671,.855,-.025),vec4(.877,-1.640,.520,-.517),vec4(-.124,-2.000,.482,-.996),vec4(-.084,-2.200,-.496,-.821),vec4(.185,1.001,-1.153,.300),vec4(1.166,-.507,.415,1.141),vec4(.028,-.297,-.017,.726),vec4(.197,1.083,.050,1.210),vec4(.403,1.938,-.140,.433),vec4(.344,-1.394,1.068,.500),vec4(-.079,-2.789,-.446,-2.401),vec4(.359,-.579,-.358,-1.018),vec4(-.541,-2.404,.203,.486),vec4(-.052,-.729,.130,-1.767),vec4(.781,-.936,-.900,-.171),vec4(.680,-.912,-.623,-.504),vec4(-1.256,1.193,-1.520,-.934),vec4(-2.034,.411,-1.340,.411),vec4(-2.804,.885,-2.582,-1.567),vec4(.520,-.135,.159,-.746),vec4(.083,-.641,.567,.507),vec4(-1.165,-.107,.091,-.474),vec4(-.982,.308,.089,-1.367),vec4(.906,-.347,-.149,1.589),vec4(-.882,.098,-.242,.391),vec4(.664,-.556,-.840,-1.535),vec4(.182,-1.950,1.237,-.961),vec4(.507,-1.106,-.790,-.869),vec4(.598,-.573,.427,2.154),vec4(-.977,-.622,-.142,.922),vec4(-.157,-.233,.438,.393),vec4(-.032,-.278,-.708,1.091),vec4(.933,.493,.635,.071),vec4(-.604,-.643,.699,.289),vec4(.741,-2.576,.725,-2.584),vec4(.509,-2.434,.158,-1.676),vec4(-1.103,.147,.907,-2.466),vec4(.196,.127,1.529,-1.846),vec4(2.357,-1.089,.245,-.476),vec4(.171,.300,-1.376,-1.911),vec4(.973,.798,-.084,-1.433),vec4(1.775,.731,-.110,-.738),vec4(-.658,.131,.032,-1.083),vec4(-.296,-1.280,.043,-.020),vec4(-.772,-1.032,-.282,-.234),vec4(-1.112,-.215,.722,-1.845),vec4(.712,.039,.365,1.543),vec4(1.073,.327,-.399,1.961),vec4(.817,.027,.007,-.557),vec4(-.361,.251,-1.292,.735),vec4(.259,.423,-1.975,.665),vec4(.368,-.088,-.448,-.590),vec4(.172,-.340,-.079,.386),vec4(-.513,-.007,-.605,.723),vec4(.565,-.297,-.067,.164),vec4(.264,.168,-.488,.380),vec4(1.636,.641,.794,.132),vec4(1.456,-.678,.632,.011),vec4(1.562,-2.047,1.228,-.130),vec4(1.633,-1.549,.436,-.381),vec4(.254,.382,.318,.652),vec4(-.183,.474,-.360,1.380),vec4(-.009,.850,1.206,-2.226),vec4(.885,1.296,1.033,-2.867),vec4(.988,.466,-2.306,-2.159),vec4(1.508,-.125,-2.082,-2.575),vec4(-.513,.399,.894,-.271),vec4(-1.244,.532,.608,.184),vec4(.051,-.318,1.233,.422),vec4(1.147,-1.031,.283,-.376),vec4(1.130,-.739,.751,.357),vec4(.537,-.720,1.376,1.343),vec4(-.354,.738,.162,.279),vec4(.243,.025,-.376,.181),vec4(.126,.161,-.588,-.371),vec4(-.411,.124,-.209,.456),vec4(-.139,.735,-.636,.360),vec4(.497,.525,-.244,.114),vec4(.546,-.150,-.276,.436),vec4(.541,.094,.415,.460),vec4(.989,.019,-.119,-.356),vec4(1.642,.037,.057,.051),vec4(.577,.204,-.626,.418),vec4(-.249,-.031,-.855,.587),vec4(.046,.255,.662,.789),vec4(.168,.700,.539,.758),vec4(.028,.349,-.359,1.287),vec4(-1.338,-.819,-.556,.481),vec4(-.945,.639,-.574,-.576),vec4(-1.861,2.285,1.927,1.100),vec4(-.875,.380,-.397,.250),vec4(-.575,.217,-1.154,-.504),vec4(-.018,.221,.038,1.917),vec4(-.348,-.222,1.192,.313),vec4(.951,.579,.322,-.126),vec4(.918,.432,.111,-.511),vec4(-.650,1.301,-.807,.049),vec4(-.390,.076,-.185,-.172),vec4(.575,.444,-.312,.785),vec4(-.306,1.145,.381,.328),vec4(-.227,1.322,-.620,.044),vec4(1.188,-.045,.183,.390),vec4(-.572,.836,-.254,1.309),vec4(-.114,.410,.220,.286),vec4(.013,.575,.330,-.072),vec4(.676,.553,-.705,-.299),vec4(.630,-.083,-.335,-.692),vec4(.427,-.032,-.151,-1.039),vec4(.240,.332,.206,-.546),vec4(.382,.226,.366,-.860),vec4(-.532,.069,-.145,-.104),vec4(-.236,.524,-.038,-.323),vec4(.218,.804,.339,.133),vec4(-.126,1.601,-.155,.587),vec4(2.448,1.020,.895,.598),vec4(.648,-1.312,.988,-.578),vec4(-.016,-1.756,.808,-.422),vec4(-.879,-.117,-.208,.034),vec4(-.254,-.111,-1.328,-.070),vec4(-.659,-1.402,-.925,-.847),vec4(-1.224,-.679,-.267,.326),vec4(-.910,.123,-.811,1.144),vec4(-.214,.037,-.331,.705),vec4(-.612,-.336,1.413,.649),vec4(-1.199,.368,.146,.981),vec4(-1.530,.686,-1.009,1.398),vec4(.042,.801,.474,1.584),vec4(-.910,-.233,.180,.719),vec4(-.678,.351,-.740,.775),vec4(-.400,.027,-.263,.482),vec4(-.568,.686,-.522,1.137),vec4(-.538,.670,-.512,-.202),vec4(.482,.690,-.215,-.618),vec4(.423,.015,.318,-1.123),vec4(-.736,1.181,.523,-.351),vec4(.401,.358,.195,.297),vec4(.400,.879,-.949,.464),vec4(-.201,1.278,-1.604,.200),vec4(-2.023,3.339,-3.800,.109),vec4(-.981,.389,-1.122,-1.015),vec4(.041,-.138,-.451,.489),vec4(-.313,-.253,.417,.769),vec4(.518,-.980,.358,.109),vec4(-1.908,1.212,-.445,-.057),vec4(-.608,.514,-.146,-.221),vec4(.574,-.307,-.347,-.012),vec4(.092,1.059,.177,-.302),vec4(-.787,-1.421,-.286,-.390),vec4(-1.990,1.209,.612,1.413),vec4(-1.310,2.006,1.866,1.769),vec4(.582,-.000,.054,.847),vec4(.055,1.056,.376,.975),vec4(.686,.861,.215,.581),vec4(.037,.522,.173,.757),vec4(.402,1.128,.868,-.767),vec4(.240,-.189,.661,-.547),vec4(.958,-1.466,.246,.191),vec4(.670,.788,.382,.469),vec4(.051,.512,.229,.142),vec4(-.227,.666,.242,.377),vec4(-.461,.662,.109,.276),vec4(.529,.630,-.644,-.244),vec4(1.730,-1.516,.993,-.057),vec4(.987,-.118,1.318,.003),vec4(.712,-.633,.441,.129),vec4(-1.329,1.042,-.255,.192),vec4(-1.035,-1.791,-.633,1.149),vec4(-1.005,-2.120,-.406,1.614),vec4(-.258,.753,-.323,-.044),vec4(.515,-.384,.195,.698),vec4(.057,-.040,-.564,-.319),vec4(-.286,-1.334,-.340,1.423),vec4(-.141,1.026,1.031,.048),vec4(-.658,1.639,.292,2.074),vec4(.341,.819,-.249,.730),vec4(1.707,3.108,1.686,.335),vec4(-1.381,1.249,-.360,.294),vec4(-1.253,.292,-.354,-.208),vec4(-.651,-.828,-1.489,1.254),vec4(.543,1.522,.671,.115),vec4(-.227,1.943,1.405,.662),vec4(.487,-2.539,-.873,.819),vec4(-.904,.055,.138,1.244),vec4(-.204,.085,-.505,.790),vec4(1.602,-.679,-.257,-.291),vec4(.568,.809,1.088,-.366),vec4(2.475,-.725,2.057,1.604),vec4(-.266,.147,-.183,.047),vec4(-.103,.320,.429,.345),vec4(-.107,.196,.283,-.806),vec4(-.507,-.895,.538,.053),vec4(.096,1.767,.738,-.854),vec4(-.440,.549,1.395,.083),vec4(.816,-.493,-.113,-1.024),vec4(-.177,-.075,-.127,.808),vec4(-.592,.871,-.271,-.211),vec4(-1.738,1.018,-.453,.918),vec4(-.195,-.916,.045,.724),vec4(-.134,.999,1.063,.248),vec4(-.743,.048,1.590,.557),vec4(.082,2.370,.593,.566),vec4(.419,2.639,-.131,.705),vec4(-.803,.642,-.169,.390),vec4(-1.287,.813,.094,-.451),vec4(-1.680,.450,-.714,-1.406),vec4(-1.480,.073,-1.466,-1.188),vec4(-.956,-1.636,-2.087,-1.386),vec4(-.542,-.674,-.066,-.548),vec4(-.567,.091,.702,.292),vec4(1.940,-.456,1.434,-1.464),vec4(-1.236,-3.581,-.486,2.854),vec4(-1.848,.320,-.375,.955),vec4(-.385,1.071,2.077,-.376),vec4(.125,-.701,.580,-.502),vec4(.436,.447,.080,-.326),vec4(-.522,.038,-.250,.486),vec4(.410,.331,.115,.610),vec4(.025,.375,.029,-.271),vec4(-.589,.573,-.416,-.315),vec4(-1.515,.621,-.364,-.043),vec4(-.101,.301,1.532,.644),vec4(-.775,.538,.152,1.056),vec4(-1.033,-.028,-.250,.997),vec4(-.565,.348,1.001,1.584),vec4(-.370,1.461,.638,2.120),vec4(.297,.939,.504,.182),vec4(-2.835,1.913,-.933,.984),vec4(-1.084,.642,-1.249,-1.771),vec4(-1.063,1.462,-.175,.202),vec4(.587,1.526,-.459,-.778),vec4(-.415,2.380,-.726,1.058),vec4(-.722,.633,.036,.372),vec4(.630,-.280,-.526,-.067),vec4(1.191,.363,-.276,.606),vec4(2.420,-3.120,.318,-.386),vec4(-1.118,-.366,1.264,.825),vec4(-.468,-2.998,-.605,-1.004),vec4(.005,.521,.917,.250),vec4(.387,.899,.996,-.252),vec4(-.256,1.078,.535,.002),vec4(-1.057,.492,.015,-.217),vec4(-.458,-.033,.001,.169),vec4(-.547,.631,.044,.764),vec4(-.922,1.541,-.164,1.239),vec4(-.373,.007,.466,1.265),vec4(.286,.509,-1.039,.139),vec4(-.994,.119,-1.058,.584),vec4(.491,-.755,-.050,1.091),vec4(.316,-.384,.079,1.192),vec4(-1.536,.072,.193,1.509),vec4(.116,.907,1.220,-.300),vec4(-.881,.364,.122,.021),vec4(.051,1.219,-1.599,-.207),vec4(-.470,.918,-.875,-.529),vec4(.989,-1.415,-.810,.292),vec4(1.190,-.574,.502,-.095),vec4(-.432,.873,.934,.783),vec4(.356,.797,.611,1.481),vec4(.953,-.839,-.379,.584),vec4(2.940,-1.191,-2.741,3.182),vec4(1.025,-1.715,-.286,-1.656),vec4(-.922,.290,-.347,2.004),vec4(.268,.491,.129,-.840),vec4(.916,.176,-.128,-.189),vec4(-.161,.533,.936,-.465),vec4(.648,.805,.522,-.850),vec4(.176,.702,.483,.397),vec4(.845,.058,.457,.209),vec4(1.419,.024,-.150,.137),vec4(-.089,.335,.314,1.029),vec4(.135,.185,-.669,-.717),vec4(-.712,.155,-.841,.502),vec4(-1.048,.168,-.079,.103),vec4(.163,.199,.371,.318),vec4(-.445,.545,.637,.275),vec4(-1.761,1.035,.378,.609),vec4(.070,.545,.348,-.003),vec4(-.166,-.688,-.432,.732),vec4(-.510,2.322,-.056,.759),vec4(-.654,1.226,.135,.122),vec4(-.173,.377,-.926,-.612),vec4(-.261,-.244,-.768,.926),vec4(-2.400,-1.267,-2.894,.215),vec4(-1.492,.182,-1.228,-1.340),vec4(.944,-2.799,.627,-.305),vec4(-.004,-.900,-.399,.805),vec4(.293,.653,-.071,-.410),vec4(.666,.499,.415,-.072),vec4(.172,-.647,.485,.303),vec4(.551,.387,.624,.492),vec4(-1.053,.980,-.605,1.483),vec4(.762,-.649,.103,.346),vec4(.428,.375,.284,.299),vec4(.167,.454,.423,.360),vec4(.521,-.450,-.267,.762),vec4(-.288,.832,.129,-.953),vec4(.460,.282,-.629,-.972),vec4(1.000,-.116,.128,-.699),vec4(-.424,-.120,.104,.923),vec4(-.602,.246,-.519,.199),vec4(-.287,.662,.224,-.032),vec4(-.696,.266,-.339,.389),vec4(.441,.590,.640,-.275),vec4(.361,-.363,1.108,-.212),vec4(.192,.040,-.731,-.889),vec4(-1.743,1.595,-2.248,-.551),vec4(-.904,-2.506,-.318,-1.144),vec4(.787,-.384,-.323,-.856),vec4(.502,.024,1.420,1.270),vec4(.227,-1.173,-.495,.092),vec4(1.300,-.018,.050,-.552),vec4(.276,.270,.151,-.602),vec4(.981,-.381,-.077,.390),vec4(-.391,-.299,.594,1.072),vec4(-.089,-.108,-.128,1.241),vec4(-.263,1.040,.119,.214),vec4(-.025,.439,.226,-.153),vec4(1.179,.254,.719,.389),vec4(-.324,.434,-.507,.455),vec4(-.274,-.449,-1.125,.057),vec4(-1.149,-.677,.121,-.769),vec4(-.100,-.866,.598,.568),vec4(-.042,-.073,.090,-1.352),vec4(-.324,-.086,.889,-.000),vec4(.832,.020,.045,.497),vec4(.237,-.395,.249,.408),vec4(-.301,.074,-.100,-.523),vec4(-.664,.533,-.520,-.223),vec4(-.338,.145,.663,-.484),vec4(.522,-.283,.351,-.157),vec4(-1.767,1.131,-.290,-3.079),vec4(1.747,-1.907,1.298,-.249),vec4(-.681,.569,.185,2.303),vec4(.012,.421,-.366,-.145),vec4(1.385,-.824,.111,-.655),vec4(1.148,-.452,.325,-.179),vec4(.052,1.471,-.799,-.327),vec4(.599,-.206,-.090,.807),vec4(-.075,.215,-.638,.377),vec4(.630,.438,-.125,-.184),vec4(.105,.245,-.071,-.516),vec4(.746,.203,-.129,.234),vec4(-.415,-1.213,-.876,.028),vec4(-.303,-.844,-.676,.382),vec4(-.566,.365,.107,-.167),vec4(-.307,-.230,-.040,.913),vec4(.411,-.282,.184,-.369),vec4(-.044,-.352,-.544,-.381),vec4(.559,1.064,-.176,.354),vec4(-.003,-.941,-.518,.323),vec4(-.371,-1.015,-.421,.362),vec4(-.451,-.944,-.045,.628),vec4(-.163,.314,.313,.190),vec4(-.825,-.912,-.976,-1.891),vec4(-1.053,-1.408,1.953,-1.946),vec4(-.171,-.093,-.730,2.154),vec4(1.660,.781,-1.467,1.301),vec4(.207,-.117,-.426,.684),vec4(1.579,-.879,.095,-.710),vec4(.210,.151,-.767,.388),vec4(.056,.367,-1.018,-.847),vec4(.008,.718,-1.293,-1.236),vec4(-.118,-.121,-1.095,.905),vec4(-.032,.066,-.536,.004),vec4(.437,.106,-.352,-1.060),vec4(-.378,.666,-1.283,-.369),vec4(.330,-.558,-.331,-1.167),vec4(-.078,.164,.802,-.530),vec4(1.006,.682,.204,-.403),vec4(-.280,.577,.663,1.262),vec4(.106,-.057,-.448,.478),vec4(-.812,.410,-1.381,-.165),vec4(.646,.869,-.142,-.133),vec4(.067,.221,-.004,1.281),vec4(.732,-1.106,-.109,-.821),vec4(-.626,-.356,.602,1.427),vec4(-.583,.854,.006,-.398),vec4(1.097,-1.529,-.751,-.666),vec4(9.573,2.640,.878,-.387),vec4(1.568,-2.321,-.471,-5.413),vec4(6.066,3.516,-2.975,-.881),vec4(1.379,-2.244,.141,.955),vec4(.135,.666,-.403,-.298),vec4(1.205,-.017,-2.394,.258),vec4(-.805,-1.356,-.137,2.711),vec4(.519,-.905,.787,1.422),vec4(-.725,-.617,.319,-1.797),vec4(-.810,1.458,-.911,-2.197),vec4(.725,-.112,-.799,-1.578),vec4(1.489,-1.979,-1.933,.047),vec4(-.073,-.320,-1.898,-.385),vec4(.508,.095,-.049,-.157),vec4(.571,.886,-.372,.340),vec4(.740,.675,-.652,-.186),vec4(-.165,.442,-.370,.056),vec4(-.843,.015,-1.313,-.278),vec4(.393,1.242,-.756,.172),vec4(1.554,-.149,-.053,-.496),vec4(1.957,-1.835,.313,-.926),vec4(1.064,.465,1.446,-.211),vec4(-.961,.969,.242,.549),vec4(1.558,1.149,-.975,-.207));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed2[idx];\n}", "buffer_c_inputs": [], "buffer_d_code": "const vec4 embed3[576] = vec4[](vec4(-.050,-1.528,-.662,2.668),vec4(-1.094,.276,.710,-.132),vec4(1.299,-.495,1.758,-.602),vec4(-1.340,-1.709,.209,.580),vec4(-1.416,2.243,1.290,1.267),vec4(-.312,2.602,-.042,1.515),vec4(1.984,-2.521,1.590,2.780),vec4(-2.166,-.905,1.754,.434),vec4(-1.276,-2.322,4.015,-.263),vec4(3.371,.617,.609,1.784),vec4(1.071,-1.948,.992,.777),vec4(2.848,-2.587,-1.072,-3.133),vec4(-.863,1.470,2.002,3.742),vec4(1.494,1.183,-1.535,-.554),vec4(-.645,1.811,.107,-.252),vec4(-.674,-4.513,.906,-.941),vec4(-6.013,3.256,1.163,-.150),vec4(.847,2.008,.702,2.813),vec4(-.124,.527,1.738,.169),vec4(-1.462,3.116,2.906,.884),vec4(-.728,-.153,-.306,-1.459),vec4(-.318,3.097,2.938,6.002),vec4(-2.500,-.725,3.481,1.598),vec4(-7.075,4.887,.969,-5.382),vec4(-.801,-.782,1.484,.349),vec4(-.474,-.917,.544,.103),vec4(.777,-.024,-.658,-2.037),vec4(.290,.541,-1.228,-1.223),vec4(1.653,-4.588,-1.390,-1.221),vec4(-1.659,1.536,-.223,1.325),vec4(.918,1.411,.630,1.462),vec4(.012,.338,.669,-.586),vec4(-1.704,.180,2.371,-.369),vec4(1.178,-1.079,-.248,-.032),vec4(.012,-.675,-1.277,.271),vec4(.537,-1.423,.118,-1.389),vec4(.117,-.000,.240,.660),vec4(1.142,-.783,-1.967,.231),vec4(-.824,.783,-.945,-.373),vec4(.095,-1.165,.663,-.866),vec4(-1.178,-1.256,-1.363,-1.057),vec4(.912,.063,2.000,-1.010),vec4(-.886,-.326,-1.254,.519),vec4(.556,.912,-.309,.027),vec4(-.634,.828,.577,.593),vec4(-1.109,-.058,-.916,.406),vec4(.913,1.113,-.183,1.755),vec4(5.802,-2.185,-2.397,.624),vec4(.680,1.527,-.250,-.856),vec4(-.201,-.077,-.738,-1.534),vec4(-.499,1.081,-.602,-1.717),vec4(.798,1.278,-.644,-1.747),vec4(-1.183,.077,-1.662,-.125),vec4(.055,1.610,.585,2.413),vec4(-.934,-.012,-.206,.835),vec4(-.407,-.588,.246,1.237),vec4(-.074,.719,.646,1.620),vec4(.904,-.185,-.107,.253),vec4(-.708,-.397,-.057,-.324),vec4(1.394,-.615,-.872,-1.910),vec4(.728,-.710,-.307,.580),vec4(.009,.280,-.429,.259),vec4(.468,-.872,.706,.574),vec4(1.859,.102,-.671,-.875),vec4(-1.022,2.572,-.976,-1.195),vec4(-.556,-.899,1.743,-.006),vec4(.121,.841,.401,-.345),vec4(-.231,-.307,.996,-1.590),vec4(.291,.454,.487,-.501),vec4(-.157,-.778,-.406,.451),vec4(-1.640,.421,-.254,-.900),vec4(-.984,-4.618,3.026,-.768),vec4(1.057,.115,-1.444,-.911),vec4(.529,.240,-.578,-.785),vec4(-.797,.228,-.842,-1.116),vec4(-.746,-1.984,-.774,.395),vec4(-.389,1.691,-.387,2.050),vec4(-.456,1.740,.538,2.287),vec4(-3.170,2.080,1.671,-.310),vec4(-.825,-.843,2.197,1.071),vec4(-.029,-1.153,3.083,-.690),vec4(-.791,1.296,-.974,.717),vec4(.301,-.555,-.076,-.717),vec4(.891,.355,-.758,-1.033),vec4(.675,-.315,-.706,-.187),vec4(.713,.071,-.662,.649),vec4(.683,.405,-.521,.388),vec4(3.293,-.381,-1.675,-.033),vec4(-.974,1.897,-.358,.153),vec4(-1.290,.252,2.753,.193),vec4(.127,1.434,-.602,-.307),vec4(-1.323,-.382,.651,-1.137),vec4(.477,-.359,2.171,.505),vec4(-1.497,1.444,-.239,1.080),vec4(.358,-.086,-.256,-.324),vec4(-.187,-3.038,-.697,1.651),vec4(1.753,.553,-.457,-.756),vec4(.069,-.334,-1.344,.215),vec4(1.235,-1.463,-2.908,-2.891),vec4(1.466,2.408,.271,1.971),vec4(-.816,.264,-.343,-.025),vec4(-3.262,1.516,.676,.737),vec4(.047,1.540,-1.601,.425),vec4(-1.384,1.584,-1.160,1.317),vec4(-.165,-.345,-.418,1.182),vec4(.229,1.038,.710,-.790),vec4(-1.033,.277,-.219,.486),vec4(1.132,-.613,-.107,-.294),vec4(.910,-.457,-.747,-.040),vec4(.762,.453,-.661,.283),vec4(.623,.470,-.367,.694),vec4(1.986,.325,-1.600,.234),vec4(.659,1.288,-.029,.608),vec4(.044,.306,-.907,-1.321),vec4(.637,-3.370,1.761,.934),vec4(.097,-.185,1.868,-.447),vec4(-.548,.074,2.679,-.709),vec4(-.282,.350,-.716,-.524),vec4(.073,-.860,-.497,-.254),vec4(-3.273,1.969,.700,-.205),vec4(-1.478,-5.104,-.129,-3.188),vec4(3.062,-.472,.108,-2.788),vec4(-3.771,.724,-.228,1.767),vec4(-.043,-1.959,1.870,2.891),vec4(-.275,-1.070,.615,.220),vec4(-1.456,-.325,-.561,.485),vec4(.307,.040,-.045,.664),vec4(.306,1.187,-.613,.166),vec4(.650,-.426,-.553,.940),vec4(.069,-.203,-1.229,.380),vec4(.232,.457,-.138,.375),vec4(.219,-1.063,.297,-.201),vec4(1.252,-.814,-.412,-.509),vec4(.440,.091,-.472,.713),vec4(-.025,.106,-.657,.911),vec4(1.169,.435,.466,.348),vec4(.137,1.122,-.265,-.564),vec4(1.568,-.923,1.850,1.114),vec4(-1.428,2.904,.288,.454),vec4(-1.087,-.295,-1.197,-1.347),vec4(-2.014,-.784,-.274,1.213),vec4(-.115,-.277,.139,.354),vec4(-1.745,.005,.907,.265),vec4(-.101,-3.161,.308,-1.348),vec4(1.992,-8.624,-1.039,-3.609),vec4(-1.935,.007,-2.577,-1.968),vec4(-.609,-.151,2.054,1.048),vec4(.356,.349,.877,-.747),vec4(1.945,.632,1.175,.040),vec4(.744,-.832,.632,-.045),vec4(-.901,.313,-.033,.566),vec4(-1.345,1.079,1.792,-.286),vec4(-.308,.981,-1.111,-1.945),vec4(-.141,-2.021,-.131,-.672),vec4(-.250,.416,.332,-.315),vec4(.787,-1.279,.249,.069),vec4(.823,-.837,-.571,-.215),vec4(.746,-.825,-.352,.084),vec4(.715,-.503,.278,.896),vec4(-.397,-.167,.681,-.309),vec4(-.313,-1.804,.432,-1.239),vec4(-2.157,.106,.184,-.602),vec4(-.343,.795,.440,-1.970),vec4(-1.375,.905,3.152,.652),vec4(1.345,-.499,.287,.636),vec4(-.579,.391,1.037,1.342),vec4(-.231,-.638,.160,.941),vec4(-3.413,1.685,.975,2.013),vec4(1.178,-1.993,1.797,-3.075),vec4(-.659,.196,.636,1.281),vec4(-1.228,.301,.235,1.744),vec4(-1.013,-.308,.517,.505),vec4(-1.637,-.632,1.554,1.481),vec4(-.387,.723,-.105,1.779),vec4(.888,.996,.758,1.319),vec4(-1.264,1.065,.415,-.233),vec4(-1.497,.370,.275,-1.075),vec4(-.995,.567,.441,.385),vec4(.925,.083,.539,-.466),vec4(.489,-.495,.056,-.209),vec4(.908,-.392,-.518,-.290),vec4(.551,-.527,-.014,-.689),vec4(1.790,-1.590,1.555,-1.217),vec4(-.508,-.834,-.171,-.045),vec4(-1.731,.946,.591,3.257),vec4(-1.045,.552,.018,-1.999),vec4(-1.382,.221,-.358,.859),vec4(-1.008,2.127,.539,.070),vec4(-.863,1.857,-.150,2.423),vec4(.123,2.566,-.194,1.473),vec4(.437,1.317,-.205,1.322),vec4(1.206,-2.125,-.571,2.995),vec4(.669,.251,-1.595,-.242),vec4(-1.106,-.373,1.031,.476),vec4(-1.434,-.133,.576,.011),vec4(-.127,-.697,-.624,.417),vec4(-.741,1.504,1.482,1.496),vec4(-2.900,.811,1.826,2.200),vec4(.181,1.108,.992,.282),vec4(-.946,.487,1.573,.955),vec4(-.726,1.087,1.979,-.393),vec4(-.326,1.003,1.790,1.121),vec4(.455,-.768,-1.603,1.382),vec4(.709,.148,-.954,.549),vec4(.997,.068,-1.064,-1.201),vec4(.302,-.093,-.524,-.980),vec4(-1.507,-1.474,-.515,-.518),vec4(-1.608,.805,-2.472,-1.534),vec4(1.028,1.252,2.118,2.324),vec4(-1.448,1.312,-.146,-.969),vec4(-.927,-.660,1.393,-1.093),vec4(.276,2.315,1.033,-.368),vec4(-.369,-.605,.548,.056),vec4(.307,-.303,.552,2.707),vec4(2.315,2.116,-1.276,.352),vec4(2.009,-.613,-2.735,-1.731),vec4(.608,.663,.376,.923),vec4(-.472,.019,1.207,1.766),vec4(-.294,.103,.746,2.057),vec4(1.637,.053,2.269,1.118),vec4(-.563,-.453,-.036,2.362),vec4(.727,-2.341,-.134,1.094),vec4(-.111,.570,-1.789,-.143),vec4(1.485,-1.475,-.271,.053),vec4(1.561,-1.502,-.766,-.016),vec4(1.080,.140,.075,-.931),vec4(1.285,-.432,-.917,.544),vec4(.454,-.423,-1.139,.150),vec4(.767,-.576,-.735,-.515),vec4(.202,-.272,-.339,-.451),vec4(-1.135,-.105,-.111,-.251),vec4(.256,-.667,-2.271,-1.354),vec4(-.366,-.259,-.213,.083),vec4(-.158,-.130,-.033,-.028),vec4(.593,.771,-.190,.517),vec4(.001,-.183,-1.412,-.410),vec4(-.002,-.561,-.382,-.585),vec4(1.746,.193,1.500,-.093),vec4(.328,-.551,.949,1.498),vec4(3.001,.295,-1.072,-.129),vec4(.994,-1.495,.667,2.170),vec4(.197,.549,-.157,1.344),vec4(.019,-.744,.005,-1.114),vec4(-1.265,-1.025,-.622,.807),vec4(-.566,.159,.992,.837),vec4(-.524,1.161,-.789,.291),vec4(-.330,.257,-.430,.255),vec4(.929,-.246,.248,.221),vec4(2.039,-.673,-.237,-.229),vec4(1.430,-.129,-.209,.185),vec4(1.194,-.363,-.677,-.153),vec4(.679,-.388,-.238,.052),vec4(.291,-.227,-.493,.359),vec4(.939,-.497,.054,-.558),vec4(.516,.151,-.527,-.935),vec4(.740,-.077,-2.004,-.757),vec4(.594,-.244,-.320,-.108),vec4(.626,-.309,-1.517,.010),vec4(-.180,.280,-.032,-.337),vec4(.221,.585,.684,-.345),vec4(-.044,.127,.662,-.523),vec4(-.387,.427,.078,-1.385),vec4(-.681,1.274,-.163,-1.782),vec4(.220,-1.309,2.148,-.906),vec4(-1.150,-1.079,2.185,2.515),vec4(-.931,.539,.871,.987),vec4(-1.073,.468,.094,.504),vec4(.528,-.391,.462,.887),vec4(.006,.377,-.486,1.643),vec4(.422,-1.299,-.316,-1.288),vec4(-.288,.196,.048,-.106),vec4(1.406,.165,-.840,-.465),vec4(.790,-.417,-1.884,-.111),vec4(1.047,-.724,.642,-.141),vec4(1.023,-.367,-.221,-.158),vec4(.431,-.452,.187,.425),vec4(-.289,.067,-.417,.464),vec4(.480,-.570,.587,.032),vec4(.319,.188,-.586,.184),vec4(.380,.721,-1.247,-.380),vec4(-.714,.576,-.599,.270),vec4(.461,.170,-.178,-.293),vec4(-.004,.218,-.775,-1.102),vec4(.506,.153,.169,-.858),vec4(.320,-.047,.797,-.797),vec4(.165,-.128,-.440,-1.816),vec4(-.297,-.264,.268,-1.361),vec4(-1.275,.645,2.398,1.861),vec4(-2.098,-.864,-.990,-4.019),vec4(-.090,.974,.591,.102),vec4(-.498,2.072,.520,.219),vec4(.049,.711,.449,-.431),vec4(.286,.436,.451,.606),vec4(.494,1.083,.140,.919),vec4(1.544,1.483,-.805,-.422),vec4(.859,.550,-1.874,.237),vec4(.158,.471,-2.101,-.921),vec4(1.002,-.703,1.075,-.869),vec4(-.330,.204,.493,-.412),vec4(-1.168,.214,.678,.453),vec4(-.682,.171,1.787,1.458),vec4(.645,.112,-.647,-.067),vec4(1.261,.138,.013,.326),vec4(.790,.372,.094,-.294),vec4(-.007,.174,-.314,.475),vec4(-.971,.123,-.549,.652),vec4(-.938,.014,-.613,-.220),vec4(-.090,-.444,-.409,-.483),vec4(-.288,.031,-.527,-1.825),vec4(-.276,-.187,-.018,-1.407),vec4(.416,.393,-.922,-.894),vec4(2.311,1.109,-1.877,-1.153),vec4(1.110,-.576,-.098,-2.210),vec4(.050,1.616,.634,-.318),vec4(-.704,.568,.138,-.108),vec4(-1.124,.469,-.530,-.806),vec4(-.139,2.004,-.361,-.209),vec4(1.246,-.774,-.003,.221),vec4(.567,-.874,-.386,-.032),vec4(-.175,-.161,-1.279,-.228),vec4(-.321,.060,-.552,-.597),vec4(.752,.343,.346,.672),vec4(-1.169,2.092,.713,2.481),vec4(-1.502,2.038,2.161,3.612),vec4(.348,-.046,-.710,.650),vec4(.658,-.396,.702,.000),vec4(.839,-1.734,.159,-.918),vec4(.840,-.400,.351,-.441),vec4(1.209,-.884,.544,-.942),vec4(.029,.589,-1.040,-.001),vec4(.382,-.846,.307,.079),vec4(-.127,-.932,.837,.600),vec4(-.178,-.107,.732,.698),vec4(-.059,-.038,1.394,.380),vec4(.320,-.035,1.222,-.321),vec4(-.529,.256,-.503,-.161),vec4(-1.719,4.579,-.971,-.209),vec4(-1.090,-1.464,.416,-.999),vec4(.429,-.387,.848,1.421),vec4(.435,.593,2.101,1.253),vec4(1.016,-.558,-.898,.621),vec4(.317,-.573,-.174,-.512),vec4(-1.130,-1.057,1.037,1.131),vec4(.230,-.304,1.190,.161),vec4(-.108,-.109,-.481,-.090),vec4(.451,1.076,-1.561,-1.823),vec4(-1.697,-.185,1.626,2.198),vec4(-.377,-.184,.206,.704),vec4(.524,.410,-.440,-1.484),vec4(.181,-.817,1.097,-.854),vec4(.056,-.059,.356,-.056),vec4(.326,-.126,.319,-.293),vec4(-.575,-.940,-.222,-.320),vec4(-1.229,-.051,.357,-.913),vec4(-1.442,1.536,-.011,-.484),vec4(.164,2.012,-.574,.382),vec4(.895,2.017,.589,.489),vec4(1.109,-.095,.939,.418),vec4(-1.156,1.272,-.784,-.507),vec4(-.936,1.336,-.810,-1.084),vec4(-1.678,-3.237,3.043,1.322),vec4(.940,-.698,2.009,.466),vec4(.345,1.163,-.177,.255),vec4(.375,.670,-.552,.207),vec4(1.490,-1.106,-.028,-.045),vec4(1.039,-1.232,.186,.207),vec4(1.652,-1.296,.925,.167),vec4(.750,.015,-.250,2.003),vec4(-.351,-.903,-.178,.177),vec4(-1.214,-.075,.971,.709),vec4(-1.169,-.116,1.002,.038),vec4(-1.135,.161,-.678,.203),vec4(.223,-1.039,.336,.115),vec4(.352,.142,.609,-.437),vec4(-1.233,.660,.458,-1.219),vec4(-1.931,-.646,-.432,-.313),vec4(.255,.523,-.087,-1.274),vec4(.789,.863,-.566,-1.090),vec4(.198,-.684,.752,-.656),vec4(-1.092,-1.568,2.091,-.063),vec4(-.010,-.166,-.662,.136),vec4(.257,.122,-.632,-.097),vec4(.575,-.628,.924,-.013),vec4(2.253,-.442,.344,-2.017),vec4(-2.128,.450,-7.270,1.104),vec4(1.807,-1.355,-.108,-.654),vec4(1.818,.570,1.284,-.694),vec4(.789,1.236,-1.701,.693),vec4(-.673,.816,.013,.972),vec4(-.321,.733,-.760,-.325),vec4(-.329,-.229,-.621,.120),vec4(.565,-.430,.164,-.073),vec4(-1.044,.189,2.609,2.277),vec4(-.847,-.709,.874,.640),vec4(-.672,.204,.854,-.326),vec4(-.049,.861,.016,.331),vec4(-.660,1.027,-1.232,-.810),vec4(.048,1.090,.095,1.125),vec4(-.208,-.491,.209,.927),vec4(.335,1.006,.859,-.240),vec4(-.147,.392,1.258,-.020),vec4(1.875,-2.763,.392,.799),vec4(-1.837,-.527,.584,-.021),vec4(-1.060,1.198,1.176,-.468),vec4(-.926,-1.339,-.499,.202),vec4(-.085,-.150,.668,-.397),vec4(-.852,.042,.617,.553),vec4(-.719,-2.079,1.624,1.028),vec4(.471,1.281,-2.726,2.677),vec4(-1.033,.766,.465,1.688),vec4(3.094,-.543,.245,-2.432),vec4(.517,.653,-.575,1.762),vec4(-.325,.859,.388,1.604),vec4(-.155,.306,.681,1.010),vec4(.557,-.251,-.657,-.185),vec4(.301,-.487,-.807,-.057),vec4(-.945,-.520,.063,1.034),vec4(-1.280,-.979,1.314,2.097),vec4(-1.394,.995,.325,-.097),vec4(-.336,1.694,.396,1.709),vec4(-.270,1.214,-.676,-.359),vec4(-1.506,1.683,-.578,-.035),vec4(-1.224,1.210,-.114,.163),vec4(.205,-.006,-.825,-.776),vec4(.249,.349,.937,-.807),vec4(-.530,1.268,.932,.263),vec4(.693,-.674,-.076,.593),vec4(.680,.527,.880,1.257),vec4(1.006,-.451,.463,-.071),vec4(.156,.567,.841,.813),vec4(.615,1.148,.506,.102),vec4(.781,-.245,1.009,.563),vec4(.656,1.375,-.219,.250),vec4(-.822,1.689,-2.197,-.388),vec4(2.151,-.424,.245,-.022),vec4(-.980,.749,-.608,2.173),vec4(-.564,.136,.088,.571),vec4(1.429,-.540,-.165,.959),vec4(.172,.602,.146,.377),vec4(-.437,-.139,.237,.898),vec4(-1.081,-.808,.558,.304),vec4(.249,.358,-.362,.352),vec4(-.348,-.329,-.574,-.194),vec4(.150,.066,-.406,.138),vec4(.076,1.221,.256,.240),vec4(-.713,.306,.682,-.676),vec4(.637,.648,.690,-.573),vec4(-.661,1.390,.348,.112),vec4(-.422,1.820,-.256,-.585),vec4(.407,1.033,.343,-.303),vec4(-1.141,.448,-.027,.482),vec4(-1.501,.837,.036,-.118),vec4(.014,.360,.624,.645),vec4(.895,.604,.273,.614),vec4(1.006,-.765,-.056,2.002),vec4(-.444,.143,.433,-.462),vec4(-6.726,2.109,.171,-.005),vec4(-.956,1.151,-.209,-1.206),vec4(-.591,1.183,-.538,-1.616),vec4(-.884,.318,-.650,1.862),vec4(-.118,.744,-.594,2.371),vec4(-.062,.084,.343,1.087),vec4(-.344,.310,.130,.811),vec4(-.032,.345,.911,.945),vec4(-.164,.973,-.384,.148),vec4(-.756,.354,-.303,1.434),vec4(.220,.545,-.355,.481),vec4(.178,.045,1.054,.432),vec4(.576,-.828,.069,.281),vec4(.305,-.375,1.232,-.408),vec4(.059,.914,.938,1.318),vec4(.151,.669,.139,.587),vec4(-.487,1.745,-.866,.549),vec4(-.252,1.795,-1.297,.650),vec4(-.481,.594,-1.036,-1.056),vec4(-1.058,.098,-1.305,-.389),vec4(-.365,.215,.366,.024),vec4(.410,.224,.909,-.504),vec4(-1.037,.677,.082,.088),vec4(.438,-.494,-.647,.902),vec4(-2.173,2.089,1.196,-.439),vec4(-3.334,.672,-.391,-3.950),vec4(-.220,1.091,-1.923,1.850),vec4(-.002,.860,.455,1.911),vec4(.681,.670,-.402,1.226),vec4(.700,.462,.724,.818),vec4(-.380,.119,-.047,.915),vec4(.360,.756,.987,.472),vec4(-.017,-.185,.646,.763),vec4(-.169,.018,.249,.743),vec4(.105,.090,.102,.271),vec4(.642,-.468,.414,-.141),vec4(.288,-.791,1.185,.367),vec4(-.837,1.146,-.445,.936),vec4(.351,1.041,.689,.338),vec4(.695,1.158,.323,.207),vec4(.298,2.016,-.230,.242),vec4(.386,.785,-.144,-.753),vec4(-.510,-.309,-.287,.923),vec4(-.060,-.121,-.207,-1.106),vec4(.507,.225,-.581,-.913),vec4(-.338,.227,-1.238,-.351),vec4(.307,.146,-.246,-1.568),vec4(.125,.070,-1.888,-.369),vec4(-3.883,1.573,2.151,1.107),vec4(-2.783,.964,.623,-5.132),vec4(2.610,.257,-3.218,.876),vec4(1.064,1.216,-.351,1.145),vec4(.714,.443,.746,.805),vec4(.041,-.373,.888,1.408),vec4(.179,.104,-.785,-.825),vec4(.081,.408,-.263,-.136),vec4(.100,-.148,-.378,-.763),vec4(.294,.670,-.280,-.129),vec4(.712,-.188,-.568,.008),vec4(-.474,-1.122,.102,.180),vec4(1.205,.227,-1.048,.210),vec4(.569,.855,-.984,.572),vec4(-.515,1.302,-1.117,-.020),vec4(-1.077,1.572,-1.050,.543),vec4(.621,1.187,.150,1.126),vec4(.454,.214,-.578,.339),vec4(-.968,-.623,.440,1.225),vec4(-.854,.259,.786,.248),vec4(.099,1.588,-.305,-.278),vec4(.030,1.181,-.822,-.188),vec4(-.311,.380,-.540,-.938),vec4(.431,.077,-.941,.181),vec4(-2.263,5.826,-1.291,-1.251),vec4(-2.155,-.028,.602,-1.227),vec4(1.280,-1.690,-.376,.462),vec4(.135,-.091,-.808,1.272),vec4(.080,.576,.496,.056),vec4(.762,-.411,-.066,-.973),vec4(.251,-.055,-.019,.098),vec4(.358,-.256,-1.144,.192),vec4(-.348,-.256,-1.433,-.865),vec4(.171,.573,.021,-.428),vec4(.655,.678,.224,-.066),vec4(.454,-.418,-.742,.214),vec4(.415,-.249,-.726,.849),vec4(1.073,-.946,-.416,-1.725),vec4(-.663,-.118,.340,-.228),vec4(-.339,1.147,-.649,.195),vec4(-.505,1.064,-.899,1.062),vec4(.443,.205,.018,.485),vec4(-.749,-.666,1.012,.493),vec4(-1.342,.045,1.441,.874),vec4(-.079,1.488,.718,1.534),vec4(.015,.003,-.168,.425),vec4(.097,.451,1.106,.554),vec4(-1.834,.209,-4.078,-.778),vec4(1.791,10.273,-3.743,1.445),vec4(-4.749,-2.611,6.456,-6.833),vec4(-1.423,.139,-6.742,2.720),vec4(.728,.073,-.075,.866),vec4(-.695,.216,-.738,1.144),vec4(-.501,-1.138,-2.047,2.065),vec4(3.842,-.863,-.941,.054),vec4(-.643,-.349,.147,1.964),vec4(1.953,.689,.723,-.309),vec4(-.274,1.188,-1.002,-1.128),vec4(-1.046,2.221,-.564,1.669),vec4(.173,.854,-.373,2.056),vec4(1.472,.798,.780,1.048),vec4(.847,-2.151,-.171,-2.166),vec4(-.371,1.342,-.533,1.753),vec4(-.451,1.261,-1.439,.910),vec4(-.784,-.022,-.174,1.365),vec4(.511,.508,-.317,-.421),vec4(-.722,.443,1.036,1.504),vec4(-2.307,1.074,.287,.485),vec4(-.179,.788,1.767,-.110),vec4(.787,.838,1.289,1.979),vec4(-1.361,-2.571,1.394,-.375),vec4(-.922,1.592,-.892,3.193));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    \n    if((c.x >= (embed_texture+2)*embed_channels/4) || (c.y >= (embed_texture+2)) || iFrame > 8) discard;\n    \n    int ch = c.x / (embed_texture + 2);\n    \n    c = clamp(c - 1 - ivec2(ch*(embed_texture + 2), 0), 0, embed_texture-1);\n    \n    int idx = ch + (c.x*embed_channels + c.y*embed_channels*embed_texture)/4;\n    \n    fragColor = embed3[idx];\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd33zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 423, 423, 4797], [4800, 4800, 4842, 4842, 5057], [5059, 5059, 5125, 5125, 5287], [5289, 5289, 5311, 5311, 5647], [5649, 5649, 5706, 5706, 5928]], "test": "untested"}
{"id": "cdtGRX", "name": "Perlin Cells", "author": "fishy", "description": "Apparently distorting the uv coordinates repeatedly by perlin noise creates cells???", "tags": ["perlin", "cells"], "likes": 12, "viewed": 227, "published": 3, "date": "1677611186", "time_retrieved": "2024-07-30T18:07:47.966377", "image_code": "#define smooth3(x) 3.*x*x-2.*x*x*x\n#define smooth5(x) 6.*x*x*x*x*x-15.*x*x*x*x+10.*x*x*x\n#define smooth7(x) -20.*x*x*x*x*x*x*x+70.*x*x*x*x*x*x-84.*x*x*x*x*x+35.*x*x*x*x\n#define r(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n#define NO_UNROLL min(iTime, 0.)\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float t)\n{\n    vec4 f = vec4(floor(p), ceil(p));\n    mat2 r = r(t);\n    return mix(mix(dot(p - f.xy,  r*(normalize(hash22(f.xy) - 0.5))),\n                   dot(p - f.xw,  r*(normalize(hash22(f.xw) - 0.5))), smooth5(fract(p.y))), \n               mix(dot(p - f.zy,  r*(normalize(hash22(f.zy) - 0.5))),\n                   dot(p - f.zw,  r*(normalize(hash22(f.zw) - 0.5))), smooth5(fract(p.y))),\n                                                                      smooth5(fract(p.x)));\n}\n\nvec2 normal(vec2 p, float t, float eps)\n{\n    mat2 o = mat2(eps*0.5);\n    return vec2(perlinNoise(p+o[0], t)-perlinNoise(p-o[0], t),\n                perlinNoise(p+o[1], t)-perlinNoise(p-o[1], t))/eps;\n}\n\nvec3 gradToVec(vec2 d, float str)\n{\n    vec3 a = normalize(vec3(1, -d.x*str, 0)),\n         b = normalize(vec3(0, -d.y*str, 1));\n    return cross(a, b);\n}\n\nvec2 distort(in vec2 p, float scale, float t, float dst, float it)\n{\n    for(float i = NO_UNROLL; i < it; i++)\n    {\n        p += normal(p*scale, t, 0.001)/it*dst;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 m =  (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    \n    uv = distort(uv+iTime*0.2, 5., iTime, 0.1, 5.);\n    m = distort(m+iTime*0.2, 5., iTime, 0.1, 3.);\n\n    vec2 n = normal(uv*5., iTime, 0.001);\n    vec3 env = texture(iChannel0, gradToVec(n, 0.4)).rgb;\n    env *= env;\n    \n    fragColor = vec4(vec3(sqrt(env*0.5+0.2*pow(max(0., dot(n, normalize(uv-m))), 10.))), 1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 275, 275, 405], [407, 407, 443, 443, 919], [921, 921, 962, 962, 1123], [1125, 1125, 1160, 1160, 1278], [1280, 1280, 1348, 1348, 1465], [1467, 1467, 1524, 1524, 1966]], "test": "untested"}
{"id": "DtSGzR", "name": "Nighttime water", "author": "fishy", "description": "I think it's cheap. Saw https://www.shadertoy.com/view/mlfGWl and decided I wanted to make my own version.", "tags": ["water"], "likes": 10, "viewed": 215, "published": 3, "date": "1677610611", "time_retrieved": "2024-07-30T18:07:48.839043", "image_code": "#define AA 16.\n\n#define FOCAL_LENGTH 0.6\n\n//#define iTime 6.52\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(in vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(in vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n \nvec3 rotZ(in vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat cosmooth(float x) { return 1.-cos(3.141593*x)*0.5-0.5; }\n\nfloat shash(float x)\n{\n    float fx = floor(x);\n    float s = mod(fx, 2.)*2.-1.;\n    float a = hash11(fx)*s;\n    float b = hash11(fx+1.)*-s;\n    return mix(a, b, cosmooth(fract(x)))*0.5;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y)\n{\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nvec3 getEnvironmentMap(vec3 rd, vec3 l)\n{\n    float ld = dot(rd, l);\n    return (1./(max(1e-10, 1.-ld+0.003))*0.01\n    +0.02/(abs(ld-0.95)+0.07) // ring\n    )\n    *vec3(0.733,0.302,0.769) // coloring\n    +exp(-rd.y*3.)*vec3(0.125,0.075,0.110) // sky gradient\n    ;\n}\n\nfloat getHeight(vec2 p)\n{\n    float r = 0.;\n    for(float i = 0.; i < 3.; i++)\n    {\n        float e = exp2(-i);\n        r += abs(sin(p.x/e+iTime))*e;\n        p = rotZ(p.xyx, hash11(i*25.)*0.2).xy;\n    }\n    return r;\n}\n\nvec2 heightNormal(vec2 p, float dist)\n{\n    vec2 e = vec2(0.2, 0);\n    return normalize(vec2(getHeight(p+e.xy)-getHeight(p-e.xy),\n                          getHeight(p+e.yx)-getHeight(p-e.yx)));\n}\n\nvec3 gradToVec(vec2 d)\n{\n    vec3 a = normalize(vec3(1, -d.x, 0)),\n         b = normalize(vec3(0, -d.y, 1));\n    return cross(a, b);\n}\n\nvec3 halfVec(vec3 a, vec3 b)\n{\n    return normalize(a+b);\n}\n\nvoid _mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 nuv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m =  (iMouse.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, iMouse.z);\n    \n    vec2 rot = vec2(3.14*-0.5, 0)-m.xy*4.-vec2(shash(iTime*0.25), shash(iTime*0.25+0.7071067812))*0.5;\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LENGTH)), rot.y), rot.x);\n    vec3 center = rotY(rotX(normalize(vec3(0, 0, FOCAL_LENGTH)), rot.y), rot.x);;\n    vec3 lgt = rotZ(vec3(1, 0, 0), 0.2);\n    \n    vec3 pli = planeIntersect(ro, rd, 0.);\n    float blend = smoothstep(-0.05, 0., rd.y);\n    \n    vec3 planeNormal = gradToVec(0.2*heightNormal(clamp(pli.xz, vec2(-1e4), vec2(1e4)), 1.)/max(1., distance(ro, pli)*0.5));\n    \n    vec3 env = getEnvironmentMap(mix(reflect(rd, planeNormal), rd, blend), lgt);\n    float vignette = 4.*nuv.x*(1.-nuv.x)*4.*nuv.y*(1.-nuv.y)*0.6+0.4;\n    float glow = pow(max(0., dot(rd, halfVec(center, lgt))), 12.)*0.3*mix(0.2, 1.5, pow(max(0., dot(center, lgt)), 25.));\n\n    fragColor = vec4(sqrt((env+glow)*vignette), 1.0);\n    //fragColor = vec4(glow);\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(vec2 o = vec2(-1.); o.x < 1.; o.x += st)\n    for(o.y = -1.; o.y < 1.; o.y += st)\n    {\n        vec4 color;\n        _mainImage(color, fc + o);\n        res += color;\n    }\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    vec4 color;\n    _mainImage(color, fc);\n    res += color;\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            vec4 color;\n            _mainImage(color, fc + (hash22((x+iTime+fc)*25.)-0.5));\n            res += color;\n        }\n    }\n    return res/AA;\n}\n\nvec3 dither(vec3 color, vec2 coord, float steps)\n{\n    vec3 reduce = floor(color*steps)/steps;\n    vec3 error = color-reduce;\n    return reduce+step(vec3(hash21(coord)), error*steps)/steps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(dither(stochasticAA(fragCoord, iMouse).rgb, fragCoord, 256.), 1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 134], [136, 136, 167, 167, 202], [204, 204, 235, 235, 270], [273, 273, 304, 304, 339], [341, 341, 364, 364, 449], [451, 451, 473, 473, 611], [613, 613, 634, 634, 770], [772, 772, 794, 794, 913], [915, 915, 940, 940, 977], [979, 979, 1001, 1001, 1167], [1169, 1169, 1220, 1220, 1293], [1295, 1295, 1336, 1336, 1561], [1563, 1563, 1588, 1588, 1782], [1784, 1784, 1823, 1823, 1980], [1982, 1982, 2006, 2006, 2116], [2118, 2118, 2148, 2148, 2177], [2179, 2179, 2237, 2237, 3344], [3346, 3346, 3378, 3378, 3629], [3631, 3631, 3667, 3667, 4010], [4012, 4012, 4062, 4062, 4203], [4205, 4205, 4262, 4262, 4351]], "test": "untested"}
{"id": "mdcGRf", "name": "Verlet Particle Simulator", "author": "me_123", "description": "set grid to 2 for lots of particles.", "tags": ["realtime", "particle", "particle", "verlet", "molecular"], "likes": 18, "viewed": 351, "published": 3, "date": "1677605031", "time_retrieved": "2024-07-30T18:07:49.778532", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 f = fragCoord.xy;\n    ivec2 fc = ivec2((f+float(grid)*0.25));\n    ivec2 cell = fc/grid;\n    ivec2 g = ivec2(fc.x%grid, fc.y%grid);\n    if (length(vec2(cell*grid+g)-iResolution.xy*0.5) > iResolution.y*0.451+float(grid)*0.5) {\n        fragColor = vec4(0.5);\n        return;\n    }\n    int id = fc.x%grid+(fc.y%grid)*grid;\n    float d = 10000.;\n    for (int x = -1; x <= 1; x += 1) {\n        for (int y = -1; y <= 1; y += 1) {\n            for (int i = 0; i < maxP; i += 1) {\n                ivec2 z = (cell-ivec2(x, y))*grid+ivec2(i%grid, (i/grid));\n                    vec2 p = texelFetch(iChannel0, z, 0).xy;\n                    if (p != vec2(-10) && d >= 0.0) d = min(d, length(vec2(g)+vec2((ivec2(x, y))*grid)-p)-float(grid)*0.25);\n                    else break;\n            }\n        }\n    }\n    fragColor = vec4(d, d, d, 1);\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tivec2 fc = ivec2(fragCoord);\n    if (fc.x == 0) fragColor = vec4(0);\n\tivec2 cell = fc/grid;\n\tint id = fc.x%grid+(fc.y%grid)*grid;\n\tvec4 old = texelFetch(iChannel0, fc, 0);\n\tfragColor = old;\n\tif (iFrame < 10 || iMouse.z > 0.0) {\n        vec2 c = vec2(cell*grid-ivec2(iResolution.xy*0.5))/iResolution.y;//ivec2((cell.x-int(iResolution.x*0.5))/grid, (cell.y-int(iResolution.x*0.5))/grid);\n        fragColor = vec4(-10.);\n        int count = (c.x*c.x+c.y*c.y < 0.3*0.3)?1:0;\n        if (id < count) {\n            vec2 p = vec2(0.5);//hash22(uvec2(fc))*float(grid);\n            vec2 v = p+0.4;\n            fragColor = vec4(p, v);\n        }\n\t} else {\n\t\tif (fragColor.w != -10.0) {\n\t\t\tfor (int x = -1; x <= 1; x += 1) {\n\t\t\t\tfor (int y = -1; y <= 1; y += 1) {\n\t\t\t\t\tivec2 lp = (cell+ivec2(x, y))*grid;\n\t\t\t\t\tfor (float i = 0.; i < float(maxP); i += 1.) {\n\t\t\t\t\t\tif (!(x==0 && y == 0 && i == float(id))) {\n\t\t\t\t\t\t\tvec4 t = texelFetch(iChannel0, lp+ivec2(mod(i, float(grid)), i*gridi), 0);\n\t\t\t\t\t\t\tif (t.x != -10.) {\n\t\t\t\t\t\t\t\tvec2 p = t.xy+vec2(x, y)*float(grid);\n\t\t\t\t\t\t\t\tfloat d = distance(p, fragColor.xy);\n\t\t\t\t\t\t\t\tvec2 axis = normalize(fragColor.xy-p);\n\t\t\t\t\t\t\t\tfloat overlap = float(grid)-d;\n\t\t\t\t\t\t\t\tif (d < float(grid))fragColor.zw += 0.5*overlap*axis;\n\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec2 old = fragColor.xy;\n\t\t\tvec2 vel = fragColor.zw-fragColor.xy;\n\t\t\tfragColor.zw = old;\n\t\t\tfragColor.xy += clamp(vel, -float(grid)*0.5, 0.5*float(grid));\n\t\t\tvec2 p = vec2(cell*grid)+fragColor.xy;\n\t\t\tfloat dist = length(p-iResolution.xy*0.5);\n            float size = float(iResolution.y*0.45);\n\t\t\tif (dist > size) {\n\t\t\t\tvec2 normal = 2.0*((p-iResolution.xy*0.5)/dist);\n\t\t\t\tfragColor.xy -= normal*(dist-size);\n\t\t\t}\n\t\t}\n\t}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int grid = 3; //number of pixels per particles\nconst int maxBalls = 4; //maximum balls per grid cell\nconst float gridi = 1./float(grid);\nconst int maxP = min(maxBalls, grid*grid);", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    ivec2 cell = fc/grid;\n    int id = fc.x%grid+(fc.y%grid)*grid;\n    fragColor = vec4(-10);\n    int d = 0;\n    for (int x = -1; x <= 1; x += 1) {\n        for (int y = -1; y <= 1; y += 1) {\n            ivec2 lp = (cell+ivec2(x, y))*grid;\n            for (int i = 0; i < maxP; i += 1) {\n                vec4 t = texelFetch(iChannel0, lp+ivec2(i%grid, i/grid), 0);\n                if (t.x != -10.) {\n                    vec2 p = t.xy+vec2(x, y)*float(grid);\n                    if (p.x > 0.0 && p.x < float(grid) && p.y > 0.0 && p.y < float(grid)) {\n                        if (id == d++) {\n                            vec2 vel = t.xy-t.zw;\n                            fragColor.xy = vec2(mod(t.x+float(grid), float(grid)), mod(t.y+float(grid), float(grid)));\n                            fragColor.zw = fragColor.xy+vel;\n                            break;\n                        }\n                    }\n                } else break;\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 918]], "test": "untested"}
{"id": "mst3z2", "name": "Wobbly rounded polygons", "author": "sig", "description": "Wob wob!", "tags": ["geometric"], "likes": 5, "viewed": 163, "published": 3, "date": "1677576067", "time_retrieved": "2024-07-30T18:07:50.673139", "image_code": "#define PI 3.1415926\n#define TWOPI 6.2831852\n\nvec2 unit(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat poly(vec2 p, float n, float outer_R, float inner_R, float lineWidth, float pixelWidth) {\n    float A = TWOPI / n;\n    float a = floor(atan(p.y, p.x) / A) * A;\n        \n    vec2 q = p - inner_R * unit(a + A * 0.5);\n    float b = atan(q.y, q.x);\n   \n    float r = mod(a - b, TWOPI) < PI ? dot(q, unit(a)) :     // b < a\n              mod(A + a - b, TWOPI) > PI ? dot(q, unit(a + A)) : length(q);   // b > a + A\n    \n    return smoothstep(lineWidth + pixelWidth, lineWidth - pixelWidth, abs(outer_R - r));\n}\n\nmat2 rotate(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(\n    c, -s,\n    s, c\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 10.0 * ((2.0 * fragCoord - iResolution.xy) / iResolution.y);\n    float pixelWidth = 10.0 / iResolution.y;\n    float lineWidth = 0.5;    \n    \n    float S = sin(iTime) + 2.0;\n    \n    float x = poly(0.25 * rotate(iTime) * (p - vec2(-12.5, 4.0)), 7.0, 2.0, 1.5, lineWidth, pixelWidth);\n    float y = poly(0.25 * rotate(iTime) * (p - vec2(-14.0, 4.0)), 9.0, 2.0, 3.0, lineWidth, pixelWidth);\n    float z = poly(0.25 * rotate(iTime) * (p - vec2(-13.0, 4.3)), 5.0, 2.0, 0.5, lineWidth, pixelWidth);\n   \n    // Output to screen\n    fragColor = vec4(x, y, z, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mst3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 70, 70, 113], [115, 115, 209, 209, 625], [627, 627, 653, 653, 743], [745, 745, 802, 802, 1375]], "test": "untested"}
{"id": "DlBGW1", "name": "Hola Shaders con sonido", "author": "degarmel", "description": "un shader simple que reacciona al sonido de los canales", "tags": ["audioreactive", "begginer"], "likes": 3, "viewed": 174, "published": 3, "date": "1677561629", "time_retrieved": "2024-07-30T18:07:51.501923", "image_code": "#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nfloat circulo(vec2 actual, vec2 cen, float r, float al)\n{\n   \n   float dis = length(actual-cen);\n   if(dis<r) return al;\n   return 0.0;\n}\n\nfloat circle(vec2 uv,vec2 cen, float r, float blur){\n    float d = length(uv-cen);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nfloat square(vec2 uv, float size, float blur) {\n    vec2 center = vec2(0.5);\n    vec2 halfSize = vec2(size / 2.0);\n    vec2 dist = abs(uv - center) - halfSize + vec2(blur);\n\n    float squareValue = smoothstep(0.0, blur, max(dist.x, dist.y));\n\n    return squareValue;\n}\n\nfloat drawCircles(vec2 uv,  float radius, float blur, vec2 center, float bigR, int numCircles, float vel) {\n    float circleValue = 0.0;\n    for(int i = 0; i < numCircles; i++) {\n        float angle = TIME * 2.0 * PI * vel + TAU / float(numCircles) * float(i);\n        vec2 circleCenter = center + vec2(bigR * cos(angle), bigR * sin(angle));\n        circleValue += circle(uv, circleCenter, radius, blur);\n    }\n    return circleValue;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   // uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft_x  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    float fft_altos= texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n    \n    float fft_bajos= texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n    \n    float radius = 0.09*fft_altos;\n    float blur = 0.06*fft_bajos;\n    float bigR = 0.05*fft_bajos;\n    vec2 center = vec2(0.5);\n        center.x*=iResolution.x / iResolution.y;\n    \n\n    float circleValue = drawCircles(uv, radius, blur, center, 0.04, 6, 0.4);\n        \n        for(float i = 1. ; i<= 15. ; i++){\n            circleValue += drawCircles(uv, radius-0.001*i, blur, center, bigR+0.05*i, 3*int(i),0.005*i);\n        } \n        \n    fragColor = vec4(circleValue, 0.0, 0.0, 1.0);\n        \n}\n\n\n\n\n", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 177, 177, 257], [259, 259, 311, 311, 397], [399, 399, 446, 446, 667], [669, 669, 776, 776, 1105], [1106, 1106, 1161, 1161, 2249]], "test": "untested"}
{"id": "dsdGRj", "name": "Fork color targ broadgsetu 713", "author": "broadgseture", "description": "forked from https://www.shadertoy.com/view/Xsl3RX by possum\nadded some pumping and rgb-color ringing", "tags": ["2d", "color", "hypnotic", "smoothstep"], "likes": 2, "viewed": 155, "published": 3, "date": "1677558237", "time_retrieved": "2024-07-30T18:07:52.495268", "image_code": "// forked from https://www.shadertoy.com/view/Xsl3RX by possum\nconst float rings      = 20.0;\nconst float velocity   = 14.5;\nconst vec3  pumpv      = vec3( 0.5 );\nconst vec3  pumpoffset = vec3( 0.05, 0.0, 0.0);\nconst vec3  pumpamp    = vec3( 1.90, 2.1, 1.7);\nconst float p          = 0.6;\nconst float b          = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2  R      = iResolution.xy,\n        pos    = ( fragCoord - 0.5 * R ) / R.y;\n    \n  float dist   = pow( length ( pos ), p );\n  float offset = abs(iTime * velocity);\n  vec3  conv   = ( cos( iTime * pumpv ) + pumpoffset ) * pumpamp + rings;\n  vec3  v      = dist * conv + offset;\n  vec3  ringr  = tan( v );\n  vec3  color  = smoothstep(\n                   -b, b,\n                   abs( dist - (\n                     ringr.x + float( fract( v.x ) > 0.5 ) + offset\n                   ) / conv ));\n  fragColor    = vec4( mix( color, 1.0 - color, mod( ringr, 2.0 )), 12.0 );      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 378, 378, 959]], "test": "untested"}
{"id": "msd3Rj", "name": "What it feels like to trip", "author": "Mik0", "description": "Look at the center until you develop tunnel vision, then look at your surroundings. That's what it feels like. It will wear off after 10 seconds.", "tags": ["trippy"], "likes": 4, "viewed": 175, "published": 3, "date": "1677557365", "time_retrieved": "2024-07-30T18:07:53.421791", "image_code": "vec3 lerp(vec3 a, vec3 b, float t)\n{\n    return (a*(1.0-t)) +(b*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=iTime/25.0;\n    uv = vec2(atan(uv.x, uv.y)/acos(0.0), length(uv));\n    \n    uv+=vec2(fract(iTime*0.25), fract(iTime*0.27));\n    \n    float c;\n    if(fract(uv.x*20.0)>0.5)\n    {\n        c = 0.0;\n        if(fract(uv.y*20.0)>0.5)\n        {\n            c = 1.0;\n        }\n    }\n    else\n    {\n        c = 1.0;\n        if(fract(uv.y*20.0)>0.5)\n        {\n            c = 0.0;\n        }\n    }\n\n    // Time varying pixel color\n    vec3 col = lerp(vec3(1,1,0), vec3(0,0,1), c);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msd3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 69], [71, 71, 128, 178, 777]], "test": "untested"}
{"id": "ddd3Rj", "name": "LookingGlass DangerNoodle intere", "author": "Cieric", "description": "Original shader form BigWings\nThis is an interlaced version of the quilt using the calibration of the device passed in by u_lenticularCalibration and\nu_lenticularRB\n\nBased on https://www.shadertoy.com/view/ttXSDN and https://www.shadertoy.com/view/flB3zK ", "tags": ["raymarching", "tutorial", "glass", "snake", "animal", "looking", "jungle", "bigwings", "lookingglass", "viper"], "likes": 1, "viewed": 224, "published": 3, "date": "1677555588", "time_retrieved": "2024-07-30T18:07:54.450041", "image_code": "// \"Danger Noodle\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Ever since I did a snake scale effect as one of my first ShaderToys\n// I have been wanting to do a snake, so here it is.\n//\n// Watch full screen with sound!\n\n#define MAX_STEPS 400\n#define MAX_DIST 2000.\n#define SURF_DIST .04\n\n#define CAM_MOVE 0.\n\n#define S smoothstep\n\n#define MAT_TONGUE 1.\n#define MAT_HEAD 2.\n#define MAT_BODY 3.\n#define MAT_EYE 4.\n\n// From Dave Hoskins\nvec2 Hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.1031, 324.1030));\n    p += dot(p, p+33.33);\n    return fract(p.x*p.y);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec4 s) {\n\tfloat t = dot(s.xyz-ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float y = length(s.xyz-p);\n    \n    vec2 o = vec2(MAX_DIST,MAX_DIST);\n    \n    if(y<s.w) {\n    \tfloat x = sqrt(s.w*s.w-y*y);\n        o.x = t-x;\n        o.y = t+x;\n    }\n    \n    return o;\n}\n\n// From IQ\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n\treturn smin(a, b, -k);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSph(vec3 p, vec3 pos, vec3 squash, float r) {\n    squash = 1./squash;\n\tp = (p-pos)*squash;\n    return (length(p)-r)/max(squash.x, max(squash.y, squash.z));\n}\n\n\nvec4 Scales(vec2 uv, float overlap, float skew, float point, float blur) {\n    \n    vec2 gv = fract(uv*5.)-.5;\n    vec2 id = floor(uv*5.);\n    \n    float m = 0.;\n    \n    gv.y = sabs(gv.y,point);\n    \n    float w = .5+overlap;\n    vec2 p1 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a1 = atan(p1.x-w, p1.y);\n    \n    float waveAmp = .02;\n    float waves = 10.;\n    float w1 = sin(a1*waves);\n    float s1 = S(w, w*blur, length(p1)+w1*waveAmp);\n    s1 +=  w1*.1*s1;\n    s1 *= mix(1., .5-gv.x, overlap*2.);\n    \n    gv.x -= 1.;\n    vec2 p2 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a2 = atan(p2.x-w, p2.y);\n    float w2 = sin(a2*waves);\n    float s2 = S(w, w*blur, length(p2)+w2*waveAmp);\n    s2 += w2*.1*s2;\n    \n    s2 *= mix(1., .5-gv.x, overlap*2.);\n    \n    if(s1>s2) {\n    \tm += s1;\n        m -= dot(p1,p1);\n    } else {\n        m += s2;\n        m -= dot(p2,p2);\n        id.x += 1.;\n    }\n\n    return vec4(1.-m, 0., id);\n}\n\nvec4 ScaleTex(vec2 uv, float overlap, float skew, float point, float blur) {\n\n    uv *= 2.;\n    vec4 s1 = Scales(uv, overlap, skew, point, blur);\n    vec4 s2 = Scales(uv+.1, overlap, skew, point, blur);\n    s2.zw -= .5;\n    \n    return s1.x<s2.x ? s1 : s2;\n}\n\n\nvec3 sdBody(vec3 p) {\n    float t = iTime*.3;\n    float neckFade = S(3., 10., p.z);\n   \n    p.x += sin(p.z*.15-t)*neckFade*4.;\n    p.y += sin(p.z*.1-t)*neckFade;\n    \n    vec2 st = vec2(atan(p.x, p.y), p.z);\n    \n    float body = length(p.xy)-(.86+S(2., 15., p.z)*.6-p.z*.01);\n    body = max(.8-p.z, body);   \n    \n    vec4 scales = vec4(0);\n    if(body<.1) {\n        vec2 uv = vec2(-st.y*.25, st.x/6.2832+.5);\n        float a = sin(st.x+1.57)*.5+.5;\n        float fade = a;\n        a = S(.1, .4, a);\n\n        uv.y = 1.-abs(uv.y*2.-1.);\n        uv.y *= (uv.y-.2)*.4;\n        scales = ScaleTex(uv*1.3, .3*a, .3*a, .01, .8);\n        body += scales.x*.02*(fade+.2);\n    }\n    \n    body += S(-.4, -.9, p.y)*.2;\t// flatten bottom\n    return vec3(body, scales.zw);\n}\n\nfloat GetHeadScales(vec3 p, vec3 eye, vec3 mouth, float md) {    \n    float t = iTime;\n  \n    float jitter = .5;\n    jitter *= S(.1, .3, abs(md));\n    jitter *= S(1.2, .5, p.z);\n    \n    p.z += .5;\n    p.z *= .5;\n    \n    p.yz *= Rot(.6);\n    float y = atan(p.y, p.x);\n    vec2 gv = vec2(p.z*5., y*3.);\n\n    vec2 id = floor(gv);\n    \n    gv = fract(gv)-.5;\n    \n    float d=MAX_DIST;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = Hash22(id+offs);\n            vec2 p = offs+sin(n*6.2831)*jitter;\n            p -= gv;\n            \n            float cd = dot(p,p);\n            if(cd<d) d = cd;\n        }\n    }\n    \n    d += sin(d*20.)*.02;    \n    d *= S(.0, .5, length(p.xy)-.1);\n    return d*.06;\n}\n\nfloat sdHead(vec3 p) {    \n    p.x = abs(p.x*.9);\n    float d = sdSph(p, vec3(0,-.05,.154), vec3(1,1,1.986),1.14); \n    d = smax(d, length(p-vec3(0,7.89,.38))-8.7, .2);\n    d = smax(d, length(p-vec3(0,-7.71,1.37))-8.7, .15); // top\n    \n    d = smax(d, 8.85-length(p-vec3(9.16,-1.0,-3.51)), .2);\t// cheeks\n    \n    vec3 ep = p-vec3(.54,.265,-.82);\n    float eye = length(ep)-.35;\n    float brows = S(.1, .8, p.y-(p.z+.9)*.5);\n    brows *= brows*brows;\n    brows *= S(.3, -.2, eye);\n   \td -= brows*.5;\n    d += S(.1, -.2, eye)*.1;\n    \n    vec2 mp = p.yz-vec2(3.76+S(-.71, -.14, p.z)*(p.z+.5)*.2, -.71); \n    float mouth = length(mp)-4.24;\n    d += S(.03,.0,abs(mouth))*S(.59,.0, p.z)*.03;\n    \n   \td += GetHeadScales(p, ep, mp.xyy, mouth);\n    \n    d = min(d, eye);\n    \n    float nostril = length(p.zy-vec2(-1.9-p.x*p.x, .15))-.05;\n    d = smax(d, -nostril,.05);\n    return d;\n}\n\nfloat sdTongue(vec3 p) {\n\tfloat t = iTime*3.;\n   \n    float inOut = S(.7, .8, sin(t*.5));\n    \n    if(p.z>-2.||inOut==0.) return MAX_DIST;\t\t// early out\n    \n    float zigzag = (abs(fract(t*2.)-.5)-.25)*4.; // flicker\n    float tl = 2.5;\t// length\n    \n    p+=vec3(0,0.27,2);\n    p.z *= -1.;\n    float z = p.z;\n    p.yz *= Rot(z*.4*zigzag);\n    p.z -= inOut*tl;\n    \n    float width = S(0., -1., p.z);\n    float fork = 1.-width;\n    \n    float r = mix(.05, .02, fork);\n\t\n    p.x = sabs(p.x, .05*width*width);\n    p.x -= r+.01;\n    p.x -= fork*.2*inOut;\n\n    return length(p-vec3(0,0,clamp(p.z, -tl, 0.)))-r;\n}\n\nfloat GetDist(vec3 P) {\n    \n    vec3 p = P;\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    float d = sdTongue(p)*.7;\n    d = min(d, sdHead(p));\n    d = smin(d, sdBody(P).x, .13);\n    \n    return d;\n}\n\nvec3 GetMat(vec3 p) {    \n    float d = MAX_DIST;\n    \n    float tongue = sdTongue(p)*.7;\n    float head = sdHead(p);\n    vec3 body = sdBody(p);\n    \n    float closest = min(tongue, min(head, body.x));\n    if(closest == tongue) {\n        return vec3(MAT_TONGUE, 0, 0);\n    } else if(closest==head) {\n        p.x = abs(p.x*.9);\n        vec3 ep = p-vec3(.54,.265,-.82);\n        float eye = length(ep)-.35;\n        if(eye<SURF_DIST)\n        \treturn vec3(MAT_EYE, ep.yz);\n        else\n            return vec3(MAT_BODY, 0, 0);\n            \n    }else if(closest==body.x) {\n        return vec3(MAT_BODY, body.yz);\n    }\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// From Nimitz\nvec4 GetNormalAndCurvature(in vec3 p, float eps) {\n    vec2 e = vec2(-1., 1.)*eps;   \n    float t1 = GetDist(p + e.yxx), t2 = GetDist(p + e.xxy);\n    float t3 = GetDist(p + e.xyx), t4 = GetDist(p + e.yyy);\n\n    float c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec4 Material(vec3 ro, vec3 rd, float d) {\n    vec3 p = ro + rd * d;\n    vec4 n = GetNormalAndCurvature(p, mix(.01, .03, S(8., 20., d)));\n\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    vec3 mat = GetMat(p);\n    \n    vec3 col = vec3(n.y*.5+.5);  \t// diffuse\n\tcol *= 1.-max(0., .3-n.w);\t\t// curvature shadow\n    \n    vec3 h = normalize(-rd + vec3(1,1,1));\n    float spe = pow(clamp(dot(h, n.xyz), 0.0, 1.0), 32.0);\n\t\n    vec3 ref = reflect(rd, n.xyz);\n    vec3 r = texture(iChannel0, ref).rgb;\n    \n    if(mat.x==MAT_EYE) {\n        vec2 sph = RaySphere(\n            vec3(abs(p.x*.9),p.yz), \n            vec3(-abs(rd.x), rd.yz), \n            vec4(.3,.265,-.82, .52)\n        );\n\n        vec3 sp = p+rd*sph.x;\n        mat.yz = sp.yz-vec2(.265,-.82)+.05;\n\n        float t = iTime*.2;\n        vec2 p1 = sin(floor(t)*vec2(20., 31.));\n        vec2 p2 = sin(floor(t+1.)*vec2(20., 31.));\n        p1 = mix(p1, p2, S(.45, .5, fract(t)));\n        mat.yz += p1*vec2(.01, .03)*1.;\n        float a = atan(mat.y, mat.z);\n\n        float d = abs(mat.z)+mat.y*mat.y;\n        col *= vec3(1,1,.1);\n        col += S(.1, .0, length(mat.yz*vec2(1,2))-.1)*.1;\n        \n        float z = S(.7, 1., rd.z*rd.z)*.05;\n        col *= S(.02-z, .03+z, d);\n        \n        vec3 gp = vec3(a, mat.yz)*20.;\n        float gyroid = (abs(dot(sin(gp), cos(gp.zxy))));\n        col *= 1.+gyroid*.1;\n        \n        col += r*r*r*.3;\n        col += pow(spe, 6.);\n    } else if(mat.x==MAT_BODY) {\n        float x = mat.y;\n        float y = mat.z;\n        float wave = S(2., 0., abs(y-2.+sin(x*.5)*1.));\n        wave *= S(2., 3., p.z);\n        \n        float t = iTime*.3;\n        float neckFade = S(3., 10., p.z);\n        p.y += sin(p.z*.1-t)*neckFade;\n        \n        vec3 baseCol = mix(vec3(1., 1., .2), vec3(.3, .8, .1), S(-.55, -.1, p.y));\n        col *= mix(baseCol, vec3(.2,.4,.2)*.5, wave);\n        col += spe*pow(1.-abs(n.w), 5.)*.3;\n        \n        r = texture(iChannel1, ref).rgb;\n        col += r*r*.05;\n    } else if(mat.x==MAT_TONGUE) {\n    \tcol *= vec3(.4, .1, .2);\n        col += pow(min(1., spe*5.), 5.);\n    }\n    \n    return vec4(col, 1);\n}\n\nvec3 Render(vec2 uv, vec2 m, float t, vec3 _ro, vec3 _rd)\n{\n    vec3 ro = vec3(0, 0, -3)*(8.+sin(t*.2)*2.*CAM_MOVE);\n    ro.yz *= Rot(-m.y*3.14+sin(t*.03)*CAM_MOVE*.2);\n    ro.xz *= Rot(-m.x*6.2831*2.+sin(t*.05)*CAM_MOVE);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,sin(t*.11)), 6.);\n    \n    ro = _ro;\n    rd = _rd;\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 col = vec3(0);\n    \n    vec2 env = RaySphere(ro, rd, vec4(0,0,0,20));\n    \n    if(d<MAX_DIST) {\n        vec4 snake = Material(ro, rd, d);\n    \tsnake.rgb *= S(14., 8., d);\n        col = mix(col, snake.rgb, snake.a);\n    } else {\n    \tcol = (rd.y*.5+.5)*vec3(.4, 1.,.2);\n        col *= texture(iChannel0, rd).rgb;\n        col *= 1.-S(.8, 1., rd.z);\n        \n        if(env.y>0.)\t// vines behind\n            col *= S(0., 1.1, sdGyroid(ro + env.y*rd, .4, .1, .0))*.5+.5;\n    }\n    \n    if(env.x>0.)\t// vines in front\n        col *= S(0., .25, sdGyroid(ro + env.x*rd, .25, .1, .0));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;    \n    if(m.x<-.49 && m.y<-.49) m*=0.;\n    \n    vec3 col = Render(uv, m, iTime, _ro, _rd);\n    \n    col *= 1.5;\t\t\t\t\t\t// exposure adjustment\n    col = pow(col, vec3(.4545));\t// gamma correction\n    col *= 1.-dot(uv,uv)*.3;\t\t// vignette\n\n    fragColor = vec4(col,1.0);\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(20.0);\nconst float\thorizontalAngle = radians(10.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvec4 mainImageQuilt( in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    return color;\n}\n\nvec2 quilt_map(vec3 tile, vec2 pos, float a) {\n    vec2 tile2 = vec2(tile.x - 1.0, tile.y - 1.0);\n    \n    a = fract(a) * tile.y;\n    tile2.y += -1.0 * floor(a);\n    \n    a = fract(a) * tile.x;\n    tile2.x += -1.0 * floor(a);\n    \n    return (tile2 + pos) / tile.xy;\n}\n\n\n//const float width = 1536.0f;\n//const float height = 2048.0f;\nconst float dpi = 324.0f;\nconst float pitch = 52.58423102066764;\nconst float slope = -7.188933233299512;\nconst float center = 0.11631189368699624;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 texCoords = fragCoord.xy / iResolution.xy;\n    float width = iResolution.x;\n    float height = iResolution.y;\n\n\n    float subp = 1.0f / (3.0f * width);\n    float tilt = height / (width * slope);\n    float adjusted_pitch = pitch * (width / dpi) * sin(atan(abs(slope)));\n\n    vec3 nuv = vec3(texCoords.xy, 0.0);\n    \n\tfragColor = vec4(1);\n    for (int i = 0; i < 3; i++) {\n        nuv.z = (texCoords.x + float(i) * subp + texCoords.y * tilt) * adjusted_pitch - center;\n        nuv.z = fract(nuv.z + ceil(abs(nuv.z)));\n\n        float dist = 1.0 / tan(horizontalAngle / 2.);\n        float minCam = -1.0 - tan(sideAngle / 2.) * dist;\n\n\t\tvec3 camPos = vec3((fract(nuv.z) * 2.0 - 1.0) * minCam, 0, dist) + vec3(0, 0, -20);\n\t\tvec3 screenPos = vec3(fract(nuv.xy) - 0.5, 0) * cameraSize;\n\t\tscreenPos.y /= aspectRatio;\n\n\t\tvec3 dir = normalize(screenPos - camPos);\n\t\tvec4 color;\n        mainImage(color, fragCoord, camPos, dir);\n\t\tfragColor[i] = clamp(color[i], 0.0, 1.0);\n    }\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21528, "src": "https://soundcloud.com/extasis_demencial/jungle-sounds", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 21529, "src": "https://soundcloud.com/liam-seagrave/pandemic-prologue-slow-strings-suspense-music-original-horror-piano-composition", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddd3Rj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[624, 645, 666, 666, 799], [801, 801, 823, 823, 918], [920, 920, 949, 949, 1028], [1030, 1030, 1072, 1072, 1327], [1329, 1340, 1381, 1381, 1472], [1474, 1474, 1513, 1513, 1539], [1541, 1541, 1560, 1560, 1636], [1638, 1638, 1704, 1704, 1783], [1785, 1785, 1838, 1838, 1950], [1953, 1953, 2027, 2027, 2902], [2904, 2904, 2980, 2980, 3162], [3165, 3165, 3186, 3186, 3925], [3927, 3927, 3988, 3988, 4710], [4712, 4712, 4734, 4734, 5591], [5593, 5593, 5617, 5617, 6202], [6204, 6204, 6227, 6227, 6411], [6413, 6413, 6434, 6434, 7027], [7030, 7030, 7064, 7064, 7275], [7277, 7292, 7342, 7342, 7655], [7657, 7657, 7707, 7707, 7898], [7901, 7901, 7943, 7943, 10023], [10025, 10025, 10084, 10084, 10996], [10999, 10999, 11082, 11082, 11467], [11780, 11780, 11821, 11821, 12585], [12587, 12587, 12633, 12633, 12855], [13069, 13069, 13124, 13124, 14102]], "test": "untested"}
{"id": "mddGRj", "name": "gradient color horizontal 4()", "author": "tianluo97", "description": "gradient color horizontal 4", "tags": ["gradientcolorhorizontal4"], "likes": 0, "viewed": 119, "published": 3, "date": "1677552423", "time_retrieved": "2024-07-30T18:07:55.308745", "image_code": "//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float PI = 3.1415926;\n    float time = iTime * 0.01; \n    float timeLeft = time * 0.03; \n    float scale = 1.2;\n    float scaleLeft = 3.6;\n    vec3 morningScatter = vec3(1.000,0.647,0.322);;\n    \n    vec4 color0 = vec4(1.000,0.576,0.502,1.0);\n    vec4 color1 = vec4(1.000,0.616,0.361,1.0); \n    vec4 color2 = vec4(1.000,0.710,0.502,1.0);\n    vec4 color3 = vec4(0.376,0.443,0.824,1.0);\n    vec4 color4 = vec4(0.141,0.369,1.000,1.0);\n    \n    if(uv.x >= 0.2){\n    \n    //uv.x\n    uv.x = smoothstep(0.2,1.0,uv.x);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.3 * scale;\n    float step2 = 0.5 * scale;\n    float step3 = 0.8 * scale;\n\n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    //morning Color\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    fragColor = mix(color0, color1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    // step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    fragColor = vec4(dist02,dist02,dist02,1.0);\n    fragColor = mix(color3, color4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    fragColor = mix(color4, color0, dist3);\n    }\n    \n    fragColor = mix(vec4(morningScatter,1.0),fragColor,pow(uv.x/1.3,0.3));\n    fragColor = mix(fragColor,vec4(morningScatter,1.0),pow(uv.x/1.3,20.0));\n    //color\n    fragColor = sqrt(fragColor);\n    //fragColor = vec4(0.);\n    }\n    \n    else{\n    \n    //uv\n    uv.x = uv.x * 5.0;\n    uv.x = 1.0 - uv.x;\n    \n    vec3 startColor = vec3(0.341,0.482,0.886);\n    \n    float step0 = 0.2 * scaleLeft;\n    float step1 = 0.3 * scaleLeft;\n    float step2 = 0.5 * scaleLeft;\n    float step3 = 0.8 * scaleLeft;\n    \n    float offset = uv.x - timeLeft;\n    float y = mod(offset,scaleLeft);\n    \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    \n    fragColor = mix(color0, color1, dist0);\n    }\n    \n    else  if (y > step0 && y < step1){\n    float dist1 = smoothstep(step0, step1, y);\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    else if (y > step1 && y < step2){\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = mix(color2, color3, dist2);\n    }\n    \n    else if (y > step2 && y < step3){\n    float dist02 = smoothstep(step2, step3, y);\n    fragColor = mix(color3, color4, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scaleLeft, y);\n    fragColor = mix(color4, color0, dist3);\n    }\n    \n    vec3 color = mix(startColor,fragColor.rgb,1.0-uv.x);\n    \n    fragColor = vec4(color,1.0);\n    \n    fragColor = mix(vec4(morningScatter,1.0),fragColor,pow(uv.x/1.3,0.7));\n    \n    fragColor = sqrt(fragColor);\n    //fragColor = vec4(1.0);\n    }\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 206, 243, 3903]], "test": "untested"}
{"id": "cst3R2", "name": "fractal GPT", "author": "mpusch88", "description": "fractal shader made with chatGPT", "tags": ["fractalgpt"], "likes": 1, "viewed": 391, "published": 3, "date": "1677543542", "time_retrieved": "2024-07-30T18:07:56.153487", "image_code": "float fractal(vec2 p, float time, float zoom) {\n    float zr = p.x * zoom;\n    float zi = p.y * zoom;\n    float cr = .5 + sin(time);\n    float ci = 0.1;\n    float n = .4;\n    float limit = 5.0;\n    float dzr = 4.0;\n    float dzi = 2.0;\n    for (int i = 0; i < 50; i++) {\n        float zr1 = zr * zr - zi * zi + cr;\n        float zi1 = 2.0 * zr * zi + ci;\n        dzr = 2.0 * zr * dzr - 2.0 * zi * dzi + 1.0;\n        dzi = 2.0 * zr * dzi + 2.0 * zi * dzr;\n        zr = zr1;\n        zi = zi1;\n        if (length(vec2(zr, zi)) > limit) {\n            float logz = log(length(vec2(zr, zi)));\n            float nu = log(logz / log(limit)) / log(3.0);\n            n = float(i) + 1.0 - nu;\n            break;\n        }\n    }\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 0.3;\n    \n    float wave = sin(uv.y * 10.0 + time * 3.0) * 0.2;\n    vec3 color1 = vec3(wave + 0.5, abs(wave), abs(wave - 0.5));\n    \n    float f = fractal(vec2(uv.x * 6.0, uv.y * 6.0), time, .44);\n    vec3 color2 = vec3(1.0 - f / 50.0);\n    \n    vec3 color = color1 * color2;\n    \n    vec3 bg_color1 = vec3(1.0, 0.5, 0.0); // Orange\n    vec3 bg_color2 = vec3(0.0, 0.0, 1.0); // Blue\n    vec3 bg_color = mix(bg_color1, bg_color2, abs(sin(time)));\n    \n    color = mix(color, bg_color, 0.44);\n    \n    fragColor = vec4(color, 0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cst3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 732], [734, 734, 789, 789, 1447]], "test": "untested"}
{"id": "cstGR2", "name": "Modulating Saw Waves - Sound", "author": "gfy_9001", "description": "modulating saw waves", "tags": ["sawwave"], "likes": 1, "viewed": 143, "published": 3, "date": "1677541689", "time_retrieved": "2024-07-30T18:07:57.049092", "image_code": "// Check these variables in Common to play around with how slow/fast it modulates\n// modulation_mod_hz_max\n// modulation_mod_hz_min\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float mod_hz = GetModulation(iTime);\n    float modulation = SawMod(1./mod_hz, 1., iTime);\n    float peak = tone(FREQUENCY, 0.5, iTime, modulation);\n     \n    vec3 modCol = (modulation * sin(modulation)) * vec3(0,2,4); \n    vec2 uv     = fragCoord / (iResolution.xy * 0.1);\n    vec3 col    = cos(modulation + peak + uv.xyx + modCol) * (iTime * modulation);\n    \n    fragColor = vec4(col * 0.1,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound(in int samp, float time)\n{\n    float mod_hz = GetModulation(time);\n    float modulation = SawMod(1./mod_hz, 1., time);\n\n    // amplitude envelope\n    float m = 1.;                      // higher, the longer it takes to reach peak\n    float b = -4.;                     // how quiet we start, lower is quieter\n    float a = AmpEnvelope(m, time, b); // linear rise\n    return vec2(tone(FREQUENCY, 0.5 * a, time, modulation));\n}", "sound_inputs": [], "common_code": "float modulation_hz = 3.;\nfloat modulation_mod_hz_max = 3.;\nfloat modulation_mod_hz_min = 0.1;\n\nfloat seconds_half_of_soundplayback = 90.;\n\n//#define PI 3.1415926536\n#define T_PI 6.28318530718\n\n// note and octave = hz\n#define C2 65.406\n#define C3 130.812\n#define C4 261.625\n#define G4 391.995\n#define F4 349.2282\t\n\nfloat FREQUENCY = C4;\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = T_PI / b;\n    return sin(p * (x + c)) + d;\n}\n\nfloat SawMod(float p, float a, float t)\n{\n    float period_t = t/p;\n    return 2.0 * (period_t - floor(0.5 + period_t));\n}\n\n// line, e.g. linear ramp\nfloat AmpEnvelope(float m, float t, float b)\n{\n    float v =  m * t + b;\n    return min(1. + (v / -b), 1.0); // convert into 0 -> 1 (nothing to full volume)\n                                    // and keep clamped at 1 (make sure we don't go super loud)\n}\n\nfloat Amp(float a)\n{\n    return a * 0.1;\n}\n\n// hz - frequency in hertz (1/period)\n// a  - amplitude e.g volume\n// t  - time\nfloat SinWave(float hz, float a, float t)\n{\n    return Amp(a) * sin(T_PI * hz * t);\n}\n\n// p - period/cycle (1/hz)\n// a - amplitude e.g volume\n// t - time\nfloat SawWave(float p, float a, float t)\n{\n    float period_t = t/p;\n    return Amp(a) * (2.0 * (period_t - floor(0.5 + period_t)));\n}\n\nfloat sum_of_sines(float f, float a, float t, float m)\n{\n    float sum = 0.;\n    for (int s = 0; s < 8; ++s)\n    {\n        float freq = f + float(s);\n        sum += SinWave(freq + float(s), a, t);\n    }\n    return sum;\n}\n\nfloat GetModulation(float t)\n{\n    float stepTime = mod(t, 15.);                                   // in seconds\n    float mixTime  = mod(t, 30.) / 30.;                             // in normalised range\n    float mod_t = mix(1. / stepTime, stepTime, step(mixTime, 0.5)); // flip modulation every 15 seconds (0.5 of x)\n    return mix(modulation_mod_hz_min, modulation_mod_hz_max, mod_t);\n}\n\nfloat tone(float f, float a, float t, float m)\n{\n    float sine          = SinWave(f,              a* .7,  t);\n    float saw           = SawWave(1./f,           a* 1.,  t);\n    float saw0          = SawWave(1./(f * 1.8),   a* .8,  t);\n    float interval_saw0 = SawWave(1./(f * 1.498), a* .56, t);\n    float interval_saw1 = SawWave(1./(f * 0.25),  a* .56, t);\n    \n    float interval      = interval_saw0 + interval_saw1;    \n    float saw_mix       = saw;\n    \n    return interval + mix(saw0, saw_mix, m);\n    //return sum_of_sines(f, a, t, m); // spooky\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cstGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 190, 190, 595]], "test": "untested"}
{"id": "md3GR2", "name": "Particle Terrain Gen", "author": "SnoopethDuckDuck", "description": "R to reset, click to see 2D\n\nBuffer A draws a distance field, particles traverse that field and change it every frame.\nThe field is used as a height map to extrude from a plane.\n\nRough 2D visual using different rule:\nhttps://www.shadertoy.com/view/ds33Rj", "tags": ["terrain", "particles", "mountain"], "likes": 17, "viewed": 301, "published": 3, "date": "1677520804", "time_retrieved": "2024-07-30T18:07:57.904804", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 20.;\n    float a = 0.2 * iTime;\n    float y = mix(3.5,14.,.5+.5*thc(4., 0.65 * iTime));\n    vec3 ro = vec3(r*sin(a), y, r*cos(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 map(vec3 p) {  \n    float sd = p.y;\n    \n    // Distance field scaled to (0,1)\n    vec4 txB = texture(ch2, 0.05 * p.xz*res.y/res+0.5) / res.x;\n    sd += -4. + 30. * txB.x;\n    \n    // Sharper peaks\n    // sd += 1. - 7. *exp(-0.015*txB.x); \n    \n    // Restrict to box (bad)\n    // sd = max(sd, mlength(p.xz) - 10.);\n    \n    return vec3(0.4 * sd, txB.bg); \n}\n\nvec4 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    vec2 mat = vec2(0);\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec3 m = map(p);\n        //m.x *= 0.8 + 0.2 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.yz;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec4(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0,0.5,0), 1.4);\n    vec3 col = vec3(0);\n   \n    vec4 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    \n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = normalize(vec3(1,2,3));\n        float dif  = dot(abs(n),  ld)*.5+.5;\n        float spec = pow(dif, 16.);\n        float fres = pow(1. + dot(rd, n),  1.);\n     \n        col = vec3(1.-dif);  \n        col = max(col, floor(4.*abs(n))/4.);\n        col *= vec3(length(col) * fres);\n    } else\n        col = vec3(0.15) * (1.-exp(-0.015 * m.y));\n   \n    col = tanh(vec3(2.2,1.2, 0.1*length(p.xz)) * col);\n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    if (iMouse.z > 0.) {\n        col = cell(ch2, ivec2(fragCoord)).rgb;\n        col.r = 1. - 16.*pow(col.r/res.y, 2.); //exp(-6.*col.r/res.y);\n        if (iMouse.x > 0.75 * res.x)\n            col = vec3(0, .5+.5*col.gb);\n        else\n            col.gb *= 0.;\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txA = cell(ch0, ipx);         \n    \n    for (int i = 0; i < numPoints; i++) {  \n        // Initialize point on reset\n        if (iFrame < 1 || key_down(KEY_RESET)) \n        if (ipx == ivec2(i,0) || ipx == ivec2(i,1))        \n            txA = vec4(floor(0.5 * res), 0, 0);             \n\n        float spd = 0.5;\n        if (ipx == ivec2(i, 0)) {\n            // Distance value\n            float d = cell(ch2, ivec2(txA.xy)).r;          \n            \n            // Normal\n            vec2 n = norm(ch2, ivec2(txA.xy));\n\n            // Update position\n            float io = float(i) / float(numPoints);\n            txA.xy += 0.25 * d * n;\n            txA.xy -= 0.2 * (io - 0.25) * d * vec2(-n.y, n.x);\n            \n            //txA.xy += 0.15 * d * n;\n            //txA.xy -= 0.25 * d * vec2(-n.y, n.x);\n            \n            //txA.xy += (io-0.5) * d * n;\n    \n            //txA.xy += 20.;\n            \n            // Reset to a random position every few frames\n            if ((iFrame+i) % 20 == 0) {\n                vec2 h = vec2(hash(txA.x + iTime, float(i) + txA.y), \n                              hash(float(i) + txA.x, txA.y + iTime));\n                txA.xy = .5*res + .4 * res * h;\n                \n                // Symmetric version\n                // txA.xy = .5*res + .4 * res.y * h;\n            }\n        }         \n        else if (ipx == ivec2(i, 1)) // Save old position\n            txA = cell(ch0, ivec2(i, 0));\n   }\n   fragColor = txA;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define KEYBOARD iChannel1\n\n// This buffer stores distances\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    vec4 txB  = cell(ch2, ipx);\n    \n    for (int i = 0; i < numPoints; i++) {\n        vec4 txP  = cell(ch0, ivec2(i, 0)); // Point\n        vec4 txP0 = cell(ch0, ivec2(i, 1)); // Previous point\n\n        // Initialize distances on reset\n        if (iFrame < 1 || key_down(KEY_RESET)) { \n            float d = res.x;//length(px - .5 * res);\n            //d = res.x;\n            //d = res.x + 0.2 * hash(px.x,px.y) * res.x;\n            txB = vec4(d,0,0,0);  \n        }\n        else {\n            float io = float(i) / float(numPoints);\n        \n            float d0 = cell(ch2, ivec2(txP.xy)).r;          \n            float d = length(px - txP.xy) - 0.;\n            //float d = seg(px, txP.xy, txP0.xy);\n        \n            // idk what this does exactly, I wanted the new\n            // distance to vary depending on the point's position\n            // in the distance field\n            d *= 0.5 * res.x / d0;\n            \n            // Soften new distance\n            d = mix(txB.r, d, 0.015);\n            \n            // Include new distance\n            txB.r = min(txB.r, d);\n           \n            // Terrain shrinking ideas,\n            // mostly leads to lots of isolated peaks\n            // txB.r += 0.002; \n            // txB.r = mix(txB.r, res.y, 0.00001);\n               \n            txB.r = clamp(txB.r, 0., res.x);\n            \n            vec2 n = norm(ch2, ivec2(px));\n            txB.gb = n;\n        }\n    }\n    \n    fragColor = txB;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define numPoints 40\n\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) int(key_val(key)) == 1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// Taken from stb's shader:\n// https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// From blacklemori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3GR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 80, 80, 348], [350, 350, 368, 368, 713], [715, 715, 754, 754, 1269], [1271, 1271, 1290, 1290, 1472], [1474, 1474, 1518, 1518, 1709], [1711, 1711, 1768, 1768, 2898]], "test": "untested"}
{"id": "ms3GRj", "name": "Github senior stuff", "author": "z0rg", "description": "bla", "tags": ["github"], "likes": 14, "viewed": 398, "published": 3, "date": "1677514270", "time_retrieved": "2024-07-30T18:07:58.666767", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\n// Thanks IQ :)\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// Thanks IQ :)\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s,c);}\nfloat map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.yz *= r2d(p.x+iTime);\n    float bend = sdBox(p2.yz, vec2(.5));\n    p.xy *= r2d(iTime);\n    p.xz *= r2d(iTime);\n    float wire = sdBoxFrame(p, vec3(1.), .05);\n    return min(wire, bend);\n}\nfloat rdr(vec2 uv)\n{\n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float col = 0.;\n    vec3 p = ro;\n    for (float i = 0.; i < 128.; ++i)\n    {\n        float d = map(p);\n        if (d < 0.01)\n        {\n            col = pow(1.-sat(distance(p, ro)/15.),.8);\n            break;\n        }\n        p+=rd*d;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col = vec3(1.);\n    vec2 rep = vec2(.015);\n    vec2 id = floor((uv+rep*.5)/rep);\n    uv = mod(uv+rep*.5,rep)-rep*.5;\n    vec3[5] cols = vec3[5](\n        vec3(0.93f, 0.93f, 0.93f),\n        vec3(0.84f, 0.9f, 0.46f),\n        vec3(0.55f, 0.78f, 0.33f),\n        vec3(0.27f, 0.64f, 0.16f),\n        vec3(0.13f, 0.41f, 0.07f)\n    );\n    vec2 sz = rep*.35;\n    float shape = sdBox(uv, sz);\n    float val = rdr(id*rep);\n    col = mix(col, cols[int(val*4.)], 1.-sat(shape*iResolution.x));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3GRj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 446, 483, 483, 563], [564, 580, 625, 625, 912], [913, 913, 932, 932, 988], [989, 989, 1008, 1008, 1220], [1221, 1221, 1241, 1241, 1580]], "test": "untested"}
{"id": "DscGzj", "name": "Complex geometric series", "author": "NinjaKoala", "description": "Recreation of a gif i saw in a chat. It can be regarded as a visualization of a geometric series in the complex numbers.\nhttps://en.wikipedia.org/wiki/Geometric_series\n\nThe ratio of the size of two neighbouring squares is the golden ratio.", "tags": ["2d", "animation", "goldenratio", "fibonacci", "series"], "likes": 22, "viewed": 300, "published": 3, "date": "1677506833", "time_retrieved": "2024-07-30T18:07:59.437706", "image_code": "const vec3 dot_col = vec3(0);\nconst vec3 circ_col = vec3(0,1,0);\nconst vec3 line_col = vec3(0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .004;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\nconst float pi = 3.1415925;\nconst float phi = 1.6180339;\n\nconst float shrink_factor = phi;\n\nmat2 rot(float t){\n\treturn mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nfloat sdBox(vec2 p, float a){\n    vec2 d = abs(p)-a;\n    return abs(length(max(d,0.0)) + min(max(d.x,d.y),0.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse -= .5;\n    mouse.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tvec3 color = bg_col;\n\n\tfloat line_dis = 1e38;\n\tfloat point_dis = 1e38;\n\tfloat circ_dis = 1e38;\n\n\tfloat side_length = .1;\n\tvec2 dir = vec2(1,1);\n\tfloat base_radius = shrink_factor/(shrink_factor * shrink_factor - 1.); // this is 1 if shrink_factor is phi\n\tvec2 corner = - dir * 2. * side_length * shrink_factor * base_radius; // put corner of biggest square such that the middle of the circle is (0,0)\n\n\tfloat r0 = 2. * side_length * length(dir) * base_radius;\n\n\tcirc_dis = min(circ_dis, abs(length(uv) - r0) - line_width);\n    \n    float t0 = mod(iTime*.4,4.);\n    float t1 = mix(0.,0.25,smoothstep(0.,1.,t0));\n    t1 = mix(t1,.5,smoothstep(1.,2.,t0));\n    t1 = mix(t1,.75,smoothstep(2.,3.,t0));\n    t1 = mix(t1,1.,smoothstep(3.,4.,t0));\n\n\tfor(int i=0;i<16;i++){\n\t\tline_dis = min(line_dis, sdBox(uv - corner - dir * side_length, side_length) - line_width);\n\t\tpoint_dis = min(point_dis, distance(uv, corner) - dot_size);\n\n\t\tcorner += 2. * dir * side_length;\n\n\t\tside_length /= shrink_factor;\n\t\tdir *= rot(pi / 2.);\n\n\t\tuv -= corner;\n        \n\t\tuv *= rot(t1 * 2. * pi);\n\t\tuv += corner;\n\t}\n\n\t//color = mix(dot_col, color, smoothstep(-border/2., border/2., point_dis));\n\tcolor = mix(circ_col, color, smoothstep(-border/2., border/2., circ_dis));\n    color = mix(line_col, color, smoothstep(-border/2., border/2., line_dis));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 321, 321, 367], [369, 369, 398, 398, 483], [485, 485, 539, 539, 2172]], "test": "untested"}
{"id": "dsdGzB", "name": "Hexagonal UVTiling", "author": "rge15", "description": "UV Tiling from tutorial : https://www.youtube.com/watch?v=VmrIDyYiJBA ", "tags": ["uv", "hexagon", "tiling"], "likes": 1, "viewed": 230, "published": 3, "date": "1677496249", "time_retrieved": "2024-07-30T18:08:00.328324", "image_code": "float HexDist(in vec2 p)\n{\n    p = abs(p);\n    float d = dot( p, normalize(vec2(1.,1.73))); \n    d = max(d,p.x);\n    d = step(d, 0.3);\n\n    return d;\n}\n\nvec4 HexUv( in vec2 uv )\n{\n    vec2 triSide = vec2(1.,1.73);\n    vec2 hSide = triSide*0.5;\n\n    vec2 gva = mod(uv,triSide) - hSide;\n    vec2 gvb = mod(uv-hSide,triSide) - hSide;\n\n    vec2 gv;\n    if(length(gva)<length(gvb))\n        gv = gva;\n    else\n        gv = gvb;\n    \n    \n    vec2 id = uv - gv;\n    \n    return vec4(gv,id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 2.;\n    vec3 col = vec3( 0.);\n\n    col = vec3( HexDist(uv));\n\n    vec4 hex = HexUv(uv);\n\n    col = vec3(hex.xy,0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 151], [153, 153, 179, 179, 485], [487, 487, 544, 594, 837]], "test": "untested"}
{"id": "ddtGzB", "name": "Reflecting Chip", "author": "dr2", "description": "Lots of reflections with a pseudo-pringle mirror", "tags": ["raymarch", "reflect", "pringle"], "likes": 23, "viewed": 220, "published": 3, "date": "1677494858", "time_retrieved": "2024-07-30T18:08:01.785429", "image_code": "// \"Reflecting Chip\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, ltPos, vuPos, chipPos, chipRot;\nfloat tCur, dstFar, roomRd, roomHt, chipRad;\nint idObj;\nconst int idFrm = 1, idWl = 2, idFlrCl = 3, idTbl = 4, idLeg = 5, idLit = 6,\n   idRing = 7, idAx = 8, idChip = 9;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SurfDf (inout vec3 q, float r)\n{  // (intersection of torus and cylinder = quasi-pringle)\n  float d, rt;\n  rt = 2. * r;\n  q = q.yzx;\n  q.z += 0.07 * r;\n  d = abs (q.z) - rt;\n  q.z = length (vec2 (length (vec2 (q.y, q.z - rt)) - 3. * rt, q.x)) - 2. * rt;\n  return max (d, SmoothMax (abs (q.z) - 0.01, length (q.xy) - r, 0.01));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, nw;\n  dMin = dstFar;\n  nw = 9.;\n  q = p;\n  q.y -= roomHt;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nw * atan (q.z, - q.x) / (2. * pi) + 0.5) / nw);\n  q.x += roomRd;\n  d = max (q.x, - PrBox2Df (q.yz, vec2 (roomHt - 0.15, roomRd * tan (pi / nw) - 0.15)));\n  DMIN (idFrm);\n  d = q.x + 0.25;\n  DMIN (idWl);\n  d = roomHt - abs (q.y);\n  DMIN (idFlrCl);\n  q = p;\n  q.y -= 0.9;\n  d = PrCylDf (q.xzy, 0.6, 0.02);\n  DMIN (idTbl);\n  q = p;\n  q.y -= 0.45;\n  q.xz += 0.02 * sin (7. * pi * q.y + vec2 (0.5 * pi, 0.));\n  d = PrCylDf (q.xzy, 0.03, 0.45);\n  DMIN (idLeg);\n  q = p;\n  d = PrCylDf (q.xzy, 0.2, 0.04 * (1. - 0.6 * smoothstep (0.1, 0.2, length (q.xz))));\n  DMIN (idLeg);\n  q = p;\n  q.y -= 0.93;\n  d = PrCylDf (q.xzy, 0.045, 0.025);\n  DMIN (idAx);\n  q = p - chipPos;\n  q.xz = Rot2Cs (q.xz, sin (chipRot.y + vec2 (0.5 * pi, 0.)));\n  d = max (abs (length (q.xy) - chipRad - 0.07) - 0.01, abs (q.z) - 0.02);\n  DMIN (idRing);\n  d = max (length (q.yz) - 0.03, abs (abs (abs (q.x) - chipRad - 0.06)) - 0.02);\n  DMIN (idAx);\n  q.yz = Rot2Cs (q.yz, sin (chipRot.x + vec2 (0.5 * pi, 0.)));\n  d = max (abs (length (q.xz) - chipRad - 0.04) - 0.01, abs (q.y) - 0.018);\n  DMIN (idRing);\n  d = max (length (q.xy) - 0.03, abs (abs (abs (q.z) - chipRad - 0.025)) - 0.015);\n  DMIN (idAx);\n  q.xy = Rot2Cs (q.xy, sin (chipRot.z + vec2 (0.5 * pi, 0.)));\n  d = max (abs (length (q.yz) - chipRad - 0.01) - 0.01, abs (q.x) - 0.016);\n  DMIN (idRing);\n  d = SurfDf (q, chipRad + 0.005);\n  DMINQ (idChip);\n  if (! isSh) {\n    q = p - ltPos;\n    d = PrSphDf (q, 0.1);  \n    DMIN (idLit);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += clamp (h, 0.01, 0.2);\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, refCol, vn, ltVec, ltDir;\n  float dstObj, ld, sh, nDotL;\n  const int nRef = 8;\n  chipRot = vec3 (0.1, 0.13, 0.16) * pi * tCur;\n  chipRad = 0.58;\n  col = vec3 (0.);\n  refCol = vec3 (1.);\n  isSh = false;\n  for (int n = VAR_ZERO; n < nRef; n ++) {\n    dstObj = ObjRay (ro, rd);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (n < nRef - 1 && dstObj < dstFar && (idObj == idWl ||\n       idObj == idChip && length (qHit.xy) < 0.95 * chipRad)) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refCol *= 0.85;\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idChip) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      if (length (qHit.xy) > 0.99 * chipRad && abs (abs (qHit.x) - abs (qHit.y)) < 0.02)\n         col4 *= 0.9;\n    } else if (idObj == idRing) {\n      col4 = vec4 (0.9, 0.95, 0.9, 0.2);\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.9, 0.7, 0.2, 0.2);\n    } else if (idObj == idFrm) {\n      col4 = vec4 (0.5, 0.2, 0., 0.1);\n    } else if (idObj == idWl) {\n      col4 = vec4 (0.1, 0.3, 0., 0.);\n    } else if (idObj == idFlrCl) {\n      col4 = (ro.y < roomHt) ? vec4 (0.45, 0.4, 0.25, 0.) : vec4 (0.8, 0.8, 1., 0.);\n    } else if (idObj == idTbl) {\n      col4 = vec4 (0.95, 0.85, 0.85, 0.2);\n      if (vn.y > 0.99) col4 = mix (vec4 (0.5, 0.4, 0.7, 0.1), col4, \n         smoothstep (0.015, 0.02, abs (Fbm2 (vec2 (4., 1.) * ro.xz) - 0.4)));\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idLit) {\n      col4 = vec4 (1., 1., 0.7, -1.);\n    }\n    if (idObj == idFlrCl || idObj == idFrm) vn = VaryNf (32. * ro, vn, 0.2);\n    if (col4.a >= 0.) {\n      isSh = true;\n      ltVec = ltPos - ro;\n      ld = length (ltVec);\n      ltDir = ltVec / ld;\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (idObj == idRing || idObj == idAx) nDotL *= nDotL;\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir, ld);\n      col = refCol * (col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, ltAz, ltEl;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 2. * pi * sin (0.005 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  roomRd = 6.;\n  roomHt = 2.;\n  ro = vec3 (0.6 * roomRd * cos (el) * sin (az + vec2 (0.5 * pi, 0.)),\n     0.9 * roomHt * sin (el)).xzy;\n  ro.y += roomHt;\n  chipPos = vec3 (0., 1.6, 0.);\n  vd = normalize (chipPos - ro);\n  u = - vd.y * vd;\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (u.x, 1. + u.y, u.z) / sqrt (1. - vd.y * vd.y), vd);\n  vuPos = ro;\n  zmFac = 2.8;\n  dstFar = 20.;\n  ltAz = -0.1 * pi * tCur;\n  ltEl = 0.15 * pi * sin (2.3 * ltAz);\n  ltPos = vec3 (0.5 * roomRd * cos (ltEl) * sin (ltAz + vec2 (0.5 * pi, 0.)),\n     0.8 * roomHt * sin (ltEl)).xzy;\n  ltPos.y += 1.4 * roomHt;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtGzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[934, 934, 972, 1029, 1268], [1270, 1270, 1292, 1292, 2894], [2896, 2896, 2929, 2929, 3112], [3114, 3114, 3135, 3135, 3390], [3392, 3392, 3443, 3443, 3726], [3728, 3728, 3763, 3763, 5907], [5909, 5909, 5965, 5965, 7524], [7526, 7526, 7559, 7559, 7648], [7650, 7650, 7683, 7683, 7710], [7712, 7712, 7754, 7754, 7805], [7807, 7807, 7852, 7852, 7944], [7946, 7946, 7991, 7991, 8029], [8031, 8031, 8088, 8088, 8171], [8173, 8173, 8203, 8203, 8316], [8318, 8318, 8349, 8349, 8413], [8447, 8447, 8471, 8471, 8583], [8585, 8585, 8610, 8610, 8796], [8798, 8798, 8819, 8819, 8974], [8976, 8976, 9005, 9005, 9217], [9219, 9219, 9258, 9258, 9510]], "test": "untested"}
{"id": "dddGRS", "name": "gradient color horizontal  3", "author": "tianluo97", "description": "gradient color horizontal  3", "tags": ["gradientcolorhorizontal3"], "likes": 0, "viewed": 152, "published": 3, "date": "1677487383", "time_retrieved": "2024-07-30T18:08:03.512810", "image_code": "\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float PI = 3.1415926;\n    float time = iTime * 0.04; \n    \n    \n    if(uv.x > 0.2){\n\n    vec4 color0 = vec4(0.784,0.827,0.941,1.0);\n    vec4 color1 = vec4(0.859,0.161,0.161,1.0); \n    vec4 color2 = vec4(1.000,0.506,0.380,1.0);\n    vec4 color02 = vec4(0.180,0.318,0.620,1.0);\n    vec4 color3 = vec4(0.000,0.220,0.820,1.0);\n    \n\n    float scale = 1.0;\n    float step0 = 0.02;\n    float step1 = 0.2;\n    float step2 = 0.5;\n    float step3 = 1.0;\n\n    \n    //uv.x\n    uv.x = smoothstep(0.2,1.0,uv.x);\n\n    float offset = uv.x ;\n    float y = offset;\n    \n    //morning Color\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    dist0 = sqrt(dist0);\n    fragColor = mix(color0, color1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    // step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color02, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    fragColor = vec4(dist02,dist02,dist02,1.0);\n    fragColor = mix(color02, color3, dist02);\n    }\n    \n    else if (y > step3){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    fragColor = mix(color3, color3, dist3);\n    }\n    \n    vec3 morningScatter = vec3(1.000,0.510,0.302);\n    \n    fragColor = mix(vec4(morningScatter,1.0),fragColor,pow(uv.x/1.3,0.5));\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    fragColor = mix(color0, fragColor, dist0);\n    }\n    fragColor = sqrt(fragColor);\n    \n    \n    //night Color\n    vec4 ncolor0 = vec4(0.784,0.827,0.941,1.0);\n    vec4 ncolor1 = vec4(1.000,0.584,0.220,1.0); \n    vec4 ncolor2 = vec4(1.000,0.820,0.639,1.0);\n    vec4 ncolor02 = vec4(0.698,0.839,0.976,1.0);\n    vec4 ncolor3 = vec4(0.302,0.639,1.000,1.0);\n    \n    float nstep0 = 0.05;\n    float nstep1 = 0.2;\n    float nstep2 = 0.3;\n    float nstep3 = 1.0;\n    \n    vec4 nightColors;\n    if (y < nstep0) {\n    float dist0 = smoothstep(0.0, nstep0, y);\n    nightColors = mix(ncolor0, ncolor1, dist0);\n    }\n    \n    else if (y > nstep0 && y < nstep1) {\n    float dist1 = smoothstep(nstep0, nstep1, y);\n    nightColors = mix(ncolor1, ncolor2, dist1);\n    }\n    \n    else if (y > nstep1 && y < nstep2) {\n    float dist2 = smoothstep(nstep1, nstep2, y);\n    nightColors = mix(ncolor2, ncolor02, dist2);\n    }\n    \n    else{\n    float dist3 = smoothstep(nstep2, nstep3, y);\n    nightColors = mix(ncolor02, ncolor3, dist3);\n    }\n   \n    vec3 nightScatter = vec3(1.000,0.925,0.820);\n    nightColors.rgb = mix(nightScatter, nightColors.rgb, pow(uv.x/1.3,0.1));\n    if (y < nstep0) {\n    float dist0 = smoothstep(0.0, nstep0, y);\n    nightColors = mix(ncolor0, nightColors, dist0);\n    }\n    nightColors = sqrt(nightColors);\n    \n    //scatter\n    float scatter = pow((sin(iTime * .3) * 0.5 + 0.5),1.0 / 1.0);\n    //float scatter = pow(iMouse.x / iResolution.x,1.0 / 15.0);\n    \n    //skyColorsfragColor\n    vec3 morningColor = fragColor.rgb;\n    vec3 nightColor = nightColors.rgb;\n    vec3 skyColors = mix(morningColor,nightColor,scatter);\n\n    /*\n    //scatterColor\n    vec3 morningScatter = vec3(1.000,0.412,0.161);\n    morningScatter = mix(color0.rgb,morningScatter,0.0);\n    vec3 nightScatter = vec3(1.000,0.816,0.561)*1.2;\n    vec3 scatterColor = mix(morningScatter,nightScatter, scatter);*/\n    \n    //vec3 color = mix(skyColors,vec3(scatterColor),pow(atmosphere/1.3,1.5));\n    \n    fragColor = vec4(skyColors,1.0);\n    }\n    \n    else {\n    vec3 startColor = vec3(0.341,0.482,0.886);\n    vec3 endColor = vec3(0.784,0.827,0.941);\n    \n    vec3 color = mix(startColor,endColor,uv.x * 5.0);\n    fragColor = vec4(color,1.0);\n    fragColor = sqrt(fragColor);\n    }\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 208, 245, 4751]], "test": "untested"}
{"id": "csd3zS", "name": "Fork Kepler 256 Luna5ama 672", "author": "Luna5ama", "description": "A planet in the habitable zone of a binary star system.", "tags": ["earth", "alienplanet"], "likes": 1, "viewed": 196, "published": 3, "date": "1677469677", "time_retrieved": "2024-07-30T18:08:04.685674", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\nprecision lowp float;\n\nfloat PI=3.14159265;\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 15.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901) * 0.0;\n\nfloat distFromSphere;\nvec3 normal;\nvec3 texBlurry;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nvec3 GetSunColor(vec3 rayDir, vec3 sunDir)\n{\n\tfloat dense = 16.0;\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tsunIntensity = max(0.0, sunIntensity - 3.0);\n\n\tlocalRay.x = localRay.x + 1.0 - iTime * 0.1;\n\t//vec3 right = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\t//vec3 up = normalize(cross(sunDir, right));\n\tvec2 wrap = fract((localRay.xy)*dense);\n\tvec4 rand = texture(iChannel2, floor(localRay.xy*dense)/dense).xyzw;\n\tvec3 starColor = rand.xyz;\n\tstarColor = starColor * 0.75 + 0.25;\n\trand.xy = rand.xy * 2.0 - 1.0;\n\tvec2 center = vec2(0.5, 0.5) + rand.xy * 0.9;// floor(fract((localRay.xy)*8.0)) + 0.5;\n\tfloat star = length(wrap - center);\n\tfloat test = star;\n\tstar = saturate((1.0 - star));\n\tfloat blink = texture(iChannel2, localRay.xy + iTime * 0.03).x;\n\tfloat cluster = 0.3;// /*(localRay.x+0.5) */ (localRay.y+0.5) * 2.8 + 0.8;\n\tstar = pow(star, 60.0 + saturate(rand.z - 0.0) * 250.0 * cluster);\n\tstar *= blink;\n\t\n\tfloat milkyMask = saturate(0.25 - abs(localRay.x - 0.65));\n\tvec3 milkyway = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3)).yxz;\n\tvec3 milkyLOD = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3), 3.0).yxz;\n\tvec3 milkyDetail = texture(iChannel3, (-localRay.yx*8.0 )+vec2(0.65, 0.3)).yxz;\n\tmilkyway *= milkyDetail.xxx;\n\tmilkyway *= vec3(1.0, 0.8, 0.91)*1.5;\n\tmilkyway = pow(milkyway, vec3(2.0, 2.0, 2.0)*3.0);\n\tmilkyway += vec3(0.2, 0.0015, 1.001) * milkyLOD * 0.006;\n\t\n\tvec3 finalColor = milkyway /* milkyMask*/ * 10850.0;\n\tfinalColor += environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\treturn finalColor;\n\t//return environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\t//return vec3(1.0,1.0,1.0)*cluster*1000.0;\n}\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn environmentSphereColor + sunCol * sunIntensity;\n}\n\nvec3 LensFlare(vec2 uv, vec2 lfPos)\n{\n\tvec2 delta = uv - lfPos;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.x, delta.y);\n\tvec3 tex = texture(iChannel0, vec2(angle*5.0, dist*0.125) /*- iTime*0.1*/).xyz;\n\tfloat bump = sin(angle * 6.0) * 0.5 + 0.54;\n\tbump -= pow(dist, 0.0125);\n\tbump = saturate(bump);\n\n\treturn sunCol * tex.x * 0.1 * bump / (dist);\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nvec2 Spiral(vec2 uv)\n{\n\tfloat reps = 2.0;\n\tvec2 uv2 = fract(uv*reps);\n\tvec2 center = floor(fract(uv*reps)) + 0.5;\n\tvec2 delta = uv2 - center;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.y, delta.x);\n\t//if (distance(center, uv2) < 0.02) return vec2(10,10);\n\tfloat nudge = dist * 4.0;\n\tvec2 offset = vec2(delta.y, -delta.x);// * 0.2 / dist ;// vec2(sin(angle+nudge), cos(angle+nudge));\n\tfloat blend = max(abs(delta.x), abs(delta.y))* 2.0;\n\tblend = clamp((0.5 - dist) * 2.0, 0.0, 1.0);\n\tblend = pow(blend, 1.5);\n\t//offset *= clamp(1.0 - blend, 0.0, 1.0);\n\toffset *= clamp(blend, 0.0, 1.0);\n\t//if (dist > 0.5) offset = vec2(0,0);\n\t//offset *= dist;\n\treturn uv + offset*vec2(1.0,1.0)*1.1*texBlurry.x ;//+ vec2(iTime*0.03, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.yy + vec2(-0.4,0.0);\n\t//vec3 worldPix = vec3(uv*2.0 - 1.0, 1.65);// + (iMouse.x - iResolution.x * 0.2)* 0.01);\n\t//vec3 camPos = vec3(0.0,0.1,0.0);\n\n    vec2 res = iResolution.xy;\n    float scaleFactor = min(iResolution.x / iResolution.y, 1.0);\n    res *= scaleFactor;\n\tvec2 uv = fragCoord.xy / res - (0.5 / scaleFactor);\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=-PI/2.0;//iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=0.0;//-iMouse.y/iResolution.y*10.0;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(2.5); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (res.x / res.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\n\tvec3 planetPos = vec3(0.0,0.0,0.0);\n\tvec3 iA, iB, iA2, iB2;\n\tfloat t = iTime * 0.1 + 0.7 - iMouse.x*0.01;\n\tfloat cloudT = iTime * 0.1;\n\tfloat distFromSphere2;\n\tvec3 normal2;\n\tfloat hit2 = IntersectSphereAndRay(planetPos, 1.05, camPos, worldPix, iA2, iB2);\n\tnormal2 = normal;\n\tdistFromSphere2 = distFromSphere;\n\tfloat hit = IntersectSphereAndRay(planetPos, 1.0, camPos, worldPix, iA, iB);\n\t//float hit = IntersectSphereAndRay(planetPos, 1.0, camPos, pixPos, iA, iB);\n\tnormal = normalize(iA - planetPos);\n\t//if (abs(normal.x) <= 0.001) normal.x += 0.001;\n\tvec2 polar = vec2(atan(normal.x, normal.z)/*0.955*/, acos(normal.y));\n\tpolar.x = (polar.x + PI) / (PI * 2.0);\n\tpolar.y = polar.y / PI;// + 0.5;\n\tif (abs(normal.x) <= 0.02)\n\t{\n\t\t//polar.x = 0.0;\n\t}\n\tpolar.x = (polar.x+2.03);\n\tpolar.xy = iA.xy;\n\t//polar.y = floor(polar.y * 32.0) / 32.0;\n/*\tif (abs(normal.x) < abs(normal.z))\n\t{\n\t\tpolar = vec2((atan(normal.z, normal.x))*0.955, acos(iA.y));\n\t\t//polar.x = 0.0;\n\t}*/\n\t//+ vec2(0.0,iTime * 0.01)\n\tvec4 texNoise = texture(iChannel2, (polar.xy+vec2(t,0)) * 2.0);\n\ttexNoise.y = texture(iChannel2, (polar.xy+vec2(t,0)) * 1.0).y;\n\ttexNoise.z = texture(iChannel2, (polar.xy+vec2(t,0)) * 4.0).z;\n\ttexBlurry = texture(iChannel0, (polar.xy+vec2(t,0))*0.03125*0.25 ).rgb;\n\n\tvec3 tex = texture(iChannel0, (polar.xy+vec2(t,0))*1.0).rgb;\n\t//vec3 tex = texture(iChannel0, polar.xy, 0.0).rgb;\n\ttex *= tex;\n\tvec3 texFlip = texture(iChannel0, (1.0 - (polar.xy+vec2(t,0))*0.5)).rgb;\n\ttexFlip *= texFlip;\n\n\tvec3 texS = texture(iChannel0, (Spiral(polar.xy+vec2(t,0))+vec2(cloudT*0.25,0))*1.0).rgb;\n\ttexS *= texS;\n\tvec3 texFlipS = texture(iChannel0, (1.0 - (Spiral(polar.xy+vec2(t,0))+vec2(cloudT*0.25,0))*0.5)).rgb;\n\ttexFlipS *= texFlipS;\n\n\tfloat atmosphereDensity = (1.45 + normal.z);\n\tvec3 atmosphereColor = vec3(0.075, 0.35, 0.99) * 0.45;\n\tfloat cloudDensity = max(0.0, (pow(texFlipS.x * texS.x, 0.7) * 3.0));\n\tvec3 finalAtmosphere = atmosphereColor * atmosphereDensity + cloudDensity;\n\tvec3 finalColor = finalAtmosphere;\n\n\tvec3 detailMap = min(texture(iChannel3, (polar.xy+vec2(t,0)) * 2.0).xyz, 0.25) * 4.0;\n\tfloat land = pow(max(0.0, texture(iChannel1, (polar.xy+vec2(t,0))* 0.25).z - 0.25), 0.4)*0.75;\n\tfloat land2 = land * texBlurry.x * 6.0;\n\tland *= detailMap.x;\n\t//land2 *= detailMap.x;\n\tland2 = max(0.0, land2);\n\tland -= tex.x*0.65;\n\tland = max(0.0, land);\n\tfloat iceFactor = abs(pow(normal.y,2.0));\n\tvec3 landColor = max(vec3(0.0,0.0,0.0), vec3(0.13,0.65,0.01) * land);// * (1.0 + iceFactor*2.0);\n\tvec3 landColor2 = max(vec3(0.0,0.0,0.0), vec3(0.8,0.4,0.01) * land2);\n\tvec3 mixedLand = (landColor + landColor2)* 0.5;\n\tmixedLand *= (detailMap.zyx + 2.0) * 0.333;\n\t//float hardBlur = saturate((texBlurry.x - 0.2)* 104.0 + 0.2)* 0.2 + 0.4;\n\t//vec3 finalLand = mix(landColor, landColor2, hardBlur);\n\tvec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land, iceFactor);\n\tfinalLand = mix(atmosphereColor * 0.05, finalLand, pow(min(1.0,max(0.0,-distFromSphere*1.0)), 0.2));\n\tfinalColor += finalLand;\n\tfinalColor *= hit;\n\n\tfloat refNoise = (texNoise.x + texNoise.y + texNoise.z)* 0.3333;\n\tvec3 noiseNormal = normal;\n\tnoiseNormal.x += refNoise*0.05*hit;\n\tnoiseNormal.y += tex.x*hit*0.1;\n\tnoiseNormal.z += texFlip.x*hit*0.1;\n\tnoiseNormal = normalize(noiseNormal);\n\tvec3 ref = reflect(normalize(worldPix - camPos), noiseNormal);\n\n\trefNoise = refNoise*0.25 + 0.75;\n\tfloat orbitSpeed = 0.125;\n\t//vec3 sunDir = normalize(vec3(-0.9 + sin(iTime*0.2)*0.5, -0.1, -0.9150));\n\tvec3 sunDir = normalize(vec3(-0.009 + sin(iTime*orbitSpeed), -0.13, -cos(iTime*orbitSpeed)));\n\tvec3 r = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\tvec3 up = normalize(cross(sunDir, r));\n\tfloat binarySpeed = 0.5;\n\tfloat binaryDist = 0.3;\n\tsunDir += r * sin(iTime*binarySpeed) * binaryDist + up * cos(iTime*binarySpeed) * binaryDist;\n\tsunDir = normalize(sunDir);\n\n\tvec3 sunDir2 = normalize(vec3(-0.009 + sin((iTime+0.2)*orbitSpeed), 0.13, -cos((iTime+0.2)*orbitSpeed)));\n\tr = normalize(cross(sunDir2, vec3(0.0,1.0,0.0)));\n\tup = normalize(cross(sunDir2, r));\n\tsunDir2 -= r * sin(iTime*binarySpeed) * binaryDist + up * cos(iTime*binarySpeed) * binaryDist;\n\tsunDir2 = normalize(sunDir2);\n\n\tvec3 refNorm = normalize(ref);\n\tfloat glance = saturate(dot(refNorm, sunDir) * saturate(sunDir.z - 0.65));\n\tfloat glance2 = saturate(dot(refNorm, sunDir2) * saturate(sunDir2.z - 0.65));\n\tfloat landMask = finalLand.x + finalLand.y * 1.5;\n\tvec3 sunRef = GetSunColorReflection(refNorm, sunDir)*0.005*hit * (1.0 - saturate(landMask*3.5)) * (1.0-texS.x) * refNoise;\n\tvec3 sunRef2 = GetSunColorReflection(refNorm, sunDir2)*0.005*hit * (1.0 - saturate(landMask*3.5)) * (1.0-texS.x) * refNoise;\n\t\n\t//sunRef = mix(sunRef, atmosphereColor * vec3(1.0, 0.2, 0.1)*3.0, saturate(atmosphereDensity - 0.35)) * hit;\n\t//sunRef *= atmosphereColor;\n\t// fade to sunset color at outer atmosphere\n\tsunRef = mix(sunRef, vec3(3.75, 0.8, 0.02)* hit, glance);\n\tsunRef2 = mix(sunRef2, vec3(3.75, 0.8, 0.02)* hit, glance2);\n\tfinalColor += sunRef;\n\tfinalColor += sunRef2;\n\n\tvec3 sunsColor = GetSunColor(normalize(ref), sunDir) *0.000096*(1.0-hit) +\n\t\t\t\t\t GetSunColor(normalize(ref), sunDir2)*0.000096*(1.0-hit);\n\n\tfloat outerGlow = 1.0 - clamp(distFromSphere * 20.0, 0.0, 1.0);\n\touterGlow = pow(outerGlow, 5.2);\n\tfinalColor += (atmosphereColor + vec3(0.2, 0.2, 0.2)) * outerGlow * (1.0 - hit);\n\t\n\tfloat light = saturate(dot(sunDir, noiseNormal));\n\tlight += saturate(dot(sunDir2, noiseNormal));\n\tfinalColor *= light * 0.75 + 0.001;\t// ambient light (from stars, of course)\n\tfinalColor += sunsColor;\n\n\tfloat scattering, scattering2;\n\tif (hit2 == 1.0) scattering = distance(iA2, iB2);\n\tscattering2 = scattering;\n\tscattering *= pow(saturate(dot(relVec, sunDir) - 0.96), 2.0);\n\tscattering2 *= pow(saturate(dot(relVec, sunDir2) - 0.96), 2.0);\n\tscattering *= hit2 * (1.0 - hit);\n\tscattering2 *= hit2 * (1.0 - hit);\n\tscattering *= outerGlow;\n\tscattering2 *= outerGlow;\n\tfinalColor += vec3(1.0, 0.25, 0.05) * scattering * 3060.0;\n\tfinalColor += vec3(1.0, 0.25, 0.05) * scattering2 * 3060.0;\n\n\t//vec3 sunUV = worldFacing + sunDir2.x * sideNorm * (iResolution.x/iResolution.y) + sunDir2.y * upNorm;\n\t//float lame = distance(sunUV, worldPix);\n\t//vec3 sunUV = sunDir2 / vec3(sideNorm  * (iResolution.x/iResolution.y) * 0.4 + upNorm * 0.999);\n\t//finalColor += LensFlare(uv * vec2((iResolution.x/iResolution.y), 1.0), vec2(sunUV.x, sunUV.y));\n\n\t//finalColor = vec3(1.0,1.0,1.0) * (finalLand.x + finalLand.y)*hit;\n\t//finalColor += vec3(1.0,1.0,1.0) * glance;\n\t//finalColor = vec3(0, polar.x, 0.0);\n\t//finalColor = GetSunColorReflection(normalize(ref), sunDir)*0.005*hit * (1.0 - clamp(finalLand.x*12.0, 0.0, 1.0)) * (1.0-texS.x) * refNoise;\n\t//if (abs(normal.x) <= 0.001) finalColor = vec3(1.0,0.0,0.0);\n\n\tfragColor = vec4(clamp(sqrt(finalColor), 0.0, 1.0), 1.0);\n    fragColor = mix(fragColor, vec4(0.1, 0.1, 0.1, 1.0), 0.7);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csd3zS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[770, 770, 793, 793, 823], [824, 824, 847, 847, 877], [878, 878, 903, 903, 933], [935, 935, 979, 979, 2849], [2850, 2850, 2904, 2904, 3198], [3200, 3200, 3237, 3237, 3558], [3560, 3560, 3679, 3740, 4434], [4436, 4436, 4458, 4458, 5171], [5173, 5173, 5230, 5417, 13058]], "test": "untested"}
{"id": "ms3GzB", "name": "A kind of bevel", "author": "PauloFalcao", "description": "Trying to create a bevel effect on a SDF\nIt only works on axis aligned surfaces\nand it's not exacly a bevel on interior unions\nBut I like effect :)", "tags": ["sdf", "bevel"], "likes": 15, "viewed": 286, "published": 3, "date": "1677453640", "time_retrieved": "2024-07-30T18:08:05.701957", "image_code": "// A kind of bevel\n// By PauloFalcao\n//\n// Trying to create a bevel effect on a SDF\n// It only works on axis aligned surfaces\n// and it's not exacly a bevel on interior unions\n//\n// But I like effect :)\n//\n// alternative effects at line 34\n// return max(max(max((x1+x2)/2.0,(y1+y2)/2.0),max((y1+y2)/2.0,(z1+z2)/2.0)),max((z1+z2)/2.0,(x1+x2)/2.0));\n// return min(min(min((x1+x2)/2.0,(y1+y2)/2.0),min((y1+y2)/2.0,(z1+z2)/2.0)),min((z1+z2)/2.0,(x1+x2)/2.0));\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_test(vec3 p){\n    vec3 d=vec3(0.6,0.6,2.0);\n    return min(min(sdBox(p,d),sdBox(p,d.xzy)),sdBox(p,d.zxy));\n}\n\nfloat bevel_sdf(in vec3 p,in float b){\n    vec3 k=vec3(1.0,0.0,-1.0)*b;\n    float x1=sdf_test(p+k.xyy);\n    float x2=sdf_test(p+k.zyy);\n    float y1=sdf_test(p+k.yxy);\n    float y2=sdf_test(p+k.yzy);\n    float z1=sdf_test(p+k.yyx);\n    float z2=sdf_test(p+k.yyz);\n    return min(min(max((x1+x2)/2.0,(y1+y2)/2.0),max((y1+y2)/2.0,(z1+z2)/2.0)),max((z1+z2)/2.0,(x1+x2)/2.0));\n}\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\n//Test Object\nfloat sdf_a(vec3 p){\n\n    //Rotate the object\n    p.yz=rot(p.yz,sin(iTime*0.5)*2.0);\n    p.xz=rot(p.xz,sin(iTime*0.2)*0.5);\n    p.xy=rot(p.xy,sin(iTime*0.03)*2.0);\n\n    float b=bevel_sdf(p,sin(iTime)*0.2+0.2);\n    \n    return b;\n}\n\n//Object Color\nvec3 tex3d_a(vec3 p){\n    return vec3(0.9,0.6,0.3);\n}\n\n//Floor\nfloat sdf_b(vec3 p){\n    return max(p.y+2.0,length(p)-8.0);\n}\n\n//Floor color\nvec3 tex3d_b(vec3 p){\n    p*=2.0;\n\tvec2 w=max(abs(dFdx(p.xz)),abs(dFdy(p.xz)))+1e-5;\n\tif (max(w.x,w.y)>0.5) {\n\t\treturn vec3(mod(floor(p.x)+floor(p.z),2.0));\n\t}\n\tvec2 i=((1.-abs(2.*fract((p.xz+.5*w)/2.)-1.))-(1.-abs(2.*fract((p.xz-.5*w)/2.)-1.)))/w;\n\treturn vec3(.5-.5*i.x*i.y);\n}\n\n\n//Combine the 2 SDFs\nvec2 sdf(vec3 p) {\n    float sdfa=sdf_a(p);\n\tfloat sdfb=sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n\n\n\n//definition\nvec3 raymarch(vec2 uv,vec3 camera,float cameraZoom,vec3 lookAt,\n    float cameraDistance,vec3 sun,float ambOcclusion,float shadowIntensity,\n    float ambLightIntensity,float lightPow,float lightSpecular,float reflection);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //setup uv\n    vec2 uv=fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //rendering parameters\n    vec3 camera=vec3(sin(sin(iTime*0.3)*0.5+0.5)*4.0,2.0,cos(cos(iTime*0.2)*0.5+0.5)*4.0);\n    float cameraZoom=1.5;\n    vec3 lookAt=vec3(0.0,0.0,0.0);\n    float cameraDistance=1.1;\n    vec3 sun=vec3(0.0,2.0,2.5);\n    float ambOcclusion=1.0;\n    float shadowIntensity=1.0;\n    float ambLightIntensity=0.25;\n    float lightPow=128.0;\n    float lightSpecular=0.7;\n    float reflection=0.2;\n    vec3 col = raymarch(uv,camera,cameraZoom,lookAt,cameraDistance,sun,\n        ambOcclusion,shadowIntensity,ambLightIntensity,lightPow,lightSpecular,reflection);\n\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n\n//************************* Rendering framework ****************************************\n\nvec3 normal(vec3 p){  \n  const vec2 e=vec2(0.001,-0.001);\n  float x=sdf(p+e.xyy).x;\n  float y=sdf(p+e.yxy).x;\n  float z=sdf(p+e.yyx).x;\n  return normalize(vec3(x-y-z,-x+y-z,-x-y+z)+sdf(p+e.xxx).x);\n}\n\nvoid march(inout float d,out vec3 p,out vec2 dS,in vec3 ro,in vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = sdf(p);\n        d += dS.x;\n        if (d > 20.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = sdf( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = sdf( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(16.0)) * v;\n}\n\nvec3 raymarch(\n        vec2 uv,\n        vec3 camera,\n        float cameraZoom,\n        vec3 lookAt,\n        float cameraDistance,\n        vec3 sun,\n        float ambOcclusion,\n        float shadowIntensity,\n        float ambLightIntensity,\n        float lightPow,\n        float lightSpecular,\n        float reflection) {\n\tvec3 cam=camera*cameraZoom;\n\tvec3 ray=normalize(lookAt-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(ray,cX));\n\tvec3 rd = normalize(ray*cameraDistance+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0.);\n\tvec2 dS=vec2(0.);\n\tmarch(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.);\n\tvec3 objColor=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\tvec3 light=normalize(sun);\n\tif (d<20.0) {\n\t    vec3 n=normal(p);\n\t\tfloat l=clamp(dot(-light,-n),0.,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.,1.0);\n\t\tfloat cAO=mix(1.0,calcAO(p,n),ambOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow(p,light,0.05,5.),shadowIntensity);\n\t\tcolor=min(\n            vec3(max(shadow,ambLightIntensity)),\n            max(l,ambLightIntensity))*max(cAO,ambLightIntensity)*objColor+\n                pow(r,lightPow)*lightSpecular;\n\t\t//reflection\n        d=0.01;\n\t\tmarch(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0.);\n\t\tif (d<20.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\t\t\tn=normal(p);\n\t\t\tl=clamp(dot(-light,-n),0.,1.);\n\t\t\tobjColorRef=max(l,ambLightIntensity)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=hdri(ref.zyx,1.0);\n\t\t}\n\t\tcolor=mix(color,objColorRef,reflection);\n\t} else {\n\t\tcolor=hdri(rd.zyx,0.0);\n\t}\n\treturn color;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3GzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 506, 535, 535, 622], [624, 624, 647, 647, 742], [744, 744, 782, 782, 1118], [1120, 1131, 1156, 1156, 1222], [1224, 1238, 1258, 1283, 1468], [1470, 1485, 1506, 1506, 1538], [1540, 1548, 1568, 1568, 1609], [1611, 1625, 1646, 1646, 1904], [1907, 1928, 1946, 1946, 2078], [2319, 2319, 2375, 2390, 3103], [3196, 3196, 3216, 3216, 3395], [3397, 3397, 3468, 3468, 3621], [3623, 3668, 3709, 3709, 3967], [3969, 4014, 4090, 4090, 4398], [4400, 4400, 4427, 4427, 4533], [4535, 4535, 4855, 4855, 6113]], "test": "untested"}
{"id": "dst3D7", "name": "Countryside in Autumn", "author": "guil", "description": "Forked from Ohanami Stipple, which is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\nSome code borrowings from IQ clouds.\n\nUse mouse X to change camera angle.", "tags": ["clouds", "grass", "tree"], "likes": 12, "viewed": 300, "published": 3, "date": "1677451578", "time_retrieved": "2024-07-30T18:08:06.593573", "image_code": "\nfloat col=5.,col2=1e3,col3=1e3;\n\n\n// Signed distance field function.\nfloat f(vec3 p)\n{\n    float ter = -fbm(.2*p.xz+2.)*.3; // Ground\n    col3=p.y-ter;\n    p.y-=ter;\n    float d=max(col3,p.y);\n    \n    \n    if(length(p)<10.)p.xz = mod(p.xz+3.,5.)-2.;// Multiply trees\n      \n    float s=1.,s1=s,g=1.6,g1=1.7;\n       \n    mat2 m1 = r2D(2.2);\n    mat2 m2 = r2D(1.05);\n    mat2 m3 = r2D(-.1);\n\n    int j=7;\n    float h=3.;\n    float scale=.7;\n    p/=scale;\n    \n    //float a = length(p-vec3(0,h/2.,0))-h/2.;\n    //if(a>2.)return min(d, a); \n    \n    \n    // Evaluate the tree \n    d=min(d,scale*max(p.y-h,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s);// trunc \n    for(int k=0;k<int(h);k++){\n      vec3 q=p;\n      s=s1;\n      // Evaluate the tree branches\n      for(int i=0;i<j;\n        q.x=abs(q.x),\n        q.z=(i==0)?q.z:abs(q.z), \n        q.y-=1.,\n        q.xz *= m2,\n        q.xy *= m1,\n        q.xz *= m3,\n        q*=g,\n        s*=g,\n        d=min(d,scale*max(q.y-1.,max(-q.y,length(q.xz)-.1/(q.y+.7)))/s),\n        ++i);\n      // Leaves\n      q.y-=1.;      \n      float l = (length(q*vec3(.6,.3,1.))-.3)/s;\n      if(l<d)col=max(0.,l), d=l;      \n      // return to trunc\n      p.y-=1.5;\n      p.xz *= -m1,\n      s1*=g1;\n      p*=g1;\n      j -=1;}\n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float zoom=1.;\n   \n    // Set up camera and primary ray.\n    vec3 ro=1.*vec3(sin(3.0*m.x),0.*m.y+2.,cos(3.0*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    // Sky \n    vec3 eps = vec3(1./iResolution.xy,0.);\n    uv = .5+.5*uv;\n    fragColor =  texture( iChannel0, uv,0.)*.2\n                +texture( iChannel0, uv+eps.xz,0.)*.2\n                +texture( iChannel0, uv-eps.xz,0.)*.2\n                +texture( iChannel0, uv+eps.zy,0.)*.2\n                +texture( iChannel0, uv-eps.zy,0.)*.2;\n    \n    \n    // Signed distance field raymarch.\n    float t=0.,d=0.;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-3)break;\n        t+=d*.9;\n        if(t>30.)return;\n    }\n\n    // Colourise ground, branch/trunk, or cherry blossom.\n    {\n        vec3 rp=ro+rd*t;\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;//wood\n        if(col<2e-3)fragColor.rgb=vec3(1.,.5,.1);//red leaves\n        if(col3<1e-2||t>12.)//grass\n            fragColor.rgb=vec3(.6,1.,.6)/3.,\n            fragColor.rg +=fbm1(rp.xz*.2)/8.,\n            fragColor.rgb +=texture(iChannel1,rp.xz*1.4+iTime*.1).rgb/3.;\n    }\n\n    // Lighting.\n    vec3 ld=sundir;\n    float e=1e-2;\n    float d2=f(ro+rd*t+ld*e);\n    float l=max(0.,(d2-d)/e);\n\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\n    float l2=max(0.,.5+.5*(d3-d)/e);\n\n    vec3 rp=ro+rd*(t-1e-3);\n\n    // Directional shadow.\n    t=0.1;\n    float sh=1.;\n    for(int i=0;i<30;++i)\n    {\n        d=f(rp+ld*t)+.01;\n        sh=min(sh,d*50.+0.3);\n        if(d<1e-4)break;\n        t+=d;\n    }\n\n    fragColor.rgb*=1.5*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3 sundir = normalize( vec3(-1.,.5,-1.) );\nconst vec3 suncol = vec3(1.,.8,.5);\n\n\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=.3;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<7;i++)r+=sin(p), p=m*(p*s+.2*r+.1),s*=1.6;\n    return r.x+r.y;\n}\n\nfloat fbm1(vec2 p)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm2(vec3 p, float t)//clouds\n{\n    float s=1., r= -2.9;\n    mat2 m = r2D(1.);\n    vec3 n = vec3(1.);\n    for(int i=0;i<12;i++)\n        p.xy *= m,\n        p.xz *= m,\n        n+=.5*cos(p.zxy+.05*t)/s, \n        r+=length(sin(p*s+n)/s),\n        s*=1.5;\n    return r;\n}\n", "buffer_a_code": "\nconst float sc =.5;\nconst float low = 2.;\nconst float high = 7.;\n\nfloat f(vec3 p)\n{\n    p *= sc;\n    p.z +=.2*iTime;\n    float d =fbm2(p*vec3(.3,1.2,.4),iTime)/sc;\n    return d+exp(low-p.y)+exp(p.y-high);\n}\n\nvec2 raymarch( vec3 ro, vec3 rd)\n{\n    float t=5.,d=0.,c=0.,dd,k=.85;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);        \n        c+=exp(-d*d);\n        t+=d*k;\n        k*=1.003;\n        if(t>150.)return vec2(0.);       \n    }\n\n    ro =ro+rd*t,t=1.2;\n    if(sc*ro.y>high)return vec2(0.);   \n    dd=d;\n    d=f(ro+sundir*t);\n    return vec2(.4*(d-dd)/t,c*.004);\n}\n\nvec4 render( in vec3 ro, in vec3 rd )//modified from IQ clouds\n{\n    // background sky         \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );    \n    vec3 col = vec3(0.6,0.6,0.78) - rd.y*0.2*vec3(1.0,0.4,.05) + 0.1*0.5;    \n    col += 0.4*suncol*pow( sun, 8.0 );  \n    // clouds        \n    vec2 res = raymarch( ro, rd);\n    float k = res.x, c=res.y;\n    if(c>.0)\n       col = k>0.? col*.9+(.2+3.5*k)*c*suncol : col*(.9+.8*k)+.1*suncol,\n       col += vec3(0.2,0.08,0.04)*pow( sun, 3.0 );    \n    return vec4( col, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n\n    float zoom=1.;   \n    vec3 ro=1.*vec3(sin(3.*m.x),0.*m.y+2.,cos(3.*m.x));\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,2.,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    fragColor = render( ro, rd );\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dst3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 70, 87, 87, 1265], [1269, 1269, 1326, 1376, 3313]], "test": "untested"}
{"id": "dd33RB", "name": "Periodic quadratic spline", "author": "NinjaKoala", "description": "Simple test of periodic piecewise C1 quadratic interpolation of points.\nYou can move one of the points with mouse.\n\nIf you set a fixed initial slope instead of the periodicity condition, moving the points only affect the neigbouring pieces.", "tags": ["spline", "quadratic", "periodic"], "likes": 5, "viewed": 204, "published": 3, "date": "1677449246", "time_retrieved": "2024-07-30T18:08:07.516107", "image_code": "/*\nSee https://www.shadertoy.com/view/Dd33zs for C2 cubic spline variant\nSee https://www.shadertoy.com/view/dd3Gzl for cubic cardinal spline variant\nSee https://www.shadertoy.com/view/cstGRs for akima spline variant\n*/\n\nconst vec3 dot_col = vec3(0);\nconst vec3 curve_col = vec3(0,1,0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .01;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\n// compute parameters of quadratic polynomial with end points a b and slope ma in a\nvec3 compute_params(vec2 a, vec2 b, float ma){\n\tmat3 matrix = mat3(a.x * a.x, b.x * b.x, 2. * a.x,\n\t                   a.x, b.x, 1.,\n\t                   1., 1., 0.);\n\n\treturn inverse(matrix) * vec3(a.y, b.y, ma);\n}\n\n// compute slope at end of quadratic piece\nfloat slope_at_end(vec3 params, float end){\n\tfloat diff = end * 2. * params.x + params.y;\n\treturn diff;\n}\n\n// approximate distance to quadratic curve between a and b\nfloat quad_distance_approx(vec2 uv, float a, float b, vec3 params){\n\tfloat val = uv.x * (uv.x * params.x + params.y) + params.z;\n\tfloat diff = uv.x * 2. * params.x + params.y;\n\n\tif(uv.x > a && uv.x < b){\n\t\treturn abs(uv.y-val) / length(vec2(diff,1));\n\t}\n\telse{\n\t\treturn 1e38;\n\t}\n}\n\n// compute parameters of the linear function which computes outgoing slope as function of ingoing slope\nvec2 slope_change_func(vec2 a, vec2 b){\n\tmat3 matrix = mat3(a.x * a.x, b.x * b.x, 2. * a.x,\n\t                   a.x, b.x, 1.,\n\t                   1., 1., 0.);\n\n\tmat3 inv = inverse(matrix);\n\n\tvec2 ci = mat2(inv[0].xy,inv[1].xy) * vec2(a.y, b.y);\n\n\t//return vec2(2.*inv[2][0]*b.x + inv[2][1], 2.*ci.x*b.x+ci.y);\n\n\t// the linear part seems to always be -1 (why exactly?)\n\treturn vec2(-1., 2.*ci.x*b.x+ci.y);\n\t\n}\n\n// compute concatenation of affine linear functions\nvec2 concat_lin_func(vec2 f1, vec2 f2){\n\treturn vec2(f1.x*f2.x, f2.x*f1.y + f2.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2. / iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse -= .5;\n    mouse.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n    \n    // choose sensible point for preview\n    if(mouse.x < -.6 || mouse.x > .6){\n        mouse = vec2(-.1,.2);\n    }\n\n    // clamp mouse to allowed area\n\tmouse.x = clamp(mouse.x, -.39, .39);\n\n    // points that are interpolated\n\tvec2 points[] = vec2[](vec2(-.8,-.2),vec2(-.6,.1),vec2(-.4,.2),mouse,vec2(.4,.0),vec2(.6,-.2));\n\n    // repeat curve\n\tuv.x -= points[0].x;\n\tuv.x = mod(uv.x, points[points.length()-1].x - points[0].x);\n\tuv.x += points[0].x;\n\n\tvec3 color = bg_col;\n\n\tfloat curve_dis = 1e38;\n\tfloat point_dis = 1e38;\n\n\tvec2 slope_func = vec2(1,0);\n\n    // compute slope in last point as linear function of the slope in first point\n\tfor(int i=0;i<points.length()-1;i++){\n\t\tvec2 change_func = slope_change_func(points[i], points[i+1]);\n\t\tslope_func = concat_lin_func(slope_func, change_func);\n\t}\n\n\t//float initial_slope = slope_func.y / (1. - slope_func.x);\n\n\t// the linear part seems to always be -1 (why exactly?)\n\tfloat initial_slope = slope_func.y / 2.;\n\t//float initial_slope = 0.;\n\n\tfloat last_slope = initial_slope;\n\n    // render splines and dots\n\tfor(int i=0;i<points.length()-1;i++){\n\t\tpoint_dis = min(point_dis, distance(uv,points[i])-dot_size);\n\n\t\tvec3 params = compute_params(points[i], points[i+1], last_slope);\n\t\tcurve_dis = min(curve_dis, quad_distance_approx(uv, points[i].x, points[i+1].x, params)-line_width);\n\n\t\tlast_slope = slope_at_end(params, points[i+1].x);\n\t}\n\tpoint_dis = min(point_dis, distance(uv,points[points.length()-1])-dot_size);\n\n\tcolor = mix(curve_col, color, smoothstep(-border/2.,border/2.,curve_dis));\n\tcolor = mix(dot_col, color, smoothstep(-border/2.,border/2.,point_dis));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd33RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 484, 530, 530, 698], [700, 743, 786, 786, 848], [850, 909, 976, 976, 1189], [1191, 1295, 1334, 1334, 1703], [1705, 1757, 1796, 1796, 1841]], "test": "untested"}
{"id": "dddGR4", "name": "The dunnos return", "author": "z0rg", "description": "Made live during \"La Fabrique  cookie 05\"", "tags": ["2d", "tunnel", "dunno"], "likes": 18, "viewed": 213, "published": 3, "date": "1677446072", "time_retrieved": "2024-07-30T18:08:08.459584", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Thanks Inigo :)\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n  return length(pa-ba*h);\n}\n#define sat(a) clamp(a, 0., 1.)\n\n\nvec3 drawTheBlobs(vec2 uv, vec3 col, vec3 rgb)\n{\n  vec3 color = col;\n  float an2 = atan(uv.y, uv.x);\n  float rep2 = acos(-1.)*2./15.;\n  float id = floor((an2+rep2*.5)/rep2);\n  float sector2 = mod(an2+rep2*.5,rep2)-rep2*.5;\n  uv = vec2(sin(sector2), cos(sector2))*length(uv);\n  uv.x += sin(uv.y*10.+iTime*3.+id)*.02;\n  uv.y -= (sin(id+iTime)*.5+.5)*.2;\n  float blob = sdSegment(uv, vec2(0.,20.), vec2(0.,.3))-.05;\n  color = mix(color, rgb, 1.-sat(blob*500.));\n  uv.x = abs(uv.x);\n  float blink = sat(sin(iTime*5.)+sin(iTime*3.+id*15.)+sin(iTime*2.+id));\n  float eyes = length((uv-vec2(0.02,0.3))*vec2(1.,1.+blink*5.))-.01;\n  color = mix(color, vec3(1.,1.,0.), 1.-sat(eyes*500.));\n\n    return color;\n}\nmat2 r2d(float a) { float c = cos(a), s =sin(a); return mat2(c, -s, s, c);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.) / iResolution.y;\n    vec2 saveuv = uv;\n    float rep = acos(-1.)*2./mix(1.,8.,sat(sin(iTime*.25)*.5+.5));\n    uv = abs(uv);\n    float an = atan(uv.y, uv.x);\n    float sector = mod(an+rep*.5,rep)-rep*.5;\n    uv = vec2(sin(sector), cos(sector))*length(uv);\n\n    float shape = abs(uv.x)-.05;\n    vec3 color = vec3(0.);\ncolor = vec3(.3,.1,.05)*10.*(1.-sat(length(uv)*7.));\n    uv = saveuv;\n    for (float i = 16.; i > 0.; --i)\n    {\n      float f = i/16.;\n      vec3 rgb = mix(vec3(0.),vec3(.3,.1,.05)*3.,f);\n      color = drawTheBlobs(uv*mix(1.,5.,f)*r2d(i), color, rgb);\n    }\n    color = drawTheBlobs(uv, color, vec3(0.));\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddGR4.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 416, 457, 457, 562], [597, 597, 645, 645, 1296], [1297, 1297, 1316, 1316, 1372], [1373, 1373, 1430, 1430, 2133]], "test": "untested"}
{"id": "ms3GzS", "name": "PopJect", "author": "QuantumSuper", "description": "One codes and sees. \nRaymarched auto-VJ. Daddy in mind of PopBaby.", "tags": ["raymarching", "reflection", "music"], "likes": 1, "viewed": 205, "published": 3, "date": "1677444141", "time_retrieved": "2024-07-30T18:08:09.316293", "image_code": "// PopJect 1.02.230226\n// raymarched auto-vj, daddy of PopBaby\n//\n// - use with music in iChannel0 -\n\n\n#define MAX_STEP 80\n#define MAX_DIST 10.\n#define MIN_DIST .002\n\nfloat aTime; //animation time\nvec3 r; //material reflection color amplitude factor\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //compress sound in iChannel0 to simple frequency-range amplitude estimations \n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    fft.x = step(.91,fft.x); //weaken weaker sounds, hard limit\n}\n\nmat3 rotMY(float rad){ //rotation about y-axis\n    return mat3(cos(rad),0.,-sin(rad),0.,1.,0.,sin(rad),0.,cos(rad));\n}\n\nfloat fitPoly2(float x, vec3 y){ //simple polynom2 fit: expects y at x = {0, .5, 1.}\n    return y.r+(4.*y.g-3.*y.r-y.b)*x+(2.*y.r-4.*y.g+2.*y.b)*x*x;\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nvec3 getCol(int id, float s){ //color definitions\n    vec3 setCol = vec3(1);\n    \n\t//id += 2*int(aTime);\n\t\n\tif (id==0) setCol = vec3( //vaporwave blue shift\n        fitPoly2(s, vec3(9,30,0)), //r\n        fitPoly2(s, vec3(0,29,250)), //g\n        fitPoly2(s, vec3(66,215,253))); //b\n    else if (id==1) setCol = vec3( //vaporwave red shift\n        fitPoly2(s, vec3(132,244,255)),\n        fitPoly2(s, vec3(0,0,148)),\n        fitPoly2(s, vec3(92,204,255)));\n\telse if (id==2) setCol = vec3( //miami green shift\n        fitPoly2(s, vec3(39,26,173)),\n        fitPoly2(s, vec3(153,246,252)),\n        fitPoly2(s, vec3(106,138,248)));\n\telse if (id==3) setCol = vec3( //miami orange shift\n        fitPoly2(s, vec3(250,252,236)),\n        fitPoly2(s, vec3(47,157,212)),\n        fitPoly2(s, vec3(11,0,80)));\n\telse if (id==4) setCol = vec3( //arena red\n        fitPoly2(s, vec3(53,231,237)),\n        fitPoly2(s, vec3(17,15,114)),\n        fitPoly2(s, vec3(18,20,41)));\n\telse if (id==5) setCol = vec3( //arena blue\n        fitPoly2(s, vec3(35,103,178)),\n        fitPoly2(s, vec3(87,211,225)),\n        fitPoly2(s, vec3(97,225,245)));\n   \n    return setCol/255.;\n}\nvec3 getCol(int id){ //overloaded\n    return getCol(id,1.); //return full intensity\n}\n\nfloat sdSphere(vec3 pos, float rad){\n    return length(pos)-rad;\n}\n\nfloat sdBox(vec3 p, vec3 b){ //source: https://iquilezles.org/articles/distfunctions/\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron(vec3 p, float s){ //source: https://iquilezles.org/articles/distfunctions/\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdMorphject(vec3 pos){\n    float aFrac = fract(fract(aTime/4.)+8.*sin(.04*aTime));\n    float r = .06+.12*ffts.w; //size\n    pos *= rotMY(-.139*aTime); //rotate\n    \n    if (aFrac<.33) return sdSphere(pos, r);\n    else if (aFrac<.66) return sdBox(pos, vec3(0.805996*r)); //volume dependend on sphere: .5*(4/3*pi*r^3)^(1/3)\n    else return sdOctahedron(pos, 1.46459*r); //volume dependend on sphere: .5*(4/sqrt(2)*pi*r^3)^(1/3)/sin(pi/4)\n\n}\n\nfloat getDist(vec3 pos){ //also sets r\n    float minDist = MAX_DIST;\n    float myDist;\n\t\n\tmyDist = min(minDist, abs(pos.y-.31)); //ceiling\n\tif (myDist != minDist){ minDist = myDist; r = vec3(.05+.2*smoothstep(.02+.1*ffts.y,.0,abs(pos.x))+.2*fft.x);} //hit\n    \n\tmyDist = min(minDist, abs(abs(pos.x)-.71)); //side walls\n\tif (myDist != minDist){ minDist = myDist; r = vec3(.1+.4*smoothstep(.02+.05*ffts.x,.0,abs(pos.y-.27+clamp(.8*fft.y,.0,.57)))+.2*fft.x);} //hit\n    \n    myDist = min(minDist, sdMorphject(pos)*1.); //central object\n\tif (myDist != minDist){ minDist = myDist; r = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(aTime))),fft.z);} //hit\n\n    return minDist;\n}\n\nvec4 rayMarch(vec3 rPos, vec3 rDir){\n    float rLen = MIN_DIST;\n    float rLenFull = 0.; \n\tfloat rad; vec3 myPos;\n    \n    for (int n=0; n<MAX_STEP; n++){\n        myPos = rPos+rLen*rDir;\n        \n        // Check if reflection and reset march from there\n        if (myPos.y<-.31 && abs(myPos.x)<.7){ //floor reflection, hide corner artifacts\n            rLen = (-.31-rPos.y)/rDir.y; //get length to reflection surface \n            rPos = rPos+rLen*rDir; //set new start pos on reflection surface\n            rLenFull += rLen; //save walked distance\n            rLen = MIN_DIST; //reset current distance to walk from new\n            \n            if (fract(.5*aTime+10.*fract(.01*aTime))<.33){ //racing shapes floor, ref. aFrac from fun sdMorphject\n                if (length(vec2(rPos.x,fract(rPos.z+.5*aTime+.1)-.5))>.15) rDir.y*=-1.; //circles\n            } else if (abs(rPos.x)>.15 || abs(fract(rPos.z+.5*aTime+.1)-.5)>.12) rDir.y*=-1.; //squares    \n        }  \n        \n        rad = getDist(myPos); //get distance sphere\n        rLen += rad; //march\n        if (rLen>MAX_DIST || abs(rad)<MIN_DIST) break;\n    }\n    \n    return vec4(rPos+rLen*rDir, rLenFull+rLen); //true pos, path length\n}\n\n\nvec3 guessNormal(vec3 pos){ //estimate the surface normal at pos\n\tvec2 tangent = vec2(.01*MIN_DIST, 0); //sensitive!\n\t\n\tvec3 normal = getDist(pos) - vec3(\n\t\tgetDist(pos-tangent.xyy),\n\t\tgetDist(pos-tangent.yxy), \n\t\tgetDist(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nvec3 getLight(vec3 pos, vec3 lPos){\n\tvec3 lDir = normalize(lPos - pos);\n\tvec3 surfN = guessNormal(pos);\n    \n\tfloat lOut = clamp(dot(lDir, surfN), 0.0, 1.0); //intensity\n\tlOut *= 1.5*lOut*lOut; //intensity modification\n    \n\tif (rayMarch(pos + 2.0*MIN_DIST*surfN, lDir).w < length(lPos-pos)) lOut *= .2; //shadows are 20%\n    \n\treturn vec3(lOut); //color \n}\nvec3 getLight(vec3 pos, vec2 lPos){//overloaded for vec2, integrate over all z here simplifies to ignore z\n    vec3 lDir = normalize(vec3(lPos-pos.xy,.0)); \n    vec3 surfN = guessNormal(pos);\n    \n    float lOut = clamp(dot(lDir, surfN), .0, 1.); //intensity\n    lOut *= 1.5*lOut*lOut; //intensity correction\n    \n    if (rayMarch(pos + 2.0*MIN_DIST*surfN, lDir).w < length(lPos-pos.xy)) lOut *= .2; //shadows are 20%\n \n\treturn vec3(lOut); //color \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 uv = (2.*fragCoord-iResolution.xy) / maxRes; // -1..1 on longer side\n    float maxX = (maxRes == iResolution.y) ? 1. : iResolution.x/maxRes;\n    aTime = 2.133333*iTime;\n\tvec3 col = vec3(0);\n    compressFft(); //initializes fft, ffts\n    \n    // Camera\n    float cZoom = 1.1; uv *= cZoom; //zoom    \n    vec3 cPos = rotMY(.15*sin(aTime/8.))*vec3(.0,.0,-.7); //move\n\tvec3 cDir = rotMY(.15*sin(aTime/8.))*normalize(vec3(1.5*uv.xy,1.)); //rotate\n    \n    // Depth calculation\n    vec4 myRay = rayMarch(cPos,cDir); // cf. The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n    \n    // Lights\n\tvec3 myR = r; //reflectivity of hit object, ?is there a better way of value transfer than global var?\n    myR /= 1.*myRay.w*myRay.w; //haze\n    vec3 col1 = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(aTime/16.))), ffts.x);\n    vec3 col2 = getCol(int(2.*mod(floor(.0156*aTime),3.)+floor(2.*fract(-aTime/16.))), ffts.y);\n    vec2 lPos1 = vec2(.69-.02*ffts.x,.27-clamp(.8*fft.y,.0,.57));\n    \n    col += myR*.3*fft.x*getLight(myRay.xyz, cPos); //flashing light at cam pos   \n    col += myR*col1*getLight(myRay.xyz, lPos1); //right light ray\n    col += myR*col1*getLight(myRay.xyz, lPos1*vec2(-1,1)); //left light ray\n    col += myR*col2*getLight(myRay.xyz, vec2(.0,.29-.04*ffts.y)); //center light ray\n\t\n\t// Misc\n\tif (abs(myRay.x)>.7 && abs(fract(2.*myRay.y-.5))<.8 && abs(fract(.5*(myRay.z+aTime-myRay.y)))<.9) col *= ffts.z*(myRay.y+.6); //racing stripes\n    col *= .92+(1.+fft.w)*.16*vec3(hash21(floor(300.12*uv+42.)+fract(aTime))); //noise\n\tcol += fft.x*.03/abs(abs(uv.x)-maxX*cZoom); //white side bars\n\tcol *= col; //light falloff modifier\n    \n    // Utility\n    //col = .6*vec3(myRay.w); //depth map\n    //col = vec3(hash21(floor(300.12*uv+42.)+fract(aTime))); //pure noise\n\t//col = (uv.y<0.) ? getCol(2*int(mod(floor(.1*aTime),3.)),fract(.5*aTime)) : getCol(1+2*int(mod(floor(.1*aTime),3.)),fract(.5*aTime)); //color sets\n    \n    // Output\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3GzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 320, 399, 1446], [1448, 1448, 1470, 1494, 1566], [1568, 1568, 1600, 1652, 1719], [1721, 1721, 1742, 1812, 1905], [1907, 1907, 1936, 1956, 3052], [3053, 3053, 3073, 3086, 3138], [3140, 3140, 3176, 3176, 3206], [3208, 3208, 3236, 3293, 3380], [3382, 3382, 3418, 3475, 3528], [3530, 3530, 3558, 3558, 3974], [3976, 3976, 4000, 4014, 4658], [4660, 4660, 4696, 4696, 5854], [5857, 5857, 5884, 5921, 6132], [6134, 6134, 6169, 6169, 6491], [6492, 6492, 6527, 6598, 6942], [6944, 6944, 7000, 7000, 9102]], "test": "untested"}
{"id": "dsc3RS", "name": "We need an expert.. Dave Hoskins", "author": "mrange", "description": "CC0: We need an expert.. Dave Hoskins\nThanks Dave_Hoskins for fixing the shader\n", "tags": ["grid"], "likes": 47, "viewed": 786, "published": 3, "date": "1677444021", "time_retrieved": "2024-07-30T18:08:10.170011", "image_code": "// CC0: We need an expert.. Dave Hoskins\n//  Thanks Dave_Hoskins for fixing the shader\n// \n//  Took the previous shader and put some music to it. Music can sometimes be a bit finicky to get playing\n//  Usually it's the browser that prevents because the user hasn't interacted with the play controls\n//  So fiddling with stop and start usually works for me.\n\n//  Inspired by this tweet: https://twitter.com/lainmell/status/1629414269019357184?s=20\n//  Very different from how I usually do stuff so wanted to make a try for something \n//  that looked like it.\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 LightDir0  = normalize(vec3(2.0, 2.0, 1.0));\nconst int   MaxIter   = 40;\nconst float Bottom    = 0.0;\nconst float MinHeight = 0.25;\nconst float MaxHeight = 7.0;\nconst float sz        = 0.475;\nconst float eps       = 1E-3;\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nfloat select(vec2 p) {\n  p *= 0.00125;\n  float h = texture(iChannel1, p).x;\n  h -= 0.5;\n  h *= 2.0;\n  return h;\n}\n\nvec3 baseCol(vec2 p) {\n  float h = select(p);\n  vec3 sc = h > 0.0 ? vec3(0.1) : vec3(1.0, 0.0, 0.0);\n  return mix(vec3(1.0), sc, smoothstep(0.33, 0.66, abs(h))); \n}\n\nfloat height(vec2 p) {\n  float s = select(p);\n//  p += TIME*0.5;\n\n  float w = sin(0.1*(p.x+p.y)+0.3*TIME);\n//  w = 1.0;\n  p *= 0.001;\n  float h = texture(iChannel1, p).x;\n//  h += 0.5*texture(iChannel1, 2.0*p).x;\n  h *= h;\n  h *= smoothstep(-2.0, 0.9, w);\n  h = smoothstep(0.0, 0.75, h);\n  float fs = smoothstep(0.33, 0.66, abs(s));\n  vec2 fp = 20.0*p;\n  float fft = texture(iChannel2, vec2(0.1+0.8*fract(fp.x+0.25*fp.y+0.25*sign(s)), 0.25)).x;\n  fft -= 0.3;\n  fft = max(fft, 0.0);\n  fft *= fft;\n//  fft *= fft;\n  fft = 1.25*smoothstep(0.0, 0.28, fft);\n  h = mix(h, fft, 0.8*fs);\n  h = clamp(h, 0.0, 1.0);\n  return mix(MinHeight, MaxHeight, h)*0.5;\n}\n\nfloat cellTrace(\n    vec3      ro\n  , vec3      rd\n  , float     near\n  , float     far\n  , out int   iter\n  , out vec2  cell\n  , out vec2  boxi\n  , out vec3  boxn\n  ) {\n  vec2 rd2  = rd.xz;\n  vec2 ird2 = 1.0/rd.xz;\n  vec2 stp  = step(vec2(0.0), rd2);\n\n  float ct = near;\n  iter = MaxIter;\n  vec2 bi = vec2(-1.0);\n  vec3 bn = vec3(0.0);\n  vec2 np2 = vec2(0.0);\n  float ft = far;\n\n  for (int i = 0; i < MaxIter; ++i) {\n    vec3 cp = ro+rd*ct;\n    np2 = floor(cp.xz);\n    float h = height(np2);\n    vec3 bdim = vec3(sz, h, sz);\n    vec3 coff = vec3(np2.x+0.5, h, np2.y+0.5);\n    vec3 bro = ro-coff;\n    bi = rayBox(bro, rd, bdim, bn);\n\n    if (bi.x> 0.0) {\n      float bt = bi.x;\n      if (bt >= far) {\n        break;\n      }\n      ft = bt;\n      iter = i;\n      break;\n    }\n\n    // Step to next cell\n    vec2 dif = np2 - cp.xz;\n    dif += stp;\n    dif *= ird2;\n    float dt = min(dif.x, dif.y);\n    ct += dt+eps;\n\n    if (ct >= far) {\n      break;\n    }\n  }\n  cell = np2;\n  boxi = bi;\n  boxn = bn;\n  return ft;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 sky = vec3(1.0);\n\n  float skyt = 1E3;\n  float bottom  = -(ro.y-Bottom)/rd.y;  \n  float near    = -(ro.y-(MaxHeight))/rd.y;  \n  float far     = bottom >= 0.0 ? bottom : skyt;\n\n  int iter;\n  vec2 cell;\n  vec2 boxi;\n  vec3 boxn;\n  float ct = cellTrace(ro, rd, near, far, iter, cell, boxi, boxn);\n  if (ct == skyt) {\n    return sky;\n  }\n\n  vec3 p = ro + ct*rd;\n\n  int siter;\n  vec2 scell;\n  vec2 sboxi;\n  vec3 sboxn;\n  float sfar  = -(p.y-MaxHeight)/LightDir0.y;  \n  float sct   = cellTrace((p-2.0*eps*rd), LightDir0, eps, sfar, siter, scell, sboxi, sboxn);\n\n  vec3 n = vec3(0.0, 1.0, 0.0);\n  vec3 bcol = vec3(0.5);\n\n  if (iter < MaxIter) {\n    n = boxn;\n    bcol = baseCol(cell);\n    bcol *= smoothstep(0.0, 0.1, boxi.y-boxi.x);\n  }\n  float dif0 = max(dot(n, LightDir0), 0.0);\n  dif0 = sqrt(dif0);\n  float sf = siter < MaxIter ? tanh_approx(0.066*sct) : 1.0; \n  bcol *= mix(0.3, 1.0, dif0*sf);\n\n  vec3 col = bcol;\n  col = mix(col, sky, 1.0-exp(-0.125*max(ct-50.0, 0.0)));\n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = tan(TAU/6.0);\n  \n  vec3 ro = 4.0*vec3(0.0, 4.0, -4.);\n  float off = 2.0*TIME;\n  ro.z += off; \n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ww = normalize(vec3(0.5,-1., 1.0));\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  col -= 0.1;\n  col *= 1.1;\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);;  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32521, "src": "https://soundcloud.com/gmm/ugress-loungemeister?si=8d8fab97f14f4fc7b5a11fbf145be240&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 1100, 1128, 1194, 1270], [1272, 1394, 1461, 1461, 2036], [2038, 2038, 2060, 2060, 2151], [2153, 2153, 2175, 2175, 2317], [2319, 2319, 2341, 2341, 2969], [2971, 2971, 3140, 3140, 3983], [3985, 3985, 4016, 4016, 5011], [5013, 5013, 5043, 5043, 5482], [5484, 5484, 5539, 5539, 5714]], "test": "untested"}
{"id": "msc3RS", "name": "Bending space", "author": "oemfoe", "description": "bending space", "tags": ["bendingspace"], "likes": 1, "viewed": 152, "published": 3, "date": "1677443462", "time_retrieved": "2024-07-30T18:08:11.069605", "image_code": "#define TWOPI 6.28318530718\n\n\nvec2 toPolar(vec2 cartesian){\n\tfloat distance = length(cartesian);\n\tfloat angle = atan(cartesian.y, cartesian.x);\n\treturn vec2(angle / TWOPI, distance);\n}\n\nvec2 rotate(vec2 uv, float phi) {\n    return vec2(\n        uv.x * cos(phi) + uv.y * sin(phi),\n        -uv.x * sin(phi) + uv.y * cos(phi)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.y /= aspect;\n    \n    vec2 uv0 = uv;\n    \n \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //////////////////////////////////////////////\n    \n    \n    \n    \n    \n    \n    \n    \n    // zoomen\n    uv *= 1. + (1. + sin(iTime)) / 2.0;\n    \n    \n    // roteren\n    float phi = iTime / 4.;\n    uv = rotate(uv, phi);\n    \n    // Verplaatsen\n    uv.x += sin(iTime);\n    //uv.y += cos(iTime) / aspect;\n    \n    // Polaire coordinaten\n    //uv = toPolar(uv);\n    \n    // krom maken\n    uv.y += 0.05 * sin(uv.x * 5.);\n    \n    // Herhalen\n    //uv.x = mod(uv.x + 0.5, 1.) - 0.5;\n    //uv.y = mod(uv.y + 0.5, 1.) - 0.5;\n    uv = mod(uv + 0.5, 1.) - 0.5;\n    \n    \n    \n    //////////////////////////////////////////////\n    // Output to screen\n    //vec3 col = vec3(uv.x, uv.y, 0.0);\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col, 1.0);\n    \n    if (uv.x >= -1.0 && uv.x <= 1.0 && uv.y >= -1.0 && uv.y <= 1.0)\n    {\n        if (mod(uv.x, 0.1) < 0.01 || mod(uv.y, 0.1) < 0.01)\n            fragColor = vec4(0.);\n    }\n    \n    //if (mod(uv.x, 1. / 8.) > 0.05 && mod(uv.y, 0.1) < 0.04)\n    //    fragColor = vec4(1.);\n    \n    //uv = uv0;\n    \n    // schijf\n    float dtc = length(uv);\n    if (dtc < 0.5 + 0.5 * sin(iTime)) {\n        fragColor = vec4(1., 0., 0., 1.);\n    }\n    \n    //uv.x *= 2.;\n    // vierkant\n    if (max(abs(uv.x), abs(uv.y)) < 0.2) {\n        if (max(abs(uv.x), abs(uv.y)) > 0.175)\n        fragColor = vec4(1.);\n    }\n    \n    \n    // lijn\n    if (uv.y > 0.25 && uv.y < 0.26)\n        fragColor = vec4(0., 1., 0., 1.);\n    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 59, 59, 184], [186, 186, 219, 219, 331], [333, 333, 390, 440, 2179]], "test": "untested"}
{"id": "mscGRS", "name": "Twists Wallpaper", "author": "fishy", "description": "A simple tile-based shader", "tags": ["sdf"], "likes": 9, "viewed": 132, "published": 3, "date": "1677440361", "time_retrieved": "2024-07-30T18:08:11.902379", "image_code": "#define time iDate.w\n\n#define TENSION 0.8\n\n#define PI 3.1415926535\n\nvec3 hue(float x)\n{\n    return sin(2.*PI*(x+vec3(0, 0.33, 0.66)))*0.5+0.5;\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat map(vec2 uv)\n{\n    uv.x += round(hash21(floor(uv.yy)))*0.5;\n    vec2 fp = floor(uv);\n    uv = abs(fract(uv)-0.5);\n    vec2 scale = vec2(0.25, 0.5);\n    return (hash21(fp) < 0.3? sdCubicBezier(uv, vec2(-1)*scale, vec2(-1, -1.+TENSION)*scale, vec2(1, 1.-TENSION)*scale, vec2(1)*scale, 20.) :\n                              abs(uv.x-scale.x))-0.03;\n    //return round(hash21(floor(uv.yy)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n\n    vec3 col = hue(fract(time/86400./2.))*(0.2+smoothstep(px*3., -px*3., map(uv*2.25+iDate.w*vec2(0, 0.2))));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 144], [146, 146, 168, 168, 285], [287, 287, 339, 339, 458], [460, 460, 535, 535, 860], [862, 862, 882, 882, 1256], [1258, 1258, 1315, 1365, 1702]], "test": "untested"}
{"id": "csc3zB", "name": "Twists", "author": "fishy", "description": "A simple tile-based shader", "tags": ["sdf"], "likes": 5, "viewed": 144, "published": 3, "date": "1677436947", "time_retrieved": "2024-07-30T18:08:12.779035", "image_code": "#define TENSION (tanh(sin(iTime*0.75)*5.)*0.5+0.5)\n\n#define PI 3.1415926535\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 s, vec2 c1, vec2 c2, vec2 e, float res)\n{\n    float r = 1e20;\n    float st = 1./res;\n    vec2 prev = s;\n    for(float i = 0.; i < 1.; i += st)\n    {\n        float j = 1.-i;\n        vec2 point = j*j*j*s+3.*j*j*i*c1+3.*j*i*i*c2+i*i*i*e;\n        r = min(r, sdSegment(uv, prev, point));\n        prev = point;\n    }\n    r = min(r, sdSegment(uv, prev, e));\n    return r;\n}\n\nfloat map(vec2 uv)\n{\n    vec2 fp = floor(uv);\n    uv = abs(fract(uv)-0.5);\n    vec2 scale = vec2(0.25, 0.5);\n    return (hash21(fp) < 0.2? sdCubicBezier(uv, vec2(-1)*scale, vec2(-1, -1.+TENSION)*scale, vec2(1, 1.-TENSION)*scale, vec2(1)*scale, 20.) :\n                              abs(uv.x-scale.x))-0.03;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n\n    vec3 col = vec3(0.259,0.580,0.976)*(0.2+smoothstep(px*3., -px*3., map(uv*2.+iTime*0.2)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csc3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 99, 99, 216], [218, 218, 270, 270, 389], [391, 391, 466, 466, 791], [793, 793, 813, 813, 1100], [1102, 1102, 1159, 1209, 1530]], "test": "untested"}
{"id": "DscGzB", "name": "Hard light grid tracer", "author": "mrange", "description": "CC0: Hard light grid tracer\nInspired by this tweet: https://twitter.com/lainmell/status/1629414269019357184?s=20\nVery different from how I usually do stuff so wanted to make a try for something \nthat looked like it.\n", "tags": ["grid"], "likes": 29, "viewed": 371, "published": 3, "date": "1677432152", "time_retrieved": "2024-07-30T18:08:13.629760", "image_code": "// CC0: Hard light grid tracer\n//  Inspired by this tweet: https://twitter.com/lainmell/status/1629414269019357184?s=20\n//  Very different from how I usually do stuff so wanted to make a try for something \n//  that looked like it.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 LightDir0  = normalize(vec3(2.0, 2.0, 1.0));\nconst int   MaxIter   = 40;\nconst float Bottom    = 0.0;\nconst float MinHeight = 0.25;\nconst float MaxHeight = 7.0;\nconst float sz        = 0.475;\nconst float eps       = 1E-3;\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec3 baseCol(vec2 p) {\n  p *= 0.00125;\n  float h = texture(iChannel1, p).x;\n  h -= 0.5;\n  h *= 2.0;\n  vec3 sc = h > 0.0 ? vec3(0.1) : vec3(1.0, 0.0, 0.0);\n  return mix(vec3(1.0), sc, smoothstep(0.33, 0.66, abs(h))); \n}\n\nfloat height(vec2 p) {\n//  p += TIME*0.5;\n  float w = sin(0.1*(p.x+p.y)+0.3*TIME);\n  p *= 0.001;\n  float h = texture(iChannel1, p).x;\n//  h += 0.5*texture(iChannel1, 2.0*p).x;\n  h *= h;\n  h *= smoothstep(-2.0, 0.9, w);\n  h = smoothstep(0.0, 0.75, h);\n  return mix(MinHeight, MaxHeight, h)*0.5;\n}\n\nfloat cellTrace(\n    vec3      ro\n  , vec3      rd\n  , float     near\n  , float     far\n  , out int   iter\n  , out vec2  cell\n  , out vec2  boxi\n  , out vec3  boxn\n  ) {\n  vec2 rd2  = rd.xz;\n  vec2 ird2 = 1.0/rd.xz;\n  vec2 stp  = step(vec2(0.0), rd2);\n\n  float ct = near;\n  iter = MaxIter;\n  vec2 bi = vec2(-1.0);\n  vec3 bn = vec3(0.0);\n  vec2 np2 = vec2(0.0);\n  float ft = far;\n\n  for (int i; i < MaxIter; ++i) {\n    vec3 cp = ro+rd*ct;\n    np2 = floor(cp.xz);\n    float h = height(np2);\n    vec3 bdim = vec3(sz, h, sz);\n    vec3 coff = vec3(np2.x+0.5, h, np2.y+0.5);\n    vec3 bro = ro-coff;\n    bi = rayBox(bro, rd, bdim, bn);\n\n    if (bi.x> 0.0) {\n      vec3 bp = bro+rd*bi.x+coff;\n      float bt = distance(bp,ro);\n      if (bt >= far) {\n        break;\n      }\n      ft = bt;\n      iter = i;\n      break;\n    }\n\n    // Step to next cell\n    vec2 dif = np2 - cp.xz;\n    dif += stp;\n    dif *= ird2;\n    float dt = min(dif.x, dif.y);\n    ct += dt+eps;\n\n    if (ct >= far) {\n      break;\n    }\n  }\n  cell = np2;\n  boxi = bi;\n  boxn = bn;\n  return ft;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 sky = vec3(1.0);\n\n  float skyt = 1E3;\n  float bottom  = -(ro.y-Bottom)/rd.y;  \n  float near    = -(ro.y-(MaxHeight))/rd.y;  \n  float far     = bottom >= 0.0 ? bottom : skyt;\n\n  int iter;\n  vec2 cell;\n  vec2 boxi;\n  vec3 boxn;\n  float ct = cellTrace(ro, rd, near, far, iter, cell, boxi, boxn);\n  if (ct == skyt) {\n    return sky;\n  }\n\n  vec3 p = ro + ct*rd;\n\n  int siter;\n  vec2 scell;\n  vec2 sboxi;\n  vec3 sboxn;\n  float sfar  = -(p.y-MaxHeight)/LightDir0.y;  \n  float sct   = cellTrace((p-2.0*eps*rd), LightDir0, eps, sfar, siter, scell, sboxi, sboxn);\n\n  vec3 n = vec3(0.0, 1.0, 0.0);\n  vec3 bcol = vec3(0.5);\n\n  if (iter < MaxIter) {\n    n = boxn;\n    bcol = baseCol(cell);\n    bcol *= smoothstep(0.0, 0.1, boxi.y-boxi.x);\n  }\n  float dif0 = max(dot(n, LightDir0), 0.0);\n  dif0 = sqrt(dif0);\n  float sf = siter < MaxIter ? tanh_approx(0.066*sct) : 1.0; \n  bcol *= mix(0.3, 1.0, dif0*sf);\n\n  vec3 col = bcol;\n  col = mix(col, sky, 1.0-exp(-0.125*max(ct-50.0, 0.0)));\n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = tan(TAU/6.0);\n  \n  vec3 ro = 4.0*vec3(0.0, 4.0, -4.);\n  float off = 2.0*TIME;\n  ro.z += off; \n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ww = normalize(vec3(0.5,-1., 1.0));\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  col -= 0.1;\n  col *= 1.1;\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);;  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[644, 772, 800, 866, 942], [944, 1066, 1133, 1133, 1708], [1710, 1710, 1732, 1732, 1928], [1930, 1930, 1952, 1971, 2225], [2227, 2227, 2396, 2396, 3280], [3282, 3282, 3313, 3313, 4308], [4310, 4310, 4340, 4340, 4779], [4781, 4781, 4836, 4836, 5011]], "test": "untested"}
{"id": "cd33R8", "name": "Cat from SDF primitives", "author": "spacecat", "description": ":3", "tags": ["sdf", "cat"], "likes": 12, "viewed": 178, "published": 3, "date": "1677430750", "time_retrieved": "2024-07-30T18:08:14.401697", "image_code": "#define PI 3.14159\n\n\nvec2 rotate2D( in vec2 uv, in float angle )\n{\n    mat2 transform = mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n    return uv * transform;\n}\n\n\n/* Primitive SDFs by iq https://iquilezles.org/articles/distfunctions2d/ */\n\nfloat sdCircle( in vec2 p, in float r, in vec2 origin )\n{\n    return length(p - origin) - r;\n}\n\nfloat sdTriangle( in vec2 p, in float size, in float rotation, in vec2 origin )\n{\n    // Transformations\n    p = rotate2D(p, rotation);\n    p -= origin;\n    p /= size;\n    \n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n \n    \n    return -length(p)*sign(p.y) * size;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\n/* Bound SDF for a cat's face from primitives */\nfloat sdCat(in vec2 uv)\n{\n    float head = sdCircle(uv, 0.36, vec2(0.0, -0.1));\n    float earLeft = sdTriangle(uv, 0.2, -0.6, vec2(-0.1, 0.29));\n    float earRight = sdTriangle(uv, 0.2, 0.6, vec2(0.1, 0.29));\n    float nose = sdTriangle(uv, 0.03, PI, vec2(0.0, 0.2));\n    float eyeLeft = max(\n            sdCircle(uv, 0.045, vec2(0.1, -0.09)),\n            -sdCircle(uv, 0.009, vec2(0.095, -0.082))\n    );\n    float eyeRight = max(\n            sdCircle(uv, 0.045, vec2(-0.1, -0.09)),\n            -sdCircle(uv, 0.009, vec2(-0.105, -0.082))\n    );\n    float mouthLeft = sdBezier(uv, vec2(0.0,-0.23), vec2(-0.05,-0.33), vec2(-0.1,-0.28));\n    float mouthRight = sdBezier(uv, vec2(0.0,-0.23), vec2(0.05,-0.33), vec2(0.1,-0.28));\n    \n    // Put it all together\n    float cat = min(head, min(earLeft, earRight));\n    cat = max(cat, -nose);\n    cat = max(max(cat, -eyeLeft), -eyeRight);\n    cat = max(max(cat, -mouthLeft), -mouthRight);\n    \n    // Whiskers\n    for (float y = -0.22; y <= -0.17; y += 0.02) {\n        float whiskerLeft = sdBezier(uv, vec2(-0.1, y), vec2(-0.25, y + 0.03),\n                vec2(-0.45, y - 0.9 * (-0.15 - y)));\n        float whiskerRight = sdBezier(uv, vec2(0.1, y), vec2(0.25, y + 0.03),\n                vec2(0.45, y - 0.9 * (-0.15 - y)));\n        \n        // The whiskers being both outside and inside the face makes this weird...\n        cat = cat > 0.0 ? min(cat, whiskerLeft) : max(cat, -whiskerLeft);\n        cat = cat > 0.0 ? min(cat, whiskerRight) : max(cat, -whiskerRight);\n    }\n    \n    return cat;\n}\n\n/* Version without details */\nfloat sdSimpleCat(vec2 uv)\n{\n    float head = sdCircle(uv, 0.36, vec2(0.0, -0.1));\n    float earLeft = sdTriangle(uv, 0.2, -0.6, vec2(-0.1, 0.29));\n    float earRight = sdTriangle(uv, 0.2, 0.6, vec2(0.1, 0.29));\n    \n    float cat = min(head, min(earLeft, earRight));\n    \n    return cat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Center and correct for aspect ratio\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.y -= 0.03;\n\n    float cat = sdCat(rotate2D(uv, sin(iTime) / 8.0));\n    float outline = 1.0 - smoothstep(0.002, 0.006, abs(cat));\n    float inside = step(0.0, -cat);\n\n\t// coloring\n    /*float d = cat*2.0;\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );*/\n    \n    vec3 col = vec3(0.0, 0.0, 0.1);\n    \n    vec2 bgPatternUV = fract(rotate2D(uv + iTime * 0.1, -0.4) * 10.0) - 0.5;\n    float bgPattern = smoothstep(-0.01, 0.01, sdSimpleCat(bgPatternUV));\n    vec3 bgColor = mix(vec3(uv * 0.2, 0.2), vec3(uv * 0.6 + 0.4, 1.0), bgPattern);\n    col = mix(col, bgColor, clamp(cat * 5.0, 0.0, 1.0));\n    \n    vec3 insideColor = vec3(uv * 0.8 + 0.8, 1.0);\n    col = mix(col, insideColor, inside);\n    \n    vec3 lineColor = vec3(uv * 1.8 + 0.6, 1.0);\n    col = mix(col, lineColor, outline);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd33R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 66, 66, 193], [273, 273, 330, 330, 367], [369, 369, 450, 473, 767], [769, 769, 794, 794, 813], [815, 815, 879, 879, 1917], [1920, 1969, 1994, 1994, 3503], [3505, 3535, 3563, 3563, 3825], [3828, 3828, 3885, 3935, 5078]], "test": "untested"}
{"id": "csc3RS", "name": "Shallow Water Equations solver", "author": "BlooD2oo1", "description": "Solver for the Shallow Water Equations with height field.\nBased on https://matthias-research.github.io/pages/publications/hfFluid.pdf\nTerrain depth based on Inigo's simplex noise.\nReset button at the bottom left.\n", "tags": ["simulation", "swe", "navierstokes", "ns", "shallowwater", "cunami"], "likes": 38, "viewed": 1367, "published": 3, "date": "1677430216", "time_retrieved": "2024-07-30T18:08:15.401024", "image_code": "const vec3 vWaterFogColor = Gamma( vec3( 0.9, 0.4, 0.3 ) ) * 16.0;\nconst vec3 vFoamColor = Gamma( vec3( 0.9, 0.9, 0.85 ) );\nconst vec3 vSkyColor = Gamma( vec3( 0.01, 0.4, 0.8 ) );\nconst vec3 vSunColor = Gamma( vec3( 1.0, 0.8, 0.5 ) );\nconst vec3 vTerrainColor0 = Gamma( vec3(1.0,0.88,0.7)*0.8 );\nconst vec3 vTerrainColor1 = Gamma( vec3(0.9,0.9,0.8)*0.9 );\n#define vLightDir normalize( vec3( 0.0, 0.21, -1.0 ) )\nconst vec3 vLookDir = vec3( 0.0, 0.0, -1.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 vTexC = textureLod(iChannel0,uv,0.0);\n    \n    vec4 vTexL = textureLodOffset(iChannel0,uv, 0.0, ivec2(-1,0));\n    vec4 vTexR = textureLodOffset(iChannel0,uv, 0.0, ivec2(1,0));\n    vec4 vTexT = textureLodOffset(iChannel0,uv, 0.0, ivec2(0,-1));\n    vec4 vTexB = textureLodOffset(iChannel0,uv, 0.0, ivec2(0,1));\n    \n    float hC = vTexC.z+vTexC.w;\n\tfloat hL = vTexL.z+vTexL.w;\n\tfloat hR = vTexR.z+vTexR.w;\n\tfloat hT = vTexT.z+vTexT.w;\n\tfloat hB = vTexB.z+vTexB.w;\n    \n    float fMinZ = min( min( min( min( vTexC.z, vTexL.z ), vTexR.z ), vTexT.z ), vTexB.z );\n    float fMaxZ = max( max( max( max( vTexC.z, vTexL.z ), vTexR.z ), vTexT.z ), vTexB.z );\n    \n    float fAlpha = min(1.0,vTexC.z*130.0);\n    \n    vec3 vNormal = vec3( ( hR - hL )*g_fGridSizeInMeter, ( hB - hT )*g_fGridSizeInMeter, 2.0 );\n    vNormal = normalize( vNormal );\n    vec2 vTerrainUV = uv;\n    vec2 vRefractUV = vTerrainUV - vNormal.xy*vTexC.z*6.0;\n    \n    vec3 vTerrainColor = mix( vTerrainColor0, vTerrainColor1, SampleColor( iChannel1, vRefractUV, iResolution.xy ) );\n    vTerrainColor *= 1.0-min(1.0,fMaxZ*80.0)*0.2;\n    vec3 vRefract = vTerrainColor;\n    vec4 vTexCRefract = textureLod(iChannel0,vRefractUV,0.0);\n    vTexCRefract = mix( vTexC, textureLod(iChannel0,vRefractUV,0.0), min( vTexCRefract.z*1.0, 1.0 ) );\n    vec3 vFog = 1.0 - exp( -vTexCRefract.zzz/(vNormal.z*0.9999)*vWaterFogColor );\n    vRefract *= ( 1.0 - vFog );\n    \n\n    \n    vec3 vReflect = ( pow( ( 1.0 - pow( vNormal.z*0.9999999, 100.0 ) ), 0.4 ) )* 1.1 * vSkyColor;\n    //vec3 vReflect = ( 1.0-pow( ( 1.0 - pow( vNormal.z*0.9999999, 1000.0 ) ), 0.1 ) )* 0.3 * vSkyColor;\n    vec3 vHalfVec = normalize( vLookDir + vLightDir );\n    float fHdotN = max( 0.0, dot( -vHalfVec, vNormal ) );\n    vReflect += pow( fHdotN , 1200.0 ) * 20.0 * vSunColor;\n    vReflect += pow( fHdotN , 180.0 ) * 0.5 * vSkyColor;\n    \n    float fLight = pow( max( dot( vNormal, -vLightDir ), 0.0 ), 10.0 );    \n    \n    \n    float fFoam = max(0.0,1.0-fMinZ*8.0)*0.3;\n    \n    vec3 vWater = mix( vRefract*fLight + vReflect, vFoamColor, vec3(fFoam,fFoam,fFoam) );    \n    //vWater = vReflect;\n    \n    \n    \n    vec3 vOut = mix( vTerrainColor*fLight, vWater, vec3(fAlpha) );\n\n    /*if ( iResolution.x > 1180.0 )\n    {\n        if ( uv.y < 0.3 ) vOut = mix( vec3(vTexC.w*0.1), vec3( vTexC.xy+0.5, 0.0 ), vec3(fAlpha) );\n        vOut *= smoothstep( 0.0, 0.004, abs(uv.y-0.3) );\n    }*/   \n    \n    //vOut = vTerrainColor;\n    \n    // button!\n    if ( fragCoord.x < 40.0 && fragCoord.y < 40.0 ) vOut = mod( iTime, 1.0 ) < 0.5 ? vec3( 0.4, 0.2, 0.2 ) : vec3( 0.3, 0.2, 0.1 );\n\n    \n    \n    fragColor = vec4( DeGamma( vOut ), 1.0 );\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Velocity Advection\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);    \n    vec4 vTexC = texelFetch(iChannel0,tc,0);    \n\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec2 vOffset = vTexC.xy/iResolution.xy * g_fAdvectSpeed * g_fElapsedTimeInSec / g_fGridSizeInMeter;\n    float dt = -g_fAdvectSpeed * g_fElapsedTimeInSec / g_fGridSizeInMeter;\n    vec2 v1 = vTexC.xy;\n    vec2 v2 = textureLod(iChannel0, uv - ( 0.5 * v1 * dt ) / iResolution.xy, 0.0 ).xy;\n    vec2 v3 = textureLod(iChannel0, uv - ( 0.5 * v2 * dt ) / iResolution.xy, 0.0 ).xy;\n    vec2 v4 = textureLod(iChannel0, uv - ( v3 * dt ) / iResolution.xy, 0.0 ).xy;\n    vec2 v = (1.0 * v1 + 2.0 * v2 + 2.0 * v3 + 1.0 * v4) / 6.0;\n    \n    \n    vec4 vTex = textureLod(iChannel0,uv + ( v * dt ) / iResolution.xy,0.0);\n\n    fragColor = vTexC;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Height Integration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   ivec2 tc = ivec2(fragCoord);    \n    vec4 vTexC = texelFetch(iChannel0,tc,0);    \n    vec4 vTexL = ( tc.x > 0 ) ?                    texelFetchOffset(iChannel0,tc, 0, ivec2(-1,0)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    vec4 vTexR = ( tc.x < int(iResolution.x)-1 ) ? texelFetchOffset(iChannel0,tc, 0, ivec2(1,0)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    vec4 vTexT = ( tc.y > 0 ) ?                    texelFetchOffset(iChannel0,tc, 0, ivec2(0,-1)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    vec4 vTexB = ( tc.y < int(iResolution.y)-1 ) ? texelFetchOffset(iChannel0,tc, 0, ivec2(0,1)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 vOffset = vTexC.xy/iResolution.xy * g_fAdvectSpeed * g_fElapsedTimeInSec / g_fGridSizeInMeter;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 vTex = textureLod(iChannel0,uv+vOffset,0.0);\n    \n    if ( vTexC.x == 0.0 ) vTex.xyz = vTexC.xyz;\n\tif ( vTexC.y == 0.0 ) vTex.xyz = vTexC.xyz;\n    \n    vTex.zw = vTexC.zw;\n    \n    float fxL = vTexL.x;\n\tfloat fxR = vTexC.x;\t\n\tfloat fyT = vTexT.y;\n\tfloat fyB = vTexC.y;\n    \n    // We also found that it yields a more stable simulation:\n\tfloat hL = ( vTexL.x >= 0.0 ) ? vTexL.z : vTexC.z;\n\tfloat hR = ( vTexC.x <= 0.0 ) ? vTexR.z : vTexC.z;\n\tfloat hT = ( vTexT.y >= 0.0 ) ? vTexT.z : vTexC.z;\n\tfloat hB = ( vTexC.y <= 0.0 ) ? vTexB.z : vTexC.z;\n    \n   \t{\n\t\t// 2.2. Overshooting Reduction\n\t\tfloat beta = 2.0;\n\t\tfloat hAvgMax = beta * g_fGridSizeInMeter / ( g_fG * (g_fElapsedTimeInSec) );\n\t\tfloat hAdj = max( 0.0, (vTexL.z+vTexR.z+vTexT.z+vTexB.z)/4.0 - hAvgMax );\n\n\t\thL -= hAdj;\n\t\thR -= hAdj;\n\t\thT -= hAdj;\n\t\thB -= hAdj;\n\t}\n    \n    float dH = -( (hR*fxR-hL*fxL) / g_fGridSizeInMeter + (hB*fyB-hT*fyT) / g_fGridSizeInMeter );\n\n\tvTexC.z += dH * (g_fElapsedTimeInSec);\n\n    fragColor = vTexC;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// Velocity Integration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);    \n    vec4 vTexC = texelFetch(iChannel0,tc,0);    \n    //vec4 vTexL = ( tc.x > 0 ) ?                    texelFetchOffset(iChannel0,tc, 0, ivec2(-1,0)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    vec4 vTexR = ( tc.x < int(iResolution.x)-1 ) ? texelFetchOffset(iChannel0,tc, 0, ivec2(1,0)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    //vec4 vTexT = ( tc.y > 0 ) ?                    texelFetchOffset(iChannel0,tc, 0, ivec2(0,-1)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n    vec4 vTexB = ( tc.y < int(iResolution.y)-1 ) ? texelFetchOffset(iChannel0,tc, 0, ivec2(0,1)) : vTexC*vec4(0.0,0.0,1.0,1.0);\n       \n    \n    ////////////////////////////////////////////////////////////////\n    \n\n    float zC = vTexC.z+vTexC.w;\n\t//float zL = vTexL.z+vTexL.w;\n\tfloat zR = vTexR.z+vTexR.w;\n\t//float zT = vTexT.z+vTexT.w;\n\tfloat zB = vTexB.z+vTexB.w;\n\n\tvec2 vV;\n\tvV.x = -g_fG / g_fGridSizeInMeter * ( zR - zC );\n\tvV.y = -g_fG / g_fGridSizeInMeter * ( zB - zC );\n\tvTexC.xy += vV * g_fElapsedTimeInSec;\n    \n    // 2.1.4. Boundary Conditions\n\n\tif (\t( ( vTexC.z <= EPS*g_fGridSizeInMeter ) && ( vTexC.w > zR ) ) || \n\t\t\t( ( vTexR.z <= EPS*g_fGridSizeInMeter ) && ( vTexR.w > zC ) ) )\n\t{\n\t\tvTexC.x = 0.0;\n\t}\n\n\tif (\t( ( vTexC.z <= EPS*g_fGridSizeInMeter ) && ( vTexC.w > zB ) ) || \n\t\t\t( ( vTexB.z <= EPS*g_fGridSizeInMeter ) && ( vTexB.w > zC ) ) )\n\t{\n\t\tvTexC.y = 0.0;\n\t}\n    \n    // We also clamp the magnitudes\n    float l = length( vTexC.xy );\n\tif ( l > 0.0 )\n\t{\n\t\tfloat alpha = 0.5;\n\t\tvTexC.xy /= l;\n\t\tl = min( l, g_fGridSizeInMeter / (g_fElapsedTimeInSec) * alpha );\n\t\tvTexC.xy *= l;\n\t}\n    \n    // hack blur\n    /*{\n        float fMinH = min( min( min( zL, zR ), min( zT, zB ) ), zC );\n        float fMaxH = max( max( max( zL, zR ), max( zT, zB ) ), zC );\n        float fW = clamp( ( fMaxH - fMinH )*g_fGridSizeInMeter/g_fHackBlurDepth, 0.0, 1.0 );\n\n        float fTexLW = min( (zL-zC)*(1.0/4.0), vTexL.z );\n        float fTexRW = min( (zR-zC)*(1.0/4.0), vTexR.z );\n        float fTexTW = min( (zT-zC)*(1.0/4.0), vTexT.z );\n        float fTexBW = min( (zB-zC)*(1.0/4.0), vTexB.z );\n\n        float fTexAddition = fTexLW + fTexRW + fTexTW + fTexBW;\n        vTexC.z += fTexAddition*0.99*fW;\n    }*/\n    \n    // 2.1.5. Stability Enhancements\n    if ( vTexC.z <= 0.0 )\n    {\n        vTexC.z = 0.0;\n    }\n    \n    ////////////////////////////////////////////////////////////////\n\n\n    vec2 uv = fragCoord/iResolution.xy;    \n    vTexC.w = SampleDepth( iChannel1, uv, iResolution.xy );\n    \n    // click\n    if ( iMouse.z > 0.0 )\n    {\n        float l = length((fragCoord-iMouse.xy)*0.001);\n        l *= 20.0;\n        l = clamp( 1.0 - l, 0.0, 1.0 );\n        vTexC.z += 0.01 * ( cos( l * PI ) * -0.5 + 0.5 );\n    }\n    \n    // reset\n    if ( ( iFrame <= 1 ) || ( iMouse.z > 0.0 && iMouse.x < 40.0 && iMouse.y < 40.0 ) )\n    {\n        vTexC.xy = vec2(0.0);\n        \n        vTexC.z = max( 0.0 - vTexC.w, 0.0 );\n\n        // jon a cunami.\n        float l = abs( uv.x - 0.95 );\n        l *= 10.0;\n        l = clamp( 1.0 - l, 0.0, 1.0 );\n        vTexC.z += 0.1 * ( cos( l * PI ) * -0.5 + 0.5 );\n    }\n    \n    // jon a cunami.\n    float ll = abs( uv.x - 0.95 );\n    ll *= 20.0;\n    ll = clamp( 1.0 - ll, 0.0, 1.0 );\n    vTexC.z += 0.001 * ( cos( ll * PI ) * -0.5 + 0.5 ) * sin( iTime*1.6 ) * max( 0.0, (10.0-iTime)/10.0 );   \n    \n    \n    fragColor = vTexC;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nconst float PI05 =\t\t1.5707963267948966192313216916398;\nconst float PI =\t\t3.1415926535897932384626433832795;\nconst float PI2 =\t\t6.283185307179586476925286766559;\nconst float PIRECIP =\t0.31830988618379067153776752674503;\nconst float PIPER180 =\t0.01745329251994329576923690768489;\nconst float SQRT2 =\t\t1.4142135623730950488016887242097;\nconst float E_NUMBER =\t2.7182818284590452353602874713527;\nconst float LN2 =\t\t0.69314718055994530941723212145817658;\n\n#define EPS 0.0001\n\nconst float g_fGridSizeInMeter = 5.0;\nconst float g_fElapsedTimeInSec = 1.0;\nconst float g_fAdvectSpeed = -1.0;\nconst float g_fG = 10.0;\nconst float g_fHackBlurDepth = 1.0;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\nfloat SampleDepth( sampler2D sampler, vec2 uv, vec2 vRes )\n{\n    float fRet = 0.0;\n    \n    vec2 vUV = uv * vRes.x/vRes.y * 3.0+1.0;\n    vUV += vec2( noise( vUV+2.0 ), noise( vUV+1.0 ) ) * 0.2;\n    mat2 m = mat2( 2.0,  1.2, -1.2,  2.0 );\n    fRet  = 0.5000*noise( vUV )*2.0; vUV = m*vUV;\n    fRet += 0.2500*noise( vUV )*1.0; vUV = m*vUV;\n    vUV += vec2( noise( vUV+0.5 ), noise( vUV+2.5) ) * 0.2;\n    fRet += 0.1250*noise( vUV )*1.0; vUV = m*vUV;\n    fRet += 0.0625*noise( vUV )*1.0; vUV = m*vUV;\n    fRet += 0.0312*noise( vUV )*1.0; vUV = m*vUV;\n    \n    fRet = fRet*0.6-0.4;\n    fRet -= (uv.x-0.6)*3.0;\n    \n    return fRet;\n}\n\nfloat SampleColor( sampler2D sampler, vec2 uv, vec2 vRes )\n{\n    float fRet = 0.0;\n    \n    vec2 vUV = uv * vRes.x/vRes.y * 3.0+1.0;\n    vUV += vec2( noise( vUV+2.0 ), noise( vUV+1.0 ) ) * 0.2;\n    mat2 m = mat2( 2.0,  1.2, -1.2,  2.0 );\n    fRet  = 0.0; vUV = m*vUV;\n    fRet += 0.0; vUV = m*vUV;\n    vUV += vec2( noise( vUV+0.5 ), noise( vUV+2.5) ) * 0.2;\n    fRet += 0.1250*noise( vUV )*0.5; vUV = m*vUV;\n    fRet += 0.0625*noise( vUV )*0.4; vUV = m*vUV;\n    fRet += 0.0312*noise( vUV )*0.4; vUV = m*vUV;\n    \n    return -fRet*4.0;\n}\n\n#define Gamma( v ) pow( v, vec3( 2.2, 2.2, 2.2 ) )\n#define DeGamma( v ) pow( v, vec3( 1.0/2.2, 1.0/2.2, 1.0/2.2 ) )\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 458, 515, 515, 3216]], "test": "untested"}
{"id": "Ds3GRB", "name": "Heightmap Shadows - Point Light", "author": "01000001", "description": "A shader I made for friends in order to demonstrate the concept of creating shading and shadows from a heightmap.", "tags": ["2d", "shadow"], "likes": 4, "viewed": 195, "published": 3, "date": "1677427694", "time_retrieved": "2024-07-30T18:08:16.311590", "image_code": "int maxSamples = 32;\nfloat normalIntensity = 1.0;\nfloat normalDistance = 1.5;\n//the bigger this is, the less defined the normals are\nfloat shadowBrightness = 0.2;\nfloat shadowDistance = 64.0;\n\n//can replace heightmap with whatever shader you want, using 0-1 UV coordinates.\nfloat heightmap(vec2 uv)\n{\n    \n    return texture(iChannel1, uv).x*10.0;\n    /*\n    if (length(uv-0.5) < 0.2){ \n        return 5.0-length(uv-0.5)*25.0;\n    }else{\n        return 0.0;\n    }\n    //*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float height = heightmap(uv);\n    vec3 lightPos = vec3(sin(iTime)*0.5+0.5, cos(iTime)*0.5+0.5, sin(iTime*0.73)*0.5 + 0.5);\n\n    //normal calculation\n    vec3 norm = vec3(0, 0, 1);\n    \n    norm.x = heightmap(uv-vec2(normalDistance/iResolution.x, 0))\n        -heightmap(uv+vec2(normalDistance/iResolution.x, 0));\n    norm.y = heightmap(uv-vec2(0, normalDistance/iResolution.y))\n        -heightmap(uv+vec2(0, normalDistance/iResolution.y));\n        \n    norm*=normalIntensity;\n    norm.z = sqrt(1.0-min(max(0.0, norm.x*norm.x+norm.y*norm.y), 1.0));\n\n    //col = norm;\n    \n    //Shading\n    float light = max(0.0, dot(norm, normalize(lightPos-vec3(uv.xy, 0.0))));\n        \n    col*=light;\n    \n    col = mix(col, vec3(1), smoothstep(0.01 + 1./iResolution.y, 0.01, length((uv-lightPos.xy)*vec2(1., iResolution.y/iResolution.x))));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3GRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 274, 300, 300, 474], [476, 476, 533, 583, 1561]], "test": "untested"}
{"id": "Dd33zS", "name": "Buffer as Distance Field", "author": "SnoopethDuckDuck", "description": "Press:\nWASD to move\nSpace to draw\nR to reset\n\nClick to see boundaries\n\nSometimes clipping occurs when the point moves too fast past boundaries, maybe could be avoided by using multiple steps", "tags": ["distancefield", "game", "interactive", "buffer"], "likes": 14, "viewed": 225, "published": 3, "date": "1677422615", "time_retrieved": "2024-07-30T18:08:17.081531", "image_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 txP = cell(ch0, ivec2(0,0)); \n    vec4 txB = cell(ch2, ivec2(px));\n    \n    // Distances for point and lines\n    vec2 n = norm(ch2, ivec2(txP.xy));\n    float d = length(px - txP.xy);       \n    float d2 = seg(px, txP.xy, txP.xy + 40. * n);\n    float d3 = seg(px, txP.xy, txP.xy + 40. * vec2(-n.y, n.x));\n    \n    // Step distances\n    float s  = smoothstep(-1.,1., br - d);\n    float s2 = smoothstep(-1.,1., 3. - d2);\n    float s3 = smoothstep(-1.,1., 3. - d3);\n    float sd = smoothstep(-1.,1., 2. - txB.r);\n    \n    // Boundary detection (not perfect)\n    float bnd = 0.;\n    for (float i = -1.; i <= 1.; i++)\n    for (float j = -1.; j <= 1.; j++) {\n        vec2 n2 = cell(ch2, ivec2(px+4.*vec2(i,j))).gb;\n        bnd += dot(n2, txB.gb);\n    }\n    bnd /= 9.;\n    \n    // Draw stuff\n    vec3 col = (1.-txB.r/iResolution.y) * vec3(1, 0.5+0.5*txB.gb);\n    col = mix(col, vec3(1), sd);\n    col = mix(col, vec3(1,1,0.5), 0.8 * s2);\n    col = mix(col, vec3(1,0.5,1), 0.8 * s3);\n    col = mix(col, vec3(1), s);\n    \n    if (iMouse.z > 0.)\n        col *= vec3(bnd);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txA = cell(ch0, ipx);         \n    vec4 txB = cell(ch2, ipx);\n    \n    // Initialize point on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0) || ipx == ivec2(0,1))        \n            txA = vec4(floor(0.5 * res), 0, 0);      \n    }\n    \n    float spd = 0.5;\n    if (ipx == ivec2(0, 0)) {\n        // Update velocity\n        txA.z += spd * (key_val(KEY_D) - key_val(KEY_A));\n        txA.w += spd * (key_val(KEY_W) - key_val(KEY_S));\n        txA.zw *= 0.95;\n        \n        // Old/New distance to buffer\n        float d0 = cell(ch2, ivec2(txA.xy)).r;          \n        float d1 = cell(ch2, ivec2(txA.xy + txA.zw)).r; \n        \n        // Normal\n        vec2 n = norm(ch2, ivec2(txA.xy));\n        \n        // If crossed boundary then push back\n        // (could use (-n.y,n.x) to slide along distances instead)\n        if (d0 > br && d1 < br) \n            txA.zw = -n * length(txA.zw);\n        \n        // Update position\n        txA.xy += txA.zw;               \n    } \n    // Save old position\n    else if (ipx == ivec2(0, 1)) \n        txA = txP;\n   \n   fragColor = txA;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define res iResolution.xy\n\n// Ball radius\n#define br 14.\n\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) int(key_val(key)) == 1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// Taken from stb's shader:\n// https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "buffer_b_code": "#define KEYBOARD iChannel1\n\n// This buffer stores distances\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP  = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txP0 = cell(ch0, ivec2(0, 1)); // Previous point\n    vec4 txB  = cell(ch2, ipx);\n    \n    // Initialize distances on reset\n    // (maybe res.x is more appropriate?)\n    if (iFrame < 1 || key_down(KEY_RESET)) \n        txB = vec4(res.y ,0,0,0);   \n    \n    // Draw distances if space pressed\n    if (key_down(KEY_SPACE)) {\n        float d = seg(px, txP.xy, txP0.xy);\n        //d = mix(d, res.y, 0.5 + 0.5 * thc(20., 25. * iTime));\n        txB.r = min(txB.r, d);\n        vec2 n = norm(ch2, ivec2(px));\n        txB.gb = n;\n    }\n    \n    fragColor = txB;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd33zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 1153]], "test": "untested"}
{"id": "mdt3D7", "name": "I'll Be Back", "author": "dean_the_coder", "description": "*** PAUSE/REWIND SHADER FOR SOUND ***", "tags": ["3d", "raymarching", "robot", "lava", "terminator", "movie", "cineshader"], "likes": 56, "viewed": 3262, "published": 3, "date": "1677414370", "time_retrieved": "2024-07-30T18:08:18.029995", "image_code": "// 'I'll Be Back' dean_the_coder (Twitter: @deanthecoder)\n// Shadertoy: https://www.shadertoy.com/view/mdt3D7\n// YouTube: https://youtu.be/Tk-UNehhoMw\n//\n// *** PAUSE/REWIND SHADER FOR SOUND ***\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My 2nd Terminator-inspired shader (1st: https://www.shadertoy.com/view/3tKyzV)\n// I took some aristic license on this one. In the movie the palm is facing\n// away from the camera, but I thought it more interesting to see the fingers.\n//\n// I'm making use of a few routines I've built up in my earlier shaders.\n// E.g. Ground fog, floating particles, and 'glow'.\n//\n// Tricks to aid performance:\n//   - There's only two fingers.\n//     Two are reflections (with a tweak in dimensions and animation).\n//   - There's only two chain links and one chain.\n//     Domain repetion extends the links to make a single chain.\n//     The second chain is a mirror of the first (z = abs(z)).\n//   - Small SDF details are only calculated when the ray point is\n//     close to the object.\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//     (Rotation matrices, etc...)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define MIN_DIST\t1e-4\n#define START_DIST\t1.\n#define MAX_DIST\t64.\n#define MAX_STEPS\t120.\n#define MAX_RDIST\t7.\n#define MAX_RSTEPS\t32.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(4, 2.34, .04)\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t;\nvec2 g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Three n31 results from three scales.\nvec3 n3331(vec3 p) {\n\tconst vec3 s = vec3(5, 13, 196);\n\tvec3 ns;\n\tfor (int i = I0; i < 3; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat sabs(float f) { return sqrt(f * f + .01); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .5, p.yz); }\n\nvec3 az(vec3 p) { return vec3(p.xy, abs(p.z) - .8); }\n\nfloat rep(float p, float c) { return p - c * floor(p / c + .5); }\n\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x),\n\t      s = sin(k * p.x);\n\tp.xz *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p) {\n\tvec2 q = abs(p) - vec2(.015, 0);\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.yz), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tr *= 1. - p.x / h * .14;\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tri(vec3 p, vec3 a, vec3 c) {\n\tconst vec3 b = vec3(.06, 0, 0);\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot3(ba * sat(dot(ba, pa) / dot3(ba)) - pa), dot3(cb * sat(dot(cb, pb) / dot3(cb)) - pb)), dot3(ac * sat(dot(ac, pc) / dot3(ac)) - pc)) : dot(n, pa) * dot(n, pa) / dot3(n));\n}\n\nfloat honk(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xz *= rot;\n\tfloat d = cap(p, h, r);\n\tp.x -= h;\n\treturn d;\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.xz -= 2. * min(dot(k.xy, p.xz), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xz - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.z - h.x), p.y - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) * (.4 + .6 * n31(n - t));\n}\n\nvec3 skyCol(vec3 rd) { return mix(vec3(.2, .001, .005), vec3(1, .15, .001), fakeEnv(rd)); }\n\n// Shameless self-promotion. :)\nfloat dtc(vec2 p) {\n\tp *= vec2(-4, 5);\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.;\n\tif (step(min2(abs(p - vec2(0, .25))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return 1.;\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn dc > 0. ? .8 : 0.;\n}\n\n#define SKY_ID\t0\n#define LAVA_ID\t1\n#define GLOVE_ID\t2\n#define SKIN_ID\t3\n#define LEATHER_ID\t4\n#define BELOW_ARE_REFLECTIVE\t5\n#define STEEL_ID\t6\n#define CHAIN_ID\t7\n\nfloat links(vec3 p) {\n\tp.y = rep(p.y, .36);\n\tfloat r2 = .01 + .002 * S(.015, 0., abs(p.y)) * step(p.x, 0.);\n\treturn length(vec2(length(vec2(p.x, max(abs(p.y) - .05, 0.))) - .06, p.z)) - r2;\n}\n\nfloat chain(vec3 p, float b) {\n\tp.y -= 5.;\n\tp.yzx = bend(p.yzx, -.003 * sin(t) * b);\n\tp.y += 5.;\n\tfloat d = links(p);\n\tp.y += .18;\n\tp.xz *= mat2(.07074, .99749, -.99749, .07074);\n\treturn min(d, links(p));\n}\n\nHit sdf(vec3 p, float shad) {\n\tp.x += .25;\n\tfloat curl, l,\n\t      lava = p.y + 1. + sin(p.x + t) * .05,\n\t      d = lava;\n\tHit h = Hit(d + shad * 1e7, LAVA_ID, p);\n\n\t// Big floaty.\n\tvec3 r,\n\t     q = ax(p);\n\tif (d < .3 && q.x > 2.) {\n\t\tq.xz -= 3.;\n\t\tq.y += 1.05 - sin(p.x + t - 2.) * .04;\n\t\td = n31(q * 4.5) * .1;\n\t\td = hex3D(q, vec2(.7 + d, .1)) - d;\n\t\tU(h, d, LEATHER_ID, q);\n\t}\n\n\t// Dunk!\n\tp.y += t * .15 - .3;\n\n\t// Glow near the lava.\n\tg += 1e-4 / (.01 + lava);\n\tg += S(.7 * S(16., 10., t), 0., length(p.xz + .25)) * 2e-4 / (2e-5 + lava * lava);\n\n\t// Chains.\n\tq = p;\n\tq.xz *= mat2(.92106, .38942, -.38942, .92106);\n\tq = az(q - vec3(1, 0, -.5));\n\tU(h, chain(q, sign(p.z)), CHAIN_ID, q);\n\n\t// Sleeve.\n\tq = p.yxz;\n\tq.x++;\n\tq.y += .16;\n\td = abs(length(q.yz) - .5 + .01 * cos(p.y * 14.)) - .01;\n\td = smin(d, p.y + p.x * .3 + .4 * cos(p.x * 1.6), -.05);\n\tU(h, d, LEATHER_ID, q);\n\n\t// Zip.\n\tq = p;\n\tq.x = abs(q.x) - .2;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\tq.y = rep(q.y, .05);\n\td = max(box2d(q.xy), d - .02);\n\td = max(d, q.z);\n\td = max(d, .43 + p.y + .3 * p.x);\n\tU(h, d, STEEL_ID, q);\n\n\t// Wrist.\n\tq = p.yxz;\n\tq.xy *= mat2(.995, .09983, -.09983, .995);\n\tq.y = sabs(q.y + .2) - .16;\n\tq.x += .8;\n\tq.z -= .04;\n\td = cap(q, .7, .13);\n\tU(h, d, SKIN_ID, q);\n\tcurl = mix(sin(t * 3.) * .1, S(2., 6., t), sat(t / 4.));\n\tp.xy *= rot(1. - .4 * curl);\n\n\t// Thumb.\n\tq = p + vec3(.25, -.1, .07);\n\tq.xy *= mat2(.49757, .86742, -.86742, .49757);\n\td = honk(q, mat2(.98007, -.19867, .19867, .98007), .42, .04 - .07 * S(.1, .5, q.x));\n\tq.yz *= mat2(.16997, -.98545, .98545, .16997);\n\td = smin(d, honk(q, rot(.3 * curl - .5), .26, -.025), .04);\n\tU(h, cyl(q, vec2(.06, .15)), STEEL_ID, p);\n\td = smin(d, honk(q, mat2(.995, -.09983, .09983, .995), .22, -.03 - .065 * S(.1, .25, q.x) * S(.05, -.08, q.z)), .02);\n\n\t// Glove cut-outs.\n\td = max(d, sin(q.x * 70.) * .01 + .22 - length(q - vec3(-.25, .12, .05)));\n\n\t// Palm.\n\tp = bend(p, -.3);\n\tr = vec3(.37, .47 - S(.1, -.4, p.x) * .15, .12);\n\td = smin(d, box(p, r - .12), .16);\n\td += S(0., .2, abs(sin((atan(p.x, p.z) + atan(p.z, p.y - .2)) * 4.))) * .005;\n\tp.x -= r.x;\n\tcurl = S01(curl * (1. + step(p.y, 0.) * .3));\n\n\t// Pre-fingers paddy bit.\n\td = smin(d, tri(p, vec3(0, r.y - .12, 0), vec3(0, .12 - r.y, 0)), .05);\n\td -= .12;\n\tp.xz *= rot(-.2 - curl * .63);\n\tl = 1. + step(0., p.y) * .1 + step(.25, p.y) * .2;\n\tp.y = -abs(p.y);\n\tp.xz -= .05;\n\n\t// Ring/Middle.\n\tq = p;\n\tq.y += r.y * .5 - .12;\n\tq.xy *= mat2(.9998, -.02, .02, .9998);\n\tmat2 r1 = rot(-.7 * curl),\n\t     r2 = rot(-1.4 * curl);\n\td = smin(d, honk(q, r1, .32 * l, .105), .06);\n\td = smin(d, honk(q, r2, .17 * l, .09), .01);\n\td = smin(d, honk(q, r1, .13 * l, .08), .01);\n\n\t// Pinky/Index.\n\tq = p;\n\tq.y += r.y - .12;\n\tq.z += .07;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\td = smin(d, honk(q, r1, .19 * l, .105), .06);\n\td = smin(d, honk(q, r2, .13 * l, .09), .01);\n\td = smin(d, honk(q, mat2(1, 0, 0, 1), .12 * l, .08), .01);\n\n\t// Glove cut-outs.\n\td = max(d, .13 - length(q + vec3(0, .02, .03)));\n\tU(h, d, GLOVE_ID, p);\n\n\t// Robot finger tip.\n\tq.x += .07;\n\td = cyl(q, vec2(.02, .1));\n\tq.x -= .03;\n\td = min(d, cyl(q, vec2(.04)));\n\tU(h, d, STEEL_ID, p);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h, 0.).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .005,\n\t      mxt = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p, 1.).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.03, d);\n\t\tif (mxt - t < 5. || s < .05) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.25, .7);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p, 0.).d;\n\n\treturn sat(min2(ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tconst vec3 lp = vec3(0, -10, -6);\n\tif (h.id == SKY_ID) return skyCol(rd);\n\tfloat _ao, fre, fogY, fg,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, ns, l, sky, col, uv,\n\t     ld = normalize(lp - p);\n\n\t// Cache noise.\n\tns = n3331(h.p);\n\t_ao = ao(p, n);\n\tif (h.id == LAVA_ID) {\n\t\tc = vec3(5, 2.49, .98);\n\t\tc *= .6 + .4 * (ns.x + .6 * ns.y);\n\t\tc += (1. - _ao) * 13.;\n\t}\n\telse if (h.id == GLOVE_ID) {\n\t\tc = vec3(.2, .15, .9);\n\t\tc *= .1 + .6 * ns.z;\n\t\tshine *= 4. * ns.y;\n\t}\n\telse if (h.id == LEATHER_ID) {\n\t\tc = vec3(.1 * ns.x * (.2 + .8 * ns.y));\n\t\tshine *= 20. * S01(abs(ns.z - .5 + rd.x));\n\t}\n\telse if (h.id == CHAIN_ID) {\n\t\tc = vec3(.15);\n\t\tshine = 5. * ns.y * ns.z;\n\t}\n\telse if (h.id == SKIN_ID) c = vec3(1, .63, .46);\n\telse {\n\t\t// Exo-skeleton / zip.\n\t\tc = vec3(.912, .914, 10.92);\n\t\tshine = 20.;\n\t\tspe = 50.;\n\t}\n\n\t// Specular imperfections.\n\tshine *= .5 + .5 * ns.x * ns.y;\n\n\t// Key light, reverse, sky.\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\n\t// Diffuse.\n\tl.xy = .1 + .9 * l.xy;\n\n\t// Ambient occlusion.\n\tl *= .1 + .9 * _ao;\n\n\t// Light contributions (key, reverse, sky).\n\tl *= vec3(1, .8, .3);\n\n\t// Specular (Blinn-Phong)\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Shadow.\n\tl.x *= .1 + .9 * shadow(p, lp, ld, n);\n\n\t// Light falloff\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\tfre = S(.7, 1., 1. + dot(rd, n)) * .2;\n\tsky = skyCol(rd);\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, fre);\n\n\t// Simple fog layer.\n\tfogY = -.25;\n\tuv = vec3(p.xz, fogY) * .4 + t * vec3(.1, -.9, .2);\n\tfloat fogTex = S(0., .5, fbm(uv));\n\tfogY -= (1. - fogTex) * .5;\n\tfg = S(0., -.5, p.y - fogY);\n\tfg *= fogTex;\n\tfg *= 1. - sat(-rd.y);\n\n\t// Distance Fog.\n\tfg += 1. - exp(dot3(p - ro) * -.01);\n\treturn mix(skyCol(vec3(rd.x, 0, rd.z)), col, 1. - sat(fg));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Heat haze.\n\trd.xy *= 1. + n31((rd - vec3(0, t * .5, 0)) * 10.) * .03;\n\trd = normalize(rd);\n\n\t// March the scene.\n\tvec3 dv, n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p, 0.);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\t// Floaty particles.\n\tdv = rd;\n\tfor (i = 1.5; i < d; i += 4.) {\n\t\tvec3 vp = ro + dv * i;\n\t\tvp.yz -= t * .15;\n\t\tg.x += 1. - S(0., mix(.05, .02, sat((i - 1.) / 19.)), length(fract(vp - ro) - .5));\n\t\tdv.xz *= mat2(.87758, .47943, -.47943, .87758);\n\t}\n\n\tcol = g.x * LIGHT_RGB;\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p, 0.);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .2 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\n#define RR(v)\tmod(4e4 * sin(dot(ceil(v), vec2(12, 7))), 10.)\n\n// Based on https://www.shadertoy.com/view/llXSzj by FabriceNeyret2\n// in turn based on https://www.shadertoy.com/view/XlXSz2 by patriciogv\n// Thanks all!\nvec3 os(vec2 u) {\n\tu *= 1. + sat(S(21., 23., t) * vec2(1, 1.5) - vec2(.3, 0)) * 50.;\n\tif (max2(abs(u)) > 1.) return vec3(0);\n\tvec2 o = u;\n\tfloat s = S(22., 20., t);\n\tu.x += u.y * .5 * (1. - s) * h11(u.y * 129.45 + 2.3 * t);\n\tfloat l = dtc(u - vec2(.62, -.35));\n\tfloat c = step(-.2, u.y) + step(u.x, .4);\n\tc *= step(abs(u.y), .458);\n\tvec2 p = 6. * fract(u *= 24.) - .5;\n\tu.y += ceil(t * RR(u.xx));\n\tint i = int(p.y);\n\ti = (abs(p.x - 1.5) > 1.5 ? 0 : i == 5 ? 972980223 : i == 4 ? 690407533 : i == 3 ? 704642687 : i == 2 ? 696556137 : i == 1 ? 972881535 : 0) / int(exp2(30. - ceil(p.x) - 3. * floor(RR(u))));\n\tc *= i > i / 2 * 2 ? 1. : 0.;\n\tc *= step(1., abs(u.x));\n\tc *= step(1., abs(abs(u.x) - 10.));\n\tc *= step(abs(u.x), 19.);\n\tvec3 f = max(vec3(l), sat(vec3(.9, .3, .01) + c));\n\tf *= s + (1. - s) * h21(floor(o * 1e2) + floor(t * 50.) * 123.4);\n\tf *= .6 + .4 * step(.5, fract(o.y * 80.)) * sat(.5 + .5 * sin(o.y * 8. - t * 3.));\n\treturn f * S(25., 22.5, t);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(max(0., iTime - 1.), 28.);\n\tg = vec2(0);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col;\n\tif (t < 18.) {\n\t\tfloat st = S(0., 15., t);\n\t\tvec3 lookAt = vec3(-.1, .1 - 1.2 * st, 0),\n\t\t     ro = vec3(-st * .5, .001, mix(-2.8, -1., st));\n\n\t\t// View bob.\n\t\tro += .1 * sin(iTime * vec3(.9, .7, .3));\n\t\tro.yz *= rot(mix(-.1, .4, st));\n\t\tro.xz *= rot(mix(-.4, .4, st));\n\t\tcol = march(ro, rayDir(ro, lookAt, uv));\n\t}\n\telse col = os(uv);\n\n\t// Vignette.\n\tcol *= 1. - .5 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 48.;\n\tfragColor = vec4(col * min(1., t), 0);\n}", "image_inputs": [{"id": 32473, "src": "https://soundcloud.com/randyheavenridgemusic/terminator-theme", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdt3D7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1922, 1922, 1968, 1968, 2002], [2004, 2004, 2024, 2024, 2048], [2050, 2050, 2070, 2070, 2094], [2096, 2096, 2116, 2116, 2150], [2152, 2152, 2172, 2172, 2192], [2194, 2194, 2214, 2214, 2240], [2242, 2303, 2323, 2323, 2394], [2396, 2396, 2416, 2416, 2513], [2515, 2515, 2534, 2534, 2555], [2557, 2557, 2576, 2576, 2918], [2920, 2960, 2980, 2980, 3094], [3096, 3096, 3115, 3115, 3247], [3249, 3249, 3270, 3270, 3298], [3300, 3300, 3339, 3339, 3421], [3423, 3423, 3442, 3442, 3509], [3511, 3511, 3528, 3528, 3564], [3566, 3566, 3583, 3583, 3619], [3621, 3621, 3650, 3650, 3686], [3688, 3688, 3716, 3716, 3807], [3809, 3809, 3836, 3836, 3907], [3909, 3909, 3930, 3930, 4013], [4015, 4015, 4043, 4043, 4143], [4145, 4145, 4182, 4182, 4260], [4262, 4262, 4297, 4297, 4757], [4759, 4759, 4813, 4813, 4876], [4878, 4878, 4907, 4907, 5167], [5169, 5169, 5213, 5213, 5349], [5351, 5351, 5374, 5394, 5461], [5463, 5463, 5485, 5485, 5554], [5556, 5588, 5607, 5607, 5913], [6078, 6078, 6099, 6099, 6269], [6271, 6271, 6301, 6301, 6477], [6479, 6479, 6508, 6508, 9676], [9678, 9678, 9703, 9703, 9914], [9916, 9916, 9964, 10011, 10297], [10299, 10335, 10361, 10361, 10497], [10499, 10499, 10553, 10553, 12340], [12342, 12342, 12372, 12387, 13538], [13602, 13757, 13774, 13774, 14718], [14720, 14720, 14765, 14765, 15328]], "test": "untested"}
{"id": "msdGWM", "name": "Pixel Range", "author": "UncannyMachines", "description": "Walking a sine range in tomorrow's memory.\n\nGoing to come back and re-factor this, but I'm liking how it looks now.", "tags": ["pixel", "vapourwave"], "likes": 4, "viewed": 139, "published": 3, "date": "1677410895", "time_retrieved": "2024-07-30T18:08:18.912635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Initalise fragColor\n    fragColor = vec4(0.,0.,0.,1.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    //set to aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    \n       \n    //pixelize to your preference!\n    float pixelSize = 0.2;\n\n    float amplitude = cos(fragCoord.x)*0.6;\n    float waveMulti;\n    float x = sin(uv.x*9.0+iTime*0.25)*amplitude+0.7;\n    waveMulti = uv.y - x;\n    \n    float d = max(uv.x - (uv.x + pixelSize), uv.y - (uv.y + pixelSize));\n    \n                \n    fragColor = vec4(1.,0.4 + uv.y,1. * (waveMulti / pixelSize),1.);\n\n\n   amplitude = cos(fragCoord.x)*0.01;\n   float x3 = sin(fragCoord.x*7.0+iTime*1.)*amplitude+0.2;\n   waveMulti = uv.y - x3;\n   if (d > (waveMulti / pixelSize) )\n   {\n        fragColor = vec4(1. * waveMulti,uv.y * 8.,1.,1);\n   }\n}\n\n\n/*Sources:\n\nCool sine wave stuff: https://www.shadertoy.com/view/lslfRn\n\nFixing my aspect ratio: https://www.shadertoy.com/view/Wl23Dy\n\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 83, 910]], "test": "untested"}
{"id": "Dst3DM", "name": "Analoge Trip", "author": "cryson", "description": "Syntth", "tags": ["synth"], "likes": 8, "viewed": 200, "published": 3, "date": "1677364825", "time_retrieved": "2024-07-30T18:08:19.804251", "image_code": "// VHS Distortion effects\n// Original by ejh1 (https://www.shadertoy.com/view/ldXGW4)\n\n#define mouseX (iMouse.x/iResolution.x)\n#define mouseY (iMouse.y/iResolution.y)\n\n// change these values to 0.0 to turn off individual effects\nfloat vertJerkOpt = 0.0;\nfloat vertMovementOpt = 0.0;\nfloat bottomStaticOpt = 1.0;\nfloat scalinesOpt = 1.0;\nfloat rgbOffsetOpt = 2.0;\nfloat horzFuzzOpt = 2.5;\n\n// Noise generation functions borrowed from: \n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = snoise(vec2(9.0,iTime*1.2+3.0))*0.3+5.0;\n    float staticAmount = snoise(vec2(1.0,iTime*1.2-6.0))*0.1+0.3;\n    float staticStrength = snoise(vec2(-9.75,iTime*0.6-3.0))*2.0+2.0;\n\treturn (1.0-step(snoise(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat jerkOffset = (1.0-step(snoise(vec2(iTime*1.3,5.0)),0.8))*0.05;\n\t\n\tfloat fuzzOffset = snoise(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = snoise(vec2(iTime*1.0,uv.y*25.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(snoise(vec2(iTime*0.2,8.0)),0.4))*vertMovementOpt;\n    float vertJerk = (1.0-step(snoise(vec2(iTime*1.5,5.0)),0.6))*vertJerkOpt;\n    float vertJerk2 = (1.0-step(snoise(vec2(iTime*5.5,5.0)),0.2))*vertJerkOpt;\n    float yOffset = abs(sin(iTime)*4.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n    \n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzzOpt;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= 1.0; y += 1.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStaticOpt;\n\t\n\tfloat red \t=   texture(\tiChannel0, \tvec2(uv.x + xOffset -0.0009*rgbOffsetOpt,y)).r+staticVal;\n\tfloat green = \ttexture(\tiChannel0, \tvec2(uv.x + xOffset,0.01+y)).g+staticVal;\n\tfloat blue \t=\ttexture(\tiChannel0, \tvec2(uv.x + xOffset +0.002*rgbOffsetOpt,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*800.0)*0.04*scalinesOpt;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Copied from my Trippier Menger Journey (https://www.shadertoy.com/view/tdfBWs)\n// Original by Snytopia (https://www.shadertoy.com/view/Mdf3z7)\n// I've made very very minimal changes to it. All credit goes to them :)\n// This one is modified to have ~ t r i p p i e r ~ parameters!\n\n\n// /////////////////////////////////////////////////////////////////// //\n// Feel free to mess with the values here,                             //\n// then hit the Play button down in the bottom left of this text area! //\n// /////////////////////////////////////////////////////////////////// //\n\n\n// Try between 8 and 40!\n#define MaxSteps 10\n\n// No time to explain all these, just mess with 'em!\n#define Iterations 3\n#define Scale 6.0\n#define FieldOfView 1.0\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 3.0\n\n// Modified time used for color effects\n// Haven't hooked this up to tweak how fast you \"fly through\" everything.\n#define xTime iTime * 0.1\n#define sTime (sin(xTime) + 2.0) / 0.5\n#define cTime (cos(xTime) + 2.0) / 0.5\n\n// Ambient brightness\n#define Ambient 0.1\n// Strength of the two light colors\n#define Diffuse 0.5\n\n// Tweak these!\n#define LightColor hsv2rgb(vec3(cTime, 3.0, 1.5))\n#define LightColor2 hsv2rgb(vec3(sTime, 3.0, 1.5))\n\n\n// \"Melts\" things when you use lower values\n#define Offset vec3(0.92858, 0.92858, 0.32858)\n\n\n// /////////////////////////////////////////////////////////////////// //\n// Messing with these won't do you much good...                        //\n// /////////////////////////////////////////////////////////////////// //\n#define MinimumDistance 0.0009\n#define normalDistance  0.0002\n\n#define LightDir vec3(1.0)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n\n#define PI 3.141592\n\n\n\n\n// from iq, https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n    /**\n    z = fract(z);\n    float d=length(z.xy-vec2(0.5));\n    d = min(d, length(z.xz-vec2(0.5)));\n    d = min(d, length(z.yz-vec2(0.5)));\n    return d-0.01;\n\t**/\n    \n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+2.0*cos( iTime/8.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dst3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 527, 527, 576], [578, 578, 599, 599, 648], [650, 650, 672, 672, 709], [711, 711, 735, 735, 2241], [2243, 2243, 2267, 2267, 2627], [2630, 2630, 2687, 2687, 4050]], "test": "untested"}
{"id": "ds33W7", "name": "Mandelbulb spheretracer", "author": "rmMinusR", "description": "Right click and drag to look\nWASD to move\nEsc: Reset camera", "tags": ["raymarching", "fractal", "spheretracing"], "likes": 2, "viewed": 176, "published": 3, "date": "1677352107", "time_retrieved": "2024-07-30T18:08:20.779643", "image_code": "/*\n\nMidterm: Fractal raymarcher\n'Image' tab\n\nJust a passthrough. Existed for testing the contents of the accumulation buffer, but\nit isn't necessary anymore. Set it up for buffer B.\n\nChannel setup:\n 0: buffer B\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nMidterm: Fractal raymarcher\n'Buffer A' tab by Sean Sawyers-Abbott, with contributions from Robert Christensen\n\nThis shader is an accumulation buffer that manages the camera position and rotation.\n\nChannel setup:\n 0: self\n 1: keyboard\n\n*/\n\n// calculates the camera's movement in global space based on the user's inputs\nvec3 calcMovement()\n{\n    // gets the camera rotation\n    vec2 camRot = texelFetch(iChannel0, camRotInd, 0).xy;\n    \n    // local right axis\n    vec3 right = vec3(cos(camRot.y), 0.0, sin(camRot.y));\n    \n    // local forward axis\n    vec3 forward = vec3(sin(camRot.y) * cos(camRot.x),\n                                       -sin(camRot.x),\n                       -cos(camRot.y) * cos(camRot.x));\n    // global up axis\n    vec3 up = vec3(0., 1., 0.);\n    \n    // gets the user's key inputs to determine camera movement\n    // \"local\" 3D movement ranging -1 to 1 on each axis\n    vec3 keyInput = vec3( texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r\n                         -texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r,\n                          texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r\n                         -texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r,\n                          texelFetch(iChannel1, ivec2(SPACE, 0), 0).r\n                         -texelFetch(iChannel1, ivec2(LCTRL, 0), 0).r);\n    \n    // checks if the shift key is held to speed up camera movement\n    keyInput *= texelFetch(iChannel1, ivec2(SHIFT, 0), 0).r + 1.;\n    \n    // puts movement into the axes\n    right *= keyInput.x * moveSens;\n    forward *= keyInput.y * moveSens;\n    up *= keyInput.z * moveSens;\n    \n    // returns total movement\n    return right + forward + up;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // gets current pixel\n    ivec2 posCoord = ivec2(fragCoord.x, fragCoord.y);\n    \n    // checks if the current pixel is where movement is stored\n    if (posCoord == camPosInd)\n    {\n        // initialization to default value: checks if on the first frame or escape is pressed\n        if (iFrame == 0 || texelFetch(iChannel1, ivec2(ESC, 0), 0).r == 1.)\n        {\n            // moves the camera outside of the fractal\n            // slightly offsets the XY position as for some reason\n            // if it's at 0.0, 0.0, then it will teleport into\n            // the fractal upon moving directly forwards\n            // or backwards upon start\n            fragColor = vec4(0.001, 0.001, 1.5, 0.);\n            //RC: this is because distance estimation messes up around (x=0, y=0)\n            //Take a look at the -Z tip of the fractal and you'll see it break down into pointclouds\n        }\n        else\n        {\n            // converts the sampled channel into a texture\n            vec4 camera = texelFetch(iChannel0, camPosInd, 0);\n            \n            // gets the length of the camera\n            float lenCam = length(camera);\n            \n            // checks if the camera's length is too far away\n            if (lenCam > 4.5)\n            {\n                // sets the camera to be inside the safe space\n                camera = camera / lenCam * 4.5;\n            }\n            \n            // gets the distance from the camera to the nearest point\n            float dist = signedDistance(camera);\n            \n            // calculates the movement while getting slower when it\n            // gets closer to the nearest point\n            fragColor = camera + vec4(calcMovement() * dist / iTimeDelta, 0.0);\n        }\n    }\n    \n    // checks if the current pixel is where mouse position is stored\n    if (posCoord == mouseInd)\n    {\n        // allows the user to control the camera's rotation with the mouse\n        fragColor.xy = iMouse.xy;\n    }\n    \n    // checks if the current pixel is where the camera's rotation is stored\n    if (posCoord == camRotInd)\n    {\n        // checks if escape is pressed\n        if (texelFetch(iChannel1, ivec2(ESC, 0), 0).r == 1.)\n        {\n            fragColor = vec4(0.);\n        }\n        else\n        {\n\t        // gets the camera's rotation\n\t        vec2 camRot = texelFetch(iChannel0, ivec2(camRotInd), 0).xy;\n\t        \n\t        // gets the mouse's x and y positions\n\t        vec2 deltaMouse = iMouse.xy - texelFetch(iChannel0, mouseInd, 0).xy;\n\t        \n\t        // ensures smooth, consistent rotation of the camera\n\t        if (length(deltaMouse) < 25.)\n\t        {\n\t            // rotates the camera at the given speed\n\t            camRot += deltaMouse.yx * mouseSens;\n\t        }\n\t        \n        \t// rotates the camera in the x direction and\n        \t// stops the camera from doing a full rotation up or down\n        \tfragColor.x = clamp(camRot.x, -90.*DEG2RAD, 90.*DEG2RAD);\n        \t\n        \t// rotates the camera in the y direction\n        \tfragColor.y = camRot.y;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\nMidterm: Fractal raymarcher\n'Buffer B' tab by Robert Christensen\n\nThis shader is responsible for rendering the scene.\n\nChannel setup:\n 0: buffer B\n 1: any cubemap for a background\n\n*/\n\n// CAMERA SETTINGS\n\nconst float viewportHeight = 2.0;\nconst float focalLength = 1.0;\n\n// BEGIN RAYMARCHER\n\n// March constructor\nMarch mk_March(in Ray ray) { March val; val.position = ray; val.closestApproach = MARCH_MAX_DIST; return val; }\n\n// Execute a single step of raymarching\nfloat march_step(inout March march) {\n    float d = signedDistance(march.position.origin);\n    march.position.origin += d*march.position.direction;\n    march.distanceMarched += d;\n    march.closestApproach = min(march.closestApproach, d);\n    return d;\n}\n\n// Perform a raymarch from the camera\nMarch cam_march(in Ray ray) {\n    March march = mk_March(ray);\n    //MARCH'S POPULATED VALUES: position.direction\n    \n    PointLight l = mk_PointLight(vec4(0.5,0.5,0,1), vec3(1), 16.);\n    \n    //March until we hit something, or run out of tries. In other words, correctly set the position\n    float d = MARCH_MAX_DIST; // temp var\n    bool hit, nohit;\n    do {\n        d = march_step(march);\n        ++march.iterations;\n        \n        //Exit condition: we didn't hit anything\n        nohit = march.distanceMarched > MARCH_MAX_DIST || march.iterations > MARCH_MAX_STEPS;\n        \n        //Exit condition: we hit something\n        hit = d < MARCH_HIT_THRESHOLD;\n    } while(!hit && !nohit);\n    \n    //Apply color and shading\n    if(hit) {\n        //MARCH'S POPULATED VALUES: position, distanceMarched, iterations, closestApproach\n\t\t\n        march.normal = normal(march.position.origin, normal_detail);\n        march.color = color(march);\n\n        //MARCH FULLY POPULATED\n        \n        //Apply lighting\n        march.color = lambert_light(l, march.color, march.position.origin, march.normal);\n    } else {\n        //We didn't hit anything. Set to transparent so layer can be blended\n        march.color = vec4(0,0,0,0);\n    }\n    \n    //Halo effect\n    //Helps emphasize surface details and edges in monotone \"caves\"\n    float halo = float(march.iterations)/96. - 0.1/max(march.closestApproach,1.);\n    halo = clamp(halo, 0., 1.);\n    march.color.rgb += vec3(1) * halo;\n    march.color.a = 1.-( (1.-march.color.a) * (1.-halo) );\n    \n    return march;\n}\n\n// END RAYMARCHER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // viewing plane (viewport) info\n    vec2 viewport, px_size, ndc, uv, resolutionInv;\n    float aspect;\n    \n    // setup\n    calcViewport(viewport, px_size, ndc, uv, aspect, resolutionInv,\n                 viewportHeight, fragCoord, iResolution.xy);\n    \n    // make ray for fragment\n    Ray ray;\n    calcRay(ray, viewport, focalLength,\n            texelFetch(iChannel0, camRotInd, 0).xy, texelFetch(iChannel0, camPosInd, 0).xyz);\n    \n    //Required so steps are the right distance\n    ray.direction = normalize(ray.direction);\n    \n    March march = cam_march(ray);\n    \n    alpha_blend(texture(iChannel1, ray.direction.xyz), clamp(march.color, 0., 1.), fragColor);\n}", "buffer_b_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\nMidterm: Fractal raymarcher\n'Common' tab by Robert Christensen and Sean Sawyers-Abbott\n\nContents:\n - Parameters\n - Constants\n - Utils\n - Data structures\n - Lab 3 boilerplate\n - Lights\n    - Lambertian model\n - Mandelbulb\n\n*/\n\n// BEGIN PARAMETERS\n\n// Parameters for raymarching\nconst int MARCH_MAX_STEPS = 256;   // Maximum iteration cap. Must be something reasonable or WebGL will crash.\nconst float MARCH_MAX_DIST = 128.; // Distance for us to safely assume we haven't hit anything.\nconst float MARCH_HIT_THRESHOLD = 0.00001; // How close must we be to be considered a \"hit\"?\n\n// Mouse and keyboard sensitivity for controlling the camera\nconst vec2 mouseSens = vec2(-0.01, 0.01);\nconst float moveSens = 0.001;\n\n// Mandelbulb parameters\n\n//#define power (1.+mod(iTime/8., 1.)*8.)\nconst float power = 10.;\nconst float normal_detail = 0.004;\n\n// END PARAMETERS\n\n\n// BEGIN CONSTANTS\n\n// Coordinates where each piece of data is stored in accumulation buffer\nconst ivec2 camPosInd = ivec2(0,0);\nconst ivec2  mouseInd = ivec2(1,0);\nconst ivec2 camRotInd = ivec2(2,0);\n\n// Math constants\nconst float PI = 3.1415926535;\nconst float DEG2RAD = PI/180.;\n\n// Keycode constants for A, W, D, and S keys respectively\nconst int ESC = 0x1b;\nconst int SHIFT = 0x10;\nconst int LCTRL = 0x11;\nconst int SPACE = 0x20;\nconst int KEY_A = 0x41;\nconst int KEY_D = 0x44;\nconst int KEY_S = 0x53;\nconst int KEY_W = 0x57;\n\n// END CONSTANTS\n\n\n// BEGIN UTILS\n\n// Square\n#define GEN_DECLARE(genType) genType sq(in genType v) { return v*v; }\nGEN_DECLARE(int  ) GEN_DECLARE(ivec2) GEN_DECLARE(ivec3) GEN_DECLARE(ivec4)\nGEN_DECLARE(float) GEN_DECLARE( vec2) GEN_DECLARE( vec3) GEN_DECLARE( vec4)\n#undef GEN_DECLARE\n\n// \"Un-reserve\" the this keyword\n#define this _this\n\n// Blend layers based on transparency\nvoid alpha_blend(in vec4 back, in vec4 front, out vec4 result) {\n    result = vec4( mix(back, front, front.a).rgb, 1.-( (1.-back.a)*(1.-front.a) ) );\n}\n\n// END UTILS\n\n\n// BEGIN DATA STRUCTURES\n\nstruct Ray {\n    vec4 origin, direction;\n};\n\nstruct March {\n    //We need approach direction as well for light view_v -> halfway\n    //(BP only) because camera will be moving\n    Ray position;\n    \n    //Saves a normalize() call\n    float distanceMarched;\n    int iterations;\n    \n    //Traditional outputs\n    vec4 normal;\n    vec4 color;\n    \n    //Allows for halos and other cool effects\n    //Ideally would be a double\n    float closestApproach;\n};\n\n// END DATA STRUCTURES\n\n\n// BEGIN LAB 3 BOILERPLATE\n// These snippets were copy-pasted from the assignment main page\n// calcViewport() modified by RC for use in SSAA (currently unused for performance reasons)\n// calcRay() modified by SSA for camera transformation\n\n// Calculate the coordinate on the viewing plane\nvoid calcViewport(out vec2 viewport, out vec2 px_size, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n\t\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n    \n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)\n    vec2 rhsCoeff = vec2(aspect, 1.0) * (viewportHeight * 0.5);\n    viewport = ndc * rhsCoeff;\n    px_size = resolutionInv * 2. * rhsCoeff; //Derived from UV and NDC\n    \n}\n\n// Build a ray for the current pixel\nvoid calcRay(out Ray ray, in vec2 viewport, in float focalLength,\n             in vec2 camRot, in vec3 camPos)\n{\n    // ray origin relative to viewer is the origin\n    ray.origin = vec4(camPos, 1.0); //SSA: move camera\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    ray.direction = vec4(viewport.x, viewport.y, -focalLength, 0.0);\n    \n    //SSA: rotate camera rays\n    mat3 xRot = mat3(vec3(1, 0, 0),\n                     vec3(0, cos(camRot.x), -sin(camRot.x)),\n                     vec3(0, sin(camRot.x),  cos(camRot.x)));\n    \n    mat3 yRot = mat3(vec3(cos(camRot.y), 0, sin(camRot.y)),\n                     vec3(0, 1, 0),\n                     vec3(-sin(camRot.y), 0, cos(camRot.y)));\n    \n    ray.direction.xyz = yRot * xRot * ray.direction.xyz;\n}\n\n// END LAB 3 BOILERPLATE\n\n\n// BEGIN LIGHTS\n\nstruct PointLight {\n    vec4 pos;\n    vec4 color; //W/A used as intensity\n};\n\n// Initialize a PointLight\nPointLight mk_PointLight(in vec4 center, in vec3 color, in float intensity) {\n    PointLight val;\n    val.pos = vec4(center.xyz, 1.);\n    val.color.rgb = color;\n    val.color.a = intensity;\n    return val;\n}\n\n// Attenuation coefficient\nfloat attenuation_coeff(in float d, in float intensity) {\n    return 1./sq(d/intensity+1.);\n}\n\n// BEGIN LAMBERTIAN MODEL\n\n// Lambertian diffuse coefficient\n// BOTH INPUTS MUST BE NORMALIZED\nfloat lambert_diffuse_coeff(in vec4 light_ray_dir, in vec4 normal) {\n    return dot(normal, light_ray_dir);\n}\n\n// Lambertian diffuse coefficient\nfloat lambert_diffuse_intensity(in PointLight light, in vec4 pos, in vec4 nrm) {\n    vec4 light_vector = light.pos-pos;\n    float lv_len = length(light_vector);\n    return lambert_diffuse_coeff(light_vector/lv_len, nrm) * attenuation_coeff(lv_len, light.color.a);\n}\n\n// Apply the Lambertian lighting model (only supports one light)\nvec4 lambert_light(in PointLight light, in vec4 color, in vec4 pos, in vec4 nrm) {\n    return vec4( lambert_diffuse_intensity(light, pos, nrm) * color.rgb * light.color.rgb, color.a);\n}\n\n// END LAMBERTIAN MODEL\n\n// END LIGHTS\n\n// BEGIN MANDELBULB\n\n// Mandelbulb distance estimation. We vaguely understand it but it isn't our code--we just optimized it.\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// Via: https://www.youtube.com/watch?v=Cp5WWtMoeKg\nfloat signedDistance(in vec4 position) {\n    vec3 z = position.xyz;\n    float dr = 1.0;\n    float r = 0.0;\n    \n    for (int i = 0; i < 15; ++i) {\n        r = length(z);\n\t\t\n        // Escape check\n        if (r<=2.) {\n            // convert to polar coordinates\n            float theta = acos(z.z/r);\n            float phi = atan(z.y,z.x);\n            dr =  pow( r, power-1.0)*power*dr + 1.0;\n\n            // scale and rotate the point\n            float zr = pow( r,power);\n            theta = theta*power;\n            phi = phi*power;\n\n            // convert back to cartesian coordinates\n            z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n            z+=position.xyz;\n        } else break;\n    }\n    \n    return 0.5*log(r)*r/dr;\n}\n\n// Approximates the normal of the surface\n// Offset should probably be dynamic based on view distance, otherwise the image will look noisy.\n// Adapated from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-ii-lighting-and-coloring/\nvec4 normal(in vec4 glob_pos, in float offset) {\n    vec4 xDir = vec4(offset, 0., 0., 0.);\n    vec4 yDir = vec4(0., offset, 0., 0.);\n    vec4 zDir = vec4(0., 0., offset, 0.);\n    return vec4(normalize(vec3(signedDistance(glob_pos+xDir)-signedDistance(glob_pos-xDir),\n\t\t                       signedDistance(glob_pos+yDir)-signedDistance(glob_pos-yDir),\n\t\t                       signedDistance(glob_pos+zDir)-signedDistance(glob_pos-zDir))), 0.);\n}\n\n// Simple bit of coloring\n// Makes more sense with this architecture than orbit trapping\nvec4 color(in March march) {\n    return vec4( march.normal.xyz*0.5+0.5, 1. );\n}\n\n// END MANDELBULB", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds33W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 273, 273, 335]], "test": "untested"}
{"id": "md33WN", "name": "Road to Nowhere", "author": "sagieL", "description": "After being struck with a bit of melancholy while driving home alone during a cold, foggy night, I tried to capture that feeling into this, somewhat too basic for my liking, scene.", "tags": ["raymarching", "noise", "sdf", "pointlight", "road", "stars", "night", "cineshader"], "likes": 17, "viewed": 1391, "published": 3, "date": "1677339696", "time_retrieved": "2024-07-30T18:08:21.882695", "image_code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Post processing effects go here.\n\n#define RES iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const mat3 YIQ2RGB = mat3(1    , 1     , 1     ,\n                              0.956, -0.272, -1.106,\n                              0.619, -0.647,  1.703);\n                              \n    const mat3 RGB2YIQ = mat3(0.299,  0.596,  0.212,\n                              0.587, -0.274, -0.523,\n                              0.114, -0.322,  0.311);\n                              \n    vec2 uv = fragCoord / RES;\n    vec3 col = texture(iChannel0, uv).rgb; \n    \n    // Desaturate.\n    vec3 colYIQ = RGB2YIQ * col;\n    colYIQ.yz *= .85;\n    \n    col = YIQ2RGB * colYIQ;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32507, "src": "https://on.soundcloud.com/r37u4", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n#define TAU 6.283185\n#define PI 3.141592\n\nstruct Mat {\n    vec3 col;\n    float spec;\n};\n\nstruct RayOut {\n  Mat mat;\n  float dist;\n};\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// SDFs from https://iquilezles.org/articles/distfunctions\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdFog(vec3 p, vec3 center, float near, float far) {\n    float fogDepth = max(far - near, 1.);\n    float dist = length(p - center);\n    dist = far - dist;\n    \n    return clamp(dist / fogDepth, 0.0, 1.0);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/// NOISE\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n  p = fract(p * 0.011); \n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n// Exposure tone mapping.\nvec3 toneMapping(vec3 hdrColor, float exposure) {\n   vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n   return mapped;\n}", "buffer_a_code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Here's where the scene is rendered.\n\n#define RES iResolution.xy\n#define EPS .000001\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 75\n#define MAX_DIST 200.\n#define SURF_DIST .001\n\n// Light.\n#define LIGHT_COLOR vec3(1.0, .3, .05)\n#define LIGHT_INTENSITY 5.\n#define SKY_COLOR vec3(0.01,0.03,0.2)\n#define OFF_BLACK vec3(0.0003)\n#define FAR_MOUNTAINS_FOG vec3(0.0001,0.0001,0.0015)\n#define BOUNCE_COLOR vec3(0.4,0.02,0.02) * .1\n#define PLANE_TEXTURE_TILLING 0.5\n\n#define POINT_LIGHT_ATTEN vec3(0.72, .09, .053)\n#define INIT_LIGHT_POS vec3(0., LAMP_HEAD_ROADSIDE - 2., LAMP_HEAD_HEIGHT + 1.)\n#define FAR_FOG_DIST_SCALE .92\n#define ROAD_FOG_DIST 50.\n\n// Lamp.\n#define LAMP_REPEAT_DIST 40.\n#define LAMP_HEAD_HEIGHT 3.3\n#define LAMP_HEAD_ROADSIDE 4.4\n\n#define FOG_COL vec3(0.05, 0.1, 0.3) * 0.08\n\n// Camera.\n#define CAMERA_HEIGHT 3.0\n#define CAMERA_INIT_POS\t0.0\n#define CAMERA_SPEED 4.0\n\n// Materials.\n#define ROAD_MAT Mat(vec3(0.2, 0.2, 0.2), 10.)\n#define MOUNTAIN_MAT Mat(vec3(0.01, 0.3, 0.1), 1.)\n#define ROAD_WHITE_LINE_MAT Mat(vec3(0.95), 40.)\n#define ROAD_YELLOW_LINE_MAT Mat(vec3(0.7, 0.7, 0.1), 40.)\n#define LAMP_STEEL_MAT Mat(vec3(0.06, 0.06, 0.06), 120.)\n#define LAMP_LIGHT_BULB Mat(LIGHT_COLOR * 6., 1.)\n\nfloat LampXRepeat(float x) {\n    return mod(x, LAMP_REPEAT_DIST) - LAMP_REPEAT_DIST * 0.5;\n}\n\nfloat MountainSideDist(float z, float scale) {\n    return smoothstep(10., 20., abs(z) * scale);\n}\n\nRayOut SceneDist(vec3 p, int onlyDist) {    \n    Mat mat;\n    \n    // StreetLamp.\n    float lampXPos = LampXRepeat(p.x);\n    float lampZPos = abs(p.z);\n    float lampBase = sdCapsule(vec3(lampXPos, p.y, lampZPos - 5.8), vec3(0., 0., 0.), vec3(0, 3., 0.), .1);\n    float lampExt = sdCapsule(vec3(lampXPos, p.y, lampZPos - 5.8), vec3(0., 3., 0.), vec3(0., 3.5, -1.4), .1);\n    float lampHead = sdCappedCone(vec3(lampXPos , p.y - LAMP_HEAD_HEIGHT, lampZPos - LAMP_HEAD_ROADSIDE), .28, .4, .12);\n    float lamp = smin(smin(lampBase, lampExt, .05), lampHead, 0.1);\n    float lightBulb = sdSphere(vec3(lampXPos , p.y - LAMP_HEAD_HEIGHT + .15, lampZPos - LAMP_HEAD_ROADSIDE), .22);\n    \n    // Road.\n    float yellowLines = sdBox(vec3(p.y, fract(p.x), abs(p.z) - 5.), vec3(0.001, 2., .4));\n    float whiteLines = sdBox(vec3(p.y, mod(p.x, 5.), p.z), vec3(0.001, 2., .2));\n    \n    float sideDist = MountainSideDist(p.z, 1.);\n    \n    // TODO: why are there artifacts when maxMountainsHeight >= 15??\n    const float maxMountainsHeight = 14.;\n    const float maxRocksHeight = 1.8;\n \n    float noise1 = noise(p.xz * 0.1);\n    float noise2 = noise(p.xz * 1.6);\n    \n    float mountainsHeight = mix(0., maxMountainsHeight, clamp(pow(abs(p.z) * 0.02, 2.), 0., 1.)) * noise1;\n    float groundPlainDistScaled = clamp(length(p.yz) * 0.02, 0., 1.);\n    float rocksHeight = mix(maxRocksHeight, 0., groundPlainDistScaled) * noise2;\n    float ground = p.y - sideDist * (mountainsHeight + rocksHeight * step(groundPlainDistScaled, .35));\n    \n    float d = min(\n        min(ground, whiteLines),\n        min(min(yellowLines, lamp), lightBulb)\n    );\n    \n    // This value should be uniform for all calls in a given scope. \n    // Is this a good optimization? \n    if (onlyDist == 1) { return RayOut(mat, d); }\n    \n    float grain = texture(iChannel0, p.xz * PLANE_TEXTURE_TILLING).r;\n    \n    Mat groundMat = Mat(mix(ROAD_MAT.col * grain, ROAD_MAT.col, 0.1), ROAD_MAT.spec);\n    groundMat.col = mix(groundMat.col, MOUNTAIN_MAT.col, sideDist);\n    float isGround = step(abs(d - ground), EPS);\n    \n    Mat whiteLinesMat = ROAD_WHITE_LINE_MAT;\n    whiteLinesMat.col = mix(whiteLinesMat.col * grain, whiteLinesMat.col, 0.8);\n    float isWhiteLines = step(abs(d - whiteLines), EPS);\n    \n    Mat yellowLinesMat = ROAD_YELLOW_LINE_MAT;\n    yellowLinesMat.col = mix(yellowLinesMat.col * grain, yellowLinesMat.col, 0.8);\n    float isYellowLines = step(abs(d - yellowLines), EPS);\n    \n    float isLamp = step(abs(d - lamp), EPS);\n    float isLightBulb = step(abs(d - lightBulb), EPS);\n        \n    mat.col = \n      groundMat.col * isGround +\n      whiteLinesMat.col * isWhiteLines +\n      yellowLinesMat.col * isYellowLines +\n      LAMP_STEEL_MAT.col * isLamp +\n      LAMP_LIGHT_BULB.col * isLightBulb;\n      \n    mat.spec = \n      groundMat.spec * isGround +\n      whiteLinesMat.spec * isWhiteLines +\n      yellowLinesMat.spec * isYellowLines +\n      LAMP_STEEL_MAT.spec * isLamp +\n      LAMP_LIGHT_BULB.spec * isLightBulb;\n    \n    return RayOut(mat, d);\n}\n\nRayOut RayMarch(vec3 ro, vec3 rd, int steps, int onlyDist) {\n\tfloat dO = 0.;\n    RayOut rayOut = RayOut(Mat(vec3(0), 1.), MAX_DIST);\n    \n    for(int i = 0; i < steps; i++) {\n    \tvec3 p = ro + rd*dO;\n        rayOut = SceneDist(p, onlyDist);\n        dO += rayOut.dist;\n        \n        if (dO > MAX_DIST || rayOut.dist < SURF_DIST) { break; }\n    }\n    \n    return RayOut(rayOut.mat, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(SURF_DIST, 0);\n    vec3 n = SceneDist(p, 1).dist - \n        vec3(SceneDist(p-e.xyy, 1).dist,\n             SceneDist(p-e.yxy, 1).dist, \n             SceneDist(p-e.yyx, 1).dist);\n    \n    return normalize(n);\n}\n\nvec3 GetPointLight(vec3 p, vec3 n, vec3 rd, float spec, vec3 lightPos)\n{\n    vec3 light = vec3(0.0);\n    \n    float lightDist = distance(p, lightPos);\n    float attenuation = 1. / (POINT_LIGHT_ATTEN.x + POINT_LIGHT_ATTEN.y * lightDist + \n    POINT_LIGHT_ATTEN.z * lightDist * lightDist);\n    \n    if (attenuation < 0.01) { return light; } // Light is too weak to contibute, save on calcs.\n    \n    vec3 LightDir = normalize(p - lightPos);\n    vec3 P2L = -LightDir;\n    \n    float diffuse = clamp(dot(n, P2L), 0.0, 1.0);\n    \n    float shadowRayDist = RayMarch(p + n * SURF_DIST * 2., P2L, SHADOW_STEPS, 1).dist;\n\n    diffuse *= attenuation;\n        \n    float shadow = shadowRayDist < lightDist ? 0. : 1.;\n    float bounce_dif = clamp(0.5 + 0.5 * dot(n, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n    vec3 reflection = reflect(-rd, n);\n    float specular = pow(clamp(dot(reflection, P2L), 0.0, 1.0), spec) * diffuse;\n    \n    specular *= attenuation;\n\n    light += vec3(specular) * LIGHT_COLOR * LIGHT_INTENSITY * shadow;\n    light += LIGHT_COLOR * diffuse * shadow;\n    light += BOUNCE_COLOR * bounce_dif;\n    \n    return light;\n}\n\nvec3 Stars(vec2 uv) {\n    const float maxRange = 40.;\n    vec2 range = uv * maxRange;\n    vec2 starUV = fract(range) - .5;\n    float d = length(starUV);\n    vec2 id = floor(range);\n    float n = noise(id);\n    float starExists = step(0.94, n); \n    float sparkle = smoothstep(0.9, 1., sin(n * 100. + n * .8 * iTime) * .5 + .5);\n    float starSDF = pow(0.8 - d, 20.) * mix(5., 30., sparkle);\n\n    float starIntensity = starExists * starSDF;\n    return vec3(starIntensity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 forward = vec3(0, 0, iTime * CAMERA_SPEED);\n    vec3 ro = vec3(0, CAMERA_HEIGHT, -CAMERA_INIT_POS) + forward;\n    ro.xz *= Rot(-0.75 * TAU);\n\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    rd.xz *= Rot(-0.75 * TAU);\n    \n    //rd.xy *= Rot(-m.y * PI + 1.); // Up-down rotation.\n    //rd.xz *= Rot(-m.x*TAU); // Doesn't work well since I cheat and bump lights forward.\n    \n    float skyFactor = smoothstep(.0, 2.2, .5 - rd.y);\n    vec3 col = mix(OFF_BLACK, SKY_COLOR, skyFactor);\n   \n    RayOut rayOut = RayMarch(ro, rd, MAX_STEPS, 0);\n\n    if (rayOut.dist < MAX_DIST) {\n        vec3 p = ro + rd * rayOut.dist;\n        vec3 n = GetNormal(p);\n        \n        float lightOffs = floor(-(forward.z - LAMP_REPEAT_DIST) / LAMP_REPEAT_DIST) * LAMP_REPEAT_DIST;\n        vec3 currLightPos = INIT_LIGHT_POS + vec3(LampXRepeat(0.) + lightOffs, 0, 0);\n        \n        // Calculate both lights over the z axis at once to save performance. Possible because \n        // scene is symmetric over the XY plane at the areas which are effected by this point light.\n        // This does not accumulate light twice for areas where both point lights should've hit\n        // however (nor account for their unique z positions).\n        vec3 reflectedP = vec3(p.xy, abs(p.z));\n        \n        col = rayOut.mat.col * GetPointLight(reflectedP, n, rd, rayOut.mat.spec, currLightPos);\n        //col += rayOut.mat.col * GetPointLight(p, n, rd, rayOut.mat.spec,\n        //    vec3(currLightPos.xy, -currLightPos.z));\n\n        for (float i = 1.; i < 2.; i += 1.) { // More lights means less performance.\n          currLightPos.x -= LAMP_REPEAT_DIST;\n            \n          col += rayOut.mat.col * GetPointLight(reflectedP, n, rd, rayOut.mat.spec, currLightPos);\n          //col += rayOut.mat.col * GetPointLight(p, n, rd, rayOut.mat.spec, \n          //  vec3(currLightPos.xy, -currLightPos.z));\n        }\n        \n        float fog = sdFog(p, ro, 8., ROAD_FOG_DIST);\n        col = mix(FOG_COL, col, fog);\n        \n        // Use mountains fog if very far away sideways.\n        col = mix(FAR_MOUNTAINS_FOG, col, 1. - MountainSideDist(abs(p.z-ro.z), FAR_FOG_DIST_SCALE));\n    } else {\n        col += smoothstep(0., 0.3, rd.y) * Stars(Rot(iTime * 0.01) * rd.yz);\n    }\n    \n    col = toneMapping(col, 4.);\n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Special thanks to BigWings and mithrandir for the Raymarching templates \n// and to IQ for all the SDFs in the world.\n\n// Here we are applying antialiasing, if desired, to the raymarched scene.\n\n#define RES iResolution.xy\n\n// Change this variable to toggle Antialiasing\n#define ENABLE_FXAA 1\n\n#define luma vec3(0.299, 0.587, 0.114)\n\n//Using the following fxaa filter\n//https://www.shadertoy.com/view/4tf3D8\nvec3 fxaa(vec2 p)\n{\n\tfloat FXAA_SPAN_MAX   = 8.0;\n    float FXAA_REDUCE_MUL = 1.0 / 8.0;\n    float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = texture(iChannel0, p + (vec2(-1.,-1.) / RES)).rgb;\n    vec3 rgbNE = texture(iChannel0, p + (vec2( 1.,-1.) / RES)).rgb;\n    vec3 rgbSW = texture(iChannel0, p + (vec2(-1., 1.) / RES)).rgb;\n    vec3 rgbSE = texture(iChannel0, p + (vec2( 1., 1.) / RES)).rgb;\n    vec3 rgbM  = texture(iChannel0, p).rgb;\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (texture(iChannel0, p + dir * (1./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (2./3. - .5)).rgb);\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  texture(iChannel0, p + dir * (0./3. - .5)).rgb +\n        \t\t\t  texture(iChannel0, p + dir * (3./3. - .5)).rgb);\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Col = vec3(0.0);\n    \n    #if ENABLE_FXAA > 0\n    \tCol = fxaa(fragCoord/RES);\n    #else\n    \tCol = texture(iChannel0, fragCoord/RES).rgb;\n    #endif\n    \n    fragColor = vec4(Col,1.0);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md33WN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[348, 348, 405, 405, 1012]], "test": "untested"}
{"id": "Ddc3W7", "name": "seed of life", "author": "jonasfrey", "description": "seed\n", "tags": ["life"], "likes": 4, "viewed": 219, "published": 3, "date": "1677331605", "time_retrieved": "2024-07-30T18:08:22.741398", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = vec4(0.);\n    \n    float n_tau = 6.2831;\n    vec2 o_trn_fc_nor = (fragCoord.xy -iResolution.xy*.5)/ iResolution.y;\n    \n\n    o_trn_fc_nor *= 3.3;//zoom out\n\n    float n_d = length(o_trn_fc_nor);\n    // n_d *= n_d*n_d*n_d;\n    float n_d_circ = abs(n_d-.5);\n    n_d_circ = pow(n_d_circ, 1./2.);\n\n    float n_its = 6.;\n    // float n_ang = atan(o_trn_fc_nor.y, o_trn_fc_nor.x);\n    // float n_ang_nor = (n_ang/n_tau)+.5;\n    // float n_ang_nor_snapped = 1./ floor(n_ang_nor / (1./6.));\n    float n_d_min = 1.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n\n        float n_ang_nor_snapped = (1./n_its)*n_it;\n        float n_radius = .5;\n        vec2 o_p = vec2(\n            sin(n_ang_nor_snapped*n_tau)*n_radius,\n            cos(n_ang_nor_snapped*n_tau)*n_radius\n        );\n        float n_radius2 = (sin(iTime+(n_ang_nor_snapped*n_tau)*2.)*.5+.5)*2.+1.;\n        float n_d2 = length((o_trn_fc_nor-o_p)*n_radius2);\n\n        // n_d *= n_d*n_d*n_d;\n        float n_d2_circ = abs(n_d2-.5);\n        // n_d2_circ = pow(n_d2_circ, 1./((sin(iTime+n_it)*.5+.5)+1.));\n        n_d2_circ = pow(n_d2_circ, 1./2.);\n\n        n_d_min = min(n_d_min, n_d2_circ);\n        // fragColor +=n_d2_circ;\n\n    }\n    n_d_min = min(n_d_min, n_d_circ);\n\n    fragColor +=n_d_min;\n    fragColor = 1.-fragColor;\n\n    // fragColor = vec4(n_ang_nor_snapped);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddc3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1402]], "test": "untested"}
{"id": "cd3GW7", "name": "webcam diff to last frame", "author": "jonasfrey", "description": "difference, \nkind of edge detection by taking the difference of the current webcam image minus the last webcam image, if you move ", "tags": ["diff"], "likes": 1, "viewed": 338, "published": 3, "date": "1677323444", "time_retrieved": "2024-07-30T18:08:23.508348", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //needed for anti aliasing ?\n    float n_ratio_1to_iresx = 1./ iResolution.x;\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    float n_x = abs(o_trn_fc_nor.x-.5)*-1.+0.5;\n    \n    vec4 o_col_wc = texture(iChannel0, o_trn_fc_nor);\n    vec4 o_col_wc_last = texture(iChannel1, o_trn_fc_nor);\n    vec4 o_col_wc_diff = o_col_wc_last - o_col_wc;\n\n    fragColor = o_col_wc;\n\n    if(o_trn_fc_nor.x > 0.5){\n        fragColor = o_col_wc_last;\n    }\n    fragColor = o_col_wc - o_col_wc_last;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    \n    vec4 o_col_wc = texture(iChannel0, o_trn_fc_nor);\n\n    fragColor = o_col_wc;\n\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    \n    vec4 o_col_wc = texture(iChannel0, o_trn_fc_nor);\n\n    fragColor = o_col_wc;\n\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3GW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 611]], "test": "untested"}
{"id": "DscGWM", "name": "Spiral Pattern Bokeh Blur", "author": "SaphiraKai", "description": "bokeh blur generated using a dynamic \"spiral flower\" sampling pattern\n\nwarning: fairly heavy on performance", "tags": ["blur", "lens", "bokeh", "defocus", "fibonacci"], "likes": 3, "viewed": 291, "published": 3, "date": "1677308426", "time_retrieved": "2024-07-30T18:08:24.296241", "image_code": "//? artifact-smoothing blur and HDR -> SDR pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    //? modulators for animation\n    float mod2 = sin(iTime * 1.0/2.0 * pi + pi/2.0) / 2.0 + 0.5;\n    \n    //? sample size/radius parameters\n    float radius = 3.0 * (mod2 + 1.0 );\n    float samples = pow((radius * 2.0 + 1.0), 2.0);\n    \n    float weights = 0.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    for (float x=-radius; x<radius; x++) {\n        for (float y=-radius; y<radius; y++) {\n\n            //? calculate distance between the sampled pixel and the output pixel\n            float d = sqrt(pow(float(abs(x)), 2.0) + pow(float(abs(y)), 2.0));\n            float d_norm = max(d / float(radius) * -1.0 + 1.0, 0.0);\n            \n            //? apply a sine function to the normalized distance for a smooth blur kernel\n            float weight = sin(pi * (d_norm + 1.5)) / 2.0 + 0.5;\n\n            //? retrieve the sampled pixel's color\n            vec2 offset = vec2(float(x), float(y));\n            vec2 uv = (fragCoord + offset) / iResolution.xy;\n            \n            //? perform a running sum of the sampled pixels and their weights\n            color += texture(iChannel0, uv) * weight;\n            weights += weight;\n        }\n    }\n    \n    //? derive an average pixel color from the samples and weights\n    color = color / weights;\n\n    //? convert HDR input back to SDR\n    fragColor = color / (1.0 + lum(color)) * post_gamma;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// things to play with ////////\nconst float blur_amount = 0.5;\nconst float pre_gamma = 0.6;\nconst float post_gamma = 1.1;\nconst float samples = 512.0;\nconst float angle = 137.5;\n////////                     //\n\n//? calculate luminance of color\nfloat lum(vec4 col) {\n    float lum = 0.2126*col.r + 0.7152*col.g + 0.0722*col.b;\n    return lum;\n}\n\n//? constants\nconst float pi = 3.14159;\nconst float phi = 1.61803;\n", "buffer_a_code": "//? SDR -> HDR pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n\n    //? convert SDR input to HDR\n    fragColor = color / (1.0 - lum(color)) * pre_gamma;\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//? bokeh blur pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    //? modulators for animation\n    float mod1 = sin(iTime * 1.0/4.0 * pi + pi/2.0) / 2.0 + 0.5;\n    float mod2 = sin(iTime * 1.0/2.0 * pi + pi/2.0) / 2.0 + 0.5;\n\n    //? sample size parameters\n    float min_samples = 32.0;\n    float samples = mod1 * (samples - min_samples) + min_samples;\n\n    //? size of blur\n    float size = blur_amount * mod2;\n    float radius = size * pow(samples, -phi/pi) / 10.0;\n\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<int(ceil(samples)); i++) {\n\n        // calculate spiral pattern for sampling ////////\n        vec2 offset = vec2(0.0, 0.0);\n\n        float angle = float(i)*radians(angle);\n        float r = radius * sqrt(float(i)) * (iResolution.y);\n\n        offset.x += r * cos(angle);\n        offset.y += r * sin(angle);\n        ////////                                       //\n\n        //? perform a running sum of the sampled pixels\n        vec2 uv = (fragCoord + offset) / iResolution.xy;\n        color += texture(iChannel0, uv);\n    }\n\n    //? derive an average pixel color from the samples\n    fragColor = color / (ceil(samples));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 103, 137, 1455]], "test": "untested"}
{"id": "mljXzG", "name": "metal lotus 04", "author": "chenxianming", "description": "pick a\ntribute to classics", "tags": ["raymarching", "sdf", "flower", "lotus", "cineshader"], "likes": 8, "viewed": 1556, "published": 3, "date": "1677299525", "time_retrieved": "2024-07-30T18:08:25.251686", "image_code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define sTime 3.\n#define sS 1.2\n// for less performance device is true\n#define smooth true\n#define calcUnit 0\n\nconst float count = 7.;\n\nfloat easeOutExpo (float t) {\n    // for mac os API pow( x, y )\n    // y was smoothly allowed\n    return t == 1. ? 1. : 1. - pow( 2., -10. * t );\n}\n\nfloat getTimeline( float t ){\n    float tl = ( t >= sTime ) ? ( t - sTime ) : 0.;\n    \n    return ( t >= ( sTime + 1. ) ) ? 1. : tl;\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat myNoise( in vec2 f ){\n    f *= m;\n    return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rotation( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n        \n        t += a*myNoise(f*x * rotation( float(i) ));\n\n    }\n    return t;\n}\n\nfloat deg2Rad( float deg ){\n    // return deg * PI / 180.;\n    return radians( deg );\n}\n\nfloat axies( vec3 p, float r, float h ){\n    return max( length( p.xy ) - r, abs( p.z ) - h );\n}\n\n// iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat bud( vec3 p, vec3 trasf ){\n    \n    p.z += 1.6;\n    \n    // p.z += pow( dot( p.xz, p.xz ), .5 ) * .2;\n    \n    float a = dot( p.xy, p.xy );\n    \n    p.z -= pow( a, .35 );\n\n    p.z -= cos( p.x ) * .2;\n    p.z -= cos( p.y ) * .2;\n    \n    return sdEllipsoid( p, vec3( .05, .05, .15 ) );\n}\n\nfloat p2d( vec2 uv ){\n\n    float ll = ( pow( uv.x + .35, 2. ) + pow( uv.y, 2. ) - .45 );\n    float rr = ( pow( uv.x - .35, 2. ) + pow( uv.y, 2. ) - .45 );\n\n    return smoothstep( .095, max( ll, rr ), 0.1 );\n}\n\nvec3 calcBg( vec2 uv ){\n    vec3 c = vec3( 0. );\n    \n    for( float i = 0.; i < 20.; i++ ){\n        float x = cos( i / 20. * TAU ) * .4 * ( i / 5. );\n        float y = sin( i / 20. * TAU ) * .4 * ( i / 5. );\n        \n        vec2 v = uv * rotation( deg2Rad( ( 360. / 20. ) * i ) + ( cos( iTime * -.25 ) * i / 20. ) * .5 );\n        \n        v -= .5;\n        v *= rotation( i / 20. );\n        \n        \n        v *= i / 20.;\n        \n        v.x += cos( iTime * .25 ) * .3;\n        v.y += sin( iTime * .25 ) * .3;\n        \n        \n        //p = mix( p, i / 120., p2d( vec2( v.x + x, v.y + y ) ) );\n        \n        c = mix( c, i / 20. * vec3(.83, .3, .43), p2d( vec2( v.x + x, v.y + y ) ) ) * .7;\n    }\n    \n    return c;\n}\n\nfloat petal( vec3 p, vec3 trasf, float h, float r, float rot, float i ){\n    \n    #if calcUnit == 0\n    p.z -= .2;\n    p.xz *= rotation( PI * ( -.15 - i * .13 ) * ( 1. - getTimeline( iTime * sS ) ) );\n    p.z += .2;\n    \n    p.z += pow( p.x, 2.8 );\n    \n    #else\n    \n    p.z -= cos( p.x );\n    p.z -= cos( p.y );\n    p.z += 2.;\n    \n    #endif\n\n    // p.z += pow( p.x, 2.8 );\n    // p.z += pow( p.y, 2.8 );\n    \n    p += trasf;\n    p.xy *= rotation( rot );\n    \n    \n    //p.z += .1;\n    //p.yz *= rotation( PI );\n    \n    //float d = max( length( pow( p.x, 1.6 - i * .05 ) + pow( p.y, 2.0 ) ) - r, abs( p.z ) - h );\n    \n    float ll = ( pow( p.x + .16, 2. ) + pow( p.y, 2. ) - r * 1.4 );\n    float rr = ( pow( p.x - .16, 2. ) + pow( p.y, 2. ) - r * 1.4 );\n\n    float d = max( max( ll, rr ), abs( p.z ) - h );\n    \n    p.y -= .25;\n    p.yz *= rotation( PI * .5 );\n\n    d = min( sdEllipsoid( p, vec3( .005 + ( 4. - i ) * .001, .005 + ( 4. - i ) * .001, .04 + ( 4. - i ) * .025 ) ), d );\n\n    return d;\n}\n\n\nfloat addLayer( float d, vec3 pos, int lI ){\n    vec3 p = pos;\n    \n    p.z += .8;\n    p.z += float( lI ) * .1;\n    \n    p.xy *= rotation( float( lI ) / count * PI );\n    \n    for( float i = 0.; i < count; i++ ){\n        \n        vec3 v = vec3( 0.0, -0.0, -.3 );\n        \n        v.x += cos( ( i / count ) * TAU ) * (.6 - ( float( lI ) ) * .055);\n        v.y += sin( ( i / count ) * TAU ) * (.6 - ( float( lI ) ) * .055);\n        \n        float n = petal( p, v, .01, .11 - float( lI ) * .015, deg2Rad( ( 360. / count ) * i ) + PI * .5, float( lI ) );\n        d = min( d, n );\n    }\n    \n    return d;\n}\n\nvoid repetition(inout vec2 p, float rep) \n{\n\n    float an = TAU/count;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    vec2 r = mat2(cos(sym),-sin(sym),\n                  sin(sym), cos(sym))*p;\n                  \n    p = r;\n}\n\nfloat allPetals( float d, vec3 pos, int lI ){\n    vec3 p = pos;\n    \n    float i = float( lI );\n    \n    p.xy *= rotation( PI * ( i - 1. ) + ( 1. - easeOutExpo( getTimeline( iTime * sS - max( 0., i / 4. * .8 ) ) ) ) * 4. );\n    \n    p.z += .6;\n    p.z += float( lI ) * .1;\n    \n    repetition( p.xy, 7. );\n    //     float n = petal( p, vec3( -0.58 + ( i * .055 ), 0.0, -.12 ), .01, .11 - i * .015, PI * -.5, i );\n\n    float n = petal( p, vec3( -0.6 + ( i * .07 ), 0.0, -.12 ), .01, .11 - i * .015, PI * -.5, i );\n    return n;\n}\n\nfloat eachPetal( vec3 p ){\n    float d = 5.;\n    vec3 pos = p;\n\n\n    #if calcUnit==1\n    \n    d = min( d, addLayer(d, p, 1) );\n    d = min( d, addLayer(d, p, 2) );\n    d = min( d, addLayer(d, p, 3) );\n    d = min( d, addLayer(d, p, 4) );\n    \n    #else\n    \n    d = min( d, allPetals(d, p, 1) );\n    d = min( d, allPetals(d, p, 2) );\n    d = min( d, allPetals(d, p, 3) );\n    d = min( d, allPetals(d, p, 4) );\n    \n    p = pos;\n    p.yz *= rotation( .5 * PI );\n    \n    #endif\n    \n    // d += pow( d, .999 ) * .001;\n    \n    float n = fbm( vec2( fbm( p.xz, .1 ) ), .1 );\n    \n    \n    return d;\n}\n\nfloat buud( vec3 p ){\n    float d = 5.;\n    p.z += .2;\n    d = min( d, bud( p, vec3( 0.0, 0.0, 0.0 ) ) );\n    p.z -= .2;\n    \n    return d;\n}\n\n\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n    \n    p.yz *= rotation( .5 * PI );\n\n    float d = axies( p, .05, .8 );\n    \n    d = max( d, axies( p, .045, .9 ) );\n    \n    float n = fbm( vec2( fbm( pos.yz, 1. ) ), .9 );\n    \n    p.z -= .4;\n    d = min( d, axies( p + n * .005, .05, 1.4 ) );\n    p.z += .4;\n    p.z += .2;\n    \n    d = min( d, axies( p, .02, 1.1 ) );\n    \n    p.z -= .2;\n    p.yz *= rotation( .0 * PI );\n    \n    d = min( d, buud( p ) );\n    \n    // bottom\n    /*\n    p.z += .7;\n    d = min( d, max( length( p ) - .15, abs( p.z ) - .02 ) );\n    p.z -= .7;\n    \n    p.z += .6;\n    d = min( d, max( length( p ) - .2, abs( p.z ) - .02 ) );\n    p.z -= .6;\n    */\n    \n    d = min( d, eachPetal( p ) );\n    \n    p.z += .875;\n    p.xy *= rotation( .58 * PI );\n    d = min( d, sdHexPrism( p, vec2( .115, .02 ) ) );\n    \n    p.z -= .33 - ( 1. - easeOutExpo( getTimeline( iTime * sS - .7 ) ) ) * .33;\n\n    d = min( d, sdHexPrism( p, vec2( .11 + ( .15 * ( easeOutExpo( getTimeline( iTime * sS - .2 ) ) ) ), .01 ) ) );\n\n    // repair\n    p.z += .25;\n    d = min( d, sdHexPrism( p, vec2( .115, .08 ) ) );\n\n    return d;\n}\n\n// IQ\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.yy;\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n\n    // Time varying pixel color\n    float tt = iTime * .4;\n\n    uv = (uv - .5) * 2.;\n\n\n    vec3 origin = vec3(cos(tt) * -2.0, 1.8, sin(tt) * -2.0);\n    vec3 ta = vec3(0.3, 0.3, 0.0);\n\n    // origin = vec3(0.0, 0.0, -3.5);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n    \n    \n    for (int i = 0; i < ( smooth ? 60 : 256 ); ++i) {\n        vec3 p = origin + ray * t;\n        \n        float distance = map(p);\n        t += distance * .4333;\n    }\n\n    vec3 col = calcBg( uv );\n    \n    vec3 lig = normalize(vec3(.57703));\n    lig.xz *= rotation( iTime * .1 );\n    \n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n\n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n        \n        vec3 ap = pos;\n        ap.yz *= rotation( .5 * PI );\n        \n        vec3 b = reflect( nor, pos );\n        \n        float p = fbm( vec2( fbm( vec2( b.xz ) * .5, 1. ) ), .9 );\n        \n        if( map( pos ) == eachPetal( ap ) ){\n        \n            float shadow = calcSoftshadow( pos, lig, 0.1, 3.0, 1 );\n            dif *= shadow;\n\n            col = spe + ( vec3(.93, .06, .76) + p * dif * .05 ) * amb + vec3(.5) * dif + vec3(.93, .06, .76) * .5;\n        }else if( map( pos ) == buud( ap ) ){\n            col = spe + ( vec3(.8, .2, .5) + p * .05 ) * amb + vec3(.8) * dif + vec3(.8, .2, .5) * .5;\n        }else{\n            col = spe + vec3(.05 + p) * amb + vec3(.1) * dif + vec3(.3, .7, .54) * .15;\n            vec3 af = vec3(0.1);\n            af += 2.*dif*vec3(1.,.2,.3);\n            af += 2.*spe*vec3(1.,2.,3.)*dif;\n            col = col*af;\n        }\n        \n        // af\n        col += 0.08 * cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 208, 272, 326], [328, 328, 357, 357, 462], [506, 506, 530, 530, 596], [598, 598, 625, 625, 709], [712, 712, 748, 748, 1037], [1039, 1039, 1066, 1097, 1126], [1128, 1128, 1168, 1168, 1224], [1226, 1232, 1269, 1269, 1352], [1354, 1360, 1396, 1396, 1669], [1671, 1671, 1703, 1703, 1963], [1965, 1965, 1986, 1986, 2173], [2175, 2175, 2198, 2198, 2898], [2900, 2900, 2972, 2972, 3905], [3908, 3908, 3952, 3952, 4510], [4512, 4512, 4555, 4555, 4796], [4798, 4798, 4843, 4843, 5327], [5329, 5329, 5355, 5355, 5926], [5928, 5928, 5949, 5949, 6069], [6073, 6073, 6094, 6094, 7194], [7203, 7203, 7296, 7296, 8151], [8153, 8199, 8230, 8230, 8478], [8480, 8480, 8535, 8585, 10982]], "test": "untested"}
{"id": "dstGWN", "name": "Sierpiski's Hypnosis", "author": "been_jamming", "description": "A smooth zoom of Sierpiski's triangle", "tags": ["fractal"], "likes": 6, "viewed": 192, "published": 3, "date": "1677295850", "time_retrieved": "2024-07-30T18:08:26.022625", "image_code": "//A zoom of Sierpinski's Triangle\n\n//Change these values to customize the shader\n\n//Defines the accuracy of the fractal\n//Increasing likely won't change the image because of anti-aliasing I've done\n#define ITERATIONS 20\n//A constant used for anti-aliasing\n//In pixels, this is how wide the boundary of the fractal is\n#define THRESHOLD_FACTOR 2.0\n//Rotations of the screen per second\n#define ROTATE_SPEED 0.06\n//Zooms per second\n#define ZOOM_SPEED 0.5\n//The color of the fractal\n#define FRACTAL_COLOR vec3(1.0, 1.0, 1.0)\n//The color near the fractal\n#define FADE_COLOR vec3(0.1, 0.3, 1.0)\n//The background color scaled by the distance of the point to the fractal\n#define BACKGROUND_COLOR vec3(0.0, 0.0, 0.0)\n//How quickly the background color scales\n#define BACKGROUND_FACTOR 0.05\n\n//Yum\n#define PI 3.1415927\n\n//The vertices of the largest triangle\nvec2 points[3];\n\n//Minimum of the screen width and screen height in pixels\nfloat min_res;\n\n//Chooes the position of the triangle vertices\nvoid initialize_points(float interp){\n    //Stores the point the screen will center on next\n    vec2 center = vec2(0.0);\n    \n    for(int i = 0; i < 3; i++){\n        //The coordinates of all 3 triangle vertices\n        points[i].x = (length(iResolution)/min_res + 2.0*BACKGROUND_FACTOR)*cos(2.0*(float(i) + 1.0/2.0)*PI/3.0 + mod(iTime*ROTATE_SPEED, 1.0)*2.0*PI);\n        points[i].y = (length(iResolution)/min_res + 2.0*BACKGROUND_FACTOR)*sin(2.0*(float(i) + 1.0/2.0)*PI/3.0 + mod(iTime*ROTATE_SPEED, 1.0)*2.0*PI);\n    }\n    \n    for(int i = 0; i < 3; i++){\n        //Alternate between zooming into each of the 3 sub-triangles\n        //The center is calculated by taking the average of the locations of the next 3 vertices\n        center = int(iTime*ZOOM_SPEED)%3 == i ? (points[i] + mix(points[(i + 1)%3], points[i], 0.5) + mix(points[(i + 2)%3], points[i], 0.5))/3.0 : center;\n    }\n    \n    //Interpolate between the starting positions and the future positions\n    points[0] = mix(points[0], 2.0*points[0] - 2.0*center, interp);\n    points[1] = mix(points[1], 2.0*points[1] - 2.0*center, interp);\n    points[2] = mix(points[2], 2.0*points[2] - 2.0*center, interp);\n}\n\n//Return the signed distance of a point p to a triangle (v0, v1, v2)\nfloat triangle_dist(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n    //Outward facing normal vectors to the sides of the triangle\n    vec2 n0 = normalize(vec2(-1.0, 1.0)*(v0 - v1).yx);\n    vec2 n1 = normalize(vec2(-1.0, 1.0)*(v1 - v2).yx);\n    vec2 n2 = normalize(vec2(-1.0, 1.0)*(v2 - v0).yx);\n    \n    //The distance to the triangle is the maximum distance to each side\n    return max(max(dot(n0, p - v0), dot(n1, p - v1)), dot(n2, p - v2));\n}\n\n//Returns the distance of a point uv to the boundary of Serpinski's fractal\n//Uses points array for fractal vertices\nfloat fractal_dist(vec2 uv){\n    //The distance of uv to the nearest triangle vertex\n    float min_dist;\n    //The triangle vertex nearest to uv\n    int min_point = 0;\n    //A temporary variable to store distances\n    float dist;\n    //Adjusts the fractal dist based on the current iteration\n    float dist_factor = 1.0;\n    \n    //In each iteration, we move uv away from the nearest triangle vertex\n    //The distance between the uv and the vertex is doubled\n    //If the point eventually ends up outside of the triangle, the point is not in the fractal\n    //The distance of the point to the triangle's boundary at the end is the fractal distance up to the factor of dist_factor\n    for(int i = 0; i < ITERATIONS; i++){\n        //The first iteration should set min_dist\n        min_dist = 100.0;\n        for(int j = 0; j < 3; j++){\n            //Computes the squared dist of uv to point j up to a constant\n            dist = dot(uv - points[j], uv - points[j]);\n            //If the distance is minimal, record the vertex\n            if(dist < min_dist){\n                min_dist = dist;\n                min_point = j;\n            }\n        }\n        //Push uv away from the nearest triangle vertex\n        uv = 2.0*uv - points[min_point];\n        //Get the distance of uv to the triangle\n        dist = triangle_dist(uv, points[0], points[1], points[2]);\n        //If uv is outside of the triangle, return that distance times dist_factor\n        if(dist > 0.0){\n            return dist*dist_factor;\n        }\n        //Adjust dist_factor for the next iteration\n        dist_factor *= 0.5;\n    }\n    \n    //The point belongs to the fractal, so return a distance of zero\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //The factor used to interpolate between states\n    float interp = smoothstep(0.0, 1.0/ZOOM_SPEED, mod(iTime, 1.0/ZOOM_SPEED));\n    //Save the minimum of the screen width and screen height\n    min_res = min(iResolution.x, iResolution.y);\n    //Compute the coordinates of the pixel\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/min_res*2.0;\n    \n    //Initialize the points of the triangle\n    initialize_points(interp);\n    //The distance to the fractal\n    float dist = fractal_dist(uv);\n    //Compute the color of the pixel\n    vec3 col = dist < THRESHOLD_FACTOR/min_res ? FRACTAL_COLOR : vec3(0.0) + mix(FADE_COLOR, BACKGROUND_COLOR, clamp(dist, 0.0, BACKGROUND_FACTOR)/BACKGROUND_FACTOR);\n    //Set the alpha channel of the color to 1 and return the color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2158, 2227, 2282, 2347, 2663], [2665, 2782, 2810, 2866, 4471], [4473, 4473, 4527, 4579, 5325]], "test": "untested"}
{"id": "mdd3D4", "name": "Blobby Visualiser", "author": "SnoopethDuckDuck", "description": "Please:\n- Click buffer A\n- Double click the pause button on the soundcloud link\n- Click reset on the shader\n- Rave \n", "tags": ["audio", "audiovisual", "rave", "audi", "aldi"], "likes": 33, "viewed": 578, "published": 3, "date": "1677294095", "time_retrieved": "2024-07-30T18:08:26.852407", "image_code": "#define pi 3.14159\n#define t iTime\n#define Dir(a) vec2(cos(a), sin(a))\n#define Rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    float vol = texture(iChannel1, vec2(0)).g; \n    \n    vec2 uv = (px - 0.5 * iResolution.xy) / iResolution.y;\n    uv.y += 0.02 * cos(t);\n    uv *= 1. - 0.4 * vol;\n    vec2 o = 0.05 * uv + vec2(0, 0.015);\n    \n    float d0 = exp(mix(.3,.5,vol)-mix(14., 4., vol) * sqrt(abs(0.25-length(uv))));\n    vec2 uv2 = uv;\n    vec3 tx = vec3(0);\n    float n = 8.;\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        uv2 *= Rot(-0.01 * t + io);\n        vec3 tx2 = vec3(texture(iChannel0, uv2 - 0.15 * t - o).r,\n                        texture(iChannel0, uv2 - 0.15 * t    ).r,\n                        texture(iChannel0, uv2 - 0.15 * t + o).r);\n        //vec3 tx3 = vec3(texture(iChannel2, 0.25*(uv2 - 0.15 * t) - o).r,\n        //                texture(iChannel2, 0.25*(uv2 - 0.15 * t)    ).r,\n        //                texture(iChannel2, 0.25*(uv2 - 0.15 * t) + o).r);\n        uv2 *= Rot(-0.01 * t - io);       \n        tx2 = pow(tx2, vec3(8));\n        //tx3 = pow(tx3, vec3(8));\n        //tx2 = mix(tx2, tx3, clamp(uv.y + 0.5, 0., 1.));\n        tx += d0 * tx2;\n        \n        uv2 = mix(uv2 * 1.2 - 0.5 * vol, \n                  uv + 0.8 * Dir(0.1 * d0 - 0.4 * t) + vol, \n                  vol);\n    }\n \n    vec3 d = abs(0.04 * vol + 1.23 - tanh(0.5 * t) + tx - length(uv));\n    \n    vec3 col1 = vec3(1, .8, .4);\n    vec3 col2 = vec3(0.75, .8, .4 + vol);\n    vec3 col = mix(col1, col2, 2.5 * d) * exp(0.45 - 3. * sqrt(d));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Other song:\n// https://soundcloud.com/alias_hallow/disconnect?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing\n\n// More experiments:\n// https://www.shadertoy.com/view/dscGDM\n\nfloat getVol(float samples) {\n    float v = 0.;\n    for (float i = 0.; i < samples; i++) \n        v += texture(iChannel1, vec2((i + 0.5)/samples, 0.05)).x;\n    return v / samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    vec4 ch0 = texture(iChannel0, uv);\n    float ch1 = 0.;\n    \n    // Number of samples in either direction\n    float n = 5.;\n    \n    // Sample spacing (value chosen because it looks good)\n    float s = 0.003;  //0.003 with n=5.\n    \n    // Average of samples, ch1\n    for (float i = -n; i <= n; i++) \n        ch1 = max(ch1, texture(iChannel1, vec2(uv.x + s * i, 0.25)).x);\n        //ch1 += log(1.+texture(iChannel1, vec2(uv.x + s * i, 0.25)).x);\n    //ch1 /= 2.*n + 1.;\n    \n    // Alpha scales with uv.x, since bassy tones are more prevalent\n    float r = mix(ch0.r, ch1, 0.4);\n    float g = mix(ch0.g, getVol(50.), 0.02);\n    float a = mix(ch0.a, ch1 * (1. + 0.55 * uv.x), 0.4);\n    \n    vec3 col = vec3(r, g, step(uv.y - a + 0.1, 0.008));\n\n    fragColor = vec4(col, a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32502, "src": "https://soundcloud.com/iamhajimari/decompress?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdd3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 172, 172, 1650]], "test": "untested"}
{"id": "cddGDN", "name": "Trees and grass", "author": "guil", "description": "Forked from Ohanami Stipple, which is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\n\nUse mouse Y to change camera tilt.", "tags": ["clouds", "grass", "tree"], "likes": 10, "viewed": 268, "published": 3, "date": "1677277131", "time_retrieved": "2024-07-30T18:08:27.862705", "image_code": "\nfloat col=5.,col2=1e3,col3=1e3;\n\n\n// Signed distance field function.\nfloat f(vec3 p)\n{\n    float ter = fbm(p.xz+4.)*.1; // Ground\n    col3=p.y-ter;\n    p.y-=ter;\n    float d=max(col3,p.y);\n    \n    \n    if(length(p)<10.)p.xz = mod(p.xz+2.,5.)-3.;// Multiply trees\n      \n    float s=1.,s1=s,g=1.6,g1=1.7;\n       \n    mat2 m1 = r2D(2.2);\n    mat2 m2 = r2D(1.05);\n    mat2 m3 = r2D(-.1);\n\n    int j=7;\n    float h=3.;\n    float scale=.6;\n    p/=scale;\n    \n    //float a = length(p-vec3(0,h/2.,0))-h/2.;\n    //if(a>2.)return min(d, a); \n    \n    \n    // Evaluate the tree \n    d=min(d,scale*max(p.y-h,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s);// trunc \n    for(int k=0;k<int(h);k++){\n      vec3 q=p;\n      s=s1;\n      // Evaluate the tree branches\n      for(int i=0;i<j;\n        q.x=abs(q.x),\n        q.z=(i==0)?q.z:abs(q.z), \n        q.y-=1.,\n        q.xz *= m2,\n        q.xy *= m1,\n        q.xz *= m3,\n        q*=g,\n        s*=g,\n        d=min(d,scale*max(q.y-1.,max(-q.y,length(q.xz)-.1/(q.y+.7)))/s),\n        ++i);\n      // Leaves\n      q.y-=1.;      \n      float l = (length(q*vec3(.6,.3,1.))-.3)/s;\n      if(l<d)col=max(0.,l), d=l;      \n      // return to trunc\n      p.y-=1.5;\n      p.xz *= -m1,\n      s1*=g1;\n      p*=g1;\n      j -=1;}\n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n\n    float zoom=1.;\n   \n    // Set up camera and primary ray.\n    vec3 ro=vec3(-2.5+cos(iTime/4.),1.5+ iMouse.y/iResolution.y,3.5);\n    vec3 rd=normalize(vec3(uv.xy,zoom));\n    vec3 target=vec3(0,1.3,0);\n\n    vec3 w=normalize(target-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=normalize(cross(w,-u));\n\n    rd=mat3(u,v,w)*rd;\n    \n    // Sky\n    float y = max(rd.y,0.);\n    fragColor.rgb = mix(vec3(.1,.2,1.)*.7,vec3(1),fbm2(rd.xz/(.1+y)));\n    fragColor.rgb = mix(fragColor.rgb,vec3(.5,.5,.9),pow(1.-y,10.));\n    \n    \n    \n\n    // Signed distance field raymarch.\n    float t=0.,d=0.;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-3)break;\n        t+=d;\n        if(t>30.)return;\n    }\n\n    // Colourise ground, branch/trunk, or cherry blossom.\n    {\n        vec3 rp=ro+rd*t;\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;//wood\n        //if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);//blossoms\n        //if(col<2e-3)fragColor.rgb=vec3(1.,.5,.1);//red leaves\n        if(col<2e-3)fragColor.rgb=vec3(.1,.5,.2);//green leaves\n        if(col3<1e-1||t>10.)//grass\n            fragColor.rgb=vec3(.6,1.,.6)/3.,\n            fragColor.rg +=fbm1(rp.xz)/8.;\n    }\n\n    // Lighting.\n    vec3 ld=normalize(vec3(1.,3.,1.));\n    float e=1e-2;\n    float d2=f(ro+rd*t+ld*e);\n    float l=max(0.,(d2-d)/e);\n\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\n    float l2=max(0.,.5+.5*(d3-d)/e);\n\n    vec3 rp=ro+rd*(t-1e-3);\n\n    // Directional shadow.\n    t=0.1;\n    float sh=1.;\n    for(int i=0;i<30;++i)\n    {\n        d=f(rp+ld*t)+.01;\n        sh=min(sh,d*50.+0.3);\n        if(d<1e-4)break;\n        t+=d;\n    }\n\n    fragColor.rgb*=1.5*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n}", "image_inputs": [], "common_code": "\nmat2 r2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nfloat fbm(vec2 p)//ground\n{\n    float s=1.;\n    mat2 m = r2D(3.7);\n    vec2 r= vec2(0.);\n    for(int i=0;i<5;i++)r+=sin(p)/s, p=m*(p*s+r),s*=1.3;\n    return r.x+r.y;\n}\n\nfloat fbm1(vec2 p)//grass\n{\n    float s=2.;\n    mat2 m = r2D(1.);\n    vec2 r= vec2(0.);\n    for(int i=0;i<8;i++)r+=(sin(p.yx+.5))/s, p=m*p*s+cos(r.yx*s), s*=1.02;\n    return (r.x+r.y)/s;\n}\n\n\nfloat fbm2(vec2 p)//clouds\n{\n    float s=1.5, r=0.;\n    mat2 m = r2D(1.);\n    vec2 f;\n    for(int i=0;i<7;i++)f=1.+.2*cos(p), p*=m, r+=abs(dot(sin(p*f*s)/s,vec2(1))),s*=1.5;\n    return clamp(r*.3,.3,1.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 70, 87, 87, 1261], [1265, 1265, 1322, 1372, 3198]], "test": "untested"}
{"id": "Ddd3WN", "name": "Vectorama 2023 Invitation", "author": "eimink", "description": "Vectorama is a lanparty held in Oulu, Finland. It's the biggest lanparty in northern Finland. Recycling old stuff for compofiller.\n", "tags": ["sdf", "text", "vectorama"], "likes": 2, "viewed": 166, "published": 3, "date": "1677273638", "time_retrieved": "2024-07-30T18:08:28.612700", "image_code": "// Created for Assembly Winter 2023 Wild Compo by recycling old things.\n// Grid coloring and inspiration from Flyguy's awesome work at https://www.shadertoy.com/view/4dt3RX\n// Font from Andre's work at https://www.shadertoy.com/view/4s3XDn\n\n#define line1 V_ E_ C_ T_ O_ R_ A_ M_ A_\n#define line2 _1 _5 _dot _sub _1 _8 _dot _6 _dot _2 _0 _2 _3\n#define line3 V_ E_ C_ T_ O_ R_ A_ M_ A_ _dot I_ N_ F_ O_\n#define M_PI 3.14159\n#define GRID_SIZE 2.0\n#define GRID_LINE_SIZE 1.25\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n#define SPEED 20.0\n\n#define GROUND 1.0\n#define FLYER 2.0\n#define BACKDROP 3.0\n#define TEXT 4.0\n\n#define RENDER_TEXT true\n\nvec3 glow = vec3(0.);\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n\n\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\n\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\n\n#define ch(l,w) x = min(x,l(clc(pp,cp+=w,w)));\n\n#define A_ ch(AA,0.7);\n#define C_ ch(CC,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define I_ ch(II,0.5);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define R_ ch(RR,0.7);\n#define V_ ch(VV,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.33);\n#define _sub ch(ssub,0.7);\n#define _ cp+=.5;\n\nvec2 clc(vec2 uv, float cp, float w) {\n    return uv-vec2(cp-(w*.5),0.);\n}\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat text(vec3 p){\n   p = vec3(p.x-3.2,p.y-5.,p.z+2.+iTime*SPEED);\n   rot(p.xz,M_PI);\n   rot(p.yz,-.3);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line1;\n   vec3 bd = vec3(10.,1.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\n\nfloat text2(vec3 p){\n   p = vec3(p.x-4.0,p.y-3.8,p.z+2.+iTime*SPEED);\n   rot(p.xz,M_PI);\n   rot(p.yz,-.3);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line2;\n   vec3 bd = vec3(10.,1.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\nfloat text3(vec3 p){\n   p = vec3(p.x-4.75,p.y+5.,p.z-2.+iTime*SPEED);\n   rot(p.xz,M_PI);\n   rot(p.yz,.4);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line3;\n   vec3 bd = vec3(10.,1.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\n\nfloat backdrop(vec3 p){\n    vec3 pp = vec3(p.xy,p.z+51.+iTime*SPEED);\n    rot(pp.xz,M_PI*.5);\n    float a = sdPlane(pp,vec3(1.,0.,0.),10.);\n    return a;\n}\n\nfloat ground(vec3 p){\n   float a = sdPlane(p,vec3(0.,1.,-0),15.);\n   float b = sdPlane(p,vec3(.5,1,0.),20.);\n   float c = sdPlane(p,vec3(-.5,1,0.),20.);\n   float d = cos(p.x*.04)*8.+(sin(p.z*.5)+cos(p.x*.3)+sin(p.y*.5))*1.2;\n   return min(a,min(b,c));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 scene2(vec3 p) {\n   vec3 pp = vec3(p.x-sin(iTime)*5.-sin(4.*iTime),(p.y-sin(iTime*.5)*2.)+2.,p.z+3.0+iTime * SPEED);\n   rot(pp.xy,M_PI);\n   rot(pp.yz,-M_PI*.5);\n   rot(pp.xz,sin(iTime)+cos(iTime*.5)-(sin(iTime*2.)+cos(iTime*4.)));\n   float prism = sdTriPrism(pp,vec2(3.,.6));\n   float prism2 = sdTriPrism(pp,vec2(4.,.5));\n   vec2 gnd = vec2(ground(p),GROUND);\n   vec2 flyer = vec2(max(-prism,prism2),FLYER);\n   glow += vec3(0.6,0.1,0.1)*0.025/(0.5+abs(prism));\n   vec2 backdr = vec2(backdrop(p),BACKDROP);\n   vec2 res = opU(opU(gnd,flyer),backdr);\n   if (RENDER_TEXT == true) {\n       vec2 txt = vec2(text(p),TEXT);\n       txt = opU(txt, vec2(text2(p),TEXT));\n       txt = opU(txt, vec2(text3(p),TEXT));\n       res = opU(res,txt);\n   }\n   return res;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(scene2(pos+e.xyy).x-scene2(pos-e.xyy).x,\n                           scene2(pos+e.yxy).x-scene2(pos-e.yxy).x,\n                           scene2(pos+e.yyx).x-scene2(pos-e.yyx).x ) );\n}\n\nMarchResult raymarch(in vec3 ro, in vec3 rd) {\n    vec3 p = ro+rd;\n    float s = 0.;\n    float id = GROUND;\n    float t = 0.;\n    for (int i = 0; i < 40; ++i){\n        vec2 d = scene2(p);\n        t += d.x;\n        p += rd*d.x;\n        s = float(i);\n        id = d.y;\n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n    }\n    MarchResult res;\n    res.position = p;\n    res.normal = calcNormal(p);\n    res.dist = t;\n    res.steps = s;\n    res.id = id;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(0.,4.,10.-iTime * SPEED);\n    vec3 ct = vec3(0,0,0.-iTime * SPEED);\n    vec3 ld = vec3(0.,15.,100. + iTime * SPEED);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m = raymarch(cp,rd);\n    \n    t = m.dist;\n    p = m.position;\n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        if (m.id == FLYER) {\n            col = vec3(abs(cos(p.z*.1)),.4,abs(sin(p.z*.1))) + (clamp(dot(m.normal, ld), 0.0, 1.0)*0.1);\n        }\n        if (m.id == GROUND) {\n            vec2 uv2 = abs(mod(p.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n            uv2 /= fwidth(p.xz);\n            float gln = min(uv2.x, uv2.y) / GRID_SIZE;       \n            col = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n        }\n        else if (m.id == BACKDROP) {\n            float th = 1.5+p.y*0.09;\n            col =  mix(mix(mix(vec3(.9,.3,0.),vec3(.9,0.1,0.),th),vec3(1.,0.,.4),th-1.3),vec3(0.4,0.,0.4),th-1.8);\n        }\n        else if (m.id == TEXT) {\n            col = vec3(1.0,.8,0.);\n        }\n        \n        \n    }\n    col += glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddd3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[705, 705, 741, 741, 866], [868, 868, 905, 905, 1064], [1065, 1065, 1084, 1084, 1138], [1139, 1139, 1158, 1158, 1389], [1390, 1390, 1409, 1409, 1479], [1480, 1480, 1499, 1499, 1563], [1567, 1567, 1586, 1586, 1811], [1813, 1813, 1832, 1832, 2133], [2134, 2134, 2153, 2153, 2379], [2380, 2380, 2399, 2399, 2603], [2604, 2604, 2623, 2623, 2780], [2781, 2781, 2800, 2800, 2937], [2938, 2938, 2957, 2957, 3206], [3207, 3207, 3226, 3226, 3425], [3426, 3426, 3445, 3445, 3512], [3513, 3513, 3532, 3532, 3816], [3817, 3817, 3836, 3836, 3972], [3973, 3973, 3992, 3992, 4167], [4168, 4168, 4187, 4187, 4260], [4262, 4262, 4282, 4282, 4486], [4487, 4487, 4507, 4507, 4780], [4781, 4781, 4801, 4801, 4975], [4976, 4976, 4996, 4996, 5186], [5187, 5187, 5207, 5207, 5559], [5560, 5560, 5580, 5580, 5875], [5876, 5876, 5896, 5896, 6017], [6018, 6018, 6038, 6038, 6200], [6201, 6201, 6221, 6221, 6502], [6503, 6503, 6523, 6523, 6601], [6603, 6603, 6624, 6624, 6675], [6677, 6677, 6698, 6698, 6756], [7419, 7419, 7457, 7457, 7493], [7603, 7603, 7645, 7645, 7681], [7684, 7684, 7715, 7715, 7802], [7804, 7804, 7840, 7840, 7923], [7925, 7925, 7958, 7958, 8003], [8006, 8006, 8025, 8025, 8257], [8259, 8259, 8279, 8279, 8512], [8513, 8513, 8533, 8533, 8765], [8767, 8767, 8790, 8790, 8922], [8924, 8924, 8945, 8945, 9177], [9179, 9179, 9207, 9207, 9245], [9247, 9247, 9268, 9268, 10004], [10006, 10006, 10038, 10038, 10281], [10283, 10283, 10329, 10329, 10772], [10774, 10774, 10831, 10831, 12272]], "test": "untested"}
{"id": "cddGWN", "name": "Checkered Confusion", "author": "johnCavatelli", "description": "I have this cool sweatshirt I based it off of  ( https://www.ebay.com/itm/354433376225    )", "tags": ["checker"], "likes": 1, "viewed": 167, "published": 3, "date": "1677271217", "time_retrieved": "2024-07-30T18:08:29.375660", "image_code": "//Based on a cool shirt that I have. \n//hash2 function is much smoother, but the semi-shitty noise produced\n//by first function produces much cooler result\n\n//https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.7183098 + vec2(0.71,0.1413));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// The Below Function\n// The MIT License\n// Copyright  2017 Inigo Quilez\nfloat hash2( vec2 w )\n{\n    uvec2 x = uvec2(w);\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x = uv.x / aspect;//divide aspect ration to make the grid square not rectangle\n    \n    //shader variables\n    float spaceWarpScale = 1.;\n    float scrollSpeed = 0.2;\n    float noiseInputScale = 1.5;//how much the uv cordinates are multiplied by going in\n    float noiseOutputScale = 0.5;//how much the noise warps the grid\n    float zoom = 5.;\n    float gridStep = 0.5;//0-1, the cuttof for the step function\n    //default: 1.0, 0.2, 1.5, 0.5, 5, 0.5\n    //cool   : 0.6, 0.2, 2.0, 0.7, 6, 0.1 \n    //trippy : 0.2, 0.02, 10, 0.5, 0.7, 0.5\n    \n    //scale the space\n    uv.x = uv.x * (0.5 * sin(spaceWarpScale * iTime) + 1.);//scale uv cords to make it 'breathe'\n    uv.y = uv.y * (0.5 * cos(spaceWarpScale * iTime) + 1.);\n    //scroll the space to avoid same loop\n    uv.x = uv.x + scrollSpeed * iTime;\n    uv.y = uv.y - scrollSpeed * iTime;\n    //warp via noise, bending the grid\n    uv.x = uv.x + noise(uv*noiseInputScale)*noiseOutputScale;\n    uv.y = uv.y + noise(uv*noiseInputScale)*noiseOutputScale;\n    \n    \n    uv = uv * vec2(zoom);//scale again after transformations to zoom in/out\n    vec3 col = vec3(step(gridStep,fract(uv.x)),step(gridStep,fract(uv.y)),0);\n    col = vec3((col.r + col.g) == 1.);   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 197, 217, 217, 322], [324, 399, 422, 422, 602], [604, 604, 630, 630, 924], [926, 926, 983, 1033, 2400]], "test": "untested"}
{"id": "ds33WN", "name": "Yolke", "author": "Trixelized", "description": "Experimental moire generator", "tags": ["spiral", "moire", "small"], "likes": 1, "viewed": 42, "published": 3, "date": "1677255797", "time_retrieved": "2024-07-30T18:08:30.247330", "image_code": "\n// careful\n\n#define twist     9.00\n#define sides     0.00\n#define expand    0.20\n\n#define zoom      3.00\n#define sharpness 2.00\n\n#define sources   3.00\n\n\nfloat spiral(vec2 uv, float t) {\n\tfloat r = length(uv);\n\tfloat a = atan(uv.x, uv.y);\n\tfloat v = sin(twist * (sqrt(r) - (sides / twist * a) - t) - (expand * iTime * 3.141));\n\treturn v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x /= (iResolution.y / iResolution.x);\n    uv *= zoom;\n    float c = 0.0;\n    for (float i=0.0; i<1.0; i+=(1.0 / sources)) {\n        vec2 source_pos = vec2(sin(i * 6.28 + iTime), cos(i * 6.28 - iTime));\n        c += spiral(uv - source_pos, 0.0);\n    }\n    vec3 col = vec3(smoothstep(-1.0, 1.0, c * sharpness));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds33WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 187, 187, 340], [342, 342, 397, 397, 796]], "test": "untested"}
{"id": "cd33D4", "name": "Refracting Bumpy Ball", "author": "dr2", "description": "Real refraction gets complicated", "tags": ["reflect", "refract", "polyhedron"], "likes": 14, "viewed": 226, "published": 3, "date": "1677237571", "time_retrieved": "2024-07-30T18:08:31.115010", "image_code": "// \"Refracting Bumpy Ball\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// No. 28 in \"Refraction\" series - others listed in \"This Is Not A Refracted Pipe\"\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir;\nfloat tCur, dstFar;\nint idObj;\nbool inBall, chkBall;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\nvec3 SymCom (vec3 p, vec2 cs, vec2 w)\n{\n  vec2 f;\n  float a;\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    f.y = dot (p.yz, vec2 (cs.x, - cs.y));\n    if (f.y > 0.) {\n      f.x = dot (p.yz, cs.yx);\n      p.yz = vec2 (dot (f, vec2 (cs.y, - cs.x)), dot (f, cs));\n    }\n    if (j < 3) p.xy = Rot2Cs (p.xy, w);\n  }\n  return vec3 (p.xy, - p.z);\n}\n\nvec3 IcosSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * acos (sqrt (5.) / 3.));\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), vec2 (cs.x, - cs.y));\n  return SymCom (p, cs, CosSin (-2. * pi / 3.));\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * atan (2.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), cs);\n  p.xy = Rot2Cs (p.xy, CosSin (- pi / 10.));\n  return SymCom (p, cs, CosSin (-2. * pi / 5.));\n}\n\nvec3 DodecSymP (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    if (j < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat PentakEdgeDf (vec3 p)\n{  // (from \"Pentakis Dodecahedron\")\n  vec3 q;\n  float d, a;\n  q = DodecSymP (p);\n  a = 0.5 * acos (-1. / sqrt (5.));\n  d = max (abs (length (q) - 1.), min (dot (q.yz, sin (a - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.))))) - 0.015;\n  return d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec2 r;\n  float dMin, d, rad;\n  r = 5. * vec2 (1., 0.98);\n  dMin = dstFar;\n  if (chkBall) { // (truncated icosahedron with curved faces - overinflated soccer ball)\n    d = min (length (IcosSym (p) + vec3 (0., 0., r.x)) - r.x,\n       length (DodecSym (p) + vec3 (0., 0., r.y)) - r.y);\n    if (inBall) d = abs (d) - 0.005;\n    dMin = max (d, r.x - length (p));\n  } else if (inBall) {\n    d = length (vec3 (p.xy, abs (p.z) - 3.)) - 1.5;\n    DMIN (1);\n  } else {\n    rad = 12.;\n    d = max (rad * PentakEdgeDf (p / rad), - p.y - 10.);\n    DMIN (2);\n    d = PrCylDf (vec3 (p.xz, p.y + 10.1), rad, 0.3);\n    DMIN (3);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 c;\n  if (idObj == 1) c = vec4 (0.7, 0.4, 0.2, 0.2);\n  else if (idObj == 2) c = vec4 (0.2, 0.6, 0.2, 0.2);\n  else if (idObj == 3) {\n    c = vec4 (0.9, 0.8, 0.8, 0.2);\n    if (p.y > -9.85) c = mix (vec4 (0.4, 0.5, 0.7, 0.1), c, \n       smoothstep (0.02, 0.03, abs (Fbm2 (vec2 (1., 0.4) * p.xz) - 0.4))) * \n       (0.9 + 0.1 * Fbm2 (4. * p.xz));\n  } \n  return c;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 c, u, uu;\n  vec2 f;\n  float t;\n  col4 = vec4 (0.);\n  uu = normalize (ro + 200. * rd);\n  for (int ky = -1; ky <= 1; ky ++) {\n    for (int kx = -1; kx <= 1; kx ++) {\n      u = uu;\n      f = vec2 (kx, ky);\n      u.yz = Rot2D (u.yz, 0.0025 * f.y);\n      u.xz = Rot2D (u.xz, 0.0025 * f.x);\n      t = max (SmoothBump (0.45, 0.55, 0.02, mod (64. * atan (u.z, - u.x) / pi, 1.)),\n         SmoothBump (0.45, 0.55, 0.02, mod (64. * asin (u.y) / pi, 1.)));\n      c = mix (vec3 (0.2, 0.3, 0.6), vec3 (0.8, 0.8, 0.5), t) * (0.7 + 0.3 * u.y);\n      t = (u.y > 2. * max (abs (u.x), abs (u.z * 0.25))) ? 0.5 * min (2. * u.y, 1.) :\n         0.05 * (1. + dot (u, sunDir));\n      if (u.y > 0.) t += pow (clamp (1.05 - 0.5 *\n         length (max (abs (u.xz / u.y) - 0.4 * vec2 (1., 4.), 0.)), 0., 1.), 8.);\n      c += vec3 (0.5, 0.5, 1.) * t + vec3 (1., 0.9, 0.6) *\n         dot (pow (abs (u.xz), vec2 (512.)), vec2 (1.));\n      col4 += vec4 (min (c, 1.), 1.) * (1. - 0.15 * dot (f, f));\n    }\n  }\n  return col4.rgb / col4.w;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{ // (from \"Wrapped Bottle\")\n  vec4 col4;\n  vec3 roo, rdo, rdd, vn, vnW, colD, colR, col, flCol;\n  float dstObj, dstBall, dstBallW, rdDotN, eta;\n  bool bWallHit;\n  eta = 1.25; // (choose your value, even -ve)\n  inBall = false;\n  chkBall = true;\n  dstBall = ObjRay (ro, rd);\n  chkBall = false;\n  dstObj = ObjRay (ro, rd);\n  roo = ro;\n  rdo = rd;\n  dstBallW = dstBall;\n  flCol = vec3 (1.);\n  rdDotN = 0.;\n  bWallHit = (dstBall < min (dstObj, dstFar));\n  if (bWallHit) {\n    ro += dstBall * rd;\n    chkBall = true;\n    vn = ObjNf (ro);\n    vnW = vn;\n    rdDotN = - dot (rd, vn);\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.1 * rd;\n    inBall = true;\n    dstBall = ObjRay (ro, rd);\n    chkBall = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstBall < min (dstObj, dstFar)) {\n      ro += dstBall * rd;\n      chkBall = true;\n      vn = ObjNf (ro);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        inBall = false;\n      } else {\n        rd = reflect (rd, vn);\n      }\n      ro += 0.01 * rd;\n      chkBall = false;\n      dstObj = ObjRay (ro, rd);\n    }\n    flCol *= vec3 (0.9, 0.85, 0.8);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    chkBall = false;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    colD = col4.rgb * (0.2 + 0.8 * max (dot (sunDir, vn), 0.) +\n       col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n  } else colD = BgCol (ro, rd);\n  colR = vec3 (0.);\n  if (bWallHit) {\n    ro = roo + dstBallW * rdo;\n    rd = reflect (rdo, vnW);\n    ro += 0.01 * rd;\n    inBall = false;\n    chkBall = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = ObjCol (ro);\n      colR = col4.rgb * (0.2 + 0.8 * max (dot (sunDir, vn), 0.) +\n         col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n    } else colR = BgCol (ro, rd);\n  }\n  col = flCol * colD;\n  if (eta != 1. && bWallHit) col = mix (colR, col, 0.1 + 0.9 * smoothstep (0.4, 0.8, rdDotN));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.05 * pi * tCur;\n    el -= 0.05 * pi * sin (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -60.);\n  zmFac = 4.;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd33D4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[740, 740, 779, 779, 1092], [1094, 1094, 1117, 1117, 1286], [1288, 1288, 1312, 1312, 1497], [1499, 1499, 1524, 1561, 2106], [2108, 2108, 2137, 2172, 2418], [2420, 2420, 2442, 2442, 3077], [3079, 3079, 3112, 3112, 3296], [3298, 3298, 3319, 3319, 3576], [3578, 3578, 3600, 3600, 3969], [3971, 3971, 4002, 4002, 5029], [5031, 5031, 5066, 5093, 7093], [7095, 7095, 7151, 7151, 8236], [8238, 8238, 8280, 8280, 8331], [8333, 8333, 8390, 8390, 8473], [8475, 8475, 8505, 8505, 8618], [8620, 8620, 8651, 8651, 8715], [8717, 8717, 8753, 8753, 8959], [8993, 8993, 9017, 9017, 9129], [9131, 9131, 9156, 9156, 9342], [9344, 9344, 9365, 9365, 9520]], "test": "untested"}
{"id": "dsdGWH", "name": "original horizontal ", "author": "tianluo97", "description": "original horizontal ", "tags": ["originalhorizontal"], "likes": 1, "viewed": 119, "published": 3, "date": "1677227550", "time_retrieved": "2024-07-30T18:08:31.861015", "image_code": "//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    vec4 color1 = vec4(0.992,0.867,0.757,1.0); \n    vec4 color2 = vec4(0.373,0.753,1.000,1.0);\n    vec4 color3 = vec4(0.976,0.780,0.792,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.1; \n    \n    //scale\n    float scale = 1.5;\n    //colorStep1\n    float colorStep1 = 0.33333;\n    //colorStep2\n    float colorStep2 = 0.66666;\n    \n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    // step0 - step1\n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    // step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n\n    //fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color3, dist2);\n    }\n    \n    // step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = mix(color3, color1, dist3);\n    }\n    \n    fragColor = sqrt(fragColor);\n    \n    \n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 206, 243, 2000]], "test": "untested"}
{"id": "dtS3DV", "name": "Mandelbulb raymarcher0", "author": "Mik0", "description": "Mandelbulb but the shadows are weird", "tags": ["mandelbulb"], "likes": 0, "viewed": 174, "published": 3, "date": "1677213496", "time_retrieved": "2024-07-30T18:08:32.647911", "image_code": "float mandelbulb(vec3 pos,  float Power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 4 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nconst float pi = asin(1.0);\nconst float constant = 90.0/pi;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 turn = vec2(((iTime/10.0)*constant)+180.0, -45);\n    vec3 cam_pos = vec3(sin((iTime/10.0))*2.0, cos((iTime/10.0))*2.0, 2);\n    vec3 cam_dir = vec3(sin((turn.x)/constant)*cos((turn.y)/constant), cos((turn.x)/constant)*cos((turn.y)/constant), sin((turn.y)/constant));\n    vec3 cam_right = vec3(sin((turn.x+90.0)/constant), cos((turn.x+90.0)/constant), 0.0);\n    vec3 cam_up = vec3(sin((turn.x)/constant)*cos((turn.y+90.0)/constant), cos((turn.x)/constant)*cos((turn.y+90.0)/constant), sin((turn.y+90.0)/constant));\n    vec3 cam_scrn = (cam_dir*1.0)+(cam_right*uv.x)+(cam_up*uv.y);\n    vec3 ray_origin = cam_pos;\n    vec3 ray_vec = normalize(cam_scrn);\n    \n    float power = 8.0;\n    \n    float dist = 1000.0;\n    while(dist>0.001)\n    {\n        dist = mandelbulb(ray_origin, power);\n        if (dist > 10.0)\n        {break;}\n        ray_origin+=ray_vec*dist;\n    }\n\n\n    // Time varying pixel color\n    vec3 col = abs(ray_vec)*((ray_vec.z+1.0)/2.0);\n    if(dist<0.001)\n    {\n        vec2 eps = vec2(0.0001, 0.0);\n        vec3 pos = ray_origin;\n\n        vec3 normal = normalize(vec3(\n\n            mandelbulb(pos + eps.xyy,  power) - mandelbulb(pos - eps.xyy,  power),\n\n            mandelbulb(pos + eps.yxy,  power) - mandelbulb(pos - eps.yxy,  power),\n\n            mandelbulb(pos + eps.yyx,  power) - mandelbulb(pos - eps.yyx,  power)\n\n    ));\n        vec3 light = vec3(sin(0.0)*cos(pi/2.0), cos(0.0)*cos(pi/2.0), sin(pi/2.0));\n        float brightness = dot(-normal,  normalize(light));\n        ray_vec=light;\n        dist = 1.0;\n        ray_origin+=ray_vec*0.035;\n        int maxShadowIters = 100;\n        int shadowI = 0;\n        while (dist<0.01)\n        {\n            shadowI+=1;\n            if(shadowI>maxShadowIters){break;}\n            dist = mandelbulb(ray_origin, power);\n            ray_origin+=ray_vec*dist;\n        }\n        dist = 1.0;\n        while(dist>0.001)\n\n        {\n\n        dist = mandelbulb(ray_origin, power);\n\n        if (dist > 100.0)\n\n        {break;}\n\n        ray_origin+=ray_vec*dist;\n\n        }\n        if(dist<0.001){brightness*=0.2;}\n        \n        //brightness=1.0;\n        col=abs(vec3(1))*brightness;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 557], [621, 621, 678, 728, 3029]], "test": "untested"}
{"id": "Dst3W8", "name": "Digital Time Clock", "author": "timmaffett", "description": "@zznewclear13's digital clock with hours, minutes and seconds and some added background hue rotation added.  I also fixed the 4's to look how @zznewclear13 was asking\n\nI also added documentation to the digit rendering function D() within the common block.", "tags": ["2d", "time", "clock", "font"], "likes": 6, "viewed": 255, "published": 3, "date": "1677201068", "time_retrieved": "2024-07-30T18:08:33.680151", "image_code": "// Fork of \"[zznewclear13] Digital Clock\" by zznewclear13. https://shadertoy.com/view/stdGRH\n// 2023-02-24 00:57:24\n\n// A digital clock (only shows minutes and seconds)\n// Inspired by https://www.shadertoy.com/view/Mt3XW8\n// Some functions are borrowed from iq, Dave_Hoskins, and FabriceNeyret2 (see Common tab)\n\n// I want a 4 like this, Fabrice please help!\n//\n//   1   1 \n//   1   1\n//   1 1 1\n//       1\n//       1\n\n#define GRID_COUNT_Y 18.0\n#define ACTIVE_TIME 0.3\n#define TWELVE_HOUR_MODE   true\n#define PI (2.0*3.141592653589793238)\n\nvec3 hueToRGB(float h, float s, float l)\n{\n    h = mod(h,360.0);\n    h = h / 60.0;\n    float c = (1.0 - abs(2.0 * l - 1.0)) * s;\n    float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n    vec3 rgb;\n    if(h <= 1.0)\n        rgb = vec3(c, x, 0.0);\n    else if(h <= 2.0)\n        rgb = vec3(x, c, 0.0);\n    else if(h <= 3.0)\n        rgb = vec3(0.0, c, x);\n    else if(h <= 4.0)\n        rgb = vec3(0.0, x, c);\n    else if(h <= 5.0)\n        rgb = vec3(x, 0.0, c);\n    else if(h <= 6.0)\n        rgb = vec3(c, 0.0, x);\n    \n    float m = l - 0.5 * c;\n        \n    return rgb + m;\n}\n\nfloat getTimeDigits(vec2 blockIndex, float dateW)\n{\n    float n = 0.0f;  \n    \n    // make colons\n    if(abs(blockIndex.y-0.5f)==1.0f && \n            (blockIndex.x==5.5f || blockIndex.x==-4.5f) ) n=1.0f;\n\n    // hours\n    blockIndex += vec2(17.0f, 3.0f);\n    float hours = floor(dateW/3600.0);\n    if(TWELVE_HOUR_MODE) {\n        if(hours>12.0) {\n            hours-= 12.0;\n        } else if (hours==0.0) {\n            hours = 12.0;\n        }\n    }\n    n += N(blockIndex, hours);\n\n    //minutes\n    blockIndex -= vec2(10.0f, 0.0f);\n    float minutes = mod(dateW, 3600.0f) / 60.0f;\n    n += N(blockIndex, minutes);\n    \n    //seconds\n    blockIndex -= vec2(10.0f, 0.0f);\n    float seconds = mod(dateW, 60.0f);\n    n += N(blockIndex, seconds);\n\n    return n;\n}\n\nvec3 renderBlock(vec2 blockUV, vec3 colorTop, vec3 colorBottom, float invPixelCountY, float progress)\n{\n    vec4 box1Params = vec4(0.05f, 0.05f, 0.95f, 0.95f);\n    float box1Radius = 0.05f;\n    float sdfBox1 = sdRoundedBox(blockUV, box1Params.xy, box1Params.zw, box1Radius);  \n    float box1 = smoothstep(0.0f, 1.5f * invPixelCountY, sdfBox1);\n    \n    float sinVal = sin(progress * 1.5708);\n    float cosVal = cos(progress * 1.5708);\n    float seperatorThickness = 0.06f;\n    float seperator = (1.0f - seperatorThickness * 0.5f) - sinVal * (1.0f - seperatorThickness);\n    \n    float minMargin = 0.01f;\n    float maxMargin = 0.05f;\n    float sideMargin = 0.04f;\n    float bottomMargin = minMargin;\n    float topMargin = minMargin;\n    \n    // bottom\n    vec4 box2Params = vec4(0.05f + minMargin, 0.05f + bottomMargin,\n                            0.95f - sideMargin, seperator-seperatorThickness*0.5f);\n    float box2Radius = 0.05f;\n    float sdfBox2 = sdRoundedBox(blockUV, box2Params.xy, box2Params.zw, box2Radius);\n    float box2 = smoothstep(0.0f, 1.5f * invPixelCountY, sdfBox2);\n    \n    // top\n    vec4 box3Params = vec4(0.05f + minMargin, seperator+seperatorThickness*0.5f,\n                            0.95f - sideMargin, 0.95f-topMargin);\n    float box3Radius = 0.05f;\n    float sdfBox3 = sdRoundedBox(blockUV, box3Params.xy, box3Params.zw, box3Radius);\n    float box3 = smoothstep(0.0f, 1.5f * invPixelCountY, sdfBox3);\n    \n    \n    vec2 lightSource = normalize(vec2(0.5, 2.0f));\n    // background\n    vec3 color0 = vec3(0.40f, 0.40f, 0.20f);\n    // edge\n    vec3 color1 = vec3(0.95f, 0.95f, 0.85f) * lightSource.y;\n    // bottom\n    vec3 color2 = colorBottom * (dot(lightSource, vec2(cosVal, -sinVal)) * 0.3f + 0.7f);\n    // top\n    vec3 color3 = colorTop * (dot(lightSource, vec2(sinVal, cosVal)) * 0.3f + 0.7f);\n    \n    vec3 color = mix(color1, color0, box1);\n    color = mix(color2, color, box2);\n    color = mix(color3, color, box3);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 pixelCount = iResolution.yy / GRID_COUNT_Y;\n    vec2 centerFragCoord = fragCoord+0.5f*pixelCount-(iResolution.xy)*0.5f;\n\n    float invPixelCountY = 1.0f / pixelCount.y; \n    ivec2 blockIndex = ivec2(floor(centerFragCoord * invPixelCountY));\n    vec2 blockUV = mod(centerFragCoord, pixelCount) * invPixelCountY;\n        \n    float progress = 0.5f;\n    // if(iMouse.z > 0.0f) {progress = 1.0f - fract(2.0f * iMouse.y / iResolution.y);}\n\n    float floorTime = floor(iDate.w);\n    float fractTime = fract(iDate.w);\n    float inactive = 1.0f - ACTIVE_TIME;\n    float randomVal = hash13(vec3(vec2(blockIndex), floorTime)) * inactive;\n\n    float dateW = floorTime;\n    progress = clamp((fractTime-randomVal) / ACTIVE_TIME, 0.0f, 1.0f);\n\n    float d1 = getTimeDigits(vec2(blockIndex)+vec2(0.5f), dateW);\n    float d2 = getTimeDigits(vec2(blockIndex)+vec2(0.5f), dateW+1.0f);\n    \n    vec3 colorBackground = vec3(0.95f, 0.95f, 0.85f);\n    \n    float time = mod(iTime*10.0,360.0);\n    colorBackground = hueToRGB( time+(60.0*(fragCoord.y/iResolution.y)),\n                          1.0, 0.7 );\n    \n    vec3 colorDigit = vec3(0.2f, 0.2f, 0.4f);\n    vec3 color1 = mix(colorBackground, colorDigit, d1);\n    vec3 color2 = mix(colorBackground, colorDigit, d2);\n    vec3 color = renderBlock(blockUV, color2, color1, invPixelCountY, progress);\n\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec4 b, in float r )\n{\n    vec2 q = abs(p-b.xy)-b.zw+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 bl, in vec2 tr, in float r )\n{\n    vec2 c = (bl+tr)*0.5;\n    vec2 s = (tr-bl)*0.5;\n    vec2 q = abs(p-c)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/ldKGRR\nfloat D(vec2 p, float n) {  // display digit\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n                         //  0   1   2   3   4   5   6   7   8   9\n        i==5? 973012991: // 111 001 111 111 101 111 111 111 111 111  /* old style 4==972980223 */\n        i==4? 690407533: // 101 001 001 001 101 100 100 001 101 101\n        i==3? 704642687: // 101 001 111 111 111 111 111 001 111 111\n        i==2? 696556137: // 101 001 100 001 001 001 101 001 101 001\n        i==1? 972881535: // 111 001 111 111 001 111 111 001 111 111\n    0 )/b;\n \treturn float(i-i/2*2);\n}\n\nfloat N(vec2 p, float v) {  // display number\n    for (float n=1.; n>=0.; n--)  // print digit 1 to 0 ( negative = fractionals )\n        if ((p.x-=4.)<3.) return D(p,floor(mod(v/pow(10.,n),10.))); \n    return 0.;\n} ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dst3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 582, 582, 1108], [1110, 1110, 1161, 1161, 1866], [1868, 1868, 1971, 1971, 3838], [3840, 3840, 3895, 3895, 5271]], "test": "untested"}
{"id": "dscGWH", "name": "Test Walker (WIP)", "author": "SnoopethDuckDuck", "description": "Keys:\nR - reset\nA/D - move\nW/S - height\nQ/E - stride width\nSPACE - shoot\nF/G - hip size\n\nBugs included!", "tags": ["interactive", "walk", "person", "legs"], "likes": 22, "viewed": 230, "published": 3, "date": "1677197847", "time_retrieved": "2024-07-30T18:08:34.434136", "image_code": "#define green vec3(0.5,1,0)\n#define blue vec3(0,0.5,1)\n#define orange vec3(1,0.5,0.5)\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// maybe overkill but might want other styles\nvoid style1(inout vec3 col, vec3 col2, float d) {\n    float s = smoothstep(-k, k, 2.*k - abs(d));\n    float s2 = smoothstep(-k, k, d);\n    col = mix(col * (1.-s2), col2, s);\n}\n\nvoid line(vec2 uv, inout vec3 col, vec3 col2, vec2 p, vec2 q, float r) {\n    float d = r - seg(uv, p, q);\n    style1(col, col2, d);\n}\n\nvoid circle(vec2 uv, inout vec3 col, vec3 col2, vec2 p, float r) {\n    float d = r - length(uv - p);\n    style1(col, col2, d);\n}\n\nvoid box(vec2 uv, inout vec3 col, vec3 col2, vec2 p, vec2 q, float th, float r) {\n    float d = r - sdBox(uv, p, q, th);\n    style1(col, col2, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    uv.y += 0.35;\n\n\n    // --- DATA / PARAMETERS ---\n    vec4 tx  = texelFetch(iChannel0, ivec2(0,0), 0); // Right foot\n    vec4 tx2 = texelFetch(iChannel0, ivec2(0,1), 0); // Left foot\n    vec4 tx3 = texelFetch(iChannel0, ivec2(0,2), 0); // Dimension data\n    float sw = mix(swMin, swMax, tx3.z);\n    \n   \n    // --- POINTS ---\n    // clamp to avoid flicker bug (maybe not needed)\n    float mx  = abs(tx.x-tx2.x)/sw;\n    float mxL = clamp(max(mx, tx.y), 0., 1.);    \n    float mxR = clamp(max(mx, tx2.y), 0., 1.);    \n    mxL = .5 + .5 * cos(pi*mxL);\n    mxR = .5 + .5 * cos(pi*mxR);\n    vec2 pFootL = vec2(tx2.x, r0 + 3. * mxL * r0);\n    vec2 pFootR = vec2(tx.x, r0 + 3. * mxR * r0);\n    \n    vec2 pTarget = vec2(mix(tx.x,tx2.x,.5), pFootL.y + pFootR.y + 2.*r1);   \n    float aL = angle(pTarget, pFootL);\n    float aR = angle(pTarget, pFootR);\n    vec2 pKneeL = pFootL + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aL);\n    vec2 pKneeR = pFootR + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aR);\n\n    vec2 pHipL = pKneeL + (6.*tx3.y+2.*mx) * r0 * Dir(aL);\n    vec2 pHipR = pKneeR + (6.*tx3.y+2.*mx) * r0 * Dir(aR); \n    vec2 pBody = mix(pHipL, pHipR, 0.5);\n    pHipL = mix(pHipL, pBody, tx3.w);\n    pHipR = mix(pHipR, pBody, tx3.w);\n    \n    vec2 dirOrbit = Dir(tx3.x*pi*(0.5-0.1*mx) - 0.5*pi);\n    vec2 pOrbit1 = pBody + r1 * dirOrbit;\n    vec2 pOrbit2 = pOrbit1 + 2.01 * r0 * dirOrbit;\n        \n    // --- DRAW ---\n    \n    // Plane\n    float pl = smoothstep(-k, k, -uv.y);\n    vec3 col = mix(vec3(0), vec3(0.25), pl);\n    \n    // Right leg (blue)\n    line(uv, col, orange, pFootR, pKneeR, 0.5 * r0);\n    line(uv, col, orange, pKneeR, pHipR, 0.5 * r0);    \n    circle(uv, col, mix(blue,vec3(1),.5*(tx2.y+1.)), pFootR, r0);\n    circle(uv, col, blue, pKneeR, r0);\n    circle(uv, col, blue, pHipR, r0);\n    \n    // Buffer B (lasers)\n    vec4 txB = texelFetch(iChannel1, ivec2(px), 0);\n    vec3 laserCol = mix(green, blue, (1.-txB.y)*txB.x); \n    col = mix(col, laserCol, txB.y*(1.-pl));\n    \n    // Centre ball\n    line(uv, col, orange, pHipR, pBody, 0.5 * r0);   \n    //line(uv, col, orange, pOrbit1, pOrbit2, 0.5* r0);\n    circle(uv, col, orange, pBody, r1);\n    pOrbit2 += -pow(txB.x, 4.)*2.*r0*dirOrbit;\n    box(uv, col, orange, pOrbit1, pOrbit2, 2.*r0 * (1.-0.*txB.x), 0.);\n    line(uv, col, orange, pBody, pHipL, 0.5 * r0);\n     \n    // Left leg (red)\n    line(uv, col, orange, pFootL, pKneeL, 0.5 * r0);\n    line(uv, col, orange, pKneeL, pHipL, 0.5 * r0);       \n    circle(uv, col, mix(green,vec3(1),.5*(tx.y+1.)), pFootL, r0);\n    circle(uv, col, green, pKneeL, r0);\n    circle(uv, col, green, pHipL, r0);    \n    \n    // UI (tx3 data)\n    line(ouv, col, vec3(1), vec2(-0.45,0.45), vec2(-0.45,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.45, mix(.3,.45,.5*(tx3.x+1.))), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.4,0.45), vec2(-0.4,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.4, mix(.3,.45,tx3.z)), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.35,0.45), vec2(-0.35,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.35, mix(.3,.45,tx3.y)), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.3,0.45), vec2(-0.3,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.3, mix(.3,.45,tx3.w)), 0.01);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n\n// probably don't need wrapping\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nfloat key_val(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// Texels:\n// (0,0) Right foot\n// (0,1) Left foot \n// (0,2) Dimension data\n\n// Dimension data:\n// x = left/rightness, [-1,1] range\n// y = height,         [0,1] range\n// z = stride width,   [0,1] range\n// w = hip size,       [0,1] range\n\n// Feet:\n// x = x position\n// y = priority value, 0 or 1\n// z = x velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    vec4 tx = cell(ipx);\n    \n    // Initialize data on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0)) {        // Right foot\n            tx.xyz = vec3(0,1,0);\n        } else if (ipx == ivec2(0,1)) { // Left foot\n            tx.xyz = vec3(0,-1,0);\n        } else if (ipx == ivec2(0,2)) { // Dimension data\n            tx.x = 0.;\n            if (iFrame < 1) \n                tx.yzw = vec3(0.7, 0.8, 0);\n        }\n    }\n    \n    // Dimension data input\n    if (ipx == ivec2(0,2)) {\n        float dirChange = 0.1 * (key_val(KEY_D) - key_val(KEY_A));\n        //if (dirChange == 0.)\n        //    dirChange = -sign(tx.x) * 0.025;\n        tx.x = clamp(tx.x + dirChange, -1., 1.);  \n        \n        tx.y += 0.05  * (key_val(KEY_W) - key_val(KEY_S));\n        tx.z += 0.025 * (key_val(KEY_E) - key_val(KEY_Q));\n        tx.w += 0.05  * (key_val(KEY_G) - key_val(KEY_F));\n        tx.yzw = clamp(tx.yzw, 0., 1.);\n    }\n    else {\n        // The other foot \n        vec4 tx2 = cell(ivec2(0, 1-ipx.y));\n        \n        // Dimension info (stride width)\n        vec4 tx3 = cell(ivec2(0,2));\n        float sw = mix(swMin, swMax, tx3.z);\n    \n        // If feet are further than stride width apart,\n        // change foot priority and pass velocity to the other foot\n        if (abs(tx.x - tx2.x) > sw) { \n            tx.y = -tx.y;\n            tx.z = tx2.z;\n        }\n\n        // If this foot has priority, update it's motion\n        if (tx.y == 1.) {\n            if (key_down(KEY_A))\n                tx.z -= dx;\n            if (key_down(KEY_D))\n                tx.z += dx;\n            tx.z *= 0.9;\n            tx.x += tx.z;\n        }\n\n       if (abs(tx.x) > 0.5)\n           tx.x *= 0.99;\n   } \n   \n   fragColor = tx;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Thanks to:\n\n// elenzil for this really helpful shader:\n// https://www.shadertoy.com/view/DscGRH\n\n// IQ for sd functions :)\n\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define angle(a,b) atan(a.y-b.y, a.x-b.x)\n\n#define res iResolution.xy\n#define k (1./res.y)\n\n// Stride width min/max values\n#define swMin 0.1\n#define swMax 0.4\n\n// Radii of points\n#define r0 0.02\n#define r1 0.06\n\n// Stride acceleration increment\n#define dx (0.005 * sw)\n\nfloat sdBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\n", "buffer_b_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat laser(vec2 ress, vec2 px, vec4 tx3) {\n        vec2 uv = (px - 0.5 * ress) / ress.y;\n        uv.y += 0.35;\n        vec4 tx  = texelFetch(iChannel0, ivec2(0,0), 0); // Right foot\n        vec4 tx2 = texelFetch(iChannel0, ivec2(0,1), 0); // Left foot\n        float sw = mix(swMin, swMax, tx3.z);\n        float mx  = abs(tx.x-tx2.x)/sw;\n        float mxL = clamp(max(mx, tx.y), 0., 1.);    \n        float mxR = clamp(max(mx, tx2.y), 0., 1.);    \n        mxL = .5 + .5 * cos(pi*mxL);\n        mxR = .5 + .5 * cos(pi*mxR);\n        vec2 pFootL = vec2(tx2.x, r0 + 3. * mxL * r0);\n        vec2 pFootR = vec2(tx.x, r0 + 3. * mxR * r0);\n        vec2 pTarget = vec2(mix(tx.x,tx2.x,.5), pFootL.y + pFootR.y + 2.*r1);   \n        float aL = angle(pTarget, pFootL);\n        float aR = angle(pTarget, pFootR);\n        vec2 pKneeL = pFootL + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aL);\n        vec2 pKneeR = pFootR + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aR);\n        vec2 pHipL = pKneeL + (6.*tx3.y+2.*mx) * r0 * Dir(aL);\n        vec2 pHipR = pKneeR + (6.*tx3.y+2.*mx) * r0 * Dir(aR); \n        vec2 pBody = mix(pHipL, pHipR, 0.5);\n        vec2 dirOrbit = Dir(tx3.x*pi*(0.5-0.1*mx) - 0.5*pi);\n        vec2 pOrbit2 = pBody + (2.*r0+r1) * dirOrbit;\n        vec2 pOrbit3 = pOrbit2 + 2. * dirOrbit;\n        return exp(-1.*sdBox(uv, pOrbit2, pOrbit3, 0.));\n        //return smoothstep(-k, k, 0.0 - sdBox(uv,pOrbit2,pOrbit3,0.01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{    \n    // Dimension data\n    vec4 tx3 = cell(ivec2(0,2));\n    \n    vec4 txB = texelFetch(iChannel2, ivec2(px), 0);   \n    \n    // x checks if space is pressed, has a cooldown\n    txB.x = max(0., txB.x - 1./30. - 0.*px.x/res.x);\n    \n    // y draws laser and fades\n    //if (txB.y < 1.)\n    txB.y *= mix(1., txB.y, 1. );    \n    if (txB.y >= 1.)\n        txB.y = 0.;\n        \n    txB.y = clamp(txB.y, 0., 1.);\n    if (key_down(KEY_SPACE) && txB.x == 0.) {\n        // reset countdown\n        txB.x = 1.;       \n        \n        // --bad-- draw laser --bad--\n        txB.y = max(txB.y, laser(res, px, tx3));       \n    }\n               \n    fragColor = txB;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 131, 131, 250], [252, 298, 347, 347, 473], [475, 475, 547, 547, 608], [610, 610, 676, 676, 738], [740, 740, 821, 821, 888], [890, 890, 940, 940, 4229]], "test": "untested"}
{"id": "DdtGW8", "name": "Fork Wobble Car elenzil 761", "author": "elenzil", "description": "Minor variation of Dormon's cool wobble UVs:\nhttps://www.shadertoy.com/view/ds3GD8\n\nThis adds an orbiting component to each jump", "tags": ["angle", "intensity"], "likes": 9, "viewed": 217, "published": 3, "date": "1677197796", "time_retrieved": "2024-07-30T18:08:35.226018", "image_code": "int gCount = 0;\n\nvec2 jumpUsingIntensityAsAngle(vec2 uv, float p, float radius){\n  vec3 color;\n  if (gCount % 2 == 0) {\n      color = texture(iChannel0,uv).xyz;\n  }\n  else {\n      color = texture(iChannel1,uv).xyz;\n  }\n  float intensity = dot(color,vec3(1./3.f));\n  float angle = radians((intensity + p)*360.f);\n  return uv+vec2(cos(angle),sin(angle))*radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    const int num = 10;\n    if(fragCoord.x > iMouse.x)\n        for(int i=0;i<num;++i)\n            uv = jumpUsingIntensityAsAngle(uv, float(-i) / float(num), 0.003f);\n      \n    \n    \n    fragColor = texture(iChannel0,uv);\n    \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 80, 80, 361], [363, 363, 419, 419, 698]], "test": "untested"}
{"id": "dsd3z7", "name": "Graph maker", "author": "maras", "description": "Ripoff of graphtoy.\nMove camera using mouse.\nSpace restart camera and zoom.\nz + mouse for zooming.", "tags": ["graph", "plot"], "likes": 0, "viewed": 76, "published": 3, "date": "1677191988", "time_retrieved": "2024-07-30T18:08:36.337048", "image_code": "#define DRAW_F1 true\n#define DRAW_F2 true\n#define DRAW_F3 true\n#define DRAW_F4 true\n#define DRAW_F5 true\n\nfloat ZOOM_OUT;\n\n#define LINE_WIDTH ZOOM_OUT / 50.0\n#define AA_WIDTH LINE_WIDTH / 5.0\n\n// functions\n\nfloat f1(float x) {\n    return 4.0 + 4.0*smoothstep(0.0,0.7,sin(x+iTime));\n}\n\nfloat f2(float x) {\n    return sqrt(pow(9.0, 2.0) - pow(x,2.0));\n}\n\nfloat f3(float x) {\n    return 3.0*sin(x)/x;\n}\n\n\n// plotter\n\nfloat plotF(float fx, float y) {\n    return smoothstep(LINE_WIDTH, LINE_WIDTH - AA_WIDTH, abs(y - fx));\n}\n\nvoid drawPlots(vec2 uv, inout vec3 col) {\n    if (DRAW_F1) col = mix(col, vec3(0.8, 0.0, 0.0), plotF(f1(uv.x), uv.y));\n    if (DRAW_F2) col = mix(col, vec3(0.0, 0.0, 0.8), plotF(f2(uv.x), uv.y));\n    if (DRAW_F3) col = mix(col, vec3(0.0, 0.8, 0.0), plotF(f3(uv.x), uv.y));\n}\n\nfloat drawAxis(vec2 uv) {\n    vec2 axises = step(vec2(0.05), abs(uv));\n    return axises.x * axises.y;\n}\n\nfloat drawDottedAxis(vec2 uv) {\n    vec2 dotted = mod(uv * 4.0, 2.0);\n    uv = mod(uv, 1.0);\n    \n    vec2 axises = step(vec2(0.05), abs(uv));\n        \n    return max(axises.x, step(1.0, dotted.y)) * max(axises.y, step(1.0, dotted.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ZOOM_OUT = texture(iChannel0, vec2(0.8)).x;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= ZOOM_OUT;\n    \n    //vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    //uv += (mouse * 5.0);\n    vec2 mouse = texture(iChannel0, vec2(0.0)).xy;\n    uv += mouse;\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(1.0);\n    col *= drawAxis(uv);\n    col *= drawDottedAxis(uv);\n    //col = vec3(uv.x);\n    drawPlots(uv, col);    \n                    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float MOUSE_SPEED = 10.0; // less means faster\nfloat ZOOM_SPEED = 50.0; // less means faster\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (iFrame == 0 || texelFetch( iChannel1, ivec2(32,1),0 ).x > 0.5) {\n        if (uv.x <= 0.25) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        else if (uv.x <= 0.5) fragColor = vec4(-1000.0, 0.0, 0.0, 0.0);\n        else if (uv.x <= 1.0) fragColor = vec4(10.0, 0.0, 0.0, 0.0);\n        return;\n    }\n\n    vec2 act_offset = texture(iChannel0, vec2(0.0)).xy;\n    vec2 act_mouse = texture(iChannel0, vec2(0.35)).xy;\n    float act_zoom = texture(iChannel0, vec2(0.8)).x;\n\n    fragColor = texture(iChannel0, vec2(0.0));\n    \n    \n    if (iMouse.z > 0.0) {\n        if (act_mouse.x < -999.0) {\n            act_mouse = iMouse.xy / MOUSE_SPEED;\n        }\n        \n        bool z_pressed = texelFetch( iChannel1, ivec2(90,0),0 ).x > 0.5;\n        \n        vec2 move = act_mouse - iMouse.xy / MOUSE_SPEED;\n        \n        if (uv.x <= 0.25) {\n            if (!z_pressed) {\n                fragColor = vec4(act_offset + move / MOUSE_SPEED, 0.0, 0.0);\n            }\n            else {\n                fragColor = vec4(act_offset, 0.0, 0.0);\n            }\n        }\n        else if (uv.x <= 0.5) {\n            if (!z_pressed) {\n                fragColor = vec4(iMouse.xy / MOUSE_SPEED, 0.0, 0.0);\n            }\n            else {\n                fragColor = vec4(act_mouse, 0.0, 0.0);\n            }\n        }\n        if (uv.x > 0.5) {\n            fragColor = vec4(act_zoom, 0.0, 0.0, 0.0);\n            if (z_pressed) {\n                fragColor = vec4(act_zoom + move.y / ZOOM_SPEED, 0.0, 0.0, 0.0);\n            }\n        }\n        \n        return;\n    }\n\n    if (uv.x > 0.25 && uv.x <= 0.5) fragColor = vec4(-1000.0, 0.0, 0.0, 0.0);\n    else if (uv.x > 0.5) fragColor = texture(iChannel0, vec2(0.8));\n    \n    //fragColor = texture(iChannel0, fragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsd3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 226, 226, 283], [285, 285, 304, 304, 351], [353, 353, 372, 372, 399], [414, 414, 446, 446, 519], [521, 521, 562, 562, 795], [797, 797, 822, 822, 901], [903, 903, 934, 934, 1140], [1142, 1142, 1199, 1199, 1763]], "test": "untested"}
{"id": "ddcGW8", "name": "For the neon style enjoyers", "author": "mrange", "description": "CC0: For the neon style enjoyers\nOr is it synthwave style? Don't know!\nAnyone been tinkering with this for awhile and now want to get on with other stuff\nHopefully someone enjoys it.\n", "tags": ["neon"], "likes": 140, "viewed": 4738, "published": 3, "date": "1677182872", "time_retrieved": "2024-07-30T18:08:37.267560", "image_code": "// CC0: For the neon style enjoyers\n//  Or is it synthwave style? Don't know!\n//  Anyone been tinkering with this for awhile and now want to get on with other stuff\n//  Hopefully someone enjoys it.\n\n//#define THAT_CRT_FEELING\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nconst vec3 skyCol       = HSV2RGB(vec3(0.58, 0.86, 1.0));\nconst vec3 speCol1      = HSV2RGB(vec3(0.60, 0.25, 1.0));\nconst vec3 speCol2      = HSV2RGB(vec3(0.55, 0.25, 1.0));\nconst vec3 diffCol1     = HSV2RGB(vec3(0.60, 0.90, 1.0));\nconst vec3 diffCol2     = HSV2RGB(vec3(0.55, 0.90, 1.0));\nconst vec3 sunCol1      = HSV2RGB(vec3(0.60, 0.50, 0.5));\nconst vec3 sunDir2      = normalize(vec3(0., 0.82, 1.0));\nconst vec3 sunDir       = normalize(vec3(0.0, 0.05, 1.0));\nconst vec3 sunCol       = HSV2RGB(vec3(0.58, 0.86, 0.0005));\nconst float mountainPos = -20.0;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan_approx(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equilateralTriangle(vec2 p) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {\n  vec3 ce = dim.xyz;\n  float ra = dim.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nvec3 skyRender(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += 0.025*skyCol;\n  col += skyCol*0.0033/pow((1.001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += (0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nvec4 sphere(vec3 ro, vec3 rd, vec4 sdim) {\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  const vec3 lightPos1   = vec3(0.0, 10.0, 10.0);\n  const vec3 lightPos2   = vec3(0.0, -80.0, 10.0);\n  \n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n\n  const float sf = 4.0;\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));\n\n  vec3 nsky   = skyRender(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += nspe1;\n  scol += nspe2;\n  \n  float t = tanh_approx(2.0*(si.y-si.x)/sdim.w);\n  \n  return vec4(scol, t);\n}\n\nvec3 sphereRender(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyRender(ro, rd);\n  vec3 col = skyCol;\n  const vec4 sdim0 = vec4(vec3(0.0), 2.0);\n  vec4 scol0 = sphere(ro, rd, sdim0);\n  col = mix(col, scol0.xyz, scol0.w);\n  return col;\n}\n\nvec3 sphereEffect(vec2 p) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = sphereRender(ro, rd);\n  \n  return col;\n}\n\nvec3 cityOfKali(vec2 p) {\n  vec2 c = -vec2(0.5, 0.5)*1.12;\n\n  float s = 2.0;\n  vec2 kp = p/s;\n \n  const float a = PI/4.0;\n  const vec2 n = vec2(cos(a), sin(a));\n\n  float ot2 = 1E6;\n  float ot3 = 1E6;\n  float n2 = 0.0;\n  float n3 = 0.0;\n\n  const float mx = 12.0;\n  for (float i = 0.0; i < mx; ++i) {\n    float m = (dot(kp, kp));\n    s *= m;\n    kp = abs(kp)/m + c;\n    float d2 = (abs(dot(kp,n)))*s;\n    if (d2 < ot2) {\n      n2 = i;\n      ot2 = d2;\n    }\n    float d3 = (dot(kp, kp));\n    if (d3 < ot3) {\n      n3 = i;\n      ot3 = d3;\n    }\n  }\n  vec3 col = vec3(0.0);\n  n2 /= mx;\n  n3 /= mx;\n  col += 0.25*(hsv2rgb(vec3(0.8-0.2*n2*n2, 0.90, 0.025))/(sqrt(ot2)+0.0025));\n  col += hsv2rgb(vec3(0.55+0.8*n3, 0.85, 0.00000025))/(ot3*ot3+0.000000025);\n  return col;\n}\n\nvec3 outerSkyRender(vec3 ro, vec3 rd) {\n  vec3 center = ro+vec3(-100.0, 40.0, 100.0);\n  vec4 sdim = vec4(center, 50);\n  vec2 pi = raySphere(ro, rd, sdim);\n  const vec3 pn = normalize(vec3(0., 1.0, -0.8));\n  vec4 pdim = vec4(pn, -dot(pn, center)); \n  float ri = rayPlane(ro, rd, pdim);\n\n  vec3 col = vec3(0.0);\n  \n  col += sunCol/pow((1.001-((dot(sunDir, rd)))), 2.0);\n\n  if (pi.x != -1.0) {\n    vec3 pp = ro + rd*pi.x;\n    vec3 psp= pp-sdim.xyz;\n    vec3 pn = normalize(pp-sdim.xyz);\n    psp = psp.zxy;\n    psp.yz *= ROT(-0.5);\n    psp.xy *= ROT(0.025*TIME);\n    vec3 pss= toSpherical(psp);\n    vec3 pcol = vec3(0.0);\n    float dif = max(dot(pn, sunDir), 0.0);\n    vec3 sc = 2000.0*sunCol;\n    pcol += sc*dif;\n    pcol += (cityOfKali(pss.yz))*smoothstep(0.125, 0.0, dif);\n    pcol += pow(max(dot(reflect(rd, pn), sunDir), 0.0), 9.0)*sc;\n    col = mix(col, pcol, tanh_approx(0.125*(pi.y-pi.x)));\n    \n  }\n\n  vec3 gcol = vec3(0.0);\n\n  vec3 rp = ro + rd*ri;\n  float rl = length(rp-center);\n  float rb = 1.55*sdim.w;\n  float re = 2.45*sdim.w;\n  float rw = 0.1*sdim.w;\n  vec3 rcol = hsv2rgb(vec3(clamp((0.005*(rl+32.0)), 0.6, 0.8), 0.9, 1.0));\n  gcol = rcol*0.025;\n  if (ri > 0.0 && (pi.x == -1.0 || ri < pi.x)) {\n    float mrl = rl;\n    float nrl = mod1(mrl, rw);\n    float rfre = 1.0+dot(rd, pn);\n    vec3 rrcol = (rcol/max(abs(mrl), 0.1+smoothstep(0.7, 1.0, rfre))); \n    rrcol *= smoothstep(1.0, 0.3, rfre);\n    rrcol *= smoothstep(re, re-0.5*rw, rl);\n    rrcol *= smoothstep(rb-0.5*rw, rb, rl);\n    col += rrcol;;\n  }\n\n  col += gcol/max(abs(rd.y), 0.0033);\n\nreturn col;\n}\n\nvec3 triRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, -2.0);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  p *= 0.5;\n\n  const float off = 1.2-0.02;\n  vec2 op = p; \n  p.y -= off;\n  const vec2 n = SCA(-PI/3.0);\n  vec2 gp = p;\n  float hoff = 0.15*dot(n, p);\n  vec3 gcol = hsv2rgb(vec3(clamp(0.7+hoff, 0.6, 0.8), 0.90, 0.02));\n  vec2 pt = p;\n  pt.y = -pt.y;\n  const float zt = 1.0;\n  float dt = equilateralTriangle(pt/zt)*zt;\n//  col += 2.0*gcol;\n  col = dt < 0.0 ? sphereEffect(1.5*(p)) : col;\n  col += (gcol/max(abs(dt), 0.001))*smoothstep(0.25, 0.0, dt);\n  if (dt < 0.0) {\n    maxt = tpd;\n  }\n  return col;  \n}\n\nfloat heightFactor(vec2 p) {\n  return 4.0*smoothstep(7.0, 0.5, abs(p.x))+.5;\n}\n\nfloat hifbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat hiheight(vec2 p) {\n  return hifbm(p);\n}\n\nfloat lofbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat loheight(vec2 p) {\n  return lofbm(p)-0.5;\n}\n\nvec3 mountainRender(vec3 col, vec3 ro, vec3 rd, bool flip, inout float maxt) {\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, mountainPos);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n  if (tpd < 0.0 || tpd > maxt) {\n    return col;\n  }\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  const float cw = 1.0-0.25;\n  float hz = 0.0*TIME+1.0;\n  float lo = loheight(vec2(p.x, hz));\n  vec2 cp = p;\n  float cn = mod1(cp.x, cw);\n\n\n  const float reps = 1.0;\n\n  float d = 1E3;\n\n  for (float i = -reps; i <= reps; ++i) {\n    float x0 = (cn -0.5 + (i))*cw;\n    float x1 = (cn -0.5 + (i + 1.0))*cw;\n  \n    float y0 = hiheight(vec2(x0, hz));\n    float y1 = hiheight(vec2(x1, hz));\n    \n    float dd = segment(cp, vec2(-cw*0.5 + cw * float(i), y0), vec2(cw*0.5 + cw * float(i), y1));\n    \n    d = min(d, dd);\n  }\n\n  vec3 rcol = hsv2rgb(vec3(clamp(0.7+(0.5*(rd.x)), 0.6, 0.8), 0.95, 0.125));\n\n  float sd = 1.0001-((dot(sunDir, rd)));\n\n  vec3 mcol = col;\n  float aa = fwidth(p.y);\n  if ((dFdy(d) < 0.0) == !flip) {\n    mcol *= mix(0.0, 1.0, smoothstep(aa, -aa, d-aa));\n    mcol += HSV2RGB(vec3(0.55, 0.85, 0.8))*smoothstep(0.0, 5.0, lo-p.y);\n    col = mcol;\n    maxt = tpd;\n  }\n  col += 3.*rcol/(abs(d)+0.005+800.*sd*sd*sd*sd);\n  col += HSV2RGB(vec3(0.55, 0.96, 0.075))/(abs(p.y)+0.05);\n\n  return col;  \n}\n\nvec3 groundRender(vec3 col, vec3 ro, vec3 rd, inout float maxt) {\n  const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));\n  const vec4 gpdim = vec4(gpn, 0.0);\n  float gpd = rayPlane(ro, rd, gpdim);\n\n  if (gpd < 0.0) {\n    return col;\n  }\n  \n  maxt = gpd;\n  \n  vec3 gp     = ro + rd*gpd;\n  float gpfre = 1.0 + dot(rd, gpn);\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  gpfre *= gpfre;\n  \n  vec3 grr = reflect(rd, gpn);\n  \n  vec2 ggp    = gp.xz;\n  ggp.y += TIME;\n  float dfy   = dFdy(ggp.y);\n  float gcf = sin(ggp.x)*sin(ggp.y);\n  vec2 ggn    = mod2(ggp, vec2(1.0));\n  float ggd   = min(abs(ggp.x), abs(ggp.y));\n\n  vec3 gcol = hsv2rgb(vec3(0.7+0.1*gcf, 0.90, 0.02));\n  \n  float rmaxt = 1E6;\n  vec3 rcol = outerSkyRender(gp, grr);\n  rcol = mountainRender(rcol, gp, grr, true, rmaxt);\n  rcol = triRender(rcol, gp, grr, rmaxt);\n\n  col = gcol/max(ggd, 0.0+0.25*dfy)*exp(-0.25*gpd);\n  rcol += HSV2RGB(vec3(0.65, 0.85, 1.0))*gpfre;\n  rcol = 4.0*tanh(rcol*0.25);\n  col += rcol*gpfre;\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float maxt = 1E6;  \n\n  vec3 col = outerSkyRender(ro, rd);\n  col = groundRender(col, ro, rd, maxt);\n  col = mountainRender(col, ro, rd, false, maxt);\n  col = triRender(col, ro, rd, maxt);\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 1.0, -4.);\n  const vec3 la = vec3(0.0, 1.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = render(ro, rd);\n#if defined(THAT_CRT_FEELING)  \n  col *= smoothstep(1.5, 0.5, length(pp));\n  col *= 1.25*mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.25*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n#endif  \n  col -= 0.05*vec3(.00, 1.0, 2.0).zyx;\n  col = aces_approx(col); \n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 32476, "src": "https://soundcloud.com/lotekstyle/lotek-style-she-danced-to-tainted-love-distracted-globe-prom-night-mix?si=3d284d8939304a2db4af73bfa86ae6c2&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 649, 649, 795], [1089, 1180, 1202, 1202, 1527], [2089, 2175, 2212, 2212, 2319], [2321, 2381, 2409, 2475, 2551], [2553, 2553, 2579, 2579, 2695], [2697, 2797, 2816, 2816, 2903], [2905, 3012, 3038, 3038, 3222], [3224, 3310, 3349, 3349, 3474], [3476, 3562, 3598, 3598, 3692], [3694, 3806, 3848, 3848, 3895], [3898, 4016, 4051, 4051, 4250], [4252, 4370, 4397, 4397, 4473], [4475, 4593, 4632, 4632, 4743], [4745, 4805, 4826, 4826, 4896], [4898, 4982, 5004, 5004, 5338], [5340, 5462, 5506, 5506, 5751], [5753, 5753, 5787, 5787, 6550], [6552, 6552, 6594, 6594, 7604], [7606, 7606, 7643, 7643, 7834], [7836, 7836, 7863, 7863, 8220], [8222, 8222, 8247, 8247, 8985], [8987, 8987, 9026, 9026, 10558], [10560, 10560, 10622, 10622, 11351], [11353, 11353, 11381, 11381, 11431], [11433, 11433, 11454, 11454, 11698], [11700, 11700, 11724, 11724, 11745], [11747, 11747, 11768, 11768, 12012], [12014, 12014, 12038, 12038, 12063], [12065, 12065, 12143, 12143, 13380], [13382, 13382, 13447, 13447, 14361], [14363, 14363, 14394, 14394, 14600], [14602, 14602, 14632, 14632, 15293], [15295, 15295, 15352, 15352, 15526]], "test": "untested"}
{"id": "DscGDH", "name": "Blobs Aura", "author": "rge15", "description": "Some Blobs with some aura color.", "tags": ["blobs2d"], "likes": 8, "viewed": 341, "published": 3, "date": "1677177416", "time_retrieved": "2024-07-30T18:08:38.298802", "image_code": "#define PI 3.14159265\n\nstruct Blob\n{\n    vec2 center;\n    vec2 axis_speed;\n    vec3 color;\n    float radius;\n    \n};\n\nconst int numBlobs = 5;\nconst float distBlobs = 1./float(numBlobs);\n\nfloat N21_limitless( in vec2 p )\n{\n    p = 50.*fract( p/PI + vec2(0.71,0.113) );\n\n    return -1. + 2. * fract( p.x*p.y*(p.x+p.y)); \n}\n\nfloat N21_normal(vec2 co)\n{\n    return fract(N21_limitless(co));\n}\n\n\nBlob blobs[numBlobs];\nvec2 N12(in int i)\n{\n    vec2 value = vec2(i, i+1); \n    return normalize(value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    for(int i = 0 ; i < numBlobs; i++)\n    {\n        blobs[i].center = vec2(float(i+1)*distBlobs);\n        \n        float speedX = N21_limitless(vec2(i));\n        float speedY = N21_limitless(vec2(i+2));\n        speedX = mod(speedX,4.);\n        speedY = mod(speedY,4.);\n        blobs[i].axis_speed = vec2(speedX, speedY);\n        \n        blobs[i].center.x *= sin(speedX*iTime);\n        blobs[i].center.y *= cos(speedY*iTime);\n    \n        blobs[i].radius = N21_normal(vec2(i));\n     \n        float colX = N21_normal(vec2(i+5,i));\n        float colY = N21_normal(vec2(i,i+3));\n        float colZ = N21_normal(vec2(i+2,i+7));\n        blobs[i].color = vec3(colX,colY,colZ);\n    }\n\n    float length_blob = 1.;\n    float length_total = 1.;\n    vec3 color = vec3(1.);\n    \n    for(int i = 0 ; i < numBlobs; i++)\n    {\n        length_blob = length(uv-blobs[i].center);\n        length_total *= length_blob;\n        length_blob = 1.-length_blob;\n        color += length_blob*blobs[i].color;\n    }\n\n    length_total = smoothstep(0.,1.,clamp(1.-length_total,0.,1.));\n    length_total = 1.-length_total;\n\n    // Time varying pixel color\n    vec3 col = vec3(length_total*color);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 221, 221, 320], [322, 322, 349, 349, 388], [413, 413, 433, 433, 496], [498, 498, 555, 605, 1894]], "test": "untested"}
{"id": "cs3GRH", "name": "White Rabbit", "author": "toomuchvoltage", "description": "White Rabbit", "tags": ["raymarch", "voxels", "sdf", "white", "trace", "unpack", "hierarchy", "jfa", "rabbit", "spheremarch", "bitstream"], "likes": 7, "viewed": 418, "published": 3, "date": "1677175542", "time_retrieved": "2024-07-30T18:08:39.392877", "image_code": "/***********************************************************\n\n   This is a follow up to https://www.shadertoy.com/view/dlBGRc\n   This time around, I'm decoding and jump flooding the voxels into a channel and sphere marching via reading from the channel.\n   Created using Shadertoy-utils by yours truly :) : https://github.com/toomuchvoltage/shadertoy-utils\n   SDFs and the simplex noise are belong to iq: https://www.shadertoy.com/view/Msf3WH\n                                            https://iquilezles.org/articles/distfunctions/\n   Additionally you should read iq's rather old write up on SDF hierarchies as it boxes the bunny:\n   https://iquilezles.org/articles/sdfbounding/\n   The white noise for the plains is from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n   The song is Jefferson Airplane - White Rabbit, a staple of 70's counter-culture\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z) * 2.0 - 1.0;\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fBm (in vec2 uv)\n{\n    float f = 0.0;\n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return (f + 1.0) * 0.5;\n}\n\nfloat warp (vec2 uv, float time)\n{\n    return fBm (vec2 (fBm(uv) + time * 0.1, fBm(uv.yx) - time * 0.1));\n}\n\nvec3 lsd (vec2 uv, float time)\n{\n    uv -= vec2 (0.5);\n    uv = abs(uv);\n    uv = (mat2 (cos(time * 0.1), sin(time * 0.1), -sin(time * 0.1), cos(time * 0.1))) * uv;\n    return (0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4))) * warp (uv, time);\n}\n\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfGrid0(vec3 p)\n{\n    p = floor (p * 4.0) * 0.25;\n    if ( clamp (p, grid0Min, grid0Max - vec3 (0.25)) != p ) return 0.25;\n\n    float pzBlock = (p.z - grid0Min.z) * 4.0;\n    uint diffZ = uint (pzBlock * 0.0625);\n    uint xBase = uint ((p.x - grid0Min.x) * 4.0);\n    uint yBase = uint ((p.y - grid0Min.y) * 4.0);\n    yBase += diffZ * uint (grid0Range.y * 4.0);\n    uint pickChannelBits = uint (pzBlock) % 16u;\n    uint pickedUint;\n    vec4 readTexel = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n    switch (pickChannelBits / 4u)\n    {\n        case 0u:\n            pickedUint = floatBitsToUint (readTexel.x);\n            break;\n        case 1u:\n            pickedUint = floatBitsToUint (readTexel.y);\n            break;\n        case 2u:\n            pickedUint = floatBitsToUint (readTexel.z);\n            break;\n        case 3u:\n            pickedUint = floatBitsToUint (readTexel.a);\n            break;\n    }\n\n    uint fetchShift = (24u - ((pickChannelBits % 4u) * 8u));\n    uint readDistance = ((pickedUint & (0x000000FFu << fetchShift)) >> fetchShift);\n\n    return float(readDistance) * 0.1;\n}\n\nfloat scene(vec3 p)\n{\n    p.xz *= 0.125;\n    vec2 q = mod(p.xz, M_PI * 2.0);\n    vec2 q2 = mod(p.xz, M_PI);\n    vec2 p2 = floor (p.xz / (M_PI * 2.0));\n    float height = hash12(p2 * 100.0) * 2.5;\n    float sin_q_x = sin(q.x);\n    float sin_q_y = sin(q.y);\n    float sign1 = sign (q.x - M_PI);\n    float sign2 = sign (q.y - M_PI);\n    float plainsHeight = 2.0 - sign1 * sign2 * height;\n    vec3 translation = vec3 (M_PI * 0.5, plainsHeight, M_PI * 0.5);\n    vec3 boxP = vec3 (q2.x, p.y, q2.y) - translation;\n    float box = sdBox (boxP, vec3 (grid0Range.x * 0.5 * 0.125, grid0Range.y * 0.5, grid0Range.z * 0.5 * 0.125));\n    if ( box < 0.5 )\n    {\n        boxP.x *= 8.0;\n        boxP.z *= 8.0;\n        box = sdfGrid0 (boxP);\n    }\n    float plains = p.y + 3.0 + sin_q_x * sin_q_y * height;\n    return min(box, plains);\n}\n\nfloat sceneAccurate(vec3 p)\n{\n    p.xz *= 0.125;\n    vec2 q = mod(p.xz, M_PI * 2.0);\n    vec2 q2 = mod(p.xz, M_PI);\n    vec2 p2 = floor (p.xz / (M_PI * 2.0));\n    float height = hash12(p2 * 100.0) * 2.5;\n    float sin_q_x = sin(q.x);\n    float sin_q_y = sin(q.y);\n    float sign1 = sign (q.x - M_PI);\n    float sign2 = sign (q.y - M_PI);\n    float plainsHeight = 2.0 - sign1 * sign2 * height;\n    vec3 translation = vec3 (M_PI * 0.5, plainsHeight, M_PI * 0.5);\n    vec3 boxP = vec3 (q2.x, p.y, q2.y) - translation;\n    float box = sdBox (boxP, vec3 (grid0Range.x * 0.5 * 0.125, grid0Range.y * 0.5, grid0Range.z * 0.5 * 0.125));\n    if ( box < 0.25 )\n    {\n        boxP.x *= 8.0;\n        boxP.z *= 8.0;\n        \n        vec3 mixAmt = mod (fract (boxP), 0.25) * 4.0;\n        \n        float grid000 = sdfGrid0 (boxP);\n        float grid001 = sdfGrid0 (boxP + vec3 (0.0, 0.0, 0.25));\n        float grid010 = sdfGrid0 (boxP + vec3 (0.0, 0.25, 0.0));\n        float grid011 = sdfGrid0 (boxP + vec3 (0.0, 0.25, 0.25));\n        float grid100 = sdfGrid0 (boxP + vec3 (0.25, 0.0, 0.0));\n        float grid101 = sdfGrid0 (boxP + vec3 (0.25, 0.0, 0.25));\n        float grid110 = sdfGrid0 (boxP + vec3 (0.25, 0.25, 0.0));\n        float grid111 = sdfGrid0 (boxP + vec3 (0.25));\n        float gridEval = mix (\n                            mix (mix (grid000, grid001, mixAmt.z), mix (grid010, grid011, mixAmt.z), mixAmt.y),\n                            mix (mix (grid100, grid101, mixAmt.z), mix (grid110, grid111, mixAmt.z), mixAmt.y),\n                            mixAmt.x);\n        box = min (0.25, gridEval);\n    }\n    else\n        box = 0.25;\n    float plains = p.y + 3.0 + sin_q_x * sin_q_y * height;\n    return min(box, plains);\n}\n\nvec3 sceneNormal (vec3 p)\n{\n    float dx = sceneAccurate(vec3 (p.x + 0.01, p.y, p.z)) - sceneAccurate(vec3 (p.x - 0.01, p.y, p.z));\n    float dy = sceneAccurate(vec3 (p.x, p.y + 0.01, p.z)) - sceneAccurate(vec3 (p.x, p.y - 0.01, p.z));\n    float dz = sceneAccurate(vec3 (p.x, p.y, p.z + 0.01)) - sceneAccurate(vec3 (p.x, p.y, p.z - 0.01));\n    return normalize (vec3 (dx, dy, dz) + vec3 (0.0001));\n}\n\nvec2 toSpherical(vec3 inpVec)\n{\n\tvec3 inpVecOnXZ = normalize (vec3(inpVec.x, 0.0, inpVec.z));\n\tfloat phi = acos(inpVecOnXZ.x);\n\tif (inpVecOnXZ.z < 0.0) phi = 2.0 * M_PI - phi;\n\tfloat theta = acos(inpVec.y);\n\treturn vec2(phi * (1.0/(2.0 * M_PI)), theta * (1.0/M_PI));\n}\n\nvec3 probeLSD (vec3 sampleDir, float curTime)\n{\n    vec2 sph = toSpherical(sampleDir);\n    sph -= vec2 (0.5);\n    sph = abs(sph);\n    return (0.5 + 0.5*cos(curTime+sph.xyx+vec3(0,2,4)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fetchUV = fragCoord.xy / iResolution.xy;\n    vec2 uvDenorm =(fetchUV - vec2 (0.5)) * 2.0;\n    float curTime = iTime;\n    vec3 curEye = vec3 (curTime * 5.0, 8.0, curTime * 5.0);\n    vec3 curLook = normalize (vec3 (0.0, 0.0, 1.0));\n    vec3 curSide = normalize (cross (vec3 (0.0, 1.0, 0.0), curLook));\n    vec3 curUp = cross (curLook, curSide) * (iResolution.y / iResolution.x);\n    vec3 curDir = normalize (curLook + curSide * uvDenorm.x + curUp * uvDenorm.y);\n    vec3 curPos = curEye + curDir;\n    \n    vec3 bgColor = lsd(fetchUV, curTime);\n    bgColor = clamp (bgColor, vec3 (0.0), vec3 (1.0));\n    bgColor = pow (bgColor, vec3 (2.2));\n    \n    float distTravelled = 1.0;\n    for (int i = 0; i != 300; i++)\n    {\n        float r = scene(curPos);\n        if (abs(r) < 0.01f) {\n            vec3 diffVec = curPos - curEye;\n            float distToEye = dot(diffVec, diffVec);\n            vec3 curNorm = sceneNormal(curPos);\n            vec3 whiteColor = clamp (vec3 (distToEye * 0.001), vec3 (0.0), vec3(1.0));\n            whiteColor = vec3 (1.0);\n            float AOTerm = 0.0;\n            AOTerm += max (sceneAccurate (curPos + 0.1 * curNorm), 0.0);\n            AOTerm += max (sceneAccurate (curPos + 0.2 * curNorm), 0.0) * 0.5;\n            AOTerm += max (sceneAccurate (curPos + 0.3 * curNorm), 0.0) * 0.3333;\n            AOTerm += max (sceneAccurate (curPos + 0.4 * curNorm), 0.0) * 0.25;\n            AOTerm += max (sceneAccurate (curPos + 0.5 * curNorm), 0.0) * 0.2;\n            AOTerm += max (sceneAccurate (curPos + 0.6 * curNorm), 0.0) * 0.16666666;\n            AOTerm += max (sceneAccurate (curPos + 0.7 * curNorm), 0.0) * 0.14;\n            AOTerm += max (sceneAccurate (curPos + 0.8 * curNorm), 0.0) * 0.125;\n            AOTerm += max (sceneAccurate (curPos + 0.9 * curNorm), 0.0) * 0.1111111;\n            whiteColor *= clamp (AOTerm, 0.3, 1.0);\n            whiteColor *= clamp (probeLSD(curNorm, curTime), vec3 (0.3), vec3 (1.0));\n            \n            if ( distToEye > 2000.0 ) bgColor = mix (bgColor, whiteColor, (7000.0 - distToEye) / 5000.0);\n            else bgColor = whiteColor;\n            fragColor = vec4 (pow (bgColor, vec3 (1.0/2.2)), 1.0);\n            return;\n        }\n        curPos += curDir * r;\n        distTravelled += r;\n        if (distTravelled > sqrt(7000.0)) break;\n    }\n\n    fragColor = vec4(pow (bgColor, vec3 (1.0/2.2)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32452, "src": "https://soundcloud.com/anarchyjournal/jefferson-airplane-white", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "/***********************************************************\n\n   This is a follow up to https://www.shadertoy.com/view/dlBGRc\n   This time around, I'm decoding and jump flooding the voxels into a channel and sphere marching via reading from the channel.\n   Created using Shadertoy-utils by yours truly :) : https://github.com/toomuchvoltage/shadertoy-utils\n   SDFs and the simplex noise are belong to iq: https://www.shadertoy.com/view/Msf3WH\n                                            https://iquilezles.org/articles/distfunctions/\n   Additionally you should read iq's rather old write up on SDF hierarchies as it boxes the bunny:\n   https://iquilezles.org/articles/sdfbounding/\n   The white noise for the plains is from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n   The song is Jefferson Airplane - White Rabbit, a staple of 70's counter-culture\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\nuint countSetBits(uint n)\n{\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nuint countSetBitsBefore(uint n, uint comp)\n{\n    uint beforeMask = comp ^ (comp - 1u); // See: https://realtimecollisiondetection.net/blog/?p=78\n    n &= (~beforeMask);\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[480] = uint[](128u,2210513095u,3479298144u,1206382640u,2955944416u,2948644703u,3759157328u,4287565583u,3759675512u,2139587772u,802340674u,3188982804u,141045714u,2138838076u,868254667u,3286638110u,504914401u,2400088239u,4111435140u,25231882u,717225475u,1058011896u,3229678206u,2130212960u,2131742716u,1009857343u,2275802654u,3097205408u,547535824u,2192417534u,3288236371u,3896412222u,505289727u,4279177016u,4043288476u,2021159043u,2386045908u,708321408u,3052425285u,4261731647u,2600436334u,1905893279u,4231802947u,3476757529u,3877378112u,1105215936u,34434u,4289098691u,3288284978u,4058111969u,1368453360u,4030781552u,2018533408u,540094515u,863606808u,301587464u,2349928471u,3958414079u,1086318151u,2701128451u,61471098u,2156002367u,62979548u,3180696977u,2123695444u,358083563u,1106362448u,272611232u,1587628053u,2095138053u,3746421117u,802705685u,17108991u,944109840u,2236852288u,1090600768u,3208819995u,1789041304u,2577271807u,4244787370u,4078985120u,265989392u,626174633u,277056386u,2952430954u,532654112u,573780048u,4286382072u,404256888u,2308730983u,4027342703u,3436158974u,2146558435u,2551187007u,867382067u,865704345u,2576993484u,3704409341u,3258775938u,3176781832u,2297956543u,3808397308u,71073779u,4062383231u,4001299939u,3858923261u,4294504910u,2281914348u,3370546118u,1063543298u,537132546u,4261943487u,4271477196u,4224646856u,3292938240u,272650234u,4016187103u,4133678343u,4080218316u,3476239359u,3120287513u,2441110503u,4294757583u,4090285104u,553641598u,4193511022u,2294243840u,2818752010u,1848374463u,3254062863u,2127319104u,2682678906u,2545967183u,3435708155u,4231000385u,432095607u,285339157u,284091511u,1148523596u,1145953754u,626850341u,3632174440u,359142741u,1118551722u,2863275440u,1521198420u,1252047863u,717509418u,3288667447u,1947428677u,3120952896u,1094996991u,1600391359u,1428034056u,16427093u,542637738u,1119939523u,3764511729u,4050662903u,4002366143u,130351256u,410541068u,1010581182u,515774602u,737923627u,3004883152u,1509530008u,2144597893u,4231843327u,3263414787u,1106579704u,410548344u,2084322364u,809377310u,403708943u,235416312u,1731735602u,3482858001u,3677724u,166411u,4256956382u,4232957900u,3451073271u,1986419065u,4052775731u,858829601u,2441190596u,1288490207u,4268161167u,1449650319u,1009265720u,1162105604u,4116665695u,4114841579u,3926179344u,2856591392u,4126637728u,938539692u,67170282u,357892821u,39127072u,1874417153u,2105410472u,717184855u,1470217045u,1428347733u,571195218u,3158670264u,1079326545u,1072002912u,1604612128u,680036493u,3712343713u,1440621329u,286263846u,1713861618u,4144182067u,4169136513u,2174327168u,4026721826u,601629663u,4084412932u,4208664577u,85018111u,2945462233u,4110471175u,4286675613u,3793592382u,2151743801u,2155977084u,4169173120u,717083454u,3154037963u,3003960254u,1637456281u,2670775436u,3436157319u,3060164556u,4088607539u,3996247560u,434274295u,717079091u,1787128459u,4164421880u,257162247u,3278619619u,3275833600u,1052572127u,3781082648u,2693315316u,341137392u,804388289u,3519082624u,262318170u,99517628u,787753794u,2906981461u,83750360u,653103197u,2554865794u,2750130721u,3876522510u,4117868073u,2155911579u,2880295434u,2916137919u,2831494024u,3577881349u,871633902u,1738041274u,1731343139u,848857241u,2564676733u,3808693497u,2974916321u,7540787u,858995097u,2417596816u,2155881986u,645005824u,359751649u,823902198u,1639497159u,4292310531u,2818932589u,830078335u,4294246389u,2635153856u,44739310u,552586956u,3186548104u,3860437401u,2582842572u,3436181894u,1718085244u,3274912563u,1047109219u,3059754667u,2113579688u,4146775159u,684012417u,3185398955u,1420475220u,1414874165u,1363219957u,1079339767u,2102744389u,1413815632u,366826968u,357914485u,1467193481u,2592717738u,2732401341u,179015024u,2411672478u,568205431u,1362022673u,785458779u,1717003460u,1103939548u,3809811491u,1440483938u,1646683955u,926936271u,2579996262u,1741474824u,4002152450u,570564978u,863502128u,3493413888u,2855251616u,2050484286u,536879654u,1648291565u,3366878410u,2925648319u,3882300403u,858915737u,2583200137u,3426431964u,4243502958u,2724621994u,3903335624u,2343400104u,1463636000u,2157835338u,2847797764u,1512267499u,1587762346u,335902077u,1410509800u,3755666049u,706029661u,2170508670u,33166762u,948444056u,2595470683u,3041042603u,2297890824u,4151451042u,998733074u,3977315069u,306673526u,1145324621u,4248974685u,3405070562u,40265331u,785182542u,4186334822u,1727842172u,3471343616u,499u,1357113102u,284424167u,3884189752u,4056380211u,590590777u,2156501401u,2631716047u,993058526u,2107101574u,3707808442u,4203227235u,3812451259u,3256942850u,2677709668u,163029666u,4196412085u,4155116048u,2868572290u,2947481239u,3356977160u,747284398u,2726734856u,2864641032u,547417086u,2776108975u,2852240829u,1153389611u,3716223248u,270268584u,2943355891u,4228260522u,5584208u,272098427u,2272765032u,462565435u,3287848969u,4194171908u,1308099677u,4087566845u,290458114u,118698865u,59898265u,2172700672u,11u,2290648947u,3208630076u,3234740275u,2678056550u,1712855483u,860142112u,3450012993u,1138225127u,337383764u,3791279575u,3244245119u,3059112932u,67235856u,2941298647u,2231728215u,4161258114u,3286278176u,2431680288u,4289712893u,41780485u,8213547u,3492795408u,635461281u,4272287920u,2968533048u,947420220u,1072201707u,4095726655u,1363230741u,218369513u,2112387719u,2919545868u,3158299634u,1040326207u,4192304903u,125730528u,4034981951u,1078985600u,2180641853u,1069596736u,4229930976u,1616934975u,941621248u,0u,2282245244u,4039911032u,2036729363u,187826218u,3170083338u,418434846u,1045493886u,2123921535u,3912681479u,2865489930u,36173420u,2302931796u,3205692963u,4193787455u,2575403127u,4160876624u,4030787824u,2021154816u,0u,0u);\n\nuint readBitsSVO0 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject0[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject0[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject0[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO0 (vec3 samplePos) {\n    if ( any(lessThan(samplePos, grid0Min)) || any(greaterThan(samplePos, grid0Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid0Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO0 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO0 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO0 (streamReadPos, 1u);\n    if (topBrick == 0u) return false;\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO0 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid0Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) return false;\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO0 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n        checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    return false;\n}\n\nvoid decodeAndJFA_SVO0( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 pixCoord = uvec2 (fragCoord - vec2 (0.5));\n    const uint tilingSide = uint (floor (sqrt(grid0Range.z))) + 1u;\n\n    int log2N = int(ceil(log2(max (max(grid0Range.x * 4.0, grid0Range.y * 4.0), grid0Range.z * 4.0))));\n    float offsetPower = float (log2N - (iFrame-1) - 1);\n    bool isInJFAResolution = all (lessThan (pixCoord,uvec2 (uint(grid0Range.x), uint(grid0Range.y)) * 4u * tilingSide));\n    float zRange = ceil (grid0Range.z * 4.0 * 0.0625);\n    bool isInJFACompactionResolution = all (lessThan (pixCoord, uvec2 (uint(grid0Range.x * 4.0), uint(grid0Range.y * 4.0 * zRange))));\n\n    if ( iFrame == 0 && isInJFAResolution ) {\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = (float (pixCoord.y / uint(grid0Range.y * 4.0)) * float(tilingSide) + float (pixCoord.x / uint(grid0Range.x * 4.0))) * 4.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        if ( baseCoord.z >= grid0Max.z )\n        {\n            fragColor = vec4 (uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u));\n            return ;\n        }\n        uint writeR = 0u, writeG = 0u, writeB = 0u, writeA = 0u;\n        vec3 pos1 = baseCoord + vec3 (0, 0, 0);\n        vec3 pos2 = baseCoord + vec3 (0, 0, 0.25);\n        vec3 pos3 = baseCoord + vec3 (0, 0, 0.5);\n        vec3 pos4 = baseCoord + vec3 (0, 0, 0.75);\n        bool occupancy1 = readLeafSVO0 (pos1 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy2 = readLeafSVO0 (pos2 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy3 = readLeafSVO0 (pos3 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy4 = readLeafSVO0 (pos4 + vec3 (0.001, -0.001, 0.001));\n        if ( occupancy1 )\n        {\n            pos1 *= 4.0;\n            pos1 += vec3(uint(grid0Range * 4.0)/2u);\n            writeR = 0xFF000000u;\n            writeR |= (uint(pos1.x) << 16);\n            writeR |= (uint(pos1.y) << 8);\n            writeR |= uint(pos1.z);\n        }\n        if ( occupancy2 )\n        {\n            pos2 *= 4.0;\n            pos2 += vec3(uint(grid0Range * 4.0)/2u);\n            writeG = 0xFF000000u;\n            writeG |= (uint(pos2.x) << 16);\n            writeG |= (uint(pos2.y) << 8);\n            writeG |= uint(pos2.z);\n        }\n        if ( occupancy3 )\n        {\n            pos3 *= 4.0;\n            pos3 += vec3(uint(grid0Range * 4.0)/2u);\n            writeB = 0xFF000000u;\n            writeB |= (uint(pos3.x) << 16);\n            writeB |= (uint(pos3.y) << 8);\n            writeB |= uint(pos3.z);\n        }\n        if ( occupancy4 )\n        {\n            pos4 *= 4.0;\n            pos4 += vec3(uint(grid0Range * 4.0)/2u);\n            writeA = 0xFF000000u;\n            writeA |= (uint(pos4.x) << 16);\n            writeA |= (uint(pos4.y) << 8);\n            writeA |= uint(pos4.z);\n        }\n        fragColor = vec4 (uintBitsToFloat(writeR), uintBitsToFloat(writeG), uintBitsToFloat(writeB), uintBitsToFloat(writeA));\n    } else if ( iFrame > 0 && offsetPower >= 0.0 && isInJFAResolution ) {\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = (float (pixCoord.y / uint(grid0Range.y * 4.0)) * float(tilingSide) + float (pixCoord.x / uint(grid0Range.x * 4.0))) * 4.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        if ( baseCoord.z >= grid0Max.z )\n        {\n            fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n            return ;\n        }\n\n        vec4 fragmentRead = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n        uint baseR = floatBitsToUint(fragmentRead.x);\n        uint baseG = floatBitsToUint(fragmentRead.y);\n        uint baseB = floatBitsToUint(fragmentRead.z);\n        uint baseA = floatBitsToUint(fragmentRead.a);\n        float offsetAmt = pow (2.0, offsetPower);\n        for (int zBrick = 0; zBrick != 4; zBrick++)\n        {\n            vec3 curCoord = baseCoord + vec3 (0, 0, float(zBrick) * 0.25);\n\n            float minDist = 100000.0;\n            uvec3 minCoord = uvec3 (0);\n            bool foundMinCoord = false;\n            for (int i = -1; i != 2; i++)\n                for (int j = -1; j != 2; j++)\n                    for (int k = -1; k != 2; k++)\n                    {\n                        vec3 sampleLoc = curCoord + vec3(i, j, k) * 0.25 * offsetAmt; \n\n                        if ( sampleLoc.x < grid0Min.x || sampleLoc.x >= grid0Max.x ) continue;\n                        if ( sampleLoc.y < grid0Min.y || sampleLoc.y >= grid0Max.y ) continue;\n                        if ( sampleLoc.z < grid0Min.z || sampleLoc.z >= grid0Max.z ) continue;\n\n                        float diffZ = sampleLoc.z - grid0Min.z;\n                        float fractionalZ = fract(diffZ);\n                        uint topLevelZ = uint(diffZ);\n                        uint xBase = (topLevelZ % tilingSide) * 4u * uint(grid0Range.x);\n                        uint yBase = (topLevelZ / tilingSide) * 4u * uint(grid0Range.y);\n                        xBase += uint ((sampleLoc.x - grid0Min.x) * 4.0);\n                        yBase += uint ((sampleLoc.y - grid0Min.y) * 4.0);\n\n                        vec4 readFrag = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n                        uint readUint;\n                        if ( fractionalZ == 0.0 ) readUint = floatBitsToUint (readFrag.x);\n                        else if ( fractionalZ == 0.25 ) readUint = floatBitsToUint (readFrag.y);\n                        else if ( fractionalZ == 0.5 ) readUint = floatBitsToUint (readFrag.z);\n                        else readUint = floatBitsToUint (readFrag.a);\n\n                        uint readR = ((readUint & 0x00FF0000u) >> 16);\n                        uint readG = ((readUint & 0x0000FF00u) >> 8);\n                        uint readB = (readUint  & 0x000000FFu);\n                        vec3 sampledCoord = (vec3 (readR, readG, readB) - vec3(uint(grid0Range * 4.0)/2u)) * 0.25;\n\n                        float sampledDist = length (sampledCoord - curCoord);\n\n                        if ( readUint != 0u && sampledDist < minDist)\n                        {\n                           minDist = sampledDist;\n                           minCoord = uvec3 (readR, readG, readB);\n                           foundMinCoord = true;\n                        }\n                    }\n\n            if ( !foundMinCoord ) continue;\n            if ( zBrick == 0 )\n            {\n                baseR = 0xFF000000u;\n                baseR |= (minCoord.x << 16);\n                baseR |= (minCoord.y << 8);\n                baseR |= minCoord.z;\n            }\n            else if ( zBrick == 1 )\n            {\n                baseG = 0xFF000000u;\n                baseG |= (minCoord.x << 16);\n                baseG |= (minCoord.y << 8);\n                baseG |= minCoord.z;\n            }\n            else if ( zBrick == 2 )\n            {\n                baseB = 0xFF000000u;\n                baseB |= (minCoord.x << 16);\n                baseB |= (minCoord.y << 8);\n                baseB |= minCoord.z;\n            }\n            else\n            {\n                baseA = 0xFF000000u;\n                baseA |= (minCoord.x << 16);\n                baseA |= (minCoord.y << 8);\n                baseA |= minCoord.z;\n            }\n        }\n\n        fragColor = vec4 (uintBitsToFloat(baseR), uintBitsToFloat(baseG), uintBitsToFloat(baseB), uintBitsToFloat(baseA));\n    } else if ( iFrame > 0 && offsetPower == -1.0 ) {\n        if ( !isInJFACompactionResolution )\n        {\n            fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n            return ;\n        }\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = float (pixCoord.y / uint(grid0Range.y * 4.0)) * 16.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        uint writeR = 0u, writeG = 0u, writeB = 0u, writeA = 0u;\n        for (int i = 0; i != 16; i++)\n        {\n            vec3 sampleLoc = baseCoord + vec3 (0, 0, float(i) * 0.25);\n\n            if ( sampleLoc.x < grid0Min.x || sampleLoc.x >= grid0Max.x ) continue;\n            if ( sampleLoc.y < grid0Min.y || sampleLoc.y >= grid0Max.y ) continue;\n            if ( sampleLoc.z < grid0Min.z || sampleLoc.z >= grid0Max.z ) continue;\n\n            float diffZ = sampleLoc.z - grid0Min.z;\n            float fractionalZ = fract(diffZ);\n            uint topLevelZ = uint(diffZ);\n            uint xBase = (topLevelZ % tilingSide) * 4u * uint(grid0Range.x);\n            uint yBase = (topLevelZ / tilingSide) * 4u * uint(grid0Range.y);\n            xBase += uint ((sampleLoc.x - grid0Min.x) * 4.0);\n            yBase += uint ((sampleLoc.y - grid0Min.y) * 4.0);\n\n            vec4 readFrag = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n            uint readUint;\n            if ( fractionalZ == 0.0 ) readUint = floatBitsToUint (readFrag.x);\n            else if ( fractionalZ == 0.25 ) readUint = floatBitsToUint (readFrag.y);\n            else if ( fractionalZ == 0.5 ) readUint = floatBitsToUint (readFrag.z);\n            else readUint = floatBitsToUint (readFrag.a);\n\n            uint readR = ((readUint & 0x00FF0000u) >> 16);\n            uint readG = ((readUint & 0x0000FF00u) >> 8);\n            uint readB = (readUint  & 0x000000FFu);\n            vec3 sampledCoord = (vec3 (readR, readG, readB) - vec3(uint(grid0Range * 4.0)/2u)) * 0.25;\n\n            float sampledDist = clamp (floor (length (sampledCoord - sampleLoc) * 10.0), 0.0, 255.0);\n            int channelSelect = i / 4;\n            int shiftAmount = 24 - ((i % 4) * 8);\n            switch (channelSelect)\n            {\n                case 0:\n                    writeR |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 1:\n                    writeG |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 2:\n                    writeB |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 3:\n                    writeA |= (uint(sampledDist) << shiftAmount);\n                    break;\n            }\n        }\n        fragColor = vec4 (uintBitsToFloat(writeR), uintBitsToFloat(writeG), uintBitsToFloat(writeB), uintBitsToFloat(writeA));\n    } else\n        fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    decodeAndJFA_SVO0 (fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3GRH.jpg", "access": "api", "license": "mit", "functions": [[2272, 2272, 2329, 2329, 2444], [2446, 2446, 2468, 2468, 2597], [2599, 2599, 2625, 2625, 3104], [3106, 3106, 3130, 3130, 3398], [3400, 3400, 3434, 3434, 3507], [3509, 3509, 3541, 3541, 3746], [3891, 3891, 3922, 3922, 4013], [4015, 4015, 4039, 4039, 5121], [5123, 5123, 5144, 5144, 5942], [5944, 5944, 5973, 5973, 7661], [7663, 7663, 7690, 7690, 8062], [8064, 8064, 8095, 8095, 8332], [8334, 8334, 8381, 8381, 8522], [8524, 8524, 8581, 8581, 10960]], "test": "untested"}
{"id": "Ds33D8", "name": "Animated Ulam spiral", "author": "rrrola", "description": "Put integers on a spiral and a black dot on each prime.\nCheck out the mysterious lines!\n\nPublic domain.", "tags": ["spiral", "pixels", "prime", "factorization"], "likes": 4, "viewed": 226, "published": 3, "date": "1677166326", "time_retrieved": "2024-07-30T18:08:40.465011", "image_code": "// Animated Ulam spiral\n\n// Put integers on a spiral and a black dot on each prime. Check out the mysterious lines!\n\n// The lines are generated by quadratic polynomials, for example n+n+41 or n-n+27941.\n// Some contain many primes and numbers with only large factors.\n\n// Primes are black.\n// Numbers with large factors are red->yellow (the color depends on the smallest factor).\n// The red numbers make the lines even more visible.\n\n\n// Return a position on a square ring of radius r.\n// Position 1 is at [r, -(r-1)].\nint to_ring(int r, int x, int y) {\n    if (x == r && y != -r) return r + y;\n    if (y == r) return 3*r - x;\n    if (x == -r) return 5*r - y;\n    return 7*r + x;\n}\n\n// Return a position on a square spiral.\nint to_spiral(int x, int y) {\n    int r = max(abs(x), abs(y));\n    int n = 2*r - 1;\n    return n*n - 1 + to_ring(r, x, y);\n}\n\n// Return the smallest prime factor of x (using wheel factorization).\n// If x is zero or one, return x.\nint smallest_factor(int x) {\n    if (x <= 3) return x;\n    int p = 2, i = 0;\n    while (p*p <= x) {\n        if (x % p == 0) return p;\n        p += int[11]( 1,2,2, 4,2,4,2,4,6,2,6 )[i];\n        i++; if (i == 11) { i = 3; }\n    }\n    return x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 p = ivec2(fragCoord) - ivec2(iResolution.xy) / 2;  // centered integer position\n    int n = to_spiral(p.x, p.y) + iFrame - 360;  // 6 seconds of negative numbers (black hole)\n    int f = smallest_factor(n);\n    fragColor = f==n ? vec4(0) : 1. - float(f) * vec4(0, 0.004, 0.04, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds33D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 523, 557, 557, 685], [687, 728, 757, 757, 852], [854, 958, 986, 986, 1201], [1203, 1203, 1258, 1258, 1551]], "test": "untested"}
{"id": "Dsd3z4", "name": "Pappus's Theorem", "author": "mla", "description": "Pappus's Theorem, together with associated cubic curve. Use mouse to drag red points.", "tags": ["curves"], "likes": 25, "viewed": 260, "published": 3, "date": "1677159389", "time_retrieved": "2024-07-30T18:08:41.376573", "image_code": "///////////////////////////////////////////////////////////////////////\n//\n// Pappus's Theorem, mla, 2023\n//\n// Given points ABCDEF, ABC, DEF collinear, the intersections\n// X = AE.BD, Y = AF.CD, Z = BF.CE are also collinear.\n//\n// There are many proofs of this fundamental relation\n// in projective geometry. A nice one uses Bezout's\n// theorem - two cubics (which might consist of three\n// lines) have exactly nine points of intersection, and\n// the Cayley-Bacharach theorem tells us that the cubics\n// passing through eight given points also pass through\n// a ninth point.\n//\n// Thick curve is a cubic through the nine points of the configuration,\n// which is defined by the five red points which are draggable.\n//\n// Use mouse to select a point for the cubic to pass through (click\n// on left edge to go back to animation).\n//\n///////////////////////////////////////////////////////////////////////\n\n// Evaluate (L.p)(M.p)(N.p) for columns L,M,N of C, ie. the cubic\n// curve consisting of the lines L,M and N.\nfloat eval(vec3 p, mat3 C) {\n  p *= C; // Transpose multiplication = dot product with columns\n  return p.x*p.y*p.z;\n}\n\n// Evaluate cubic LMN + kPQR at p, with k chosen so the\n// curve passes through q.\nfloat cubic(vec3 p, vec3 q, mat3 C, mat3 D) {\n  float k = -eval(q,C)/eval(q,D);\n  return eval(p,C) + k*eval(p,D);\n}\n\n// Distance from projective line\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p.xy/p.z,q.xy/q.z);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    setscale();\n    vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1);\n    vec4 tex = texture(iChannel0,0.25*p.xy);\n    float lwidth = 0.005*(0.5+0.5*length(tex.rgb));\n    float px = 1.2*scale*2.0/iResolution.y;\n    vec3 A = vec3(getselection(0),1);\n    vec3 B = vec3(getselection(1),1);\n    vec3 D = vec3(getselection(2),1);\n    vec3 E = vec3(getselection(3),1);\n    vec3 Y = vec3(getselection(4),1);\n    vec3 AB = cross(A,B);\n    vec3 DE = cross(D,E);\n    vec3 AE = cross(A,E);\n    vec3 BD = cross(B,D);\n    vec3 AY = cross(A,Y);\n    vec3 DY = cross(D,Y);\n    vec3 C = cross(AB,DY);\n    vec3 F = cross(DE,AY);\n    vec3 X = cross(AE,BD);\n    vec3 BF = cross(B,F);\n    vec3 CE = cross(C,E);\n    vec3 Z = cross(BF,CE);\n    vec3 XZ = cross(X,Z);\n    vec3 q = vec3(defaultselection(),1);\n    if (q.xy == vec2(0)) q = vec3(2.0*vec2(cos(0.1*PI*iTime),sin(0.1*PI*iTime)),1);\n    float d = cubic(p,q,mat3(AB,DE,XZ),mat3(BD,CE,AY));\n    d *= px/length(vec2(dFdx(d),dFdy(d)));\n    float t = d;\n    vec3 col = vec3(1,1,0.5);\n    col *= 0.75+0.25*tex.rgb;\n    //col *= 0.9+0.1*cos(100.0*t);\n    col = mix(vec3(0),col,smoothstep(0.0,px,abs(d)-4.0*lwidth));\n    if (true) {\n      float d = 1e8;\n      vec3 lcol = vec3(0);\n      // 9 lines split up into 3 cubics of 3 lines each.\n      // By construction, each cubic passes through 8 points\n      // of the configuration, and so each pass through the 9th.\n      d = min(d,line(p,AB));\n      d = min(d,line(p,DE));\n      d = min(d,line(p,XZ));\n      \n      d = min(d,line(p,AE));\n      d = min(d,line(p,BF));\n      d = min(d,line(p,DY));\n\n      d = min(d,line(p,BD));\n      d = min(d,line(p,CE));\n      d = min(d,line(p,AY));\n      col = mix(lcol,col,smoothstep(0.0,px,d-1.0*lwidth));\n    }\n    if (true){\n      float d = 1e8;\n      vec3 pcol = vec3(1,0,0);\n      d = min(d,point(p,A));\n      d = min(d,point(p,B));\n      d = min(d,point(p,D));\n      d = min(d,point(p,E));\n      d = min(d,point(p,Y));\n      float d0 = d;\n      d = min(d,point(p,C));\n      d = min(d,point(p,F));\n      d = min(d,point(p,X));\n      d = min(d,point(p,Z));\n      //d = min(d,point(p,q));\n      if (d < d0) pcol = vec3(0);\n      if (key(CHAR_C)) {\n        d0 = d;\n        d = min(d,point(p,q));\n        if (d < d0) pcol = vec3(0.5);\n      }\n      col = mix(pcol,col,smoothstep(0.0,px,abs(d-0.06)-1.0*lwidth));\n    }\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col, 1.0);;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  if (iFrame == 0) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 2.0;\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int nselections = 5;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-2,1.3);\n  if (i == 1) return vec2(0,1);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsd3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[904, 1014, 1042, 1042, 1131], [1133, 1216, 1261, 1261, 1331], [1333, 1366, 1394, 1394, 1439], [1441, 1441, 1470, 1470, 1510], [1512, 1512, 1566, 1566, 4012]], "test": "untested"}
{"id": "DstGDr", "name": "Falling Chips", "author": "dr2", "description": "Lots of falling saddle-shaped disks (colorful pringles?)", "tags": ["grid", "raymarch", "lighting", "surface", "pringle"], "likes": 31, "viewed": 337, "published": 3, "date": "1677150815", "time_retrieved": "2024-07-30T18:08:42.276168", "image_code": "// \"Falling Chips\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec3 qHit, bGrid, cId, obDisp, obRot, ltDir[4], ltCol[4];\nfloat dstFar, tCur, vSpd;\nbool cOcc;\nconst float pi = 3.1415927;\n\nfloat SurfDf (inout vec3 q, float r)\n{  // (intersection of torus and cylinder)\n  float d, rt;\n  rt = 1.5 * r;\n  d = abs (q.z) - rt;\n  q.z = length (vec2 (length (vec2 (q.y, q.z - rt)) - 3. * rt, q.x)) - 2. * rt;\n  return max (d, SmoothMax (abs (q.z) - 0.005, length (q.xy) - r, 0.01));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  if (cOcc) {\n    q -= obDisp;\n    q.yz = Rot2Cs (q.yz, sin (obRot.x + vec2 (0.5 * pi, 0.)));\n    q.xz = Rot2Cs (q.xz, sin (obRot.y + vec2 (0.5 * pi, 0.)));\n    q.xy = Rot2Cs (q.xy, sin (obRot.z + vec2 (0.5 * pi, 0.)));\n    d = SurfDf (q, 0.3); // (pringle perhaps?)\n    if (d < dMin) {\n      dMin = d; \n      qHit = q; \n    }\n  }\n  return dMin;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  vRan = Hashv3v3 (cId + 11.1);\n  cOcc = (vRan.x * step (4., length (cId.xz)) > 0.2);\n  if (cOcc) {\n    obDisp = bGrid * (cId + 0.5 + 0.2 * cos ((0.5 + 0.5 * vRan) * tCur + vRan.zxy));\n    obRot = (vRan - 0.5) * tCur;\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((bGrid * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, c, vn, sumD, sumS;\n  float dstObj, nDotL, h;\n  col = vec3 (0.2);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ObjCell (ro));\n    h = Hashfv3 (cId);\n    c = (qHit.z < 0.) ? HsvToRgb (vec3 (h, 0.5, 0.8)) : HsvToRgb (vec3 (h, 1., 1.));\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      sumD += ltCol[k] * c * nDotL * nDotL;\n      sumS += vec3 (0.3) * pow (max (0., dot (ltDir[k], reflect (rd, vn))), 128.);\n    }\n    col = sumD + sumS;\n    col = mix (col, vec3 (0.2), 1. - exp (min (0., 4. - 5. * dstObj / dstFar)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.01 * tCur;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  bGrid = vec3 (1.);\n  vSpd = 0.2;\n  ro = vec3 (0.5 * bGrid.x);\n  zmFac = 6.;\n  dstFar = 50.;\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 1., 0.3);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstGDr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[610, 610, 648, 689, 898], [900, 900, 922, 922, 1323], [1325, 1325, 1343, 1343, 1580], [1582, 1582, 1605, 1605, 1736], [1738, 1738, 1771, 1771, 2329], [2331, 2331, 2352, 2352, 2607], [2609, 2609, 2644, 2644, 3339], [3341, 3341, 3397, 3397, 4824], [4826, 4826, 4848, 4848, 4886], [4888, 4888, 4933, 4933, 5025], [5027, 5027, 5072, 5072, 5110], [5112, 5112, 5148, 5148, 5354], [5356, 5356, 5386, 5386, 5499], [5501, 5501, 5532, 5532, 5596], [5598, 5598, 5622, 5622, 5739], [5773, 5773, 5797, 5797, 5857], [5859, 5859, 5883, 5883, 5948], [5950, 5950, 5974, 5974, 6092]], "test": "untested"}
{"id": "ms3GDr", "name": "thinnests AA lines", "author": "FabriceNeyret2", "description": "from left to right: smoothstep 1pix thick radius or diameter , linear tent 1pix thick radius or diameter.\nBottom: with final sRGB conversion ( which should always be done, and especially improves AA and interpolated greys and colors )", "tags": ["lines", "antialiasing", "aa", "srgb"], "likes": 22, "viewed": 415, "published": 3, "date": "1677144024", "time_retrieved": "2024-07-30T18:08:43.147837", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u -.5* R ) / R.y;\n    O *= 0.;\n    float v = dot( U , cos( .4*sin(.5*iTime) + vec2(0,11) ) ),\n      // dv = length(vec2(dFdx(v),dFdy(v)));\n      // dv = fwidth(v);                             // approx\n         dv = 1./R.y;                                // approx ( here, exact )\n    \n    O += // smoothstep( 1.5/R.y, 0., abs(v+.2) )     // approx of next\n      +  smoothstep( 1.5, 0., abs(v+.1)/dv )         // 1 pixel thick radius   smoothstep\n      +  smoothstep(  .8, 0., abs(v+.0)/dv )         // 1 pixel thick diameter smoothstep\n      +  max( 1. -    abs(v-.1)/dv, 0. )             // 1 pixel thick radius   linear\n      +  max( 1. - 2.*abs(v-.2)/dv, 0. );            // 1 pixel thick diameter linear\n    \n    if (U.y<0.) \n        O = pow(O, vec4(1./2.2) );                   // to sRGB ( even more important for AA )\n     // O = sqrt(O);                                 // approx\n     \n    if ( int(u.y)==int(R.y)/2 ) O.r++;               // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3GDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1049]], "test": "untested"}
{"id": "ds33RN", "name": "Loading loop", "author": "yli110", "description": "depend on atan() && SDFIsoscelesTriangle", "tags": ["2d", "loading"], "likes": 3, "viewed": 163, "published": 3, "date": "1677141841", "time_retrieved": "2024-07-30T18:08:44.003550", "image_code": "#define PI 3.1415926535\nvec2 fixUV(in vec2 uv)\n{\n    return (2.*uv.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\nmat2 rotation(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat Circle(in vec2 uv, in vec2 point, in float r)\n{\n    float p = (length(uv-point)-r);\n    \n    return p;\n}\n\nfloat SDFIsoscelesTriangle(in vec2 uv, in vec2 a)\n{\n    uv.y = abs(uv.y);\n    vec2 p =uv;\n    vec2 AC = vec2(-a.x,a.y);\n    vec2 AP = vec2(p.x-a.x,p.y);\n    vec2 q1 = vec2(p.x,max(p.y-a.y,0.));\n    float c = clamp(dot(AC,AP)/dot(AC,AC),0.,1.);\n    vec2 q2 = AP-c*AC;\n    float s = sign(AP.y*AC.x-AC.y*AP.x);\n    s = sign(a.x)>0.?(p.x<0.?1.:-s):(p.x>0.?1.:s);\n    return min(length(q1),length(q2))*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fixUV(fragCoord);\n    uv *= rotation(2.*iTime*PI/3.);\n    float pixel = 3./min(iResolution.x,iResolution.y);\n    vec2 ringwidth = vec2(0.42,0.5);\n    float centerpoint = (ringwidth.y+ringwidth.x)/2.;\n    float ringwidthR =  (ringwidth.y-ringwidth.x)/2.;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //one loop\n    #if 1\n        float blendintensity = atan(uv.x,uv.y);\n        float a = mod(0.5+0.5*blendintensity/PI, 1.);\n        vec3 colo_w = mix(col,vec3(1.),a*a);\n        col = mix(col,colo_w,smoothstep(ringwidth.y+pixel,ringwidth.y,length(uv))-smoothstep(ringwidth.x,ringwidth.x-pixel,length(uv)));\n\n        /* vec2 point1 = vec2(0.,-centerpoint); \n        float circle1 = Circle(uv,point1,ringwidthR+pixel*0.5);\n        float mark = smoothstep(pixel,-pixel*0.5,circle1)*(1.-step(0.,uv.x)); */\n\n        float d = SDFIsoscelesTriangle(vec2(uv.x-pixel*0.5,uv.y+0.46),vec2(-0.1,0.1));\n        float mark = smoothstep(pixel*0.5,-pixel*0.5,d);\n    \n    //Two loops\n    #else \n        float blendintensity = -atan(uv.y,uv.x);\n        float a = mod(0.5+blendintensity/PI, 1.);\n        vec3 colo_w = mix(col,vec3(1.),a);\n        col = mix(col,colo_w,smoothstep(ringwidth.y+pixel,ringwidth.y,length(uv))-smoothstep(ringwidth.x,ringwidth.x-pixel,length(uv)));\n\n        vec2 point1 = vec2(0.,centerpoint);\n        vec2 point2 = vec2(0.,-centerpoint);\n        float circle1 = Circle(uv,point1,ringwidthR+pixel*0.5);\n        float circle2 = Circle(uv,point2,ringwidthR+pixel*0.5);\n        float mark = smoothstep(pixel*0.5,-pixel*0.5,circle1)*step(0.,uv.x)+smoothstep(pixel*0.5,-pixel*0.5,circle2)*(1.-step(0.,uv.x));\n    #endif\n       \n    col = mix(col,vec3(1.),mark);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds33RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 121], [123, 123, 151, 151, 216], [218, 218, 271, 271, 328], [330, 330, 381, 381, 731], [733, 733, 790, 841, 2628]], "test": "untested"}
{"id": "Ds3GDr", "name": "Trigonometric mandelbrot", "author": "Mik0", "description": "Mandelbrot set but I'm using trigonometry to represent complex numbers.", "tags": ["mandelbrot"], "likes": 2, "viewed": 183, "published": 3, "date": "1677141580", "time_retrieved": "2024-07-30T18:08:44.903144", "image_code": "#define Power (0.0-cos(iTime/25.0))+3.0\n#define iters 100\nconst float tau = acos(0.0)*2.0;\n#define aa 4\n// aa is ani aliasing level\n\nfloat mandelbrot(vec2 p)\n{\n    vec2 z = p;\n    float brightness;\n    for(int i = 0; i<iters; i++)\n    {\n        brightness = float(i);\n        float d = length(z);\n        if(d>2.0){break;}\n        float a = atan(z.x, z.y);\n        d = pow(d, Power);\n        a*=Power;\n        z = vec2(sin(a)*d,cos(a)*d)+(p*1.0);\n    }\n    if(brightness+1.0==float(iters)){brightness=0.0;}\n    return mod(brightness/50.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=4.0;\n    uv/=pow(2.0, 0.0);\n    uv+=vec2(0,0);\n    float col = 0.0;\n    vec2 offset = vec2(0,0);\n    \n    \n    for(int i = 0; i<aa; i++)\n    {\n        col+=mandelbrot(uv+vec2((sin(offset.x)*offset.y)/iResolution.x, (cos(offset.x)*offset.y)/iResolution.y));\n        offset+=vec2((tau/float(aa))*(tau), sqrt(2.0)/float(aa));\n    }\n    col/=float(aa);\n    \n    vec3 col1 = vec3(0, 7, 100)/255.0;\n    vec3 col2 = vec3(32, 107, 203)/255.0;\n    vec3 col3 = vec3(237, 255, 255)/255.0;\n    vec3 col4 = vec3(255, 170, 0)/255.0;\n    vec3 col5 = vec3(0, 2, 0)/255.0;\n\n    // Output to screen\n    fragColor = vec4(vec3(smoothstep(col1.x, col2.x, col), smoothstep(col1.y, col2.y, col), smoothstep(col1.z, col2.z, col)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3GDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 159, 159, 546], [548, 548, 605, 655, 1469]], "test": "untested"}
{"id": "Dd3GWr", "name": "Random Pulsing Points (Texture)", "author": "sotrh", "description": "Computes random points that pulsate at random intervals.", "tags": ["programmingchallenge"], "likes": 1, "viewed": 41, "published": 3, "date": "1677120366", "time_retrieved": "2024-07-30T18:08:46.063044", "image_code": "float rand(vec2 co){\n    return texture(iChannel0, co / 10.0).r;\n}\n\nvec2 rPoint(vec2 co) {\n    float x = rand(co);\n    float y = rand(co + x);\n    vec2 p = vec2(x, y) * 0.5 + 0.25;\n    return p;\n}\n\nfloat sdfCircle(vec2 p, vec2 c, float r) {\n    return length(c - p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv *= 10.0;\n    uv += iTime;\n    \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 c = rPoint(i);\n    \n    float freq = 3.14 * rand(i + 6.1234);\n    float r = sin(iTime * freq + rand(c + i)) * 2.0;\n    r *= 0.05;\n    float d = sdfCircle(f, c, r);\n    \n    d = smoothstep(0.05, 0.1, d);\n\n    vec3 col = vec3(\n        rand(i),\n        rand(i + c),\n        rand(i + 234.3)\n    );\n    \n    col = mix(vec3(1.0), col, 1.0 - d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3GWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 66], [68, 68, 90, 90, 196], [198, 198, 240, 240, 272], [274, 274, 331, 331, 867]], "test": "untested"}
{"id": "dsdGz7", "name": "Saw Wave - Sound", "author": "gfy_9001", "description": "Saw Wave - Audio/Visual\n\nOther things I've done:\nhttps://www.shadertoy.com/view/sdSyWG\nhttps://www.shadertoy.com/view/NdSyDy", "tags": ["sawwave"], "likes": 1, "viewed": 191, "published": 3, "date": "1677107321", "time_retrieved": "2024-07-30T18:08:46.913769", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    FREQUENCY = 1. / iTime;\n    \n    float s0     = SawMod(FREQUENCY, 1.0, iTime);    \n    vec3  modCol = s0 * vec3(0,2,4);    \n    vec2  uv     = fragCoord / (iResolution.xy * 0.1);\n    vec3  col    = cos(s0+uv.xyx + modCol) * iTime;\n    \n    fragColor = vec4(col * 0.1,1.0);\n}", "image_inputs": [], "sound_code": "// Toggle me between [0, 1]\n#define USE_LFO 0\n\nfloat Amp(float a)\n{\n    return a * 0.1;\n}\n\nfloat SinWave(float hz, float a, float t)\n{\n    return Amp(a) * sin(T_PI * hz * t);\n}\n\nfloat SawWave(float p, float a, float t)\n{\n    float period_t = t/p;\n    return Amp(a) * (2.0 * (period_t - floor(0.5 + period_t)));\n}\n\nfloat AmpEnvelope(float m, float t, float b)\n{\n    return m * t + b;\n}\n\n// question: anyone know why audio cuts out after a while? (around 170 seconds)\n// answer here in the comments -  https://www.shadertoy.com/view/3ssyWB\n\nvec2 mainSound(in int samp, float time)\n{\n    // modulates the pitch\n#if USE_LFO\n    // lfo = low frequency oscillator\n    float lfo_freq = 1./ 1.;\n    // sin wave, used to modulate (range 0 <-> 1)\n    float sm = SinMod(time, lfo_freq, 0., 0.);\n    time *= sm;\n#endif\n\n    FREQUENCY = 1. / time;             // Period/Interval (1/HZ)\n                                       // Time is our frequency, seconds == hertz in this context\n\n    // amplitude envelope\n    float m = 1.;                      // higher, the longer it takes to reach peak\n    float b = -10.;                    // how quiet we start, lower is quieter\n    float e = AmpEnvelope(m, time, b); // linear rise\n    float a = min(1. + (e / -b), 1.0); // convert into 0 -> 1 and keep clamped at 1\n    \n    // rising pitch\n    float saw = SawWave(FREQUENCY, 0.5 * a, time);\n    \n    // detune modulation\n    float detune_freq = 1. / .2;\n    float detune_mod = SinMod(time, detune_freq, 0., 0.);\n    float detune_plus_minus_hz = 0.07;\n    float detune_amount = detune_mod * detune_plus_minus_hz;\n     \n    // chord\n    float c2_sin = SinWave(C2,                        0.10 * a, time);\n    float c2_saw = SawWave(1. / C2,                   0.18 * a, time);\n    float c4_saw = SawWave(1. / C3,                   0.20 * a, time);\n    float g4_saw = SawWave(1. / (G4 + detune_amount), 0.18 * a, time);\n    float f4_saw = SawWave(1. / (F4 + detune_amount), 0.18 * a, time);        \n    \n    // sum the waves!!!\n    return vec2(saw + c2_sin + c2_saw + c4_saw + g4_saw + f4_saw);\n}", "sound_inputs": [], "common_code": "//#define PI 3.1415926536\n#define T_PI 6.28318530718\n\n// hz\n#define C2 65.406\n#define C3 130.812\n#define C4 261.625\n#define G4 391.995\n#define F4 349.2282\t\n\nfloat FREQUENCY = 4.;\n\nfloat SinMod(float x, float b, float c, float d)\n{\n    float p = T_PI / b;\n    return sin(p * (x + c)) + d;\n}\n\nfloat SawMod(float p, float a, float t)\n{\n    float period_t = t/p;\n    return 2.0 * (period_t - floor(0.5 + period_t));\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 336]], "test": "untested"}
{"id": "dsd3R7", "name": "Fork City of Ka Housecity 572", "author": "Housecity", "description": "CC0: City of Kali\nWanted to created some kind of abstract city of light\nHad the idea that Kali fractal might be a good start.\n10/10 - would use Kali fractal again :).\n", "tags": ["2d", "kali"], "likes": 4, "viewed": 190, "published": 3, "date": "1677102503", "time_retrieved": "2024-07-30T18:08:47.752526", "image_code": "// CC0: City of Kali\n//  Wanted to created some kind of abstract city of light\n//  Had the idea that Kali fractal might be a good start.\n//  10/10 - would use Kali fractal again :).\n\n// Kali fractal source: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec2 c = -vec2(0.5, 0.5)*1.05;\n\n  float s = 3.0;\n  vec2 kp = p/s;\n  kp += sin(0.05*(TIME+100.0)*vec2(1.0, sqrt(0.5)));\n \n  const float a = PI/4.0;\n  const vec2 n = vec2(cos(a), sin(a));\n\n  float ot2 = 1E6;\n  float ot3 = 1E6;\n  float n2 = 0.0;\n  float n3 = 0.0;\n\n  const float mx = 15.0;\n  for (float i = 0.0; i < mx; ++i) {\n    float m = (dot(kp, kp));\n    s *= m;\n    kp = abs(kp)/m + c;\n    float d2 = (abs(dot(kp,n)))*s;\n    if (d2 < ot2) {\n      n2 = i;\n      ot2 = d2;\n    }\n    float d3 = (dot(kp, kp));\n    if (d3 < ot3) {\n      n3 = i;\n      ot3 = d3;\n    }\n  }\n  vec3 col = vec3(0.0);\n  n2 /= mx;\n  n3 /= mx;\n  col += hsv2rgb(vec3(0.55+0.2*n2, 0.90, 0.00125))/(ot2+0.001);\n  col += hsv2rgb(vec3(0.05-0.1*n3, 0.85, 0.0025))/(ot3+0.000025+0.005*n3*n3);\n  col -= 0.1*vec3(0.0, 1.0, 2.0).zxy;\n  col *= smoothstep(1.5, 0.5, length(pp));  \n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsd3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 658, 658, 804], [1099, 1199, 1218, 1218, 1305], [1307, 1414, 1440, 1440, 1624], [1626, 1626, 1656, 1656, 2562], [2564, 2564, 2621, 2621, 2812]], "test": "untested"}
{"id": "ddt3R7", "name": "City of Kali", "author": "mrange", "description": "CC0: City of Kali\nWanted to created some kind of abstract city of light\nHad the idea that Kali fractal might be a good start.\n10/10 - would use Kali fractal again :).\n", "tags": ["2d", "kali"], "likes": 36, "viewed": 349, "published": 3, "date": "1677099655", "time_retrieved": "2024-07-30T18:08:48.759833", "image_code": "// CC0: City of Kali\n//  Wanted to created some kind of abstract city of light\n//  Had the idea that Kali fractal might be a good start.\n//  10/10 - would use Kali fractal again :).\n\n// Kali fractal source: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec2 c = -vec2(0.5, 0.5)*1.05;\n\n  float s = 3.0;\n  vec2 kp = p/s;\n  kp += sin(0.05*(TIME+100.0)*vec2(1.0, sqrt(0.5)));\n \n  const float a = PI/4.0;\n  const vec2 n = vec2(cos(a), sin(a));\n\n  float ot2 = 1E6;\n  float ot3 = 1E6;\n  float n2 = 0.0;\n  float n3 = 0.0;\n\n  const float mx = 15.0;\n  for (float i = 0.0; i < mx; ++i) {\n    float m = (dot(kp, kp));\n    s *= m;\n    kp = abs(kp)/m + c;\n    float d2 = (abs(dot(kp,n)))*s;\n    if (d2 < ot2) {\n      n2 = i;\n      ot2 = d2;\n    }\n    float d3 = (dot(kp, kp));\n    if (d3 < ot3) {\n      n3 = i;\n      ot3 = d3;\n    }\n  }\n  vec3 col = vec3(0.0);\n  n2 /= mx;\n  n3 /= mx;\n  col += hsv2rgb(vec3(0.55+0.2*n2, 0.90, 0.00125))/(ot2+0.001);\n  col += hsv2rgb(vec3(0.05-0.1*n3, 0.85, 0.0025))/(ot3+0.000025+0.005*n3*n3);\n  col -= 0.1*vec3(0.0, 1.0, 2.0).zxy;\n  col *= smoothstep(1.5, 0.5, length(pp));  \n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddt3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 658, 658, 804], [1099, 1199, 1218, 1218, 1305], [1307, 1414, 1440, 1440, 1624], [1626, 1626, 1656, 1656, 2562], [2564, 2564, 2621, 2621, 2812]], "test": "untested"}
{"id": "ddt3RM", "name": "Chromatic Aberration CameraShake", "author": "djancool", "description": "Chromatic Aberration Camera Shake", "tags": ["camera", "chromatic", "aberration", "shake"], "likes": 4, "viewed": 416, "published": 3, "date": "1677095619", "time_retrieved": "2024-07-30T18:08:49.679375", "image_code": "vec2 random2(float seed)\n{\n    float rand1 = fract(sin(seed) * 43758.5453123);\n    float rand2 = fract(cos(seed) * 23421.631235);\n    \n    return vec2(rand1, rand2) * 2.0 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime * 16.0 + sin(iTime * 15.0) * 0.25;\n    vec2 pos_rnd_1 = random2(floor(time));\n         pos_rnd_1 = pow(pos_rnd_1, vec2(3.0));\n    vec2 pos_rnd_2 = random2(floor(time) + 1.0);\n         pos_rnd_2 = pow(pos_rnd_2, vec2(3.0));\n    vec2 pos_rnd = mix(pos_rnd_1, pos_rnd_2, fract(time));\n\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5) * 0.96 + 0.5;\n    \n    vec2 uv1 = uv + pos_rnd * 0.01;\n    vec2 uv2 = uv + pos_rnd * 0.02;\n    vec2 uv3 = uv + pos_rnd * 0.04;\n\n    // Time varying pixel color\n    float r = texture(iChannel0, uv1).r;\n    float g = texture(iChannel0, uv2).g;\n    float b = texture(iChannel0, uv3).b;\n\n    vec3 col = vec3(r,g,b);\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddt3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 179], [181, 181, 238, 238, 978]], "test": "untested"}
{"id": "Ddt3R7", "name": "Light spectrum  Gaussian", "author": "rrrola", "description": "The point-wise spectrum looks wrong (washed out yellow and blue). To make the spectrum look correct, smear it with the normal distribution.\n\nPublic domain, except for xyz_from_wavelength() which is from an article ( 2013 Chris Wyman et al.).", "tags": ["spectrum", "rainbow", "graph", "wavelength"], "likes": 19, "viewed": 355, "published": 3, "date": "1677088668", "time_retrieved": "2024-07-30T18:08:50.506163", "image_code": "// The light spectrum smeared with a Gaussian.\n\n// Public domain, except for the approximate xyz_from_wavelength() function\n// which is  2013 Chris Wyman, Peter-Pike Sloan, and Peter Shirley.\n\n// RGB from wavelength is usually computed point-wise, but it looks wrong (washed out yellow and blue)\n// because in reality you almost never see the pure spectrum.\n// To make the spectrum look \"correct\", you can smear it a little with the normal distribution.\n\nfloat nm_min = 300., nm_max = 750.; // X axis range in nanometers\nfloat sd_nm = 30.;  // standard deviation (smear amount) in nanometers\n\n// Scale and add a little gray to get the most vivid colors without underflow/overflow.\nfloat scale = 0.46;\nfloat add_gray = 0.22;\n\n// Convert light wavelength to CIE 1931 XYZ.\n// Approximate multi-lobe fit from http://jcgt.org/published/0002/02/01\n// [C. Wyman, P. Sloan, P. Shirley: Simple Analytic Approximations to the CIE XYZ Color Matching Functions].\n// NOTE(rrrola): \n//  It would be useful if the spectrum would integrate to white (r=g=b).\n//  This approximation makes the red channel too strong.\nvec3 xyz_from_wavelength(float nm) {\n    float x1 = (nm - 442.0) * (nm<442.0? .0624 : .0374);\n    float x2 = (nm - 599.8) * (nm<599.8? .0264 : .0323);\n    float x3 = (nm - 501.1) * (nm<501.1? .0490 : .0382);\n    float y1 = (nm - 568.8) * (nm<568.8? .0213 : .0247);\n    float y2 = (nm - 530.9) * (nm<530.9? .0613 : .0322);\n    float z1 = (nm - 437.0) * (nm<437.0? .0845 : .0278);\n    float z2 = (nm - 459.0) * (nm<459.0? .0385 : .0725);\n    return vec3(0.362*exp(-.5*x1*x1) + 1.056*exp(-.5*x2*x2) - 0.065*exp(-.5*x3*x3),\n                0.821*exp(-.5*y1*y1) + 0.286*exp(-.5*y2*y2),\n                1.217*exp(-.5*z1*z1) + 0.681*exp(-.5*z2*z2));\n}\n\n// Convert CIE 1931 XYZ to linear sRGB.\nvec3 rgb_from_xyz(vec3 xyz) {\n    return mat3(vec3(3.2404542, -0.9692660, 0.0556434),\n                vec3(-1.5371385, 1.8760108, -0.2040259),\n                vec3(-0.4985314, 0.0415560, 1.0572252)) * xyz;\n}\n\n// Evaluate the probability density function of the normal distribution.\nfloat normal_pdf(float mean, float sd, float x) {\n    float z = (x - mean) / sd;\n    return exp(-0.5*z*z) / (sd * sqrt(2.0 * 3.14159265358979323846));\n}\n\n// Convolve the spectrum with the normal pdf and normalize.\nvec3 convolve_spectrum_with_normal_pdf(float mean, float sd) {\n    float sum_w = 0.;\n    vec3 sum = vec3(0);\n    for (float i=-5.; i<=5.; i+=0.0625) {  // just accumulate samples, 5*sd is enough\n        float nm = mean + i*sd;\n        float w = normal_pdf(mean, sd, nm);\n        sum_w += w;\n        sum += w * rgb_from_xyz(xyz_from_wavelength(nm));\n    }\n    return sum / sum_w;\n}\n\n// Scale and add a little gray to get the most vivid colors without underflow/overflow.\nvec3 color(float mean, float sd) {\n    return add_gray + scale * convolve_spectrum_with_normal_pdf(mean, sd);\n}\n\nfloat unmix(float a, float b, float x) { return (x-a)/(b-a); }  // undo lerp\nfloat aa(float r, float x) { return clamp(r-x,0.,1.); }  // clamped triangle filter with radius r\nfloat seg_dist(vec2 p, vec2 a, vec2 b) { p-=a; b-=a; return length(p - b*clamp(dot(p,b)/dot(b,b),0.,1.)); }\nfloat line_dist(vec2 p, vec2 a, vec2 b) { p-=a; b-=a; return length(p - b*(dot(p,b)/dot(b,b))); }\nfloat aa_seg(float width, vec2 p, vec2 a, vec2 b) { return aa(width, seg_dist(p,a,b)); }\nfloat aa_line(float width, vec2 p, vec2 a, vec2 b) { return aa(width, line_dist(p,a,b)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // graph space: x(nm_min..nm_max), y(0..1).\n    float nm = mix(nm_min, nm_max, fragCoord.x/iResolution.x);\n\n    float x0 = nm;      vec3 y0 = color(x0, sd_nm);\n    float x1 = nm+.001; vec3 y1 = color(x1, sd_nm);  // for slope\n\n    // Convert from graph space to screen space.\n    #define SCR(X,Y) (iResolution.xy * vec2(unmix(nm_min, nm_max, X), Y))\n    \n    // Add an antialiased segment or line into col.\n    #define SEG(X0,Y0,X1,Y1,Width,Color) col = mix(col,Color,aa_seg(Width,fragCoord,SCR(X0,Y0),SCR(X1,Y1)))\n    #define LINE(X0,Y0,X1,Y1,Width,Color) col = mix(col,Color,aa_line(Width,fragCoord,SCR(X0,Y0),SCR(X1,Y1)))\n\n    // background\n    vec3 col = y0;\n\n    // horizontal axis\n    LINE(0.,add_gray, 1.,add_gray, 1., vec3(0));\n\n    // ticks\n    float tick = round(nm/10.) * 10.; // closest tick\n    float tick_mod_100 = mod(tick, 100.);\n    float tick_size = tick_mod_100==0.||tick_mod_100==100.? 0.03 : tick_mod_100==50.? 0.02 : 0.01;\n    SEG(tick,add_gray-tick_size, tick,add_gray+tick_size, 1., vec3(0));\n\n    // RGB color graphs\n    LINE(x0,y0.r, x1,y1.r, 2.5, vec3(0,0,0)); // outline\n    LINE(x0,y0.r, x1,y1.r, 1.5, vec3(.87,.14,.09)); // interior\n    LINE(x0,y0.g, x1,y1.g, 2.5, vec3(0,0,0));\n    LINE(x0,y0.g, x1,y1.g, 1.5, vec3(.07,.47,.06));\n    LINE(x0,y0.b, x1,y1.b, 2.5, vec3(0,0,0));\n    LINE(x0,y0.b, x1,y1.b, 1.5, vec3(.13,.31,1));\n    \n    // approximate linear -> gamma sRGB\n    fragColor = vec4(pow(col,vec3(1.0/2.2)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddt3R7.jpg", "access": "api", "license": "public-domain", "functions": [[727, 1101, 1137, 1137, 1745], [1747, 1787, 1816, 1816, 1994], [1996, 2069, 2118, 2118, 2221], [2223, 2283, 2345, 2345, 2665], [2667, 2755, 2789, 2789, 2866], [2868, 2868, 2908, 2908, 2930], [2932, 2945, 2973, 2973, 3000], [3002, 3043, 3083, 3083, 3150], [3151, 3151, 3192, 3192, 3248], [3249, 3249, 3300, 3300, 3337], [3338, 3338, 3390, 3390, 3428], [3430, 3430, 3485, 3533, 4942]], "test": "untested"}
{"id": "Dd3GR4", "name": "Volumetric Media Rendering", "author": "FifthStateOfMatter", "description": "3D", "tags": ["3d", "volumetric"], "likes": 1, "viewed": 121, "published": 3, "date": "1677081096", "time_retrieved": "2024-07-30T18:08:51.317994", "image_code": "//const vec3 lightDir = normalize(vec3(-10, -10, 10));\nconst float mediaDensity = 0.3;\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return max(fract((p.x + p.y)*p.z)*2.0 - 1.0, 0.0);\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return max(fract(p.x + p.y)*2.0 - 1.0, 0.0);\n}\n\nfloat noise3(vec3 p){\n    /*vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);*/\n    return texture(iChannel0, p*0.03).g*0.7;\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    /*float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise3(p*f)*h;\n    for(int i = 0; i < 2; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise3(rotate2D(p, vec2(0, r))*f)*h;\n    }*/\n    //return n/1.0;\n    return (texture(iChannel0, p*0.001).r + texture(iChannel0, p*0.002).g*0.5 + texture(iChannel0, p*0.004).g*0.25)*(1.0/1.75);\n}\n\nfloat fbm2(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 4; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nstruct box{\n    vec3 pos;\n    vec3 size;\n};\n\nbox b1 = box(vec3(0, 2, 0), vec3(60, 2, 60));\n\nbool raytraceBox(vec3 o, vec3 d, out float ct, out float ft, box b){\n    vec3 tMin;\n    vec3 tMax;\n\n    vec3 halfSize = b.size/2.0;\n\n    vec3 lbf = b.pos - halfSize;\n    vec3 rtb = b.pos + halfSize;\n\n    tMin = (lbf - o)/d;\n    tMax = (rtb - o)/d;\n\n    if(tMin.x > tMax.x){\n        float tempT = tMin.x;\n        tMin.x = tMax.x;\n        tMax.x = tempT;\n    }\n\n    if(tMin.y > tMax.y){\n        float tempT = tMin.y;\n        tMin.y = tMax.y;\n        tMax.y = tempT;\n    }\n\n    if(tMin.z > tMax.z){\n        float tempT = tMin.z;\n        tMin.z = tMax.z;\n        tMax.z = tempT;\n    }\n\n    if((tMin.x > tMax.y) || (tMin.y > tMax.x)){\n        return false;\n    }\n\n    if(tMin.y > tMin.x){\n        tMin.x = tMin.y;\n    }\n\n    if(tMax.y < tMax.x){\n        tMax.x = tMax.y;\n    }\n\n    if((tMin.x > tMax.z) || (tMin.z > tMax.x)){\n        return false;\n    }\n\n    if(tMin.z > tMin.x){\n        tMin.x = tMin.z;\n    }\n\n    if(tMax.z < tMax.x){\n        tMax.x = tMax.z;\n    }\n    \n    if(ct < 0.0){\n        return false;\n    }\n    ct = max(tMin.x, 0.0);\n    ft = max(tMax.x, 0.0);\n    return true;\n}\n\nfloat densityAtPoint(vec3 p){\n    return max(fbm((p - vec3(iTime, 0, 0))*vec3(0.5, 1, 0.5))*10.0 - noise3((p - vec3(iTime, 0, 0))*0.3)*20.0, 0.0);\n}\n\nfloat getDensityOnRay(vec3 o, vec3 d, float ct, float ft, int res){\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = d*stepLength;\n    float density = 1.0;\n    for(int i = 0; i < res; i++){\n        float currDensity = exp(-mediaDensity*stepLength*densityAtPoint(samplePos));\n        density *= currDensity;\n        samplePos += stepDir;\n        if(density >= 0.99) break;\n    }\n    return density;\n}\n\nvec2 renderVolume(vec3 o, vec3 d, float ct, float ft, int res){\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = stepLength*d;\n    float density = 1.0;\n    float outDensity = 0.0;\n    float transmittance = 0.0;\n    for(int i = 0; i < res; i++){\n        //vec3 lightDir = normalize(vec3(0, 10, cos(iTime)*100.0 - 100.0) - samplePos);\n        vec3 lightDir = normalize(vec3(-10, -10, 10));\n        float lct;\n        float lft;\n        bool lightHit = raytraceBox(samplePos, lightDir, lct, lft, b1);\n        float currDensity = exp(-mediaDensity*stepLength*densityAtPoint(samplePos));\n        density *= currDensity;\n        if(lightHit){\n            float lDensity = getDensityOnRay(samplePos, lightDir, lct, lft, 15);\n            transmittance += density*lDensity*densityAtPoint(samplePos)*mediaDensity*stepLength;\n        }\n        outDensity += (1.0 - currDensity)*(1.0 - outDensity);\n        samplePos += stepDir;\n        if(outDensity >= 0.999 || transmittance >= 0.999) break;\n    }\n    return vec2(outDensity, transmittance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //vec3 o = vec3(sin(-iTime)*8.0, 0, cos(-iTime)*8.0);\n    //vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(0, iTime - radians(180.0))));\n    vec3 o = vec3(0, 0, -8);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(0, 0)));\n    float ct;\n    float ft;\n    bool hitBox = raytraceBox(o, d, ct, ft, b1);\n    \n    vec3 skyCol = mix(vec3(0.7, 0.9, 1), vec3(0.4, 0.5, 1), uv.y/2.0 + 0.5);\n    \n    if(hitBox){\n        vec2 renderMedia = renderVolume(o, d, ct, ft, 50);\n        \n        col = mix(skyCol, mix(mix(vec3(1, 0.8, 0.7), vec3(0), renderMedia.y), skyCol, 1.0 - exp(-ct*vec3(0.1, 0.1, 0.15))), renderMedia.x);\n    }else{\n        col = skyCol;\n    }\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3GR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 118, 118, 525], [527, 561, 583, 583, 697], [699, 699, 721, 721, 828], [830, 830, 851, 1687, 1734], [1736, 1736, 1757, 1757, 2177], [2179, 2179, 2197, 2469, 2599], [2601, 2601, 2620, 2620, 2894], [2988, 2988, 3056, 3056, 4074], [4076, 4076, 4105, 4105, 4224], [4226, 4226, 4293, 4293, 4671], [4673, 4673, 4736, 4736, 5752], [5754, 5754, 5808, 5808, 6601]], "test": "untested"}
{"id": "ddtGR8", "name": "Dynamic Occlusion", "author": "krupitskas", "description": "Experiment with a cone tracing to achieve sky dynamic occlusion\n\nInspiration: \n[1] https://advances.realtimerendering.com/s2015/DynamicOcclusionWithSignedDistanceFields.pdf\n[2] https://advances.realtimerendering.com/s2006/Evans-Fast_Approximations_for_Lig", "tags": ["sdf", "cone", "ao", "conetracing"], "likes": 5, "viewed": 273, "published": 3, "date": "1677077751", "time_retrieved": "2024-07-30T18:08:52.239529", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nconst float EPSILON = 0.001;\n    \nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat scene(vec3 p) \n{\n    float a1 = sphere(p + vec3(2.0 * sin( iTime * 0.7), 1.0, 2.0 * cos( iTime * 0.7)), 1.0);\n    float a2 = sphere(p, 1.0);\n    float a3 = sphere(p - vec3(0.0, -33.5, 0.0), 32.0);\n    float a4 = sphere(p - vec3(0.0, -2.0, 0.0), 0.5 + abs(sin( iTime )) );\n    float a5 = sphere(p + vec3(-4.0, -0.5 + sin( iTime ), 0.0), 1.0);\n    \n    return min(min(min(min(a1,a2), a3), a4), a5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    const int MAX_MARCHING_STEPS = 255;\n\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    \n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nuvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\nuvec3 quasi3 = uvec3( 3518319155, 2882110345, 2360945575 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 15.0);\n    \n    const float MIN_DIST = 0.0;\n    const float MAX_DIST = 100.0;\n\n    // Get geometry information\n    \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n\n    vec3 p = eye + dist * dir;\n    vec3 N = estimateNormal(p);\n\n    uint seed = uint(fragCoord.x)*quasi2.x\n        \t\t+ uint(fragCoord.y)*quasi2.y;\n     \n    // Now start with cone tracing\n    \n    const float CONES_NUM = 5.0; \n    const float MAX_DIST_CONE = 5.0;\n    const float MAX_STEPS_CONE = 16.0;\n    const float CONE_CAP_RAD = M_PI / CONES_NUM; \n\n    const float phi = 1.6180339887498948;\n    const float tau = 6.2831853071795865;\n\n    float ao = 0.0;\n\n    for( int j=0; j < int(CONES_NUM); j++ )\n    {\n        // https://mathworld.wolfram.com/DiskPointPicking.html\n        float r = sqrt((float(j) + 0.5) / CONES_NUM);\n        float a = phi * tau * float( j );\n        \n        // Dither\n        a += tau*(float(seed)/exp2(32.));\n\n        vec3 dir = vec3(sin(a) * r, sqrt( 1.0 - r * r), cos( a ) * r);\n        vec3 tangent = normalize(cross(N, vec3(1,0,0)));\n        vec3 bitangent = cross(tangent,N);\n        \n        // Rotate it\n        dir = dir.x * tangent + dir.y * N + dir.z * bitangent;\n\n        // Get the step size\n        vec3 endTrace = p + MAX_DIST_CONE * dir;\n        float len = length(p - endTrace);\n        float stepSize = len / MAX_STEPS_CONE;\n\n        float vis = 1.0f;\n\n        // Start a bit offsetted\n        for(int i = 1; i <= int(MAX_STEPS_CONE); i++)\n        {\n            vec3 stepPos = p + dir * stepSize * float(i);\n            \n            float distToStep = length(p - stepPos); \n            float radiusAtStep = tan(CONE_CAP_RAD / 2.0) * distToStep;\n            \n            float sdf_d = scene(stepPos);\n\n            vis = min( vis, smoothstep( -radiusAtStep, radiusAtStep, sdf_d ) );\n        }\n\n        ao += vis;\n    }\n    \n    // Normalize\n    ao /= CONES_NUM;\n\n    fragColor = vec4(ao, ao, ao, 1.0);\n        \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 115, 115, 141], [143, 143, 165, 165, 547], [549, 549, 578, 578, 870], [872, 872, 963, 963, 1307], [1309, 1309, 1374, 1374, 1511]], "test": "untested"}
{"id": "msc3R7", "name": "chatGPT Raytrace Mod", "author": "Sergeindamix", "description": "Para crear una variante de este shader con un array de cubos equidistantes y centrados en la cmara, podemos modificar la funcin GetDist para que calcule la distancia al objeto ms cercano que sea un cubo equidistante del centro de la cmara.\n\nAqu est ", "tags": ["chatgpt"], "likes": 1, "viewed": 163, "published": 3, "date": "1677076990", "time_retrieved": "2024-07-30T18:08:53.019444", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define CUBE_SIZE 2.0\n#define CUBE_GAP 1.0\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    vec3 cube_pos = CUBE_SIZE * floor(p / CUBE_SIZE);\n    float d = sdBox(p - cube_pos, vec3(1));\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n\n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n\n    col = pow(col, vec3(.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msc3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 208, 208, 270], [272, 272, 301, 301, 385], [387, 387, 410, 410, 524], [526, 526, 560, 560, 767], [769, 769, 793, 793, 933], [935, 935, 985, 985, 1165], [1167, 1167, 1224, 1224, 1813]], "test": "untested"}
{"id": "mdcGzM", "name": "horizontal ", "author": "tianluo97", "description": "horizontal ", "tags": ["horizontal"], "likes": 0, "viewed": 126, "published": 3, "date": "1677074308", "time_retrieved": "2024-07-30T18:08:53.965913", "image_code": "//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\nvec3 getSky(vec2 uv)\n{\n    float atmosphere = sqrt(1.0-uv.x);\n    vec3 skyColor = vec3(0.2,0.4,0.8);\n    \n    float scatter = pow(iMouse.x / iResolution.x,1.0 / 15.0);\n    scatter = 1.0 - clamp(scatter,0.8,1.0);\n    \n    vec3 scatterColor = mix(vec3(1.0),vec3(1.0,0.3,0.0) * 1.5,scatter);\n    return mix(skyColor,vec3(scatterColor),atmosphere/1.3);\n}\n\nvec3 getSun(vec2 uv){\n\tfloat sun = 1.0 - distance(uv,iMouse.xy / iResolution.y);\n    sun = clamp(sun,0.0,1.0);\n    \n    float glow = sun;\n    glow = clamp(glow,0.0,1.0);\n    \n    sun = pow(sun,100.0);\n    sun *= 100.0;\n    sun = clamp(sun,0.0,1.0);\n    \n    glow = pow(glow,6.0) * 1.0;\n    glow = pow(glow,(uv.y));\n    glow = clamp(glow,0.0,1.0);\n    \n    sun *= pow(dot(uv.y, uv.y), 1.0 / 1.65);\n    \n    glow *= pow(dot(uv.y, uv.y), 1.0 / 2.0);\n    \n    sun += glow;\n    \n    vec3 sunColor = vec3(1.0,0.6,0.05) * glow;\n    \n    return vec3(sunColor);\n}\n\n\nfloat smooth_step( float edge0, float edge1, float x )\n{\n    float p = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    float v = p * p * (3.0 - 2.0 * p); // smoothstep formula\n    \n    //v = smoothstep( edge0, edge1, x ); // Compare with built-in\n    \n    return v;\n}\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    vec4 color1 = vec4(0.922,0.443,0.000,1.0); \n    vec4 color2 = vec4(1.000,0.894,0.859,1.0);\n    vec4 color3 = vec4(0.141,0.361,0.800,1.0);\n    \n    /*\n    vec4 color1 = vec4(0.992,0.867,0.757,1.0); \n    vec4 color2 = vec4(0.373,0.753,1.000,1.0);\n    vec4 color3 = vec4(0.976,0.780,0.792,1.0);*/\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.; \n    \n    //scale\n    float scale = 1.0;\n    //colorStep1\n    float colorStep1 = 0.23333;\n    //colorStep2\n    float colorStep2 = 0.5555;\n    \n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    float step1 = scale * (colorStep1);\n    float step2 = scale * max(colorStep1+0.1, (colorStep2)); \n    \n    // step0 - step1\n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    // step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n\n    //fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color3, dist2);\n    }\n    \n    // step2 - 1.0\n    else{\n    float dist3 = smoothstep(step2, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = color3;\n    }\n    \n    //fragColor = sqrt(fragColor);\n    \n    //sky\n    vec3 sky = getSky(uv);\n    float atmosphere = sqrt(1.0-uv.x);\n    \n    //vec3 skyColor = vec3(fragColor.rgb);\n    vec3 skyColor = vec3(0.2,0.4,0.8);\n     \n    float scatter = pow(iMouse.x / iResolution.x,1.0 / 15.0);\n    scatter = 1.0 - clamp(scatter,0.8,1.0);\n    \n    vec3 scatterColor = mix(vec3(1.0),vec3(1.0,0.3,0.0) * 1.5,scatter);\n    //vec3 scatterColor = vec3(1.);\n    \n    //vec3 color = vec3(atmosphere/1.3,atmosphere/1.3,atmosphere/1.3);\n    vec3 color = mix(skyColor,vec3(scatterColor),atmosphere/1.3);\n    \n    vec3 sun = getSun(fragCoord.xy / iResolution.y);\n    \n    fragColor = vec4(color,1.0);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 123, 123, 451], [453, 453, 474, 474, 1007], [1010, 1010, 1066, 1066, 1281], [1330, 1330, 1387, 1424, 3938]], "test": "untested"}
{"id": "ms3GzH", "name": "Random Asymmetric Quad Grid", "author": "Shane", "description": "A random animated 2D asymmetric rounded quad grid.", "tags": ["2d", "grid", "text", "font", "quad", "aymmetric"], "likes": 94, "viewed": 1074, "published": 3, "date": "1677074052", "time_retrieved": "2024-07-30T18:08:54.957263", "image_code": "/*\n\n    Random Asymmetric Quad Grid\n    ---------------------------\n\n    Rendering the buffer.\n \n    See Buffer A for an explanation.\n    \n*/\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a couple of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec4 bloom(sampler2D iCh, vec2 uv, float radius){\n\n\tvec4 tot = vec4(0);\n    \n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*3.;\n    \n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n           \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            vec4 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7); \n            tot += mix(c, pow(c, vec4(1.25))*3.4, rnd2.x*rnd2.x); //ow(c, vec4(1.5))*4.\n            \n        }\n    }\n    \n\treturn tot/float((n*2 + 1)*(n*2 + 1));\n}\n \n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n   \n    // Custom DOF bloom-like function.\n    col = bloom(iChannel0, uv, 1.);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Random Asymmetric Quad Grid\n    ---------------------------\n    \n    I coded up an asymmetric quad cell grid some time ago, just for\n    the fun of it, then forgot about it. I came across it the other \n    day and decided to add some bump mapping, highlights, etc, and \n    wound up with whatever this is. :) It's a 2D example, so should \n    run at a reasonable pace on most machines.\n    \n    Out of sheer boredome, I put some letters in the cells, then \n    proceeded to hack away at it until it looked like... a picture of\n    a keyboard that's been run through a poorly written AI art \n    generating algorithm or something. :)\n    \n    I originally used static cells, which is a little more believable,\n    since hardened graphite material doesn't flow, but I thought the\n    animation made it a little more interesting.\n    \n    There's nothing ground breaking in here, but the grid code might\n    be interesting to some. The code was originally written with \n    extruded grids in mind. I have a few examples, and will post one \n    or two at some stage. There's a custom bloom-like postprocessing \n    routine in the \"Image\" tab that someone might find useful also.\n    \n\n*/\n\n\n// Animate the blocks or not. The animation reduces the beveled \n// letter illusion a bit, but it's more interesting.\n#define ANIMATE\n\n// Different color configurations.\n// Orange: 0, Blue: 1, Green 2, Orange and blue: 3.\n#define COLOR 0\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n\n// Entirely based on IQ's signed distance to a 2D triangle -- Very handy.\n// I have a generalized version somewhere that's a little more succinct,\n// so I'll track that down and drop it in later.\nfloat quad(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3){\n\n    //////////////////\n    // Extra calculations here.\n    //////////////////\n    \n    // Unfortunately, to render rounded quads on a grid, the vertices need to \n    // be moved inward in order to add a rounding factor and have the quad still\n    // fit within the cell. Contracting all vertices by a simple shrinking factor \n    // doesn't preserve edge width, so some extra trigonometry is required.\n    //\n    // By the way, I can't but help think there must be a simpler way to go about\n    // this that I'm not seeing, so if someone can figure out a way to produce \n    // the same without the following addition, feel free to let me know. :)\n\n\n    // Nudge factor to move the vertices inward. \n    const float ndg = .02;\n    \n    // Normalized edge lines.\n\tvec2 e0 = normalize(p1 - p0);\n\tvec2 e1 = normalize(p2 - p1);\n\tvec2 e2 = normalize(p3 - p2);\n\tvec2 e3 = normalize(p0 - p3);\n    \n    // Angle between vectors. Calculating four at a time, which one would\n    // assume is less draining on the GPU.\n    vec4 ang, sl;\n    ang = acos(vec4(dot(e0, -e3), dot(e1, -e0), dot(e2, -e1), dot(e3, -e2)));\n    sl = ndg/tan(ang/2.);\n    // Using the above to move the vertices in by the nudge factor.\n    p0 += sl.x*e0 + ndg*e0.yx*vec2(1, -1);\n    p1 += sl.y*e1 + ndg*e1.yx*vec2(1, -1);\n    p2 += sl.z*e2 + ndg*e2.yx*vec2(1, -1);\n    p3 += sl.w*e3 + ndg*e3.yx*vec2(1, -1);\n    \n    // Setting the new edge vectors.\n    e0 = p1 - p0;\n    e1 = p2 - p1;\n    e2 = p3 - p2;\n    e3 = p0 - p3;\n    \n    //////////////////\n    //////////////////\n\n    // Continuing with IQ's quad calculations... Actually, this is a \n    // slighlty modified version of his triangle function. \n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n   \n\tvec2 pq0 = v0 - e0*clamp(dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp(dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp(dot(v2, e2)/dot(e2, e2), 0., 1.);\n\tvec2 pq3 = v3 - e3*clamp(dot(v3, e3)/dot(e3, e3), 0., 1.);\n    \n    float s = sign(e0.x*e3.y - e0.y*e3.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n    \n    d = min(d, vec2(dot(pq3, pq3), s*(v3.x*e3.y - v3.y*e3.x)));\n \n    // Signed, rounded quad distance.\n\treturn -sqrt(d.x)*sign(d.y) - ndg;\n}\n\n\n// IQ's vec2 to float hash.\nvec2 hash22TA(vec2 p){ \n\n    p = texture(iChannel3, p/63.2453).xy;\n    return sin(p*6.2831853 + iTime);//p;//\n    \n  \n}\n\n// IQ's vec2 to float hash.\nvec2 hash22T(vec2 p){ return texture(iChannel3, p/65.6217).xy*2. - 1.; }\n\n\nvec4 gVal; // Storage for the cell contents.\nvec2 gSID; // Static ID.\n\n// Global normal. It's a weird place to put it, but I'm doing the \n// bump mapping inside the \"map\" function to save calculations.\nvec3 gN; \n\nvec2 scale = vec2(1.5, 1)/10.; // Scale.\n\n// The asymmetric quad grid. \nvec4 map(vec2 p){\n    \n    // Distance and edge width.\n    float d = 1e5;\n    float ew = .005;\n    \n    // Scale.\n    vec2 sc = scale;\n    \n    \n    // Centers for all four tiles.\n    const mat4x2 cntr = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5)); \n    \n    // Saving the local coordinates and four vertices of the nearest quad. \n    // Only used for bump mapping.\n    vec2 svQ;\n    mat4x2 svV;\n    \n    // Because the asymmetric boundaries of the quads overlap neighboring cells, \n    // neighbors need to be considered. In this case four cell renders will do.\n    const int n = 2;\n    //const float m = floor(float(n)/2. + .001) - .5;\n    for(int i = 0; i<n*n; i++){\n\n        // Local coordinates and ID.\n        vec2 q = p.xy;\n        vec2 iq = floor(q/sc - cntr[i]) + .5; \n        q -= (iq)*sc;\n        \n        // The four vertices for this cell.\n        mat4x2 v = cntr;\n        \n        // Offset the vertices.\n        #ifdef ANIMATE\n        v[0] += hash22TA(iq + v[0])*.2;\n   \t\tv[1] += hash22TA(iq + v[1])*.2;\n        v[2] += hash22TA(iq + v[2])*.2; \n        v[3] += hash22TA(iq + v[3])*.2;\n        #else\n        v[0] += hash22T(iq + v[0])*.2;\n   \t\tv[1] += hash22T(iq + v[1])*.2;\n        v[2] += hash22T(iq + v[2])*.2; \n        v[3] += hash22T(iq + v[3])*.2;\n        #endif\n        // Scale.\n        v[0] *= sc; v[1] *= sc; v[2] *= sc; v[3] *= sc;\n        \n\n        // Render the quad. This is a modified version of one of IQs\n        // polygon functions to render rounded general quads that\n        // fit on a grid.\n        float d2 = quad(q, v[0], v[1], v[2], v[3]) + ew;\n        \n        // If this quad distance is nearer, update.\n        if(d2<d){\n            \n            // New distance, static ID and moving ID.\n            // The zero field is an unused height value holder.\n            d = d2;\n            gSID = iq;\n            iq += (v[0] + v[1] + v[2] + v[3])/4./sc;\n            gVal = vec4(d2, 0., iq);\n            \n            // Saving the local coordinates and vertices to perform \n            // some bump mapping. These were hacked in as an afterthough.\n            // Normally, you wouldn't need to do this.\n            svQ = q;\n            svV = v;\n      \n        }\n    \n    }\n    \n    // Set the normal to the back plane.\n    gN = vec3(0, 0, -1);\n    \n    // If we've hit a quad, bump map the normal.\n    if(d<1e5){\n    \n        // Saving some calculations by constructing the normal here,\n        // instead of calling the entire map function two more times.\n        //\n        vec2 e = vec2(.005, 0); // Sample spread.\n\n        vec2 q = svQ;\n        mat4x2 v = svV;\n\n        // Nearby X and Y samples -- Standard gradient calculations.\n        float d2X = quad(q - e, v[0], v[1], v[2], v[3]) + ew;// - .02;\n        float d2Y = quad(q - e.yx, v[0], v[1], v[2], v[3]) + ew;// - .02;\n        // Modifying the samples to give a slightly rounded beveled look.\n        d = mix(d, smax(d, smax(d*2., -.01, .01), .1), .75); \n        d2X = mix(d2X, smax(d2X, smax(d2X*2., -.01, .01), .1), .75);  \n        d2Y = mix(d2Y, smax(d2Y, smax(d2Y*2., -.01, .01), .1), .75);  \n        /*\n        // Alternative flatter tops, which are more button like.\n        d = smax(smax(d*6., -.03, .01), smax(d*2., -.02, .01), .03); \n        d2X = smax(smax(d2X*6., -.03, .01), smax(d2X*2., -.02, .01), .03); \n        d2Y = smax(smax(d2Y*6., -.03, .01), smax(d2Y*2., -.02, .01), .03); \n        */\n        // Applying the gradient to the flat plane normal, vec3(0, 0, -1).\n        float bf = .7; // Bump factor.\n        gN = normalize(vec3((d - d2X)/e.x, (d - d2Y)/e.x, -1./bf));\n    }\n    \n    \n    // Combining the floor with the extruded object.\n    return  gVal;\n \n}\n\n// Obtaining an ASCII character from the font texture. This is pretty standard.\n// I think I based it on one of Fabrice's early examples. I'll find it and put\n// in the link later.\nvec4 chTx(vec2 p, int n){\n\n    vec2 i = vec2(n&15, 15 - (n>>4))/16.;\n    return (p.x<0. || p.x>1./16. || p.y<0. || p.y>1./16.)? \n            vec4(0, 0, 0, 1e5) : texture(iChannel1, p + i);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Moving coordinates.\n    vec2 p = r2(-3.14159/16.)*uv + vec2(0, 2)*iTime/64.;//r2(-3.14159/12.)*\n     \n    // Unit direction ray and light direction.\n    vec3 rd = normalize(vec3(uv, 1)); \n    vec3 ld = normalize(vec3(-.5, .5, -3) - vec3(uv, 0));\n\n    // Obtaining the asymmetric quad cell information.\n    vec4 d4 = map(p);\n    \n    // Set the normal to the one calculated in the \"map\" function.\n    vec3 sn = gN;\n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    // Random graphite cell color.\n    float rnd = hash21(gSID); // Random object value.\n    vec3 oCol = vec3(rnd*rnd*.04 + .05);\n    \n    // Random color for blinking light cells.\n    vec3 oColL = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2)*1.2); // Orange.\n    //vec3 oColL = .5 + .45*cos(6.2831*rnd/15. + vec3(0, 1, 2.2)*1.1 + 1.15);\n    //vec3 oColL = .5 + .38*cos(6.2831*rnd/7.5 + vec3(0, 1, 2.2)/1.2 + .7);\n    \n    // Mixing in another color.\n    oColL = mix(oColL, oColL.xzy, hash21(gSID + .42)*.25);\n    \n    #if COLOR == 1\n    oColL = oColL.zyx; // Blue.\n    #elif COLOR == 2\n    oColL = mix(oColL, oColL.yxz*.8, .8); // Green.\n    #elif COLOR == 3\n    // Random compliment colors.\n    oColL = mix(oColL.zyx, oColL, step(.5, hash21(gSID + .44)));\n    #endif\n    \n\n    \n    // Random lighter grey.\n    if(hash21(gSID + .17)<.5) {\n        oColL = vec3(.88, .9, 1)*(rnd*.12 + .18);//dot(oColL, vec3(.299, .587, .114));\n    }\n         \n    // Random blinking colors. I overuse this trick a bit, but it's effective.    \n    float rnd2 = hash21(gSID + .23);\n    oCol = mix(oCol, oColL*1.5, smoothstep(.93, .96, sin(6.2831*rnd2 + iTime/4.)*.5 + .5));\n\n    \n    ///// FONTS /////\n    // Adding text to the cells.\n    vec2 sc = scale;\n    vec2 tPos = p - d4.zw*sc - vec2(1, 2)*32./1024.*sc + vec2(sc.x/4., sc.y/2.4);\n    int nc = int(floor(hash21(gSID)*93.) + 33.);\n    float sD = .003;\n    float bF = 2.;\n    // Texture samples.\n    vec4 dC = chTx(tPos, nc);\n    vec4 dCX = chTx(tPos - vec2(sD, 0), nc);\n    vec4 dCY = chTx(tPos - vec2(0, sD), nc);\n    // Gradient indentation -- I was in a hurry, so there are probably neater\n    // ways to do this... Probably a question for Fabrice. :)\n    dC.x = smoothstep(0., .25, -(dC.w - .53));\n    dCX.x = smoothstep(0., .25, -(dCX.w - .53));\n    dCY.x = smoothstep(0., .25, -(dCY.w - .53));\n    \n    // Applying the font indentation bump to the normal. It's not perfect, but it'll do.\n    float bf = .5;\n    sn = normalize(sn + vec3((dC.x - dCX.x)*bf, (dC.x - dCY.x)*bf, 0)/sD*bF);\n   \n    // Applying a font overlay color to the font indentation.\n    vec3 fCol = oCol/(.5 + dot(col, vec3(.299, .587, .114)));  \n    float gr = dot(fCol, vec3(.299, .587, .114));\n    fCol = max(vec3(1) - gr*gr*8., .0)*.9 + .05;\n    //svC = mix(oColL, svC*, smoothstep(.93, .96, sin(6.2831*rnd2 + iTime/4.)*.5 + .5));\n    oCol = mix(oCol, fCol, (1. - smoothstep(0., sf*3., dC.w - .51))*.9);\n    //////////////\n    \n    \n    // Diffuse and specular calculations. \n    float dif = max(dot(ld, sn), 0.); \n    float spe = pow(max(dot(reflect(ld, sn), rd), 0.), 8.);\n    //float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 16.);\n\n    \n    // Overall coloring and lighting for the cell.\n    oCol *= (dif*.35 + .3 + vec3(1, .97, .92)*spe*.5);\n    \n    // Using the cube map for some fake specular reflections.\n    vec3 tx = texture(iChannel2, reflect(rd, sn)).xyz; tx *= tx;\n    oCol += (oCol*.75 + .25)*mix(tx.zyx, tx.yyy, .3)*4.*spe;\n \n    // Applying the cell to the background.\n    col = mix(col, oCol, 1. - smoothstep(0., sf, d4.x));\n \n \n  \n    #if 1\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./3.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), d4.x), blend);\n    #else\n    // Output to screen.\n    fragColor = vec4((max(col, 0.)), d4.x);\n    #endif\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3GzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 171, 192, 192, 255], [257, 797, 846, 846, 1606], [1612, 1612, 1666, 1696, 2079]], "test": "untested"}
{"id": "cst3RN", "name": "Mystic", "author": "guil", "description": "Probably alien.", "tags": ["fractal"], "likes": 7, "viewed": 231, "published": 3, "date": "1677063503", "time_retrieved": "2024-07-30T18:08:55.731193", "image_code": "#define r(a)   mat2(cos(a+vec4(0,11,33,0)))  \n#define t      .1*iTime\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float o=4.,i=0.,j=i,s,g=1.,k=.04;\n    vec3 p,n,c,r= iResolution;\n    p = 3.*vec3( g* ( U - r.xy/2. ) / r.y, g-2. );\n    for(g = length(p)-2.1; i++ < 80.; g += o*k )\n      { s = 1.;\n        if(abs(o)<.005)continue; \n        n=r-r,\n        p = 3.*vec3( g* ( U - r.xy/2. ) / r.y, g-2. );\n        c=p;\n        p.yz *= r(.5);\n        p.xy *= r(t);\n        k *= 1.036;\n        for(;s<1.5; s/=.98 ){           \n            p.x = abs(p.x-.2+.2*cos(t)),          \n            n = .08*sin(1.2*p+.4)*s,\n            p = p.yxz*s;            \n            for(j=0.;j<3.;j++)p = p-n,o = min(o, length(p)-.1);\n            }                        \n        }            \n    c = log(1. + c)*exp(-12.*o*o);    \n    C = vec4(c,1);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cst3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 109, 109, 827]], "test": "untested"}
{"id": "csd3z4", "name": "clock 5  ( 248ch )", "author": "FabriceNeyret2", "description": "inspiration: [url]https://www.boredpanda.com/blog/wp-content/uploads/2022/10/633c179cf17c9_ce66fqc32rg91__700.jpg[/url]\nfrom https://www.boredpanda.com/cool-design-images-and-models/", "tags": ["clock", "2tweets", "short", "reproduction", "funclock"], "likes": 22, "viewed": 355, "published": 3, "date": "1677056042", "time_retrieved": "2024-07-30T18:08:56.747476", "image_code": "// variant of \"clock (240)\" https://shadertoy.com/view/MdVGDd\n\n// -8 by sylvain69780, (12 by Fab\n\n#define N(T,l)  U = ( u+u - R ) / R.y * mat2(cos(iDate.w/T+vec4(0,33,11,0))),      \\\n                O += max(0., l - R.y/2.                              /* AA draw */ \\\n                      * min( max( abs(U.x), abs(U.y-.3)-.3 ),        /* handle  */ \\\n                             abs( max(abs(U).x,abs(U).y) - .6 ) ));  /* frame   */\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, U;\n    O*=0.;\n    //N(1e30, 3.)\n\tN( 6875., 3. )\n    N( 573.,  1.5)\n    N( 9.55,  1. )\n    \n    O = sqrt(O);     // to sRGB\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csd3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ddcGzN", "name": "Arabesque knots 3", "author": "jarble", "description": "An arabesque knot pattern.", "tags": ["fractal", "music", "arabesque"], "likes": 10, "viewed": 213, "published": 3, "date": "1677050193", "time_retrieved": "2024-07-30T18:08:57.609172", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += iTime/t1/16.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 5; k++){\n        uv =\n            2.*abs(.5+uv+t2)/1.5\n        ; \n        //uv += floor(uv*2.); //another interesting pattern\n        //uv += floor(uv*2.)+floor(uv*1.5); //another interesting pattern\n        uv += sign(uv-uv.yx)/2.+.5+floor(uv*2.)*floor(uv*1.5); //another interesting pattern\n\n        bool b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        //else k += 1;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        //if(uv.y>uv.x) uv = uv.yx-vec2(1.5,.5);\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        //if(b||t2.y<t2.x)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n        ;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    a /= (1. + floor(mod(a*4.,2.)))*4.;\n    return mod(floor(a),b);\n}\n\nvec2 mainSound(int samp, float t){\n  //float p1 = 1. + floor(mod(mod(t,1.+t/4.)/2.,2.));\n  t *= 1./2.;\n  t += fract(t);\n  float s1 = 8.;\n  float a=\n      pow((1.-sqrt(fract(t/2.))),2.)\n  ,\n  nb = pow(2.,(2.+fmod(t*2.,s1)+1. + fmod(floor(t/s1),2.))/5.+7.);\n  return\n      abs(.5-vec2(fract(t*nb*.998*2.),fract(t*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1155]], "test": "untested"}
{"id": "dscGz4", "name": "Melted Wax", "author": "wyatt", "description": "Use mouse", "tags": ["fluid"], "likes": 21, "viewed": 355, "published": 3, "date": "1677034448", "time_retrieved": "2024-07-30T18:08:58.371135", "image_code": "// Fork of \"Watershed\" by wyatt. https://shadertoy.com/view/md3GRn\n// 2023-02-22 02:19:50\n\n// Fork of \"Liquid Disco\" by wyatt. https://shadertoy.com/view/Dt2XWK\n// 2023-02-20 06:14:33\n\nMain \n{\n    vec4 f = A(U);\n    vec4 c = B(U);\n    vec4 n = A(U+vec2(0,1))+B(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0))+B(U+vec2(1,0));\n    vec4 s = B(U-vec2(0,1))+B(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0))+B(U-vec2(1,0));\n    Q = min(10.*c.w,1.)*(.6+.5*sin(2.*c.z+vec4(1,2,3,4)));\n    Q = mix(Q,f.w*(.6+.5*sin(2.*f.z+vec4(1,2,3,4))),.5*f.w);\n    Q.xyz *= .5+.5*normalize(vec3(e.w-w.w,n.w-s.w,1.)).zzz;\n    \n    Q.w = 1.;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat erf(in float x) {\n    x *= .8;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "buffer_a_code": "Main\n{\n    vec4 dQ = Q = vec4(0);\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    Q.y -= 1e-3;\n    Q.xy *= .95;\n    vec4 c = C(U);\n    Q.w -= c.x;\n    if (U.x < 1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.w = 0.;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.w = .5,Q.z = sin(iTime);\n    if (iFrame < 1) {Q = vec4(0);}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = a.w*(a.w-1.5)+b.w;\n        dQ.xy -= .5*f*u/dot(u,u);\n    }\n    Q += dQ;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    vec4 a = A(U);\n    Q = B(U);\n    Q.x = .001*a.w-.01*Q.w*(a.w);\n    Q.w += Q.x;\n    if (10.*max(Q.x,0.)+a.w>0.)\n    Q.z = ((10.*Q.z*max(Q.x,0.))+a.z*a.w)/\n            (10.*max(Q.x,0.)+a.w);\n    \n    \n    if (iFrame < 1)\n        Q = vec4(0);\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Ds33RN", "name": "Fork Exotic tre guil 145", "author": "guil", "description": "Probably alien.", "tags": ["tree"], "likes": 0, "viewed": 183, "published": 3, "date": "1677021726", "time_retrieved": "2024-07-30T18:08:59.159028", "image_code": "#define r(a)   mat2(cos(a+vec4(0,11,33,0)))          //\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float o=4.,i=0.,j=i,s,g=1.,k=.05;\n    vec3 p,r,n,c;\n    for(; i++ < 100.; g += o*k )\n      { s = 1.;\n        if(abs(o)<.0005)continue;\n        r = iResolution, \n        n=r-r,\n        p = 2.5*vec3( g* ( U - r.xy/2. ) / r.y, g-3. );\n        p.y+=2.;\n        p.xz *= r(.1*iTime+3.5);\n        k *= 1.036;\n        for(j=0.;j<15.;j++)p.y-=.15,o = min(o, length(p)-.16);\n        p.yz *= r(-.4);\n        for(;s<2.2; s/=.9 ){\n            p.xz *= r(1.3),\n            p.yz *= r(-.4),\n            p.z = abs(p.z),          \n            n = .06*sin(p+1.2).yzx*s,\n            p = (p*s).yxz;\n            if(s>1.5)p.x = abs(p.x); \n            for(j=0.;j<6.;j++)p = p-n,o = min(o, length(p)-.1);\n            }                        \n        o = min(o, length(p*vec3(1,.2,.5))-.2);\n        }        \n    o+=.06;\n    c = log(1. + p*o);    \n    C = vec4(c,1);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds33RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 95, 95, 943]], "test": "untested"}
{"id": "Ddc3RN", "name": "plasma-1", "author": "coolcoder613", "description": "animation", "tags": ["plasma"], "likes": 3, "viewed": 212, "published": 3, "date": "1677021209", "time_retrieved": "2024-07-30T18:08:59.967866", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfor(int i=1;i<10;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.6/float(i)*sin(float(i)*p.y+iTime+0.3*float(i))+1.0;\n\t\tnewp.y+=0.6/float(i)*sin(float(i)*p.x+iTime+0.3*float(i+10))-1.4;\n\t\tp=newp;\n\t}\n\tvec3 col=vec3(1.0,1.0-(sin(p.y)),sin(p.x+p.y));\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddc3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 398]], "test": "untested"}
{"id": "Ds33R4", "name": "first shader rotating", "author": "koe1k", "description": "it's rotating and scaling for no reason", "tags": ["circle"], "likes": 0, "viewed": 183, "published": 3, "date": "1677006880", "time_retrieved": "2024-07-30T18:09:01.043988", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = length(uv - vec2(0.90,0.5));\n\n    float c = dist;\n    \n    float r = cos(iTime) * 0.05 + 0.45;\n    \n    if(c > r)\n        c = 1.0;\n    else\n        c = 0.0;\n        \n        \n    fragColor = vec4(vec3(c),1.0);\n        \n    for(float i = 0.0; i < 6.0; i+=1.0)\n    {\n        if((uv.x - r * (2.0/3.0) * cos(radians(i*60.0 + iTime*15.0)) - 0.9) * (uv.x - r * (2.0/3.0) * cos(radians(i*60.0+ iTime*15.0)) - 0.9) + (uv.y - r * (2.0/3.0) * sin(radians(i*60.0+ iTime*15.0)) - 0.5) * (uv.y - r * (2.0/3.0) * sin(radians(i*60.0+ iTime*15.0)) - 0.5) < r*r/9.0)\n            {\n            fragColor.x = 0.5;\n            fragColor.y = 0.5;\n            }\n            \n    }\n    \n    \n    // Output to screen\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds33R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 922]], "test": "untested"}
{"id": "cstGzH", "name": "Exotic tree", "author": "guil", "description": "Probably alien.", "tags": ["tree"], "likes": 9, "viewed": 264, "published": 3, "date": "1676997839", "time_retrieved": "2024-07-30T18:09:02.162997", "image_code": "#define r(a)   mat2(cos(a+vec4(0,11,33,0)))          //\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float o=4.,i=0.,j=i,s,g=1.,k=.04;\n    vec3 p,n,c,r= iResolution;\n    p = 3.*vec3( g* ( U - r.xy/2. ) / r.y, g-2. );\n    for(g = length(p)-2.1; i++ < 80.; g += o*k )\n      { s = 1.;\n        if(abs(o)<.005)continue; \n        n=r-r,\n        p = 3.*vec3( g* ( U - r.xy/2. ) / r.y, g-2. );\n        p.y+=2.;\n        p.zy*=r(.5);\n        p.xz *= r(.1*iTime+3.5);\n        k *= 1.036;\n        for(j=0.;j<12.;j++)p.y-=.15,o = min(o, length(p)-.16);\n        for(;s<3.; s/=.9 ){\n            p.xz *= r(1.),\n            p.yz *= r(-.1),\n            p.z = abs(p.z),          \n            n = .06*sin(p+1.2).yzx*s,\n            p = (p*s).yxz;\n            if(s>1.5)p.x = abs(p.x); \n            for(j=0.;j<6.;j++)p = p-n,o = min(o, length(p)-.1);\n            }                        \n        //o = min(o, length(p*vec3(1,.2,.5))-.2);\n        }        \n    c = log(1. + p*o);    \n    C = vec4(c,1);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cstGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 95, 95, 981]], "test": "untested"}
{"id": "dst3z8", "name": "Eye Ball Monster", "author": "yasuo", "description": "Eye Ball Monster", "tags": ["eyeball", "cineshader"], "likes": 26, "viewed": 1923, "published": 3, "date": "1676993761", "time_retrieved": "2024-07-30T18:09:03.265050", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n\nfloat SimpleVesicaDistanceX(vec2 p, float r, float d) {\n    p.y = abs(p.y);\n    p.y+=d;\n    return length(p)-r;\n}\n\nfloat eyeBall(vec2 p){\n    \n    p.x+=sin(iTime*0.5)*0.1;\n    vec2 prevP = p;\n    \n    float d = abs(length(p)-0.13)-0.005;\n    float d2 = length(p)-0.045;\n    d = min(d,d2);\n    \n    p*=Rot(radians(iTime*-20.));\n    p=DF(p,8.);\n    p-=vec2(0.08);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.003,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot(radians(iTime*30.));\n    d2 = abs(length(p)-0.075)-0.012;\n    \n    float a = radians(45.);\n    p.x = abs(p.x);\n    \n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(length(p)-0.075)-0.002;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat eye(vec3 p, float mask, float mask2){\n    vec3 prevP = p;\n    p.z = abs(p.z);\n    p.z-=0.55;\n    \n    float eye = eyeBall(p.xy);\n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.55;\n    float s = mod(iTime*0.5,2.3);\n    if(s<1.){\n        p.y*=1.+s;\n    } else if(s>=1. && s<2.){\n        p.y*=1.+2.-s;\n    }\n    \n    float d2 = abs(SimpleVesicaDistanceX(p.xy,0.25,0.1))-0.01;\n    float d3 = SimpleVesicaDistanceX(p.xy,0.25,0.1);\n    \n    \n    eye = max(abs(p.z)-0.03,eye);\n    \n    \n    d2 = max(abs(p.z)-0.07,d2);\n    d2 = max(mask,d2);\n    \n    d3 = max(abs(p.z)-0.1,d3);\n    d3 = max(mask2,d3);\n    eye = max(d3,eye);\n    \n    \n    return  min(eye,d2);\n}\n\nfloat pattern(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-30.*iTime));\n    float d = abs(length(p)-0.1)-0.005;\n    d = max(abs(p.x)-0.05,d);\n    p = prevP;\n    float d2 = abs(length(p)-0.07)-0.001;\n    \n    d = min(d,d2);\n    \n    p*=Rot(radians(90.+30.*iTime));\n    p.y = abs(p.y)-0.15;\n    d2 = Tri(p,vec2(0.03),radians(45.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern2(vec2 p, float thickness){\n    vec2 prevP = p;\n    p*=Rot(radians(45.));\n    float d = abs(B(p, vec2(0.1)))-0.002;\n    float d2 = abs(B(p, vec2(0.06)))-0.002;\n    d2 = max(-(abs(p.x)-0.02),d2);\n    d2 = max(-(abs(p.y)-0.02),d2);\n    d = min(d,d2);\n    d2 = abs(B(p, vec2(0.1)))-thickness;\n    p*=Rot(radians(30.*iTime));\n    d2 = max(-(abs(p.x)-0.05),d2);\n    d2 = max(-(abs(p.y)-0.05),d2);\n    d = min(d,d2);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n\n    p.yz *= Rot(radians(iTime*-3.0));\n    vec3 prevP = p;\n    \n    float mask = length(p)-0.58;\n    float mask2 = length(p)-0.565;\n    float d = length(p)-0.55;\n    \n    float d2 = eye(p,mask,mask2);\n    \n    d = min(d,d2);\n    \n    p.xz*=Rot(radians(90.));\n    d2 = eye(p,mask,mask2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.yz*=Rot(radians(90.));\n    d2 = eye(p,mask,mask2);    \n    d = min(d,d2);\n    \n    p = prevP;\n    p.yz*=Rot(radians(45.));\n    p.xz*=Rot(radians(35.));\n    d2 = pattern(p.xy);\n    d2 = max(mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-45.));\n    p.xz*=Rot(radians(35.));\n    d2 = pattern(p.xy);\n    d2 = max(mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-45.));\n    p.xz*=Rot(radians(-35.));\n    d2 = pattern(p.xy);\n    d2 = max(mask,d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.yz*=Rot(radians(45.));\n    p.xz*=Rot(radians(-35.));\n    d2 = pattern(p.xy);\n    d2 = max(mask,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.yz*=Rot(radians(45.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);   \n    \n    p = prevP;\n    p.yz*=Rot(radians(-45.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);       \n    \n    p = prevP;\n    p.xz*=Rot(radians(45.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);   \n        \n    p = prevP;\n    p.xz*=Rot(radians(-45.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);   \n    \n    p = prevP;\n    p.xz*=Rot(radians(90.));\n    p.yz*=Rot(radians(-35.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);      \n    \n    \n    p = prevP;\n    p.xz*=Rot(radians(-90.));\n    p.yz*=Rot(radians(-35.));\n    d2 = pattern2(p.xy,0.01);    \n    d2 = max(mask,d2);\n    d = min(d,d2);         \n    \n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    //diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.95)*skyDiff*occ;\n    diffCol += col*vec3(0.95)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.));\n    return col;\n}\n\nfloat bg (vec2 p){\n    vec2 prevP = p;\n    float d = 10.;\n    for(float i = 0.; i<5.; i++){\n        p*=Rot(radians(i*60.0+sin(i)*20.));\n        p = abs(p)-0.18;\n        p.y+=0.05;\n        float d2 = abs(pattern2(p*Rot(0.1*iTime*-(i+1.)),0.007))-0.001;\n        d = min(d,d2);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        float bd = bg(uv);\n        col = mix(col,vec3(0.5),S(bd,0.0));\n    }\n      \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dst3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 595, 595, 653], [655, 655, 677, 677, 1296], [1298, 1298, 1341, 1341, 1957], [1959, 1959, 1981, 1981, 2332], [2334, 2334, 2374, 2374, 2773], [2775, 2775, 2797, 2797, 4669], [4671, 4671, 4729, 4729, 4996], [4998, 4998, 5022, 5022, 5223], [5225, 5225, 5267, 5267, 5462], [5464, 5505, 5554, 5554, 5848], [5850, 5850, 5907, 5907, 6526], [6528, 6528, 6587, 6587, 6649], [6651, 6651, 6669, 6669, 6947], [6949, 6949, 7006, 7006, 7806]], "test": "untested"}
{"id": "md3GzH", "name": "A star is born", "author": "guil", "description": "Birth of a star.", "tags": ["star", "space"], "likes": 4, "viewed": 213, "published": 3, "date": "1676974097", "time_retrieved": "2024-07-30T18:09:04.191573", "image_code": "#define r(a)   mat2(cos(a+vec4(0,11,33,0)))          //\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float o,i=0.,s,g=1.,k=.04;\n    vec3 p,r,n,c;\n    for(; i++ < 120.; g += o*k )\n      { s = 1.;\n        r = iResolution, \n        n=r-r,\n        p = vec3( g* ( U - r.xy/2. ) / r.y, g-2. );        \n        p.yz*=r(3.5);\n        p.xz *= r(.1*iTime);\n        k *= 1.035;\n        c = p;\n        for( o = length(sin(.5*p))-.1 ; s<10.; s/=.6 )\n            p.xz *= r(1.),\n            n += .15*cos(p),\n            p = p*s+n.zxy,\n            o = min(o, length(n));\n        }        \n    c = clamp(c,-6.,0.);\n    c = .3 *(log(7.+ c));    \n    C = vec4(c,1);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3GzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 95, 95, 648]], "test": "untested"}
{"id": "dd33R8", "name": "2D Water Wave Test2", "author": "zyc", "description": "water wave noob test shader", "tags": ["2d", "test", "wave", "water"], "likes": 4, "viewed": 374, "published": 3, "date": "1676951986", "time_retrieved": "2024-07-30T18:09:05.146021", "image_code": "// Fork of \"2D Water Wave Test\" by Sleicreider. https://shadertoy.com/view/MsKXDh\n// 2023-02-21 03:56:30\n\n#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n            float time = iTime*2.0*PI;\n            \n            vec2 p = fragCoord/iResolution.xy;\n            vec2 w1 = p * 15. + time * 2.;\n            p += vec2(sin(w1.y), cos(w1.x))/iResolution.xy;\n            float w2 = (p.x + p.y)*15. + time * 2.;\n            p += vec2(sin(w2), cos(w2))/(iResolution.xy * vec2(0.16, 0.3) + 2. * sin(time));\n            \n            fragColor =  texture(iChannel0, p);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd33R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 186, 186, 596]], "test": "untested"}
{"id": "DscGRH", "name": "what the key", "author": "elenzil", "description": "Key-board util to find the key-code corresponding to a key-press.\nTop (blue) : Is key toggled ?\nMid (green) : Did key become pressed this frame ?\nBot (red) : Is key currently pressed ?", "tags": ["utility", "keyboard"], "likes": 7, "viewed": 218, "published": 3, "date": "1676941153", "time_retrieved": "2024-07-30T18:09:05.899008", "image_code": "float PrintInt(const in vec2 uv, const in float value);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float maxKeyCode = 200.0;\n    \n    ivec2 IJ = ivec2(fragCoord / iResolution.xy * maxKeyCode);\n    \n    vec3 keyState;\n    for (int n = 0; n < 3; ++n) {\n        keyState[n] = texelFetch(iChannel0, ivec2(IJ.x, n), 0).x;\n    }\n\n    vec3 rgb;\n\n    if (fragCoord.y > iResolution.y * 2.0 / 3.0) {\n        rgb[2] = keyState[2];\n    }\n    else if (fragCoord.y < iResolution.y * 1.0 / 3.0) {\n        rgb[0] = keyState[0];\n    }\n    else {\n        rgb[1] = keyState[1];\n    }\n\n    // draw number of smallest pressed keycode\n    for (float n = 0.0; n <= maxKeyCode; ++n) {\n        if (texelFetch(iChannel0, ivec2(n, 0), 0).x != 0.0) {\n            vec2 textP = fragCoord + vec2(-1.0, 1.0) * 20.0;\n            textP.y -= iResolution.y;\n            textP /= 100.0;\n            textP += 1.0;\n            rgb = mix(rgb, vec3(0.5, 0.6, 0.4), PrintInt(textP, n));\n            break;            \n        }\n    }\n\n    fragColor = vec4(rgb, 1.0);\n}\n\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{       \n    if(vUV.x  < 0.0) return 0.0;\n    if(vUV.y  < 0.0) return 0.0;\n    if(vUV.x >= 1.0) return 0.0;\n    if(vUV.y >= 1.0) return 0.0;\n    \n    float data = 0.0;\n    \n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(log2(value + 0.00001)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res; \n}\n// end of number-printing\n///////////////////////////////////////////////\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 114, 1052]], "test": "untested"}
{"id": "cdc3RH", "name": "Spinning Pulsing Lines", "author": "fishy", "description": "I wonder if it can be made smaller ", "tags": ["lines", "sin", "spinning"], "likes": 1, "viewed": 193, "published": 3, "date": "1676940933", "time_retrieved": "2024-07-30T18:09:06.715824", "image_code": "// I wonder if it can be made smaller \n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    c = sin(iTime*.3)*0.2+ // Pulsing\n    vec4(.9, .6, 1, 1)* // Color\n    sin(dot((p*2.-iResolution.xy)/iResolution.y*10., vec2(cos(iTime+vec2(0, 33))))); // Compute uv.x*cos(iTime) + uv.y*sin(iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdc3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 83, 83, 287]], "test": "untested"}
{"id": "Ddc3R8", "name": "Simple Sphere With Rays", "author": "sagefarrenholz", "description": "Simple sphere rendering using rays.", "tags": ["spheres", "learn"], "likes": 1, "viewed": 183, "published": 3, "date": "1676929959", "time_retrieved": "2024-07-30T18:09:07.748064", "image_code": "// Pi\n#define PI 3.14159256\n\n// FOV for both h and v\n#define FOV 135.\n\n// Near plane distance\n#define NP 10.\n\n// Sphere\n#define S_R 20.\n#define S_C vec3(15.,5.,40.)\n\n// Turn sensisitivity\n#define MOUSE_SEN 5\n\n// Point light loc\n#define LI vec3(5.,0.,35.)\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 dir;\n    vec3 nor;\n};\n\nHit sphereInter(vec3 ray_dir, vec3 cen, float rad) {\n    vec3 neg_cen = (-1.*cen);\n    \n    float inter = pow(dot(ray_dir, neg_cen),2.) - (dot(neg_cen,neg_cen) - pow(rad,2.));    \n    float tmp = -1.*(dot(ray_dir,neg_cen));\n    float sqr_inter = sqrt(inter);\n    float d = max(tmp - sqr_inter,tmp + sqr_inter);\n    vec3 nor = normalize(ray_dir - cen);\n    \n    return Hit(d >= 0., d, d*ray_dir, nor);\n}\n\nfloat diffuse(vec3 light, vec3 point, vec3 normal) {\n    vec3 light_dir = normalize(light - point);\n    return max(dot(normal, light_dir),0.);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - (iResolution.xy / 2.))/iResolution.y;\n    \n    // Normalized mouse coord\n    vec2 mv = iMouse.xy / iResolution.xy;\n     \n    // View plane coordinate\n    vec2 win = NP*tan(FOV/2.*PI/180.)*uv;\n        \n    // Unit ray direction\n    vec3 ray_dir = normalize(vec3(win,NP));\n    \n    Hit sphere_hit = sphereInter(ray_dir, S_C, S_R);\n    \n    float diff = 4.*diffuse(LI, sphere_hit.dir, sphere_hit.nor);\n    \n    vec3 light_dir = normalize(LI - sphere_hit.dir);\n    vec3 halfv = normalize(light_dir - sphere_hit.dir);\n    \n\n    // Specular lighting\n    float spec = .8*pow(dot(halfv, sphere_hit.nor),50.);\n\n    // Distance based illumination value\n    float illu = (diff + spec) / (.2*length(LI-sphere_hit.dir)) + 0.015;\n   \n    vec3 col = vec3(1.0);\n    col *= mix(vec3(0.0), vec3(0.0, 1.0, 1.0), illu);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddc3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 382, 382, 732], [734, 734, 786, 786, 878], [880, 880, 900, 900, 970], [972, 972, 1029, 1079, 1945]], "test": "untested"}
{"id": "cdt3Rn", "name": "Harmonic sine wave", "author": "trinketMage", "description": "Harmonic sine wave  with smoothstep", "tags": ["waves", "sine", "harmonic", "cineshader"], "likes": 13, "viewed": 2055, "published": 3, "date": "1676900237", "time_retrieved": "2024-07-30T18:09:08.511024", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 uv = fragCoord / iResolution.x;\n    uv.y *= 1.25;\n\tfloat time = iTime * 0.000628;\n    \n    vec3 params1 = vec3(\n        20.0,\n        100.0 + 12.5 * uv.y,\n        (0.0)\n    );\n        \n    vec3 params2 = vec3(\n        0.03125 - 0.03125 * uv.y,\n        0.125 - 0.0625 * -time + 0.0625 * uv.y,\n        0.0 \n    );\n        \n    vec3 params3 = vec3(\n        0.025 - 0.025 * uv.y * 4.,\n        0.125 - 0.0125 * -time + 0.25 * uv.y,\n        0.01\n    );\n        \n    vec3 params4 = vec3(\n        0.25 - 0.025 * uv.y * 2.,\n        1.125 - 0.125 * -time + 1.0 * uv.y,\n        1.0\n    );\n    \n    uv.y += params1.x * sin(uv.x / params1.y + time) + params1.z + params2.x * cos(uv.x / params2.y);\n    uv.y += params3.x * sin(uv.x / params3.y + time) + params3.z;\n    uv.y += params4.x * sin(uv.x / params4.y + time) + params4.z;\n\n    float ny = sin(mod(uv.y * 18., 1.0));\n    \n    float up = 1.0 - smoothstep(0.25, 1.0, ny);\n    float down = smoothstep(0.0, 0.2, ny);\n    \n    vec4 color = vec4(vec3(up * down), up * down * 0.3 - 6.75);\n    fragColor = color * 0.1 + 0.9;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Harmonic sine wave\",\n\t\"description\": \"Harmonic sine wave with smoothstep\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdt3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 1129]], "test": "untested"}
{"id": "mdc3zr", "name": "Amogus Hell", "author": "ronwnor", "description": "come on, get in.\nit's all amogus.\nyou'll enjoy.", "tags": ["math", "tiling", "amongus", "amogus"], "likes": 13, "viewed": 418, "published": 3, "date": "1676894093", "time_retrieved": "2024-07-30T18:09:09.421589", "image_code": "\nfloat sussy(float x, float y){\n    \n    float a = max(abs(abs(x) - 4.), abs(y + sign(x)*.5));\n    float b = max(abs(abs(x*2.) - 5.) - 2., abs(abs(y*2.) - 2.));\n    float c = max(abs(abs(abs(x*2.) - 5.) - 2.), abs(y*2. + sign(x)*4.));\n    \n    return min(min(a,b),c) - 1.;\n}\n\nfloat impostor(float x, float y){\n    \n    float a = mod(x + 2.*round(y*.2 - round((x*5. + y*2.)/66.)*.6) - 6., 12.) - 6.;\n    float b = mod(y - 3.*round((x*5. + y*2.)/66.) - 2.5, 5.) - 2.5;\n    \n    return -sussy(a, b);\n}\n\nvec3 among(vec2 z){\n\n    z = vec2( 6.*log(z.x*z.x + z.y*z.y), 10.5*atan(z.y, z.x)) - vec2(8,2)*iTime;\n    \n    float blur = 0.; \n        \n    for(float i=0.; i<.7; i+=.07){\n        blur += step(0., impostor(z.x - i,z.y - .25*i));\n        blur += step(0., impostor(z.x - i,z.y - .25*i - 11.))*.4;\n    }\n    \n    return vec3(blur*.1, .0, .2);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 us = (2.*fragCoord - iResolution.xy)/iResolution.y*15.;\n\n    fragColor = vec4(among(us) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdc3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 274], [276, 276, 309, 309, 498], [500, 500, 519, 519, 847], [849, 849, 906, 906, 1012]], "test": "untested"}
{"id": "md33zr", "name": "INFINITE AMOGUS TILING", "author": "ronwnor", "description": "they are everywhere\n\nman I love math", "tags": ["math", "tiling", "amongus", "amogus"], "likes": 12, "viewed": 459, "published": 3, "date": "1676892952", "time_retrieved": "2024-07-30T18:09:10.241398", "image_code": "\nvec3 sussy(vec3 x, vec3 y){\n    \n    vec3 a = max(abs(abs(x) - 4.), abs(y + sign(x)*.5));\n    vec3 b = max(abs(abs(x*2.) - 5.) - 2., abs(abs(y*2.) - 2.));\n    vec3 c = max(abs(abs(abs(x*2.) - 5.) - 2.), abs(y*2. + sign(x)*4.));\n    \n    return min(min(a,b),c) - 1.;\n}\n\nvec3 impostor(vec3 x, vec3 y){\n    \n    vec3 a = mod(x + 2.*round(y*.2 - round((x*5. + y*2.)/66.)*.6) - 6., 12.) - 6.;\n    vec3 b = mod(y - 3.*round((x*5. + y*2.)/66.) - 2.5, 5.) - 2.5;\n    \n    return -sussy(a, b);\n}\n\nvec3 among(vec2 z){\n    vec3 i = vec3(0,1,2);\n    return sign(impostor(z.x - i*4.,z.y - i)) + 1.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 us = (2.*fragCoord - iResolution.xy)/iResolution.y*15. + 2.*iTime;\n\n    fragColor = vec4(among(us) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md33zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 268], [270, 270, 300, 300, 487], [489, 489, 508, 508, 589], [591, 591, 648, 648, 765]], "test": "untested"}
{"id": "ms33zn", "name": "metamaterial tiling", "author": "FabriceNeyret2", "description": ".", "tags": ["tiling", "short", "metamaterial"], "likes": 36, "viewed": 321, "published": 3, "date": "1676888350", "time_retrieved": "2024-07-30T18:09:11.000368", "image_code": "float L(vec2 p, vec2 a,vec2 b) {            // --- draw line \n    p -= a, b -= a;\n    return length( p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n\nfloat t(vec2 U, vec2 A, vec2 B) {           // --- draw equilateral triangle\n    vec2 C = A + (B-A) *mat2(.5,-.867,.867,.5);                   \n    return min( L(U,A,B), min( L(U,B,C), L(U,C,A) )); \n}\n#define T(U,A,B) min( t(U,A,B), t( U+ vec2( H.x*sign(cos(a+1.05)) ,0 ),A,B) ) // tile wrap\n\n#define CS(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float a = 1.05*(1. + cos(iTime)),       // base angle of first triangle\n          b = 1.05 - a, w, h;               // base angle of second triangle (2pi/3 symmetry )\n    vec2  R = iResolution.xy,\n          U = 5.* ( u+u - R ) / R.y,\n          A = CS(a),\n          H = mat2(1,1.73,1.73,3) * A;      // 2-triangles tile size\n\n    U = mod(U, H);\n    U.y = abs(U-H/2.).y;                    // bi-tile = vertical symmetry         \n // w = A.x      + A.y*1.73;                // 2-triangles tile size \n // h = A.x*.867 + A.y*1.5; \n // U = mod(U, vec2(w,h+h));\n // U.y = abs(U.y-h);                       // bi-tile = vertical symmetry\n    \n    O = R.yyyy*.1* min( T( U, vec2(0) ,A ), // draw the 2 triangles\n                        T( U, A, A+CS(b)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms33zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 61, 150], [152, 152, 185, 228, 352], [480, 480, 518, 518, 1273]], "test": "untested"}
{"id": "msc3zn", "name": "Monorail 2", "author": "dr2", "description": "More monorails", "tags": ["truchet", "train", "monorail"], "likes": 24, "viewed": 316, "published": 3, "date": "1676886521", "time_retrieved": "2024-07-30T18:09:11.945841", "image_code": "// \"Monorail 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Another monorail with track based on generalized hexagonal Truchet tiles\n// (mouseable, multiple views).\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CAR 6   // any reasonable value\n#define PLEN 17\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, sunDir;\nvec2 cIdB, cIdS, cMidB, cMidS, blOff;\nfloat dstFar, tCur, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType, gHt, trSzFac,\n   flrGap, blRad, blHt, blCol;\nint idObj;\nbool blOcc, isTransS, vuHi;\nconst int idGrnd = 1, idRail = 2, idSup = 3, idBldg = 4, idMast = 5,  idWhl = 6, idCar = 7;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Forest Train Ride\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * sign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * sign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * sign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = sign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. || \n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n  return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= sign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - sign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = abs (SmoothMax (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.7, 0.1)) - 0.02;\n    d = max (d, - min (PrBox2Df (vec2 (q.x, q.y - 0.25), vec2 (0.4, 0.25)),\n       PrBox2Df (vec2 (abs (q.z) - 0.5, q.y - 0.25), vec2 (0.4, 0.25))));\n    DMINQ (idCar + k);\n    q.z = abs (q.z);\n    q.yz -= vec2 (1.19, 0.6);\n    d = max (max (PrCaps2Df (q.zy, 0.12, 0.9), max (abs (q.x) - 0.13, -0.5 - q.y)),\n       max (min (0.07 - abs (q.x), 0.4 - abs (q.y)), min (0.22 - abs (q.y - 0.7), 0.07 - q.x)));\n    DMINQ (idMast);\n    q.xy -= vec2 (0.02, 0.85);\n    d = PrCylDf (q.yzx, 0.11, 0.12);\n    DMINQ (idWhl);\n  }\n  return dMin * trSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / trSzFac;\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    d = max (PrRoundBox2Df (q.xz, vec2 (0.3, 1.1), 0.4), abs (q.y) - 0.6);\n    DMIN (0);\n  }\n  return dMin * trSzFac;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvoid SetBConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 b;\n  float dMin, d, dt, dWid, eWid, rc, ac, dh, a;\n  bool onTrk;\n  dWid = 0.2;\n  eWid = 0.1;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (q.xz);\n    dt = hgSizeB * abs (cm3.x);\n    rc = abs (cm3.y);\n    ac = 18. * cm3.z;\n    dh = hgSizeB * HexEdgeDist (q.xz);\n    onTrk = (cType <= 2. && rc != 0. && OnTrk (q.xz));\n    if (onTrk) {\n      a = (fract (3. * rc * ac + 0.5) - 0.5) / 3.;\n      d = PrRoundBox2Df (vec2 (dt, q.y - 0.4), vec2 (0.002, 0.01), 0.001);\n      DMIN (idRail);\n      if (cm3.y < 0.) {\n        b = vec2 (dt - 0.18, q.y - 0.4);\n        d = max (max (min (min (max (abs (b.x - 0.002) - 0.008, b.y), max (abs (b.y) - 0.006,\n           b.x - 0.01)), max (abs (dot (b, sign (0.25 * pi + vec2 (0.5 * pi, 0.))) + \n           0.05) - 0.005, Maxv2 (b))), abs (a) - 0.0013), - q.y - 0.03);\n        d = min (d, max (max (abs (b.x) - 0.02, abs (a) - 0.004), abs (q.y - 0.015) - 0.015));\n        DMIN (idSup);\n      }\n    }\n    d = SmoothMax (q.y - gHt, - max (min (abs (dh) - eWid, abs (dt) - dWid), gHt - 0.01 - q.y), 0.01);\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeB;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeB));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      SetBConf ();\n    }\n    d = BObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      SetBConf ();\n    }\n    h = BObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > hgSizeB) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvoid SetSConf ()\n{\n  vec2 u;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  u = Hashv2v2 (73. * cIdS + 1.1);\n  blRad = (sqrt3/2.) * hgSizeS * (0.2 + 0.25 * (u.x + u.y));\n  blHt = flrGap * floor (3. * blRad / flrGap);\n  blOff = ((sqrt3/2.) * hgSizeS * (0.5 + 0.3 * u.x) - blRad) * sin (2. * pi * u.y + vec2 (0.5 * pi, 0.));\n  blCol = fract (2.5 * u.x + 3.5 * u.y);\n}\n\nvoid SetSBConf ()\n{\n  vec2 s, u;\n  u = cMidS + blOff;\n  cIdB = PixToHex (u / hgSizeB);\n  SetBConf ();\n  s = (u - cMidB) / hgSizeB;\n  blOcc = (min (hgSizeB * abs (TruchSDist (s).x) - 0.9, hgSizeB * HexEdgeDist (s) - 0.5) > 0.);\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 u;\n  float dMin, d, rb, hb, r;\n  dMin = dstFar;\n  if (blOcc) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= blOff;\n    q.y -= gHt;\n    rb = blRad;\n    hb = blHt;\n    r = length (q.xz);\n    if (isTransS) q.xz = Rot2D (q.xz, pi / 12.);\n    u = Rot2D (q.xz, 2. * pi * (floor (12. * ((r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.)) + 0.5) / 12.);\n    if (isTransS) {\n      hb -= 0.02 * flrGap;\n      rb -= 0.01 * flrGap;\n      u.x += 0.95 * rb;\n      d = abs (u.x) - 0.01 * rb;\n    } else {\n      d = max (flrGap * (abs (fract (q.y / flrGap + 0.5) - 0.5) - 0.05), r - rb);\n      if (! vuHi) {\n        d = min (d, max (flrGap * (abs (fract (q.y / flrGap - 0.12 + 0.5) - 0.5) - 0.12),\n           max (abs (abs (r - 0.6 * rb) - 0.2 * rb) - 0.03 * rb, 0.05 * rb - abs (u.y))));\n        d = min (d, max (r - 0.95 * rb, q.y - flrGap));\n        u.x = abs (u.x + 0.8 * rb) - 0.18 * rb;\n      } else u.x += 0.98 * rb;\n      d = min (min (d, r - 0.07 * rb), length (u) - 0.02 * rb);\n    }\n    d = max (d, abs (q.y - hb) - hb);\n    DMINQ (idBldg);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, cIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSizeS;\n  pM = HexToPix (PixToHex (ro.xz / hgSizeS));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  cIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SetSConf ();\n    }\n    SetSBConf ();\n    d = SObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SetSConf ();\n    }\n    SetSBConf ();\n    if (blOcc) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.02 * d, h));\n      d += max (h, 0.01);\n    } else d += 0.2 * hgSizeS;\n    if (sh < 0.05 || d > hgSizeB) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  vec3 cm3;\n  float dt, rc, ac;\n  if (idObj == idRail || idObj == idSup) {\n    cm3 = TruchSDist ((ro.xz - cMidB) / hgSizeB);\n    dt = hgSizeB * abs (cm3.x);\n    rc = abs (cm3.y);\n    ac = 18. * cm3.z;\n  }\n  if (idObj == idBldg) {\n    col4 = vec4 (HsvToRgb (vec3 (blCol, 0.3, 0.7)), 0.);\n    if (vn.y < 0. && length (vec2 (length (qHit.xz) / blRad - 0.7, 0.05 * pi * (fract (24. *\n       atan (qHit.z, - qHit.x) / (2. * pi)) - 0.5))) < 0.04) col4 = vec4 (0.7, 0.7, 0.7, -1.);\n    else if (abs (vn.y) > 0.9 && length (qHit.xz) > 0.95 * blRad) col4 *= 0.5;\n  } else if (idObj == idRail) {\n    col4 = vec4 (0.6, 0.6, 0.65, 0.) * (0.5 + 0.5 * smoothstep (0., 0.001,\n         abs (fract (3. * rc * ac + 0.5) - 0.5) - 0.001));\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.7, 0.7, 0.75, 0.);\n    if (abs (dt - 0.183) < 0.01 && ro.y < 0.395 && ro.y > 0.03)\n       col4 *= 0.8 + 0.2 * step (0.1, abs (fract (128. * ro.y + 0.5) - 0.5));\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n  } else if (idObj >= idCar) {\n    col4 = vec4 (HsvToRgb (vec3 (float (idObj - idCar) / float (N_CAR), 0.8, 1.)), 0.2);\n    col4 = (qHit.y < 0.65) ? col4 : vec4 (0.8, 0.8, 0.85, 0.2) * (0.95 +\n       0.05 * step (0.1, abs (fract (8. * qHit.x + 0.5) - 0.5)));\n    if (max (PrRoundBox2Df (qHit.xz, vec2 (0.3, 1.1), 0.4), abs (qHit.y) - 0.7) < -0.01 ||\n       abs (qHit.y + 0.2) < 0.05) col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n    else if (length (vec2 (qHit.x, qHit.y + 0.4)) < 0.15) {\n      if (ShowInt (vec2 (qHit.x - 0.13 * sign (qHit.z), qHit.y + 0.46),\n         0.25 * vec2 (sign (qHit.z), 0.5), 2.,\n         float (idObj - idCar + 63)) != 0.) col4 = vec4 (vec3 (0.8), -1.);\n      else col4 *= 0.8;\n    }\n    if (abs (qHit.y) < 0.6 && abs (qHit.z) < 1.) col4 *= 0.5 + 0.5 * smoothstep (0., 0.001,\n       min (abs (abs (abs (qHit.z) - 0.5) - 0.5) - 0.03, abs (abs (qHit.y) - 0.6) - 0.015));\n  }\n  return col4;\n}\n\nvec4 GroundCol (vec3 p, inout vec2 vf)\n{\n  vec4 col4, gCol;\n  vec3 cm3;\n  vec2 w;\n  float dt, rc, ac;\n  gCol = vec4 (0.3, 0.4, 0.3, 0.05);\n  if (p.y < 0.022) {\n    col4 = mix (vec4 (0.5, 0.55, 0.5, 0.), gCol, smoothstep (0., 0.2,\n       abs (Rot2D (p.xz, pi / 3.).x) / (5. * hgSizeB) - 1.));\n    vf = vec2 (64., 1.);\n  } else {\n    col4 = gCol * (0.7 + 0.3 * Fbm2 (0.5 * p.xz));\n    vf = vec2 (32., 2.);\n  }\n  w = (p.xz - cMidB) / hgSizeB;\n  cm3 = TruchSDist (w);\n  dt = hgSizeB * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * cm3.z;\n  if (cType <= 2. && rc != 0. && OnTrk (w)) {\n    if (dt < 0.025 && step (0.3, abs (fract (16. * rc * ac + 0.5) - 0.5)) > 0.)\n       col4 = vec4 (0.5, 0.5, 0.4, 0.);\n  }\n  return col4;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  if (rd.y > 0.) col = mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n  else col = vec3 (0.4, 0.4, 0.5);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR, vn, rs, roo, rdr;\n  vec2 vf, g;\n  float dstObj, dstObjB, dstObjS, dstTrObj, dstTrObjS, sh;\n  int idObjB, idObjS, idObjT;\n  bool isLit;\n  flrGap = 1./6.;\n  vf = vec2 (0.);\n  roo = ro;\n  isTransS = false;\n  dstObjB = BObjRay (ro, rd);\n  idObjB = idObj;\n  dstObjS = SObjRay (ro, rd);\n  idObjS = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObjB, dstObjS) < dstObj) {\n    if (dstObjB < dstObjS) {\n      dstObj = dstObjB;\n      idObj = idObjB;\n    } else {\n      dstObj = dstObjS;\n      idObj = idObjS;\n    }\n  }\n  isLit = false;\n  idObjT = idObj;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      SetBConf ();\n      vn = BObjNf (ro);\n    } else if (dstObj == dstObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SetSConf ();\n      SetSBConf ();\n      vn = SObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    col4 = (idObj == idGrnd) ? GroundCol (ro, vf) : ObjCol (ro, vn);\n    if (col4.a >= 0.) {\n      rs = ro + 0.01 * vn;\n      sh = min (ObjSShadow (rs, sunDir), BObjSShadow (rs, sunDir));\n      if (idObjT != idBldg) sh = min (sh, SObjSShadow (rs, sunDir));\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else {\n      col = col4.rgb * (0.3 + 0.7 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    vn = vec3 (0., 1., 0.);\n    col4 = 0.7 * vec4 (0.3, 0.4, 0.3, 0.);\n    sh = 1.;\n    isLit = true;\n  } else {\n    col = BgCol (rd);\n  }\n  if (isLit) {\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (sunDir, vn), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    col = mix (col, BgCol (rd), 1. - exp (min (0., 1. - 5. * dstObj / dstFar)));\n  }\n  dstTrObj = TrObjRay (roo, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    vn = TrObjNf (roo + dstTrObj * rd);\n    col = mix (0.9 * col, BgCol (reflect (rd, vn)), 0.1);\n  }\n  isTransS = true;\n  dstTrObjS = SObjRay (roo, rd);\n  if (dstTrObjS < min (dstObj, dstFar)) {\n    if (! vuHi) {\n      ro = roo + dstTrObjS * rd;\n      vn = SObjNf (ro);\n      rdr = reflect (rd, vn);\n      g = Rot2D (rdr.xz, 5.1 * atan (20. + cIdS.y, 20. + cIdS.x));\n      colR = (ro.y + 2. * hgSizeS * rdr.y + 0.1 * floor (8. * IFbm1 (0.2 * (atan (g.y, g.x) + pi))) >\n         12. * flrGap) ? BgCol (rdr) : vec3 (0.3);\n      col = mix (0.8 * col, colR, 0.5 + 0.5 * pow (1. + dot (rd, vn), 4.));\n    } else col *= 0.6;\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd, pAv;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, t, cGap, nc;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  hgSizeB = 8.;\n  hgSizeS = 1.;\n  gHt = 0.03;\n  SetPath ();\n  trSzFac = 0.1;\n  trVel = 0.2;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az -= 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  cGap = 0.3;\n  tCur += 5.;\n  pAv = vec3 (0.);\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = tCur * trVel - float (k) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * 0.06 : 0.));\n    vd.xz = pc[2] - pc[1];\n    carPos[k].xzyw = vec4 (pc[0], 0.22, 0.5 * pi - atan (vd.z, vd.x));\n    pAv += carPos[k].xyz;\n  }\n  nc = float (N_CAR);\n  pAv /= nc;\n  t = tCur * trVel;\n  if (vuId == 0 || vuId == 2) {\n    if (uv.y > 1. - 2. * SmoothBump (0.25, 0.75, 0.01, fract (0.025 * tCur))) vuId = 2 - vuId;\n    ro.xz = EvalPPos (t - ((vuId == 0) ? nc + 1. : -2.) * cGap);\n    ro.x += 0.1;\n    ro.y = (vuId == 0) ? 0.65 : 0.15;\n    vd = normalize (pAv - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    el = clamp (el, -0.15 * pi, 0.25 * pi);\n    zmFac = 3.;\n    dstFar = 12. * hgSizeB;\n    vuHi = false;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x -= 1.5 * hgSizeB;\n    vd = normalize (pAv - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = max (20. + 50. * msw.y, 2.5);\n    dstFar = 30. * hgSizeB;\n    vuHi = true;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (-2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.6, 0.6, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msc3zn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1659, 1659, 1680, 1680, 1703], [1705, 1705, 1731, 1761, 2745], [2747, 2747, 2768, 2768, 3412], [3414, 3414, 3431, 3431, 4276], [4278, 4278, 4303, 4303, 4955], [4957, 4957, 4979, 4979, 5796], [5798, 5798, 5831, 5831, 6014], [6016, 6016, 6037, 6037, 6294], [6296, 6296, 6320, 6320, 6615], [6617, 6617, 6652, 6652, 6836], [6838, 6838, 6861, 6861, 7120], [7122, 7122, 7159, 7159, 7402], [7404, 7404, 7422, 7422, 8131], [8133, 8133, 8156, 8156, 9311], [9313, 9313, 9347, 9347, 10595], [10597, 10597, 10619, 10619, 10877], [10879, 10879, 10917, 10917, 11337], [11339, 11339, 11357, 11357, 11696], [11698, 11698, 11717, 11717, 11926], [11928, 11928, 11951, 11951, 13037], [13039, 13039, 13073, 13073, 14339], [14341, 14341, 14363, 14363, 14621], [14623, 14623, 14661, 14661, 15153], [15155, 15155, 15187, 15187, 17179], [17181, 17181, 17221, 17221, 17901], [17903, 17903, 17925, 17925, 18142], [18144, 18144, 18179, 18179, 20738], [20758, 20758, 20814, 20814, 24152], [24154, 24154, 24187, 24187, 24276], [24278, 24278, 24325, 24325, 24372], [24374, 24374, 24416, 24416, 24467], [24469, 24469, 24513, 24513, 24573], [24575, 24575, 24599, 24599, 24829], [24831, 24831, 24855, 24855, 24915], [24917, 24917, 24945, 24945, 25025], [25027, 25027, 25049, 25049, 25076], [25078, 25078, 25100, 25100, 25127], [25129, 25129, 25151, 25151, 25189], [25191, 25191, 25213, 25213, 25251], [25253, 25253, 25298, 25298, 25390], [25392, 25392, 25437, 25437, 25475], [25477, 25477, 25534, 25534, 25617], [25619, 25619, 25643, 25643, 25765], [25767, 25767, 25803, 25803, 26009], [26011, 26011, 26041, 26041, 26154], [26156, 26156, 26187, 26187, 26251], [26253, 26253, 26276, 26276, 26380], [26453, 26453, 26485, 26485, 27033], [27035, 27035, 27095, 27095, 27637], [27671, 27671, 27695, 27695, 27755], [27757, 27757, 27781, 27781, 27834], [27836, 27836, 27860, 27860, 27972], [27974, 27974, 27998, 27998, 28141], [28143, 28143, 28168, 28168, 28314], [28316, 28316, 28341, 28341, 28527], [28529, 28529, 28552, 28552, 28716], [28718, 28718, 28739, 28739, 28894], [28896, 28896, 28925, 28925, 29137], [29139, 29139, 29178, 29178, 29430]], "test": "untested"}
{"id": "mdc3Rn", "name": "Sediment", "author": "wyatt", "description": "Sped up is best", "tags": ["fluid"], "likes": 41, "viewed": 560, "published": 3, "date": "1676881332", "time_retrieved": "2024-07-30T18:09:12.719771", "image_code": "Main {\n    Q = A(U).wwww;\n    vec4 c = C(U);\n    \n    Q= (.5+.5*sin(c.w*100.+vec4(1,2,3,4)))*\n    smoothstep(1.5,0.,length(U-c.xy)-c.w);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage(out vec4 Q,vec2 U)\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    Q.xy -= .5*vec2(e.z-w.z,n.z-s.z);\n    Q.z = clamp(Q.z,-1.,1.);\n    //if (length(U-vec2(.1,.5)*R)<20.)\n    //    Q.xy *= 0.;\n    vec4 c = C(U);\n    if(length(U-c.xy)<c.w) \n        Q.xy *= 1.-.1*pow(c.z,10.);\n    if (iFrame < 1||U.x<1.||R.x-U.x<1.||R.y-U.y<1.||U.y<1.)\n        Q = vec4(.3,0,Q.z,.5+.5*sign(sin(.1*U.y)));\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 T (vec2 U) {\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    return A(U);\n}\nMain {\n    Q = T(U);\n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    Q.z -= .5*(e.x-w.x+n.y-s.y);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = C(U);\n    for (float x = -1.; x <= 1.; x++)\n    for (float y = -1.; y <= 1.; y++)\n    {\n        vec4 c = C(U+vec2(x,y));\n        if (length(U-c.xy)<length(U-Q.xy))\n            Q = c;\n    }\n    \n    Q.xy += A(Q.xy).xy;\n    if (iFrame < 1||U.x<1.) {\n        float x = hash33(vec3(U,iFrame)).x;\n        Q = vec4(floor(U/10.)*10.,x,5.*pow(x,10.));\n      }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdc3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ms3Gzn", "name": "Arabesque knots 2", "author": "jarble", "description": "An arabesque knot pattern.", "tags": ["fractal", "music", "arabesque"], "likes": 4, "viewed": 202, "published": 3, "date": "1676880844", "time_retrieved": "2024-07-30T18:09:13.481735", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 5; k++){\n        uv =\n            2.*abs(.5+uv+t2)/1.5\n        ;  \n        //uv += floor(uv*2.); //another interesting pattern\n        //uv += floor(uv*2.)+floor(uv*1.5); //another interesting pattern\n        //uv += floor(uv*2.)*floor(uv*1.5); //another interesting pattern\n        bool b = uv.y>uv.x;\n        if(b)\n            uv = uv.yx\n            //uv = uv.yx+floor(uv.x*2.)\n        ;\n        //else k += 1;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        //t2.y += floor(uv.y/1.5); //another interesting pattern\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        //if(b||t2.y<t2.x)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n            //abs(vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),-col.y)))\n        ;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    a /= (1. + floor(mod(a*4.,2.)))*4.;\n    return mod(floor(a),b);\n}\n\nvec2 mainSound(int samp, float t){\n  float p1 = 1. + floor(mod(mod(t,1.+t/4.)/2.,2.));\n  t *= p1/2.;\n  float s1 = 8.;\n  float a=\n      pow((1.-sqrt(fract(t*p1))),2.)\n  ,\n  nb = t*pow(2.,(2.+fmod(t*2.,s1)+1. + fmod(floor(t/s1),2.))/5.+7.)/p1;\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3Gzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1361]], "test": "untested"}
{"id": "dd3GRn", "name": "Zellij pattern (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "zellige"], "likes": 12, "viewed": 423, "published": 3, "date": "1676876661", "time_retrieved": "2024-07-30T18:09:14.238710", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a)*fract(fract(a)*fract(a))\n        //abs(fract(a*2.+.5)/2.+fract(a+.5)/2.)\n\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a-fract(a*4.)/2.)\n        //min(abs(fract(a)-.5),abs(fract(a*2.)-.5))\n        //fract(a-.5+mod(floor(a.x*2.),2.)/2.)\n        //abs(fract(a)-fract(-a/2.)/2.)\n        //abs(fract(a)-abs(.5-fract(a)))\n    ;\n}\n\nvec2 triangle_wave1(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.-sign(a.x)/2.,0.5+sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //sqrt(abs(f1((a1)*(a2.x+a2.y))-.5))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    return\n        triangle_wave1(a)\n        //(triangle_wave1(a.yx)+triangle_wave1(a))/2.\n        //triangle_wave1(a-triangle_wave1(a+.5)/1.5)\n        //triangle_wave1(a+.5*floor(a.x))\n    ;\n}\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\n#define triwave(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave((.5 - length( min(p=fract(p*sign(triwave1(c*c.y))), 1.-p.yx) )));\n}\n\nvec3 fractal(vec2 uv,vec2 t2){\n    vec3 col = vec3(0.);\n    bool b = uv.y>uv.x;\n    for(int k = 0; k < 6; k++){\n        \n        //WOW!\n        //uv = (uv*1.5)-.5;\n        \n        \n        //uv.x += t1_(uv,floor(uv))*3.;\n        //uv.y += .25*sign(uv.x-uv.y);\n\n        \n        //if((k) % 3 == 0) uv *= 1.5;\n        //if(uv.x<uv.y && k%5 == 0) {uv = -uv;}\n    \n        //uv.x += float(int(uv.x*2.)<<2)/8.;\n        //k += int(uv.y>uv.x);\n\n        //if(uv.y>0.) uv.x += .5;\n        //else uv.y += .5;\n        //if((k) % 3 == 0 && abs(t2.x)<abs(t2.y)) uv *= 1.5;\n        \n        //uv += binary_digit(k+1,2)/2.;\n        \n        //if(uv.y>uv.x)\n        uv =\n            abs(.5+uv+t2)/1.5\n            //-sign(uv/1.5-t2)-abs(.5+uv/1.5+t2)\n            //abs(max(uv.yx,t2)+t2)\n            //abs(.5+abs(uv)/1.5-t2)\n            //abs(.5+uv+max(t2,uv/1.5))/1.5\n            //abs(.5+max(uv/1.5,t2)+t2)\n            //abs(.5+uv+max(1.-t2/2.,1.-uv/4.))/1.5\n            //abs(.5+uv+t2/1.5)\n            //abs(.5+uv/1.5+t2)\n            //abs(.5*sign(uv.y-uv.x)+uv+t2)/1.5\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))/1.5\n            //(uv+t2)/1.5\n            //abs(.5+uv*mod(floor(-uv.x*4.),2.)+t2)/1.5\n        ;\n        \n        //uv.x -= .5;\n        //uv += sign(uv-uv.yx)/2.+.5;\n        //if(t2.y<t2.x)\n        b =\n            uv.y>uv.x\n            //uv.y>uv.x+float(t2.y<t2.x)\n            //uv.y>uv.x || b\n        ;\n        if(\n            b\n            //uv.y<uv.x && t2.x > t2.y\n            //uv.y>uv.x || t2.x < t2.y\n        ) uv = uv.yx;\n        //else k += 1;\n\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5*sign(uv.x-.5)-sign(t2.x-.5))\n            //-triangle_wave(uv-.5)*sign(.5-uv.x)\n        ;\n        //if(t2.y>t2.x) t2 = t2.yx;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2+triangle_wave(uv.yx-floor(.5+t2.y+t2.x))\n        ;\n        \n        //uv += (uv-ceil(uv));\n        //if(t2.y<uv.x)\n        \n        //if(t2.y>t2.x) t2 -= .5;\n        if(\n            true\n            //uv.y<-.5 || uv.x<-.5\n            //uv.y<-.5 && uv.x<-.5\n            //uv.x<-.5\n            //uv.x<-.5\n        )\n        {t2 =\n            t2.yx\n            //t2.yx*(1.+mod(floor(uv.y),2.)/2.)\n        ;\n        uv=uv.yx;}\n        vec2 uv1 =\n            //triangle_wave(uv)-triangle_wave(uv.yx-.5)\n            uv\n        ;\n        \n        //if(b||uv.y<uv.x)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n            //vec3(col.zx,max(uv.y-uv.x,col.y))\n        ;\n        //if(uv.x < -.5) uv.x += .5;\n        //if(uv.y < -.5) uv.y += .5;\n        //if(uv.x<uv.y) uv.y -= .5;\n        //uv.y += float(uv.x<uv.y);\n        }\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    //if(iMouse.z>.5)\n    //uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    vec3 col = fractal(uv,t2);\n    for(int i = 0; i < 1; i++){\n        col = abs(fractal(uv,t2));\n        //uv *= 2.;\n    }\n    \n    \n\n        \n\n        //if(uv.x<uv.y && k%2 == 0) {uv = -uv;break;}\n\n        //if(uv.x>uv.y) col=col.yzx;\n        //uv /= 1.+mod(uv.y,2.);\n        //if(uv.x>t2.x-.25) uv.x /= 1.5;\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod2(float a, float b){\n    return\n        //b*max(mod(floor(a),b),mod(floor(a*2.),b))\n        b*mod(floor(a),b)\n    ;\n}\n\nfloat m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a/4.-mod(a/2.,b),b)\n        //mod(a+floor(a/4.),b)\n    ;\n}\n\nfloat fmod1(float a, float b){\n    //a += m1(a,3.,7.);\n    //a += mod(-a/2.,2.);\n    //a -= floor(a/8.)/8.;\n    /*\n    for(int i = 0; i < 1+int(mod(a/8.,8.)); i++){\n        a /= (1. + floor(mod(a*2.,2.)));\n    }\n    */\n    \n    //a += floor(a*pow(2.,b)/128.);\n    a /= (1. + floor(mod1(a*8.,2.)))/4.;\n    //a += fmod2(a,7.);\n    //a += pow(2.,mod(floor(a),8.));\n\n    //a /= 2.;\n    /*\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    /*\n    for(float a2 = 16.; a2 < 128.; a2 *= 2.){\n        a += mod(floor(a/a2),2.);\n    }\n    */\n    //a += mod(b/2.,2.);\n    return\n        mod(floor(a),b)\n        //floor(mod(floor(floor(a)/2.)+floor(floor(a)/2.)*2.,b))\n        //mod(floor(a)*5.,b+mod(floor(a)*3.,b))\n        //mod(floor(a/pow(2.,mod(floor(a/b),3.))),b)\n        //floor(mod(mod(floor(a),(b*8./3.)),b))\n        //mod(floor(a),b+mod(floor(a*2.),b))\n        //mod(mod(13.+floor(a*b/8.),19.+floor(a*b)),b)\n        //mod(mod(floor(a/2.+4.),floor(a/8.+4.)),b)\n        //floor(mod(a/2.,b)-mod(-a/2.,b/2.))\n        //mod(floor(a+mod(a/8.*b,8.)),b)\n        //max(mod(floor(a/b),b),mod(floor(a),b*2.))\n        //mod(floor(a+mod(floor(a/8.*b),b)),b)\n        //max(mod(floor(a*8./b),b),mod(floor(a/b),b))\n        //mod(floor(a*b/8.),(b/2.))*mod(floor(a/b)*floor(a*b/8.),b/2.)\n        //mod(mod(floor(a),b)*mod(floor(a/b),b),b)\n        //floor(mod(floor(a*2.),8.-b)/b/8.)\n\n        //mod(floor(a+pow(2.,b*mod(floor(a*2.),2.))),b)\n        //mod(floor(a/pow(2.,mod(floor(a*2.),3.)-1.)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(a+fmod1(a/2.,b),b)\n    ;\n}\n\nfloat fract1(float a){\n    return\n        fract(a)\n        //fract(a)*fract(fract(a)*fract(a))\n        //fract(a)*fract(a)\n        //fract(4.*a/(1.+fmod(a*4.,2.)))\n        //fract(a+fract(a*2.)/2.)\n    ;\n}\n\nvec2 song(float t,float scale){\n  float tempo = 1.;\n  t /= tempo;\n  float s1 =\n      8.\n      //pow(2.,2.+fmod(t/8./2.,3.))\n  ;\n  float p1 = 1. + floor(mod((1.+t/4.)/2.,2.));\n  t *= p1/2.;\n  //t /= pow(2.,fmod(t/2.,2.));\n  //t += pow(2.,mod(floor(t*2.),2.));\n  //t += pow(2.,mod(floor(t*4.),2.));\n  //t += pow(2.,mod(floor(t*8.),2.));\n  //t += floor(t*pow(2.,fmod(t/4.,4.)))/pow(2.,fmod(t/4.,4.));\n  \n  float a=\n      //64.*pow((1.-(fract(t*p1))),2.)\n      4.*pow(2.,fract1(-t*p1))\n      //2.*pow(log(fract(t*p1)/4.),2.)\n      //pow(2.,log(fract(-t*p1)/2.))*64.\n  ,\n  nb =\n      t*tempo*pow(2.,(2.+fmod(t,s1)+1. + fmod(floor(t/s1),2.))/5.+scale)/p1\n      //t*pow(2.,1.-log(fract(t)))\n      //.5*t*tempo*pow(2.,(2.+fmod(t/s1,s1/2.)+fmod(t,s1)+2.)/5.+8.)/p1\n  ;\n  return\n      vec2(a,nb)\n  ;\n}\n\nvec2 mainSound1(int samp, float t,float scale){\n  vec2 s =\n      //max(song(t),song(t/4.))\n      song(t,scale)\n      //min(song(t/2.)*2.,song(t))\n   ;\n  \n  float a=\n      s.x\n  ,\n  nb =\n      s.y;\n  return\n      //(abs(.5-abs(vec2(fract1(nb/2.),fract1(nb)))))*a\n      \n      log(abs(a/8.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a))\n      \n      //abs(vec2(sin(nb*.998*4.),sin(nb*2.)))*a*16.\n  ;\n}\n\nvec2 mainSound(int a,float b){\n    return mainSound1(a,b,7.);\n    //return (mainSound1(a,b,7.5)+mainSound1(a,b*2.,6.5));\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3GRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 451], [453, 453, 481, 481, 711], [713, 713, 740, 740, 934], [936, 936, 969, 969, 1003], [1118, 1118, 1144, 1144, 1231], [1233, 1233, 1263, 1263, 3934], [3936, 3936, 3991, 3991, 4679]], "test": "untested"}
{"id": "md3GRn", "name": "Watershed", "author": "wyatt", "description": "fluid", "tags": ["fluid"], "likes": 20, "viewed": 347, "published": 3, "date": "1676875725", "time_retrieved": "2024-07-30T18:09:15.085446", "image_code": "// Fork of \"Liquid Disco\" by wyatt. https://shadertoy.com/view/Dt2XWK\n// 2023-02-20 06:14:33\n\nMain \n{\n    vec4 f = A(U);\n    Q = f.wwww*(sin(-1.1+6.2*f.z+vec4(1,2,3,4)));\n    \n    vec4 n = B(U+vec2(0,1));\n    vec4 e = B(U+vec2(1,0));\n    vec4 s = B(U-vec2(0,1));\n    vec4 w = B(U-vec2(1,0));\n    Q.xyz = .5+.5*normalize(vec3(e.x-w.x,n.x-s.x,1)).zzz;\n    Q *= .5+.5*sin(.1*B(U).x+vec4(1,2,3,4));\n    Q.w = 1.;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat erf(in float x) {\n    x *= .8;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "buffer_a_code": "Main\n{\n    vec4 dQ = Q = vec4(0);\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    Q.xy *= .95;\n    Q.w += 4e-4;\n    Q.w *= .999;\n    Q.w = min(Q.w,2.);\n    if (U.x < 1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.w = 0.;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.w = 1.;\n    if (iFrame < 1) {Q = vec4(0,0,0,.5+.01*sin(3.1*U.x)+.01*sin(3.1*U.y));}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = sqrt(a.w)+b.x;\n        dQ.xy -= .5*f*u/dot(u,u);\n    }\n    Q += dQ;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    vec4 a = A(U);\n    Q = B(U);\n    Q.x -= 2e-2*min(length(a.xy)*sqrt(a.w),1.);\n    Q.x += 1e-3;\n    \n    if (iFrame < 100)\n        Q.x = C(U).x+20.*(1.-length(U-.5*R)/R.x);\n\n}", "buffer_c_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3GRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ctjXzd", "name": "realtime water caustics point", "author": "lanx06", "description": "water surface https://www.shadertoy.com/view/MdXyzX\ncaustics https://alltd.org/realtime-caustics-in-touchdesigner-with-easy-glsl/", "tags": ["water", "caustics"], "likes": 6, "viewed": 136, "published": 3, "date": "1676873708", "time_retrieved": "2024-07-30T18:09:15.857382", "image_code": "#define fc fragCoord\n#define ir iResolution.xy\n#define iter 20\n#define SIZE 7\n//#define N 10\n#define N int(iResolution.y/1.5)\n#define T iTime*0.2\nvec2 stdNormalMap(vec2  uv) \n{\n    float h =texture(iChannel0, uv).r;\n    return -vec2(dFdx(h), dFdy(h)); \n}\nvec3 normalPlane(vec2 uv){\n    \n    vec3 normalMap;\n    const int textureOffset =1;\n    //uv*=1.2;\n    uv*=0.5+ length(iMouse.xy / ir)*1.5;\n    \n    float p =getwaves(uv,iter,T);\n    float h1=getwaves(uv +  vec2(textureOffset,0)/ir,iter,T);\n    float v1=getwaves(uv +  vec2(0,textureOffset)/ir,iter,T);\n   \tnormalMap.xy= (p - vec2(h1, v1))*100.0;\n    //normalMap.xy=-vec2(dFdx(p), dFdy())*10.0; \n    normalMap+=0.5;\n    normalMap.z=1.0;\n    vec3 normal;\n    mat3 TBN=mat3(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1));\n    \n    //normal=(TBN*normalMap)*2.0-1.0;\n    //normal=normalize(normal);\n    normal=normalMap;\n    return normal;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 lightdir=\n    vec2(0.5,0.5);\n    //(iMouse.xy / ir.xy)-0.5;\n    float row=iResolution.x/float(N);\n    vec3 col ;\n \n    \n    vec2 block=vec2( floor(fc/vec2(row)) );\n    if(uv.x<0.5 && uv.y>0.5)\n        col=normalPlane(uv);\n    if(uv.x<0.5)\n        col=normalPlane(uv);\n    else \n        for(int i=0;i<SIZE*SIZE;i++){\n                vec2 id=vec2(i%SIZE , i/SIZE )+vec2(-SIZE/2)\n                //+block;\n                ;vec2 simaplepos=(id+vec2(0.5))*row\n                +fc;\n                ;\n                //pos+=(random(id)-vec2(0.5))*v*row*float(SIZE)*0.5;\n                float pix=0.5;\n                float radius=0.5;\n                vec3 normal=normalPlane(simaplepos/ir);\n                \n                vec2 offset=refract(vec3(lightdir,-0.707),normal,1.0/1.3).xy;\n                float len=row*float(SIZE)*0.7;\n                vec2 midpos=simaplepos+offset*len;\n                \n                //vec2 dis=();\n                float l=length((fc-midpos)/row);\n                vec2 lo=normalize(offset)*len*0.2;\n                float ldis=line_segment(fc,midpos-lo,midpos+lo)/row*1.0;\n                float tem=dot((fc-midpos),normalize(offset))/pow(length(lo)+(pix+radius)*row,1.0);\n                vec3 color=\n                //spectral_bruton((tem+1.5)*0.4);\n                //spectral_bruton((tem+1.0)*0.5);\n                //spectral_jet((tem+.8)*0.5);\n                spectral_jet((tem+1.0)*.5);\n                \n                color=rgb2hsv(color);\n                color.y=pow(l,2.0);\n                //l*0.9;\n                color=hsv2rgb(color);\n                color.g*=0.7;\n                col+=(smoothstep(radius+pix,radius-pix,ldis))/float(SIZE)*1.0\n                \n                //*(tem+1.0)*0.5;\n                //*abs(tem);\n                *color;\n                //col.xy+=pos/ir*smoothstep(radius+pix,radius-pix,dis);\n                //col+=normal *smoothstep(radius+pix,radius-pix,dis);\n            }\n    \n    \n    //col.xy=block/float(N);;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations,float t){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    #define DRAG_MULT 0.048\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, t);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}float line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\nvec3 spectral_bruton (float w)\n{\n    //remap 0to 1->380 780\n    w=mix(400.0,800.0,w);\n\tvec3 c;\n\n\tif (w >= 380. && w < 440.)\n\t\tc = vec3\n\t\t(\n\t\t\t-(w - 440.) / (440. - 380.),\n\t\t\t0.0,\n\t\t\t1.0\n\t\t);\n\telse if (w >= 440. && w < 490.)\n\t\tc = vec3\n\t\t(\n\t\t\t0.0,\n\t\t\t(w - 440.) / (490. - 440.),\n\t\t\t1.0\n\t\t);\n\telse if (w >= 490. && w < 510.)\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t1.0,\n\t\t\t-(w - 510.) / (510. - 490.)\n\t\t);\n\telse if (w >= 510. && w < 580.)\n\t\tc = vec3\n\t\t(\n\t\t\t(w - 510.) / (580. - 510.),\n\t\t\t1.0,\n\t\t\t0.0\n\t\t);\n\telse if (w >= 580. && w < 645.)\n\t\tc = vec3\n\t\t(\n\t\t\t1.0,\n\t\t\t-(w - 645.) / (645. - 580.),\n\t\t\t0.0\n\t\t);\n\telse if (w >= 645. && w <= 780.)\n\t\tc = vec3\n\t\t(\t1.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\telse\n\t\tc = vec3\n\t\t(\t0.0,\n\t\t\t0.0,\n\t\t\t0.0\n\t\t);\n\n\treturn saturate(c);\n}\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = w;\n    //saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 176, 176, 254], [255, 255, 281, 281, 882], [883, 883, 940, 940, 2999]], "test": "untested"}
{"id": "DscGRr", "name": "Simple Smooth Circle", "author": "JamesR48", "description": "Learning to make circles!!", "tags": ["sdf", "circle"], "likes": 0, "viewed": 140, "published": 3, "date": "1676854167", "time_retrieved": "2024-07-30T18:09:16.720075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 Center = vec2(0.5);\n    uv -= Center; // Remap the UV to be -0.5 to 0.5\n    \n    float AspectRatio = iResolution.x/iResolution.y;\n    uv.x *= AspectRatio; // Compensate the UVx since the viewport is wider\n    \n    float DistToCenter = length(uv);\n    float Radius = 0.45;\n    vec3 WhiteCircle = vec3(smoothstep(Radius,Radius-0.01, DistToCenter));\n    col *= WhiteCircle;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 679]], "test": "untested"}
{"id": "cll3zr", "name": "Circling hearts", "author": "maksy", "description": "Studying polar coordinates.\n\nResources:\n\nMaking A Heart in ShaderToy:\nhttps://www.youtube.com/watch?v=dXyPOLf2MbU\n\nUsing Polar Coordinates to create art:\nhttps://www.youtube.com/watch?v=r1UOB8NVE8I", "tags": ["heart", "polarcoordinates"], "likes": 1, "viewed": 132, "published": 3, "date": "1676836552", "time_retrieved": "2024-07-30T18:09:17.499990", "image_code": "#define BLACK vec3(0.0)\n#define RED vec3(1.0, 0.01, 0.01)\n\n// Polynomial smooth max from IQ.\nfloat smax(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\t\n    return mix(a, b, h) + k*h*(1.0-h);\n}\n\nfloat Heart(vec2 uv, float b)\n{\n\t// Widen the heart by stretching the underlying coordinates.\n    uv.x *= .8;\n\n    // Smooth max removes the sharp edge in the middle of the heart. \n    uv.y -= smax(sqrt(abs(uv.x)), b, 0.3*b)*.3;\n    \n    return smoothstep(b, -b, length(uv)-0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    // Make the circle of hearts wavy.\n    float t = uv.x*7.0 - 0.8*iTime + uv.x*1.1;\n    uv.y -= sin(t)*0.07;\n    \n    // Polar coordinates\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));    \n    \n    // st.x: transform -PI to PI into 0 to 1.\n    // Make it twisting and rotating by adding iTime and st.y.\n    uv = vec2(st.x / 6.28 + .5 + 2.5 * st.y * sin(iTime*0.2), st.y);\n    uv *= vec2(3.0, 1.2);\n    \n    float d = 0.0;\n    \n    // X goes outside of the visible x-axis since adding iTime and twisting stuff \n    // to the polar coordinates makes the non-visible hearts appear.\n    for (float x = -2.8; x < 5.8; x += 0.30) {\n        d += Heart(uv-vec2(x, 0.28), 0.01); \n    }\n    \n    vec3 col = mix(BLACK, RED, d);\n    \n    // Add shading.\n    col *= .75 + cos(t) * 0.2;\n \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cll3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 93, 132, 132, 223], [225, 225, 256, 318, 506], [508, 508, 563, 563, 1447]], "test": "untested"}
{"id": "mt2XDd", "name": "Long Shadow", "author": "MysteryPancake", "description": "Basic long shadow effect, couldn't find an example of this on Shadertoy yet for some reason :)", "tags": ["2d", "chroma", "shadow", "drop", "sample", "sampler", "dropshadow"], "likes": 1, "viewed": 246, "published": 3, "date": "1676835928", "time_retrieved": "2024-07-30T18:09:18.272924", "image_code": "float getAlpha(vec3 color) {\n    return smoothstep(0.5, 0.7, distance(color.rgb, vec3(0.0, 1.0, 0.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 vid = texture(iChannel0, uv);\n    fragColor = vid;\n    \n    // Correct aspect ratio for non-square images\n    vec2 aspect = 1.0 / iResolution.xy;\n    \n    // In pixels\n    float shadowLength = 512.0;\n    // Lower values mean better precision\n    float shadowPrecision = 4.0;\n    // In radians\n    float shadowAngle = iTime;\n    \n    float shadowMatte = 0.0;\n    for (float i = shadowPrecision; i <= shadowLength; i += shadowPrecision) {\n        vec2 offset = vec2(sin(shadowAngle), cos(shadowAngle));\n\t\tvec4 col = texture(iChannel0, uv + offset * i * aspect);\n        shadowMatte = max(shadowMatte, getAlpha(col.rgb));\n\t}\n    \n    // Use shadow to darken\n    fragColor -= shadowMatte * 0.25;\n\t\n    // Add back original video\n\tfragColor = mix(fragColor, vid, getAlpha(vid.rgb));\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2XDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 105], [107, 107, 162, 162, 994]], "test": "untested"}
{"id": "ctjXDt", "name": "Mediterran reef and waves", "author": "guil", "description": "Test of sea  transparency", "tags": ["wave", "sea", "reef"], "likes": 9, "viewed": 199, "published": 3, "date": "1676825824", "time_retrieved": "2024-07-30T18:09:19.487676", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n\n\n\n//reef/waves combined field\nvec3 map(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<1e2;s*=1.3)\n            p.xz*=m2,\n            n.xy*=m2,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*2.,\n            e+=.35*abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.3*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n\te+=1.4;\n    return vec3(min(e,f),f,e);\n}\n\nvec3 normalRocks(in vec3 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).y - map(p - e.xyy).y,\n        .008,\n\t\tmap(p + e.yyx).y - map(p - e.yyx).y\n\t\t));\n}\n\nvec3 normalSea(in vec3 p)\n{\n\tconst vec2 e = vec2(0.005, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).z - map(p - e.xyy).z,\n        .008,\n\t\tmap(p + e.yyx).z - map(p - e.yyx).z\n\t\t));\n}\n\n\nvec3 sky(in vec2 p)\n{\t\n    vec3 q =vec3(p.x,1.,p.y);\n    return sin(vec3(1.7,1.5,1)- 2.-map(q*11.).y*.25);\n}\n\nvec3 march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 45.0;\n\tconst float precis = 0.001;\n    float h = 0.0;\n    float t = 0.0;\n    float dt = .2;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t).x;\n        t += h*dt;\n        dt *= 1.015;\n    }\n    if(t < maxd) res = t;\n    return vec3(res,map(ro + rd * t).yz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, .5, -2.+.2*time);\n    vec3 li = normalize(vec3(-4., 4., -2.));   \n    \n    vec3 v = march(ro, rd);\n    float t = v.x;\n    float dh = v.z-v.y;\n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        float k=map(pos).z*1.+1.3;       \n        vec3 nor = normalRocks(pos);\n        float r = max(dot(nor, li),0.1)/2.;\n        col =vec3(r*k*k, r*k, r*.8)+.5*exp(-50.*dh*dh);\n        if(dh<0.0){\n        \tvec3 nor = normalSea(pos+dh*rd);\n        \tnor = reflect(rd, nor);\n            col +=vec3(0.9,.2,.05)*dh*.7;\n        \tcol += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.7);\n        \tcol +=.3* sky(nor.xz);\n            \n        }\n\t    col = .1+col;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(.2+rd.y));\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjXDt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[213, 241, 262, 262, 644], [646, 646, 675, 675, 832], [834, 834, 861, 861, 1018], [1021, 1021, 1042, 1042, 1129], [1131, 1131, 1167, 1167, 1526], [1529, 1529, 1586, 1586, 2500]], "test": "untested"}
{"id": "dt2SDt", "name": "Synthwave grid", "author": "sdclibbery", "description": "Synthwave grid from https://www.shadertoy.com/view/7lKyDD", "tags": ["grid", "synthwave"], "likes": 10, "viewed": 293, "published": 3, "date": "1676824431", "time_retrieved": "2024-07-30T18:09:20.266593", "image_code": "// Original: https://www.shadertoy.com/view/7lKyDD\n\nfloat grid(vec2 uv)\n{\n  vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n  uv += vec2(0.0, iTime * 4.0);\n  uv = abs(fract(uv) - 0.5);\n  vec2 lines = smoothstep(size, vec2(0.0), uv);\n  lines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4;\n  return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n  float horizon = -0.9;\n\n  float fog = smoothstep(0.2, -0.05, abs(uv.y + horizon));\n  vec3 col = vec3(0.0, 0.1, 0.2);\n  if (uv.y < -horizon)\n  {\n    uv.y = 3.0 / (abs(uv.y + horizon) + 0.05);\n    uv.x *= uv.y * 1.0;\n    float gridVal = grid(uv);\n    col = mix(col, vec3(1.0, 0.25, 0.5), gridVal);\n  }\n\n  col += fog * fog * fog;\n  col = mix(vec3(0.75, 0.1, 0.45) * 0.2, col, 0.7);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2SDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 73, 73, 337], [339, 339, 394, 394, 874]], "test": "untested"}
{"id": "ml2XWt", "name": "Synthwave Sun with bars", "author": "sdclibbery", "description": "Just the sun from https://www.shadertoy.com/view/7lKyDD", "tags": ["sun", "synthwave"], "likes": 9, "viewed": 287, "published": 3, "date": "1676822281", "time_retrieved": "2024-07-30T18:09:21.188129", "image_code": "// Original shader: https://www.shadertoy.com/view/7lKyDD\n\nfloat sun(vec2 uv)\n{\n  float r = 0.9;\n  float val = smoothstep(r, r-0.01, length(uv));\n  float bloom = smoothstep(1.0, 0.0, length(uv));\n  float cut = 5.0 * sin((uv.y + iTime * 0.2 * (1.02)) * 60.0)\n    + clamp((uv.y+0.15) * 10.0, -6.0, 6.0);\n  cut = clamp(cut, 0.0, 1.0);\n  return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n  vec3 col = vec3(1.0, 0.4, 0.4);\n  float sunVal = sun(uv);\n  col = mix(col, vec3(1.0, 0.85, 0.3), uv.y * 2.0 + 0.2);\n  col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2XWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 79, 79, 384], [386, 386, 441, 441, 707]], "test": "untested"}
{"id": "DtjSWd", "name": "Impulse 2023!", "author": "mrange", "description": "CC0: Impulse 2023!\nSilliness on sunday morning. \nMusic by Lotek Style, hope he doesn't mind I put his music to this silliness\n", "tags": ["atari"], "likes": 16, "viewed": 377, "published": 3, "date": "1676806086", "time_retrieved": "2024-07-30T18:09:22.027884", "image_code": "// CC0: Impulse 2023!\n// Silliness on sunday morning. \n// Music by Lotek Style, hope he doesn't mind I put his music to this silliness\n\n// If you struggle getting the music to play the reason is often that the browser \n// refuse to play unless you interacted with the controls. \n// So usually pausing and rewinding tend to unlock the music.\n\n#define THAT_CRT_FEELING\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n// Font rendering macros (ASCII codes)\n#define _SPACE 32\n#define _EXCLAMATION 33\n#define _COMMA 44\n#define _DASH 45\n#define _PERIOD 46\n#define _SLASH 47\n#define _COLON 58\n#define _AT 64\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\nconst int numLetters = 13;\nconst int letterArray[numLetters] = int[](\n  _I,_M,_P,_U,_L,_S,_E,_EXCLAMATION,_SPACE,_2,_0,_2,_3\n);\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 atariBee(vec2 p, float aa, float csz, vec3 bgCol, vec3 fgCol) {\n  const int[] rows = int[16](\n    0x00007c3e\n  , 0x282c7f7f\n  , 0x6a52ffff\n  , 0x1b22ffff\n  , 0x7b02ffff\n  , 0x0686ffff\n  , 0x3fcc7fff\n  , 0x1ab87ffe\n  , 0x07603ffc\n  , 0x2ad87ffc\n  , 0x5198ffff\n  , 0x2163ffff\n  , 0x4360fff7\n  , 0x4600fff8\n  , 0x3c10ff38\n  , 0x00107e38\n  );\n\n  vec2 cp = p;\n  float r  = 0.125*csz; \n  vec2 cn = mod2(cp, vec2(csz));\n  cn += 7.0;\n  \n  \n  if (cn.x < 0.0 || cn.x > 15.0) {\n    return vec4(0.0);\n  }\n  \n  if (cn.y < 0.0 || cn.y > 15.0) {\n    return vec4(0.0);\n  }\n\n  float d = box(cp, vec2(0.5*csz-r))-r;\n  // Praying bit tests aren't _too_ bad performance wise.\n  int row = rows[int(cn.y)];\n  bool bg = (row & (1 << int(cn.x))) != 0;\n  if (!bg) {\n    return vec4(0.0);\n  }\n  vec3 col = bgCol;\n  bool fg = (row & (1 << (int(cn.x)+16))) != 0;\n  if (fg) {\n    col = fgCol;\n  }\n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nvec4 atariBomb(vec2 p, float aa, float csz, vec3 bgCol, vec3 fgCol) {\n  const int[] rows = int[16](\n    0x03800380\n  , 0x0fe00fe0\n  , 0x1df01ff0\n  , 0x3bf83ff8\n  , 0x3bf83ff8\n  , 0x7ffc7ffc\n  , 0x7ffc7ffc\n  , 0x3fb83ff8\n  , 0x3ff83ff8\n  , 0x1ff01ff0\n  , 0x07c007c0\n  , 0x07c407c4\n  , 0x01090109\n  , 0x00800080\n  , 0x004a004a\n  , 0x00300030\n  );\n\n  vec2 cp = p;\n  float r  = 0.125*csz; \n  vec2 cn = mod2(cp, vec2(csz));\n  cn += 7.0;\n  \n  \n  if (cn.x < 0.0 || cn.x > 15.0) {\n    return vec4(0.0);\n  }\n  \n  if (cn.y < 0.0 || cn.y > 15.0) {\n    return vec4(0.0);\n  }\n\n  float d = box(cp, vec2(0.5*csz-r))-r;\n  // Praying bit tests aren't _too_ bad performance wise.\n  int row = rows[int(cn.y)];\n  bool bg = (row & (1 << int(cn.x))) != 0;\n  if (!bg) {\n    return vec4(0.0);\n  }\n  vec3 col = bgCol;\n  bool fg = (row & (1 << (int(cn.x)+16))) != 0;\n  if (fg) {\n    col = fgCol;\n  }\n\n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nvec4 text(in vec2 uv, int start, int count, bool repeat) {\n  float fl = floor(uv + 0.5).x;\n  float cursorPos = fl;\n  int arrayPos = int(cursorPos);\n  if (arrayPos < 0)\n  {\n    return vec4(0.0, 0.0, 0.0, 1.0);\n  }\n  if (!repeat && arrayPos >= count)\n  {\n    return vec4(0.0, 0.0, 0.0, 1.0);\n  }\n\n  arrayPos %= count;\n  arrayPos += start;\n\n  int letter = letterArray[arrayPos];\n  vec2 lp = vec2(letter % 16, 15 - letter/16);\n  vec2 uvl = lp + fract(uv+0.5)-0.5;\n\n  // Sample the font texture. Make sure to not use mipmaps.\n  // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n  vec2 tp = (uvl+0.5)*(1.0/16.0);\n  return texture(iChannel1, tp, -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nvec3 competitionWinnerEffect(vec3 col, vec2 p, float tm) {\n  vec2 tp = p;\n  tp.x += sin(p.y+tm);\n  tp.y += sin(tm)*sin(p.x+sqrt(0.5)*tm);\n  tp *= 3.0;\n  tp.x -= -float(numLetters)*0.5;\n  tp.y += 0.4*tm;\n  if (tp.y < 0.5+18.0) {\n    return col;\n  }\n  vec4 tcol = text(tp, 0, numLetters, false);\n  \n  vec3 ecol = vec3(0.0);\n  vec3 fcol = vec3(1.0);\n\n  float ry = p.y-tm;\n  fcol = (1.0+cos(2.0*vec3(0.0, 1.0, 2.0)+ry));\n  fcol = floor(fcol*16.0)/16.0;\n  fcol = step(tcol.w, 0.5)*fcol;\n  float t = step(tcol.w, 0.55);\n  \n  return mix(col, fcol, t);;\n}\n\nvec3 background(vec2 p, vec2 q, float sz) {\n  const vec3 atariBg = vec3(148.0, 236.0, 70.0)/255.0;\n  vec3 col = atariBg;\n  if (1.0-q.y < sz*8.0 ) {\n    col = vec3(0.0);\n  }\n  if (1.0-q.y < sz*7.0 ) {\n    vec2 tp =p;\n    tp *= 8.0;\n    tp.x += float(numLetters)*0.5;\n    tp.y += 0.5;\n    vec4 tcol = text(tp, 0, numLetters, false);\n    col = step(0.52,tcol.w)*vec3(1.0);\n  }\n  return col;\n}\n\nvec3 bombsAway(vec3 col, vec2 p, float sz, float r, float aa) {\n  vec2 bp = p;\n  bp.x -= -1.0*r+8.0*sz;\n  bp.y += -1.0+8.0*sz;\n  vec2 bn = mod2(bp, vec2(16.0*sz));\n\n  float bombs = texture(iChannel0, vec2(clamp((0.0125*(1.0-bn.y)), 0.0, 1.0), 0.25)).x;\n  bombs -= 0.2;\n  bombs = max(bombs, 0.0);\n  bombs *= bombs;\n  bombs *= 20.0;\n\n  if (bn.x > bombs || bn.y > -1.0) {\n    return col;\n  }\n\n  col = vec3(1.0);\n  vec4 bcol = atariBomb(bp, aa, sz, vec3(1.0), vec3(0.0));\n  return mix(col, bcol.xyz, bcol.w);\n}\n\nvec3 busyBee(vec3 col, vec2 p, vec2 m, float aa, float sz) {\n  vec2 ap = p;\n  if (iMouse.z != 0.0) {\n    ap -= m;\n  }\n\n  vec4 acol = atariBee(ap, aa, sz, vec3(1.0), vec3(0.0));\n  return mix(col, acol.xyz, acol.w);\n}\n\nvec3 beatingNik(vec3 col, vec2 p, float aa, float sz, float tm) {\n  sz *= 4.0;\n\n  float ry = 1.0*p.y+tm;\n  vec3 fcol = (1.0+cos(1.6*vec3(0.0, 1.0, 2.0).yzx+ry));\n  fcol = floor(fcol*16.0)/16.0;\n  fcol = mix(vec3(1.0), fcol, smoothstep(54.0, 56.0, tm));\n  p.y += 3.0*smoothstep(15.0, 9.0, tm);\n//  p *= 1.0-0.5*length(p-sin(1.133*TAU*vec2(1.0, sqrt(0.5))*(tm)));\n  for (float i = 0.0; i < 10.0; ++i) {\n    vec2 bp = p;\n    bp += sin(0.33*TAU*vec2(1.0, sqrt(0.5))*(tm+0.25*i));\n    vec4 bcol = atariBee(bp, aa, sz, fcol, vec3(0.0));\n    col = mix(col, bcol.xyz, bcol.w);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  vec2 m = -1. + 2. * (iMouse.xy)/RESOLUTION.xy;\n  float r = RESOLUTION.x/RESOLUTION.y;\n  p.x *= r;\n  m.x *= r;\n  float tm = mod(TIME, 4.0*60.0+11.0);\n//  tm += 10.0;\n  float aa = 2.0/RESOLUTION.y;\n  const float dsz = 0.01;\n  float sz = aa*floor(dsz/aa);\n\n  vec3 col = background(p, q, sz);\n  col = bombsAway(col, p, sz, r, aa);\n  col = beatingNik(col, p, aa, sz, tm);\n  col = competitionWinnerEffect(col, p, tm);\n  col = busyBee(col, p, m, aa, sz);\n  col = clamp(col, 0.0, 1.0);\n#ifdef THAT_CRT_FEELING\n  col *= 1.1*smoothstep(2.1, 0.75, length(pp));\n  col *= mix(vec3(0.71), vec3(1.0),smoothstep(-0.9, 0.9, sin(TAU*p.y/sz+TAU*vec3(0.0, 1., 2.0)/3.0)));\n#endif\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32428, "src": "https://soundcloud.com/lotekstyle/lotek-style-artefakt", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1683, 1769, 1805, 1805, 1899], [1901, 2019, 2046, 2046, 2122], [3996, 3996, 4054, 4054, 4737], [4739, 4739, 4797, 4797, 5286], [5288, 5288, 5331, 5331, 5677], [5679, 5679, 5742, 5742, 6185], [6187, 6187, 6247, 6247, 6402], [6404, 6404, 6469, 6469, 6992], [6994, 6994, 7049, 7049, 7820]], "test": "untested"}
{"id": "DtjXDt", "name": "Chat GPI test 2", "author": "DJSoundPhaze", "description": "Test 2", "tags": ["ai"], "likes": 0, "viewed": 185, "published": 3, "date": "1676799030", "time_retrieved": "2024-07-30T18:09:22.780871", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the audio waveform from the iChannel0 texture input\n    vec4 waveform = texture(iChannel0, vec2(0.0, 0.5));\n    \n    // Calculate the average amplitude of the waveform\n    float amplitude = (waveform.x + waveform.y + waveform.z + waveform.w) / 4.0;\n    \n    // Calculate the color based on the amplitude\n    vec3 color = vec3(amplitude);\n    \n    // Add laser beams\n    float laser = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(1.0, 0.5, 0.0) * laser;\n    \n    // Add sound waves\n    float wave = sin(fragCoord.x * 10.0 + iTime * 10.0) * amplitude * 0.1;\n    color += vec3(0.0, 0.5, 1.0) * wave;\n    \n    // Add pulsating circles\n    vec2 center = vec2(0.5, 0.5);\n    float radius = length(fragCoord - center) * 2.0;\n    float pulse = sin(iTime * 3.0) * 0.2 + 0.8;\n    color += vec3(pulse) * smoothstep(1.0, 0.99, radius);\n    \n    // Add rotating squares\n    vec2 squareCoord = fragCoord - vec2(0.5, 0.5);\n    float angle = atan(squareCoord.y, squareCoord.x) + iTime * 2.0;\n    float squareSize = 0.1;\n    vec2 rotatedSquare = vec2(cos(angle), sin(angle)) * squareSize;\n    float square = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(0.5, 0.0, 1.0) * square * smoothstep(squareSize, 0.0, length(rotatedSquare - squareCoord));\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Define the size of the buffer\nconst float BUFFER_SIZE = 0.03;\n\n// Define the strength of the buffer effect\nconst float BUFFER_STRENGTH = 0.05;\n\n// Define the speed of the buffer effect\nconst float BUFFER_SPEED = 0.5;\n\n// Define the color of the buffer effect\nconst vec3 BUFFER_COLOR = vec3(0.5, 1.0, 0.5);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the audio waveform from the iChannel0 texture input\n    vec4 waveform = texture(iChannel0, vec2(0.0, 0.5));\n    \n    // Calculate the average amplitude of the waveform\n    float amplitude = (waveform.x + waveform.y + waveform.z + waveform.w) / 4.0;\n    \n    // Calculate the color based on the amplitude\n    vec3 color = vec3(amplitude);\n    \n    // Add laser beams\n    float laser = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(1.0, 0.5, 0.0) * laser;\n    \n    // Add sound waves\n    float wave = sin(fragCoord.x * 10.0 + iTime * 10.0) * amplitude * 0.1;\n    color += vec3(0.0, 0.5, 1.0) * wave;\n    \n    // Add pulsating circles\n    vec2 center = vec2(0.5, 0.5);\n    float radius = length(fragCoord - center) * 2.0;\n    float pulse = sin(iTime * 3.0) * 0.2 + 0.8;\n    color += vec3(pulse) * smoothstep(1.0, 0.99, radius);\n    \n    // Add rotating squares\n    vec2 squareCoord = fragCoord - vec2(0.5, 0.5);\n    float angle = atan(squareCoord.y, squareCoord.x) + iTime * 2.0;\n    float squareSize = 0.1;\n    vec2 rotatedSquare = vec2(cos(angle), sin(angle)) * squareSize;\n    float square = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(0.5, 0.0, 1.0) * square * smoothstep(squareSize, 0.0, length(rotatedSquare - squareCoord));\n    \n    // Apply the buffer effect\n    vec2 bufferCoord = fragCoord - vec2(0.5, 0.5);\n    float bufferDist = length(bufferCoord);\n    float bufferWave = sin(bufferDist * 50.0 + iTime * BUFFER_SPEED);\n    float bufferStrength = smoothstep(1.0, BUFFER_SIZE, bufferDist) * BUFFER_STRENGTH * bufferWave;\n    color += BUFFER_COLOR * bufferStrength;\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 118, 1389]], "test": "untested"}
{"id": "Dl2SDt", "name": "Dj Shader Chat GPG", "author": "DJSoundPhaze", "description": "A quick test of the ai", "tags": ["ai"], "likes": 0, "viewed": 179, "published": 3, "date": "1676797698", "time_retrieved": "2024-07-30T18:09:23.664508", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the audio waveform from the iChannel0 texture input\n    vec4 waveform = texture(iChannel0, vec2(0.0, 0.5));\n    \n    // Calculate the average amplitude of the waveform\n    float amplitude = (waveform.x + waveform.y + waveform.z + waveform.w) / 4.0;\n    \n    // Calculate the color based on the amplitude\n    vec3 color = vec3(amplitude);\n    \n    // Add laser beams\n    float laser = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(1.0, 0.5, 0.0) * laser;\n    \n    // Add sound waves\n    float wave = sin(fragCoord.x * 10.0 + iTime * 10.0) * amplitude * 0.1;\n    color += vec3(0.0, 0.5, 1.0) * wave;\n    \n    // Add pulsating circles\n    vec2 center = vec2(0.5, 0.5);\n    float radius = length(fragCoord - center) * 2.0;\n    float pulse = sin(iTime * 3.0) * 0.2 + 0.8;\n    color += vec3(pulse) * smoothstep(1.0, 0.99, radius);\n    \n    // Add rotating squares\n    vec2 squareCoord = fragCoord - vec2(0.5, 0.5);\n    float angle = atan(squareCoord.y, squareCoord.x) + iTime * 2.0;\n    float squareSize = 0.1;\n    vec2 rotatedSquare = vec2(cos(angle), sin(angle)) * squareSize;\n    float square = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(0.5, 0.0, 1.0) * square * smoothstep(squareSize, 0.0, length(rotatedSquare - squareCoord));\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "buffer_a_code": "// Define the size of the buffer\nconst float BUFFER_SIZE = 0.03;\n\n// Define the strength of the buffer effect\nconst float BUFFER_STRENGTH = 0.05;\n\n// Define the speed of the buffer effect\nconst float BUFFER_SPEED = 0.5;\n\n// Define the color of the buffer effect\nconst vec3 BUFFER_COLOR = vec3(0.5, 1.0, 0.5);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the audio waveform from the iChannel0 texture input\n    vec4 waveform = texture(iChannel0, vec2(0.0, 0.5));\n    \n    // Calculate the average amplitude of the waveform\n    float amplitude = (waveform.x + waveform.y + waveform.z + waveform.w) / 4.0;\n    \n    // Calculate the color based on the amplitude\n    vec3 color = vec3(amplitude);\n    \n    // Add laser beams\n    float laser = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(1.0, 0.5, 0.0) * laser;\n    \n    // Add sound waves\n    float wave = sin(fragCoord.x * 10.0 + iTime * 10.0) * amplitude * 0.1;\n    color += vec3(0.0, 0.5, 1.0) * wave;\n    \n    // Add pulsating circles\n    vec2 center = vec2(0.5, 0.5);\n    float radius = length(fragCoord - center) * 2.0;\n    float pulse = sin(iTime * 3.0) * 0.2 + 0.8;\n    color += vec3(pulse) * smoothstep(1.0, 0.99, radius);\n    \n    // Add rotating squares\n    vec2 squareCoord = fragCoord - vec2(0.5, 0.5);\n    float angle = atan(squareCoord.y, squareCoord.x) + iTime * 2.0;\n    float squareSize = 0.1;\n    vec2 rotatedSquare = vec2(cos(angle), sin(angle)) * squareSize;\n    float square = smoothstep(0.98, 1.0, amplitude) * 0.5;\n    color += vec3(0.5, 0.0, 1.0) * square * smoothstep(squareSize, 0.0, length(rotatedSquare - squareCoord));\n    \n    // Apply the buffer effect\n    vec2 bufferCoord = fragCoord - vec2(0.5, 0.5);\n    float bufferDist = length(bufferCoord);\n    float bufferWave = sin(bufferDist * 50.0 + iTime * BUFFER_SPEED);\n    float bufferStrength = smoothstep(1.0, BUFFER_SIZE, bufferDist) * BUFFER_STRENGTH * bufferWave;\n    color += BUFFER_COLOR * bufferStrength;\n    \n    // Set the output color\n    fragColor = vec4(color, 1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2SDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 118, 1389]], "test": "untested"}
{"id": "DlSXDd", "name": "Antialiased atan2", "author": "oneshade", "description": "Not so useful for calculations, but this is one way to go about antialiasing an angular gradient.", "tags": ["antialiasing", "aa", "angle", "atan2"], "likes": 16, "viewed": 356, "published": 3, "date": "1676753694", "time_retrieved": "2024-07-30T18:09:24.575073", "image_code": "#define PI 3.1415926536\n#define RHO 1.5707963268\n\n// atan2(x, y) = abs(atan(abs(y / x)) + PI * min(0, sign(x))) * sign(y)\n// sign(y) causes the discontinuity so we just need a smooth sign function\n// for example, a smoothstep mapped from -1 to 1\nfloat satan(in vec2 p, in float w) { // :)\n    float a = abs(p.x) < 1e-8 ? RHO : atan(abs(p.y / p.x));\n    float sy = 2.0 * smoothstep(-w, w, p.y) - 1.0;\n    return abs(a + PI * min(0.0, sign(p.x))) * sy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 1.0 / iResolution.y;\n\n    float rot = 0.1 * iTime;\n    float co = cos(rot), si = sin(rot);\n    uv *= mat2(co, -si, si, co);\n\n    fragColor = vec4(0.5 + 0.5 * satan(uv, unit) / PI);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 246, 282, 288, 452], [454, 454, 509, 509, 775]], "test": "untested"}
{"id": "DlBSDd", "name": "Atari Busy Bee", "author": "mrange", "description": "CC0: Atari Busy Bee\nRecreating the Atari Busy bee\nUse mouse to drag it around", "tags": ["atari"], "likes": 5, "viewed": 312, "published": 3, "date": "1676752868", "time_retrieved": "2024-07-30T18:09:25.419815", "image_code": "// CC0: Atari Busy Bee\n//  Recreating the Atari Busy bee\n//  Use mouse to drag it around\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 atariBee(vec2 p, float aa, float csz, vec3 bgCol, vec3 fgCol) {\n  const int[] rows = int[16](\n    0x00007c3e\n  , 0x282c7f7f\n  , 0x6a52ffff\n  , 0x1b22ffff\n  , 0x7b02ffff\n  , 0x0686ffff\n  , 0x3fcc7fff\n  , 0x1ab87ffe\n  , 0x07603ffc\n  , 0x2ad87ffc\n  , 0x5198ffff\n  , 0x2163ffff\n  , 0x4360fff7\n  , 0x4600fff8\n  , 0x3c10ff38\n  , 0x00107e38\n  );\n\n  vec2 cp = p;\n  float r  = 0.125*csz; \n  vec2 cn = mod2(cp, vec2(csz));\n  cn += 7.0;\n  \n  \n  if (cn.x < 0.0 || cn.x > 15.0) {\n    return vec4(0.0);\n  }\n  \n  if (cn.y < 0.0 || cn.y > 15.0) {\n    return vec4(0.0);\n  }\n\n  float d = box(cp, vec2(0.5*csz-r))-r;\n  // Praying bit tests aren't _too_ bad performance wise.\n  int row = rows[int(cn.y)];\n  bool bg = (row & (1 << int(cn.x))) != 0;\n  if (!bg) {\n    return vec4(0.0);\n  }\n  vec3 col = bgCol;\n  bool fg = (row & (1 << (int(cn.x)+16))) != 0;\n  if (fg) {\n    col = fgCol;\n  }\n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nvec4 atariBomb(vec2 p, float aa, float csz, vec3 bgCol, vec3 fgCol) {\n  const int[] rows = int[16](\n    0x03800380\n  , 0x0fe00fe0\n  , 0x1df01ff0\n  , 0x3bf83ff8\n  , 0x3bf83ff8\n  , 0x7ffc7ffc\n  , 0x7ffc7ffc\n  , 0x3fb83ff8\n  , 0x3ff83ff8\n  , 0x1ff01ff0\n  , 0x07c007c0\n  , 0x07c407c4\n  , 0x01090109\n  , 0x00800080\n  , 0x004a004a\n  , 0x00300030\n  );\n\n  vec2 cp = p;\n  float r  = 0.125*csz; \n  vec2 cn = mod2(cp, vec2(csz));\n  cn += 7.0;\n  \n  \n  if (cn.x < 0.0 || cn.x > 15.0) {\n    return vec4(0.0);\n  }\n  \n  if (cn.y < 0.0 || cn.y > 15.0) {\n    return vec4(0.0);\n  }\n\n  float d = box(cp, vec2(0.5*csz-r))-r;\n  // Praying bit tests aren't _too_ bad performance wise.\n  int row = rows[int(cn.y)];\n  bool bg = (row & (1 << int(cn.x))) != 0;\n  if (!bg) {\n    return vec4(0.0);\n  }\n  vec3 col = bgCol;\n  bool fg = (row & (1 << (int(cn.x)+16))) != 0;\n  if (fg) {\n    col = fgCol;\n  }\n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 m = -1. + 2. * (iMouse.xy)/RESOLUTION.xy;\n  float r = RESOLUTION.x/RESOLUTION.y;\n  p.x *= r;\n  m.x *= r;\n\n  float aa = 2.0/RESOLUTION.y;\n  float sz = 4.0*aa;\n\n  const vec3 atariBg = vec3(148.0, 236.0, 70.0)/255.0;\n  vec3 col = atariBg;\n  if (1.0-q.y < sz*8.0 ) {\n      col = vec3(0.0);\n  }\n  if (1.0-q.y < sz*7.0 ) {\n      col = vec3(1.0);\n  }\n  vec2 ap = p;\n  if (iMouse.z != 0.0) {\n    ap -= m;\n  }\n  \n  vec2 bp = p;\n  bp.x -= -1.0*r+8.0*sz;\n  float bombs = 11.0*(0.5+0.5*sin(TIME))-1.0;\n  vec2 bn = mod2(bp, vec2(16.0*sz));\n  \n  vec4 acol = atariBee(ap, aa, sz, vec3(1.0), vec3(0.0));\n  vec4 bcol = atariBomb(bp, aa, sz, vec3(1.0), vec3(0.0));\n\n  if (bn.x < bombs && bn.y == 0.0) {\n    col = vec3(1.0);\n    col = mix(col, bcol.xyz, bcol.w);\n  }\n  col = mix(col, acol.xyz, acol.w);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 234, 270, 270, 364], [366, 484, 511, 511, 587], [2460, 2460, 2515, 2515, 3399]], "test": "untested"}
{"id": "DtBSWd", "name": "Synced Walker Dude", "author": "fishy", "description": "now really needs music :)", "tags": ["walk", "person"], "likes": 4, "viewed": 207, "published": 3, "date": "1676748150", "time_retrieved": "2024-07-30T18:09:26.282508", "image_code": "// The only new line of code here\n#define iTime texture(iChannel1, vec2(0)).r*2.\n\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n\n//https://lospec.com/palette-list/verdigris\n#define white vec3(238, 228, 189) / 255.\n#define grey1 vec3(196, 196, 153) / 255.\n#define grey2 vec3(127, 144, 129) / 255.\n#define brown0 vec3(44,  31,  26) / 255.\n#define brown1 vec3(125, 71,  53) / 255.\n#define brown2 vec3(179, 109, 65) / 255.\n#define brown3 vec3(216, 152, 64) / 255.\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSeg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    float k = 1. / res.y;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    vec2 ms = (iMouse.xy - 0.5 * res) / res.y;\n    if (iMouse.z <= 0.)\n        ms = vec2(0.18, -0.1);\n    float t = 0.65 * iTime;\n   \n    float h = -0.25; \n    float r = 0.03;\n    \n    float sw = ms.x;//0.18 * ms.x; // Stride width (x2)\n    float sh = -ms.y; // Stride height\n    \n    float fr = mod(t, 2.);\n    float fr2 = mod(t + 1., 2.);\n\n    float y = max(0., -ths(4., pi/2. + pi * t));\n    float y2 = max(0.,ths(4., pi/2. + pi * t));\n    y = pow(y, 14.);\n    y2 = pow(y2, 14.);\n    \n    vec2 pHead = vec2(0, 0.225 + 2. * r * ths(2., 2. * pi * t + 0.1));\n    vec2 pNeck = vec2(0, 0.1 + 2. * r * ths(2., 2. * pi * t + 0.2));\n    vec2 pHip = vec2(0, 2. * r * ths(2., 2. * pi * t ));\n    vec2 pFoot1 = vec2(sw * ths(4., pi*t), h + 0.4*r + 2. * r * y);\n    vec2 pFoot2 = vec2(sw * -ths(4., pi*t), h + 0.4*r + 2. * r * y2);\n    vec2 pHand1 = pNeck - vec2(sw * ths(4.,pi*t), sh * (.5+.5*thc(2.,pi*t)));\n    vec2 pHand2 = pNeck - vec2(sw * -ths(4.,pi*t), sh * (.5+.5*thc(2.,pi*t)));\n    \n    float dHead = length(uv - pHead) - 0.05 - 0.004 *ths(2.,2.*pi*t+0.1);\n    float dBody = sdSeg(uv, pHip, pNeck) - 0.05 - 0.005 *ths(2.,2.*pi*t);\n    vec2 dLeg = vec2(sdSeg(uv, pFoot1, pHip),\n                     sdSeg(uv, pFoot2, pHip)) - 0.9 * r;\n    vec2 m = min(vec2(r), abs(vec2(pFoot1.y, pFoot2.y) - h));\n    vec2 dFoot = vec2(sdBox(uv-pFoot1, vec2(r*r/m.x, m.x)-.4*r)-.4*r,\n                      sdBox(uv-pFoot2, vec2(r*r/m.y, m.y)-.4*r)-.4*r);\n    vec2 dArm = vec2(sdSeg(uv, pNeck, pHand1) - 0.8 * r,\n                     sdSeg(uv, pNeck, pHand2) - 0.8 * r);\n    \n    float d = min(dHead, dBody);\n    //d = min(d, min(dLeg.x, dLeg.y));\n    d = min(d, min(dFoot.x, dFoot.y));\n    d = min(d, min(dArm.x, dArm.y));\n    \n    float sHead = smoothstep(-k, k, -dHead);\n    float sBody = smoothstep(-k, k, -dBody);\n    vec2   sLeg = smoothstep(-k, k, -dLeg);\n    sLeg.x *= step(pFoot1.y - m.x + k, uv.y);\n    sLeg.y *= step(pFoot2.y - m.y + k, uv.y);\n    vec2  sFoot = smoothstep(-k, k, -dFoot);\n    vec2   sArm = smoothstep(-k, k, -dArm);\n    float sGround = smoothstep(-k, k, h - uv.y);\n    \n    float s = smoothstep(-k, k, -d + 0.4 * r);\n    vec2 sLeg2 = smoothstep(-k, k, -dLeg + 0.4 * r); //sloppy\n    sLeg2.x *= step(pFoot1.y - m.x + k, uv.y);\n    sLeg2.y *= step(pFoot2.y - m.y + k, uv.y);\n    s = max(s, max(sLeg2.x, sLeg2.y));\n    \n    vec3 col = vec3(0);    \n    col.r = max(sFoot.x, sLeg.x);\n    col.r = max(col.r, sArm.x);\n    col.g += max(sFoot.y, sLeg.y);\n    col.g = max(col.g, sArm.y);\n    col.b = max(sHead, sBody);\n    \n    vec3 col2 = white;//mix(white, brown0, s);\n    float dHill = -0.5 * h * (1. - cos(4.*uv.x-0.25*pi*t)) - uv.y;\n    float sHill = smoothstep(-k, k, dHill);\n    uv = 2. * (uv + vec2(0.125*pi*(1.- 0.5*t), 0.5*h));\n    float ix = floor(2.*uv.x/pi) + 0.;\n    float fx = mod(uv.x, 0.5*pi) - pi/4.;\n    float test = mod(ix, 2.);\n    \n    float dCircle = length(vec2(fx, uv.y)) - 0.2;\n    float sCircle = smoothstep(-2.*k, 2.*k, dCircle);\n    col2 = mix(col2, grey1, 1.-sHill);\n    col2 = mix(col2, mix(white, grey1, test), (1.-sCircle));\n    col2 = mix(col2, grey2, sGround);\n    col2 = mix(col2, brown0, s);\n    col2 = mix(col2, brown1, col.r);\n    col2 = mix(col2, brown2, col.b);\n    col2 = mix(col2, brown3, col.g);\n    fragColor = vec4(col2,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Stores audio in a buffer because the soundcloud input doesn't have mipmaps\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, vec2(fragCoord.x/iResolution.x, 0));\n}", "buffer_a_inputs": [{"id": 32415, "src": "https://soundcloud.com/lostdogz/sumthin-sumthin-cut-that-untz-premiere?in=user-747537358/sets/2021-playback&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// Accumulate the average of all the pixels using mipmaps\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(iFrame == 0)\n        fragColor = vec4(0);\n    fragColor += vec4(pow(textureLod(iChannel0, fragCoord/iResolution.xy, 10.).r, 2.)*iTimeDelta);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[549, 549, 588, 588, 688], [690, 690, 725, 725, 805], [807, 807, 853, 853, 972], [974, 974, 1031, 1031, 4410]], "test": "untested"}
{"id": "dt2Xzt", "name": "Banger sponge", "author": "rcargou", "description": "Fork from https://www.shadertoy.com/view/4s3SRN", "tags": ["fractal", "camera", "spline", "menger", "curve", "catmullrom"], "likes": 12, "viewed": 409, "published": 3, "date": "1676747689", "time_retrieved": "2024-07-30T18:09:27.287820", "image_code": "vec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel1, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel2, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n\n    color += GetBloom(uv) * 0.12;\n    \n    //color *= 2.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n    \n //   fragColor = texture(iChannel1, uv);\n\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash31(vec3 p) {\n   \tfloat h = dot(p,vec3(127.1,311.7, 21.));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash21( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n", "buffer_a_code": "// Fork of \"Fractal Flythrough\" by Shane. https://shadertoy.com/view/4s3SRN\n// 2023-02-13 22:36:13\n// Sorry I got rid of the comment because it helps me navigate the code,\n// but go see the original from Shane for amazing explaination\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\nvec3 stripCols(float t, float z) {\n    vec3 cols[3];\n    cols[0] = vec3(0.506,0.780,0.255) ;\n    cols[1] = vec3(.106,0.280,0.255) ;\n    cols[2] = vec3(0.906,0.30,1.255) ;\n    \n    int id = int( floor(mod(t / 12., 3.)) );\n    id += int(z / 10.);\n    id = id % 3;\n    return cols[id];\n}\nvec2 getPhase() {\n//    return vec2( 0., 0. );\n    float t = iTime * 2.;\n    float i = smoothstep(0.75, 1.28, abs ( mod(t / 16. - t / 8., 2.) - 1.) );\n    return vec2( floor( mod(t / 16., 2.) ),  i );\n}\n\nconst float FAR = 50.0; // Far plane.\n\nfloat objID = 0.; // Wood = 1., Metal = 2., Gold = 3..\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\nfloat pulseHalf() {\n    return 1.;\n}\n\nfloat pulse() {\n\n    return pow( ( sin(iTime * 5.) + 1. ) * .5, 2.) * .75 + .25;\n}\n\nfloat pulseFast() {\n    return pow( ( sin(iTime * 10.) + 1. ) * .5, 4.) * .75 + .25;\n}\n\nfloat backStars(vec2 uv) {\n\n    uv.y+=cos(uv.x * 1. +0.) / 4.;\n    float ret = 0.;\n    uv.x -= iTime / 4.;\n    \n    for (int i = 0; i < 2; ++i) {\n        uv *= 3.;\n        float rep = .2;\n\n        vec2 m_uv = mod(uv, rep) - rep / 2.;\n        vec2 m_id = floor( uv / rep);\n        \n        float id1 = hash21(m_id / 123.321);\n     //   float id2 = hash22(m_id / 123.321); \n        float star = smoothstep(0.02, 0.01, length(m_uv) );\n        if (id1 > 0.98)\n            ret = star + ret;\n    }\n    return ret;\n}\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\nfloat map(in vec3 q){\n    q.z/=.5;\n\n    // benef\n    if (getPhase().x == 1.) {\n        q*= rotateZ(iTime);\n        q.xy+=sin(q.z / 8. + sin(iTime / 512.)) * 2.;\n      }\n\n   if (length(max(abs(q.x), abs(q.y))) >11. && getPhase().x==0.) {\n      //     return 1.;\n   }\n\n   if (length(max(abs(q.x), abs(q.y))) <8.) {\n\n    // q*=2.;\n      // q.z+=iTime *32.;\n   }\n\n    vec3 p = abs(fract(q/4.)*4. - 2.);\n \tfloat tube = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) -4./3. - .015;// + .05;\n    vec3 qq = abs(q);\n    float amp =  2. ;//+ sin(iTime) /2.;\n    \n    for (int i = 0; i < 3 ; ++i) {\n        // Layer two.\n        qq *=rotateZ( ( -iTime /8.) * float(getPhase().x == 1.) );\n        p = abs(fract(qq)*amp - amp/2.);\n        //d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);// + .025\n        tube = .15*(pulse()-.25)+max(tube, sminP(max(p.x, p.y), sminP(max(p.y, p.z), max(p.x, p.z), .05), .05) - 2./3.);// + .025\n        qq/=4.;\n        amp *= 1.5;\n     }\n     \n    float strip = step(p.x, .75)*step(p.y, .75)*step(p.z, .75);\n    tube -= (strip)*.025;     \n    \n    float repxy = 20.;// - 5.*pulse();\n    float s = .2*(pulse());\n    float repz = .051;//.2-pulse()/10.;\n    vec3 si = sign(q);\n    //q *= rotateY(si.x / 2.);\n   // q *= rotateX(-si.y/4.);\n   q.z/=2.;\n   \n   q.y +=mix( 1.5*sin(q.z * 1. + iTime * 16.) * sin(iTime * 4.), abs(fract(q.z * 2. + iTime * 8.) - .5) * 2., pulse() - .25);\n  // q.y += ;\n   q *= rotateZ(3.1415/4.);\n   q.xy +=5.*sign(q.xy);\n   vec3 qball = abs(fract(q/( vec3(repxy, repxy, repz) ))*vec3(repxy, repxy, repz) - vec3(repxy/2., repxy/2., repz/2.));\n      \n   float d = length(qball) - s;\n   // return d;\n    objID = strip;\n    \n    objID += step(d, tube) * 3.;\n    return min(tube, d);\n   return (tube);\n}\n\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    for(int i = 0; i < 50; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*1.;\n        \n    }\n\n    return t;\n}\n\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    \n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    \n    vec3  ro = vec3(0., 0., 1. + iTime *8.);\n    vec3 lk = vec3(0., 0., 2. + iTime*8.);\n    vec3 lp = lk;\n    // Using the above to produce the unit ray-direction vector.\n    float FOV =6.57 + pulse(); // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n        // Unit direction ray.\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    \n    // Raymarch the scene.\n    float t = trace(ro, rd);\n    \n    // Initialize the scene color.\n    vec3 col = vec3(0);\n    \n\n    float lum = 0.;\n    // Scene hit, so color the pixel. Technically, the object should always be hit, so it's tempting to\n    // remove this entire branch... but I'll leave it, for now.\n    if(t<FAR){\n        \n        // This looks a little messy and haphazard, but it's really just some basic lighting, and application\n        // of the following material properties: Wood = 1., Metal = 2., Gold = 3..\n    \n        float ts = 1.;  // Texture scale.\n        \n        // Global object ID. It needs to be saved just after the raymarching equation, since other \"map\" calls,\n        // like normal calculations will give incorrect results. Found that out the hard way. :)\n        float saveObjID = objID; \n        \n        \n        vec3 pos = ro + rd*t; // Scene postion.\n        vec3 nor = calcNormal(pos); // Normal.\n        vec3 sNor = nor;\n\n        // Reflected ray. Note that the normal is only half bumped. It's fake, but it helps\n        // taking some of the warping effect off of the reflections.\n        vec3 ref = reflect(rd, normalize(sNor*.5 + nor*.5)); \n         \n        \n\t\tcol = tex3D(iChannel0, pos*ts, nor)* vec3(0.925,0.388,0.067); // Texture pixel at the scene postion.\n        \n        \n        vec3  li = lp - pos; // Point light.\n        float lDist = max(length(li), .001); // Surface to light distance.\n        float atten = 1./(1.0 + lDist*0.125 + lDist*lDist*.05); // Light attenuation.\n        li /= lDist; // Normalizing the point light vector.\n        \n        float occ = 1.;//calcAO( pos, nor ); // Occlusion.\n\t\t\n        float dif = clamp(dot(nor, li), 0.0, 1.0); // Diffuse.\n        dif = pow(dif, 4.)*2.;\n        float spe = pow(max(dot(reflect(-li, nor), -rd), 0.), 8.); // Object specular.\n        float spe2 = spe*spe; // Global specular.\n        \n        float refl = .35; // Reflection coefficient. Different for different materials.\n\n            \n\n        // Reflection color. Mostly fake.\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n        // effort is being put in.\n        float rt = 0.;//refTrace(pos + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        float rSaveObjID = objID; // IDs change with reflection. Learned that the hard way. :)\n        vec3 rsp = pos + ref*rt; // Reflected surface hit point.\n        vec3 rsn = calcNormal(rsp); // Normal at the reflected surface. Too costly to bump reflections.\n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        vec3 rLi = lp-rsp;\n        float rlDist = max(length(rLi), 0.001);\n        rLi /= rlDist;\n        float rDiff = max(dot(rsn, rLi), 0.); // Diffuse light at \"rsp.\"\n        rDiff = pow(rDiff, 4.)*2.;\n        float rAtten = 1./(1. + rlDist*0.125 + rlDist*rlDist*.05);\n        \n        if(rSaveObjID <  1.){\n         //   lum = 2.;\n         lum = 0.;\n            col *= 1.*vec3(0.549,0.475,0.557);\n        } else if (rSaveObjID < 1.5){\n            col = stripCols(iTime, pos.z) * pulseFast();\n            lum = 5.*pulseFast();\n        } else {\n            col = vec3(0.169,0.745,0.867);\n            lum = 10. * (pulse()-.25) * (1.+sin(pos.z * 5.) / 2.);\n        }\n        col += 1.3*vec3(0.169,0.745,0.867) * ( pulse() - .25);\n        col +=1.1*stripCols(iTime, pos.z) * ( pulseFast() - .25);\n//        if (nor.z < 0.)\n        rCol *= (rDiff + .35)*rAtten; // Reflected color. Not accurate, but close enough.         \n        \n\n         if(length(pos.xy) > 20.)\n            col *=2.;\n        // Combining everything together to produce the scene color.\n        col = col*(dif + .35  + vec3(.35, .45, .5)*spe*2.) + vec3(.7, .9, 1)*spe2 * 2. + rCol*refl;\n  //      col *= occ* ( atten + pulse() - .25); // Applying occlusion.\n            col *= occ* ( atten); // Applying occlusion.\n        \n    }    else{ col=vec3( backStars(u * 4.)); lum = col.r*20.; }\n    // Applying some very slight fog in the distance. This is technically an inside scene...\n    // Or is it underground... Who cares, it's just a shader. :)\n    //col = mix(min(col, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*20.));//smoothstep(0., FAR-20., t)\n   // col = mix(min(col, 1.), vec3(0), smoothstep(0., FAR-35., t));//smoothstep(0., FAR-20., t)\n    \n//        col.xyz = helix(vec2(u)).xyz;\n    \n        \n    // Done.\n    fragColor = vec4(pow( (max(col, 0.)), vec3( .9 ) ), lum);\n    \n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb * texture(iChannel0, coord).w;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 1.12)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2Xzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 68], [70, 70, 91, 91, 307], [309, 309, 363, 363, 1300], [1302, 1302, 1331, 1331, 1376], [1378, 1378, 1407, 1407, 1459], [1461, 1461, 1523, 1523, 1632], [1634, 1634, 1665, 1665, 1971], [1973, 1973, 2000, 2000, 2579], [2581, 2581, 2638, 2638, 3236]], "test": "untested"}
{"id": "DtBXDt", "name": "Gaussian blur w/ R2 curve", "author": "clauswilke", "description": "Gaussian blur implemented by sampling via a low discrepancy sequence R2. Left: For each output pixel we retrieve N samples displaced by pixel-specific R2 sequence. Right: For each output pixel we retrieve a single sample displaced by global R2 sequence. ", "tags": ["2d", "noise", "blur", "lowdiscrepancy", "r2curve"], "likes": 5, "viewed": 252, "published": 3, "date": "1676746340", "time_retrieved": "2024-07-30T18:09:28.135554", "image_code": "// Gaussian Blur via 2D Low Discrepancy Sequence\n// Claus O. Wilke, Feb. 2023\n// Licensed CC0, https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// This shader uses the R2 curve described here:\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// See also: https://www.shadertoy.com/view/dlSXDc\n\n// Plastic constant, https://en.wikipedia.org/wiki/Plastic_number\nconst float phi2 = pow((9. + sqrt(69.)) / 18., 1./3.) + pow((9. - sqrt(69.)) / 18., 1./3.); \n\n// Calculate R2 for index i\nvec2 getR2(float i) {\n    // We're using 1 - 1/phi instead of 1/phi for higher precision,\n    // as explained here: https://www.shadertoy.com/view/mts3zN\n    const float C1 = 1. - 1. / phi2;\n    const float C2 = 1. - 1. / (phi2 * phi2);\n\n    return vec2(fract(i * C1), fract(i * C2));\n}\n\n// Taken from: https://www.shadertoy.com/view/Nsjczt by Matt Ebb\n// Modified version of https://www.shadertoy.com/view/WldXR4\n// by TinyTexel\n// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\nuint hilbert_idx(uvec2 uv, uint offset)\n{\n    // Hilbert curve:\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    uv += uint(offset) * uvec2(2447445397u, 3242174893u);\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    const uint N = 7u;// tile size = 2^N\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by layer)\n        p = (P >> o) & 3u;// update pattern\n    }\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float N = 100.; // number of samples\n    float dmax = 0.02 * (1.01 + sin(0.5 * iTime + 0.5)); // max blur distance\n    float sigma = dmax / 2.5;\n    sigma *= sigma;\n    \n    vec3 col = vec3(0);\n    float weight = 0.;\n    if (uv.x > 0.5) {\n        float idx = mod(float(hilbert_idx(uvec2(fragCoord), 0u)), 100000.);\n        vec2 uvoff = dmax * (getR2(float(idx)) - 0.5);\n        float bw = exp(-dot(uvoff, uvoff) / sigma);\n        col += bw * texture(iChannel0, uv + uvoff).rgb;\n        weight += bw;\n    } else {\n        float idx = mod(float(hilbert_idx(uvec2(fragCoord), 0u)), 100000.);\n        for (float i = 0.; i < N; i++) {\n            vec2 uvoff = dmax * (getR2(idx + i) - 0.5);\n            float bw = exp(-dot(uvoff, uvoff) / sigma);\n            col += bw * texture(iChannel0, uv + uvoff).rgb;\n            weight += bw;\n        }\n    }\n    col /= weight;\n    col *= smoothstep(0.0008, 0.0012, abs(uv.x - 0.5));\n       \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXDt.jpg", "access": "api", "license": "cc0-1.0 OR openssl-ssleay OR apache-2.0", "functions": [[506, 534, 555, 687, 820], [1034, 1034, 1075, 1097, 1712], [1715, 1715, 1772, 1772, 2778]], "test": "untested"}
{"id": "ctBXDt", "name": "Newton's cradle", "author": "dphillip11", "description": "an experiment with raytraced reflections and shadows,  use the mouse to move the light. Ray bounces increase over time", "tags": ["raytracing"], "likes": 3, "viewed": 323, "published": 3, "date": "1676744286", "time_retrieved": "2024-07-30T18:09:29.184749", "image_code": "//number of light bounces\nint BOUNCES = 1;\nstruct cylinder\n{\n    vec3 centre;\n    vec3 axis;\n    float length;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 centre;\n    vec3 size;\n};\n\n\n//////////////////////objects\n\n//collider ID's\nconst int NO_COL = -2;\nconst int GROUND = -1;\nconst int BALL[5] = int[5](0,1,2,3,4);\nconst int BASE = 5;\nconst int FRAME = 6;\nconst int PIPEJOINT = 7;\nconst int STRINGS = 8;\nconst int CUBEMAP = 9;\n\n\ncylinder frame[8] = cylinder[8](\n    //frame\n    cylinder(vec3(0., 8., 8.), vec3(1, 0, 0), 10., 0.25),\n    cylinder(vec3(0., 8., 2.), vec3(1, 0, 0), 10., 0.25),\n    cylinder(vec3(-5, 8., 5.), vec3(0, 0, 1), 6., 0.25),\n    cylinder(vec3(5, 8., 5.), vec3(0, 0, 1), 6., 0.25),\n    //legs\n    cylinder(vec3(-5, 4., 2.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(-5, 4., 8.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(5, 4., 2.), vec3(0, 1, 0), 8., 0.25),\n    cylinder(vec3(5, 4., 8.), vec3(0, 1, 0), 8., 0.25));\n    \ncylinder strings[10];\n   \nvec4 balls[5] = vec4[5](\n    //balls\n    vec4(-4., 2, 5, 1), \n    vec4(-2, 2, 5, 1), \n    vec4(0., 2, 5, 1), \n    vec4(2, 2, 5, 1), \n    vec4(4, 2, 5, 1));\n\nvec4 pipeJoints[4] = vec4[4](\n    //pipe joints\n    vec4(-5, 8, 2, 0.25), \n    vec4(5, 8, 2, 0.25), \n    vec4(-5, 8, 8,0.25), \n    vec4(5, 8, 8, 0.25));\n\nconst float MAP_SIZE = 20.;\nBox base = Box(vec3(0,0.25,5),vec3(11.25,0.5,7));\nBox cubeMap = Box(vec3(0,0,5),vec3(MAP_SIZE,90.,MAP_SIZE));\n\nvec3 ballColor[5] = vec3[5](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 0), vec3(0, 0, 1), vec3(1, 1, 0));\nvec3 frameColor = vec3(0.3, 0.3, 0.3);\nvec3 groundColor = vec3(0.3, 0.05, 0.4);\nvec3 skyColor = vec3(0.5, 0.8, 1);\nvec3 stringColor = vec3(0.4, 0.4, 0.4);\nvec3 baseColor = vec3(214., 141., 6.)/255.;\nvec3 cubeMapColor = vec3(0.1, 0.1, 0.1);\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 target;\n    float depth;\n    vec3 up;\n    vec3 right;\n    vec3 forward;\n};\n\n\nCamera cam = Camera(vec3(1),vec3(0,5,3),0.7,vec3(0,1,0),vec3(1,0,0), vec3(0,0,1));\n\nvec3 light_pos;\nfloat reflectionDenominator = 150.;\nfloat shininess_ball = 128.;\nfloat shininess_frame = 90.;\nfloat shininess_base = 32.;\nfloat shininess_ground = 16.;\nfloat shininess_string = 5.;\nfloat shininess_cubeMap = 128.;\nfloat ambientIntensity = 0.3;\n\n\n\nstruct intersection {\n    int collider;\n    float distance;\n    vec3 normal;\n    vec3 point;\n    vec3 reflectDir;  \n};\n\nvoid GetGroundIntersection(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    //check intersection with ground, y=0\n    if (ray_origin.y > 0. && ray_dir.y < 0.)\n    {\n        float d = abs(ray_origin.y / ray_dir.y);\n        \n        if (d > 0. && (intx.collider == NO_COL || d < intx.distance))\n        {  \n            intx.collider = GROUND;\n            intx.distance = d;\n            intx.normal = vec3(0,1,0);\n        }\n    }\n}\n\nvoid GetSphereIntersection(vec3 ray_origin, vec3 ray_dir, vec4 sphere, inout intersection intx, int ID)\n{\n        //vector to sphere directly\n        vec3 sphere_dir = sphere.xyz - ray_origin;\n        //calculate projection along ray direction\n        float dotP = dot(sphere_dir, ray_dir);\n        //ignore spheres in opposite direction\n        if (dotP < 0.)\n            return;\n        vec3 ray_proj = dotP * ray_dir;\n        float ray_length = length(ray_proj);\n        vec3 ray_point = ray_proj + ray_origin;\n        //distance from line to centre\n        float d = length(sphere.xyz - ray_point);\n        if (d > sphere.w)\n            return;\n        //calculate sphere intersection, pythagoras\n        float overlap = sqrt(pow(sphere.w, 2.) - pow(d, 2.));\n        ray_length -= overlap;\n        if (ray_length < intx.distance || intx.collider == NO_COL)\n        {\n            intx.distance = ray_length;\n            intx.collider = ID;\n            intx.normal = normalize(ray_origin + ray_length * ray_dir - sphere.xyz);\n        }\n}\n\nvoid WorldSphereIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    for (int i = 0; i < balls.length(); i ++)\n    {\n          GetSphereIntersection(ray_origin, ray_dir, balls[i], intx, BALL[i]);     \n    }\n    for (int i = 0; i < pipeJoints.length(); i ++)\n    {\n          GetSphereIntersection(ray_origin, ray_dir, pipeJoints[i], intx, PIPEJOINT);     \n    }\n}\n\nvoid GetCubeMapIntersection(vec3 ray_origin, vec3 ray_dir, Box box, inout intersection intx, int ID)\n{\n\n     float dz = (sign(ray_dir.z) * MAP_SIZE - ray_origin.z + 5.) / ray_dir.z;\n     float dx = (sign(ray_dir.x) * MAP_SIZE - ray_origin.x) / ray_dir.x;\n     //throwing error when the second normal is set correctly\n     vec3 normal = dz > 0. && dz < dx ? vec3(0,0,-sign(ray_dir.z)): vec3(-1,0,0); \n     float d = min(abs(dz),abs(dx));   \n     if (d > 0. && (intx.collider == NO_COL || d < intx.distance))\n     {  \n        intx.collider = ID;\n        intx.distance = d;\n        intx.normal = normal;\n     }\n}\n\nvoid GetBoxIntersection(vec3 ray_origin, vec3 ray_dir, Box box, inout intersection intx, int ID)\n{\n    vec3 m = 1.0 / ray_dir;\n    vec3 n = m * (ray_origin - box.centre);\n    vec3 k = abs(m) * 0.5 * box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0)\n        return;\n\n    vec3 oN = -sign(ray_dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0. && tN < intx.distance)\n    {\n        intx.distance = tN;\n        intx.normal = oN;\n        intx.collider = ID;\n    }\n\n}\n\nvoid WorldBoxIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    GetBoxIntersection(ray_origin, ray_dir, base, intx, BASE);\n    GetCubeMapIntersection(ray_origin, ray_dir, cubeMap, intx, CUBEMAP);  \n}\n    \nvoid GetCylinderIntersection(vec3 ray_origin, vec3 ray_dir, cylinder cyl, inout intersection intx, int ID)\n{\n   vec3 A = cyl.centre - cyl.axis * (cyl.length * 0.5);\n   vec3 OA = ray_origin - A;\n   float a = dot(ray_dir, ray_dir) -pow(dot(ray_dir, cyl.axis),2.);\n   float b = 2. * (dot(ray_dir,OA) - dot(ray_dir,cyl.axis) * dot(OA, cyl.axis));\n   float c = dot(OA,OA) - pow(dot(OA,cyl.axis),2.) - pow(cyl.radius,2.);\n   \n   float det = b*b - 4.*a*c;\n   if (det<0.)\n       return;\n   float t1 = (-b+sqrt(det))/(2.*a);\n   float t2 = (-b-sqrt(det))/(2.*a);\n   float distance = min(t1,t2);\n   vec3 t = ray_origin + distance * ray_dir;\n   vec3 At = t-A;\n   float axisPos = dot(At, cyl.axis);\n   if (axisPos > cyl.length || axisPos < 0.)\n      return;\n  \n   if (distance >= 0. && (distance < intx.distance || intx.collider == NO_COL))\n   {\n       intx.collider = ID;\n       intx.distance = distance;\n       vec3 point = ray_origin + ray_dir * distance;\n       vec3 c2p = point - cyl.centre;\n       vec3 normal = c2p - dot(c2p, cyl.axis) * cyl.axis;\n       intx.normal = normalize(normal);\n   }\n}\n\nvoid WorldCylinderIntersections(vec3 ray_origin, vec3 ray_dir, inout intersection intx)\n{\n    for (int i = 0; i < frame.length(); i ++)\n    {\n         GetCylinderIntersection(ray_origin, ray_dir, frame[i], intx, FRAME);\n    }\n    for (int i = 0; i < strings.length(); i ++)\n    {\n         GetCylinderIntersection(ray_origin, ray_dir, strings[i], intx, STRINGS);\n    }\n}\n\nintersection GetIntersection(vec3 ray_origin, vec3 ray_dir)\n{\n    intersection intx = intersection(NO_COL,0., vec3(0), vec3(0),vec3(0));\n    \n    GetGroundIntersection(ray_origin, ray_dir, intx);\n    \n    WorldSphereIntersections(ray_origin, ray_dir, intx);\n    \n    WorldBoxIntersections(ray_origin, ray_dir, intx);\n    \n    WorldCylinderIntersections(ray_origin, ray_dir, intx); \n    \n    intx.point = ray_origin + ray_dir * intx.distance;\n    intx.reflectDir = normalize(reflect(ray_dir, intx.normal));\n    \n    return intx;\n    \n}\n\nfloat GetLocalDiffuse(vec3 point, vec3 normal, vec3 ray_dir)\n{\n    vec3 light_dir = normalize(light_pos - point);\n    //check if light is obstructed\n    intersection incomingLight = GetIntersection(point, light_dir);\n    float obstructedModifier = 1.;\n    if (incomingLight.collider != NO_COL && incomingLight.collider != CUBEMAP)\n        obstructedModifier = 0.4;\n    //calculate diffuse value\n    float diffuseIntensity = 0.6 * max(dot(light_dir, normal), 0.);\n    return diffuseIntensity * obstructedModifier + ambientIntensity;\n}\n\n\n\nvec3 GetLocalColor(vec3 ray_dir, intersection intx, inout float multiplier)\n{\n\n    if (intx.collider == NO_COL)\n    {\n        return (0.3 + abs(ray_dir.z)) * skyColor;\n    }\n    \n    vec3 materialColor;\n    float reflectivity;\n    float shininess;\n    \n    if (intx.collider == GROUND)\n    {\n        vec3 col = 0.2 + 0.5*cos(iTime+intx.point.xzx/MAP_SIZE+vec3(0,2,4));\n        materialColor = col;\n        shininess = shininess_ground;\n    }\n    else if (intx.collider == FRAME || intx.collider == PIPEJOINT)\n    {\n        materialColor = frameColor;\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider < BASE)\n    {\n        materialColor = ballColor[BALL[intx.collider]];\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider == BASE)\n    {\n        materialColor = baseColor;\n        shininess = shininess_frame;  \n    }\n    else if (intx.collider == STRINGS)\n    {\n        materialColor = stringColor;;\n        shininess = shininess_string; \n    }\n     else if (intx.collider == CUBEMAP)\n    {\n        materialColor =  cubeMapColor * ((sin(iTime)+1.)*0.3)/(intx.point.y * 0.05);\n        shininess = shininess_cubeMap; \n    }\n    reflectivity = shininess/reflectionDenominator;\n    multiplier *= reflectivity;\n    //diffuse\n    vec3 diffuseColor = GetLocalDiffuse(intx.point, intx.normal, ray_dir) * materialColor;\n    //reflected\n    vec3 light_dir = normalize(light_pos - intx.point);\n    //specular\n    vec3 specular = pow(max(dot(light_dir, intx.reflectDir), 0.), shininess) * vec3(1);\n    \n    return diffuseColor + specular;\n\n}\n\n\nvoid TraverseLightPath(vec3 ray_dir, inout intersection intx, inout vec3 totalColor, inout float multiplier)\n{\n    totalColor += multiplier * GetLocalColor(ray_dir, intx, multiplier);\n    intx = GetIntersection(intx.point, intx.reflectDir);\n}\n\nvec3 GetColor(vec3 ray_origin, vec3 ray_dir)\n{\n    float multiplier = 1.;\n    vec3 totalColor = vec3(0);\n    intersection intx = GetIntersection(ray_origin, ray_dir);\n    \n    for (int i = 0; i < BOUNCES; i ++)\n    {\n        TraverseLightPath(ray_dir, intx, totalColor, multiplier);\n        ray_dir = intx.reflectDir;\n    }\n    totalColor = clamp(totalColor, vec3(0),vec3(1));\n    return totalColor;\n}\n\n\nvoid PositionBalls()\n{\n    float angle = 0.4 * sin(iTime * 3.);\n    //vertical and hoirizonatl components of rotated line\n    float xD1 = 6. * max(sin(angle),0.);\n    float xD2 = 6. * min(sin(angle),0.);\n    float yD1 = 6. - (6. * cos(min(angle,0.)));\n    float yD2 = 6. - (6. * cos(max(angle,0.)));\n    float xDiffs[5] = float[5](xD2, 0.3 * xD2,  0.,  0.3 * xD1 , xD1);\n    float yDiffs[5] = float[5](yD1, 0.3 * yD1,  0.,  0.3 * yD2 , yD2);\n    vec3 spacing = vec3(2,0,0);\n    //string length coefficient\n    float sC = 5./6.;\n    \n    vec3 topPos1 = vec3(-4., 7.75, 8.);\n    vec3 topPos2 = vec3(-4., 7.75, 2.);\n    \n    for(int i = 0; i < balls.length(); i++)\n    {\n        balls[i].xyz = vec3(-4. + xDiffs[i] + spacing.x * float(i), 2. + yDiffs[i], 5.);\n        \n        //calculate string positions\n        \n        vec3 bottomPos = vec3(-4. + 2. * float(i) + xDiffs[i] * sC, 3. + yDiffs[i] * sC, 5.);\n        vec3 position1 = (topPos1 + bottomPos) * 0.5;\n        vec3 axis1 = normalize(topPos1-bottomPos);\n        vec3 position2 = (topPos2 + bottomPos) * 0.5;\n        vec3 axis2 = normalize(topPos2-bottomPos);\n    \n        strings[2 * i] = cylinder(position1, axis1, 6., 0.02);\n        strings[2 * i + 1] = cylinder(position2, axis2, 6., 0.02);\n    \n        topPos1 += spacing;\n        topPos2  += spacing;\n    }\n   \n}\n\n\nvec3 GetRayDir(vec2 uv)\n{\n    vec3 rayScreenIntersection = vec3(cam.pos + uv.x * cam.right + uv.y * cam.up + cam.depth * cam.forward);\n    vec3 rayDir = normalize(rayScreenIntersection - cam.pos);\n    return rayDir;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    light_pos = vec3(15. * sin(iTime / 5.), 20., 5. + 15. * cos(iTime / 10.));\n    PositionBalls();\n    BOUNCES = int(1.5 * iTime/3.14) % 10 + 1;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float iMousex = clamp(iMouse.x, - iResolution.x, iResolution.x);\n    float iMousey = clamp(iMouse.y, - iResolution.y, iResolution.y);\n    cam.pos = cam.target + vec3(10. * sin(iMousex / 100.), 15. * max(sin((1.57 * iMousey - 0.3 *iResolution.y)/iResolution.y),0.) , 10. * cos(iMouse.x/ 100.));\n\n    //align with camera\n    cam.forward = normalize(cam.target - cam.pos);\n    cam.right = normalize(cross(vec3(0., 1., 0.), cam.forward));\n    cam.up = normalize(cross(cam.forward, cam.right));\n    \n    vec3 raydir = GetRayDir(uv);\n    vec3 color = GetColor(cam.pos, raydir);\n\n    // Output to screen\n    fragColor = vec4(color, 01);\n}", "image_inputs": [], "sound_code": "//borrowed from https://www.shadertoy.com/view/sdsXWr\nvec2 mainSound( int samp, float T )\n{\n    float \n        f = 3./3.14,\n        t = fract(T*f),\n        m = smoothstep(.01, 0., t),\n        w = cos(t*1e5);\n    return vec2( w*m );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2349, 2349, 2433, 2475, 2790], [2792, 2792, 2897, 2933, 3831], [3833, 3833, 3920, 3920, 4218], [4220, 4220, 4322, 4322, 4829], [4831, 4831, 4929, 4929, 5430], [5432, 5432, 5516, 5516, 5656], [5662, 5662, 5770, 5770, 6750], [6752, 6752, 6841, 6841, 7121], [7123, 7123, 7184, 7184, 7657], [7659, 7659, 7721, 7721, 8192], [8196, 8196, 8273, 8273, 9768], [9771, 9771, 9881, 9881, 10013], [10015, 10015, 10061, 10061, 10416], [10419, 10419, 10441, 10441, 11743], [11746, 11746, 11771, 11771, 11963], [11967, 11967, 12022, 12022, 12929]], "test": "untested"}
{"id": "cljSDc", "name": "Piano roll", "author": "guil", "description": "Piano roll visualisation of a soundcloud file.", "tags": ["dsp"], "likes": 7, "viewed": 222, "published": 3, "date": "1676744173", "time_retrieved": "2024-07-30T18:09:29.935741", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tfragColor = texture(iChannel0, uv); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//https://soundcloud.com/neilbalfour/prelude-no-1-in-c-major-j-s\n//https://soundcloud.com/glennmorrison/beethoven-moonlight-sonata\n//https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you\n//https://soundcloud.com/nermeen-meawad/moonlight-sonata-beethoven\n//https://soundcloud.com/veillex01/vivaldi-four-seasons\n//https://soundcloud.com/thebestofbach/johann-sebastian-bach-chaconne\n//https://soundcloud.com/claudiocruz/max-bruch-violin-concerto-in-g\n//https://soundcloud.com/guitaristique-fr/diapason\n\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(float n){\n    return pow(Semitone,(n-8.))*440./48000.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    if(uv.x > 1. - pixelSize.x){\n    \n      vec3 col = vec3(0.0);\n      float nBands = 64.0;\n      float i = floor(uv.y*nBands);\n      float f = fract(uv.y*nBands);\n      float band = KeyToFrequency(i);\n      float s = texture( iChannel0, vec2(band,0.25) ).x;\n      s += .2*s*texture( iChannel0, vec2(KeyToFrequency(i+12.),0.25) ).x;\n      s *= s;\n    \n      col= vec3(s,4.*s*(1.-s),(1.-s))*s;\n      \n      vec3 col1 = vec3(0.0);\n      col1 += .5*smoothstep(0.00,0.125,f);\n      if (mod(i,12.)==2.){col1 = vec3(.1);}\n      if (mod(i,12.)==4.){col1 = vec3(.1);}\n      if (mod(i,12.)==7.){col1 = vec3(.1);}\n      if (mod(i,12.)==9.){col1 = vec3(.1);}\n      if (mod(i,12.)==11.){col1 = vec3(.1);}\n      col += col1;\n\n      col *= smoothstep(0.125,0.375,f);\n      col = clamp(col, 0.0, 1.0);\n\t  fragColor = vec4(col,1.0);\n        \n    }else{\n      fragColor = texture(iChannel1, uv + vec2(1,0) * pixelSize);\n    }\n}", "buffer_a_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 144]], "test": "untested"}
{"id": "ctBSWt", "name": "Shatter Flake", "author": "QuantumSuper", "description": "A bit of a flashy one.\nAuto-VJ with snowflake symmetry, use with music in iChannel0", "tags": ["music", "hexagonal"], "likes": 7, "viewed": 423, "published": 3, "date": "1676738369", "time_retrieved": "2024-07-30T18:09:31.044775", "image_code": "// ShatterFlake 0.62.230218\n// auto-vj with snowflake symmetry\n//\n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \nvec4 fft, ffts;\n\nvoid compressFft(){ //compress sound in iChannel0 to simple frequency-range amplitude estimations \n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    fft.x = step(.9,fft.x); //weaken weaker sounds, hard limit\n}\n\nmat2 rotM(float rad){ // rotation matrix in 2D\n    return mat2(cos(rad),-sin(rad),sin(rad),cos(rad));\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 ab = b-a;\n\treturn .005/length(a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.)-p);\n}\n\nfloat rect(vec2 c, vec2 dim){ //c at center of rectangle dim\n    vec2 dv = abs(c/dim)-.5; //dist per axis\n    return 1./max(.0,max(dv.x+dv.y,max(dv.x,dv.y)));\n}\n\nfloat flakeLine(vec2 p, vec2 a, vec2 b){ //hexagonal prism geometry for line\n    return line(abs(p), a, b) + line(abs(p*rotM(PI/3.)), a, b) + line(abs(p*rotM(-PI/3.)), a, b);\n}\n\nfloat flakeRect(vec2 p, vec2 c, vec2 d){ //hexagonal prism geometry for rectangle\n    return rect(abs(p)-c, d) + rect(abs(p*rotM(PI/3.))-c, d) + rect(abs(p*rotM(-PI/3.))-c, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // General initializations\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); // viewport max -1..1\n    float aTime = 1.066667*iTime;\n    compressFft(); //initializes fft, ffts\n\n    // View manipulation\n    float amp = .2*fft.w*hash21(floor(300.12*uv+42.)*cos(aTime)); //noise\n    if (abs(uv.y)<.2*fft.z) uv*=.5+.5*fft.z; //horizontal bar\n    uv *= rotM(sin(aTime/8.))*(1.+.2*sin(aTime/4.)); //rotate & zoom \n    uv = 2.*fract(.5*uv+.5)-1.; //edge repeat\n    \n    // Generate pattern parameters\n    vec2 r = vec2(42.23*floor(aTime), floor(aTime));\n    vec2 r2 = vec2(42.23*ceil(aTime), ceil(aTime));\n    vec2 a1 = vec2(hash21(r),hash21(r*2.345));\n    vec2 a2 = vec2(hash21(r2),hash21(r2*2.345));\n    vec2 a = smoothstep(a1,a2,a1+(-a1+a2)*fract(aTime)); //smoothstepped linear outwards movement\n    vec2 b = .5*fft.xw;\n    if(length(b)<.5) b = vec2(hash21(sin(r)),hash21(r*r))*(.7+.3*fft.w); //default on \"calm\" b in case of low volume  \n    \n    // Draw lines\n    amp += flakeLine(2.5*uv*rotM(-aTime/4.),a,b)+flakeLine(1.25*uv*rotM(-aTime/4.),a,b);\n    vec3 col = vec3(amp*amp); //light falloff correction\n    col *= vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x); //colors;\n    \n    // Draw rectangles\n    amp = fft.x*smoothstep(0.,100., flakeRect(uv, vec2(sin(a1.x),cos(a1.y)), vec2(.1)+a2*(.66+.33*fract(aTime))));\n    col += vec3(amp);\n  \n    // Output\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 164, 243, 1289], [1291, 1291, 1312, 1337, 1394], [1396, 1396, 1417, 1487, 1580], [1582, 1582, 1617, 1657, 1742], [1744, 1744, 1773, 1804, 1904], [1906, 1906, 1946, 1982, 2082], [2084, 2084, 2124, 2165, 2262], [2264, 2264, 2320, 2351, 3797]], "test": "untested"}
{"id": "DtjSW3", "name": "Segmented Displays", "author": "Karp", "description": "Inspired by this video : https://youtu.be/RTB5XhjbgZA", "tags": ["2d"], "likes": 1, "viewed": 129, "published": 3, "date": "1676729489", "time_retrieved": "2024-07-30T18:09:32.288450", "image_code": "//Reminder\nfloat SegmentedNumber(float value, vec2 uv, float thickness, float AA)\n{\n    float result;\n    float line;\n    \n    if(abs(mod(value - 1.,3.)) > .5)\n    {\n        //_ -> 1 4 7 \n        line = sdLine(uv, vec2(-.15,-.4), vec2(.15,-.4)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(value > 1.5 && abs(value-7.) > .5)\n    {\n        //- -> 0 1 7 \n        line = sdLine(uv, vec2(-.15,.0), vec2(.15,.0)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(abs(value-1.)>.5 && abs(value-4.)>.5)\n    {\n        //- top\n        line = sdLine(uv, vec2(-.15,.4), vec2(.15,.4)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(abs(value-2.)>1.5 && abs(value-7.)>.5)\n    {\n        //|- top\n        line = sdLine(uv, vec2(-.2,.05), vec2(-.2,.35)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(mod(value + 1.,2.)>.5 && abs(value-4.)>.5)\n    {\n        //|-\n        line = sdLine(uv, vec2(-.2,-.05), vec2(-.2,-.35)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(abs(value-5.5)>.75)\n    {\n        //-| top\n        line = sdLine(uv, vec2(.2,.05), vec2(.2,.35)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    if(abs(value-2.)>.5)\n    {\n        //-|\n        line = sdLine(uv, vec2(.2,-.05), vec2(.2,-.35)) - thickness;\n        result = mix(result, 1., step(line, 0.));\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy, iResolution.xy);\n    uv *= 0.5;\n    \n    //Parameter\n    float time = iTime;\n    float value = floor(mod(iTime, 10.));\n    float value2 = floor(mod(iTime/10., 10.));\n    float thickness = .025;\n    float AA = .1;\n    \n    //Visu\n    vec3 pix = vec3(0.2);\n    float line;\n    \n    pix = mix(pix, vec3(.8), SegmentedNumber(value, uv + vec2(-.3,.0), thickness, AA));\n    pix = mix(pix, vec3(.8), SegmentedNumber(value2, uv + vec2(.3,.0), thickness, AA));\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "//Constant\n#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//Color\n#define black   vec3(0.0)\n#define grey    vec3(0.5)\n#define white   vec3(1.0)\n//\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n///UV (TextCoord)\nvec2 CenterUV(vec2 fragCoord, vec2 resolution)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5 * resolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 FullScreenUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n    uv = 2.0 * uv.xy / resolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord, vec2 resolution)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy, resolution);\n\tuv = 2.0 * uv.xy / resolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    return uv * mat2( cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n}\n\n///COLOR\nvec3 Color255(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 HSV2RGB(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 RGB2HSV(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\nvec3 HueShiftcolor(vec3 c, float shift)\n{\n    c = RGB2HSV(c);\n    c = vec3(mod(c.x + shift,1.), c.yz);\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Maths\nfloat clamp01(float value) {return clamp(value,0.0,1.0);}\nfloat saturate(float value) {return clamp(value,0.0,1.0);}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 83, 83, 1486], [1488, 1488, 1545, 1568, 2098]], "test": "untested"}
{"id": "dtBXDc", "name": "Raymarching mirror", "author": "maras", "description": "My (probably very stupid) implementation of mirror in raymarching.\nCore of raymarching, SDFs and skybox color taken from IQ`s [url=https://www.shadertoy.com/view/3lsSzf]Happy Jumping[/url].\nCamera is attached to mouse.", "tags": ["raymarching", "reflection", "simple", "mirror"], "likes": 13, "viewed": 327, "published": 3, "date": "1676722549", "time_retrieved": "2024-07-30T18:09:33.281794", "image_code": "float smin(in float a, in float b, float k) {\n    float h = max(k - abs(a-b), 0.0);\n    \n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat sdSphere(in vec3 pos, float rad) {\n    return length(pos) - rad;\n}\n\nfloat sdMirror(vec3 pos) {\n    float mirror = max(pos.x + 1.0, pos.y - 0.8);\n    mirror = max(mirror, abs(pos.z + 0.7) - 0.8);\n    mirror = max(mirror, -pos.x - 1.25);\n    \n    return mirror;\n}\n\nfloat sdFrame(vec3 pos) {\n    float frame = max(pos.x + 1.001, pos.y - 0.9);\n    frame = max(frame, abs(pos.z + 0.7) - 0.9);\n    frame = max(frame, -pos.x - 1.2499);\n    \n    return frame;\n}\n\nfloat map(in vec3 pos, bool reflected, inout float material)\n{\n    float ground = pos.y + 0.25;\n    float sphere = sdSphere(pos + vec3(-0.5, -0.2, 0.8), 0.25);\n    float sphere2 = sdSphere(pos + vec3(-0.95, -0.2, 0.8 + sin(iTime)), 0.25);\n    float mirror = sdMirror(pos);\n    float frame = max(sdFrame(pos), -mirror);\n      \n    float res;\n    \n    res = ground;\n    material = 0.0;\n    \n    float sphere_blend = smin(sphere, sphere2, 0.25);\n\n    if (sphere_blend < res) {\n        res = sphere_blend;\n        material = 1.0;\n        if (sphere2 < sphere)\n            material = 2.0;\n    }\n\n    if (!reflected && frame < res) {\n        res = frame;\n        material = 3.0;\n    }\n\n    if (!reflected && mirror < res) {\n        res = mirror;\n        material = 4.0;\n    }\n        \n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float mat = 0.0;\n    \n    return normalize(  vec3(map(pos+e.xyy, false, mat) - map(pos-e.xyy, false, mat),\n                            map(pos+e.yxy, false, mat) - map(pos-e.yxy, false, mat),\n                            map(pos+e.yyx, false, mat) - map(pos-e.yyx, false, mat)));\n}\n\nfloat castRay (inout vec3 ro, vec3 rd, inout bool reflected, inout float material) {\n    float t = 0.0;\n    int i=0;    \n    for (; i<100; i++) {\n        float map_res = map(ro, reflected, material);\n        float h = map_res;\n        ro += h*rd;\n        \n        if (h < 0.001) {\n            if (material > 3.5) {\n                if (!reflected) {\n                    vec3 norm = calcNormal(ro - 0.001 * rd);\n                    rd = rd - 2.0 * dot(rd,norm) * norm;\n\n                    reflected = true;\n                }\n                t += h;\n                continue;\n            }\n            \n            break;\n        }\n        \n        t += h;\n        \n        if (t > 20.0) {\n            break;\n        }\n    }\n    \n    if (t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nfloat castShadow (vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 pos = ro;\n    bool reflected = false;\n    float material = 0.0;\n    for (int i=0; i<100; i++) {\n        float map_res = map(pos, reflected, material);\n        float h = map_res;\n        pos += h*rd;\n\n        \n        if (h < 0.0001) {\n            break;\n        }\n        \n        t += h;\n        \n        if (t > 20.0) {\n            break;\n        }\n    }\n    \n    if (t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float an_x = 10.0*iMouse.x/iResolution.x + 1.0;//iTime;\n    float an_y = 1.0*iMouse.y/iResolution.y;\n    \n    vec3 ta = vec3(0.0, 0.25, 0.0);\n    vec3 ro = ta + vec3(1.5*sin(an_x), 1.5*sin(an_y), 1.5*cos(an_x));\n    ro *= 1.5;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(vec3(p.x*uu + p.y*vv + 1.8*ww));\n    \n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    col = mix(col, vec3(0.7,0.75,0.8), exp(-10.0*rd.y));\n        \n    bool reflected = false;\n    \n    float material = 0.0;\n    float tp = castRay(ro, rd, reflected, material);\n    float t = tp;\n    vec3 pos = ro;\n    \n    if (t > 0.0) {\n        vec3 nor = calcNormal(pos);\n        \n        float row = floor(mod(pos.x * 2.0, 2.0));\n        float column = floor(mod(pos.z * 2.0, 2.0));\n        \n        vec3 mate = vec3(0.2);\n        if (material < 0.5 && (row < 0.5 || column < 0.5) && !(row < 0.5 && column < 0.5)) mate = vec3(0.1);\n        if (material < 1.5 && material > 0.5) mate = vec3(0.3, 0.2, 0.1);\n        if (material < 2.5 && material > 1.5) mate = vec3(0.1, 0.2, 0.3);\n        if (material < 3.5 && material > 2.5) mate = vec3(0.01);\n        \n        vec3 sun_dir = normalize(vec3(sin(iTime / 5.0), 0.4, cos(iTime / 5.0)));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = step(castShadow(pos+nor*0.001, sun_dir), -0.5);\n        float sky_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        col = mate*vec3(7.0, 5.0, 3.0)*sun_dif*sun_sha;\n        col += mate*vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif;\n    }\n        \n    col = pow(col, vec3(0.4545));\n    if (reflected) {\n        col *= 0.75;\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 125], [127, 127, 167, 167, 199], [201, 201, 227, 227, 394], [396, 396, 421, 421, 586], [588, 588, 650, 650, 1389], [1391, 1391, 1421, 1421, 1738], [1740, 1740, 1824, 1824, 2516], [2518, 2518, 2555, 2555, 2994], [2996, 2996, 3051, 3051, 5037]], "test": "untested"}
{"id": "dl2SD3", "name": "Little Walker Dude", "author": "SnoopethDuckDuck", "description": "doesnt really need music but why not :)", "tags": ["walk", "person"], "likes": 20, "viewed": 237, "published": 3, "date": "1676717481", "time_retrieved": "2024-07-30T18:09:34.130525", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n\n//https://lospec.com/palette-list/verdigris\n#define white vec3(238, 228, 189) / 255.\n#define grey1 vec3(196, 196, 153) / 255.\n#define grey2 vec3(127, 144, 129) / 255.\n#define brown0 vec3(44,  31,  26) / 255.\n#define brown1 vec3(125, 71,  53) / 255.\n#define brown2 vec3(179, 109, 65) / 255.\n#define brown3 vec3(216, 152, 64) / 255.\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSeg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    float k = 1. / res.y;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    vec2 ms = (iMouse.xy - 0.5 * res) / res.y;\n    if (iMouse.z <= 0.)\n        ms = vec2(0.18, -0.1);\n    float t = 0.65 * iTime;\n   \n    float h = -0.25; \n    float r = 0.03;\n    \n    float sw = ms.x;//0.18 * ms.x; // Stride width (x2)\n    float sh = -ms.y; // Stride height\n    \n    //float fr = mod(t, 2.);\n    //float fr2 = mod(t + 1., 2.);\n\n    float y = max(0., -ths(4., pi/2. + pi * t));\n    float y2 = max(0.,ths(4., pi/2. + pi * t));\n    y = pow(y, 14.);\n    y2 = pow(y2, 14.);\n    \n    vec2 pHead = vec2(0, 0.225 + 2. * r * ths(2., 2. * pi * t + 0.1));\n    vec2 pNeck = vec2(0, 0.1 + 2. * r * ths(2., 2. * pi * t + 0.2));\n    vec2 pHip = vec2(0, 2. * r * ths(2., 2. * pi * t ));\n    vec2 pFoot1 = vec2(sw * ths(4., pi*t), h + 0.4*r + 2. * r * y);\n    vec2 pFoot2 = vec2(sw * -ths(4., pi*t), h + 0.4*r + 2. * r * y2);\n    vec2 pHand1 = pNeck - vec2(sw * ths(4.,pi*t), sh * (.5+.5*thc(2.,pi*t)));\n    vec2 pHand2 = pNeck - vec2(sw * -ths(4.,pi*t), sh * (.5+.5*thc(2.,pi*t)));\n    \n    float dHead = length(uv - pHead) - 0.05 - 0.004 *ths(2.,2.*pi*t+0.1);\n    float dBody = sdSeg(uv, pHip, pNeck) - 0.05 - 0.005 *ths(2.,2.*pi*t);\n    vec2 dLeg = vec2(sdSeg(uv, pFoot1, pHip),\n                     sdSeg(uv, pFoot2, pHip)) - 0.9 * r;\n    vec2 m = min(vec2(r), abs(vec2(pFoot1.y, pFoot2.y) - h));\n    vec2 dFoot = vec2(sdBox(uv-pFoot1, vec2(r*r/m.x, m.x)-.4*r)-.4*r,\n                      sdBox(uv-pFoot2, vec2(r*r/m.y, m.y)-.4*r)-.4*r);\n    vec2 dArm = vec2(sdSeg(uv, pNeck, pHand1) - 0.8 * r,\n                     sdSeg(uv, pNeck, pHand2) - 0.8 * r);\n    \n    float d = min(dHead, dBody);\n    //d = min(d, min(dLeg.x, dLeg.y));\n    d = min(d, min(dFoot.x, dFoot.y));\n    d = min(d, min(dArm.x, dArm.y));\n    \n    float sHead = smoothstep(-k, k, -dHead);\n    float sBody = smoothstep(-k, k, -dBody);\n    vec2   sLeg = smoothstep(-k, k, -dLeg);\n    sLeg.x *= step(pFoot1.y - m.x + k, uv.y);\n    sLeg.y *= step(pFoot2.y - m.y + k, uv.y);\n    vec2  sFoot = smoothstep(-k, k, -dFoot);\n    vec2   sArm = smoothstep(-k, k, -dArm);\n    float sGround = smoothstep(-k, k, h - uv.y);\n    \n    float s = smoothstep(-k, k, -d + 0.4 * r);\n    vec2 sLeg2 = smoothstep(-k, k, -dLeg + 0.4 * r); //sloppy\n    sLeg2.x *= step(pFoot1.y - m.x + k, uv.y);\n    sLeg2.y *= step(pFoot2.y - m.y + k, uv.y);\n    s = max(s, max(sLeg2.x, sLeg2.y));\n    \n    vec3 col = vec3(0);    \n    col.r = max(sFoot.x, sLeg.x);\n    col.r = max(col.r, sArm.x);\n    col.g += max(sFoot.y, sLeg.y);\n    col.g = max(col.g, sArm.y);\n    col.b = max(sHead, sBody);\n    \n    vec3 col2 = white;//mix(white, brown0, s);\n    float dHill = -0.5 * h * (1. - cos(4.*uv.x-0.25*pi*t)) - uv.y;\n    float sHill = smoothstep(-k, k, dHill);\n    uv = 2. * (uv + vec2(0.125*pi*(1.- 0.5*t), 0.5*h));\n    float ix = floor(2.*uv.x/pi) + 0.;\n    float fx = mod(uv.x, 0.5*pi) - pi/4.;\n    float test = mod(ix, 2.);\n    \n    float dCircle = length(vec2(fx, uv.y)) - 0.2;\n    float sCircle = smoothstep(-2.*k, 2.*k, dCircle);\n    col2 = mix(col2, grey1, 1.-sHill);\n    col2 = mix(col2, mix(white, grey1, test), (1.-sCircle));\n    col2 = mix(col2, grey2, sGround);\n    col2 = mix(col2, brown0, s);\n    col2 = mix(col2, brown1, col.r);\n    col2 = mix(col2, brown2, col.b);\n    col2 = mix(col2, brown3, col.g);\n    fragColor = vec4(col2,1.0);\n}", "image_inputs": [{"id": 32395, "src": "https://soundcloud.com/lostdogz/sumthin-sumthin-cut-that-untz-premiere?in=user-747537358/sets/2021-playback&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2SD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 506, 506, 606], [608, 608, 643, 643, 723], [725, 725, 771, 771, 890], [892, 892, 949, 949, 4332]], "test": "untested"}
{"id": "dlSXDc", "name": "2D low discrepancy sequence R2", "author": "clauswilke", "description": "2d low discrepancy sequence R2, as described at: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/", "tags": ["2d", "noise", "lowdiscrepancy", "r2curve"], "likes": 4, "viewed": 338, "published": 3, "date": "1676690221", "time_retrieved": "2024-07-30T18:09:34.920413", "image_code": "// 2D Low Discrepancy Sequence\n// Claus O. Wilke, Feb. 2023\n// Licensed CC0, https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// This shader implements the R2 curve described here:\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\n// Plastic constant, https://en.wikipedia.org/wiki/Plastic_number\nconst float phi2 = pow((9. + sqrt(69.)) / 18., 1./3.) + pow((9. - sqrt(69.)) / 18., 1./3.); \n\n// Calculate R2 for index i\nvec2 getR2(float i) {\n    // We're using 1 - 1/phi instead of 1/phi for higher precision,\n    // as explained here: https://www.shadertoy.com/view/mts3zN\n    const float C1 = 1. - 1. / phi2;\n    const float C2 = 1. - 1. / (phi2 * phi2);\n\n    return vec2(fract(i * C1), fract(i * C2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    // number of dots to show\n    float N = mod(100.*iTime + 500., 1000.);\n    \n    vec3 col = vec3(0);\n    for (float i = 0.; i<N; i++) {\n        vec2 uv0 = 2. * getR2(i) - 1.;\n        float d = length(uv0 - uv);\n        if (d < 0.01) {\n            col +=  smoothstep(0.009, 0.008, d) * vec3(.6, .8, 1.);        \n        }\n    }\n       \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSXDc.jpg", "access": "api", "license": "cc0-1.0 OR openssl-ssleay OR apache-2.0", "functions": [[444, 472, 493, 625, 758], [760, 760, 817, 817, 1254]], "test": "untested"}
{"id": "DljXD3", "name": "Foggy mountains", "author": "jarble", "description": "A foggy mountain terrain.", "tags": ["mountains", "snow"], "likes": 17, "viewed": 434, "published": 3, "date": "1676689218", "time_retrieved": "2024-07-30T18:09:35.811032", "image_code": "mat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 C, in vec2 FC )\n{\n    float o,c,i,e,f,s,g,k=.01,p2;\n    vec2 r = iResolution.xy;\n    float t = iTime;\n    for(o++,c++;i++<1e2;g+=min(f,max(.03,e))*.4)\n        {s=2.;vec3 p=vec3((FC.xy-r/s)/r.y*g,g-s),p1=p;\n        p.yz*=rotate2D(-.8);\n        p.z+=t;\n        for(e=f=p.y;s<2e2;s/=.4)\n            p1 = sin(p.yzx*s/2.)/s/2.,\n            p2 = abs(p1.x+p1.y+p1.z),\n            e += p2,\n            f += p2*1.5;\n    o+=(f>k*k?e:-exp(-f*f))*o*k;}\n    c+=e;\n    \n    C = vec4(o);\n    C.rg -= c*.04;\n    \n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(mod(a,1.+a/2.)),b)\n        //mod(floor(mod(a*floor(a/b),1.+a/2.)),b)\n        //mod(floor(mod(a,1.+floor(a/2.)+floor(a/4.)+floor(a/8.))),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  time =\n      (time + mod(time,1.+floor(time)))/2.\n      //mod(time+floor(time/8.),1.+floor(time))+floor(time*8.);\n  ;\n  float s1 = 8.,\n  t=time/(1.+fmod(time,2.)),\n  m3 =\n      fmod(floor(t*s1+fmod(t,s1)),s1)\n      //fmod(floor(t*pow(s1,fmod(t,2.))+fmod(t,s1)),s1)\n  ;\n  t *= s1*s1/(1.+fmod(t/s1,2.));\n  float a = 64.*((1.-sqrt(max(fract(t/s1/s1/2.),fract(t/s1/2.)))))*.2,\n  nb = pow(2.,(m3+1. + fmod(t/s1,s1))/5.+6.5);\n  return abs(.5-vec2(fract(time*nb*.998),fract(time*nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 75], [77, 77, 119, 119, 600]], "test": "untested"}
{"id": "mtSSDc", "name": "Custom spectogram 2", "author": "guil", "description": "Visualize a custom spectrogram of a soundcloud file", "tags": ["dsp"], "likes": 5, "viewed": 243, "published": 3, "date": "1676676518", "time_retrieved": "2024-07-30T18:09:36.637821", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float c = texture(iChannel0, uv).z;\n    c= log(1.+2.*c);\n\tfragColor = vec4(c*c*.2,c*.3,c*.8,0.)*.5; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//https://soundcloud.com/neilbalfour/prelude-no-1-in-c-major-j-s\n//https://soundcloud.com/glennmorrison/beethoven-moonlight-sonata\n//https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you\n//https://soundcloud.com/nermeen-meawad/moonlight-sonata-beethoven\n//https://soundcloud.com/veillex01/vivaldi-four-seasons\n//https://soundcloud.com/thebestofbach/johann-sebastian-bach-chaconne\n//https://soundcloud.com/claudiocruz/max-bruch-violin-concerto-in-g\n//https://soundcloud.com/guitaristique-fr/diapason\n\n\n\nvec2 dft(float y, vec2 v)\n{\n    float c = v.x;\n    float s = v.y;\n    float f = pow(2.,5.*y)*10.;\n    for (int i = 0; i< 512; i++){\n        float x = float(i)/512.;\n        s += (texture(iChannel0, vec2(x,1.)).x-.5)*sin(x*f);\n        c += (texture(iChannel0, vec2(x,1.)).x-.5)*cos(x*f);    \n    }\n    return vec2(s,c);\n    \n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    if(uv.x > 1. - pixelSize.x){\n        \n        vec2 v = texture(iChannel0, uv* vec2(pixelSize.x,0)).xy*2.-1.;\n        vec2 d = dft(uv.y,v);\n        fragColor = vec4(d.x*.5+.5,d.y*.5+.5,1.,0.)*length(d); \n        \n    }else{\n        fragColor = texture(iChannel1, uv + vec2(1,0) * pixelSize);\n    }\n}", "buffer_a_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 207]], "test": "untested"}
{"id": "mtBSWc", "name": "swirly eyes", "author": "pb", "description": "redo of an old shader of mine with more interesting swirly motion", "tags": ["raymarch", "fbm"], "likes": 26, "viewed": 498, "published": 3, "date": "1676672073", "time_retrieved": "2024-07-30T18:09:37.492536", "image_code": "//philip.bertani@gmail.com\n\nfloat numOct  = 5. ;  //number of fbm octaves\nfloat focus = 0.;\nfloat focus2 = 0.;\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 5e5 );\n}\n\nmat2 rot2(float an){float cc=cos(an),ss=sin(an); return mat2(cc,-ss,ss,cc);}\n\n//this is taken from Visions of Chaos shader \"Sample Noise 2D 4.glsl\"\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f); \n    \n    return mix( mix(a,b,u.x), mix(c,d,u.x), u.y);\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(focus - focus2);     //play with this\n    \n    float angle = pi/1.3 + .03*focus;      //play with this\n\n    for (float i=0.; i<numOct; i++) {\n        v += a * noise(p);\n        p.xz = rot2(-angle)*p.xz ;\n        p = 2.*p + shift;\n        a *= .22*(1.+focus+focus2);  //this is the main modification that makes the fbm more interesting\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y * 2.5;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rd = normalize( vec3(uv, -1.2) );  \n    vec3 ro = vec3(0); \n    \n    float delta = iTime / 1.3 ; \n        \n    rd.yz *= rot2(-delta );\n    rd.xz *= rot2(delta*3.);\n    vec3 p = ro + rd;\n\n    float bass = 1.8 + .8 * sin(iTime);  //used to be connected to audioContext.analyser\n    \n    vec2 nudge = vec2( aspectRatio, 0.);\n\n    focus = length(uv + nudge);\n    focus = 1.8/(1.+focus) * bass;\n\n    focus2 = length(uv - nudge);\n    focus2 = 4.5/(1.+focus2*focus2) / bass;\n\n    vec3 q = vec3( fbm3d(p), fbm3d(p.yzx), fbm3d(p.zxy) ) ;\n\n    float f = fbm3d(p + q);\n    \n    vec3 cc = q;\n    cc *= 20.*f;   \n\n    cc.r += 4.5*focus; cc.g+= 2.*focus; \n    cc.b += 7.*focus2; cc.r-=3.5*focus2;    \n    cc /= 20.;\n \n\n    fragColor = vec4( cc,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 157, 219, 277], [279, 279, 299, 299, 355], [357, 427, 448, 448, 742], [744, 744, 765, 765, 1180], [1182, 1182, 1239, 1239, 2114]], "test": "untested"}
{"id": "mlBSWc", "name": "Colorful underwater bubbles II", "author": "mrange", "description": "CCO: Colorful underwater bubbles II\nRecoloring of earlier shader + spherical shading\n", "tags": ["2d", "bubbles"], "likes": 70, "viewed": 1545, "published": 3, "date": "1676667839", "time_retrieved": "2024-07-30T18:09:39.672707", "image_code": "// CCO: Colorful underwater bubbles II\n//  Recoloring of earlier shader + spherical shading\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\nconst float MaxIter = 12.0;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec4 plane(vec2 p, float i, float zf, float z, vec3 bgcol) {\n  float sz = 0.5*zf;\n  vec2 cp = p;\n  vec2 cn = mod2(cp, vec2(2.0*sz, sz));\n  float h0 = hash(cn+i+123.4);\n  float h1 = fract(4483.0*h0);\n  float h2 = fract(8677.0*h0);\n  float h3 = fract(9677.0*h0);\n  float h4 = fract(7877.0*h0);\n  float h5 = fract(9967.0*h0);\n  if (h4 < 0.5) {\n    return vec4(0.0);\n  }\n  float fi = exp(-0.25*max(z-2.0, 0.0));\n  float aa = mix(0.0125, 2.0/RESOLUTION.y, fi); \n  float r  = sz*mix(0.1, 0.475, h0*h0);\n  float amp = mix(0.5, 0.5, h3)*r;\n  cp.x -= amp*sin(mix(3.0, 0.25, h0)*TIME+TAU*h2);\n  cp.x += 0.95*(sz-r-amp)*sign(h3-0.5)*h3;\n  cp.y += 0.475*(sz-2.0*r)*sign(h5-0.5)*h5;\n  float d = length(cp)-r;\n  if (d > aa) {\n    return vec4(0.0);\n  }\n  vec3 ocol = (0.5+0.5*sin(vec3(0.0, 1.0, 2.0)+h1*TAU));\n  vec3 icol = sqrt(ocol);\n  ocol *= 1.5;\n  icol *= 2.0;\n  const vec3 lightDir = normalize(vec3(1.0, 1.5, 2.0));\n  float z2 = (r*r-dot(cp, cp));\n  vec3 col = ocol;\n  float t = smoothstep(aa, -aa, d);\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    t *= mix(1.0, 0.8, z/r);\n    vec3 pp = vec3(cp, z);\n    vec3 nn = normalize(pp);\n    float dd= max(dot(lightDir, nn), 0.0);\n    \n    col = mix(ocol, icol, dd*dd*dd);\n  }\n  col *= mix(0.8, 1.0, h0);\n  col = mix(bgcol, col, fi);\n  return vec4(col, t);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 bgcol0 = vec3(0.1, 0.0, 1.0)*0.1; \n  const vec3 bgcol1 = vec3(0.0, 0.4, 1.0)*0.6;\n  vec3 bgcol = mix(bgcol1, bgcol0, tanh_approx(1.5*length(p)));\n  vec3 col = bgcol;\n\n  for (float i = 0.0; i < MaxIter; ++i) {\n    const float Near = 4.0;\n    float z = MaxIter - i;\n    float zf = Near/(Near + MaxIter - i);\n    vec2 sp = p;\n    float h = hash(i+1234.5); \n    sp.y += -mix(0.2, 0.3, h*h)*TIME*zf;\n    sp += h;\n    vec4 pcol = plane(sp, i, zf, z, bgcol);\n    col = mix(col, pcol.xyz, pcol.w);\n  }\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 32387, "src": "https://soundcloud.com/carbonbasedlifeforms/photosynthesis?si=bee7218328e849c29c9e6564e2de9c2d&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 301, 323, 323, 371], [373, 433, 454, 454, 524], [526, 612, 648, 648, 742], [744, 744, 804, 804, 2035], [2037, 2165, 2193, 2259, 2335], [2337, 2337, 2367, 2367, 2982], [2984, 2984, 3039, 3039, 3211]], "test": "untested"}
{"id": "ctBSDc", "name": "Simple spherical shading", "author": "mrange", "description": "CC0: Simple spherical shading\nI wanted spherical shading with no ray trace step\n", "tags": ["2d", "sphere"], "likes": 9, "viewed": 338, "published": 3, "date": "1676656548", "time_retrieved": "2024-07-30T18:09:40.840585", "image_code": "// CC0: Simple spherical shading\n//  I wanted spherical shading with no ray trace step\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 lightDir = normalize(vec3(1.0, 1.5, 2.0));\n  vec3 col = vec3(0.025);\n\n  float r = 0.75;\n\n  float aa = 2.0/RESOLUTION.y;\n  float z2 = (r*r-dot(p, p));\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    float cd= max(dot(lightDir, cn), 0.0);\n    \n    vec3 ccol = col;\n    ccol = cd*cd*vec3(1.0);\n    float d = length(p)-r;\n    col = mix(col, ccol, smoothstep(0., -2.*aa, d));\n  }\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp =p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.05);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 177, 177, 696], [698, 698, 755, 755, 946]], "test": "untested"}
{"id": "DlSSDc", "name": "BiCubic interpolation test", "author": "djancool", "description": "BiCubic interpolation. Using BiLinear but curving the UVs\nInspired by iq inplementation https://www.shadertoy.com/view/XsfGDn", "tags": ["test", "bicubic", "sampling", "interpolation"], "likes": 0, "viewed": 210, "published": 3, "date": "1676655950", "time_retrieved": "2024-07-30T18:09:41.765112", "image_code": "#define res 8.0\n\nfloat s_curve(float x, float p)\n{\n    float x1 = pow(x, p);\n    float x2 = pow(1.0 - x, p);\n    return x1 / (x1 + x2);\n}\n\nvec2 s_curve2(vec2 x, float p)\n{\n    vec2 x1 = pow(x, vec2(p));\n    vec2 x2 = pow(1.0 - x, vec2(p));\n    return x1 / (x1 + x2);\n}\n\nvec3 hash(vec2 i) {\n  return vec3(fract(sin(dot(i.xy, vec2(12.9898, 78.233))) * 43758.5453),\n              fract(sin(dot(i.xy, vec2(54.323, 21.123))) * 23452.2345),\n              fract(sin(dot(i.xy, vec2(31.432, 93.532))) * 98562.9867));\n}\n\nvec3 tex2D(vec2 uv)\n{\n    uv = fract(uv);\n    uv = floor(uv * res) / res;\n    return hash(uv);\n}\n\nvec3 bilInterp(vec2 uv)\n{\n    float pxl = 1.0 / res;\n    uv -= pxl * 0.5;\n    vec2 blend = fract(uv * res);\n\n    vec3 col_x1 = tex2D(uv + vec2(0.0, 0.0));\n    vec3 col_x2 = tex2D(uv + vec2(pxl, 0.0));\n    vec3 col_y1 = tex2D(uv + vec2(0.0, pxl));\n    vec3 col_y2 = tex2D(uv + vec2(pxl, pxl));\n    \n    vec3 col_x = mix(col_x1, col_x2, blend.x);\n    vec3 col_y = mix(col_y1, col_y2, blend.x);\n    vec3 col = mix(col_x, col_y, blend.y);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x + iTime * 0.02;\n    uv *= 3.0;\n    uv = (uv - vec2(0.0, 0.333));\n    \n    \n    float time_frac = fract(iTime * 0.15);\n    float blend = s_curve(min(time_frac, 1.0 - time_frac) * 2.0, 15.0) * 0.5 + 1.0;\n    \n    \n    // BiCubic Interpolation // inspired from: https://www.shadertoy.com/view/XsfGDn\n    vec2 uvBC = uv + 0.5 / res;\n    uvBC *= res;\n    vec2 uvBC_index = floor(uvBC);\n    vec2 uvBC_fract = fract(uvBC);\n    uvBC = uvBC_index + vec2(s_curve2(uvBC_fract, blend));\n    uvBC = (uvBC - 0.5) / res;\n    // BiCubic Interpolation //\n    \n    // Base color\n    vec3 col = bilInterp(uvBC);\n    \n\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 50, 50, 137], [139, 139, 171, 171, 268], [270, 270, 289, 289, 509], [511, 511, 532, 532, 607], [609, 609, 634, 634, 1062], [1064, 1064, 1121, 1171, 1872]], "test": "untested"}
{"id": "DtSXWc", "name": "Walk on spheres - Neumann BC", "author": "michael0884", "description": "Walk on spheres algorithm that takes into account Neumann boundary conditions", "tags": ["laplace", "neumann", "wos", "dirichet"], "likes": 13, "viewed": 419, "published": 3, "date": "1676655844", "time_retrieved": "2024-07-30T18:09:42.658723", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 vec2Color(vec2 v)\n{\n    float m = length(v);\n    float ang = atan(v.x, v.y)/TWO_PI;\n    return hsv2rgb(vec3(ang, 1.0, m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n    \n    fragColor = vec4(0.5*abs(texelFetch(iChannel0, ivec2(fragCoord), 0).x));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI (2.0 * 3.14159)\n#define MAX_WOS_STEPS 250\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 minSD(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(TWO_PI * ang), sin(TWO_PI * ang));\n}\n\n\n//https://www.shadertoy.com/view/XlGcRh\n\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\n\nuint rotl(uint x, uint r)\n{\n\treturn (x << r) | (x >> (32u - r));\n}\n\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\n\nuint murmur3(uint seed)\n{\n    uint h = 0u;\n    uint k = seed;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 4u;\n\n    return fmix(h);\n}\n\nuint murmur3(uvec4 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.w;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 16u;\n\n    return fmix(h);\n}\n\nuint _seed; \n\nvoid InitRNG(vec2 p, int frame)\n{\n    _seed = murmur3(uvec4(p, uint(frame), uint(p.x) + uint(p.y)));\n}\n\nfloat rand()\n{\n    _seed = murmur3(_seed);\n    return float(_seed)*(1.0/float(0xffffffffu));\n}\n", "buffer_a_code": "// Pseudocode recursive implementation\n//float estimateNeumannU(vec2 p)\n//{\n//  //inverse gradient estimate\n//  vec2 normal = SDF_grad(p);\n//  //gradient is = (u(p + eps*normal) - u(p))/eps = A \n//  // -> u(x) = u(p + eps*normal) - eps*A;\n//  return estimateU(p + eps*normal) - eps * getNeumannBC(p);\n//}\n//\n//float estimateU(vec2 p)\n//{\n//  vec2 sd = SDF(p);\n//  if(sd < eps) \n//  {\n//    if(sd.y == DIRICHLET) return getDirichetU(p);\n//    if(sd.y == NEUMANN) return estimateNeumannU(p);\n//  }\n//  else return estimateU(p + sd.x*Dir(rand()));\n//}\n\n\n#define EPS 5.0\n#define NEPS 15.0\n\nvec2 Boundary(in vec2 p, in vec2 R)\n{\n    vec2 edge = vec2(-sdBox(p - vec2(0.5)*R, R*vec2(0.49)), 0);\n    vec2 obj0 = vec2(sdCircle(p - vec2(0.75)*R, 0.1*R.y),1);\n    vec2 obj1 = vec2(sdBox(p - vec2(0.3)*R, 0.15*R),1);\n    return minSD(edge, minSD(obj0, obj1));\n}\n\nvec2 BoundaryNormal(vec2 p, vec2 R) \n{\n\tconst vec3 k = vec3(1,-1,0);\n\treturn normalize(vec2(Boundary(p + k.xz,R).x - Boundary(p + k.yz,R).x, Boundary(p + k.zx,R).x - Boundary(p + k.zy,R).x));\n}\n\nfloat NeumannBC(vec2 p, vec2 normal)\n{\n    return 0.025*dot(Dir(0.25*iTime), normal);\n}\n\nfloat WOS(vec2 p)\n{\n    float U = 0.0;\n\n    for(int i = 0; i < MAX_WOS_STEPS; i++)\n    {\n        vec2 boundary = Boundary(p, iResolution.xy);\n        float sd = boundary.x;\n        float type = boundary.y;\n        \n        //if(sd < 0.0) return 1.0; //inside of boundary\n        \n        if(sd < 1.0)\n        {\n            if(type == 0.0) //dirichlet \n            {\n                return U;\n            }\n            if(type == 1.0) //neumann \n            {\n                vec2 normal = BoundaryNormal(p, iResolution.xy);\n                U += NeumannBC(p, normal) * NEPS;\n                p += normal * NEPS;\n            }\n        }\n        else p += Dir(rand())*sd;\n    }\n    \n    return 0.0;\n}\n\nvec2 EstimateU(vec2 p)\n{\n    vec2 est = vec2(0.0, 0.00001);\n    vec2 prev = texelFetch(iChannel0, ivec2(p), 0).xy*0.95;\n    est += prev.xy * vec2(prev.y, 1.0);\n    for(int i = 0; i < 8; i++)\n    {\n        est += vec2(WOS(p), 1.0);\n    }\n    return vec2(est.x/est.y, est.y);\n}\n\nvec3 EstimateGradU(vec2 p)\n{\n    vec3 est = vec3(0.0, 0.0, 0.00001);\n    float sd = Boundary(p, iResolution.xy).x;\n    if(sd <= 0.0) return vec3(0.0);\n    for(int i = 0; i < 1; i++)\n    {\n        vec2 n = Dir(rand());\n        est += vec3(100.0* n * WOS(p + n*sd) / sd, 1.0);\n    }\n    return vec3(est.xy/est.z, est.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRNG(fragCoord, iFrame);\n    \n    fragColor.xy = EstimateU(fragCoord);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 217, 217, 322], [324, 324, 381, 381, 497]], "test": "untested"}
{"id": "DlBXD3", "name": "Fork modmunch DJDoomz 256", "author": "DJDoomz", "description": "it looks like a little city\n(any smart ideas on how to make it look smoother?)", "tags": ["2d", "int", "bitwise", "munching"], "likes": 10, "viewed": 177, "published": 3, "date": "1676651238", "time_retrieved": "2024-07-30T18:09:43.414702", "image_code": "const int COMPLEXITY = 26;\nconst float FRAMERATE = 10.0;\nconst float SCALE = .3;\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= SCALE;\n    u.y += 221.;\n    //u += 10.*iTime;\n    //float zor = float(int(u.x)^ int(u.y));\n    \n\to=vec4((((int(u.x)^ int(u.y))+int(iTime*FRAMERATE))%COMPLEXITY))*.2;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clBXWV", "name": "dumb bouncing ball", "author": "oudend", "description": "ball", "tags": ["ball"], "likes": 0, "viewed": 100, "published": 3, "date": "1676636358", "time_retrieved": "2024-07-30T18:09:44.184643", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x  / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = .5 + .8*cos(iTime*.1*vec3(0,1,4) );\n    \n    vec4 BufferA = texture(iChannel0, uv);\n    \n    fragColor = vec4(BufferA.w * col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float distToEdge(vec2 pos)\n{\n    return min( 1. - max(pos.x, pos.y), min(pos.x, pos.y) );\n}\n\nbool collision( vec2 pos, float size )\n{\n    return distToEdge(pos) <= size;\n\n    if(distToEdge(pos) <= size)//size * 50.) //I'm gonna add more conditions, this is what peak performance looks like except I wasted 30 seconds typing this comment.\n    {\n        return true;\n    }\n    return false;\n}\n\nvec2 radianToVector(float radian)\n{\n    return vec2(cos(radian),sin(radian));\n}\n\nfloat vectorToRadian(vec2 vector)\n{\n    return atan(vector.y, vector.x);\n}\n\nfloat angleReflect(float normal, float radian){\n  return radian - 2. * dot( radian, normal) * normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    vec2 resRatio = vec2(ratio * .5, 1. / ratio); \n    \n    bool initialized = iTime > 1.;\n    \n    //bool initialized2 = mod(iTime, 2.5) > 1.;\n    \n    //float distanceToBall = distance(uv*resRatio, ballPos*resRatio);\n    \n    vec4 ballData = texture(iChannel0, vec2(0.5,0.5) / iResolution.xy);\n    \n    vec2 ballPos = vec2(ballData.x, ballData.y);\n    \n    float ballDirection = ballData.z;\n    \n    float ballSpeed = ballData.w;\n    \n    float distanceToBall = distance(uv*resRatio, ballPos*resRatio);\n    \n    \n    if(initialized && fragCoord == vec2(.5, .5))\n    {\n        vec2 directionVector = radianToVector(ballDirection * PI);\n    \n        vec2 futureBallPos = (ballPos + directionVector*ballSpeed);\n    \n        if( collision( futureBallPos, ballSize * ratio ) ) {\n            float edgeDist = distToEdge(futureBallPos);\n            directionVector = directionVector * vec2( (edgeDist == futureBallPos.x || edgeDist == 1. - futureBallPos.x) ? -1. : 1., (edgeDist == futureBallPos.y || edgeDist == 1. - futureBallPos.y) ? -1. : 1.  ); //angleReflect( mod( ballDirection + (PI/2.)/PI, 1. ), ballDirection );\n        }\n        \n        ballDirection = vectorToRadian(directionVector) / PI;\n        \n        //directionVector = radianToVector(ballDirection * PI);\n    \n        futureBallPos = (ballPos + directionVector*ballSpeed);\n    \n        fragColor = vec4(futureBallPos,ballDirection,ballSpeed);\n        return;\n    }\n    \n    if(initialized && distanceToBall < ballSize)  \n    {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    if(!initialized && fragCoord == vec2(0.5, 0.5))\n    {\n        vec2 ballPos = vec2(.2, .2);\n        float ballDirection = mod(iDate.w, 1.);\n        float ballSpeed = .009 * 4.;\n    \n        fragColor = vec4(ballPos,ballDirection,ballSpeed);\n        return;\n    } else if(!initialized)//&& distanceToBall < ballSize )// || ( distanceToCenter < circleSize + .01 && distanceToCenter > circleSize ) ) )// && uv.y == 0.)\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    \n    vec4 BufferB = vec4(0.0,0.0,0.0,0.0);//texture(iChannel0, uv);\n    \n    fragColor = BufferB;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 BufferA = texture(iChannel0, uv);\n\n    fragColor = BufferA;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926538\n\nfloat ballSize = .01;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 384]], "test": "untested"}
{"id": "mljSWV", "name": "Burning inferno 2", "author": "guil", "description": "Smoke/lava effect", "tags": ["smoke", "lava", "inferno"], "likes": 22, "viewed": 694, "published": 3, "date": "1676635014", "time_retrieved": "2024-07-30T18:09:45.062297", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n#define time -iTime \n\nmat2 R(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(2.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n\tvec3 q=p;\n\tfor(e=f=p.y;s<4e2;s/=.6)\n            p.xz*=R(s),\n            q=p,\n            q.x+=time*.2*log(s),\n            e+=abs(dot(sin(q.xz*s*.1)/s,l.xz*2.))*.9,\n            f+=abs(dot(sin(p*s*.15)/s,l)),\n            p.x+=time*.0005*s;\n\to = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.07)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.03;\n        col = .95*col+ .015*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    p *=2.;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=R(-1.5); \n    ro.y +=4.;\n    ro.xz*=R(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljSWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[141, 141, 158, 158, 205], [227, 269, 292, 292, 632], [635, 635, 672, 672, 965], [968, 968, 1025, 1025, 1688]], "test": "untested"}
{"id": "dl2SWK", "name": "Asteroid short version", "author": "guil", "description": "Hacked from yonatan mountains\nhttps://twitter.com/User2E32/status/1443544969847918593", "tags": ["dust", "asteroid"], "likes": 12, "viewed": 344, "published": 3, "date": "1676629657", "time_retrieved": "2024-07-30T18:09:45.990815", "image_code": "#define r(a)   mat2(cos(a+vec4(0,11,33,0)))          //\n#define S      abs(dot( r/r, sin(p*s\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float o=1.,i=0.,e,f,s,g=i,k=.004;\n   \n    for(; i++ < 1e2; g += min(f,max(.05,e))*.6 )\n      { s = 2.;\n        vec3 r = iResolution, \n             p = vec3( g* ( U - r.xy/s ) / r.y, g-s );\n        p.yz *= r(-.8);\n        p.z += iTime/4.;\n        for( e = p.y/4.,f=-.6 ; s<2e2; s/=.6 )\n            p.xz *= r(s),\n            e += S   )/s)),\n            f += S*.3)/s));\n            o += f>k ? e*k: -k/exp(f*f);\n        }        \n    C = .8 - exp(-o) + f*vec4(f*f, f, 1,0)*.2;\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2SWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dtjXWK", "name": "Encoding and drawing numbers", "author": "krax", "description": "Demo of a thing I made here:\nhttps://alister-chowdhury.github.io/posts/20230120-simplifying-drawing-numbers-on-the-gpu/\n\nCompacts numbers into a single u32 for drawing.\n\nNumbers drawn here are:\n* iTime\n* sin(iTime)\n* cos(iTime)\n* iTime^5\n* rcp(iTime)", "tags": ["text", "utility", "numbers", "font", "digits"], "likes": 7, "viewed": 340, "published": 3, "date": "1676623394", "time_retrieved": "2024-07-30T18:09:46.956233", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float padding = .1;\n    float numNumbersToDraw = 5.;\n    float coordScaling = min(iResolution.x/8., iResolution.y/numNumbersToDraw);\n    vec2 uv = fragCoord * vec2(1./8., 1.) / coordScaling;\n\n    int numId = int(uv.y);\n    uv.y = fract(uv.y);\n    uv = uv * (1. + 2.*padding) - padding;\n    bool valid = (numId < int(numNumbersToDraw)) && (min(uv.x, uv.y) > 0.) && (max(uv.x, uv.y) < 1.);\n    \n    float x = iTime;\n    switch(numId)\n    {\n        case 3: { x = sin(x); break; }\n        case 2: { x = cos(x); break; }\n        case 1: { x = x * x * x * x * x; break; }\n        case 0: { x = 1./x; break; }\n    }\n \n    uint encoded = encodeNumber(x);\n    uint signedValue = sampleEncodedNumber(encoded, uv);\n\n    vec3 bgCol = vec3(.251, .027, .471);\n    vec3 fgCol = vec3(0., .835, 1.);\n    fragColor = vec4(mix(bgCol, fgCol, vec3(float(signedValue) * float(valid))), 1.);\n}\n\n", "image_inputs": [], "common_code": "// This contains logic for encoding and drawing numbers.\n//\n// The encoding logic is based off:\n// https://github.com/alister-chowdhury/impl-function-ref/blob/master/generic/encode_number_for_gpu_rendering.inl\n//\n// The way this works is by packing a u32 with 8 characters (4 bits per character).\n// This is useful because it requires a fixed amount of storage and max triangle count.\n// If the number doesn't fit into the budget (8 characters), engineering notation is used instead.\n//\n//\n// The drawing part uses a 5x6 1bpp font (30bits), with each character encoded into a\n// uint that can be sampled from.\n//\n// Functions:\n//  uint encodeNumber(uint value);\n//  uint encodeNumber(int value);\n//  uint encodeNumber(float value);\n//\n//  uint sampleEncodedDigit(uint encodedDigit, vec2 uv);\n//  uint sampleEncodedNumber(uint encodedNumber, vec2 uv);\n//  uint sampleEncodedNumber(uvec2 encodedNumber, vec2 uv);\n//\n// It's worth noting `sampleEncodedNumber` will scale the UV.x by 1.2\n// to add a logical 1px padding.\n// So you should be aiming to draw a box with an aspect ratio of 6:1\n//\n// https://alister-chowdhury.github.io/posts/20230120-simplifying-drawing-numbers-on-the-gpu/\n\n\n// GL = Y starts at the bottom\n// DX = Y starts at the top\n#ifndef Y_STARTS_AT_BOTTOM\n#define Y_STARTS_AT_BOTTOM 1\n#endif\n\n\n// Encoding logic\n\n#define GPU_NUMBER_ENCODING_E        10u\n#define GPU_NUMBER_ENCODING_DOT      11u\n#define GPU_NUMBER_ENCODING_PLUS     12u\n#define GPU_NUMBER_ENCODING_NEG      13u\n#define GPU_NUMBER_ENCODING_INVALID  14u\n#define GPU_NUMBER_ENCODING_EMPTY    15u\n\n#define INV_LN_10 0.434294481903251827651128918916605082294397005803666566\n\n#define pow10(x)            pow(10., float(x))\n#define floorLog10(x)       floor(log(x) * INV_LN_10)\n\n\nfloat fractInputReturnFloor(inout float x)\n{\n    float floored = floor(x);\n    x -= floored;\n    return floored;\n}\n\nstruct RepBuffer\n{\n    uint    data;\n    uint    index;\n};\n\n\nRepBuffer RepBuffer_init()\n{\n    RepBuffer repBuffer;\n    repBuffer.data = 0u;\n    repBuffer.index = 0u;\n    return repBuffer;\n}\n\nvoid RepBuffer_push(inout RepBuffer repBuffer, uint value)\n{\n    repBuffer.data |= ((~value) & 15u) << (4u * repBuffer.index++);\n}\n\nvoid RepBuffer_pop(inout RepBuffer repBuffer, uint count)\n{\n    if(count > repBuffer.index) { count = repBuffer.index; }\n    uint mask = ~0u;\n    mask >>= ((count - repBuffer.index) * 4u);\n    repBuffer.data &= mask;\n    repBuffer.index -= count;\n}\n\n\nuint RepBuffer_remainingSpace(RepBuffer repBuffer)\n{\n    return 8u - repBuffer.index;\n}\n\n\nuint RepBuffer_get(RepBuffer repBuffer)\n{\n    return ~repBuffer.data;\n}\n\n\nuint RepBuffer_getZero()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, 0u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    RepBuffer_push(repBuffer, 0u);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getNan()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_INVALID);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_INVALID);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getPosInf()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    return RepBuffer_get(repBuffer);\n}\n\nuint RepBuffer_getNegInf()\n{\n    RepBuffer repBuffer = RepBuffer_init();\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_PLUS);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    RepBuffer_push(repBuffer, 9u);\n    return RepBuffer_get(repBuffer);\n}\n\n\nRepBuffer encodeWholeNumber(float x, bool isInteger)\n{\n\n    RepBuffer repBuffer = RepBuffer_init();\n\n    if(x < 0.)\n    {\n        x = -x;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    }\n\n    int e10 = int(floorLog10(x));\n    float d10 = pow10(-e10);\n\n    // Scale down\n    x *= d10;\n\n    // Apply rounding logic\n    x += 0.5f * pow10(-int(RepBuffer_remainingSpace(repBuffer)) + 2);\n\n    // Deal with really odd case\n    // where we round up enough to\n    // change our current number\n    if(x >= 10.0f)\n    {\n        x *= 0.1f;\n        ++e10;\n    }\n\n    // Numbers >= 1, will also omit 0 for decimal numbers\n    if(e10 >= 0)\n    {\n        for(int i=0; i<=e10; ++i)\n        {\n            uint decimal = uint(fractInputReturnFloor(x));\n            x *= 10.0f;\n            RepBuffer_push(repBuffer, decimal);\n        }\n\n        // stop on whole numbers or if we'd just write a single decimal place\n        if(isInteger || (RepBuffer_remainingSpace(repBuffer) <= 1u))\n        {\n            return repBuffer;\n        }\n    }\n\n\n    // Decimals\n    {\n        // Include decimal place as zero we wish to strip\n        uint writtenZeroes = 1u;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n\n        // Fill in 0's\n        for(int i=0; i<(-e10-1); ++i)\n        {\n            RepBuffer_push(repBuffer, 0u);\n            ++writtenZeroes;\n        }\n\n        // Use the remaining space for anything left\n        uint budget = RepBuffer_remainingSpace(repBuffer);\n        for(uint i=0u; i<budget; ++i)\n        {\n            uint decimal = uint(fractInputReturnFloor(x));\n            x *= 10.0f;\n            if(decimal == 0u)\n            {\n                ++writtenZeroes;\n            }\n            else\n            {\n                writtenZeroes = 0u;\n            }\n            RepBuffer_push(repBuffer, decimal);\n        }\n\n        // Clear trailing 0's and possibly the decimal place\n        RepBuffer_pop(repBuffer, writtenZeroes);\n    }\n\n    return repBuffer;\n}\n\n\nRepBuffer encodeWholeNumber(float x)\n{\n    return encodeWholeNumber(x, floor(x) == x);\n}\n\n\nRepBuffer encodeWholeNumber(int x)\n{\n    return encodeWholeNumber(float(x), true);\n}\n\n\nRepBuffer encodeWholeNumber(uint x)\n{\n    return encodeWholeNumber(float(x), true);\n}\n\n\nRepBuffer encodeEngNotation(float x)\n{\n\n    RepBuffer repBuffer = RepBuffer_init();\n\n    if(x < 0.)\n    {\n        x = -x;\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_NEG);\n    }\n\n    int e10 = int(floorLog10(x));\n    float d10 = pow10(-e10);\n\n    // Scale down\n    x *= d10;\n\n    uint budget = RepBuffer_remainingSpace(repBuffer);\n\n    // X.e+X\n    budget -= 5u;\n    if(abs(e10) >= 10)\n    {\n        budget -= 1u;\n    }\n\n    // Apply rounding logic\n    x += 0.5f * pow10(-int(budget));\n\n    // Deal with really odd case\n    // where we round up enough to\n    // change our current number\n    if(x >= 10.0f)\n    {\n        x *= 0.1f;\n        // Even odder case where our budget decreases\n        if(++e10 == 10)\n        {\n            budget -= 1u;\n        }\n    }\n\n    // First number and a dot\n    {\n        uint decimal = uint(fractInputReturnFloor(x));\n        x *= 10.0f;\n        RepBuffer_push(repBuffer, decimal);\n        RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_DOT);\n    }\n\n\n    while(budget != 0u)\n    {\n        uint decimal = uint(fractInputReturnFloor(x));\n        x *= 10.0f;\n        RepBuffer_push(repBuffer, decimal);\n        --budget;\n    }\n\n    RepBuffer_push(repBuffer, GPU_NUMBER_ENCODING_E);\n    RepBuffer_push(repBuffer, (e10 < 0) ? GPU_NUMBER_ENCODING_NEG : GPU_NUMBER_ENCODING_PLUS);\n\n    if(e10 < 0)\n    {\n        e10 = -e10;\n    }\n\n    // NB: We only handle two digit exponents (which is fine for floats)\n    if(e10 >= 10)\n    {\n        RepBuffer_push(repBuffer, uint(e10 / 10));\n    }\n\n    RepBuffer_push(repBuffer, uint(e10) % 10u);\n\n    return repBuffer;\n}\n\n\nbool requiresEngineerNotation(float value)\n{\n    // This is the maximum float we can represent as an integer.\n    // before errors start emerging, (8000011 will output 8000012).\n    // Found purely by brute force.\n    const float maxValidFloat = 8000010.0f;\n    if(value == 0. || value == -0.) return false;\n    if(value < 0.)\n    {\n        value = -value;\n        return !(value <= maxValidFloat && value >= 0.001);\n    }\n    return !(value <= maxValidFloat && value >= 0.0001);\n}\n\n\nbool requiresEngineerNotation(int value)\n{\n    if(value < 0)\n    {\n        value = -value;\n        return !(value < 10000000);\n    }\n    return !(value < 100000000);\n}\n\n\nbool requiresEngineerNotation(uint value)\n{\n    return !(value < 100000000u);\n}\n\n\nuint encodeNumber(uint value)\n{\n    if(value == 0u) { return RepBuffer_getZero(); }\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(float(value)); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\nuint encodeNumber(int value)\n{\n    if(value == 0) { return RepBuffer_getZero(); }\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(float(value)); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\nuint encodeNumber(float value)\n{\n    if(value == 0.)      { return RepBuffer_getZero(); }\n    if(isnan(value))    { return RepBuffer_getNan(); }\n    if(isinf(value))\n    {\n        if(value > 0.)\n        {\n            return RepBuffer_getPosInf();\n        }\n        return RepBuffer_getNegInf();\n    }\n\n    RepBuffer buf;\n    if(requiresEngineerNotation(value)) { buf = encodeEngNotation(value); } else { buf = encodeWholeNumber(value); }\n    return RepBuffer_get(buf);\n}\n\n\n\n//// Drawing logic\n\n// .###. ..#.. .###. ##### #...# ##### .#### ##### .###. .###.\n// #..## .##.. #...# ....# #...# #.... #.... ....# #...# #...#\n// #.#.# ..#.. ...#. ..##. #...# ####. ####. ...#. .###. #...#\n// ##..# ..#.. ..#.. ....# .#### ....# #...# ..#.. #...# .####\n// #...# ..#.. .#... #...# ....# ....# #...# ..#.. #...# ....#\n// .###. .###. ##### .###. ....# ####. .###. ..#.. .###. .###.\n//\n// ..... ..... ..... ..... ..... .....\n// .###. ..... ..... ..... .#.#. .....\n// #...# ..... ..#.. ..... ##### .....\n// ##### ..... .###. .###. .#.#. .....\n// #.... .##.. ..#.. ..... ##### .....\n// .###. .##.. ..... ..... .#.#. .....\n\nuint numberPixels[16] = uint[16](\n#if !Y_STARTS_AT_BOTTOM\n    0x1d19d72eu, 0x1c4210c4u, 0x3e22222eu, 0x1d18321fu,\n    0x210f4631u, 0x1f083c3fu, 0x1d18bc3eu, 0x0842221fu,\n    0x1d18ba2eu, 0x1d0f462eu, 0x1c1fc5c0u, 0x0c600000u,\n    0x00471000u, 0x00070000u, 0x15f57d40u, 0x00000000u\n#else\n    0x1d9ace2eu, 0x0862108eu, 0x1d14105fu, 0x3f06422eu,\n    0x2318fa10u, 0x3e17c20fu, 0x3c17c62eu, 0x3f041084u,\n    0x1d17462eu, 0x1d18fa0eu, 0x00e8fc2eu, 0x000000c6u,\n    0x00023880u, 0x00003800u, 0x00afabeau, 0x00000000u\n#endif\n);\n\n\nuint sampleEncodedDigit(uint encodedDigit, vec2 uv)\n{\n    if(uv.x < 0. || uv.y < 0. || uv.x >= 1. || uv.y >= 1.) return 0u;\n    uvec2 coord = uvec2(uv * vec2(5., 6.));\n    return (numberPixels[encodedDigit] >> (coord.y * 5u + coord.x)) & 1u;\n}\n\n\n// 8 character variant\nuint sampleEncodedNumber(uint encodedNumber, vec2 uv)\n{\n    // Extract the digit ID by scaling the uv.x value by 8 and clipping\n    // the relevant 4 bits.\n    uv.x *= 8.0;\n    uint encodedDigit = (encodedNumber >> (uint(uv.x) * 4u)) & 0xfu;\n    \n    // Put the U in between then [0, 1.2] range, the extra 0.2 is add a\n    // logical 1px padding.\n    // (6/5, where 5 is the number of pixels on the x axis)\n    uv.x = fract(uv.x) * 1.2;\n\n    return sampleEncodedDigit(encodedDigit, uv);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 933]], "test": "untested"}
{"id": "cljXWV", "name": "Asteroids and dust", "author": "guil", "description": "Asteroid field with dust clouds.", "tags": ["cloud", "asteroid"], "likes": 13, "viewed": 345, "published": 3, "date": "1676620439", "time_retrieved": "2024-07-30T18:09:47.801972", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n\t\n\tfor(e=p.y/2.-.8,f=-.5; s<4e2; s*=1.6)\n            p.xz*=rot(1.),\n            e+=abs(dot(sin(p*s)/s,l)),\n            f+=abs(dot(sin(p*s*.5)/s,l));\n\n    o = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.5)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 1., dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.035;\n        col = .95*col+ .09*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5); \n    ro.y +=3.;\n    ro.xz*=rot(sin(0.1*t));\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljXWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [210, 252, 275, 275, 528], [531, 531, 568, 568, 850], [853, 853, 910, 910, 1570]], "test": "untested"}
{"id": "Dt2XDK", "name": "color blocks test", "author": "tianluo97", "description": "color blocks test", "tags": ["colorblockstest"], "likes": 0, "viewed": 148, "published": 3, "date": "1676615332", "time_retrieved": "2024-07-30T18:09:48.549972", "image_code": "// c64 palette\n\nvec3 color1 = vec3(0.678,0.922,1.000);// white\nvec3 color2 = vec3(0.302,0.788,1.000); // red\nvec3 color3 = vec3(0.400,0.878,1.000);// cyan\nvec3 color4 = vec3(0.302,0.659,0.796);// violet\nvec3 color5 = vec3(0.208,0.455,0.553);// green\nvec3 color6 = vec3(0.592,0.863,0.949);// blue\n//vec3 color7 = vec3(0.278,0.831,1.000);// yellow\n\n\nfloat gradientStep(float edge0, float edge1, float x)\n{\n    return smoothstep(edge0, edge1, x);\n\n    // smootherstep\n    //x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    //return x*x*x*(x*(x*6. - 15.) + 10.);\n    \n    // linear\n    //x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    //return x;\n}\n\nvec3 gradient(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6)\n{\n    const float colCount = 6.;\n    const float bandSize = 1./(colCount- 1.);\n    const float plateauSize = 0. * (bandSize/2.);\n    float i = 0.;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*i++))))\n        ;\n}\n\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float offset1 = iTime*0.04;\n    offset1 = uv.x - offset1;\n    float x1 = mod(offset1,1.0);\n    \n    float offset2 = iTime*0.04;\n    offset2 = uv.x + offset2;\n    float x2 = mod(offset2,1.0);\n    \n    float offset3 = iTime*0.04;\n    offset3 = uv.x - offset3;\n    float x3 = mod(offset3,1.0);\n    \n    if (uv.y < 0.37)\n        fragColor = vec4(gradient(x1 , color1, color2, color3, color4, color5, color1),1);\n    else if(uv.y < 0.676)\n        fragColor = vec4(gradient(x2 ,  color2, color3, color4, color5, color1,color2),1);\n    else\n        fragColor = vec4(gradient(x3 , color3, color4, color5, color1, color2, color3),1);\n    \n    // band\n    float f = fract(uv.y*3.0);\n    // borders\n    //fragColor.rgb *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    // shadowing\n    //fragColor.rgb *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n    \n    fragColor = sqrt(fragColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2XDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 403, 403, 656], [658, 658, 736, 736, 1441], [1593, 1593, 1650, 1687, 3131]], "test": "untested"}
{"id": "Dt2XWK", "name": "Liquid Disco", "author": "wyatt", "description": "fluid", "tags": ["fluid"], "likes": 16, "viewed": 337, "published": 3, "date": "1676607019", "time_retrieved": "2024-07-30T18:09:49.369780", "image_code": "Main \n{\n    vec4 f = A(U);\n    Q = f.wwww*abs(sin(iTime+6.2*f.z+vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat erf(in float x) {\n    x *= 1.;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "buffer_a_code": "Main\n{\n    vec4 dQ = Q = vec4(0);\n    U -= .5;\n    for (float x = -4.; x<=4.;x++)\n    for (float y = -4.; y<=4.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec2 v = u+a.xy;\n        float w = erfstep(-.5,.5,v.x)*\n                  erfstep(-.5,.5,v.y);\n        dQ.xyz += w*a.w*a.xyz;\n        dQ.w   += w*a.w;\n    }\n    if (dQ.w>0.)\n    {\n        dQ.xyz/=dQ.w;\n        Q = dQ;\n    }\n    Q.xy *= .9;\n    Q.w += 1e-4;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.w = 1.;\n    if (iFrame < 1) {Q = vec4(0,0,0,.5+.01*sin(3.1*U.x)+.01*sin(3.1*U.y));}\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n        \n    Q = A(U);\n    vec4 dQ = vec4(0);\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++)\n    if(x!=0.||y!=0.)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = a.w*(a.w-2.);\n        dQ.xy -= .5*f*u/dot(u,u);\n    }\n    Q += dQ;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2XWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dlSSDV", "name": "Simple raymarched gyroid", "author": "fishy", "description": "I thought the formula from https://www.shadertoy.com/view/3sKfWy was too simple to be true, so I had to test it. It works well as long as you march with a smaller step factor", "tags": ["raymarching"], "likes": 6, "viewed": 211, "published": 3, "date": "1676598429", "time_retrieved": "2024-07-30T18:09:50.127753", "image_code": "#define AA 6.0\n#define FOCAL_LEN 1.\n\n#define AO_STR 1.\n#define AO_DIST 0.03\n#define AO_POW 2.\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#define saturate(x) clamp(0.0, 1.0, x)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    float scale = 0.06;\n    p /= scale;\n    //p = rotZ(p, iTime);\n    float d = sin(p.x)*cos(p.y) + sin(p.y)*cos(p.z) + sin(p.z)*cos(p.x);\n    d = abs(d)-0.03;\n    intersect(d, sdBox(p, vec3(5.)));\n    //join(d, sdBox(p, vec3(10., 30., 10.)));\n    outMat = marchMat(vec3(0.9), 0);\n    d *= scale;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat)*0.6;\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.00001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982+iTime*0.2) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    float lighting = dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))+0.1*max(0., n.z);\n    float ao = 1.-pow(0.9-saturate(sceneDist(res.pos+AO_DIST*n)/AO_DIST), AO_POW);\n    \n    vec3 envMap = texture(iChannel0, reflect(rd, n), texture(iChannel2, res.pos*0.5).r*5.0).rgb;\n    envMap *= envMap;\n    \n    res.mat.color = res.mat.color + envMap*1.0;\n\n    return displayVar(mix(vec3(0.9), res.mat.color*lighting*mix(1., ao, AO_STR), vec3(res.hit)));\n    //return displayVar(ao);\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    res += getColorAtPix(fc, m);\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            res += getColorAtPix(fc + (hash22((x+iTime+fc)*25.)-0.5), m);\n        }\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = sqrt(col) + displayVar(printFR((fragCoord-iResolution.xy*0.5)/iResolution.y*0.55, iFrameRate));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 117, 117, 255], [257, 257, 278, 278, 414], [456, 456, 500, 500, 536], [538, 538, 577, 577, 617], [619, 619, 668, 668, 765], [767, 767, 788, 788, 837], [840, 840, 868, 868, 903], [905, 905, 933, 933, 968], [970, 970, 998, 998, 1033], [1035, 1035, 1181, 1181, 1265], [1402, 1402, 1436, 1436, 1454], [1455, 1455, 1495, 1495, 1512], [1514, 1514, 1569, 1569, 1650], [1652, 1652, 1708, 1708, 1806], [1808, 1808, 1868, 1868, 1909], [1911, 1911, 1971, 1971, 2015], [2017, 2017, 2050, 2050, 2076], [2078, 2078, 2118, 2118, 2205], [2207, 2207, 2247, 2247, 2325], [2327, 2327, 2365, 2365, 2395], [2397, 2397, 2431, 2431, 2478], [2480, 2480, 2523, 2523, 2574], [2576, 2576, 2641, 2641, 2753], [2755, 2755, 2801, 2801, 3114], [3116, 3116, 3141, 3141, 3187], [3189, 3189, 3263, 3263, 3648], [3650, 3650, 3689, 3689, 3952], [3954, 3954, 3991, 3991, 4915], [4917, 4917, 4949, 4949, 5168], [5170, 5170, 5206, 5206, 5477], [5479, 5479, 5536, 5536, 5698]], "test": "untested"}
{"id": "dtSSDV", "name": "Interactive Fractal 77.565/3.14", "author": "timmaffett", "description": "fractal\nmouse around and explore", "tags": ["fractal"], "likes": 6, "viewed": 231, "published": 3, "date": "1676597318", "time_retrieved": "2024-07-30T18:09:50.960527", "image_code": "// Fork of \"Fork Fractal 77 sleeplessm 565\" by sleeplessmonk. https://shadertoy.com/view/mt2XDy\n// 2023-02-17 01:27:35\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    mouse.x += 0.5;\n    if(mouse==vec2(1.0)) mouse=vec2(sin(fract(iTime/0.234234)*3.14),cos(fract(iTime/0.63234234)*6.39));\n      \n    fragColor=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((fragCoord-.65*r.xy)/r.y,0.5));\n    float g=0.,e,s;\n    for(float i=0.;i<19.;i++) {\n        p=g*d;\n        p.z-=.6;\n        p=R(p,normalize(vec3(1.*mouse.x,2.,3.*mouse.y)),iTime*.6);\n        s=1.42;//1.;//4.;\n        for(int j=0;j<6;j++) {\n            p=abs(p);\n            //p=p.x<p.y?p.zxy:p.zyx;\n            s*=e=(1.8/min(dot(p,p),1.3))*mouse.x/mouse.y;\n            p=p*e-vec3(15,3,2);\n        }\n        g+=e=length(p.xz)/s;\n        fragColor.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-i*i*e);\n    }\n    fragColor=pow(fragColor,vec4(3));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 278, 278, 1097]], "test": "untested"}
{"id": "dtBSWV", "name": "vscode / monaco editor", "author": "jonasfrey", "description": "hi guys i just coded a small script that implements the monaco editor for shadertoy\nhttps://gist.github.com/jonasfrey/dab4d236bc505df6db8a9d5005b4ad0b\n[url]https://gist.github.com/jonasfrey/dab4d236bc505df6db8a9d5005b4ad0b[/url]", "tags": ["shadertoyextension", "customjs"], "likes": 3, "viewed": 245, "published": 3, "date": "1676591996", "time_retrieved": "2024-07-30T18:09:51.715508", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc_nor = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    float n = length(o_fc_nor);\n    n = sin(cos(n*20.+iTime*.2)*10.+iTime)*0.5+.5;\n    fragColor = vec4(\n        n\n    );\n\n    float n2 = 2.; \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 273]], "test": "untested"}
{"id": "dtSSWm", "name": "circle through three points", "author": "jonasfrey", "description": "circle", "tags": ["circle"], "likes": 2, "viewed": 161, "published": 3, "date": "1676583884", "time_retrieved": "2024-07-30T18:09:52.555263", "image_code": "float f_n_dist_line_byiq(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n\n    float n_radius;\n    \n    vec4 o_col = vec4(0.);\n    vec2 o_p1 = vec2(-0.25, .33);\n    vec2 o_p2 = vec2(0.25,  .33);\n    vec2 o_p3 = vec2(0.0, -0.0);\n    //test 2\n    float n_thi = 0.01;\n    float aa = 1./iResolution.x;;\n\n    float n_aa = aa * 55.;\n    float n = length(o_fc-o_p1);\n    n = smoothstep(n_thi+n_aa, n_thi,n);\n    o_col+=n;\n    \n    n = f_n_dist_line_byiq(o_fc, o_p1, o_p2);\n    n = smoothstep(n_thi+n_aa, n_thi,n);\n    o_col += n*vec4(0.23, 0.1, 0.8,1.);\n    \n    n = f_n_dist_line_byiq(o_fc, o_p2, o_p3);\n    n = smoothstep(n_thi+n_aa, n_thi,n);\n    o_col += n*vec4(0.78, 0.5, 0.3,1.);;\n    \n    n = f_n_dist_line_byiq(o_fc, o_p1, o_p3);\n    n = smoothstep(n_thi+n_aa, n_thi,n);\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);;\n    \n    \n    n_radius = 0.3;\n    \n    n = length(o_fc-o_p1);\n    n_aa = aa * 25.;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    \n    n = length(o_fc-o_p2);\n    n_aa = aa * 25.;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    n = length(o_fc-o_p3);\n    n_aa = aa * 25.;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    \n    vec2 o_pmiddle = ((o_p2-o_p3)*.5)+o_p3;\n    \n    n = length(o_fc-o_pmiddle);\n    n_aa = aa * 25.;\n    n_radius = .02;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    \n\n    float n_tau = 6.2831;\n    float n_ang = atan((o_p2-o_p3).x, (o_p2-o_p3).y);\n    n_ang += n_tau / 4.;\n    vec2 o_lot = vec2(\n        sin(n_ang)*0.25,\n        cos(n_ang)*0.25\n    );\n    vec2 o_pn = o_lot+o_pmiddle;\n        n = length(o_fc-o_pn);\n    n_aa = aa * 25.;\n    n_radius = .02;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    \n    vec2 o_lot2 = vec2(\n        sin(n_ang+n_tau*.5)*0.25,\n        cos(n_ang+n_tau*.5)*0.25\n    );\n    vec2 o_pn2 = o_lot2+o_pmiddle;\n    \n    n = length(o_fc-o_pn2);\n    n_aa = aa * 25.;\n    n_radius = .02;\n    n_thi = 0.001;\n    n = smoothstep(n_thi+n_aa, n_thi,abs(n-n_radius));\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);\n    \n    n = f_n_dist_line_byiq(o_fc, o_pn, o_pn2);\n    n = smoothstep(n_thi+n_aa, n_thi,n);\n    o_col += n*vec4(0.28, 0.78, 0.8,1.);;\n    \n    \n    fragColor = o_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 179], [182, 182, 239, 239, 2750]], "test": "untested"}
{"id": "ctBXDK", "name": "Arbitrary Polygons, Blur/Border", "author": "adremeaux", "description": "Draw multiple discrete polygons in a single pass with controls for colors, blur, border size, and border blur.", "tags": ["procedural", "2d", "blur", "draw", "polygon", "sdh"], "likes": 2, "viewed": 472, "published": 3, "date": "1676574132", "time_retrieved": "2024-07-30T18:09:53.332185", "image_code": "// Multiple Arbitrary Polygons with Blur and Border\n// Adapted from https://www.shadertoy.com/view/WdSGRd\n//\n// This shader can draw single or multiple polygons in a single pass\n// Overlap is supported and works as expected, no weirdness\n// The shader supports Blur, Border Thickness, and Border Blur\n// \n// New polygons should be marked by an extra point with a value > CUTOFF\n// This is a totally arbitrary value but can be easily changed\n//\n// Note that is a bit of a visual hitch between BorderBlur 0 and >0\n// There is also some weirdness in the overlap edges when blur is enabled, I'm not\n//   sure how to fix\n// If desired, it shouldn't be too hard to have it use multiple colors for the different\n//   polys, although the arbitrary amount of polys coupled with a hardcoded set of colors\n//   would be pretty ugly\n\n#define N 9\n#define CUTOFF 10.\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\n// https://www.shadertoy.com/view/XsfGDH\nvec4 lerp(vec4 colorone, vec4 colortwo, float value)\n{\n\treturn (colorone + value * (colortwo - colorone));\n}\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPoly( in vec2[N] poly, in vec2 p, int cornerCount ) {\n    vec2[N] edgeDist;\n    vec2[N] pointDist;\n    vec2[N] pq;\n    \n    int lastMark = 0; //start position of each successive poly\n    \n    // data\n    for (int i=0; i < cornerCount; i++) {\n       int i2 = i + 1;\n       if (i2 == cornerCount) i2 = lastMark;\n       \n       if (poly[i].x >= CUTOFF) {\n           pq[i] = vec2(1000.);\n           lastMark = i + 1;\n           continue;\n       }\n       if (poly[i2].x >= CUTOFF) {\n           i2 = lastMark;\n       }\n       \n\t\tedgeDist[i] = poly[i2] - poly[i];\n        pointDist[i] = p - poly[i];\n        float dotE = dot(edgeDist[i], edgeDist[i]);\n        if (dotE == 0.) dotE = .0001;\n        pq[i] = pointDist[i] - edgeDist[i] * \n            clamp( dot(pointDist[i], edgeDist[i]) / dotE, 0.0, 1.0 );\n    }\n    \n    //distance\n    float d = dot(pq[0], pq[0]); \n\tfor (int i = 1; i < cornerCount; i++) {\n    \td = min(d, dot(pq[i], pq[i]));\n    }\n\t\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    int wn = 0;\n    lastMark = 0;\n    bool runningVal = true;\n    \n    for (int i = 0; i < cornerCount; i++) {\n        if (poly[i].x >= CUTOFF) {\n            runningVal = runningVal && (wn == 0);\n            lastMark = i + 1;\n            continue;\n        }\n\n        int i2 = i + 1;\n        if (poly[i2].x >= CUTOFF) {\n            i2 = lastMark;\n        }\n        if (i2 == cornerCount) i2 = lastMark;\n        \n        bool cond1 = 0. <= pointDist[i].y;\n        bool cond2 = 0. > pointDist[i2].y;\n        float val3 = cross2d(edgeDist[i], pointDist[i]); //isLeft\n        wn +=  cond1 &&  cond2 && val3 > 0. ? 1 : 0; // have  a valid up intersect\n        wn -= !cond1 && !cond2 && val3 < 0. ? 1 : 0; // have  a valid down intersect\n    }\n    \n    runningVal = runningVal && (wn == 0);\n    float s = runningVal ? 1. : -1.;\n    return sqrt(d) * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurMax = 0.5;\n    float borderSizeMax = 20.0; \n    float borderBlurMax = 5.0; \n    \n    vec3 col2 = 0.5 + 0.5 * cos(iTime + vec3(0, 2, 4));\n    \n    vec4 innerColor = vec4(col2, 1.);//vec4(.75, .12, .67, 1.);\n    vec4 outerColor = vec4(.05, .01, .27, 0.); \n    vec4 borderColor = vec4(1.); \n    \n    float blur = clamp(cos(iTime) * blurMax, 0., blurMax);\n    float borderSize = clamp(cos(iTime * 1.5 + 0.3) * borderSizeMax, 0., borderSizeMax);\n    float borderBlur = clamp(cos(iTime * 1.2 + 0.6) * borderBlurMax, 0., borderBlurMax);\n\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    vec2 offset = vec2(.5, .5);\n\tvec2 v1 = cos( iTime + vec2(0.0,1.40) + 0.3 ) + offset;\n\tvec2 v2 = cos( iTime + vec2(0.0,1.10) + 1.5 ) + offset;\n\tvec2 v3 = cos( iTime + vec2(0.0,0.70) + 4.0 ) + offset;\n\tvec2 v4 = cos( iTime + vec2(0.0,0.50) - 2.0 ) + offset;\n    \n    vec2 v6 = vec2(CUTOFF * 2.);\n    \n    offset = -offset;\n    vec2 v7 = cos( iTime + vec2(0.0,1.50) - 0.0) + offset;\n\tvec2 v8 = cos( iTime + vec2(0.0,2.50) - 1.5 ) + offset;\n\tvec2 v9 = cos( iTime + vec2(0.0,2.20) - 4.0 ) + offset;\n\tvec2 v10 = cos( iTime + vec2(0.0,1.80) + 2.0 ) + offset;\n    \n    vec2[N] poly= vec2[N](\n    v1,\n    v2,\n    v3,\n    v4,\n    v6,\n    v7,\n    v8,\n    v9,\n    v10);\n    \n    float dist = -sdPoly(poly, p, N);\n    float rawDist = abs(dist);\n    float pos = sign(dist);\n    if (blur == 0.) blur = 0.001;\n    dist /= blur;\n    dist = clamp(dist, -1., 1.);\n\n    float ic = dist * .5 + .5;\n    float oc = -dist * .5 + .5;\n\n    vec4 col = lerp(outerColor, innerColor, ic);\n    if (pos < 1.) col = lerp(innerColor, outerColor, oc);\n\n    float bs = borderSize / iResolution.x;\n    float bBlur = bs * (borderBlur + 1.);\n    if (rawDist < bBlur) {\n        float lowBound = 0.;\n        float highBound = bBlur;\n        float blurDist = borderBlur <= 0. ? 0. : (rawDist - lowBound) / (highBound - lowBound);\n        blurDist = clamp(blurDist, 0., 1.);\n        col = lerp(borderColor, col, blurDist);\n    }\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[854, 854, 887, 887, 927], [929, 970, 1024, 1024, 1078]], "test": "untested"}
{"id": "dljXWy", "name": "Reef and waves 4", "author": "guil", "description": "Reef and waves effect. Code refactoring", "tags": ["waves", "reef"], "likes": 10, "viewed": 442, "published": 3, "date": "1676563488", "time_retrieved": "2024-07-30T18:09:54.213828", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//reef/waves combined field\nvec3 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,g,h,o,d;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n    mat2 m = rot(1.);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<4e2;s*=1.7)\n            p.xz*=m,\n            n.yz*=m,\n            q=p*s+n*1.5,\n            r=p*s+n,\n            r.x+=iTime*2.,\n            e+=abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.22+.5*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n\tg=exp(-e);h=exp(-f);\n    o=1.-(f>.001 ? (e<.001 ? g:0.):h);\n    d=min(min(e,2.*e*f),.8*f);\n    \n    return vec3(d,g*o,h*o);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3., dt = .3,d,e,f;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{        \n        vec3 v = field(ro+t*rd); \n        d=v.x; e=v.y; f=v.z; \n        t+=dt*d;\n        dt *= 1.01;       \n        col = .97*col + .15*(f*vec3(5,5,4)+e*vec3(3,5,6));        \n    }    \n    return col*exp(-t*.15);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera\n\n    vec3 ro = vec3(2.);   \n    ro.yz*=rot(-1.6);   \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -= t*.4;\n    \n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljXWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [192, 220, 243, 243, 737], [740, 740, 777, 777, 1091], [1094, 1094, 1151, 1151, 1809]], "test": "untested"}
{"id": "DtSXzK", "name": "Nice subdivided 2d grid", "author": "rsk", "description": "Nice infinite subdivided smooth 2d grid, similar to one used in Blender\n\nClick like if you like it!", "tags": ["2d", "grid", "lines", "editor", "nice", "divide"], "likes": 4, "viewed": 360, "published": 3, "date": "1676561080", "time_retrieved": "2024-07-30T18:09:54.972799", "image_code": "// Nice subdivided 2d grid\n// author: rsk -> https://twitter.com/rsk\n\n// antialising mode\n#define AA false\n// background color\n#define BG vec3(0.1, 0.2, 0.3)\n// axis color\n#define AXIS_C vec3(0.15, 0.25, 0.44)\n// axis line width\n#define AXIS_W 4.0\n// grid lines color\n#define GRID_C vec3(0.1, 0.27, 0.35)\n// grid lines width (for AA recommended 2.5)\n#define GRID_W 2.0\n// grid step\n#define GRID_STEP 120.0\n// number of subdivisions for main grid\n#define GRID_DIV 10.0\n// minimal visible step size in pixels for grid subdivisions\n#define MIN_VISIBLE_STEP 10.0\n// subgrid lines width (for AA recommended 2.0)\n#define SUB_W 1.0\n// color for sub grid\n#define SUB_C vec3(0.117, 0.225, 0.332)\n\nvec3 srgb(vec3 c) {\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nfloat ilerp(float a, float b, float value) {\n    return clamp((value - a) / (b - a), 0.0, 1.0);\n}\n\nfloat logBase(float value, float base) {\n    return log(value) / log(base);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    vec2 center = r / 2.0;\n    vec2 d = center - fragCoord;\n    float scale = 1.0 / 10.0 + (sin(iTime / 5.5 - 1.3) + 1.0) * 20.0;\n    float scaledStep = GRID_STEP * scale;\n    // zoom level with fraction\n    float levelF = logBase(MIN_VISIBLE_STEP / scaledStep, GRID_DIV);\n    // zoom level integer\n    float level = floor(levelF);\n    // zoom level fraction\n    float f = fract(levelF);\n    float gridStep = scaledStep * pow(GRID_DIV, level + 2.0);\n    float subStep = scaledStep * pow(GRID_DIV, level + 1.0);\n    float subW = float(f < 0.5) * mix(SUB_W, GRID_W, (0.5 - f) / 0.5) + float(f >= 0.5) * SUB_W;\n    vec3 subStepColor = float(f < 0.5) * mix(SUB_C, GRID_C, (0.5 - f) / 0.5) + float(f >= 0.5) * mix(BG, SUB_C, (1.0 - f) / 0.5);\n\n    float centerC = ilerp(AXIS_W / 2.0, 0.0, min(abs(d.x), abs(d.y)));\n    centerC = float(centerC > 0.0);\n    \n    if (!AA) {\n        float gridC = ilerp(GRID_W, 0.0, min(abs(mod(d.x, gridStep)), abs(mod(d.y, gridStep))));\n        gridC = float(gridC > 0.0);\n        // don't paint over AXIS\n        gridC = (1.0 - centerC) * gridC;\n\n        float subC = ilerp(subW, 0.0, min(abs(mod(d.x, subStep)), abs(mod(d.y, subStep))));\n        subC = float(subC > 0.0);\n        // don't paint over AXIS and over main GRID\n        subC = (1.0 - centerC) * (1.0 - gridC) * subC;\n        float bgC = 1.0 - clamp(centerC + gridC + subC, 0.0, 1.0);\n        fragColor = vec4(srgb(AXIS_C * centerC + GRID_C * gridC + subStepColor * subC + BG * bgC), 1.0);\n    } else {\n        float gridC = min(abs(mod(d.x, gridStep)), abs(mod(d.y, gridStep)));\n        gridC = GRID_W - gridC;\n        gridC = float(gridC < 1.0 && gridC > 0.0) * gridC + float(gridC >= 1.0);\n        // don't paint over AXIS\n        gridC = min(1.0 - centerC, gridC);\n\n        float subC = min(abs(mod(d.x, subStep)), abs(mod(d.y, subStep)));\n        subC = subW - subC;\n        subC = float(subC < 1.0 && subC > 0.0) * subC + float(subC >= 1.0);\n        // don't paint over AXIS and over main GRID\n        subC = min(1.0 - centerC - gridC, subC);\n        float bgC = 1.0 - clamp(centerC + gridC + subC, 0.0, 1.0);\n        fragColor = vec4(srgb(AXIS_C * centerC + GRID_C * gridC + subStepColor * subC + BG * bgC), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[688, 688, 707, 707, 745], [747, 747, 791, 791, 844], [846, 846, 886, 886, 923], [925, 925, 982, 982, 3229]], "test": "untested"}
{"id": "Dt23WV", "name": "Scrolling Hills and Houses. ", "author": "dvshkbm", "description": "Scrolling houses scene with mouse interaction. ", "tags": ["scrolling"], "likes": 8, "viewed": 225, "published": 3, "date": "1676558371", "time_retrieved": "2024-07-30T18:09:55.765679", "image_code": "// slight variation on this tutorial https://www.youtube.com/watch?v=LLZPnh_LK8c\n\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat GetHeight(float x){\n    return sin(x * .1632) + sin(x)*.132 + sin(x)*.1;\n}\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur){\n\n    //Top and Bottom. \n    float _b = S(-blur, blur, p.y - yb);\n    float _t = S(blur, -blur, p.y - yt);\n    \n    //Widths of top and bottom, with taper. \n    p.x = abs(p.x);\n    // 0 when p.y = yb and 1 when p.y = yt.\n    float _w = mix(wb, wt, (p.y - yb)/(yt - yb)); //Taper. \n    float _wmult = S(blur, -blur, p.x - _w); //Apply taper. \n    \n    float _m = _b * _t * _wmult;\n    return _m;\n}\n\nvec4 House(vec2 uv, vec3 col, float blr){\n\n    float h = TaperBox(uv, .1, .1, -.8, -.4, blr); //house base\n    float r = TaperBox(uv, .12, 0., -.4, -.06, blr); // roof\n    float w = TaperBox(uv, .025, .025, -.45, -.4, blr); // window top\n    float w1 = TaperBox(uv, .025, .025, -.55, -.5, blr); // window mid\n    float w2 = TaperBox(uv, .025, .025, -.75, -.6, blr); // window bttm\n    float s = .25* TaperBox(uv, .1, .1, -.45, -.399, 1.2*blr); //shadow\n    float _a = h + r - w - w1 - w2 - s;\n    \n    return vec4(col, _a);\n}\n\nvec4 Layer(vec2 uv, float blr){\n\n    vec4 _col = vec4(0);\n    //Making the ground y values over time. \n    float _y = GetHeight(uv.x);\n    float grnd = S(blr, -blr, _y+uv.y);\n    _col += grnd;\n    \n    //separating x values into columns\n    float id = floor(uv.x);\n    float n = fract(sin(id * 342.9) * 2343.) * 2. - 1.; //sin function to space out each house within column. \n    uv.x = fract(uv.x)-.5; //adjusting values to the center of the column\n    \n    //Initialising values for xy pos of houses. \n    float locx = n*.3; //.5 - roof width, then adjusted for uv.x multiply in lines below.\n    float locy = 0.;\n    \n    //Adjusting ground values to create 1 value for every box. \n    float _gy = GetHeight(id + .5 + locx);\n    \n    //Making the house, applying xy values translated about. \n    vec4 hs = House((uv-vec2(locx, -_gy + .6))*vec2(1.+.2*n, 1.+.3*n), vec3(1.), blr);\n    //col.rg = uv;\n    _col = mix(_col, hs, hs.a);\n    _col.a = max(grnd, hs.a);\n    return _col;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(436.3, 647.9));\n    p += dot(p,p+682.26);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 m = iMouse / iResolution.x;\n    vec2 _m = (iMouse.xy / iResolution.xy)*2.-3.;\n\n    float twnkl = dot(length(sin(uv*1.3 + iTime*0.5)), length(cos(uv*vec2(202.3, 32.7)-iTime)));\n    twnkl = sin(twnkl*10.)+.5;\n    float strs = pow(Hash21(uv), 100.)*twnkl; //multiply it by itself to get the values closer to either 1 or 0.\n    vec4 col = vec4(strs);\n    \n    float moon = S(.01, -.01, length(uv + vec2(-.5,-.3))-.18);\n    moon *= S(-.03, .03, length(uv + vec2(-.6,-.35))-.18);\n    col += moon;\n    \n    //Expand the canvas between 2 and 5. \n    uv*=3. + (m.x)*4.;\n    //uv.y -= m.x*-2.;\n    \n    //Scroll in the x axis.\n    uv.x += iTime;\n    \n    vec4 layer;\n    for(float i = 0.; i < 1.; i +=1./10.){\n        float scale = mix(8., 1., i);\n        float blur = mix(.1, .005, i);\n        layer = Layer(vec2(uv.x + scale*i, uv.y-.5) * scale + vec2(iTime+i*362., i)-1.-(_m.y*1.2), blur);\n        layer.rgb *= 1. - i *vec3(1., .9, .7*i);\n        col = mix(col, layer, layer.a);\n    }\n    layer = Layer(uv + vec2(iTime, -2.5) -(_m.y*1.2), .1);\n    col = mix(col, layer*.1, layer.a);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt23WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 143, 143, 198], [200, 200, 275, 299, 671], [673, 673, 714, 714, 1198], [1200, 1200, 1231, 1231, 2180], [2182, 2182, 2203, 2203, 2295], [2297, 2297, 2354, 2404, 3595]], "test": "untested"}
{"id": "mlSGDy", "name": "Psychedelic Sailor Moon. ", "author": "dvshkbm", "description": "shader magic", "tags": ["space"], "likes": 3, "viewed": 175, "published": 3, "date": "1676558344", "time_retrieved": "2024-07-30T18:09:56.574517", "image_code": "#define QUART_PI 0.78539816339\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1), setting the center to 0.\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    float s = sin(QUART_PI);\n    float c = cos(QUART_PI);\n    uv *= mat2(c, -s, s, c); //typical rotation matrix for 2d vector. \n    \n    uv *= 15.;\n    vec2 gridUV = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    vec2 rot = vec2(sin(iTime*3.), cos(iTime*3.))*.05;\n    \n    float m = 0.;\n    \n    for(float _i =-1.; _i<=1.; _i++){\n        for(float _j =-1.; _j<=1.; _j++){\n            vec2 offset = vec2(_i, _j);\n            \n            float d = length(gridUV - offset);\n            float dist = length(rot + id + offset) * 7.5;\n            float r = mix(.01, 1.5, sin(iTime - dist)*.5+.5);\n            m += smoothstep(r, r*.9, d);\n        }\n    }\n    \n    float a = atan(iTime)*.5 + .5;\n    col.r += mod(m, 3.);\n    col.g += mod(m, 3.5 - a);\n    col.b += mod(m, 3.5 + a);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 166, 1084]], "test": "untested"}
{"id": "DtjXDG", "name": "Hyperbola - distance", "author": "iq", "description": "Distance to a Hyperbola, which is just the y(x)=k/x curve rotated 45 degrees. See [url]https://www.shadertoy.com/view/ftcyW8[/url]", "tags": ["2d", "distancefield", "sdf", "hyperbola"], "likes": 30, "viewed": 1082, "published": 3, "date": "1676526201", "time_retrieved": "2024-07-30T18:09:57.324512", "image_code": "// The MIT License\n// Copyright  2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a Hyerbola, which is just the y(x)=k/x curve rotated 45 degrees.\n//\n// Minimizing the distance squared D = (x-t)+(y-k/t) produces\n//\n// t - xt + kyt - k = 0\n//\n// which can be solved with the quartic formula, as described in Wikipedia:\n// https://en.wikipedia.org/wiki/Quartic_equation. I followed the \n// section \"Summary of Ferrari's method\" and simplified a lot of things\n// (complex branches to reals, trigonometrics, constant unfolding, etc)\n// until I got this expression.\n//\n// Based on https://www.shadertoy.com/view/ftcyW8\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdHyberbola( in vec2 p, in float k, in float he ) // k in (0,inf)\n{\n    // symmetry and rotation\n    p = abs(p);\n    p = vec2(p.x-p.y,p.x+p.y)/sqrt(2.0);\n\n    // distance to y(x)=k/x by finding t in such that t - xt + kyt - k = 0\n    float x2 = p.x*p.x/16.0;\n    float y2 = p.y*p.y/16.0;\n    float r = k*(4.0*k - p.x*p.y)/12.0;\n    float q = (x2 - y2)*k*k;\n    float h = q*q + r*r*r;\n    float u;\n    if( h<0.0 )\n    {\n        float m = sqrt(-r);\n        u = m*cos( acos(q/(r*m))/3.0 );\n    }\n    else\n    {\n        float m = pow(sqrt(h)-q,1.0/3.0);\n        u = (m - r/m)/2.0;\n    }\n    float w = sqrt( u + x2 );\n    float b = k*p.y - x2*p.x*2.0;\n    float t = p.x/4.0 - w + sqrt( 2.0*x2 - u + b/w/4.0 );\n\n    // comment this line out for an infinite hyperbola\n    t = max(t,sqrt(he*he*0.5+k)-he/sqrt(2.0));\n\n    // distance from t\n    float d = length( p-vec2(t,k/t) );\n\n    // sign\n    return p.x*p.y < k ? d : -d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 3.0;\n    \n\tvec2  p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = scale*2.0/iResolution.y;\n    \n    // animate hyperbola\n    float an = smoothstep(-0.2,0.2,sin(iTime*0.5+0.2));\n    float k = 3.0 + 2.98*sin(iTime*1.0);\n    float h = 0.8 + 5.0*an;\n\n    // distance\n    float d = sdHyberbola(p,k,h);\n    \n    // colorize\n    const vec3 colA = vec3(0.90,0.60,0.3);\n    const vec3 colB = vec3(0.65,0.85,1.0);\n    vec3 col = mix( colA, (d>0.0) ? colA : colB, an );\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(50.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,3.0*px,abs(d)) );\n    \n     // mouse\n    if( iMouse.z>0.001 )\n    {\n        float d = sdHyberbola(m, k,h);\n        float l = length(p-m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, abs(l-abs(d))-0.005));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 2.0*px, l-0.05));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjXDG.jpg", "access": "api", "license": "mit", "functions": [[1768, 1768, 1841, 1870, 2699], [2701, 2701, 2756, 2756, 3789]], "test": "untested"}
{"id": "mlBSWy", "name": "Shader coded by ChatGPT", "author": "morisil", "description": "ChatGPT apparently speaks GLSL", "tags": ["ai"], "likes": 2, "viewed": 376, "published": 3, "date": "1676503176", "time_retrieved": "2024-07-30T18:09:58.083482", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float radius = length(uv);\n    float angle = atan(uv.y, uv.x);\n    vec3 color = vec3(0.0);\n    float t = iTime * 0.1;\n    float gradientCount = 3.0;\n    float gradientIndex = mod(floor(t), gradientCount);\n    float gradientT = fract(t);\n    if (gradientIndex == 0.0) {\n        color = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), gradientT);\n    } else if (gradientIndex == 1.0) {\n        color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), gradientT);\n    } else if (gradientIndex == 2.0) {\n        color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), gradientT);\n    }\n    color *= 1.0 - smoothstep(0.4, 0.5, radius);\n    color += vec3(1.0, 1.0, 1.0) * smoothstep(0.4, 0.5, radius) * (0.5 + 0.5 * sin(5.0 * angle + 2.0 * iTime));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 892]], "test": "untested"}
{"id": "dlBSWy", "name": "Fork 301's Fire Tabyltop 636", "author": "Tabyltop", "description": "Fork for experimentation\n", "tags": ["flame", "fire", "blaze"], "likes": 4, "viewed": 752, "published": 3, "date": "1676502687", "time_retrieved": "2024-07-30T18:09:59.037930", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(1.2, 0.1);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n    //change the constant term for all kinds of cool distance versions,\n    //make plus/minus to switch between \n    //ground fire and fire rain!\n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.01+1.0*sin(iTime)/10.0);\n    float qb = fbm(p - iTime * 0.002+0.1*cos(iTime)/5.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/7.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/30.0)-4.0;\n    float q4 = fbm(p - iTime * 2.0 - 20.0*sin(iTime)/20.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(c * cos(shift * fragCoord.y / iResolution.y));\n    color += .05;\n    color.r *= .8;\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= hsv.z  * 1.1;\n    hsv.z *= hsv.y * 1.13;\n    hsv.y = (2.2-hsv.z*.9)*1.20;\n    color = hsv2rgb(hsv);\n    vec4 camColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = camColor * 0.5 + vec4(color.x, color.y, color.z, alpha) * 0.5;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 568, 568, 642], [644, 644, 665, 665, 871], [873, 873, 892, 892, 1077], [1079, 1079, 1136, 1136, 2663]], "test": "untested"}
{"id": "dlSSWy", "name": "Fork Matrix Rai Tabyltop 850", "author": "Tabyltop", "description": "Matrix Rain - Forked for Testing", "tags": ["matrix"], "likes": 6, "viewed": 724, "published": 3, "date": "1676500887", "time_retrieved": "2024-07-30T18:10:00.321498", "image_code": "#define RAIN_SPEED 1.75 // Speed of rain droplets\n#define DROP_SIZE  3.0  // Higher value lowers, the size of individual droplets\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rchar(vec2 outer, vec2 inner, float globalTime) {\n\t//return float(rand(floor(inner * 2.0) + outer) > 0.9);\n\t\n\tvec2 seed = floor(inner * 4.0) + outer.y;\n\tif (rand(vec2(outer.y, 23.0)) > 0.98) {\n\t\tseed += floor((globalTime + rand(vec2(outer.y, 49.0))) * 3.0);\n\t}\n\t\n\treturn float(rand(seed) > 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = fragCoord.xy / iResolution.xy;\n\tvec2 uv = vec2(position.x, position.y);\n    position.x /= iResolution.x / iResolution.y;\n\tfloat globalTime = iTime * RAIN_SPEED;\n\t\n\tfloat scaledown = DROP_SIZE;\n\tfloat rx = fragCoord.x / (40.0 * scaledown);\n\tfloat mx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\tvec4 result;\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult = vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x / (15.0));\n\t\t\n\n\t\tfloat ry = position.y*600.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult = vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry / 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);\n\t\t\t\n\t\t\tresult = vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tposition.x += 0.05;\n\n\tscaledown = DROP_SIZE;\n\trx = fragCoord.x / (40.0 * scaledown);\n\tmx = 40.0*scaledown*fract(position.x * 30.0 * scaledown);\n\t\n\tif (mx > 12.0 * scaledown) {\n\t\tresult += vec4(0.0);\n\t} else \n\t{\n        float x = floor(rx);\n\t\tfloat r1x = floor(fragCoord.x / (12.0));\n\t\t\n\n\t\tfloat ry = position.y*700.0 + rand(vec2(x, x * 3.0)) * 100000.0 + globalTime* rand(vec2(r1x, 23.0)) * 120.0;\n\t\tfloat my = mod(ry, 15.0);\n\t\tif (my > 12.0 * scaledown) {\n\t\t\tresult += vec4(0.0);\n\t\t} else {\n\t\t\n\t\t\tfloat y = floor(ry / 15.0);\n\t\t\t\n\t\t\tfloat b = rchar(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0, globalTime);\n\t\t\tfloat col = max(mod(-y, 24.0) - 4.0, 0.0) / 20.0;\n\t\t\tvec3 c = col < 0.8 ? vec3(0.0, col / 0.8, 0.0) : mix(vec3(0.0, 1.0, 0.0), vec3(1.0), (col - 0.8) / 0.2);\n\t\t\t\n\t\t\tresult += vec4(c * b, 1.0)  ;\n\t\t}\n\t}\n\t\n\tresult = result * length(texture(iChannel0,uv).rgb) + 0.22 * vec4(0.,texture(iChannel0,uv).g,0.,1.);\n\tif(result.b < 0.5)\n\tresult.b = result.g * 0.5 ;\n\tfragColor = result;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 151, 151, 223], [225, 225, 280, 337, 528], [530, 530, 587, 587, 2591]], "test": "untested"}
{"id": "mlSXDG", "name": "Fork comic book Tabyltop 691", "author": "Tabyltop", "description": "Testing", "tags": ["video", "toon"], "likes": 3, "viewed": 352, "published": 3, "date": "1676499731", "time_retrieved": "2024-07-30T18:10:01.372687", "image_code": "const mat3 yuv_2_rgb = mat3(1.0, 1.0, 1.0,\n                            0.0, -0.39465, 2.03211,\n                            1.13983, -0.58060, 0.0);\n\nconst mat3 rgb_2_yuv = mat3(0.299, -0.14713, 0.615,\n                            0.587, -0.28886, -0.51499,\n                            0.114, 0.436, -0.10001);\n\nfloat edge(vec2 uv, float stepsize) {\n\tfloat x = length(\n                     texture(iChannel0, uv - vec2(stepsize, 0.0)).rgb -\n                     texture(iChannel0, uv + vec2(stepsize, 0.0)).rgb);\n    \n\tfloat y = length(\n                     texture(iChannel0, uv - vec2(0.0, stepsize)).rgb -\n                     texture(iChannel0, uv + vec2(0.0, stepsize)).rgb);\n    return (x + y) / stepsize;\n}\n\n\nvec3 color_quantize_yuv(in vec3 color) {\n    const float yuv_step = 0.1;\n \tvec3 yuv = rgb_2_yuv * color;\n    yuv.x = 0.2 + 0.8 * yuv.x;\n    vec3 quantized =\n        vec3(0.1 * (0.2 + round(10.0 * yuv.x)),\n             0.125 * (0.25 * sign(yuv.yz) + round(8.0 * yuv.yz)));\n    return yuv_2_rgb * quantized;\n}\n\nvec3 orangize(in vec3 col) {\n     mat3 blowout = mat3(1.87583893, 0.96308725, 0.,\n       0.96308725, 1.17416107, 0.,\n       0.        , 0.        , 0.5);\n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517) + 0.2;\n   \n    \n    vec3 dir = blowout * (col - cent);\n    \n    vec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    float amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    return col + dir * 0.5 * amount;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float edgesize = 2.0 / min(iResolution.x, iResolution.y);\n    float edge_modulate =\n        smoothstep(30.0, 15.0, 0.4 * edge(uv, edgesize));\n    vec3 color = orangize(color_quantize_yuv(texture(iChannel0, uv).rgb));\n    vec3 line_color = vec3(0.1);\n\tfragColor = vec4(mix(line_color, color, edge_modulate),1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 347, 347, 711], [714, 714, 754, 754, 1021], [1023, 1023, 1051, 1051, 1491], [1493, 1493, 1550, 1550, 1910]], "test": "untested"}
{"id": "mtSXDG", "name": "Fork Cartoon 00 Tabyltop 468", "author": "Tabyltop", "description": "Cartoon Version 1", "tags": ["cartoon"], "likes": 1, "viewed": 261, "published": 3, "date": "1676499487", "time_retrieved": "2024-07-30T18:10:02.261311", "image_code": "// Higher blur sizes are slower and will make large areas of very similar colours become very flat.\n// Low blur sizes are faster and will do nothing.\n// Recommended is 5\n#define BLUR_SIZE 9\n\n// High thresholds mean that the colour has to be very similar to use it with blurring.\n// A low threshold will look more like a normal blur.\n// Recommended is .93\n#define THRESHOLD .8\n\n// The below is for a very strange look that you might get from overdone noise removal.\n// #define BLUR_SIZE 15\n// #define THRESHOLD .85\n\n// Turn this on to see outlines where there are edges.\n// A higher value means more pronounced edges. The edges will also be darker/fatter\n// when there is a greater difference.\n// Note: Use lower values with lower blurs.\n// Recommended values:\n// Blur | Edge\n//   5  |  48\n//  15  |  386\n#define EDGES_AMNT 200.0\n\nvec4 quantize(vec4 color, float levels) {\n    color.r = floor(color.r * levels) / levels;\n   color.g = floor(color.g * levels) / levels;\n   color.b = floor(color.b * levels) / levels;\n\n    return color;\n}\n\nvec3 rgb2hsl(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1./iResolution.x;\n\tfloat h = 1./iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\n\n#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 2.5\n#define MAX_S 19.0\n#define SPEED 0.57\n\n#define SST 0.888\n#define SSQ 0.288\n\n#define ORIGIN (0.5 * iResolution.xy)\nfloat R;\nfloat S;\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat k = max(max(c.r, c.g), c.b);\n\treturn min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px)\n{\n\treturn vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px)\n{\n\treturn px - mod(px,S);\n}\n\nvec4 ss(in vec4 v)\n{\n\treturn smoothstep(SST-SSQ, SST+SSQ, v);\n}\n\nvec4 halftone(in vec2 fc,in mat2 m)\n{\n\tvec2 smp = (grid(m*fc) + 0.5*S) * m;\n\tfloat s = min(length(fc-smp) / (DOTSIZE*0.5*S), 1.0);\n    vec3 texc = texture(iChannel0, px2uv(smp+ORIGIN)).rgb;\n    texc = pow(texc, vec3(2.2)); // Gamma decode.\n\tvec4 c = rgb2cmyki(texc);\n\treturn c+s;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    S = MIN_S + (MAX_S-MIN_S) * 2.0*16.0 / iResolution.x;\n    R = D2R(180.0 * (8.0) / iResolution.y);\n\n\tvec2 fc = fragCoord.xy - ORIGIN;\n\t\n\tmat2 mc = rotm(R + D2R(15.0));\n\tmat2 mm = rotm(R + D2R(75.0));\n\tmat2 my = rotm(R);\n\tmat2 mk = rotm(R + D2R(45.0));\n\t\n\tfloat k = halftone(fc, mk).a;\n\tvec3 c = cmyki2rgb(ss(vec4(\n\t\thalftone(fc, mc).r,\n\t\thalftone(fc, mm).g,\n\t\thalftone(fc, my).b,\n\t\thalftone(fc, mk).a\n\t)));\n    \n    c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(c, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // find outlines\n    \n        float intensity = 1.5;\n        vec4 n[9];\n        make_kernel( n, iChannel0, fragCoord/iResolution.xy );\n\n        vec4 sobel_edge_h = (n[2]*intensity + (2.0*n[5])*intensity + n[8]*intensity - (n[0]*intensity + (2.0*n[3])*intensity + n[6]*intensity))*1.0;\n        vec4 sobel_edge_v = (n[0]*intensity + (2.0*n[1])*intensity + n[2]*intensity - (n[6]*intensity + (2.0*n[7])*intensity + n[8]*intensity))*1.0;\n        vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    \n\n\n\n    // reduce noise\n    \n     vec2 uv = fragCoord.xy / iResolution.xy;   \n    //vec4 newColor = vec4(0., 0., 0., 1.);\n    vec4 currentColor = texture(iChannel0, uv);\n    float totalWeight = 1.;\n    vec3 colors = vec3(0.);\n\n     for (int y = -BLUR_SIZE; y < BLUR_SIZE; y++) {\n        for (int x = -BLUR_SIZE; x < BLUR_SIZE; x++) {\n            vec3 color = texture(iChannel0, uv + vec2(float(x), float(y)) / iResolution.xy).rgb;\n\n            float weight = 1. - sqrt(\n                pow(color.r - currentColor.r, 2.) +\n                pow(color.g - currentColor.g,  2.) +\n                pow(color.b - currentColor.b, 2.));\n\n            // threshold\n            if (weight > THRESHOLD) {\n                weight = 1.;\n            } else {\n                weight = 0.;\n            }\n\n            totalWeight += weight;\n\n            colors += color * weight * 1.0;\n\n            vec3 hsl = rgb2hsl(colors.rgb);\n            hsl.z = hsl.z*1.001;\n            hsl.y *= 0.999;\n            colors = hsl2rgb(hsl);\n            colors *= 1.003;\n\n        }\n    }\n    \n\n    fragColor = vec4(colors *=1.0 / totalWeight, 1.);\n    fragColor -= max(0., min(1., 1. - totalWeight / EDGES_AMNT));\n    \n     // Grayscale effect\n      \n        vec2 pixel = vec2(iResolution.x/iResolution.y*1.,1.);\n        vec2 coord = (fragCoord.xy / pixel) + (0.5 / pixel);\n        vec2 newCoord = coord - floor(coord);\n        vec4 grayScale = fragColor;\n        float gray = dot(grayScale.rgb, vec3(0.4, 0.9, 0.));\n        gray = gray*1.5-0.25; // this can raise the black-point and lower the white-point\n        grayScale.rgb = vec3(gray);\n        grayScale = quantize(grayScale, 4.0); // reduce the number of grays\n\n        fragColor = mix(grayScale, fragColor, 0.4); // mix in the grayscale\n         fragColor =  clamp(fragColor,0.0,100.0);\n\n    \n    //fragColor = quantize(fragColor, 6.0); // reduce the number of colors\n    \n    \n    // Halftone effect\n    \n        S = MIN_S + (MAX_S-MIN_S) * 2.0*(iResolution.x / 20.) / iResolution.x;\n        R = D2R(180.0 * (iResolution.x/80.) / iResolution.y);\n\n        vec2 fc = fragCoord.xy - ORIGIN;\n\n        mat2 mc = rotm(R + D2R(15.0));\n        mat2 mm = rotm(R + D2R(75.0));\n        mat2 my = rotm(R);\n        mat2 mk = rotm(R + D2R(45.0));\n\n        float k = halftone(fc, mk).a;\n        vec3 c = cmyki2rgb(ss(vec4(\n            halftone(fc, mc).r,\n            halftone(fc, mm).g,\n            halftone(fc, my).b,\n            halftone(fc, mk).a\n        )));\n\n        c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n        fragColor = mix(fragColor, vec4(c, 1.0), 0.4); // mix in halftone\n    \n    \n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 5.0), sobel); // add outlines\n \n    \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[830, 830, 871, 871, 1034], [1036, 1036, 1058, 1058, 1389], [1391, 1391, 1413, 1413, 1582], [1584, 1584, 1646, 1646, 2095], [2296, 2296, 2323, 2323, 2399], [2401, 2401, 2428, 2428, 2451], [2453, 2453, 2477, 2477, 2514], [2516, 2516, 2539, 2539, 2565], [2567, 2567, 2587, 2587, 2630], [2632, 2632, 2669, 2669, 2913], [2915, 2915, 2938, 2938, 3016], [3018, 3018, 3076, 3076, 3568], [3572, 3572, 3629, 3651, 6861]], "test": "untested"}
{"id": "mtBXWG", "name": "frag", "author": "oudend", "description": "expanding circle pattern. ", "tags": ["frag"], "likes": 1, "viewed": 113, "published": 3, "date": "1676495766", "time_retrieved": "2024-07-30T18:10:03.159909", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x  / iResolution.y;\n    \n    vec2 resRatio = vec2(ratio * .5, 1. / ratio);\n    \n    float centerDist = 1.-distance(uv*resRatio, vec2(.5,.5)*resRatio);\n\n    // Time varying pixel color\n    vec3 col = .5 + .8*cos(centerDist+iTime*.1*vec3(0,1,4) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n    vec4 BufferA = texture(iChannel0, uv);\n\n    fragColor = vec4(col*.1 + col*BufferA.w, 1.);\n    \n    //fragColor = BufferA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int adjacentCount(vec2 uv, float alphaThreshold)\n{\n    //return true;\n    int count = 0;\n    \n    for(int i = -searchRadius; i <= searchRadius; i++)\n    {\n        for(int j = -searchRadius; j <= searchRadius; j++)\n        {\n            if(i == 0 && j == 0)\n            {\n                continue;\n            }\n\n            vec2 adjacentCoords = vec2(float(i),float(j))/iResolution.xy;\n\n            vec2 offsetUV = uv + adjacentCoords;\n            vec4 pixel = texture(iChannel0, offsetUV);\n\n            if(pixel.w >= alphaThreshold)\n            {\n                count++;\n                //return true;\n            }\n        }\n    }\n    return count;\n}\n\nfloat distToEdge(vec2 uv)\n{\n    return min( 1. - max(uv.x, uv.y), min(uv.x, uv.y) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = iResolution.x  / iResolution.y;\n    \n    vec2 resRatio = vec2(ratio * .5, 1. / ratio);\n    \n    bool initialized = iTime > 1.;\n    \n    //bool initialized2 = mod(iTime, 2.5) > 1.;\n    \n    float distanceToCenter = distance(uv*resRatio, vec2(.5,.5)*resRatio);\n    \n    if(!initialized && ( distanceToCenter < circleSize ) )// || ( distanceToCenter < circleSize + .01 && distanceToCenter > circleSize ) ) )// && uv.y == 0.)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    } else if(!initialized)\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n    \n    \n    vec4 BufferB = texture(iChannel0, uv);\n    \n    int adjacents = adjacentCount(uv, .3);\n    \n    noiseThreshold = float(adjacents) / 8.;\n    \n    //if(uv.x == 0. || uv.x == 1. || uv.y == 0. || uv.y == 1.) \n    //{\n        //noiseThreshold = 10.\n    //} \n    \n    \n    //adjacents > 0\n    \n    if(BufferB.w <= .3 && gold_noise(uv, iTime+iDate.w*uv.x+uv.y ) < noiseThreshold && adjacents > adjacentThreshold)//int(mod(iTime, 3.)) == 0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0 );\n        return;\n    }\n    \n    fragColor = BufferB;\n    \n    if(fragColor.w > 0.)\n    {\n        fragColor = vec4(BufferB.xyz * decrease, max( 0., BufferB.w * decrease - .01 ) );\n    }\n    \n    //if(fragColor.w <= .1 && fragColor.w > 0. && distToEdge(uv) < .01)// && gold_noise(uv, iTime * iDate.w ) < .1 ) \n    //{\n    //    fragColor.w = 1.;\n    //}\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 BufferA = texture(iChannel0, uv);\n\n    fragColor = BufferA;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Gold Noise 2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nint searchRadius = 2;\nfloat noiseThreshold = .4;\nfloat decrease = .99;\nfloat circleSize = .01;\nint adjacentThreshold = 0;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 627]], "test": "untested"}
{"id": "DtBXDy", "name": "esoteric.ltd", "author": "yozic", "description": "More gloopy fun.", "tags": ["trippy", "polar", "warm"], "likes": 13, "viewed": 273, "published": 3, "date": "1676489780", "time_retrieved": "2024-07-30T18:10:03.949797", "image_code": "mat2 r2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float PI = 3.14159;\n  vec2 uv = -1. + 2. * fragCoord.xy / iResolution.xy;\n  fragColor = vec4(0, 0, 0, 1.);\n  uv.x *= iResolution.x/iResolution.y;\n  uv *= .09;\n  uv = abs(uv);\n  uv /= dot(uv, uv);\n  uv *= r2d(1157.12);\n  for (float i = 0.; i < 20.; i++) {\n    uv.x += 0.65 * cos(0.54 * uv.y - iTime);\n    uv.y += 1.21 * cos(0.28 * uv.x + iTime);\n    float t = i * PI / 21.00 * 2.;\n    float x = 95.38 * tan(t - 4332. + iTime / 9.);\n    float y = 25.38 * cos(t - 680.65);\n    vec2 pos = vec2(x, y);\n    vec3 col = vec3(cos(vec3(-2, 0, -1) * PI * 2. / 3. + (2. * PI) * (1.4) + 3.) * 0.5 + 0.5);\n    fragColor += pow(vec4(27. / length(uv + pos) * col, 1.), vec4(1.59));\n    \n  }\n  fragColor.xyz = 1. - pow(abs(1. - log(abs(fragColor.xyz))), vec3(1.59));\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 69], [71, 71, 128, 128, 882]], "test": "untested"}
{"id": "ctBSDG", "name": "Hyperbola - projection 2D", "author": "Paul_31415", "description": "Analytical projection to a hyperbola, which can be solved with a quartic equation. \nVisualization code from iq : https://www.shadertoy.com/view/4sS3zz", "tags": ["2d", "distance", "analytic", "hyperbola"], "likes": 1, "viewed": 144, "published": 3, "date": "1676485423", "time_retrieved": "2024-07-30T18:10:04.891280", "image_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Analytical distance to an 2D ellipse, which is more\n// complicated than it seems. It ends up being a quartic\n// equation, which can be resolved through a cubic, then\n// a quadratic. Some steps through the derivation can be\n// found in this article: \n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\nfloat msign(in float x) { return (x<0.0)?-1.0:1.0; }\n\n\n\n\n\n// MIT License\n// Copyright  2023 Paul Soulanille\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat cbrt(in float x) {\n    return sign(x)*pow(abs(x),1.0/3.0);\n}\nfloat quart(in float x) {\n    x *= x;\n    return x*x;\n}\n\n// Hyperbola \n//  \n// y=1/t       |\n// x=t         \\__\n// rotate 45  (we do this to be able to change the open angle via x and y scaling)\n// x = t-1/t     \\_/\n// y = t+1/t\n// has min Y at 2 and focus at 22\n//     \n//  z,w s.t. |(x,y)-(z,w)| is min\n//       https://www.wolframalpha.com/input?i=d%2Fdt+%28%28a*%28t-1%2Ft%29-z%29%5E2%2B%28b*%28t%2B1%2Ft%29-w%29%5E2+%29+\n//  (2 a^2 t^4 - 2 a^2 - 2 a t^3 z - 2 a t z + 2 b^2 t^4 - 2 b^2 - 2 b t^3 w + 2 b t w)/t^3 = 0\n//  t^4 : 2 a^2 + 2 b^2 \n//  t^3 : - 2 a z - 2 b w\n//  t^2 : 0\n//  t   : - 2 a z + 2 b w\n//  1   : - 2 a^2 - 2 b^2\n// using: https://en.wikipedia.org/wiki/Quartic_equation#Summary_of_Ferrari's_method\n// let r^2 = a^2 + b^2\n// coeffs (AE): 2r^2, -2(abzw), 0, -2((a,b)(z,-w)), -2r^2\n//   = -3/8 (B/A)^2 + C/A\n//   = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n//   = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n// \n// when  = 0\n//  t = -B/4A  ((-  (^2-4))/2)\n// else\n//  P = - ^2/12 - \n//  Q = - ^3/108 + /3 - ^2/8\n//  R = - Q/2  ((Q/2)^2 + (P/3)^3)\n//  U = R\n//\n//  d = -5/6  + (U==0? -Q : U - P/(3U))\n//  W = ( + 2d)\n//  t = -B/4A + 1/2( _s W  (-(3 + 2d _s 2/W)))\n//\n//\n\n\n// currently suffers from precision loss in some areas\n//  which can be shown by uncommenting \"col = p.x<m.x?ploss: col;\" in mainImage\n//\nvec2 pHyperbola( vec2 p, in vec2 ab){\n    \n    //vec2 s1 = pHyperbola_sols(p,ab,1.0,1.0);\n    //vec2 s2 = pHyperbola_sols(p,ab,-1.0,1.0);\n    //vec2 s3 = pHyperbola_sols(p,ab,-1.0,-1.0);\n    //vec2 s4 = pHyperbola_sols(p,ab,1.0,-1.0);\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2;\n    //s2 = (length(s3-p)<length(s4-p))?s3:s4;\n    //s1 = (length(s1-p)<length(s2-p))?s1:s2; \n    //return s1;\n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //   = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //   = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //   = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //          = (-3/256 boa^3 - 1/4 doa)*boa - 1\n    //          _     az+bw4   az+bwaz-bw\n    //            -3 4r2  - 4r2r2 - 1\n    //          = \n    //          -(3 x^4)/(256 d^4) - (3 x^3 y)/(64 d^4) - (9 x^2 y^2)/(128 d^4) - (3 x y^3)/(64 d^4) - (3 y^4)/(256 d^4) - x^2/(4 d^2) + y^2/(4 d^2) - 1\n    //float gamma = -3.0/256.0 * quart(az / r2) - 3.0*(az\n    \n    \n    // when  = 0\n    //  t = -B/4A  ((-  (^2-4))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - ^2/12 - \n    //float P = - alpha2 / 12.0 - gamma;\n    //  P = - (3/8 * boa2)^2/12 - (-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0);\n    //    = - 3/256 boa^4 + 3.0/256.0 * (boa2*boa2) + 0.25 * boa*doa + 1.0;\n    //    = 0.25 * boa*doa + 1.0;\n    float P = 0.25 * boa*doa + 1.0;\n    \n    //  Q = - ^3/108 + /3 - ^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2  ((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //                     ^^^ lowers cancellation error\n    \n    \n    //  U = R\n    float U = cbrt(R);\n    \n    //  d = -5/6  + (U==0? -Q : U - P/(3U))\n    float dp56a = (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    float d = -5.0/6.0 * alpha + dp56a;\n    //  W = ( + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //  W = ( + -5/3  + (U==0? -2Q : 2U - 2P/(3U))\n    //    = (-2/3  + )\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * dp56a));\n    //  W = (-2/3  + (U==0? -Q : U - P/(3U))\n    // case U==0\n    //  W = (-2/3  -Q)\n    //    = (-2/3  -(- ^3/108 + /3 - ^2/8))\n    // case U!=0\n    //  W = (-2/3  + U + (^2/12 + )/(3U))\n    //    = (-2/3  + U - P/(3U))\n    //  W = (-2/3  + R - P/(3R))\n    \n    \n    //  t = -B/4A + 1/2( _s W  (-(3 + 2d _s 2/W)))\n    //float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //        3 + 2d = 3 + 2(-5/6   + dp56a)\n    //                = (3-5/3)   + 2 dp56a\n    //                =  4/3   + 2 dp56a\n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + 2.0*beta/W)));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(4.0/3.0*alpha + 2.0*dp56a + -2.0*beta/W)));\n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    return (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n}\n\n//using the \"locus of points\" geometric defn of hyperbola\nfloat inside_Hyperbola( vec2 p, in vec2 ab){\n    float sqrt2 = sqrt(2.0);//foci are at (0,2)\n    p /= ab;\n    p /= 2.0;\n    return sign(length(p-vec2(0,sqrt2))-length(p-vec2(0,-sqrt2))+2.0);\n}\n\n\n//precision loss testing\nfloat add_ploss(in float a, in float b){\n    return -log2(abs(a+b)/(abs(a)+abs(b)))/24.0;\n}\nvec3 pHyperbola_loss( vec2 p, in vec2 ab)\n{\n    \n                                                                                                  \n    float loss1 = 0.0;\n    float loss2 = 0.0;\n    float loss3 = 0.0;\n    \n    float sx = sign(p.x);\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*abs(p.x);\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float D = -2.0*(az-bw);\n    \n    \n    float boa = B/A;\n    float doa = D/A;\n    float boa2 = boa*boa;\n    \n    \n    //   = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2;\n    //   = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa + doa;\n    //loss3 = add_ploss(0.125 * boa2*boa, doa);\n    //   = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa - 1.0;\n    //loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) ,- 0.25 * boa*doa-1.0);\n    loss3 = add_ploss(-3.0/256.0 * (boa2*boa2) - 0.25 * boa*doa,-1.0);\n    // when  = 0\n    //  t = -B/4A  ((-  (^2-4))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - ^2/12 - \n    float P = - alpha2 / 12.0 - gamma;\n    loss1 = add_ploss(alpha2 / 12.0,gamma);\n    //  Q = - ^3/108 + /3 - ^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //loss3 = add_ploss(alpha2 / 108.0, - gamma/3.0);\n    //loss3 = add_ploss(- alpha*(alpha2 / 108.0 - gamma/3.0),- beta*beta / 8.0); \n    //  R = - Q/2  ((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //loss3 = add_ploss(Q*Q*0.25,P*P*P/27.0);\n    //loss3 = add_ploss(- Q * 0.5,sqrt(abs(Q*Q*0.25 + P*P*P/27.0))); //lines up with P in upper half, fixed\n    //  U = R\n    float U = cbrt(R);\n    \n    //  d = -5/6  + (U==0? -Q : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U));\n    //loss3 = add_ploss(-5.0/6.0 * alpha, (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))); //not here\n    //loss3 = add_ploss(U, - P/(3.0*U));// not here\n    //  W = ( + 2d)\n    //float W = sqrt(abs(alpha + 2.0 * d));\n    //loss2 = add_ploss(alpha,2.0*d);\n    float W = sqrt(abs(-2.0/3.0 * alpha + 2.0 * (abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U))));\n    loss2 = add_ploss(-2.0/3.0 * alpha,2.0*(abs(U)<=0.0? -cbrt(Q) : U - P/(3.0*U)));\n    //  t = -B/4A + 1/2( _s W  (-(3 + 2d _s 2/W)))\n    //  W = (-2/3  + (U==0? -Q : U - P/(3U))\n    // case U==0\n    //  W = (-2/3  -Q)\n    //    = (-2/3  -(- ^3/108 + /3 - ^2/8))\n    // case U!=0\n    //  W = (-2/3  + U + (^2/12 + )/(3U))\n    //    = (-2/3  + U - P/(3U))\n    //  W = (-2/3  + R - P/(3R))\n    //loss3 = add_ploss(-2.0/3.0 *alpha, + U);\n    \n    float t1 = -boa*0.25 + 0.5 * (W + sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(W+sqrt(abs(3.0*alpha + 2.0*d + 2.0*beta/W))));\n    float t2 = -boa*0.25 + 0.5 * (-W + sqrt(abs(3.0*alpha + 2.0*d + -2.0*beta/W)));\n    //loss3 = add_ploss(-boa*0.25,0.5*(-W+sqrt(abs(3.0*alpha + 2.0*d - 2.0*beta/W))));\n    \n    \n    float recip_t1 = 1.0/t1;\n    float recip_t2 = 1.0/t2;\n    vec2 p1 = vec2((t1-recip_t1)*sx,t1+recip_t1)*ab;\n    vec2 p2 = vec2((t2-recip_t2)*sx,t2+recip_t2)*ab;\n    vec2 result = (length(p1-p)<length(p2-p) && p1.y>=0.0) || p2.y < 0.0?p1:p2;\n    \n    \n    return vec3(loss1,loss2,loss3);\n    \n}\n\n\n//for highlighting individual solutions\nvec2 pHyperbola_sols( vec2 p, in vec2 ab, in float s1, in float s2 )\n{\n    float t = 0.0;\n    \n    float r2 = ab.x*ab.x+ab.y*ab.y;\n    float az = ab.x*p.x;\n    float bw = ab.y*p.y;\n    \n    float A = 2.0*r2;\n    float B = -2.0*(az+bw);\n    float C = 0.0;\n    float D = -2.0*(az-bw);\n    float E = -2.0*r2;\n    \n    \n    float boa = B/A;\n    float coa = C/A;\n    float doa = D/A;\n    float eoa = E/A;\n    float boa2 = boa*boa;\n    \n    \n    //   = -3/8 (B/A)^2 + C/A\n    float alpha = -0.375 * boa2 + coa;\n    //   = 1/8 (B/A)^3 - 1/2 BC/A^2 + D/A\n    float beta  = 0.125 * boa2*boa - 0.5*boa*coa + doa;\n    //   = - 3/256 (B/A)^4 + 1/16 CB^2/A^3 - 1/4 BD/A^2 + E/A\n    float gamma = -3.0/256.0 * (boa2*boa2) + 0.0625 * coa*boa2 - 0.25 * boa*doa + eoa;\n    // when  = 0\n    //  t = -B/4A  ((-  (^2-4))/2)\n    //t = -0.25*boa + s1*sqrt(0.5*(-alpha + s2*sqrt(alpha * alpha - 4.0*gamma)));\n    // else\n    float alpha2 = alpha * alpha;\n    //  P = - ^2/12 - \n    float P = - alpha2 / 12.0 - gamma;\n    //  Q = - ^3/108 + /3 - ^2/8\n    float Q = - alpha*(alpha2 / 108.0 - gamma/3.0) - beta*beta / 8.0;\n    //  R = - Q/2  ((Q/2)^2 + (P/3)^3)\n    float R = - Q * 0.5 + sign(-Q)*sqrt(abs(Q*Q*0.25 + P*P*P/27.0));\n    //  U = R\n    float U = cbrt(R);\n    \n    //  d = -5/6  + (U==0? -Q : U - P/(3U))\n    float d = -5.0/6.0 * alpha + (U==0.0? -cbrt(Q) : U - P/(3.0*U));\n    //  W = ( + 2d)\n    float W = sqrt(alpha + 2.0 * d);\n    //  t = -B/4A + 1/2( _s W  (-(3 + 2d _s 2/W)))\n    t = -boa*0.25 + 0.5 * (s1*W + s2*sqrt(abs(3.0*alpha + 2.0*d + s1*2.0*beta/W)));\n    \n    float recip_t = 1.0/t;\n    return vec2(t-recip_t,t+recip_t)*ab;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 ra = (vec2(0.25,0.25) + 0.25*cos(iTime*vec2(1.1,1.3)+vec2(1.0,1.0) ))*0.25*(1.0625-sin(iTime));\n\t\n \tvec2 pd = pHyperbola( p, ra);\n    float d = length(pd-p)*inside_Hyperbola(p,ra);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    vec3 ploss = pHyperbola_loss(p,ra);\n    //uncomment the next line to see a map of floating point precision loss on the solution\n    col = p.x<m.x?ploss: col;\n    \n    \n    if( iMouse.z>0.001 )\n    {\n    pd = pHyperbola(m, ra);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0030));\n    col = mix(col, vec3(1.0,1.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.030));\n    \n    pd = pHyperbola_sols(m, ra,1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.025));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0020));\n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.020));\n    \n    pd = pHyperbola_sols(m, ra,1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0015));\n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.015));\n    \n    pd = pHyperbola_sols(m, ra,-1.0,-1.0);\n    d = length(pd-m);\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0010));\n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.0, 0.005, length(p-pd)-0.010));\n    \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSDG.jpg", "access": "api", "license": "mit", "functions": [[1858, 1858, 1883, 1883, 1910], [2993, 2993, 3017, 3017, 3059], [3060, 3060, 3085, 3085, 3115], [4329, 4467, 4504, 4857, 8182], [8184, 8242, 8286, 8286, 8439], [8442, 8467, 8507, 8507, 8558], [8559, 8559, 8602, 8602, 12040], [12043, 12083, 12153, 12153, 13776], [13784, 13784, 13841, 13841, 15929]], "test": "ok"}
{"id": "NtGBDR", "name": "Fluid sim mk2", "author": "thepinkpanzer", "description": "new fluid sim with a Godunov solver", "tags": ["simulation", "fluid"], "likes": 3, "viewed": 206, "published": 3, "date": "1676482698", "time_retrieved": "2024-07-30T18:10:05.644267", "image_code": "#define T(p) texture(iChannel0,(p))\n#define B(p) texture(iChannel1,(p))\n\nvec4 jet(float x) // from 0 to 1\n{\n    return pow(vec4(x*x*(1.-x)/0.148, pow(x*(1.-x)*4.,2.), x*(1.-x)*(1.-x)/0.148, 0), vec4(1.6));\n}\nvec4 twilight(float x) // from -1 to 1\n{\n    float s  = sign(x);\n    x *= s;\n    \n    float r  = mix(1., (s > 0. ? x*x : x*x*x*x*x), 0.8);\n    float b  = mix(1., (s < 0. ? x*x : x*x*x*x*x), 0.8);\n    float g  = mix(1., x*x*x*x, 0.95);\n    return vec4(r, g, b, 0);\n}\n\nvec4 recolor(float x)\n{\n    x = tanh(x);\n    return jet(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec4 Q   = T(uv);\n    vec4 q   = Q/Q.r;\n    \n    float ek = 0.5*(q.g*q.g+q.b*q.b);\n    float t  = q.a-ek;\n    float s  = (GAMMA-1.)*t*pow(Q.r, -GAMMA);\n    \n    // ek  is kinetic energy per unit mass\n    // t   is thermal energy per unit mass\n    // s   is related to the entropy\n    // Q.r is density\n    \n    // Colour scheme: vec4(tanh(ek/t*10.));//\n    fragColor = tanh(normalize(recolor(sqrt(t)*0.4))*Q.r);//tanh(vec4(Q.r));//recolor(q.b*2.);\n    // Draw obstacles in black\n    fragColor*= (1.-B(uv).r);\n    //fragColor = tanh((int(fragCoord.x + fragCoord.y) % 2 == 0 ? Q : abs(Q))/vec4(1,10,1,1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(p) texture(iChannel0,(p)/iResolution.xy)\n#define Y(p) texture(iChannel1,(p)/iResolution.xy)\n#define PI 3.1415926535897932384626\n\nfloat P(vec4 Q)\n{\n    float ek = (dot(Q.gb, Q.gb))/(2.*Q.r);\n    float T  = Q.a-ek;\n    float P  = T*(GAMMA-1.);\n    return P;\n}\nvec4 Flux(vec4 Q)\n{\n    float P = P(Q);\n    return vec4(Q.g, (Q.g*Q.g/Q.r + P), Q.g*Q.b/Q.r, Q.g/Q.r*(Q.a + P));\n}\nvec4 Flux(vec4 QL, vec4 QR)\n{\n    float PL = P(QL);\n    float PR = P(QR);\n    float uL = QL.g/QL.r;\n    float uR = QR.g/QR.r;\n    float aL = sqrt(GAMMA*PL/QL.r);\n    float aR = sqrt(GAMMA*PR/QR.r);\n    \n    float z  = (GAMMA-1.)/(2.*GAMMA);\n    float Ps = pow(((aL + aR) - (GAMMA-1.)/2.*(uR - uL))/(aL/pow(PL, z) + aR/pow(PR, z)), 1./z);\n    \n    float qL = Ps > PL ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Ps/PL - 1.)) : 1.;\n    float qR = Ps > PR ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Ps/PR - 1.)) : 1.;\n    \n    float SL = uL - aL*qL;\n    float SR = uR + aR*qR;\n    float Ss = ((PR - PL) + QL.r*uL*(SL-uL) - QR.r*uR*(SR-uR))/(QL.r*(SL-uL)-QR.r*(SR-uR));\n    \n    vec4 QLs = QL.r*((SL-uL)/(SL-Ss))*vec4(1,Ss,QL.b/QL.r,QL.a/QL.r + (Ss-uL)*(Ss+PL/(QL.r*(SL-uL))));\n    vec4 QRs = QR.r*((SR-uR)/(SR-Ss))*vec4(1,Ss,QR.b/QR.r,QR.a/QR.r + (Ss-uR)*(Ss+PR/(QR.r*(SR-uR))));\n    \n    vec4 flux;\n    if (Ss > 0.)\n    {\n        flux = Flux(QL);\n        if (SL < 0.)\n        {\n            flux += SL*(QLs - QL);\n        }\n    }\n    else\n    {\n        flux = Flux(QR);\n        if (SR > 0.)\n        {\n            flux += SR*(QRs - QR);\n        }\n    }\n    return flux;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting the data\n    float x   = fragCoord.x;\n    float y   = fragCoord.y;\n    \n    vec4 Q00  = T(vec2(x , y ));\n    // Q:    Quantities (vec4 of conserved quantities)\n    // Q.r:  Mass density\n    // Q.gb: X- and Y-momentum.\n    // Q.a:  Total energy (kinetic + thermal)\n    \n    // Boring boundary condition stuff\n    #if   X_BOUNDARY == 0\n        float xp  = mod(fragCoord.x + 1.0 + iResolution.x, iResolution.x);\n        float xm  = mod(fragCoord.x - 1.0 + iResolution.x, iResolution.x);\n\n        vec4 Qp0  = T(vec2(xp, y ));\n        vec4 Qm0  = T(vec2(xm, y ));\n    #elif X_BOUNDARY == 1\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = T(vec2(xm, y))*vec4(1,-1,1,1);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = T(vec2(xp, y))*vec4(1,-1,1,1);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #elif X_BOUNDARY == 2\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = T(vec2(xm, y))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = T(vec2(xm, y))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #elif X_BOUNDARY == 3\n        float xp  = x + 1.;\n        float xm  = x - 1.;\n        \n        vec4 Qp0;\n        vec4 Qm0;\n        if (xp >= iResolution.x)\n        {\n            Qp0 = mix(T(vec2(xm, y)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Qp0 = T(vec2(xp, y));\n        }\n        if (xm < 0.)\n        {\n            Qm0 = mix(T(vec2(xp, y)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Qm0 = T(vec2(xm, y));\n        }\n    #endif\n    #if   Y_BOUNDARY == 0\n        float yp  = mod(fragCoord.y + 1.0 + iResolution.y, iResolution.y);\n        float ym  = mod(fragCoord.y - 1.0 + iResolution.y, iResolution.y);\n        \n        vec4 Q0p  = T(vec2(x , yp));\n        vec4 Q0m  = T(vec2(x , ym));\n    #elif Y_BOUNDARY == 1\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = T(vec2(x, ym))*vec4(1,1,-1,1);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = T(vec2(x, yp))*vec4(1,1,-1,1);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #elif Y_BOUNDARY == 2\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = T(vec2(x, ym))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = T(vec2(x, yp))*vec4(1,-1,-1,1);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #elif Y_BOUNDARY == 3\n        float yp  = y + 1.;\n        float ym  = y - 1.;\n        \n        vec4 Q0p;\n        vec4 Q0m;\n        if (yp >= iResolution.y)\n        {\n            Q0p = mix(T(vec2(x, ym)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Q0p = T(vec2(x, yp));\n        }\n        if (ym < 0.)\n        {\n            Q0m = mix(T(vec2(x, yp)), Q00, 1.+ALPHA);\n        }\n        else\n        {\n            Q0m = T(vec2(x, ym));\n        }\n    #endif\n    \n    // Calculating the fluxes\n    vec4 Q1 = Q00;\n    Q1 -= DT*(Flux(Q00, Qp0) + Flux(Q00.xzyw, Q0p.xzyw).xzyw\n            - Flux(Qm0, Q00) - Flux(Q0m.xzyw, Q00.xzyw).xzyw);\n    \n    // Diffusion\n    Q1     += D0*(Qp0 + Qm0 + Q0p + Q0m - 4.*Q00)*DT;\n    \n    // Obstacles\n    float q = 0.5*Y(fragCoord).r;\n    Q1 *= vec4(1,1.-q,1.-q,1);\n    \n    // Initial conditions\n    if (iFrame == 0)\n    {\n        if (cos(3.*3.14159265*(fragCoord.y+5.*sin(3.14159*fragCoord.x/iResolution.x*3.))/iResolution.y) > 0.)\n        {\n            Q1 = vec4(1, 4.4,0,10);\n        }\n        else\n        {\n            Q1 = vec4(1,-4.4,0,10);\n        }\n    }\n    fragColor = Q1;//Q00;//FluxQ(Q1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// here i will store the fundamental laws of the universe\n// DT:    Timestep\n// D0:    Diffusion coefficient (numerical dissipation)\n// GAMMA: Adiabatic constant for the gas (1.67=monatomic, 1.4=diatomic, 1.33=polyatomic)\n#define DT      0.04\n#define D0      0.0\n#define GAMMA   1.67\n\n// Boundary conditions\n// 0: Loop\n// 1: Smooth wall\n// 2: No-slip wall\n// 3: Open (linear)\n#define X_BOUNDARY 0\n#define Y_BOUNDARY 1\n\n// Alpha is just used by the OPEN boundary condition\n// Describes whether to be more linear or flat.\n#define ALPHA 0.95\n// Alpha=0 -> flat\n// Alpha=1 -> linear\n// Alpha>=1 will probably be unstable.", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Obstacles\n    // Modelled as porous; gas can flow through somewhat (makes for a bit less stress on the system)\n    if (distance(fragCoord, iResolution.xy/2.) < 20.)\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 107, 107, 207], [208, 208, 248, 248, 473], [475, 475, 498, 498, 536], [538, 538, 595, 595, 1246]], "test": "untested"}
{"id": "DtBXWG", "name": "Reaction Diffusion ", "author": "SnoopethDuckDuck", "description": "It's very slow! Click the screen to play with it.\n\nInfluenced by: \nhttp://www.karlsims.com/rd.html\nhttps://www.shadertoy.com/view/MlByzR", "tags": ["worms", "reactiondiffusion"], "likes": 25, "viewed": 372, "published": 3, "date": "1676482402", "time_retrieved": "2024-07-30T18:10:06.456096", "image_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    float k = 1. / res.y;\n\n    // Uncomment to zoom (tracks mouse incorrectly)\n    float sc = 0.6;\n    //px = sc * (px - 0.5 * res) + 0.5 * res;\n    \n    vec4 col1 = tex(ch0, px);\n    vec4 col2 = tex(ch0, px - vec2(5));\n  \n    // Messy color stuff\n    vec4 col = vec4(3. * col1.g - 1.2 * col2.r);\n    if (col.g > 0.)\n        col.rgb *= 0.8 + 0.2 * cos(2.*pi*(col.g + vec3(0,1,2)/3.));\n    col = tanh(vec4(3.5, 1, 1, 1) * col);\n    float ab = 2. * abs(col.g-col2.g);\n    col = clamp(col, 0., 1.);\n    col += vec4(pow(ab, 5.));\n    \n    col = mix(col, vec4(1), 0.25 * (1.-col.r));\n\n    fragColor = col;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n\n#define Dir(a) vec2(cos(a), sin(a))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define res iResolution.xy\n\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec4 tex(sampler2D ch, in vec2 q) {\n    ivec2 p = ivec2(q);\n    ivec2 r = ivec2(vec2(textureSize(ch, 0)));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0 );\n}\n\nvec4 calc(sampler2D ch, vec2 px, vec2 rs, float t) {\n    float dt = 2.; // Delta t (large values break)\n    \n    vec4 c0 = tex(ch, px);\n    vec4 av = vec4(0);  // Average neighbor value\n    vec4 mx = vec4(0);  // Max neighbor value (unused)\n     \n    float n = 3.;\n    for (float i = -n; i <= n; i++)\n    for (float j = -n; j <= n; j++) {\n        if (vec2(i, j) != vec2(0)) {\n            vec4 cell = tex(ch, px + vec2(i, j));\n            av += cell;\n            mx = max(mx, cell);\n        }\n    }\n    av /= (2.*n+1.)*(2.*n+1.) - 1.;\n    \n    vec4 lap = av - c0; // Laplacian function (maybe)\n    //c0 += 0.008 * abs(av-mx);// mix(c0, 2. * abs(av-mx), 0.1); \n    \n    float A = c0.r;\n    float B = c0.g;\n    \n    float da = 0.65; // Diffusion rates\n    float db = 0.25;\n    float f = .075;  // Feed rate\n    float k = .062;  // Kill rate\n    \n    // (should be db*lap.g*B !!)\n    vec4 c = vec4(0);\n    c.r = A + (da*lap.r*A - A*B*B + f*(1.-A)) * dt;\n    c.g = B + (db*lap.g*A + A*B*B - (k+f)*B ) * dt;\n    return c;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 c = calc(ch0, px, res, iTime);\n    \n    if (iFrame < 1) {\n        c.r = 1.;\n        c.g = 0.;\n        c.g = step(length(px - 0.5 * res), 100.);\n        \n        c.r += h21(px + mod(iDate[3], 1000.)) - 0.5;\n    }\n    \n    if (iMouse.z >0. && length(iMouse.xy - px) < 32.)\n        c.g = 1.;\n\n    c = clamp(c, 0., 1.);\n    fragColor = c;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 c = calc(ch0, px, res, iTime);\n    c = clamp(c, 0., 1.);\n    fragColor = c;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 c = calc(ch0, px, res, iTime);\n    c = clamp(c, 0., 1.);\n    fragColor = c;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 c = calc(ch0, px, res, iTime);\n    c = clamp(c, 0., 1.);\n    fragColor = c;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 653]], "test": "untested"}
{"id": "DlSXWG", "name": "Rainbow Attack", "author": "Tabyltop", "description": "Just Testing", "tags": ["tabyltop"], "likes": 0, "viewed": 211, "published": 3, "date": "1676481957", "time_retrieved": "2024-07-30T18:10:07.219056", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 currentColor = vec3(texture(iChannel0, uv));\n    \n    // Output to screen\n    fragColor = vec4(col * 0.5 + currentColor *0.5,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 383]], "test": "untested"}
{"id": "fsG3Ry", "name": "BC - Beach", "author": "BackwardsCap", "description": "a crab on a beach", "tags": ["sketch", "beach", "buffers", "crab"], "likes": 9, "viewed": 239, "published": 3, "date": "1676476621", "time_retrieved": "2024-07-30T18:10:07.990992", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = texture(iChannel2, uv).rgb;\n    vec4 wave = texture(iChannel0, uv);\n    vec4 wetness = texture(iChannel1, uv);\n    if(wetness.a > 0.0) col -= 0.5;\n    else col -= (wetness.r + wetness.b) * 0.5;\n    \n    col = mix(col, wave.rgb, wave.a);\n    \n    vec4 crabValue = getCrabValue(nuv, iTime+CRAB_OFFSET, 3./iResolution.y);\n    \n    col = mix(col, crabValue.rgb, crabValue.a);\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32378, "src": "https://soundcloud.com/relaxing-white-noise/ocean-sounds-for-sleep-75-minutes", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 wave = getWaterLine(uv, iTime);\n    \n    float localBrim = getBrim(wave.y) + .01;\n    float wv = S(0., .05, wave.x - uv.y);\n    float b = S(0., 10./iResolution.y, (wave.x + localBrim) - uv.y);\n    vec3 foam = vec3(1);\n    vec2 waveCoord = vec2(uv.x, uv.y - wave.x);\n\n    foam -= pow(texture(iChannel0, uv + waveCoord - vec2(0, iTime*0.1)).r,.1) * .1;\n    \n    vec3 col = mix(foam, vec3(0.349,0.624,1.000), wv);    \n        \n    col -= length(waveCoord.y * 100.0) * 0.005;\n        \n    float w = 10.0;\n    float t = cos(iTime/20.0) * 3.0;\n    if(wave.x > uv.y)\n    {\n        float waveShading = length(cos(waveCoord.y * w + t)) * cos((waveCoord.x + waveCoord.y - t) * w);\n        col -= waveShading * 0.01;\n    }   \n        \n    \n    col = clamp(col, 0., 1.);\n\n    fragColor = vec4(col,max(wv,b));\n}", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define S(A,B,U) smoothstep(A,B,U)\n#define CRAB_OFFSET cos(iTime/10.0 + sin(-iTime*0.5+cos(iTime/2.-10.234)))*3.\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(2189.1283,8941.1283)))*(1828.1233));\n}\n\nfloat getBrim(float wave)\n{\n    float brim = 0.01;\n    float whiteLerp = (wave + 1.0)  * 0.5;\n    whiteLerp = pow(whiteLerp, 2.0);\n    return brim + (5.*brim * whiteLerp + brim/2.);\n}\n\nvec2 getWaterLine(vec2 uv, float time)\n{\n    float s = sin(uv.x * 5. + (sin(time / 10.0)*5.0)) * .05 + cos(time/2.0)*0.25;\n    float o = cos(time);\n    float scale = (0.5  * cos(time + sin(uv.x + cos(time + uv.x * 0.2))) + 1.0)/2.0;\n    \n    s*=scale;\n    s+=o*.3;\n    return vec2(s,o);\n}\n\nvec2 getCrabPosition(vec2 uv, float time)\n{\n    float crabX = mod((time-1.5)/10., 6.25) - 2.5;\n    return vec2(crabX-0.8, 1.3 + cos(time / 6.) * 0.05);\n}\n\n// thanks iq https://www.shadertoy.com/view/MlKcDD\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat sdBezier( vec2 p, vec2 v0, vec2 v1, vec2 v2 )\n{\n\tvec2 i = v0 - v2;\n    vec2 j = v2 - v1;\n    vec2 k = v1 - v0;\n    vec2 w = j-k;\n\n\tv0-= p; v1-= p; v2-= p;\n    \n\tfloat x = cro(v0, v2);\n    float y = cro(v1, v0);\n    float z = cro(v2, v1);\n\n\tvec2 s = 2.0*(y*j+z*k)-x*i;\n\n    float r =  (y*z-x*x*0.25)/dot2(s);\n    float t = clamp( (0.5*x+y+r*dot(s,w))/(x+y+z),0.0,1.0);\n    \n\treturn length( v0+t*(k+k+t*w) );\n}\nfloat o = 0.01;\nvec2 foff = vec2(0,-0.0075);\nvec2 footPos1(float dir, float t, float i){return vec2(0.045*dir,o+i*0.015)-foff;}\nvec2 footPos2(vec2 p1, float dir, float t, float i){return p1 + vec2(dir*0.025+cos(t)*o,3.*o+i*o)+foff;}\nvec2 footPos3(vec2 p1, float dir, float t, float i){return p1 + vec2(dir*0.05+pow(cos(t),2.)*o,o+i*o)+foff;}\nvoid drawLeg(vec2 uv, vec2 crabPos, float dir, float i, float t, inout float legs)\n{\n        vec2 p = uv - crabPos + vec2(0.00,0.02);\n        float m = (i < 3.) ? 1. : -1.;\n        vec2 p1 = footPos1(dir, t, i);\n        vec2 p2 = footPos2(p1, dir, t, i);\n        vec2 p3 = footPos3(p1, dir, t, i);\n        float d = sdBezier(p, p1, p2, p3);\n        legs = min(legs, d*10.);\n}\nfloat fs = 0.005;\nfloat thresh = .98;\nvoid drawFoot(vec2 p, float dir, float i, float t, inout float foot)\n{\n    float m = (i < 3.) ? 1. : -1.;\n    vec2 p1 = footPos1(dir,t,i);\n    vec2 p3 = footPos3(p1, dir, t, i);\n    float v = length(p-p3)-fs;\n    float anim = pow(cos(t),2.);\n\n    if(anim > thresh) foot = min(foot, v);\n}\n\nvec4 getCrabValue(vec2 uv, float time, float px)\n{   \n    uv*=1.5;\n    vec2 crabPos = getCrabPosition(uv, time)-vec2(0,0.03);\n    vec2 localPosition = (uv-crabPos);\n    localPosition = localPosition/vec2(1,.5 + abs(sin(localPosition.x*10.)) * sign(localPosition.y)*.5) + vec2(0,-.03);\n    float c = length(localPosition) - .02;\n    float cull = length(uv - crabPos) - .1;\n    cull = S(0., px, cull);\n    if(cull>0.)c=1.;\n    \n    time *= 10.0;\n    float t = time/2.;\n    float legs = 1.;\n    for(float i=0.;i<3.;i+=1.){\n        t -= .5;\n        drawLeg(uv, crabPos, -1., i, t, legs);\n    }\n    t = time/2.;\n    for(float i=0.;i<3.;i+=1.){\n        t -= 1.;\n        drawLeg(uv, crabPos, 1., i, t, legs);\n    }\n    float sl = smoothstep(px*10.5, 0., legs-0.05);\n    float sc = smoothstep(px*1.5,0.0,c/1.1-0.05);\n    vec3 color = mix(vec3(.8,0,0)*(1.0-pow(legs*10.,2.)), vec3(1,0,0)*(1.0-pow(c*10.,2.)), sc);\n    return vec4(color, max(sc, sl));\n}\nfloat crabFoot(vec2 uv, vec2 o, float s)\n{\n    return length(uv + o) - s;\n}\nfloat getCrabFeetValue(vec2 nuv, float time, float px)\n{\n\n    nuv*=1.5;\n    vec2 crabPos = getCrabPosition(nuv, time)-vec2(0,0.03);\n    time *= 10.0;\n    float t = time/2.;\n    float c= 1.0;\n    \n    vec2 p = nuv - crabPos + vec2(0.0,0.02);\n    for(float i=0.;i<3.;i+=1.){\n        t -= .5;\n        drawFoot(p, -1., i, t, c);\n    }\n    t = time/2.;\n    for(float i=0.;i<3.;i+=1.){\n        t -= 1.;\n        drawFoot(p, 1., i, t, c);\n    }     \n    return c;\n}\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 water = texture(iChannel0, uv);\n    vec4 selfSample = texture(iChannel1, uv);\n    float a = selfSample.a - 0.05;\n    vec2 wl = getWaterLine(nuv, iTime);\n\n    float localBrim = getBrim(wl.y);\n    \n    if(wl.x > nuv.y) selfSample.r = 1.0;\n    if(wl.x + localBrim > nuv.y)\n    {\n        float l = S(1.,0.,(nuv.y - wl.x) / localBrim);\n        selfSample.r = max(selfSample.r,l);\n    }\n    vec3 col = vec3(0);\n    float w = length(water.rgb);\n    col.r = clamp(selfSample.r * 0.996, 0.,1.);\n    col.b = selfSample.b * 0.9998;\n    col.g=0.;\n    float crabFeet = getCrabFeetValue(nuv, iTime+CRAB_OFFSET,3./iResolution.y);\n    if(crabFeet < 0.0) col.b = 0.2;\n    \n    fragColor = vec4(col,a);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.949,0.824,.663);\n    float sand = texture(iChannel0, uv * 5.).r;\n    float dunes = cos((uv.y + sin(uv.x * 10.0) * 0.015 * cos(uv.x/.1)) * 100.0);\n    \n    float size = 100.;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1);\n    vec2 cell = fract(uv * aspect * size);\n    vec2 id = floor(uv * aspect * size)/size;\n    float shells = rand(id*3.14);\n    \n    col -= dunes * 0.01;\n    col -= sand * 0.1;\n    \n    float thresh = .05;\n    if(shells <= thresh)\n    {\n        size = rand(id);\n        vec3 stoneColor = texture(iChannel1, cell).rgb;\n        col += (S(3./iResolution.y,0.,length(cell-.5)-0.3*pow(size,3.))*.3*rand(id*100.))*stoneColor;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 582]], "test": "untested"}
{"id": "dtjSRd", "name": "Linear vs Sin vs Scurve", "author": "djancool", "description": "You can change the s curve curvature with the CURVE define at line 2", "tags": ["sin", "linear", "scurve", "scurve"], "likes": 1, "viewed": 170, "published": 3, "date": "1676470883", "time_retrieved": "2024-07-30T18:10:08.743979", "image_code": "#define PI 3.14159265359\n#define CURVE 3.0\n\nfloat s_curve(float x, float p)\n{\n    float x1 = pow(x, p);\n    float x2 = pow(1.0 - x, p);\n    return x1 / (x1 + x2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0);\n    float dim = iResolution.x / iResolution.y;\n\n    float time = iTime * 0.2;\n    float time_frac = fract(time);\n    float time_pyr = min(time_frac, 1.0 - time_frac) * 2.0;\n\n    float s_offset = s_curve(time_pyr , CURVE);\n    float sin_offset = sin(time * PI * 2.0 + 1.5 * PI) * 0.5 + 0.5;\n    float l_offset = time_pyr;  \n    \n    float sphere1 = step(length(uv - vec2(0.1, 0.15) - vec2(s_offset * 1.575, 0.0)),  0.075);\n    float sphere2 = step(length(uv - vec2(0.1, 0.5) - vec2(sin_offset * 1.575, 0.0)), 0.075);\n    float sphere3 = step(length(uv - vec2(0.1, 0.85) - vec2(time_pyr * 1.575, 0.0)),  0.075);\n    float spheres = sphere1 + sphere2 + sphere3;\n\n    float gradient1 = uv.x / dim * float(uv.y > 0.6667);\n    float gradient2 = sin(uv.x / dim * PI * 0.5) * float(uv.y > 1.0/3.0 && uv.y < 2.0/3.0);\n    float gradient3 = s_curve(uv.x / dim, CURVE) * float(uv.y < 1.0/3.0);\n    float gradient = gradient1 + gradient2 + gradient3;\n    //gradient *= 1.0;\n    \n    vec3 col = mix(vec3(gradient), vec3(0.925,0.557,0.557), spheres);\n    col = pow(col, vec3(2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 77, 77, 164], [166, 166, 223, 223, 1432]], "test": "untested"}
{"id": "dt2SRt", "name": "3D Voronoi testje", "author": "djancool", "description": "3D voronoi", "tags": ["3d", "voronoi", "test"], "likes": 2, "viewed": 205, "published": 3, "date": "1676465253", "time_retrieved": "2024-07-30T18:10:09.571766", "image_code": "vec3 random(vec3 n)\n{\n  return fract(sin(dot(n, vec3(127.1, 311.7, 157.3))) * vec3(43758.5453123, 5453123.43758, 76975.1234567));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3(fragCoord/iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0), iTime * 0.05);\n    uv *= 15.0;\n\n    vec3 uv_floor = floor(uv);\n    vec3 uv_fract = fract(uv);\n    float sum = 1000.0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            for(int k = -1; k <= 1; k++)\n            {\n                vec3 index = vec3(i,j,k);\n                float dst = distance(uv_fract, random(uv_floor + index) + index);\n                sum = min(dst, sum);\n            }\n        }\n    }\n        \n    fragColor = vec4(vec3(sum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2SRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 131], [133, 133, 190, 190, 781]], "test": "untested"}
{"id": "dlBXWm", "name": "deconstructed telescope", "author": "elenzil", "description": "I set out to try subsurface scattering and a gyroid and ended up here. You know how it is.\nRaymarched except the plane.", "tags": ["lens", "optics", "telescope", "lenses"], "likes": 15, "viewed": 302, "published": 3, "date": "1676444076", "time_retrieved": "2024-07-30T18:10:10.501280", "image_code": "const uint mtl_0       =  0u;\nconst uint mtl_clear1  =  1u;\nconst uint mtl_clear2  =  2u;\nconst uint mtl_pink    =  3u;\nconst uint mtl_chrome  =  4u;\nconst uint mtl_floor   =  5u;\nconst uint mtl_grey    =  6u;\nconst uint mtl_mtl     =  7u;\nconst uint mtl_black   =  8u;\nconst uint mtl_white1  =  9u;\nconst uint mtl_count   = 10u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0        , 1.0 , v1),                   // sky\n    mtl_t(1.2        , 0.98, v1),                   // clear1\n    mtl_t(ior_aerogel, 0.94, v1),                   // clear2\n    mtl_t(1.2        , 0.0 , vec3(0.0, 0.8, 1.0)),  // pink\n    mtl_t(1e2        , 0.0 , v1),                   // chrome\n    mtl_t(1.0        , 0.0 , v1),                   // floor\n    mtl_t(1.0        , 0.4 , v1 * 0.4),             // grey\n    mtl_t(3.0        , 0.0 , vec3(0.5, 0.1, 0.1)),  // mtl\n    mtl_t(1.0        , 0.0 , v0),                   // black\n    mtl_t(1.0        , 0.0 , v1 * 0.8)              // white1\n);\n\nconst float cPixelize           =   1.0;\n\nconst float cMinRayAmt          =   1.0 / 256.0;\nconst uint  cMaxRays            =  22u;\nconst float cSurfEps            =   0.005;\nconst float cSelfSoftShadowDist =   0.5;\n\nconst int   cMaxMarchSteps      = 100;\nconst float cWSEps              =   0.002;\n      float gUnderStepFactor    =   1.0;\n\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 6u\nQ_IMPLEMENTATION\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gT           = 1e9;\nfloat gSmoothEps   = 1e9;\nvec3  gSunDir      = 1e9 * v1;\nvec3  gRGB         = 1e9 * (vX + vZ);\nfloat gSceneParam1 = 1e9;\n\nvec3  gBigLensDsc;\nvec3  gSmlLensDsc;\nfloat gBigLensFcl;\nfloat gSmlLensFcl;\nfloat gHeight;\nfloat gBigLensX;\nfloat gSmlLensX;\nmat2  gBigMatRot;\nmat2  gSmlMatRot;\n\nconst uint gLensMtl = mtl_clear1;\n\nfloat unitBounce(in float t) {\n    t = fract(t) * 2.0 - 1.0;\n    t *= t;\n    return 1.0 - t;\n}\n\nvoid setupScene() {\n    float sunT = gT * 0.1 + 3.3;\n    gSunDir = normalize(vec3(6.0 + cos(sunT), sin(sunT) * 2.0 + 2.5, 1.0));\n    \n    // lengths in cm\n    const float bigLensRad  =  6.0;\n    const float smlLensRad  =  1.0;\n    gBigLensFcl = 20.0;\n    gSmlLensFcl =  4.0;\n    \n    float ior = materials[gLensMtl].ior;\n    gBigLensDsc.xy = radiusAndOffsetForLens(gBigLensFcl, ior, bigLensRad);\n    gSmlLensDsc.xy = radiusAndOffsetForLens(gSmlLensFcl, ior, smlLensRad);\n    gBigLensDsc.z  = bigLensRad * 0.9;\n    gSmlLensDsc.z  = smlLensRad * 0.9;\n    \n    gBigLensX      = -gBigLensFcl / 2.0 + (gSceneParam1 * 2.0 - 1.0) * 6.0;\n    gSmlLensX      =  gBigLensFcl / 2.0 * 1.5;\n    \n    gBigMatRot = matRot2(pi * smoothstep(0.9, 1.0, fract(gT * 0.2       )));\n    gSmlMatRot = matRot2(pi * smoothstep(0.9, 1.0, fract(gT * 0.2 + 0.03)));\n    \n    gHeight = bigLensRad * 1.1;\n}\n\nmapSample_t map(in vec3 p) {\n    \n    MST ret = MST(1e9, mtl_0);\n\n    vec3 pa = p;\n    pa.y -= gHeight;\n    pa.x -= gBigLensX;\n    vec3 pc = pa;\n    pa.xz *= gBigMatRot;\n    opUnion(ret, MST(sdLensCc(pa, gBigLensDsc), mtl_clear1));\n    pc.x += gBigLensX - gSmlLensX;\n    pc.xz *= gSmlMatRot;\n    opUnion(ret, MST(sdLensCc(pc, gSmlLensDsc), mtl_clear1));\n    \n    vec3 pb = p;\n    pb.xy += vec2(90.0, -gHeight);\n    float cylHeight = gHeight * 0.6;\n    opUnion(ret, MST(sdCappedCylinderX((pb + vX * 10.0 + vY * (gHeight - cylHeight)).yxz, cylHeight, 2.0) - 0.1, mtl_white1));\n    pb.xy *= matRot2(gT * 0.76);\n    pb.xz *= matRot2(gT * 0.67);\n    opUnion(ret, MST(sdBoxFrame(pb, vec3(1.0), 0.1) - 0.08, mtl_clear2));\n\n//  opUnion(ret, MST(sdBoxFrame(p - vY * 1.1, vec3(1.0), 0.1) - 0.08, mtl_pink));\n\n    return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        mapSample_t ms = map(p);\n        if (ms.dist * r.side < cWSEps) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            h.miss     = 0.0;\n            return;\n        }\n        else {\n            if (t > cSelfSoftShadowDist && ms.dist < h.miss) {\n                h.miss  = ms.dist;\n                h.missT = t;\n            }\n        }\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n}\n\n\n//------------------------------------------------------------------\n\nvec3 toneSky(in ray_t r) {\n    vec3 rgb = simple_sky(r.ro, r.rd, gSunDir);\n    float theta = atan(r.rd.z, r.rd.x);\n    float q = 2.0 - smoothstep(1.0, 0.98, cos((theta + pi/2.0) * 50.0));\n    rgb *= q;\n    return rgb;\n}\n\nvec3 toneFloor(in vec2 p) {\n    return texture(iChannel0, fract(p * 0.03)).rgb;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n//------------------------------------------------------------------\n\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit\n            gRGB += r.amt * tone(r, h);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n            \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            float reflAmt = schlick  (R0, dot(r.rd, -nrm));            \n            float trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            float diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n                        \n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n\n            if (diffAmt > cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                // cast a ray for shadows.\n                ray_t shdRay;\n                shdRay.ro         = h.pnt + h.nrm * cSurfEps;\n                shdRay.rd         = gSunDir;\n                shdRay.amt        = diffAmt;\n                shdRay.side       = 1.0;\n                hit_t shdHit      = newHit();\n                \n                float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                \n                rayVsScene(shdRay, shdHit);\n                float lit = 1.0 - float(shdHit.hit);\n                float blur = shdHit.missT * 0.03;\n                lit *= smoothstep(0.0, blur, shdHit.miss);\n                                \n                vec3 diff = lit * diffAmt * sunDot * tone(r, h);\n                                \n                gRGB += diff;\n            }\n\n            // moving on to transmission and then reflection.\n            \n            if (QSpaceLeft() < 2u) {\n                continue;\n            }\n            \n            if (gRayCount >= cMaxRays) {\n                continue;\n            }\n            \n            if (trnsAmt > cMinRayAmt) {\n                float eta = ior_air / m.ior;\n                if (r.side < 0.0) {\n                    eta = 1.0 / eta;\n                }\n                vec3 trnRayDir = refract(r.rd, nrm, eta);\n                if (dot(trnRayDir, trnRayDir) < 0.001) {\n                    // total internal reflection.\n                    // this is theoretically impossible for a ray that entered a sphere,\n                    // but keeping it in here anyhow for more exotic scenarios.\n                    reflAmt += trnsAmt;\n                }\n                else {\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = trnRayDir;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    \n                    QEnqueue(trnRay);\n                }\n            }\n\n            if (reflAmt > cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime * 0.2;\n    gSmoothEps = 4.0 / MINRES;\n    \n    // pixelate\n    vec2 XY2 = XY - (fract(XY / cPixelize ) - 0.5) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    \n    vec4 inp = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 m  = viewportFromScreen(inp.xy);\n    if (length(inp.xy) < 50.0) {\n        const vec2 start = vec2(0.7, -0.7);\n        m = mix(start, v0.xy, smoothstep(2.0, 9.0, iTime));\n    }\n    gSceneParam1 = inp.z / iResolution.y;\n\n    setupScene();\n                \n    // setup camera\n    float theta     = sign(m.x) * pow(abs(m.x), 2.0) * -pi / 3.0;\n    vec3  lookTo    = vY * gHeight;\n    vec3  lookFrom  = vec3(cos(theta), gHeight - 15.0 * sign(m.y) * pow(abs(m.y), 2.5), sin(theta));\n    lookFrom.xz  *= gSmlLensX * 1.2 + abs(theta * 15.0);\n    lookTo.x += abs(theta * 2.0);\n    //lookFrom = vec3(gBigLensFcl * 0.5 + gSmlLensFcl * 2.0, gHeight, 0.0);\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -3.0));\n    r0.amt  = 1.0;\n    r0.side = 1.0;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n       \n    // uncomment to view relative # of rays per pixel\n    // gRGB = v1 * float(gRayCount) / float(cMaxRays);\n    \n    RGBA = vec4(gRGB, 1.0);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float miss;  // smallest distance to a shadowing point.\n    float missT; // distance to miss.\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit      = false;\n    ret.t        = 1e9;\n    ret.miss     = 1e9;\n    ret.missT    = 1e9;\n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// assumes 'up' is world Y.\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// how far to offset each of two spheres of radius sphRad\n// to obtain a lens of radius lensRad\nfloat offsetToMakeLens(float sphRad, float lensRad) {\n    return sqrt(max(0.0, (sphRad * sphRad) - (lensRad * lensRad)));\n}\n\n// lensmaker's equation\nfloat radiusForFocalLength(float focalLength, float ior) {\n    return (ior - 1.0) * 2.0 * focalLength;\n}\n\nvec2 radiusAndOffsetForLens(float focalLength, float ior, float lensRad) {\n    vec2 ret;\n    \n    ret.x = radiusForFocalLength(focalLength, ior);\n    ret.y = offsetToMakeLens(ret.x, lensRad);\n    \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    p.y *= -1.0;\n    p.y = max(0.1, p.y);\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCyl(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// return a symmetric bi-concave lens shape given:\n// desc.x = sphere radius\n// desc.y = lens radius\n// desc.z = chamfer radius\nfloat sdLensCc(in vec3 p, vec3 desc) {\n\n    p.x = abs(p.x) + desc.y;\n    \n    float dCyl = length(p.yz) - desc.z;\n    \n    float d = length(p) - desc.x;\n    \n    d = max(d, dCyl);\n    \n    return d;\n}\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n\n", "buffer_a_code": "// mouse state\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (iFrame < 2) {\n        RGBA = vec4(0.0, 0.0, iResolution.y / 2.0, 0.0);\n        return;\n    }\n    \n    if (IJ == ivec2(0)) {\n        RGBA = texelFetch(iChannel0, IJ, 0);\n        if (iMouse.x > iResolution.x - 100.0) {\n            RGBA.z = iMouse.y;\n        }\n        else {\n            RGBA.xy = iMouse.xy;\n        }\n    }\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1822, 1822, 1852, 1852, 1916], [1918, 1918, 1937, 1937, 2792], [2794, 2794, 2822, 2822, 3610], [3612, 3770, 3793, 3793, 3995], [3998, 3998, 4042, 4092, 4770], [4843, 4843, 4869, 4869, 5062], [5064, 5064, 5091, 5091, 5145], [5147, 5147, 5182, 5182, 5386], [5474, 5474, 5490, 5519, 8807], [8809, 8809, 8852, 8852, 10280]], "test": "untested"}
{"id": "DlBSzd", "name": "WOAHHHH (first shadertoy)", "author": "waawaw", "description": ":)", "tags": ["boring"], "likes": 1, "viewed": 168, "published": 3, "date": "1676426633", "time_retrieved": "2024-07-30T18:10:11.345024", "image_code": "#define NUM_BARS 40.0\n#define BAR_WIDTH (1.0 / NUM_BARS)\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n#define NUM_WAVES 3.0\n\nfloat step2(float left, float right, float x)\n{\n    return step(left, x) * step(x, right);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float current_bar = floor(uv.x / BAR_WIDTH);\n    float bar_start = current_bar * BAR_WIDTH;\n    float bar_end = bar_start + BAR_WIDTH;\n    float offset = iTime * 2.0;\n    float bar_height = (sin(offset + bar_start * TWO_PI * NUM_WAVES) + 1.0) / 2.0;\n    float g = step2(bar_start, bar_end, uv.x) * step(uv.y, bar_height);\n\n    fragColor = vec4(g*uv.y, g, bar_height*g/1.4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 172, 172, 217], [219, 219, 274, 274, 702]], "test": "untested"}
{"id": "clBSzd", "name": "Arabesque knots", "author": "jarble", "description": "An arabesque knot pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "arabesque"], "likes": 10, "viewed": 352, "published": 3, "date": "1676425375", "time_retrieved": "2024-07-30T18:10:12.210710", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*1.5;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = uv.y > uv.x;\n    bool b1 = b;\n    \n    //rotate 45 degrees\n    mat2 r = rotate2D(-0.785398);\n\n    \n    for(int k = 0; k < 9; k++){\n        //uv.x += t1_(floor(uv),floor(uv))/2.;\n        b1 = uv.y>uv.x || !b1;\n        //if(b1)\n        uv =\n            abs(.5+uv+t2)\n            //abs(.5-max(uv+t2,t2)-t2)\n            //abs(max(uv,t2)+t2)\n            //(max(abs(uv-t2*2.)/2.,abs(t2)*2.))\n            //abs(.5+max(uv,t2)+t2)\n            //min(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))\n            //abs(.5+uv+t2*(1.+mod(floor(uv.y),2.)/2.))\n            //abs(.5+uv+t2+pow(floor(uv.x),2.)/1.5)\n        ;\n\n        //if((t2.x)>(t2.y) || k%2 == 0) uv /= 1.5;\n\n        //k += int(uv.x>uv.y);\n        //uv += float(int(iTime)/3);\n        \n        //uv += sign(uv-uv.yx)/2.+.5;\n        //uv += floor(uv*1.5); //another interesting pattern\n        \n        //if(t2.y>t2.x||t2.y<t2.x&&!b)\n        b =\n            uv.y>uv.x\n            //(b && uv.y<uv.x)||(!b && t2.y<t2.x)\n            //(uv.y>uv.x||t2.y<t2.x)&&!b\n            //uv.y>uv.x*float(t2.y>t2.x)\n            //uv.y>uv.x*float(t2.y>t2.x) //makes a braided pattern\n            //uv.y>uv.x+float(!b1)\n            //uv.y*float(!b1)>uv.x\n        ;\n        if(b) uv = uv.yx;\n        \n        //else {k += 1; uv *= 1.5; col=col.yzx;}\n        //uv.x += sign(t2.x-t2.y);\n        //uv.x += sign(uv.x-uv.y);\n\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        \n        //if(t2.y<t2.x) t2 = t2*1.5; else t2=t2/1.5;\n\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+floor(uv.x*2.))\n        ;\n        //if(t2.y>t2.x)\n        //if(col.y<col.x||uv.y<uv.x)\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            //abs(vec3(col.zx*float(b),max(uv.x-uv.y,0.)))\n            //abs(vec3(col.zx,max(-uv.x+uv.y,col.y))-col.y)\n            //max(vec3(col.zx,max(uv.x-uv.y,col.y)).yzx,vec3(col.y))\n            //vec3(col.zx,max(uv.y-uv.x,t2.x-t2.y))\n            //vec3(col.zx,max(max(t2.x-t2.y,uv.x-uv.y),0.))\n            //vec3(col.zx,max(uv.x+uv.y+1.,0.))\n            //abs(vec3(col.zx,max(uv.x-uv.y,col.y)))\n            //vec3(col.xy,max(uv.x-uv.y,col.z)).yzx\n            //vec3(col.zx,max(uv.x-uv.y,col.x))\n            //abs(sign(uv.x-uv.y)/2.-vec3(col.zx,max(uv.x-uv.y,0.)))\n        ;\n        //uv /= 1.+mod(uv.x,2.);\n        //if(t2.x>t2.y) col=col.yzx;\n        //uv.y -= float(uv.x<uv.y)/2.;\n\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "int collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    \n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat mod1(float a, float b){\n    //a += collatz(a,8.);\n    return\n        mod(a,b)\n        //mod(a+floor(b*2./5.),b)\n    ;\n}\n\n\n//multiply by prime numbers to get an interesting rhythm\nfloat fmod(float a, float b){\n    \n    \n    \n    /*\n    for(float i = 0.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/8.),8.)*i;\n    }\n    */\n    \n    //divide by powers of 2 and multiply by prime numbers to get interesting rhythms\n    a += mod1(floor((a)/128.)*19.,128.);\n    a += mod1(floor((a)/64.)*17.,64.);\n    a += mod1(floor((a)/32.)*13.,32.);\n    a += mod1(floor((a)/16.)*7.,16.);\n    a += mod1(floor((a)/8.)*5.,8.);\n    a += mod1(floor((a)/4.)*3.,4.);\n    a += mod1(floor((a)/2.)*2.,2.);\n\n    //a += mod(floor((a)/2.)*13.,2.);\n    //a += mod(floor((a)/2.)*17.,2.);\n    return mod1(floor(a),b);\n}\n\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)*2.+floor((a)/4.)*3.+floor((a)/8.)*5.+floor((a)/16.)*7.,b)\n\n\n\n\n\n//some other rhythms:\n\n//#define fmod(a,b) min(mod(floor(a)+floor((a)/2.)*2.+floor((a)/4.)*3.+floor((a)/8.)*5.+floor((a)/16.)*7.,b),mod(floor(a),b))\n//#define fmod(a,b) mod(floor(a),b)\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)+floor((a)/4.)+floor((a)/8.),b)\n//#define fmod(a,b) mod(floor(a)+floor((a)/2.)+floor(a*pow(2.,mod(floor(a),3.))),b)\n\nvec2 mainSound(int samp, float time){\n  \n  //time /= 64.*2.;\n  float s1 =\n      8.;\n  time = (time + floor(time*s1)/s1);\n  float\n  t= //varying tempo\n      (((time)/s1+max(fract(-time/2.),fract(time))/8.))/4./(1.+fmod(time*4.-floor(time/s1),2.)),\n  t1 = fmod(t,2.)\n  ;\n  t *=\n      (s1*s1)\n  ;\n  float a= //instruments\n      16.*pow((1.-(fract(t))),2.)\n  ,\n  nb = time*pow(2.,(1.+t1)*(2.+fmod(t/(1.+t1),s1)+1. + fmod(floor(t/s1),2.))/7.+6.5)/2.;\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 107], [109, 109, 136, 136, 297], [299, 299, 323, 323, 375], [492, 492, 518, 518, 607], [609, 609, 666, 666, 3439]], "test": "untested"}
{"id": "mt2XR3", "name": "Mediterranean Sea", "author": "guil", "description": "Test of sea  transparency", "tags": ["wave", "sea", "reef"], "likes": 20, "viewed": 375, "published": 3, "date": "1676413593", "time_retrieved": "2024-07-30T18:10:13.041489", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=.7;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<12;i++){\t\n\t\tvec3 n = noised(p);\n        r += abs(noise( p*f +n.xz)+.5)/f;       \n\t    f *=1.45;\n        p=m2*p;       \n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=.7;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<6;i++){\t\t\t\n        r += (1.-abs(noise( p*f -.6*time)))/f;       \n\t    f *=1.4;\n        p-=vec2(-.01,.04)*(r+.2*time/(.1-f));\n\t}\n\treturn r/4.+.8;\n}\n\n\n\nfloat rocks(vec2 p){   \n   return 1.-fbmabs(p)*.15;   \n}\n\nvec3 map( vec3 p)\n{\n\tfloat d1 =p.y+ cos(.2*p.x-sin(.5*p.z))*cos(.2*p.z+sin(.3*p.x))+.5-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    //dh = d2-d1;\n    float d = min(d1,d2);\n\treturn vec3(d,d1,d2);\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n    return sin(vec3(1.7,1.5,1)+ 2.-fbmabs(p*12.)*.25)+.3;\n}\n\nvec3 march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 35.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t).x;\n        t += h*.5;\n    }\n    if(t < maxd) res = t;\n    return vec3(res,map(ro + rd * t).yz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    vec3 li = normalize(vec3(2., 2., -4.));   \n    \n    vec3 v = march(ro, rd);\n    float t = v.x;\n    float dh = v.z-v.y;\n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;       \n        float k=rocks(pos.xz)*2.;       \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.05)/2.;\n        col =vec3(r*k*k, r*k, r*.8)+.4*exp(-150.*dh*dh);\n        if(dh<0.03){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n            col +=vec3(0.9,.2,.05)*dh*1.;\n        \tcol += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.5);\n        \tcol +=.2* sky(nor.xz/(.5+nor.y));\n            \n        }\n\t    col = .1+col;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(.1+rd.y));\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2XR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[211, 211, 234, 234, 409], [411, 411, 434, 458, 772], [775, 775, 799, 799, 989], [991, 991, 1013, 1013, 1213], [1217, 1217, 1237, 1237, 1273], [1275, 1275, 1294, 1294, 1485], [1487, 1487, 1516, 1516, 1669], [1671, 1671, 1698, 1698, 1843], [1845, 1845, 1866, 1866, 1927], [1929, 1929, 1965, 1965, 2293], [2296, 2296, 2353, 2353, 3280]], "test": "untested"}
{"id": "clSSRt", "name": "Squeeze Pillar ", "author": "SnoopethDuckDuck", "description": "I was playing with squashing + squeezing a rect, and had the idea to stack them.\nIt's quite wormy, maybe something fun could be made with this", "tags": ["squeeze", "squash"], "likes": 35, "viewed": 308, "published": 3, "date": "1676406387", "time_retrieved": "2024-07-30T18:10:13.867281", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (f - 0.5 * res) / res.y;\n    float k = 1. / res.y;\n    float t = iTime;    \n       \n    // Starting point, centre bottom of new box\n    float h = -0.45;\n    vec2 q = vec2(0, h);\n    \n    // Stretched box dimensions\n    vec2 mxDim = vec2(0);\n    \n    // Step box distances\n    float s = 0.;\n    float s2 = 0.;\n    float s3 = 0.;\n    \n    float n = 12.;\n    for (float i = 0.; i < n; i++) {\n        // Offset\n        float io = 0.5 * pi * i / n;\n        \n        // Base dimensions of box\n        vec2 dim = vec2(0.04);\n        \n        // Squeeze amount\n        float mx = 0.5 + 0.25 * thc(9., t + 2.*pi*q.y + io);\n        //mx = 0.5 + 0.25 * thc(3., t + 4. * io);\n        \n        // Centre of box \n        // = centre of previous box + height of both squeezed boxes\n        vec2 p = q;\n        p.y += mxDim.y;\n        p.y += 2. * dim.y * (1. - mx);      \n        \n        // Squeezed dimensions of box\n        mxDim = 2. * dim * vec2(mx, 1. - mx);\n          \n        // Draw box\n        float d = sdBox(uv - p, mxDim);\n        float d2 = sdBox(uv - p, mxDim - 0.15 * dim);\n        float d3 = length(uv - p);     \n        s += smoothstep(-k, k, -d);\n        s2 += smoothstep(-k, k, -d2);   \n        s3 += smoothstep(-k, k, 0.01 - d3);\n        \n        // Reset previous centre\n        q = p;\n        //q.x += 0.5 * cos(t + 0.5 * io) * dim.x;\n    }\n    \n    vec3 col = vec3(0.5 * smoothstep(-k, k, h - uv.y));\n    col += s * vec3(1, 0.5, 1);\n    col += 0.5 * (s3 - s2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 135, 135, 215], [217, 217, 266, 266, 1818]], "test": "untested"}
{"id": "dtjSRc", "name": "Easy Text Test", "author": "Calgon", "description": "Trying to make a really simple way to display text on screen.", "tags": ["2d", "transparency", "text", "font", "scale", "print", "align", "texturedfont"], "likes": 5, "viewed": 297, "published": 3, "date": "1676402545", "time_retrieved": "2024-07-30T18:10:14.629243", "image_code": "// Forked from\n// https://www.shadertoy.com/view/XlfyRr\n\n\nint _= 32; \nint _0 = 48;\nint _1 = 49;\nint\t_2 = 50;\nint\t_3 = 51;\nint\t_4 = 52;\nint _5 = 53;\nint _6 = 54;\nint _7 = 55;\nint _8 = 56;\nint _9 = 57;\nconst int A = 65;\nconst int B = 66;\nconst int C = 67;\nconst int D = 68;\nconst int E = 69;\nconst int F = 70;\nconst int G = 71;\nconst int H = 72;\nconst int I = 73;\nconst int J = 74;\nconst int K = 75;\nconst int L = 76;\nconst int M = 77;\nconst int N = 78;\nconst int O = 79;\nconst int P = 80;\nconst int Q = 81;\nconst int R = 82;\nconst int S = 83;\nconst int T = 84;\nconst int U = 85;\nconst int V = 65;\nconst int W = 66;\nconst int X = 67;\nconst int Y = 68;\nconst int Z = 69;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\n\n/*\nascii table:\nhttp://www.theasciicode.com.ar/american-standard-code-information-interchange/ascii-codes-table.png\n*/\n\n\n\n\n// char size 64*64   16 char per row\nvoid WriteChar(vec2 screenCoord, vec2 pos, float charValue, float fontSize, vec4 fontColor, inout vec4 pixel)\n{\n  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+fontSize && screenCoord.y >=pos.y && screenCoord.y <=pos.y+fontSize)\n  {\n      // calculate texture grab position of character\n      float col = mod(charValue,16.0);\n      vec2 charPos = vec2(col,(charValue-col)/16.0);\n      charPos *= 64.0;\n      \n      vec2 dist = screenCoord-pos;\n\n//      vec2 steps = (vec2(1.0,-1.0) / iChannelResolution[0].xy);\n      vec2 steps = (vec2(1.0,-1.0) / vec2(1024,1024));\n      vec2 startOffset = charPos *steps;\n      // scale texture uv step by fontSize\n      steps*=(1.0/(fontSize/64.0));\n      dist *=steps;\n      vec4 ccc = texture(iChannel0,startOffset+dist);\n\n      // Check if texture is a part of the character\n      if(ccc.r>0.6)\n      {\n        pixel=mix(pixel,fontColor, fontColor.w);\n      }      \n  }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frame = radians(iTime)*120.0;\n    float cosValue = cos(frame);\n    float sinValue = sin(frame);\n    \n    vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color; \n        \n    // backdrop effect\n    if (mod(screenCoord.x,50.0)+mod(screenCoord.y,50.0) < 50.0)\n    {\n         color = vec4(0.15);\n    }\n    else\n    {\n         color = vec4(0);\n    }\n        \n    // SET TEXT VARIABLES ********************\n    vec2 textPos = vec2(-1150.0+(mod(frame*200.0,2000.0)),40.0+cos(frame+uv.x*5.0)*25.0);\n    float fontSize = 112.0;\n    float charSpacing = fontSize*0.5;\n    vec4 fontColor = vec4(uv.x,uv.x*4.0, 1.0-uv.x,1.0);\n\n    // write text by storing as an array of ascii values (table above)\n    // A SMALL TEST OF\n    int text[15] = int[](A,_,s,m,a,l,l,_,T,E,S,T,_,O,F);\n    \n    for(int iii=0; iii<15; iii++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(iii)*charSpacing,0.0),float(text[iii]),fontSize, fontColor, color);\n    }  \n    // THE BELOW CODE IS JUST VARIATIONS\n    // ****************************************\n    \n    \n    // CENTER SCALE TEST ******************** \n    textPos = iResolution.xy*0.5;\n    fontSize = 78.0 + (cosValue*32.0);\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(0.5-cosValue*0.5,0.5+cosValue*0.5, uv.x*1.0,1.0);\n    \n    // center text \n    // FONTS &\n    int text2[7] = int[](f,o,n,t,s,_,38);\n    textPos.x -= (7.0*charSpacing)*0.5;\n    textPos.y -= fontSize*0.5;\n    \n    for(int iii=0; iii<7; iii++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(iii)*charSpacing,0.0),float(text2[iii]),fontSize, fontColor, color);\n    }\n  \n    \n    // NUMBERS AND TRANSPARENCY ******************** \n    textPos = vec2(180.0+cos(frame+uv.x*25.0)*5.0,320.0+sin(frame+uv.x*25.0)*5.0);\n    fontSize = 76.0;\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(uv.x*4.0,2.0-uv.x, 2.0*uv.y,0.2);\n    \n    // # 123456789\n    int text3[12] = int[](35,_,_1,_2,_3,_4,_5,_6,_7,_8,_9,_0);\n    \n    for(int iii=0; iii<12; iii++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(iii)*charSpacing,0.0),float(text3[iii]),fontSize, fontColor, color);\n    }\n    \n    fragColor = color;\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1283, 1320, 1431, 1431, 2235]], "test": "untested"}
{"id": "ctSSRV", "name": "Better Materials pt", "author": "RubberDuck55", "description": "Pathtracer with better materials", "tags": ["3d", "materials", "pathtracer"], "likes": 7, "viewed": 256, "published": 3, "date": "1676398097", "time_retrieved": "2024-07-30T18:10:15.380235", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = vec4(data.rgb / data.a, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Loosely Based off of methods described here:\n// https://blog.demofox.org/#Graphics\n\n// Raymaracher Settings\n#define MAX_DIST   100.\n#define MAX_STEP   250\n#define SURF_DIST  0.01\n\n// Pathtracer Settings\n#define BOUNCES    4\n#define SAMPLES    2 // Increase this number if it is still running at 60fps\n\n// Surface Settings\n#define COLR       0\n#define CHEK       1\n\n\nfloat seed;\n\nstruct MaterialInfo {\n    vec3 albedo;\n    vec3 emissive;\n    vec3 specular;\n    float specPercent;\n    float specRough;\n    vec3 refraction;\n    float refrPercent;\n    float refrRough;\n    float IOR;\n    int surface;\n};\n\nMaterialInfo zeroed_mat () {\n    return MaterialInfo (\n        vec3(0.05),\n        vec3(0.),\n        vec3(0.),\n        0.,\n        0.,\n        vec3(0.),\n        0.,\n        0.,\n        0.,\n        COLR\n    );\n}\n\nstruct HitInfo {\n    float dist;\n    vec3 pos, n, ro, rd;\n    bool hit;\n    bool fromIn;\n    MaterialInfo mat;\n};\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1416 * 4.;\n    float theta = (rand()-0.5) * 3.1416 * 4.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nfloat dist_mat (vec3 p, out MaterialInfo m) {\n\n    float dg = p.y+1.0;\n    float dsr = length(p-vec3(0,.1,0))-1.;\n    float ds1 = length(p-vec3(1., 0., 2.))-1.0;\n    float ds2 = length(p-vec3(3., 0., 0.))-1.;\n    float ds3 = length(p-vec3(-2., 0., 2.))-1.;\n    \n    float minD = min(dg, min(min(ds1, ds2), min(ds3, dsr)));\n    \n    m = zeroed_mat();\n    \n    if(minD == dg) {\n        m.albedo = vec3(1.);\n        m.surface = CHEK;\n    }\n    if(minD == ds1) {\n        m.albedo = vec3(0.9, 0.9, 0.5);\n        m.specPercent = 0.1;\n        m.specRough = 0.;\n        m.specular = vec3(.9);\n    }\n    if(minD == ds2) {\n        m.albedo = vec3(0.9, 0.2, 0.2);\n        m.specPercent = 0.5;\n        m.specRough = 0.4;\n        m.specular = vec3(0.2, 0.2, 0.9);\n    }\n    if(minD == ds3) {\n        m.albedo = vec3(0.9);\n        m.specPercent = 1.;\n        m.specRough = 0.7;\n        m.specular = vec3(0.5, 0.9, 0.5);\n    }\n    if(minD == dsr) {\n        m.albedo = vec3(1.);\n        m.refrPercent = 1.;\n        m.IOR = 1.5;\n    }\n    \n    return minD;\n}\n\nfloat dist (vec3 p) {\n    MaterialInfo m;\n    return dist_mat(p, m);\n}\n\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nHitInfo raymarch (vec3 ro, vec3 rd) {\n    \n    float dO = 0.0;\n    \n    bool hit = false;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        \n        float d = abs(dist(p));\n        \n        if(d <= SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            hit = false;\n            break;\n        }\n        \n        dO += d;\n    }\n    \n    vec3 p = ro + rd * dO;\n    \n    MaterialInfo m;\n    dist_mat(p, m);\n    \n    bool inside = dist(p) < 0.0;\n    \n    return HitInfo (dO, p, normal(p), ro, rd, hit, inside, m);\n}\n\nvec3 color ( in vec3 ro, in vec3 rd ) {\n    \n    vec3 throughput = vec3(1.0);\n    vec3 final = vec3(0.0);\n    \n    for(int i = 0; i < BOUNCES; i++) {\n        \n        vec3 col = vec3(0.);\n        \n        HitInfo h = raymarch(ro, rd);\n        \n        if(h.hit == false) {\n            col = texture(iChannel1, h.pos).rgb*3.;\n            throughput  *=  col;\n            final += throughput;\n            break;\n        }\n        \n        float isSpec = rand() < h.mat.specPercent ? 1.0 : 0.0;\n        \n        vec3 diffrd = rand_hemisphere(h.n);\n        vec3 specrd = reflect(h.rd, h.n);\n        specrd = normalize(mix(specrd, diffrd, h.mat.specRough*h.mat.specRough));\n        \n        rd = mix(diffrd, specrd, isSpec);\n        ro = h.pos + h.n * SURF_DIST*2.0;\n        \n        // TEMP\n        if(h.mat.refrPercent == 1. ){\n            if (h.fromIn) {\n                rd = refract(h.rd, -h.n, h.mat.IOR);\n            }\n            else {\n                rd = refract(h.rd, h.n, 1./h.mat.IOR);\n            }\n        \n            if(!h.fromIn) {\n                ro = h.pos - h.n * SURF_DIST*2.0;\n            }\n        }\n        // TEMP\n        \n        if (h.mat.surface == COLR)\n            col = mix(h.mat.albedo, h.mat.specular, isSpec);\n        if (h.mat.surface == CHEK) {\n            col = mix(vec3(0.6),vec3(0.5),round(0.5+0.25*(sin(h.pos.x*3.)+sin(h.pos.z*3.))));\n        }\n        \n        final += throughput * h.mat.emissive;\n        throughput *= col;\n    }\n    \n    return final;\n}\n\nvec3 aces_filmic (vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ivec2(fragCoord) == ivec2(0)) {\n        fragColor = vec4(iResolution.xy, iMouse.xy);\n        return;\n    }\n    \n    vec2 res = iResolution.xy;\n    \n    init_rand(fragCoord + iTime * res.x);\n    \n    vec2 tv = ( ( ( fragCoord + vec2( rand(), rand() ) ) / res) -.5 ) / vec2(res.y / res.x, 1.0);\n    \n    vec3 ro = vec3(0., 0., -5.);\n    vec3 rd = normalize(vec3(tv, 1.));\n    \n    // Rotations\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    \n    rd.yz *= rot(-m.y);\n    rd.xz *= rot(-m.x);\n    ro.yz *= rot(-m.y);\n    ro.xz*= rot(-m.x);\n    \n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < SAMPLES; i++) {\n    \n        col += color(ro, rd);\n    \n    }\n    \n    col /= float(SAMPLES);\n    \n    //col = aces_filmic(col);\n    \n    if(texelFetch(iChannel0, ivec2(0), 0) == vec4(iResolution.xy, iMouse.xy)) {\n        fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 170]], "test": "untested"}
{"id": "dl2SR3", "name": "frequency red/white/green/yellow", "author": "nobody", "description": ".", "tags": ["frequency"], "likes": 1, "viewed": 236, "published": 3, "date": "1676397451", "time_retrieved": "2024-07-30T18:10:16.150177", "image_code": "const bool symmetrical = false;\nconst float base_hight = 0.3;\n\n\nvec3 red = vec3(1.0, 0.5, 0.5);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 green = vec3(0.5, 1.0, 0.5);\nvec3 yellow = vec3(1.0, 1.0, 0.5);\nvec3 blue = vec3(0.5, 0.5, 1.0);\nvec3 magenta = vec3(1.0, 0.5, 1.0);\n\nuniform vec2 u_resolution;\n\n\n\n\nvec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float fVBars = 100.0;\n    float fHSpacing = 1.0;\n    \n    float fHFreq = (uv.x * 3.14);\n\tfloat squarewave = sign(sin(fHFreq*fVBars)+1.0-fHSpacing);\n    \n    float x = floor(uv.x * fVBars)/fVBars;\n    float fSample = texture( iChannel0, vec2(abs(2.0 * x - 1.0), 0.25)).x;\n  \n\tfloat fft = squarewave * fSample* 0.5;\n    \n    float fHBars = 100.0;\n    float fVSpacing = 0.180;\n    float fVFreq = (uv.y * 3.14);\n\tfVFreq = sign(sin(fVFreq * fHBars)+1.0-fVSpacing);\n\n    vec2 centered = vec2(1.0) * uv - vec2(1.0);\n    float t = iTime / 100.0;\n    float polychrome = 1.0;\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    float ff = fract(uv.x);\n    vec3 base_color = vec3(1.0, 0.0, 0.0);\n    if (symmetrical) {\n        if (ff < 0.16666666)\n            base_color = mix(red, white, ff * 6.0);\n        else if (ff < 0.33333333)\n            base_color = mix(white, yellow, (ff - 0.16666666) * 6.0);\n        else if (ff < 0.5)\n            base_color = mix(yellow, green, (ff - 0.33333333) * 6.0);\n        else if (ff < 0.66666666)\n            base_color = mix(green, yellow, (ff - 0.5) * 6.0);\n        else if (ff < 0.86666666)\n            base_color = mix(yellow, white, (ff - 0.66666666) * 6.0);\n        else\n            base_color = mix(white, red, (ff - 0.86666666) * 6.0);\n    } else {\n        if (ff < 0.33333333)\n            base_color = mix(red, white, ff * 4.0);\n        else if (ff < 0.66666666)\n            base_color = mix(white, yellow, (ff - 0.33333333) * 4.0);\n        else\n            base_color = mix(yellow, green, (ff - 0.66666666) * 4.0);\n    }\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    \n    float tt = base_hight - uv.y;\n    float df = sign(tt);\n    df = (df + 1.0)/0.5;\n    vec3 col = flame_color * vec3(1.0 - step(fft, abs(base_hight-uv.y))) * vec3(fVFreq);\n    col -= col * df * 0.180;\n    \n\t// output final color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2SR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 324, 368, 675], [677, 677, 734, 766, 2804]], "test": "untested"}
{"id": "mtjXzG", "name": "water drop effect? ", "author": "jsweetpotato", "description": "It looks like a drop of water, so I named it like this. I made it without thinking.", "tags": ["mouse", "waterdrop"], "likes": 4, "viewed": 298, "published": 3, "date": "1676386373", "time_retrieved": "2024-07-30T18:10:16.933084", "image_code": "float Circle(vec2 uv, vec2 pos, float size, float blur){\n   float d = length(uv - pos);\n   float c = smoothstep(size, size-blur,d);\n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    uv.x *= asp;    \n\n    vec2 mUv = iMouse.xy/iResolution.xy;\n    \n    float mask = texture(iChannel0, uv).r;\n    \n    // change color\n    vec3 color = vec3(1.,1.,1.);\n    \n    float circle = Circle(uv, vec2(mUv.x*asp, mUv.y), fract(iTime*0.1)*0.4, 0.01);\n    float circle2 = Circle(uv, vec2(mUv.x*asp, mUv.y), fract(iTime*0.1)*0.8, 0.4);\n    float circle3 = Circle(uv, vec2(mUv.x*asp, mUv.y), .6, 0.5)*mask;\n    // Time varying pixel color\n    vec3 col = color*(circle-(circle2*circle2))/circle3;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 146], [148, 148, 205, 255, 899]], "test": "untested"}
{"id": "mtBSz3", "name": "Chasing souls [281 chars]", "author": "kishimisu", "description": "Happy Valentine's day!", "tags": ["heart", "bloom", "glow", "code", "parametric", "shape", "neon", "short", "golf", "golfing"], "likes": 39, "viewed": 812, "published": 3, "date": "1676375265", "time_retrieved": "2024-07-30T18:10:17.764860", "image_code": "/* \"Chasing souls\" by @kishimisu (2023) - https://www.shadertoy.com/view/mtBSz3\n   [281 chars] (+1 due to code shape)\n*/\n          void      mainImage\n       (out vec4    O, vec2 u)\n      { vec2  r =  iResolution.\n     xy;float l,o,v,e  =iTime*.5\n    ;u+=u-r; for(O*=v=0.; v<120.;\n    l=sin(o = v + e +abs(sin(e-v)\n    )),O+=pow(.0025/length(u/r.y/\n     .6+vec2(l*l*l,cos(o*4.)*.07\n       +cos(o*3.)/7.+cos(o+o)*\n       .3-cos(o)))*(cos(v+v++\n         +vec4(7,6,4,0))+1.\n           ),O-O+1.1))u*=\n              1.001+.001\n                *cos(\n                 e);\n                  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 131, 189, 189, 584]], "test": "untested"}
{"id": "DlSXWm", "name": "simplex noise sin lerp", "author": "lanx06", "description": "https://www.shadertoy.com/view/Msf3WH", "tags": ["noise", "cloud"], "likes": 0, "viewed": 161, "published": 3, "date": "1676372201", "time_retrieved": "2024-07-30T18:10:18.599628", "image_code": "#define PI 3.1415926538\nfloat sin_lerp(float a,float b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nvec2 sin_lerp(vec2 a,vec2 b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nfloat random(float seed){\n    return fract(sin(seed+1.) * 43758.5453);\n}\nvec2 random(vec2 p){\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return vec2(random(p.x),random(p.y));\n}\nvec2 lerp(vec2 a,vec2 b,float t){\n    return sin_lerp(a,b,t);\n    //return mix(a,b,t);\n}\nvec2 noise(vec2 uv){\n    vec2 v0=random(floor(uv));\n    vec2 v1=random(floor(uv)+vec2(1,0));\n    vec2 v2=random(floor(uv)+vec2(1,1));\n    vec2 v3=random(floor(uv)+vec2(0,1));\n    vec2 dtt=uv-floor(uv);\n    vec2 x1 =lerp(v0,v1,dtt.x);\n    vec2 x2 =lerp(v3,v2,dtt.x);\n    vec2 o=lerp(x1,x2,dtt.y);\n    //return v2;\n    return o;   \n}\nfloat force(vec2 uv,int level){\n    float c=0.0;\n    float scale=10.0;\n    float t=2.0;\n    for(int i=0;i<10;i++){\n        if(i>level)\n            break;\n        c+=noise(uv*scale).x/t;\n        scale*=2.0;\n        t*=2.0;\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col ;\n    col.r=force(uv*1.5+vec2(iTime*0.1),int(uv.x*5.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 64, 64, 131], [132, 132, 169, 169, 236], [237, 237, 262, 262, 309], [310, 310, 330, 330, 492], [493, 493, 526, 526, 581], [582, 582, 602, 602, 913], [914, 914, 945, 945, 1157], [1158, 1158, 1215, 1215, 1383]], "test": "untested"}
{"id": "DtSXRc", "name": "This Is Not A Refracted Pipe", "author": "dr2", "description": "The nonpipe again - now with refraction and a varying index (mouseable)", "tags": ["refract", "pipe", "magritte"], "likes": 20, "viewed": 294, "published": 3, "date": "1676367577", "time_retrieved": "2024-07-30T18:10:19.460326", "image_code": "// \"This Is Not A Refracted Pipe\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n Note from \"This Is Not A Pipe\":\n  This is clearly not Magritte's masterpiece. But is the 3D form less\n  'not a pipe' than the original?\n\n No. 27 in \"Refraction\" series - listed at end\n\n No. 4 in \"Nonpipe\" series\n    \"This Is Not A Pipe\"              (4s3XD2)\n    \"This Is Not A Reflected Pipe\"    (Wsd3W8)\n    \"This Is Not A Reflected Pipe 2\"  (Nsd3RN)\n\n (with bits from \"This Is Not A Reflected Pipe 2\" and \"Fugu Egg\")\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nfloat dstFar, tCur, szFac, sphRad;\nint idObj;\nconst int idPipe = 1, idCoal = 2;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"This Is Not A Reflected Pipe 2\")\n  vec3 q;\n  vec2 rp;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (abs (PrCapsDf (q.xzy, 0.55, 0.25)) - 0.06, q.y - 0.5, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  DMIN (idPipe);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.5, 0.01);\n  DMIN (idCoal);\n  return 0.7 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat InSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat OutSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b + sqrt (d) : dstFar;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col; \n  if (rd.y > 0.85) col = mix (vec3 (0.1), vec3 (0.9, 0.9, 1.), smoothstep (0., 0.02,\n     0.47 - Maxv2 (abs (fract (8. * Rot2D (rd.xz / rd.y, 0.25 * pi) + 0.5) - 0.5))));\n  else col = mix (vec3 (0.5, 0.5, 0.), vec3 (0.7, 0.9, 1.),  Minv2 (smoothstep (0.05, 0.1, \n     abs (sin (64. * atan (rd.zy, vec2 (rd.x, length (rd.xz)))))))) * (0.3 + 0.1 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{  // (optics simplified from \"Fugu Egg\")\n  vec3 col, rdo, vn, vnIn, q;\n  float dstObj, dstSphIn, dstSphOut, eta, sh;\n  szFac = 0.8;\n  eta = 1. / (1. - 0.6 * SmoothBump (0.25, 0.75, 0.15, mod (0.05 * tCur, 1.)));\n  rdo = rd;\n  dstObj = dstFar;\n  dstSphIn = InSphHit (ro, rd, sphRad);\n  if (dstSphIn < dstFar) {\n    ro += dstSphIn * rd;\n    vnIn = ro / sphRad;\n    rd = refract (rd, vnIn, 1. / eta);\n    dstObj = ObjRay (ro, rd);\n    dstSphOut = OutSphHit (ro, rd, sphRad);\n    if (dstSphOut < dstObj) {\n      ro += dstSphOut * rd;\n      rd = refract (rd, - ro / sphRad, eta);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    q = ro / szFac;\n    if (idObj == idPipe) {\n      q.xy -= vec2 (0.4);\n      q.xy = Rot2D (q.xy, -0.2 * pi);\n      if (q.x < -0.03) vn = VaryNf (16. * q, vn, 0.1);\n      col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.), 0.5 * Fbm3 (4. * q)) :\n         vec3 (0.1), vec3 (0.7, 0.6, 0.), SmoothBump (-0.03, 0.03, 0.01, q.x));\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n      col = col * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         0.2 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } else if (idObj == idCoal) {\n      col = mix (vec3 (0.9, 0., 0.) * (0.2 + 0.8 * smoothstep (0.1, 0.9, Fbm1 (0.5 * tCur))),\n         vec3 (0.1, 0., 0.), smoothstep (0.2, 0.7, Fbm2 (64. * q.xz)));\n    }\n  } else {\n    col = BgCol (rd);\n  }\n  if (dstSphIn < dstFar) col = mix (col, 2. * BgCol (reflect (rdo, vnIn)),\n     0.05 + 0.95 * pow (1. - abs (dot (rdo, vnIn)), 5.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 1.);\n    t = (floor (32. * t) + smoothstep (0.5, 1., mod (32. * t, 1.))) / 32.;\n    az = pi * sin (2. * pi * t);\n    el = -0.2 * pi * sin (4. * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  sphRad = 2.;\n  ro = vuMat * vec3 (0., 0., -5. * sphRad);\n  zmFac = 4.5;\n  dstFar = 30.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n  \"Refraction\" series\n    \"Aquarium\"                    (Mtf3zM)\n    \"Wavescape\"                   (lls3z7)\n    \"Sailing Home\"                (Ml23WV)\n    \"Fishbowl\"                    (MlSSDR)\n    \"A Few Fish\"                  (4dtSDs)\n    \"Fishbowl 2\"                  (lt3SW8)\n    \"Swimming Pool Waves\"         (llKSDG)\n    \"Green Grotto\"                (Ms2yR1)\n    \"Glass Duck\"                  (XslBR8)\n    \"Foggy Duck\"                  (XsfBWn)\n    \"Rainbow Cavern\"              (XsfBWM)\n    \"Magic Orb\"                   (XsfBWB)\n    \"Glass Duck 2\"                (MtlyRf)\n    \"White Folly\"                 (ll2cDG)\n    \"White Folly 2\"               (ltXfzr)\n    \"Virtual Dolphins\"            (XlfBD2)\n    \"Refractable Ship\"            (MtjBRm)\n    \"Refracted Colliding Balls\"   (lljBDR)\n    \"Refraction Exercise\"         (4ddyRj)\n    \"Wrapped Bottle\"              (wdS3zV)\n    \"Ship in a Bottle\"            (wlXXzf)\n    \"Booze Cruise\"                (3dsfWl)\n    \"Nautilus Submerging\"         (WtXfR2)\n    \"Nautilus Interior\"           (wt2fzz)\n    \"Nautilus at Sunset\"          (slscWj)\n    \"Fugu Egg\"                    (NtjcRV)\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSXRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1369, 1369, 1391, 1435, 2046], [2048, 2048, 2081, 2081, 2265], [2267, 2267, 2288, 2288, 2543], [2545, 2545, 2582, 2582, 2814], [2816, 2816, 2862, 2862, 2983], [2985, 2985, 3032, 3032, 3153], [3155, 3155, 3177, 3177, 3575], [3577, 3577, 3612, 3652, 5252], [5254, 5254, 5310, 5310, 6485], [6487, 6487, 6529, 6529, 6580], [6582, 6582, 6625, 6625, 6689], [6691, 6691, 6735, 6735, 6810], [6812, 6812, 6834, 6834, 6861], [6863, 6863, 6885, 6885, 6912], [6914, 6914, 6959, 6959, 7051], [7053, 7053, 7098, 7098, 7136], [7138, 7138, 7195, 7195, 7278], [7280, 7280, 7310, 7310, 7423], [7425, 7425, 7456, 7456, 7520], [7522, 7522, 7558, 7558, 7764], [7798, 7798, 7822, 7822, 7875], [7877, 7877, 7901, 7901, 8013], [8015, 8015, 8039, 8039, 8182], [8184, 8184, 8209, 8209, 8355], [8357, 8357, 8382, 8382, 8568], [8570, 8570, 8595, 8595, 8820], [8822, 8822, 8844, 8844, 8998], [9000, 9000, 9021, 9021, 9176], [9178, 9178, 9199, 9199, 9354], [9356, 9356, 9385, 9385, 9597], [9599, 9599, 9638, 9638, 9895]], "test": "untested"}
{"id": "cl2SzW", "name": "Reaction speed up", "author": "lanx06", "description": "https://www.karlsims.com/rd.html\nhttps://www.karlsims.com/rdtool.html", "tags": ["mouse", "fog", "chalk", "framebuffer"], "likes": 3, "viewed": 215, "published": 3, "date": "1676363877", "time_retrieved": "2024-07-30T18:10:20.346956", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float v=texture(iChannel0, uv).g;\n\t\n    fragColor = vec4((0.35-v)/0.15);\n    //fragColor=texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//a+b+b= b b b\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 color=vec4(0.0);\n\tvec2 uv= fc /ir;\n    bool mouse_hold = !(iMouse.z < 0.0);\n    vec2 mouse = iMouse.xy;\n\tvec4 last = tx(vec2(0,0));\n    if(iFrame<1){\n        float dis=distance(uv,vec2(0.5));\n        float s=2.0;\n        vec2 id=floor(uv*s);\n        last.r=1.0;\n        //if(fc.x>ir.x/4.0 &&  fc.x <3.0*ir.x/4.0 && fc.y>ir.y/4.0 &&  fc.y <3.0*ir.y/4.0){\n        if(uv.x>0.45 && uv.x<0.55 && uv.y>0.45 && uv.y<0.55){\n            last.r=0.05;\n            last.g=0.5;\n\n        }\n        color=last;\n        \n    }else{\n        vec4 avg=vec4(0);\n        for(int i=0;i<8;i++){\n            vec2 d=dir8[i];\n            avg+=tx(d)*dir8w[i];\n        }\n\n        float a=last.r;\n        float b=last.g;\n        float reaction=a * b * b;\n       \n        color.r=a+(((avg.r)-a)*da - reaction + F *(1.0 - a))*dt;\n        color.g=b+(((avg.g)-b)*db + reaction - (K+F)*b)*dt;\n        \n        //color.r=a+(((avg.r+a)*0.5-a)*da - reaction + F *(1.0 - a))*dt;\n        //color.g=b+(((avg.g+b)*0.5-b)*db + reaction - (K+F)*b)*dt;\n\n    }\n    float dis=1.0-distance(fragCoord,mouse)/50.0;\n    \n    if(mouse_hold && dis>0.5){\n       color.g=0.5;\n       //color.r=0.5;\n    }\n    color=clamp(color,vec4(0.0),vec4(1.0));\n    fragColor =color ;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define K mix(0.045,0.07,uv.x)\n//#define F mix(0.01,0.1,uv.y)\n#define K 0.062 \n#define F 0.0545\n//#define K 0.05381 \n//#define F 0.10389\n\n#define da 1.0\n#define db 0.5\n#define dt 1.0\n\n#define fb iChannel0\n#define T iTime*1.5\n#define PI 3.1415926538\n#define ir iResolution.xy\n#define fc fragCoord.xy\n#define S 10.0\n#define tx(offset)(texture( iChannel0,( (fragCoord.xy+offset) /iResolution.xy) ) )\n\nvec2 dir8[8]=vec2[](vec2(1.0,0.0),vec2(1.0,1.0),vec2(0.0,1.0),vec2(-1.0,1.0),vec2(-1.0,0.0),vec2(-1.0,-1.0),vec2(0.0,-1.0),vec2(1.0,-1.0));\nfloat dir8w[8]=float[](0.2,0.05,0.2,0.05,0.2,0.05,0.2,0.05);\nvec2 dir4[4]=vec2[](vec2(1.0,0.0),vec2(0.0,1.0),vec2(-1.0,0.0),vec2(0.0,-1.0));\nfloat dir4w[4]=float[](0.25,0.25,0.25,0.25);\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= fc /ir;\n    vec4 avg=vec4(0);\n    vec4 last = tx(vec2(0,0));\n    vec4 color;\n    \n    \n    for(int i=0;i<8;i++){\n        vec2 d=dir8[i];\n        vec2 ov=(fc+d)/ir;\n        avg+=tx(d)*dir8w[i];\n    }\n\n    float a=last.r;\n    float b=last.g;\n    float reaction=a * b * b;\n\n    color.r=a+(((avg.r)-a)*da - reaction + F *(1.0 - a))*dt;\n    color.g=b+(((avg.g)-b)*db + reaction - (K+F)*b)*dt;\n    fragColor=color;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= fc /ir;\n    vec4 avg=vec4(0);\n    vec4 last = tx(vec2(0,0));\n    vec4 color;\n    \n    \n    for(int i=0;i<8;i++){\n        vec2 d=dir8[i];\n        vec2 ov=(fc+d)/ir;\n        avg+=tx(d)*dir8w[i];\n    }\n\n    float a=last.r;\n    float b=last.g;\n    float reaction=a * b * b;\n\n    color.r=a+(((avg.r)-a)*da - reaction + F *(1.0 - a))*dt;\n    color.g=b+(((avg.g)-b)*db + reaction - (K+F)*b)*dt;\n    fragColor=color;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= fc /ir;\n    vec4 avg=vec4(0);\n    vec4 last = tx(vec2(0,0));\n    vec4 color;\n    \n    \n    for(int i=0;i<8;i++){\n        vec2 d=dir8[i];\n        vec2 ov=(fc+d)/ir;\n        avg+=tx(d)*dir8w[i];\n    }\n\n    float a=last.r;\n    float b=last.g;\n    float reaction=a * b * b;\n\n    color.r=a+(((avg.r)-a)*da - reaction + F *(1.0 - a))*dt;\n    color.g=b+(((avg.g)-b)*db + reaction - (K+F)*b)*dt;\n    fragColor=color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2SzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 217]], "test": "untested"}
{"id": "ctSXz3", "name": "Apparent Depth (color) (494 ch)", "author": "fenix", "description": "Same idea as the last one, jazzed up with some color, which brings out the depth effect even more. I tried to apply the same tricks that FabriceNeyret2 found in this shader's fork parent, but I probably missed something.", "tags": ["2d", "illusion", "hexagon", "depth", "tiling", "hex", "hexagons", "tiles", "codegolf"], "likes": 8, "viewed": 259, "published": 3, "date": "1676361941", "time_retrieved": "2024-07-30T18:10:21.162775", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//   Same idea as the last one, jazzed up with some color, which brings out the depth\n//   effect even more. I tried to apply the same tricks that FabriceNeyret2 found in\n//   this shader's fork parent, but I probably missed something.\n//\n// ---------------------------------------------------------------------------------------\n\n// My attempt to apply FabriceNeyret2's changes from fork parent: 494 chars\n//*\n#define n(X) fract(dot(sin(X+i), sin(X+i)))                 //\n#define r(X) sin(.523 * vec2(X+1, X+4) )                    //\n#define c(X) (X + u - (length(a = mod(X + u, h + h) - h) <  \\\n                      length(b = mod(X + u - h, h + h) - h) \\\n                      ? a : b))                             //\n#define o(X) max(0., max(0., dot(X, u - c())) *    \\\n                     mix(n(c(X) -1.) - n(c() -1.), \\\n                         n(c(X)    ) - n(c()    ), \\\n                         pow(fract(t), 7.)))       //\n#define M(h,v,w) max( o(r(w)), max( o(r(w+v)), o(r(w-v)) ) /2. )\n               \nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 9. / iResolution.y;\n    \n    float t = iTime * .2, i = ceil(t);\n    vec2 h = r(), a, b;\n    \n    O = O * 0.\n        + (.4 - M(h,2,) + M(-h,4,) * .4) * vec4(1, .1, 1, 1)\n        + (.4 - M(h,2,-2) + M(-h,4,-2) * .4) * vec4(.1, 1, 1, 1);\n}\n/**/\n\n// Original: 577 chars\n/*\n#define n(X) fract(dot(sin(X), sin(X)))\n#define r(X) sin(.523 * (X + vec2(1, 4)))\n#define c(X) (X - (length(a = mod(X    , h + h) - h) < \\\n                   length(b = mod(X - h, h + h) - h) \\\n                   ? a : b))\n#define o(X) max(0., max(0., dot(X, u - c(u))) * \\\n                     mix(n(c(u + X) + s.x) - n(d + s.x), \\\n                         n(c(u + X) + s.y) - n(d + s.y), \\\n                         pow(fract(iTime*.2), 7.)))\n               \nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 9. / iResolution.y;\n    \n    vec2 h = r(0.),\n         s = trunc(iTime * .2 + vec2(0, 1)),\n         a, b, d = c(u);\n    \n    O = O * 0.\n        + (.4\n        + max(max(o(-h) * 2., o(r(4.))), o(r(-4.))) * .2\n        - max(max(o(h) * 2., o(r(2.))), o(r(-2.))) * .5) * vec4(1, .1, 1, 1)\n        + (.4\n        + max(max(o(-h), o(r(4.))) * 2., o(r(2.))) * .2\n        - max(max(o(h), o(r(-4.))), o(r(-2.)) * 2.) * .5) * vec4(.1, 1, 1, 1);\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSXz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "csjGWw", "name": "RGB Hearts", "author": "ruudhelderman", "description": "My dear Tracy,\nHappy Valentine's day!\n", "tags": ["heart", "love"], "likes": 1, "viewed": 236, "published": 3, "date": "1676358981", "time_retrieved": "2024-07-30T18:10:21.917758", "image_code": "// There are prettier heart formulas, but I like the simplicity of this one.\n\nvoid mainImage(out vec4 c, vec2 u)\n{\n    u /= iResolution.y;\n\n    vec3 a = cos(7. * (u.x + sin(iTime * vec3(.7, .8, .9))));\n    vec3 b = cos(9. * (u.y + sin(iTime * vec3(.5, .6, .7))) - acos(a));\n\n    c = vec4(smoothstep(1., 1.1, a + b), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 114, 114, 321]], "test": "untested"}
{"id": "dtBSRy", "name": "Apparent Depth (421 ch)", "author": "fenix", "description": "I was thinking recently about different ways to create the effect of depth in a scene. It seemed like an interesting experiment to try to create depth without directly analyzing a fictitious world using 3D geometry.", "tags": ["2d", "illusion", "hexagon", "depth", "tiling", "hex", "hexagons", "tiles", "codegolf"], "likes": 18, "viewed": 412, "published": 3, "date": "1676356014", "time_retrieved": "2024-07-30T18:10:22.666753", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//   I was thinking recently about different ways to create the effect of depth in a\n//   scene. It seemed like an interesting experiment to try to create depth without\n//   directly analyzing a fictitious world using 3D geometry.\n//\n// ---------------------------------------------------------------------------------------\n\n// From FabriceNeyret2: 421 chars!\n//*\n#define n(X) fract( dot( sin(X+i), sin(X+i)))              //\n#define r(X) sin(.523 * vec2(X+1, X+4) )                   //\n#define c(X) (X+u - (  dot(a = mod(X+u    , h + h) - h, a)  \\\n                     < dot(b = mod(X+u - h, h + h) - h, b)  \\\n                     ? a : b ) )                           //\n#define o(X)   max(0., dot(X, u - c()))                     \\\n             * max(0., mix(n(c(X) -1.) - n(c() -1.),        \\\n                           n(c(X)    ) - n(c()    ),        \\\n                           pow(fract(t), 7.)))             //\n#define M(h,v) max( o(h), max( o(r(v)), o(r(-v)) ) /2. )\n               \nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 9. / iResolution.y;\n    float t = iTime*.2, i = ceil(t);\n    vec2  h = r(), a, b;\n    \n    O = .7 - M(h,2) + M(-h,4) * .4 + O * 0.;\n}\n/**/\n\n// Golfed by me: 459 chars\n/*\n#define n(X) fract(dot(sin(X), sin(X)))\n#define r(X) sin(.523 * (X + vec2(1, 4)))\n#define c(X) (X - (length(a = mod(X    , h + h) - h) < \\\n                   length(b = mod(X - h, h + h) - h) \\\n                   ? a : b))\n#define o(X) max(0., max(0., dot(X, u - c(u))) * \\\n                     mix(n(c(u + X) + s.x) - n(d + s.x), \\\n                         n(c(u + X) + s.y) - n(d + s.y), \\\n                         pow(fract(iTime*.2), 7.)))\n               \nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 9. / iResolution.y;\n    \n    vec2 h = r(0.),\n         s = trunc(iTime * .2 + vec2(0, 1)),\n         a, b, d = c(u);\n    \n    O = O * 0. + .7\n        - max(max(o(h) * 2., o(r(2.))), o(r(-2.))) * .5\n        + max(max(o(-h) * 2., o(r(4.))), o(r(-4.))) * .2;\n}\n/**/\n\n// Original: 1154 chars\n/*\n// From BigWIngs' Hexagonal Tiling Explained: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec4 hexCoords(vec2 u)\n{\n    const vec2 r = vec2(1, 1.73);\n    const vec2 h = r * .5;\n    vec2 a = mod(u, r) - h;\n    vec2 b = mod(u - h, r) - h;\n    \n    vec2 gv;\n    if (length(a) < length(b))\n        gv = a;\n    else\n        gv = b;\n    \n    vec2 id = u - gv;\n    return vec4(gv, id);\n}\n\nfloat noise( in vec2 p )\n{\n    return fract(4e4*dot(sin(177.*p + 1e5), sin(988.*p + 2e5)));\n}\n\nfloat oneNeighbor(vec2 p, vec2 dir, vec2 uv, vec2 h, vec3 t)\n{\n    float hsA = noise(hexCoords(p + dir).zw + t.x);\n    float shA = max(0., hsA - h.x);\n    float sA = shA * max(0., dot(normalize(dir), uv));\n\n    float hsB = noise(hexCoords(p + dir).zw + t.y);\n    float shB = max(0., hsB - h.y);\n    float sB = shB * max(0., dot(normalize(dir), uv));\n    \n    return mix(sA, sB, t.z);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u = 9. * (u - .5*iResolution.xy) / iResolution.y;\n    \n    O = vec4(.7);\n\n    vec3 t = vec3(trunc(iTime*.2), trunc(iTime*.2) + 1., pow(fract(iTime*.2), 9.));\n       \n    vec4 hc = hexCoords(u);\n    vec2 h = vec2(noise(hc.zw + t.x), noise(hc.zw + t.y));\n    \n    float s0 = oneNeighbor(u, .5 * vec2(1, 1.73), hc.xy, h, t);\n    float s1 = oneNeighbor(u, vec2(1, 0), hc.xy, h, t) * .5;\n    float s2 = oneNeighbor(u, .5 * vec2(-1, 1.73), hc.xy, h, t) * .5;\n    \n    O -= max(max(s0, s1), s2);\n    \n    float b0 = oneNeighbor(u, .5 * vec2(-1, -1.73), hc.xy, h, t) * .2;\n    float b1 = oneNeighbor(u, .5 * vec2(1, -1.73), hc.xy, h, t) * .1;\n    float b2 = oneNeighbor(u, .5 * vec2(-1, 0), hc.xy, h, t) * .1;\n    \n    O += max(max(b0, b1), b2);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSRy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1205, 1205, 1241, 1241, 1384]], "test": "untested"}
{"id": "dljXRK", "name": "Schripsz", "author": "gschian0", "description": "equations are fun and blurry", "tags": ["zen"], "likes": 1, "viewed": 176, "published": 3, "date": "1676333938", "time_retrieved": "2024-07-30T18:10:23.421735", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec3 uvw = vec3(gl_FragCoord.xyz) / iResolution.xyz;\nuvw = uvw * 2.0 - 0.5;\nfloat t = iTime * 0.1;\nfloat wave = sin(uvw.x * 20.0 + t) * cos(uvw.y * 20.0 + t) * sin(uvw.z * 20.0 + t);\nfragColor = vec4(cos(wave*4.), sin(wave), sin(2.*wave), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 305]], "test": "untested"}
{"id": "ct2XRV", "name": "Yet Another Halftone Shader", "author": "barjin", "description": "Color- and contrast- animated simple halftone shader.", "tags": ["2d", "animated", "halftone", "dithering"], "likes": 5, "viewed": 228, "published": 3, "date": "1676325918", "time_retrieved": "2024-07-30T18:10:24.171730", "image_code": "int modulo = 8;\nfloat radius = 4.0;\n\nvec2 getClosestCenter(vec2 fragCoord){      \n    if(abs(int(fragCoord.y) % (modulo<<1) - modulo) < (modulo>>1)){\n        int y = int(fragCoord.y) - (int(fragCoord.y) % (modulo<<1)) + modulo;\n        int x = int(fragCoord.x) - (int(fragCoord.x) % modulo) + (modulo>>1);\n        \n        return vec2(x,y);\n    } else if (int(fragCoord.y) % (modulo<<1) < modulo) {\n        int y = int(fragCoord.y) - (int(fragCoord.y) % (modulo));\n        int x = int(fragCoord.x) - (int(fragCoord.x) % modulo) + ((int(fragCoord.x) % modulo) < modulo>>1 ? 0 : modulo);\n        \n        return vec2(x,y);\n    } else if (int(fragCoord.y) % (modulo<<1) > modulo) {\n        int y = int(fragCoord.y) - (int(fragCoord.y) % (modulo)) + modulo;\n        int x = int(fragCoord.x) - (int(fragCoord.x) % modulo) + ((int(fragCoord.x) % modulo) < modulo>>1 ? 0 : modulo);\n        \n        return vec2(x,y);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ctr = getClosestCenter(fragCoord);\n    \n    vec4 val = texture(iChannel0, uv);\n    if(distance(fragCoord,ctr) < (sin(iTime)*0.5 + 2.0) * radius*(1.0 - (val.r+val.g+val.b)/3.0)) {\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col,1.0);\n        return;\n    }\n   \n\n    // Output to screen\n    fragColor = vec4(1,1,1,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2XRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[919, 919, 976, 976, 1385]], "test": "untested"}
{"id": "Dl2SRK", "name": "nado", "author": "SnoopethDuckDuck", "description": "I found this piggy online then made it a shader:\nhttps://www.pinterest.co.uk/pin/492862752944528156/\n\n", "tags": ["pig", "piggy"], "likes": 24, "viewed": 327, "published": 3, "date": "1676322851", "time_retrieved": "2024-07-30T18:10:24.930700", "image_code": "#define black vec3(0.01)\n#define pink vec3(1, 0.5, 0.5)\n#define darkPink vec3(200, 100, 100) / 255.\n\n#define pi 3.14159\n#define t 0.25 * iTime\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//  ty fabrice \nfloat box(vec2 f, int x, int y, int w, int h) {\n    vec2 p = vec2(x,y);\n    f = step(p, f) * step(f, p + vec2(w,h) - 1.);\n    return f.x*f.y;\n}\n\nfloat drawPink(vec2 p) {\n    float s = box(p, 0, -8, 9, 17);\n    s += box(p, 6, 9, 2, 2);\n    s += box(p, 9, -5, 2, 3);\n    s += box(p, 9, -2, 1, 1);\n    return s;\n}\n\nfloat drawBlack(vec2 p) {\n    // Snout\n    float s = box(p, 0, 0, 2, 1);\n    s += box(p, 2, 1, 1, 1);\n    s += box(p, 3, 2, 1, 4);\n    s += box(p, 0, 6, 3, 1);\n    s += box(p, 1, 3, 1, 2);\n    \n    // Outline\n    s += box(p, 0, 8, 5, 1);\n    s += box(p, 5, 9, 1, 3);\n    s += box(p, 6, 11, 2, 1);\n    s += box(p, 8, 0, 1, 11);\n    s += box(p, 8, -8, 1, 5);\n    s += box(p, 9, -6, 2, 1);\n    s += box(p, 11, -5, 1, 3);\n    s += box(p, 10, -2, 1, 1);\n    s += box(p, 9, -1, 1, 1);\n    s += box(p, 0, -9, 8, 1);\n    \n    // Eyes\n    s += box(p, 6, 6, 1, 1);\n    return s;\n}\n\nfloat drawDarkPink(vec2 p) {\n    // Snout\n    float s = box(p, 0, -1, 2, 1);\n    s += box(p, 2, 0, 1, 1);\n    s += box(p, 3, 1, 1, 1);\n    \n    // Eyes\n    s += box(p, 6, 5, 1, 1);\n    return s;\n}\n\nvec3 drawPiggy(vec2 ipos, vec3 col, vec3 bgcol, float shade) {\n    ipos.x = abs(ipos.x);\n    col = mix(col, mix(bgcol, pink, shade), drawPink(ipos));\n    col = mix(col, mix(bgcol, black, shade), drawBlack(ipos));\n    col = mix(col, mix(bgcol, darkPink, shade), drawDarkPink(ipos));\n    return col;\n}\n\nvec3 drawGridPiggy(vec2 uv, vec3 col, vec3 bgcol, float i, float n, float m) {\n    float io = 0.25 * 3.14159 * i /n;\n    \n    float th = tanh(0.3 * max(0., t - 1.5));\n    uv *= rot(th * (pi * cos(0.5 * t + 4. * io)));  \n    uv.y += th * cos(t + io);\n    \n    vec2 o = vec2(cos(t + io), sin(t + io));\n    vec2 fpos = fract((n-i) * uv + t + o) - 0.5;\n    vec2 ipos2 = floor((m + 4. * cos(10.*uv.x + io + 10.*t)) * fpos + vec2(0,0.5)) ;\n    return drawPiggy(ipos2, col, bgcol, i /n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 bgcol = vec3(exp(-abs(uv)), 0.8 + 0.2 * cos(length(uv) - t));\n    vec3 col = bgcol;\n    \n    // Number of layers\n    float n = 14.;\n    \n    // Grid piggy scale\n    float m = 50.;\n    \n    // Centre piggy scale\n    float piggyAmount = 0.45 + 0.4 * cos(4.*t);\n    float piggyLayer = piggyAmount * n;\n    float piggyScale = piggyLayer * m;\n    \n    // Back piggies\n    for (float i = 0.; i <= floor(n - piggyLayer); i++) \n        col = drawGridPiggy(uv, col, bgcol, i, n, m);   \n    \n    // Centre piggy\n    vec2 ipos1 = floor(piggyScale * uv + vec2(0, 2.5));\n    col = drawPiggy(ipos1, col, bgcol, 1. - piggyAmount);\n    \n    // Front piggies\n    for (float i = ceil(n - piggyLayer); i < n; i++)\n        col = drawGridPiggy(uv, col, bgcol, i, n, m);\n       \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2SRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 218, 265, 265, 361], [363, 363, 387, 387, 528], [530, 530, 555, 568, 1100], [1102, 1102, 1130, 1143, 1298], [1300, 1300, 1362, 1362, 1599], [1601, 1601, 1679, 1679, 2083], [2085, 2085, 2142, 2142, 3012]], "test": "untested"}
{"id": "mlBSzV", "name": "animated 4 Color gradient", "author": "nobody", "description": "simple animated background color gradient", "tags": ["background"], "likes": 0, "viewed": 153, "published": 3, "date": "1676320724", "time_retrieved": "2024-07-30T18:10:25.680695", "image_code": "const float SPEED = 0.001;\n\n\n\n\nvec3 startColor = vec3(1.0, 0.0, 0.0);\nvec3 midColor1 = vec3(1.0, 1.0, 1.0);\nvec3 midColor2 = vec3(0.0, 1.0, 0.0);\nvec3 endColor = vec3(1.0, 1.0, 0.0);\n\nvec3 gradient(float t, float time) {\nt = t + time * SPEED; // Bewegung des Farbverlaufs ber die Zeit\nt = fract(t); // Normalisierung des Parameters auf den Bereich [0,1]\n\nif (t < 0.25)\nreturn mix(startColor, midColor1, t * 4.0);\nelse if (t < 0.5)\nreturn mix(midColor1, midColor2, (t - 0.25) * 4.0);\nelse if (t < 0.75)\nreturn mix(midColor2, endColor, (t - 0.5) * 4.0);\nelse\nreturn mix(endColor, startColor, (t - 0.75) * 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;\n\nvec3 color = gradient(uv.x, iTime);\n\nfragColor = vec4(color, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 220, 220, 612], [614, 614, 671, 671, 778]], "test": "untested"}
{"id": "ctBXzV", "name": "Reef and waves 3 ", "author": "guil", "description": "Reef and waves effect. It requires a good GPU for smooth animation.", "tags": ["waves", "reef"], "likes": 22, "viewed": 312, "published": 3, "date": "1676319468", "time_retrieved": "2024-07-30T18:10:26.427698", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//reef/waves combined field\nvec3 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n    mat2 m = rot(1.);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<4e2;s*=1.7)\n            p.xz*=m,\n            n.xy*=m,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*2.,\n            e+=abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.5*(dot(sin(q.xz*.5)/s,l)),\n            n-=cos(q);\n\to=1.-(f>.001 ? (e<0.001 ? exp(-e):0.):exp(-f));\n    return vec3(o,e*1.2,f);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3.5, dt = .3,c,d,e,f;\n    vec3 col= vec3(0.);\n    for( int i=0; i<80; i++ )\n\t{        \n        vec3 v = field(ro+t*rd); \n        c=v.x; e=v.y; f=v.z; d=min(min(e,2.*e*f),f);\n        t+=dt*d;\n        dt *= 1.01;\n        e=exp(-e);f=exp(-f);\n        col = .94*col+ .4*c*(f*vec3(5,3,2)+e*vec3(1,5,7)+1./(.1+abs(v.y)));        \n    }    \n    return col*exp(-t*.15);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.6);\n    \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -= t*.4;\n    \n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBXzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [192, 220, 243, 243, 678], [681, 681, 718, 718, 1096], [1099, 1099, 1156, 1156, 1817]], "test": "untested"}
{"id": "dtBSRV", "name": "Colorful bubbles underwater", "author": "mrange", "description": "CC0: Colorful bubbles\nTwitter art again that I attempted to recreate with a bit of a twist\n", "tags": ["bubbles"], "likes": 20, "viewed": 556, "published": 3, "date": "1676317562", "time_retrieved": "2024-07-30T18:10:27.234541", "image_code": "// CC0: Colorful bubbles underwater\n//  Twitter art again that I attempted to recreate with a bit of a twist\n\n#define RAINBOW_COLORS\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\nconst float MaxIter = 12.0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec4 plane(vec2 p, float i, float zf, float z, vec3 bgcol) {\n  float sz = 0.5*zf;\n  vec2 cp = p;\n  vec2 cn = mod2(cp, vec2(2.0*sz, sz));\n  float h0 = hash(cn+i+123.4);\n  float h1 = fract(4483.0*h0);\n  float h2 = fract(8677.0*h0);\n  float h3 = fract(9677.0*h0);\n  float h4 = fract(7877.0*h0);\n  float h5 = fract(9967.0*h0);\n  if (h4 < 0.5) {\n    return vec4(0.0);\n  }\n  float fi = exp(-0.25*max(z-1.0, 0.0));\n  float aa = mix(6.0, 1.0, fi)*2.0/RESOLUTION.y; \n  float r  = sz*mix(0.1, 0.475, h0*h0);\n  float amp = mix(0.25, 0.5, h3)*r;\n  cp.x -= amp*sin(mix(3.0, 0.25, h0)*TIME+TAU*h2);\n  cp.x += 0.95*(sz-r-amp)*sign(h3-0.5)*h3;\n  cp.y += 0.475*(sz-2.0*r)*sign(h5-0.5)*h5;\n  float d = length(cp)-r;\n#if defined(RAINBOW_COLORS)\n  vec3 hsv = vec3(h1, 0.75, 1.5);\n  vec3 ocol = hsv2rgb(hsv);\n  vec3 icol = hsv2rgb(hsv*vec3(1.0, 0.5, 1.25));\n#else\n  vec3 ocol = (0.5+0.5*sin(vec3(0.0, 1.0, 2.0)+h1*TAU));\n  vec3 icol = sqrt(ocol);\n  ocol *= 1.5;\n  icol *= 2.0;\n#endif\n  vec3 col = mix(icol, ocol, smoothstep(r, 0.0, -d))*mix(0.8, 1.0, h0);\n  col = mix(bgcol, col, fi);\n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 bgcol0 = HSV2RGB(vec3(0.66, 0.85, 0.1)); \n  const vec3 bgcol1 = HSV2RGB(vec3(0.55, 0.66, 0.6));\n  vec3 bgcol = mix(bgcol1, bgcol0, tanh_approx(1.5*length(p)));\n  vec3 col = bgcol;\n  for (float i = 0.0; i < MaxIter; ++i) {\n    const float Near = 4.0;\n    float z = MaxIter - i;\n    float zf = Near/(Near + MaxIter - i);\n    vec2 sp = p;\n    float h = hash(i+1234.5); \n    sp.y += -mix(0.2, 0.3, h*h)*TIME*zf;\n    sp += h;\n    vec4 pcol = plane(sp, i, zf, z, bgcol);\n    col = mix(col, pcol.xyz, pcol.w);\n  }  \n  col *= smoothstep(1.4, 0.5, length(pp));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 32372, "src": "https://soundcloud.com/euphonicvisions/gate-44-doubt?in=marten-range-59281907/sets/voices-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 456, 456, 602], [897, 957, 979, 979, 1027], [1028, 1088, 1109, 1109, 1179], [1181, 1267, 1303, 1303, 1397], [1399, 1399, 1459, 1459, 2523], [2525, 2653, 2681, 2747, 2823], [2825, 2825, 2855, 2855, 3455], [3457, 3457, 3512, 3512, 3684]], "test": "untested"}
{"id": "mlBXRK", "name": "Wet neural network", "author": "guil", "description": "Forked from newl shader from Yonatan :\nhttps://twitter.com/zozuar/status/1625182758745128981", "tags": ["neuron"], "likes": 64, "viewed": 1314, "published": 3, "date": "1676317529", "time_retrieved": "2024-07-30T18:10:27.983538", "image_code": "mat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\n\n// based on the follow tweet:\n// https://twitter.com/zozuar/status/1625182758745128981\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 n = vec2(0),q;\n    vec2 N = vec2(0);\n    vec2 p = uv + t/10.;\n    float S = 10.;\n    mat2 m = rotate2D(1.);\n\n    for(float j=0.;j++<30.;){\n      p*=m;\n      n*=m;\n      q=p*S+j+n+t;\n      n+=sin(q);\n      N+=cos(q)/S;\n      S*=1.2;\n    }\n    col = vec3(1, 2, 4) * ((N.x + N.y + .15)+.005/length(N));\n    \n    //col=pow(max(vec3(0),(N.x+N.y+.5)*.1*vec3(6,1,2)+.003/length(N)),vec3(.45));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 76], [80, 167, 224, 274, 846]], "test": "untested"}
{"id": "Dl2XRy", "name": "Tornado with Particles Light", "author": "rubioh", "description": " You can change the number of particles in Common if you have performances issues (NPARTICLES).", "tags": ["sdf", "light", "particles", "volumetric", "tornado"], "likes": 11, "viewed": 311, "published": 3, "date": "1676300174", "time_retrieved": "2024-07-30T18:10:28.917042", "image_code": "// Comment this line to see the particles as Sphere with a little bloom effect \n#define CUBE 1\n#define CUBE_BLOOM\n\n#ifdef CUBE\nconst float RAD = 10.;\n#else\nconst float RAD = 3.;\n#endif\n\n\n// Flickering the cube brightness\nfloat flicker(float i){\n    // Random flickering frequency and flickering amplitude\n    return pow(noise1(iTime*(2.+10.*hash11(i/7.453)), i), 1.+7.*hash11(i/2.473))*.95+.05;\n}\n\nfloat gyroid(vec3 p){\n    return abs(dot(cos(p), sin(p.zxy)));\n}\n\nfloat fbm(vec3 p, float dmin){\n    // FBM on gyroid noise, really cheap and high variety of texture\n    // Amplitude\n    float A = 1.;\n    // Total density\n    float d = 0.;\n    // Offset\n    float k = .6;\n    // Frequency deformation\n    float f = 1.;\n    // Add movement on the deformation\n    float V = 2.;\n    // Rescale\n    p/= 10.;\n    // Move to top\n    p.y +=  iTime*4.5;\n    // rotate the noise\n    p.xz = p.xz*rot(iTime*4.)*S(8., 0., length(p.xz)) + p.xz*S(7.5, 8.5, length(p.xz))*rot(iTime/8.);\n    \n\n    for (int i=0; i<5; i++){\n        p += .1*sin(p.xzy*.75*f+iTime*.2*V); // p deformation\n        p.y += iTime; // Move to top faster for higher frequencies (why not?)\n        d -= gyroid(p)*(A+((dmin-7.)/7.))-k; // Gyroid\n        A *= .63; // Amplitude\n        p *= 1.95*ROT3; // p rescale and rot\n        k -= .1; // change offset\n        f *= 2.5; \n        V *= 10.;\n    }\n    // Return the density at position p\n    return d;\n}\n\n// Map tornado\nfloat mapTornadoDensity(vec3 p)\n{\n  // Map tornado as a deformed cone \n  // Centering\n  vec3 c = vec3(0.,0.,4.);\n  p -= c;\n  // Cone angle\n  vec2 t = vec2(.07, .02)*4.;\n  \n  // Cone size\n  float h = 300.;\n  \n  // Reverse and translate cone\n  p.y *= -1.;\n  p.y -= 50.;\n  // Add sinusoidal movement on the cone\n  p.xz += vec2(cos(p.y/17.+iTime*2.435)*2., sin(p.y/17.+iTime*1.4532)*2.)*(.75+.25*cos(iTime/8.))*(10.);\n  // Finally compute the SDF \n  // SDF is not exact (and more because of all the deformation) but we don't care since we are doing volumetric marching\n  float d = sdCone(p, t, h);\n  // Add noise to get density\n  return fbm(p, d);\n}\n\n// ---------------------- MAP PARTICLES ------------------------\n\nfloat sdCube(vec3 p, vec3 c, float rad, int id){\n    // Cube SDF with rotation considering the cube's ID\n    float phi = 2.*3.1415*(float(id));\n    float psi = 2.*3.1415*(float(id)+.6);\n    float theta = 2.*3.1415*(float(id)+.7);\n\n    mat3 rot = rot3D(iTime*(1.+hash11(float(id))*.2), phi, psi, theta);\n\n    vec3 b = vec3(rad);\n    p = rot*(p-c);\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Map the cube\nfloat mapParticles(vec3 p, out vec3 col, out int id, out vec3 bloom){\n    bloom = vec3(0.);\n    col = vec3(0.);\n    id = 0;\n    float d = 1e10;\n    float dC;\n    for (int i=0; i<int(NPARTICLES); i++){\n        vec3 pos = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n        float d_bloom = sdSphere(p, pos, RAD);\n        #ifdef CUBE\n        float dC = sdCube(p, pos, RAD, i);\n        #else\n        float dC = d_bloom;\n        #endif\n        if (dC<d && dC<0.){\n           col = palette(float(i)/NPARTICLES);\n           d = dC;\n           id = i;\n        }\n        \n        bloom += palette(float(i)/NPARTICLES) * exp(-d_bloom*.1)*.02*pow(flicker(float(i)/NPARTICLES), 1.5);\n    }\n    return d;\n}\n\n// ---------------------- VOLUMETRIC RAYMARCHING ------------------------\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec4 col, out int id, out bool on_sph, out float density_when_hit, out vec3 bloom) {  \n  \n  bloom = vec3(0.);\n  col = vec4(0.);\n  // Init id object to -1\n  id = -1;\n  on_sph = false;\n  density_when_hit = 0.;\n  bool update_dwh = false;\n  \n  // Light vector\n  vec3 lp = vec3(0.), ld = vec3(0.);\n  \n  //Density activation treshold\n  float thresh= .1;\n  \n  // Total density\n  float td = 0.;\n  \n  // Raymarching parameters (dithering, marching step, depth)\n  float dit = fract(sin(dot(rd, vec3(14.456, 17.2154, 73.156))*4678.123))*2.;\n  float marchStep = 0.;\n  float t = START; // Starting point (depth)\n  \n  vec3 p = vec3(0.);\n  vec3 col_sph = vec3(0.);\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++){\n      \n      // Stop condition (ie total density > 1)\n      if (td > .99) break;\n      \n      // Map tornado and particles\n      p = ro + (t+dit)*rd;\n      float d = mapTornadoDensity(p);\n      int first_id;\n      vec3 new_bloom;\n      float dC = mapParticles(p, col_sph, first_id, new_bloom); \n      new_bloom *= 1./(1.+.004*max(length(p-ro)-START, 0.));\n      \n      bloom += new_bloom*2.;\n      // Hit Cube\n      if (dC<.1 && on_sph == false){\n          // If we hit a cube we keep the id of the first we hit\n          on_sph = true;\n          id = first_id;\n          density_when_hit = td;\n          update_dwh = true;\n      }\n      \n      \n      // Correct density\n      float den = step(thresh, d)*(d-thresh)*marchStep;\n      den = (1.-td)*den*.1;   \n      td += den*den*den;\n      \n      // Init New Color\n      vec3 ncol = vec3(0.);\n      \n      if (d>thresh){           \n          \n          // Cube color lightning\n          vec3 colS = vec3(0.);\n          for (int i=0; i<int(NPARTICLES); i++){\n              // Cube pos\n              vec3 lp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n              ld = lp-p;\n              float lDist = (length(ld));\n              ld = normalize(ld);\n              \n              // Dist to cube attenuation\n              float atten = 1./(1.+ .002*pow(lDist*.1, 4.));\n              vec3 sn = -rd;\n              \n              // Classic lightning module\n              vec3 colL = palette(float(i)/NPARTICLES);\n              float lint = flicker(float(i))*1.5;\n              float diff = clamp(dot(sn, ld), 0., 1.);\n              float spec = clamp(dot(reflect(sn, ld), -rd), .0, 1.);\n              colS += lint*colL*(diff+spec*.15)*atten;\n          }\n          // Aggregate color for this voxel\n          col.rgb += .4*(colS*den)*(1.-td);\n      }\n      \n      // Adaptative marching step\n      marchStep = (4.-3.8*S(.0, .05, den));\n      \n      float dit2 = fract(sin(dot(p, vec3(14.456, 17.2154, 73.156))*4678.123))*marchStep*.5;\n      \n      // Update depth\n      t += marchStep + dit2;\n  }\n  \n  if (td < .97 && ! update_dwh){\n      density_when_hit = td;\n  }\n  \n  // Store total density\n  col.a = td;\n  return length(p-ro);\n}\n\n// ---------------------- RENDER AND LIGHTNING ------------------------\n\n//iq's function\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in float radius, in int id, out vec3 outNormal, vec3 pos_cube) \n{\n    // Centerize ro\n    ro -= pos_cube;\n     \n    float phi = 2.*3.1415*(float(id));\n    float psi = 2.*3.1415*(float(id)+.6);\n    float theta = 2.*3.1415*(float(id)+.7);\n\n    mat3 txx = rot3D(iTime*(1.+hash11(float(id))*.2), phi, psi, theta);\n    mat3 txi = inverse(txx);\n    // Rotate ro and rd\n    ro = txx*ro;\n    rd = txx*rd;\n\n    // Intersect\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*vec3(radius);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n\n    // Inverse rotate Normal\n    outNormal = txi*outNormal;\n    return vec2( tN, tF );\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float ra, int id, vec3 pos_cube)\n{\n    ro -= pos_cube;\n     \n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    \n    return vec2( -b-h, -b+h );\n}\n\n// Coloring the particles\nvec3 getLightPart(vec3 ro, vec3 rd, int id, vec3 col, out float cubedepth, float density_when_hit, vec3 bloom){\n      // Since we use volumetric ray marching, the position do not represent cube surface.\n      // So we need to check the SDF another time considering only the cube \"id\"\n      \n     vec3 pos_cube = texelFetch(iChannel0, ivec2(id, 0.), 0).xyz;\n      \n     // Cube Case\n     #ifdef CUBE\n        float density = pow(density_when_hit, .2);\n        float depth = 0.;\n        // Ray intersect the nearest Cube with a radius slightly samller from the volumetric marcher\n        // Because we use a fixed step size around a cube the ray can miss the intersection around the edge.\n        // So, using a smaller radius reduce alliasing from this effect\n        // In counter part, it create black border when two cube are superposed but it's a minor effect\n        float radius = RAD - 2.;\n        vec3 normal = vec3(1.);\n        depth = boxIntersection(ro, rd, radius, id, normal, pos_cube).x;\n        if (depth == -1.){\n            #ifdef CUBE_BLOOM\n                return col + bloom;\n            #else\n                return col;\n            #endif\n        }\n        cubedepth = depth;\n        vec3 p = ro+rd*depth;\n        vec3 ld = normalize(p-pos_cube);\n        vec3 colS = palette(float(id)/NPARTICLES);\n\n        // Diffuse lightning\n        // The pow enforce darker edge on the cube\n        float dotLN = clamp(dot(ld, normal), 0., 1.);\n        vec3 diffuse = colS * pow(dotLN, 6.)*3.; \n\n        float flick = flicker(float(id));\n        vec3 final_col = flick*diffuse*exp(-max(depth-START, 0.)*.02);\n\n\n        final_col = final_col*(1.-density)+col.rgb*density;\n\n        return final_col;\n\n    // Sphere Case\n    #else\n        float radius = RAD - 2.;\n        float d = sphIntersect(ro, rd, radius, id, pos_cube).x;\n        float depth = d;\n        if (depth == -1.){\n        return col;\n        }\n        vec3 p = ro+rd*depth;\n        // No lightning since the source is the center of the ball\n        vec3 colS = palette(float(id)/NPARTICLES);\n        float flick = flicker(float(id));\n        vec3 final_col = flick*colS*exp(-max(depth-START, 0.)*.02);\n        float density = pow(density_when_hit, .2);\n        final_col = final_col*(1.-density)+col.rgb*density;\n        return final_col*10.*flick;\n    #endif\n}\n\n// Rendering\nvec4 render(vec3 ro, vec3 rd, out float depth){\n  vec4 col = vec4(0.);\n  int id = -1;\n  bool on_sph = false;\n  float density_when_hit = 0.;\n  vec3 bloom;\n  depth = rayMarch(ro, rd, col, id, on_sph, density_when_hit, bloom);\n  \n  // If we hit a cube compute the corresponding lightning else we have the volumetric color\n  if (on_sph){\n      float depthC = 0.;\n      col.rgb = getLightPart(ro, rd, id, col.rgb, depthC, density_when_hit, bloom);\n  }\n  #ifdef CUBE\n      #ifdef CUBE_BLOOM\n          else{\n              col.rgb += bloom;\n          }\n      #endif\n      return col;\n  #else\n      return col + vec4(bloom, 0.);\n  #endif\n}\n\n// ---------------------- MAIN ------------------------\n\n// Camera thing's\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // Setup ray origin, camera, ray direction\n  vec3 ro = vec3(0, 0, -185); \n  vec2 m = iMouse.xy/iResolution.xy;\n  if (iMouse.z == 0.){\n      m = vec2(.5, .4);\n  }\n  vec3 lookat = vec3(0., 0., 4.);\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y*2.));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z);\n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -.5));\n\n  float depth = 0.;\n  vec4 col = render(ro, rd, depth);\n  \n  // Gamma correction\n  fragColor = vec4(pow(max(vec3(0.), col.rgb*4.), vec3(.5)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NPARTICLES 20.\n#define PI 3.14159\n#define S(a,b,c) smoothstep(a,b,c)\n#define ROT mat3(cos(.7), 0., sin(.7), 0., 1., 0., -sin(.7), 0., cos(.7))\n#define ROT2 ROT*mat3(1., 0., 0., 0., cos(7.), sin(.7), 0., -sin(.7), cos(.7))\n#define ROT3 ROT2*mat3(cos(.7), sin(.7), 0., -sin(.7), cos(.7), 0., 0., 0., 1.)\n#define START 70.\nconst int MAX_MARCHING_STEPS = 60;\n\n\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat hash11(float p){\n    return fract(sin(p*12.789)*7896.4563);\n}\n\nfloat noise1(float p, float id)\n{\n    float i = floor(p);\n    float f = fract(p);\n    return mix(hash11(i+hash11(id*10.)*100.), hash11(i+1.+hash11(id*10.)*100.), smoothstep(0., 1., f));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, .5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., 0.33, 0.67);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere(vec3 p, vec3 c, float rad){\n    return length(p-c)-rad;\n}\n\nmat3 rot3D(float t, float phi, float psi, float theta){\n    float ca = cos(phi+t);\n    float sa = sin(phi+t);\n    float cb = cos(psi+t);\n    float sb = sin(psi+t);\n    float cg = cos(theta+t);\n    float sg = sin(theta+t);\n\n    return mat3(cb*cg, sa*sb*cg-ca*sg, ca*sb*cg+sa*sg,\n                cb*sg, sa*sb*sg+ca*cg, ca*sb*sg-sa*cg,\n                -sb,   sa*cb,           ca*cb);\n}", "buffer_a_code": "// Particles displacement buffer\n\nvec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    float phi = 2.*3.1415*pos.x;\n    float rad = 100.;\n    return vec3(cos(phi), hash11(seed.y)/5., sin(phi))*(200.+hash11(seed.x)*rad)+vec3(0.,-80.,0.);\n}\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel.x, 0., vel.z);\n}\n\n\nvec3 get_vel_change(vec3 p, int id) {\n  // Get a new velocity considering the position of the particles from the tornado\n  vec3 part = p;\n  vec3 nvel;\n  p.y *= -1.;\n  vec2 t = vec2(.07, .02)*4.;\n  float h = 300.;\n  p.y -= 80.;\n  p.xz += vec2(cos(p.y/17.+iTime*2.435)*2., sin(p.y/17.+iTime*1.4532)*2.)*(.75+.25*cos(iTime/8.))*(10.);\n  float dist;\n  // Cone's SDF\n  float d = sdCone(p, t, h);\n  \n  if (d<0.)\n      dist = 1.;\n  \n  // Custom velocity field\n  // Not perfect but do the job\n  else dist = 1./(1.+d*20.);\n  vec2 phi = normalize(p.xz).yx;\n  vec3 rot_around_cone = vec3(-phi.x, 0., phi.y)*500.; // Circle tangent \n  vec3 dir_to_cone = normalize(-p)*sign(d); \n  vec3 gravity = step(0., p.y)*vec3(0., -1, 0.)*abs(p.y)*10.; \n  nvel = mix(dir_to_cone*.75+gravity, rot_around_cone + vec3(0., 1., 0.)*.01, dist)*4.;\n  \n  // Slightly repulse cube from eachother\n  // Poor technique to replace collision\n  vec3 pos_other;\n  for (int i=0; i<int(NPARTICLES); i++){\n      if (i == id){\n          continue;\n      }\n      pos_other = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n      vec3 dir = pos_other-part;\n      float dist = length(dir);\n      dir = normalize(dir);\n      nvel -= 30.*dir * 1./(1.+.5*dist*dist);\n  }\n  \n  return nvel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(NPARTICLES) || uv.y>1){\n        // Pass most of time\n        fragColor = vec4(0.);\n        return;\n    }\n\n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    // Initialize position and velocity\n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n    }\n        \n    else{\n        // Get previous position and velocity\n        pos = texelFetch(iChannel0, ivec2(uv.x, 0), 0).xyz;\n        vel = texelFetch(iChannel0, ivec2(uv.x, 1), 0).xyz;\n        \n        // Update vel and pos\n        vel = (.95 * vel + .05 * (get_vel_change(pos, uv.x)));\n        pos += vel*.5;\n              \n        // Bound on y coordinate\n        if (abs(pos.y)>300.){\n            pos = init_position(hash33(pos+float(uv.x)));\n            vel = init_velocity(hash33(pos));     \n       }\n    }\n    \n    // Write position on first row\n    if (uv.y == 0){\n        fragColor.xyz = pos;\n    }\n    // Write velocity on second row\n    if (uv.y == 1){\n        fragColor.xyz = vel;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2XRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 221, 244, 304, 396], [398, 398, 419, 419, 462], [464, 464, 494, 580, 1408], [1410, 1425, 1458, 1510, 2070], [2577, 2593, 2662, 2662, 3285], [3363, 3363, 3484, 3484, 6281], [7463, 7463, 7540, 7540, 7784], [7786, 7812, 7923, 8095, 10143], [10847, 10865, 10912, 10912, 11123], [11125, 11125, 11182, 11182, 11769]], "test": "untested"}
{"id": "Dt2Szy", "name": "squaricle", "author": "oudend", "description": "it's a squaricle!", "tags": ["superb"], "likes": 3, "viewed": 171, "published": 3, "date": "1676286872", "time_retrieved": "2024-07-30T18:10:29.667037", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat manhattanDistance(vec2 p1, vec2 p2) {\n    float d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\treturn d1 + d2;\n}\n\nvec3 squareMask(vec2 uv, float rotation, vec2 mid, float thickness, float gap, vec2 ratio)\n{\n    float dist = (1. - manhattanDistance( rotate(uv*ratio, rotation), rotate(mid*ratio, rotation) )) - (1. - thickness);\n    float dist2 = (manhattanDistance( rotate(uv*ratio, rotation), rotate(mid*ratio, rotation ) )) - gap;\n    \n    return vec3( ceil(dist2 * dist) + min(.1, .1 - dist2) * .2 );\n    return vec3( ceil(dist2 * dist) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float ratio = iResolution.x / iResolution.y;\n    vec2 resRatio = vec2(ratio * .5, 1./ratio);\n    \n    int steps = 190;\n    float speed = .075;\n    float size = .001;\n    float thickness = .001;\n    float thicknessDiff = .0001;\n    float angleDiff = 1.;\n    float sizeDiff = .005;\n    float speedDiff = .1;\n    \n    \n    //speed = speed + mod(iTime, 1.) * .1;//speed + (mod(iTime / 2., 4.) / 40. );\n    \n    \n    // Time varying pixel color\n    \n    vec3 col = (.9 + 0.5*cos(iTime + uv.xyx*ratio+vec3(0,1,4))) * ( 1. - distance(uv,vec2(.5,.5))*1.2 )*.4;// * (1. - distance(uv, vec2(.5, .5)));\n    vec3 colConst = (.9 + 0.5*cos(iTime+vec3(4,1,4)));\n    \n    \n    vec3 squares = vec3(0.);\n    \n    for(int i = 0; i < steps; ++i)\n    {\n        vec3 square = squareMask(uv, iTime * (speed + speedDiff*float(i)) + angleDiff*float(i), vec2(.5,.5), size + sizeDiff*float(i) + (thickness+thicknessDiff*float(i)), size + sizeDiff*float(i), resRatio);\n        squares = (squares + square) / 1.01;\n    }\n    \n    colConst = max(vec3(0.), colConst - squares) * col;\n\n    // Output to screen\n    fragColor = vec4(colConst + col * squares,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2Szy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 114], [116, 116, 159, 159, 241], [243, 243, 335, 335, 673], [675, 675, 732, 782, 1959]], "test": "untested"}
{"id": "dtlXW4", "name": "Mod Sunset", "author": "robstalone", "description": "My experimenting with the Fuji shader", "tags": ["test"], "likes": 4, "viewed": 201, "published": 3, "date": "1676272827", "time_retrieved": "2024-07-30T18:10:30.424013", "image_code": "float sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.4, 0.39, length(uv));\n \tfloat bloom = smoothstep(0.65, 0.2, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.05 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery - 0.15));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 0.95;\n    \n    {\n        // Grid\n       vec3 col = vec3(0.05, 0.05, 0.1);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.2, 0.9, 0.3), gridVal);\n        }\n        else\n        {\n            uv.y -= battery * 1.1 - 0.51;\n            vec2 sunUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            col = vec3(1.2, 0.9, 0.3);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.06, 0.05, 0.04), col, sunVal);\n            \n        }\n        col = mix(vec3(col.r, col.r, col.r) * 0.2, col, battery);\n        fragColor = vec4(col,1.0);\n    }   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlXW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 342], [344, 344, 380, 380, 681], [683, 683, 740, 740, 1663]], "test": "untested"}
{"id": "DtjXDW", "name": "Raymarching Tesseracts", "author": "SpencerKuan", "description": "More 4d tests", "tags": ["raymarching", "4d", "hypercube"], "likes": 7, "viewed": 238, "published": 3, "date": "1676270122", "time_retrieved": "2024-07-30T18:10:31.184978", "image_code": "/*\n\n\n    This program demonstrates a render of a grid of \n    4D cube wireframes. Each cube has a blobby hypersphere \n    in the center as a point of reference. There is no movement\n    in the scene other than the camera's rotation.\n    \n    Each color represents a different direction in 4D space \n    (there are 8 sides to every 4D cube)\n    \n    To render the scene, a 4D camera takes a 3D 'picture' of \n    the scene using raymarching. A 2D 'slice' of this 3D picture\n    is displayed on the screen.\n    \n    You can control which 'slice' of the scene is rendered \n    by dragging the mouse along the x-axis on the screen.\n\n*/\n\n\n//  --- SETTINGS ---  // (remove the slashes to change the settings)\n\n// #define WALLS\n\n// \n\n\n\n// based on the 3D equivalent by IQ \nfloat sdBox( vec4 p, vec4 b ){\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.w, max(q.x,max(q.y,q.z))),0.0);\n}\n\n\n\n// the 4D SDF for the scene\nfloat map(vec4 p){\n\n    float d;\n    \n    #ifdef WALLS\n    \n        // room walls\n        const float wallDist = 7.0;\n        float wall = min(wallDist - p.x, wallDist + p.x);\n        wall = min(wall, wallDist + p.y);\n        wall = min(wall, wallDist - p.y);\n        wall = min(wall, wallDist + p.z);\n        wall = min(wall, wallDist - p.z);\n        wall = min(wall, wallDist + p.w);\n        wall = min(wall, wallDist - p.w);\n\n         d = (wall);\n\n        // domain repitition\n        p = mod(p + 5.0, 10.0) - 5.0;\n\n        // basic box\n        d = min(d, sdBox(p, vec4(1.2)));\n    #else\n    \n        // domain repitition\n        p = mod(p + 5.0, 10.0) - 5.0;\n        d = sdBox(p, vec4(1.2));\n    \n    #endif\n    \n    // box cutouts\n    float rem = sdBox(p, vec4(2, 1, 1, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 2, 1, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 1, 2, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 1, 1, 2));\n    d = max(d, -rem);\n    \n    \n    const float r = 5.0;\n    float disp = sin(p.x * r) * sin(p.y * r) * sin(p.z * r) * sin(p.w * r);\n    \n    // central sphere\n    d = min(d, (length(p) - 0.8 + disp * 0.2));\n    \n    return d;\n}\n\n// in: a point in 4D space\n// out: the normal of the surface using a central difference method on the 4D SDF\nvec4 normal(vec4 p){\n    vec2 e = vec2(0.001, 0);\n    float v = map(p);\n    \n    return normalize(vec4(\n        map(p + e.xyyy) - v,\n        map(p + e.yxyy) - v,\n        map(p + e.yyxy) - v,\n        map(p + e.yyyx) - v\n    ));\n}\n\n// finds the intersection between a ray starting at a \n// start position and a point on the 4D scene\n// out: distance to the intersection \nfloat intersect (vec4 start, vec4 dir){\n    // minimum distance for a intersection\n    const float eps = 0.01;\n    \n    // max constraints \n    const float maxD = 100.0;\n    const int maxIts = 200;\n    \n    // total distance traveled so far\n    float total = 0.0;\n    \n    // current position\n    vec4 pos = start;\n    \n    // current distance to a object\n    float d = 0.0;\n    \n    for(int i = 0; i < maxIts; i ++){\n        d = map(pos);\n        total = total + d;\n        pos += dir * d;\n        \n        if (d < eps) return total;\n        if (total > maxD) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n\n// returns the color contributions of a light on a surface\nvec3 shade (vec3 col, vec4 n, vec4 dir){\n    return col * max(dot(n, dir), 0.0);\n}\n\n// renders a point on a 3D viewport\nvec3 render3D (vec3 screen){\n    /*\n    \n        In 3D space, a camera works by projecting light to a 2D\n        screen. In 3D rendering, this plane usually spans the XY plane. \n        The point used for perspective is in the center of this plane \n        but is removed by some unit on the Z plane.\n    \n        In a similar manner, 4D space can be accurately captured with a \n        point camera using a 3D lense. Thus, the resulting 'image' is \n        really a 3D object. \n        \n        The camera point is a 4D point in the center of the cubish \n        camera picture but is removed by some unit on the W-dimension.\n    \n        Thus, this function takes an input in XYZ, projects a ray from \n        the camera point to that point, and then traces that ray until \n        it hits a point on the 4D scene to find an intersection to render. \n    \n    */\n\n\n    // pixelate the output\n    // screen = floor(screen * 50.0) / 50.0;\n\n    // camera rotation for the scene\n    mat4 rot = mat4(1.0);\n    \n    // animation variable for the rotation\n    float animate = (iTime) * 0.2;\n    \n    // composite rotations\n    \n    rot = rot * rotateXY(animate * 0.2);\n    rot = rot * rotateXZ(animate * 0.3);\n    rot = rot * rotateXW(animate * 0.4);\n    \n    rot = rot * rotateYZ(animate * 0.5);\n    rot = rot * rotateYW(animate * 0.6);\n    \n    rot = rot * rotateZW(animate * 0.7);\n\n    // 4D camera position, spun around the axis\n    vec4 cam = vec4 (0, 0, 0, -6) * rot;\n    \n    // 4D camera direction for that particular 3D viewport\n    vec4 dir = normalize(vec4(screen, 2.0)) * rot;\n    \n    // the total distance to a intersection with the 4D scene\n    float d = intersect(cam, dir);\n   \n    // black background for no collisions\n    if (d == -1.0) return vec3(0);\n    \n    // position and normal of the intersection in the 4D scene\n    vec4 p = cam + dir * d;\n    vec4 n = normal(p);\n    \n    // resulting output color\n    vec3 col = vec3(0);\n    \n    const vec3 colors[8] = vec3[8](\n        vec3(255, 105, 97) / 255.,\n        vec3(255, 180, 128) / 255.,\n        vec3(248, 243, 141) / 255.,\n        vec3(66, 214, 164) / 255.,\n        vec3(8, 202, 209) / 255.,\n        vec3(89, 173, 246) / 255.,\n        vec3(157, 148, 255) / 255.,\n        vec3(199, 128, 232) / 255.\n    );\n    \n    // shading for each of the 8 spacial directions in 4D space\n    col += shade(colors[0], n, vec4(+1, 0, 0, 0)); // +x\n    col += shade(colors[1], n, vec4(0, +1, 0, 0)); // +y\n    col += shade(colors[2], n, vec4(0, 0, +1, 0)); // +z\n    col += shade(colors[3], n, vec4(0, 0, 0, +1)); // +w\n    col += shade(colors[4], n, vec4(-1, 0, 0, 0)); // -x\n    col += shade(colors[5], n, vec4(0, -1, 0, 0)); // -y\n    col += shade(colors[6], n, vec4(0, 0, -1, 0)); // -z\n    col += shade(colors[7], n, vec4(0, 0, 0, -1)); // -w\n    \n    // make everything a little less bright\n    col = col * min(exp(-d * 0.08), 1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvo = (fragCoord/iResolution.xy * 2.0 - 1.0);\n    vec2 uv = uvo * iResolution.xy / min(iResolution.x, iResolution.y);\n\n    // mouse position (from 0 to 1)\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    /* \n        To show the 3D render on a computer's 2D screen, \n        I just take a slice of the resulting 3D image \n        and display that instead.\n        \n        The following z variable is which slice is chosen\n    */\n\n    // z position of the 3D viewport (another dimension of the screen)\n    float z = mouse.x == -1.0 ? sin(iTime * 0.25) * 0.5 : mouse.x;\n    \n    // 3D screen position for the particular pixel\n    vec3 screenCoord = vec3(uv, z).xyz;\n    \n    // rendered color\n    vec3 col = render3D(screenCoord);\n    \n    // gamma correction\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    \n    // output\n    fragColor = vec4(col, 1.0);\n    \n    if (abs(z - uvo.x) < 0.001 && abs(uvo.y) > 0.9) {\n        fragColor = fragColor * 0.5 + vec4(vec3(0.5), 1);\n    }\n}", "image_inputs": [], "common_code": "// 4D utils\n\nmat4 rotateXY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, 0.0, -s,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        s, 0.0, 0.0, c\n    );\n}\n\nmat4 rotateYZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateYW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, 0.0, -s,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, s, 0.0, c\n    );\n}\n\nmat4 rotateZW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, c, -s,\n        0.0, 0.0, s, c\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[728, 765, 795, 795, 892], [896, 924, 942, 942, 2112], [2114, 2223, 2243, 2243, 2451], [2453, 2592, 2631, 2674, 3195], [3198, 3257, 3297, 3297, 3339], [3341, 3377, 3405, 4352, 6290], [6293, 6293, 6350, 6400, 7424]], "test": "untested"}
{"id": "mlBXzG", "name": "mandlebbrot_KAL", "author": "gschian0", "description": "boom bam", "tags": ["zen"], "likes": 0, "viewed": 132, "published": 3, "date": "1676262754", "time_retrieved": "2024-07-30T18:10:32.043682", "image_code": "uniform float time;\n\nmat4 rotateZ(float angle)\n{\nreturn mat4(vec4(cos(angle), sin(angle), 0, 0), vec4(-sin(angle), cos(angle), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));\n}\n\nmat4 rotateY(float angle)\n{\nreturn mat4(vec4(cos(angle), 0, -sin(angle), 0), vec4(0, 1, 0, 0), vec4(sin(angle), 0, cos(angle), 0), vec4(0, 0, 0, 1));\n}\n\nmat4 rotateX(float angle)\n{\nreturn mat4(vec4(1, 0, 0, 0), vec4(0, cos(angle), sin(angle), 0), vec4(0, -sin(angle), cos(angle), 0), vec4(0, 0, 0, 1));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\nvec4 K = vec4(1.0, 1.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat noise(vec2 n)\n{\n  return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3(fragCoord.xy / vec2(iResolution.xy) * 2.0 - 1.0, 0.0);\n    uv *= 2.;\n    uv = abs(uv);\n    vec4 c = 2. *vec4(uv, 0.0);\n    vec3 color = vec3(0.1, 0.5, 0.1);\n    \n    // Antialiasing\n    float sampleCount = 32.0; // number of samples per pixel\n    float totalWeight = 0.0;\n    vec3 avgColor = vec3(0.0);\n    \n    for (int sampleIndex = 0; float(sampleIndex) < sampleCount; sampleIndex++) {\n        \n        float offsetX = (noise(vec2(iTime, fragCoord.y)) * 2.0 - 1.0) / sampleCount;\n        float offsetY = (noise(vec2(iTime, fragCoord.x)) * 2.0 - 1.0) / sampleCount;\n        \n        vec3 subPixelCoord = vec3(uv.xy + vec2(offsetX, offsetY), 0.0);\n        c = vec4(subPixelCoord, 0.0);\n        \n        color = vec3(0.1, 0.2, 0.1);\n        \n        for (int i = 0; i < 5; i++) {\n            c = rotateZ(iTime + float(float(i)+iTime) * 0.1) * rotateY(iTime + float(i) * 0.2) * rotateX(iTime + float(i) * 0.3) * c;\n            int iterations = 0;\n            int maxIterations = 200;\n            vec4 z = vec4(0.0);\n            for(int j = 0; j < maxIterations; j++)\n            {\n                float x = z.x;\n                float y = z.y;\n                float z_real = x * x - y * y + c.x;\n                float z_imag = 2.0 * x * y + c.y;\n                z = vec4(z_real, z_imag, 0.0, 0.0);\n                if(length(z) > 2.0)\n                {\n                    iterations = j;\n                    break;\n                }\n            }\n            color += hsv2rgb(vec3(float(iterations) / float(maxIterations), 1.0-float(iterations) / float(maxIterations), float(iterations) / float(maxIterations)));\n        }\n        \n        float weight = 1.0 / sampleCount;\n        avgColor += color * weight;\n        totalWeight += weight;\n    }\n    \n    avgColor /= totalWeight;\n    fragColor = vec4(avgColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 48, 48, 172], [174, 174, 201, 201, 325], [327, 327, 354, 354, 478], [480, 480, 502, 502, 659], [660, 660, 681, 681, 751], [756, 756, 813, 813, 2650]], "test": "untested"}
{"id": "dlBXzG", "name": "OVERLAP_ROTATING_MANDLEBROT", "author": "gschian0", "description": "having fun", "tags": ["zen"], "likes": 2, "viewed": 159, "published": 3, "date": "1676262709", "time_retrieved": "2024-07-30T18:10:32.795672", "image_code": "uniform float time;\n\nmat4 rotateZ(float angle)\n{\nreturn mat4(vec4(cos(angle), sin(angle), 0, 0), vec4(-sin(angle), cos(angle), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));\n}\n\nmat4 rotateY(float angle)\n{\nreturn mat4(vec4(cos(angle), 0, -sin(angle), 0), vec4(0, 1, 0, 0), vec4(sin(angle), 0, cos(angle), 0), vec4(0, 0, 0, 1));\n}\n\nmat4 rotateX(float angle)\n{\nreturn mat4(vec4(1, 0, 0, 0), vec4(0, cos(angle), sin(angle), 0), vec4(0, -sin(angle), cos(angle), 0), vec4(0, 0, 0, 1));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\nvec4 K = vec4(1.0, 1.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / vec2(iResolution.x, iResolution.y) * 2.0 - 1.0;\nvec2 c = vec2(uv);\n//c.x += 0.1 *sin(2.*3.14*c.y);\nvec3 color = vec3(0.2, 0., 0.5);\nfor (int i = 0; i < 50; i++) {\nmat4 rotZ = rotateZ(time + float(float(i)+iTime) *fract(iTime*.001));\nmat4 rotY = rotateY(time + float(i) * 0.2);\nmat4 rotX = rotateX(time + float(i) * 0.3);\nvec4 c_homo = vec4(c, 0.0, 1.0);\nc_homo = rotZ * rotY * rotX * c_homo;\nc = c_homo.xy;\nint iterations = 0;\nint maxIterations = 100;\nvec2 z = vec2(0.0);\nfor(int j = 0; j < maxIterations; j++)\n{\nfloat x = z.x;\nfloat y = z.y;\nfloat z_real = x * x - y * y + c.x;\nfloat z_imag = 2.0 * x * y + c.y;\nz = vec2(z_real, z_imag);\nif(length(z) > 2.0)\n{\niterations = j;\nbreak;\n}\n}\ncolor += hsv2rgb(vec3(float(iterations) / float(maxIterations), 1.0-float(iterations) / float(maxIterations), float(iterations) / float(maxIterations)));\n}\nfragColor = vec4(color*4. / 5.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 48, 48, 172], [174, 174, 201, 201, 325], [327, 327, 354, 354, 478], [480, 480, 502, 502, 659], [661, 661, 718, 718, 1628]], "test": "untested"}
{"id": "DtSXRy", "name": "Circulo-creado con bing chat", "author": "Sergeindamix", "description": "Para dibujar un crculo en Glsl, necesitas calcular la distancia al centro del crculo usando las coordenadas de textura o de fragmento. Luego, puedes usar una funcin como smoothstep o step para crear un borde suave o duro para el crculo, dependiendo de", "tags": ["learning"], "likes": 1, "viewed": 144, "published": 3, "date": "1676241110", "time_retrieved": "2024-07-30T18:10:33.618472", "image_code": "vec3 circleColor = vec3(1,0,0); // the color of the circle\nvec3 borderColor = vec3(0,0,0); // the color of the border\nuniform float radius; // the radius of the circle\nfloat borderThickness = 1.0; // the thickness of the border\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    // Calculate the distance to the center\n    float d = length(uv);\n    // Create a smooth border\n    float t = 1.0 - smoothstep(0.0, borderThickness, abs(radius-d));\n    // Mix the colors according to the border\n    \n    vec3 color = mix(vec3(0,0,0), vec3(1,0,0), t);\n    // Set the alpha channel according to the distance\n    float alpha = step(d, radius);\n    // Output the final color\n    // Output to screen\n    fragColor = vec4(color, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 228, 285, 335, 854]], "test": "untested"}
{"id": "DtSSzG", "name": "Fork Playable P manthrax 828", "author": "manthrax", "description": "WARNING: THRAX HERE.. I DID NOT WRITE THIS, I MERELY FIXED THE ASPECT RATIO. APOLOGIES FOR ANY MISUNDERSTANDING. ORIGINAL TITLE IS BELOW:\nMy first shader !\nNot impressive looking, but I hope it's original.", "tags": ["game"], "likes": 3, "viewed": 197, "published": 3, "date": "1676231919", "time_retrieved": "2024-07-30T18:10:34.368466", "image_code": "// Pong shader\n// \n// press the mouse and drag up and down to play.\n// HF ! jerome.\n// \n// todo :ball trail.\n\nvec2 uv;\nvec4 col;\nfloat aspect;\nvoid drawCircle( vec2 center, float radius )\n{\n\tvec2 dif = center - uv;\n    dif.x *= aspect;\n\tif( length(dif) < radius )\n\t{\n\t\tcol = vec4(1.0);\n\t}\n}\n\nvoid drawRectangle( vec2 center )\n{\n\tcenter.y = clamp(center.y, 0.25, 0.75 );\n\tif( abs( center.x - uv.x ) < 0.02 )\n\t{\n\t\tif( abs( center.y - uv.y ) < 0.05  )\n\t\t{\n\t\t\tcol = vec4(1,0,0,0);\n\t\t}\n\t}\n}\n\nvoid drawTable()\n{\n\tif( abs( 0.5 - uv.x ) < 0.25 )\n\t{\n\t\tif( abs( 0.5 - uv.y ) < 0.25  )\n\t\t{\n\t\t\tcol = vec4(0.2,0.2,0.2,1.0);\n\t\t}\n\t}\n}\n\nfloat GetheightForTime( float time )\n{\n\tfloat y = 0.0;\n\t\n\t// the X speed is always the same, only the Y speed varies\n\tfloat arraySpeed[3];\n\tarraySpeed[0] = 0.5;\n\tarraySpeed[1] = 0.4;\n\tarraySpeed[2] = 0.3;\n\t\t\n\tfloat div = floor( time / 3.0 );\n\tfloat rest = time - div*3.0;\n\tfloat distanceTotale = div * 0.4 * 3.0; // avg speed is 0.4\n\t\n\tif( rest > 0.0 && rest <= 1.0)\n\t{\n\t\tdistanceTotale += arraySpeed[0] * rest;\n\t}\n\tif( rest > 1.0 && rest <= 2.0)\n\t{\n\t\tdistanceTotale += arraySpeed[0] + arraySpeed[1] * (rest-1.0);\n\t}\n\telse if( rest > 2.0 )\n\t{\n\t\tdistanceTotale += arraySpeed[0] + arraySpeed[1] + arraySpeed[2]*(rest-2.0);\n\t}\t\n\t\n\tfloat restant = fract( distanceTotale );\n\t// move on the Y axis\n\t// how many time did we bounce so far ?\n\tif( restant >= 0.5 )\n\t{\n\t\ty = 0.25 - (restant-0.5);// going down\n\t}\n\telse\n\t{\n\t\ty = -0.25 + restant; //frc*dec; // going up\n\t}\n\n\treturn y;\n}\n\nvec2 findCenter()\n{\n\tvec2 start = vec2(0.5,0.5); // center\n\t\n\tfloat speed = 0.50; // 2 secs to go from one side to the other.\n\tfloat x = 0.;\n\tfloat y = 0.;\n\tfloat secs = floor(iTime);\t\n\tfloat dec = fract( iTime );\n    \n\ty = GetheightForTime(iTime);\n\t\n\t// move on the X axis (speed is constant, easy):\n\tfloat restant = fract( iTime * 0.5 );\n\tif( restant >= 0.5  )\n\t{\n\t\tx = 0.25 - (restant-0.5);\n\t}\n\telse\n\t{\n\t\tx = -0.25 + restant;\n\t}\n\t\n\t// check if the player missed\n\tif( x > 0.24 && length( iMouse.x ) > 100.0 )\n\t{\n\t\t// when is the ball going to reach the right side ?\n\t\tfloat timeReach = ceil( iTime );\n\t\tfloat yfuture = GetheightForTime( timeReach );\n\t\tif( abs( (0.5+y) - (iMouse.y / iResolution.y) ) > 0.07 )\n\t\t{\n\t\t\tcol = vec4(1.0,0.0,0.0,1.0);\n\t\t}\n\t}\n\n\treturn start + vec2(x,y);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\naspect = iResolution.x/iResolution.y;\n\tcol = vec4(0);\n\tuv = fragCoord.xy / iResolution.xy;\n\tvec2 center = findCenter();\n\t\n\tdrawTable();\n\tcenter.x = ((center.x-.5)*1.05)+.5;\n\tdrawCircle( center, 0.03 );\n\t\n\tif( length( iMouse.x ) > 100.0 )\n\t{\n\t\tdrawRectangle( vec2(0.8, iMouse.y / iResolution.y) );\n\t}\n\telse\n\t{\n\t\tdrawRectangle( vec2(0.8, center.y) );\n\t}\n\t\n\t// AI raquette\n\tdrawRectangle( vec2(0.2, center.y) );\n\tfragColor = col;\n}\n\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 189, 189, 290], [292, 292, 327, 327, 485], [487, 487, 505, 505, 619], [621, 621, 659, 659, 1494], [1496, 1496, 1515, 1515, 2280], [2282, 2282, 2339, 2339, 2768]], "test": "untested"}
{"id": "ctSSzG", "name": "Mandlebrot Audio Visualizer", "author": "fishy", "description": "has audio", "tags": ["audio", "visualizer", "mandlebrot"], "likes": 1, "viewed": 198, "published": 3, "date": "1676230825", "time_retrieved": "2024-07-30T18:10:35.116467", "image_code": "#define AA 8.\n\nvoid _mainImage( out vec4 c, in vec2 p )\n{\n    vec2 z = (p*3.-iResolution.xy)/iResolution.y-vec2(1.3, .5), m = z;\n    float i = 0.;\n    for(;i < 50. && length(z = vec2(z.x*z.x - z.y*z.y + m.x, 2.*z.x*z.y + m.y)) < 14.; i++) {}\n    c += cos(mix(\n                 pow(texture(iChannel0, vec2(abs(abs(z.x)-abs(z.y)*2.0), 0)*0.05).r, 8.)*1.5, // inside set\n                 i/33., // outside\n                 1.-float(i>47.))+vec4(5, 4, 2, 0))/AA;\n}\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    c = vec4(0);\n    for(float i = 0.; i < AA; i++)\n        _mainImage(c, p + (fract(sin(p*25.6)*cross(p.xyx + iTime, p.yxx + i*216.165).xy)-0.5)); // terrible hash lol\n}", "image_inputs": [{"id": 32384, "src": "https://soundcloud.com/eduardo-giron-546618539/colbreakz-gold-ring", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 57, 57, 460], [462, 462, 501, 501, 672]], "test": "untested"}
{"id": "dtBSWm", "name": "Flow Field CA", "author": "SnoopethDuckDuck", "description": "I bashed Michael's shader with a brick and used it to make flow fields :)\n\nIt uses 3D noise from iq's shader:\nhttps://www.shadertoy.com/view/4sfGzS", "tags": ["particles", "ca", "flowfield"], "likes": 21, "viewed": 423, "published": 3, "date": "1676221726", "time_retrieved": "2024-07-30T18:10:35.892392", "image_code": "#define texel(a, p) texelFetch(a, ivec2(mod(p,iResolution.xy)), 0)\n\n// this code is bad \nvoid mainImage( out vec4 col, in vec2 pos )\n{ \n    vec2 uv = (pos - 0.5 * iResolution.xy) / iResolution.y;\n    float a = noise(vec3(0.02 * pos, floor(spd * iTime)));\n    vec4 data = texel(iChannel0, pos);\n    vec3 pl = .55+.45*cos(2.*PI*(0.25 * cos(PI*a) + 0.35 + 0.5 * data.w + vec3(data.w,0.5,0.5)/3.));\n    pl = mix(pl, vec3(.5+.5*data.w), 0.85);\n    \n    pl = vec3(0.1*(1.+a)/pl);mix(pl, vec3(a), .5-.5*cos(PI*a+vec3(0,1,2)/3.));\n    pl -= 0.2 * (a+1.);\n    pl += vec3(0.15,0.15,0.2);\n    //pl = clamp(pl, 0., 1.);\n    //pl = pow(pl, vec3(1./1.4));\n    pl = tanh((1.+vec3(1.8,1.6,1.4)) * pl);\n    pl = mix(pl, vec3(0.08), 1.-clamp(3.*exp(-2.*length(uv)), 0., 1.));\n    col = vec4(pl, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n\n#define spd 0.15\n\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}", "buffer_a_code": "#define texel(a, p) texelFetch(a, ivec2(mod(p,iResolution.xy)), 0)\n\n// [0, 4] is a good range. lower values -> more octagonal curves\n#define soft1 0.6\n\n// diffuse, higher values -> more fluid-like, more blurry\n#define dif 0.6\n\n// zoom of the noise field\n#define fieldScale 0.02\n\n// [0, 2] a good range, lower values -> softer\n#define soft2 0.35\n\nvec3 distribution(vec2 x, vec2 p, float K) {\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\nvec4 Reintegration(sampler2D ch, vec4 data, vec2 pos) {\n    data.xyz *= 0.;\n    \n    for (int i = -2; i <= 2; i++)\n    for (int j = -2; j <= 2; j++)\n    {\n        vec2 tpos = pos + vec2(i,j) + soft1 * (hash32(pos + iTime).x - 0.5); \n        \n        vec4 data0 = texel(ch, tpos);      \n        data0.xy = tpos;\n       \n        vec3 D = distribution(data0.xy, pos, dif);\n        \n        //the deposited mass into this cell\n        float m = data0.z*D.z;\n        \n        //add weighted by mass\n        data.xy += D.xy*m;\n      \n        //add mass\n        data.z += m;\n    }\n    \n    // hacky way to get data.w to converge to a value.\n    // data.w \"trails\" the mass data.z\n    float f = 1.-fract(spd * iTime);\n    data.w = mix(data.w, data.z, 0.04 * f);\n   \n    return data;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec4 data = texel(iChannel0, pos);   \n    \n    float a = noise(vec3(fieldScale * pos, floor(spd * iTime)));\n    a *= PI;    \n    \n    pos += vec2(0, 1);\n    pos += vec2(cos(a), sin(a));\n\n    data = Reintegration(iChannel0, data, pos);     \n\n    data.z += soft2 * (hash32(pos).x - 0.5);\n    data.z = clamp(data.z, -1., 1.);\n\n    U = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 89, 134, 134, 783]], "test": "untested"}
{"id": "dlBSWw", "name": "Taquin", "author": "rubioh", "description": "U can insert any shader in buffer A ! \nPress space to reset (when you change resolution)\nIn Common, u can change number of tiles and swap frequency with SPEED\n\n\n//TODO interactive swap", "tags": ["taquin"], "likes": 8, "viewed": 197, "published": 3, "date": "1676220180", "time_retrieved": "2024-07-30T18:10:36.647373", "image_code": "vec3 TileColoring(vec2 idx, vec2 pos){\n    vec2 uv = (idx + pos)/TILE;\n    return texture(iChannel0, uv).rgb;\n}\n\nvec2 getTile(vec2 uv){\n    vec2 st = texture(iChannel1, uv).xy;\n    return st;\n}\n\n\nfloat getHeight(vec2 uv){\n    float L = length_(uv-.5, 14.);\n    float H = pow(L*2., 8.);\n    return (H);\n}\n\nvec3 calcNormal(vec2 uv){\n    vec2 eps = vec2(1.,-1.)*.01;\n    return normalize(\n            eps.yxx*getHeight(uv+eps.yx)+\n            eps.xyx*getHeight(uv+eps.xy)+\n            eps.xxx*getHeight(uv)\n            );\n}\n\nvec3 getLight(vec2 uv, vec3 col, vec2 globalUV){\n    \n    vec3 sp = vec3(globalUV, 0.);\n   \n    // FROM https://www.shadertoy.com/view/DtfSRB\n    vec2 eps = vec2(1.,0.)*.001;\n    float h = getHeight(uv);\n    vec3 bumpMap = vec3(  (getHeight(uv+eps.xy)-h), (getHeight(uv+eps.yx)-h), 0.)/eps.x*.2;\n    \n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 lp = vec3(iMouse.xy/iResolution.xy, -0.45); // Light position\n    vec3 sn = vec3(0., 0., -1);\n    \n    sn = normalize( sn + bumpMap);           \n\n    \n    vec3 ld = lp-sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n        \n\tfloat diff = max(dot(sn, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 62.);\n    \n    return (diff*col*.9 + spec*vec3(.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 SLOT = floor(uv*TILE);\n\n    vec2 idx = getTile(uv);\n    vec2 coord = fract(uv*TILE);\n    vec2 free = texture(iChannel1, uv).zw;\n    \n        \n    float L = length_(coord-.5, 10.);\n    float border = S(.5, .48, L);\n\n    \n    vec3 col = getLight(coord,  TileColoring(idx, coord)*border, uv);\n    col = (SLOT == free) ? vec3(0.) : col;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos){\n    float scale = 10.0;\n    pos *= scale;\n    float v = sin(pos.x*3.1415);\n    \n    return smoothstep(-1., 1., v/fwidth(v));\n}\n\n\n// https://thebookofshaders.com/edit.php#11/circleWave-noise.frag\nfloat shape(vec2 st, float radius) {\n    float r = length(st)*2.0;\n    float a = atan(st.y,st.x);\n    float m = abs(mod(a+iTime*2.,3.14*2.)-3.14)/3.6;\n    float f = radius ;\n    m += noise(st+iTime*0.1)*.5;\n    // a *= 1.+abs(atan(u_time*0.2))*.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f += sin(a*10.)*noise(st+iTime*.2)*.1;\n    f += (sin(a*20.)*.1*pow(m,2.));\n    return 1.-smoothstep(f,f+0.1,r);\n}\n\nfloat shapeBorder(vec2 st, float radius, float width) {\n    return shape(st,radius)-shape(st,radius-width);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    vec2 pos = uv.yx*vec2(2.,4.);\n\n    float circle = 1. - step(shapeBorder(uv,0.6+ abs(cos(iTime))*.2, 10.), length(uv));\n\n\n    float pattern_ext = 0.;\n    float pattern_int = 0.;\n\n    pos += abs(cos(.5*iTime*vec2(0.1+sin(iTime/1600.), cos(iTime)/1600.+.2)*.2+ .1*length(pos)*vec2(1.,.1)));\n\n    // Add noise\n    pos = rotate2d(noise(pos) ) * pos;\n    // Draw lines\n    pattern_ext = 2.*lines(pos*(1.-circle));\n    \n    pattern_int = 2.*lines(pos*circle);\n    \n    vec3 pattern_color = (1.-circle)*pattern_ext*vec3(.6, .2, .1);\n    pattern_color += (circle)*(1.-pattern_int)*vec3(.2, .4, .3);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(pattern_color+.05,1.0);\n    \n }", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Usless for the moment, i will update this to swap the tiles smoothly\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 displacement = vec2(0.);\n    vec2 toMove = vec2(0.);\n    if (iFrame == 0){\n        fragColor.xy = displacement;\n        fragColor.zw = toMove;\n        return;\n    }\n    \n    if (mod(float(iFrame), 100.) == 0.){\n        vec2 free = texture(iChannel1, uv).zw;\n        vec2 toMove = ChooseNeighbour(free, iFrame);\n        fragColor.zw = toMove;\n        return;\n    }\n    else{\n        toMove = texture(iChannel0, uv).zw;\n        float tmp = mod(float(iFrame), 100.);\n        displacement = clamp(toMove*tmp/40., vec2(-1,-1), vec2(1., 1.));\n        fragColor.xy = displacement;\n        fragColor.zw = toMove;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TILE 9.\n#define SPEED 10.\n#define S(a,b,c) smoothstep(a,b,c)\n\n\nfloat hash11(float p){\n    return fract(sin(p*4573.2345)*143.1234);\n}\n\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(134.25463, 289.3458))*4573.2345)*143.1234);\n}\n\nfloat length_(vec2 uv, float P){\n    float x = pow(abs(uv.x), P);\n    float y = pow(abs(uv.y), P);\n    return pow(x+y, 1./P);\n}\n\nvec2 ChooseNeighbour(vec2 free, int iFrame){\n   // Very ugly\n   float r = hash11(float(iFrame)/743.);\n   if (free == vec2(0.)){\n       return (r>.5) ? vec2(0,1) : vec2(1,0);\n   }\n   if (free.x == 0.){\n       if (free.y == TILE-1.){\n           return (r>.5) ? vec2(1,0) : vec2(0,-1);\n       }\n       return (r<.33) ? vec2(1,0) : (r<.66) ? vec2(0,1) : vec2(0,-1);\n   }\n   if (free.y == 0.){\n       if (free.x == TILE-1.){\n           return (r>.5) ? vec2(-1,0) : vec2(0,1);\n       }\n       return (r<.33) ? vec2(0,1) : (r<.66) ? vec2(1,0) : vec2(-1,0);\n   }\n   if (free.y == TILE-1.){\n       if (free.x == TILE-1.){\n           return (r>.5) ? vec2(-1,0) : vec2(0,-1);\n       }\n       return (r<.33) ? vec2(1,0) : (r<.66) ? vec2(-1,0) : vec2(0,-1);\n   }\n   \n   if (free.x == TILE-1.){\n       return (r<.33) ? vec2(-1,0) : (r<.66) ? vec2(0,-1) : vec2(0,1);\n   }\n   return (r<.25) ? vec2(-1,0) : (r<.5) ? vec2(0,-1) : (r<.75) ? vec2(1, 0) : vec2(0, 1);\n}\n", "buffer_c_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 SLOT = floor(uv*TILE);\n\n    if (iFrame == 0 || texelFetch(iChannel3,ivec2(32,0),0).x > 0.){\n        fragColor.xy = floor(uv*TILE);\n        fragColor.zw = vec2(2,2);\n    }\n    else{\n        vec4 state = texture(iChannel0, uv).xyzw;\n\n        if (mod(float(iFrame), float(int(SPEED))) == 0.){\n        \n            vec2 st = state.xy;\n            vec2 free = state.zw;\n\n            vec2 tile_idx = floor(st);\n\n            vec2 toMove = ChooseNeighbour(free, iFrame);\n\n            if(toMove != vec2(0,0)){\n\n                if (SLOT == toMove+free)\n                    tile_idx = floor(texture(iChannel0, (SLOT-toMove+.1)/TILE).xy);\n                else if (SLOT == free) \n                    tile_idx = floor(texture(iChannel0, (SLOT+toMove+.1)/TILE).xy);\n            }\n            fragColor.xy = vec2(tile_idx);\n            fragColor.zw = free+toMove;\n\n        }\n        else fragColor = state;\n    }\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 111], [113, 113, 135, 135, 193], [196, 196, 221, 221, 303], [305, 305, 330, 330, 520], [522, 522, 570, 570, 1258], [1260, 1260, 1317, 1367, 1817]], "test": "untested"}
{"id": "mtjSWm", "name": "Fork SoundEclip nobody 012", "author": "nobody", "description": "a twist on DuckMonster's SoundEclipse (https://www.shadertoy.com/view/4tGXzt), adding some rotation.\nIt looks better as a visualization in virtualdj with the rotation and beatmove.", "tags": ["visualization", "mic", "virtualdj"], "likes": 6, "viewed": 735, "published": 3, "date": "1676215134", "time_retrieved": "2024-07-30T18:10:37.402355", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 10.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.0;\nconst float BRIGHTNESS = 0.5;\nconst float SPEED = 0.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "untested"}
{"id": "Dl2SWm", "name": "crowded pillars 3  ( 404 chars )", "author": "FabriceNeyret2", "description": "regolfing 458 chars [url]https://shadertoy.com/view/4lsSRB[/url]\ncompact simplified version of [url]https://www.shadertoy.com/view/4lfSDn[/url]", "tags": ["3d", "raymarching", "short", "golf"], "likes": 26, "viewed": 445, "published": 3, "date": "1676200665", "time_retrieved": "2024-07-30T18:10:38.154344", "image_code": "// regolfing 458 chars https://shadertoy.com/view/4lsSRB\n// compact simplified version of https://www.shadertoy.com/view/4lfSDn \n\n// -5 by fab, -3 by coyote\n\n#define r(t)    mat2(cos( t*T + vec4(0,11,33,0))),              //\n#define M(a,b)  1. / ( 1./length(a) + 1./length(b) )            //\n#define D(s)    min( A = abs(fract(p)+s.2), min(A.y,A.z) ).x,\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    \n    float T=iTime, l=1.,a,b; \n    vec3 p = vec3(u,0)/iResolution.y-.5, d,q,A; p.x-=.4;\n    p.xz *= r(.13)  p.yz *= r(.2)\n    d = p; p.z += 5.*T;\n    for ( o = 1.2 + o*0. ; o.x>0. && l>.01; o-=.012 ) \n        q = mod(p,8.) - 4., \n        l = M(q.xy,M(q.yz,q.xz)) -.7,\n        a = D(-) b = D()\n     \tl = sqrt(l*l+min(a*a,b*b)),\n//     \tl = sqrt(l*l+min(D(-)*D(-),D()*D())), // would this work on windows ?\n        p -= d*l;                             // ( without , at end of #def D )\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2SWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ct2SWm", "name": "circle dithering ( golf )", "author": "FabriceNeyret2", "description": "golfing 496 chars [url]https://shadertoy.com/view/MdSfWK[url]\nbetter seen fullscreen\nref image: [url]http://www.boredpanda.com/single-line-plotter-scribbles-sergej-stoppel/[/url]", "tags": ["halftone", "dithering", "short", "golf", "reproduction"], "likes": 31, "viewed": 658, "published": 3, "date": "1676197946", "time_retrieved": "2024-07-30T18:10:38.905336", "image_code": "// golfing 496 chars https://shadertoy.com/view/MdSfWK\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(1);                                                      // start plain white\n    for (int k=0; k<289; k++) {                                       // check 17x17 neighborhood\n        vec2 P = ceil( U/4. + vec2(k%17,k/17) - 9. );                 // cell Id\n        P += fract( 1e4* sin( P * mat2(12.1,-37.4,-17.3,31.7) )) -.5; // random point in cell\n        P *= 4.;\n        float v = texture(iChannel0, P/iResolution.xy ).r ,           // check texture there\n              r = 2.+30.*v;                                           // circle radius\n        fract( 1e4* sin( dot(P,vec2(12.1,31.7))  )) * r/8. < 1.-v     // drawing proba ~ darkness/circumference\n          ?  O -= .2 * smoothstep(1.5,0.,abs( length(P-U) - r )) :O;  // draw antialiased circle\n    }\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2SWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 95, 95, 873]], "test": "untested"}
{"id": "dtBSDw", "name": "Polygon SDF Modelling Tool", "author": "fenix", "description": "Not so much as a toy as a tool to help us (me) to make toys. I really wanted something like this when I was working on my last shader.\n\n*drag vertex to move*\n*click edge to add vertex*\n*shift-click vertex to delete*\n*space to hide/show vertex positions* \n", "tags": ["2d", "mouse", "interactive", "sdf", "model", "polygon", "tool", "editor"], "likes": 40, "viewed": 518, "published": 3, "date": "1676183641", "time_retrieved": "2024-07-30T18:10:39.957523", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Polygon SDFs are very expressive, allowing us to create any shape we want. But\n//  modelling with them directly in ShaderToy is difficult. When you're just staring\n//  at an array of numbers, it's hard to know which vertex you're even modifying, let\n//  alone what new number to punch in. This shader seeks to create a functional workflow\n//  for creating polygons for use in shaders. Really, this is the shader I wished I had\n//  when I was working on this other shader with lots of polygon art:\n//  \n//    Celtic Knots Zoo: Wood Carving     https://shadertoy.com/view/DlX3Ds\n//  \n//  HOW TO USE:\n//\n//    * Click the vertices to move them around\n//    * Click on an edge to create a new vertex\n//    * Shift-click a vertex to remove it\n//    * Alt-click to toggle selection of a vertex\n//    * Left and right arrow to change the selected vertex, backspace to delete it\n//    * Drag anywhere else to select vertices in a rectangle\n//       - Drag all selected vertices together to reposition them\n//       - Press backspace to delete all selected vertices\n//    * Press the \"A\" key to select all vertices\n//    * When you're done, copy all the vertex coordinates into an array in your shader.\n//       - Low tech method is to type them by hand into the shadertoy editor.\n//       - I've had some success using \"P\" to hide polygon render, then saving out\n//         the image and loading it into OCR software e.g.: https://www.onlineocr.net/\n//    * Use iq's polygon SDF function with it: https://www.shadertoy.com/view/wdBXRW\n//    * Use the min and max values as an optional bounding box.\n//    * To save your work, fork this shader (privately please) and copy your vertices\n//      into INIT_VERT_POS_ARRAY in the Common tab. Then you can resume editing where\n//      you left off if need be.\n//\n//  Should this shader exist? I'm not sure. There's probably a way to do this in 17\n//  lines using JavaScript or something. But I don't know JavaScript. There are probably\n//  better free tools for this already on the web, but I tried to find one and everything\n//  I came across seemed way too powerful for this purpose. Maybe someone reading this\n//  will point me to the correct tool to use for this, and if that's the only outcome of\n//  this shader it will still be time well spent.\n//\n//  One reason for this shader to exist is that it's meant to be used to make shaders\n//  on this platform, so we can customize it to improve its usability for that purpose.\n//  Toward that end, any suggestions for improvement are very welcome!\n// \n//  Here's some ideas I had for improvements, I'll gladly implement these if anyone\n//  would be interested in using them:\n//\n//    * Other rendering styles...would it be helpful to render the polygon itself as a\n//      simple solid or wireframe model? Shaded somehow?\n//    * Rotate vertices button? If you want a different vertex in the first slot without\n//      changing the shape.\n//    * Some kind of way to get the numbers out of the shader other than typing them in by\n//      hand. Maybe...a QR code?\n//    * More advanced editing tools? This is meant to be a light weight editor but maybe\n//      there are some key tools missing?\n//    * Different basis? (0...8 is pretty convenient to work in for example)\n//\n//  Buffer A computes the vertex positions and neighbors\n//  Buffer B handles persistent state data\n//\n//  Update 2/12/23: Added multi-selection! Drag to select multiple verts, alt-click to\n//    toggle selection, key \"A\" to select all verts. All selected verts can be dragged.\n//  Update 2/12/23: Fixed multi-selection delete.\n//  Update 2/13/23: Display vertices in glsl format.\n//  Update 2/13/23: Added a cat polygon example (enable in the common tab then rewind\n//    the shader).\n//\n// ---------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdPolygon(int num, vec2 p)\n{\n    float d = dot(p-fxGetVertex(0),p-fxGetVertex(0));\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = fxGetVertex(j) - fxGetVertex(i);\n        vec2 w =    p - fxGetVertex(i);\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=fxGetVertex(i).y, \n                            p.y <fxGetVertex(j).y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// you know it, you love it, the SDF debug color\nvec3 sdfDebugColor(float d)\n{\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\treturn mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n}\n\n// From FabriceNeyret2's iResolution, iDate, iMouse, etc: https://shadertoy.com/view/llySRh\n\n//     First only determine the valid char id at cur pixel \n//     then call the draw char once at the end.\nint char_id = -1; vec2 char_pos, dfdx, dfdy; vec4 char_color; vec4 cur_color;\nvoid char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy, char_color = cur_color;\n}\n\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\n\nvoid pInt(vec2 p, float n) {\n    if (n < 0.) \n    {\n        char(p - vec2(-1,0), 45 );\n        n = -n;\n    }\n    for (float i = 3.; i>=0.; i--) \n    {\n        n /=  9.999999; // 10., // for windows :-(\n        char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    }\n}\n\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n\n// print some 2D coords to the screen with brackets around them\nvoid pCoords(vec2 U, vec2 c, bool comma)\n{\n    C(-24); if (c.x < 0.) spc; C(-18); spc; pInt(U, c.x * 10000.); spc; spc; spc; C(-20); if (c.y < 0.) spc;\n    C(-18); spc; pInt(U, c.y * 10000.); spc; spc; spc; C(-23); if (comma) { C(-20); }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{   \n    fxState state = fxGetState();\n    vec2 p = (u - .5*iResolution.xy)/iResolution.y;\n    \n    // render the old vertices while we're in the process of adding or removing one\n    int numVerts = state.numVerts;\n    if (state.grabAction == ACTION_ADD) numVerts--;\n    if (state.grabAction == ACTION_DELETE) numVerts += countBits(state.selectedVerts);\n    \n    // render polygon\n    O = vec4(0);\n    \n    if (state.renderPoly)\n    {\n        // distance to polygon\n        float d = sdPolygon(numVerts, p);\n        O.xyz = sdfDebugColor(d);\n    }\n    \n    cur_color = vec4(1);\n    vec2 U0 = p - vec2(-iResolution.x/iResolution.y * .5, .425);\n    U0 *= TEXT_SIZE;\n    vec2 U = U0;\n    \n    // render Verts: XXXX\n    C(22); low C(5); C(18); C(20); C(19); caps C(-6); spc; spc; pInt(U, float(state.numVerts));    \n    if (state.renderVerts)\n    {\n        U = U0 + vec2(0, 1.5);\n        low C(22); C(5); C(3); caps C(-14); C(27); C(29); spc; low C(22); C(5); C(18); C(20); C(19); spc; caps C(-3); spc;\n        low C(22); C(5); C(3); caps C(-14); C(27); C(29); C(-24)\n    }\n    U = U0 + vec2(-1, 2.5);\n    \n    const float THICKNESS = .005;\n\n    vec2 mins = vec2(1e6);\n    vec2 maxs = vec2(-1e6);\n    for (int i = 0; i < numVerts; ++i)\n    {\n        vec2 pos = fxGetVertex(i);\n        mins = min(mins, pos);\n        maxs = max(maxs, pos);\n        \n        if (state.renderVerts || !state.renderPoly)\n        {\n            bool selected = isUvec4BitSet(state.selectedVerts, i);\n            \n            // render red circles\n            if (state.renderPoly)\n            {\n                float d = distance(pos, p);\n                vec4 dotColor = selected ? vec4(0, 1, 0, 1) : vec4(1, 0, 0, 1);\n                O = mix(O, dotColor, smoothstep(1. / iResolution.y, 0., abs(d - MAX_GRAB_DIST) - THICKNESS));\n            }\n\n            // render coordinates\n            vec2 coord = vec2(float(i / LINES) * -9.5, i % LINES);\n            cur_color = selected ? vec4(0, 1, 0, 1) : vec4(1);\n            pCoords(U + vec2(coord), pos, i < numVerts - 1);\n        }\n    }\n\n    cur_color = vec4(1);\n    \n    if (state.renderVerts)\n    {\n        vec2 coord = vec2(1. + float(numVerts / LINES) * -9.5, numVerts % LINES);\n        U += vec2(coord);\n        C(-23); C(-5);\n    }\n    \n    // render Min: [X, X]\n    U = U0 - vec2(6.5, 0);\n    C(13); low C(9); C(14); caps C(-6); spc\n    pCoords(U, mins, true);\n    \n    // render Max: [X, X]\n    U -= vec2(9.5, 0);\n    C(13); low C(1); C(24); caps C(-6); // Max\n    pCoords(U, maxs, false);\n    \n    //O -= draw_char().xxxx;\n    char_pos += vec2(-.025, .025);\n    O = mix(O, vec4(0), draw_char().xxxx);\n    char_pos += vec2(.05, -.05);\n    O = mix(O, char_color, draw_char().xxxx);\n    \n    // render selection rectangle\n    if (state.grabAction == ACTION_SELECT)\n    {\n        vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n        vec2 boxCenter = (m + state.grabOffset) * .5;\n        vec2 boxExtents = abs(m - state.grabOffset) * .5;\n        float bd = sdBox(p - boxCenter, boxExtents);\n        O = mix(O, vec4(1), smoothstep(1. / iResolution.y, 0., abs(bd - MAX_GRAB_DIST) - THICKNESS));\n    }\n    \n    O.a = 1.;\n    //O = texture(iChannel2, u / iResolution.xy);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int LINES = 18;\nconst int MAX_VERTICES = LINES * 4; // how many do you really need?\nconst float TEXT_SIZE = 23.; // scales the text\nconst float MAX_GRAB_DIST = .02; // size of handles on vertices\n\n#if 1 // set to zero to enable cat example polygon\n// fork this shader and copy your polygon here to save it for more editing later\nconst int NUM_INIT_VERTS = 4;\nconst vec2[NUM_INIT_VERTS] INIT_VERT_POS_ARRAY = vec2[](\n    vec2(-.25,  .25),\n    vec2(-.25, -.25),\n    vec2( .25, -.25),\n    vec2( .25,  .25)\n);\n#else\nconst int NUM_INIT_VERTS = 57;\n\nvec2 INIT_VERT_POS_ARRAY[NUM_INIT_VERTS] = vec2[](\n    vec2(-.3611,  .1611), vec2(-.3748,  .0705), vec2(-.3729, -.0289), vec2(-.4263, -.0861), vec2(-.4640, -.2351), vec2(-.4420, -.3109),\n    vec2(-.3769, -.3278), vec2(-.3503, -.2880), vec2(-.3791, -.2880), vec2(-.3518, -.1545), vec2(-.2936, -.3289), vec2(-.2351, -.3362),\n    vec2(-.2011, -.3026), vec2(-.2353, -.3362), vec2(-.2709, -.1860), vec2(-.1916, -.0790), vec2( .0180, -.1125), vec2(-.0540, -.3109),\n    \n    vec2(-.0357, -.3959), vec2( .0530, -.4028), vec2( .0489, -.3514), vec2( .0291, -.3061), vec2( .1292, -.1678), vec2( .2382, -.2473),\n    vec2( .3710, -.3797), vec2( .4420, -.3817), vec2( .4310, -.3225), vec2( .3911, -.3030), vec2( .3255, -.2074), vec2( .2513, -.0338),\n    vec2( .2753,  .0660), vec2( .3159,  .1415), vec2( .3485,  .1585), vec2( .3798,  .1663), vec2( .4114,  .1841), vec2( .4189,  .2119),\n    \n    vec2( .4240,  .2313), vec2( .4046,  .2503), vec2( .3738,  .2729), vec2( .3463,  .3034), vec2( .2622,  .3149), vec2( .2183,  .3624),\n    vec2( .2025,  .3515), vec2( .2064,  .2763), vec2( .1760,  .2200), vec2( .1222,  .1638), vec2(-.0029,  .1504), vec2(-.3013,  .1993),\n    vec2(-.3589,  .2386), vec2(-.3894,  .3087), vec2(-.3850,  .3777), vec2(-.4273,  .4373), vec2(-.4629,  .4355), vec2(-.4795,  .4097),\n    \n    vec2(-.4372,  .3537), vec2(-.4327,  .2703), vec2(-.4004,  .1993)\n);\n#endif\n\n    \n// returns the location of the vertex within the vertex buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id)\n{\n    return ivec2(id % width, id / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X)\n\n// get the vertex corresponding to the input id\nvec2 fxGetVertexImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id), 0).xy;\n}\n\nvec4 fxSaveVertex(vec2 v)\n{    \n    return vec4(v, 0, 0);\n}\n\n#define fxGetVertex(X) fxGetVertexImpl(iChannel0, int(iResolution.x), X)\n\n// user actions\n#define ACTION_NONE 0\n#define ACTION_DRAG 1\n#define ACTION_DELETE 2\n#define ACTION_ADD 3\n#define ACTION_SELECT 4\n\n// persistent state (managed in buffer B)\nstruct fxState\n{\n    uvec4 selectedVerts;\n    vec2 grabOffset;\n    vec2 lastMouse;\n    int grabAction;\n    int numVerts;\n    bool renderVerts;\n    bool renderPoly;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    vec4 data2 = texelFetch(sampler, ivec2(0, 2), 0);\n    \n    fxState state;\n    state.selectedVerts = floatBitsToUint(data0);\n    state.grabOffset = data1.xy;\n    state.grabAction = int(data1.z);\n    state.renderVerts = data1.w != 0.;\n    state.numVerts = int(data2.x);\n    state.lastMouse = data2.yz;\n    state.renderPoly = data2.w != 0.;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n        return vec4(uintBitsToFloat(state.selectedVerts));\n    else if (ifc == ivec2(0, 1))\n        return vec4(state.grabOffset, state.grabAction, state.renderVerts ? 1. : 0.);\n    else\n        return vec4(state.numVerts, state.lastMouse, state.renderPoly ? 1. : 0.);\n}\n\nbool fxIsStatePixel(ivec2 ifc) { return ifc == ivec2(0) || ifc == ivec2(0, 1) || ifc == ivec2(0, 2); }\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat square(float x) { return x * x; }\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, out float h)\n{\n    p -= a, b -= a;\n    h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n// delete vertex\n#define KEY_SHIFT 16\n\n// hide show vertex positions\n#define KEY_SPACE 32\n\n// change selected vertex\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n// delete selected vertex\n#define KEY_DELETE 8\n\n// select all vertices\n#define KEY_A 65\n\n// toggle-select\n#define KEY_ALT 18\n\n// hide polygon\n#define KEY_P 80\n\n// counts the number of bits set to 1 in a uint\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\n// counts the number of bits set to 1 in a uvec4\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\n// computes the highest set bit index in a uint\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\nint log2int(uvec4 v)\n{\n    if (v[3] != 0u) return log2int(v[3]) + 96;\n    if (v[2] != 0u) return log2int(v[2]) + 64;\n    if (v[1] != 0u) return log2int(v[1]) + 32;\n    return log2int(v[0]);\n}\n\nbool isUvec4BitSet(uvec4 v, int b)\n{\n    return (v[b/32] & (1u << (b % 32))) != 0u;\n}\n\nuvec4 setUvec4Bit(int b)\n{\n    uvec4 v = uvec4(0);\n    v[b/32] = (1u << (b % 32));\n    return v;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Handle vertex positions\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    int id = ifc.x + ifc.y * int(iResolution.x);\n\n    if (id>=MAX_VERTICES) return;\n\n    vec2 v;\n    if (iFrame == 0)\n    {\n        // init vertices\n        if (id < NUM_INIT_VERTS) v = INIT_VERT_POS_ARRAY[id];\n    }\n    else\n    {\n        fxState state = fxGetState();\n        bool selected = isUvec4BitSet(state.selectedVerts, id);\n        vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n        \n        // support mouse drag and vertex add\n        if (state.grabAction == ACTION_ADD && selected)\n        {\n            v = state.grabOffset + m;\n        }\n        else if (state.grabAction == ACTION_DRAG && selected)\n        {\n            v = fxGetVertex(id) + m - state.lastMouse;\n        }\n        else\n        {\n            if (id > state.numVerts) return;\n            \n            // slide the vertices if we're adding or deleting\n            if (state.grabAction == ACTION_DELETE)\n            {\n                for (int i = 0; i <= id; ++i)\n                    if (isUvec4BitSet(state.selectedVerts, i)) ++id;\n            }\n            else if (state.grabAction == ACTION_ADD)\n            {\n                if (id >= log2int(state.selectedVerts)) --id;\n            }\n            \n            v = fxGetVertex(id);\n        }\n    }\n    \n    O = fxSaveVertex(v);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Management of persistent state data\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n   \tivec2 ifc = ivec2(u);\n    if (!fxIsStatePixel(ifc)) return;\n    \n    fxState state = fxGetState();\n\n    if (iFrame == 0)\n    {\n        // reset\n        state.selectedVerts = uvec4(0);\n        state.grabOffset = vec2(0);\n        state.grabAction = ACTION_NONE;\n        state.numVerts = NUM_INIT_VERTS;\n        state.renderVerts = true;\n        state.renderPoly = true;\n    }\n    else\n    {\n        if (state.grabAction == ACTION_DELETE)\n        {\n            // recover from delete action\n            state.grabAction = ACTION_NONE;\n            state.selectedVerts = uvec4(0);\n        }\n        \n        if (state.grabAction == ACTION_ADD) state.grabAction = ACTION_DRAG; // convert add into drag\n\n        if (iMouse.z > 0. && (state.grabAction == ACTION_DRAG ||\n                              state.grabAction == ACTION_NONE ||\n                              state.grabAction == ACTION_SELECT))\n        {\n            vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n            if (state.grabAction == ACTION_SELECT)\n            {\n                // handle rectangle selection\n                vec2 boxCenter = (m + state.grabOffset) * .5,\n                     boxExtents = abs(m - state.grabOffset) * .5;\n                \n                state.selectedVerts = uvec4(0);\n                for (int i = 0; i < state.numVerts; ++i)\n                {\n                    if (sdBox(fxGetVertex(i) - boxCenter, boxExtents) <= MAX_GRAB_DIST) state.selectedVerts |= setUvec4Bit(i);\n                }\n            }\n            else if (iMouse.w > 0.) // new click\n            {\n                int closestEdge = -1; // the edge we are closest to\n                vec2 closestOffset; // the offset from the mouse to the closest point on the closest edge\n\n                for (int i = 0; i < state.numVerts; ++i)\n                {\n                    vec2 v = fxGetVertex(i);\n                    if (length2(m - v) < square(MAX_GRAB_DIST))\n                    {\n                        // we've clicked a vertex\n                        if (keyDown(KEY_SHIFT) && state.numVerts > 2)\n                        {\n                            // handle shift-click (delete)\n                            state.selectedVerts = setUvec4Bit(i);\n                            state.numVerts--;\n                            state.grabAction = ACTION_DELETE;\n                        }\n                        else\n                        {\n                            // handle click-select and drag\n                            bool selected = isUvec4BitSet(state.selectedVerts, i);\n                            state.grabAction = ACTION_DRAG;\n\n                            if (keyDown(KEY_ALT))\n                            {\n                                // handle alt-click (toggle selection)\n                                if (selected)\n                                    state.selectedVerts &= ~setUvec4Bit(i);\n                                else\n                                    state.selectedVerts |= setUvec4Bit(i);\n                            }\n                            else\n                            {\n                                // re-seat selection if clicked vertex was not selected\n                                if (!selected) state.selectedVerts = setUvec4Bit(i);\n                            }\n                        }\n                    }\n\n                    // compute the distance to the closest point on this edge\n                    vec2 nv = fxGetVertex((i + 1) % state.numVerts);\n                    float h, ld2 = fxLinePointDist2(v, nv, m, h);\n                    if (ld2 <= square(MAX_GRAB_DIST))\n                    {\n                        closestEdge = i;\n                        closestOffset = v + (nv - v) * h - m;\n                    }\n                }\n\n                if (state.grabAction == ACTION_NONE &&\n                    closestEdge >= 0 &&\n                    state.numVerts < MAX_VERTICES &&\n                    !keyDown(KEY_SHIFT))\n                {\n                    // if no vertex was clicked, add but an edge was, add a vertex here\n                    state.grabOffset = closestOffset;\n                    state.selectedVerts = setUvec4Bit(closestEdge + 1);\n                    state.numVerts++;\n                    state.grabAction = ACTION_ADD;\n                }\n                \n                if (state.grabAction == ACTION_NONE)\n                {\n                    // missed all verts and edges, start a multi-selection rectangle\n                    state.grabOffset = m;\n                    state.grabAction = ACTION_SELECT;\n                }\n            }\n            \n            state.lastMouse = m;\n        }\n        else\n        {\n            // mouse released...reset action\n            state.grabAction = ACTION_NONE;\n        }\n    }\n    \n    int selVert = log2int(state.selectedVerts); // rotate selected vert\n    if (keyClick(KEY_LEFT)) state.selectedVerts = setUvec4Bit((selVert + state.numVerts - 1) % state.numVerts);\n    if (keyClick(KEY_RIGHT)) state.selectedVerts = setUvec4Bit((selVert + 1) % state.numVerts);\n    if (keyClick(KEY_DELETE))\n    {\n        int vertsToDelete = countBits(state.selectedVerts);\n        if (state.numVerts - vertsToDelete > 1)\n        {\n            state.grabAction = ACTION_DELETE; // delete selected vert\n            state.numVerts -= vertsToDelete;\n        }\n    }\n    if (keyClick(KEY_A)) state.selectedVerts = uvec4(-1u); // select all\n    if (keyClick(KEY_SPACE)) state.renderVerts = !state.renderVerts; // hide/show verts\n    if (keyClick(KEY_P)) state.renderPoly = !state.renderPoly; // hide/show verts\n\n    O = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[4056, 4108, 4142, 4142, 4783], [4785, 4834, 4863, 4863, 5060], [5341, 5341, 5367, 5367, 5571], [5573, 5573, 5591, 5591, 5790], [6173, 6237, 6279, 6279, 6476]], "test": "untested"}
{"id": "mtSSWm", "name": "Stellar Evolution Experiments", "author": "Zi7ar21", "description": "Playing with Michael0884's \"Stellar evolution Poisson filter\"", "tags": ["particles", "ca"], "likes": 6, "viewed": 245, "published": 3, "date": "1676160798", "time_retrieved": "2024-07-30T18:10:41.152328", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\n\nfloat getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nvec2 getPotentialGrad(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    vec2(texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x - texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x,\n         texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x - texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x);\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + getEstimatedDensity(p);\n}\n\nvec4 Va(vec2 p)\n{\n    return  100.0*Gscale * length(getPotentialGrad(ivec2(p))) * vec4(0,0,0,1) +2.0*pixel(ch0, p).z * vec4(1,1,1,0);\n}\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = Va(pos);\n    rho.z *= 5.;\n    //rho.w = tanh(rho.w);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(Va(pos + dx.zy).zw - Va(pos + dx.xy).zw,\n                         Va(pos + dx.yz).zw - Va(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0.5, fluid_rho*2., rho.z),0.1);\n   \n    col.xyz = 0.001 * vec3(0.2, 0.5, 1.0) * rho.w;\n    col.xyz += vec3(1.0, 0.7, 0.5) * rho.z;\n   // col.xyz = vec3(100.0)*abs(getDensityError(p));\n    col.xyz = tanh(col.xyz);\n    //col = vec4(0.01 * (texelFetch(iChannel1, ivec2(pos), 0).rgb - 0.99*texture(iChannel1, vec2(0.5, 0.5)).r), 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define UPDATE_INTERVAL 2\n\n//#define PI 3.14159265\n// ##### Constants #####\n\n/*\nhttps://float.exposed/\nhttp://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n*/\n\n/*\nIt's convenient to make constant floating-point variables with the best possible precision so you don't need to type them everywhere,\nand precomputing their inverses allows you to change division (which is slow) into multiplication e.g. x / PI = INV_PI * x\n*/\n\n//const float     PI = glm::uintBitsToFloat(0x40490FDBu); // Pi\n//const float INV_PI = glm::uintBitsToFloat(0x3EA2F983u); // 1 / Pi\n//const float     TAU = glm::uintBitsToFloat(0x40C90FDBu); // 2 * Pi = \"Tau\"\n//const float INV_TAU = glm::uintBitsToFloat(0x3E22F983u); // 1 / (2 * Pi)\n\nconst float     PI = 3.141592653589793238462643383279502884197169399375105820974944592;\nconst float INV_PI = 0.318309886183790671537767526745028724068919291480912897495334688; // 1 / Pi\n\nconst float     TAU = 6.283185307179586476925286766559005768394338798750211641949889185; // 2 * Pi = \"Tau\"\nconst float INV_TAU = 0.159154943091895335768883763372514362034459645740456448747667344; // 1 / (2 * Pi)\n\n// 2^32 (but slightly different, so 32-bit RNG doesn't ever reach 0.0 or 1.0)\n// I know I said \"C++11 lacks a real way to do this\" earlier but there's no real way to get the closest\n// but still *slightly* different float besides using hexadecimal\nconst float     RNG32_MAX = uintBitsToFloat(0x4F7FFFFFU); // Actual: 0x4F800000U\nconst float INV_RNG32_MAX = uintBitsToFloat(0x2F7FFFFFU); // Actual: 0x2F800000U\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define temporal_blurring 0.0\n\n#define mass 1.0\n\n#define fluid_rho 0.5\n\nconst float Gscale = 0.3;\n\nfloat Pf(float rho) {\n    //return 0.0;\n    //return 1.0;\n    //return 0.1;\n    return 0.1+0.1*rho;\n    //return 0.1*rho + 1.0*rho*rho;\n    //return rho > 10.0 ? 100000.0 : 0.1*rho + 1.0*rho*rho;\n    //return 0.1*rho + 1.0*rho*rho + 0.0*pow(rho, 10.0); //gas + supernova\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.2)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.6), R*vec2(1.5, 2.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.0\nvec3 bN(vec2 p) {\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X; //\n    vec2 V; //velocity\n    float M; //mass\n    float I; //angular velocity\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.z;\n    P.I = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M, P.I);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n//#define dif 0.78539816339\n#define dif 1.0\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n   \n    //pass 1 - get center of mass\n    range(i, -4, 4) range(j, -4, 4)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n    }\n    \n    //moment of inertia\n    float I = 0.;\n    //pass 2 - get velocity and angular momentum\n    range(i, -4, 4) range(j, -4, 4)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        vec2 dx = P0.X - P.X;\n      \n\t\tfloat W = P0.I; \n        //relative velocity of this part of the square\n        vec2 rel_V = P0.V + W*vec2(dx.y, -dx.x);\n        float v = length(P.V);\n    \trel_V /= (v > 2.)?v:1.;\n        \n        //add momentum\n        P.V += rel_V*m;\n        //add angular momentum\n        P.I += (dx.x*P0.V.y - dx.y*P0.V.x)*m;\n        //add moment of inertia\n        I += dot(dx, dx)*m;\n    }\n   // I = max(I, 0.1);\n    //normalization\n    if(P.M != 0.)\n    {\n        P.V /= P.M; //get velocity\n        P.I /= I;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, sampler2D chG, inout particle P, vec2 pos)\n{\n    //Compute the forces\n    vec2 F = vec2(0.);\n    float w = 0.;\n    vec3 avgV = vec3(0.);\n    //local gravity potential\n    float lU = pixel(chG, P.X).w;\n    range(i, -8, 8) range(j, -8, 8)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M*(Pf(P.M) + Pf(P0.M)); \n        //gas pressure\n        F -= 0.5*G(1.*dx)*avgP*dx;\n        \n        //neighbor gravity potential\n        float rU = pixel(chG, P0.X).w;\n        \n        //gas gravity\n        F -= Gscale * 0.025*P.M*dx*clamp(lU - rU, -15., 15.)*G(1.*dx);\n        avgV += G(1.*dx)*vec3(P0.V,1.);\n    }\n    \n    avgV /= avgV.z;\n\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/9.;\n        F += 0.003*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 2.*P.M*N.xy*exp(-abs(N.z));\n    if(N.z < 5.) \n    {\n        //P.X = pos;\n        P.V *= 0.;\n       // P.M = 2.*fluid_rho;\n    }\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.0) ? v : 1.0;\n    //angular momentum limit\n    P.I = P.M*clamp(P.I/P.M, -0.5, 0.5);\n    //P.I = P.M * clamp(P.I / P.M, -1.0, 1.0);\n}\n\n\n//The first 4 columns of the U matrix: \nfloat U[516] = float[](-4.9245E-04, -1.2542E-03, -2.2055E-03, -3.2879E-03, -4.4913E-03, -5.8014E-03, -7.1809E-03, -8.6281E-03, -1.0138E-02, -1.1689E-02, -1.3303E-02, -1.4958E-02, -1.6672E-02, -1.8424E-02, -2.0218E-02, -2.2054E-02, -2.3945E-02, -2.5875E-02, -2.7843E-02, -2.9853E-02, -3.1902E-02, -3.3991E-02, -3.6115E-02, -3.8287E-02, -4.0503E-02, -4.2764E-02, -4.5069E-02, -4.7415E-02, -4.9812E-02, -5.2256E-02, -5.4747E-02, -5.7291E-02, -5.9888E-02, -6.2535E-02, -6.5240E-02, -6.8001E-02, -7.0822E-02, -7.3704E-02, -7.6651E-02, -7.9663E-02, -8.2744E-02, -8.5899E-02, -8.9129E-02, -9.2437E-02, -9.5830E-02, -9.9308E-02, -1.0288E-01, -1.0654E-01, -1.1031E-01, -1.1418E-01, -1.1816E-01, -1.2226E-01, -1.2649E-01, -1.3085E-01, -1.3535E-01, -1.4000E-01, -1.4483E-01, -1.4982E-01, -1.5502E-01, -1.6043E-01, -1.6607E-01, -1.7198E-01, -1.7820E-01, -1.8480E-01, -1.9188E-01, -1.8480E-01, -1.7820E-01, -1.7198E-01, -1.6607E-01, -1.6043E-01, -1.5502E-01, -1.4982E-01, -1.4483E-01, -1.4000E-01, -1.3535E-01, -1.3085E-01, -1.2649E-01, -1.2226E-01, -1.1816E-01, -1.1418E-01, -1.1031E-01, -1.0654E-01, -1.0288E-01, -9.9308E-02, -9.5830E-02, -9.2437E-02, -8.9129E-02, -8.5899E-02, -8.2744E-02, -7.9663E-02, -7.6651E-02, -7.3704E-02, -7.0822E-02, -6.8001E-02, -6.5240E-02, -6.2535E-02, -5.9888E-02, -5.7291E-02, -5.4747E-02, -5.2256E-02, -4.9812E-02, -4.7415E-02, -4.5069E-02, -4.2764E-02, -4.0503E-02, -3.8287E-02, -3.6115E-02, -3.3991E-02, -3.1902E-02, -2.9853E-02, -2.7843E-02, -2.5875E-02, -2.3945E-02, -2.2054E-02, -2.0218E-02, -1.8424E-02, -1.6672E-02, -1.4958E-02, -1.3303E-02, -1.1689E-02, -1.0138E-02, -8.6281E-03, -7.1809E-03, -5.8014E-03, -4.4913E-03, -3.2879E-03, -2.2055E-03, -1.2542E-03, -4.9245E-04, 3.9763E-03, 7.3026E-03, 9.5644E-03, 1.0917E-02, 1.1331E-02, 1.0875E-02, 9.9083E-03, 8.4459E-03, 6.5456E-03, 4.4496E-03, 1.9250E-03, -7.7003E-04, -3.8168E-03, -6.9826E-03, -1.0283E-02, -1.3724E-02, -1.7401E-02, -2.1135E-02, -2.4924E-02, -2.8759E-02, -3.2622E-02, -3.6495E-02, -4.0335E-02, -4.4201E-02, -4.8062E-02, -5.1898E-02, -5.5689E-02, -5.9418E-02, -6.3084E-02, -6.6668E-02, -7.0161E-02, -7.3537E-02, -7.6782E-02, -7.9895E-02, -8.2831E-02, -8.5595E-02, -8.8133E-02, -9.0449E-02, -9.2482E-02, -9.4232E-02, -9.5648E-02, -9.6656E-02, -9.7247E-02, -9.7353E-02, -9.6875E-02, -9.5782E-02, -9.3976E-02, -9.1327E-02, -8.7758E-02, -8.3124E-02, -7.7257E-02, -6.9949E-02, -6.1007E-02, -5.0154E-02, -3.7058E-02, -2.1316E-02, -2.4165E-03, 2.0250E-02, 4.7498E-02, 8.0410E-02, 1.2047E-01, 1.6982E-01, 2.3182E-01, 3.1239E-01, 4.2417E-01, 3.1239E-01, 2.3182E-01, 1.6982E-01, 1.2047E-01, 8.0410E-02, 4.7498E-02, 2.0250E-02, -2.4165E-03, -2.1316E-02, -3.7058E-02, -5.0154E-02, -6.1007E-02, -6.9949E-02, -7.7257E-02, -8.3124E-02, -8.7758E-02, -9.1327E-02, -9.3976E-02, -9.5782E-02, -9.6875E-02, -9.7353E-02, -9.7247E-02, -9.6656E-02, -9.5648E-02, -9.4232E-02, -9.2482E-02, -9.0449E-02, -8.8133E-02, -8.5595E-02, -8.2831E-02, -7.9895E-02, -7.6782E-02, -7.3537E-02, -7.0161E-02, -6.6668E-02, -6.3084E-02, -5.9418E-02, -5.5689E-02, -5.1898E-02, -4.8062E-02, -4.4201E-02, -4.0335E-02, -3.6495E-02, -3.2622E-02, -2.8759E-02, -2.4924E-02, -2.1135E-02, -1.7401E-02, -1.3724E-02, -1.0283E-02, -6.9826E-03, -3.8168E-03, -7.7003E-04, 1.9250E-03, 4.4496E-03, 6.5456E-03, 8.4459E-03, 9.9083E-03, 1.0875E-02, 1.1331E-02, 1.0917E-02, 9.5644E-03, 7.3026E-03, 3.9763E-03, 3.9355E-03, 1.3650E-02, 2.3904E-02, 3.2938E-02, 3.9832E-02, 4.4184E-02, 4.6843E-02, 4.7742E-02, 4.7008E-02, 4.5548E-02, 4.2430E-02, 3.8683E-02, 3.3605E-02, 2.8133E-02, 2.2223E-02, 1.5883E-02, 8.8690E-03, 1.7994E-03, -5.2834E-03, -1.2309E-02, -1.9204E-02, -2.5905E-02, -3.2485E-02, -3.8726E-02, -4.4600E-02, -5.0063E-02, -5.5110E-02, -6.0029E-02, -6.4241E-02, -6.7899E-02, -7.1391E-02, -7.4020E-02, -7.6015E-02, -7.7796E-02, -7.8704E-02, -7.9309E-02, -7.8953E-02, -7.8208E-02, -7.6467E-02, -7.4255E-02, -7.1337E-02, -6.7179E-02, -6.2323E-02, -5.6538E-02, -4.9348E-02, -4.1208E-02, -3.1913E-02, -2.1097E-02, -9.0917E-03, 4.2374E-03, 1.8978E-02, 3.5285E-02, 5.2822E-02, 7.1460E-02, 9.0918E-02, 1.1069E-01, 1.2995E-01, 1.4714E-01, 1.5994E-01, 1.6446E-01, 1.5407E-01, 1.1667E-01, 2.8240E-02, -1.6583E-01, -6.1374E-01, -1.6583E-01, 2.8240E-02, 1.1667E-01, 1.5407E-01, 1.6446E-01, 1.5994E-01, 1.4714E-01, 1.2995E-01, 1.1069E-01, 9.0918E-02, 7.1460E-02, 5.2822E-02, 3.5285E-02, 1.8978E-02, 4.2374E-03, -9.0917E-03, -2.1097E-02, -3.1913E-02, -4.1208E-02, -4.9348E-02, -5.6538E-02, -6.2323E-02, -6.7179E-02, -7.1337E-02, -7.4255E-02, -7.6467E-02, -7.8208E-02, -7.8953E-02, -7.9309E-02, -7.8704E-02, -7.7796E-02, -7.6015E-02, -7.4020E-02, -7.1391E-02, -6.7899E-02, -6.4241E-02, -6.0029E-02, -5.5110E-02, -5.0063E-02, -4.4600E-02, -3.8726E-02, -3.2485E-02, -2.5905E-02, -1.9204E-02, -1.2309E-02, -5.2834E-03, 1.7994E-03, 8.8690E-03, 1.5883E-02, 2.2223E-02, 2.8133E-02, 3.3605E-02, 3.8683E-02, 4.2430E-02, 4.5548E-02, 4.7008E-02, 4.7742E-02, 4.6843E-02, 4.4184E-02, 3.9832E-02, 3.2938E-02, 2.3904E-02, 1.3650E-02, 3.9355E-03, -2.8697E-04, 2.2993E-03, 8.9515E-03, 1.8986E-02, 3.2109E-02, 4.7412E-02, 6.3502E-02, 7.9787E-02, 9.5611E-02, 1.1102E-01, 1.2477E-01, 1.3760E-01, 1.4772E-01, 1.5667E-01, 1.6404E-01, 1.6948E-01, 1.7070E-01, 1.7058E-01, 1.6884E-01, 1.6543E-01, 1.6046E-01, 1.5429E-01, 1.4888E-01, 1.4070E-01, 1.3073E-01, 1.1945E-01, 1.0744E-01, 9.6486E-02, 8.3808E-02, 7.0604E-02, 5.8515E-02, 4.5302E-02, 3.2083E-02, 2.0118E-02, 7.9839E-03, -2.9234E-03, -1.3739E-02, -2.3292E-02, -3.2394E-02, -4.0164E-02, -4.6821E-02, -5.2890E-02, -5.7655E-02, -6.1257E-02, -6.4026E-02, -6.5502E-02, -6.5774E-02, -6.5026E-02, -6.3045E-02, -5.9908E-02, -5.5715E-02, -5.0610E-02, -4.4614E-02, -3.7877E-02, -3.0599E-02, -2.3030E-02, -1.5459E-02, -8.2046E-03, -1.6536E-03, 3.7415E-03, 7.4873E-03, 9.1017E-03, 8.2388E-03, 5.0100E-03, 9.1062E-04, 5.0100E-03, 8.2388E-03, 9.1017E-03, 7.4873E-03, 3.7415E-03, -1.6536E-03, -8.2046E-03, -1.5459E-02, -2.3030E-02, -3.0599E-02, -3.7877E-02, -4.4614E-02, -5.0610E-02, -5.5715E-02, -5.9908E-02, -6.3045E-02, -6.5026E-02, -6.5774E-02, -6.5502E-02, -6.4026E-02, -6.1257E-02, -5.7655E-02, -5.2890E-02, -4.6821E-02, -4.0164E-02, -3.2394E-02, -2.3292E-02, -1.3739E-02, -2.9234E-03, 7.9839E-03, 2.0118E-02, 3.2083E-02, 4.5302E-02, 5.8515E-02, 7.0604E-02, 8.3808E-02, 9.6486E-02, 1.0744E-01, 1.1945E-01, 1.3073E-01, 1.4070E-01, 1.4888E-01, 1.5429E-01, 1.6046E-01, 1.6543E-01, 1.6884E-01, 1.7058E-01, 1.7070E-01, 1.6948E-01, 1.6404E-01, 1.5667E-01, 1.4772E-01, 1.3760E-01, 1.2477E-01, 1.1102E-01, 9.5611E-02, 7.9787E-02, 6.3502E-02, 4.7412E-02, 3.2109E-02, 1.8986E-02, 8.9515E-03, 2.2993E-03, -2.8697E-04); \n//The first 4 rows of the V matrix: \nfloat V[516] = float[](-6.3313E-03, -1.6125E-02, -2.8355E-02, -4.2272E-02, -5.7744E-02, -7.4587E-02, -9.2324E-02, -1.1093E-01, -1.3034E-01, -1.5028E-01, -1.7104E-01, -1.9232E-01, -2.1435E-01, -2.3688E-01, -2.5994E-01, -2.8355E-01, -3.0786E-01, -3.3266E-01, -3.5798E-01, -3.8381E-01, -4.1016E-01, -4.3702E-01, -4.6433E-01, -4.9224E-01, -5.2073E-01, -5.4980E-01, -5.7944E-01, -6.0961E-01, -6.4042E-01, -6.7185E-01, -7.0387E-01, -7.3658E-01, -7.6996E-01, -8.0400E-01, -8.3878E-01, -8.7427E-01, -9.1054E-01, -9.4759E-01, -9.8548E-01, -1.0242E+00, -1.0638E+00, -1.1044E+00, -1.1459E+00, -1.1884E+00, -1.2321E+00, -1.2768E+00, -1.3227E+00, -1.3698E+00, -1.4182E+00, -1.4679E+00, -1.5191E+00, -1.5719E+00, -1.6262E+00, -1.6823E+00, -1.7402E+00, -1.8000E+00, -1.8620E+00, -1.9263E+00, -1.9930E+00, -2.0625E+00, -2.1351E+00, -2.2111E+00, -2.2911E+00, -2.3759E+00, -2.4670E+00, -2.3759E+00, -2.2911E+00, -2.2111E+00, -2.1351E+00, -2.0625E+00, -1.9930E+00, -1.9263E+00, -1.8620E+00, -1.8000E+00, -1.7402E+00, -1.6823E+00, -1.6262E+00, -1.5719E+00, -1.5191E+00, -1.4679E+00, -1.4182E+00, -1.3698E+00, -1.3227E+00, -1.2768E+00, -1.2321E+00, -1.1884E+00, -1.1459E+00, -1.1044E+00, -1.0638E+00, -1.0242E+00, -9.8548E-01, -9.4759E-01, -9.1054E-01, -8.7427E-01, -8.3878E-01, -8.0400E-01, -7.6996E-01, -7.3658E-01, -7.0387E-01, -6.7185E-01, -6.4042E-01, -6.0961E-01, -5.7944E-01, -5.4980E-01, -5.2073E-01, -4.9224E-01, -4.6433E-01, -4.3702E-01, -4.1016E-01, -3.8381E-01, -3.5798E-01, -3.3266E-01, -3.0786E-01, -2.8355E-01, -2.5994E-01, -2.3688E-01, -2.1435E-01, -1.9232E-01, -1.7104E-01, -1.5028E-01, -1.3034E-01, -1.1093E-01, -9.2324E-02, -7.4587E-02, -5.7744E-02, -4.2272E-02, -2.8355E-02, -1.6125E-02, -6.3313E-03, 5.8353E-03, 1.0717E-02, 1.4036E-02, 1.6021E-02, 1.6629E-02, 1.5960E-02, 1.4541E-02, 1.2395E-02, 9.6060E-03, 6.5301E-03, 2.8250E-03, -1.1301E-03, -5.6013E-03, -1.0247E-02, -1.5091E-02, -2.0141E-02, -2.5537E-02, -3.1016E-02, -3.6578E-02, -4.2205E-02, -4.7875E-02, -5.3559E-02, -5.9194E-02, -6.4867E-02, -7.0533E-02, -7.6162E-02, -8.1726E-02, -8.7199E-02, -9.2579E-02, -9.7838E-02, -1.0296E-01, -1.0792E-01, -1.1268E-01, -1.1725E-01, -1.2156E-01, -1.2561E-01, -1.2934E-01, -1.3274E-01, -1.3572E-01, -1.3829E-01, -1.4037E-01, -1.4185E-01, -1.4271E-01, -1.4287E-01, -1.4217E-01, -1.4056E-01, -1.3791E-01, -1.3403E-01, -1.2879E-01, -1.2199E-01, -1.1338E-01, -1.0265E-01, -8.9530E-02, -7.3603E-02, -5.4384E-02, -3.1282E-02, -3.5463E-03, 2.9717E-02, 6.9706E-02, 1.1801E-01, 1.7679E-01, 2.4922E-01, 3.4020E-01, 4.5845E-01, 6.2249E-01, 4.5845E-01, 3.4020E-01, 2.4922E-01, 1.7679E-01, 1.1801E-01, 6.9706E-02, 2.9717E-02, -3.5463E-03, -3.1282E-02, -5.4384E-02, -7.3603E-02, -8.9530E-02, -1.0265E-01, -1.1338E-01, -1.2199E-01, -1.2879E-01, -1.3403E-01, -1.3791E-01, -1.4056E-01, -1.4217E-01, -1.4287E-01, -1.4271E-01, -1.4185E-01, -1.4037E-01, -1.3829E-01, -1.3572E-01, -1.3274E-01, -1.2934E-01, -1.2561E-01, -1.2156E-01, -1.1725E-01, -1.1268E-01, -1.0792E-01, -1.0296E-01, -9.7838E-02, -9.2579E-02, -8.7199E-02, -8.1726E-02, -7.6162E-02, -7.0533E-02, -6.4867E-02, -5.9194E-02, -5.3559E-02, -4.7875E-02, -4.2205E-02, -3.6578E-02, -3.1016E-02, -2.5537E-02, -2.0141E-02, -1.5091E-02, -1.0247E-02, -5.6013E-03, -1.1301E-03, 2.8250E-03, 6.5301E-03, 9.6060E-03, 1.2395E-02, 1.4541E-02, 1.5960E-02, 1.6629E-02, 1.6021E-02, 1.4036E-02, 1.0717E-02, 5.8353E-03, 1.4748E-03, 5.1153E-03, 8.9583E-03, 1.2344E-02, 1.4927E-02, 1.6558E-02, 1.7555E-02, 1.7891E-02, 1.7616E-02, 1.7069E-02, 1.5901E-02, 1.4497E-02, 1.2593E-02, 1.0543E-02, 8.3282E-03, 5.9520E-03, 3.3237E-03, 6.7431E-04, -1.9800E-03, -4.6130E-03, -7.1968E-03, -9.7081E-03, -1.2174E-02, -1.4513E-02, -1.6714E-02, -1.8761E-02, -2.0653E-02, -2.2496E-02, -2.4075E-02, -2.5445E-02, -2.6754E-02, -2.7739E-02, -2.8487E-02, -2.9154E-02, -2.9495E-02, -2.9721E-02, -2.9588E-02, -2.9308E-02, -2.8656E-02, -2.7827E-02, -2.6734E-02, -2.5176E-02, -2.3356E-02, -2.1188E-02, -1.8493E-02, -1.5443E-02, -1.1959E-02, -7.9062E-03, -3.4071E-03, 1.5880E-03, 7.1121E-03, 1.3223E-02, 1.9795E-02, 2.6780E-02, 3.4072E-02, 4.1481E-02, 4.8698E-02, 5.5143E-02, 5.9938E-02, 6.1633E-02, 5.7737E-02, 4.3722E-02, 1.0583E-02, -6.2144E-02, -2.3000E-01, -6.2144E-02, 1.0583E-02, 4.3722E-02, 5.7737E-02, 6.1633E-02, 5.9938E-02, 5.5143E-02, 4.8698E-02, 4.1481E-02, 3.4072E-02, 2.6780E-02, 1.9795E-02, 1.3223E-02, 7.1121E-03, 1.5880E-03, -3.4071E-03, -7.9062E-03, -1.1959E-02, -1.5443E-02, -1.8493E-02, -2.1188E-02, -2.3356E-02, -2.5176E-02, -2.6734E-02, -2.7827E-02, -2.8656E-02, -2.9308E-02, -2.9588E-02, -2.9721E-02, -2.9495E-02, -2.9154E-02, -2.8487E-02, -2.7739E-02, -2.6754E-02, -2.5445E-02, -2.4075E-02, -2.2496E-02, -2.0653E-02, -1.8761E-02, -1.6714E-02, -1.4513E-02, -1.2174E-02, -9.7081E-03, -7.1968E-03, -4.6130E-03, -1.9800E-03, 6.7431E-04, 3.3237E-03, 5.9520E-03, 8.3282E-03, 1.0543E-02, 1.2593E-02, 1.4497E-02, 1.5901E-02, 1.7069E-02, 1.7616E-02, 1.7891E-02, 1.7555E-02, 1.6558E-02, 1.4927E-02, 1.2344E-02, 8.9583E-03, 5.1153E-03, 1.4748E-03, 8.3758E-05, -6.7109E-04, -2.6127E-03, -5.5415E-03, -9.3716E-03, -1.3838E-02, -1.8534E-02, -2.3288E-02, -2.7906E-02, -3.2404E-02, -3.6416E-02, -4.0163E-02, -4.3115E-02, -4.5726E-02, -4.7877E-02, -4.9467E-02, -4.9824E-02, -4.9789E-02, -4.9280E-02, -4.8284E-02, -4.6833E-02, -4.5032E-02, -4.3454E-02, -4.1067E-02, -3.8156E-02, -3.4863E-02, -3.1359E-02, -2.8161E-02, -2.4461E-02, -2.0607E-02, -1.7079E-02, -1.3222E-02, -9.3641E-03, -5.8718E-03, -2.3303E-03, 8.5326E-04, 4.0101E-03, 6.7982E-03, 9.4547E-03, 1.1723E-02, 1.3666E-02, 1.5437E-02, 1.6828E-02, 1.7879E-02, 1.8687E-02, 1.9118E-02, 1.9198E-02, 1.8979E-02, 1.8401E-02, 1.7485E-02, 1.6261E-02, 1.4772E-02, 1.3022E-02, 1.1055E-02, 8.9311E-03, 6.7218E-03, 4.5121E-03, 2.3947E-03, 4.8263E-04, -1.0920E-03, -2.1853E-03, -2.6565E-03, -2.4047E-03, -1.4623E-03, -2.6578E-04, -1.4623E-03, -2.4047E-03, -2.6565E-03, -2.1853E-03, -1.0920E-03, 4.8263E-04, 2.3947E-03, 4.5121E-03, 6.7218E-03, 8.9311E-03, 1.1055E-02, 1.3022E-02, 1.4772E-02, 1.6261E-02, 1.7485E-02, 1.8401E-02, 1.8979E-02, 1.9198E-02, 1.9118E-02, 1.8687E-02, 1.7879E-02, 1.6828E-02, 1.5437E-02, 1.3666E-02, 1.1723E-02, 9.4547E-03, 6.7982E-03, 4.0101E-03, 8.5326E-04, -2.3303E-03, -5.8718E-03, -9.3641E-03, -1.3222E-02, -1.7079E-02, -2.0607E-02, -2.4461E-02, -2.8161E-02, -3.1359E-02, -3.4863E-02, -3.8156E-02, -4.1067E-02, -4.3454E-02, -4.5032E-02, -4.6833E-02, -4.8284E-02, -4.9280E-02, -4.9789E-02, -4.9824E-02, -4.9467E-02, -4.7877E-02, -4.5726E-02, -4.3115E-02, -4.0163E-02, -3.6416E-02, -3.2404E-02, -2.7906E-02, -2.3288E-02, -1.8534E-02, -1.3838E-02, -9.3716E-03, -5.5415E-03, -2.6127E-03, -6.7109E-04, 8.3758E-05); \n//center of the convolution \nint Nc = 64; \n//number of ranks \nint Nr = 4; \n//convolution size \nint N = 129; \n\n\n\nfloat pack2(vec2 a)\n{\n    return uintBitsToFloat(packHalf2x16(a));\n}\n\nvec2 unpack2(float packed)\n{\n    return unpackHalf2x16(floatBitsToUint(packed));\n}\n\nivec2 wrap(ivec2 p, ivec2 res)\n{\n    return (p + res)%res;\n}\n\n// ##### Random Number Generator #####\n\n#ifdef USE_PCG_RANDOM\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\nstruct rng_state_t {\n    uvec4 seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    uvec2 coord = uvec2(pixel_coord);\n\n    rng_state.seed = uvec4(coord, uint(frame_number), coord.x + coord.y);\n\n    //rng_state.seed = uvec4(frame, frame * 15843, frame * 31 + 4566, frame * 2345 + 58585);\n}\n\n// http://www.pcg-random.org/\nuvec4 pcg4d(uvec4 v) {\n\tv = v * 0x0019660Du + 0x3C6EF35Fu;\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n    v = v ^ (v >> 16u);\n    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;\n\n    return v;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed.x);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec2(rng_state.seed.xy);\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec3(rng_state.seed.xyz);\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    rng_state.seed = pcg4d(rng_state.seed);\n\n    return INV_RNG32_MAX * vec4(rng_state.seed);\n}\n#else\nstruct rng_state_t {\n    uint seed;\n};\n\nvoid init_rng(inout rng_state_t rng_state, vec2 pixel_coord, vec2 res, int frame_number) {\n    pixel_coord = floor(pixel_coord);\n\n    rng_state.seed = uint(frame_number) * uint(res.x * res.y) + uint(pixel_coord.x + res.x * pixel_coord.y) + 1u;\n}\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\n// this hash in particular is remarkable because it's a statistically perfect 32-bit integer hash (of this kind)\nuint triple32(uint x) {\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\nfloat rand(inout rng_state_t rng_state) {\n    rng_state.seed = triple32(rng_state.seed);\n\n    return INV_RNG32_MAX * float(rng_state.seed);\n}\n\nvec2 rand2(inout rng_state_t rng_state) {\n    vec2 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    return v;\n}\n\nvec3 rand3(inout rng_state_t rng_state) {\n    vec3 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    return v;\n}\n\nvec4 rand4(inout rng_state_t rng_state) {\n    vec4 v;\n    v.x = rand(rng_state);\n    v.y = rand(rng_state);\n    v.z = rand(rng_state);\n    v.w = rand(rng_state);\n    return v;\n}\n#endif\n\nvec2 udir2(inout rng_state_t rng_state) {\n    float z = rand(rng_state);\n    float t = TAU * z;\n    float c = cos(t), s = sin(t);\n    return vec2(c, s);\n}\n\nvec3 udir3(inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    vec2 t = vec2(TAU * z.x, acos(2.0 * z.y - 1.0));\n    vec2 c = cos(t), s = sin(t);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// Box-Muller Transform\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 nrand2(float sigma, vec2 mean, inout rng_state_t rng_state) {\n    vec2 z = rand2(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.x   )) * vec2(cos(TAU * z.y), sin(TAU * z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxy )) * vec3(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean, inout rng_state_t rng_state) {\n    vec4 z = rand4(rng_state);\n    return mean + sigma * sqrt(-2.0 * log(z.xxyy)) * vec4(cos(TAU * z.z), sin(TAU * z.z), cos(TAU * z.w), sin(TAU * z.w));\n}\n\nvec2 pixel_filter(vec2 coord, float width, rng_state_t rng_state) {\n    return coord + width * (rand2(rng_state) - 0.5); // box filter, uniform over entire pixel\n    //return nrand2(width, coord, rng_state); // normal filter, normal distribution\n}\n\n/*\n*/\n//\n// psrdnoise2.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned and slightly stretched in\n// the y direction to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer period\n// in x and any even integer period in y. Odd periods may be specified\n// for y, but then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along z in 3-D\n// noise. The rotating gradients in conjunction with the analytic\n// derivatives allow for \"flow noise\" effects as presented by Ken\n// Perlin and Fabrice Neyret.\n//\n\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// \"vec2 x\" is the point (x,y) to evaluate,\n// \"vec2 period\" is the desired periods along x and y, and\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\n// The \"float\" return value is the noise value, and\n// the \"out vec2 gradient\" argument returns the x,y partial derivatives.\n//\n// Setting either period to 0.0 or a negative value will skip the wrapping\n// along that dimension. Setting both periods to 0.0 makes the function\n// execute about 15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function\n// by 10-15%.\n//\n// The rotation by alpha uses one single addition. Unlike the 3-D version\n// of psrdnoise(), setting alpha == 0.0 gives no speedup.\n//\nfloat psrdnoise(vec2 x, vec2 period, float alpha) {\n\n\t// Transform to simplex space (axis-aligned hexagonal grid)\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t// Determine which simplex we're in, with i0 being the \"base\"\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t// o1 is the offset in simplex space to the second corner\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t// Enumerate the remaining simplex corners\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t// Transform corners back to texture space\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t// Compute vectors from v to each of the simplex corners\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t// Wrap to periods, if desired\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t// Transform back to simplex space and fix rounding errors\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { // Shortcut if neither x nor y periods are specified\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t// Compute one pseudo-random hash value for each corner\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t// Pick a pseudo-random angle and add the desired rotation\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t// Reorganize for dot products below\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t// Radial decay with distance from each simplex corner\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t// The value of the linear ramp from each of the corners\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t// Multiply by the radial decay and sum up the noise value\n\tfloat n = dot(w4, gdotx);\n\n\t// Compute the first order partial derivatives\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\t//gradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t// Scale the return value to fit nicely into the range [-1,1]\n\treturn 10.9 * n;\n}\n/*\n*/", "buffer_a_code": "float fbm(vec2 x) {\n    return\n    0.5333333333333333 * ((0.5 * psrdnoise(1.0 * x, vec2(0), 0.0)) + 0.5) +\n    0.2666666666666667 * ((0.5 * psrdnoise(2.0 * x, vec2(0), 0.0)) + 0.5) +\n    0.1333333333333333 * ((0.5 * psrdnoise(4.0 * x, vec2(0), 0.0)) + 0.5) +\n    0.0666666666666667 * ((0.5 * psrdnoise(8.0 * x, vec2(0), 0.0)) + 0.5);\n}\n\nvoid mainImage(out vec4 U, in vec2 pos) {\n    if(iFrame % UPDATE_INTERVAL != 0 && iFrame > 0) {\n        U = texelFetch(iChannel1, ivec2(pos), 0);\n\n        return;\n    }\n\n    rng_state_t rng_state;\n\n    init_rng(rng_state, pos, iResolution.xy, iFrame);\n\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n\n    Reintegration(ch0, P, pos);\n\n    //initial condition\n    if(iFrame < 1)\n    {\n        /*\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 1.) \n        {\n            vec2 dC = pos - R*0.5;\n            P.X = pos;\n            P.V = 0.*(rand.xy-0.5) + 0.5*vec2(dC.y/R.x, -dC.x/R.x);\n            P.M = 0.005*mass;\n            P.I = 0.;\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = 1e-6;\n            P.I = 0.;\n        }\n        */\n        vec2 uv = (pos - 0.5 * iResolution.xy) / 256.0;\n        P.X = pos;\n        P.V = nrand2(0.1, vec2(0), rng_state);\n        //P.M = 0.05 * mass;\n        //P.M = 0.05 * mass * ((0.5 * psrdnoise(0.1 * (pos - 0.5 * iResolution.xy), vec2(0), 0.0)) + 0.5);\n        //P.M = 0.1 * mass * fbm(0.02 * (pos - 0.5 * iResolution.xy));\n        P.M = 0.08*mass*exp(-dot(4.0*uv,4.0*uv));\n        P.V = 4.0 * vec2(uv.y, -uv.x) + nrand2(0.2, vec2(0), rng_state);\n        P.I = 0.0;\n    }\n\n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 U, in vec2 pos) {\n    if(iFrame % 2 != 0 && iFrame > 0) {\n        U = texelFetch(iChannel2, ivec2(pos), 0);\n\n        return;\n    }\n\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos); \n    \n   \n    if(P.M != 0.) //not vacuum\n    {\n        Simulation(ch0, ch1, P, pos);\n    }\n    \n   \n\t/*\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }*/\n    \n    //if(length(pos - R*vec2(0.5, 0.1)) < 10.) \n    //{\n    //   P.I = 0.2;\n    //}\n\n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + 0.995*getEstimatedDensity(p);\n}\n\n\n//single component convolution pass x\n//first pass of separable poisson filter convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    vec4 sum = vec4(0.0);\n    \n    for (int i = -Nc; i <= Nc; i++) \n    {\n        ivec2 pos = wrap(coord + ivec2(i, 0), resol);\n       \n        float density = getDensityError(pos);\n\n        int id = (i + Nc);\n        //loop over ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum[j] += density * U[id + j * N];\n        }\n    }\n\n    fragColor = sum;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    float sum = 0.0;\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = wrap(coord + ivec2(0, i), resol);\n        \n        //wrap around\n        pos.x = (pos.x + resol.x) % resol.x;\n        pos.y = (pos.y + resol.y) % resol.y;\n        \n        vec4 data = texelFetch(iChannel0, pos, 0);\n    \n        int id = (i + Nc);\n        //loop over pairs of ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum += data[j] * V[id + j * N];\n        }\n    }\n\n    //get previous poisson solution\n    float prev = 0.995*texelFetch(iChannel1, coord, 0).x;\n\n    //add the previous poisson solution to the convolution\n    sum += prev;\n\n    //return the final poisson solution\n    fragColor = vec4(sum);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [296, 296, 323, 323, 367], [369, 369, 405, 405, 831], [833, 833, 865, 865, 1250], [1252, 1252, 1284, 1388, 1441], [1443, 1443, 1460, 1460, 1578], [1581, 1581, 1626, 1626, 2736]], "test": "untested"}
{"id": "mtBSDw", "name": "SF poisson filter LARGE", "author": "michael0884", "description": "Using poisson filters to get a really high quality pressure estimate(by shadertoy standards) \n+tricubic interpolation advection + rk4\nUsing a large filter here so that I can overproject, since otherwise with reuse its unstable", "tags": ["particles", "ca"], "likes": 13, "viewed": 378, "published": 3, "date": "1676149224", "time_retrieved": "2024-07-30T18:10:42.358105", "image_code": "///\n///\n/// DOES NOT WORK ON OPENGL AND INTEL GPUS!1!!!!!\n///\n///\n\n\n\nfloat getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + getEstimatedDensity(p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n\n    col.xyz = vec3(10.0)*abs(getDensityError(p));\n    //col.xyz = vec3(0.5)*abs(getDensity(p));\n    //col.xyz = -vec3(1.0)*getEstimatedDensity(p);\n    col.xyz = 0.3*vec3(1,2,3)*texelFetch(iChannel0, p, 0).w;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define HELMHOLTZ_DECOMP_FACTOR 0.75\n#define PRESSURE_REUSE_FACTOR 0.0\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n//The first 8 columns of the U matrix: \nfloat U[2056] = float[](-1.2299E-04, -3.2649E-04, -5.8313E-04, -8.7281E-04, -1.1939E-03, -1.5440E-03, -1.9149E-03, -2.3056E-03, -2.7102E-03, -3.1341E-03, -3.5711E-03, -4.0257E-03, -4.4920E-03, -4.9702E-03, -5.4600E-03, -5.9607E-03, -6.4689E-03, -6.9890E-03, -7.5202E-03, -8.0615E-03, -8.6099E-03, -9.1688E-03, -9.7348E-03, -1.0311E-02, -1.0894E-02, -1.1484E-02, -1.2085E-02, -1.2692E-02, -1.3307E-02, -1.3930E-02, -1.4562E-02, -1.5201E-02, -1.5848E-02, -1.6502E-02, -1.7163E-02, -1.7833E-02, -1.8510E-02, -1.9194E-02, -1.9887E-02, -2.0587E-02, -2.1295E-02, -2.2012E-02, -2.2736E-02, -2.3468E-02, -2.4209E-02, -2.4957E-02, -2.5713E-02, -2.6477E-02, -2.7250E-02, -2.8032E-02, -2.8822E-02, -2.9620E-02, -3.0428E-02, -3.1244E-02, -3.2070E-02, -3.2904E-02, -3.3748E-02, -3.4601E-02, -3.5463E-02, -3.6336E-02, -3.7218E-02, -3.8110E-02, -3.9013E-02, -3.9925E-02, -4.0848E-02, -4.1782E-02, -4.2727E-02, -4.3683E-02, -4.4650E-02, -4.5629E-02, -4.6620E-02, -4.7622E-02, -4.8637E-02, -4.9664E-02, -5.0703E-02, -5.1756E-02, -5.2821E-02, -5.3900E-02, -5.4993E-02, -5.6100E-02, -5.7221E-02, -5.8356E-02, -5.9506E-02, -6.0672E-02, -6.1853E-02, -6.3051E-02, -6.4264E-02, -6.5494E-02, -6.6741E-02, -6.8006E-02, -6.9288E-02, -7.0589E-02, -7.1908E-02, -7.3246E-02, -7.4605E-02, -7.5983E-02, -7.7382E-02, -7.8803E-02, -8.0245E-02, -8.1710E-02, -8.3198E-02, -8.4710E-02, -8.6246E-02, -8.7808E-02, -8.9396E-02, -9.1010E-02, -9.2652E-02, -9.4323E-02, -9.6024E-02, -9.7756E-02, -9.9519E-02, -1.0132E-01, -1.0315E-01, -1.0501E-01, -1.0692E-01, -1.0886E-01, -1.1084E-01, -1.1287E-01, -1.1494E-01, -1.1706E-01, -1.1923E-01, -1.2146E-01, -1.2374E-01, -1.2608E-01, -1.2850E-01, -1.3098E-01, -1.3355E-01, -1.3622E-01, -1.3901E-01, -1.3622E-01, -1.3355E-01, -1.3098E-01, -1.2850E-01, -1.2608E-01, -1.2374E-01, -1.2146E-01, -1.1923E-01, -1.1706E-01, -1.1494E-01, -1.1287E-01, -1.1084E-01, -1.0886E-01, -1.0692E-01, -1.0501E-01, -1.0315E-01, -1.0132E-01, -9.9519E-02, -9.7756E-02, -9.6024E-02, -9.4323E-02, -9.2652E-02, -9.1010E-02, -8.9396E-02, -8.7808E-02, -8.6246E-02, -8.4710E-02, -8.3198E-02, -8.1710E-02, -8.0245E-02, -7.8803E-02, -7.7382E-02, -7.5983E-02, -7.4605E-02, -7.3246E-02, -7.1908E-02, -7.0589E-02, -6.9288E-02, -6.8006E-02, -6.6741E-02, -6.5494E-02, -6.4264E-02, -6.3051E-02, -6.1853E-02, -6.0672E-02, -5.9506E-02, -5.8356E-02, -5.7221E-02, -5.6100E-02, -5.4993E-02, -5.3900E-02, -5.2821E-02, -5.1756E-02, -5.0703E-02, -4.9664E-02, -4.8637E-02, -4.7622E-02, -4.6620E-02, -4.5629E-02, -4.4650E-02, -4.3683E-02, -4.2727E-02, -4.1782E-02, -4.0848E-02, -3.9925E-02, -3.9013E-02, -3.8110E-02, -3.7218E-02, -3.6336E-02, -3.5463E-02, -3.4601E-02, -3.3748E-02, -3.2904E-02, -3.2070E-02, -3.1244E-02, -3.0428E-02, -2.9620E-02, -2.8822E-02, -2.8032E-02, -2.7250E-02, -2.6477E-02, -2.5713E-02, -2.4957E-02, -2.4209E-02, -2.3468E-02, -2.2736E-02, -2.2012E-02, -2.1295E-02, -2.0587E-02, -1.9887E-02, -1.9194E-02, -1.8510E-02, -1.7833E-02, -1.7163E-02, -1.6502E-02, -1.5848E-02, -1.5201E-02, -1.4562E-02, -1.3930E-02, -1.3307E-02, -1.2692E-02, -1.2085E-02, -1.1484E-02, -1.0894E-02, -1.0311E-02, -9.7348E-03, -9.1688E-03, -8.6099E-03, -8.0615E-03, -7.5202E-03, -6.9890E-03, -6.4689E-03, -5.9607E-03, -5.4600E-03, -4.9702E-03, -4.4920E-03, -4.0257E-03, -3.5711E-03, -3.1341E-03, -2.7102E-03, -2.3056E-03, -1.9149E-03, -1.5440E-03, -1.1939E-03, -8.7281E-04, -5.8313E-04, -3.2649E-04, -1.2299E-04, 1.2170E-03, 2.4862E-03, 3.5913E-03, 4.5367E-03, 5.2951E-03, 5.8557E-03, 6.2683E-03, 6.5320E-03, 6.6969E-03, 6.7074E-03, 6.6214E-03, 6.3903E-03, 6.0738E-03, 5.6711E-03, 5.1853E-03, 4.6229E-03, 4.0231E-03, 3.3370E-03, 2.5760E-03, 1.7500E-03, 8.9463E-04, -2.6284E-05, -9.7455E-04, -1.9818E-03, -3.0116E-03, -4.0691E-03, -5.1796E-03, -6.3087E-03, -7.4597E-03, -8.6344E-03, -9.8519E-03, -1.1083E-02, -1.2329E-02, -1.3590E-02, -1.4866E-02, -1.6156E-02, -1.7458E-02, -1.8773E-02, -2.0098E-02, -2.1432E-02, -2.2775E-02, -2.4124E-02, -2.5478E-02, -2.6837E-02, -2.8197E-02, -2.9557E-02, -3.0912E-02, -3.2269E-02, -3.3626E-02, -3.4980E-02, -3.6329E-02, -3.7671E-02, -3.9008E-02, -4.0338E-02, -4.1659E-02, -4.2970E-02, -4.4270E-02, -4.5558E-02, -4.6833E-02, -4.8093E-02, -4.9337E-02, -5.0565E-02, -5.1773E-02, -5.2963E-02, -5.4130E-02, -5.5275E-02, -5.6394E-02, -5.7485E-02, -5.8551E-02, -5.9584E-02, -6.0586E-02, -6.1552E-02, -6.2484E-02, -6.3373E-02, -6.4223E-02, -6.5025E-02, -6.5783E-02, -6.6490E-02, -6.7140E-02, -6.7734E-02, -6.8263E-02, -6.8730E-02, -6.9127E-02, -6.9445E-02, -6.9686E-02, -6.9840E-02, -6.9905E-02, -6.9874E-02, -6.9736E-02, -6.9491E-02, -6.9128E-02, -6.8636E-02, -6.8012E-02, -6.7244E-02, -6.6322E-02, -6.5231E-02, -6.3965E-02, -6.2510E-02, -6.0850E-02, -5.8968E-02, -5.6852E-02, -5.4484E-02, -5.1842E-02, -4.8903E-02, -4.5648E-02, -4.2049E-02, -3.8079E-02, -3.3705E-02, -2.8893E-02, -2.3602E-02, -1.7792E-02, -1.1415E-02, -4.4168E-03, 3.2644E-03, 1.1698E-02, 2.0963E-02, 3.1150E-02, 4.2367E-02, 5.4735E-02, 6.8399E-02, 8.3535E-02, 1.0035E-01, 1.1912E-01, 1.4017E-01, 1.6394E-01, 1.9103E-01, 2.2234E-01, 2.5934E-01, 3.0494E-01, 2.5934E-01, 2.2234E-01, 1.9103E-01, 1.6394E-01, 1.4017E-01, 1.1912E-01, 1.0035E-01, 8.3535E-02, 6.8399E-02, 5.4735E-02, 4.2367E-02, 3.1150E-02, 2.0963E-02, 1.1698E-02, 3.2644E-03, -4.4168E-03, -1.1415E-02, -1.7792E-02, -2.3602E-02, -2.8893E-02, -3.3705E-02, -3.8079E-02, -4.2049E-02, -4.5648E-02, -4.8903E-02, -5.1842E-02, -5.4484E-02, -5.6852E-02, -5.8968E-02, -6.0850E-02, -6.2510E-02, -6.3965E-02, -6.5231E-02, -6.6322E-02, -6.7244E-02, -6.8012E-02, -6.8636E-02, -6.9128E-02, -6.9491E-02, -6.9736E-02, -6.9874E-02, -6.9905E-02, -6.9840E-02, -6.9686E-02, -6.9445E-02, -6.9127E-02, -6.8730E-02, -6.8263E-02, -6.7734E-02, -6.7140E-02, -6.6490E-02, -6.5783E-02, -6.5025E-02, -6.4223E-02, -6.3373E-02, -6.2484E-02, -6.1552E-02, -6.0586E-02, -5.9584E-02, -5.8551E-02, -5.7485E-02, -5.6394E-02, -5.5275E-02, -5.4130E-02, -5.2963E-02, -5.1773E-02, -5.0565E-02, -4.9337E-02, -4.8093E-02, -4.6833E-02, -4.5558E-02, -4.4270E-02, -4.2970E-02, -4.1659E-02, -4.0338E-02, -3.9008E-02, -3.7671E-02, -3.6329E-02, -3.4980E-02, -3.3626E-02, -3.2269E-02, -3.0912E-02, -2.9557E-02, -2.8197E-02, -2.6837E-02, -2.5478E-02, -2.4124E-02, -2.2775E-02, -2.1432E-02, -2.0098E-02, -1.8773E-02, -1.7458E-02, -1.6156E-02, -1.4866E-02, -1.3590E-02, -1.2329E-02, -1.1083E-02, -9.8519E-03, -8.6344E-03, -7.4597E-03, -6.3087E-03, -5.1796E-03, -4.0691E-03, -3.0116E-03, -1.9818E-03, -9.7455E-04, -2.6284E-05, 8.9463E-04, 1.7500E-03, 2.5760E-03, 3.3370E-03, 4.0231E-03, 4.6229E-03, 5.1853E-03, 5.6711E-03, 6.0738E-03, 6.3903E-03, 6.6214E-03, 6.7074E-03, 6.6969E-03, 6.5320E-03, 6.2683E-03, 5.8557E-03, 5.2951E-03, 4.5367E-03, 3.5913E-03, 2.4862E-03, 1.2170E-03, 2.5052E-04, -2.0747E-03, -5.4078E-03, -9.0034E-03, -1.2595E-02, -1.5970E-02, -1.9081E-02, -2.1859E-02, -2.4386E-02, -2.6474E-02, -2.8266E-02, -2.9582E-02, -3.0604E-02, -3.1320E-02, -3.1731E-02, -3.1854E-02, -3.1842E-02, -3.1495E-02, -3.0858E-02, -2.9966E-02, -2.8967E-02, -2.7712E-02, -2.6357E-02, -2.4776E-02, -2.3118E-02, -2.1363E-02, -1.9415E-02, -1.7410E-02, -1.5338E-02, -1.3194E-02, -1.0916E-02, -8.6086E-03, -6.2701E-03, -3.9028E-03, -1.5116E-03, 8.9815E-04, 3.3197E-03, 5.7469E-03, 8.1723E-03, 1.0589E-02, 1.2991E-02, 1.5369E-02, 1.7719E-02, 2.0033E-02, 2.2306E-02, 2.4536E-02, 2.6744E-02, 2.8884E-02, 3.0960E-02, 3.2970E-02, 3.4918E-02, 3.6844E-02, 3.8668E-02, 4.0406E-02, 4.2069E-02, 4.3706E-02, 4.5224E-02, 4.6652E-02, 4.8051E-02, 4.9317E-02, 5.0485E-02, 5.1620E-02, 5.2624E-02, 5.3587E-02, 5.4402E-02, 5.5167E-02, 5.5764E-02, 5.6239E-02, 5.6662E-02, 5.6932E-02, 5.7140E-02, 5.7184E-02, 5.7157E-02, 5.6959E-02, 5.6682E-02, 5.6233E-02, 5.5697E-02, 5.5042E-02, 5.4179E-02, 5.3204E-02, 5.2031E-02, 5.0739E-02, 4.9296E-02, 4.7625E-02, 4.5807E-02, 4.3769E-02, 4.1576E-02, 3.9201E-02, 3.6582E-02, 3.3782E-02, 3.0775E-02, 2.7513E-02, 2.4044E-02, 2.0350E-02, 1.6414E-02, 1.2198E-02, 7.7442E-03, 3.0401E-03, -1.9264E-03, -7.1807E-03, -1.2686E-02, -1.8447E-02, -2.4464E-02, -3.0743E-02, -3.7249E-02, -4.3965E-02, -5.0871E-02, -5.7935E-02, -6.5118E-02, -7.2370E-02, -7.9606E-02, -8.6735E-02, -9.3642E-02, -1.0018E-01, -1.0616E-01, -1.1133E-01, -1.1540E-01, -1.1796E-01, -1.1847E-01, -1.1625E-01, -1.1039E-01, -9.9618E-02, -8.2208E-02, -5.5673E-02, -1.6309E-02, 4.1729E-02, 1.2851E-01, 2.6383E-01, 4.9470E-01, 2.6383E-01, 1.2851E-01, 4.1729E-02, -1.6309E-02, -5.5673E-02, -8.2208E-02, -9.9618E-02, -1.1039E-01, -1.1625E-01, -1.1847E-01, -1.1796E-01, -1.1540E-01, -1.1133E-01, -1.0616E-01, -1.0018E-01, -9.3642E-02, -8.6735E-02, -7.9606E-02, -7.2370E-02, -6.5118E-02, -5.7935E-02, -5.0871E-02, -4.3965E-02, -3.7249E-02, -3.0743E-02, -2.4464E-02, -1.8447E-02, -1.2686E-02, -7.1807E-03, -1.9264E-03, 3.0401E-03, 7.7442E-03, 1.2198E-02, 1.6414E-02, 2.0350E-02, 2.4044E-02, 2.7513E-02, 3.0775E-02, 3.3782E-02, 3.6582E-02, 3.9201E-02, 4.1576E-02, 4.3769E-02, 4.5807E-02, 4.7625E-02, 4.9296E-02, 5.0739E-02, 5.2031E-02, 5.3204E-02, 5.4179E-02, 5.5042E-02, 5.5697E-02, 5.6233E-02, 5.6682E-02, 5.6959E-02, 5.7157E-02, 5.7184E-02, 5.7140E-02, 5.6932E-02, 5.6662E-02, 5.6239E-02, 5.5764E-02, 5.5167E-02, 5.4402E-02, 5.3587E-02, 5.2624E-02, 5.1620E-02, 5.0485E-02, 4.9317E-02, 4.8051E-02, 4.6652E-02, 4.5224E-02, 4.3706E-02, 4.2069E-02, 4.0406E-02, 3.8668E-02, 3.6844E-02, 3.4918E-02, 3.2970E-02, 3.0960E-02, 2.8884E-02, 2.6744E-02, 2.4536E-02, 2.2306E-02, 2.0033E-02, 1.7719E-02, 1.5369E-02, 1.2991E-02, 1.0589E-02, 8.1723E-03, 5.7469E-03, 3.3197E-03, 8.9815E-04, -1.5116E-03, -3.9028E-03, -6.2701E-03, -8.6086E-03, -1.0916E-02, -1.3194E-02, -1.5338E-02, -1.7410E-02, -1.9415E-02, -2.1363E-02, -2.3118E-02, -2.4776E-02, -2.6357E-02, -2.7712E-02, -2.8967E-02, -2.9966E-02, -3.0858E-02, -3.1495E-02, -3.1842E-02, -3.1854E-02, -3.1731E-02, -3.1320E-02, -3.0604E-02, -2.9582E-02, -2.8266E-02, -2.6474E-02, -2.4386E-02, -2.1859E-02, -1.9081E-02, -1.5970E-02, -1.2595E-02, -9.0034E-03, -5.4078E-03, -2.0747E-03, 2.5052E-04, 2.2292E-04, 2.4028E-04, -3.9082E-04, -1.6657E-03, -3.7093E-03, -6.5651E-03, -1.0024E-02, -1.4058E-02, -1.8463E-02, -2.3373E-02, -2.8570E-02, -3.4105E-02, -3.9796E-02, -4.5592E-02, -5.1434E-02, -5.7261E-02, -6.3076E-02, -6.8758E-02, -7.4252E-02, -7.9513E-02, -8.4659E-02, -8.9443E-02, -9.4067E-02, -9.8234E-02, -1.0222E-01, -1.0595E-01, -1.0909E-01, -1.1201E-01, -1.1465E-01, -1.1695E-01, -1.1852E-01, -1.1986E-01, -1.2090E-01, -1.2163E-01, -1.2202E-01, -1.2207E-01, -1.2176E-01, -1.2110E-01, -1.2009E-01, -1.1872E-01, -1.1702E-01, -1.1499E-01, -1.1265E-01, -1.1002E-01, -1.0713E-01, -1.0407E-01, -1.0117E-01, -9.7812E-02, -9.4151E-02, -9.0262E-02, -8.6232E-02, -8.2390E-02, -7.8173E-02, -7.3756E-02, -6.9243E-02, -6.4935E-02, -6.0353E-02, -5.5687E-02, -5.1229E-02, -4.6549E-02, -4.1834E-02, -3.7340E-02, -3.2732E-02, -2.8329E-02, -2.3808E-02, -1.9486E-02, -1.5032E-02, -1.0615E-02, -6.4282E-03, -2.2406E-03, 1.7215E-03, 5.6646E-03, 9.3802E-03, 1.3047E-02, 1.6481E-02, 1.9829E-02, 2.2936E-02, 2.5845E-02, 2.8678E-02, 3.1280E-02, 3.3754E-02, 3.5987E-02, 3.8008E-02, 3.9895E-02, 4.1546E-02, 4.3022E-02, 4.4254E-02, 4.5258E-02, 4.6075E-02, 4.6650E-02, 4.6997E-02, 4.7142E-02, 4.7051E-02, 4.6732E-02, 4.6195E-02, 4.5459E-02, 4.4505E-02, 4.3341E-02, 4.1977E-02, 4.0428E-02, 3.8691E-02, 3.6776E-02, 3.4697E-02, 3.2468E-02, 3.0100E-02, 2.7608E-02, 2.5013E-02, 2.2334E-02, 1.9595E-02, 1.6821E-02, 1.4039E-02, 1.1278E-02, 8.5691E-03, 5.9481E-03, 3.4525E-03, 1.1222E-03, -1.0011E-03, -2.8753E-03, -4.4558E-03, -5.7001E-03, -6.5671E-03, -7.0201E-03, -7.0314E-03, -6.5875E-03, -5.7003E-03, -4.4225E-03, -2.8771E-03, -1.3154E-03, -2.4931E-04, -1.3154E-03, -2.8771E-03, -4.4225E-03, -5.7003E-03, -6.5875E-03, -7.0314E-03, -7.0201E-03, -6.5671E-03, -5.7001E-03, -4.4558E-03, -2.8753E-03, -1.0011E-03, 1.1222E-03, 3.4525E-03, 5.9481E-03, 8.5691E-03, 1.1278E-02, 1.4039E-02, 1.6821E-02, 1.9595E-02, 2.2334E-02, 2.5013E-02, 2.7608E-02, 3.0100E-02, 3.2468E-02, 3.4697E-02, 3.6776E-02, 3.8691E-02, 4.0428E-02, 4.1977E-02, 4.3341E-02, 4.4505E-02, 4.5459E-02, 4.6195E-02, 4.6732E-02, 4.7051E-02, 4.7142E-02, 4.6997E-02, 4.6650E-02, 4.6075E-02, 4.5258E-02, 4.4254E-02, 4.3022E-02, 4.1546E-02, 3.9895E-02, 3.8008E-02, 3.5987E-02, 3.3754E-02, 3.1280E-02, 2.8678E-02, 2.5845E-02, 2.2936E-02, 1.9829E-02, 1.6481E-02, 1.3047E-02, 9.3802E-03, 5.6646E-03, 1.7215E-03, -2.2406E-03, -6.4282E-03, -1.0615E-02, -1.5032E-02, -1.9486E-02, -2.3808E-02, -2.8329E-02, -3.2732E-02, -3.7340E-02, -4.1834E-02, -4.6549E-02, -5.1229E-02, -5.5687E-02, -6.0353E-02, -6.4935E-02, -6.9243E-02, -7.3756E-02, -7.8173E-02, -8.2390E-02, -8.6232E-02, -9.0262E-02, -9.4151E-02, -9.7812E-02, -1.0117E-01, -1.0407E-01, -1.0713E-01, -1.1002E-01, -1.1265E-01, -1.1499E-01, -1.1702E-01, -1.1872E-01, -1.2009E-01, -1.2110E-01, -1.2176E-01, -1.2207E-01, -1.2202E-01, -1.2163E-01, -1.2090E-01, -1.1986E-01, -1.1852E-01, -1.1695E-01, -1.1465E-01, -1.1201E-01, -1.0909E-01, -1.0595E-01, -1.0222E-01, -9.8234E-02, -9.4067E-02, -8.9443E-02, -8.4659E-02, -7.9513E-02, -7.4252E-02, -6.8758E-02, -6.3076E-02, -5.7261E-02, -5.1434E-02, -4.5592E-02, -3.9796E-02, -3.4105E-02, -2.8570E-02, -2.3373E-02, -1.8463E-02, -1.4058E-02, -1.0024E-02, -6.5651E-03, -3.7093E-03, -1.6657E-03, -3.9082E-04, 2.4028E-04, 2.2292E-04, 4.3617E-03, 6.1134E-03, 4.4961E-03, 9.0892E-04, -4.2437E-03, -1.0425E-02, -1.7018E-02, -2.3745E-02, -3.0415E-02, -3.6773E-02, -4.2806E-02, -4.8153E-02, -5.2986E-02, -5.7216E-02, -6.0781E-02, -6.3665E-02, -6.6202E-02, -6.7857E-02, -6.8694E-02, -6.8780E-02, -6.8528E-02, -6.7465E-02, -6.6073E-02, -6.3925E-02, -6.1506E-02, -5.8747E-02, -5.5315E-02, -5.1677E-02, -4.7795E-02, -4.3655E-02, -3.9058E-02, -3.4361E-02, -2.9558E-02, -2.4666E-02, -1.9706E-02, -1.4706E-02, -9.6930E-03, -4.6987E-03, 2.4759E-04, 5.1125E-03, 9.8674E-03, 1.4481E-02, 1.8928E-02, 2.3184E-02, 2.7237E-02, 3.1095E-02, 3.4969E-02, 3.8453E-02, 4.1622E-02, 4.4491E-02, 4.7108E-02, 4.9769E-02, 5.1931E-02, 5.3729E-02, 5.5248E-02, 5.6833E-02, 5.7896E-02, 5.8641E-02, 5.9461E-02, 5.9738E-02, 5.9714E-02, 5.9778E-02, 5.9382E-02, 5.9049E-02, 5.8209E-02, 5.7414E-02, 5.6047E-02, 5.4387E-02, 5.2815E-02, 5.0835E-02, 4.8921E-02, 4.6601E-02, 4.4337E-02, 4.1695E-02, 3.9105E-02, 3.6191E-02, 3.3336E-02, 3.0418E-02, 2.7110E-02, 2.3813E-02, 2.0235E-02, 1.6682E-02, 1.3068E-02, 9.1524E-03, 5.2386E-03, 1.1312E-03, -2.9569E-03, -7.0812E-03, -1.1360E-02, -1.5624E-02, -1.9897E-02, -2.4256E-02, -2.8573E-02, -3.2861E-02, -3.7114E-02, -4.1354E-02, -4.5494E-02, -4.9516E-02, -5.3393E-02, -5.7092E-02, -6.0558E-02, -6.3740E-02, -6.6577E-02, -6.8986E-02, -7.0918E-02, -7.2281E-02, -7.2973E-02, -7.2891E-02, -7.1907E-02, -6.9861E-02, -6.6649E-02, -6.2099E-02, -5.6022E-02, -4.8229E-02, -3.8515E-02, -2.6679E-02, -1.2523E-02, 4.1340E-03, 2.3347E-02, 4.5083E-02, 6.9076E-02, 9.4619E-02, 1.2024E-01, 1.4301E-01, 1.5718E-01, 1.5100E-01, 9.8588E-02, -6.4629E-02, -5.2784E-01, -6.4629E-02, 9.8588E-02, 1.5100E-01, 1.5718E-01, 1.4301E-01, 1.2024E-01, 9.4619E-02, 6.9076E-02, 4.5083E-02, 2.3347E-02, 4.1340E-03, -1.2523E-02, -2.6679E-02, -3.8515E-02, -4.8229E-02, -5.6022E-02, -6.2099E-02, -6.6649E-02, -6.9861E-02, -7.1907E-02, -7.2891E-02, -7.2973E-02, -7.2281E-02, -7.0918E-02, -6.8986E-02, -6.6577E-02, -6.3740E-02, -6.0558E-02, -5.7092E-02, -5.3393E-02, -4.9516E-02, -4.5494E-02, -4.1354E-02, -3.7114E-02, -3.2861E-02, -2.8573E-02, -2.4256E-02, -1.9897E-02, -1.5624E-02, -1.1360E-02, -7.0812E-03, -2.9569E-03, 1.1312E-03, 5.2386E-03, 9.1524E-03, 1.3068E-02, 1.6682E-02, 2.0235E-02, 2.3813E-02, 2.7110E-02, 3.0418E-02, 3.3336E-02, 3.6191E-02, 3.9105E-02, 4.1695E-02, 4.4337E-02, 4.6601E-02, 4.8921E-02, 5.0835E-02, 5.2815E-02, 5.4387E-02, 5.6047E-02, 5.7414E-02, 5.8209E-02, 5.9049E-02, 5.9382E-02, 5.9778E-02, 5.9714E-02, 5.9738E-02, 5.9461E-02, 5.8641E-02, 5.7896E-02, 5.6833E-02, 5.5248E-02, 5.3729E-02, 5.1931E-02, 4.9769E-02, 4.7108E-02, 4.4491E-02, 4.1622E-02, 3.8453E-02, 3.4969E-02, 3.1095E-02, 2.7237E-02, 2.3184E-02, 1.8928E-02, 1.4481E-02, 9.8674E-03, 5.1125E-03, 2.4759E-04, -4.6987E-03, -9.6930E-03, -1.4706E-02, -1.9706E-02, -2.4666E-02, -2.9558E-02, -3.4361E-02, -3.9058E-02, -4.3655E-02, -4.7795E-02, -5.1677E-02, -5.5315E-02, -5.8747E-02, -6.1506E-02, -6.3925E-02, -6.6073E-02, -6.7465E-02, -6.8528E-02, -6.8780E-02, -6.8694E-02, -6.7857E-02, -6.6202E-02, -6.3665E-02, -6.0781E-02, -5.7216E-02, -5.2986E-02, -4.8153E-02, -4.2806E-02, -3.6773E-02, -3.0415E-02, -2.3745E-02, -1.7018E-02, -1.0425E-02, -4.2437E-03, 9.0892E-04, 4.4961E-03, 6.1134E-03, 4.3617E-03, 7.8306E-04, -7.6696E-03, -1.6581E-02, -2.3489E-02, -2.7310E-02, -2.7660E-02, -2.5473E-02, -2.0941E-02, -1.4998E-02, -7.2141E-03, 1.4779E-03, 1.1084E-02, 2.0930E-02, 3.0752E-02, 4.0277E-02, 4.9254E-02, 5.7871E-02, 6.5402E-02, 7.1720E-02, 7.6745E-02, 8.1121E-02, 8.3849E-02, 8.5845E-02, 8.6095E-02, 8.5664E-02, 8.4353E-02, 8.1281E-02, 7.7612E-02, 7.3240E-02, 6.8103E-02, 6.1622E-02, 5.4799E-02, 4.7619E-02, 4.0118E-02, 3.2364E-02, 2.4429E-02, 1.6405E-02, 8.3770E-03, 4.4603E-04, -7.2988E-03, -1.4759E-02, -2.1852E-02, -2.8495E-02, -3.4630E-02, -4.0218E-02, -4.5313E-02, -5.0561E-02, -5.4723E-02, -5.8035E-02, -6.0590E-02, -6.2535E-02, -6.4753E-02, -6.5675E-02, -6.5736E-02, -6.5196E-02, -6.4999E-02, -6.3592E-02, -6.1569E-02, -5.9892E-02, -5.7099E-02, -5.3800E-02, -5.0889E-02, -4.7179E-02, -4.3786E-02, -3.9572E-02, -3.5632E-02, -3.0839E-02, -2.5784E-02, -2.1055E-02, -1.5970E-02, -1.1159E-02, -6.0897E-03, -1.2678E-03, 3.6803E-03, 8.3995E-03, 1.3098E-02, 1.7582E-02, 2.1899E-02, 2.6132E-02, 3.0191E-02, 3.4019E-02, 3.7681E-02, 4.1147E-02, 4.4222E-02, 4.7141E-02, 4.9597E-02, 5.1897E-02, 5.3917E-02, 5.5341E-02, 5.6563E-02, 5.7460E-02, 5.7662E-02, 5.7630E-02, 5.7214E-02, 5.6335E-02, 5.4622E-02, 5.2572E-02, 5.0033E-02, 4.6922E-02, 4.2904E-02, 3.8428E-02, 3.3363E-02, 2.7644E-02, 2.1034E-02, 1.3882E-02, 6.1217E-03, -2.2486E-03, -1.1233E-02, -2.0782E-02, -3.0924E-02, -4.1313E-02, -5.1802E-02, -6.2152E-02, -7.2072E-02, -8.1139E-02, -8.8838E-02, -9.4466E-02, -9.7156E-02, -9.5726E-02, -8.8781E-02, -7.4611E-02, -5.1260E-02, -1.6617E-02, 3.1015E-02, 9.1443E-02, 1.5798E-01, 2.0303E-01, 1.2703E-01, -4.4032E-01, 1.2703E-01, 2.0303E-01, 1.5798E-01, 9.1443E-02, 3.1015E-02, -1.6617E-02, -5.1260E-02, -7.4611E-02, -8.8781E-02, -9.5726E-02, -9.7156E-02, -9.4466E-02, -8.8838E-02, -8.1139E-02, -7.2072E-02, -6.2152E-02, -5.1802E-02, -4.1313E-02, -3.0924E-02, -2.0782E-02, -1.1233E-02, -2.2486E-03, 6.1217E-03, 1.3882E-02, 2.1034E-02, 2.7644E-02, 3.3363E-02, 3.8428E-02, 4.2904E-02, 4.6922E-02, 5.0033E-02, 5.2572E-02, 5.4622E-02, 5.6335E-02, 5.7214E-02, 5.7630E-02, 5.7662E-02, 5.7460E-02, 5.6563E-02, 5.5341E-02, 5.3917E-02, 5.1897E-02, 4.9597E-02, 4.7141E-02, 4.4222E-02, 4.1147E-02, 3.7681E-02, 3.4019E-02, 3.0191E-02, 2.6132E-02, 2.1899E-02, 1.7582E-02, 1.3098E-02, 8.3995E-03, 3.6803E-03, -1.2678E-03, -6.0897E-03, -1.1159E-02, -1.5970E-02, -2.1055E-02, -2.5784E-02, -3.0839E-02, -3.5632E-02, -3.9572E-02, -4.3786E-02, -4.7179E-02, -5.0889E-02, -5.3800E-02, -5.7099E-02, -5.9892E-02, -6.1569E-02, -6.3592E-02, -6.4999E-02, -6.5196E-02, -6.5736E-02, -6.5675E-02, -6.4753E-02, -6.2535E-02, -6.0590E-02, -5.8035E-02, -5.4723E-02, -5.0561E-02, -4.5313E-02, -4.0218E-02, -3.4630E-02, -2.8495E-02, -2.1852E-02, -1.4759E-02, -7.2988E-03, 4.4603E-04, 8.3770E-03, 1.6405E-02, 2.4429E-02, 3.2364E-02, 4.0118E-02, 4.7619E-02, 5.4799E-02, 6.1622E-02, 6.8103E-02, 7.3240E-02, 7.7612E-02, 8.1281E-02, 8.4353E-02, 8.5664E-02, 8.6095E-02, 8.5845E-02, 8.3849E-02, 8.1121E-02, 7.6745E-02, 7.1720E-02, 6.5402E-02, 5.7871E-02, 4.9254E-02, 4.0277E-02, 3.0752E-02, 2.0930E-02, 1.1084E-02, 1.4779E-03, -7.2141E-03, -1.4998E-02, -2.0941E-02, -2.5473E-02, -2.7660E-02, -2.7310E-02, -2.3489E-02, -1.6581E-02, -7.6696E-03, 7.8306E-04, 9.6066E-04, 3.0071E-03, 2.3837E-03, -1.6697E-03, -9.8782E-03, -2.2126E-02, -3.6847E-02, -5.3252E-02, -7.0213E-02, -8.7003E-02, -1.0298E-01, -1.1664E-01, -1.2826E-01, -1.3725E-01, -1.4319E-01, -1.4589E-01, -1.4687E-01, -1.4364E-01, -1.3668E-01, -1.2654E-01, -1.1506E-01, -1.0069E-01, -8.5313E-02, -6.8065E-02, -5.0390E-02, -3.2327E-02, -1.4092E-02, 3.8349E-03, 2.1210E-02, 3.7744E-02, 5.1981E-02, 6.5121E-02, 7.6820E-02, 8.6848E-02, 9.5032E-02, 1.0124E-01, 1.0540E-01, 1.0747E-01, 1.0746E-01, 1.0543E-01, 1.0149E-01, 9.5808E-02, 8.8587E-02, 8.0084E-02, 7.0607E-02, 6.0551E-02, 5.0767E-02, 3.9855E-02, 2.8461E-02, 1.6982E-02, 5.7134E-03, -5.6102E-03, -1.6283E-02, -2.6196E-02, -3.5313E-02, -4.4837E-02, -5.2544E-02, -5.9046E-02, -6.6215E-02, -7.0938E-02, -7.4294E-02, -7.8617E-02, -8.0543E-02, -8.3424E-02, -8.3520E-02, -8.4588E-02, -8.2324E-02, -7.8646E-02, -7.6337E-02, -7.1748E-02, -6.8431E-02, -6.2853E-02, -5.8547E-02, -5.2218E-02, -4.7191E-02, -4.0593E-02, -3.5395E-02, -3.0695E-02, -2.3973E-02, -1.8357E-02, -1.1596E-02, -6.0566E-03, -1.0567E-03, 5.1761E-03, 1.0426E-02, 1.6101E-02, 2.0718E-02, 2.4679E-02, 2.8896E-02, 3.2206E-02, 3.4882E-02, 3.7487E-02, 3.9293E-02, 4.0455E-02, 4.1117E-02, 4.1570E-02, 4.1421E-02, 4.0745E-02, 3.9630E-02, 3.8186E-02, 3.6303E-02, 3.4013E-02, 3.1370E-02, 2.8397E-02, 2.5159E-02, 2.1687E-02, 1.8040E-02, 1.4294E-02, 1.0528E-02, 6.7714E-03, 3.1744E-03, -2.0586E-04, -3.2911E-03, -5.9933E-03, -8.2232E-03, -9.8979E-03, -1.0950E-02, -1.1355E-02, -1.1053E-02, -1.0065E-02, -8.4571E-03, -6.3485E-03, -3.9312E-03, -1.4845E-03, 6.1872E-04, 1.9339E-03, 2.0451E-03, 8.8483E-04, -2.9199E-04, 8.8483E-04, 2.0451E-03, 1.9339E-03, 6.1872E-04, -1.4845E-03, -3.9312E-03, -6.3485E-03, -8.4571E-03, -1.0065E-02, -1.1053E-02, -1.1355E-02, -1.0950E-02, -9.8979E-03, -8.2232E-03, -5.9933E-03, -3.2911E-03, -2.0586E-04, 3.1744E-03, 6.7714E-03, 1.0528E-02, 1.4294E-02, 1.8040E-02, 2.1687E-02, 2.5159E-02, 2.8397E-02, 3.1370E-02, 3.4013E-02, 3.6303E-02, 3.8186E-02, 3.9630E-02, 4.0745E-02, 4.1421E-02, 4.1570E-02, 4.1117E-02, 4.0455E-02, 3.9293E-02, 3.7487E-02, 3.4882E-02, 3.2206E-02, 2.8896E-02, 2.4679E-02, 2.0718E-02, 1.6101E-02, 1.0426E-02, 5.1761E-03, -1.0567E-03, -6.0566E-03, -1.1596E-02, -1.8357E-02, -2.3973E-02, -3.0695E-02, -3.5395E-02, -4.0593E-02, -4.7191E-02, -5.2218E-02, -5.8547E-02, -6.2853E-02, -6.8431E-02, -7.1748E-02, -7.6337E-02, -7.8646E-02, -8.2324E-02, -8.4588E-02, -8.3520E-02, -8.3424E-02, -8.0543E-02, -7.8617E-02, -7.4294E-02, -7.0938E-02, -6.6215E-02, -5.9046E-02, -5.2544E-02, -4.4837E-02, -3.5313E-02, -2.6196E-02, -1.6283E-02, -5.6102E-03, 5.7134E-03, 1.6982E-02, 2.8461E-02, 3.9855E-02, 5.0767E-02, 6.0551E-02, 7.0607E-02, 8.0084E-02, 8.8587E-02, 9.5808E-02, 1.0149E-01, 1.0543E-01, 1.0746E-01, 1.0747E-01, 1.0540E-01, 1.0124E-01, 9.5032E-02, 8.6848E-02, 7.6820E-02, 6.5121E-02, 5.1981E-02, 3.7744E-02, 2.1210E-02, 3.8349E-03, -1.4092E-02, -3.2327E-02, -5.0390E-02, -6.8065E-02, -8.5313E-02, -1.0069E-01, -1.1506E-01, -1.2654E-01, -1.3668E-01, -1.4364E-01, -1.4687E-01, -1.4589E-01, -1.4319E-01, -1.3725E-01, -1.2826E-01, -1.1664E-01, -1.0298E-01, -8.7003E-02, -7.0213E-02, -5.3252E-02, -3.6847E-02, -2.2126E-02, -9.8782E-03, -1.6697E-03, 2.3837E-03, 3.0071E-03, 9.6066E-04, 1.0149E-02, 1.5391E-02, 8.6671E-03, -4.3569E-03, -2.1119E-02, -3.8605E-02, -5.4728E-02, -6.8063E-02, -7.8794E-02, -8.4680E-02, -8.7107E-02, -8.4104E-02, -7.7909E-02, -6.8633E-02, -5.6677E-02, -4.2663E-02, -2.7850E-02, -1.1680E-02, 4.8737E-03, 2.0969E-02, 3.6525E-02, 5.0299E-02, 6.2999E-02, 7.2802E-02, 8.1237E-02, 8.7826E-02, 9.0403E-02, 9.1469E-02, 9.0659E-02, 8.7758E-02, 8.0985E-02, 7.3144E-02, 6.4121E-02, 5.4010E-02, 4.2967E-02, 3.1218E-02, 1.9003E-02, 6.6062E-03, -5.6984E-03, -1.7613E-02, -2.8876E-02, -3.9220E-02, -4.8442E-02, -5.6364E-02, -6.2927E-02, -6.8265E-02, -7.4070E-02, -7.7170E-02, -7.8292E-02, -7.7725E-02, -7.5942E-02, -7.4820E-02, -7.1106E-02, -6.5853E-02, -5.9744E-02, -5.4301E-02, -4.7169E-02, -3.9421E-02, -3.2220E-02, -2.4053E-02, -1.5793E-02, -7.9088E-03, -2.0688E-05, 7.6847E-03, 1.5056E-02, 2.2398E-02, 2.8930E-02, 3.4716E-02, 4.0668E-02, 4.5274E-02, 5.0132E-02, 5.3332E-02, 5.6895E-02, 5.8616E-02, 6.0816E-02, 6.1194E-02, 6.2228E-02, 6.3191E-02, 6.1653E-02, 6.0702E-02, 5.7807E-02, 5.5668E-02, 5.3472E-02, 4.8982E-02, 4.5041E-02, 3.9602E-02, 3.4826E-02, 3.0125E-02, 2.3959E-02, 1.8340E-02, 1.2771E-02, 6.2069E-03, 8.8953E-05, -5.8438E-03, -1.1834E-02, -1.8454E-02, -2.4745E-02, -3.0794E-02, -3.6719E-02, -4.2651E-02, -4.8197E-02, -5.3263E-02, -5.7830E-02, -6.1652E-02, -6.4784E-02, -6.6978E-02, -6.8100E-02, -6.7965E-02, -6.6429E-02, -6.2970E-02, -5.7879E-02, -5.0788E-02, -4.1497E-02, -2.9812E-02, -1.5672E-02, 9.3647E-04, 1.9814E-02, 4.0778E-02, 6.2562E-02, 8.3850E-02, 1.0234E-01, 1.1450E-01, 1.1494E-01, 9.6001E-02, 4.7661E-02, -3.9531E-02, -1.5899E-01, -2.1698E-01, 2.8812E-01, -2.1698E-01, -1.5899E-01, -3.9531E-02, 4.7661E-02, 9.6001E-02, 1.1494E-01, 1.1450E-01, 1.0234E-01, 8.3850E-02, 6.2562E-02, 4.0778E-02, 1.9814E-02, 9.3647E-04, -1.5672E-02, -2.9812E-02, -4.1497E-02, -5.0788E-02, -5.7879E-02, -6.2970E-02, -6.6429E-02, -6.7965E-02, -6.8100E-02, -6.6978E-02, -6.4784E-02, -6.1652E-02, -5.7830E-02, -5.3263E-02, -4.8197E-02, -4.2651E-02, -3.6719E-02, -3.0794E-02, -2.4745E-02, -1.8454E-02, -1.1834E-02, -5.8438E-03, 8.8953E-05, 6.2069E-03, 1.2771E-02, 1.8340E-02, 2.3959E-02, 3.0125E-02, 3.4826E-02, 3.9602E-02, 4.5041E-02, 4.8982E-02, 5.3472E-02, 5.5668E-02, 5.7807E-02, 6.0702E-02, 6.1653E-02, 6.3191E-02, 6.2228E-02, 6.1194E-02, 6.0816E-02, 5.8616E-02, 5.6895E-02, 5.3332E-02, 5.0132E-02, 4.5274E-02, 4.0668E-02, 3.4716E-02, 2.8930E-02, 2.2398E-02, 1.5056E-02, 7.6847E-03, -2.0688E-05, -7.9088E-03, -1.5793E-02, -2.4053E-02, -3.2220E-02, -3.9421E-02, -4.7169E-02, -5.4301E-02, -5.9744E-02, -6.5853E-02, -7.1106E-02, -7.4820E-02, -7.5942E-02, -7.7725E-02, -7.8292E-02, -7.7170E-02, -7.4070E-02, -6.8265E-02, -6.2927E-02, -5.6364E-02, -4.8442E-02, -3.9220E-02, -2.8876E-02, -1.7613E-02, -5.6984E-03, 6.6062E-03, 1.9003E-02, 3.1218E-02, 4.2967E-02, 5.4010E-02, 6.4121E-02, 7.3144E-02, 8.0985E-02, 8.7758E-02, 9.0659E-02, 9.1469E-02, 9.0403E-02, 8.7826E-02, 8.1237E-02, 7.2802E-02, 6.2999E-02, 5.0299E-02, 3.6525E-02, 2.0969E-02, 4.8737E-03, -1.1680E-02, -2.7850E-02, -4.2663E-02, -5.6677E-02, -6.8633E-02, -7.7909E-02, -8.4104E-02, -8.7107E-02, -8.4680E-02, -7.8794E-02, -6.8063E-02, -5.4728E-02, -3.8605E-02, -2.1119E-02, -4.3569E-03, 8.6671E-03, 1.5391E-02, 1.0149E-02); \n//The first 8 rows of the V matrix: \nfloat V[2056] = float[](-2.9670E-03, -7.8761E-03, -1.4067E-02, -2.1055E-02, -2.8802E-02, -3.7248E-02, -4.6194E-02, -5.5619E-02, -6.5380E-02, -7.5605E-02, -8.6147E-02, -9.7113E-02, -1.0836E-01, -1.1990E-01, -1.3171E-01, -1.4379E-01, -1.5605E-01, -1.6860E-01, -1.8141E-01, -1.9447E-01, -2.0770E-01, -2.2118E-01, -2.3483E-01, -2.4873E-01, -2.6280E-01, -2.7704E-01, -2.9153E-01, -3.0619E-01, -3.2102E-01, -3.3603E-01, -3.5129E-01, -3.6671E-01, -3.8230E-01, -3.9808E-01, -4.1404E-01, -4.3018E-01, -4.4651E-01, -4.6303E-01, -4.7973E-01, -4.9663E-01, -5.1372E-01, -5.3100E-01, -5.4847E-01, -5.6614E-01, -5.8400E-01, -6.0205E-01, -6.2027E-01, -6.3872E-01, -6.5737E-01, -6.7622E-01, -6.9529E-01, -7.1454E-01, -7.3402E-01, -7.5372E-01, -7.7363E-01, -7.9375E-01, -8.1411E-01, -8.3469E-01, -8.5550E-01, -8.7654E-01, -8.9783E-01, -9.1935E-01, -9.4112E-01, -9.6313E-01, -9.8540E-01, -1.0079E+00, -1.0307E+00, -1.0538E+00, -1.0771E+00, -1.1007E+00, -1.1246E+00, -1.1488E+00, -1.1733E+00, -1.1981E+00, -1.2231E+00, -1.2485E+00, -1.2742E+00, -1.3003E+00, -1.3266E+00, -1.3533E+00, -1.3804E+00, -1.4077E+00, -1.4355E+00, -1.4636E+00, -1.4921E+00, -1.5210E+00, -1.5503E+00, -1.5799E+00, -1.6100E+00, -1.6405E+00, -1.6715E+00, -1.7028E+00, -1.7347E+00, -1.7669E+00, -1.7997E+00, -1.8330E+00, -1.8667E+00, -1.9010E+00, -1.9358E+00, -1.9711E+00, -2.0070E+00, -2.0435E+00, -2.0805E+00, -2.1182E+00, -2.1565E+00, -2.1955E+00, -2.2351E+00, -2.2754E+00, -2.3164E+00, -2.3582E+00, -2.4007E+00, -2.4441E+00, -2.4882E+00, -2.5333E+00, -2.5792E+00, -2.6261E+00, -2.6739E+00, -2.7228E+00, -2.7728E+00, -2.8240E+00, -2.8763E+00, -2.9300E+00, -2.9850E+00, -3.0416E+00, -3.0997E+00, -3.1597E+00, -3.2217E+00, -3.2861E+00, -3.3534E+00, -3.2861E+00, -3.2217E+00, -3.1597E+00, -3.0997E+00, -3.0416E+00, -2.9850E+00, -2.9300E+00, -2.8763E+00, -2.8240E+00, -2.7728E+00, -2.7228E+00, -2.6739E+00, -2.6261E+00, -2.5792E+00, -2.5333E+00, -2.4882E+00, -2.4441E+00, -2.4007E+00, -2.3582E+00, -2.3164E+00, -2.2754E+00, -2.2351E+00, -2.1955E+00, -2.1565E+00, -2.1182E+00, -2.0805E+00, -2.0435E+00, -2.0070E+00, -1.9711E+00, -1.9358E+00, -1.9010E+00, -1.8667E+00, -1.8330E+00, -1.7997E+00, -1.7669E+00, -1.7347E+00, -1.7028E+00, -1.6715E+00, -1.6405E+00, -1.6100E+00, -1.5799E+00, -1.5503E+00, -1.5210E+00, -1.4921E+00, -1.4636E+00, -1.4355E+00, -1.4077E+00, -1.3804E+00, -1.3533E+00, -1.3266E+00, -1.3003E+00, -1.2742E+00, -1.2485E+00, -1.2231E+00, -1.1981E+00, -1.1733E+00, -1.1488E+00, -1.1246E+00, -1.1007E+00, -1.0771E+00, -1.0538E+00, -1.0307E+00, -1.0079E+00, -9.8540E-01, -9.6313E-01, -9.4112E-01, -9.1935E-01, -8.9783E-01, -8.7654E-01, -8.5550E-01, -8.3469E-01, -8.1411E-01, -7.9375E-01, -7.7363E-01, -7.5372E-01, -7.3402E-01, -7.1454E-01, -6.9529E-01, -6.7622E-01, -6.5737E-01, -6.3872E-01, -6.2027E-01, -6.0205E-01, -5.8400E-01, -5.6614E-01, -5.4847E-01, -5.3100E-01, -5.1372E-01, -4.9663E-01, -4.7973E-01, -4.6303E-01, -4.4651E-01, -4.3018E-01, -4.1404E-01, -3.9808E-01, -3.8230E-01, -3.6671E-01, -3.5129E-01, -3.3603E-01, -3.2102E-01, -3.0619E-01, -2.9153E-01, -2.7704E-01, -2.6280E-01, -2.4873E-01, -2.3483E-01, -2.2118E-01, -2.0770E-01, -1.9447E-01, -1.8141E-01, -1.6860E-01, -1.5605E-01, -1.4379E-01, -1.3171E-01, -1.1990E-01, -1.0836E-01, -9.7113E-02, -8.6147E-02, -7.5605E-02, -6.5380E-02, -5.5619E-02, -4.6194E-02, -3.7248E-02, -2.8802E-02, -2.1055E-02, -1.4067E-02, -7.8761E-03, -2.9670E-03, 3.4592E-03, 7.0668E-03, 1.0208E-02, 1.2895E-02, 1.5051E-02, 1.6644E-02, 1.7817E-02, 1.8567E-02, 1.9035E-02, 1.9065E-02, 1.8820E-02, 1.8164E-02, 1.7264E-02, 1.6119E-02, 1.4739E-02, 1.3140E-02, 1.1435E-02, 9.4849E-03, 7.3219E-03, 4.9741E-03, 2.5429E-03, -7.4710E-05, -2.7700E-03, -5.6330E-03, -8.5600E-03, -1.1566E-02, -1.4722E-02, -1.7932E-02, -2.1203E-02, -2.4542E-02, -2.8003E-02, -3.1502E-02, -3.5044E-02, -3.8629E-02, -4.2255E-02, -4.5921E-02, -4.9623E-02, -5.3359E-02, -5.7126E-02, -6.0918E-02, -6.4734E-02, -6.8569E-02, -7.2419E-02, -7.6280E-02, -8.0146E-02, -8.4012E-02, -8.7863E-02, -9.1721E-02, -9.5577E-02, -9.9426E-02, -1.0326E-01, -1.0707E-01, -1.1088E-01, -1.1466E-01, -1.1841E-01, -1.2214E-01, -1.2583E-01, -1.2949E-01, -1.3312E-01, -1.3670E-01, -1.4023E-01, -1.4372E-01, -1.4716E-01, -1.5054E-01, -1.5386E-01, -1.5711E-01, -1.6029E-01, -1.6340E-01, -1.6642E-01, -1.6936E-01, -1.7221E-01, -1.7495E-01, -1.7760E-01, -1.8013E-01, -1.8254E-01, -1.8483E-01, -1.8698E-01, -1.8899E-01, -1.9084E-01, -1.9252E-01, -1.9403E-01, -1.9536E-01, -1.9648E-01, -1.9739E-01, -1.9807E-01, -1.9851E-01, -1.9870E-01, -1.9861E-01, -1.9822E-01, -1.9752E-01, -1.9649E-01, -1.9509E-01, -1.9331E-01, -1.9113E-01, -1.8851E-01, -1.8541E-01, -1.8181E-01, -1.7768E-01, -1.7296E-01, -1.6761E-01, -1.6160E-01, -1.5486E-01, -1.4735E-01, -1.3900E-01, -1.2975E-01, -1.1952E-01, -1.0823E-01, -9.5802E-02, -8.2124E-02, -6.7085E-02, -5.0572E-02, -3.2446E-02, -1.2554E-02, 9.2788E-03, 3.3250E-02, 5.9584E-02, 8.8541E-02, 1.2042E-01, 1.5558E-01, 1.9442E-01, 2.3744E-01, 2.8525E-01, 3.3859E-01, 3.9842E-01, 4.6598E-01, 5.4299E-01, 6.3198E-01, 7.3713E-01, 8.6677E-01, 7.3713E-01, 6.3198E-01, 5.4299E-01, 4.6598E-01, 3.9842E-01, 3.3859E-01, 2.8525E-01, 2.3744E-01, 1.9442E-01, 1.5558E-01, 1.2042E-01, 8.8541E-02, 5.9584E-02, 3.3250E-02, 9.2788E-03, -1.2554E-02, -3.2446E-02, -5.0572E-02, -6.7085E-02, -8.2124E-02, -9.5802E-02, -1.0823E-01, -1.1952E-01, -1.2975E-01, -1.3900E-01, -1.4735E-01, -1.5486E-01, -1.6160E-01, -1.6761E-01, -1.7296E-01, -1.7768E-01, -1.8181E-01, -1.8541E-01, -1.8851E-01, -1.9113E-01, -1.9331E-01, -1.9509E-01, -1.9649E-01, -1.9752E-01, -1.9822E-01, -1.9861E-01, -1.9870E-01, -1.9851E-01, -1.9807E-01, -1.9739E-01, -1.9648E-01, -1.9536E-01, -1.9403E-01, -1.9252E-01, -1.9084E-01, -1.8899E-01, -1.8698E-01, -1.8483E-01, -1.8254E-01, -1.8013E-01, -1.7760E-01, -1.7495E-01, -1.7221E-01, -1.6936E-01, -1.6642E-01, -1.6340E-01, -1.6029E-01, -1.5711E-01, -1.5386E-01, -1.5054E-01, -1.4716E-01, -1.4372E-01, -1.4023E-01, -1.3670E-01, -1.3312E-01, -1.2949E-01, -1.2583E-01, -1.2214E-01, -1.1841E-01, -1.1466E-01, -1.1088E-01, -1.0707E-01, -1.0326E-01, -9.9426E-02, -9.5577E-02, -9.1721E-02, -8.7863E-02, -8.4012E-02, -8.0146E-02, -7.6280E-02, -7.2419E-02, -6.8569E-02, -6.4734E-02, -6.0918E-02, -5.7126E-02, -5.3359E-02, -4.9623E-02, -4.5921E-02, -4.2255E-02, -3.8629E-02, -3.5044E-02, -3.1502E-02, -2.8003E-02, -2.4542E-02, -2.1203E-02, -1.7932E-02, -1.4722E-02, -1.1566E-02, -8.5600E-03, -5.6330E-03, -2.7700E-03, -7.4710E-05, 2.5429E-03, 4.9741E-03, 7.3219E-03, 9.4849E-03, 1.1435E-02, 1.3140E-02, 1.4739E-02, 1.6119E-02, 1.7264E-02, 1.8164E-02, 1.8820E-02, 1.9065E-02, 1.9035E-02, 1.8567E-02, 1.7817E-02, 1.6644E-02, 1.5051E-02, 1.2895E-02, 1.0208E-02, 7.0668E-03, 3.4592E-03, 1.7781E-04, -1.4725E-03, -3.8382E-03, -6.3901E-03, -8.9392E-03, -1.1334E-02, -1.3543E-02, -1.5514E-02, -1.7308E-02, -1.8789E-02, -2.0062E-02, -2.0996E-02, -2.1721E-02, -2.2229E-02, -2.2521E-02, -2.2608E-02, -2.2599E-02, -2.2354E-02, -2.1901E-02, -2.1268E-02, -2.0559E-02, -1.9668E-02, -1.8707E-02, -1.7585E-02, -1.6408E-02, -1.5163E-02, -1.3780E-02, -1.2357E-02, -1.0886E-02, -9.3643E-03, -7.7473E-03, -6.1099E-03, -4.4502E-03, -2.7700E-03, -1.0728E-03, 6.3746E-04, 2.3562E-03, 4.0788E-03, 5.8002E-03, 7.5157E-03, 9.2200E-03, 1.0908E-02, 1.2576E-02, 1.4218E-02, 1.5831E-02, 1.7414E-02, 1.8982E-02, 2.0500E-02, 2.1973E-02, 2.3400E-02, 2.4783E-02, 2.6149E-02, 2.7444E-02, 2.8678E-02, 2.9858E-02, 3.1020E-02, 3.2097E-02, 3.3111E-02, 3.4104E-02, 3.5002E-02, 3.5831E-02, 3.6637E-02, 3.7350E-02, 3.8033E-02, 3.8611E-02, 3.9155E-02, 3.9578E-02, 3.9915E-02, 4.0216E-02, 4.0407E-02, 4.0555E-02, 4.0586E-02, 4.0567E-02, 4.0426E-02, 4.0229E-02, 3.9911E-02, 3.9531E-02, 3.9066E-02, 3.8453E-02, 3.7761E-02, 3.6929E-02, 3.6012E-02, 3.4988E-02, 3.3801E-02, 3.2511E-02, 3.1065E-02, 2.9509E-02, 2.7822E-02, 2.5964E-02, 2.3976E-02, 2.1842E-02, 1.9527E-02, 1.7065E-02, 1.4443E-02, 1.1650E-02, 8.6572E-03, 5.4964E-03, 2.1577E-03, -1.3672E-03, -5.0964E-03, -9.0040E-03, -1.3093E-02, -1.7363E-02, -2.1820E-02, -2.6437E-02, -3.1204E-02, -3.6105E-02, -4.1119E-02, -4.6217E-02, -5.1364E-02, -5.6500E-02, -6.1559E-02, -6.6461E-02, -7.1101E-02, -7.5343E-02, -7.9018E-02, -8.1905E-02, -8.3718E-02, -8.4084E-02, -8.2511E-02, -7.8347E-02, -7.0703E-02, -5.8347E-02, -3.9513E-02, -1.1575E-02, 2.9617E-02, 9.1209E-02, 1.8725E-01, 3.5111E-01, 1.8725E-01, 9.1209E-02, 2.9617E-02, -1.1575E-02, -3.9513E-02, -5.8347E-02, -7.0703E-02, -7.8347E-02, -8.2511E-02, -8.4084E-02, -8.3718E-02, -8.1905E-02, -7.9018E-02, -7.5343E-02, -7.1101E-02, -6.6461E-02, -6.1559E-02, -5.6500E-02, -5.1364E-02, -4.6217E-02, -4.1119E-02, -3.6105E-02, -3.1204E-02, -2.6437E-02, -2.1820E-02, -1.7363E-02, -1.3093E-02, -9.0040E-03, -5.0964E-03, -1.3672E-03, 2.1577E-03, 5.4964E-03, 8.6572E-03, 1.1650E-02, 1.4443E-02, 1.7065E-02, 1.9527E-02, 2.1842E-02, 2.3976E-02, 2.5964E-02, 2.7822E-02, 2.9509E-02, 3.1065E-02, 3.2511E-02, 3.3801E-02, 3.4988E-02, 3.6012E-02, 3.6929E-02, 3.7761E-02, 3.8453E-02, 3.9066E-02, 3.9531E-02, 3.9911E-02, 4.0229E-02, 4.0426E-02, 4.0567E-02, 4.0586E-02, 4.0555E-02, 4.0407E-02, 4.0216E-02, 3.9915E-02, 3.9578E-02, 3.9155E-02, 3.8611E-02, 3.8033E-02, 3.7350E-02, 3.6637E-02, 3.5831E-02, 3.5002E-02, 3.4104E-02, 3.3111E-02, 3.2097E-02, 3.1020E-02, 2.9858E-02, 2.8678E-02, 2.7444E-02, 2.6149E-02, 2.4783E-02, 2.3400E-02, 2.1973E-02, 2.0500E-02, 1.8982E-02, 1.7414E-02, 1.5831E-02, 1.4218E-02, 1.2576E-02, 1.0908E-02, 9.2200E-03, 7.5157E-03, 5.8002E-03, 4.0788E-03, 2.3562E-03, 6.3746E-04, -1.0728E-03, -2.7700E-03, -4.4502E-03, -6.1099E-03, -7.7473E-03, -9.3643E-03, -1.0886E-02, -1.2357E-02, -1.3780E-02, -1.5163E-02, -1.6408E-02, -1.7585E-02, -1.8707E-02, -1.9668E-02, -2.0559E-02, -2.1268E-02, -2.1901E-02, -2.2354E-02, -2.2599E-02, -2.2608E-02, -2.2521E-02, -2.2229E-02, -2.1721E-02, -2.0996E-02, -2.0062E-02, -1.8789E-02, -1.7308E-02, -1.5514E-02, -1.3543E-02, -1.1334E-02, -8.9392E-03, -6.3901E-03, -3.8382E-03, -1.4725E-03, 1.7781E-04, -1.1310E-04, -1.2191E-04, 1.9829E-04, 8.4514E-04, 1.8820E-03, 3.3310E-03, 5.0858E-03, 7.1327E-03, 9.3676E-03, 1.1859E-02, 1.4496E-02, 1.7304E-02, 2.0191E-02, 2.3132E-02, 2.6096E-02, 2.9053E-02, 3.2003E-02, 3.4886E-02, 3.7673E-02, 4.0342E-02, 4.2953E-02, 4.5380E-02, 4.7727E-02, 4.9841E-02, 5.1863E-02, 5.3758E-02, 5.5348E-02, 5.6829E-02, 5.8168E-02, 5.9337E-02, 6.0134E-02, 6.0813E-02, 6.1343E-02, 6.1712E-02, 6.1910E-02, 6.1933E-02, 6.1777E-02, 6.1442E-02, 6.0928E-02, 6.0237E-02, 5.9373E-02, 5.8343E-02, 5.7154E-02, 5.5819E-02, 5.4356E-02, 5.2802E-02, 5.1332E-02, 4.9627E-02, 4.7769E-02, 4.5796E-02, 4.3751E-02, 4.1802E-02, 3.9663E-02, 3.7421E-02, 3.5132E-02, 3.2946E-02, 3.0621E-02, 2.8254E-02, 2.5992E-02, 2.3618E-02, 2.1225E-02, 1.8945E-02, 1.6607E-02, 1.4373E-02, 1.2079E-02, 9.8865E-03, 7.6269E-03, 5.3856E-03, 3.2615E-03, 1.1368E-03, -8.7341E-04, -2.8741E-03, -4.7592E-03, -6.6197E-03, -8.3621E-03, -1.0061E-02, -1.1637E-02, -1.3113E-02, -1.4550E-02, -1.5870E-02, -1.7126E-02, -1.8259E-02, -1.9284E-02, -2.0242E-02, -2.1079E-02, -2.1828E-02, -2.2453E-02, -2.2962E-02, -2.3377E-02, -2.3669E-02, -2.3845E-02, -2.3918E-02, -2.3872E-02, -2.3710E-02, -2.3438E-02, -2.3065E-02, -2.2580E-02, -2.1990E-02, -2.1298E-02, -2.0512E-02, -1.9631E-02, -1.8659E-02, -1.7604E-02, -1.6473E-02, -1.5272E-02, -1.4008E-02, -1.2691E-02, -1.1331E-02, -9.9420E-03, -8.5347E-03, -7.1231E-03, -5.7220E-03, -4.3477E-03, -3.0179E-03, -1.7517E-03, -5.6938E-04, 5.0795E-04, 1.4588E-03, 2.2608E-03, 2.8921E-03, 3.3319E-03, 3.5618E-03, 3.5675E-03, 3.3423E-03, 2.8922E-03, 2.2438E-03, 1.4598E-03, 6.6741E-04, 1.2649E-04, 6.6741E-04, 1.4598E-03, 2.2438E-03, 2.8922E-03, 3.3423E-03, 3.5675E-03, 3.5618E-03, 3.3319E-03, 2.8921E-03, 2.2608E-03, 1.4588E-03, 5.0795E-04, -5.6938E-04, -1.7517E-03, -3.0179E-03, -4.3477E-03, -5.7220E-03, -7.1231E-03, -8.5347E-03, -9.9420E-03, -1.1331E-02, -1.2691E-02, -1.4008E-02, -1.5272E-02, -1.6473E-02, -1.7604E-02, -1.8659E-02, -1.9631E-02, -2.0512E-02, -2.1298E-02, -2.1990E-02, -2.2580E-02, -2.3065E-02, -2.3438E-02, -2.3710E-02, -2.3872E-02, -2.3918E-02, -2.3845E-02, -2.3669E-02, -2.3377E-02, -2.2962E-02, -2.2453E-02, -2.1828E-02, -2.1079E-02, -2.0242E-02, -1.9284E-02, -1.8259E-02, -1.7126E-02, -1.5870E-02, -1.4550E-02, -1.3113E-02, -1.1637E-02, -1.0061E-02, -8.3621E-03, -6.6197E-03, -4.7592E-03, -2.8741E-03, -8.7341E-04, 1.1368E-03, 3.2615E-03, 5.3856E-03, 7.6269E-03, 9.8865E-03, 1.2079E-02, 1.4373E-02, 1.6607E-02, 1.8945E-02, 2.1225E-02, 2.3618E-02, 2.5992E-02, 2.8254E-02, 3.0621E-02, 3.2946E-02, 3.5132E-02, 3.7421E-02, 3.9663E-02, 4.1802E-02, 4.3751E-02, 4.5796E-02, 4.7769E-02, 4.9627E-02, 5.1332E-02, 5.2802E-02, 5.4356E-02, 5.5819E-02, 5.7154E-02, 5.8343E-02, 5.9373E-02, 6.0237E-02, 6.0928E-02, 6.1442E-02, 6.1777E-02, 6.1933E-02, 6.1910E-02, 6.1712E-02, 6.1343E-02, 6.0813E-02, 6.0134E-02, 5.9337E-02, 5.8168E-02, 5.6829E-02, 5.5348E-02, 5.3758E-02, 5.1863E-02, 4.9841E-02, 4.7727E-02, 4.5380E-02, 4.2953E-02, 4.0342E-02, 3.7673E-02, 3.4886E-02, 3.2003E-02, 2.9053E-02, 2.6096E-02, 2.3132E-02, 2.0191E-02, 1.7304E-02, 1.4496E-02, 1.1859E-02, 9.3676E-03, 7.1327E-03, 5.0858E-03, 3.3310E-03, 1.8820E-03, 8.4514E-04, 1.9829E-04, -1.2191E-04, -1.1310E-04, 1.2219E-03, 1.7126E-03, 1.2595E-03, 2.5462E-04, -1.1888E-03, -2.9204E-03, -4.7674E-03, -6.6517E-03, -8.5202E-03, -1.0302E-02, -1.1991E-02, -1.3489E-02, -1.4843E-02, -1.6028E-02, -1.7027E-02, -1.7835E-02, -1.8545E-02, -1.9009E-02, -1.9244E-02, -1.9268E-02, -1.9197E-02, -1.8899E-02, -1.8509E-02, -1.7908E-02, -1.7230E-02, -1.6457E-02, -1.5496E-02, -1.4477E-02, -1.3389E-02, -1.2229E-02, -1.0942E-02, -9.6257E-03, -8.2803E-03, -6.9099E-03, -5.5205E-03, -4.1198E-03, -2.7154E-03, -1.3163E-03, 6.9359E-05, 1.4322E-03, 2.7642E-03, 4.0566E-03, 5.3024E-03, 6.4946E-03, 7.6300E-03, 8.7109E-03, 9.7962E-03, 1.0772E-02, 1.1660E-02, 1.2463E-02, 1.3197E-02, 1.3942E-02, 1.4548E-02, 1.5051E-02, 1.5477E-02, 1.5921E-02, 1.6219E-02, 1.6427E-02, 1.6657E-02, 1.6735E-02, 1.6728E-02, 1.6746E-02, 1.6635E-02, 1.6542E-02, 1.6306E-02, 1.6084E-02, 1.5701E-02, 1.5236E-02, 1.4795E-02, 1.4241E-02, 1.3705E-02, 1.3055E-02, 1.2420E-02, 1.1680E-02, 1.0955E-02, 1.0138E-02, 9.3387E-03, 8.5211E-03, 7.5946E-03, 6.6710E-03, 5.6687E-03, 4.6732E-03, 3.6608E-03, 2.5639E-03, 1.4675E-03, 3.1690E-04, -8.2833E-04, -1.9837E-03, -3.1823E-03, -4.3767E-03, -5.5740E-03, -6.7949E-03, -8.0045E-03, -9.2056E-03, -1.0397E-02, -1.1585E-02, -1.2744E-02, -1.3871E-02, -1.4957E-02, -1.5994E-02, -1.6964E-02, -1.7856E-02, -1.8651E-02, -1.9326E-02, -1.9867E-02, -2.0249E-02, -2.0442E-02, -2.0419E-02, -2.0144E-02, -1.9571E-02, -1.8671E-02, -1.7396E-02, -1.5694E-02, -1.3511E-02, -1.0789E-02, -7.4738E-03, -3.5083E-03, 1.1581E-03, 6.5405E-03, 1.2629E-02, 1.9351E-02, 2.6506E-02, 3.3684E-02, 4.0063E-02, 4.4032E-02, 4.2301E-02, 2.7618E-02, -1.8105E-02, -1.4787E-01, -1.8105E-02, 2.7618E-02, 4.2301E-02, 4.4032E-02, 4.0063E-02, 3.3684E-02, 2.6506E-02, 1.9351E-02, 1.2629E-02, 6.5405E-03, 1.1581E-03, -3.5083E-03, -7.4738E-03, -1.0789E-02, -1.3511E-02, -1.5694E-02, -1.7396E-02, -1.8671E-02, -1.9571E-02, -2.0144E-02, -2.0419E-02, -2.0442E-02, -2.0249E-02, -1.9867E-02, -1.9326E-02, -1.8651E-02, -1.7856E-02, -1.6964E-02, -1.5994E-02, -1.4957E-02, -1.3871E-02, -1.2744E-02, -1.1585E-02, -1.0397E-02, -9.2056E-03, -8.0045E-03, -6.7949E-03, -5.5740E-03, -4.3767E-03, -3.1823E-03, -1.9837E-03, -8.2833E-04, 3.1690E-04, 1.4675E-03, 2.5639E-03, 3.6608E-03, 4.6732E-03, 5.6687E-03, 6.6710E-03, 7.5946E-03, 8.5211E-03, 9.3387E-03, 1.0138E-02, 1.0955E-02, 1.1680E-02, 1.2420E-02, 1.3055E-02, 1.3705E-02, 1.4241E-02, 1.4795E-02, 1.5236E-02, 1.5701E-02, 1.6084E-02, 1.6306E-02, 1.6542E-02, 1.6635E-02, 1.6746E-02, 1.6728E-02, 1.6735E-02, 1.6657E-02, 1.6427E-02, 1.6219E-02, 1.5921E-02, 1.5477E-02, 1.5051E-02, 1.4548E-02, 1.3942E-02, 1.3197E-02, 1.2463E-02, 1.1660E-02, 1.0772E-02, 9.7962E-03, 8.7109E-03, 7.6300E-03, 6.4946E-03, 5.3024E-03, 4.0566E-03, 2.7642E-03, 1.4322E-03, 6.9359E-05, -1.3163E-03, -2.7154E-03, -4.1198E-03, -5.5205E-03, -6.9099E-03, -8.2803E-03, -9.6257E-03, -1.0942E-02, -1.2229E-02, -1.3389E-02, -1.4477E-02, -1.5496E-02, -1.6457E-02, -1.7230E-02, -1.7908E-02, -1.8509E-02, -1.8899E-02, -1.9197E-02, -1.9268E-02, -1.9244E-02, -1.9009E-02, -1.8545E-02, -1.7835E-02, -1.7027E-02, -1.6028E-02, -1.4843E-02, -1.3489E-02, -1.1991E-02, -1.0302E-02, -8.5202E-03, -6.6517E-03, -4.7674E-03, -2.9204E-03, -1.1888E-03, 2.5462E-04, 1.2595E-03, 1.7126E-03, 1.2219E-03, 1.1053E-04, -1.0826E-03, -2.3406E-03, -3.3156E-03, -3.8550E-03, -3.9044E-03, -3.5957E-03, -2.9560E-03, -2.1170E-03, -1.0183E-03, 2.0861E-04, 1.5646E-03, 2.9545E-03, 4.3409E-03, 5.6853E-03, 6.9525E-03, 8.1689E-03, 9.2319E-03, 1.0124E-02, 1.0833E-02, 1.1451E-02, 1.1836E-02, 1.2118E-02, 1.2153E-02, 1.2092E-02, 1.1907E-02, 1.1473E-02, 1.0955E-02, 1.0338E-02, 9.6132E-03, 8.6984E-03, 7.7352E-03, 6.7218E-03, 5.6630E-03, 4.5685E-03, 3.4484E-03, 2.3157E-03, 1.1825E-03, 6.2961E-05, -1.0303E-03, -2.0833E-03, -3.0846E-03, -4.0222E-03, -4.8882E-03, -5.6770E-03, -6.3962E-03, -7.1370E-03, -7.7245E-03, -8.1920E-03, -8.5527E-03, -8.8272E-03, -9.1404E-03, -9.2704E-03, -9.2791E-03, -9.2028E-03, -9.1751E-03, -8.9765E-03, -8.6909E-03, -8.4541E-03, -8.0599E-03, -7.5943E-03, -7.1834E-03, -6.6596E-03, -6.1807E-03, -5.5859E-03, -5.0298E-03, -4.3531E-03, -3.6396E-03, -2.9721E-03, -2.2542E-03, -1.5752E-03, -8.5960E-04, -1.7895E-04, 5.1950E-04, 1.1856E-03, 1.8489E-03, 2.4819E-03, 3.0912E-03, 3.6887E-03, 4.2616E-03, 4.8021E-03, 5.3189E-03, 5.8082E-03, 6.2423E-03, 6.6542E-03, 7.0010E-03, 7.3256E-03, 7.6107E-03, 7.8118E-03, 7.9842E-03, 8.1109E-03, 8.1394E-03, 8.1348E-03, 8.0761E-03, 7.9520E-03, 7.7103E-03, 7.4209E-03, 7.0626E-03, 6.6234E-03, 6.0563E-03, 5.4243E-03, 4.7094E-03, 3.9021E-03, 2.9691E-03, 1.9596E-03, 8.6412E-04, -3.1740E-04, -1.5856E-03, -2.9336E-03, -4.3652E-03, -5.8316E-03, -7.3122E-03, -8.7732E-03, -1.0173E-02, -1.1453E-02, -1.2540E-02, -1.3335E-02, -1.3714E-02, -1.3512E-02, -1.2532E-02, -1.0532E-02, -7.2358E-03, -2.3456E-03, 4.3779E-03, 1.2908E-02, 2.2301E-02, 2.8659E-02, 1.7931E-02, -6.2154E-02, 1.7931E-02, 2.8659E-02, 2.2301E-02, 1.2908E-02, 4.3779E-03, -2.3456E-03, -7.2358E-03, -1.0532E-02, -1.2532E-02, -1.3512E-02, -1.3714E-02, -1.3335E-02, -1.2540E-02, -1.1453E-02, -1.0173E-02, -8.7732E-03, -7.3122E-03, -5.8316E-03, -4.3652E-03, -2.9336E-03, -1.5856E-03, -3.1740E-04, 8.6412E-04, 1.9596E-03, 2.9691E-03, 3.9021E-03, 4.7094E-03, 5.4243E-03, 6.0563E-03, 6.6234E-03, 7.0626E-03, 7.4209E-03, 7.7103E-03, 7.9520E-03, 8.0761E-03, 8.1348E-03, 8.1394E-03, 8.1109E-03, 7.9842E-03, 7.8118E-03, 7.6107E-03, 7.3256E-03, 7.0010E-03, 6.6542E-03, 6.2423E-03, 5.8082E-03, 5.3189E-03, 4.8021E-03, 4.2616E-03, 3.6887E-03, 3.0912E-03, 2.4819E-03, 1.8489E-03, 1.1856E-03, 5.1950E-04, -1.7895E-04, -8.5960E-04, -1.5752E-03, -2.2542E-03, -2.9721E-03, -3.6396E-03, -4.3531E-03, -5.0298E-03, -5.5859E-03, -6.1807E-03, -6.6596E-03, -7.1834E-03, -7.5943E-03, -8.0599E-03, -8.4541E-03, -8.6909E-03, -8.9765E-03, -9.1751E-03, -9.2028E-03, -9.2791E-03, -9.2704E-03, -9.1404E-03, -8.8272E-03, -8.5527E-03, -8.1920E-03, -7.7245E-03, -7.1370E-03, -6.3962E-03, -5.6770E-03, -4.8882E-03, -4.0222E-03, -3.0846E-03, -2.0833E-03, -1.0303E-03, 6.2961E-05, 1.1825E-03, 2.3157E-03, 3.4484E-03, 4.5685E-03, 5.6630E-03, 6.7218E-03, 7.7352E-03, 8.6984E-03, 9.6132E-03, 1.0338E-02, 1.0955E-02, 1.1473E-02, 1.1907E-02, 1.2092E-02, 1.2153E-02, 1.2118E-02, 1.1836E-02, 1.1451E-02, 1.0833E-02, 1.0124E-02, 9.2319E-03, 8.1689E-03, 6.9525E-03, 5.6853E-03, 4.3409E-03, 2.9545E-03, 1.5646E-03, 2.0861E-04, -1.0183E-03, -2.1170E-03, -2.9560E-03, -3.5957E-03, -3.9044E-03, -3.8550E-03, -3.3156E-03, -2.3406E-03, -1.0826E-03, 1.1053E-04, -8.4022E-05, -2.6301E-04, -2.0848E-04, 1.4604E-04, 8.6398E-04, 1.9352E-03, 3.2227E-03, 4.6576E-03, 6.1411E-03, 7.6096E-03, 9.0066E-03, 1.0202E-02, 1.1218E-02, 1.2004E-02, 1.2524E-02, 1.2760E-02, 1.2846E-02, 1.2564E-02, 1.1955E-02, 1.1068E-02, 1.0064E-02, 8.8063E-03, 7.4618E-03, 5.9532E-03, 4.4073E-03, 2.8274E-03, 1.2325E-03, -3.3541E-04, -1.8551E-03, -3.3012E-03, -4.5464E-03, -5.6957E-03, -6.7189E-03, -7.5960E-03, -8.3118E-03, -8.8551E-03, -9.2188E-03, -9.3995E-03, -9.3984E-03, -9.2209E-03, -8.8767E-03, -8.3797E-03, -7.7482E-03, -7.0044E-03, -6.1756E-03, -5.2960E-03, -4.4403E-03, -3.4859E-03, -2.4893E-03, -1.4853E-03, -4.9971E-04, 4.9069E-04, 1.4242E-03, 2.2912E-03, 3.0886E-03, 3.9216E-03, 4.5957E-03, 5.1644E-03, 5.7914E-03, 6.2044E-03, 6.4980E-03, 6.8761E-03, 7.0446E-03, 7.2965E-03, 7.3050E-03, 7.3984E-03, 7.2004E-03, 6.8787E-03, 6.6767E-03, 6.2753E-03, 5.9852E-03, 5.4974E-03, 5.1208E-03, 4.5672E-03, 4.1275E-03, 3.5504E-03, 3.0958E-03, 2.6847E-03, 2.0967E-03, 1.6056E-03, 1.0142E-03, 5.2973E-04, 9.2422E-05, -4.5272E-04, -9.1193E-04, -1.4083E-03, -1.8120E-03, -2.1586E-03, -2.5273E-03, -2.8169E-03, -3.0509E-03, -3.2787E-03, -3.4367E-03, -3.5384E-03, -3.5962E-03, -3.6359E-03, -3.6228E-03, -3.5637E-03, -3.4662E-03, -3.3399E-03, -3.1752E-03, -2.9749E-03, -2.7437E-03, -2.4837E-03, -2.2005E-03, -1.8968E-03, -1.5779E-03, -1.2502E-03, -9.2085E-04, -5.9225E-04, -2.7764E-04, 1.8005E-05, 2.8785E-04, 5.2419E-04, 7.1923E-04, 8.6570E-04, 9.5777E-04, 9.9318E-04, 9.6670E-04, 8.8032E-04, 7.3969E-04, 5.5527E-04, 3.4384E-04, 1.2984E-04, -5.4115E-05, -1.6915E-04, -1.7887E-04, -7.7390E-05, 2.5538E-05, -7.7390E-05, -1.7887E-04, -1.6915E-04, -5.4115E-05, 1.2984E-04, 3.4384E-04, 5.5527E-04, 7.3969E-04, 8.8032E-04, 9.6670E-04, 9.9318E-04, 9.5777E-04, 8.6570E-04, 7.1923E-04, 5.2419E-04, 2.8785E-04, 1.8005E-05, -2.7764E-04, -5.9225E-04, -9.2085E-04, -1.2502E-03, -1.5779E-03, -1.8968E-03, -2.2005E-03, -2.4837E-03, -2.7437E-03, -2.9749E-03, -3.1752E-03, -3.3399E-03, -3.4662E-03, -3.5637E-03, -3.6228E-03, -3.6359E-03, -3.5962E-03, -3.5384E-03, -3.4367E-03, -3.2787E-03, -3.0509E-03, -2.8169E-03, -2.5273E-03, -2.1586E-03, -1.8120E-03, -1.4083E-03, -9.1193E-04, -4.5272E-04, 9.2422E-05, 5.2973E-04, 1.0142E-03, 1.6056E-03, 2.0967E-03, 2.6847E-03, 3.0958E-03, 3.5504E-03, 4.1275E-03, 4.5672E-03, 5.1208E-03, 5.4974E-03, 5.9852E-03, 6.2753E-03, 6.6767E-03, 6.8787E-03, 7.2004E-03, 7.3984E-03, 7.3050E-03, 7.2965E-03, 7.0446E-03, 6.8761E-03, 6.4980E-03, 6.2044E-03, 5.7914E-03, 5.1644E-03, 4.5957E-03, 3.9216E-03, 3.0886E-03, 2.2912E-03, 1.4242E-03, 4.9069E-04, -4.9971E-04, -1.4853E-03, -2.4893E-03, -3.4859E-03, -4.4403E-03, -5.2960E-03, -6.1756E-03, -7.0044E-03, -7.7482E-03, -8.3797E-03, -8.8767E-03, -9.2209E-03, -9.3984E-03, -9.3995E-03, -9.2188E-03, -8.8551E-03, -8.3118E-03, -7.5960E-03, -6.7189E-03, -5.6957E-03, -4.5464E-03, -3.3012E-03, -1.8551E-03, -3.3541E-04, 1.2325E-03, 2.8274E-03, 4.4073E-03, 5.9532E-03, 7.4618E-03, 8.8063E-03, 1.0064E-02, 1.1068E-02, 1.1955E-02, 1.2564E-02, 1.2846E-02, 1.2760E-02, 1.2524E-02, 1.2004E-02, 1.1218E-02, 1.0202E-02, 9.0066E-03, 7.6096E-03, 6.1411E-03, 4.6576E-03, 3.2227E-03, 1.9352E-03, 8.6398E-04, 1.4604E-04, -2.0848E-04, -2.6301E-04, -8.4022E-05, 7.3507E-04, 1.1147E-03, 6.2775E-04, -3.1557E-04, -1.5296E-03, -2.7961E-03, -3.9639E-03, -4.9298E-03, -5.7070E-03, -6.1333E-03, -6.3091E-03, -6.0916E-03, -5.6429E-03, -4.9711E-03, -4.1051E-03, -3.0900E-03, -2.0172E-03, -8.4599E-04, 3.5300E-04, 1.5188E-03, 2.6455E-03, 3.6431E-03, 4.5629E-03, 5.2730E-03, 5.8839E-03, 6.3612E-03, 6.5479E-03, 6.6251E-03, 6.5664E-03, 6.3562E-03, 5.8657E-03, 5.2977E-03, 4.6442E-03, 3.9119E-03, 3.1121E-03, 2.2611E-03, 1.3764E-03, 4.7848E-04, -4.1273E-04, -1.2757E-03, -2.0915E-03, -2.8407E-03, -3.5086E-03, -4.0824E-03, -4.5578E-03, -4.9444E-03, -5.3648E-03, -5.5893E-03, -5.6706E-03, -5.6295E-03, -5.5005E-03, -5.4192E-03, -5.1502E-03, -4.7697E-03, -4.3272E-03, -3.9330E-03, -3.4164E-03, -2.8553E-03, -2.3336E-03, -1.7422E-03, -1.1439E-03, -5.7283E-04, -1.4984E-06, 5.5660E-04, 1.0905E-03, 1.6223E-03, 2.0954E-03, 2.5145E-03, 2.9455E-03, 3.2791E-03, 3.6310E-03, 3.8628E-03, 4.1209E-03, 4.2455E-03, 4.4048E-03, 4.4322E-03, 4.5071E-03, 4.5769E-03, 4.4655E-03, 4.3966E-03, 4.1869E-03, 4.0320E-03, 3.8729E-03, 3.5477E-03, 3.2623E-03, 2.8683E-03, 2.5224E-03, 2.1819E-03, 1.7354E-03, 1.3284E-03, 9.2497E-04, 4.4956E-04, 6.4428E-06, -4.2326E-04, -8.5709E-04, -1.3366E-03, -1.7923E-03, -2.2304E-03, -2.6595E-03, -3.0892E-03, -3.4909E-03, -3.8578E-03, -4.1886E-03, -4.4654E-03, -4.6923E-03, -4.8512E-03, -4.9324E-03, -4.9227E-03, -4.8114E-03, -4.5609E-03, -4.1921E-03, -3.6786E-03, -3.0056E-03, -2.1592E-03, -1.1351E-03, 6.7828E-05, 1.4351E-03, 2.9535E-03, 4.5313E-03, 6.0732E-03, 7.4125E-03, 8.2931E-03, 8.3247E-03, 6.9533E-03, 3.4521E-03, -2.8632E-03, -1.1516E-02, -1.5716E-02, 2.0869E-02, -1.5716E-02, -1.1516E-02, -2.8632E-03, 3.4521E-03, 6.9533E-03, 8.3247E-03, 8.2931E-03, 7.4125E-03, 6.0732E-03, 4.5313E-03, 2.9535E-03, 1.4351E-03, 6.7828E-05, -1.1351E-03, -2.1592E-03, -3.0056E-03, -3.6786E-03, -4.1921E-03, -4.5609E-03, -4.8114E-03, -4.9227E-03, -4.9324E-03, -4.8512E-03, -4.6923E-03, -4.4654E-03, -4.1886E-03, -3.8578E-03, -3.4909E-03, -3.0892E-03, -2.6595E-03, -2.2304E-03, -1.7923E-03, -1.3366E-03, -8.5709E-04, -4.2326E-04, 6.4428E-06, 4.4956E-04, 9.2497E-04, 1.3284E-03, 1.7354E-03, 2.1819E-03, 2.5224E-03, 2.8683E-03, 3.2623E-03, 3.5477E-03, 3.8729E-03, 4.0320E-03, 4.1869E-03, 4.3966E-03, 4.4655E-03, 4.5769E-03, 4.5071E-03, 4.4322E-03, 4.4048E-03, 4.2455E-03, 4.1209E-03, 3.8628E-03, 3.6310E-03, 3.2791E-03, 2.9455E-03, 2.5145E-03, 2.0954E-03, 1.6223E-03, 1.0905E-03, 5.5660E-04, -1.4984E-06, -5.7283E-04, -1.1439E-03, -1.7422E-03, -2.3336E-03, -2.8553E-03, -3.4164E-03, -3.9330E-03, -4.3272E-03, -4.7697E-03, -5.1502E-03, -5.4192E-03, -5.5005E-03, -5.6295E-03, -5.6706E-03, -5.5893E-03, -5.3648E-03, -4.9444E-03, -4.5578E-03, -4.0824E-03, -3.5086E-03, -2.8407E-03, -2.0915E-03, -1.2757E-03, -4.1273E-04, 4.7848E-04, 1.3764E-03, 2.2611E-03, 3.1121E-03, 3.9119E-03, 4.6442E-03, 5.2977E-03, 5.8657E-03, 6.3562E-03, 6.5664E-03, 6.6251E-03, 6.5479E-03, 6.3612E-03, 5.8839E-03, 5.2730E-03, 4.5629E-03, 3.6431E-03, 2.6455E-03, 1.5188E-03, 3.5300E-04, -8.4599E-04, -2.0172E-03, -3.0900E-03, -4.1051E-03, -4.9711E-03, -5.6429E-03, -6.0916E-03, -6.3091E-03, -6.1333E-03, -5.7070E-03, -4.9298E-03, -3.9639E-03, -2.7961E-03, -1.5296E-03, -3.1557E-04, 6.2775E-04, 1.1147E-03, 7.3507E-04); \n//center of the convolution \nint Nc = 128; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 257; \n\n\nfloat pack2(vec2 a)\n{\n    return uintBitsToFloat(packHalf2x16(a));\n}\n\nvec2 unpack2(float packed)\n{\n    return unpackHalf2x16(floatBitsToUint(packed));\n}\n\nivec2 wrap(ivec2 p, ivec2 res)\n{\n    return (p + res)%res;\n}\n", "buffer_a_code": "// Subtract pressure gradient to ensure zero divergence.\n\n#define PressureTexture iChannel1\n#define VelocityTexture iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n    \n    float x0 = texture(PressureTexture, uv - vec2(inverseResolution.x, 0)).x;\n    float x1 = texture(PressureTexture, uv + vec2(inverseResolution.x, 0)).x;\n    float y0 = texture(PressureTexture, uv - vec2(0, inverseResolution.y)).x;\n    float y1 = texture(PressureTexture, uv + vec2(0, inverseResolution.y)).x;\n    vec2 pressureGradient = -(vec2(x1, y1) - vec2(x0, y0)) * HELMHOLTZ_DECOMP_FACTOR;\n    vec4 oldV = texture(VelocityTexture, uv);\n    \n    fragColor = vec4(oldV.xy - pressureGradient, 0.0, oldV.w);\n    \n    ivec2 p = ivec2(fragCoord.xy);\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    fragColor.z = texelFetch(PressureTexture, wrap(p + ivec2(1,0),resol), 0).x + \n                  texelFetch(PressureTexture, wrap(p - ivec2(1,0),resol), 0).x + \n                  texelFetch(PressureTexture, wrap(p + ivec2(0,1),resol), 0).x +\n                  texelFetch(PressureTexture, wrap(p - ivec2(0,1),resol), 0).x - \n                  4.0*texelFetch(PressureTexture, p, 0).x;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//https://www.shadertoy.com/view/ldd3WS\n// Advection & force\n\n// Magic force within a rectangle.\nconst vec2 Force = vec2(3000.0, 0.0);\nconst vec2 ForceAreaMin = vec2(0.0, 0.2); \nconst vec2 ForceAreaMax = vec2(0.06, 0.8);\n\n// Circular barrier.\nconst vec2 BarrierPosition = vec2(0.2, 0.5);\nconst float BarrierRadiusSq = 0.02;\n\n#define VelocityTexture iChannel0\n\n//https://www.shadertoy.com/view/MllSzX\n//=======================================================================================\n#define c_textureSize iResolution.xy\n#define c_onePixel  (1.0 / c_textureSize)\n#define c_twoPixels  (2.0 / c_textureSize)\n\nvec4 CubicHermite (vec4 A, vec4 B, vec4 C, vec4 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec4 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec4 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec4 c = -A/2.0 + C/2.0;\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec4 BicubicHermiteTextureSample (vec2 P)\n{\n    vec2 pixel = P * iResolution.xy + 0.5;\n    \n    vec2 frac = fract(pixel);\n    pixel = floor(pixel) / iResolution.xy - vec2(c_onePixel/2.0);\n    \n    vec4 C00 = texture(iChannel0, pixel + c_onePixel*vec2(-1.0 ,-1.0));\n    vec4 C10 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        ,-1));\n    vec4 C20 = texture(iChannel0, pixel + c_onePixel*vec2( 1 ,-1));\n    vec4 C30 = texture(iChannel0, pixel + c_onePixel*vec2( 2,-1));\n    \n    vec4 C01 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 0.0));\n    vec4 C11 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 0.0));\n    vec4 C21 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 0.0));\n    vec4 C31 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 0.0));    \n    \n    vec4 C02 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 1));\n    vec4 C12 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 1));\n    vec4 C22 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 1));\n    vec4 C32 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 1));    \n    \n    vec4 C03 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 2));\n    vec4 C13 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 2));\n    vec4 C23 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 2));\n    vec4 C33 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 2));    \n    \n    vec4 CP0X = CubicHermite(C00, C10, C20, C30, frac.x);\n    vec4 CP1X = CubicHermite(C01, C11, C21, C31, frac.x);\n    vec4 CP2X = CubicHermite(C02, C12, C22, C32, frac.x);\n    vec4 CP3X = CubicHermite(C03, C13, C23, C33, frac.x);\n    \n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\nvec4 advectionPass(in vec2 fragCoord)\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n\n    float dt = iTimeDelta;\n    vec2 v1 = texture(VelocityTexture, uv.xy).xy;\n    vec2 v2 = texture(VelocityTexture, uv.xy - 0.5 * v1 * dt * inverseResolution).xy;\n    vec2 v3 = texture(VelocityTexture, uv.xy - 0.5 * v2 * dt * inverseResolution).xy;\n    vec2 v4 = texture(VelocityTexture, uv.xy - v3 * dt * inverseResolution).xy;\n    vec2 oldVelocity = (1.0 * v1 + 2.0 * v2 + 2.0 * v3 + 1.0 * v4) / 6.0;\n    \n    vec2 samplePos = uv - oldVelocity * iTimeDelta * inverseResolution;\n    vec4 outputDataL = texture(VelocityTexture, samplePos);\n    vec4 delta =  vec4(1.5, 1.5, 0.0, 0.5)*abs(outputDataL);\n    vec4 outputData = clamp(BicubicHermiteTextureSample(samplePos), outputDataL - delta, outputDataL + delta);\n    vec2 outputVelocity = outputData.xy;\n    \n    // Add force.\n    if(uv.x > ForceAreaMin.x && uv.x < ForceAreaMax.x &&\n       uv.y > ForceAreaMin.y && uv.y < ForceAreaMax.y)\n    {\n    \toutputVelocity += Force * iTimeDelta;\n    }\n    \n   \n\n    // Circle barrier.\n    vec2 toBarrier = BarrierPosition - uv;\n    toBarrier.x *= inverseResolution.y / inverseResolution.x;\n    if(dot(toBarrier, toBarrier) < BarrierRadiusSq)\n    {\n        fragColor = vec4(0.0, 0.0, 999.0, 0.0);\n    }\n    else\n    {\n        fragColor = vec4(outputVelocity, 0.0, outputData.w)*0.999;\n        if(abs(sin(100.0*uv.y)) < 0.1 && abs(uv.x - 0.05) < 0.0025)\n            fragColor.w += 1.0;\n    } \n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = advectionPass(fragCoord); \n    \n    float divergence = 0.0;\n    if(fragColor.z > 0.0)\n        divergence = 0.0;\n    else\n    {\n        float x0 = advectionPass(fragCoord - vec2(1,0)).x;\n        float x1 = advectionPass(fragCoord + vec2(1,0)).x;\n        float y0 = advectionPass(fragCoord - vec2(0,1)).y;\n        float y1 = advectionPass(fragCoord + vec2(0,1)).y;\n        divergence = ((x1-x0) + (y1-y0)) * 0.5;\n    }\n    fragColor.z = divergence;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    return texelFetch(iChannel2, p, 0).z;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + PRESSURE_REUSE_FACTOR*getEstimatedDensity(p);\n}\n\n\n//single component convolution pass x\n//first pass of separable poisson filter convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    vec4 sum0 = vec4(0.0);\n    vec4 sum1 = vec4(0.0);\n\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        ivec2 pos = wrap(coord + ivec2(i, 0), resol);\n       \n        float density = getDensityError(pos);\n\n        int id = (i + Nc);\n        //loop over ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum0[j] += density * U[id + 2 * j * N];\n            sum1[j] += density * U[id + (2 * j + 1) * N];\n        }\n    }\n\n    //loop over pairs of ranks\n    for(int j = 0; j < 4; j++)\n    {\n        fragColor[j] = pack2(vec2(sum0[j], sum1[j]));\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    float sum = 0.0;\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = wrap(coord + ivec2(0, i), resol);\n        \n        //wrap around\n        pos.x = (pos.x + resol.x) % resol.x;\n        pos.y = (pos.y + resol.y) % resol.y;\n        \n        vec4 data = texelFetch(iChannel0, pos, 0);\n\n        //loop over pairs of ranks\n        for(int j = 0; j < 4; j++)\n        {\n            vec2 val = unpack2(data[j]);\n            sum += val.x * V[i + Nc + 2 * j * N];\n            sum += val.y * V[i + Nc + (2*j + 1) * N];\n        }\n    }\n\n    //get previous poisson solution\n    float prev = PRESSURE_REUSE_FACTOR*texelFetch(iChannel1, coord, 0).x;\n\n    //add the previous poisson solution to the convolution\n    sum += prev;\n\n    //return the final poisson solution\n    fragColor = vec4(sum);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 140], [142, 142, 178, 178, 604], [606, 606, 638, 742, 795], [797, 797, 842, 842, 1079]], "test": "untested"}
{"id": "clBXDm", "name": "Stable fluids poisson filter", "author": "michael0884", "description": "Using poisson filters to get a really high quality pressure estimate(by shadertoy standards) \n+bicubic interpolation advection + rk4", "tags": ["particles", "ca"], "likes": 31, "viewed": 564, "published": 3, "date": "1676145189", "time_retrieved": "2024-07-30T18:10:43.298591", "image_code": "float getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + getEstimatedDensity(p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n\n    col.xyz = vec3(10.0)*abs(getDensityError(p));\n    \n\n    //col.xyz = vec3(0.5)*abs(getDensity(p));\n    //col.xyz = -vec3(1.0)*getEstimatedDensity(p);\n    col.xyz = vec3(0.400,1.000,0.988)*texelFetch(iChannel0, p, 0).w;\n    col.xyz *= -0.0001*texelFetch(iChannel1, p, 0).x + 1.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define HELMHOLTZ_DECOMP_FACTOR 0.45\n#define PRESSURE_REUSE_FACTOR 0.99\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n//The first 8 columns of the U matrix: \nfloat U[1032] = float[](-4.8700E-04, -1.2393E-03, -2.1780E-03, -3.2455E-03, -4.4319E-03, -5.7229E-03, -7.0822E-03, -8.5081E-03, -9.9956E-03, -1.1524E-02, -1.3115E-02, -1.4747E-02, -1.6437E-02, -1.8165E-02, -1.9935E-02, -2.1748E-02, -2.3615E-02, -2.5521E-02, -2.7467E-02, -2.9454E-02, -3.1483E-02, -3.3552E-02, -3.5656E-02, -3.7809E-02, -4.0008E-02, -4.2253E-02, -4.4544E-02, -4.6877E-02, -4.9262E-02, -5.1697E-02, -5.4179E-02, -5.6717E-02, -5.9309E-02, -6.1955E-02, -6.4660E-02, -6.7423E-02, -7.0250E-02, -7.3139E-02, -7.6096E-02, -7.9121E-02, -8.2219E-02, -8.5393E-02, -8.8645E-02, -9.1979E-02, -9.5400E-02, -9.8911E-02, -1.0252E-01, -1.0622E-01, -1.1003E-01, -1.1395E-01, -1.1799E-01, -1.2215E-01, -1.2644E-01, -1.3087E-01, -1.3545E-01, -1.4019E-01, -1.4509E-01, -1.5019E-01, -1.5549E-01, -1.6101E-01, -1.6677E-01, -1.7282E-01, -1.7919E-01, -1.8594E-01, -1.9321E-01, -1.8594E-01, -1.7919E-01, -1.7282E-01, -1.6677E-01, -1.6101E-01, -1.5549E-01, -1.5019E-01, -1.4509E-01, -1.4019E-01, -1.3545E-01, -1.3087E-01, -1.2644E-01, -1.2215E-01, -1.1799E-01, -1.1395E-01, -1.1003E-01, -1.0622E-01, -1.0252E-01, -9.8911E-02, -9.5400E-02, -9.1979E-02, -8.8645E-02, -8.5393E-02, -8.2219E-02, -7.9121E-02, -7.6096E-02, -7.3139E-02, -7.0250E-02, -6.7423E-02, -6.4660E-02, -6.1955E-02, -5.9309E-02, -5.6717E-02, -5.4179E-02, -5.1697E-02, -4.9262E-02, -4.6877E-02, -4.4544E-02, -4.2253E-02, -4.0008E-02, -3.7809E-02, -3.5656E-02, -3.3552E-02, -3.1483E-02, -2.9454E-02, -2.7467E-02, -2.5521E-02, -2.3615E-02, -2.1748E-02, -1.9935E-02, -1.8165E-02, -1.6437E-02, -1.4747E-02, -1.3115E-02, -1.1524E-02, -9.9956E-03, -8.5081E-03, -7.0822E-03, -5.7229E-03, -4.4319E-03, -3.2455E-03, -2.1780E-03, -1.2393E-03, -4.8700E-04, 3.8441E-03, 7.0405E-03, 9.1937E-03, 1.0459E-02, 1.0810E-02, 1.0314E-02, 9.3210E-03, 7.8464E-03, 5.9459E-03, 3.8550E-03, 1.3471E-03, -1.3269E-03, -4.3436E-03, -7.4768E-03, -1.0742E-02, -1.4145E-02, -1.7780E-02, -2.1471E-02, -2.5218E-02, -2.9011E-02, -3.2834E-02, -3.6669E-02, -4.0472E-02, -4.4304E-02, -4.8134E-02, -5.1941E-02, -5.5708E-02, -5.9415E-02, -6.3064E-02, -6.6634E-02, -7.0117E-02, -7.3489E-02, -7.6735E-02, -7.9851E-02, -8.2796E-02, -8.5573E-02, -8.8129E-02, -9.0468E-02, -9.2529E-02, -9.4310E-02, -9.5762E-02, -9.6811E-02, -9.7448E-02, -9.7602E-02, -9.7180E-02, -9.6145E-02, -9.4400E-02, -9.1818E-02, -8.8317E-02, -8.3752E-02, -7.7957E-02, -7.0722E-02, -6.1851E-02, -5.1066E-02, -3.8035E-02, -2.2350E-02, -3.4984E-03, 1.9136E-02, 4.6374E-02, 7.9306E-02, 1.1943E-01, 1.6891E-01, 2.3113E-01, 3.1208E-01, 4.2455E-01, 3.1208E-01, 2.3113E-01, 1.6891E-01, 1.1943E-01, 7.9306E-02, 4.6374E-02, 1.9136E-02, -3.4984E-03, -2.2350E-02, -3.8035E-02, -5.1066E-02, -6.1851E-02, -7.0722E-02, -7.7957E-02, -8.3752E-02, -8.8317E-02, -9.1818E-02, -9.4400E-02, -9.6145E-02, -9.7180E-02, -9.7602E-02, -9.7448E-02, -9.6811E-02, -9.5762E-02, -9.4310E-02, -9.2529E-02, -9.0468E-02, -8.8129E-02, -8.5573E-02, -8.2796E-02, -7.9851E-02, -7.6735E-02, -7.3489E-02, -7.0117E-02, -6.6634E-02, -6.3064E-02, -5.9415E-02, -5.5708E-02, -5.1941E-02, -4.8134E-02, -4.4304E-02, -4.0472E-02, -3.6669E-02, -3.2834E-02, -2.9011E-02, -2.5218E-02, -2.1471E-02, -1.7780E-02, -1.4145E-02, -1.0742E-02, -7.4768E-03, -4.3436E-03, -1.3269E-03, 1.3471E-03, 3.8550E-03, 5.9459E-03, 7.8464E-03, 9.3210E-03, 1.0314E-02, 1.0810E-02, 1.0459E-02, 9.1937E-03, 7.0405E-03, 3.8441E-03, 3.8780E-03, 1.3323E-02, 2.3249E-02, 3.1961E-02, 3.8579E-02, 4.2719E-02, 4.5218E-02, 4.6011E-02, 4.5227E-02, 4.3743E-02, 4.0658E-02, 3.6968E-02, 3.1993E-02, 2.6639E-02, 2.0864E-02, 1.4672E-02, 7.8253E-03, 9.2183E-04, -5.9968E-03, -1.2866E-02, -1.9612E-02, -2.6177E-02, -3.2618E-02, -3.8747E-02, -4.4527E-02, -4.9918E-02, -5.4911E-02, -5.9772E-02, -6.3961E-02, -6.7619E-02, -7.1102E-02, -7.3763E-02, -7.5807E-02, -7.7626E-02, -7.8602E-02, -7.9264E-02, -7.8991E-02, -7.8320E-02, -7.6672E-02, -7.4539E-02, -7.1693E-02, -6.7631E-02, -6.2852E-02, -5.7139E-02, -5.0033E-02, -4.1961E-02, -3.2719E-02, -2.1960E-02, -9.9851E-03, 3.3321E-03, 1.8084E-02, 3.4415E-02, 5.2011E-02, 7.0739E-02, 9.0328E-02, 1.1027E-01, 1.2973E-01, 1.4719E-01, 1.6028E-01, 1.6515E-01, 1.5511E-01, 1.1801E-01, 2.9671E-02, -1.6494E-01, -6.1534E-01, -1.6494E-01, 2.9671E-02, 1.1801E-01, 1.5511E-01, 1.6515E-01, 1.6028E-01, 1.4719E-01, 1.2973E-01, 1.1027E-01, 9.0328E-02, 7.0739E-02, 5.2011E-02, 3.4415E-02, 1.8084E-02, 3.3321E-03, -9.9851E-03, -2.1960E-02, -3.2719E-02, -4.1961E-02, -5.0033E-02, -5.7139E-02, -6.2852E-02, -6.7631E-02, -7.1693E-02, -7.4539E-02, -7.6672E-02, -7.8320E-02, -7.8991E-02, -7.9264E-02, -7.8602E-02, -7.7626E-02, -7.5807E-02, -7.3763E-02, -7.1102E-02, -6.7619E-02, -6.3961E-02, -5.9772E-02, -5.4911E-02, -4.9918E-02, -4.4527E-02, -3.8747E-02, -3.2618E-02, -2.6177E-02, -1.9612E-02, -1.2866E-02, -5.9968E-03, 9.2183E-04, 7.8253E-03, 1.4672E-02, 2.0864E-02, 2.6639E-02, 3.1993E-02, 3.6968E-02, 4.0658E-02, 4.3743E-02, 4.5227E-02, 4.6011E-02, 4.5218E-02, 4.2719E-02, 3.8579E-02, 3.1961E-02, 2.3249E-02, 1.3323E-02, 3.8780E-03, -3.5540E-04, 2.0967E-03, 8.6209E-03, 1.8563E-02, 3.1646E-02, 4.6963E-02, 6.3099E-02, 7.9456E-02, 9.5368E-02, 1.1087E-01, 1.2472E-01, 1.3765E-01, 1.4785E-01, 1.5687E-01, 1.6430E-01, 1.6980E-01, 1.7103E-01, 1.7090E-01, 1.6914E-01, 1.6570E-01, 1.6068E-01, 1.5446E-01, 1.4901E-01, 1.4077E-01, 1.3071E-01, 1.1933E-01, 1.0723E-01, 9.6199E-02, 8.3432E-02, 7.0140E-02, 5.7980E-02, 4.4693E-02, 3.1409E-02, 1.9397E-02, 7.2246E-03, -3.7034E-03, -1.4528E-02, -2.4071E-02, -3.3149E-02, -4.0878E-02, -4.7477E-02, -5.3472E-02, -5.8147E-02, -6.1644E-02, -6.4292E-02, -6.5635E-02, -6.5764E-02, -6.4860E-02, -6.2719E-02, -5.9421E-02, -5.5069E-02, -4.9810E-02, -4.3674E-02, -3.6819E-02, -2.9452E-02, -2.1831E-02, -1.4254E-02, -7.0495E-03, -6.1328E-04, 4.5980E-03, 8.0935E-03, 9.4065E-03, 8.2309E-03, 4.7655E-03, 6.8506E-04, 4.7655E-03, 8.2309E-03, 9.4065E-03, 8.0935E-03, 4.5980E-03, -6.1328E-04, -7.0495E-03, -1.4254E-02, -2.1831E-02, -2.9452E-02, -3.6819E-02, -4.3674E-02, -4.9810E-02, -5.5069E-02, -5.9421E-02, -6.2719E-02, -6.4860E-02, -6.5764E-02, -6.5635E-02, -6.4292E-02, -6.1644E-02, -5.8147E-02, -5.3472E-02, -4.7477E-02, -4.0878E-02, -3.3149E-02, -2.4071E-02, -1.4528E-02, -3.7034E-03, 7.2246E-03, 1.9397E-02, 3.1409E-02, 4.4693E-02, 5.7980E-02, 7.0140E-02, 8.3432E-02, 9.6199E-02, 1.0723E-01, 1.1933E-01, 1.3071E-01, 1.4077E-01, 1.4901E-01, 1.5446E-01, 1.6068E-01, 1.6570E-01, 1.6914E-01, 1.7090E-01, 1.7103E-01, 1.6980E-01, 1.6430E-01, 1.5687E-01, 1.4785E-01, 1.3765E-01, 1.2472E-01, 1.1087E-01, 9.5368E-02, 7.9456E-02, 6.3099E-02, 4.6963E-02, 3.1646E-02, 1.8563E-02, 8.6209E-03, 2.0967E-03, -3.5540E-04, -1.0751E-02, -5.0997E-03, 1.1055E-02, 3.1040E-02, 5.1374E-02, 6.9059E-02, 8.3718E-02, 9.4425E-02, 1.0077E-01, 1.0489E-01, 1.0369E-01, 1.0027E-01, 9.2030E-02, 8.2261E-02, 7.0767E-02, 5.7584E-02, 4.1982E-02, 2.6253E-02, 1.0631E-02, -4.5384E-03, -1.8931E-02, -3.2333E-02, -4.5708E-02, -5.7000E-02, -6.6373E-02, -7.3788E-02, -7.9487E-02, -8.5550E-02, -8.8285E-02, -8.8960E-02, -9.0129E-02, -8.7818E-02, -8.3704E-02, -8.0207E-02, -7.4144E-02, -6.8539E-02, -6.0532E-02, -5.2927E-02, -4.3433E-02, -3.4362E-02, -2.5041E-02, -1.3821E-02, -2.8284E-03, 8.4234E-03, 2.0931E-02, 3.3216E-02, 4.5423E-02, 5.7869E-02, 6.9653E-02, 8.0558E-02, 9.0237E-02, 9.8149E-02, 1.0354E-01, 1.0546E-01, 1.0271E-01, 9.3924E-02, 7.7119E-02, 5.0622E-02, 1.2212E-02, -3.9707E-02, -1.0456E-01, -1.7460E-01, -2.1946E-01, -1.3176E-01, 4.8380E-01, -1.3176E-01, -2.1946E-01, -1.7460E-01, -1.0456E-01, -3.9707E-02, 1.2212E-02, 5.0622E-02, 7.7119E-02, 9.3924E-02, 1.0271E-01, 1.0546E-01, 1.0354E-01, 9.8149E-02, 9.0237E-02, 8.0558E-02, 6.9653E-02, 5.7869E-02, 4.5423E-02, 3.3216E-02, 2.0931E-02, 8.4234E-03, -2.8284E-03, -1.3821E-02, -2.5041E-02, -3.4362E-02, -4.3433E-02, -5.2927E-02, -6.0532E-02, -6.8539E-02, -7.4144E-02, -8.0207E-02, -8.3704E-02, -8.7818E-02, -9.0129E-02, -8.8960E-02, -8.8285E-02, -8.5550E-02, -7.9487E-02, -7.3788E-02, -6.6373E-02, -5.7000E-02, -4.5708E-02, -3.2333E-02, -1.8931E-02, -4.5384E-03, 1.0631E-02, 2.6253E-02, 4.1982E-02, 5.7584E-02, 7.0767E-02, 8.2261E-02, 9.2030E-02, 1.0027E-01, 1.0369E-01, 1.0489E-01, 1.0077E-01, 9.4425E-02, 8.3718E-02, 6.9059E-02, 5.1374E-02, 3.1040E-02, 1.1055E-02, -5.0997E-03, -1.0751E-02, -1.1608E-02, -4.1497E-02, -5.8424E-02, -5.8730E-02, -4.2288E-02, -1.3921E-02, 1.8135E-02, 5.0399E-02, 7.9162E-02, 1.0472E-01, 1.2078E-01, 1.3175E-01, 1.3044E-01, 1.2448E-01, 1.1298E-01, 9.5729E-02, 6.9944E-02, 4.3317E-02, 1.6612E-02, -9.0493E-03, -3.2492E-02, -5.3057E-02, -7.4192E-02, -8.8730E-02, -9.7519E-02, -1.0090E-01, -1.0004E-01, -1.0137E-01, -9.4199E-02, -8.3009E-02, -7.4215E-02, -5.8870E-02, -4.1686E-02, -2.6940E-02, -1.0183E-02, 4.7403E-03, 2.0031E-02, 3.3876E-02, 4.6223E-02, 5.7492E-02, 6.7493E-02, 7.4221E-02, 8.0422E-02, 8.5075E-02, 8.4909E-02, 8.4108E-02, 8.1289E-02, 7.2857E-02, 6.3279E-02, 5.1226E-02, 3.5946E-02, 1.4927E-02, -7.8408E-03, -3.2714E-02, -5.9234E-02, -8.6278E-02, -1.1213E-01, -1.3105E-01, -1.3678E-01, -1.2019E-01, -6.8706E-02, 3.0595E-02, 1.7353E-01, 2.5477E-01, -3.1741E-01, 2.5477E-01, 1.7353E-01, 3.0595E-02, -6.8706E-02, -1.2019E-01, -1.3678E-01, -1.3105E-01, -1.1213E-01, -8.6278E-02, -5.9234E-02, -3.2714E-02, -7.8408E-03, 1.4927E-02, 3.5946E-02, 5.1226E-02, 6.3279E-02, 7.2857E-02, 8.1289E-02, 8.4108E-02, 8.4909E-02, 8.5075E-02, 8.0422E-02, 7.4221E-02, 6.7493E-02, 5.7492E-02, 4.6223E-02, 3.3876E-02, 2.0031E-02, 4.7403E-03, -1.0183E-02, -2.6940E-02, -4.1686E-02, -5.8870E-02, -7.4215E-02, -8.3009E-02, -9.4199E-02, -1.0137E-01, -1.0004E-01, -1.0090E-01, -9.7519E-02, -8.8730E-02, -7.4192E-02, -5.3057E-02, -3.2492E-02, -9.0493E-03, 1.6612E-02, 4.3317E-02, 6.9944E-02, 9.5729E-02, 1.1298E-01, 1.2448E-01, 1.3044E-01, 1.3175E-01, 1.2078E-01, 1.0472E-01, 7.9162E-02, 5.0399E-02, 1.8135E-02, -1.3921E-02, -4.2288E-02, -5.8730E-02, -5.8424E-02, -4.1497E-02, -1.1608E-02, -5.2558E-03, 5.7421E-04, 2.8679E-02, 7.1520E-02, 1.2013E-01, 1.6229E-01, 1.9293E-01, 2.0637E-01, 2.0044E-01, 1.8468E-01, 1.4803E-01, 1.0465E-01, 5.1659E-02, -8.6808E-04, -5.0693E-02, -9.4777E-02, -1.2117E-01, -1.3936E-01, -1.4732E-01, -1.4474E-01, -1.3277E-01, -1.1422E-01, -9.7506E-02, -6.9057E-02, -3.5777E-02, -2.2474E-03, 2.8151E-02, 5.9320E-02, 8.1875E-02, 9.6887E-02, 1.1571E-01, 1.1865E-01, 1.1298E-01, 1.1389E-01, 1.0079E-01, 9.4466E-02, 7.5018E-02, 6.2853E-02, 4.1418E-02, 2.7969E-02, 1.7640E-02, -1.4046E-03, -1.3750E-02, -2.3031E-02, -3.7013E-02, -4.5500E-02, -5.0654E-02, -5.6221E-02, -5.7448E-02, -5.5244E-02, -5.0687E-02, -4.4902E-02, -3.7034E-02, -2.7487E-02, -1.7137E-02, -7.0352E-03, 2.1131E-03, 9.2634E-03, 1.3798E-02, 1.5012E-02, 1.2549E-02, 6.9539E-03, 3.3534E-04, -3.2169E-03, 3.8893E-05, -3.2169E-03, 3.3534E-04, 6.9539E-03, 1.2549E-02, 1.5012E-02, 1.3798E-02, 9.2634E-03, 2.1131E-03, -7.0352E-03, -1.7137E-02, -2.7487E-02, -3.7034E-02, -4.4902E-02, -5.0687E-02, -5.5244E-02, -5.7448E-02, -5.6221E-02, -5.0654E-02, -4.5500E-02, -3.7013E-02, -2.3031E-02, -1.3750E-02, -1.4046E-03, 1.7640E-02, 2.7969E-02, 4.1418E-02, 6.2853E-02, 7.5018E-02, 9.4466E-02, 1.0079E-01, 1.1389E-01, 1.1298E-01, 1.1865E-01, 1.1571E-01, 9.6887E-02, 8.1875E-02, 5.9320E-02, 2.8151E-02, -2.2474E-03, -3.5777E-02, -6.9057E-02, -9.7506E-02, -1.1422E-01, -1.3277E-01, -1.4474E-01, -1.4732E-01, -1.3936E-01, -1.2117E-01, -9.4777E-02, -5.0693E-02, -8.6808E-04, 5.1659E-02, 1.0465E-01, 1.4803E-01, 1.8468E-01, 2.0044E-01, 2.0637E-01, 1.9293E-01, 1.6229E-01, 1.2013E-01, 7.1520E-02, 2.8679E-02, 5.7421E-04, -5.2558E-03, -3.9837E-02, -3.7920E-02, 9.3629E-03, 6.9318E-02, 1.1881E-01, 1.4046E-01, 1.3889E-01, 1.1331E-01, 6.9891E-02, 2.1323E-02, -3.0613E-02, -7.8570E-02, -1.0936E-01, -1.3006E-01, -1.3699E-01, -1.2800E-01, -9.2327E-02, -5.3098E-02, -1.2135E-02, 2.7024E-02, 6.0740E-02, 8.6744E-02, 1.1452E-01, 1.2451E-01, 1.2063E-01, 1.0564E-01, 8.4358E-02, 6.7550E-02, 3.9803E-02, 1.0865E-02, -1.5696E-02, -4.0295E-02, -5.8812E-02, -7.8366E-02, -8.5841E-02, -9.6379E-02, -9.2088E-02, -9.2549E-02, -7.9259E-02, -7.2315E-02, -6.6029E-02, -4.5276E-02, -3.0431E-02, -1.6668E-02, 6.3617E-03, 2.4718E-02, 4.1191E-02, 5.8795E-02, 7.3061E-02, 8.3723E-02, 9.0979E-02, 9.1335E-02, 8.7853E-02, 7.7802E-02, 5.9924E-02, 3.3282E-02, -5.8637E-03, -4.9998E-02, -9.5989E-02, -1.3414E-01, -1.4457E-01, -9.4312E-02, 5.3627E-02, 2.4785E-01, -1.8494E-01, 2.4785E-01, 5.3627E-02, -9.4312E-02, -1.4457E-01, -1.3414E-01, -9.5989E-02, -4.9998E-02, -5.8637E-03, 3.3282E-02, 5.9924E-02, 7.7802E-02, 8.7853E-02, 9.1335E-02, 9.0979E-02, 8.3723E-02, 7.3061E-02, 5.8795E-02, 4.1191E-02, 2.4718E-02, 6.3617E-03, -1.6668E-02, -3.0431E-02, -4.5276E-02, -6.6029E-02, -7.2315E-02, -7.9259E-02, -9.2549E-02, -9.2088E-02, -9.6379E-02, -8.5841E-02, -7.8366E-02, -5.8812E-02, -4.0295E-02, -1.5696E-02, 1.0865E-02, 3.9803E-02, 6.7550E-02, 8.4358E-02, 1.0564E-01, 1.2063E-01, 1.2451E-01, 1.1452E-01, 8.6744E-02, 6.0740E-02, 2.7024E-02, -1.2135E-02, -5.3098E-02, -9.2327E-02, -1.2800E-01, -1.3699E-01, -1.3006E-01, -1.0936E-01, -7.8570E-02, -3.0613E-02, 2.1323E-02, 6.9891E-02, 1.1331E-01, 1.3889E-01, 1.4046E-01, 1.1881E-01, 6.9318E-02, 9.3629E-03, -3.7920E-02, -3.9837E-02); \n//The first 8 rows of the V matrix: \nfloat V[1032] = float[](-6.1416E-03, -1.5629E-02, -2.7467E-02, -4.0930E-02, -5.5891E-02, -7.2172E-02, -8.9315E-02, -1.0730E-01, -1.2606E-01, -1.4533E-01, -1.6540E-01, -1.8598E-01, -2.0729E-01, -2.2908E-01, -2.5140E-01, -2.7426E-01, -2.9781E-01, -3.2185E-01, -3.4639E-01, -3.7145E-01, -3.9703E-01, -4.2312E-01, -4.4967E-01, -4.7682E-01, -5.0455E-01, -5.3286E-01, -5.6175E-01, -5.9117E-01, -6.2125E-01, -6.5195E-01, -6.8326E-01, -7.1527E-01, -7.4796E-01, -7.8132E-01, -8.1544E-01, -8.5028E-01, -8.8592E-01, -9.2236E-01, -9.5965E-01, -9.9781E-01, -1.0369E+00, -1.0769E+00, -1.1179E+00, -1.1600E+00, -1.2031E+00, -1.2474E+00, -1.2929E+00, -1.3396E+00, -1.3876E+00, -1.4371E+00, -1.4880E+00, -1.5404E+00, -1.5945E+00, -1.6504E+00, -1.7081E+00, -1.7679E+00, -1.8298E+00, -1.8941E+00, -1.9609E+00, -2.0305E+00, -2.1032E+00, -2.1794E+00, -2.2597E+00, -2.3450E+00, -2.4366E+00, -2.3450E+00, -2.2597E+00, -2.1794E+00, -2.1032E+00, -2.0305E+00, -1.9609E+00, -1.8941E+00, -1.8298E+00, -1.7679E+00, -1.7081E+00, -1.6504E+00, -1.5945E+00, -1.5404E+00, -1.4880E+00, -1.4371E+00, -1.3876E+00, -1.3396E+00, -1.2929E+00, -1.2474E+00, -1.2031E+00, -1.1600E+00, -1.1179E+00, -1.0769E+00, -1.0369E+00, -9.9781E-01, -9.5965E-01, -9.2236E-01, -8.8592E-01, -8.5028E-01, -8.1544E-01, -7.8132E-01, -7.4796E-01, -7.1527E-01, -6.8326E-01, -6.5195E-01, -6.2125E-01, -5.9117E-01, -5.6175E-01, -5.3286E-01, -5.0455E-01, -4.7682E-01, -4.4967E-01, -4.2312E-01, -3.9703E-01, -3.7145E-01, -3.4639E-01, -3.2185E-01, -2.9781E-01, -2.7426E-01, -2.5140E-01, -2.2908E-01, -2.0729E-01, -1.8598E-01, -1.6540E-01, -1.4533E-01, -1.2606E-01, -1.0730E-01, -8.9315E-02, -7.2172E-02, -5.5891E-02, -4.0930E-02, -2.7467E-02, -1.5629E-02, -6.1416E-03, 5.6056E-03, 1.0267E-02, 1.3407E-02, 1.5251E-02, 1.5763E-02, 1.5040E-02, 1.3592E-02, 1.1442E-02, 8.6706E-03, 5.6215E-03, 1.9644E-03, -1.9350E-03, -6.3340E-03, -1.0903E-02, -1.5665E-02, -2.0627E-02, -2.5927E-02, -3.1310E-02, -3.6774E-02, -4.2304E-02, -4.7880E-02, -5.3472E-02, -5.9018E-02, -6.4606E-02, -7.0191E-02, -7.5743E-02, -8.1236E-02, -8.6642E-02, -9.1962E-02, -9.7169E-02, -1.0225E-01, -1.0716E-01, -1.1190E-01, -1.1644E-01, -1.2074E-01, -1.2479E-01, -1.2851E-01, -1.3192E-01, -1.3493E-01, -1.3753E-01, -1.3964E-01, -1.4117E-01, -1.4210E-01, -1.4233E-01, -1.4171E-01, -1.4020E-01, -1.3766E-01, -1.3389E-01, -1.2879E-01, -1.2213E-01, -1.1368E-01, -1.0313E-01, -9.0193E-02, -7.4466E-02, -5.5464E-02, -3.2591E-02, -5.1015E-03, 2.7904E-02, 6.7624E-02, 1.1565E-01, 1.7415E-01, 2.4630E-01, 3.3704E-01, 4.5509E-01, 6.1910E-01, 4.5509E-01, 3.3704E-01, 2.4630E-01, 1.7415E-01, 1.1565E-01, 6.7624E-02, 2.7904E-02, -5.1015E-03, -3.2591E-02, -5.5464E-02, -7.4466E-02, -9.0193E-02, -1.0313E-01, -1.1368E-01, -1.2213E-01, -1.2879E-01, -1.3389E-01, -1.3766E-01, -1.4020E-01, -1.4171E-01, -1.4233E-01, -1.4210E-01, -1.4117E-01, -1.3964E-01, -1.3753E-01, -1.3493E-01, -1.3192E-01, -1.2851E-01, -1.2479E-01, -1.2074E-01, -1.1644E-01, -1.1190E-01, -1.0716E-01, -1.0225E-01, -9.7169E-02, -9.1962E-02, -8.6642E-02, -8.1236E-02, -7.5743E-02, -7.0191E-02, -6.4606E-02, -5.9018E-02, -5.3472E-02, -4.7880E-02, -4.2304E-02, -3.6774E-02, -3.1310E-02, -2.5927E-02, -2.0627E-02, -1.5665E-02, -1.0903E-02, -6.3340E-03, -1.9350E-03, 1.9644E-03, 5.6215E-03, 8.6706E-03, 1.1442E-02, 1.3592E-02, 1.5040E-02, 1.5763E-02, 1.5251E-02, 1.3407E-02, 1.0267E-02, 5.6056E-03, 1.4468E-03, 4.9706E-03, 8.6735E-03, 1.1924E-02, 1.4393E-02, 1.5937E-02, 1.6870E-02, 1.7166E-02, 1.6873E-02, 1.6319E-02, 1.5168E-02, 1.3792E-02, 1.1936E-02, 9.9384E-03, 7.7839E-03, 5.4736E-03, 2.9194E-03, 3.4391E-04, -2.2372E-03, -4.8000E-03, -7.3168E-03, -9.7660E-03, -1.2169E-02, -1.4455E-02, -1.6612E-02, -1.8623E-02, -2.0486E-02, -2.2299E-02, -2.3862E-02, -2.5227E-02, -2.6526E-02, -2.7519E-02, -2.8281E-02, -2.8960E-02, -2.9324E-02, -2.9571E-02, -2.9470E-02, -2.9219E-02, -2.8604E-02, -2.7808E-02, -2.6747E-02, -2.5231E-02, -2.3448E-02, -2.1317E-02, -1.8666E-02, -1.5655E-02, -1.2207E-02, -8.1926E-03, -3.7252E-03, 1.2431E-03, 6.7467E-03, 1.2839E-02, 1.9404E-02, 2.6391E-02, 3.3699E-02, 4.1137E-02, 4.8400E-02, 5.4911E-02, 5.9798E-02, 6.1612E-02, 5.7865E-02, 4.4025E-02, 1.1070E-02, -6.1534E-02, -2.2957E-01, -6.1534E-02, 1.1070E-02, 4.4025E-02, 5.7865E-02, 6.1612E-02, 5.9798E-02, 5.4911E-02, 4.8400E-02, 4.1137E-02, 3.3699E-02, 2.6391E-02, 1.9404E-02, 1.2839E-02, 6.7467E-03, 1.2431E-03, -3.7252E-03, -8.1926E-03, -1.2207E-02, -1.5655E-02, -1.8666E-02, -2.1317E-02, -2.3448E-02, -2.5231E-02, -2.6747E-02, -2.7808E-02, -2.8604E-02, -2.9219E-02, -2.9470E-02, -2.9571E-02, -2.9324E-02, -2.8960E-02, -2.8281E-02, -2.7519E-02, -2.6526E-02, -2.5227E-02, -2.3862E-02, -2.2299E-02, -2.0486E-02, -1.8623E-02, -1.6612E-02, -1.4455E-02, -1.2169E-02, -9.7660E-03, -7.3168E-03, -4.8000E-03, -2.2372E-03, 3.4391E-04, 2.9194E-03, 5.4736E-03, 7.7839E-03, 9.9384E-03, 1.1936E-02, 1.3792E-02, 1.5168E-02, 1.6319E-02, 1.6873E-02, 1.7166E-02, 1.6870E-02, 1.5937E-02, 1.4393E-02, 1.1924E-02, 8.6735E-03, 4.9706E-03, 1.4468E-03, 9.9157E-05, -5.8497E-04, -2.4052E-03, -5.1791E-03, -8.8292E-03, -1.3103E-02, -1.7604E-02, -2.2168E-02, -2.6608E-02, -3.0933E-02, -3.4795E-02, -3.8404E-02, -4.1249E-02, -4.3766E-02, -4.5840E-02, -4.7373E-02, -4.7716E-02, -4.7681E-02, -4.7190E-02, -4.6230E-02, -4.4830E-02, -4.3093E-02, -4.1574E-02, -3.9273E-02, -3.6467E-02, -3.3294E-02, -2.9918E-02, -2.6839E-02, -2.3277E-02, -1.9569E-02, -1.6176E-02, -1.2469E-02, -8.7631E-03, -5.4116E-03, -2.0156E-03, 1.0332E-03, 4.0533E-03, 6.7159E-03, 9.2485E-03, 1.1405E-02, 1.3246E-02, 1.4919E-02, 1.6223E-02, 1.7199E-02, 1.7937E-02, 1.8312E-02, 1.8348E-02, 1.8096E-02, 1.7499E-02, 1.6578E-02, 1.5364E-02, 1.3897E-02, 1.2185E-02, 1.0272E-02, 8.2171E-03, 6.0908E-03, 3.9768E-03, 1.9668E-03, 1.7111E-04, -1.2828E-03, -2.2581E-03, -2.6244E-03, -2.2964E-03, -1.3296E-03, -1.9113E-04, -1.3296E-03, -2.2964E-03, -2.6244E-03, -2.2581E-03, -1.2828E-03, 1.7111E-04, 1.9668E-03, 3.9768E-03, 6.0908E-03, 8.2171E-03, 1.0272E-02, 1.2185E-02, 1.3897E-02, 1.5364E-02, 1.6578E-02, 1.7499E-02, 1.8096E-02, 1.8348E-02, 1.8312E-02, 1.7937E-02, 1.7199E-02, 1.6223E-02, 1.4919E-02, 1.3246E-02, 1.1405E-02, 9.2485E-03, 6.7159E-03, 4.0533E-03, 1.0332E-03, -2.0156E-03, -5.4116E-03, -8.7631E-03, -1.2469E-02, -1.6176E-02, -1.9569E-02, -2.3277E-02, -2.6839E-02, -2.9918E-02, -3.3294E-02, -3.6467E-02, -3.9273E-02, -4.1574E-02, -4.3093E-02, -4.4830E-02, -4.6230E-02, -4.7190E-02, -4.7681E-02, -4.7716E-02, -4.7373E-02, -4.5840E-02, -4.3766E-02, -4.1249E-02, -3.8404E-02, -3.4795E-02, -3.0933E-02, -2.6608E-02, -2.2168E-02, -1.7604E-02, -1.3103E-02, -8.8292E-03, -5.1791E-03, -2.4052E-03, -5.8497E-04, 9.9157E-05, -1.5555E-03, -7.3785E-04, 1.5995E-03, 4.4910E-03, 7.4330E-03, 9.9918E-03, 1.2113E-02, 1.3662E-02, 1.4581E-02, 1.5176E-02, 1.5002E-02, 1.4507E-02, 1.3315E-02, 1.1902E-02, 1.0239E-02, 8.3315E-03, 6.0741E-03, 3.7984E-03, 1.5382E-03, -6.5664E-04, -2.7391E-03, -4.6782E-03, -6.6133E-03, -8.2471E-03, -9.6033E-03, -1.0676E-02, -1.1501E-02, -1.2378E-02, -1.2774E-02, -1.2871E-02, -1.3040E-02, -1.2706E-02, -1.2111E-02, -1.1605E-02, -1.0728E-02, -9.9166E-03, -8.7581E-03, -7.6578E-03, -6.2841E-03, -4.9716E-03, -3.6230E-03, -1.9997E-03, -4.0923E-04, 1.2187E-03, 3.0284E-03, 4.8059E-03, 6.5721E-03, 8.3727E-03, 1.0078E-02, 1.1656E-02, 1.3056E-02, 1.4201E-02, 1.4981E-02, 1.5258E-02, 1.4861E-02, 1.3589E-02, 1.1158E-02, 7.3243E-03, 1.7669E-03, -5.7451E-03, -1.5129E-02, -2.5263E-02, -3.1753E-02, -1.9063E-02, 6.9999E-02, -1.9063E-02, -3.1753E-02, -2.5263E-02, -1.5129E-02, -5.7451E-03, 1.7669E-03, 7.3243E-03, 1.1158E-02, 1.3589E-02, 1.4861E-02, 1.5258E-02, 1.4981E-02, 1.4201E-02, 1.3056E-02, 1.1656E-02, 1.0078E-02, 8.3727E-03, 6.5721E-03, 4.8059E-03, 3.0284E-03, 1.2187E-03, -4.0923E-04, -1.9997E-03, -3.6230E-03, -4.9716E-03, -6.2841E-03, -7.6578E-03, -8.7581E-03, -9.9166E-03, -1.0728E-02, -1.1605E-02, -1.2111E-02, -1.2706E-02, -1.3040E-02, -1.2871E-02, -1.2774E-02, -1.2378E-02, -1.1501E-02, -1.0676E-02, -9.6033E-03, -8.2471E-03, -6.6133E-03, -4.6782E-03, -2.7391E-03, -6.5664E-04, 1.5382E-03, 3.7984E-03, 6.0741E-03, 8.3315E-03, 1.0239E-02, 1.1902E-02, 1.3315E-02, 1.4507E-02, 1.5002E-02, 1.5176E-02, 1.4581E-02, 1.3662E-02, 1.2113E-02, 9.9918E-03, 7.4330E-03, 4.4910E-03, 1.5995E-03, -7.3785E-04, -1.5555E-03, -7.8570E-04, -2.8087E-03, -3.9543E-03, -3.9750E-03, -2.8622E-03, -9.4219E-04, 1.2274E-03, 3.4112E-03, 5.3580E-03, 7.0877E-03, 8.1747E-03, 8.9175E-03, 8.8287E-03, 8.4249E-03, 7.6468E-03, 6.4793E-03, 4.7340E-03, 2.9318E-03, 1.1243E-03, -6.1249E-04, -2.1992E-03, -3.5911E-03, -5.0216E-03, -6.0056E-03, -6.6005E-03, -6.8294E-03, -6.7713E-03, -6.8613E-03, -6.3757E-03, -5.6183E-03, -5.0231E-03, -3.9845E-03, -2.8215E-03, -1.8234E-03, -6.8922E-04, 3.2084E-04, 1.3558E-03, 2.2928E-03, 3.1285E-03, 3.8913E-03, 4.5682E-03, 5.0235E-03, 5.4432E-03, 5.7582E-03, 5.7469E-03, 5.6927E-03, 5.5019E-03, 4.9312E-03, 4.2829E-03, 3.4672E-03, 2.4329E-03, 1.0103E-03, -5.3070E-04, -2.2142E-03, -4.0092E-03, -5.8396E-03, -7.5892E-03, -8.8696E-03, -9.2575E-03, -8.1346E-03, -4.6503E-03, 2.0708E-03, 1.1745E-02, 1.7244E-02, -2.1483E-02, 1.7244E-02, 1.1745E-02, 2.0708E-03, -4.6503E-03, -8.1346E-03, -9.2575E-03, -8.8696E-03, -7.5892E-03, -5.8396E-03, -4.0092E-03, -2.2142E-03, -5.3070E-04, 1.0103E-03, 2.4329E-03, 3.4672E-03, 4.2829E-03, 4.9312E-03, 5.5019E-03, 5.6927E-03, 5.7469E-03, 5.7582E-03, 5.4432E-03, 5.0235E-03, 4.5682E-03, 3.8913E-03, 3.1285E-03, 2.2928E-03, 1.3558E-03, 3.2084E-04, -6.8922E-04, -1.8234E-03, -2.8215E-03, -3.9845E-03, -5.0231E-03, -5.6183E-03, -6.3757E-03, -6.8613E-03, -6.7713E-03, -6.8294E-03, -6.6005E-03, -6.0056E-03, -5.0216E-03, -3.5911E-03, -2.1992E-03, -6.1249E-04, 1.1243E-03, 2.9318E-03, 4.7340E-03, 6.4793E-03, 7.6468E-03, 8.4249E-03, 8.8287E-03, 8.9175E-03, 8.1747E-03, 7.0877E-03, 5.3580E-03, 3.4112E-03, 1.2274E-03, -9.4219E-04, -2.8622E-03, -3.9750E-03, -3.9543E-03, -2.8087E-03, -7.8570E-04, 2.4269E-04, -2.6514E-05, -1.3243E-03, -3.3024E-03, -5.5470E-03, -7.4937E-03, -8.9087E-03, -9.5292E-03, -9.2554E-03, -8.5275E-03, -6.8351E-03, -4.8321E-03, -2.3854E-03, 4.0083E-05, 2.3408E-03, 4.3764E-03, 5.5948E-03, 6.4352E-03, 6.8024E-03, 6.6834E-03, 6.1306E-03, 5.2743E-03, 4.5024E-03, 3.1887E-03, 1.6520E-03, 1.0377E-04, -1.2999E-03, -2.7391E-03, -3.7806E-03, -4.4738E-03, -5.3431E-03, -5.4786E-03, -5.2170E-03, -5.2591E-03, -4.6542E-03, -4.3620E-03, -3.4640E-03, -2.9022E-03, -1.9125E-03, -1.2915E-03, -8.1451E-04, 6.4859E-05, 6.3491E-04, 1.0635E-03, 1.7091E-03, 2.1010E-03, 2.3390E-03, 2.5960E-03, 2.6527E-03, 2.5509E-03, 2.3405E-03, 2.0733E-03, 1.7100E-03, 1.2692E-03, 7.9129E-04, 3.2485E-04, -9.7573E-05, -4.2774E-04, -6.3713E-04, -6.9320E-04, -5.7947E-04, -3.2110E-04, -1.5484E-05, 1.4854E-04, -1.7959E-06, 1.4854E-04, -1.5484E-05, -3.2110E-04, -5.7947E-04, -6.9320E-04, -6.3713E-04, -4.2774E-04, -9.7573E-05, 3.2485E-04, 7.9129E-04, 1.2692E-03, 1.7100E-03, 2.0733E-03, 2.3405E-03, 2.5509E-03, 2.6527E-03, 2.5960E-03, 2.3390E-03, 2.1010E-03, 1.7091E-03, 1.0635E-03, 6.3491E-04, 6.4859E-05, -8.1451E-04, -1.2915E-03, -1.9125E-03, -2.9022E-03, -3.4640E-03, -4.3620E-03, -4.6542E-03, -5.2591E-03, -5.2170E-03, -5.4786E-03, -5.3431E-03, -4.4738E-03, -3.7806E-03, -2.7391E-03, -1.2999E-03, 1.0377E-04, 1.6520E-03, 3.1887E-03, 4.5024E-03, 5.2743E-03, 6.1306E-03, 6.6834E-03, 6.8024E-03, 6.4352E-03, 5.5948E-03, 4.3764E-03, 2.3408E-03, 4.0083E-05, -2.3854E-03, -4.8321E-03, -6.8351E-03, -8.5275E-03, -9.2554E-03, -9.5292E-03, -8.9087E-03, -7.4937E-03, -5.5470E-03, -3.3024E-03, -1.3243E-03, -2.6514E-05, 2.4269E-04, -1.3155E-03, -1.2522E-03, 3.0919E-04, 2.2891E-03, 3.9235E-03, 4.6384E-03, 4.5866E-03, 3.7419E-03, 2.3080E-03, 7.0413E-04, -1.0109E-03, -2.5946E-03, -3.6113E-03, -4.2949E-03, -4.5236E-03, -4.2269E-03, -3.0489E-03, -1.7534E-03, -4.0073E-04, 8.9239E-04, 2.0058E-03, 2.8645E-03, 3.7819E-03, 4.1118E-03, 3.9835E-03, 3.4885E-03, 2.7857E-03, 2.2307E-03, 1.3144E-03, 3.5880E-04, -5.1833E-04, -1.3306E-03, -1.9421E-03, -2.5879E-03, -2.8347E-03, -3.1827E-03, -3.0410E-03, -3.0562E-03, -2.6173E-03, -2.3880E-03, -2.1805E-03, -1.4951E-03, -1.0049E-03, -5.5042E-04, 2.1008E-04, 8.1625E-04, 1.3602E-03, 1.9416E-03, 2.4127E-03, 2.7647E-03, 3.0044E-03, 3.0161E-03, 2.9011E-03, 2.5692E-03, 1.9788E-03, 1.0991E-03, -1.9364E-04, -1.6511E-03, -3.1698E-03, -4.4296E-03, -4.7742E-03, -3.1144E-03, 1.7709E-03, 8.1848E-03, -6.1073E-03, 8.1848E-03, 1.7709E-03, -3.1144E-03, -4.7742E-03, -4.4296E-03, -3.1698E-03, -1.6511E-03, -1.9364E-04, 1.0991E-03, 1.9788E-03, 2.5692E-03, 2.9011E-03, 3.0161E-03, 3.0044E-03, 2.7647E-03, 2.4127E-03, 1.9416E-03, 1.3602E-03, 8.1625E-04, 2.1008E-04, -5.5042E-04, -1.0049E-03, -1.4951E-03, -2.1805E-03, -2.3880E-03, -2.6173E-03, -3.0562E-03, -3.0410E-03, -3.1827E-03, -2.8347E-03, -2.5879E-03, -1.9421E-03, -1.3306E-03, -5.1833E-04, 3.5880E-04, 1.3144E-03, 2.2307E-03, 2.7857E-03, 3.4885E-03, 3.9835E-03, 4.1118E-03, 3.7819E-03, 2.8645E-03, 2.0058E-03, 8.9239E-04, -4.0073E-04, -1.7534E-03, -3.0489E-03, -4.2269E-03, -4.5236E-03, -4.2949E-03, -3.6113E-03, -2.5946E-03, -1.0109E-03, 7.0413E-04, 2.3080E-03, 3.7419E-03, 4.5866E-03, 4.6384E-03, 3.9235E-03, 2.2891E-03, 3.0919E-04, -1.2522E-03, -1.3155E-03); \n//center of the convolution \nint Nc = 64; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 129;\n\n\nfloat pack2(vec2 a)\n{\n    return uintBitsToFloat(packHalf2x16(a));\n}\n\nvec2 unpack2(float packed)\n{\n    return unpackHalf2x16(floatBitsToUint(packed));\n}\n\nivec2 wrap(ivec2 p, ivec2 res)\n{\n    return (p + res)%res;\n}\n", "buffer_a_code": "// Subtract pressure gradient to ensure zero divergence.\n\n#define PressureTexture iChannel1\n#define VelocityTexture iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n    \n    float x0 = texture(PressureTexture, uv - vec2(inverseResolution.x, 0)).x;\n    float x1 = texture(PressureTexture, uv + vec2(inverseResolution.x, 0)).x;\n    float y0 = texture(PressureTexture, uv - vec2(0, inverseResolution.y)).x;\n    float y1 = texture(PressureTexture, uv + vec2(0, inverseResolution.y)).x;\n    vec2 pressureGradient = -(vec2(x1, y1) - vec2(x0, y0)) * HELMHOLTZ_DECOMP_FACTOR;\n    vec4 oldV = texture(VelocityTexture, uv);\n    \n    fragColor = vec4(oldV.xy - pressureGradient, 0.0, oldV.w);\n    \n    ivec2 p = ivec2(fragCoord.xy);\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    fragColor.z = texelFetch(PressureTexture, wrap(p + ivec2(1,0),resol), 0).x + \n                  texelFetch(PressureTexture, wrap(p - ivec2(1,0),resol), 0).x + \n                  texelFetch(PressureTexture, wrap(p + ivec2(0,1),resol), 0).x +\n                  texelFetch(PressureTexture, wrap(p - ivec2(0,1),resol), 0).x - \n                  4.0*texelFetch(PressureTexture, p, 0).x;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//https://www.shadertoy.com/view/ldd3WS\n// Advection & force\n\n// Magic force within a rectangle.\nconst vec2 Force = vec2(3000.0, 0.0);\nconst vec2 ForceAreaMin = vec2(0.0, 0.2); \nconst vec2 ForceAreaMax = vec2(0.06, 0.8);\n\n// Circular barrier.\nconst vec2 BarrierPosition = vec2(0.2, 0.5);\nconst float BarrierRadiusSq = 0.02;\n\n#define VelocityTexture iChannel0\n\n//https://www.shadertoy.com/view/MllSzX\n//=======================================================================================\n#define c_textureSize iResolution.xy\n#define c_onePixel  (1.0 / c_textureSize)\n#define c_twoPixels  (2.0 / c_textureSize)\n\nvec4 CubicHermite (vec4 A, vec4 B, vec4 C, vec4 D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec4 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec4 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec4 c = -A/2.0 + C/2.0;\n   \tvec4 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n//=======================================================================================\nvec4 BicubicHermiteTextureSample (vec2 P)\n{\n    vec2 pixel = P * iResolution.xy + 0.5;\n    \n    vec2 frac = fract(pixel);\n    pixel = floor(pixel) / iResolution.xy - vec2(c_onePixel/2.0);\n    \n    vec4 C00 = texture(iChannel0, pixel + c_onePixel*vec2(-1.0 ,-1.0));\n    vec4 C10 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        ,-1));\n    vec4 C20 = texture(iChannel0, pixel + c_onePixel*vec2( 1 ,-1));\n    vec4 C30 = texture(iChannel0, pixel + c_onePixel*vec2( 2,-1));\n    \n    vec4 C01 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 0.0));\n    vec4 C11 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 0.0));\n    vec4 C21 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 0.0));\n    vec4 C31 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 0.0));    \n    \n    vec4 C02 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 1));\n    vec4 C12 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 1));\n    vec4 C22 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 1));\n    vec4 C32 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 1));    \n    \n    vec4 C03 = texture(iChannel0, pixel + c_onePixel*vec2(-1 , 2));\n    vec4 C13 = texture(iChannel0, pixel + c_onePixel*vec2( 0.0        , 2));\n    vec4 C23 = texture(iChannel0, pixel + c_onePixel*vec2( 1 , 2));\n    vec4 C33 = texture(iChannel0, pixel + c_onePixel*vec2( 2, 2));    \n    \n    vec4 CP0X = CubicHermite(C00, C10, C20, C30, frac.x);\n    vec4 CP1X = CubicHermite(C01, C11, C21, C31, frac.x);\n    vec4 CP2X = CubicHermite(C02, C12, C22, C32, frac.x);\n    vec4 CP3X = CubicHermite(C03, C13, C23, C33, frac.x);\n    \n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\nvec4 advectionPass(in vec2 fragCoord)\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 inverseResolution = vec2(1.0) / iResolution.xy;\n    vec2 uv = fragCoord.xy * inverseResolution;\n\n    float dt = 0.01;\n    vec2 v1 = texture(VelocityTexture, uv.xy).xy;\n    vec2 v2 = texture(VelocityTexture, uv.xy - 0.5 * v1 * dt * inverseResolution).xy;\n    vec2 v3 = texture(VelocityTexture, uv.xy - 0.5 * v2 * dt * inverseResolution).xy;\n    vec2 v4 = texture(VelocityTexture, uv.xy - v3 * dt * inverseResolution).xy;\n    vec2 oldVelocity = (1.0 * v1 + 2.0 * v2 + 2.0 * v3 + 1.0 * v4) / 6.0;\n    \n    vec2 samplePos = uv - oldVelocity * dt * inverseResolution;\n    vec4 outputDataL = texture(VelocityTexture, samplePos);\n    vec4 delta =  vec4(1.5, 1.5, 0.0, 0.5)*abs(outputDataL);\n    vec4 outputData = clamp(BicubicHermiteTextureSample(samplePos), outputDataL - delta, outputDataL + delta);\n    vec2 outputVelocity = outputData.xy;\n    \n    // Add force.\n    if(uv.x > ForceAreaMin.x && uv.x < ForceAreaMax.x &&\n       uv.y > ForceAreaMin.y && uv.y < ForceAreaMax.y)\n    {\n    \toutputVelocity += Force * iTimeDelta;\n    }\n    \n   \n\n    // Circle barrier.\n    vec2 toBarrier = BarrierPosition - uv;\n    toBarrier.x *= inverseResolution.y / inverseResolution.x;\n    if(dot(toBarrier, toBarrier) < BarrierRadiusSq)\n    {\n        fragColor = vec4(0.0, 0.0, 999.0, 0.0);\n    }\n    else\n    {\n        fragColor = vec4(outputVelocity, 0.0, outputData.w)*0.999;\n        if(abs(sin(100.0*uv.y)) < 0.15 && abs(uv.x - 0.0) < 0.005)\n            fragColor.w += 1.0;\n    } \n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = advectionPass(fragCoord); \n    \n    float divergence = 0.0;\n    if(fragColor.z > 0.0)\n        divergence = 0.0;\n    else\n    {\n        float x0 = advectionPass(fragCoord - vec2(1,0)).x;\n        float x1 = advectionPass(fragCoord + vec2(1,0)).x;\n        float y0 = advectionPass(fragCoord - vec2(0,1)).y;\n        float y1 = advectionPass(fragCoord + vec2(0,1)).y;\n        divergence = ((x1-x0) + (y1-y0)) * 0.5;\n    }\n    fragColor.z = divergence;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    return texelFetch(iChannel2, p, 0).z;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + PRESSURE_REUSE_FACTOR*getEstimatedDensity(p);\n}\n\n\n//single component convolution pass x\n//first pass of separable poisson filter convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    vec4 sum0 = vec4(0.0);\n    vec4 sum1 = vec4(0.0);\n\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        ivec2 pos = wrap(coord + ivec2(i, 0), resol);\n       \n        float density = getDensityError(pos);\n\n        int id = (i + Nc);\n        //loop over ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum0[j] += density * U[id + 2 * j * N];\n            sum1[j] += density * U[id + (2 * j + 1) * N];\n        }\n    }\n\n    //loop over pairs of ranks\n    for(int j = 0; j < 4; j++)\n    {\n        fragColor[j] = pack2(vec2(sum0[j], sum1[j]));\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    float sum = 0.0;\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = wrap(coord + ivec2(0, i), resol);\n        \n        //wrap around\n        pos.x = (pos.x + resol.x) % resol.x;\n        pos.y = (pos.y + resol.y) % resol.y;\n        \n        vec4 data = texelFetch(iChannel0, pos, 0);\n\n        //loop over pairs of ranks\n        for(int j = 0; j < 4; j++)\n        {\n            vec2 val = unpack2(data[j]);\n            sum += val.x * V[i + Nc + 2 * j * N];\n            sum += val.y * V[i + Nc + (2*j + 1) * N];\n        }\n    }\n\n    //get previous poisson solution\n    float prev = PRESSURE_REUSE_FACTOR*texelFetch(iChannel1, coord, 0).x;\n\n    //add the previous poisson solution to the convolution\n    sum += prev;\n\n    //return the final poisson solution\n    fragColor = vec4(sum);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 71], [73, 73, 109, 109, 535], [537, 537, 569, 673, 726], [728, 728, 773, 773, 1084]], "test": "untested"}
{"id": "DtBXDm", "name": "Sphere of Cubes (Supersampled)", "author": "themorfeus", "description": "See https://youtu.be/A2IAyXc0LuE and https://youtu.be/yrDbD90HXyo for videos on why there appear to be circles all over the sphere.\n\nDerived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n\n\n", "tags": ["raytracing"], "likes": 3, "viewed": 456, "published": 3, "date": "1676137849", "time_retrieved": "2024-07-30T18:10:44.052574", "image_code": "// derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n \n \nconst int supersampling = 2;\nconst int samples = supersampling * supersampling;\n\n \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t, out float t2) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   t2 = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool step_forward(in Ray R, inout float t, inout vec3 roundpoint, out int coord, in float max_t, in float cubeWidth, in float cubesRad){\n    vec3 point = R.Origin + t*R.Dir;\n    vec3 signDir = sign(R.Dir);\n    /// solve for param: point + param*Dir = roundpoint + 0.5*(signDir)*cubeWidth component by component\n    vec3 params = (roundpoint - point + 0.5*signDir*cubeWidth)/R.Dir;\n\n    // find out which wall we hit next\n    if(params.x < params.y){\n        if(params.x < params.z){ coord = 0;}\n        else{ coord = 2;}\n    }\n    else{\n        if(params.y < params.z){ coord = 1;}\n        else{ coord = 2;}\n    }\n    \n    t += params[coord];\n    vec3 move = vec3(0.0,0.0,0.0);\n    move[coord] += cubeWidth;\n    roundpoint += signDir*move;\n\n    if(length(roundpoint) < cubesRad){ \n        roundpoint -= signDir*move; // take a step back to the cube before we hit the solid cube\n        return false; } // we hit a cube \n    if(t > max_t){ coord = 3; \n        return false;\n    }  // meaning that we were tangent to the sphere of cubes and didnt hit anything\n \n    return true; // keep going\n}\n\nfloat mysmoothstep(in float x){\n    float t = clamp(x, 0.0, 1.0);\n    t = 1.0 - pow((1.0 - t),1.5); \n    return t * t * (3.0 - 2.0 * t);\n}\nvec2 uvmap(vec2 pixels)\n{\n\tvec2 uv = pixels / iResolution.xy;\n\tuv = uv * 2.0 - vec2(1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\treturn uv;\n}\n\nfloat f(vec2 pixels)\n{\n\tvec2 uv = uvmap(pixels);\n\tfloat len = length(uv);\n\tif (len < 0.8 && mod(len, 0.1) < 0.0075) return 1.0;\n\telse return 0.0;\n}\nfloat sampleSubpixel(vec2 pixels)\n{\n\tconst int size = 8; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\t\n\tfor (int j = -size; j <= size; j++)\n\t{\n\t\tfor (int i = -size; i <= size; i++)\n\t\t{\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\t\n\treturn 1.0 - (contrb / maxContrb);\n}\n\nvec4 sampleAntialiasedSubpixel(vec2 pixels)\n{\n\treturn vec4(sampleSubpixel(pixels - vec2(1.0 / 3.0, 0)),\n\t\t\t\tsampleSubpixel(pixels),\n\t\t\t\tsampleSubpixel(pixels + vec2(1.0 / 3.0, 0)),\n\t\t\t\t1);\n}\n\nvec4 samplePixel(vec2 uv) {\n   vec2 fragCoord = uv * iResolution.xy;\n   float timeOffset = 60.0;\n   float fr =  (timeOffset / 100.0) + float(iFrame) / 500.0;\n   float time = 1.0 + float(pow(fr, 8.0));\n   float cubeWidth = 1.0/time;\n   //float cubeWidth = 0.2;\n   float sphereRad = 1.0;\n   float cubesRad = sphereRad - cubeWidth*0.5*sqrt(3.0); // cube with center within this rad is contained in sphere\n \n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 green = vec3(0.0,1.0,0.0);\n   vec3 blue = vec3(0.0,0.0,1.0);\n   \n   float beta = 3.14159 / 4.0 + 0.2; //* time; // * time;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera \n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       50.0       \n   );\n \n   Ray R = launch(C, fragCoord);\n   Sphere S = Sphere(vec3(0.0, 0.0, 0.0), sphereRad);\n      \n   float t;\n   float max_t;\n   int coord;\n   \n   vec3 col = vec3(0.0,0.0,0.0);\n   if(intersect_sphere(R,S,t,max_t)) {\n      vec3 point = R.Origin + t*R.Dir;\n      vec3 roundpoint = round(point/cubeWidth)*cubeWidth;\n      \n      bool cont = true;\n      for(int i = 0; i <= 50; i++) { \n          cont = step_forward(R, t, roundpoint, coord, max_t, cubeWidth, cubesRad);\n          if(cont == false){break;}\n      }\n      if(coord <= 2){ // hit a solid cube\n          col[coord] = 1.0;\n          \n          vec3 point = R.Origin + t*R.Dir;\n          vec3 signOctant = -sign(point);\n          point -= roundpoint; // now relative to the cube center we just hit\n          point *= signOctant; // now moving in the positive direction sends us to potential solid cubes\n          point /= cubeWidth; // now in (-0.5,0.5)^2\n          \n          float brightness = 1.0;\n          float d = 0.3; // ambient occlusion darkness amount\n          \n          vec3 move1 = vec3(0.0,0.0,0.0);\n          move1[(coord + 1) % 3] += cubeWidth;\n          vec3 neighbour1 = signOctant*roundpoint + move1;\n          vec3 move2 = vec3(0.0,0.0,0.0);\n          move2[(coord + 2) % 3] += cubeWidth;\n          vec3 neighbour2 = signOctant*roundpoint + move2;\n          vec3 move3 = move1 + move2;\n          vec3 neighbour3 = signOctant*roundpoint + move3;\n          bool n1solid = (length(neighbour1) < cubesRad);\n          bool n2solid = (length(neighbour2) < cubesRad);\n          bool n3solid = (length(neighbour3) < cubesRad);\n          \n          if(n1solid){\n              brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 1) % 3]);\n          }\n          if(n2solid){\n              brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 2) % 3]);\n          }\n          \n          if(n3solid && (!n1solid && !n2solid)){\n              float s1 = mysmoothstep(0.5 - point[(coord + 1) % 3]);\n              float s2 = mysmoothstep(0.5 - point[(coord + 2) % 3]);\n              float foo = 1.0 - (1.0 - s1)*(1.0 - s2);\n              brightness *= (1.0 - d) + d*foo;\n          }\n          \n          col *= brightness;\n          \n          return vec4(col, 1.0);\n      }\n   }\n   \n   return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    vec2 off = 1.0 / float(samples) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    for (int x=0; x<samples; x++) {\n        for (int y=0; y<samples; y++) {\n            sum += samplePixel(pos + vec2(off.x*float(x), off.y*float(y)));\n        }\n    }\n    return sum / float(samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = superSamplePixel(uv);\n}\n \n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 399, 399, 697], [699, 699, 736, 736, 833], [883, 883, 956, 956, 1258], [1260, 1260, 1396, 1396, 2352], [2354, 2354, 2385, 2385, 2492], [2493, 2493, 2518, 2518, 2636], [2638, 2638, 2660, 2660, 2785], [3156, 3156, 3201, 3201, 3346], [3348, 3348, 3375, 3375, 6400], [6402, 6402, 6435, 6435, 6728], [6730, 6730, 6787, 6787, 6870]], "test": "untested"}
{"id": "ctSXDm", "name": "Stellar evolution Poisson filter", "author": "michael0884", "description": "Using poission filters + previous frame as initial assumption to get an almost exact gravity solution in 2D.", "tags": ["particles", "ca"], "likes": 40, "viewed": 490, "published": 3, "date": "1676135761", "time_retrieved": "2024-07-30T18:10:44.984083", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\n\nfloat getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nvec2 getPotentialGrad(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    vec2(texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x - texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x,\n         texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x - texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x);\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + getEstimatedDensity(p);\n}\n\nvec4 Va(vec2 p)\n{\n    return  100.0*Gscale * length(getPotentialGrad(ivec2(p))) * vec4(0,0,0,1) +2.0*pixel(ch0, p).z * vec4(1,1,1,0);\n}\n\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = Va(pos);\n    rho.z *= 5.;\n    //rho.w = tanh(rho.w);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(Va(pos + dx.zy).zw - Va(pos + dx.xy).zw,\n                         Va(pos + dx.yz).zw - Va(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0.5, fluid_rho*2., rho.z),0.1);\n   \n    col.xyz = 0.02*vec3(0.2, 0.5, 1.)*rho.w;\n    col.xyz += vec3(1., 0.7, 0.5)*rho.z;\n   // col.xyz = vec3(100.0)*abs(getDensityError(p));\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define temporal_blurring 0.98\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\n\nconst float Gscale = 0.1;\n\nfloat Pf(float rho)\n{\n    return rho*0.1 + 1.*rho*rho + 0.*pow(rho, 10.); //gas + supernova\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.2)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.6), R*vec2(1.5, 2.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X; //\n    vec2 V; //velocity\n    float M; //mass\n    float I; //angular velocity\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.z;\n    P.I = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M, P.I);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 0.8\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n   \n    //pass 1 - get center of mass\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n    }\n    \n    //moment of inertia\n    float I = 0.;\n    //pass 2 - get velocity and angular momentum\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        vec2 dx = P0.X - P.X;\n      \n\t\tfloat W = P0.I; \n        //relative velocity of this part of the square\n        vec2 rel_V = P0.V + W*vec2(dx.y, -dx.x);\n        float v = length(P.V);\n    \trel_V /= (v > 2.)?v:1.;\n        \n        //add momentum\n        P.V += rel_V*m;\n        //add angular momentum\n        P.I += (dx.x*P0.V.y - dx.y*P0.V.x)*m;\n        //add moment of inertia\n        I += dot(dx, dx)*m;\n    }\n   // I = max(I, 0.1);\n    //normalization\n    if(P.M != 0.)\n    {\n        P.V /= P.M; //get velocity\n        P.I /= I;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, sampler2D chG, inout particle P, vec2 pos)\n{\n    //Compute the forces\n    vec2 F = vec2(0.);\n    float w = 0.;\n    vec3 avgV = vec3(0.);\n    //local gravity potential\n    float lU = pixel(chG, P.X).w;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M*(Pf(P.M) + Pf(P0.M)); \n        //gas pressure\n        F -= 0.5*G(1.*dx)*avgP*dx;\n        \n        //neighbor gravity potential\n        float rU = pixel(chG, P0.X).w;\n        \n        //gas gravity\n        F -= Gscale * 0.025*P.M*dx*clamp(lU - rU, -15., 15.)*G(1.*dx);\n        avgV += G(1.*dx)*vec3(P0.V,1.);\n    }\n    \n    avgV /= avgV.z;\n\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/9.;\n        F += 0.003*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 2.*P.M*N.xy*exp(-abs(N.z));\n    if(N.z < 5.) \n    {\n        //P.X = pos;\n        P.V *= 0.;\n       // P.M = 2.*fluid_rho;\n    }\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n    //angular momentum limit\n    P.I = P.M*clamp(P.I/P.M, -0.5, 0.5);\n}\n\n\n//The first 4 columns of the U matrix: \nfloat U[516] = float[](-4.9245E-04, -1.2542E-03, -2.2055E-03, -3.2879E-03, -4.4913E-03, -5.8014E-03, -7.1809E-03, -8.6281E-03, -1.0138E-02, -1.1689E-02, -1.3303E-02, -1.4958E-02, -1.6672E-02, -1.8424E-02, -2.0218E-02, -2.2054E-02, -2.3945E-02, -2.5875E-02, -2.7843E-02, -2.9853E-02, -3.1902E-02, -3.3991E-02, -3.6115E-02, -3.8287E-02, -4.0503E-02, -4.2764E-02, -4.5069E-02, -4.7415E-02, -4.9812E-02, -5.2256E-02, -5.4747E-02, -5.7291E-02, -5.9888E-02, -6.2535E-02, -6.5240E-02, -6.8001E-02, -7.0822E-02, -7.3704E-02, -7.6651E-02, -7.9663E-02, -8.2744E-02, -8.5899E-02, -8.9129E-02, -9.2437E-02, -9.5830E-02, -9.9308E-02, -1.0288E-01, -1.0654E-01, -1.1031E-01, -1.1418E-01, -1.1816E-01, -1.2226E-01, -1.2649E-01, -1.3085E-01, -1.3535E-01, -1.4000E-01, -1.4483E-01, -1.4982E-01, -1.5502E-01, -1.6043E-01, -1.6607E-01, -1.7198E-01, -1.7820E-01, -1.8480E-01, -1.9188E-01, -1.8480E-01, -1.7820E-01, -1.7198E-01, -1.6607E-01, -1.6043E-01, -1.5502E-01, -1.4982E-01, -1.4483E-01, -1.4000E-01, -1.3535E-01, -1.3085E-01, -1.2649E-01, -1.2226E-01, -1.1816E-01, -1.1418E-01, -1.1031E-01, -1.0654E-01, -1.0288E-01, -9.9308E-02, -9.5830E-02, -9.2437E-02, -8.9129E-02, -8.5899E-02, -8.2744E-02, -7.9663E-02, -7.6651E-02, -7.3704E-02, -7.0822E-02, -6.8001E-02, -6.5240E-02, -6.2535E-02, -5.9888E-02, -5.7291E-02, -5.4747E-02, -5.2256E-02, -4.9812E-02, -4.7415E-02, -4.5069E-02, -4.2764E-02, -4.0503E-02, -3.8287E-02, -3.6115E-02, -3.3991E-02, -3.1902E-02, -2.9853E-02, -2.7843E-02, -2.5875E-02, -2.3945E-02, -2.2054E-02, -2.0218E-02, -1.8424E-02, -1.6672E-02, -1.4958E-02, -1.3303E-02, -1.1689E-02, -1.0138E-02, -8.6281E-03, -7.1809E-03, -5.8014E-03, -4.4913E-03, -3.2879E-03, -2.2055E-03, -1.2542E-03, -4.9245E-04, 3.9763E-03, 7.3026E-03, 9.5644E-03, 1.0917E-02, 1.1331E-02, 1.0875E-02, 9.9083E-03, 8.4459E-03, 6.5456E-03, 4.4496E-03, 1.9250E-03, -7.7003E-04, -3.8168E-03, -6.9826E-03, -1.0283E-02, -1.3724E-02, -1.7401E-02, -2.1135E-02, -2.4924E-02, -2.8759E-02, -3.2622E-02, -3.6495E-02, -4.0335E-02, -4.4201E-02, -4.8062E-02, -5.1898E-02, -5.5689E-02, -5.9418E-02, -6.3084E-02, -6.6668E-02, -7.0161E-02, -7.3537E-02, -7.6782E-02, -7.9895E-02, -8.2831E-02, -8.5595E-02, -8.8133E-02, -9.0449E-02, -9.2482E-02, -9.4232E-02, -9.5648E-02, -9.6656E-02, -9.7247E-02, -9.7353E-02, -9.6875E-02, -9.5782E-02, -9.3976E-02, -9.1327E-02, -8.7758E-02, -8.3124E-02, -7.7257E-02, -6.9949E-02, -6.1007E-02, -5.0154E-02, -3.7058E-02, -2.1316E-02, -2.4165E-03, 2.0250E-02, 4.7498E-02, 8.0410E-02, 1.2047E-01, 1.6982E-01, 2.3182E-01, 3.1239E-01, 4.2417E-01, 3.1239E-01, 2.3182E-01, 1.6982E-01, 1.2047E-01, 8.0410E-02, 4.7498E-02, 2.0250E-02, -2.4165E-03, -2.1316E-02, -3.7058E-02, -5.0154E-02, -6.1007E-02, -6.9949E-02, -7.7257E-02, -8.3124E-02, -8.7758E-02, -9.1327E-02, -9.3976E-02, -9.5782E-02, -9.6875E-02, -9.7353E-02, -9.7247E-02, -9.6656E-02, -9.5648E-02, -9.4232E-02, -9.2482E-02, -9.0449E-02, -8.8133E-02, -8.5595E-02, -8.2831E-02, -7.9895E-02, -7.6782E-02, -7.3537E-02, -7.0161E-02, -6.6668E-02, -6.3084E-02, -5.9418E-02, -5.5689E-02, -5.1898E-02, -4.8062E-02, -4.4201E-02, -4.0335E-02, -3.6495E-02, -3.2622E-02, -2.8759E-02, -2.4924E-02, -2.1135E-02, -1.7401E-02, -1.3724E-02, -1.0283E-02, -6.9826E-03, -3.8168E-03, -7.7003E-04, 1.9250E-03, 4.4496E-03, 6.5456E-03, 8.4459E-03, 9.9083E-03, 1.0875E-02, 1.1331E-02, 1.0917E-02, 9.5644E-03, 7.3026E-03, 3.9763E-03, 3.9355E-03, 1.3650E-02, 2.3904E-02, 3.2938E-02, 3.9832E-02, 4.4184E-02, 4.6843E-02, 4.7742E-02, 4.7008E-02, 4.5548E-02, 4.2430E-02, 3.8683E-02, 3.3605E-02, 2.8133E-02, 2.2223E-02, 1.5883E-02, 8.8690E-03, 1.7994E-03, -5.2834E-03, -1.2309E-02, -1.9204E-02, -2.5905E-02, -3.2485E-02, -3.8726E-02, -4.4600E-02, -5.0063E-02, -5.5110E-02, -6.0029E-02, -6.4241E-02, -6.7899E-02, -7.1391E-02, -7.4020E-02, -7.6015E-02, -7.7796E-02, -7.8704E-02, -7.9309E-02, -7.8953E-02, -7.8208E-02, -7.6467E-02, -7.4255E-02, -7.1337E-02, -6.7179E-02, -6.2323E-02, -5.6538E-02, -4.9348E-02, -4.1208E-02, -3.1913E-02, -2.1097E-02, -9.0917E-03, 4.2374E-03, 1.8978E-02, 3.5285E-02, 5.2822E-02, 7.1460E-02, 9.0918E-02, 1.1069E-01, 1.2995E-01, 1.4714E-01, 1.5994E-01, 1.6446E-01, 1.5407E-01, 1.1667E-01, 2.8240E-02, -1.6583E-01, -6.1374E-01, -1.6583E-01, 2.8240E-02, 1.1667E-01, 1.5407E-01, 1.6446E-01, 1.5994E-01, 1.4714E-01, 1.2995E-01, 1.1069E-01, 9.0918E-02, 7.1460E-02, 5.2822E-02, 3.5285E-02, 1.8978E-02, 4.2374E-03, -9.0917E-03, -2.1097E-02, -3.1913E-02, -4.1208E-02, -4.9348E-02, -5.6538E-02, -6.2323E-02, -6.7179E-02, -7.1337E-02, -7.4255E-02, -7.6467E-02, -7.8208E-02, -7.8953E-02, -7.9309E-02, -7.8704E-02, -7.7796E-02, -7.6015E-02, -7.4020E-02, -7.1391E-02, -6.7899E-02, -6.4241E-02, -6.0029E-02, -5.5110E-02, -5.0063E-02, -4.4600E-02, -3.8726E-02, -3.2485E-02, -2.5905E-02, -1.9204E-02, -1.2309E-02, -5.2834E-03, 1.7994E-03, 8.8690E-03, 1.5883E-02, 2.2223E-02, 2.8133E-02, 3.3605E-02, 3.8683E-02, 4.2430E-02, 4.5548E-02, 4.7008E-02, 4.7742E-02, 4.6843E-02, 4.4184E-02, 3.9832E-02, 3.2938E-02, 2.3904E-02, 1.3650E-02, 3.9355E-03, -2.8697E-04, 2.2993E-03, 8.9515E-03, 1.8986E-02, 3.2109E-02, 4.7412E-02, 6.3502E-02, 7.9787E-02, 9.5611E-02, 1.1102E-01, 1.2477E-01, 1.3760E-01, 1.4772E-01, 1.5667E-01, 1.6404E-01, 1.6948E-01, 1.7070E-01, 1.7058E-01, 1.6884E-01, 1.6543E-01, 1.6046E-01, 1.5429E-01, 1.4888E-01, 1.4070E-01, 1.3073E-01, 1.1945E-01, 1.0744E-01, 9.6486E-02, 8.3808E-02, 7.0604E-02, 5.8515E-02, 4.5302E-02, 3.2083E-02, 2.0118E-02, 7.9839E-03, -2.9234E-03, -1.3739E-02, -2.3292E-02, -3.2394E-02, -4.0164E-02, -4.6821E-02, -5.2890E-02, -5.7655E-02, -6.1257E-02, -6.4026E-02, -6.5502E-02, -6.5774E-02, -6.5026E-02, -6.3045E-02, -5.9908E-02, -5.5715E-02, -5.0610E-02, -4.4614E-02, -3.7877E-02, -3.0599E-02, -2.3030E-02, -1.5459E-02, -8.2046E-03, -1.6536E-03, 3.7415E-03, 7.4873E-03, 9.1017E-03, 8.2388E-03, 5.0100E-03, 9.1062E-04, 5.0100E-03, 8.2388E-03, 9.1017E-03, 7.4873E-03, 3.7415E-03, -1.6536E-03, -8.2046E-03, -1.5459E-02, -2.3030E-02, -3.0599E-02, -3.7877E-02, -4.4614E-02, -5.0610E-02, -5.5715E-02, -5.9908E-02, -6.3045E-02, -6.5026E-02, -6.5774E-02, -6.5502E-02, -6.4026E-02, -6.1257E-02, -5.7655E-02, -5.2890E-02, -4.6821E-02, -4.0164E-02, -3.2394E-02, -2.3292E-02, -1.3739E-02, -2.9234E-03, 7.9839E-03, 2.0118E-02, 3.2083E-02, 4.5302E-02, 5.8515E-02, 7.0604E-02, 8.3808E-02, 9.6486E-02, 1.0744E-01, 1.1945E-01, 1.3073E-01, 1.4070E-01, 1.4888E-01, 1.5429E-01, 1.6046E-01, 1.6543E-01, 1.6884E-01, 1.7058E-01, 1.7070E-01, 1.6948E-01, 1.6404E-01, 1.5667E-01, 1.4772E-01, 1.3760E-01, 1.2477E-01, 1.1102E-01, 9.5611E-02, 7.9787E-02, 6.3502E-02, 4.7412E-02, 3.2109E-02, 1.8986E-02, 8.9515E-03, 2.2993E-03, -2.8697E-04); \n//The first 4 rows of the V matrix: \nfloat V[516] = float[](-6.3313E-03, -1.6125E-02, -2.8355E-02, -4.2272E-02, -5.7744E-02, -7.4587E-02, -9.2324E-02, -1.1093E-01, -1.3034E-01, -1.5028E-01, -1.7104E-01, -1.9232E-01, -2.1435E-01, -2.3688E-01, -2.5994E-01, -2.8355E-01, -3.0786E-01, -3.3266E-01, -3.5798E-01, -3.8381E-01, -4.1016E-01, -4.3702E-01, -4.6433E-01, -4.9224E-01, -5.2073E-01, -5.4980E-01, -5.7944E-01, -6.0961E-01, -6.4042E-01, -6.7185E-01, -7.0387E-01, -7.3658E-01, -7.6996E-01, -8.0400E-01, -8.3878E-01, -8.7427E-01, -9.1054E-01, -9.4759E-01, -9.8548E-01, -1.0242E+00, -1.0638E+00, -1.1044E+00, -1.1459E+00, -1.1884E+00, -1.2321E+00, -1.2768E+00, -1.3227E+00, -1.3698E+00, -1.4182E+00, -1.4679E+00, -1.5191E+00, -1.5719E+00, -1.6262E+00, -1.6823E+00, -1.7402E+00, -1.8000E+00, -1.8620E+00, -1.9263E+00, -1.9930E+00, -2.0625E+00, -2.1351E+00, -2.2111E+00, -2.2911E+00, -2.3759E+00, -2.4670E+00, -2.3759E+00, -2.2911E+00, -2.2111E+00, -2.1351E+00, -2.0625E+00, -1.9930E+00, -1.9263E+00, -1.8620E+00, -1.8000E+00, -1.7402E+00, -1.6823E+00, -1.6262E+00, -1.5719E+00, -1.5191E+00, -1.4679E+00, -1.4182E+00, -1.3698E+00, -1.3227E+00, -1.2768E+00, -1.2321E+00, -1.1884E+00, -1.1459E+00, -1.1044E+00, -1.0638E+00, -1.0242E+00, -9.8548E-01, -9.4759E-01, -9.1054E-01, -8.7427E-01, -8.3878E-01, -8.0400E-01, -7.6996E-01, -7.3658E-01, -7.0387E-01, -6.7185E-01, -6.4042E-01, -6.0961E-01, -5.7944E-01, -5.4980E-01, -5.2073E-01, -4.9224E-01, -4.6433E-01, -4.3702E-01, -4.1016E-01, -3.8381E-01, -3.5798E-01, -3.3266E-01, -3.0786E-01, -2.8355E-01, -2.5994E-01, -2.3688E-01, -2.1435E-01, -1.9232E-01, -1.7104E-01, -1.5028E-01, -1.3034E-01, -1.1093E-01, -9.2324E-02, -7.4587E-02, -5.7744E-02, -4.2272E-02, -2.8355E-02, -1.6125E-02, -6.3313E-03, 5.8353E-03, 1.0717E-02, 1.4036E-02, 1.6021E-02, 1.6629E-02, 1.5960E-02, 1.4541E-02, 1.2395E-02, 9.6060E-03, 6.5301E-03, 2.8250E-03, -1.1301E-03, -5.6013E-03, -1.0247E-02, -1.5091E-02, -2.0141E-02, -2.5537E-02, -3.1016E-02, -3.6578E-02, -4.2205E-02, -4.7875E-02, -5.3559E-02, -5.9194E-02, -6.4867E-02, -7.0533E-02, -7.6162E-02, -8.1726E-02, -8.7199E-02, -9.2579E-02, -9.7838E-02, -1.0296E-01, -1.0792E-01, -1.1268E-01, -1.1725E-01, -1.2156E-01, -1.2561E-01, -1.2934E-01, -1.3274E-01, -1.3572E-01, -1.3829E-01, -1.4037E-01, -1.4185E-01, -1.4271E-01, -1.4287E-01, -1.4217E-01, -1.4056E-01, -1.3791E-01, -1.3403E-01, -1.2879E-01, -1.2199E-01, -1.1338E-01, -1.0265E-01, -8.9530E-02, -7.3603E-02, -5.4384E-02, -3.1282E-02, -3.5463E-03, 2.9717E-02, 6.9706E-02, 1.1801E-01, 1.7679E-01, 2.4922E-01, 3.4020E-01, 4.5845E-01, 6.2249E-01, 4.5845E-01, 3.4020E-01, 2.4922E-01, 1.7679E-01, 1.1801E-01, 6.9706E-02, 2.9717E-02, -3.5463E-03, -3.1282E-02, -5.4384E-02, -7.3603E-02, -8.9530E-02, -1.0265E-01, -1.1338E-01, -1.2199E-01, -1.2879E-01, -1.3403E-01, -1.3791E-01, -1.4056E-01, -1.4217E-01, -1.4287E-01, -1.4271E-01, -1.4185E-01, -1.4037E-01, -1.3829E-01, -1.3572E-01, -1.3274E-01, -1.2934E-01, -1.2561E-01, -1.2156E-01, -1.1725E-01, -1.1268E-01, -1.0792E-01, -1.0296E-01, -9.7838E-02, -9.2579E-02, -8.7199E-02, -8.1726E-02, -7.6162E-02, -7.0533E-02, -6.4867E-02, -5.9194E-02, -5.3559E-02, -4.7875E-02, -4.2205E-02, -3.6578E-02, -3.1016E-02, -2.5537E-02, -2.0141E-02, -1.5091E-02, -1.0247E-02, -5.6013E-03, -1.1301E-03, 2.8250E-03, 6.5301E-03, 9.6060E-03, 1.2395E-02, 1.4541E-02, 1.5960E-02, 1.6629E-02, 1.6021E-02, 1.4036E-02, 1.0717E-02, 5.8353E-03, 1.4748E-03, 5.1153E-03, 8.9583E-03, 1.2344E-02, 1.4927E-02, 1.6558E-02, 1.7555E-02, 1.7891E-02, 1.7616E-02, 1.7069E-02, 1.5901E-02, 1.4497E-02, 1.2593E-02, 1.0543E-02, 8.3282E-03, 5.9520E-03, 3.3237E-03, 6.7431E-04, -1.9800E-03, -4.6130E-03, -7.1968E-03, -9.7081E-03, -1.2174E-02, -1.4513E-02, -1.6714E-02, -1.8761E-02, -2.0653E-02, -2.2496E-02, -2.4075E-02, -2.5445E-02, -2.6754E-02, -2.7739E-02, -2.8487E-02, -2.9154E-02, -2.9495E-02, -2.9721E-02, -2.9588E-02, -2.9308E-02, -2.8656E-02, -2.7827E-02, -2.6734E-02, -2.5176E-02, -2.3356E-02, -2.1188E-02, -1.8493E-02, -1.5443E-02, -1.1959E-02, -7.9062E-03, -3.4071E-03, 1.5880E-03, 7.1121E-03, 1.3223E-02, 1.9795E-02, 2.6780E-02, 3.4072E-02, 4.1481E-02, 4.8698E-02, 5.5143E-02, 5.9938E-02, 6.1633E-02, 5.7737E-02, 4.3722E-02, 1.0583E-02, -6.2144E-02, -2.3000E-01, -6.2144E-02, 1.0583E-02, 4.3722E-02, 5.7737E-02, 6.1633E-02, 5.9938E-02, 5.5143E-02, 4.8698E-02, 4.1481E-02, 3.4072E-02, 2.6780E-02, 1.9795E-02, 1.3223E-02, 7.1121E-03, 1.5880E-03, -3.4071E-03, -7.9062E-03, -1.1959E-02, -1.5443E-02, -1.8493E-02, -2.1188E-02, -2.3356E-02, -2.5176E-02, -2.6734E-02, -2.7827E-02, -2.8656E-02, -2.9308E-02, -2.9588E-02, -2.9721E-02, -2.9495E-02, -2.9154E-02, -2.8487E-02, -2.7739E-02, -2.6754E-02, -2.5445E-02, -2.4075E-02, -2.2496E-02, -2.0653E-02, -1.8761E-02, -1.6714E-02, -1.4513E-02, -1.2174E-02, -9.7081E-03, -7.1968E-03, -4.6130E-03, -1.9800E-03, 6.7431E-04, 3.3237E-03, 5.9520E-03, 8.3282E-03, 1.0543E-02, 1.2593E-02, 1.4497E-02, 1.5901E-02, 1.7069E-02, 1.7616E-02, 1.7891E-02, 1.7555E-02, 1.6558E-02, 1.4927E-02, 1.2344E-02, 8.9583E-03, 5.1153E-03, 1.4748E-03, 8.3758E-05, -6.7109E-04, -2.6127E-03, -5.5415E-03, -9.3716E-03, -1.3838E-02, -1.8534E-02, -2.3288E-02, -2.7906E-02, -3.2404E-02, -3.6416E-02, -4.0163E-02, -4.3115E-02, -4.5726E-02, -4.7877E-02, -4.9467E-02, -4.9824E-02, -4.9789E-02, -4.9280E-02, -4.8284E-02, -4.6833E-02, -4.5032E-02, -4.3454E-02, -4.1067E-02, -3.8156E-02, -3.4863E-02, -3.1359E-02, -2.8161E-02, -2.4461E-02, -2.0607E-02, -1.7079E-02, -1.3222E-02, -9.3641E-03, -5.8718E-03, -2.3303E-03, 8.5326E-04, 4.0101E-03, 6.7982E-03, 9.4547E-03, 1.1723E-02, 1.3666E-02, 1.5437E-02, 1.6828E-02, 1.7879E-02, 1.8687E-02, 1.9118E-02, 1.9198E-02, 1.8979E-02, 1.8401E-02, 1.7485E-02, 1.6261E-02, 1.4772E-02, 1.3022E-02, 1.1055E-02, 8.9311E-03, 6.7218E-03, 4.5121E-03, 2.3947E-03, 4.8263E-04, -1.0920E-03, -2.1853E-03, -2.6565E-03, -2.4047E-03, -1.4623E-03, -2.6578E-04, -1.4623E-03, -2.4047E-03, -2.6565E-03, -2.1853E-03, -1.0920E-03, 4.8263E-04, 2.3947E-03, 4.5121E-03, 6.7218E-03, 8.9311E-03, 1.1055E-02, 1.3022E-02, 1.4772E-02, 1.6261E-02, 1.7485E-02, 1.8401E-02, 1.8979E-02, 1.9198E-02, 1.9118E-02, 1.8687E-02, 1.7879E-02, 1.6828E-02, 1.5437E-02, 1.3666E-02, 1.1723E-02, 9.4547E-03, 6.7982E-03, 4.0101E-03, 8.5326E-04, -2.3303E-03, -5.8718E-03, -9.3641E-03, -1.3222E-02, -1.7079E-02, -2.0607E-02, -2.4461E-02, -2.8161E-02, -3.1359E-02, -3.4863E-02, -3.8156E-02, -4.1067E-02, -4.3454E-02, -4.5032E-02, -4.6833E-02, -4.8284E-02, -4.9280E-02, -4.9789E-02, -4.9824E-02, -4.9467E-02, -4.7877E-02, -4.5726E-02, -4.3115E-02, -4.0163E-02, -3.6416E-02, -3.2404E-02, -2.7906E-02, -2.3288E-02, -1.8534E-02, -1.3838E-02, -9.3716E-03, -5.5415E-03, -2.6127E-03, -6.7109E-04, 8.3758E-05); \n//center of the convolution \nint Nc = 64; \n//number of ranks \nint Nr = 4; \n//convolution size \nint N = 129; \n\n\n\nfloat pack2(vec2 a)\n{\n    return uintBitsToFloat(packHalf2x16(a));\n}\n\nvec2 unpack2(float packed)\n{\n    return unpackHalf2x16(floatBitsToUint(packed));\n}\n\nivec2 wrap(ivec2 p, ivec2 res)\n{\n    return (p + res)%res;\n}\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 1.) \n        {\n            vec2 dC = pos - R*0.5;\n            P.X = pos;\n            P.V = 0.*(rand.xy-0.5) + 0.5*vec2(dC.y/R.x, -dC.x/R.x);\n            P.M = 0.005*mass;\n            P.I = 0.;\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = 1e-6;\n            P.I = 0.;\n        }\n    }\n    \n   \n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos); \n    \n   \n    if(P.M != 0.) //not vacuum\n    {\n        Simulation(ch0, ch1, P, pos);\n    }\n    \n   \n\t/*\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }*/\n    \n    if(length(pos - R*vec2(0.5, 0.1)) < 10.) \n    {\n      // P.I = 0.2;\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float getDensity(ivec2 p)\n{\n    return texelFetch(iChannel0, p, 0).z;\n}\n\nfloat getEstimatedDensity(ivec2 p)\n{\n    ivec2 resol = ivec2(iResolution.xy);\n    //the laplacian of the density field is the source term for the poisson equation\n    return \n    texelFetch(iChannel1, wrap(p + ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p - ivec2(1,0),resol), 0).x + \n    texelFetch(iChannel1, wrap(p + ivec2(0,1),resol), 0).x +\n    texelFetch(iChannel1, wrap(p - ivec2(0,1),resol), 0).x - \n    4.0*texelFetch(iChannel1, p, 0).x;\n}\n\nfloat getDensityError(ivec2 p)\n{\n    //find how far off the estimated density is from the actual density and use that as the source term\n    return getDensity(p) + 0.995*getEstimatedDensity(p);\n}\n\n\n//single component convolution pass x\n//first pass of separable poisson filter convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    vec4 sum = vec4(0.0);\n    \n    for (int i = -Nc; i <= Nc; i++) \n    {\n        ivec2 pos = wrap(coord + ivec2(i, 0), resol);\n       \n        float density = getDensityError(pos);\n\n        int id = (i + Nc);\n        //loop over ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum[j] += density * U[id + j * N];\n        }\n    }\n\n    fragColor = sum;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy);\n    ivec2 coord = ivec2(fragCoord.xy);\n\n    float sum = 0.0;\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = wrap(coord + ivec2(0, i), resol);\n        \n        //wrap around\n        pos.x = (pos.x + resol.x) % resol.x;\n        pos.y = (pos.y + resol.y) % resol.y;\n        \n        vec4 data = texelFetch(iChannel0, pos, 0);\n    \n        int id = (i + Nc);\n        //loop over pairs of ranks\n        for(int j = 0; j < 4; j++)\n        {\n            sum += data[j] * V[id + j * N];\n        }\n    }\n\n    //get previous poisson solution\n    float prev = 0.995*texelFetch(iChannel1, coord, 0).x;\n\n    //add the previous poisson solution to the convolution\n    sum += prev;\n\n    //return the final poisson solution\n    fragColor = vec4(sum);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [296, 296, 323, 323, 367], [369, 369, 405, 405, 831], [833, 833, 865, 865, 1250], [1252, 1252, 1284, 1388, 1441], [1443, 1443, 1460, 1460, 1578], [1581, 1581, 1626, 1626, 2609]], "test": "untested"}
{"id": "DtSSWm", "name": "Pathtraced DoF", "author": "RubberDuck55", "description": "Depth of field using a method described here: https://stackoverflow.com/questions/10012219/how-to-implement-depth-of-field-in-ray-tracer\n\nI don't believe this method has Bokeh", "tags": ["pathtracer"], "likes": 2, "viewed": 200, "published": 3, "date": "1676135479", "time_retrieved": "2024-07-30T18:10:45.794916", "image_code": "// Editable values in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(data.rgb/data.a, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEP 250\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define BOUNCES 3\n\n#define num_obj 7\n\nfloat seed;\n\nstruct sphere {\n    vec3   pos;\n    float  r;\n    vec3   col;\n};\n\nstruct hit {\n    float  dist;\n    vec3   pos, n, ro, rd;\n    bool   sky;\n    sphere s;\n};\n\nsphere obj[num_obj];\n\nvoid init_obj () {\n    obj[0] = sphere(vec3(0.,-1001.,0.), 1000., vec3(1.)); // Floor\n    obj[1] = sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.));  // Main\n    obj[2] = sphere(vec3(2.0, -.6, 0.0), 0.4, vec3(1., 1., 0.5));\n    obj[3] = sphere(vec3(-2., -.6, -2.), 0.4, vec3(1.,0.5, 1.));\n    obj[4] = sphere(vec3(-2., -.6, 2.0), 0.4, vec3(0.5,1., 0.5));\n    obj[5] = sphere(vec3(1.5, -.6, 3.0), 0.4, vec3(1.,0.5,0.5));\n    obj[6] = sphere(vec3(2., -.6, -3.0), 0.4, vec3(0.5,0.5,1.));\n}\n\nmat2 rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1416 * 4.;\n    float theta = (rand()-0.5) * 3.1416 * 4.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nvec2 rand_disk () {\n    float theta = (rand()-0.5) * 3.1416 * 2.;\n    float mag   = rand();\n    \n    return vec2(sin(theta), cos(theta)) * mag;\n}\n\nfloat dist_sphere (vec3 p, out sphere s) {\n    float minDist = MAX_DIST;\n    \n    for(int i = 0; i < num_obj; i++) {\n        float td = length(p-obj[i].pos)-obj[i].r;\n        \n        if(td < minDist) {\n            minDist = td;\n            s = obj[i];\n        }\n    }\n    \n    return minDist;\n}\n\nfloat dist (vec3 p) {\n    sphere s;\n    return dist_sphere(p, s);\n}\n\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nhit raymarch (vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    bool sky = true;\n    \n    for(int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        \n        float d = dist(p);\n        \n        if(d <= SURF_DIST) {\n            sky = false;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            sky = true;\n        }\n        dO += d;\n    }\n    \n    vec3 p = ro + rd * dO;\n    \n    sphere s;\n    dist_sphere(p, s);\n    \n    return hit(dO, p, normal(p), ro, rd, sky, s);\n}\n\nvec3 montecarlo (vec3 ro, vec3 rd) {\n    vec3 mask  =  vec3(1.0);\n    vec3 color =  vec3(0.0);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 col = vec3(0.0);\n        hit h = raymarch(ro, rd);\n        \n        ro = h.pos + h.n *  SURF_DIST;\n        \n        if(h.sky) {\n            col = texture(iChannel1, h.pos).rgb*1.4;\n            mask  *=  col;\n            color +=  mask;\n            break;\n        }\n        else {\n            col = h.s.col;\n            rd  = rand_hemisphere(h.n); \n        }\n        \n        mask  *=  col;//  \\/ This is the throughput\n        color +=  mask * 0.01;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(ivec2(fragCoord) == ivec2(0)) {\n        fragColor = vec4(iResolution.xyxy);\n        return;\n    }\n    \n    init_obj();\n    \n    init_rand(fragCoord * iTime + 1.0);\n    \n    vec2 uv = ((fragCoord+vec2(rand()-.5,rand()-.5)) / iResolution.xy-.5)/vec2(1.,iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(0.,0.,-8.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // Random Rotation For DoF\n    //                     \\/ This is the amount of blur\n    vec2 ra = rand_disk()*0.1;\n    \n    ro.xz *= rot(ra.x);\n    ro.yz *= rot(ra.y);\n    rd.xz *= rot(ra.x);\n    rd.yz *= rot(ra.y);\n    //\n    //\n    \n    vec3 col = vec3(montecarlo(ro, rd));\n    \n    if(texelFetch(iChannel0, ivec2(0), 0) == vec4(iResolution.xyxy)){\n        fragColor = vec4(col,1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 89, 237]], "test": "untested"}
{"id": "DtjSWh", "name": "Refractive Polyhedron", "author": "Shane", "description": "A refractive two way mirrored polyhedron rendered in realtime.", "tags": ["reflection", "refraction", "dof", "bokeh", "glass", "metal", "icosahedron", "dodecahedron", "polyhedron"], "likes": 263, "viewed": 11154, "published": 3, "date": "1676126090", "time_retrieved": "2024-07-30T18:10:46.786265", "image_code": "/*\n\n\tRefractive Polyhedron\n\t---------------------\n    \n    See Buffer A.    \n\n*/\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.25, coc = 1.65;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n/*\n// Very basic bloom function.\nvec4 bloomBlur(sampler2D iCh, vec2 p){\n    \n    vec4 c = vec4(0);\n\n    const int n = 2;\n    for(int j = -n; j<=n; j++){\n        for(int i = -n; i<=n; i++){\n            c +=  texture(iCh, p + vec2(i, j)/iResolution.xy*2., 1.);\n        }\n    }\n    \n    return c/float((n*2 + 1)*(n*2 + 1));\n   \n}\n*/\n\n\n// This is not a great bokeh function example, but it'll do. It's an amalgamation\n// of old blur and DOF functions with a couple of borrowed lines from Dave Hoskins's \n// much nicer Fibonacci based \"Bokeh disc\" function, which you can find here:\n// https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec3 bokeh(sampler2D iCh, vec2 uv, float radius){\n\n\tvec3 tot = vec3(0), sum = vec3(0);\n\n     // Focal point and circle of confusion.\n    const float focD = 1.25, coc = 1.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float r = (dot(uv - .5, uv - .5))*8. + .125;//(clamp(l/coc, 0., 2.))*8.;//;\n\n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n \n            //r = mix(dof*dof*2. + .5, 0., step(0., shape(vec2(i, j)) - float(n)));\n            \n            // If we're not inside the circle, continue.\n            //if(length(vec2(i, j))>float(n)) continue; \n           \n            \n            //vec2 offs = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)) + .5;\n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            //vec2 rnd = texture(iChannel1, uv + vec2(i, j)/iResolution.xy).xy - .5; \n            //vec3 c = texture(iCh, uv + (vec2(i, j))/vec2(800, 450)*r, r*.7).xyz; \n            vec3 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7).xyz; \n            vec3 bokeh = pow(c, vec3(6));\n            tot += c*sqrt(c)*bokeh*2.;\n            sum += bokeh;\n        }\n    }\n    \n\treturn tot/sum;\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // Just the unprocessed texture on it's own.\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Cheap 25 tap depth of field function.\n    //vec3 col = DpthFld(iChannel0, uv);\n    \n    \n    // Worst bokeh algorithm ever -- Definitely needs work. :)\n    vec3 bokCol = bokeh(iChannel0, uv, 1.).xyz;\n    col = mix(col, bokCol, .75);\n     \n    \n    // Bloom. Too much here.\n    //vec3 bloom = bloomBlur(iChannel0, uv).xyz;\n    //vec3 bloomLight = vec3(1, .9, .7);\n    //col += pow(bloom, 2./bloomLight)*2.;\n    \n         \n    fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n\tRefractive Polyhedron\n\t---------------------\n\n    Creating an antialiased, glass and metal, refractive polyhedron in realtime. \n    Rendering a two way mirrored polyhedron is a fairly common graphics exercise, \n    and there are a few examples on Shadertoy already. I put a version of this \n    together directly after looking at Quinchilion's really nice \"Interstellar \n    Icosahedron\" shader. I think it may have been the first one posted on here \n    and is still one of my favorites -- There's a link below for anyone who \n    hasn't seen it.\n    \n    I started with an icosahedron, but changed it to a dodecahedron after looking \n    at Xjorma's recent \"Infinite Dodecahedron\" example. I dropped some more \n    intricate truncated polyhedra into the scene, but I felt the reflections \n    looked too busy, so decided to keep things simple. There's a \"define\" option\n    to render an icosahedron also, for anyone interested.\n    \n    Anyway, since I had absolutely nothing new to add to the reflective polyhedron\n    genre, I thought I'd spend some time prettying it up with some post processing\n    algorithms. I was going to add some glowing tubes, but ran out of steam. I\n    might try that out in cube form at a later date.    \n  \n\n    \n    Useful examples:\n\n\t// Beautiful example. I love the conciseness of the reflective pattern.\n    Interstellar icosahedron - Quinchilion \n\thttps://www.shadertoy.com/view/tlX3WH\n    \n    // Multiple light reflections off the inner faces of a polyhedron.\n    // Rendered with a Belgian theme. :)\n    This Is Not A Reflected Pipe 2 - Dr2 \n    https://www.shadertoy.com/view/Nsd3RN\n    \n    // Multiple reflections on a truncated dodecahedron. I like the\n    // approach Xjorma took, but I had to use a different one.\n    Infinite Dodecahedron - xjorma\n    https://www.shadertoy.com/view/DlfXWS\n \n*/\n\n\n// Pentagon or icosahedron.\n#define PENTAGON\n\n//#define INSIDE_VIEW\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 6\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(23.527, 57.683)))*43758.5453); }\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n}\n*/\n\n\n///////////\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\nconst float PHI = (1. + sqrt(5.))/2.; // 1.618\nconst float A = PHI/sqrt(1. + PHI*PHI); // .85064\nconst float B = 1./sqrt( 1. + PHI*PHI); // .5257\nconst float J = (PHI - 1.)/2.; // .309016994375\nconst float K = PHI/2.; // J + .5\nconst mat3 R0 = mat3(.5,  -K,   J,  K,  J, -.5,  J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5,  J, .5,   K, .5 , -K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K, .5, -K,  -J,  K ,  J, .5);\n\n// I wanted all vertices hardcoded. Everything's been projected to the\n// surface of a sphere.\n#ifdef PENTAGON\nconst float size = .5/.85;\n#else\nconst float size = .5;\n#endif\n\nconst vec3 v0 = (vec3(0, A, B))*size; // Already normalized.\nconst vec3 v1 = (vec3(B, 0, A))*size;\nconst vec3 v2 = (vec3(-B, 0, A))*size;\nconst vec3 e0 = (mix(v0, v1, .5));\nconst vec3 e1 = (mix(v1, v2, .5));\nconst vec3 e2 = (mix(v2, v0, .5));\n//const vec3 mid = normalize(vec3(0, A, B + A*2.))/3.; // (v0 + v1 + v2)/3.*size.\nconst vec3 ctr = (v0 + v1 + v2)/3.;//mix(e0, v2, .5);//\nconst mat3 R3 = mat3(-.5, sqrt(.75), 0, K, .467086179481, .356822089773,-J, -.178411044887, .934172358963);\n// A handy matrix that rotates icosahedral vertices into the dual dodecahedron postions. \nconst mat3 R4 = mat3(.587785252292, -K, 0, \n                     -.425325404176, -J, .850650808352, \n                     .688190960236, .5, .525731112119);\nconst vec3 O3 = vec3(B,B/sqrt(3.), sqrt(1. - 4./3.*B*B));                     \nconst vec3 O4 = vec3(A/3./tan(3.14159/5.), A/3., .63147573033330584);\n\n\n\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p); \n    return abs(p);  \n} \n\n/*\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length(pa);\n}\n*/\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    //p.x = abs(p.x - .015);\n    \n   \n    #ifdef PENTAGON\n    const float n = 12.; //12.\n    float zr = abs(mod(p.z - l*lf, 1./n) - .5/n);\n    float riv = length(vec2(p.y, zr)) - .008;\n    #else\n    const float n = 12.; //12.\n    float zr = abs(mod(p.z - l*lf - .5/n, 1./n) - .5/n);\n    float riv = length(vec2(p.x, zr)) - .008;\n    #endif\n    \n \n    p = abs(p);\n   \n    \n    //float ln = max(length(p.xy) - r, p.z - l*lf);\n    //float ln = max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //float ln = max(max(p.x, p.y) - r, p.z - l*lf);\n    float ln = max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    //float ln = max(max(p.y*.866025 + p.x*.5, p.x) - r, p.z - l*lf);\n    //float ln = max(max(p.x*.866025 + p.y*.5, p.y) - r, p.z - l*lf);\n    \n    return max(ln, -riv);\n    //return min(ln, max(riv, p.y - r - .01));\n}\n\n\n////////////////\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n// Object rotation.\nvec3 objRot(vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    //float it = floor(iTime/8.);\n    //float t = abs(fract(iTime/16.) - .5)*2.;\n    //float mv = smoothstep(.35, .65, t)*3.14159;\n    //if(mod(it, 2.)<.5) mv = -mv;\n    p.xy = rot2(3.14159/10.)*p.xy;\n    p.xz = rot2(iTime/8.)*p.xz;  //iTime/4. \n    return p;\n\n}\n\n\n \n// The scene. All of it is pretty standard. To be honest, this was a \n// little rushed, but the field doesn't have a lot going on, so tightening \n// it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + 1.; // Thick wall: abs(p.z - .2) - .21;\n    // Peturb that back wal to bounce the light off a little more.\n    wall -= dot(sin(p*3. - cos(p.yzx*6. + vec3(iTime/4., .5, iTime/2.))), vec3(.025));  \n    \n\n    // 3D object position.\n    vec3 bq = objRot(p);\n  \n    // Local object cell coordinates.\n    vec3 objP = opIcosahedron(bq);\n    \n    \n    // Render a pentagon or and icosahedron. Thanks to DjinnKahn's original\n    // setup, there is very little calculation necessary at this point.\n    // For a multiple bounce scenario, this is a good thing. :)\n    \n    #ifdef PENTAGON\n    \n    // Lines -- Rendered from an icosahedron perspective, so from the\n    // face centers to the mid-edge points.\n    float line = sdCapsule(objP, (ctr), e0*PHI*PHI/3., .02, .55); \n    // The solid pentagon, which will be turned into a thin outer shell\n    // for the glass. I.e. obj = abs(obj) - w.\n    vec3 pentP = R4*objP - O4*size;\n    float face = length(vec3(max(pentP.x, 0.), max(pentP.y, 0.), pentP.z));\n    \n    #else\n    \n    // Lines.\n    float line = sdCapsule(objP, v0, v1, .02, .55); \n    // The solid icosahedron, which will be turned into a thin outer shell\n    // for the glass. I.e. obj = abs(obj) - w.\n    vec3 icosP = R3*objP - O3*size;\n    float face = length(vec3(max(icosP.x, 0.), max(icosP.y, 0.), icosP.z));\n    line = smax(line, length(p) - size - .02, .01); // Round off the points.\n    \n    #endif\n    \n    \n    // Debug: Take out the metal tubing.\n    //line = 1e5;\n    \n    // Turning the solid object into a thin outer shell.\n    float glass = max(abs(face) - .002, -line);\n     \n    // The lines will be made of metal.\n    float mtl = line; \n   \n   \n    \n    // Storing the object ID.\n    vObjID = vec4(wall, glass, mtl, 1e5);\n    \n    // Returning the closest object.\n    return min(min(wall, glass), mtl);\n \n}\n\n\n \nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n    float tmin = 0.;\n    float tmax = FAR;\n    \n    // IQ's bounding plane addition, to help give some extra performance.\n    //\n    // If ray starts above bounding plane, skip all the empty space.\n    // If ray starts below bounding plane, never march beyond it.\n    const float boundZ = -.6;\n    float h = (boundZ - ro.z)/rd.z;\n    if(h>0.){\n    \n        if( ro.z<boundZ ) tmin = max(tmin, h);\n        else tmax = min(h, FAR);\n    }\n \n    float t = tmin;\n    for(int i = 0; i<72; i++){\n    \n        float d = map(ro + rd*t)*distanceFactor;\n        if( abs(d)<DELTA ) return t;\n        if( t>tmax) break; \n        t += d*.9; \n    }\n\n    return FAR;\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow \n    // test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        //if (d<0. || t>end) break; \n        // Bounding plane optimization, specific to this example. Thanks to IQ. \n        if (d<0. || t>end || (ro.z + rd.z*t)<-.6) break;\n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n/* \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Random hash setup.\nvec2 seed = vec2(.13, .27);\n\nvec2 hash22() {\n    \n    seed += vec2(.723, 643);\n    seed = fract(seed);\n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    float resT = 1e8;\n \n    float iRes = iResolution.y;\n\n    \n    // Screen coordinates.\n    seed += fract(iTime)*113.87;\n\t//vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5 + (hash22() - .5)/4.)/iRes;\n\t\n\n    // \"Look At\" position.\n    vec3 lk = vec3(0); \n    \n    // Ray origin.\n    #ifdef INSIDE_VIEW\n    vec3 ro = lk + vec3(cos(iTime/4.)*.05, .1, .1);\n    #else\n    vec3 ro = lk + vec3(cos(iTime/4.)*.1, 0, -1.25);\n    #endif\n  \n    // Light positioning.\n \tvec3 lp = lk + vec3(-.25, .75, -.6); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    mat3 mCam = mat3(rgt, up, fwd);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the glass. Normally, you'd have\n    // different ones for different objects, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object: With more objects, you'd use a looping\n        // mechanism, but I'd imagine this hideous expression is a little faster.\n        float svObjID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z && vObjID.x<vObjID.w)? 0. : \n                        vObjID.y<vObjID.z && vObjID.y<vObjID.w? 1. : vObjID.z<vObjID.w? 2. :  3.;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n         \n         \n            if(j==0){\n                resT = t;\n            }\n\n            \n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel1, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            float sh = 1.;\n            #if 0\n            // Shadows on each bounce.\n            sh = softShadow(sp, lp, sn, 12.);\n            gSh = min(sh + .5, 1.); // Adding brightness to the shadow.\n            #else\n            // Shadows on just two bounces.\n            if(j < 2){ \n                sh = softShadow(sp, lp, sn, 12.);\n                gSh = min(gSh, min(sh + .53, 1.)); \n            }\n            #endif\n            \n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 16.);\n            float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 16.);\n            //float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            // Fresnel.\n            float Schlick = pow(1. - clamp(dot(rd, normalize(rd + ld)), 0., 1.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n            vec3 txP = objRot(sp);\n            vec3 txN = objRot(sn);\n            \n             \n            if(svObjID == 0.){ // Back wall.\n               \n                // Texturing. \n                //vec3 tx = tex3D(iChannel2, sp/2., sn);\n                vec3 tx = texture(iChannel2, sp.xy/3. + vec2(1, .5)*iTime/72.).xyz; tx *= tx;\n\n                // Background. \n                // It's roughly incorporattes Edwardbraed's simple background here:\n                // https://www.shadertoy.com/view/NslXz4\n                uv.y = abs(uv.y + .125) - .5;\n                float grad = pow(1.0 - length(uv*vec2(iResolution.y/iResolution.x, 1)), 4.);\n                oCol = mix(vec3(.7, .5, 1), vec3(.5, .7, 1), uv.y + .5); \n                oCol *= grad*.95 + .05;\n                oCol *= tx*2.;\n               \n                 \n                // The wall has no reflection of refraction, so setting the\n                // reflective or transmission power to zero will cause the\n                // loop to terminate early, which saves a lot of work.\n                objRef = 0.;\n\n                spe *= freS;\n\n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass box.\n            \n                \n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dark, in order to look transparent.\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                \n                // Color.\n                oCol = mix(vec3(.7, .5, 1), vec3(.5, .7, 1), uv.y + .5); \n                oCol *= tx*.1;\n\n               \n                // Faking more reflectivity in the glass.\n                objRef = 1.125; \n                spe = pow(spe, 4.);\n                \n                #ifdef INSIDE_VIEW\n                oCol *= vec3(.8, .6, 1); // Adding a bit more glass color for the inside view.\n                refraction *= 0.; // Turn off refraction inside the object.\n                #else\n                // Reflection only override.\n                if((j>0 && distanceFactor>0.)){ \n                    refraction *= 0.;\n                }\n                #endif\n                \n            }\n            else { // Metallic stuff.            \n            \n               \n                // Joins, tracks and animated metal objects.\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                tx = smoothstep(.0, .5, tx);\n                if(svObjID==3.) oCol = tx*vec3(1, .7, .5);\n                else oCol = tx*vec3(.5)*vec3(1, .95, .9);\n                \n               \n                objRef = .25; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*2.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n                \n            }\n            \n            \n            // Cheap specular reflections.\n            vec3 rTx = texture(iChannel3, reflection).xyz; rTx *= rTx;\n            if(svObjID == 0.) rTx *= .25;\n            oCol += (oCol*.75 + .25)*speR*rTx*3.;//*vec3(.85, .7, 1); //*speR\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .2 + vec3(1, .7, .4)*spe*6.);\n            \n            // Shading.\n            colL *= gSh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n        \n    }\n    \n    \n    #ifdef INSIDE_VIEW\n    // Vignette.\n    // Using IQ's box formula to produce a more configurable border overlay.\n    // Equivalent to: float bord = sBox(uv, vec2(iResolution.x/iResolution.y, 1)/2.);\n    vec2 d = abs(uv) - vec2(iResolution.x/iResolution.y, 1)/2. + .15;\n    float bord = min(max(d.x, d.y), 0.) + length(max(d, 0.)) - .3;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .05, abs(bord) - .15))*.7);\n    #endif\n    \n    \n    \n\n    \n    fragColor.w = resT;\n     \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(col, 0.), 1);\n    \n    \n   \n    \n    \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjSWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 111, 132, 132, 195], [198, 980, 1017, 1063, 1807], [2141, 2738, 2787, 2787, 4200], [4204, 4204, 4258, 4279, 4908]], "test": "untested"}
{"id": "DllSWB", "name": "Semi-regular 3,3,4,3,4 Extrusion", "author": "Shane", "description": "A semi-regular 3,3,4,3,4 extruded tiling of the plane.", "tags": ["pattern", "tile", "extrude", "snub", "semiregular", "33434"], "likes": 79, "viewed": 1132, "published": 3, "date": "1676125872", "time_retrieved": "2024-07-30T18:10:47.731737", "image_code": "/*\n\n    Semi-regular 3,3,4,3,4 Extrusion\n    --------------------------------\n\n    Rendering the buffer.\n \n    See Buffer A for an explanation.\n    \n*/\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.25, coc = 1.65;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n/*\n// Very basic bloom function.\nvec4 bloomBlur(sampler2D iCh, vec2 p){\n    \n    vec4 c = vec4(0);\n\n    const int n = 2;\n    for(int j = -n; j<=n; j++){\n        for(int i = -n; i<=n; i++){\n            c +=  texture(iCh, p + vec2(i, j)/iResolution.xy*2., 1.);\n        }\n    }\n    \n    return c/float((n*2 + 1)*(n*2 + 1));\n   \n}\n*/\n\n\n// This is not a great bokeh function example, but it'll do. It's an amalgamation\n// of old blur and DOF functions with a couple of borrowed lines from Dave Hoskins's \n// much nicer Fibonacci based \"Bokeh disc\" function, which you can find here:\n// https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\n//\nvec3 bokeh(sampler2D iCh, vec2 uv, float radius){\n\n\tvec3 tot = vec3(0), sum = vec3(0);\n\n     // Focal point and circle of confusion.\n    const float focD = 2.15, coc = .6;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float r = (clamp(l/coc, 0., 2.)) + .05;\n     \n\n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){ \n              \n            // If we're not inside the circle, continue.\n            //if(length(vec2(i, j))>float(n)) continue; \n        \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            //vec3 c = texture(iCh, uv + vec2(i, j)/vec2(800, 450)*r, r*.7).xyz; \n            vec3 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7).xyz;\n            // Based on Dave Hoskins's tweak. I've tried my own, and they don't seem to\n            // work as well. If you know of better ways, feel free to let me know.\n            c *= sqrt(c)*4.;\n            vec3 bokeh = pow(c, vec3(4));\n            tot += c*bokeh;\n            sum += bokeh;\n        }\n    }\n    \n\treturn tot/sum;\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Just the unprocessed texture on it's own.\n    //vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Cheap 25 tap depth of field function.\n    vec3 col = DpthFld(iChannel0, uv);\n    \n    \n    // Worst bokeh algorithm ever. :)\n    vec3 bokCol = bokeh(iChannel0, uv, 1.).xyz;\n    col = mix(col, bokCol, .5);\n     \n    /*\n    // Bloom. Too much here.\n    vec3 bloom = bloomBlur(iChannel0, uv).xyz;\n    vec3 bloomLight = vec3(1, .9, .7);\n    col += pow(bloom, 2./bloomLight)*2.;//*.35;\n    */\n    \n         \n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Semi-regular 3,3,4,3,4 Extrusion\n    --------------------------------\n    \n    This is a semi-regular 3,3,4,3,4 tiling in variable height extruded form. I like \n    the overlapping elliptical nature of the pattern. The 2D version isn't what I'd \n    call common in the real world, but thanks to math people who like to code, you'll \n    see it a lot in the 2D graphics world. Oddly enough, the extruded quasi 3D form \n    is not common at all. In fact, I couldn't find an example anywhere. I've noticed \n    this for virtually all semi-regular tilings, which I find perplexing for various \n    reasons... I'll put it down to the mysteries of the graphics world. :)\n    \n    Anyway, I have an almost unhealthy compulsion to drag a 2D pattern off the plane, \n    so I'm slowly growing a collection of extruded semi-regular arrangements on \n    Shadertoy. Like the previous pattern, I coded it up quickly in order to get the \n    job done, so I'd imagine there'd be better ways to do it.\n    \n    I wasn't feeling very creative when it came to presentation, so I attempted to \n    dress the scene up with a few graphics cliches and post processing. Post\n    processing algorithms are mostly common sense, and easy to put together, provided\n    you can use a lot of samples. Unfortunately, slower machines don't like that, so\n    I've attempted to write some lower sampled ones, which are not ideal. They're\n    OK for this... Kind of. The 25 tap DOF isn't too bad, but the hacky bokeh routine\n    is not my best work. :) By the way, if you know of ways to make those functions\n    better, feel free to let me know.\n    \n    \n    \n    Related examples:\n    \n    // I like this example, since it's a simple 2D semi-regular tiling \n    // visual reference. The floret pattern is contained in it somewhere.\n    Wythoff Uniform Tilings + Duals - Fizzer \n    https://www.shadertoy.com/view/3tyXWw\n    \n    // Hyperbolic semi-regular tilings. A really nice example. As an aside,\n    // I have an extruded hyperbolic regular tiled example somewhere.\n    Wythoffian Tiling Generator - mla\n    https://www.shadertoy.com/view/wlGSWc\n    \n    // An unlisted 2D parallelogram grid example that, hopefully, will \n    // show roughly how the pattern was made.\n    Parallelogram Grid - Shane \n    https://www.shadertoy.com/view/dlBSRG\n    \n    \n*/\n\n\n#define FAR 40.\n\n// Animate the pattern. By rotating respective tile angles, it's possible\n// to change the packing arrangement.\n//#define ANIMATE\n\n\n#ifndef ANIMATE\n// I didn't arrange for holes to work during animation -- I may fix that later. You \n// can comment out the following line and override the holes entirely, if desired.\n#define HOLES\n#endif\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n\n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n// Pylon height function.\nfloat hMap(vec2 p){\n    return hash21(p)*.1 + .025;// + (dot(sin(p.xy*2. - cos(p.yx*4.)*2.), vec2(.25)) + .5)*.15;     \n}\n\nvec4 gVal;\n//vec3 glow, lCol; // Global glow and glow color variables.\n\n\nfloat m(vec3 p){\n   \n \n    // The floor.\n    float fl = -p.z;\n    \n    \n    \n    // The semi-regular 3,3,4,3,4 extrusion. By the way, for anyone not familiar with\n    // the nomenclature process, choose any vertex, then count the number of shapes\n    // that surround it -- In this case, you'll see that it is five. Now list the number\n    // of vertices for each shape, then put them in order from smallest (including repeats)\n    // to largest. In this case it'll be, triangle, triangle, square, triangle, square,\n    // which have vertex numbers, 3,3,4,3,4. Simple... Well, I get it wrong all the time,\n    // but it's still a simple process. :D\n    \n    // Scaling variables.\n    float sc = 1./4.5, s = sc*2.;\n    \n    #ifdef ANIMATE\n    // Variable angle. This will work, but the holes will need to be removed.\n    float ang = atan(1., 2.)*(cos(iTime*.5)*.5 + .25);//\n    #else\n    // The angle necessary to make the squares and equilateral triangles pattern...\n    // I can't remember how I came up with it... I probably used math. :D\n    float ang = atan(1., 4.);\n    #endif\n    // h = 1./cos(ang) = R*(1. + sqrt(3.)/2.);\n    // => R = 1./cos(ang)/(1. + sqrt(3.)/2.);\n    //float dim = 1./sin((3.14159/2. + ang))/4.;\n    \n    // The dimensions of the two squares and the two skewed squares (parallelograms).\n    // The two parallelograms are split along the diagonal to form triangles.\n    float dim = 1./cos((ang))/2.;\n    float dim2 = dim*cos(ang*2.);\n    mat2 matA = r2(ang);\n    mat2 matB = r2(-ang);\n    \n    float d = 1e5;\n    const mat4x2 offs = mat4x2(vec2(-.25), vec2(-.25, .25), vec2(.25), vec2(.25, -.25));\n    \n    // Rendering four objects per pass, two of which are split down the center, so \n    // that's six all up.\n    for(int i = min(0, iFrame); i<4; i++){\n    \n        // Local coordinats and ID.\n        vec2 q = p.xy;\n        vec2 iq = floor(q/s - offs[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (iq + offs[i])*s;\n        \n        q -= idi; // New local position.\n        \n        \n        // Rotating q by two different matrices. Mixing the coordinates will produce\n        // two squares and two skewed parallelograms, which will be split across the\n        // diagonal to form triangles.\n        vec2 qA = matA*q, qB = matB*q;\n\n        // This forms the 2D coordinates for four parallelograms -- Two are mutually\n        // perpendicular (qr = qA and qr = qB), so remain square. The other two\n        // coordinate sets are mixed, so will be skewed... It's a simple trick that I\n        // take for granted in situation like this, and is handy to know.\n        vec2 qr = vec2((i==0 || i ==3)? qA.x : qB.x, i<2? qA.y : qB.y);\n        \n         \n        // Edge width and smoothing factor.\n        const float ew = .003, sm = .035; \n        float dm = ((i&1)==0)? dim : dim2;\n        qr = abs(qr) - dm*sc + sm + ew;\n        // 2D parallelogram (or square) distance. Most certainly not a correct distance,\n        // field but it passes the visual test, so it's fine for this demonstration.\n        float d2 = min(max(qr.x, qr.y), 0.) + length(max(qr, 0.)) - sm; \n       \n       \n        vec2 tOffs = i==1 || i==2? vec2(1) : vec2(-1, 1);\n        vec2 idOffs = tOffs*(.7071 + sin(ang)*dim)/4.;\n        \n        float d3, h;\n        \n        if(i==0 || i==2){\n            // The two squares.\n            \n            if(i==0) tOffs *= 0.;\n            \n            #ifdef HOLES\n            // Bore out random holes.\n            if(hash21(idi + .03)<.35){ \n                float hlSz = (hash21(idi - tOffs*s/2. + .04)*.2 + .2)*sc;\n                 d2 = max(d2, -(d2 + hlSz));//abs(d2 + .125) - .125;  \n                //d2 = max(d2, -(length(q) - hlSz/2.5));//abs(d2 + .125) - .125;  \n            }\n            #endif\n        \n           \n            h = hMap(idi - tOffs*s/2.); // Prism height.\n            d3 = opExtrusion(d2, p.z + h/2., h/2.);  // Prism.\n            d3 += d2*.1; // Face slope. \n        }\n        else {\n            \n        \n            // Splitting the parallelograms across the diagonal to \n            // create two triangles.\n            \n            // Triangle dividing line.\n            float triLn;\n            if(i==1) triLn = distLineS(q, vec2(-1, 1)*dim*sc/2., vec2(1, -1)*dim*sc/2.);\n            else triLn = distLineS(q, vec2(0), vec2(1)*dim*sc/2.);\n            \n            float d2B = smax(d2, triLn + ew, sm);\n            d2 = smax(d2, -triLn + ew, sm);\n            \n            \n            #ifdef HOLES\n             // Bore out random holes.\n            if(hash21(idi - tOffs*s/4. + .03)<.35){ \n                float hlSz = (hash21(idi - tOffs*s/4. + .04)*.25 + .25)*sc;\n                //d2 = max(d2, -(d2 + hlSz));//abs(d2 + .125) - .125;  \n                //d2 = max(d2, -(length(q - r2(dir*3.14159/4.)*vec2(sc*.31, 0)) - hlSz/4.));\n                //d2 = max(d2, -(length(q - tOffs*(.7071 + sin(ang)*dim)*sc/4.) - hlSz/3.5));\n                \n                // Triangle holes.\n                vec2 qrr = q - tOffs*(.7071 + sin(ang)*dim)*sc/4.;\n                qrr *= r2(3.14159 - tOffs.x*ang);\n                d2 = max(d2, -getTri(qrr,  hlSz/2.5));\n                 \n            }\n            \n            if(hash21(idi + tOffs*s/4. + .03)<.35){ \n                float hlSz = (hash21(idi + tOffs*s/4. + .04)*.25 + .25)*sc;\n                //d2B = max(d2B, -(d2B + hlSz));//abs(d2 + .125) - .125; \n                //d2B = max(d2B, -(length(q - r2(-dir*3.14159/4.)*vec2(sc*.31, 0).yx) - hlSz/4.));\n                //d2B = max(d2B, -(length(q + tOffs*(.7071 + sin(ang)*dim)*sc/4.) - hlSz/3.5));\n\n                // Triangle holes.\n                vec2 qrr = q + tOffs*(.7071 + sin(ang)*dim)*sc/4.;\n                qrr *= r2(-tOffs.x*ang);\n                d2B = max(d2B, -getTri(qrr,  hlSz/2.5));\n                \n            }\n            #endif\n           \n            // The two triangle prisms on either side of the split.\n            h = hMap(idi - tOffs*s/4.);\n            d3 = opExtrusion(d2, p.z + h/2., h/2.);\n            float hB = hMap(idi + tOffs*s/4.);\n            float d3B = opExtrusion(d2B, p.z + hB/2., hB/2.);\n            d3 += d2*.1;\n            d3B += d2B*.1;\n            \n            // Determine the minimum triangle prism distance.\n            if(d3B<d3){            \n                idi -= tOffs/4.;\n                d3 = d3B;\n                d2 = d2B;\n                h = hB;            \n            }\n            else {\n                idi += tOffs/4.;\n            }\n            \n        \n        }\n \n        // Closest of all the prisms.\n        if(d3<d){\n        \n           d = d3; // Set the new minimum.\n           \n           // Saving the 2D face distance, height, and ID\n           // for this particular prism.\n           gVal = vec4(d2, h, idi);\n        \n        } \n        \n        //if(d<-1e5) break;\n    \n    }\n    \n    // Check to see if the floor is closer.\n    if(fl<d) gVal = vec4(-1);\n    \n    /*\n    // Glow calculations.\n    lCol = vec3(0);\n    if((d)<.25 && d<fl && hash21(gVal.zw + .13)>=.7){\n       float rnd = hash21(gVal.zw);\n       vec3 gCol = .5 + .45*cos(6.2831*rnd/8. + (vec3(0, 1.2, 2) + .5)*1.5 + 1.5);\n       lCol = gCol*smoothstep(0., .5, -(gVal.x));\n    }    \n    */\n    \n    // Minimum scene distance.\n    return min(fl, d);\n    \n}\n\n\n// Basic raymarcher.\nfloat tr(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319) + rd)*.1, d;\n    \n    //glow = vec3(0);\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n         // Accumulate the glow color.\n        //glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.7, .1); \n    }\n\n    return min(t, FAR);\n}\n\n// fb39ca4's inverse mix function.\n// Inverse mix takes a value between \"a\" and \"b\" and maps it to zero to one range.\nfloat invMix(float a, float b, float x) {\n\tx = (x - a)/(b - a);\n    return x*x; // Returning the square for darker tones... My tweak, and not correct.\n}\n\n// IQ's soft shadow function.\nfloat sha(vec3 ro, vec3 lp, vec3 n, float k) {\n\t\n    // Use penumbra modifications.\n    #define PENUM\n    \n\t// More would be nicer. More is always nicer, but not always affordable. :)\n    const int iter = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.; // Initialize the shadow to 1., or no shadow.\n    float t = 0.;//hash31(fract(ro/7.319) + n)*.01; // Scene distance.\n    float maxD = max(length(rd), .0001); // Max light distance.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= maxD; // Normalize.\n\t\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n\tfor (int i = 0; i<iter; i++) {\n \t \n\t\tfloat d = m(ro + rd*t); // Distance to the scene.\n        #ifdef PENUM\n        // This is a tweak I found in fb39ca4's Loxodrom example. It makes sense,\n        // but I'd need to investigate further. The shadows are more succint, but lighter.\n        // https://www.shadertoy.com/view/MsX3D2\n\t\tfloat penumbraDist = t/k;\n\t\tshade = min(shade, invMix(-penumbraDist, penumbraDist, d));\n\t\tt += min((d + penumbraDist)*.5, .2);\n        #else\n        // IQ's simpler calculation. If feel the shade itself is more constistant, but\n        // the shape isn't perfect. Emulating soft shadows isn't easy, if not impossible.\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        t += clamp(d, .005, .2);\n        #endif\n\t\t\n        // Early exit, and not exceeding the maximum light distance.\n        if(d<0. || t>maxD) break;\n\t}\n    \n    #ifdef PENUM\n    // Another one of fb39ca4's additions. Penumbra stuff. :) \n    shade = max(shade, 0.)*2. - 1.;\n\treturn ((sqrt(1. - shade*shade)*shade + asin(shade)) + 3.14159265/2.)/3.14159265;\n    #else\n    return max(shade, 0.);\n    #endif\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\n\tfloat sca = 5., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n/*\n// Standard normal function.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), \n                          m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Unit direction vector, camera (moving along Z), and point light (above the camera).\n    // A \"to\" and \"from\" camera system is better, and only requires a few more lines, but\n    // we're keeping things simple.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         o = vec3(0, iTime/6., -1.25), l = o + vec3(-.25, 4.75, -.5);\n    \n    // Rotating the unit direction ray, for a bit of visual interest.\n    r.xz = r2(.35)*r.xz;\n    r.yz = r2(.75)*r.yz;\n    r.xy = r2(-.5)*r.xy;\n\n    // Raymarching.\n    float t = tr(o, r);\n      \n    // Save the distance function prism information.\n    vec4 svVal = gVal;\n    \n    // Scene color, initialized to zero.\n    c = vec4(0);\n    \n    // If we've hit an object, light it up.\n    if(t<FAR){\n    \n        // Hit point and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Shadow and ambient occlusion.\n        float sh = sha(p, l, n, 8.);\n        float ao = cao(p, n);\n      \n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), .001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n  \n        // Diffuse, half vector specular, and reflective specular.\n        float dif = max(dot(l, n), 0.); //dif = pow(dif, 4.)*2.;\n        float speR = pow(max(dot(normalize(l - r), n), 0.), 16.);\n        float spe = pow(max(dot(reflect(l, n), r), 0.), 5.);\n        \n        // Schlick approximation. I use it to tone down the specular term.\n\t\tfloat Schlick = pow(1. - max(dot(r, normalize(r + l)), 0.), 5.);\n\t\tfloat freS = mix(.7, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n\n        // Scene object color.\n        \n        // Coloring the grid objects.\n        float rnd = hash21(svVal.zw);\n        c = .5 + .45*cos(6.2831*rnd/8. + (vec4(0, 1.2, 2, 0) + .5)*1.5 + 2.25);\n        \n        // Giving the foreground prisms a different color, just for fun.\n        c = mix(c.yxzw, c, smoothstep(0., 1., t/3. - .1));\n        \n        // Setting most of the prisms to grey.\n        if(hash21(svVal.zw + .13)<.75){ \n            c = mix(c, vec4(.2)*dot(c, vec4(.299, .587, .114, 0)) + .15, .95);\n            //glow *= 0.;\n        }\n        \n        // One flat color, if you'd prefer that.\n        //c = vec4(.45, .15, 1, 0); \n\n        // Extra shading.\n        c *= hash21(svVal.zw + .143)*.5 + .5;\n        \n        \n        // Floor.\n        if(abs(svVal.y + 1.)<.001) c = vec4(.05);\n        \n        \n        // Adding some texture.\n        vec3 tx = tex3D(iChannel1, p - vec3(0, 0, svVal.y*2.), n);\n        c.xyz *= (tx*3. + .2);\n         \n        // Cheap specular reflections.\n        vec3 rf = reflect(r, n); // Surface reflection.\n        vec4 rTx = texture(iChannel0, rf); rTx *= rTx;\n        c += (c*.6 + .4)*speR*rTx*1.5;\n        \n        \n        if(svVal.y > 0.){\n            // Face edge distance.\n            float d = max(abs(svVal.x), abs(p.z + svVal.y));\n            c = mix(c, c*.1, 1. - smoothstep(0., .006, d - .002));\n        }\n        \n        // Glow. Not used here.\n        //c.xyz += c.xyz*glow*24.;\n        \n        \n         \n        // Applying diffuse lighting, ambient lighting, and attenuation.\n        c.xyz = c.xyz*(dif*sh + vec3(1, .9, .7)*spe*freS*4.*sh + .35)*1./(1. + d*d*.125)*ao;\n        \n    }\n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    c = mix(clamp(c, 0., 1.), vec4(0), smoothstep(0., .9, t/FAR));\n    \n    // Clamp.\n    c = vec4(clamp(c.xyz, 0., 1.), t);\n    \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but minor temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel2, ivec2(u), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    c = mix(preCol, c, blend);\n    \n    \n    \n    \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 181, 202, 202, 265], [269, 1051, 1088, 1134, 1878], [2212, 2812, 2861, 2861, 4163], [4167, 4167, 4221, 4242, 4843]], "test": "untested"}
{"id": "DlBSDw", "name": "colors benchmark", "author": "chenxianming", "description": "view this benchmark via \nhttp://benchart.cn/70rl8xdw/", "tags": ["lookup", "cineshader"], "likes": 4, "viewed": 1727, "published": 3, "date": "1676122285", "time_retrieved": "2024-07-30T18:10:48.497689", "image_code": "mat2 n(float a) { float b = sin(a), c = cos(a); return mat2(c, b, -b, c); } \nconst mat2 z = mat2(-1.1, -.4, .3, 1); \nfloat A(in vec2 a) { return sin(a.x) * sin(a.y); } \nfloat o(vec2 b) { float c = 0.; for (float a = 0.; a < 5.; a++) c += .15 * A(b * a), b = z * b * abs(a - 2.) * 2.3; return c / 1.; } \nvec2 h(vec2 a) { return vec2(o(a), o(a + vec2(7.8))); } \nfloat p(vec3 b, int d) { vec3 a = b; float c = length(a) - .5 + h(a.yz - iTime * .2).y * 1.5 * h(a.xz - iTime * .2).x * 1. * cos(a).y * 1. * .6; return c; } \nfloat e(vec3 a) { vec3 b = a; float c = p(b, 1); return c; } \nvec3 q(in vec3 b) { vec2 a = vec2(1, -1) * .5773; return normalize(a.xyy * e(b + a.xyy * 5e-4) + a.yyx * e(b + a.yyx * 5e-4) + a.yxy * e(b + a.yxy * 5e-4) + a.xxx * e(b + a.xxx * 5e-4)); } \n\n\nvoid mainImage(out vec4 U, in vec2 V) { \n\n    vec2 a = V.xy / iResolution.yy; \n    a.x -= (iResolution.x - iResolution.y) / iResolution.y * .5; \n    float i = iTime * .4; a = (a - .5) * 1.35; \n    vec3 b = vec3(cos(i) * -1.2, 0, sin(i) * -1.2), r = vec3(0, 0, 0); \n    b = vec3(0, 0, -1); \n    vec3 c = normalize(r - b), j = normalize(cross(c, vec3(0, 1, 0))), s = normalize(cross(j, c)), m = vec3(0), d = normalize(a.x * j + a.y * s + 1.5 * c); \n    float f = 0.; for (int t = 0; t < 5; ++t) { vec3 u = b + d * f; float B = e(u); f += B * .9999; } \n    vec3 k = vec3(0), l = normalize(vec3(.57703)); \n    l.yz *= n(-iTime * .5), l.xy *= n(iTime * .5); \n    vec3 v = normalize(l - d); if (f < 5.) { vec3 w = b + f * d, g = q(w); \n    float x = clamp(dot(g, vec3(.4, 1, -.5)), 0., 1.), y = pow(clamp(dot(g, v), 0., 1.), 125.) * .6; y *= x; \n    float C = dot(g, vec3(0, 1, 0)); k = y + vec3(.1) * C + vec3(.5) * x + vec3(.5); } k = sqrt(k), m += k, m *= .7 + .3 * cos(iTime + a.xyx + vec3(0, 2, 4)), U = vec4(m, 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 75], [117, 117, 137, 137, 167], [169, 169, 186, 186, 301], [303, 303, 319, 319, 358], [360, 360, 384, 384, 516], [518, 518, 535, 535, 578], [580, 580, 599, 599, 768], [772, 772, 811, 811, 1789]], "test": "untested"}
{"id": "DtBSWw", "name": "dark star ", "author": "FabriceNeyret2", "description": "trying to port yonatan @zozuar [url] https://twitter.com/zozuar/status/1624060123957035010 [/url]", "tags": ["short", "golf", "reproduction", "twigl"], "likes": 68, "viewed": 1136, "published": 3, "date": "1676114283", "time_retrieved": "2024-07-30T18:10:49.249679", "image_code": "// porting yonatan @zozuar https://twitter.com/zozuar/status/1624060123957035010\n//                         https://twigl.app/?ol=true&ss=-NNvoVus2U-Pm1lzLVMb\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec4 V; r = iResolution.xy; t = iTime;  // Complicated transmission of iResolution, iChannel0, iTime, because shadertoy :-(\n    \n    O = Image( V, u, iChannel0 );\n    O += V;\n\n/*\n    #define R(a) mat2(cos(a+vec4(0,11,33,0)))\n    \n    vec2  r = iResolution.xy,\n          p = (u+u-r) / r.y, q, n=r-r;\n    float S = 6.,a=0.,i=a, d = dot(p,p), e = 2e2, t = iTime, s=a;\n    p = p/( .7-d ) + t/3.14;\n    for( O *= 0. ; i++ < e ; O += texture( iChannel0, (u/r-.5)*i/e+.5 ) / e)\n        p *= R(5.), n *= R(5.),\n        a += dot( sin( q = p*S +i -abs(n)*R(t*.2) ) / S, r/r ),\n        n += cos(q), \n        S *= 1.1;\n    a = max( s, .9 -a*.2 -d );\n    O += pow( a+ a*vec4(8,4,1,0)/e , O+40. );\n // O += o1 = pow( a+ a*vec4(8,4,1,0)/e , O+40. );\n*/\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec4 V; r = iResolution.xy; t = iTime;  // Complicated transmission of iResolution, iChannel0, iTime, because shadertoy :-(\n    O = Image( V, u, iChannel0 );\n    O = clamp(O, 0.,1.);\n    \n/*\n    #define R(a) mat2(cos(a+vec4(0,11,33,0)))\n\n    vec2  r = iResolution.xy,\n          p = (u+u-r) / r.y, q, n=r-r;\n    float S = 6.,a=0.,i=a, d = dot(p,p), e = 2e2, t = iTime, s=a;\n    p = p/( .7-d ) + t/3.14;\n    for( O *= 0. ; i++ < e ; O += texture( iChannel0, (u/r-.5)*i/e+.5 ) / e)\n        p *= R(5.), n *= R(5.),\n        a += dot( sin( q = p*S +i -abs(n)*R(t*.2) ) / S, r/r ),\n        n += cos(q), \n        S *= 1.1;\n    a = max( s, .9 -a*.2 -d );\n    O = pow( a+ a*vec4(8,4,1,0)/e , O+40. );\n*/\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 r; float t; // Complicated transmission of iResolution, iChannel0, iTime, because shadertoy :-(\n\n#define R(a) mat2(cos(a+vec4(0,11,33,0)))\n\nvec4 Image( out vec4 O, vec2 u , sampler2D ch )\n{\n    vec2  p = (u+u-r) / r.y, q, n = r-r;\n    float S = 6.,a=0.,i=a, d = dot(p,p), e = 2e2, s=a;\n    p = p/( .7-d ) + t/3.14;\n    for( O *= 0. ; i++ < e ; O += texture( ch, (u/r-.5)*i/e+.5 ) / e)\n        p *= R(5.), n *= R(5.),\n        a += dot( sin( q = p*S +i -abs(n)*R(t*.2) ) / S, r/r ),\n        n += cos(q), \n        S *= 1.1;\n    a = max( s, .9 -a*.2 -d );\n    return pow( a+ a*vec4(8,4,1,0)/e , O+15. );  // was + 40.\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 943]], "test": "untested"}
{"id": "DlBSDW", "name": "Yin Yang Bangles", "author": "FabriceNeyret2", "description": "inspiration: Gianni A. Sarcone  [url]https://twitter.com/gsarcone/status/1623399098811355136[/url]", "tags": ["short", "golf", "reproduction"], "likes": 29, "viewed": 322, "published": 3, "date": "1676108890", "time_retrieved": "2024-07-30T18:10:50.003662", "image_code": "#define S(v,s) smoothstep( 0., s 36./R.y, v ) // antialiasing, to black or white dep sign s\n\n#define D(L,A,k) w = length( vec2( sqrt(L*L-d*d) - l*cos(A-a), d - l*abs(sin(A-a)) ) ),       \\\n                 s = mix( S( abs( w -.85 ) -.3, k ),                        /* ring end    */ \\\n                          abs(A-a)*l < 1. && abs(l-L) < .6 ? .5 + k .5 : s, /* ring or gap */ \\\n                          S( w - 1., ) )\n//  general case, with pattern at angles wrap:  abs( mod(A-a +3.14, 6.283) - 3.14 ) < 1./l\n        \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 12.* ( u+u - R ) / R.y;\n    float a = atan(U.y,U.x), d = 1.15, w,\n          l = length(U),\n          s = S( abs( mod( l < 11. ? l+1. : 0. , 2. ) - 1. ) -.45 , ); // main \"target\" shape\n    \n    D(10., -2.1 ,  );  // black bangles ends\n    D( 8., -1.6 ,  );\n    D( 6., -1.  ,  );\n    D( 4., -.2  ,  );\n    \n    D( 9.,  1.  , -);  // white bangles ends\n    D( 7.,  1.6 , -);\n    D( 5.,  2.4 , -); \n    D( 3., -2.8 , -); \n    \n    O = vec4( sqrt( s ));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtjSDD", "name": "C# (programming language) logo", "author": "mrange", "description": "C0: C# (programming language) logo\n Took some liberties with the \"hashtag\"\n Based on: https://learn.microsoft.com/en-us/windows/images/csharp-logo.png\n", "tags": ["logo", "c"], "likes": 12, "viewed": 406, "published": 3, "date": "1676108268", "time_retrieved": "2024-07-30T18:10:51.011969", "image_code": "// CC0: C# (programming language) logo\n//  Took some liberties with the \"hashtag\"\n//  Based on: https://learn.microsoft.com/en-us/windows/images/csharp-logo.png\n\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec4 csharp(vec2 p, float aa) {\n  const float invgamma = 2.0;\n  const vec3 bgcol0 = pow(vec3(164.0, 124.0, 222.0)/255.0, vec3(invgamma));\n  const vec3 bgcol1 = pow(vec3(037.0, 000.0, 104.0)/255.0, vec3(invgamma));\n  const vec3 bgcol2 = pow(vec3(055.0, 000.0, 147.0)/255.0, vec3(invgamma));\n  const vec3 white  = vec3(1.0); \n\n  vec2 pp = p;\n  pp.y = abs(pp.y);\n\n  float l   = length(p);\n  float hd  = hexagon(p.yx, 0.4)-0.1;\n  float fsd = dot(normalize(vec2(-1.0, sqrt(3.0))), p);\n  float rsd = dot(normalize(vec2(-1.0, -sqrt(3.0))), p);\n  float cd  = abs(l-0.25)-0.08;\n  float sd  = max(fsd, rsd);\n  float bd  = abs(l-0.25)-0.03;\n  bd        = abs(bd) - 0.0125;\n  float dd  = dot(normalize(vec2(-1.0, 2.9)), pp);\n  bd        = max(bd, dd);\n  float ld  = dot(normalize(vec2(-1.0, 7.0)), pp);\n  ld        = abs(ld) - 0.0125;\n  bd        = min(bd, ld);\n  float od  = abs(l-0.25)-0.0666;\n  bd        = max(bd, od);\n    \n  vec3 bgcol = mix(bgcol0, bgcol1, smoothstep(aa, -aa, fsd));\n  \n  vec3 col = vec3(0.0);\n  float t = smoothstep(aa, -aa, hd);\n  \n  col = bgcol;\n  col = mix(col, white  , smoothstep(aa, -aa, cd));\n  col = mix(col, bgcol2 , smoothstep(aa, -aa, sd));\n  col = mix(col, white  , smoothstep(aa, -aa, bd));\n\n  return vec4(col, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  vec4 cc = csharp(p, 2.0/RESOLUTION.y);\n  col = mix(col, cc.xyz, cc.w);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 374, 406, 406, 592], [594, 594, 625, 625, 1835], [1837, 1837, 1894, 1894, 2140]], "test": "untested"}
{"id": "mljSDW", "name": "Recursion for Windows Terminal", "author": "mrange", "description": "CC0: Recursion for Windows Terminal\nTweaked an earlier shader for use with Windows Terminal\nhttps://github.com/mrange/windows-terminal-shader-gallery\n\n", "tags": ["recursion"], "likes": 14, "viewed": 357, "published": 3, "date": "1676103807", "time_retrieved": "2024-07-30T18:10:51.866681", "image_code": "// CC0: Recursion for Windows Terminal\n//  Tweaked an earlier shader for user with Windows Terminal\n//  https://github.com/mrange/windows-terminal-shader-gallery\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PI_2            (0.5*PI)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.025, 0.85, 0.5));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.75, 0.85, 1.0));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 ce = sph.xyz;\n  float ra= sph.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += clamp(vec3(0.0025/abs(rd.y))*glowCol, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nfloat split(vec3 sp, vec4 sph, float h) {\n  const float aa = 0.04;\n  float angle = atan_approx(sp.x, sp.z)+h*TAU;\n  float d = sph.w*(0.5*sin(4.0*angle)+0.15)/2.5-sp.y;\n  return smoothstep(-aa, aa, d);\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 ld = normalize(vec3(0.0) - ro);\n\n  vec3 bcol = vec3(0.0);\n  vec3 fcol = vec3(0.0);\n  \n  float ftm = TIME*TAU*10.0;\n  const float foff = 0.3;\n  const vec3 beerf = -0.125*vec3(1.0, 2.0, 3.0);\n  float tm = TIME*0.05;\n  float ff = fract(tm);\n  float ofo = smoothstep(0.9, 0.0, ff);\n  float flare = smoothstep(0.0, 1.0, cos(TAU*ff));\n\n  vec3 light = (mix(vec3(.001), 0.5*vec3(0.015, 0.01, 0.025), flare))/(0.0001+ 1.0-max(dot(ld, rd), 0.0));\n\n  const float MaxIter = 12.0;\n  for (float i = 0.0; i <  MaxIter; ++i) {\n    float j = i+floor(tm);\n    float h = hash(j+123.4);\n    vec4 sph = vec4(vec3(0.0) , 4.5*exp2(-(i-ff)*0.5));\n\n    vec2 s2 = raySphere(ro, rd, sph);\n\n    float sd = s2.y - s2.x;\n    if (sd == 0.0) {\n      break;\n    }\n    \n    float fo = i == 0.0 ? ofo : 1.0;\n    \n    vec3 beer0 = exp(beerf*(s2.x));\n    vec3 p0 = ro+rd*s2.x;\n    vec3 sp0 = p0 - sph.xyz;\n    vec3 n0 = normalize(sp0);\n    vec3 r0 = reflect(rd, n0);\n    float fre0 = 1.0+dot(rd, n0);\n    fre0 *= fre0;\n    float dif0 = mix(0.25, 1.0, max(dot(sunDir1, n0), 0.0)); \n    float s0 = split(sp0, sph, h);\n    vec3 rcol0 = mix(0.1, 1.0, fre0)*render0(p0, r0);\n    vec3 dcol0 = sunCol1*dif0*dif0*diffCol;\n    rcol0 += 0.125*dcol0;\n    dcol0 += 0.125*rcol0;\n    rcol0 *= beer0;\n    dcol0 *= beer0;\n    rcol0 *= fo;\n\n    if (s0 > 0.9) {\n      bcol = mix(bcol, mix(bcol, dcol0, tanh_approx(0.18*s2.x)), s0*fo);\n      break;\n    }\n    \n    fcol += rcol0*(1.0-s0);\n\n    vec3 beer1 = exp(beerf*(s2.y));\n    vec3 p1 = ro+rd*s2.y;\n    vec3 sp1 = p1 - sph.xyz;\n    vec3 n1 = -normalize(sp1);\n    float dif1 = mix(0.25, 1.0, max(dot(sunDir1, n1), 0.0)); \n    float s1 = split(sp1, sph, h);\n    vec3 dcol1 = sunCol1*dif1*dif1*diffCol;\n    dcol1 *= beer1;\n    s1 *= fo;\n    bcol = mix(bcol, dcol1, s1);\n    bcol += light*beer1*fo;\n  }\n\n\n  vec3 col = bcol;\n  col += fcol;\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = TIME*0.5;\n  \n  vec3 ro = vec3(5.0, 3.0, 0.);\n  ro.xz *= ROT(-0.05*tm+3.0);\n  const vec3 la = vec3(0.0, 0.5, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  float ll = length(pp);\n  col *= smoothstep(1.5, 0.5, ll);\n  col -= 0.033*vec3(3.0, 2.0, 1.0)*(ll+0.25);\n  col = aces_approx(col); \n  col = sRGB(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 569, 569, 715], [1404, 1504, 1523, 1523, 1610], [1612, 1719, 1745, 1745, 1929], [1931, 2024, 2066, 2066, 2113], [2115, 2233, 2260, 2260, 2336], [2338, 2430, 2474, 2474, 2718], [2720, 2806, 2843, 2843, 2950], [2952, 3080, 3108, 3174, 3250], [3252, 3312, 3334, 3334, 3382], [3385, 3385, 3417, 3417, 4070], [4072, 4072, 4113, 4113, 4274], [4276, 4276, 4308, 4308, 6162], [6164, 6164, 6194, 6194, 6757], [6759, 6759, 6816, 6816, 7007]], "test": "untested"}
{"id": "dl2XW1", "name": "1px wide line", "author": "rsk", "description": "Shader for rendering 1px wide lines", "tags": ["simple", "line", "px", "1px", "itsharderthanyouthink"], "likes": 5, "viewed": 252, "published": 3, "date": "1676103717", "time_retrieved": "2024-07-30T18:10:52.730372", "image_code": "// 1px wide line\n// author: rsk -> https://twitter.com/rsk\n\n// sets pixel size for rendering\n#define PX_SIZE 1.0\n\nbool isLine(vec2 a, vec2 b, vec2 p) {\n    // line parametric equation:\n    // x = x0 + ab.x * t\n    // y = y0 + ab.y * t\n    //\n    a = floor(a);\n    b = floor(b);\n    // `+ 0.01` allows to render zero length lines (if `ab == (0, 0)`, `t` will\n    // be `nan`), and at same time it will not affect rendered pixel position,\n    // because it will keep shifted position in the same integer cell\n    b.x += 0.01;\n    p = floor(p);\n\n    vec2 ab = b - a;\n    // swap `x` and `y` if needed\n    // algorithm depends on which side is wider `x` or `y`, but both variants is\n    // similar just instead of `x` `y` is used, swapping allows simplify code,\n    // and get rid of `if` branching\n    int i = int(abs(ab.x) > abs(ab.y));\n    int xi = 1 - i;\n    int yi = i;\n    float t = (p[xi] - a[xi]) / ab[xi];\n    float y = round(a[yi] + ab[yi] * t);\n    // `x` should be rounded because `0.01` was added before, otherwise some\n    // tests will fail, line will not be rendered in some places\n    float minX = round(min(a[xi], b[xi]));\n    float maxX = round(max(a[xi], b[xi]));\n    return p[yi] == y && minX <= p[xi] && p[xi] <= maxX;\n}\n\nbool seg(vec2 position, float size, float rotation, vec2 fragment) {\n    vec2 cs = vec2(cos(rotation), sin(rotation));\n    vec2 a = -cs * size / 2.0 + position;\n    vec2 b =  cs * size / 2.0 + position;\n    return isLine(a, b, fragment);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoord /= PX_SIZE;\n    const float tau = 6.283185307179586;\n    vec2 r = iResolution.xy / PX_SIZE;\n    float s = min(r.x, r.y) / 2.25;\n    \n    vec2 p = r / vec2(3.0, 2.0);\n    bool lines = seg(p, s, 0.0, fragCoord);\n    lines = lines || seg(p, s, tau / 4.0, fragCoord);\n    \n    float pxScale = s / 200.0;\n    // zero length line, rendered as one pixel\n    lines = lines || isLine(p + round(vec2(10.0) * pxScale), p + round(vec2(10.0) * pxScale), fragCoord);\n    lines = lines || isLine(p + round(vec2(15.0) * pxScale), p + round(vec2(50.0) * pxScale), fragCoord);\n    lines = lines || isLine(p + round(vec2(15.0) * pxScale), p + round(vec2(20.0, 25.0) * pxScale), fragCoord);\n    lines = lines || isLine(p + round(vec2(15.0) * pxScale), p + round(vec2(25.0, 20.0) * pxScale), fragCoord);\n\n    p += vec2(p.x, 0.0);\n    float t = iTime / 3.0;\n    lines = lines || seg(p, s, t, fragCoord);\n    float tShifted = iTime / 25.0 + tau / 4.0;\n    lines = lines || seg(p, s, tShifted, fragCoord);\n    tShifted += tau / 4.0;\n    lines = lines || seg(p, s, tShifted, fragCoord);\n    \n    const int steps = 20;\n    p = r / vec2(float(steps) + 1.0, 7.0);\n    float ps = s / 5.5;\n    for (int i = 0; i < steps; i++) {\n        lines = lines || seg(p + vec2(p.x * float(i), 0.0), ps, tau / float(steps - 1) * float(i), fragCoord);\n    }\n    p = vec2(r.x/(float(steps) + 1.0), r.y * 6.0 / 7.0);\n    for (int i = 0; i < steps; i++) {\n        lines = lines || seg(p + vec2(p.x * float(i), 0.0), ps, tau / float(steps - 1) * float(i), fragCoord);\n    }\n    fragColor = vec4(vec3(!lines), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2XW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 151, 241, 1238], [1240, 1240, 1308, 1308, 1479]], "test": "untested"}
{"id": "DtjXDD", "name": "Truchet FBM Lace", "author": "fenix", "description": "Just trying to understand noise and I wondered what it would look like to try to build a noise function on top of a truchet pattern. I came across this lacy pattern and I thought it was interesting enough to share.", "tags": ["fbm", "truchet"], "likes": 15, "viewed": 264, "published": 3, "date": "1676101636", "time_retrieved": "2024-07-30T18:10:53.483360", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//    Just trying to understand noise and I wondered what it would look like to try to\n//    build a noise function on top of a truchet pattern. I came across this lacy pattern\n//    and I thought it was interesting enough to share.\n//\n// ---------------------------------------------------------------------------------------\n\n// From iq's Noise - gradient - 2D https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));                       \n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nconst float PI = 3.141592653589793;\n\nfloat truchet(vec2 p, float t)\n{\n    float a = trunc(grad(ivec2(p)).x * 4.) * PI * .5;\n    vec2 uv = (fract(p) - .5) * rotate(a) + .5;\n    return smoothstep(t, 0., abs(length(uv) - .5)) + smoothstep(t, 0., abs(length(uv - 1.) - .5));\n}\n\nvec3 truchetFbm(vec2 p)\n{\n    vec3 c = vec3(0);\n    float t = .0005;\n    for (float i = 0.; i < 50.; ++i)\n    {\n        p += i*vec2(0.01 * iTime + .3, 0.) * rotate(i * 4.);\n        c = max(c, truchet(p, t));\n        const float R = 1.1;\n        p = p * rotate(1.9) * R;\n        t *= R;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 bg = normalize(sin(iTime + u.x + u.y + vec3(0, 1, 3)) * .5 + .5) * .5;\n    O.rgb = truchetFbm(u*.25) + bg;\n    O.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjXDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[537, 610, 687, 741, 997], [999, 999, 1021, 1021, 1101], [1140, 1140, 1172, 1172, 1375], [1377, 1377, 1402, 1402, 1684], [1686, 1686, 1724, 1724, 1910]], "test": "untested"}
{"id": "dtjSWW", "name": "Simple LoDless Shaded Clouds", "author": "42yeah", "description": "Raymarched clouds. The clouds are not very good. This is a demo shader of a blog post, in which I dissect iq's cloud shader: https://blog.42yeah.is/rendering/2023/02/11/clouds.html", "tags": ["clouds"], "likes": 11, "viewed": 3842, "published": 3, "date": "1676101476", "time_retrieved": "2024-07-30T18:10:54.342063", "image_code": "float rand(vec3 p) \n{\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\nfloat valueNoise(vec3 p) \n{\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\nfloat fbm(vec3 p) \n{\n    vec3 q = p - vec3(0.1, 0.0, 0.0) * iTime;\n//    vec3 q = p;\n    int numOctaves = 4;\n    float weight = 0.5;\n    float ret = 0.0;\n    \n    // fbm\n    for (int i = 0; i < numOctaves; i++)\n    {\n        ret += weight * valueNoise(q); \n        q *= 2.0;\n        weight *= 0.5;\n    }\n    return clamp(ret - p.y, 0.0, 1.0);\n}\n\nvec3 sunDir = normalize(vec3(1.0, 1.0, 2.0));\n\nvec4 volumetricMarch(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 150; i++)\n    {\n        vec3 p = ro + depth * rd;\n        float density = fbm(p);\n        \n        // If density is unignorable...\n        if (density > 1e-3)\n        {\n            // We estimate the color with w.r.t. density\n            vec4 c = vec4(mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), density), density);\n            // Multiply it by a factor so that it becomes softer\n            float dif = clamp(density - fbm(p + 0.3 * sunDir) / 0.3, 0.0, 1.0);\n            vec3 lig = vec3(1.0) + vec3(0.9, 0.7, 0.0) * dif;\n            c.rgb *= lig;\n            \n            c.a *= 0.4;\n            c.rgb *= c.a;\n            color += c * (1.0 - color.a);\n        }\n        \n        // March forward a fixed distance\n        depth += max(0.05, 0.02 * depth);\n    }\n    \n    return vec4(clamp(color.rgb, 0.0, 1.0), color.a);\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 sc = mix(vec3(1.0), vec3(0.1, 0.5, 1.0), clamp(rd.y, -1.0, 1.0) * 0.5 + 0.5);\n    sc += max(vec3(0.0), pow(dot(rd, sunDir) * vec3(1.0, 1.0, 0.0), vec3(24.0)));\n    return sc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 ro = vec3(0.0, 1.0, iTime);\n    vec3 front = normalize(vec3(0.0, -0.3, 1.0));\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat3 lookAt = mat3(right, up, front);\n    vec3 rd = lookAt * normalize(vec3(uv, 1.0));\n    vec3 skyColor = getSky(rd);\n    vec4 cloudColor = volumetricMarch(ro, rd);\n    \n    // Alpha composite with sky\n    vec3 c = clamp(cloudColor.rgb + (1.0 - cloudColor.a) * skyColor, 0.0, 1.0);\n    \n    // Gamma correction\n    c = pow(c, vec3(0.4545));\n    \n    fragColor = vec4(\n        c,\n        1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 106], [108, 108, 135, 135, 704], [706, 706, 726, 726, 1050], [1099, 1099, 1139, 1139, 2060], [2062, 2062, 2084, 2084, 2270], [2272, 2272, 2327, 2327, 3052]], "test": "untested"}
{"id": "Dl2XWD", "name": "Fork Fork Simpl birdmachin 817", "author": "Birdmachine", "description": "Parallax scrolling fractal galaxy.\nInspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr", "tags": ["fractal", "cineshader"], "likes": 18, "viewed": 2775, "published": 3, "date": "1676095920", "time_retrieved": "2024-07-30T18:10:55.098042", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2)); \n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2XWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 255, 255, 642], [644, 680, 714, 714, 1102], [1104, 1104, 1128, 1128, 1311], [1314, 1314, 1371, 1371, 2790]], "test": "untested"}
{"id": "Dl2SDW", "name": "Mipped Bicubic Texture Filtering", "author": "N8Shader", "description": "It's kinda hacky trilinear interpolation of bicubic filtering on mips.", "tags": ["texture", "filter", "bicubic"], "likes": 6, "viewed": 525, "published": 3, "date": "1676085122", "time_retrieved": "2024-07-30T18:10:55.875962", "image_code": "// Original filtering function from https://www.shadertoy.com/view/4df3Dn\nfloat w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nfloat h1(float a)\n{\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod)\n{\n\tuv = uv*texelSize.zw + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = h0(fuv.x);\n    float h1x = h1(fuv.x);\n    float h0y = h0(fuv.y);\n    float h1y = h1(fuv.y);\n\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\t\n    vec2 lodFudge = pow(1.95, lod) / fullSize;\n    return g0(fuv.y) * (g0x * \n        textureLod(tex, p0, lod)  +\n                        \n        g1x * textureLod(tex, p1, lod)\n                    ) +\n           g1(fuv.y) * (\n            g0x * textureLod(tex, p2, lod)  +\n                        g1x * textureLod(tex, p3, lod));\n}\n\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n vec2 fullSize = vec2(textureSize(s, 0));\n vec4 floorSample = texture_bicubic( s, uv, vec4(1.0 / lodSizeFloor.x, 1.0 / lodSizeFloor.y, lodSizeFloor.x, lodSizeFloor.y), fullSize, floor(lod));\n vec4 ceilSample = texture_bicubic( s, uv, vec4(1.0 / lodSizeCeil.x, 1.0 / lodSizeCeil.y, lodSizeCeil.x, lodSizeCeil.y), fullSize, ceil(lod));\n return mix(floorSample, ceilSample, fract(lod));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float lod = 10.0 * (0.5 + 0.5 * (-cos(0.5 * iTime)));\n    fragColor = textureBicubic(iChannel0, uv, lod);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2SDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 93, 93, 148], [150, 150, 169, 169, 219], [221, 221, 240, 240, 299], [301, 301, 320, 320, 352], [354, 399, 418, 418, 446], [448, 448, 467, 467, 495], [497, 539, 558, 558, 603], [605, 605, 624, 624, 668], [670, 670, 758, 758, 1599], [1602, 1602, 1656, 1656, 2153], [2155, 2155, 2212, 2262, 2414]], "test": "untested"}
{"id": "dlBXWh", "name": "Glowing Julia", "author": "fishy", "description": "Julia set", "tags": ["julia"], "likes": 5, "viewed": 152, "published": 3, "date": "1676064832", "time_retrieved": "2024-07-30T18:10:56.634933", "image_code": "// I am almost certain this can be made in under a tweet, but I can't\n\n#define f(a) (a*3.-iResolution.xy)/iResolution.y-vec2(0.9, .5)\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec2 z = f(p),\n    m = mix(sin(iTime+vec2(0, 1.6))*cos(iTime*1.6), // No mouse input\n            f(iMouse.xy), // Mouse input\n            min(1., iMouse.x)); // switch between the two\n    for(float i = 0.; i < 50. && length(z = vec2(z.x*z.x - z.y*z.y + m.x, 2.*z.x*z.y + m.y)) < 14.; i++)\n    c = cos(i/33.+vec4(5, 4, 2, 0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 176, 176, 508]], "test": "untested"}
{"id": "mtBXDW", "name": "Black and White Simple Ripples", "author": "alexisupsidedown", "description": "A shader that generates black and white ripples.", "tags": ["waves", "ripples", "sound", "interference", "physics"], "likes": 2, "viewed": 171, "published": 3, "date": "1676060411", "time_retrieved": "2024-07-30T18:10:57.463717", "image_code": "#define PI 3.14159265358979323846\n#define RIPPLE_AMOUNT 10.0\n\n#define ADD_SECOND_SOURCE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    vec2 mouse_uv = iMouse.xy / iResolution.yy; // think of the mouse_uv as an offset from 0,0\n    vec3 color = vec3(0.0);\n    \n    {\n        float d = distance(uv, mouse_uv); // suggestion by @eo\n        float sine = sin((RIPPLE_AMOUNT * d - iTime) * PI);\n        color += vec3(sine); // suggestion by @eo\n    }\n    \n    #ifdef ADD_SECOND_SOURCE\n    {\n        float d = distance(uv, vec2(.5));\n        float sine = sin((RIPPLE_AMOUNT * d - iTime) * PI);\n        color += vec3(sine);\n    }\n    #endif\n    \n    // normalise - from -1..1 to 0..1\n    color = vec3(0.5 + 0.5 * color.r); // suggestion by @eo\n    \n    // thank you @eo for cleaning up my code :D\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 146, 146, 889]], "test": "untested"}
{"id": "dtSSWW", "name": "Lyapunov Exponents for Double Pe", "author": "epsil0n", "description": "Compute the Lyapunov Exponents for each point, corresponding to a initial condition of the pendulum", "tags": ["math"], "likes": 0, "viewed": 167, "published": 3, "date": "1676052529", "time_retrieved": "2024-07-30T18:10:58.381263", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 col = texture(iChannel0, uv);\n\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "precision highp float;\n\nfloat epsi = 0.001;\nfloat step = 0.001;\n\nfloat m1 = 1.;\nfloat m2 = 1.;\nfloat l1 = 1.;\nfloat l2 = 1.;\nfloat mu = 2.;\nfloat g = 9.81;\nfloat PI = 3.14155926535893972384;\n\nfloat random (vec2 st) {\n\treturn fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat ddTheta1(float Theta1, float Theta2, float dTheta1, float dTheta2){\n\treturn (g*(sin(Theta2)*cos(Theta1-Theta2)-mu*sin(Theta1))-(l2*dTheta2*dTheta2+l1*dTheta1*dTheta1*cos(Theta1-Theta2))*sin(Theta1-Theta2))/(l1*(mu-cos(Theta1-Theta2)*cos(Theta1-Theta2)));\n}\n\nfloat ddTheta2(float Theta1, float Theta2, float dTheta1, float dTheta2){\n\treturn (mu*g*(sin(Theta1)*cos(Theta1-Theta2)-sin(Theta2))+(mu*l1*dTheta1*dTheta1+l2*dTheta2*dTheta2*cos(Theta1-Theta2))*sin(Theta1-Theta2))/(l2*(mu-cos(Theta1-Theta2)*cos(Theta1-Theta2)));\n}\n\nfloat map(float x, float in_min, float in_max, float out_min, float out_max)\n{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float maxiter = map(float(iFrame), 0., 900., 0., 5000.) ;\n\tvec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n\n\n\n\tfloat x0 = map(uv.x, -1.5 * 16./9., 1.5 * 16./9., -PI, PI);\n\tfloat y0 = map(uv.y, -1.5, 1.5, -PI, PI);\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tvec2 r = vec2(1., 0.);\n\tfloat iteration = 0.;\n\tfloat xtemp = 0.0;\n\n\n\tfloat a0, b0, c0, d0;\n\tfloat a1, b1, c1, d1;\n\n\tfloat theta1_pend1, theta2_pend1;\n\tfloat dTheta1_pend1, dTheta2_pend1;\n\n\tfloat theta1_pend2, theta2_pend2;\n\tfloat dTheta1_pend2, dTheta2_pend2;\n\n\tfloat l_theta1, l_theta2;\n\n\tfloat maxLyap = 0.;\n\tfloat minLyap = 1e10;\n\n\tfloat dx, dy, dInit;\n\n\tdTheta1_pend1 = 0.;\n\tdTheta2_pend1 = 0.;\n\tdTheta1_pend2 = 0.;\n\tdTheta2_pend2 = 0.;\n\ttheta1_pend1 = map(x0, -2., 2., 0., 2. * PI);\n\ttheta2_pend1 = map(y0, -2., 2., 0., 2. * PI);\n\ttheta1_pend2 = theta1_pend1 + 0.1;\n\ttheta2_pend2 = theta2_pend1 + 0.1;\n\n\tdx = theta1_pend1 - theta1_pend2;\n\tdy = theta2_pend1 - theta2_pend2;\n\n\tdInit = sqrt(dx * dx + dy * dy);\n    \n\n\tfor (float iter = 0.; iter < maxiter; iter++){\n\t\t//First pendulum\n\t\ta0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1,        dTheta2_pend1);\n\t\ta1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1,        dTheta2_pend1);\n\t\tb0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + a0/2., dTheta2_pend1 + a1/2.);\n\t\tb1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + a0/2., dTheta2_pend1 + a1/2.);\n\t\tc0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + b0/2., dTheta2_pend1 + b1/2.);\n\t\tc1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + b0/2., dTheta2_pend1 + b1/2.);\n\t\td0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + c0,   dTheta2_pend1 + c1);\n\t\td1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + c0,   dTheta2_pend1 + c1);\n\n\t\tdTheta1_pend1 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\tdTheta2_pend1 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\ta0 = step *  dTheta1_pend1;\n\t\ta1 = step *  dTheta2_pend1;\n\t\tb0 = step * (dTheta1_pend1 + a0/2.);\n\t\tb1 = step * (dTheta2_pend1 + a1/2.);\n\t\tc0 = step * (dTheta1_pend1 + b0/2.);\n\t\tc1 = step * (dTheta2_pend1 + b1/2.);\n\t\td0 = step * (dTheta1_pend1 + c0);\n\t\td1 = step * (dTheta2_pend1 + c1);\n\n\t\ttheta1_pend1 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\ttheta2_pend1 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\t//Second pendulum\n\t\ta0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2,        dTheta2_pend2);\n\t\ta1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2,        dTheta2_pend2);\n\t\tb0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + a0/2., dTheta2_pend2 + a1/2.);\n\t\tb1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + a0/2., dTheta2_pend2 + a1/2.);\n\t\tc0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + b0/2., dTheta2_pend2 + b1/2.);\n\t\tc1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + b0/2., dTheta2_pend2 + b1/2.);\n\t\td0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + c0,   dTheta2_pend2 + c1);\n\t\td1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + c0,   dTheta2_pend2 + c1);\n\n\t\tdTheta1_pend2 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\tdTheta2_pend2 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\ta0 = step *  dTheta1_pend2;\n\t\ta1 = step *  dTheta2_pend2;\n\t\tb0 = step * (dTheta1_pend2 + a0/2.);\n\t\tb1 = step * (dTheta2_pend2 + a1/2.);\n\t\tc0 = step * (dTheta1_pend2 + b0/2.);\n\t\tc1 = step * (dTheta2_pend2 + b1/2.);\n\t\td0 = step * (dTheta1_pend2 + c0);\n\t\td1 = step * (dTheta2_pend2 + c1);\n\n\t\ttheta1_pend2 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\ttheta2_pend2 += (a1 + b1*2. + c1*2. + d1)/6.;\n\t}\n\n\tdx = theta1_pend1 - theta1_pend2;\n\tdy = theta2_pend1 - theta2_pend2;\n\tfloat v = 1./(maxiter) * log(sqrt(dx * dx + dy * dy)/dInit) * 64.;\n\tfragColor = vec4(v, v, v, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 251]], "test": "untested"}
{"id": "ctSXDW", "name": "basic_pt", "author": "RubberDuck55", "description": "A starter project", "tags": ["3d", "cubemap", "pathtracer"], "likes": 3, "viewed": 197, "published": 3, "date": "1676049766", "time_retrieved": "2024-07-30T18:10:59.138239", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.a),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_DIST 1000.0\n#define SURF_DIST 0.001\n#define MAX_STEP 500\n\n#define NUM_OBJECTS 5\n#define BOUNCES 3\n\n#define DIFF 0\n#define REFL 1\n#define EMIT 2\n#define REFR 3 // Not working \n#define CHEK 4 // Based on x,y not normal\n\nfloat seed;\n\nstruct Material {\n    int id;\n    vec3 col;\n    float aux;\n};\n\nstruct ray {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 n, rd, ro;\n    Material mat;\n};\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 lerp (vec3 v1, vec3 v2, float t) {\n    return v1 * (vec3(1.) - t) + v2 * t;\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1415 * 2.;\n    float theta = (rand()-0.5) * 3.1415 * 2.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nvec3 rand_hemisphere_weighted (vec3 rd, vec3 n, float t) {\n    vec3 rh = rand_hemisphere (n);\n    vec3 er = reflect(rd, n);\n    \n    return lerp(rh, er, t);\n}\n\nmat2 rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat distMat (vec3 p, out Material s) {\n    Material closest;\n    float minD = MAX_DIST;\n    \n    float ds = length(p-vec3(3., 0.5, 0.4))-1.5;\n    float ms = length(p)-1.;\n    float es = length(p-vec3(-3, 0.7, 0.9))-1.7;\n    float g = p.y+1.;\n    float light = length(p-vec3(0.,2.,0.))-0.5;\n    \n    minD = min(min(ms, g), min( ds, es));\n    \n    if(minD == ms)\n        closest = Material(REFL, vec3(0.5,1.,0.9), 1.0);\n    if(minD == ds)\n        closest = Material(REFL, vec3(1., 0.9, 0.5), 0.5);\n    if(minD == es)\n        closest = Material(EMIT, vec3(1.,0.5,0.5), 2.0);\n    if(minD == g)\n        closest = Material(CHEK, vec3(1.), 1.0);\n    \n    s = closest;\n    \n    return minD;\n}\n\n// Returns distance(float)\nfloat dist (vec3 p) {\n    Material d;\n    return distMat(p, d);\n}\n\n// Returns a normal(vec3) from a point\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\n// Returns object (hit|?|, pos, dist, n|ormal|, rd, ro)\nray raymarch (vec3 ro, vec3 rd) {\n    \n    bool hit = false;\n    \n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        float d = dist(p);\n        \n        if(d <= SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            hit = false;\n        }\n        \n        dO += d;\n    }\n    \n    vec3 p = ro+rd * dO;\n    \n    vec3 n = vec3(0,1,0);\n    if(hit){\n        n = normal(p);\n    }\n    \n    Material outM;\n    distMat(p, outM);\n    \n    return ray(hit, p, dO, n, ro, rd, outM);\n}\n\nvec3 color (in vec3 ro, in vec3 rd) { \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 col = vec3(0.);\n        ray r = raymarch(ro, rd);\n        \n        col = r.mat.col;\n        \n        ro = r.pos + r.n * SURF_DIST * 2.0;\n        \n        if(r.mat.id == DIFF){\n            rd = rand_hemisphere(r.n);\n        }\n        \n        if(r.mat.id == CHEK){\n            rd = rand_hemisphere(r.n);\n            col = lerp(vec3(0.3),vec3(0.4),round(0.5+0.25*(sin(r.pos.x)+sin(r.pos.z))));\n        }\n        \n        if(r.mat.id == REFL){\n            float a = r.mat.aux;\n            rd = rand_hemisphere_weighted(rd, r.n, a);\n        }\n        if(r.mat.id == EMIT) {\n            rd = vec3(0);\n            \n            fcol *= col * r.mat.aux;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        if(r.hit == false) {\n            col = texture(iChannel1, r.ro).rgb * 0.7;\n            rd = vec3(0.);\n            \n            fcol *= col;\n            tcol += fcol;\n            \n            continue;\n        }\n        \n        fcol *= col;\n        tcol += fcol * 0.01;\n    }\n    \n    return tcol;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    \n    init_rand(uv + iTime + 1.0);\n    \n    // Setup for raycast\n    vec2 tv = (((fragCoord+vec2(rand(),rand()))/iResolution.xy)-.5)/vec2(iResolution.y/iResolution.x, 1.);\n    vec3 ro = vec3(0,0,-5.);\n    vec3 rd = normalize(vec3(tv, 1.));\n    \n    // Rotations\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    \n    rd.yz *= rot(-m.y);\n    rd.xz *= rot(-m.x);\n    ro.yz *= rot(-m.y);\n    ro.xz *= rot(-m.x);\n    \n    \n    \n    vec3 col = color(ro, rd);\n    \n    //vec3 col = vec3(raymarch(p, rd).hit ? vec3(1.) : vec3(0.));\n    \n    \n    // Fog\n    // col *= 1.-clamp(o.dist*0.01, 0.0, 1.0);\n\n    if(texelFetch(iChannel0, ivec2(0), 0).xyzw == vec4(iResolution.xy, iMouse.xy)){\n        fragColor = vec4(col, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col, 1.0);\n    }\n    \n    if(ivec2(fragCoord) == ivec2(0))\n        fragColor = vec4(iResolution.xy, iMouse.xy);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 167]], "test": "untested"}
{"id": "DlBXWW", "name": "Synchronicity ( 214 chars )", "author": "FabriceNeyret2", "description": "inspiration: Gianni A. Sarcone  [url]https://twitter.com/gsarcone/status/1623405765015789571[/url]", "tags": ["2tweets", "short", "opart", "golf", "vasarely", "reproduction"], "likes": 27, "viewed": 320, "published": 3, "date": "1676040568", "time_retrieved": "2024-07-30T18:10:59.903194", "image_code": "#define S(v) smoothstep( 36./R.y, 0., abs( mod( v < 11.5 ? v+.5 : 0. , 2. ) - 1. ) - .5  )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         A = 12.* abs( u+u - R ) / R.y;\n \n    O = sqrt( max( S( length(A)/.97 + .6 )  * ( .9 - u/R ),\n                   S( max(A.x,A.y) )        *     u/R\n            )     ).yyyy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 130, 130, 343]], "test": "untested"}
{"id": "NtyfR1", "name": "", "author": "yjx", "description": "synchrotron radiation and bremsstrahlung ", "tags": ["electrodynamics"], "likes": 2, "viewed": 182, "published": 3, "date": "1676038778", "time_retrieved": "2024-07-30T18:11:00.666155", "image_code": "const float e=2.718281828;\nconst float pi=3.141592653;\nconst float R=1.;\nconst float c=0.5;\nconst vec2 o=vec2(0.);\n\nfloat circle(float r,vec2 o,vec2 uv){\nreturn abs(length(uv-o)-r);}\n\nfloat sq(float x){\n    return x*x;}\n\nfloat vbeta(float iTime){return sq(sin(0.1*iTime));}\n\nfloat abetapara(float iTime){return 0.1*sin(0.2*iTime);}\n\nfloat s(float iTime){return c*(iTime/2.-2.5*sin(0.2*iTime));}\n\nfloat angle(float iTime){return mod(s(iTime)/R,2.*pi);}\n\nvec2 position(float iTime){return R*vec2(cos(angle(iTime)),sin(angle(iTime)));}\n\nmat2 rotate2(float angle){\n    return mat2(vec2(cos(angle),-sin(angle)),\n                vec2(sin(angle),cos(angle)));}\n    \nfloat r(float x,float y){\n    return sqrt(x*x+y*y);}\n\n\nfloat intensityvert(float theta,float phi,float beta,float abetavert,float abetapara){\n    return 60.*sq(abetavert)*(sq(1.-beta*cos(theta))-\n    (1.-sq(beta))*sq(sin(theta)))/pow(1.-beta*cos(theta),5.);}\n           \nfloat intensitypara(float theta,float phi,float beta,float abetavert,float abetapara){\n    return 60.*sq(abetapara)*sq(sin(theta))/pow(1.-beta*cos(theta),5.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cof=20.;\n    vec2 uv=cof*(fragCoord-iResolution.xy*vec2(.5))/iResolution.x;\n    vec2 XY=vec2(rotate2(angle(iTime))*(uv.xy-position(iTime)));\n    vec2 UV=XY;\n    float intensityvert=intensityvert(atan(-XY.x,XY.y),0.,vbeta(iTime),\n    sq(c*vbeta(iTime))/R,abetapara(iTime))\n    *cos(20.*r(UV.x,UV.y)-10.*iTime)*10.*pow(e,-e*r(UV.x,UV.y));\n    float intensitypara=intensitypara(atan(-XY.x,XY.y),0.,vbeta(iTime),\n    sq(c*vbeta(iTime))/R,abetapara(iTime))\n    *cos(20.*r(UV.x,UV.y)-10.*iTime)*10.*pow(e,-e*r(UV.x,UV.y));\n    \n    vec3 col = mix(vec3(254.,204.,17.)/256.,vec3(0.,intensityvert,0.),\n    smoothstep(0.,0.02,circle(R,o,uv)));\n    col=col+vec3(intensitypara,0.,0.);\n     \n    fragColor = vec4(vec3(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 153, 153, 182], [184, 184, 202, 202, 219], [221, 221, 246, 246, 273], [275, 275, 304, 304, 331], [333, 333, 354, 354, 394], [396, 396, 421, 421, 451], [453, 453, 480, 480, 532], [534, 534, 560, 560, 653], [659, 659, 684, 684, 711], [714, 714, 800, 800, 917], [930, 930, 1016, 1016, 1089], [1091, 1091, 1148, 1148, 1875]], "test": "untested"}
{"id": "dtjXW1", "name": "dots mouse move", "author": "jsweetpotato", "description": "dots circle move\nReference https://www.shadertoy.com/view/MtcXRB", "tags": ["2d", "dots"], "likes": 4, "viewed": 221, "published": 3, "date": "1676027704", "time_retrieved": "2024-07-30T18:11:01.424127", "image_code": "#define COLORED 1\nfloat Circle(vec2 uv,vec2 position, float blur, float size){\n    float d = length(uv - position);\n    float c = smoothstep(size, size-blur, d);\n    return c;\n}\n\nfloat remap01(float a, float b, float t){\n    return (t-a) / (b-a);\n}\n\nfloat remap(float a, float b,float c, float d, float t){\n    return remap01(a, b, t) * (d-c) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float asp = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= asp;    \n    vec2 mUv = iMouse.xy/iResolution.xy;\n    \n\n    \n    float circle = Circle(uv, vec2(mUv.x*asp,mUv.y), .5, .5);\n    \n\tvec2 center = floor(fragCoord/16.0)*16.0 + 8.0;    \n    vec3 col = vec3(0.9,1.,.7)*circle;\n    float l = max(0.1, dot(col, vec3(0.2125, 0.7154, 0.0721)));\n    float dist = distance(center,fragCoord)/8.0;\n    float alpha = smoothstep(1.0, 0.7, dist/l);\n    #if defined COLORED\n    \tfragColor.rgb = col.rgb * alpha;\n    #else\n    \tfragColor.rgb = vec3(alpha);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 78, 78, 177], [179, 179, 220, 220, 248], [250, 250, 306, 306, 349], [351, 351, 408, 408, 1008]], "test": "untested"}
{"id": "DlBXW1", "name": "Reef and wave 2", "author": "guil", "description": "Reef and waves effect. It requires a good GPU for smooth animation.", "tags": ["waves", "reef"], "likes": 34, "viewed": 520, "published": 3, "date": "1676019229", "time_retrieved": "2024-07-30T18:11:02.175120", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//reef/waves combined field\nvec3 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o=1.;\n    vec3 q=p,r=p;\n    vec3 n = vec3(0);\n    mat2 m = rot(1.);\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<4e2;s*=1.6)\n            p.xz*=m,\n            n.xy*=m,\n            q=p*s+n,\n            r=p*s+n,\n            r.x+=iTime*2.,\n            e+=abs(dot(sin(r.xz*.1)/s,.8*l)),\n            f+=.2+.5*(dot(sin(q.xz*.5)/s,l)),\n            n+=cos(q);\n\to+=(f>.001 ? (e<0.01 ? -exp(-e*e):f*e):-exp(-f*f));\n    return vec3(max(o,0.),e,f);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3.5, dt = .3,c,d,e,f;\n    vec3 col= vec3(0.);\n    for( int i=0; i<80; i++ )\n\t{        \n        vec3 v = field(ro+t*rd); \n        c=v.x; e=v.y; f=v.z; d=min(min(e,2.*e*f),f);\n        t+=dt*d;\n        dt *= 1.01;\n        e=exp(-e);f=exp(-f);\n        col = .93*col+ .4*c*(f*vec3(5,3,2)+e*vec3(1,5,7)+2.);        \n    }    \n    return col*exp(-t*.15);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.6);\n    \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -= t*.4;\n    \n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBXW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [192, 220, 243, 243, 689], [692, 692, 729, 729, 1093], [1096, 1096, 1153, 1153, 1814]], "test": "untested"}
{"id": "DlX3Ds", "name": "Celtic Knots Zoo: Wood Carving", "author": "fenix", "description": "Stylistically inspired by Ben Griffin's KNOTS Zoo project: https://github.com/MrBenGriffin/Knot\nSimulation inspired by Wave Function Collapse: https://github.com/mxgmn/WaveFunctionCollapse\n\n*mouse to reset tiles*\n*WASD/QE/RF to fly*\n*space to reset*", "tags": ["raymarch", "dof", "depthoffield", "wood", "carve", "multipass", "carving", "wfc", "wavefunctioncollapse"], "likes": 48, "viewed": 536, "published": 3, "date": "1676011329", "time_retrieved": "2024-07-30T18:11:03.295126", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse, this time again\n//  with a 3D raymarched renderer.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  Stylistically this is inspired by Ben Griffin's KNOTS Zoo project, especially \"Knots\n//  Zoo Holy\":\n//\n//      https://github.com/MrBenGriffin/Knot\n//      https://fontlibrary.org/en/font/knots\n//\n//  Here are my previous WFC shaders:\n//\n//      Simple Wave Function Collapse   https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC               https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC           https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                   https://shadertoy.com/view/ds2XzD\n//      Superposition Weave WFC         https://shadertoy.com/view/Ds2XRV\n//      Celtic Knotwork WFC             https://shadertoy.com/view/mtfGWX\n//\n//  But this one shares the most code and concepts from my other raymarched WFC shader:\n//\n//      Raymarched Circuit Board WFC    https://shadertoy.com/view/mdjSDz\n//\n//  However there have been a lot of changes:\n//\n//    * Brought tileset over from Celtic Knotwork WFC\n//    * Adapted 2D SDF to 3D with chamfered extrusion\n//    * Added dragon heads/tails/wings and dots\n//    * Added extra logic to allow heads to connect to tails and nothing else\n//    * Merged superposition simulation (faster)\n//    * Rigged simulation and rendering for toroidal repeat at edges\n//    * Simulation resets not far from camera position\n//    * Removed multiple lights/shadows\n//    * Added noise layers for wood grain and gouged surfaces\n//    * Non-repeating wood texture as a base color\n//    * New attract mode camera motion, including roll\n//    \n//  This shader was originally released with HERE_BE_DRAGONS disabled in the Common tab,\n//  because when I tested it on a PC it took almost a minute to compile. But iq saved the\n//  day by pointing out I had missed de-unrolling the grad loop (see comments for more \n//  details).\n//\n//  If you've been following my other shaders, you might wonder if I tried \"progressive\n//  ray marching\" here. I did, and I left some commented out code if you want to see what\n//  I tried. It does speed up rendering, but only very slightly, I think because the ray\n//  marcher converges in very few iterations anyway.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//  Buffer C does the main scene render\n//  Image applies blur effect and renders lights on top\n//\n// ---------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\tvec3 centerRayDir = fxCalcRay(iResolution.xy * vec2(.5, .7), iResolution, cameraFwd, cameraUp, cameraLeft);\n    float centerDepth = -cameraPos.y / centerRayDir.y;\n\n    vec4 pixel = texelFetch(iChannel0, ivec2(u), 0);\n    float depth = pixel.w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a depth of field effect.\n    w = (abs(depth-centerDepth)) * iResolution.y / 500.;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = pixel;\n    }\n    \n    // render lights after blur\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightPos = calcLightPos(iTime, iResolution, cameraPos, cameraFwd);\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    lightPos = (w2c * vec4(lightPos,1.0)).xyz;\n    lightPos.xy = lightPos.xy / lightPos.z;\n    \n    float d = distance(lightPos.xy, (u - .5*iResolution.xy) / iResolution.y);\n    O.xyz = max(O.xyz, smoothstep(.04, .02, d));\n    \n    O.xyz = pow(ACESFilm(O.xyz), vec3(1./2.2));\n    O.a = 1.;\n    \n    //O = vec4(float(countBits(floatBitsToUint(texelFetch(iChannel2, ivec2(u), 0))))) *.1; // debug draw sim buffer\n    //u = iResolution.xy - u;\n    //O = smoothstep(0., .01, vec4(sdEndFoot(8. * u / iResolution.y))); // debug draw one tile\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Turn this on for all the cool dragon heads and stuff, but\n// if you have a PC it may take a minute (or more?) to compile.\n#define HERE_BE_DRAGONS 1\n\n// This makes all the circles, turn this off I guess if it's\n// running really badly for you or if you like a smoother look.\n#define HERE_BE_DOTS 1 \n\n// CONSTANTS\n\nconst float MAX_Y = 0.; \nconst float MAX_T = 2.2;\nconst float SDF_EPSILON_R = 0.002;\nfloat SDF_EPSILON = SDF_EPSILON_R;\nconst int MAX_MARCH_ITER = 8;\n\nconst uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\n// UTILITY\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\nvec2 rot90(vec2 v) { return v.yx * vec2(1, -1); }\n\nconst float PI = 3.141592653589793;\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69\n\n// counts the number of bits set to 1 in a uint\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\n// counts the number of bits set to 1 in a uvec4\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\n// computes the highest set bit index in a uint\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// STATE MANAGEMENT\n\nstruct fxState\n{\n    vec3 camPos;\n    float camDir;\n    float camRoll;\n    float resolution;\n    bool attract;\n    float attractTime;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.attract = data0.y != 0.;\n    state.camRoll = data0.z;\n    state.attractTime = data0.w;\n    state.camPos = data1.xyz;\n    state.camDir = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.attract ? 1. : 0., state.camRoll, state.attractTime);\n    }\n    \n    return vec4(state.camPos, state.camDir);\n}\n\n// TILE TYPE ENUM\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_WING = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\n#if HERE_BE_DRAGONS\nconst int I_ST_DRH = 11;\nconst int I_ST_DRT = 12;\nconst int CORNER_CR_DRH = 13;\nconst int CORNER_ST_DRT = 14;\nconst int NUM_TILES = 15;\n#else\nconst int NUM_TILES = 11;\n#endif\n\n// SIGNED DISTANCE FIELDS (2D)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n#if HERE_BE_DRAGONS\n\n// https://iquilezles.org/articles/distfunctions2d/\n#define POLY_FN(N) \\\nfloat sdPolygon( in vec2[N] v, vec2 p, int iFrame ) \\\n{ \\\n    float d = dot(p-v[0],p-v[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=N-1; DONT_UNROLL && i<N; j=i, i++ ) \\\n    { \\\n        vec2 e = v[j] - v[i]; \\\n        vec2 w =    p - v[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \\\n        if( all(c) || all(not(c)) ) s*=-1.0; \\\n    } \\\n    return s*sqrt(d); \\\n}\n\nbool inBBox(vec2 mins, vec2 maxs, vec2 p)\n{\n    return clamp(p, mins, maxs) == p;\n}\n\nconst int NUM_WING_POINTS = 24;\nconst vec2 WING_MIN = vec2(3.9,4.4);\nconst vec2 WING_MAX = vec2(6.6, 8);\nconst vec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(4.8, 4.7), vec2(5.3, 4.6), vec2(6, 6.1), vec2(6.3, 7), vec2(6.3, 7.5),\n    vec2(6.1, 7.7), vec2(5.85, 6.7), vec2(5.5, 6.1), vec2(5.65, 6.7), vec2(5.6, 7.5),\n    vec2(5.3, 7.8), vec2(5.4, 7.3), vec2(5.3, 6.8), vec2(5, 6.3),\n    vec2(5, 6.8), vec2(4.8, 7.4), vec2(4.5, 7.6),\n    vec2(4.65, 7.2), vec2(4.7, 6.6), vec2(4.6, 6.3), vec2(4.2, 5.9),\n    vec2(4.7, 6), vec2(5, 5.8), vec2(5, 5.3)\n);\n\nPOLY_FN(NUM_WING_POINTS)\n\nconst int NUM_HEAD_S_POINTS = 6;\nconst vec2 HEAD_S_MIN = vec2(4.7, 3.6);\nconst vec2 HEAD_S_MAX = vec2(7.7, 8.2);\nconst vec2 HEAD_S_POINTS[NUM_HEAD_S_POINTS] = vec2[](\n    vec2(7, 4.5), vec2(6.3, 4.), vec2(5.7, 3.9),\n    vec2(5, 4.1), vec2(5, 8.2), vec2(7, 8.2)\n);\n\nPOLY_FN(NUM_HEAD_S_POINTS)\n\nconst int NUM_HEAD_POINTS = 25;\nconst vec2 HEAD_MIN = vec2(3.3, -.05);\nconst vec2 HEAD_MAX = vec2(7.7, 4);\nconst vec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(4.45, -.05), vec2(6.0, 1.4), vec2(6.35, 1.8), vec2(6.4, 2.4), vec2(5.9, 2.9),\n    vec2(5.35, 2.8), vec2(5.55, 2.2), vec2(5.55, 1.9), vec2(5.45, 1.65), vec2(5., 1.2),\n    vec2(4.75, 1.45), vec2(5.1, 1.8), vec2(5.05, 2.2), vec2(4.9, 2.8), vec2(4.3, 3.7),\n    vec2(5.5, 3.4), vec2(6.5, 3.5), vec2(7, 3.8), vec2(6.97, 3.55), vec2(6.99, 3.15),\n    vec2(7.4, 2.5), vec2(7.5, 2.), vec2(7.2, 1.5), vec2(5.7, .7), vec2(4.95, -.05)\n);\n\nPOLY_FN(NUM_HEAD_POINTS)\n\nconst int NUM_TAIL_POINTS = 26;\nconst vec2 TAIL_MIN = vec2(3.8, 2.4);\nconst vec2 TAIL_MAX = vec2(7.3, 8.2);\nconst vec2 TAIL_POINTS[NUM_TAIL_POINTS] = vec2[](\n    vec2(7, 5), vec2(6.8, 3.7), vec2(6.2, 3.1), vec2(5.7, 2.9), vec2(4.9, 3.0),\n    vec2(4.2, 3.5), vec2(4, 4.2), vec2(4, 4.8), vec2(4.3, 5.2), vec2(4.9, 5.5),\n    vec2(5.1, 5.4), vec2(5.2, 5.25), vec2(5.3, 5.0), vec2(5.35, 4.7), vec2(5.25, 4.5),\n    vec2(5.15, 4.9), vec2(4.95, 5.1), vec2(4.7, 5.), vec2(4.7, 4.3), vec2(4.9, 4.),\n    vec2(5.3, 3.95), vec2(5.45, 4.05), vec2(5.7, 4.4), vec2(5.7, 5), vec2(4.95, 8.2),\n    vec2(7, 8.2)\n);\n\nPOLY_FN(NUM_TAIL_POINTS)\n\nconst int NUM_EYE_POINTS = 8;\nconst vec2 EYE_MIN = vec2(6.5, 1.4);\nconst vec2 EYE_MAX = vec2(7.4, 2.8);\nconst vec2 EYE_POINTS[NUM_EYE_POINTS] = vec2[](\n    vec2(7., 2.5), vec2(7.2, 2.), vec2(7.1, 1.8), vec2(6.9, 1.7),\n    vec2(6.7, 1.7), vec2(6.6, 1.85), vec2(6.7, 2.1), vec2(6.85, 2.2)\n);\n\nPOLY_FN(NUM_EYE_POINTS)\n\nconst int NUM_NOSE_POINTS = 12;\nconst vec2 NOSE_MIN = vec2(2.6, -.3);\nconst vec2 NOSE_MAX = vec2(5.8, 2.3);\nconst vec2 NOSE_POINTS[NUM_NOSE_POINTS] = vec2[](\n    vec2(2.95, -.05), vec2(4.5, 1.5), vec2(4.6, 1.7), vec2(4.75, 2.), vec2(4.9, 2.05), vec2(5.2, 2),\n    vec2(5.5, 1.5), vec2(5.6, 1.2), vec2(5.4, .7), vec2(5.3, 1.2), vec2(5, 1.5), vec2(3.45, -.05)\n);\n\nPOLY_FN(NUM_NOSE_POINTS)\n\nconst int NUM_TOOTH_POINTS = 4;\nconst vec2 TOOTH_MIN = vec2(4.4, .5);\nconst vec2 TOOTH_MAX = vec2(5.5, 1.4);\nconst vec2 TOOTH_POINTS[NUM_TOOTH_POINTS] = vec2[](\n    vec2(4.7, 0.9), vec2(4.9, 1.1), vec2(5.2, 0.8), vec2(4.95, 0.8)\n);\n\nPOLY_FN(NUM_TOOTH_POINTS)\n\nconst int NUM_TAIL2_POINTS = 30;\nconst vec2 TAIL2_MIN = vec2(0, .7);\nconst vec2 TAIL2_MAX = vec2(8.3, 5.8);\nconst vec2 TAIL2_POINTS[NUM_TAIL2_POINTS] = vec2[](\n    vec2(8.1, 3), vec2(8.1, 1), vec2(3, 1), vec2(2, 1.1), vec2(1.3, 1.4),\n    vec2(.8, 2.2), vec2(.6, 4), vec2(1, 5), vec2(1.7, 5.5), vec2(2.5, 5.5),\n    vec2(3.6, 5.1), vec2(3.9, 4.8), vec2(4.3, 4.1), vec2(4.2, 3.5), vec2(3.9, 3.1),\n    vec2(3.2, 3), vec2(2.6, 3.3), vec2(2.5, 3.8), vec2(2.8, 4.3), vec2(3.1, 4.3),\n    vec2(3.3, 4), vec2(3, 3.6), vec2(3.3, 3.5), vec2(3.7, 3.8), vec2(3.5, 4.3),\n    vec2(3, 4.6), vec2(2, 4.4), vec2(1.9, 3.6), vec2(2, 2.8), vec2(3, 2.4)\n);\n\nPOLY_FN(NUM_TAIL2_POINTS)\n#endif // HERE_BE_DRAGONS\n\n// cell distance functions\n#if HERE_BE_DOTS\n#define DOTR(X, Y, R) dist = max(dist, R - distance(p, vec2(X, Y)))\n#define DOT(X, Y) DOTR(X, Y, .6)\n#else\n#define DOTR(X, Y, R)\n#define DOT(X, Y)\n#endif\n\nfloat sdIStSt(vec2 p)\n{\n    float dist = min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n    \n    DOT(2, .7); DOT(2, 2.); DOT(2, 3.3); DOT(2, 4.7); DOT(2, 6.); DOT(2, 7.3);\n    DOT(6, .7); DOT(6, 2.); DOT(6, 3.3); DOT(6, 4.7); DOT(6, 6.); DOT(6, 7.3);\n    \n    return dist;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    \n    DOT(4.6, .6); DOT(5.7, 1.9); DOT(6, 3.35); DOT(6, 4.7); DOT(6, 6); DOT(6, 7.35);\n    DOT(2, 7.4); DOT(2, 6); DOT(2, 4.6); DOT(2, 3.2); DOT(2.4, 1.8);\n    \n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.6)));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.6)));\n\n    DOT(4.6, .6); DOT(5.7, 1.9); DOT(6, 3.4); DOT(6, 4.9); DOT(5.6, 6.3);\n    DOT(3.3, 7.3); DOT(2.4, 6); DOT(1.9, 4.7); DOT(1.9, 3.2); DOT(2.4, 1.8);\n\n    return dist;\n}\n\nfloat sdEndCross(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1.2));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1.2)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    \n    DOT(2.4, 1.8); DOT(2, 3.2); DOT(2, 4.6); DOT(2, 6); DOT(3.3, 6); DOT(4.7, 6);\n    DOT(6, 6); DOT(6, 4.6); DOT(6, 3.2); DOT(5.8, 1.8); DOT(4.7, .7);\n\n    return dist;\n}\n\nfloat sdEndWing(vec2 p, int iFrame)\n{\n    float dist = 1e6;\n#if HERE_BE_DRAGONS\n    vec2 wp1 = rotate(-.4) * p - vec2(-.5, -2.1);\n    if (inBBox(WING_MIN, WING_MAX, wp1))\n        dist = min(dist, sdPolygon(WING_POINTS, wp1, iFrame));\n    dist = max(dist, -sdBox(rotate(-.3) * (p - vec2(3, 4.5)), vec2(1, .5)));\n#endif // HERE_BE_DRAGONS\n    dist = min(dist, sdBox(p - vec2(2, 1), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1.5)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n#if HERE_BE_DRAGONS\n    dist = max(dist, .7 - length((p - vec2(5, 4.7)) * vec2(1, .7)));\n    vec2 wp2 = p - vec2(-.2, -.5);\n    if (inBBox(WING_MIN, WING_MAX, wp2))\n        dist = min(dist, sdPolygon(WING_POINTS, wp2, iFrame));\n#else\n    DOT(4.8, 4.1);\n#endif // HERE_BE_DRAGONS\n\n    DOT(6, .65); DOT(6, 1.95); DOT(5.8, 3.25); DOT(3.45, 4.1); DOT(2.4, 3.25); DOT(2, 1.95); DOT(2, .65);\n    \n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.6), vec2(1, 1.6)));\n    dist = min(dist, sdBox(p - vec2(6.6, 6), vec2(1.6, 1)));\n    \n    DOT(2, 7.3); DOT(2, 5.9); DOT(2, 4.6); DOT(2, 3.3); DOT(2, 2); DOT(3.3, 2);\n    DOT(4.6, 2); DOT(5.9, 2); DOT(7.3, 2); DOT(7.3, 6); DOT(6, 6); DOT(6, 7.3);\n    \n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(3.9, 2), vec2(1.2, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    DOT(7.4, 4.6); DOT(6.2, 5.85); DOT(6, 7.35); DOT(2, 7.4); DOT(2, 6.1);\n    DOT(2, 4.8); DOT(2, 3.4); DOT(2, 2); DOT(3.4, 2); DOT(4.8, 2); DOT(6.2, 2.4);\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1.2)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    DOT(5.8, 6.3); DOT(7.3, 6); DOT(7.3, 2); DOT(6, 2); DOT(4.6, 2); DOT(3.3, 2);\n    DOT(2, 2); DOT(2, 3.4); DOT(2, 4.8); DOT(2.3, 6.2); DOT(3.3, 7.3);\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    DOT(7.3, 4.7); DOT(6, 6); DOT(6, 2.2); DOT(4.6, 2); DOT(3.3, 2); DOT(2, 2);\n    DOT(2, 2); DOT(2, 3.3); DOT(2, 4.6); DOT(2.2, 6.1); DOT(3.3, 7.3);\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2.1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    DOT(6, .8); DOT(6.3, 2.3); DOT(7.4, 4.7); DOT(6.3, 5.8); DOT(6, 7.3);\n    DOT(2, 7.3); DOT(2, 6); DOT(2, 4.7); DOT(2, 3.4); DOT(2, 2); DOT(2, 0.7);\n\n    return dist;\n}\n\n#if HERE_BE_DRAGONS\nfloat sdIStDrH(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(3.3, 0.87)), vec2(1, 1)));\n    if (inBBox(HEAD_S_MIN, HEAD_S_MAX, p))\n        dist = min(dist, sdPolygon(HEAD_S_POINTS, p, iFrame));\n    if (inBBox(HEAD_MIN, HEAD_MAX, p))\n        dist = min(dist, sdPolygon(HEAD_POINTS, p, iFrame));\n    if (inBBox(EYE_MIN, EYE_MAX, p))\n        dist = max(dist, -sdPolygon(EYE_POINTS, p, iFrame));\n    dist = min(dist, distance(p, vec2(6.9, 1.95)) - .05);\n\n    DOT(2, 7.3); DOT(2, 6); DOT(2, 4.7); DOT(2, 3.3); DOT(2.3, 1.9);\n    DOT(3.3, .8); DOT(6, 7.3); DOT(6, 6); DOTR(6, 4.7, .5);\n\n    return dist;\n}\n\nfloat sdIStDrT(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4.2));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 2.7)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.07)), vec2(.45, 1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4.7, -1. + 0.12)), vec2(1, 1)));\n    if (inBBox(TAIL_MIN, TAIL_MAX, p))\n        dist = min(dist, sdPolygon(TAIL_POINTS, p, iFrame));\n    if (inBBox(NOSE_MIN, NOSE_MAX, p))\n        dist = min(dist, sdPolygon(NOSE_POINTS, p, iFrame));\n    if (inBBox(TOOTH_MIN, TOOTH_MAX, p))\n        dist = min(dist, sdPolygon(TOOTH_POINTS, p, iFrame));\n    dist = max(dist, .1 - distance(p * vec2(.7, 1), vec2(5. * .7, 1.8)));\n    \n    DOTR(4.6, 3.8, .2); DOTR(5.2, 3.5, .2); DOTR(6, 3.9, .3); DOTR(6.3, 4.9, .3); DOTR(6.2, 6, .4);\n    DOTR(6.1, 7.2, .5); DOT(2, 7.2); DOT(2, 5.8); DOT(2, 4.3); DOT(2, 2.8); DOT(2.5, 1.4);\n    \n    return dist;\n}\n\nfloat sdCornerCrDrH(vec2 p, int iFrame)\n{\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    const float ARC_ANGLE2 = PI / 2.9;\n    const vec2 ARC_SC2 = vec2(sin(ARC_ANGLE2), cos(ARC_ANGLE2));\n    float dist = sdArc(rotate(12.7 * PI / 8.) * (p1 - vec2(3.5, 3.5)), ARC_SC2, 2., 1.);\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n    if (inBBox(HEAD_MIN, HEAD_MAX, 8. - p))\n        dist = min(dist, sdPolygon(HEAD_POINTS, 8. - p, iFrame));\n    if (inBBox(EYE_MIN, EYE_MAX, 8. - p))\n        dist = max(dist, -sdPolygon(EYE_POINTS, 8. - p, iFrame));\n    dist = min(dist, distance(8. - p, vec2(6.9, 1.95)) - .05);\n    dist = min(dist, sdBox(rotate(PI / 3.8) * (p2 - vec2(6.9, 2.9)), vec2(1, 4.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.5, 5.3)), vec2(.55, .99)));\n\n    DOT(4.7, 7.2); DOT(5.9, 6); DOT(7.3, 4.7); DOT(6.2, 2.5);\n    DOT(4.9, 1.6); DOT(3.4, 1.8); DOT(2.5, 3);\n\n    return dist;\n}\n\nfloat sdCornerStDrT(vec2 p, int iFrame)\n{\n    float dist = sdBox(p - vec2(8, 6), vec2(1, 1));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.4, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.65, 1)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * ((8. - p) - vec2(4.7, -1. + 0.12)), vec2(1, 1)));\n    if (inBBox(NOSE_MIN, NOSE_MAX, 8. - p))\n        dist = min(dist, sdPolygon(NOSE_POINTS, 8. - p, iFrame));\n    if (inBBox(TOOTH_MIN, TOOTH_MAX, 8. - p))\n        dist = min(dist, sdPolygon(TOOTH_POINTS, 8. - p, iFrame));\n    dist = max(dist, .1 - distance((8. - p) * vec2(.7, 1), vec2(5. * .7, 1.8)));\n    if (inBBox(TAIL2_MIN, TAIL2_MAX, p))\n        dist = min(dist, sdPolygon(TAIL2_POINTS, p, iFrame));\n        \n    DOT(7.2, 6); DOT(5.6, 6.5); DOTR(7.3, 1.95, .55); DOTR(5.9, 1.9, .5); DOTR(4.7, 1.825, .425);\n    DOTR(3.5, 1.75, .35); DOTR(2.3, 1.7, .3); DOTR(1.5, 2.4, .3); DOTR(1.3, 3.4, .3);\n    DOTR(1.4, 4.2, .2); DOTR(1.9, 4.9, .2); DOTR(2.7, 5, .2); DOTR(3.5, 4.7, .2);\n    \n    return dist;\n}\n#endif // HERE_BE_DRAGONS\n\nfloat sdCell(vec2 p, int type, int iFrame)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)            dist = sdIStSt(p);\n    else if (type == I_ST_CR)       dist = sdIStCr(p);\n    else if (type == I_CR_CR)       dist = sdICrCr(p);\n    else if (type == END_CR)        dist = sdEndCross(p);\n    else if (type == END_WING)      dist = sdEndWing(p, iFrame);\n    else if (type == CORNER_ST_ST)  dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST)  dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR)  dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR)  dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)    dist = sdTStCrSt(p);\n#if HERE_BE_DRAGONS\n    else if (type == I_ST_DRT)      dist = sdIStDrH(p, iFrame);\n    else if (type == I_ST_DRH)      dist = sdIStDrT(p, iFrame);\n    else if (type == CORNER_CR_DRH) dist = sdCornerCrDrH(p, iFrame);\n    else if (type == CORNER_ST_DRT) dist = sdCornerStDrT(p, iFrame);\n#endif // HERE_BE_DRAGONS\n\n    return dist;\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\n// NOISE\n\n// From iq's Noise - gradient - 2D https://www.shadertoy.com/view/XdXGW8\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 1\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// From Voronoise by iq: https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise(vec2 p)\n{\n\tfloat k = 1.0+63.0*pow(1.0,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g );\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-step(1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\n// wood grain top surface\nfloat topNoise(vec3 gp)\n{\n    return pow(noise(gp.xz * vec2(1000., 50000.)), 6.) * .05;\n}\n\n// gouged-out looking rougher bottom surface\nfloat bottomNoise(vec3 gp)\n{\n    float angle = voronoise(gp.xz*3000.) * PI * 2.;\n    gp.xz = rotate(angle) * gp.xz; // align according to voronoi region\n    return abs(fract(gp.x*20000.) - .5) * .01; // sawtooth pattern\n}\n\n// SIGNED DISTANCE FIELDS (3D)\n\nfloat extrudeCell(vec3 p, vec3 gp, float t, int type, int iFrame, out float d2d, vec2 res)\n{\n    float dp = p.y; // distance to plane\n    float df = sdCell(p.xz*8. + 4., type, iFrame); // distance to 2d SDF\n    df = smoothstep(-.05, .5, df) * .05;\n    \n    vec2 w = vec2(df, dp); // box distance\n    float de = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n    de = min(de, w.x * .5 + w.y); // with chamfered edges\n    \n    float tb = smoothstep(.01, .0, df - .02); // top or bottom noise\n\n    float tnl = 15./res.y; // noise t limits\n    float bnl = 12./res.y;\n    float tn = tb > 0. && t < tnl ? topNoise(gp) * smoothstep(tnl, tnl * .7, t) : 0.;\n    float bn = tb < 1. ? bottomNoise(gp) * smoothstep(bnl, bnl * .5, t) : 0.;\n\n    de += mix(bn, tn, tb);\n    \n    d2d = df;\n\n    return min(de, p.y + 0.05);\n}\n\nfloat sdCell(uvec4 value, vec3 p, vec3 gp, float t, bool forShadow, int iFrame, out float d2d, vec2 res)\n{\n    if (value != uvec4(0) &&\n        value != MAX_UVEC4 &&\n        countBits(value) == 1) // only render anything if we have collapsed to a single state\n    {\n        uint top;\n        int rot = emptyWords(value, top);\n        int type = log2int(top);\n\n        if (rot == 1) p.xz = rot90(p.xz);\n        if (rot == 2) p.xz = rot90(rot90(p.xz));\n        if (rot == 3) p.xz = rot90(rot90(rot90(p.xz)));\n\n        return extrudeCell(p, gp, t, type, iFrame, d2d, res);\n    }\n\n    return extrudeCell(p, gp, t, 0, iFrame, d2d, res);\n}\n\nfloat scene(sampler2D sampler, vec3 res, vec3 p, float t, bool forShadow, int iFrame, out float d2d)\n{\n    // compute addresses\n    vec2 addr = mod(p.xz + .5, vec2(res.x/res.y, 1)) * res.y;\n    vec2 subaddr = (fract(addr) - .5);\n    vec3 subp = vec3(subaddr.x, p.y * res.y, subaddr.y);\n    \n    // fetch underlying sim result\n    uvec4 value = floatBitsToUint(texelFetch(sampler, ivec2(addr), 0));\n    \n    // render\n    float minDist = sdCell(value, subp, p, t, forShadow, iFrame, d2d, res.xy);\n    minDist /= res.y;\n    \n    return minDist;\n}\n\n// RENDER\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos, float t, int iFrame )\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        float d2d;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(sampler,res,pos+0.000001*e, t, false, iFrame, d2d);\n    }\n    return normalize(n);\n}\n\nvec3 rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, bool forShadow, inout float t, int iFrame, out float d2d)\n{\n    pos += t * dir; // passed-in t is warm-start (best guess)\n    \n    for (int i = 0; DONT_UNROLL && i < MAX_MARCH_ITER; ++i)\n    {\n        float d = scene(sampler, res, pos, t, forShadow, iFrame, d2d);\n        \n        if (abs(d) < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        t += d;\n        pos += dir * d;\n    }\n    \n    return pos;\n}\n\nvec3 calcLightPos(float time, vec3 res, vec3 cameraPos, vec3 cameraFwd)\n{\n    vec3 lightCenter = cameraPos; // light move along with camera\n    lightCenter.y = 10. / res.y;\n    lightCenter.xz += cameraFwd.xz * 30. / res.y;\n    return lightCenter;\n}\n\nvec4 pixelInternal(sampler2D sampler, sampler2D tex, float time, int iFrame, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, inout float t, out vec3 hitPos, out vec3 normal)\n{    \n    float d2d;\n    hitPos = rayMarch(sampler, res, cameraPos, rayDir, false, t, iFrame, d2d);\n    normal = grad(sampler, res, hitPos, t, iFrame);\n\n    // compute color\n    vec2 wood = hitPos.xz*.1*res.xy;\n    vec2 tile = trunc(wood);\n    vec3 wh = hash3(uvec3(tile, tile.x * tile.y));\n    wood = wood * .5 - .25 + .5 * wh.xy; // choose a random offset within the texture per tile, to relieve repetition\n    vec3 mColor = texture(tex, wood).rgb;\n    float mShiny = float(d2d < 0.02); // 2D distance to pattern determines shininess\n    \n    const float AMBIENT = .02;\n    vec3 color = mColor * AMBIENT;    \n\n    // apply light\n    vec3 lightPos = calcLightPos(time, res, cameraPos, cameraFwd);            \n    vec3 lightDir = normalize(lightPos - hitPos);\n                              \n    // diffuse\n    float dp = max(0., dot(normal, lightDir));\n    color += .1 * mColor * dp / (res.y * length2(lightPos - hitPos));\n\n    // specular\n    vec3 reflection = reflect(lightDir, normal);\n    dp = max(0., dot(cameraFwd, reflection));\n\n    color.rgb += .075 * mShiny * pow(abs(dp), 50.0) / (res.y * length2(lightPos - hitPos));\n    color *= 1000./res.y;\n    \n    // fade at distance\n    if (t >= MAX_T*.75)\n    {\n        vec3 sky = vec3(.01);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, t));\n    }\n    \n    return vec4(color.xyz, t);\n}\n\n#define pixel(A, B, C, D, E, F) pixelInternal(iChannel0, iChannel2, iTime, iFrame, iResolution, A, B, C, D, E, F)\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = state.camPos;\n    vec3 delta = vec3(0,-.013,.015);\n    delta.xz *= rotate(state.camDir);\n    cameraLookAt = cameraPos + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    vec3 up = normalize(vec3(delta.z * state.camRoll, 1, -delta.x * state.camRoll));\n    cameraLeft = -normalize(cross(cameraFwd, up));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_WING =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n#if HERE_BE_DRAGONS\nconst mat3 S_I_ST_DRH =\n    mat3(0,1,0,\n         0,2,0,\n         0,3,0);\n                  \nconst mat3 S_I_ST_DRT =\n    mat3(0,1,0,\n         0,3,0,\n         0,3,0);\n                  \nconst mat3 S_CORNER_CR_DRH =\n    mat3(0,3,0,\n         0,3,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_DRT =\n    mat3(0,3,0,\n         0,2,1,\n         0,0,0);\n#endif // HERE_BE_DRAGONS\n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_WING)       return S_END_WING;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    if (type == T_ST_CR_ST)     return S_T_ST_CR_ST;\n#if HERE_BE_DRAGONS\n    if (type == I_ST_DRH)       return S_I_ST_DRH;\n    if (type == I_ST_DRT)       return S_I_ST_DRT;\n    if (type == CORNER_CR_DRH)  return S_CORNER_CR_DRH;\n    if (type == CORNER_ST_DRT)  return S_CORNER_ST_DRT;\n#endif // HERE_BE_DRAGONS\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .01;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return 1.;\n    if (type == END_CR)         return .1;\n    if (type == END_WING)       return .05;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    if (type == T_ST_CR_ST)     return .1;\n#if HERE_BE_DRAGONS\n    if (type == I_ST_DRH)       return .05;\n    if (type == I_ST_DRT)       return .05;\n    if (type == CORNER_CR_DRH)  return .05;\n    if (type == CORNER_ST_DRT)  return .05;\n#endif // HERE_BE_DRAGONS\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            if (myShape[1][1] <= 1. || nShape[1][1] != myShape[1][1])\n            {\n                for (int d = 0; d < 4; ++d)\n                {\n                    if (tilesMatch(rotShape(myShape, d), nShape))\n                    {\n                        valid[(d + 4 - r) % 4] |= bit;\n                    }\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\n// compute the ivec2 offset for each direction\n// n.b. using the modulo negatives here to avoid issues with mods of negative numbers\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, iResolution.y - 1.);\n    /*if (d == 0)*/ return ivec2(iResolution.x - 1., 0);\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nuvec4 getCell(ivec2 coord, ivec2 offset)\n{\n    return floatBitsToUint(texelFetch(iChannel0, (coord + offset) % ivec2(iResolution.xy), 0));\n}\n\n// use toroidal distance to find the squared distance to a cell including wrap-around\nfloat dist2ToCell(vec2 p, vec2 coord)\n{\n    vec2 d = abs(p - coord);\n    d = mix(d, iResolution.xy - d, greaterThan(d, .5 * iResolution.xy));\n    return d.x * d.x + d.y * d.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    ivec2 ifc = ivec2(fragCoord);\n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0 ||\n        state.resolution < 0. )\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        return;\n    }\n\n    if (dist2ToCell((cameraPos.xz + .5) * iResolution.y, fragCoord) > 15. * 15.)\n    {\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        return;\n    }\n\n    // handle mouse input\n    if (iMouse.z > 0. && iMouse.w < 0.)\n    {\n        vec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        float toT = cameraPos.y / rayTo.y;\n        vec3 toHit = cameraPos - toT * rayTo;\n        vec2 proj = (toHit.xz + .5) * iResolution.y;\n\n        if (dist2ToCell(proj, fragCoord) < 2.5 * 2.5)\n        {\n            fragColor = uintBitsToFloat(MAX_UVEC4);\n            return;\n        }\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n\n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = getCell(ifc, nDir(d));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = getCell(ifc, nDir(d));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-3)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and direction\n// ---------------------------------------------------------------------------------------\n\nvec3 camPath(float t)\n{\n    vec3 result;\n    result.x = t * .00002;\n    result.y = (4. + 1.5*sin(t*.004))/iResolution.y;\n    result.z = -.005*sin(t*.002);\n    return result;\n}\n\nvoid updateCamera(inout fxState state)\n{\n    const float MOVE_SPEED = 0.0002;\n    vec3 camMove = vec3(0);\n    if (keyDown(KEY_W))\n    {\n        camMove.z += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_S))\n    {\n        camMove.z -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_A))\n    {\n        camMove.x += MOVE_SPEED;\n        state.camRoll += 2.;\n        state.attract = false;\n    }\n    if (keyDown(KEY_D))\n    {\n        camMove.x -= MOVE_SPEED;\n        state.camRoll -= 2.;\n        state.attract = false;\n    }\n    if (keyDown(KEY_R))\n    {\n        camMove.y += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_F))\n    {\n        camMove.y -= MOVE_SPEED;\n        state.attract = false;\n    }\n    \n    state.camRoll *= .9;\n\n    camMove.xz *= rotate(state.camDir);\n    state.camPos += camMove;\n\n    if (state.attract)\n    {\n        state.attractTime = mod(state.attractTime + 1., 1e4); // protect against numerical error by resetting every five minutes\n        state.camPos = camPath(state.attractTime);\n        vec3 nextCamPath = camPath(state.attractTime + 50.);\n        vec3 camDelta = state.camPos - nextCamPath;\n        state.camDir = atan(camDelta.x, camDelta.z) + PI;\n        vec3 nextCamDelta = camPath(state.attractTime + 100.) - nextCamPath;\n        state.camRoll = -cross(camDelta, nextCamDelta).y * 5e8;\n    }\n\n    const float TURN_RATE = 0.02;\n    if (keyDown(KEY_Q))\n    {\n        state.camRoll += 2.;\n        state.camDir += TURN_RATE;\n        state.attract = false;\n    }\n    if (keyDown(KEY_E))\n    {\n        state.camRoll -= 2.;\n        state.camDir -= TURN_RATE;\n        state.attract = false;\n    }\n\n    float MIN_HEIGHT = .0002;\n    float MAX_HEIGHT = .01;\n    state.camPos.y = clamp(state.camPos.y, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { fragColor = vec4(0); return; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.attract = true;\n        state.camPos = vec3(0, 5. / iResolution.y, 0);\n        state.camDir = 0.;\n        state.attractTime = 0.;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        updateCamera(state);\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Main render: RGB color A depth\n// ---------------------------------------------------------------------------------------\n\n// set this to 2 for 4xMSAA, 3 for 9x, etc.\n#define MSAA 1\n\nvec4 render(vec2 u, fxState state)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 hitPos, normal;\n    vec4 color = vec4(0);\n    float count = 0.;\n    \n#if MSAA > 1\n    float t = 0.;//texelFetch(iChannel3, ivec2(u), 0).w; // \"progressive ray marching\" doesn't help here\n    \n    for (int x = 0; x < MSAA; ++x)\n    for (int y = 0; y < MSAA; ++y)\n    {\n        vec2 offset = .7*vec2(x, y) / float(MSAA - 1) - .5 * float(MSAA - 1);\n        vec3 rayDir = fxCalcRay(u + offset, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n        if (t == 0.) t = (MAX_Y - cameraPos.y) / rayDir.y;\n\n        // t is inout param here, so we will use the t from one subsample as a starting guess for the next one\n        vec4 subsample = pixel(cameraPos, cameraFwd, rayDir, t, hitPos, normal);\n        \n        color += subsample;\n    }\n    \n    color /= float(MSAA * MSAA);\n#else\n    vec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (rayDir.y > 0.) { return vec4(0,0,0,MAX_T); }\n    float t = (MAX_Y - cameraPos.y) / rayDir.y;\n    //t = texelFetch(iChannel3, ivec2(u), 0).w; // testing \"progressive ray marching\"...doesn't help much here, I suppose because of fast convergence\n    \n    color = pixel(cameraPos, cameraFwd, rayDir, t, hitPos, normal);\n#endif\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    SDF_EPSILON = SDF_EPSILON_R / iResolution.y;\n    fxState state = fxGetState();\n    fragColor = render(fragCoord, state);\n}\n", "buffer_c_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlX3Ds.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3260, 3260, 3283, 3283, 3889], [3897, 3981, 4004, 4004, 4164]], "test": "untested"}
{"id": "mlBSD1", "name": "Concentric rings", "author": "fishy", "description": "I did a thing. I wonder if it's possible to get an exact interior distance field for this...", "tags": ["sdf", "rings", "gooey"], "likes": 1, "viewed": 185, "published": 3, "date": "1675995407", "time_retrieved": "2024-07-30T18:11:04.045120", "image_code": "#define SDF_VIEW 0\n\nfloat sdConcentricRing(vec2 uv, float k, float o)\n{\n    return abs(mod(length(uv)-o, k)-k/2.)-k/4.;\n}\n\nfloat map(vec2 uv)\n{\n    float d0 = sdConcentricRing(uv+vec2(0, 2), 0.2, iTime*0.2);\n    float d1 = sdConcentricRing(uv-vec2(0, 2), 0.2, iTime*0.2);\n    return min(d0, d1);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m, float px)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.005\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n    #if SDF_VIEW\n    vec3 col = vec3(colorSdf(uv, m, px));\n    #else\n    vec3 col = vec3(smoothstep(-px, px, map(uv)));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 71, 71, 121], [123, 123, 143, 143, 297], [299, 299, 341, 341, 993], [995, 995, 1052, 1102, 1459]], "test": "untested"}
{"id": "mtBSDh", "name": "Voronoi RGB", "author": "Horriblebarry12", "description": "rgb go brrr", "tags": ["noise"], "likes": 2, "viewed": 321, "published": 3, "date": "1675982211", "time_retrieved": "2024-07-30T18:11:04.802096", "image_code": "#define Color\n#define Round\n#define RoundAmount 0.1\n#define Scale 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y; // Scaled normalized pixel coordinates (from 0 to Scale)\n    vec2 uvN = fragCoord/iResolution.y; // Normalized pixel coordinates (from 0 to 1)\n    uv*=Scale;\n\n    \n    #ifdef Color\n    vec3 col = 0.5 + 0.5*cos((iTime/2.5)+uvN.xyx+vec3(0,2,4)); // the rgb color\n    #endif\n    #ifndef Color\n    vec3 col = vec3(1);\n    #endif\n    float noise = voronoi3d(vec3(uv.x,uv.y,iTime/7.6)).w; // the noise\n    \n    #ifdef Round\n    \n    if (noise <= RoundAmount)\n    {\n        noise = 1.0;\n    }\n    else\n    {\n        noise = 0.0;\n    }\n    \n    #endif\n    \n    fragColor = vec4(noise * col,1.0);\n}", "image_inputs": [], "common_code": "\n\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nvec4 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n    \n  return vec4(sqrt(res), abs(id), sqrt(res).y-sqrt(res).x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 763]], "test": "untested"}
{"id": "mtSSDh", "name": "Display On Hover", "author": "maxwellcoffee", "description": "10 LSD tabs each night", "tags": ["psychedelic"], "likes": 0, "viewed": 139, "published": 3, "date": "1675981196", "time_retrieved": "2024-07-30T18:11:05.684736", "image_code": "/* Structure from:\n/* https://www.shadertoy.com/view/cllSzl */\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n\n    float d=0., m=d, t=-0.8*((iTime) * (0.1 + sin(iTime / 1000.)*0.3) + 20.3) + 0.8, c;\n    vec3 g, p, q;\n\n    for (g*=d; m++<(64. + 60.*sin(iTime * 0.8)); \n        p  = abs(d*normalize(vec3(u/r.y*r(iTime * 0.1), 1)))) \n        g += (tan(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-4.,mod(p.z+t*10.,1.)-7.))-.05)*1.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, cos(q.z*6.28+t/.1)*tan(t+length(p.xy))/(6.*sin(t)))) - .1) - pow(d,3.5 + 2.5*sin(iTime * 0.5));\n    \n    O.rgb = (tan(d*4.+t+vec3(0,1,2))+1.) / tan(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 145, 145, 799]], "test": "untested"}
{"id": "mtBXWh", "name": "WIP: fisheye view of text plane", "author": "e4iso", "description": "Hopefully this will turn into a kind of \nzoomable user interface for browsing \nand editing textual information.", "tags": ["sdf", "sphere", "projection", "fisheye", "font", "zui", "zoomableuserinterface"], "likes": 0, "viewed": 220, "published": 3, "date": "1675980937", "time_retrieved": "2024-07-30T18:11:06.754875", "image_code": "void mainImage(out vec4 o, in vec2 p) {\n  o = texture(iChannel0, p.xy / iResolution.xy); \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* a circle that is a viewport to a plane\n * \n * https://registry.khronos.org/OpenGL-Refpages/es3.0/\n * https://www.ronja-tutorials.com/post/034-2d-sdf-basics/\n * https://iquilezles.org/articles/distfunctions2d/\n * https://github.com/CesiumGS/cesium\n * https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n * https://github.com/microsoft/monaco-editor\n * * https://github.com/scalameta/metabrowse\n * * https://github.com/benhutchison/scalajs-monaco-editor/blob/master/src/main/scala/facade/monacoEditorFacade.scala\n *\n * https://www.shadertoy.com/view/XtG3Rt (sliders, digits, draganddrop)\n * https://www.shadertoy.com/view/lddXzM (Shadertext)\n */\n// ----------------------------------------------------------------------------------------------------------------------\n// read/write\nconst vec2 activeUIAddress = vec2(0,4);\nconst vec4 bitShL          = vec4(    16777216.0,     65536.0,     256.0, 1.0);\nconst vec4 bitShR          = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\nbool  isCell(in vec2 p, in vec2 a) { return floor(p) == a;}\nvoid  savePixel(vec4 val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=val;}\nvec4  readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nvec4 packInt(int val) { // only positive int\n  vec4 res = floor(float(val)*bitShR);\n  res.yzw -= res.xyz*256.0;\n  return res;\n}\nfloat unpackInt( const in vec4 value ){ return dot(value, bitShL);}\nvoid saveInt(int val, vec2 address, inout vec4 col, vec2 p){if(isCell(p, address)) col= packInt(val);}\nfloat readInt(vec2 address){ return unpackInt(readPixel(address));}\nvec4 packFloat(const in float val){ // +-2147483 with 3 digit float precigion\n  bool negative = sign(val)==-1.;\n  vec4 res      = floor(abs(val)*1000.0*bitShR);\n  res.gba      -= res.rgb*256.0;\n  if(negative) res.r+=256.;\n  return res;\n}\nfloat unpackFloat( in vec4 val){\n  float m = 1.0;\n  if(val.r>=256.){ val.r-=256.; m=-1.0; }   \n  return dot(val, bitShL)/1000.*m;\n}\nvoid  saveFloat(float val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=packFloat(val);}\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n// ----------------------------------------------------------------------------------------------------------------------\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius) { vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat slider(in int intId, in vec4 conf, in vec2 loc, in vec2 sp, inout vec4 col, inout float ui) { \n  float id         = float(intId);\n  float val        = readFloat(vec2(id,0));                               // read saved value \n  vec4  data       = readPixel(vec2(id,3));\n  float activeUIID = readInt(activeUIAddress);    \n  float slui       = dfBoxRounded(floor(sp), vec4(loc,124,20), 5.0);\n  slui             = max(-slui-2.0, slui);    \n  if(data.x==0.) {                                                        // set default value\n    val = conf.x; data.x=.05;\n    saveFloat(val, vec2(id,0), col, sp);\n  } if(iMouse.z <= 0.) {                                                  // on mouse up\n    data.g = 0.;                                                          // stop drag this point\n    savePixel(vec4(0), activeUIAddress, col, sp);                         // unlock other controlls\n  } else if(dfBox(iMouse.xy, vec4(loc, 120, 20))<2. && activeUIID==0.0) { // on press\n    data.g = .05;                                                         // start drag this point\n    saveInt(int(id),activeUIAddress, col, sp);                            // lock other controlls\n  } else if(data.g>0.0 && activeUIID==id) {                               // on mouse drag\n    float distanceFromLeftEdge = clamp(iMouse.x, loc.x, loc.x+120.0)-loc.x;\n    val = mix(conf.y, conf.z, distanceFromLeftEdge/120.0);\n    val = floor(val/conf.w) * conf.w;        \n    saveFloat(val, vec2(id,0), col, sp);\n  }\n  slui = min(slui, dfBoxRounded(floor(sp), vec4(loc+vec2(2,2),120.0*(val-conf.y)/(conf.z-conf.y),16), 3.0) );\n//ui   = min(ui, -drawFloat(val,    2.0, sp, loc+vec2(128,  8), 1)); // val   \n//ui   = min(ui, -drawFloat(conf.y, 2.0, sp, loc+vec2(  0, 24), 1)); // from   \n//ui   = min(ui, -drawFloat(conf.z, 2.0, sp, loc+vec2( 80, 24), 1)); // to   \n//ui   = min(ui, -drawFloat(conf.w, 2.0, sp, loc+vec2( 50,-10), 1)); // step    \n  ui   = min(ui, slui);     \n  savePixel(data, vec2(id,3), col, sp);     \n  return val;    \n}\n// ----------------------------------------------------------------------------------------------------------------------\n// Shadertoy specific stuff...\nvec4 mouse()                { return iMouse / min(iResolution.x, iResolution.y); }\nbool iKeyPressed(int ascii) { return (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.); }\n\nint KeySpace = 32;\nint KeyA     = 65;\nint KeyB     = 66;\nint KeyC     = 67;\nint KeyD     = 68;\nint KeyE     = 69;\nint KeyF     = 70;\nint KeyG     = 71;\nint KeyH     = 72;\nint KeyI     = 73;\nint KeyJ     = 74;\nint KeyK     = 75;\nint KeyL     = 76;\nint KeyM     = 77;\nint KeyN     = 78;\nint KeyO     = 79;\nint KeyP     = 80;\nint KeyQ     = 81;\nint KeyR     = 82;\nint KeyS     = 83;\nint KeyT     = 84;\nint KeyU     = 85;\nint KeyV     = 86;\nint KeyW     = 87;\nint KeyX     = 88;\nint KeyY     = 89;\nint KeyZ     = 90;\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----- >>> character drawing <<< --------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// vec2  v00 = vec2(0., 0.);  // (.0, .0)\n// vec2  v01 = vec2(3., 4.);  // (.3, .4)\n\nstruct fmt { // format\n  float Xw;\n  float Xh;\n  float xw;\n  float hx;\n  float wo;\n  float Xx;\n  vec2 X11;\n  vec2 X12;\n  vec2 X21;\n  vec2 X22;\n  vec2 x11;\n  vec2 x12;\n  vec2 x21;\n  vec2 x22;\n};\nfmt createFmt(float Xw,float Xh,float xw,float hx,float wo) {\n  return fmt(\n    Xw,Xh,xw,hx,wo,\n    Xh-hx,\n    vec2(Xw,Xh),vec2(Xw,-Xh),vec2(-Xw,Xh),vec2(-Xw,-Xh),\n    vec2(xw,hx),vec2(xw,-hx),vec2(-xw,hx),vec2(-xw,-hx)\n  );\n}\n\nstruct pnt { // point\n  vec2 P;\n  vec2 p;\n  vec2 Abs;\n  vec2 abs;\n  vec2 Xabs;\n  vec2 Neg;\n  vec2 NegX;\n};\npnt createPnt(fmt f, vec2 P) {\n  vec2 p = vec2(P.x, P.y + f.Xx);\n  return pnt(P,p,abs(P),abs(p), vec2(abs(P.x),P.y), -P, vec2(-P.x, P.y));\n}\n\nstruct bdl { // bounding lines\n  vec2 lbl1; // upper point of left bounding line\n  vec2 lbl2;\n  vec2 rbl1;\n  vec2 rbl2;\n};\n\nvec2   py(vec2 p,float dy) { return vec2( p.x,p.y+dy); }\nvec2   lc(vec2 p)          { return py(p, 2.); }\nvec2 absx(vec2 p)          { return vec2(abs(p.x), p.y); }\nvec2 P00 = vec2(0., 0.); // centre of 'X'\n// ----------------------------------------------------------------------------------------------------------------------\n// These functions are re-used by multiple letters\nfloat line(vec2 p,vec2 a,vec2 b){vec2 c=p-a;vec2 d=b-a;float h=clamp(dot(c,d)/dot(d,d),0.,1.);return length(c-d*h);}\nvec2     dx(vec2 p, float dx){return vec2(p.x+dx,p.y);}\nfloat   _sY(vec2 p, float dy){return length(vec2(p.x, max(0.,abs(p.y)-dy)));}  // stretch Y\nfloat   _i(vec2 p, fmt f) { return length(vec2(p.x,       max(0.,abs(p.y)-f.hx)                 )); }\nfloat   _l(vec2 p,fmt f){return _sY(p, f.Xh); }  // 6. = f.hY\nfloat   _u(vec2 p,float w,float v) { return length(vec2(abs(length(vec2(p.x,max(.0,-(6.-v)-p.y)))-w),max(.0,p.y-2.))); }\nvec2  lcnx(vec2 p) { return vec2(-p.x,p.y+2.); }\n//float  _pp(vec2 p,fmt f) { return min(_o(p,f),_l(p+vec2(2.5,4.))); }\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n\n\nconst int XX = 88;\nconst int YY = 89;\nconst int bb = 98;\nconst int dd = 100;\nconst int oo = 111;\nconst int pp = 112;\nconst int xx = 120;\n\n/*'X'*/float u0058(pnt p,fmt f){return line(p.Abs,P00,f.X11);}\n/*'Y'*/float u0059(pnt p,fmt f){return min(line(p.Neg,P00,f.X11),line(p.Xabs,P00,f.X11));}\n/*'o'*/float u006f(pnt p,fmt f){return abs(_sY(p.p,f.hx-f.wo)-f.wo);}\n/*'b'*/float u0062(pnt p,fmt f){return min(u006f(p,f),_l(dx(p.P, f.wo),f));}\n/*'d'*/float u0064(pnt p,fmt f){return u0062(createPnt(f,p.NegX),f);}\n/*'x'*/float u0078(pnt p,fmt f){return line(p.abs,P00,f.x11);}\n\nbdl charWidth(int c, fmt f) { switch(c) { // left and right bounding lines\n  case XX:return bdl(f.X21,f.X22,f.X11,f.X12);break;\n  case YY:return bdl(f.X21,f.X22,f.X11,f.X12);break;\n  case bb:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case dd:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case oo:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case xx:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n}; }\n\nfloat char(pnt p, int c, fmt f) { switch(c) {  // calculates the signed distance from point p to character c - formatted with f\n  case XX:return u0058(p,f);break;\n  case YY:return u0059(p,f);break;\n  case xx:return u0078(p,f);break;\n  case bb:return u0062(p,f);break;\n  case dd:return u0064(p,f);break;\n  case oo:return u006f(p,f);break;\n}; }\n\nint text[] = int[](dd,bb,oo,xx,YY,XX);\n\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nfloat r  = 1.; // radius of circle at end of line (half line with)\nfloat cd = 2.; // character distance\n\n\nfloat xyz(vec2 p, fmt f) {\n  float tl2    = 0.; \n  float d      = 100000.;\n  float dx     = 0.;\n  for (int i=0; i<text.length(); i++) { \n    int   c  = text[i];\n    bdl bdl2 = charWidth(c, f);\n    float cw = max(bdl2.rbl1.x, bdl2.rbl2.x) + r;\n    if (i > 0) dx += cw;\n    d = min(d, char(createPnt(f, vec2(p.x - dx, p.y)), c, f) - r); // +// float(text.length())*.5;\n    dx += cw + cd;\n  };\n  return d;\n}\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n/* A grid of columns and rows helps visualizing a projection.\n * @return signed distance to grid lines\n */ \nfloat grid(vec2 p, float lineDistance, float lineWidth) { vec2 g = mod(p +.5 * lineWidth, lineDistance) - lineWidth; return min(g.x, g.y); }\nfloat lH(vec2 p, float y, float r) { return abs(p.y-y)-r; } // horizontal line\nfloat lV(vec2 p, float x, float r) { return abs(p.x-x)-r; } // vertical line\nfloat y[] = float[](6., 2., -2., -6., -10.);\nfloat llH(vec2 p) { float d = lH(p,0.,0.2); for (int i=0;i<y.length();i++) d = min(d,lH(p,y[i],0.1)); return d; }\nfloat llV(vec2 p, float cw) { float d = lV(p,0.,0.2); d = min(d,lV(p,cw,0.1)); return min(d,lV(p,-cw,0.1)); }\nfloat crosshair(vec2 p, float cw) { return min(llH(p), llV(p, cw)); }\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nconst vec4  backgroundColor = vec4(.1, .1, .1, 1.);\nconst vec4  foregroundColor = vec4(.2, .2, .2, 1.);\nconst vec4  crosshairColor  = vec4(.6, .0, .2, 1.);\nconst float da              = 0.; // 6. - data area height\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nvoid mainScene(inout vec4 col, in vec2 sp) {\n  fmt  myFmt         = createFmt(3., 6., 2., 4.,2.5);  // makeFormat(1., .2, 0., false, 0.);\n  bool withCrosshair = true;\n  vec2 center        = vec2(0., 0.); // center: the point on the plane that shall be in the center of the circle\n  \n  float viewPortScale = 1.; // ##### how much of the viewport do i see? #####          2. * sin(1.7 * iTime) + 1.;\n  if (iKeyPressed(KeyA)) { viewPortScale =  .00; }\n  if (iKeyPressed(KeyS)) { viewPortScale = -.25; }\n  if (iKeyPressed(KeyD)) { viewPortScale = -.50; }\n  if (iKeyPressed(KeyF)) { viewPortScale = -.75; }\n  if (iKeyPressed(KeyG)) { viewPortScale = -1.0; }\n  \n  \n  int   model         = 0;\n//float ui            = 0.;\n//viewPortScale = slider(3, vec4(1, -1, 1, .10), vec2(5, 85), sp, col, ui); // #############################################################################################\n//dx            = slider(4, vec4(1, -1, 2, .02), vec2(5, 45), sp, col, ui); // #############################################################################################\n//dy            = slider(5, vec4(1, -1, 2, .02), vec2(5,  5), sp, col, ui); // #############################################################################################\n  float vpScale = 1./min(iResolution.x,iResolution.y)/pow(2.5,1.*(viewPortScale+1.));\n  vec2  point   = 2. * sp - iResolution.xy;\n  vec2  circle  = point * vpScale;\n  float len     = length(circle);\n  if (len > 1. && sp.y > 5.) { col = backgroundColor; return; }\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n  /* And what is the projection from the plane to the circular viewport?\n   * computes the fisheye view within the circle distance  [0, [\n   */\n  vec2 plane = circle * 0.90 * (1. / (1. - len) - 1.)  / len; \n  switch (model) {\n    case  0: plane = circle * 0.95 * tan(radians(90. * len)) / len; break;\n  };\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n  float zoom = 80. * vpScale;   // ##### how big shall text at the center point be? #####\n  if (iKeyPressed(KeyQ)) { zoom *= pow(2.5, -1.); }\n  if (iKeyPressed(KeyW)) { zoom *= pow(2.5, -2.); }\n  if (iKeyPressed(KeyE)) { zoom *= pow(2.5, -3.); }\n  if (iKeyPressed(KeyR)) { zoom *= pow(2.5, -4.); }\n  if (iKeyPressed(KeyT)) { zoom *= pow(2.5, -5.); }\n  \n  vec2  info          = (plane + center) / zoom;\n  vec4  c             = foregroundColor;\n  if (withCrosshair) {\n//  if (crosshair(info, charWidth(text[0], myFmt)) < .0) c.r = 0.6;\n  }\n//if (grid(plane,  0.1, 0.02) > .0) c.b = 1.;\n  if (iKeyPressed(KeySpace)) { if (grid(circle, 1., 0.2) > .0) c.g = .4; } //SPACE\n  if (grid(info,   1., 0.1) < .0) c.b = 1.;\n  if (length(info) - 6.*r   < .0) c.g = .4;\n//if (length(info) -    r   < .0) c.g = .6;\n  if (xyz(info, myFmt)      < .0) c.r = .8;\n//if (ui   < .0)  c.g = 0.8;\n  if (sp.y >= da)  col = c;  //draw only on non data area // mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));\n}\nvoid mainImage( out vec4 o, in vec2 p ){ \n  o = (p.y < da) ? texture(iChannel0,p.xy / iResolution.xy) : vec4(0);  //data for next frame\n  mainScene(o, p);   \n}\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n/*\n//////////////////////////////\n//   Read Write             //\n//////////////////////////////\n\nvec4 packNormal( const in float value) { // only positive in range 0-1\n  vec4 res = fract( value*bitShL );\n  res.yzw -= res.xyz/256.0;\n  return res;\n}\nfloat unpackNormal(const in vec4 value) { return dot(value, bitShR);}\n\nvoid saveIntVec2(vec2 val, float id, inout vec4 col, vec2 p) {\n  saveInt(int(val.x), vec2(id,0.0), col, p);        \n  saveInt(int(val.y), vec2(id,1.0), col, p);\n}\n\n////// Constants ////////////////////////////////////////////////////////////////////////\nconst float PI    = 3.14159265358979323846;\nconst float SQRT2 = 1.41421356237309504880;\n\n////// 2D Transformations ///////////////////////////////////////////////////////////////\nvec2 translate(vec2 p, vec2 t){\treturn p - t;}\nvec2 scale(vec2 p, float s){ return p * mat2(s, 0, 0, s);}\nvec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\nvec2 rotateCCW(vec2 p, float a){\treturn p * mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n////// 2D Matrix Transformations /////////////////////////////////////////////////////////\nmat3 rotate(float r){float c = cos(r), s = sin(r); return mat3(c,-s,0,  s,c,0,  0,0,1);}\nmat3 scale(float s){ return mat3(s,0,0, 0,s,0, 0,0,1);}\nmat3 translate(vec2 p) { return mat3(1,0,p.x, 0,1,p.y, 0,0,1);}\nmat3 skew(float r) { return mat3(1,tan(r),0, 0,1,0, 0,0,1);}\nmat3 skewVert(float r) { return mat3(1,0,0, tan(r),1,0, 0,0,1);}\nmat3 inverse2x3(mat3 m){\n      float a=m[0][0], b=m[0][1], c=m[0][2], d=m[1][0], e=m[1][1], f=m[1][2], t=a*e-b*d;\n      return mat3(e/t, -b/t, (f*b-c*e)/t, -d/t, a/t, (-f*a+c*d)/t, 0, 0, 1);\n}\nvec2 transform(vec2 p, mat3 m){ return (vec3(p,1)*m).xy;}\n////// Distance field functions //////////////////////////////////////////////////////////\n\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\n\nfloat dfCircle(vec2 p, float radius){\t\n    return length(p) - radius;\n}\nfloat dfLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n////// UI /////////////////////////////////////////////////////////////////////////////////\nfloat extract_bit(float n, float b){ return mod(floor(n/exp2(floor(b))),2.0);}\nfloat extract_decimal(float n, float index){ return mod(n/pow(10.0, index),10.0);}\n\n\nfloat drawDigit(int n, vec2 p) { \n  p=floor(p);\n  int i = n== 0?0x69996:\n          n== 1?0x62227:\n          n== 2?0xE168F:\n          n== 3?0xE161E:\n          n== 4?0x99711:\n          n== 5?0xF8E1E:\n          n== 6?0x68E96:\n          n== 7?0xF1244:\n          n== 8?0x69696:\n          n== 9?0x69716:\n          n==10?0x00700:\n          n==11?0x00004:\n                0xFFFFF;\n  return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);\n}\n\nfloat drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    p-=location; p/= float(zoom);\n    float n = floor(p.x / 5.0); //current char index \n    p.x -= n*5.; //move origin\n    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds\n    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    float count = intCount + fractPrecision; //totla number of digits to print \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  \n    if(count <= n)  return 0.0; //no need to draw more\n    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   \n}\nfloat drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    float r =drawFloat(val.y,fractPrecision, p, location, zoom);\n    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);\n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n\nvec2 controlPoint(float id, vec2 loc, mat3 stv, vec2 sp, inout vec4 col, inout float ui){\n    \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);\n    vec2 m = transform(iMouse.xy, stv); //viewport mouse position \n    vec2 pos = vec2(readFloat(vec2(id,0)),readFloat(vec2(id,1)));//read saved value \n    \n    \n    if(data.x==0.){ //set default value\n        pos = loc; data.x=.05;\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    }\n    vec2 spos = transform(pos, inverse2x3(stv));\n    \n    if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(distance(spos, iMouse.xy)<20. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n        \n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        pos = m;//drag this point\n        spos = iMouse.xy;//drag this point\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    } \n    \n    ui = min(ui, -drawVec2(pos, 2.0, sp, spos+vec2(10,-5), 1));    \n    ui = min(ui, dfCircle(sp-spos, 6.));\n    \n    savePixel(data, vec2(id,3), col, sp); \n    \n    return pos;\n}\n\n\n/////// Combine distance field functions //////////////////////////////////////////////////\nfloat merge(float d1, float d2){return min(d1, d2);}\n\n\n////// Grid //////////////////////////////////////////////////////////////////////////////\nfloat chessboard(vec2 p){ p=floor(p*2.0); return mod(p.x+p.y, 2.0);}\n\n\n/////////////////////////////////////////////////////////////////\n//    Bezier                                                  //\n///////////////////////////////////////////////////////////////\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c){\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n// Find the unsigned distance from a point to a bezier curve\nfloat usBezier(vec2 A, vec2 B, vec2 C, vec2 p){    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\n\n////// Masks for drawing /////////////////////////////////////////////////////////////////\n\nfloat hardFill(float d){return step(0.0, -d);}\nfloat fill(in float d, in float softness, in float offset){\n    return clamp((offset +softness*.5 - d)/softness, 0.0, 1.0);\n}\nfloat simpleFill(float d){return clamp(-d, 0.0, 1.0);}\nfloat sharpFill(in float d){return clamp(.5-d, 0.0, 1.0);} //same as fill(d, 1.0, 0.0)\nfloat stroke(in float d, in float softness, in float offset, in float width){ \n   d = abs(d-offset);\n   return clamp((width/2.0 +softness*.5 - d)/softness, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainScene(inout vec4 col, in vec2 sp ){\n    \n    float zoom = 1.;\n   \n    //viewport transformation matrix \n    mat3 screenToView = translate(-iResolution.xy / 2.0)*scale(zoom); \n    mat3 screenToView2 = translate(vec2(-iResolution.x / 2.0, -25))*scale(0.025); \n    \n    //ui elements\n    float ui = 0.;\n    vec2 pt1 = controlPoint(1.0, vec2(-125, -40), screenToView, sp, col, ui);\n    vec2 pt2 = controlPoint(2.0, vec2(-35, 122), screenToView, sp, col, ui);    \n    vec2 pt3 = controlPoint(3.0, vec2(115, 40), screenToView, sp, col, ui);     \n    \n    ///////////////// output /////////////////\n    if(sp.y > 80.){ //viewport 1\n        \n        \n        vec2 p = transform(sp.xy, screenToView);  //viewport pixel position\n        // background     \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.r -= .03*chessboard(p*.05); //grid2  \n        \n        // scene\n        float lines = merge(dfLine(p, pt1, pt2), dfLine(p, pt3, pt2));\n        float bz = usBezier(pt1, pt2, pt3, p);    \n        float cc = dfCircle(p, 50.);\n\n        col = mix(col, vec4(1.0, 0.7, 0.9, 1.0), stroke(cc, softness * zoom, offset * zoom, width * zoom));         \n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), stroke(bz, softness * zoom, offset * zoom, width * zoom)); \n        col = mix(col, vec4(0.2, 0.2, 0.2, 1.0), stroke(lines, zoom, .0, .5*zoom));\n        \n    }else if(sp.y > 5.){ //viewport 2    \t\n        vec2 p = transform(sp.xy, screenToView2);         \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.rgb -= .03*chessboard(p*.5); //grid2         \n        \n        float fn = stroke(p.x, softness, offset, width);\n        float ln = p.y < fn ? -1. : 0.;\n        col = mix(col, vec4(.4, 0.4, 0.4, 1.0), simpleFill(ln));\n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), 1.0-step(simpleFill(ln)*p.y,.0));\n        col = mix(col, vec4(.3,.3,.3,1), hardFill(dfRoundedBox(p,vec2(.05,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(5,0),vec2(.025,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(-5,0),vec2(.025,10), .0)));\n    }\n    \n}\n*/\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n\n/*\n      val xh = 0.2 - (0.2 + 0.2) * 2 / 3\n\n      val X1: IsoPoint = IsoPoint(-1, -2) // 1--2--3\n      val X2: IsoPoint = IsoPoint(0, -2)  // |\\ | /|\n      val X3: IsoPoint = IsoPoint(1, -2)  // | \\|/ |\n      val X4: IsoPoint = IsoPoint(-1, 0)  // 4--5--6\n      val X5: IsoPoint = IsoPoint(0, 0)   // | /|\\ |\n      val X6: IsoPoint = IsoPoint(1, 0)   // |/ | \\|\n      val X7: IsoPoint = IsoPoint(-1, 2)  // 7--8--9\n      val X8: IsoPoint = IsoPoint(0, 2)\n      val X9: IsoPoint = IsoPoint(1, 2)\n\n      def lx(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, xh), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, xh), IsoPoint(-0.1 + dx, 0.2))\n      )\n      def lz(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, xh), IsoPoint(0.1 + dx, xh)),\n        IsoLine(IsoPoint(0.1 + dx, xh), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n\n      def lX(dx: Double): Seq[IsoLine] = Seq(IsoLine(X1, X9), IsoLine(X3, X7))\n\n      def lY(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(0.0 + dx, 0.0), IsoPoint(-0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2))\n      )\n      def lZ(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n      def lH(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.0), IsoPoint(0.1 + dx, 0.0))\n      )\n      def lV(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.0 + dx, 0.2)),\n        IsoLine(IsoPoint(0.0 + dx, 0.2), IsoPoint(0.1 + dx, -0.2))\n      )\n      def lT(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.0 + dx, -0.2), IsoPoint(0.0 + dx, 0.2))\n      )\n      def lL(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n      def lN(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(-0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, 0.2), IsoPoint(0.1 + dx, -0.2))\n      )\n*/\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 91]], "test": "untested"}
{"id": "mt2XRw", "name": "Japanese Ornamental Tiling", "author": "eo", "description": "Replicating the 'Japanese Ornamental design' (fig.17, pg.6) from paper by Rinus Roelofs:\n[url]http://www.archive.bridgesmathart.org/2007/bridges2007-81.pdf[/url]\n\nmouse x:\n  Pattern sizing\n\ntab:\n  See how pattern is constructed (mouse works here too)", "tags": ["escher", "hexagon", "tiling", "construction"], "likes": 14, "viewed": 197, "published": 3, "date": "1675980548", "time_retrieved": "2024-07-30T18:11:07.515840", "image_code": "/*\nReplicating a pattern found in \"Entwined Circular Rings\" by Rinus Roelofs:\nhttp://www.archive.bridgesmathart.org/2007/bridges2007-81.pdf\n\nHeavily relied on TheArtOfCode youtube video for hex tiling explanation:\nhttps://www.youtube.com/watch?v=VmrIDyYiJBA\n*/\n\nconst vec3 fg_color = vec3(0.9, 0.75, 0.6);\nconst vec3 bg_color_l = vec3(0.55, 0.25, 0.6);\nconst vec3 bg_color_r = vec3(0.9, 0.45, 0.1);\n\n\nvec3 draw_construction(vec2 uv, float circle_size_01) {\n\n    /*\n    Alternate coloring function, shows a simple animation\n    of how the tiling pattern is constructed.\n    It's basically two overlapping patterns of 3 circles,\n    see the comments/animation timing for more details\n    */\n\n    // Set up time steps/frames for animating construction\n    float t = mod(iTime*1.25, 9.0);\n\n    // Set important sizing\n    const float radial_offset = root3;\n    float circle_radius = mix(1.0, 1.5, circle_size_01);\n    \n    // Switch to full tiled view\n    if (t > 6.0)\n        uv = hex_uv(uv, 1.0).xy;\n    \n    // Get pattern sdfs\n    float bot_sdf = tricircle_sdf(uv, radial_offset, 0.0, circle_radius);\n    float top_sdf = tricircle_sdf(uv, radial_offset, 1.0, circle_radius);\n    float hex_sdf = 1.0 - hex_edge_dist(uv);\n    \n    // For convenience\n    float bot_edge = 1.0 - get_edge_outline(bot_sdf, 0.1);\n    float top_edge = 1.0 - get_edge_outline(top_sdf, 0.1);\n    float hex_edge = 1.0 - get_edge_outline(hex_sdf+0.05, 0.1);\n    float hex_mask = step(hex_edge_dist(uv), 1.0);\n    \n    // Pick colors (switch to white at end for clarity)\n    bool is_not_last_frame = t < 8.0;\n    vec3 bot_col = is_not_last_frame ? vec3(0,1,0) : vec3(1);\n    vec3 top_col = is_not_last_frame ? vec3(1,0,0) : vec3(1);\n    \n    // 'Bottom' circle pattern\n    vec3 col = vec3(0);\n    if (t > 1.0)\n        col = mix(col, bot_col, bot_edge) * step(bot_sdf, 0.0);\n    \n    // 'Top' circle pattern\n    if (t > 2.0)\n        col = mix(col, top_col, top_edge);\n    \n    // Cut away 'bottom' pieces outside of top circles\n    if (t > 3.0)\n        col *= step(top_sdf, 0.0);\n    \n    // Draw hex boundary\n    if (t > 4.0 && t < 7.0)\n        col = mix(col, vec3(1,1,1), hex_edge);\n    \n    // Cut away out-of-hex parts\n    if (t > 5.0)\n        col *= hex_mask;\n    \n    return vec3(col);\n}\n\nvec3 get_tile_color(vec4 uvid, float circle_size_01, vec3 bg_color) {\n\n    /*\n    Function which colors in a single (hex) tile. Caller of function\n    is responsible for tiling the uv coords.\n    \n    Most of the complexity comes from adding noise to the shadowing,\n    and then layering everything in the right order.\n    \n    For a better idea of how the pattern is made, see the\n    construction animation (press tab on viewer)\n    */\n\n    // For convenience\n    vec2 uv = uvid.xy;\n    vec2 noise_uv = (hash22(bg_color.xy*uv*500.5) - 0.5);\n    float noise_id = hash12(uvid.zw * 123.56) + 1.0;\n    float radial_falloff = 1.0 - length(uv + noise_uv*0.55) * two_over_root3;\n\n    // Set important sizing\n    const float radial_offset = root3;\n    float circle_radius = mix(1.0, 1.5, circle_size_01);\n    \n    // Get circle patterns used to contruct tiling\n    float bot_sdf = tricircle_sdf(uv, radial_offset, 0.0, circle_radius);\n    float top_sdf = tricircle_sdf(uv, radial_offset, 1.0, circle_radius);\n    \n    // Create binary masks\n    float top_mask = float(top_sdf > 0.0);\n    float bot_mask = float(bot_sdf > 0.0) * (1.0 - top_mask);\n\n    // Set up coloring\n    vec3 shadow_color = mix(fg_color, bg_color, 0.75);\n    vec3 edge_color = bg_color * 0.75;\n    float edge_thick = 0.04;\n    \n    // Get top-over-bottom shadowing maps (kind of mangled)    \n    float shadow_scale = mix(0.75, 2.0, circle_size_01);\n    float bot_shadow = clamp01(hex_edge_dist((uv + noise_uv)*shadow_scale));\n    float top_shadow = clamp01((root3 - bot_shadow)*shadow_scale);\n    \n    // Layer bottom circles over a background color, with edge line & shadow\n    vec3 col = mix(bg_color, fg_color, bot_mask);\n    col = mix(shadow_color, col, max(bot_shadow, 1.0 - bot_mask));\n    col = mix(edge_color, col, get_edge_outline(bot_sdf, edge_thick));    \n    \n    // Layer top circle pattern over lower pattern, with edge line & shadow\n    col = mix(col, fg_color, top_mask);\n    col = mix(shadow_color, col, max(top_shadow, 1.0-top_mask));\n    col = mix(edge_color, col, get_edge_outline(top_sdf, edge_thick));\n    \n    // Add random highlights for better contrast\n    float radial_highlight = mix(1.0, 0.9 + noise_id * 0.2, radial_falloff * top_mask);\n    col *= radial_highlight;\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Set up full-canvas coordinate spaces\n    vec2 uv_01 = fragCoord.xy / iResolution.xy;\n    vec2 uv = get_centered_unstretched_uvs(fragCoord, iResolution);\n    \n    // Set up background coloring\n    float bg_fade = 0.5*(1.0 + smoothstep(0.4, 0.6, 1.0 - length(uv_01 - 0.5)));\n    vec3 bg_color = mix(bg_color_l, bg_color_r, uv_01.x) * bg_fade;\n    \n    // Turn tiling on/off, for debugging\n    float tile_scale = 7.;\n    float mask = 1.0;\n    if (tile_scale < 1.1) {\n        mask = step(hex_edge_dist(uv), 1.0);\n        tile_scale = 1.0;\n    }\n    \n    // Handle mouse interaction\n    float is_mouse_down = clamp(iMouse.z, 0., 1.);\n    float default_circle_size = 0.3;\n    float mouse_circle_size = mix(0.1, 0.7, get_mouse_x_norm(iMouse, iResolution));\n    float circle_size = mix(default_circle_size, mouse_circle_size, is_mouse_down);\n    \n    // Switch between showing pattern vs. construction animation\n    vec3 col;\n    bool show_construction = get_key_toggle(iChannel0, KEY_tab);\n    if (show_construction) {\n        col = draw_construction(uv*tile_scale, circle_size);\n    } else {\n        vec4 uv_hextile = hex_uv(uv, tile_scale);\n        col = get_tile_color(uv_hextile, circle_size, bg_color);\n    }    \n    fragColor = vec4(col * mask, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define TWOPI 6.28318530718\n#define root3 1.732050808\n#define root3_over_2 0.866025404\n#define two_over_root3 1.154700538\n#define one_over_root3 0.577350269\n\n#define KEY_tab   9\n\n\n// -------------------------------------------------------------------------------\n// Noise functions\n\n// From Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// -------------------------------------------------------------------------------\n// Helpers functions\n\nfloat clamp01(float value) {\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat get_mouse_x_norm(vec4 mouse, vec3 res) {\n\n    /* Grab mouse x position, between 0 and 1, with some dead space on edges */\n\n    float is_mouse_down = clamp(mouse.z, 0., 1.);\n    float mouse_x_norm = clamp(2.0*mouse.x / res.x - 0.5, 0., 1.);\n    float default_mouse_not_down = 1.0;\n    return mix(default_mouse_not_down, mouse_x_norm, is_mouse_down);\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nvec2 get_centered_unstretched_uvs(vec2 fragCoord, vec3 iResolution) {\n\n    /*\n    - Center of the screen maps to (0,0)\n    - Top & bottom have y values: +1 & -1, respectively\n    - Left & right have x values of -/+ the aspect ratio (ex. 16/9)\n    */\n\n    return (2.0*fragCoord - iResolution.xy) / iResolution.y;\n}\n\nvec2 get_xy_from_polar(float r, float theta) {\n    return vec2(r*cos(theta), r*sin(theta));\n}\n\nfloat get_edge_outline(float sdf, float thickness) {\n    return smoothstep(-thickness*0.75, 0.0, abs(sdf) - thickness);\n}\n\n\n// -------------------------------------------------------------------------------\n// Circle sdfs\n\nfloat circle_sdf(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\n\nfloat offset_circle_sdf(vec2 uv, float radial_distance, float angle_radians, float circle_radius) {\n    vec2 xy_offset = get_xy_from_polar(radial_distance, angle_radians);\n    return circle_sdf(uv - xy_offset, circle_radius);\n}\n\nfloat tricircle_sdf(vec2 uv, float radial_offset, float angle_offset, float circle_radius) {\n    \n    float angle_step = TWOPI / 6.0;\n    \n    float c1 = offset_circle_sdf(uv, radial_offset, (angle_offset + 0.0)*angle_step, circle_radius);\n    float c2 = offset_circle_sdf(uv, radial_offset, (angle_offset + 2.0)*angle_step, circle_radius);\n    float c3 = offset_circle_sdf(uv, radial_offset, (angle_offset + 4.0)*angle_step, circle_radius);\n    \n    return min(c1, min(c2, c3));\n}\n\n\n// -------------------------------------------------------------------------------\n// Hex-specific functions\n\n/*\nSee TheArtOfCode/BigWings youtube videos for better explanations of hex stuff:\nhttps://www.youtube.com/watch?v=VmrIDyYiJBA\n*/\n\nfloat hex_edge_dist(vec2 uv) {\n\n    /*\n    Get distance to edges from uv point (0, 0),\n    output is scaled so edges are at a distance of 1.0\n    */\n    \n    // Define edge normal vectors\n    vec2 slant_normal = normalize(vec2(1.0, root3));\n    vec2 vert_normal = normalize(vec2(1.0, 0.0));\n    \n    // Mirror the uv in x & y, so we only have to figure out positive quadrant\n    vec2 mirrored_uv = abs(uv);\n    \n    // Find linear distance to both hex edges\n    float lindist_to_slanted_edge = dot(mirrored_uv, slant_normal);\n    float lindist_to_vertical_edge = dot(mirrored_uv, vert_normal);\n    \n    // Scale so that the distance to edges ends up being 1.0\n    float edge_dist = max(lindist_to_slanted_edge, lindist_to_vertical_edge);\n    edge_dist *= two_over_root3;\n    \n    return edge_dist;\n}\n\n\nvec4 hex_uv(vec2 uv, float tile_scale) {\n\n    /*\n    Makes staggered repeating uv pattern like:\n    ....  ...\n    ...  ...\n    ....  ...\n    \n    Also returns unique 2D ids for each tile\n    Returns vec4: [uv x, uv y, id x, id y]\n    */\n\n    // Get tile steps\n    // x-direction: step full width once, which is twice the inner radius = 2 * 3 / 2 = 3\n    // y-direction: step full height + half height, which is 3 times outer radius = 3 * 1 = 3\n    vec2 grid_step = vec2(root3, 3.0);\n    vec2 half_step = grid_step * 0.5;\n    \n    // Create 2 grids using hex steps,\n    // one grid is off a half step to account for staggered rows\n    vec2 uv_tiled = uv * tile_scale;\n    vec2 odd_grid = mod(uv_tiled, grid_step) - half_step;\n    vec2 even_grid = mod(uv_tiled - half_step, grid_step) - half_step;\n    \n    // Make uvs by picking uvs from whichever grid is closest\n    float pick_even_row = float(length(even_grid) < length(odd_grid));\n    vec2 hex_grid = mix(odd_grid, even_grid, pick_even_row);\n    \n    // Bundle ids with output (useful for adding per-tile noise/effects)\n    // (note, the ids are not integers/nice numbers!)\n    vec2 id = round(hex_grid - uv_tiled);\n    return vec4(hex_grid, id);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2XRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 456, 748, 2263], [2265, 2265, 2334, 2726, 4542], [4544, 4544, 4599, 4644, 5859]], "test": "untested"}
{"id": "dtBXWh", "name": "Sphere recursion", "author": "mrange", "description": "CC0: Sphere recursion\n Once again inspired by some art seen on twitter can't find it again\n Not real refraction going on, just repeating spheres\n", "tags": ["sphere", "recursion"], "likes": 50, "viewed": 554, "published": 3, "date": "1675977859", "time_retrieved": "2024-07-30T18:11:08.265835", "image_code": "// CC0: Sphere recursion\n//  Once again inspired by some art seen on twitter can't find it again\n//  Not real refraction going on, just repeating spheres\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PI_2            (0.5*PI)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.025, 0.85, 0.5));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.75, 0.85, 1.0));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 ce = sph.xyz;\n  float ra= sph.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += clamp(vec3(0.0025/abs(rd.y))*glowCol, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nfloat split(vec3 sp, vec4 sph, float h) {\n  const float aa = 0.04;\n  float angle = atan_approx(sp.x, sp.z)+h*TAU;\n  float d = sph.w*(0.5*sin(4.0*angle)+0.15)/2.5-sp.y;\n  return smoothstep(-aa, aa, d);\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 ld = normalize(vec3(0.0) - ro);\n\n  vec3 bcol = vec3(0.0);\n  vec3 fcol = vec3(0.0);\n  \n  const vec3 beerf = -0.1*vec3(1.0, 2.0, 3.0);\n  float tm = TIME*0.25;\n  float ff = fract(tm);\n  float fo = smoothstep(0.9, 0.0, ff);\n\n  vec3 light = vec3(.01)/(0.0001+ 1.0-max(dot(ld, rd), 0.0));\n\n  const float MaxIter = 12.0;\n  for (float i = 0.0; i <  MaxIter; ++i) {\n    float j = i+floor(tm);\n    float h = hash(j+123.4);\n    vec4 sph = vec4(vec3(0.0) , 4.5*exp2(-(i-ff)*0.5));\n\n    vec2 s2 = raySphere(ro, rd, sph);\n\n    float sd = s2.y - s2.x;\n    if (sd == 0.0) {\n      break;\n    }\n    \n    float fo = i == 0.0 ? fo : 1.0;\n    \n    vec3 beer0 = exp(beerf*(s2.x));\n    vec3 p0 = ro+rd*s2.x;\n    vec3 sp0 = p0 - sph.xyz;\n    vec3 n0 = normalize(sp0);\n    vec3 r0 = reflect(rd, n0);\n    float fre0 = 1.0+dot(rd, n0);\n    fre0 *= fre0;\n    float dif0 = mix(0.25, 1.0, max(dot(sunDir1, n0), 0.0)); \n    float s0 = split(sp0, sph, h);\n    vec3 rcol0 = mix(0.1, 1.0, fre0)*render0(p0, r0);\n    vec3 dcol0 = sunCol1*dif0*dif0*diffCol;\n    rcol0 += 0.125*dcol0;\n    dcol0 += 0.125*rcol0;\n    rcol0 *= beer0;\n    dcol0 *= beer0;\n    rcol0 *= fo;\n\n    if (s0 > 0.9) {\n      bcol = mix(bcol, mix(dcol0, bcol, 1.0-tanh_approx(0.18*s2.x)), s0*fo);\n      break;\n    }\n    \n    fcol += rcol0*(1.0-s0);\n\n    vec3 beer1 = exp(beerf*(s2.y));\n    vec3 p1 = ro+rd*s2.y;\n    vec3 sp1 = p1 - sph.xyz;\n    vec3 n1 = -normalize(sp1);\n    float dif1 = mix(0.25, 1.0, max(dot(sunDir1, n1), 0.0)); \n    float s1 = split(sp1, sph, h);\n    vec3 dcol1 = sunCol1*dif1*dif1*diffCol;\n    dcol1 *= beer1;\n    s1 *= fo;\n    bcol = mix(bcol, dcol1, s1);\n    bcol += light*beer1*fo;\n  }\n\n\n  vec3 col = bcol;\n  col += fcol;\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = TIME*0.5;\n  \n  vec3 ro = vec3(5.0, 3.0, 0.);\n  ro.xz *= ROT(-0.1*tm+3.0);\n  const vec3 la = vec3(0.0, 0.5, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  float ll = length(pp);\n  col *= smoothstep(1.5, 0.5, ll);\n  col -= 0.033*vec3(3.0, 2.0, 1.0)*(ll+0.25);\n  col = aces_approx(col); \n  col = sRGB(col);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 561, 561, 707], [1396, 1496, 1515, 1515, 1602], [1604, 1711, 1737, 1737, 1921], [1923, 2016, 2058, 2058, 2105], [2107, 2225, 2252, 2252, 2328], [2330, 2422, 2466, 2466, 2710], [2712, 2798, 2835, 2835, 2942], [2944, 3072, 3100, 3166, 3242], [3244, 3304, 3326, 3326, 3374], [3377, 3377, 3409, 3409, 4062], [4064, 4064, 4105, 4105, 4266], [4268, 4268, 4300, 4300, 6003], [6005, 6005, 6035, 6035, 6597], [6599, 6599, 6654, 6654, 6846]], "test": "untested"}
{"id": "mlSXWh", "name": "strawberry wine", "author": "mds2", "description": "simple image color filter, I just happen to like the way it looks", "tags": ["simple", "filter", "color", "image"], "likes": 0, "viewed": 260, "published": 3, "date": "1675976711", "time_retrieved": "2024-07-30T18:11:09.013835", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    // col.r = textureLod(iChannel0, uv, 5.0).r;\n    \n    col.gb = mix(vec2(0.5), col.gb, smoothstep(0.0, 0.5, abs(col.gb - vec2(0.5))));\n    // col.gb = mix(vec2(0.5), col.gb, smoothstep(0.0, 1.0, col.gb));\n    col.gb = 0.5 * (col.gb + col.bg);\n    \n    // col.rgb = max(col.rgb, col.rgb - mod(col.rgb, vec3(0.25)) + 0.125);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 607]], "test": "untested"}
{"id": "DlSXD1", "name": "Lucidity or Fantasy?", "author": "maxwellcoffee", "description": "Let's all step outside of our mind a bit. Everyday. At midnight.", "tags": ["psychedelic"], "likes": 2, "viewed": 163, "published": 3, "date": "1675971122", "time_retrieved": "2024-07-30T18:11:09.811702", "image_code": "/* Structure from:\n/* https://www.shadertoy.com/view/cllSzl */\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n\n    float d=0., m=d, t=0.8*sin((iTime) * (0.1 + sin(iTime / 1000.)*0.3) + 20.3) + 0.8, c;\n    vec3 g, p, q;\n\n    for (g*=d; m++<(64. + 60.*sin(iTime * 0.8)); \n        p  = abs(d*normalize(vec3(u/r.y*r(t*.3), 1)))) \n        g += (tan(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-1.,mod(p.z+t*4.,14.)-7.))-.05)*40.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, tan(q.z*6.28+t/.1)*tan(t+length(p.xy))/(6.*sin(t)))) - .1) - d*d/(1. + 0.1 * iTime);\n    \n    O.rgb = (tan(d*4.+t+vec3(0,1,2))+1.) / tan(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 145, 145, 784]], "test": "untested"}
{"id": "DtBXzz", "name": "Lighting models showcase", "author": "VPaltoDance", "description": "\"Showcase of different lighting models\" or simply: \"Remembering good old stuff\".", "tags": ["raymarching", "lighting", "lightingmodels"], "likes": 9, "viewed": 213, "published": 3, "date": "1675971108", "time_retrieved": "2024-07-30T18:11:10.833968", "image_code": "//------------------------------------------------------------------------\n// This shader is designed to showcase different lighting models.\n// The user can change the lighting and material parameters which include ambient lighting, light direction, light color, material color\n// and others to see, how they impact the lighting in each case. Some lighting models have their own parameters, that can be modified.\n// By using this shader, you can gain a deeper understanding of how lighting works in computer graphics and how to implement different lighting \n// models in your own shaders.\n//------------------------------------------------------------------------\n// References:\n//\n// 1. https://www.shadertoy.com/view/ldfSWs by iq was used as a starting project.\n// 2. \"Computer Graphics From Pixels to Programmable Graphics Hardware\" by Brian A. Barsky was used as a hint for recalling lighting models.\n// 3. https://learnopengl.com/PBR/Lighting helped me to recall BRDF related stuff.\n\n\n\n\n// Lighting macros\n#define BACKGROUND_COLOR vec3(0.0, 0.0125, 0.025)\n#define LIGHT_COLOR vec3(0.5, 0.5, 0.5)\n#define DIFFUSE_COLOR vec3(0.5, 0.0, 0.0)\n#define SPECULAR_COLOR vec3(0.5, 0.33, 0.157)\n\n// Material macros\n#define METALNESS 0.8\n#define ROUGHNESS 0.25\n#define SHINESS 16.0\n\n// Constant macros\n#define PI  3.1415926\n#define EXP 2.7182818284\n\n#define RM_MAX_DISTANCE 20.0\n#define RM_DISTANCE_EPS 0.01\n#define RM_MAX_ITER 64\n\n#define SAT(x) clamp(x, 0.0, 1.0)\n\n// Buffers for passing arguments to lighting functions. Makes code more clean and orgnized\n\n// Buffer with data for lighting calculations\nstruct LightBuffer\n{\n    vec3 worldPos;\n    vec3 normal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec3 viewDir;\n    vec3 lightDir;\n    vec3 lightCol;\n    vec3 halfVec;\n    float lambert;\n};\n\n// Buffer with data for material properties of the rendered object\nstruct MaterialBuffer\n{\n    vec3 diffuse;\n    vec3 specular;\n    float roughness;\n    float metalness;\n    float shiness;\n};\n\n// Signed distance field for our object\nfloat sphereSDF(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\n// Function for setting cmera properties\nvoid fillCameraData(out vec3 camPos, out vec3 camLookAt)\n{\n    camPos = vec3(0.0, 0.0, 5.0);\n    camLookAt = vec3(0.0, 0.0, 0.0);\n}\n\n// Function for setting environment properties\nvec3 backgroundColor(vec2 uv)\n{\n    return BACKGROUND_COLOR*(1.0-0.2*length(uv));\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tconst float maxd = 20.0;           \n    float t = 0.0;\n    \n    for( int i = 0; i < RM_MAX_ITER; i++ )          \n    {\n\t    float d = sphereSDF( rayOrigin+rayDir*t, 1.0);\n        if(d < RM_DISTANCE_EPS || t > RM_MAX_DISTANCE) break;  \n        t += d;\n    }\n    return t < RM_MAX_DISTANCE ? t : -1.0;\n}\n\n// Function for filling material buffer data\nMaterialBuffer fillMaterialData()\n{\n    MaterialBuffer mb;\n\n    mb.diffuse = DIFFUSE_COLOR;\n    mb.specular = SPECULAR_COLOR;\n    mb.roughness = ROUGHNESS;\n    mb.metalness = METALNESS;\n    mb.shiness = SHINESS;\n    \n    return mb;\n}\n\n// Filling main geometry properties needed for lighting calculations\nLightBuffer fillLightData(vec3 worldPos, vec3 rayDir)\n{\n    LightBuffer lb;\n    \n    lb.worldPos = worldPos;\n    lb.normal = normalize(worldPos);  // Straightforward way to find normals to a sphere centered at the origin\n    \n    // Calculating tangent and bitangent (needed for some lighting models)\n    if (lb.normal == vec3(0.0, 1.0, 0.0))\n        lb.tangent = vec3(1.0, 0.0, 0.0);\n     else\n        lb.tangent = normalize(cross(vec3(0.0, 1.0, 0.0), lb.normal)); \n    lb.bitangent = normalize(cross(lb.normal, lb.tangent));\n    \n    lb.viewDir = -rayDir;  // We need direction from the pixel to the camera.\n    lb.lightDir = normalize(vec3(sin(iTime), 1.0, cos(iTime)));  // Rotating the light direction around y axis\n    lb.halfVec = normalize(lb.viewDir + lb.lightDir);  // Half vector calculation as it is needed in most of the algorithms\n    lb.lightCol = LIGHT_COLOR;\n    lb.lambert = max(0.0, dot(lb.normal, lb.lightDir));  // Calculation of lambert term\n    \n    return lb;\n}\n\n// Functions for calculating fresnel term\n// It is the ratio of how much the surface reflects vs how much it refracts based on some parameter cosTheta\n// F0 is a parameter, that shows the minimum amount of light, that could be reflected by the object\n// Or \"surface reflection at zero incidence\" (means, when cosTheta is one)\n\nvec3 fresnelSchlick3(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(SAT(1.0 - cosTheta), 5.0);\n}  \n\nfloat fresnelSchlick1(float cosTheta, float F0)\n{\n    return F0 + (1.0 - F0) * pow(SAT(1.0 - cosTheta), 5.0);\n}  \n\n//------------------------------------------------------------------------\n// Blinn-Phong model\n//------------------------------------------------------------------------\nvec3 blinnPhong(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Nothing fancy, using lambert ndotl for diffuse term and halfvec approximation for specular term\n    float diff = lightBuff.lambert;\n    float spec = pow(max(dot(lightBuff.normal, lightBuff.halfVec), 0.0), matBuff.shiness);\n    spec = diff > 0.0 ? spec : 0.0;  // One of possible ways to restrict specular light on the shadowed side of the object\n    \n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n\n//------------------------------------------------------------------------\n// Phong model\n//------------------------------------------------------------------------\nvec3 phong(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Nothing fancy, using lambert ndotl for diffuse term and reflected view direction approximation for specular term\n    vec3 r = reflect(-lightBuff.viewDir, lightBuff.normal);\n    float diff = lightBuff.lambert;\n    float spec = pow(max(dot(lightBuff.lightDir, r), 0.0), matBuff.shiness);\n    \n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n//------------------------------------------------------------------------\n// Cook-Torrance model\n//------------------------------------------------------------------------\nvec3 cookTorrance(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Based on the empirical observation, that roughness squared gives a better look\n    float a = matBuff.roughness * matBuff.roughness;\n    \n    // Calculating dot pproducts\n    float nDotH = max(dot (lightBuff.normal, lightBuff.halfVec), 0.0);\n    float vDotH = max(dot (lightBuff.viewDir, lightBuff.halfVec), 0.0);\n    float nDotV = max(dot (lightBuff.normal, lightBuff.viewDir) , 0.0);\n    float nDotH2 = nDotH * nDotH;\n    \n    // Surface reflection of the object at zero incidence depends on its' metalness parameter\n    vec3 F0 = vec3(0.04); // if the object is pure dielectric - its' F0 is simply 0.04\n    F0 = mix(F0, matBuff.specular, matBuff.metalness);\n    vec3 F = fresnelSchlick3(nDotV, F0);\n    \n    // Here we use the Beckmann distribution function for calculating microfacets' alignment term\n    float power = - (1.0 - nDotH2) / (nDotH2 * a);\n    float BDF = pow (EXP, power) / (a * nDotH2 * nDotH2);\n    \n    // Geometrical attenuation factor\n    float c = 2.0 * nDotH / vDotH;\n    float G = min (1.0, min (c * nDotV, c * lightBuff.lambert));\n    \n    vec3 specBRDF   = F*BDF*G / (PI * nDotV * lightBuff.lambert);  // Combining the terms to get our specular BRDF term\n\n    float  diff = lightBuff.lambert;  // The diffuse BRDF term is immortal lambert\n    vec3  spec = max (vec3(0.0), specBRDF);\n\n    return matBuff.diffuse * diff + matBuff.specular * spec;\n}\n\n//------------------------------------------------------------------------\n// OrenNayar model\n//------------------------------------------------------------------------\n\n// We start with functions for computing main coefficients in the OrenNayar formula\nfloat computeA(float roughness)\n{\n    float rsqr = roughness * roughness;\n    return 1.0 - 0.5 * rsqr / (rsqr + 0.33);\n}\n\nfloat computeB(float roughness)\n{\n    float rsqr = roughness * roughness;\n    return 0.45 * rsqr / (rsqr + 0.09);\n}\n\n// The actual model function\nvec3 orenNayar(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Computing coefficients\n    float A = computeA(0.5);\n    float B = computeB(0.5);\n    \n    // Computing dot staff\n    float nDotL = dot(lightBuff.normal, lightBuff.lightDir);\n    float nDotV = dot(lightBuff.normal, lightBuff.viewDir);\n    \n    // Projecting vectors on the plane, that is tangent to the current surface point\n    // D - direction, S - surface, P - projection\n    vec3  lightDSP = normalize ( lightBuff.lightDir - lightBuff.normal * nDotL );\n    vec3  viewDSP = normalize ( lightBuff.viewDir - lightBuff.normal * nDotV );\n    \n    // Find cos between projections\n    float projCos    = max(dot(lightDSP, viewDSP), 0.0);\n    \n    // Calculating trigonometry for the formula\n    float cosAlpha = max(nDotL, nDotV);\n    float cosBeta  = min(nDotL, nDotV);\n    float sinAlpha = 1.0 - cosAlpha * cosAlpha;\n    float sinBeta = 1.0 - cosBeta * cosBeta;\n    float sinTan = sqrt (sinAlpha * sinBeta) / cosBeta;\n    \n    float diff = lightBuff.lambert * (A + B * projCos * sinTan);\n\n    return matBuff.diffuse * diff;\n\n}\n\n//------------------------------------------------------------------------\n// Minnaert model\n//------------------------------------------------------------------------\n\n// Coefficients needed for the formula\n#define mnrt_K 1.0  \n\nvec3 minnaert(LightBuffer lightBuff, MaterialBuffer matBuff)\n{   \n    // Nothing fancy, just following the formula\n    float nDotV = max(dot(lightBuff.normal, lightBuff.viewDir), 0.0);\n    float minnaert = pow(lightBuff.lambert, 1.0 + mnrt_K ) * pow(1.0 - nDotV, 1.0 - mnrt_K );\n\n    return matBuff.diffuse * minnaert;\n}\n\n//------------------------------------------------------------------------\n// Ashikhmin-Shirley model\n//------------------------------------------------------------------------\n#define as_DIFF 2.0  // Should be 28.0 / (23.0 * PI)\n#define as_PU 15.5\n#define as_PV 15.5\n\nfloat computeC()\n{\n    return sqrt((as_PU + 1.0) * (as_PV + 1.0)) / (8.0 * PI);\n}\n\nvec3 ashikhminShirley(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // Computing the dots\n    float ndotV = max(0.0, dot (lightBuff.normal, lightBuff.viewDir ) );\n    float ndotH = max(0.0, dot (lightBuff.normal, lightBuff.halfVec ) );\n    float hDotL = max(0.0, dot (lightBuff.halfVec, lightBuff.lightDir ) );\n    float hDotV = max(0.0, dot (lightBuff.halfVec, lightBuff.viewDir ) );\n    float bDotH = dot(lightBuff.bitangent, lightBuff.halfVec);\n    float tDotH = dot(lightBuff.tangent, lightBuff.halfVec);\n\n    float C = computeC();  // Calculating main coefficient\n    \n    vec3 F0 = vec3(0.04); // If the object is pure dielectric - its' F0 is simply 0.04\n    F0 = mix(F0, matBuff.specular, matBuff.metalness);\n    vec3 F = fresnelSchlick3(hDotL, F0);  // Calculating the fresnel\n    \n    // Diffuse term\n    vec3 diff = as_DIFF * ( vec3(1.0) - F0) * ( 1.0 - pow ( 1.0 - 0.5*ndotV, 5.0 ) ) * \n                ( 1.0 - pow (1.0 - 0.5 * lightBuff.lambert, 5.0) );\n\t\n    // Specular term\n    float B  = pow ( ndotH, (as_PU * bDotH * bDotH + as_PV * tDotH * tDotH)/(1.0 - ndotH * ndotH) );\n    float denom = hDotV * max(ndotV, lightBuff.lambert);\n    vec3 spec = C * B * F / denom;\n\n    return lightBuff.lambert * (matBuff.diffuse  * diff + matBuff.specular * spec );\n}\n\n\n//------------------------------------------------------------------------\n// Lommel-Seeliger model\n//------------------------------------------------------------------------\nvec3 lommelSeeliger(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // Another diffuse-only model, that came from astronomy\n\tfloat denom = lightBuff.lambert + max(0.0, dot(lightBuff.normal, lightBuff.viewDir));\n\treturn matBuff.diffuse * lightBuff.lambert / denom;\n}\n\n\n//------------------------------------------------------------------------\n// Strauss model\n//------------------------------------------------------------------------\n\n#define\tstr_K  0.1\n#define\tstr_Kf 1.12\n#define\tstr_Ks 1.01\n\n// Strauss model defines its' own fresnel\nfloat strFresnel ( float x, float kf )\n{\n\tfloat\tdx  = x - kf;\n\tfloat\td1 = 1.0 - kf;\n\tfloat\tkf2 = kf * kf;\n\t\n    return (1.0 / (dx * dx) - 1.0 / kf2) / \n            (1.0 / (d1 * d1) - 1.0 / kf2 );\n}\n\nfloat strShadow ( float x, float ks )\n{\n\n\tfloat\tdx  = x - ks;\n\tfloat\td1 = 1.0 - ks;\n\tfloat\tks2 = ks * ks;\n\t\n\treturn (1.0 / (dx * dx) - 1.0 / ks2) / (1.0 / (d1 * d1) - 1.0 / ks2 );\n}\n\nvec3 strauss(LightBuffer lightBuff, MaterialBuffer matBuff)\n{\n    // Smoothness is opposite to roughness\n    float smoothness = 1.0 - matBuff.roughness;\n    const float transparency = 0.0;\n\t\n    // alculating dots and coefficients for the formula\n\tvec3 lrn = reflect(lightBuff.lightDir, lightBuff.normal);\n\tfloat nDotV = dot(lightBuff.normal, lightBuff.viewDir);\n\tfloat hDotV = dot(lrn, lightBuff.viewDir);\n\tfloat strF  = strFresnel(lightBuff.lambert, str_Kf);\n\tfloat smoothness3 = smoothness * smoothness * smoothness;\n \n    // Diffuse formula\n\tfloat\tomst = (1.0 - smoothness3) * (1.0 - transparency);\n\tvec3\tdiff = lightBuff.lambert * (1.0 - matBuff.metalness * smoothness) * omst * matBuff.diffuse;\n    \n    // Specular formula\n\tfloat\tr = (1.0 - transparency) - omst;\n\tfloat\tj = strF * strShadow (lightBuff.lambert, str_Ks) * strShadow ( nDotV, str_Ks);\n\tfloat\trefl = min ( 1.0, r + j * ( r + str_K) );\n\tvec3 \tCs = vec3 ( 1.0 ) + matBuff.metalness * (1.0 - strF) * (matBuff.diffuse - vec3 ( 1.0 )); \n\tvec3\tspec    = Cs * pow (-hDotV, 3.0 / (1.0 - smoothness) ) * refl;\n \n\tdiff = max(vec3(0.0), diff);\n\tspec = max(vec3(0.0), spec);\n    \n    // Combining\n\treturn diff + spec * matBuff.specular;\n}\n\n\n//------------------------------------------------------------------------\n// Ward model (isotropic)\n//------------------------------------------------------------------------\n#define wrd_K 10.0\n\nvec3 ward(LightBuffer lightBuff, MaterialBuffer matBuff)\n{    \n    // (N, H) product is all we need for specular term\n    float nDotH = dot(lightBuff.halfVec, lightBuff.normal);\n    float nDotH2 = nDotH * nDotH;\n    float  spec = exp(-wrd_K * (1.0 - nDotH2) / nDotH2);\n    spec = lightBuff.lambert > 0.0 ? spec : 0.0;\n    // Combining with lambert for diffuse\n    return matBuff.diffuse * lightBuff.lambert + matBuff.specular * spec;\n}\n\n// Manage lighting procedures for according \"screen\"\nvec3 doLighting(LightBuffer lightBuff, MaterialBuffer matBuff, vec2 screenIdx)\n{\n    // Calculating the lighting model index from the current screen index\n    int lightIdx = int(screenIdx.y * 3.0 + screenIdx.x);\n    \n    // Apply corresponding lighting model\n    vec3 linLight = blinnPhong(lightBuff, matBuff);\n    switch(lightIdx)\n    {\n        case 1:\n        linLight = phong(lightBuff, matBuff);\n        break;\n        case 2:\n        linLight = cookTorrance(lightBuff, matBuff);\n        break;\n        case 3:\n        linLight = orenNayar(lightBuff, matBuff);\n        break;\n        case 4:\n        linLight = minnaert(lightBuff, matBuff);\n        break;\n        case 5:\n        linLight = ashikhminShirley(lightBuff, matBuff);\n        break;\n        case 6:\n        linLight = lommelSeeliger(lightBuff, matBuff);\n        break;\n        case 7:\n        linLight = strauss(lightBuff, matBuff);\n        break;\n        case 8:\n        linLight = ward(lightBuff, matBuff);\n        break;\n    }\n    \n    // Add main light\n    linLight *= lightBuff.lightCol;\n    \n    // Add ambient light\n    linLight += (BACKGROUND_COLOR + matBuff.diffuse) * 0.033;\n\n    \n    return linLight;\n}\n\n\nvec3 render(vec2 uv, vec2 screenIdx)\n{\n    // Set up camera variables\n    vec3 camPos, camLookAt;\n    fillCameraData(camPos, camLookAt);\n    \n    // Construct view matrix from camera basis vectors\n    vec3 camForward = normalize(camLookAt - camPos);\n    vec3 camRight = normalize(cross(camForward,vec3(0.0,1.0,0.0)));\n    vec3 camUp = normalize(cross(camRight,camForward));\n    mat3 camMatrix = mat3(camRight, camUp, camForward);\n    \n    // This is how far from the screen the ray starts\n    const float focalLength = 2.0;\n    // Point on screen, through which a ray will pass (in view space)\n    vec3 onScreenPoint = vec3(uv, focalLength);\n    // Create a ray and transform it to world space\n    vec3 rayDir = normalize(camMatrix * onScreenPoint);\n    \n    // Start with background color\n    vec3 col = backgroundColor(uv);\n    \n    float t = rayMarch(camPos, rayDir);\n    \n    if(t > -0.5)\n    {\n        // Compute geometry variables\n        vec3 worldPos = camPos + rayDir * t;        \n        \n        LightBuffer lightBuff = fillLightData(worldPos, rayDir);\n        MaterialBuffer matBuff = fillMaterialData();\n        \n        col = doLighting( lightBuff, matBuff, screenIdx);\n        \n    }\n    \n    vec2 postProcessUV = uv * 0.5 + 0.5;\n    // Apply vignette\n    col *= pow(16. * postProcessUV.x * postProcessUV.y * (1. - postProcessUV.x) * (1. - postProcessUV.y), .2);\n    \n    col = pow(SAT(col), vec3(0.4545));\n    \n    \n    //return vec3(uv, 0.0);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fragCoordScaled = vec2(3.0, 3.0) * fragCoord;\n    vec2 uv = (mod(fragCoordScaled, iResolution.xy) - 0.5 * iResolution.xy)/ min(iResolution.x, iResolution.y);\n    vec2 screenIdx = floor(fragCoordScaled/ iResolution.xy);\n    \n    fragColor = vec4(render(uv, screenIdx), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1983, 2023, 2059, 2059, 2089], [2091, 2132, 2190, 2190, 2263], [2265, 2312, 2343, 2343, 2395], [2397, 2427, 2472, 2472, 2775], [2777, 2822, 2857, 2857, 3055], [3057, 3126, 3181, 3181, 4111], [4440, 4440, 4487, 4487, 4549], [4553, 4553, 4602, 4602, 4664], [4668, 4839, 4903, 5006, 5324], [5327, 5492, 5551, 5671, 5912], [5914, 6087, 6153, 6239, 7533], [7708, 7795, 7828, 7828, 7915], [7917, 7917, 7950, 7950, 8032], [8034, 8063, 8126, 8156, 9158], [9390, 9390, 9452, 9504, 9710], [9981, 9981, 9999, 9999, 10062], [10064, 10064, 10134, 10164, 11344], [11347, 11522, 11590, 11654, 11796], [12027, 12069, 12109, 12109, 12266], [12268, 12268, 12307, 12307, 12449], [12451, 12451, 12512, 12555, 13649], [13848, 13848, 13906, 13965, 14283], [14285, 14338, 14418, 14492, 15516], [15519, 15519, 15557, 15588, 16996], [16998, 16998, 17053, 17053, 17338]], "test": "untested"}
{"id": "DtBSDh", "name": "Donut Slug", "author": "drliquidglitch", "description": "Forked from Leon's donut sketch", "tags": ["cartoon", "window", "donut"], "likes": 0, "viewed": 183, "published": 3, "date": "1675960565", "time_retrieved": "2024-07-30T18:11:11.684694", "image_code": "// Fork of leon's Tribute\n// using code from IQ, Mercury, LJ, Duke, Koltes\n\n// tweak it\n#define donut 30.\n#define cell 3.\n#define height 2.\n#define thin .04\n#define radius 15.\n#define speed 1.\n#define wigglex 0.2*sin(time)\n#define wiggley 0.8\n\n#define STEPS 100.\n#define VOLUME 0.001\n#define PI 3.14159\n#define TAU (2.*PI)\n#define time iTime\n\n// raymarching toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdDisk (vec3 p, vec3 s) { return max(max(length(p.xz)-s.x, s.y), abs(p.y)-s.z); }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat amodIndex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); return c; }\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, vec2 c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\nfloat smoo (float a, float b, float r) { return clamp(.5+.5*(b-a)/r, 0., 1.); }\nfloat smin (float a, float b, float r) { float h = smoo(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nfloat smax (float a, float b, float r) { float h = smoo(a,b,r); return mix(a,b,h)+r*h*(1.-h); }\nvec2 displaceLoop (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nfloat map (vec3);\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\nvec3 getNormal (vec3 p) { vec2 e = vec2(.01,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }\n\nvoid camera (inout vec3 p) {\n    p.xz *= rot(PI/8.);\n    p.yz *= rot(PI/6.);\n}\n\nfloat windowCross (vec3 pos, vec4 size, float salt) {\n    vec3 p = pos;\n    float sx = size.x * (.6+salt*.4);\n    float sy = size.y * (.3+salt*.7);\n    vec2 sxy = vec2(sx,sy);\n    p.xy = repeat(p.xy+sxy/2., sxy);\n    float scene = sdBox(p, size.zyw*2.);\n    scene = min(scene, sdBox(p, size.xzw*2.));\n    scene = max(scene, sdBox(pos, size.xyw));\n    return scene;\n}\n\nfloat window (vec3 pos, vec2 dimension, float salt) {\n    float thinn = .008;\n    float depth = .04;\n    float depthCadre = .06;\n    float padding = .08;\n    float scene = windowCross(pos, vec4(dimension,thinn,depth), salt);\n    float cadre = sdBox(pos, vec3(dimension, depthCadre));\n    cadre = max(cadre, -sdBox(pos, vec3(dimension - padding, depthCadre*2.)));\n    scene = min(scene, cadre);\n    return scene;\n}\n\nfloat boxes (vec3 pos, float salt) {\n    vec3 p = pos;\n    float ry = cell * .43*(.3+salt);\n    float rz = cell * .2*(.5+salt);\n    float salty = rng(vec2(floor(pos.y/ry), floor(pos.z/rz)));\n    pos.y = repeat(pos.y, ry);\n    pos.z = repeat(pos.z, rz);\n    float scene = sdBox(pos, vec3(.1+.8*salt+salty,.1+.2*salt,.1+.2*salty));\n    scene = max(scene, sdBox(p, vec3(cell*.2)));\n    return scene;\n}\n\nfloat map (vec3 pos) {\n    vec3 camOffset = vec3(-4,0,0.);\n\n    float scene = 1000.;\n    vec3 p = pos + camOffset;\n    float segments = PI*radius;\n    float indexX, indexY, salt;\n    vec2 seed;\n\n    // donut distortion\n    vec3 pDonut = p;\n    pDonut.x += donut;\n    pDonut.y += radius;\n    pDonut.xz = displaceLoop(pDonut.xz, donut);\n    pDonut.z *= donut;\n    pDonut.xzy = pDonut.xyz;\n    pDonut.xz *= rot(time*.05*speed);\n\n    // ground\n    p = pDonut;\n    scene = min(scene, sdCylinder(p.xz, radius-height));\n\n    // walls\n    p = pDonut;\n    float py = p.y + time * speed;\n    indexY = floor(py / (cell+thin));\n    p.y = repeat(py, cell+thin);\n    scene = min(scene, max(abs(p.y)-thin, sdCylinder(p.xz, radius)));\n    amod(p.xz, segments);\n    p.x -= radius;\n    scene = min(scene, max(abs(p.z)-thin, p.x));\n\n\n    // elements\n    p = pDonut;\n    p.xz *= rot(PI/segments);\n    py = p.y + cell/2. + time * speed;\n    indexY = floor(py / (cell+thin));\n    p.y = repeat(py, cell+thin);\n    indexX = amodIndex(p.xz, segments);\n    amod(p.xz, segments);\n    seed = vec2(indexX, indexY);\n    salt = rng(seed);\n    p.x -= radius - height;\n    scene = max(scene, boxes(p, salt));\n\n    return scene;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord ) {\n    vec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    uv.x += wigglex*sin(time+(11.0*uv.y));\n    uv.y += wiggley*cos(time+uv.x*uv.y);\n    uv.xy *= rot((1.+sin(time)));\n    vec3 eye = vec3(15.0*sin(time),20.0*cos(time),-100.0+(sin(time)*80.0));\n    vec3 ray = normalize(vec3(uv, 1.3*abs(sin(time))));\n    camera(eye);\n    camera(ray);\n    float dither = rng(uv+fract(time));\n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME) {\n            shade = 1.-i;\n            break;\n        }\n        dist *= .5 + .1 * dither;\n        pos += ray * dist;\n    }\n    vec3 light = vec3(40.,100.,-10.);\n    float shadow = getShadow(pos, light, 4.);\n    color = vec4(1);\n    color *= shade;\n    color *= shadow;\n    color = smoothstep(.0, .5, color);\n    color.r *= 1.0/dither;\n    color.g += uv.y-uv.x;\n    color.b -= uv.y+uv.x;\n    color.rgb = sqrt(color.rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 366, 389, 389, 456], [457, 457, 477, 477, 527], [528, 528, 562, 562, 584], [585, 585, 621, 621, 643], [644, 644, 675, 675, 731], [732, 732, 762, 762, 808], [809, 809, 840, 840, 923], [924, 924, 957, 957, 1018], [1019, 1019, 1059, 1059, 1247], [1248, 1248, 1287, 1287, 1416], [1417, 1417, 1450, 1450, 1474], [1475, 1475, 1505, 1505, 1529], [1530, 1530, 1561, 1561, 1585], [1586, 1586, 1626, 1626, 1665], [1666, 1666, 1706, 1706, 1761], [1762, 1762, 1802, 1802, 1857], [1858, 1858, 1895, 1895, 1941], [1960, 1960, 2006, 2006, 2353], [2354, 2354, 2379, 2379, 2506], [2508, 2508, 2536, 2536, 2586], [2588, 2588, 2641, 2641, 2954], [2956, 2956, 3009, 3009, 3369], [3371, 3371, 3407, 3407, 3769], [3771, 3771, 3793, 3793, 4967], [4969, 4969, 5018, 5018, 5972]], "test": "untested"}
{"id": "mljXDz", "name": "sea adventure", "author": "rcargou", "description": "hi", "tags": ["sdf", "water"], "likes": 14, "viewed": 266, "published": 3, "date": "1675951511", "time_retrieved": "2024-07-30T18:11:12.752838", "image_code": "\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n\n    color += GetBloom(uv) * 0.12;\n    \n    //color *= 2.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n    \n    //fragColor = texture(iChannel0, uv);\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nvec3 getDis() {\n    return vec3(0., 0., iTime * 3.);\n}\n\nvec3 getTrailDis() {\n    return vec3(0., 0., iTime * 35.);\n}\n\nvec3 getLightPos() {\n    return getDis() + vec3(.0, 10, 100.);\n}\n\nvec3 getLightCol() {\n    vec3 col1=vec3(.22,.22,.4);\n    vec3 col2=vec3(.62,.22,.1);\n    return mix(col1, col2, (sin(iTime) +1.) / 2.);\n}\n\nfloat mapStarFish(in vec3 pos, out vec3 id, vec3 ro) {\n    float rep = 5.;\n     // vec3 pp = ro + d * (dot(pos-ro, ) / dot(pos-ro,pos-ro) )\n    if (length( ( ro.x -pos.x) )> 60. || length(ro.z-pos.z) >100.)\n        return 1e10;\n    float l_id = hash21(floor(pos.xz/rep));\n        id.x = hash11( l_id );\n    if(l_id < .85)\n        return 3.;\n  \n    vec3 mp = mod(pos.xxz, rep) - rep / 2.;\n  //  mp.xz = rotate2d(.3) * mp.xz;\n\n     \n    // return length(vec3(mp.x, mp.z,pos.y+9.))-.5;\n    return opExtrusionT(vec3(mp.x, mp.z, pos.y + 9.), .03); \n}\n\nfloat mapTrails(vec3 p) {\n\n//    p.y += sin(p.z) / 20.;\n    p.x -= cos( ( p.z + 20.) / 40.) * 10.;\n    if ( length (p.x -getDis().x) > 20. || abs(p.z - getDis().z) >90.)\n        return 1e10;\n        \n    float r = .1;\n    p.xz -= getTrailDis().xz * rotate2d(r);\n    p.xz *= rotate2d(-r);\n\n    p.y += sin(p.z) / 20.;\n    p.y += sin(iTime * 2. + p.z / 10.);\n    p.y -= 2.;\n    \n    float repz = 30.;\n    float repxy = 8.;\n    float id = hash31(vec3(floor( p.z / repz ) , floor( p.x / repxy), floor( abs( p.y) / repxy) ) );\n\n    p.z = mod(p.z, repz) - repz/2.;\n    \n    p.xy = mod(p.xy, repxy) - vec2(repxy/2.);\n    if (id < .6)\n        return 10.;\n    float s = sdCappedCylinder(p.xzy, 8., .02);\n    return s;\n}\n\nfloat mapSea(vec3 p) {\n\n    return p.y  + 0.1;\n}\n\nfloat mapMoon(vec3 p, out vec3 id) {\n    float l = length(p - getLightPos());\n    vec3 lp = p - vec3(0., 5.,20.);\n\n    p-=getLightPos();\n    float s = length(p) - 5.;\n    \n    vec3 o = getLightPos();\n //   lp/=5.;\n    id = vec3(atan(-lp.y, lp.x) );\n    lp = p;\n    float a =  1. - ((atan(lp.z/lp.x)))/(2.*3.14);\n    float b =  1. - ((acos(lp.y/length(lp))))/3.14;\n    id = vec3(a*2., b*2., 0.);\n    return s;\n}\n\nfloat getWind() {\n    \n    return .4 + ( pow(sin(iTime / 2.), 2.)) * .6;\n    return  (sin(iTime) + 1. ) / 2.;\n}\n\nfloat mapBoat(vec3 p, out vec3 id) {\n\n    p -= getDis();\n    p.z -= (getWind()-.4)  * 2.;\n    p.z-= 2.;\n    p.y += log(sin(iTime * 2.) + 1.5) / 15.;\n\n    p.x -= 1.5;\n    float c1 = sdCappedCylinder(p.xzy, 2., .2);\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(1., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(1.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(2., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(2.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(3., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xyz + vec3(1.5, 0., 0.), 3., .1));\n     \n     p.x += 1.5;\n     p.y -= 1.8;\n     \n     p.z += .8 * abs(p.y*p.y * getWind() ) - 1. * getWind();\n    float v = max(p.z -.1, p.x - 1.);\n    v =  max(v, p.y - 1.);\n    v = abs( p.z - .3);\n    v = max(v, abs( p.x) - 1.2 );\n    v = max(v, abs( p.y) - 1.2 );\n    if (v < c1) {\n        c1 = v;\n        id.y = 1.;\n    } else {\n        id.y = 2.;\n    }\n    return c1;\n}\n\nvec2 map( in vec3 pos, vec3 ro, float mask_water, out vec3 id )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    float d = 1e10;\n    vec3 tmp_id;\n    if (mask_water == 0. && (res.x = mapBoat(pos, tmp_id)) < 1e10) {\n        res.y = 1.0f;\n        id = tmp_id;\n    }\n    if (mask_water == 0. && ( d = mapSea(pos) ) < res.x ) {\n        res.x = d;\n        res.y = 2.;\n        id.x = 1.;\n    } if ( (d = mapStarFish(pos, tmp_id, ro) ) < res.x ) {\n        id = tmp_id;\n        res.x = d;\n        res.y = 3.;\n    } if ( (d = mapTrails(pos)) < res.x ) {\n        res.x = d;\n        res.y = 4.;\n    }\n     if (mask_water==0. && (d = mapMoon(pos, tmp_id)) < res.x ) {\n        res.x = d;\n        res.y = 5.;\n        id = tmp_id;\n    }\n     if ( (d = mapMoon(pos - vec3(0., -25., 0.), tmp_id)) < res.x ) {\n        res.x = d;\n        res.y = 5.;\n        id = tmp_id;\n    }\n    return res;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 id;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy,pos, 0., id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, pos,0. , id).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, pos,0. , id).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, pos,0. , id).x );\n \n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 id , float maskSea, float s)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.0;\n    float tmax = 110.0;\n    int m = 120;\n    if (maskSea > 0.)\n        m = 80;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<m && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t,ro, maskSea , id);\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x*s;// * (1.+ t / 100.);\n        }\n    }\n    \n    return res;\n}\n\nfloat backStars(vec2 uv) {\n\n    uv.y+=cos(uv.x * 1. +0.) / 4.;\n    float ret = 0.;\n    uv.x -= iTime / 16.;\n    \n    for (int i = 0; i < 2; ++i) {\n        uv *= 3.;\n        float rep = .2;\n\n        vec2 m_uv = mod(uv, rep) - rep / 2.;\n        vec2 m_id = floor( uv / rep);\n        \n        float id1 = hash21(m_id / 123.321);\n     //   float id2 = hash22(m_id / 123.321); \n        float star = smoothstep(0.02, 0.01, length(m_uv) );\n        if (id1 > 0.98)\n            ret = star + ret;\n    }\n    return ret;\n}\n\nvec3 sky(vec2 uv) {\n    vec3 k_bottom = vec3(0.05,0.05,.9);\n    vec3 k_sky = vec3(0.4,0.15,.6);\n   \n    float interpolator = max( 0., uv.y -.18);\n    vec3 ret = mix(k_bottom, k_sky, interpolator);\n    ret += vec3(backStars(uv));\n    return ret;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv, out float lum )\n{ \n    vec3 col = vec3(.0f);\n    vec3 id;\n    vec3 id_u;\n    vec2 res = castRay(ro,rd,id, 0.,.9);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * res.x;\n    vec3 albedo = vec3(0.);\n    float dis = res.x;\n    if (res.y == 1.) {\n        vec3 k_wood = vec3(.3, .1, .05) / 1.5;\n        col = k_wood;\n        vec3 ldir = normalize( getLightPos() - p );\n        vec3 n = calcNormal(p);\n        float ndotl = max(0., dot(n, ldir) );\n        col = k_wood * .2 + .8 * k_wood * ndotl;\n        if (id.y == 1.) {\n            col = mix(vec3(.3, .3, .8), sky(uv), .5);\n        }\n    } else if (res.y == 2.) {\n        float v = voronoi(p * .8);\n        vec3 k_sea = vec3(.05, .1, .2) / .7;\n        col = k_sea;\n        col -= v * .08;\n        col *= .5;\n        vec3 t  = pow( texture(iChannel0, p.xz / 100.).xxx * .5, vec3(5.));\n        t += texture(iChannel0, p.xz / 10.).xxx * 0.01;\n        col+=t;\n        v-=t.x * 20.;\n        v = clamp(1., 0., v);\n        rd = normalize(rd + vec3(v*.02, 0., 0.));\n        res = castRay(ro, rd, id, 1.,1.);\n       // float shadow = calcSoftshadow( p, normalize(getLightPos()-p), 1., 10. );\n        if (res.y >= 0.) {\n            if (res.y == 1.) {\n                col = vec3(.3, .1, .05) / 1.5;\n            } else if (res.y == 5.) {\n                col = getLightCol();\n                lum = 4.;\n             } else if (res.y  != 4.){ \n                col = mix( pow( hash13(id.x), vec3(1.)) * 2., col, min(1., v * 2.));\n                lum = 5.;\n            } else {\n                col = vec3(.1);\n            }\n        }\n        col = mix(col, sky(vec2(uv.x + v / 10., -uv.y) ), .1);// * shadow;\n        float d = ( length(p - getLightPos()) );\n        \n       // d *= d*d*d*0.0000001;\n        d = pow(d * .017, 9.);\n  \n        vec3 tot = col * getLightCol() * 200. / d;\n        col += tot;\n        dis = max( min(1., dis/30.), 0.);\n        dis = smoothstep(0.2, 1., dis);\n        dis *= dis*dis;\n        col = mix(col, sky(uv), dis );\n        //col = vec3(1./d);\n    } else if (res.y == 4.) {\n        col = mix( vec3(.5), sky(uv),.5);\n    } else if (res.y == 5.) {\n        col = id;\n        col = texture(iChannel1, vec2(id.xy)).xxx * getLightCol();\n        lum = 20.;\n    } else {\n        col = sky(uv);\n    }\n   \treturn vec3(col);\n}\n\n\nvec3 camAnim() {\n    return vec3(0., log(2.+sin(iTime * 3.)) / 8., 1.0*pow( 2.+sin(iTime / 2.) * 2., .5));\n}\nvec3 cellShade(vec3 c) {\n    float s = 30.;\n    return floor(c*s)/s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n    vec3 dis = getDis();\n    // camera\n    \n    vec3 ro = dis + vec3(6.0f, 1.5f, -5.0f) + camAnim();//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = dis + vec3( 3., 1. + camAnim().y , .5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float lum = 0.;\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        // ray direction\n        p.y -= cos(p.x) / 40.;\n        vec3 rd = normalize( vec3(p.xy,2.) );\n\n        rd = ca * rd;\n        // render\t\n        vec3 col = render( ro, rd, p , lum);\n\n\t\t// gamma\n        col = pow( col*1.5, vec3(0.9045) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    tot = max(tot, vec3(0.));\n    tot = min(tot, vec3(1.));\n   // tot = cellShade(tot);\n    fragColor = vec4( tot, lum  );\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb * texture(iChannel0, coord).w;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 1.12)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float maxHei = 0.8;\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash31(vec3 p) {\n   \tfloat h = dot(p,vec3(127.1,311.7, 21.));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash21( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\t// Maximum value: I think outliers could get as high as \"3,\" the squared diagonal length \n\t// of the unit cube, with the mid point being \"0.75.\" Is that right? Either way, for this \n\t// example, the maximum is set to one, which would cover a good part of the range, whilst \n\t// dispensing with the need to clamp the final result.\n\tfloat d = 1.; \n     \n    // I've unrolled one of the loops. GPU architecture is a mystery to me, but I'm aware \n    // they're not fond of nesting, branching, etc. My laptop GPU seems to hate everything, \n    // including multiple loops. If it were a person, we wouldn't hang out. \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat starfish(vec2 uv) {\n    vec3 col = vec3(0.);\n     vec2 l = uv;\n \n     float it = 5.;\n     for(int i = 0; i < int(it); ++i) {\n        uv.xy = rotate2d(6.28/it + cos(length(uv) * 2.) / 80. ) * uv;\n        float h = 1.;\n\n        float u = smoothstep(.2, .1, uv.y);\n        float d = min(10.,  max(0., h - ((uv.y) / h) ));\n        d = .5 * (d + pow(d, .3));\n        float l = abs(uv.x + sin(0.)/3.) / d + u;\n        float c = smoothstep(.5, .32, l);\n        col += vec3(c);\n    }\n    col += smoothstep(.3, .2, length(uv) );\n   // col = normalize(col);\n    col.x = smoothstep(.0, .1, col.x);\n   // col.x = 1.;\n    //col /= 1.+length(l)*2.;\n    return .1-col.x;\n}\n\n\nfloat opExtrusionT( in vec3 p, in float h )\n{\n    float d = starfish(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 238], [240, 240, 294, 294, 1231], [1233, 1233, 1262, 1262, 1307], [1309, 1309, 1338, 1338, 1390], [1392, 1392, 1454, 1454, 1563], [1565, 1565, 1596, 1596, 1902], [1904, 1904, 1931, 1931, 2510], [2512, 2512, 2569, 2569, 3167]], "test": "untested"}
{"id": "ctjXWR", "name": "testPattern", "author": "yym28088", "description": "testPattern", "tags": ["testpattern"], "likes": 0, "viewed": 152, "published": 3, "date": "1675924259", "time_retrieved": "2024-07-30T18:11:13.505825", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// A simple way to create color variation in a cheap way (yes, trigonometrics ARE cheap\n// in the GPU, don't try to be smart and use a triangle wave instead).\n\n// See https://iquilezles.org/articles/palettes for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bands = 11.0;\n    \n    float curr = bands;\n\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // animate\n    //p.x += 0.01*iTime;\n    \n    // Vec1 -> Brightness\n    // Vec2 -> Saturation\n    // Vec3 -> Size of interval (if all components equal)\n    // Vec4 -> Style of interval (components) \n    // \t\t\t& position on interval (if adding single float)\n    \n    // compute colors\n    vec3 col = vec3(0);\n    if( p.y>((curr -= 1.0)/bands) ) { // Rainbow (orig)\n        col=pal(p.x,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.8,0.8,0.8),vec3(0.0,0.33,0.67)+0.21);\n    } /*else if( p.y > ((curr -= 1.0)/bands) ) { // Rainbow (more yellow, narrower green, deeper red)\n        col=pal(p.x,vec3(0.55,0.4,0.3),vec3(0.50,0.51,0.35)+0.1,vec3(0.8,0.75,0.8),vec3(0.075,0.33,0.67)+0.21);\n    } else if( p.y > ((curr -= 1.0)/bands) ) { // Black -> Blue -> White (cooler)\n        col=pal(p.x,vec3(0.55),vec3(0.8),vec3(0.29),vec3(0.00,0.05,0.15) + 0.54 );\n    } else if( p.y > ((curr -= 1.0)/bands) ) { // Black -> Blue -> White (warmer)\n        col=pal(p.x,vec3(0.5),vec3(0.55),vec3(0.45),vec3(0.00,0.10,0.20) + 0.47 );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(0.9),vec3(0.3,0.20,0.20) + 0.31 );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(0.9),vec3(0.0,0.10,0.20) + 0.47 );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.5),vec3(0.5),vec3(1),vec3(0.0,0.33,0.67));\n    } else if( p.y > ((curr -= 1.0)/bands) ) {\n        col=pal(p.x,vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    }*/\n\n    // band\n    //float f = fract(p.y*bands);\n    // borders\n    //col *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    // shadowing\n    //col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjXWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[357, 357, 425, 425, 468], [470, 470, 527, 527, 2754]], "test": "untested"}
{"id": "Dl2SWR", "name": "Are you dreaming?", "author": "maxwellcoffee", "description": "We are all walking each other home", "tags": ["psychedelic"], "likes": 0, "viewed": 155, "published": 3, "date": "1675924002", "time_retrieved": "2024-07-30T18:11:14.258811", "image_code": "/* Trippier system */\n/* https://www.shadertoy.com/view/cllSzl */\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n\n    float d=0., m=d, t=0.8*sin((iTime) * 0.3 + 20.3) + 0.8, c;\n    vec3 g, p, q;\n\n    for (g*=d; m++<(62. + 60.*sin(iTime * 0.8)); \n        p  = abs(d*normalize(vec3(u/r.y*r(t*.3), 1)))) \n        g += (tan(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-1.,mod(p.z+t*4.,14.)-7.))-.05)*40.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, tan(q.z*6.28+t/.1)*tan(t+length(p.xy))/(6.*sin(t)))) - .1) - d*d/(1. + 0.01 * iTime);\n    \n    O.rgb = (tan(d*4.+t+vec3(0,1,2))+1.) / tan(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2SWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 148, 148, 761]], "test": "untested"}
{"id": "Dt2SWR", "name": "Psychedelic Monk", "author": "maxwellcoffee", "description": "You can function without thoughts?", "tags": ["psychedelic"], "likes": 2, "viewed": 177, "published": 3, "date": "1675923661", "time_retrieved": "2024-07-30T18:11:15.023766", "image_code": "/* Trippier system */\n/* https://www.shadertoy.com/view/cllSzl */\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n\n    float d=0., m=d, t=0.8*sin((iTime) * 0.3 + 20.3) + 0.8, c;\n    vec3 g, p, q;\n\n    for (g*=d; m++<(62. + 60.*sin(iTime * 0.8)); \n        p  = abs(d*normalize(vec3(u/r.y*r(t*.3), 1)))) \n        g += (tan(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-1.,mod(p.z+t*4.,14.)-7.))-.05)*40.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, tan(q.z*6.28+t/.1)*tan(t+length(p.xy))/(6.*sin(t)))) - .1) - d*d/1e1;\n    \n    O.rgb = (tan(d*4.+t+vec3(0,1,2))+1.) / tan(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2SWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 148, 148, 745]], "test": "untested"}
{"id": "ctjSzR", "name": "refraction tracing vs. marching", "author": "elenzil", "description": "left side = ray marched\nright side = ray traced\nexcept the plane is ray-traced in both cases.", "tags": ["optics", "bakeoff"], "likes": 7, "viewed": 202, "published": 3, "date": "1675923380", "time_retrieved": "2024-07-30T18:11:16.053014", "image_code": "\n\nconst uint mtl_0       = 0u;\nconst uint mtl_clear1  = 1u;\nconst uint mtl_clear2  = 2u;\nconst uint mtl_pink    = 3u;\nconst uint mtl_chrome  = 4u;\nconst uint mtl_floor   = 5u;\nconst uint mtl_count   = 6u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0        , 1.0 , v1),                   // sky\n    mtl_t(ior_water  , 0.98, v1),                   // clear1\n    mtl_t(ior_aerogel, 0.94, v1),                   // clear2\n    mtl_t(1.2        , 0.0 , vec3(0.0, 0.8, 1.0)),  // pink\n    mtl_t(1e2        , 0.0 , v1),                   // chrome\n    mtl_t(1.0        , 0.0 , v1)                    // floor\n);\n\nconst float cPixelize  = 1.0;\n\nconst float cMinRayAmt = .004;\nconst uint  cMaxRays   = 11u;\nconst float cSurfEps   = 0.01;\n\nconst int   cMaxMarchSteps    = 100;\nconst float cWSEps            =   0.005;\n      float gUnderStepFactor  =   1.0;\n\n\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 6u\nQ_IMPLEMENTATION\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gT;\nfloat gSmoothEps;\nvec3  gSunDir;\nvec3  gBallPos1;\nvec3  gBallPos2;\nvec3  gBallPos3;\nfloat gLemA;\nvec3  gRGB;\n\nfloat unitBounce(in float t) {\n    t = fract(t) * 2.0 - 1.0;\n    t *= t;\n    return 1.0 - t;\n}\n\nvoid setupScene() {\n    const float br12    = 1.0;\n    const float spacing = 1.5;\n    \n    gBallPos1 = vec3( spacing, 1.01 + unitBounce(gT * 2.31), 0.0);\n    gBallPos2 = vec3(-spacing, 1.01 + unitBounce(gT * 2.52), 0.0);\n    gSunDir   = normalize(v1);\n    \n    float t3 = gT * 2.3;\n    gLemA = (spacing + br12 * 1.5);\n    gBallPos3.xz = vec2(cos(t3), sin(t3) * cos(t3));\n    gBallPos3.xz *= gLemA  / (1.0 + sin(t3) * sin(t3));\n    gBallPos3.z  *= 1.2;\n    gBallPos3.y  = 0.301;// + unitBounce(t3 * 3.543) * 0.2;\n}\n\nvoid rayVsScene_trace(in ray_t r, inout hit_t h) {\n    rayVsSphere(r, gBallPos1, 1.0, mtl_clear1, h);\n    rayVsSphere(r, gBallPos2, 1.0, mtl_clear2, h);\n    rayVsSphere(r, gBallPos3, 0.3, mtl_pink  , h);\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n}\n\nmapSample_t map(in vec3 p) {\n    mapSample_t ret = mapSample_t(1e9, mtl_0);\n    \n    opUnion(ret, sdSphere  (p - gBallPos1, 1.0), mtl_clear1);\n    opUnion(ret, sdSphere  (p - gBallPos2, 1.0), mtl_clear2);\n//  opUnion(ret, sdBoxFrame(p - gBallPos2, vec3(1.0), 0.1) - 0.05, mtl_clear2);\n    opUnion(ret, sdSphere  (p - gBallPos3, 0.3), mtl_pink  );\n    \n    return ret;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene_march(in ray_t r, inout hit_t h) {\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e2; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        mapSample_t ms = map(p);\n        if (ms.dist * r.side < cWSEps) {\n            h.hit = true;\n            h.t   = t;\n            h.pnt = p;\n            h.nrm = mapNormal(p);\n            h.mtl = ms.mtl;\n            return;\n        }\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n}\n\n\nbool gUseMarching;\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    if (gUseMarching) {\n        rayVsScene_march(r, h);\n    }\n    else {\n        rayVsScene_trace(r, h);\n    }\n}\n\n//------------------------------------------------------------------\n\nconst float blankSkyTone = 0.01;\n\nvec3 toneSky(in ray_t r) {\n    return simple_sky(r.ro, r.rd, gSunDir);\n}\n\nvec3 toneFloor(in vec2 p) {\n#if 0\n    const float width2 = 0.03;\n          float width1 = width2 * mix(0.1, 0.9, smoothstep(10.0, 1.0, length(p)));\n    p *= 0.25;\n    float q = 1.0;\n    q *= smoothstep(width1, width2, abs(fract(p.x) - 0.5));\n    q *= smoothstep(width1, width2, abs(fract(p.y) - 0.5));\n    q *= smoothstep(width1, width2, abs(length(p) / 1.5 - 1.0) * 1.5);\n    q  = 1.0 - 0.95 * q;\n    q = mix(q, blankSkyTone, smoothstep(2.0, 10.0, length(p)));\n#else\n    float q = 0.006;\n#endif\n    \n    vec3 rgb = v1 * q;\n    \n    float lemL = dot(p, p) * dot(p, p);\n    float lemR = gLemA * gLemA * (p.x * p.x - p.y * p.y / (1.2 * 1.2));\n    float lemD = lemL - lemR;\n    if (dot(p, p) < 10.0) {\n        const vec3 lemC = vec3(0.4, 0.01, 0.01);\n        rgb = mix(rgb, lemC, smoothstep(gSmoothEps * 80.0, 0.0, abs(lemD) - 0.9));\n        rgb = mix(rgb, vX + vY, smoothstep(gSmoothEps * 2.0, 0.0, length(p) - 0.15));\n    }\n    \n    return rgb;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_clear1:\n        case mtl_clear2:\n        case mtl_pink:\n        case mtl_chrome:\n            return materials[h.mtl].color;\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n    }\n}\n\n//------------------------------------------------------------------\n\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    // process the queue until it's empty.\n    // careful you don't get an infinite loop here.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit\n            gRGB += r.amt * tone(r, h);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n            \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            float reflAmt = schlick  (R0, dot(r.rd, -nrm));            \n            float trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            float diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n                        \n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n\n            if (diffAmt > cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                // cast a ray for shadows.\n                ray_t shdRay;\n                shdRay.ro         = h.pnt + h.nrm * cSurfEps;\n                shdRay.rd         = gSunDir;\n                shdRay.amt        = diffAmt;\n                shdRay.side       = 1.0;\n                hit_t shdHit      = newHit();\n                \n                float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                \n                rayVsScene(shdRay, shdHit);\n                float lit = 1.0 - float(shdHit.hit);\n                                \n                vec3 diff = lit * diffAmt * sunDot * tone(r, h);\n                                \n                gRGB += diff;\n            }\n\n            // moving on to transmission and then reflection.\n            \n            if (QSpaceLeft() < 2u)    continue;\n            if (gRayCount >= cMaxRays) continue;\n            \n            if (trnsAmt > cMinRayAmt) {\n                float eta = ior_air / m.ior;\n                if (r.side < 0.0) {\n                    eta = 1.0 / eta;\n                }\n                vec3 trnRayDir = refract(r.rd, nrm, eta);\n                if (dot(trnRayDir, trnRayDir) < 0.001) {\n                    // total internal reflection.\n                    // this is theoretically impossible for a ray that entered a sphere,\n                    // but keeping it in here anyhow for more exotic scenarios.\n                    reflAmt += trnsAmt;\n                }\n                else {\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = trnRayDir;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    \n                    QEnqueue(trnRay);\n                }\n            }\n\n            if (reflAmt > cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime * 0.2;\n    gSmoothEps = 4.0 / MINRES;\n    setupScene();\n    \n    // pixelate\n    vec2 XY2 = XY - fract(XY / cPixelize) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    vec2 m  = viewportFromScreen(iMouse.xy);\n    \n    gUseMarching = XY.x < RES.x / 2.0;\n        \n    // setup camera\n    float theta     = (length(iMouse.xy) < 40.0 ? gT : 0.0) - m.x * pi;\n    vec3  lookTo    = vY * 1.5;\n    vec3  lookFrom  = vec3(cos(theta), 0.8 - 1.0 * m.y, sin(theta)) * 4.0;\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -2.0));\n    r0.amt  = 1.0;\n    r0.side = 1.0;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n    \n    // uncomment to view # of rays per pixel\n    // rgb = v1 * float(gRayCount) / float(cMaxRays);\n    \n    gRGB = mix(gRGB, vec3(0.4), 0.5 - 0.5 * step(3.0, abs(XY.x - RES.x/2.0)));\n\n    RGBA = vec4(gRGB, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit = false;\n    ret.t   = 1e9;\n    return ret;\n}\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n//  David Hoskins\n//  https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nvoid opUnion(inout mapSample_t ms, float dist, uint mtl) {\n    if (dist < ms.dist) {\n        ms.dist = dist;\n        ms.mtl  = mtl;\n    }\n}\n\nvoid opUnion(inout float distA, float dist) {\n    distA = min(distA, dist);\n}\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1133, 1133, 1163, 1163, 1227], [1229, 1229, 1248, 1248, 1742], [1744, 1744, 1794, 1794, 1992], [1994, 1994, 2022, 2022, 2363], [2366, 2524, 2547, 2547, 2749], [2752, 2752, 2802, 2802, 3259], [3281, 3281, 3325, 3325, 3438], [3544, 3544, 3570, 3570, 3616], [3618, 3618, 3645, 3645, 4563], [4565, 4565, 4600, 4600, 4885], [4973, 4973, 4989, 5118, 8223], [8225, 8225, 8268, 8268, 9360]], "test": "untested"}
{"id": "ct2SWR", "name": "Threshold (Psychedelic)", "author": "maxwellcoffee", "description": "One hit away from Blasting Off", "tags": ["psychedelic"], "likes": 1, "viewed": 135, "published": 3, "date": "1675923322", "time_retrieved": "2024-07-30T18:11:17.132129", "image_code": "/* Trippier system */\n/* https://www.shadertoy.com/view/cllSzl */\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n\n    float d=0., m=d, t=0.8*sin((iTime) * 0.3 + 20.3) + 0.8, c;\n    vec3 g, p, q;\n\n    for (g*=d; m++<(62. + 60.*sin(iTime * 0.8)); \n        p  = abs(d*normalize(vec3(u/r.y*r(t*.3), 1)))) \n        g += (tan(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-1.,mod(p.z+t*4.,14.)-7.))-.05)*40.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, tan(q.z*6.28+t/.1)*tan(t+length(p.xy))/(6.*sin(t)))) - .1) - d*d/5e2;\n    \n    O.rgb = (tan(d*4.+t+vec3(0,1,2))+1.) / tan(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2SWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 148, 148, 745]], "test": "untested"}
{"id": "mlBXDR", "name": "Smudged orb", "author": "A_Toaster", "description": "A fingerprint magnet.\nJust a quick test while I'm working on a more complex scene. Semi-accurate thin-film interference effect for the smudges, and semi-accurate PBR.", "tags": ["sdf", "marble", "pbr", "iridescent", "thinfilm"], "likes": 7, "viewed": 269, "published": 3, "date": "1675918963", "time_retrieved": "2024-07-30T18:11:18.179329", "image_code": "#define EPS 0.0001\n#define NORM_EPS (EPS * 2.)\n#define SHADOW_BIAS (0.)\n#define MAX_DIST 10.\n\n#define PI 3.1415926535\n\nconst vec3 cam_origin = vec3(0., 0.75, 0.);\n\nconst vec3 ambient_boost = vec3(0.0);\n\n// Function prototypes\nvec3 calcNormal( in vec3 pos);\n\n\n// From https://www.shadertoy.com/view/XdsGDB\n// Set up a camera looking at the scene.\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions\n// -----------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n// SDF Functions\n// -----------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opU( float d1, float d2 ) { return min(d1, d2); }\n\n// polynomial smooth min\nfloat opSU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Smooth min returning mix factor\nvec2 opSUMix( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opMirrorZ(vec3 p){\n    return vec3(p.x, p.y, abs(p.z));\n}\n\n\n// Pedestal SDF\n// -----------------------------------------------------------------\n\nfloat pedestal_ridges(vec3 p) {\n    p.xz = abs(p.xz);\n    return min(\n        sdVerticalCapsule(p - vec3(0.7, -3.5, 1.), 3., 0.15),\n        sdVerticalCapsule(p - vec3(1., -3.5, 0.7), 3., 0.15)\n    );\n}\n\n\nfloat ground_displacement(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    vec3 q2 = p * 40.;\n    float f2 = noise( q2 ); q2 = m*q2*2.03;\n    f2 += 0.5*noise( q2 ); q2 = m*q2*2.04;\n    f2 += 0.25*noise( q2 ); q2 = m*q2*2.05;\n    f2 += 0.125*noise( q2 );\n    //f2 = f2 * f2 * (2. - f2);\n    \n    return f2 * 0.125;\n}\n\n\nfloat ground(vec3 p) {\n    vec3 q = p + vec3(0., 0.10, 0.);\n    float d = opSU(\n        opSU(\n            sdBox(q, vec3(1., 0.1, 1.)),\n            sdBox(q + vec3(0., 0.15, 0.), vec3(.95, 0.1, .95)),\n            0.05\n        ),\n        opSU(\n            sdBox(q + vec3(0., 2., 0.), vec3(0.85, 2., 0.85)),\n            opSS(\n                pedestal_ridges(q),\n                sdBoxFrame(q + vec3(0., 2., 0.), vec3(0.9, 2., 0.9), 0.2),\n                0.005\n            ),\n            0.03\n        ),\n        0.09\n    );\n    \n    // Calculate displacement if very close\n    if(d < 0.1)\n        d -= 0.002 * ground_displacement(p) + 0.01;\n    // Otherwise decrease distance a bit to avoid overshoot\n    else d -= .02;\n    return d;\n}\n\n// ball SDF\n// -----------------------------------------------------------------\n\nfloat ball(vec3 p){\n\n    \n    return sdSphere(p - vec3(0., 1., 0.), 0.75);\n}\n\nfloat map(vec3 p) {\n    return min(\n        ground(p),\n        ball(p)\n    );\n}\n\n\nfloat fract_noise(vec3 p) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \n    vec3 q1 = p;\n    \n    float f1 = 0.5000*noise( q1 ); q1 = m*q1*2.01;\n    f1 += 0.2500*noise( q1 ); q1 = m*q1*2.02;\n    f1 += 0.1250*noise( q1 ); q1 = m*q1*2.03;\n    return f1;\n}\n\nfloat marble(vec3 p) {\n    float f1 = fract_noise(p);\n    f1 = smoothstep(0.5, 0.6, f1);\n    f1 = pow(4.0*f1*(1.0-f1), 2.);\n    \n    return f1;\n}\n\nvoid material(in vec3 p, out vec3 albedo, out float roughness, out float ao, out float metallic, out float film_thickness, out vec3 normal) {\n    float ground = ground(p);\n    float ball = ball(p);\n    \n    if(ground < ball) {\n        // Ground material\n        float d = clamp(ground_displacement(p) * 5., 0., 1.);\n        d = pow(1. - d, 2.);\n        float c = marble(p * vec3(2., 0.5, 2.))\n            + marble(p * vec3(5., 1., 5.));\n        c = clamp(c, 0., 1.);\n        albedo = vec3(0.23, 0.23, 0.23);\n        roughness = mix(0.65, 0.6, c);\n        ao = mix(1., 0.7, d);\n        metallic = c * 0.3;\n        film_thickness = 0.;\n    } else {\n        // ball material\n        albedo = vec3(0.35, 0.34, 0.31);\n        vec3 p2 = vec3(p.x * sin(iTime) + p.z * cos(iTime), p.y, p.x * cos(iTime) + p.z * -sin(iTime)); \n        float oiliness = smoothstep(0.25, 1., fract_noise(p2 * 2.));\n        \n        roughness = mix(0.3, 0.8, oiliness);\n        ao = 1.;\n        metallic = mix(0.99, 0.7, oiliness);\n        \n        film_thickness = 10. * oiliness + 1.;\n    }\n    \n    normal = calcNormal(p);\n}\n\n// Raymarching functions\n// -----------------------------------------------------------------\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h * 1.;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos)\n{\n    const float h = NORM_EPS;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 1.0*occ, 0.0, 1.0 );\n}\n\n\n//Tonemapping\n// -----------------------------------------------------------------\n\n// linear to tonemapped\nvec3 ACES(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n}\n\n// tonemapped to linear\nvec3 ACES_Inv(vec3 x) {\n    return (sqrt(-10127.*x*x + 13702.*x + 9.) + 59.*x - 3.) / (502. - 486.*x); // thanks to https://www.wolframalpha.com/input?i=2.51y%5E2%2B.03y%3Dx%282.43y%5E2%2B.59y%2B.14%29+solve+for+y\n}\n\n\n\n// Rendering functions\n// -----------------------------------------------------------------\n// https://learnopengl.com/PBR/Theory\n\n// Irridescent thin film interference effect\nvec3 thinFilm(float ndotv, float thickness, float metallic) {\n    // Relative wavelengths of each component\n    const vec3 freqs = vec3(700./435., 565./435., 1.);\n    const float ior = 2.;\n    float n2 = sin(acos(ndotv)) / ior;\n    float cos2 = cos(asin(n2));\n    float dist = thickness / cos2;\n    \n    // Strength of thin film effect is controlled by reflection angle\n    // and mettalicity of material.\n    // Power to make irridescence stronger\n    float strength = pow(metallic * ndotv, 0.2);\n    \n    vec3 rgb = (cos(dist * freqs) *strength * 0.5) + vec3(0.5);\n    return rgb;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\nvec3 light(\n    vec3 light_dir, vec3 light_col, vec3 normal, vec3 rd, float attenuation,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness\n) {\n        // Shading calculations\n        vec3 V = -rd; // Camera direction\n        vec3 H = normalize(light_dir - rd);\n        \n        float ndotl = max(dot(normal, light_dir), 0.);\n        float hdotv = max(dot(H, V), 0.);\n        float ndotv = max(dot(normal, V), 0.);\n        \n        vec3 radiance = light_col * attenuation;\n        \n        vec3 F = fresnelSchlickRoughness(hdotv, F0, roughness);\n        F *= thinFilm(ndotv, film_thickness, metallic);\n        \n        \n        float NDF = DistributionGGX(normal, H, roughness);\n        float G   = GeometrySmith(normal, V, light_dir, roughness);\n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * ndotv * ndotl  + 0.0001;\n        vec3 specular     = numerator / denominator; \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n\n        kD *= 1.0 - metallic;\n        \n        return (kD * albedo / PI + specular) * radiance * ndotl;\n}\n\nvec3 ambient(\n    vec3 normal, vec3 rd, float ao,\n    vec3 albedo, float roughness, float metallic, vec3 F0, float film_thickness\n) {\n    vec3 V = -rd;\n    vec3 F = fresnelSchlickRoughness(max(dot(normal, V), 0.0), F0, roughness);\n    \n    vec3 R = reflect(-V, normal);\n    \n    F *= thinFilm(dot(V, normal), film_thickness, metallic);\n    // Diffuse\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    vec3 irradiance = textureLod(iChannel1, normal.zyx, 4.8).rgb + ambient_boost;\n    vec3 diffuse    = irradiance * albedo;\n    \n    //Specular\n    const float MAX_REFLECTION_LOD = 16.0;\n    vec3 prefilteredColor = textureLod(iChannel0, R.zyx,  roughness * MAX_REFLECTION_LOD + 1.).rgb;  \n    \n    \n    vec2 envBRDF  = texelFetch(iChannel2, ivec2(vec2(max(dot(normal, V), 0.0), roughness) / vec2(255.)), 0).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y) * albedo;\n    \n    return (kD * diffuse + specular) * ao;\n}\n\n// -----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro, rd;\n    \n    vec2 camRot = vec2(2.,3.5)+vec2(-4.,7.)*(iMouse.yx/iResolution.yx);\n    \n    CamPolar(ro, rd,\n             cam_origin, // Origin\n             camRot, // Rotation\n             3.5, // Distance\n             1.2, //Zoom\n             fragCoord);\n    \n    vec3 sun_dir = normalize(vec3(-0.25, 1., -1.));\n    vec3 sun_color = vec3(23.47, 21.31, 20.79);\n    \n    float dist;\n    \n    vec3 color;\n    if (intersect(ro, rd, dist)) {\n        //Foreground object\n        vec3 hit_pt = ro + rd * dist;\n        \n        // Get material\n        vec3  albedo; // Subsurface color\n        float roughness;\n        float ao;          // Microsurface AO\n        float metallic;\n        float film_thickness;\n        vec3 normal;\n        \n        material(hit_pt, albedo, roughness, ao, metallic, film_thickness, normal);\n        \n        // Square roughness\n        roughness = roughness * roughness;\n        \n        vec3 F0 = mix(vec3(0.04), albedo, metallic);\n        \n        // Calculate AO and shadows\n        \n        ao = ao * calcAO(hit_pt, normal);\n        float shadow = softShadow(hit_pt + normal * dist * SHADOW_BIAS, sun_dir, 0.01, 3.);\n        float attenuation = shadow * ao;\n        \n        \n        // Shading calculations\n        vec3 Lo = light(sun_dir, sun_color, normal, rd, attenuation, albedo, roughness, metallic, F0, film_thickness);\n        vec3 ambient = ambient(normal, rd, ao, albedo, roughness, metallic, F0, film_thickness);\n        \n        color = Lo + ambient * 2.;\n    } else {\n        //Background\n        color = ACES_Inv(textureLod(iChannel0, rd.zyx, 1.4).rgb) * 2.;\n    }\n    \n    \n    color = ACES(color);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Pre-calculated BRDF LUT for reflections\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_SQRT_PI 0.56418958354\n\nvec2 SampleEquirectangular(vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    return uv;\n}\n\nvec3 F_Schlick(float NoV, vec3 F0, float roughness)\n{\n\treturn F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NoV, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat G_SmithIBL(float roughness, float NoL, float NoV)\n{\n\tfloat k = roughness * roughness * 0.5;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nfloat G_SmithDirect(float roughness, float NoL, float NoV)\n{\n\tfloat k = (roughness + 1.0) * (roughness + 1.0) * 0.125;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 n)\n{\n\tfloat a = roughness * roughness;\n    float phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    vec3 h;\n    h.x = sinTheta * cos(phi);\n    h.y = sinTheta * sin(phi);\n    h.z = cosTheta;\n    \n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = normalize(cross(up, n));\n    vec3 tangentY = cross(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    uint bits = i;\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    float inv = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i)/float(N), inv);\n}\n\n\nvec2 IntegrateBRDF(float roughness, float NoV)\n{\n\tvec3 v;\n    v.x = sqrt(1.0 - NoV * NoV);\n    v.y = 0.0;\n    v.z = NoV;\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = clamp(l.z, 0.0, 1.0);\n        float NoH = clamp(h.z, 0.0, 1.0);\n        float VoH = clamp(dot(v, h), 0.0, 1.0);\n        \n        if (NoL > 0.0)\n        {\n            float G = G_SmithIBL(roughness, NoL, NoV);\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    \n    return vec2(A, B) / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (iFrame > 0) {\n        if(fragCoord.x > 256. || fragCoord.y > 256.){\n            fragColor = vec4(0.);\n        } else {\n    \n    \n            vec2 uv = fragCoord / vec2(256.);\n            float NoV = uv.x;\n            float roughness = uv.y;\n            fragColor = vec4(IntegrateBRDF(roughness, NoV).xy, 0.0, 1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 346, 478, 508, 974], [977, 1065, 1091, 1091, 1298], [1301, 1387, 1422, 1422, 1446], [1448, 1448, 1479, 1479, 1570], [1572, 1572, 1617, 1617, 1904], [1906, 1906, 1926, 1926, 1949], [1951, 1951, 2014, 2076, 2623], [2625, 2625, 2678, 2678, 2737], [2741, 2741, 2785, 2785, 2874], [2877, 2877, 2910, 2910, 2932], [2934, 2934, 2967, 2967, 2988], [2990, 2990, 3023, 3023, 3045], [3047, 3072, 3115, 3115, 3214], [3220, 3255, 3298, 3298, 3442], [3444, 3444, 3487, 3487, 3587], [3589, 3589, 3632, 3632, 3731], [3733, 3733, 3756, 3756, 3795], [3884, 3884, 3915, 3915, 4085], [4088, 4088, 4123, 4123, 4497], [4500, 4500, 4522, 4522, 5229], [5313, 5313, 5332, 5332, 5389], [5391, 5391, 5410, 5410, 5470], [5473, 5473, 5500, 5500, 5832], [5834, 5834, 5856, 5856, 5979], [5981, 5981, 6122, 6122, 7079], [7081, 7175, 7233, 7233, 7445], [7447, 7447, 7512, 7512, 7736], [7739, 7791, 7822, 7822, 8103], [8106, 8106, 8148, 8148, 8434], [8521, 8545, 8564, 8564, 8701], [8703, 8727, 8750, 8750, 8942], [9077, 9122, 9183, 9229, 9706], [9708, 9708, 9764, 9764, 10031], [10033, 10033, 10089, 10089, 10244], [10245, 10245, 10307, 10307, 10525], [10527, 10527, 10573, 10573, 10647], [10649, 10649, 10721, 10721, 10822], [10824, 10824, 10996, 11028, 11933], [11935, 11935, 12068, 12068, 12865], [12867, 12936, 12993, 12993, 14694]], "test": "untested"}
{"id": "mtSSRD", "name": "Year of Truchets #005", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 23, "viewed": 250, "published": 3, "date": "1675907238", "time_retrieved": "2024-07-30T18:11:18.944284", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #005\n    02/08/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p+iDate.z,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e-b), 0., 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    return .6+.55*cos(PI2*t+iDate.z*(vec3(1.,.99,.95)+vec3(0.329,0.851,0.529))); \n}\n\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.,ga7=0.,ga8=0.,lhsh,ghsh;\nvec2 lid,gid;\nmat2 ry,rx,r1,r2,r3,r4,r5,r6;\n\n#define SCALE 1.\nconst float scale = 2./SCALE;\nconst float xf = scale*.5;\nconst vec2 l = vec2(scale);\nconst vec2 s = l*2.;\nconst float sl = l.x*4.;\nconst vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n\n//@iq sdf \nfloat torus( vec3 p, vec2 a ){\n  return length(vec2(length(p.xz)-a.x,p.y))-a.y;\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat tbox( vec3 p ) {\n    vec2 d2 = vec2(length(p.xz-xf), length(p.xz+xf));\n    vec2 gx = d2.x<d2.y ? vec2(p.xz-xf) : vec2(p.xz+xf);\n    vec3 pv = vec3(gx.x,p.y,gx.y);\n    float d = torus(pv,vec2(xf,.2));\n    float b = box(p,vec3(xf));\n    d=max(abs(d)-.085,-d);\n    d=max(d,b);\n    return d;\n}\nfloat flt( vec3 p ) {\n    float d = min(length(p.yz)-.2,length(p.yx)-.2);\n    float b = box(p,vec3(xf));\n    d=max(abs(d)-.085,-d);\n    d=max(d,b);\n    return d;\n}\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    mat2 rz = rot((ga7-ga8)*PI);\n    p.xz*=rz;\n\n    vec2 r,ip,ct = vec2(0);\n\n    //@Shane - multi tap grid\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2.;              // Block center.\n        r = p.xz - ct*s;             // Local coordinates. \n        ip = floor(r/s) + .5;        // Local tile ID. \n        r -= (ip)*s;                 // New local position.   \n        vec2 idi = (ip*s) + ct;\n \n        float hs = hash21(idi);\n        \n        vec3 q = vec3(r.x,p.y,r.y);\n        \n        float chx = mod(idi.x,2.) * 2. - 1.;\n        float chy = mod(idi.y,2.) * 2. - 1.;\n        \n        float chk = (chy<1. ^^ chx<1.) ? 1. : .0;\n        \n        if(chk>.5) { \n            q.xz*=r1; \n            q.xy*=r5;\n            q.xy*=r3;\n        } else { \n            q.xz*=r2; \n            q.xy*=r4;\n            q.xy*=r6;\n        }\n\n        if(hs>.5) q.z*=-1.;\n        \n        float frame2 = (hs>.8) ? flt(q):tbox(q);\n        if(frame2<res.x) {\n            float nf = fract(hs*32.);\n            lid=idi;\n            lhsh=hs;\n            res = vec2(frame2,nf<.175?4.:2.);\n        }\n\n    }\n    \n    float ff = p.y+2.;\n        if(ff<res.x) {\n        res = vec2(ff,1.);\n    }\n        \n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d);\n    vec3 lpos =  vec3(8,5,0);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n\n    vec3 h=vec3(.01);\n    if(m==1.) {\n        //p.xz-=T*vec2(.5,-.5);\n        vec2 id = floor(p.xz*1.25);\n        vec2 uv = fract(p.xz*1.25)-.5;\n        float hs = hash21(id);\n        if(hs>.5) uv.x*=-1.;\n        \n        float px = 10./R.x;\n        \n        vec2 d2 = vec2(length(uv-.5), length(uv+.5));\n        vec2 nv = d2.x<d2.y? vec2(uv-.5) : vec2(uv+.5);\n        float d = length(nv)-.5;\n        d=smoothstep(px,-px,abs(abs(d)-.2)-.075);\n        h=mix(h,vec3(.075),d);\n        \n    } else {\n        h = m==2. ? hue(ghsh*.3) : vec3(.075);\n    }\n    \n    return diff*h;\n}\n\nfloat zoom = 7.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    \n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 3. - 1.5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    \n    zoom = 7.-x;\n    \n    tmod = mod(time, 16.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(10.0, 12.0, tmod);\n    float t3 = lsp(4.0, 8.0, tmod);\n    float t4 = lsp(5.0, 8.0, tmod);\n    float t5 = lsp(13.0, 15.0, tmod);\n    float t6 = lsp(8.0, 10.0, tmod);\n    float t7 = lsp(7.0, 11.0, tmod);\n    float t8 = lsp(1.0, 5.0, tmod);\n    \n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    ga5 = eoc(t5);\n    ga5 = ga5*ga5*ga5;\n    \n    ga6 = eoc(t6);\n    ga6 = ga6*ga6*ga6;\n    \n    ga7 = eoc(t7);\n    ga7 = ga7*ga7*ga7;\n    \n    ga8 = eoc(t8);\n    ga8 = ga8*ga8*ga8;\n\n    r1=rot(ga1*PI); \n    r2=rot(ga2*PI); \n    r3=rot(ga3*PI);\n    r4=rot(ga4*PI);\n    r5=rot(ga5*PI);\n    r6=rot(ga6*PI);\n            \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom-5.);\n    vec3 rd = vec3(0,0,1.);\n\n    rx = rot(.615);\n    ry = rot(-.785+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    vec3  p = ro + rd;\n    float atten = .95;\n    \n    float k = 1.,d = 0.,b = 4.;\n    \n    for(int i=0;i<80;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<32 ? ray.x*.5 : ray.x;\n        p += rd * d *k;\n        \n        gid=lid;\n        ghsh=lhsh;\n            \n        if (d*d < 1e-6) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n            b--;\n            \n            if(m==1.||b<0.) break;\n            \n            atten *= ray.y==4.?.95:.65;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n            \n            if(m==2.) {\n                rd=reflect(-rd,n);\n                p+=n*.035;\n                b-=2.;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.85 ? C+.015 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C*vec3(0.494,0.655,0.827),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSSRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[430, 430, 450, 450, 495], [496, 496, 520, 520, 586], [587, 587, 625, 625, 666], [667, 667, 687, 687, 723], [725, 773, 791, 791, 876], [1235, 1246, 1276, 1276, 1327], [1329, 1329, 1357, 1357, 1442], [1444, 1444, 1466, 1466, 1739], [1740, 1740, 1761, 1761, 1903], [3152, 3221, 3251, 3251, 3514], [3516, 3516, 3608, 3608, 4308], [4327, 4327, 4368, 4382, 6743]], "test": "untested"}
{"id": "dtSSDR", "name": "Pulsing Guts analysis", "author": "SonOfLilit", "description": "I tried to work out how this amazing effect works, and once I got it, explain to other people too. Just watch the components gradually fade in.\n\nSee top comment for play-by-play.", "tags": ["2d", "organic", "explanation", "analysis", "pulsingguts"], "likes": 39, "viewed": 2338, "published": 3, "date": "1675902635", "time_retrieved": "2024-07-30T18:11:19.692284", "image_code": "/*\nExplaining https://www.shadertoy.com/view/clXXDl to myself\n\nbased on the follow tweet:\nhttps://twitter.com/zozuar/status/1621229990267310081\n\nLeft to right: layer index (1, 5, 9, 13, 17, all 20)\nTop and bottom - single layers. Middle - sum of layers\n\nt=0: make nice squares from layers of cos(x) + cos(y)\nt=2.5: soften them by introducing some diagonal movement between layers\nt=5: introduce 57deg rotation between layers\nt=10: introduce 20% zoom out between layers\nt=15: fade in pulsing\nt=20: fade in radial pulse delay\nt=25: fade in edge darkening\nt=30: the full effect!\n\nBetter watched in full screen.\n\nAur\n*/\n\nmat2 rotation(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (center is (0,0), height is 1)\n    vec2 uv = (fragCoord -\n 0.5 * iResolution.xy)/iResolution.y;\n\n    float t = iTime;\n    float fade_squares = clamp(0.4 * t, 0., 1.);\n    float fade_layer_distance = clamp(0.4 * (t - 2.5), 0., 1.);\n    float fade_layer_rotation = clamp(pow(0.2 * (t - 5.), 1.5), 0., 1.);\n    float fade_layer_zoomout = clamp(0.2 * (t - 10.), 0., 1.);\n    float fade_pulse = clamp(0.2 * (t - 15.), 0., 1.);\n    float t2 = t - 15.;\n    float fade_radial_delay = clamp(0.2 * (t - 20.), 0., 1.);\n    float fade_edge_darkening = clamp(0.2 * (t - 25.), 0., 1.);\n    \n    vec2 p = uv;\n    float d = p.x * p.x + p.y * p.y; // square of distance from center\n    float S = 12.; // zoom factor\n    mat2 m = rotation(fade_layer_rotation * 1.0); // rotates by ~57deg\n    vec2 q = vec2(0.);\n    vec2 n = vec2(0.);\n    float a = 0.;\n    float sum = 0.;\n    float layers = 4. * floor(20. / 4. * (uv.x + 1.));\n    for(float j = 0.; j < layers; j++) {\n        p *= m;\n        n *= m;\n        q = p * S\n           + fade_squares * n\n           + fade_layer_distance * j         \n           + fade_pulse * (4.*t2 + .8 * sin(4.*t2 - fade_radial_delay * 6. * d));\n        a = (cos(q.x) + cos(q.y)) * 0.2 / S;\n        sum += a;\n        n -= sin(q);\n        S *= (1.0 + 0.2 * fade_layer_zoomout);\n    }\n    float y = abs(uv.y) < 0.3 ? 0. : 1.;\n    a = y * a + (1. - y) * sum;\n    // Output to screen\n    vec3 col = vec3(4, 2, 1) * (a + 0.2) + a + a - fade_edge_darkening * d;\n    //a = fade_edge_darkening;\n    //col = vec3(a, a, a);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 641, 641, 693], [694, 694, 751, 818, 2347]], "test": "untested"}
{"id": "DtBXDz", "name": "normalize vector", "author": "jonasfrey", "description": "today i learned , to normalize a vector means, to multiply it so that its length becomes 1", "tags": ["normalize"], "likes": 2, "viewed": 188, "published": 3, "date": "1675897012", "time_retrieved": "2024-07-30T18:11:20.440284", "image_code": "float f_n_dist_line(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy -iResolution.xy*.5)/iResolution.y;\n    vec2 o_mc = (iMouse.xy -iResolution.xy*.5)/iResolution.y;\n    float n_tau =6.2831;\n    \n    if(iMouse.z == 0.){\n        o_mc = vec2(\n            sin(iTime *2.)*.25,\n            cos(iTime *1.)*.4\n        );\n    }\n    float n_zoom = 20.;\n    o_fc *= n_zoom;\n    o_mc *= n_zoom;\n    \n    vec2 o = abs(fract(o_fc)-.5)*2.;\n    float n_grid = max(o.x, o.y);\n    float n_th = 0.02;\n    float n_aa = 1./iResolution.x; \n    n_grid = smoothstep(1.-n_th-n_aa, 1.,  n_grid); \n\n    float n_circ = cos(length(((o_fc)/n_zoom))*n_tau*n_zoom)*.5+.5;\n    //n_circ = pow(n_circ,2000.);\n    n_circ = smoothstep(1.-n_th-n_aa, 1.,  n_circ); \n    \n    vec4 o_col = vec4(0.);\n    o_col += n_grid;\n    o_col += n_circ;\n\n    \n    float n_dist_line_to_mc = 1.-f_n_dist_line(o_fc, vec2(0.), o_mc);\n    \n    vec2 o_mc_normalized = normalize(o_mc);\n    \n    float n_dist_line_to_mc_normalized = 1.-f_n_dist_line(o_fc, vec2(0.), o_mc_normalized);\n    \n    o_col += n_dist_line_to_mc*vec4(1., 0., 0., 1.);\n    o_col += n_dist_line_to_mc_normalized*vec4(0., 1., 0., 1.);\n    \n    float n_dist_mc = length(o_fc - o_mc);\n    float n_dist_mc_normalized = length(o_fc - o_mc_normalized);\n    n_th = 0.5;\n    \n    n_dist_mc = smoothstep(n_th+n_aa, n_th, n_dist_mc);\n    n_dist_mc_normalized = smoothstep(n_th+n_aa, n_th, n_dist_mc_normalized);\n    o_col += n_dist_mc*vec4(0., 0., 1., 1.);\n    o_col += n_dist_mc_normalized*vec4(0., 1., 1., 1.);\n    \n    //o_col += n_dist_line_to_mc_normalized;\n    //o_col = vec4(n_dist_line_to_mc);\n    \n    \n    \n    fragColor = o_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 174], [176, 176, 233, 233, 1838]], "test": "untested"}
{"id": "DlSXWz", "name": "CatThink diffraction kernel", "author": "Zi7ar21", "description": "Shamelessly stolen from https://shadertoy.com/view/DlSXzm\n\nOriginal description: 8 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera", "cat", "funny", "svd", "catthink"], "likes": 4, "viewed": 262, "published": 3, "date": "1675888468", "time_retrieved": "2024-07-30T18:11:21.705900", "image_code": "// Fork of \"JWST diffraction kernel smaller\" by michael0884. https://shadertoy.com/view/DlSXzm\n// 2023-02-08 20:23:40\n\n// Fork of \"JWST diffraction kernel\" by michael0884. https://shadertoy.com/view/clBSzm\n// 2023-02-07 22:12:08\n\n#define exposure 1.0\n#define sqrexposure 0.5\n#define gamma 1.3\n#define bloom 200.0\n\nvec3 expose(vec3 c) {\n    return 1.0 - exp(-exposure * (1.0 + sqrexposure * c) * c);\n}\n\nvec3 saturate(vec3 c) {\n    return pow(expose(c), vec3(1.0/gamma));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 acc = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5 * fragCoord / iResolution.xy);\n    \n    vec3 col = (1.0*acc.xyz/acc.w) + (bloom * convol.xyz);\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 2.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nvec4 project(mat3 cam_mat, vec3 cam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(cam_pos, p);\n    vec3 dir = (p - cam_pos)/td;\n    vec3 screen = dir*cam_mat;\n    return vec4(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, screen.z, td);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 8 columns of the U matrix: \nfloat U[1016] = float[](-4.2491E-02, -4.5468E-02, -4.7422E-02, -4.9283E-02, -5.1429E-02, -5.3374E-02, -5.6075E-02, -5.8603E-02, -6.1223E-02, -6.4278E-02, -6.6885E-02, -6.7691E-02, -6.9739E-02, -7.0434E-02, -7.2187E-02, -7.5000E-02, -7.7263E-02, -7.8294E-02, -7.9480E-02, -8.0702E-02, -8.1855E-02, -8.3811E-02, -8.6175E-02, -8.6893E-02, -8.6646E-02, -8.3490E-02, -7.9265E-02, -7.6857E-02, -7.4902E-02, -7.4748E-02, -7.2759E-02, -6.7564E-02, -6.3035E-02, -6.0704E-02, -5.9201E-02, -5.7877E-02, -5.7078E-02, -5.7172E-02, -5.6413E-02, -5.6159E-02, -5.7885E-02, -6.0500E-02, -6.4115E-02, -6.7074E-02, -7.2689E-02, -7.9942E-02, -8.8715E-02, -9.3352E-02, -9.7819E-02, -1.0289E-01, -1.0490E-01, -1.0719E-01, -1.0960E-01, -1.1173E-01, -1.1309E-01, -1.1456E-01, -1.1362E-01, -1.1265E-01, -1.1234E-01, -1.1217E-01, -1.1085E-01, -1.1074E-01, -1.0984E-01, -1.0853E-01, -1.0757E-01, -1.0666E-01, -1.0492E-01, -1.0289E-01, -1.0189E-01, -1.0111E-01, -1.0050E-01, -9.7895E-02, -9.6467E-02, -9.6851E-02, -9.8377E-02, -9.8181E-02, -9.7227E-02, -9.5512E-02, -9.3827E-02, -9.2759E-02, -9.3722E-02, -9.1554E-02, -8.9152E-02, -8.6195E-02, -8.4127E-02, -8.4358E-02, -8.4621E-02, -8.4020E-02, -8.3691E-02, -8.4114E-02, -8.4894E-02, -8.5224E-02, -8.5777E-02, -8.6720E-02, -8.8257E-02, -8.9713E-02, -9.1100E-02, -9.2593E-02, -9.4009E-02, -9.5793E-02, -9.7352E-02, -9.8097E-02, -9.8373E-02, -9.8282E-02, -9.8006E-02, -9.7696E-02, -9.7581E-02, -9.7574E-02, -9.8101E-02, -9.8657E-02, -9.9032E-02, -9.9339E-02, -9.9719E-02, -9.9858E-02, -9.9803E-02, -9.9816E-02, -9.9596E-02, -9.9400E-02, -9.9292E-02, -9.8978E-02, -9.8910E-02, -9.8853E-02, -9.8825E-02, -9.8896E-02, -9.8879E-02, -9.8494E-02, -9.7247E-02, 2.6349E-02, 4.3425E-02, 5.9081E-02, 7.4628E-02, 8.8003E-02, 1.0114E-01, 1.1035E-01, 1.2033E-01, 1.3126E-01, 1.3977E-01, 1.4603E-01, 1.5153E-01, 1.4916E-01, 1.5007E-01, 1.4963E-01, 1.4194E-01, 1.3642E-01, 1.3360E-01, 1.2983E-01, 1.2313E-01, 1.1965E-01, 1.0972E-01, 9.8730E-02, 9.1697E-02, 8.8371E-02, 9.3862E-02, 9.7531E-02, 9.8162E-02, 1.0360E-01, 9.9283E-02, 1.0610E-01, 1.2444E-01, 1.3897E-01, 1.4316E-01, 1.4620E-01, 1.4631E-01, 1.4886E-01, 1.4711E-01, 1.5044E-01, 1.5354E-01, 1.5233E-01, 1.4398E-01, 1.3590E-01, 1.2605E-01, 1.0928E-01, 8.7372E-02, 5.8953E-02, 5.0246E-02, 3.8928E-02, 2.8012E-02, 3.0031E-02, 1.9568E-02, 9.6937E-03, 3.1386E-03, -3.3766E-03, -1.5832E-02, -1.0054E-02, -6.3103E-03, -1.0513E-02, -1.4952E-02, -1.3206E-02, -1.3619E-02, -1.4627E-02, -1.2344E-02, -1.2748E-02, -1.4526E-02, -2.1873E-02, -2.8282E-02, -3.6430E-02, -4.5241E-02, -5.5615E-02, -7.0678E-02, -8.4733E-02, -7.6156E-02, -7.1208E-02, -6.4824E-02, -7.0275E-02, -8.2384E-02, -8.6274E-02, -8.2113E-02, -8.3646E-02, -8.3543E-02, -8.8512E-02, -9.5632E-02, -9.6399E-02, -9.7801E-02, -1.0138E-01, -1.0349E-01, -1.0509E-01, -1.0553E-01, -1.0538E-01, -1.0522E-01, -1.0239E-01, -9.6942E-02, -8.9490E-02, -8.0481E-02, -7.1719E-02, -6.2557E-02, -5.5103E-02, -4.8869E-02, -4.3620E-02, -4.0636E-02, -3.9502E-02, -4.0275E-02, -4.1497E-02, -4.2330E-02, -4.2228E-02, -4.1212E-02, -4.0978E-02, -4.3385E-02, -4.6027E-02, -5.0140E-02, -5.4764E-02, -5.9573E-02, -6.2359E-02, -6.4479E-02, -6.6063E-02, -6.5204E-02, -6.2971E-02, -6.0934E-02, -5.8451E-02, -5.6759E-02, -5.3769E-02, -5.3670E-02, -5.2141E-02, -4.8423E-02, -4.5824E-02, -4.1127E-02, -3.6086E-02, -3.5897E-02, -3.6304E-02, -3.6651E-02, -3.7232E-02, -3.5848E-02, -3.8733E-02, -3.3499E-02, -2.8520E-02, -3.1750E-02, -2.8685E-02, -3.1819E-02, -3.1644E-02, -3.7661E-02, -4.5139E-02, -5.0774E-02, -5.5694E-02, -5.4445E-02, -5.3887E-02, -5.2854E-02, -5.2039E-02, -5.5522E-02, -4.1953E-02, -3.6832E-02, -2.3701E-02, 1.3705E-02, 6.4980E-02, 7.0340E-02, 6.3731E-02, 6.8505E-02, 1.0313E-01, 1.3410E-01, 1.4071E-01, 1.4069E-01, 1.4513E-01, 1.4951E-01, 1.3552E-01, 1.2838E-01, 1.2872E-01, 1.2157E-01, 1.1237E-01, 8.3232E-02, 5.8310E-02, 2.3202E-02, -2.0685E-02, -5.2857E-02, -7.8504E-02, -8.4932E-02, -7.2756E-02, -7.2937E-02, -6.2727E-02, -6.6899E-02, -5.6899E-02, -3.8184E-02, -1.6339E-02, -5.2754E-02, -5.4752E-02, -3.3234E-02, 5.8761E-03, 6.7213E-03, 7.4328E-03, 2.8581E-02, 2.4487E-02, 2.6487E-02, 3.2593E-02, 5.1733E-02, 5.3198E-02, 6.2030E-02, 7.2299E-02, 8.1437E-02, 9.0773E-02, 1.1888E-01, 1.3806E-01, 1.4580E-01, 1.5075E-01, 1.4226E-01, 1.2726E-01, 1.2562E-01, 1.4380E-01, 1.6342E-01, 1.7999E-01, 1.7224E-01, 1.6186E-01, 1.5083E-01, 1.5943E-01, 1.5678E-01, 1.3981E-01, 1.1495E-01, 8.9443E-02, 6.4055E-02, 3.9769E-02, 2.0216E-02, 9.8781E-03, 2.2423E-03, -1.1430E-02, -2.5182E-02, -3.8704E-02, -5.3874E-02, -6.9025E-02, -8.2159E-02, -9.4753E-02, -1.0536E-01, -1.1641E-01, -1.2495E-01, -1.3143E-01, -1.3777E-01, -1.4027E-01, -1.4066E-01, -1.3753E-01, -1.3446E-01, -1.2390E-01, -1.0865E-01, -9.7945E-02, -8.7974E-02, -7.5613E-02, -6.4531E-02, -5.8655E-02, -6.0271E-02, -6.7571E-02, -6.6695E-02, -6.5167E-02, -6.8606E-02, -5.0512E-02, -4.4752E-02, -6.2190E-02, -7.0482E-02, 3.3595E-02, 2.6573E-02, 1.5397E-02, 2.0656E-02, 1.5998E-02, 2.0673E-02, 5.5164E-03, -3.3796E-03, -1.3936E-02, -1.0597E-02, -8.8379E-03, -6.9423E-03, 1.2550E-02, 3.0145E-02, 2.8476E-02, 1.3631E-02, -1.4890E-02, -4.7102E-02, -4.5672E-02, -4.5108E-02, -3.5459E-02, -3.7229E-02, -4.9688E-02, -5.3906E-02, -7.0103E-02, -8.3562E-02, -1.1007E-01, -1.1046E-01, -9.8333E-02, -9.7753E-02, -6.0756E-02, 1.6644E-03, 8.7957E-02, 1.3008E-01, 1.4382E-01, 1.7567E-01, 1.5042E-01, 1.3650E-01, 1.4088E-01, 1.3355E-01, 1.3110E-01, 1.3108E-01, 1.2033E-01, 1.0406E-01, 1.0058E-01, 5.5950E-02, 1.6297E-02, -5.0722E-02, -9.1740E-02, -1.5567E-01, -2.1172E-01, -2.0228E-01, -1.8596E-01, -1.6737E-01, -1.5392E-01, -1.2881E-01, -1.2992E-01, -1.3365E-01, -1.2639E-01, -1.1838E-01, -1.2128E-01, -1.0917E-01, -1.0737E-01, -9.9927E-02, -1.0094E-01, -8.1716E-02, -6.8994E-02, -6.1719E-02, -6.2183E-02, -4.2092E-02, -3.0772E-02, -3.5257E-02, -4.2129E-02, -8.5399E-02, -8.6506E-02, -6.4756E-02, -4.2959E-02, -4.3015E-02, -3.7750E-02, -3.0967E-02, -3.7713E-02, -4.0160E-02, -3.2562E-02, -2.4482E-02, 5.2493E-03, 2.7544E-03, -4.7009E-04, 2.0604E-02, 5.4331E-02, 7.9676E-02, 9.3681E-02, 1.0230E-01, 1.0929E-01, 1.0908E-01, 9.8033E-02, 8.7238E-02, 8.3179E-02, 8.9189E-02, 9.3005E-02, 9.1106E-02, 8.4476E-02, 8.1387E-02, 7.6555E-02, 7.0991E-02, 6.2659E-02, 5.4054E-02, 4.5659E-02, 4.0106E-02, 3.8960E-02, 4.1717E-02, 5.0024E-02, 6.3723E-02, 7.9503E-02, 9.1709E-02, 9.8175E-02, 1.0438E-01, 1.0526E-01, 1.0464E-01, 1.0377E-01, 1.0360E-01, 1.0399E-01, 1.0381E-01, 9.9315E-02, 9.3744E-02, 9.2907E-02, 9.2775E-02, 8.6910E-02, 1.7872E-01, 1.6131E-01, 1.4784E-01, 1.3506E-01, 1.1336E-01, 1.0287E-01, 7.9680E-02, 6.4413E-02, 3.2535E-02, 1.7253E-02, 2.4220E-02, 9.9160E-03, 9.1936E-03, 6.0185E-04, 2.3575E-03, -1.3967E-02, -3.3120E-02, -5.4841E-02, -6.3014E-02, -7.2966E-02, -6.7991E-02, -6.9739E-02, -6.6421E-02, -8.1988E-02, -8.8540E-02, -1.4960E-01, -2.4732E-01, -2.8309E-01, -2.7414E-01, -2.6442E-01, -2.2237E-01, -1.6820E-01, -1.0318E-01, -6.5947E-02, -3.0025E-02, -1.5140E-02, 2.1590E-02, 9.5945E-03, 2.1707E-02, 4.3638E-02, 5.5710E-02, 7.6403E-02, 1.2004E-01, 1.5811E-01, 2.0282E-01, 2.2843E-01, 2.3639E-01, 2.1106E-01, 1.6749E-01, 1.2190E-01, 9.7647E-02, 6.6071E-02, 6.0165E-02, 5.2608E-02, 5.0058E-02, 2.6061E-02, 2.3372E-02, 2.8035E-02, 2.1727E-02, 3.1492E-02, 3.4607E-02, 3.8085E-02, 3.1588E-02, 3.4438E-02, 3.4553E-02, 2.5274E-02, 1.7106E-02, 6.6460E-03, 1.0944E-02, 9.0160E-03, 1.0168E-02, 2.6690E-02, 5.1067E-02, 6.1069E-02, 2.2162E-02, 2.1056E-02, 3.6434E-02, 2.5227E-02, 2.0859E-02, 8.1860E-03, -7.5531E-03, 2.2782E-03, 1.3643E-02, 2.8270E-02, 2.4433E-02, 2.3286E-02, 1.4885E-02, 1.4683E-02, 1.5321E-02, -3.3704E-03, -2.7417E-02, -3.9507E-02, -4.4338E-02, -4.7127E-02, -5.3899E-02, -5.6095E-02, -6.1133E-02, -7.1416E-02, -8.4805E-02, -9.2659E-02, -9.4583E-02, -8.9015E-02, -8.3642E-02, -7.8177E-02, -7.0626E-02, -6.4089E-02, -5.3404E-02, -4.2357E-02, -3.6242E-02, -3.2839E-02, -2.7683E-02, -2.2977E-02, -2.2019E-02, -1.9192E-02, -9.4065E-03, -1.4701E-03, 4.3168E-03, 8.6627E-03, 8.6637E-03, 7.8359E-03, 9.2444E-03, 8.1310E-03, 7.3327E-03, 1.5146E-02, 1.2688E-02, 4.2541E-03, -2.4448E-03, 2.4788E-01, 2.6992E-01, 2.7592E-01, 2.8362E-01, 2.6898E-01, 2.4038E-01, 2.0051E-01, 1.6990E-01, 1.4739E-01, 1.3150E-01, 1.2797E-01, 1.1462E-01, 9.7509E-02, 8.3836E-02, 7.5472E-02, 5.8973E-02, 3.9537E-02, 2.4819E-02, 8.0381E-03, 5.9907E-05, 1.6631E-02, 1.3854E-02, 1.2806E-02, 1.0898E-03, 6.7113E-03, 1.3455E-02, 1.2832E-03, 1.1929E-02, -1.6934E-03, -2.5050E-04, -1.1371E-02, -1.2964E-02, -2.4054E-02, -2.2541E-02, -2.2897E-02, -2.7291E-02, -6.0239E-02, -7.6961E-02, -9.0935E-02, -1.4960E-01, -1.5376E-01, -1.5899E-01, -1.3928E-01, -1.5990E-01, -1.5054E-01, -1.2249E-01, -1.2203E-01, -1.3078E-01, -1.5315E-01, -1.3410E-01, -1.2480E-01, -1.4299E-01, -1.2343E-01, -8.4372E-02, -9.0411E-02, -8.5402E-02, -5.7741E-02, -3.4169E-02, -3.8898E-02, -3.7473E-02, -4.3327E-02, -3.4314E-02, -2.4932E-02, -2.1244E-02, -2.2717E-02, 1.6098E-03, -5.3373E-04, 1.9761E-02, 2.2892E-02, 3.9973E-02, 5.2182E-02, 7.6627E-02, 1.1427E-01, 9.0965E-02, 7.7530E-02, 8.6847E-02, 7.6867E-02, 6.6663E-02, 5.0833E-02, 5.2314E-02, 5.2349E-02, 3.9194E-02, 2.1419E-02, -4.2013E-03, 1.3618E-02, 2.2691E-02, 2.5515E-02, 1.4107E-02, 9.6749E-03, -2.3843E-03, 2.3689E-04, 1.7173E-02, 3.1864E-02, 2.6256E-02, 2.7847E-02, 2.7019E-02, 1.8110E-02, -4.5888E-03, -2.4125E-02, -2.4967E-02, -1.4374E-02, -1.0569E-03, 6.5190E-03, 4.0289E-03, 2.8105E-03, 3.2398E-03, 5.5700E-03, 3.1706E-03, 2.4287E-03, 1.6461E-03, -1.9989E-03, -4.1095E-03, -7.5505E-03, -8.3730E-03, -1.1166E-02, -1.6232E-02, -2.0063E-02, -2.0743E-02, -1.8582E-02, -1.7125E-02, -1.7401E-02, -1.7549E-02, -1.5950E-02, -2.5165E-02, -2.6131E-02, -2.3956E-02, -2.1353E-02, 8.5104E-02, 6.7568E-02, 2.5684E-02, 1.4038E-02, 1.7334E-02, 2.1337E-02, 3.1487E-02, 3.6184E-02, 4.1799E-02, 4.7087E-02, 2.5597E-02, 1.4525E-02, -3.4697E-03, -1.7907E-02, -4.3141E-02, -4.6190E-02, -3.7592E-02, -5.2472E-02, -8.6513E-02, -1.4517E-01, -1.4070E-01, -1.3627E-01, -1.3825E-01, -1.3622E-01, -1.5208E-01, -1.0464E-01, -2.6580E-02, -7.4584E-03, 2.3635E-02, 6.2161E-02, 7.5332E-02, 8.1387E-03, -1.4134E-02, -1.9753E-02, -6.8396E-03, 3.8127E-03, 4.0510E-02, 4.4396E-02, 1.8095E-03, -7.8453E-04, 3.1790E-02, 7.5441E-02, 1.1566E-01, 9.6532E-02, 8.6490E-02, 4.2071E-02, -5.3753E-03, -4.2827E-02, -6.6039E-02, -5.8387E-02, -8.1456E-02, -1.2424E-01, -3.8532E-02, 3.5237E-02, 7.8191E-02, 2.8349E-02, 9.9199E-02, 1.3491E-01, 1.0699E-01, 9.4344E-02, 1.1191E-01, 1.1769E-01, 9.5657E-02, 9.1459E-02, 1.2173E-01, 1.1910E-01, 7.1304E-02, 3.6958E-02, 1.7681E-02, -5.6660E-03, -3.8472E-02, -7.2935E-02, -1.2952E-01, -7.4668E-02, -6.5490E-02, -6.4160E-02, -7.5010E-02, -6.6591E-02, -5.8061E-02, -2.5572E-02, 2.3457E-02, 1.6004E-02, -1.1629E-02, -1.0354E-02, -2.3101E-02, -5.8318E-03, 2.4226E-03, 1.4488E-02, 4.0321E-02, 4.4821E-02, 4.5397E-02, 4.4631E-02, 4.5292E-02, 4.3400E-02, 4.6590E-02, 5.9489E-02, 8.3147E-02, 1.1092E-01, 1.2666E-01, 1.2183E-01, 1.1462E-01, 1.1421E-01, 1.1672E-01, 1.1938E-01, 1.2338E-01, 1.2416E-01, 1.2772E-01, 1.2457E-01, 1.1772E-01, 9.9348E-02, 7.9961E-02, 4.7621E-02, -2.6586E-03, -4.5810E-02, -7.2016E-02, -1.0226E-01, -1.2794E-01, -1.4348E-01, -1.5711E-01, -1.5947E-01, -1.6418E-01, -1.7374E-01, -1.7417E-01, -1.8374E-01, -1.9941E-01, -1.9759E-01, -1.8531E-01, -5.8092E-02, -6.1691E-02, -5.0704E-02, -6.4452E-02, -9.5844E-02, -1.0872E-01, -1.2187E-01, -1.3167E-01, -1.1003E-01, -6.8929E-02, -1.9162E-02, 3.2682E-02, 1.0308E-01, 1.6098E-01, 1.9124E-01, 2.0035E-01, 1.6992E-01, 1.3279E-01, 1.4305E-01, 1.4554E-01, 1.4480E-01, 8.1202E-02, 5.5000E-02, 3.9342E-03, -7.8086E-02, -5.8691E-02, -1.0670E-01, -1.5167E-01, -1.8790E-01, -2.4511E-01, -2.8558E-01, -2.0352E-01, -7.9464E-02, -1.0107E-02, 6.3177E-02, 1.4796E-01, 1.4331E-01, 1.4035E-01, 8.9840E-02, 5.2046E-02, 2.1436E-02, -2.2735E-02, -4.7379E-02, -7.7192E-02, -1.3424E-01, -1.8913E-01, -1.7931E-01, -1.5077E-01, -9.0544E-02, -4.5661E-02, -5.0060E-02, -6.8021E-02, -1.0967E-04, 3.8309E-02, 9.2581E-02, 2.1229E-02, 6.7666E-02, 8.5789E-02, 3.7083E-02, 8.4465E-03, 4.3838E-03, 1.5536E-02, 4.2162E-03, 3.0001E-02, 5.9735E-03, 2.6366E-02, 3.0350E-02, 5.9113E-02, 7.8086E-02, 8.7923E-02, 1.3296E-01, 1.0674E-01, 5.0414E-02, 6.9585E-02, 2.8368E-02, -6.6046E-03, 2.1861E-02, 9.1075E-03, -2.2754E-02, -1.5811E-02, -1.2232E-02, 3.5348E-02, 4.0023E-02, 3.3950E-02, 1.1339E-02, 1.3410E-02, 5.1790E-03, -1.1536E-02, -3.4503E-02, -3.2020E-02, -3.9085E-02, -6.3915E-02, -7.0004E-02, -8.2224E-02, -6.2865E-02, -4.4074E-02, -1.0653E-02, 2.0233E-02, 2.6680E-02, 5.3318E-03, -9.3843E-03, -6.3713E-03, 7.6304E-03, 2.7847E-02, 4.8079E-02, 7.1583E-02, 8.7916E-02, 9.0540E-02, 9.0213E-02, 8.0460E-02, 6.7736E-02, 3.9942E-02, -4.1840E-03, -4.0432E-02, -6.3992E-02, -8.6513E-02, -9.2154E-02, -8.7104E-02, -7.9565E-02, -5.6641E-02, -4.2611E-02, -3.4434E-02, -1.9606E-02, -9.4571E-03, -1.2463E-02, -5.9629E-03, 1.2468E-02); \n//The first 8 rows of the V matrix: \nfloat V[1016] = float[](-1.2549E-04, -1.5666E-04, -1.8989E-04, -2.2463E-04, -2.5064E-04, -2.6632E-04, -2.8839E-04, -3.2241E-04, -3.6463E-04, -4.0969E-04, -4.5423E-04, -4.9841E-04, -5.4126E-04, -5.7030E-04, -5.8662E-04, -6.0188E-04, -6.1601E-04, -6.3077E-04, -6.4092E-04, -6.4688E-04, -6.5422E-04, -6.5786E-04, -6.6397E-04, -6.7279E-04, -6.9850E-04, -7.2309E-04, -7.3535E-04, -7.4311E-04, -7.4752E-04, -7.5184E-04, -7.5604E-04, -7.6151E-04, -7.7467E-04, -7.7950E-04, -7.8335E-04, -7.8850E-04, -7.9428E-04, -7.8972E-04, -7.7685E-04, -7.7035E-04, -7.7073E-04, -7.7241E-04, -7.7918E-04, -7.8896E-04, -8.0170E-04, -8.0648E-04, -8.0597E-04, -8.0510E-04, -8.0998E-04, -8.1100E-04, -8.2967E-04, -8.5076E-04, -8.5907E-04, -8.6823E-04, -8.7374E-04, -8.8137E-04, -8.8540E-04, -8.9210E-04, -8.8867E-04, -8.8947E-04, -8.9059E-04, -8.9918E-04, -9.0917E-04, -9.1179E-04, -9.1112E-04, -9.1333E-04, -9.1486E-04, -9.1109E-04, -9.1084E-04, -9.1278E-04, -9.0695E-04, -9.0104E-04, -8.9206E-04, -8.8061E-04, -8.6629E-04, -8.5349E-04, -8.5050E-04, -8.5238E-04, -8.4676E-04, -8.3938E-04, -8.3530E-04, -8.2562E-04, -8.1690E-04, -8.0192E-04, -7.8314E-04, -7.5086E-04, -7.5072E-04, -7.3206E-04, -7.3119E-04, -7.3808E-04, -7.4091E-04, -7.3157E-04, -7.1574E-04, -6.9622E-04, -6.9128E-04, -6.8473E-04, -6.6998E-04, -6.6453E-04, -6.7203E-04, -6.7894E-04, -6.7495E-04, -6.7625E-04, -6.8365E-04, -6.8362E-04, -6.9063E-04, -6.9661E-04, -7.0143E-04, -7.0877E-04, -6.9973E-04, -6.9775E-04, -7.0055E-04, -6.9753E-04, -7.0148E-04, -6.9881E-04, -6.9645E-04, -6.9322E-04, -6.8795E-04, -6.8071E-04, -6.8062E-04, -6.7562E-04, -6.7615E-04, -6.7422E-04, -6.7107E-04, -6.6219E-04, -6.5961E-04, -6.5797E-04, -6.5103E-04, 1.0232E-05, 1.6698E-05, 8.5319E-06, -1.2359E-05, -3.2217E-05, -4.9852E-05, -7.0070E-05, -9.4774E-05, -1.2001E-04, -1.4539E-04, -1.7262E-04, -1.9580E-04, -2.1025E-04, -2.1522E-04, -2.1406E-04, -2.0951E-04, -2.0096E-04, -1.8028E-04, -1.6050E-04, -1.4380E-04, -1.2603E-04, -1.1750E-04, -1.0968E-04, -1.0192E-04, -7.3146E-05, -4.5408E-05, -3.5866E-05, -3.1623E-05, -3.5983E-05, -4.4150E-05, -6.0908E-05, -6.9559E-05, -5.7362E-05, -5.3933E-05, -5.4771E-05, -5.3507E-05, -5.2086E-05, -6.8745E-05, -1.0332E-04, -1.2087E-04, -1.2712E-04, -1.2898E-04, -1.2086E-04, -1.0300E-04, -8.1348E-05, -7.1677E-05, -6.0762E-05, -4.5204E-05, -1.4076E-05, 4.0821E-06, 5.5788E-05, 1.0439E-04, 1.2090E-04, 1.4362E-04, 1.6600E-04, 1.8882E-04, 1.9714E-04, 2.1146E-04, 2.1567E-04, 2.2361E-04, 2.2548E-04, 2.4061E-04, 2.5149E-04, 2.5827E-04, 2.5690E-04, 2.5571E-04, 2.5014E-04, 2.4383E-04, 2.3817E-04, 2.3964E-04, 2.3744E-04, 2.3634E-04, 2.3484E-04, 2.3286E-04, 2.3593E-04, 2.3340E-04, 2.2858E-04, 2.1769E-04, 2.0399E-04, 1.8904E-04, 1.7273E-04, 1.4039E-04, 1.1904E-04, 8.8848E-05, 5.4032E-05, -1.1921E-05, -1.1182E-05, -4.1779E-05, -4.2105E-05, -2.5106E-05, -1.7941E-05, -4.3730E-05, -7.7928E-05, -1.0747E-04, -1.0940E-04, -1.1151E-04, -1.3267E-04, -1.4716E-04, -1.4082E-04, -1.2825E-04, -1.4347E-04, -1.4659E-04, -1.4182E-04, -1.4555E-04, -1.3663E-04, -1.2215E-04, -1.1046E-04, -9.9343E-05, -1.1784E-04, -1.2199E-04, -1.1388E-04, -1.1357E-04, -1.0108E-04, -1.0828E-04, -1.0816E-04, -1.1092E-04, -1.1998E-04, -1.2908E-04, -1.2675E-04, -1.3838E-04, -1.4326E-04, -1.4439E-04, -1.4654E-04, -1.5819E-04, -1.6027E-04, -1.5840E-04, -1.5786E-04, 2.3770E-05, 4.3984E-05, 9.4181E-05, 1.6225E-04, 2.1673E-04, 2.4594E-04, 2.5413E-04, 2.4504E-04, 2.2316E-04, 1.9450E-04, 1.5773E-04, 1.1392E-04, 6.8139E-05, 3.8051E-05, 2.1001E-05, 1.1640E-05, 8.9453E-06, 1.1420E-05, 1.8008E-05, 2.7351E-05, 3.2798E-05, 2.9949E-05, 2.7783E-05, 2.2485E-05, 1.1974E-05, -6.2580E-07, -5.1754E-06, -7.5297E-06, -1.4894E-05, -3.1200E-05, -5.0963E-05, -5.4823E-05, -4.1175E-05, -3.5398E-05, -3.7901E-05, -4.2093E-05, -5.0065E-05, -6.8000E-05, -9.6656E-05, -1.0906E-04, -1.1509E-04, -1.1703E-04, -1.2199E-04, -1.2613E-04, -1.2866E-04, -1.2703E-04, -1.0997E-04, -9.8875E-05, -9.5545E-05, -7.7496E-05, -6.5153E-05, -4.8574E-05, -4.7675E-05, -5.5401E-05, -6.1704E-05, -7.1502E-05, -6.8279E-05, -6.2824E-05, -5.3099E-05, -4.4663E-05, -3.0458E-05, -2.6065E-05, -1.7763E-05, -9.8773E-06, -1.1214E-06, 5.9738E-06, 1.5327E-05, 2.0796E-05, 2.6373E-05, 2.8808E-05, 3.4840E-05, 4.3155E-05, 5.3607E-05, 6.1268E-05, 6.8060E-05, 7.4851E-05, 7.7334E-05, 7.4646E-05, 7.5068E-05, 7.4363E-05, 7.2537E-05, 7.1620E-05, 6.4683E-05, 5.9990E-05, 5.4993E-05, 4.8231E-05, 5.0505E-05, 6.6367E-05, 6.3074E-05, 5.2355E-05, 4.2357E-05, 2.3845E-05, -4.1428E-06, -1.3531E-05, -2.2148E-05, -2.9171E-05, -2.9523E-05, -3.0069E-05, -2.5930E-05, -2.7825E-05, -4.0317E-05, -4.4400E-05, -5.0764E-05, -4.4715E-05, -3.2759E-05, -9.5195E-06, 1.2232E-06, -2.8518E-06, -6.5821E-06, -1.1782E-05, -4.5197E-06, 9.2826E-06, 1.6017E-05, 1.9707E-05, 2.1341E-05, 2.2797E-05, 2.3127E-05, 2.4812E-05, 2.3036E-05, 2.4244E-05, 2.1882E-05, 2.8063E-05, 3.0053E-05, 3.1958E-05, 3.4146E-05, 3.5396E-05, 3.9517E-05, -8.8762E-05, -9.5501E-05, -9.1839E-05, -8.1511E-05, -6.5024E-05, -5.1718E-05, -3.3034E-05, -7.9820E-06, 1.9406E-05, 4.2266E-05, 6.2581E-05, 7.6586E-05, 8.5816E-05, 8.9916E-05, 8.8503E-05, 7.9019E-05, 7.1457E-05, 7.0443E-05, 7.4791E-05, 8.3669E-05, 9.1120E-05, 8.7990E-05, 7.9293E-05, 7.3696E-05, 7.2200E-05, 6.2566E-05, 5.7802E-05, 5.5776E-05, 5.3934E-05, 4.5912E-05, 3.2030E-05, 3.2444E-05, 4.2762E-05, 3.9005E-05, 3.4871E-05, 3.1570E-05, 2.2943E-05, 4.2512E-06, -2.8162E-05, -4.0461E-05, -4.9227E-05, -5.8465E-05, -6.2648E-05, -6.7444E-05, -7.1310E-05, -7.4876E-05, -6.4195E-05, -5.6906E-05, -4.3334E-05, -1.5235E-05, 1.6762E-05, 5.2844E-05, 6.1292E-05, 6.2161E-05, 6.4520E-05, 6.5293E-05, 6.3953E-05, 6.5709E-05, 6.2165E-05, 6.1098E-05, 5.4758E-05, 5.2170E-05, 4.8856E-05, 4.2931E-05, 3.5873E-05, 3.0107E-05, 2.5677E-05, 1.9840E-05, 1.4978E-05, 1.2989E-05, 8.2278E-06, 1.3145E-06, -8.3695E-06, -1.4549E-05, -2.5447E-05, -3.6678E-05, -4.0586E-05, -4.0178E-05, -4.3514E-05, -4.9051E-05, -5.2376E-05, -5.8612E-05, -7.1626E-05, -8.5131E-05, -9.5076E-05, -1.1123E-04, -1.0225E-04, -9.2598E-05, -8.0459E-05, -7.4221E-05, -7.3774E-05, -8.6996E-05, -1.1132E-04, -1.1733E-04, -1.1297E-04, -1.0628E-04, -1.0445E-04, -1.0007E-04, -9.0216E-05, -8.5239E-05, -8.9784E-05, -8.3890E-05, -7.9444E-05, -7.1675E-05, -5.5052E-05, -2.8536E-05, -1.4790E-05, -1.1572E-05, -1.4259E-05, -1.7812E-05, -5.7514E-06, 1.0002E-05, 2.2466E-05, 3.1103E-05, 4.3237E-05, 5.1001E-05, 5.1865E-05, 5.3334E-05, 5.4662E-05, 5.3816E-05, 4.8814E-05, 5.0761E-05, 5.0944E-05, 5.5946E-05, 5.6543E-05, 5.6857E-05, 6.4689E-05, 8.5734E-05, 1.0862E-04, 1.1591E-04, 1.1375E-04, 1.0515E-04, 8.7385E-05, 6.3872E-05, 3.6171E-05, 4.0707E-06, -2.5173E-05, -4.4123E-05, -5.3442E-05, -5.8764E-05, -5.4173E-05, -4.7700E-05, -3.6270E-05, -2.6646E-05, -2.9622E-05, -3.2859E-05, -3.4514E-05, -3.1981E-05, -3.0089E-05, -2.6409E-05, -1.1153E-05, 2.3842E-05, 3.8202E-05, 4.5241E-05, 5.1605E-05, 6.4706E-05, 8.5537E-05, 1.0456E-04, 1.1964E-04, 1.2078E-04, 1.1110E-04, 1.0538E-04, 1.0518E-04, 1.0339E-04, 1.0304E-04, 1.0104E-04, 9.9462E-05, 8.5648E-05, 6.5409E-05, 5.3811E-05, 3.7476E-05, 2.6580E-05, 1.4635E-05, -3.9863E-06, -3.2775E-05, -4.9687E-05, -6.3396E-05, -5.4520E-05, -3.6959E-05, -3.6495E-05, -3.5740E-05, -3.7292E-05, -2.7539E-05, -3.3710E-05, -2.8283E-05, -4.2548E-05, -3.9884E-05, -4.9619E-05, -3.5852E-05, -1.6031E-05, -3.5995E-06, -4.6868E-06, 3.7399E-06, 4.1691E-06, 4.3085E-06, 6.9752E-06, 2.3510E-05, 2.9165E-05, 3.9003E-05, 4.2150E-05, 3.7207E-05, 2.9831E-05, 1.8748E-05, 2.0924E-05, 2.3495E-05, 9.5509E-06, -3.1536E-06, -1.6328E-05, -3.4366E-05, -5.3333E-05, -7.3979E-05, -8.3343E-05, -9.9590E-05, -8.7285E-05, -7.7728E-05, -5.5494E-05, -3.9386E-05, -2.8077E-05, -2.5614E-05, -3.0618E-05, -4.4803E-05, -4.4717E-05, -4.0526E-05, -5.2012E-05, -5.4878E-05, -5.5698E-05, -5.1744E-05, -4.1269E-05, -3.2845E-05, -1.2783E-05, -6.1475E-06, 5.8815E-06, 1.4436E-05, 1.3536E-05, 1.4426E-05, 1.2505E-05, 5.4358E-06, 4.4803E-06, 6.1271E-06, 4.2531E-06, 4.5979E-06, 1.1140E-05, 1.1995E-05, 9.1280E-06, 3.4149E-06, 6.9174E-06, 2.9093E-06, -5.2503E-06, -1.0704E-05, -1.4025E-05, -1.4358E-05, -2.5745E-05, -3.6966E-05, -3.6826E-05, -7.5100E-05, -9.4373E-05, -9.2692E-05, -7.3293E-05, -5.1530E-05, -3.2779E-05, -2.0927E-05, -1.4825E-05, -1.0509E-05, -6.7722E-06, -4.1418E-06, -6.4259E-06, -1.2288E-05, -2.0800E-05, -2.7092E-05, -3.6974E-05, -4.4485E-05, -4.3333E-05, -3.9630E-05, -4.0077E-05, -3.7829E-05, -3.6223E-05, -3.9940E-05, -2.2595E-05, 2.8992E-05, 5.7653E-05, 4.6807E-05, 2.9700E-05, 1.2782E-05, 3.9828E-06, 2.2913E-06, -5.1765E-06, -1.3176E-05, -2.4845E-05, -2.7903E-05, -2.6992E-05, -1.8869E-05, -1.0177E-05, 1.4850E-06, 5.8937E-06, 2.2577E-06, -3.2323E-07, 1.2951E-05, 1.9623E-05, 3.6358E-05, 3.8155E-05, 2.4342E-05, 5.0123E-06, 9.9661E-06, -5.9365E-06, -1.2932E-05, -5.8577E-05, -8.3797E-05, -7.7561E-05, -7.5599E-05, -5.2294E-05, -5.6439E-05, -4.1603E-05, -6.8830E-05, -6.8319E-05, -8.3390E-05, -5.0563E-05, -1.1850E-05, 1.5394E-05, 1.8087E-05, 3.3193E-05, 3.3836E-05, 3.2357E-05, 3.5506E-05, 5.9239E-05, 6.5713E-05, 7.3615E-05, 6.8987E-05, 5.8102E-05, 4.9585E-05, 2.9111E-05, 3.8162E-05, 4.4345E-05, 2.6356E-05, 1.2831E-05, 5.0763E-06, -9.2887E-06, -1.1836E-05, -1.8954E-05, -1.6213E-05, -3.7549E-05, -1.4118E-05, -3.3496E-05, -3.0339E-05, -1.9475E-05, -3.1834E-06, 6.6622E-06, 3.8146E-05, 3.3132E-05, 4.5698E-05, 5.4921E-05, 2.9343E-05, 1.0387E-05, -7.0493E-06, -1.1628E-05, -7.1669E-06, -1.4938E-05, -6.7201E-06, -2.6530E-05, -4.1901E-05, -5.3204E-05, -6.2047E-05, -4.9605E-05, -3.9148E-05, -2.4543E-05, -2.0304E-05, -2.6742E-05, -1.6493E-05, -1.4115E-05, 1.6880E-06, 1.4700E-05, 2.3634E-05, 2.9618E-05, 5.4718E-05, 6.4898E-05, 6.4320E-05, 6.8184E-05, 7.6091E-05, 8.5625E-05, 9.2564E-05, 1.0160E-04, 1.0593E-04, 4.0886E-05, 5.0293E-05, 5.2034E-05, 4.1968E-05, 2.5599E-05, 8.4140E-06, -1.0871E-05, -3.4236E-05, -6.2434E-05, -9.0587E-05, -1.0018E-04, -8.6793E-05, -6.1464E-05, -4.1750E-05, -3.4987E-05, -3.0455E-05, -2.0387E-05, -1.9977E-05, -1.6075E-05, -1.0121E-05, -4.2559E-06, -1.0561E-06, -2.6781E-07, 1.8310E-06, 4.8180E-06, -7.3548E-07, -7.9972E-06, -1.3966E-05, -1.8812E-05, -2.3312E-05, -3.1683E-05, -3.5243E-05, -3.1804E-05, -3.2015E-05, -3.2881E-05, -3.0978E-05, -3.0975E-05, -3.2316E-05, -3.4967E-05, -3.6156E-05, -4.0504E-05, -4.3087E-05, -4.3270E-05, -4.0846E-05, -3.5073E-05, -2.9950E-05, -2.4593E-05, -2.6412E-05, -3.2254E-05, -3.2981E-05, -1.2781E-05, 1.4585E-06, 6.6730E-06, 8.1689E-06, 1.1398E-05, 1.6960E-05, 1.8269E-05, 2.1884E-05, 1.7208E-05, 1.9130E-05, 1.2816E-05, 1.1496E-05, 1.0654E-05, 7.0268E-06, 1.2052E-06, -2.0854E-06, -6.7494E-06, -1.2303E-05, -1.2708E-05, -9.9634E-06, -1.2670E-05, -1.5476E-05, -1.7705E-05, -1.4371E-05, -4.2306E-06, 6.2604E-06, 1.3903E-05, 1.5802E-05, 1.0674E-05, 2.4068E-06, -4.7576E-06, -1.6700E-05, -2.3556E-05, -3.1419E-05, -2.8593E-05, -3.3501E-05, -2.6819E-05, -6.7895E-06, -4.3516E-06, -5.7084E-06, -4.9060E-07, -1.6526E-06, -2.7875E-06, -8.6558E-06, -4.7482E-06, 8.7710E-06, 1.2654E-05, 1.4022E-05, 1.2409E-05, 1.4653E-05, 1.8855E-05, 1.7123E-05, 2.2891E-05, 3.0774E-05, 3.9618E-05, 4.8114E-05, 4.8643E-05, 4.7149E-05, 5.1595E-05, 5.2610E-05, 5.3096E-05, 5.6387E-05, 5.7744E-05, 5.6058E-05, 5.7233E-05, 5.7631E-05, 5.7966E-05, 5.9079E-05, 5.9279E-05, 5.9927E-05, 5.2385E-05, 5.4372E-05, 5.1814E-05, 5.0123E-05, 4.0588E-05, 3.6612E-05, 3.5425E-05, -5.0948E-06, -8.5964E-06, 2.7349E-06, 2.4357E-05, 3.8632E-05, 3.2419E-05, 9.3989E-06, -2.2673E-05, -5.5647E-05, -7.5237E-05, -7.7035E-05, -6.2865E-05, -3.5008E-05, -8.6805E-06, 4.6731E-06, 9.2431E-06, 8.6234E-06, 3.1127E-05, 5.2416E-05, 6.3155E-05, 6.7318E-05, 6.9407E-05, 6.7006E-05, 6.4891E-05, 4.6303E-05, 1.6890E-05, 8.5833E-06, 9.1464E-06, 1.6434E-06, -4.3037E-06, -7.3471E-06, 2.6533E-06, -7.1016E-07, -4.2591E-06, -1.4075E-06, 2.9190E-06, 3.2326E-06, 5.1936E-06, 4.7645E-06, 1.7003E-05, 2.5819E-05, 2.6554E-05, 2.9577E-05, 3.3219E-05, 1.8322E-05, -3.9202E-06, -3.1277E-05, -5.2592E-05, -5.0410E-05, -2.4994E-05, -1.5547E-05, -2.4627E-06, 1.3211E-05, 1.8066E-05, 1.5882E-05, 6.0339E-06, 2.4306E-06, -4.3485E-06, 6.6921E-07, -2.8512E-06, -2.7442E-06, -1.4619E-05, -2.1220E-05, -2.6780E-05, -2.7676E-05, -2.7561E-05, -2.4935E-05, -1.8656E-05, -1.6708E-05, -1.8170E-05, -1.6726E-05, -1.8201E-05, -1.8497E-05, -1.4028E-05, -8.0851E-06, 3.8902E-06, 8.9034E-06, 1.1379E-05, 2.4988E-05, 3.4637E-05, 4.0514E-05, 5.0565E-05, 4.9724E-05, 5.0987E-05, 3.3909E-05, 2.2630E-05, 1.0617E-05, -2.1408E-05, -5.4630E-06, 1.6175E-05, 1.2247E-05, 9.3816E-06, -5.6549E-06, 2.7361E-06, 1.7048E-05, 1.6795E-05, 6.2091E-06, 4.8969E-06, 5.5749E-06, 9.8741E-06, -1.3963E-05, -1.5325E-05, -2.7245E-05, -3.5892E-05, -4.9450E-05, -5.4804E-05, -4.5521E-05, -3.7583E-05, -5.2153E-05, -5.3014E-05, -4.2527E-05, -3.2768E-05, -1.7527E-05, -2.0934E-05, -1.6442E-05, -6.4906E-06, -1.0048E-05, -5.4097E-06, -5.0290E-07, 3.8525E-07, 3.5365E-06, 1.2103E-06, 8.3594E-07, 9.1004E-06, 1.9179E-05, 2.4737E-05, 3.3673E-05); \n//center of the convolution \nint Nc = 63; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 127; \n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 50.0\n\nvec2 pixPos;\nmat3 cammat;\nvec3 campos;\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\n//vec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n//{\n//    float r = region(pos);\n//    if(r < 0.5) return vec3(0.0);\n//    float temp = hash13(pos);\n//    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n//    vec3 spos = hash33(pos) + pos;\n//    vec4 screenPos = project(cammat, campos, iResolution.xy, spos);\n//    if(screenPos.z < 0.0) return vec3(0.0);\n//    float distr = k1(screenPos.xy - pixPos);\n//    return 100.0*heat * distr / (screenPos.w*screenPos.w);\n//}\n//\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.25*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec * pow(camdist, -2.25));\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    cammat = cam;\n    \n    ro = get(CamP).xyz;\n    campos = ro;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n    pixPos = floor(fragCoord);\n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(0, i), 1);\n        vec3 pcolor = min(pow(pixel.xyz/(pixel.w+1e-6),vec3(2.3)), 5.0);\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x + i, coord.y);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 335, 335, 400], [402, 402, 425, 425, 471], [473, 473, 528, 528, 772]], "test": "untested"}
{"id": "mlsXDj", "name": "pulsating intestines", "author": "shaderology", "description": "variation of @yonatan twigl shader", "tags": ["2d", "twigl"], "likes": 56, "viewed": 1598, "published": 3, "date": "1675885747", "time_retrieved": "2024-07-30T18:11:22.592530", "image_code": "// noisePulse() by @yonatan\n// https://twigl.app/?ol=true&ss=-NNIajM4aEzy75lqtAUd\n// https://twitter.com/zozuar\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat noisePulse(in vec2 p, in float t){\n\n    vec2 n,q;\n    vec2 o = (iMouse.xy*.001);\n    float d=dot(p,p),S=9.,i,a,j;\n    for(mat2 m=rotate2D(5.);j++<16.;){\n      p*=m;\n      n*=m;\n      q=(p+o)*S+t*4.+sin(t*4.-d*6.)*.8+j+n ;\n      a+=dot(cos(q)/S,vec2(.2));\n      n-=sin(q);\n      S*=1.2;\n    }\n    \n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 r = (fragCoord.xy-.5*iResolution.xy);\n    float a = iResolution.y;\n    vec2 uv = r/a;\n\n\tvec2 m = iMouse.xy / a;\n    \n    // VARIABLES\n    vec3 sp = vec3(uv + .5, 0.);\n    vec3 lp = vec3(0.5, 0.5, 1.) + vec3(m,0.);\n    vec3 ld = normalize(lp - sp);\n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(ro-sp);\n\n    // NORMALS\n    vec2 x1 = (r-vec2(-1.,0.))/a;\n    vec2 y1 = (r-vec2(0.,-1.))/a;\n         \n    float nB = noisePulse(uv, iTime);\n    float nX = noisePulse(x1, iTime);\n    float nY = noisePulse(y1, iTime);\n    \n    float Nx = (nB-nX);\n    float Ny = (nB-nY);\n    vec3 N = normalize(vec3(Nx,Ny,0.005));\n\n    // TEXTURE\n    vec2 uvd = uv * (1. + (N.xy*.1)) + (N.xy*.1);\n    vec3 tex = texture(iChannel0,uvd).xyz;\n    \n    // SHADE\n\tfloat diff = max(dot(N, ld), 0.);\n    float spec = pow(max(dot( reflect(N, ld), rd), 0.), 16.); \n    float occl = nB + .5;  \n    \n    // COMP\n    vec3 tint = vec3(0.3, 0.03, 0.005);\n    vec3 comp = vec3(0);\n    comp += occl * occl * tint;\n    comp += diff * tint * 0.2;\n    comp += spec * tex;\n    \n    // POST\n    uv -= vec2(1.);\n    comp *= pow(2.0*uv.x*uv.y*(uv.x-1.)*(uv.y-1.),0.4);\n    comp = sqrt(comp);    \n    \n    fragColor=vec4(comp,1.);\n    \n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 136, 136, 188], [190, 190, 230, 230, 508], [510, 510, 567, 567, 1777]], "test": "untested"}
{"id": "DlSSWz", "name": "circle not lines", "author": "diocan", "description": "circle not lines", "tags": ["circle"], "likes": 5, "viewed": 226, "published": 3, "date": "1675885340", "time_retrieved": "2024-07-30T18:11:23.353495", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "untested"}
{"id": "ctBSWR", "name": "Signed distance to conic section", "author": "NinjaKoala", "description": "Iterative method to get the distance to a conic section\nComment first line to get a visualization of the method.\n\nThen you see the lagrange curve relative to the mouse in green, its asymptotes in red and the nearest point in black.", "tags": ["2d", "sdf", "conicsection"], "likes": 5, "viewed": 194, "published": 3, "date": "1675880325", "time_retrieved": "2024-07-30T18:11:24.190259", "image_code": "/*\nAlso see https://www.shadertoy.com/view/mlB3RD\nand https://www.shadertoy.com/view/Dl2Xz1\n\nBasically, the nearest point ist found by\nintersection with a curve derived via lagrange multiplier.\n\nThe iteration is alternately doing a gradient descent\nto the conic and the \"lagrange curve\".\n\nAnother variant of the iteration is\ndoing a step perpendicular to the gradient of the conic\ninstead of the gradient descent step towards the \"lagrange curve\".\n\nThe nearest intersection of the asymptotes of the lagrange\ncurve and the conic is used as initial approximation.\n\nThere are some variants of this method used\nin different cases to ensure proper convergence.\n\nnum_iterations is the number of iterations in\none case, num_iterations2 in another case.\n*/\n\n#define SHOW_DISTANCE_FIELD\n#define ANIMATE\n\nconst int num_iterations = 6;\nconst int num_iterations2 = 10;\n\nfloat a_param = 30.;\nfloat b_param = -30.;\n//float a_param = -3.;\n//float b_param = -10.;\nfloat c_param = 0.;\nfloat d_param = 0.;\n\nvec3 bg_col = vec3(1);\nvec3 conic_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 asym_col = vec3(1,0,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 1.;\n\nconst float pi = 3.1415925;\n\nfloat conic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x*a_param + c_param, 2.*p.y*b_param + d_param);\n\treturn p.x*(p.x*a_param + c_param) + p.y*(p.y*b_param + d_param) + 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n    grad = vec2(2.*(a_param*(p.y-p2.y)-p.y*b_param) - d_param,\n                2.*(b_param*(p2.x-p.x)+p.x*a_param) + c_param);\n    return 2.*(p.x*a_param*(p.y-p2.y)-p.y*b_param*(p.x-p2.x)) + c_param*(p.y-p2.y) - d_param*(p.x-p2.x);\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nvec2 iteration2(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tvec2 tang = vec2(p_grad1.y, -p_grad1.x);\n\tp -= dot(p-p2,tang)/dot(tang,tang) * tang;\n\n\tp_val1 = conic_curve(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\treturn p;\n}\n\nvec2 nearest_point_to_conic(vec2 uv, out float sgn){\n\t// asymptotes of the lagrange curve\n\tfloat asym_x = -.5*(2.*b_param*uv.x + c_param)/(a_param - b_param);\n\tfloat asym_y = .5*(2.*a_param*uv.y + d_param)/(a_param - b_param);\n\n\tfloat x_discriminant = c_param * c_param - 4. * a_param * ((b_param*asym_y + d_param)*asym_y + 1.);\n\tfloat y_discriminant = d_param * d_param - 4. * b_param * ((a_param*asym_x + c_param)*asym_x + 1.);\n\n\tvec2 nearest_point = uv;\n\tfloat nearest_dist = 1e38;\n\n\tif(x_discriminant > 0.){\n\t\tfloat x_intersection1 = (-c_param + sqrt(x_discriminant))/(2.*a_param);\n\t\tvec2 cur_point1 = vec2(x_intersection1,asym_y);\n\t\tfloat cur_dis1 = distance(cur_point1,uv);\n\t\tif(cur_dis1 < nearest_dist){\n\t\t\tnearest_dist = cur_dis1;\n\t\t\tnearest_point = cur_point1;\n\t\t}\n\n\t\tfloat x_intersection2 = (-c_param - sqrt(x_discriminant))/(2.*a_param);\n\t\tvec2 cur_point2 = vec2(x_intersection2,asym_y);\n\t\tfloat cur_dis2 = distance(cur_point2,uv);\n\t\tif(cur_dis2 < nearest_dist){\n\t\t\tnearest_dist = cur_dis2;\n\t\t\tnearest_point = cur_point2;\n\t\t}\n\t}\n\tif(y_discriminant > 0.){\n\t\tfloat y_intersection1 = (-d_param + sqrt(y_discriminant))/(2.*b_param);\n\t\tvec2 cur_point1 = vec2(asym_x,y_intersection1);\n\t\tfloat cur_dis1 = distance(cur_point1,uv);\n\t\tif(cur_dis1 < nearest_dist){\n\t\t\tnearest_dist = cur_dis1;\n\t\t\tnearest_point = cur_point1;\n\t\t}\n\n\t\tfloat y_intersection2 = (-d_param - sqrt(y_discriminant))/(2.*b_param);\n\t\tvec2 cur_point2 = vec2(asym_x,y_intersection2);\n\t\tfloat cur_dis2 = distance(cur_point2,uv);\n\t\tif(cur_dis2 < nearest_dist){\n\t\t\tnearest_dist = cur_dis2;\n\t\t\tnearest_point = cur_point2;\n\t\t}\n\t}\n\n\tvec2 nor1;\n\tfloat val1 = conic_curve(uv, nor1);\n    sgn = sign(val1);\n\n\tif(distance(uv,iteration(uv,uv)) < distance(nearest_point,iteration(nearest_point,uv))){\n\t\tnearest_point = uv;\n\t}\n\n\tif(sign(a_param) != sign(b_param) || sgn < 0.){\n\t\tfor(int i=0;i<num_iterations;i++){\n\t\t\tnearest_point = iteration(nearest_point, uv);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<num_iterations2;i++){\n\t\t\tnearest_point = iteration2(nearest_point, uv);\n\t\t}\n\t}\n\n\treturn nearest_point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #ifdef ANIMATE\n    a_param = mix(30.,-5.,sin(iTime));\n    b_param = mix(-30.,-10.,sin(iTime));\n    c_param = 0.;\n    d_param = 0.;\n    #endif\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 conic_grad;\n\tfloat conic_val = conic_curve(uv, conic_grad);\n\n\tdis = min(dis, abs(conic_val / length(conic_grad)) - line_width);\n\tcolor = mix(conic_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n    \n    float asym_x = -.5*(2.*b_param*mouse.x + c_param)/(a_param - b_param);\n    float asym_y = .5*(2.*a_param*mouse.y + d_param)/(a_param - b_param);\n    dis = min(dis,abs(uv.x-asym_x));\n    dis = min(dis,abs(uv.y-asym_y));\n    \n    color = mix(asym_col,color,smoothstep(0.,border,dis));\n    dis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n    float sgn;\n\tvec2 nearest_point = nearest_point_to_conic(mouse, sgn);\n\n    dis = min(dis, distance(uv,nearest_point) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n    \n\t#ifdef SHOW_DISTANCE_FIELD\n\tnearest_point = nearest_point_to_conic(uv, sgn);\n\tdis = distance(uv, nearest_point);\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1225, 1225, 1266, 1266, 1406], [1408, 1408, 1461, 1461, 1695], [1697, 1697, 1729, 1729, 1956], [1958, 1958, 1991, 1991, 2253], [2255, 2255, 2307, 2344, 4307], [4309, 4309, 4365, 4365, 6161]], "test": "untested"}
{"id": "DtBXzm", "name": "Neuron network", "author": "guil", "description": "Forked from Pulsing Guts and original shader :\nhttps://twitter.com/zozuar/status/1621229990267310081", "tags": ["neuron"], "likes": 25, "viewed": 391, "published": 3, "date": "1675877692", "time_retrieved": "2024-07-30T18:11:25.084866", "image_code": "mat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\n\n// based on the follow tweet:\n// https://twitter.com/zozuar/status/1621229990267310081\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 n = vec2(0);\n    vec2 q = vec2(0);\n    vec2 p = uv + t/4.;\n    float S = 10.;\n    float a = 0.0;\n    mat2 m = rotate2D(1.);\n\n    for (float j = 0.; j < 20.; j++) {\n        p *= m;\n        n *= m;\n        q = p * S + n +.2*sin(t); \n        a += dot(sin(q)/S, vec2(.3));\n        n -= cos(q);\n        S *= 1.2;\n    }\n\n    col = vec3(1, 2, 4) * (3.*a + .3) ;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 76], [80, 167, 224, 274, 814]], "test": "untested"}
{"id": "mljXzD", "name": "Cloudy Volumetric Gyroid", "author": "rubioh", "description": "First shader with volumetric rendering, ", "tags": ["raymarch", "volumetric", "gyroid"], "likes": 15, "viewed": 208, "published": 3, "date": "1675876233", "time_retrieved": "2024-07-30T18:11:25.977479", "image_code": "#define PI 3.14159\n#define S(a,b,c) smoothstep(a,b,c)\n#define SCALE .75\n#define START 11.\n#define ROT mat3(cos(.7), 0., sin(.7), 0., 1., 0., -sin(.7), 0., cos(.7))\n#define ROT2 ROT*mat3(1., 0., 0., 0., cos(7.), sin(.7), 0., -sin(.7), cos(.7))\n#define ROT3 ROT2*mat3(cos(.7), sin(.7), 0., -sin(.7), cos(.7), 0., 0., 0., 1.)\n\n\n#define GYROFBM\nconst int MAX_MARCHING_STEPS = 120;\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat gyronoise(vec3 p){\n    return abs(dot(cos(p), sin(p.zxy)));\n}\n\n#ifdef GYROFBM\nfloat fbm(vec3 p){\n\n    float A = 1.;\n    float n = 0.;\n    float k = .6;\n    float f = 1.;\n    \n    // Nimitz gyroid noise: https://www.shadertoy.com/view/3l23Rh\n    for (int i=0; i<5; i++){\n        p += .1*sin(p.xzy*.75*f+iTime/4.);\n        n += gyronoise(p)*A-k; \n        A *= .7;\n        p *= 1.95*ROT3;\n        k -= .15;\n        f *= 3.;\n    }\n    return n*1.2;\n}\n#else\nfloat fbm(vec3 p){\n    return (noise(p)-.1)*.5 + noise(p*ROT*2.)*.5 + noise(p*ROT*8.)*.25 + noise(p*ROT*16.)*.25 + noise(p*ROT*32.)*.25-.1;\n}\n#endif\n\n\nfloat fbm2(vec3 p){\n    return noise(p) + noise(p*ROT*2.)*.5;\n}\n\nfloat sdGyroid(vec3 p, vec3 offset, float scale, float thickness){\n    p += offset;\n    p *= scale;\n    return abs(dot(cos(p), sin(p.zxy)))/scale - thickness;\n}\n\nfloat getGyr(vec3 p){\n    float gyr = sdGyroid(p, vec3(10.,10.5,iTime/10.), SCALE, 1.5);\n    return gyr;\n}\n\n\nvec2 map(vec3 p)\n{\n  float gyr = getGyr(p);\n  return vec2(abs(gyr)*fbm(p+iTime/10.), gyr);//*S(2.5, 0., length(p)));\n}\n\nfloat flicker(){\n    return pow(noise1(iTime*4.), 8.)*.75+.25;\n}\n\nvoid rayMarch(vec3 ro, vec3 rd, out vec4 col) {  \n\n  //Vol March in Fog\n  float t = START; // Starting point\n  float fogT0 = 0.;\n  \n  vec3 lp = vec3(0.,0.,2.);\n  vec3 ld; ld-=ld;\n  \n  float thresh= .35;\n  float lDe, w;\n  float td = 0.;\n  float dit = fract(sin(dot(rd+ro, vec3(14.456, 17.2154, 73.156))*45678.123))*.0;\n  float dt = 0.;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++){\n      \n      if (td > .99) break;\n      \n      vec3 p = ro + (t+dit)*rd;\n      vec2 d = map(p);\n      \n      vec3 ncol = vec3(0.);\n      \n      float f = flicker();\n      float df = S(START*1.1-2.*f, START*1.5-2.5*f, length(p-ro)); //Dist flick\n      vec3 flick_col = vec3(0.0,0.30,1.)*f*df;\n      \n      // Inspire by Shane's Cheap Cloud Flytrhough:  https://www.shadertoy.com/view/Xsc3R4\n      // And Protean clouds by Nimitz : https://www.shadertoy.com/view/3l23Rh\n      // Not as accurate as theirs but i will keep trying to improve the rendering and the fog texture\n      if (d.x>thresh){\n          float den = pow(d.x-thresh, 1.);\n          td += den;\n          \n          ld = lp-p;\n          float lDist = length(ld);\n          ld = normalize(ld);\n          \n          vec3 sn = -rd + .1*hash33(p);\n          float atten = 1./(1.+.125*pow(den, 2.) + .125*den + .25*length(p-ro));\n          float interp = max(abs(getGyr(p)/1.3) -.45, 0.);\n          float diff = max(dot(sn, ld), 0.);\n          vec3 interior = mix(vec3(0.9,0.000,0.000), vec3(0.961,0.475,0.000), fbm2(p*8.)*.7);\n          vec3 exterior = mix(vec3(.1, .05, .05), flick_col+interior*.5, df*.5);\n          ncol = mix(exterior*(diff*.5+.25), interior*1.5, interp)*atten*(1.+den);\n          col.rgb += ncol*(1.-td);\n      }\n      else{\n          col.rgb += (vec3(1.)+flick_col)*dt*.03;\n          td += .005;\n      }\n      dt = (.07-.06*S(thresh-.1, thresh, d.x))+fract(sin(dot(p, vec3(14.456, 17.2154, 73.156))*45678.123))*.0;\n      \n      t += dt;\n  }\n}\n\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 render(vec3 ro, vec3 rd){\n  vec3 backgroundColor = vec3(0.1, .1, .1);\n  vec4 col = vec4(0.);\n  rayMarch(ro, rd, col); \n  return col;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  vec3 ro = vec3(0, 0, -4); \n  vec2 m = iMouse.xy/iResolution.xy;\n  vec3 lookat = vec3(0., 0.,0. );\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z);\n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -1));\n\n  vec4 col = render(ro, rd);\n\n  vec3 background = vec3(.1,.1, .1);\n    // Output to screen\n  fragColor = vec4(pow(vec3(col), vec3(1.5)),1.0);\n}\n\n", "image_inputs": [], "common_code": "float noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n\nfloat hash11(float p){\n    return fract(sin(p*12.789)*7896.4563);\n}\n\nfloat noise1(float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n    return mix(hash11(i), hash11(i+1.), smoothstep(0., 1., f));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 398, 398, 502], [504, 504, 528, 528, 571], [1114, 1114, 1133, 1133, 1177], [1179, 1179, 1245, 1245, 1339], [1341, 1341, 1362, 1362, 1447], [1450, 1450, 1468, 1468, 1568], [1570, 1570, 1586, 1586, 1634], [1636, 1636, 1683, 1707, 3542], [3545, 3545, 3564, 3564, 3640], [3642, 3642, 3672, 3672, 3781], [3783, 3783, 3830, 3830, 4041], [4043, 4043, 4100, 4100, 4579]], "test": "untested"}
{"id": "dtjXzm", "name": "3d Music Visualizer", "author": "MiniByte", "description": "3d Music Visualizer - Techno Melodic - mix by MiniByte", "tags": ["3d", "music", "visualizer"], "likes": 0, "viewed": 132, "published": 3, "date": "1675875937", "time_retrieved": "2024-07-30T18:11:26.788311", "image_code": "// thanks for Techno Core - Kali\nfloat det = .001;\nvec3 objcol=vec3(0.);\nfloat snd;\n\n\nmat2 rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fractal(vec3 p) {\n    vec3 c = p;\n    float m = 100.;\n    for(int i = 0; i < 10; i++) {\n\t\tp=abs(p + 1.) - abs( p - 1.) - p;\n        p=p / clamp(dot(p,p), 0.1, 1.) - c;\n    \tm=min(m, abs(length(p) - 3.5));\n    }\n    m = max(0., 1. - m);\n    objcol = abs(p) * .6;\n    return m * m * (.2+snd);\n}\n\nfloat de(vec3 p) {\n    p.yz *= rot(iTime);\n    p.xz *= rot(.2);\n    float f = fractal(p);\n    //\tfloat d = length(p) - 3.5 + f * 1.5 - snd * 3.;\n\tfloat d = length(p) - 3.9 + f * 2.1 - snd * 1.;\n    //d = min(d, length(p.xy) - .25);\n\t//d = min(d, length(p.yz) - .25);\n\t//d = min(d, length(p.xz) - .25);\n    d = min(d, length(p.xy) - .55);\n\td = min(d, length(p.yz) - .55);\n\td = min(d, length(p.xz) - .55);\n    //return (d - f * .5) * .5;\n    return (d - f * .3) * .4;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 col = vec3(0.), p;\n    float td = 0., d;\n    for (int i = 0; i < 150; i++) {\n    \tp = from + td * dir;    \n\t\td = de(p);\n        td += max(det, abs(d));\n\t\tif (td > 20.) break;\n        col += objcol * exp(-.005 * td * td);\n    }\n    vec3 rescol = col * .01 * (.3 + snd * 1.5);\n    return rescol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    snd = texture(iChannel0,vec2(.15)).r;\n    vec2 p = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = normalize(vec3(p, .7));\n    float t = iTime*.5;\n    vec3 from = vec3(sin(t) * 2., 0., -10.);\n    from.xz *= rot(t);\n    dir.xz *= rot(t);\n\tdet += max(0. ,5. - iTime)*.02;\n    vec3 col = march(from, dir);\n    col += pow(abs(.5 - fract(dir.x * 20.)) * 2., 10.) * .2;\n    col += pow(abs(.5 - fract(dir.y * 20.)) * 2., 10.) * .2;\n    float spec = pow(texture(iChannel0, vec2(floor(dir.x*20.)/20. * .5 + .5, .1)).r,2.);\n\tvec2 sq = abs(.5-fract(dir.xy*20.));\n    col+=abs(1.-length(max(vec2(0.),abs(sq.xy)-.1)))*step(dir.y+.4,spec)*length(fract(dir.xy*10.))*.4;\n    col=max(col, vec3(.5, .2, 0.) - smoothstep(0.,.03,abs(dir.y - spec + .35)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33348, "src": "https://soundcloud.com/cristi-covlea/tehno-melodic-vol-01-mix-by-minibyte", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 105, 105, 168], [170, 170, 193, 193, 468], [470, 470, 488, 488, 937], [939, 939, 972, 972, 1274], [1276, 1276, 1333, 1333, 2171]], "test": "untested"}
{"id": "DtjXzm", "name": "my test -ref123", "author": "reflog", "description": "my test", "tags": ["test"], "likes": 0, "viewed": 124, "published": 3, "date": "1675863435", "time_retrieved": "2024-07-30T18:11:27.722813", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  //  vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n //   vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n  //  fragColor = vec4(col,1.0);\n    \n      vec2 st = fragCoord/iResolution.xy;\n        float line = step(0.1, mod(st.x, 0.2));\n    fragColor = vec4(vec3(line), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 298, 434]], "test": "untested"}
{"id": "msXXDS", "name": "Physically-based sky", "author": "fgarlin", "description": "A physically-based atmosphere rendering technique, featuring a multiple scattering approximation and spectral rendering with only four samples.", "tags": ["sky", "volumetric", "atmosphere", "participatingmedia"], "likes": 19, "viewed": 879, "published": 3, "date": "1675862011", "time_retrieved": "2024-07-30T18:11:29.315555", "image_code": "/*\n * Copyright (c) 2023 Fernando Garca Lin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * You can have a look at all the configurable parameters in the Common tab. \n *\n * This shader is the final result of my Master's Thesis.\n * The main contributions are:\n *\n * 1. A spectral rendering technique that only requires 4 wavelength samples to\n *    get accurate results.\n * 2. A multiple scattering approximation.\n *\n * Both of these approximations rely on an analytical fit, so they only work for\n * Earth's atmosphere. We make up for it by using a very flexible atmosphere\n * model that is able to represent a wide variety of atmospheric conditions.\n *\n * The path tracer that has been used as a ground truth can be found at:\n * https://github.com/fgarlin/skytracer\n */\n \n//------------------------------------------------------------------------------\n\n/*\n * ACES tonemapping fit for the sRGB color space\n * https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n */\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 aces_input_mat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n    );\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 aces_output_mat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n    );\n\nvec3 rrt_and_odt_fit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 aces_fitted(vec3 color)\n{\n\tcolor = aces_input_mat * color;\n    color = rrt_and_odt_fit(color);\n    color = aces_output_mat * color;\n    return clamp(color, 0.0, 1.0);\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 gamma_correct(vec3 linear_srgb)\n{\n    vec3 a = 12.92 * linear_srgb;\n    vec3 b = 1.055 * pow(linear_srgb, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linear_srgb);\n    return mix(a, b, c);\n}\n\nvoid fisheye_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    if (aspect_ratio < 1.0) {\n        uv.y *= 1.0 / aspect_ratio;\n    } else {\n        uv.x *= aspect_ratio;\n    }\n    phi = atan(uv.y, uv.x);\n    theta = PI * (0.5 - length(uv));\n}\n\nvoid equirectangular_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    phi = 2.0 * PI * uv.x;\n    theta = PI * uv.y;\n}\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\nvoid projection_camera(in vec2 fragCoord, out float phi, out float theta)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ray_dir = vec3(1.0 / tan(radians(CAMERA_FOV) * 0.5), uv.x, uv.y);\n    ray_dir = normalize(ray_dir);\n    ray_dir *= rotY(radians(CAMERA_PITCH)) * rotZ(radians(CAMERA_YAW)) * rotX(radians(CAMERA_ROLL));\n\n    phi = atan(ray_dir.y, ray_dir.x);\n    theta = asin(ray_dir.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float phi, theta;\n#if CAMERA_TYPE == 0\n    equirectangular_camera(fragCoord, phi, theta);\n#elif CAMERA_TYPE == 1\n    fisheye_camera(fragCoord, phi, theta);\n#else\n    projection_camera(fragCoord, phi, theta);\n#endif\n\n    float azimuth = phi / PI * 0.5 + 0.5;\n    // Undo the non-linear transformation from the sky-view LUT\n    float elev = sqrt(abs(theta) / (PI * 0.5)) * sign(theta) * 0.5 + 0.5;\n\n    vec3 col = texture(iChannel0, vec2(azimuth, elev)).rgb;\n\n#if SHOW_RELATIVE_LUMINANCE == 0\n#if TONEMAPPING_TECHNIQUE == 0\n    // Apply exposure\n    col = col * exp2(EXPOSURE);\n    // Tonemap\n    col = aces_fitted(col);\n    // Apply the sRGB transfer function (gamma correction)\n    col = clamp(gamma_correct(col), 0.0, 1.0);\n#elif TONEMAPPING_TECHNIQUE == 1\n    const float k = 0.05;\n    col = 1.0 - exp(-k * col);\n    col = clamp(gamma_correct(col), 0.0, 1.0);\n#endif\n#else\n    const mat3 srgb_to_xyz = mat3(0.4124564, 0.2126729, 0.0193339,\n                                  0.3575761, 0.7151522, 0.1191920,\n                                  0.1804375, 0.0721750, 0.9503041);\n    vec3 xyz = srgb_to_xyz * col;\n    float lum = xyz.y * (1.0 / 17.4862339609375);\n    col = vec3(lum);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n * Buffer A: Transmittance LUT\n *\n * In this buffer we precompute the transmittance to the top of the atmosphere.\n * We use the same technique as in \"Precomputed Atmospheric Scattering\"\n * by Eric Bruneton and Fabrice Neyret (2008).\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float sun_cos_theta = uv.x * 2.0 - 1.0;\n    vec3 sun_dir = vec3(-sqrt(1.0 - sun_cos_theta*sun_cos_theta), 0.0, sun_cos_theta);\n\n    float distance_to_earth_center = mix(EARTH_RADIUS, ATMOSPHERE_RADIUS, uv.y);\n    vec3 ray_origin = vec3(0.0, 0.0, distance_to_earth_center);\n\n    float t_d = ray_sphere_intersection(ray_origin, sun_dir, ATMOSPHERE_RADIUS);\n    float dt = t_d / float(TRANSMITTANCE_STEPS);\n\n    vec4 result = vec4(0.0);\n\n    for (int i = 0; i < TRANSMITTANCE_STEPS; ++i) {\n        float t = (float(i) + 0.5) * dt;\n        vec3 x_t = ray_origin + sun_dir * t;\n\n        float altitude = length(x_t) - EARTH_RADIUS;\n\n        vec4 aerosol_absorption, aerosol_scattering;\n        vec4 molecular_absorption, molecular_scattering;\n        vec4 extinction;\n        get_atmosphere_collision_coefficients(\n            altitude,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        result += extinction * dt;\n    }\n\n    vec4 transmittance = exp(-result);\n    fragColor = transmittance;\n}\n", "buffer_a_inputs": [], "common_code": "// Configurable parameters\n\n#define ANIMATE_SUN 1\n// 0=equirectangular, 1=fisheye, 2=projection\n#define CAMERA_TYPE 2\n// 0=Background, 1=Desert Dust, 2=Maritime Clean, 3=Maritime Mineral,\n// 4=Polar Antarctic, 5=Polar Artic, 6=Remote Continental, 7=Rural, 8=Urban\n#define AEROSOL_TYPE 8\n\nconst float SUN_ELEVATION_DEGREES = 0.0;    // 0=horizon, 90=zenith\nconst float EYE_ALTITUDE          = 0.5;    // km\nconst int   MONTH                 = 0;      // 0-11, January to December\nconst float AEROSOL_TURBIDITY     = 1.0;\nconst vec4  GROUND_ALBEDO         = vec4(0.3);\n// Ray marching steps. More steps mean better accuracy but worse performance\nconst int TRANSMITTANCE_STEPS     = 32;\nconst int IN_SCATTERING_STEPS     = 32;\n// Camera settings\nconst float EXPOSURE              = -4.0;\n// For the \"projection\" type camera\nconst float CAMERA_FOV   =  90.0;\nconst float CAMERA_YAW   =  15.0;\nconst float CAMERA_PITCH = -12.0;\nconst float CAMERA_ROLL  =   0.0;\n\n// Debug\n#define ENABLE_SPECTRAL 1\n#define ENABLE_MULTIPLE_SCATTERING 1\n#define ENABLE_AEROSOLS 1\n#define SHOW_RELATIVE_LUMINANCE 0\n#define TONEMAPPING_TECHNIQUE 0 // 0=ACES, 1=simple\n\n//-----------------------------------------------------------------------------\n// Constants\n\n// All parameters that depend on wavelength (vec4) are sampled at\n// 630, 560, 490, 430 nanometers\n\nconst float PI = 3.14159265358979323846;\nconst float INV_PI = 0.31830988618379067154;\nconst float INV_4PI = 0.25 * INV_PI;\nconst float PHASE_ISOTROPIC = INV_4PI;\nconst float RAYLEIGH_PHASE_SCALE = (3.0 / 16.0) * INV_PI;\nconst float g = 0.8;\nconst float gg = g*g;\n\nconst float EARTH_RADIUS = 6371.0; // km\nconst float ATMOSPHERE_THICKNESS = 100.0; // km\nconst float ATMOSPHERE_RADIUS = EARTH_RADIUS + ATMOSPHERE_THICKNESS;\nconst float EYE_DISTANCE_TO_EARTH_CENTER = EARTH_RADIUS + EYE_ALTITUDE;\nconst float SUN_ZENITH_COS_ANGLE = cos(radians(90.0 - SUN_ELEVATION_DEGREES));\nconst vec3 SUN_DIR = vec3(-sqrt(1.0 - SUN_ZENITH_COS_ANGLE*SUN_ZENITH_COS_ANGLE), 0.0, SUN_ZENITH_COS_ANGLE);\n\n#if ENABLE_SPECTRAL == 1\n// Extraterrestial Solar Irradiance Spectra, units W * m^-2 * nm^-1\n// https://www.nrel.gov/grid/solar-resource/spectra.html\nconst vec4 sun_spectral_irradiance = vec4(1.679, 1.828, 1.986, 1.307);\n// Rayleigh scattering coefficient at sea level, units km^-1\n// \"Rayleigh-scattering calculations for the terrestrial atmosphere\"\n// by Anthony Bucholtz (1995).\nconst vec4 molecular_scattering_coefficient_base = vec4(6.605e-3, 1.067e-2, 1.842e-2, 3.156e-2);\n// Ozone absorption cross section, units m^2 / molecules\n// \"High spectral resolution ozone absorption cross-sections\"\n// by V. Gorshelev et al. (2014).\nconst vec4 ozone_absorption_cross_section = vec4(3.472e-21, 3.914e-21, 1.349e-21, 11.03e-23) * 1e-4f;\n#else\n// Same as above but for the following \"RGB\" wavelengths: 680, 550, 440 nm\n// The Sun spectral irradiance is also multiplied by a constant factor to\n// compensate for the fact that we use the spectral samples directly as RGB,\n// which is incorrect.\nconst vec4 sun_spectral_irradiance = vec4(1.500, 1.864, 1.715, 0.0) * 150.0;\nconst vec4 molecular_scattering_coefficient_base = vec4(4.847e-3, 1.149e-2, 2.870e-2, 0.0);\nconst vec4 ozone_absorption_cross_section = vec4(3.36e-21f, 3.08e-21f, 20.6e-23f, 0.0) * 1e-4f;\n#endif\n\n// Mean ozone concentration in Dobson for each month of the year.\nconst float ozone_mean_monthly_dobson[] = float[](\n    347.0, // January\n    370.0, // February\n    381.0, // March\n    384.0, // April\n    372.0, // May\n    352.0, // June\n    333.0, // July\n    317.0, // August\n    298.0, // September\n    285.0, // October\n    290.0, // November\n    315.0  // December\n);\n\n/*\n * Every aerosol type expects 5 parameters:\n * - Scattering cross section\n * - Absorption cross section\n * - Base density (km^-3)\n * - Background density (km^-3)\n * - Height scaling parameter\n * These parameters can be sent as uniforms.\n *\n * This model for aerosols and their corresponding parameters come from\n * \"A Physically-Based Spatio-Temporal Sky Model\"\n * by Guimera et al. (2018).\n */\n#if   AEROSOL_TYPE == 0 // Background\nconst vec4 aerosol_absorption_cross_section = vec4(4.5517e-19, 5.9269e-19, 6.9143e-19, 8.5228e-19);\nconst vec4 aerosol_scattering_cross_section = vec4(1.8921e-26, 1.6951e-26, 1.7436e-26, 2.1158e-26);\nconst float aerosol_base_density = 2.584e17;\nconst float aerosol_background_density = 2e6;\n#elif AEROSOL_TYPE == 1 // Desert Dust\nconst vec4 aerosol_absorption_cross_section = vec4(4.6758e-16, 4.4654e-16, 4.1989e-16, 4.1493e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(2.9144e-16, 3.1463e-16, 3.3902e-16, 3.4298e-16);\nconst float aerosol_base_density = 1.8662e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 2.0;\n#elif AEROSOL_TYPE == 2 // Maritime Clean\nconst vec4 aerosol_absorption_cross_section = vec4(6.3312e-19, 7.5567e-19, 9.2627e-19, 1.0391e-18);\nconst vec4 aerosol_scattering_cross_section = vec4(4.6539e-26, 2.721e-26, 4.1104e-26, 5.6249e-26);\nconst float aerosol_base_density = 2.0266e17;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.9;\n#elif AEROSOL_TYPE == 3 // Maritime Mineral\nconst vec4 aerosol_absorption_cross_section = vec4(6.9365e-19, 7.5951e-19, 8.2423e-19, 8.9101e-19);\nconst vec4 aerosol_scattering_cross_section = vec4(2.3699e-19, 2.2439e-19, 2.2126e-19, 2.021e-19);\nconst float aerosol_base_density = 2.0266e17;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 2.0;\n#elif AEROSOL_TYPE == 4 // Polar Antarctic\nconst vec4 aerosol_absorption_cross_section = vec4(1.3399e-16, 1.3178e-16, 1.2909e-16, 1.3006e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5506e-19, 1.809e-19, 2.3069e-19, 2.5804e-19);\nconst float aerosol_base_density = 2.3864e16;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 30.0;\n#elif AEROSOL_TYPE == 5 // Polar Arctic\nconst vec4 aerosol_absorption_cross_section = vec4(1.0364e-16, 1.0609e-16, 1.0193e-16, 1.0092e-16);\nconst vec4 aerosol_scattering_cross_section = vec4(2.1609e-17, 2.2759e-17, 2.5089e-17, 2.6323e-17);\nconst float aerosol_base_density = 2.3864e16;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 30.0;\n#elif AEROSOL_TYPE == 6 // Remote Continental\nconst vec4 aerosol_absorption_cross_section = vec4(4.5307e-18, 5.0662e-18, 4.4877e-18, 3.7917e-18);\nconst vec4 aerosol_scattering_cross_section = vec4(1.8764e-18, 1.746e-18, 1.6902e-18, 1.479e-18);\nconst float aerosol_base_density = 6.103e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#elif AEROSOL_TYPE == 7 // Rural\nconst vec4 aerosol_absorption_cross_section = vec4(5.0393e-23, 8.0765e-23, 1.3823e-22, 2.3383e-22);\nconst vec4 aerosol_scattering_cross_section = vec4(2.6004e-22, 2.4844e-22, 2.8362e-22, 2.7494e-22);\nconst float aerosol_base_density = 8.544e18;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#elif AEROSOL_TYPE == 8 // Urban\nconst vec4 aerosol_absorption_cross_section = vec4(2.8722e-24, 4.6168e-24, 7.9706e-24, 1.3578e-23);\nconst vec4 aerosol_scattering_cross_section = vec4(1.5908e-22, 1.7711e-22, 2.0942e-22, 2.4033e-22);\nconst float aerosol_base_density = 1.3681e20;\nconst float aerosol_background_density = 2e6;\nconst float aerosol_height_scale = 0.73;\n#endif\nconst float aerosol_background_divided_by_base_density = aerosol_background_density / aerosol_base_density;\n\n//-----------------------------------------------------------------------------\n\nvec3 get_sun_direction(float time)\n{\n#if ANIMATE_SUN == 0\n    return SUN_DIR;\n#else\n    float a = sin(time*0.5 - 1.5) * 0.55 + 0.45;\n    return vec3(-sqrt(1.0 - a*a), 0.0, a);\n#endif\n}\n\n/*\n * Helper function to obtain the transmittance to the top of the atmosphere\n * from Buffer A.\n */\nvec4 transmittance_from_lut(sampler2D lut, float cos_theta, float normalized_altitude)\n{\n    float u = clamp(cos_theta * 0.5 + 0.5, 0.0, 1.0);\n    float v = clamp(normalized_altitude, 0.0, 1.0);\n    return texture(lut, vec2(u, v));\n}\n\n/*\n * Returns the distance between ro and the first intersection with the sphere\n * or -1.0 if there is no intersection. The sphere's origin is (0,0,0).\n * -1.0 is also returned if the ray is pointing away from the sphere.\n */\nfloat ray_sphere_intersection(vec3 ro, vec3 rd, float radius)\n{\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius*radius;\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float d = b*b - c;\n    if (d < 0.0) return -1.0;\n    if (d > b*b) return (-b+sqrt(d));\n    return (-b-sqrt(d));\n}\n\n/*\n * Rayleigh phase function.\n */\nfloat molecular_phase_function(float cos_theta)\n{\n    return RAYLEIGH_PHASE_SCALE * (1.0 + cos_theta*cos_theta);\n}\n\n/*\n * Henyey-Greenstrein phase function.\n */\nfloat aerosol_phase_function(float cos_theta)\n{\n    float den = 1.0 + gg + 2.0 * g * cos_theta;\n    return INV_4PI * (1.0 - gg) / (den * sqrt(den));\n}\n\nvec4 get_multiple_scattering(sampler2D transmittance_lut, float cos_theta, float normalized_height, float d)\n{\n#if ENABLE_MULTIPLE_SCATTERING == 1\n    // Solid angle subtended by the planet from a point at d distance\n    // from the planet center.\n    float omega = 2.0 * PI * (1.0 - sqrt(d*d - EARTH_RADIUS*EARTH_RADIUS) / d);\n\n    vec4 T_to_ground = transmittance_from_lut(transmittance_lut, cos_theta, 0.0);\n\n    vec4 T_ground_to_sample =\n        transmittance_from_lut(transmittance_lut, 1.0, 0.0) /\n        transmittance_from_lut(transmittance_lut, 1.0, normalized_height);\n\n    // 2nd order scattering from the ground\n    vec4 L_ground = PHASE_ISOTROPIC * omega * (GROUND_ALBEDO / PI) * T_to_ground * T_ground_to_sample * cos_theta;\n\n    // Fit of Earth's multiple scattering coming from other points in the atmosphere\n    vec4 L_ms = 0.02 * vec4(0.217, 0.347, 0.594, 1.0) * (1.0 / (1.0 + 5.0 * exp(-17.92 * cos_theta)));\n\n    return L_ms + L_ground;\n#else\n    return vec4(0.0);\n#endif\n}\n\n/*\n * Return the molecular volume scattering coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_scattering_coefficient(float h)\n{\n    return molecular_scattering_coefficient_base * exp(-0.07771971 * pow(h, 1.16364243));\n}\n\n/*\n * Return the molecular volume absorption coefficient (km^-1) for a given altitude\n * in kilometers.\n */\nvec4 get_molecular_absorption_coefficient(float h)\n{\n    h += 1e-4; // Avoid division by 0\n    float t = log(h) - 3.22261;\n    float density = 3.78547397e20 * (1.0 / h) * exp(-t * t * 5.55555555);\n    return ozone_absorption_cross_section * ozone_mean_monthly_dobson[MONTH] * density;\n}\n\nfloat get_aerosol_density(float h)\n{\n#if AEROSOL_TYPE == 0 // Only for the Background aerosol type, no dependency on height\n    return aerosol_base_density * (1.0 + aerosol_background_divided_by_base_density);\n#else\n    return aerosol_base_density * (exp(-h / aerosol_height_scale)\n        + aerosol_background_divided_by_base_density);\n#endif\n}\n\n/*\n * Get the collision coefficients (scattering and absorption) of the\n * atmospheric medium for a given point at an altitude h.\n */\nvoid get_atmosphere_collision_coefficients(in float h,\n                                           out vec4 aerosol_absorption,\n                                           out vec4 aerosol_scattering,\n                                           out vec4 molecular_absorption,\n                                           out vec4 molecular_scattering,\n                                           out vec4 extinction)\n{\n    h = max(h, 0.0); // In case height is negative\n#if ENABLE_AEROSOLS == 0\n    aerosol_absorption = vec4(0.0);\n    aerosol_scattering = vec4(0.0);\n#else\n    float aerosol_density = get_aerosol_density(h);\n    aerosol_absorption = aerosol_absorption_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n    aerosol_scattering = aerosol_scattering_cross_section * aerosol_density * AEROSOL_TURBIDITY;\n#endif\n    molecular_absorption = get_molecular_absorption_coefficient(h);\n    molecular_scattering = get_molecular_scattering_coefficient(h);\n    extinction = aerosol_absorption + aerosol_scattering + molecular_absorption + molecular_scattering;\n}\n\n//-----------------------------------------------------------------------------\n// Spectral rendering stuff\n\nconst mat4x3 M = mat4x3(\n    137.672389239975, -8.632904716299537, -1.7181567391931372,\n    32.549094028629234, 91.29801417199785, -12.005406444382531,\n    -38.91428392614275, 34.31665471469816, 29.89044807197628,\n    8.572844237945445, -11.103384660054624, 117.47585277566478\n);\n\nvec3 linear_srgb_from_spectral_samples(vec4 L)\n{\n    return M * L;\n}", "buffer_b_code": "/*\n * Buffer B: Sky texture\n *\n * \"A Scalable and Production Ready Sky and Atmosphere Rendering Technique\"\n * by Sbastien Hillaire (2020).\n *\n * We render the sky to a texture instead of raymarching on the entire screen.\n * This is not very useful in Shadertoy, but very useful for someone looking\n * to implement this on a real application.\n *\n * It is important to note that quality decreases significantly when rendering\n * space views. To avoid this, the compute_inscattering() function can be used\n * directly when rendering to a fullscreen quad.\n */\n \nvec4 compute_inscattering(vec3 ray_origin, vec3 ray_dir, float t_d, out vec4 transmittance)\n{\n    vec3 sun_dir = get_sun_direction(iTime);\n    float cos_theta = dot(-ray_dir, sun_dir);\n\n    float molecular_phase = molecular_phase_function(cos_theta);\n    float aerosol_phase = aerosol_phase_function(cos_theta);\n\n    float dt = t_d / float(IN_SCATTERING_STEPS);\n\n    vec4 L_inscattering = vec4(0.0);\n    transmittance = vec4(1.0);\n\n    for (int i = 0; i < IN_SCATTERING_STEPS; ++i) {\n        float t = (float(i) + 0.5) * dt;\n        vec3 x_t = ray_origin + ray_dir * t;\n\n        float distance_to_earth_center = length(x_t);\n        vec3 zenith_dir = x_t / distance_to_earth_center;\n        float altitude = distance_to_earth_center - EARTH_RADIUS;\n        float normalized_altitude = altitude / ATMOSPHERE_THICKNESS;\n\n        float sample_cos_theta = dot(zenith_dir, sun_dir);\n\n        vec4 aerosol_absorption, aerosol_scattering;\n        vec4 molecular_absorption, molecular_scattering;\n        vec4 extinction;\n        get_atmosphere_collision_coefficients(\n            altitude,\n            aerosol_absorption, aerosol_scattering,\n            molecular_absorption, molecular_scattering,\n            extinction);\n\n        vec4 transmittance_to_sun = transmittance_from_lut(\n            iChannel0, sample_cos_theta, normalized_altitude);\n\n        vec4 ms = get_multiple_scattering(\n            iChannel0, sample_cos_theta, normalized_altitude,\n            distance_to_earth_center);\n\n        vec4 S = sun_spectral_irradiance *\n            (molecular_scattering * (molecular_phase * transmittance_to_sun + ms) +\n             aerosol_scattering   * (aerosol_phase   * transmittance_to_sun + ms));\n\n        vec4 step_transmittance = exp(-dt * extinction);\n\n        // Energy-conserving analytical integration\n        // \"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\"\n        // by Sbastien Hillaire\n        vec4 S_int = (S - S * step_transmittance) / max(extinction, 1e-7);\n        L_inscattering += transmittance * S_int;\n        transmittance *= step_transmittance;\n    }\n\n    return L_inscattering;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float azimuth = 2.0 * PI * uv.x;\n\n    // Apply a non-linear transformation to the elevation to dedicate more\n    // texels to the horizon, where having more detail matters.\n    float l = uv.y * 2.0 - 1.0;\n    float elev = l*l * sign(l) * PI * 0.5; // [-pi/2, pi/2]\n\n    vec3 ray_dir = vec3(cos(elev) * cos(azimuth),\n                        cos(elev) * sin(azimuth),\n                        sin(elev));\n\n    vec3 ray_origin = vec3(0.0, 0.0, EYE_DISTANCE_TO_EARTH_CENTER);\n\n    float atmos_dist  = ray_sphere_intersection(ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n    float ground_dist = ray_sphere_intersection(ray_origin, ray_dir, EARTH_RADIUS);\n    float t_d;\n    if (EYE_ALTITUDE < ATMOSPHERE_THICKNESS) {\n        // We are inside the atmosphere\n        if (ground_dist < 0.0) {\n            // No ground collision, use the distance to the outer atmosphere\n            t_d = atmos_dist;\n        } else {\n            // We have a collision with the ground, use the distance to it\n            t_d = ground_dist;\n        }\n    } else {\n        // We are in outer space\n        if (atmos_dist < 0.0) {\n            // No collision with the atmosphere, just return black\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        } else {\n            // Move the ray origin to the atmosphere intersection\n            ray_origin = ray_origin + ray_dir * (atmos_dist + 1e-3);\n            if (ground_dist < 0.0) {\n                // No collision with the ground, so the ray is exiting through\n                // the atmosphere.\n                float second_atmos_dist = ray_sphere_intersection(\n                    ray_origin, ray_dir, ATMOSPHERE_RADIUS);\n                t_d = second_atmos_dist;\n            } else {\n                t_d = ground_dist - atmos_dist;\n            }\n        }\n    }\n\n    vec4 transmittance;\n    vec4 L = compute_inscattering(ray_origin, ray_dir, t_d, transmittance);\n\n#if ENABLE_SPECTRAL == 1\n    fragColor = vec4(linear_srgb_from_spectral_samples(L), 1.0);\n#else\n    fragColor = vec4(L.rgb, 1.0);\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msXXDS.jpg", "access": "api", "license": "mit", "functions": [[2392, 2392, 2422, 2422, 2546], [2548, 2548, 2578, 2578, 2721], [2804, 2804, 2842, 2842, 3016], [3018, 3018, 3090, 3090, 3376], [3378, 3378, 3458, 3458, 3558], [3560, 3560, 3580, 3580, 3650], [3651, 3651, 3671, 3671, 3741], [3742, 3742, 3762, 3762, 3832], [3834, 3834, 3909, 3909, 4256], [4258, 4258, 4313, 4313, 5541]], "test": "untested"}
{"id": "cl2SRm", "name": "Non-continious texture rotation", "author": "djancool", "description": "Texture rotation with non continious UVs", "tags": ["rotation", "continious"], "likes": 3, "viewed": 216, "published": 3, "date": "1675857522", "time_retrieved": "2024-07-30T18:11:30.125389", "image_code": "#define PI 3.1415926535\n\nfloat s_curve (float i, float mul, float p)\n{\n    float x_floor = floor(i * mul);\n    float x = i * mul - x_floor;\n    float x_1m = 1.0 - x;\n    float x_p1 = pow(x, p);\n    float x_p2 = pow(x_1m, p);\n    float curve = x_p1 / (x_p1 + x_p2);\n    return curve + x_floor;\n}\n\nvec2 rotate(vec2 uv, float th)\n{\n    return mat2(cos(th), sin(th),\n               -sin(th), cos(th)) * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * vec2(1.0, iResolution.y / iResolution.x);\n\n    uv = fract(uv * 3.0);\n    \n    float speed = 0.07;\n    float curve = s_curve(iTime, speed * 4.0, 10.0);\n\n    float mul_x1 = cos(iTime * speed * PI * 2.0 + 0.35 * PI);\n    mul_x1 *= mul_x1;\n    float mul_x2 = 1.0 - mul_x1;\n    float mul_x1_p = pow(mul_x1, 8.0);\n    float mul_curve = mul_x1_p / (mul_x1_p + pow(mul_x2, 8.0));\n    float mul_final = mix(1.0, sqrt(2.0), mul_curve);\n\n\n\n    float rotation = curve * PI / 4.0;// + PI / 4.0;\n    vec2 uv_rot = rotate((uv - 0.5) * mul_final, rotation) + 0.5;\n    \n\n\n    vec3 col = texture(iChannel0, uv_rot, 0.0).rgb;\n    //col = vec3(uv, 0.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2SRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 70, 70, 294], [296, 296, 328, 328, 404], [406, 406, 463, 513, 1253]], "test": "untested"}
{"id": "ct2Szw", "name": "ripple_xiao", "author": "The_King_Of_Shader", "description": "ripple normal", "tags": ["normal"], "likes": 2, "viewed": 177, "published": 3, "date": "1675850171", "time_retrieved": "2024-07-30T18:11:31.090808", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy) - vec2(0.5);\n    vec2 uv2 = (fragCoord/iResolution.xy) - vec2(0.5,0.505);\n    vec2 uv3 = (fragCoord/iResolution.xy) - vec2(0.505,0.5);\n    float Circle = (length(uv) + (5.*(iTime*-0.02))) * 40.;\n    float Circle2 = (length(uv2) + (5.*(iTime*-0.02))) * 40.;\n    float Circle3 = (length(uv3) + (5.*(iTime*-0.02))) * 40.;\n\n    float Cc = (sin(Circle)+1.)/2.;\n    float Cc2 = (sin(Circle2)+1.)/2.;\n    float Cc3 = (sin(Circle3)+1.)/2.;\n    float intensity = 10.;\n    float Cy = (Cc-Cc2) * intensity;\n    float Cx = (Cc-Cc3) * intensity;\n\n    vec3 Result = normalize(cross(vec3(1,0,Cy),vec3(0,1,Cx)));\n    Result *= vec3(1.,1.,Result.z*10.);\n    fragColor=vec4(vec3(Result),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2Szw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 770]], "test": "untested"}
{"id": "cljSRw", "name": "Black and blue rug", "author": "jarble", "description": "Another fractal rug pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 11, "viewed": 226, "published": 3, "date": "1675840166", "time_retrieved": "2024-07-30T18:11:31.849779", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    vec2 uv = (fragCoord)/iResolution.y/2.0;\n    uv.x += iTime/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy;\n    \n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n    \n        //uv.y += t1_(floor(uv),floor(uv));\n        \n        uv = (uv+t2)/1.5;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        t2 = triangle_wave(uv+.5);\n        uv = t2-triangle_wave(uv.yx+1.)/1.5;\n        //log-polar stuff\n        //uv=vec2(log(length(uv/3.)), atan(uv.y/3., uv.x/3.))/3.;\n        //if(uv.x>uv.y) uv.y += .5;\n        col.x =\n            max((t2.y+t2.x)/3.,col.x)\n        ;\n        col =\n            abs(col-1.+col.x);\n        //if(uv.y<.5) {uv=uv.yx;t2=t2.yx;}\n\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 162], [279, 279, 305, 305, 394], [396, 396, 453, 453, 1243]], "test": "untested"}
{"id": "mtSXRm", "name": "texture loader", "author": "tianluo97", "description": "texture loader", "tags": ["textureloader"], "likes": 0, "viewed": 183, "published": 3, "date": "1675828803", "time_retrieved": "2024-07-30T18:11:32.645651", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 target_resolution = vec2(940, 84);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;   \n    \n    // get pixel information from uv location\n    vec4 texColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(texColor);\n    // Output to screen\n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 931]], "test": "untested"}
{"id": "mtBSRm", "name": "gradient color horizontal  2", "author": "tianluo97", "description": "gradient color horizontal 2", "tags": ["gradientcolorhorizontal2"], "likes": 0, "viewed": 153, "published": 3, "date": "1675828292", "time_retrieved": "2024-07-30T18:11:33.683875", "image_code": "\n\n//The shader code that embeds a 938x84 frame buffer at its largest size without stretching the input\n\nconst vec2 target_resolution = vec2(940, 86);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n\tuv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //color1/2/3\n    vec4 color1 = vec4(0.639,0.263,0.263,1.0); \n    vec4 color2 = vec4(1.000,0.722,0.478,1.0);\n    vec4 color02 = vec4(0.502,0.667,1.000,1.0);\n    vec4 color3 = vec4(0.000,0.267,1.000,1.0);\n    \n    float PI = 3.1415926;\n    float time = iTime * 0.04; \n    \n    //scale\n    float scale = 1.0;\n    //colorStep1\n    float colorStep1 = 0.2;\n    //colorStep2\n    float colorStep2 = 0.4;\n    float colorStep3 = 1.5;\n    float colorStep4 = 1.9;\n    \n    //float offset  =  floor(time/scale)*scale;\n    float offset = uv.x ;\n    float y = offset;\n    \n    //float y = offset; \n    \n    float step1 = (colorStep1);\n    float step2 = (colorStep2); \n    float step3 = (colorStep3); \n    float step4 = (colorStep3);\n    \n    if (y < step1) {\n    float dist1 = smoothstep(0.0, step1, y);\n    fragColor = mix(color1, color2, dist1);\n    }\n    \n    // step1 - step2\n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    fragColor = vec4(dist2,dist2,dist2,1.0);\n    fragColor = mix(color2, color02, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    fragColor = vec4(dist02,dist02,dist02,1.0);\n    fragColor = mix(color02, color3, dist02);\n    }\n    \n    // step2 - 1.0\n    else if (y > step3 && y < step4){\n    float dist3 = smoothstep(step3, 1.0 * scale, y);\n    fragColor = vec4 (dist3,dist3,dist3,1.0);\n    fragColor = color3;\n    }\n    \n    fragColor = sqrt(fragColor);\n    \n    float atmosphere = sqrt(1.0-uv.x);\n    \n    //vec3 skyColor = vec3(fragColor.rgb);\n    vec3 skyColor = vec3(0.2,0.4,0.8);\n     \n    float scatter = pow((sin(iTime * .5) * 0.5 + 0.5),1.0 / 1.0);\n    //float scatter = pow(iMouse.x / iResolution.x,1.0 / 15.0);\n    //scatter = clamp(scatter,0.2,1.0);\n    \n    vec3 scatterColor = mix(vec3(1.000,0.412,0.161), vec3(1.000,0.816,0.561)*1.2, scatter);\n    vec3 skyColors = mix(fragColor.rgb,skyColor,scatter);\n    \n    //vec3 color = vec3(atmosphere/1.3,atmosphere/1.3,atmosphere/1.3);\n    vec3 color = mix(skyColors,vec3(scatterColor),pow(atmosphere/1.3,1.5));\n    \n    fragColor = vec4(color,1.0);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 208, 245, 3032]], "test": "untested"}
{"id": "dt2XzD", "name": "subgrid test", "author": "lennyjpg", "description": "sdfgsdfg", "tags": ["dfsgsdfg"], "likes": 1, "viewed": 193, "published": 3, "date": "1675810315", "time_retrieved": "2024-07-30T18:11:34.542579", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    //vec2 u = fract(uv * 10.0);\n    //float g = min(u.x,u.y);\n    vec2 f = fragCoord.xy * .005;\n    vec2 m = fract(f);\n    vec2 i = floor(f);\n    float k = ceil(min(m.x, m.y) - .004);\n\n    float z = step(i.x, 1.) * step(i.y, .0);\n    k -= z;\n    \n    \n    vec2 r = fract(m * 8.);\n    \n    \n    vec2 id = vec2(3.0, 7.0);\n    vec2 ii = floor(r * 8.0);\n    \n    float h = step(id.x, ii.x) * step(id.y, ii.y);\n    \n    float s = ceil(min(r.x, r.y) - .04);\n    \n    float grid = 1.0 - k - s;\n    //grid = max(grid,h);\n    fragColor = vec4(grid);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2XzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 640]], "test": "untested"}
{"id": "DlSXzm", "name": "JWST diffraction kernel smaller", "author": "michael0884", "description": "8 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera", "svd"], "likes": 19, "viewed": 406, "published": 3, "date": "1675807944", "time_retrieved": "2024-07-30T18:11:36.451475", "image_code": "// Fork of \"JWST diffraction kernel\" by michael0884. https://shadertoy.com/view/clBSzm\n// 2023-02-07 22:12:08\n\n#define exposure 3.5\n#define sqrexposure 0.5\n#define gamma 1.3\n#define bloom 10.0\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*(1.0+sqrexposure*c)*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 1.0*acc.xyz/acc.w + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 2.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nvec4 project(mat3 cam_mat, vec3 cam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(cam_pos, p);\n    vec3 dir = (p - cam_pos)/td;\n    vec3 screen = dir*cam_mat;\n    return vec4(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, screen.z, td);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 8 columns of the U matrix: \nfloat U[1016] = float[](-1.1842E-07, -1.1268E-06, -1.8904E-06, -3.1583E-06, -5.3096E-06, -1.0118E-05, -1.4520E-05, -1.9462E-05, -2.0183E-05, -2.6224E-05, -3.1880E-05, -4.3602E-05, -5.1091E-05, -5.1760E-05, -6.1062E-05, -7.6017E-05, -9.4007E-05, -1.1207E-04, -1.2179E-04, -1.5626E-04, -1.4159E-04, -1.6448E-04, -1.8274E-04, -2.9349E-04, -3.4950E-04, -4.4876E-04, -7.0126E-04, -6.1299E-04, -5.3111E-04, -4.6782E-04, -3.9730E-04, -4.1987E-04, -4.1421E-04, -3.5734E-04, -5.5319E-04, -5.8685E-04, -6.3378E-04, -6.1371E-04, -7.0697E-04, -5.2489E-04, -7.3274E-04, -7.7262E-04, -1.1158E-03, -9.6932E-04, -1.1427E-03, -9.4501E-04, -1.3424E-03, -1.7172E-03, -2.2912E-03, -2.3970E-03, -2.0727E-03, -2.3740E-03, -2.8899E-03, -4.7924E-03, -6.1480E-03, -7.9435E-03, -5.8779E-03, -1.0120E-02, -1.0679E-02, -2.6083E-02, -3.9506E-02, -6.9328E-02, -1.2810E-01, -5.3082E-01, -7.8470E-01, -2.6500E-01, -7.7895E-02, -3.6887E-02, -2.0966E-02, -1.0654E-02, -1.1517E-02, -9.3575E-03, -8.7508E-03, -5.6306E-03, -3.8273E-03, -2.2770E-03, -3.1324E-03, -2.6593E-03, -2.6659E-03, -2.0236E-03, -1.3645E-03, -1.0555E-03, -1.1805E-03, -1.2382E-03, -1.0703E-03, -9.4232E-04, -5.7082E-04, -6.9208E-04, -5.0356E-04, -7.2157E-04, -6.0580E-04, -6.6006E-04, -4.1296E-04, -4.8194E-04, -3.4413E-04, -4.1653E-04, -3.7708E-04, -3.3201E-04, -4.1427E-04, -3.6365E-04, -6.6114E-04, -4.0746E-04, -5.8100E-04, -2.9378E-04, -2.4748E-04, -1.5735E-04, -1.6160E-04, -1.5220E-04, -1.2811E-04, -1.1806E-04, -8.5893E-05, -8.3745E-05, -5.9893E-05, -8.0787E-05, -4.2347E-05, -4.4772E-05, -2.7607E-05, -2.6821E-05, -1.7801E-05, -2.0396E-05, -1.3303E-05, -7.9177E-06, -5.3451E-06, -3.1342E-06, -1.6786E-06, -7.0085E-07, -1.1687E-07, 1.4463E-07, 1.4833E-06, 1.6108E-05, 1.8564E-05, 3.3743E-05, 3.4312E-05, 5.5497E-05, 4.9054E-05, 7.6169E-05, 9.2412E-05, 1.3336E-04, 1.2618E-04, 2.2849E-04, 2.4331E-04, 2.4988E-04, 2.8219E-04, 2.3151E-04, 3.9522E-04, 5.5677E-04, 6.3214E-04, 7.5057E-04, 8.8708E-04, 9.0286E-04, 1.9325E-03, 1.6495E-03, 9.2766E-04, -4.7289E-04, 2.5727E-04, 1.3712E-03, 3.3028E-03, 2.6754E-03, 2.1479E-03, 1.9157E-03, 1.8775E-03, 1.8521E-03, 1.5187E-03, 2.1556E-03, 2.0944E-03, 1.8656E-03, 2.3806E-03, 3.0628E-03, 2.9234E-03, 3.7553E-03, 3.5235E-03, 3.8380E-03, 3.0398E-03, 4.6163E-03, 6.2841E-03, 8.7218E-03, 9.3776E-03, 8.4922E-03, 9.3318E-03, 1.1138E-02, 2.1680E-02, 2.7147E-02, 3.8475E-02, 3.1002E-02, 6.5136E-02, 5.9308E-02, 1.8594E-01, 2.9989E-01, 5.3655E-01, 3.1424E-01, -3.3517E-01, -1.6647E-02, 1.5694E-01, 4.7189E-01, 2.7447E-01, 1.5780E-01, 7.5950E-02, 7.2050E-02, 4.9178E-02, 4.0426E-02, 2.5631E-02, 1.7025E-02, 9.8987E-03, 1.2105E-02, 1.0120E-02, 1.0654E-02, 7.0982E-03, 4.9285E-03, 3.3771E-03, 4.0624E-03, 4.3698E-03, 4.0031E-03, 3.2964E-03, 2.1512E-03, 3.0137E-03, 1.9981E-03, 2.9746E-03, 1.8669E-03, 1.2566E-03, 1.3391E-03, 1.8105E-03, 1.9485E-03, 1.8028E-03, 1.9581E-03, 1.8266E-03, 3.3485E-03, 1.1361E-03, 1.4591E-04, 5.6091E-04, 3.8344E-04, 1.3298E-03, 2.1011E-03, 8.2035E-04, 8.8784E-04, 7.7448E-04, 5.4267E-04, 4.3268E-04, 2.6727E-04, 2.6458E-04, 1.9542E-04, 2.1589E-04, 2.1453E-04, 2.2156E-04, 1.1407E-04, 1.0476E-04, 8.0254E-05, 7.2416E-05, 5.3804E-05, 3.4371E-05, 2.2517E-05, 1.4718E-05, 1.2217E-05, 4.6752E-06, 4.5840E-07, -1.3986E-07, 1.4055E-06, 7.1329E-06, 7.3636E-06, 2.2637E-05, 2.5255E-05, 3.9108E-05, 4.0821E-05, 4.7760E-05, 1.5074E-05, 4.8742E-05, 8.5952E-05, 1.6267E-04, 1.6654E-04, -6.2004E-06, 2.0443E-04, 2.9354E-04, 3.3853E-04, 1.7896E-04, 2.0102E-04, 4.4367E-04, 6.9715E-04, 5.7989E-04, 9.7945E-04, 3.7509E-04, -6.4461E-04, 1.5830E-03, 5.5595E-04, -6.8815E-04, 1.3470E-03, 1.5266E-03, 1.5022E-03, 1.5055E-03, 1.2135E-03, 1.1252E-03, 9.0971E-04, 4.4536E-05, 9.7942E-04, 1.9424E-03, 1.6564E-03, 1.6649E-03, 2.2395E-03, 3.3719E-03, 2.6467E-03, 2.9967E-03, 2.0581E-03, 1.9493E-03, 4.2649E-03, 7.0853E-03, 6.2122E-03, 5.1677E-03, 5.3765E-03, 5.1721E-03, 1.3677E-02, 2.2610E-02, 2.7237E-02, 1.5351E-02, 4.5004E-02, 3.1812E-02, 1.1541E-01, 1.7171E-01, 2.0486E-01, -6.0355E-01, 1.2002E-01, 1.7822E-01, -6.5902E-01, 2.0725E-01, 8.1584E-02, 9.1843E-02, 4.5420E-02, 4.9064E-02, 3.2752E-02, 3.4261E-02, 1.7524E-02, 1.1157E-02, 5.8959E-03, 8.4160E-03, 7.1582E-03, 8.5606E-03, 4.3777E-03, 2.5106E-03, 2.4818E-03, 2.3451E-03, 3.0409E-03, 2.9541E-03, 1.4197E-03, 1.3194E-03, 2.2430E-03, 1.1572E-03, 7.8224E-04, 1.4828E-03, 1.5843E-03, 8.0175E-04, 1.8164E-04, 1.0363E-03, 1.2883E-03, 1.7222E-03, 1.2470E-03, 1.5805E-03, 1.5452E-04, -2.0298E-05, 3.1041E-04, -5.9129E-04, 4.1049E-04, 9.5067E-04, 4.9391E-04, 6.8072E-04, 5.3541E-04, 3.6504E-04, 4.5690E-04, 9.7131E-05, 1.5461E-06, 1.4411E-04, 1.8709E-04, 1.2732E-04, 1.0275E-04, 3.7932E-05, 7.2567E-05, 4.9384E-05, 7.2063E-05, 1.1900E-05, 1.4089E-05, 9.5806E-06, 1.0888E-05, 7.1190E-06, 2.1145E-06, -2.8481E-07, -2.0808E-07, -1.1441E-06, 2.6323E-06, -2.2197E-05, -9.6269E-05, -7.6502E-05, -1.1998E-04, -1.3400E-04, -1.3794E-04, -1.9616E-04, -2.7960E-04, -2.7116E-04, -4.3342E-04, -4.4178E-04, -5.2718E-04, -5.4154E-04, -6.9522E-04, -1.0287E-03, -1.2396E-03, -1.4470E-03, -2.0271E-03, -2.4781E-03, -2.2805E-03, -8.0694E-04, -3.1239E-04, -1.2126E-03, -6.9329E-04, -1.0721E-03, -1.0577E-03, -5.6391E-04, -3.3837E-03, -5.0182E-03, -6.2891E-03, -3.4780E-03, -4.5980E-03, -4.6762E-03, -5.0195E-03, -5.3199E-03, -5.0057E-03, -4.1086E-03, -7.3481E-03, -7.6870E-03, -9.1904E-03, -8.5119E-03, -1.0481E-02, -8.9974E-03, -1.3308E-02, -1.6309E-02, -2.0217E-02, -2.3409E-02, -2.4379E-02, -2.9541E-02, -3.3726E-02, -5.9753E-02, -6.8949E-02, -1.2552E-01, -9.1361E-02, -2.4857E-01, -1.9051E-01, -4.9997E-01, 6.9002E-02, 2.5769E-01, -5.9676E-02, 1.2377E-01, -8.8209E-02, 1.2719E-02, 3.4866E-01, -2.1607E-02, -4.7137E-01, -2.5582E-01, -2.4290E-01, -1.4195E-01, -1.1893E-01, -7.3712E-02, -5.9086E-02, -2.8825E-02, -3.7095E-02, -2.5824E-02, -2.6522E-02, -1.8905E-02, -1.2832E-02, -1.0055E-02, -1.1751E-02, -1.0168E-02, -9.5540E-03, -8.4060E-03, -6.1575E-03, -6.9206E-03, -4.5594E-03, -4.8506E-03, -4.8827E-03, -4.0758E-03, -3.8925E-03, -3.4163E-03, -4.9951E-03, -4.4902E-03, -6.6062E-03, -3.4508E-03, -1.8571E-04, -1.4733E-03, -8.4898E-04, -1.3663E-03, -9.8791E-04, -6.2882E-04, 1.4457E-05, -2.5731E-03, -2.7623E-03, -1.9252E-03, -1.3962E-03, -1.1285E-03, -7.6226E-04, -7.4392E-04, -5.2286E-04, -3.3325E-04, -4.9703E-04, -3.7282E-04, -2.5934E-04, -2.0216E-04, -1.6318E-04, -1.1700E-04, -1.0089E-04, -8.4809E-05, -6.0893E-05, -3.8105E-05, -1.4640E-05, -1.1315E-06, 1.0142E-07, -5.6986E-09, 4.5482E-06, 1.1972E-05, 9.7439E-06, -8.2800E-06, 6.8823E-05, 1.9695E-04, 2.0334E-04, 2.9505E-04, 3.0152E-04, 4.0002E-04, 4.1516E-04, 5.1860E-04, 5.4109E-04, 7.3302E-04, 9.5887E-04, 1.1809E-03, 1.5416E-03, 1.9864E-03, 2.6092E-03, 3.4977E-03, 2.3385E-04, 3.4315E-04, 7.4666E-04, 1.4387E-03, 2.1693E-03, 1.2732E-03, 2.1410E-03, 2.1069E-03, 2.6995E-03, 1.7910E-03, -6.6255E-05, 3.7772E-03, 4.4252E-03, 8.6983E-03, 7.5941E-03, 8.2457E-03, 7.8083E-03, 7.1344E-03, 6.0625E-03, 5.9307E-03, 8.2654E-03, 1.4955E-02, 1.2896E-02, 1.5264E-02, 1.2642E-02, 1.6662E-02, 2.2948E-02, 3.6684E-02, 4.0494E-02, 3.6111E-02, 5.2751E-02, 5.1962E-02, 1.1070E-01, 1.4511E-01, 2.7768E-01, 1.6304E-01, 4.3346E-01, 2.5565E-02, -3.2357E-01, -8.2099E-02, 8.9262E-03, 3.5360E-02, -9.4649E-02, 7.3490E-02, -4.9100E-02, 6.3324E-03, 2.3862E-02, -4.5834E-01, -5.4193E-02, 3.6193E-01, 2.7427E-01, 2.6304E-01, 1.3232E-01, 1.1203E-01, 5.1831E-02, 6.5850E-02, 4.5660E-02, 4.3296E-02, 2.9091E-02, 2.0250E-02, 1.6593E-02, 1.6724E-02, 1.6259E-02, 1.5814E-02, 1.1095E-02, 6.6219E-03, 6.5643E-03, 6.6001E-03, 7.6387E-03, 6.3453E-03, 6.0779E-03, 7.3917E-03, 6.0495E-03, 8.1008E-03, 4.8710E-03, 2.1384E-05, 1.4095E-03, 2.3949E-03, 2.0756E-03, 1.7863E-03, 1.8432E-03, 1.6779E-03, 1.5548E-03, 1.0560E-03, -6.5864E-04, -9.9490E-04, 1.7738E-03, 2.9236E-03, 2.1578E-03, 1.3039E-03, 1.1549E-03, 7.8047E-04, 7.3195E-04, 5.1827E-04, 3.3413E-04, 3.2212E-04, 2.6121E-04, 2.5788E-04, 2.2388E-04, 2.0696E-04, 1.0483E-04, 6.3773E-05, 2.4840E-06, -5.7251E-06, 2.1219E-06, 1.5386E-07, -1.9325E-07, -3.3843E-06, -1.6232E-05, -3.5978E-05, -5.4628E-05, -5.2994E-05, -6.6725E-05, -2.2568E-04, -4.4814E-04, -4.2902E-04, -7.0873E-04, -6.3746E-04, -1.0746E-03, -1.3314E-03, -9.6957E-04, -1.7371E-03, -2.4332E-03, -2.8118E-03, -3.6241E-03, -1.1888E-03, 2.1266E-03, -1.1036E-03, -1.3934E-03, -2.5291E-03, -2.4587E-03, -2.8037E-03, -2.2383E-03, -3.5312E-03, -3.6468E-03, -3.1406E-03, -3.2082E-03, -4.8709E-03, 3.7874E-04, -1.8714E-03, -4.4649E-03, -1.2736E-02, -1.4626E-02, -1.4508E-02, -1.4339E-02, -1.3506E-02, -1.9189E-02, -1.9148E-02, -2.0512E-02, -2.3396E-02, -3.1659E-02, -2.9315E-02, -4.2450E-02, -4.8158E-02, -5.7996E-02, -9.0616E-02, -8.7779E-02, -1.3413E-01, -1.3095E-01, -2.3123E-01, -2.1518E-01, -3.8294E-01, -4.7607E-02, 4.6165E-01, 7.0595E-02, 1.8216E-02, 5.8674E-02, -2.4327E-02, -2.5407E-02, 9.4394E-02, -7.6313E-02, 4.3834E-02, 6.2640E-02, -1.2994E-02, -6.6501E-02, 4.5464E-02, 3.8608E-01, 8.6325E-02, -2.8019E-01, -2.3640E-01, -2.7927E-01, -1.1657E-01, -1.6194E-01, -9.4289E-02, -9.1289E-02, -6.2279E-02, -4.3740E-02, -3.3795E-02, -3.6711E-02, -2.8607E-02, -2.5586E-02, -2.1220E-02, -1.4112E-02, -1.7727E-02, -1.2365E-02, -1.3160E-02, -1.4973E-02, -1.3335E-02, -1.1514E-02, -9.9264E-03, 1.3642E-03, -1.9429E-03, -4.1643E-03, -2.9805E-03, -2.6087E-03, -2.8601E-03, -2.9031E-03, -2.5890E-03, -2.9460E-03, -1.7891E-03, -1.8489E-03, -1.3324E-03, -1.6377E-03, 1.0290E-03, 4.6797E-04, -2.6960E-03, -2.3670E-03, -2.7855E-03, -1.4945E-03, -1.3426E-03, -9.2186E-04, -9.5868E-04, -4.4823E-04, -5.3964E-04, -3.6392E-04, -3.3482E-04, -1.4800E-04, -8.9772E-05, 5.6629E-06, -2.8370E-05, -1.8058E-05, -3.5979E-06, 8.7336E-08, -1.4846E-07, -7.6951E-07, 1.0130E-05, 2.7537E-05, 3.4182E-05, 2.6285E-05, 3.6084E-05, 3.1324E-05, -8.4586E-05, 7.3620E-05, 3.2184E-04, 2.9374E-04, 4.1289E-04, 3.8378E-04, 5.9049E-04, 7.2917E-04, 4.9481E-04, 5.1693E-04, -4.1205E-06, -4.6489E-04, -5.5999E-04, 4.2064E-03, 9.7307E-04, -1.2896E-03, 2.0495E-03, 9.6883E-04, 8.8919E-04, 1.0859E-03, 1.5529E-03, 4.0707E-03, -2.4763E-03, 1.5676E-03, 8.3307E-03, 3.6040E-03, -1.4926E-03, 2.5850E-03, 4.6116E-03, 4.9138E-03, 7.9128E-03, 5.7110E-03, 8.7634E-03, 9.4021E-03, 1.0801E-02, 1.0315E-02, 1.7466E-02, 1.8266E-02, 2.0595E-02, 3.0293E-02, 2.5627E-02, 3.0977E-02, 2.8452E-02, 5.1451E-02, 3.6071E-02, 4.8361E-02, -1.4958E-02, -1.5883E-01, -5.8910E-02, -5.6192E-02, 9.7888E-02, 3.1809E-01, -5.3469E-01, -3.6185E-02, 6.5131E-02, 8.9556E-03, 1.5256E-02, -1.0577E-01, 1.6840E-01, 3.5046E-01, -4.3787E-01, 3.8137E-01, -4.2987E-02, -1.6431E-01, -1.2289E-01, 2.4638E-02, 3.1976E-02, 2.9520E-02, 5.2585E-02, 2.2756E-02, 3.6097E-02, 3.7465E-02, 1.9496E-02, 1.8912E-02, 2.1733E-02, 1.1341E-02, 1.1243E-02, 1.3835E-02, 9.5422E-03, 6.6832E-03, 6.4901E-03, 7.5146E-03, 6.1211E-03, 5.7607E-03, 1.3228E-03, 3.6667E-03, 3.3190E-04, -1.4869E-03, 6.5831E-03, 3.2047E-03, -4.6947E-04, 1.2519E-03, 7.8573E-04, 4.7969E-05, 1.4014E-03, 9.6334E-04, 1.7361E-03, 9.4349E-04, 1.9203E-04, 2.2358E-03, 2.2370E-04, -4.6138E-04, 1.3741E-05, 5.1833E-04, 2.8487E-04, 3.5370E-04, 3.0995E-04, 5.4557E-04, 1.9191E-04, 2.1404E-04, 8.0855E-05, 7.6876E-05, -1.6503E-06, 1.7532E-05, 3.0436E-05, 4.0315E-05, -1.9764E-05, 2.8286E-07, 4.2190E-07, 1.0808E-07, -8.8005E-06, -2.4938E-05, -5.4878E-05, -9.3547E-05, -1.5711E-04, -1.8324E-04, -2.0489E-04, -6.7677E-05, -7.1627E-04, -1.0888E-03, -1.3584E-03, -2.5041E-03, -2.3521E-03, -2.4585E-03, -2.9089E-03, -2.4915E-03, -4.8879E-04, 1.5836E-03, -8.3815E-04, -2.8598E-03, -2.1934E-03, -2.8042E-03, -4.3956E-03, -3.0688E-03, -4.2693E-03, -2.5438E-03, -3.7542E-03, -2.3067E-03, -5.2950E-03, -7.9212E-03, -7.6980E-03, -8.0600E-03, -7.5677E-03, -6.8961E-03, -5.1231E-03, -1.5650E-02, -2.0023E-02, -2.5566E-02, -2.3810E-02, -3.2229E-02, -3.5659E-02, -4.9800E-02, -4.7440E-02, -5.7319E-02, -5.7981E-02, -8.1028E-02, -9.9538E-02, -1.4565E-01, -2.0783E-01, -1.7831E-01, -2.6517E-01, -1.7910E-01, -1.5650E-01, -5.2811E-02, 4.4968E-01, 7.3049E-02, -8.2157E-02, 1.9113E-03, 1.0139E-01, -2.1165E-01, 1.4336E-02, -1.5300E-02, 1.1079E-01, -8.8319E-02, 2.5443E-02, 1.1459E-01, 7.5825E-02, -1.1198E-02, 7.5323E-02, -9.7695E-02, 5.6158E-02, 3.5723E-01, 7.0282E-02, -1.8135E-01, -1.3712E-01, -3.1946E-01, -1.9152E-01, -2.0738E-01, -1.2991E-01, -8.9762E-02, -6.7066E-02, -7.8146E-02, -5.5899E-02, -4.8227E-02, -4.1727E-02, -2.8759E-02, -3.9586E-02, -2.5691E-02, -2.8319E-02, -2.1719E-02, -1.5658E-02, -7.8352E-04, -5.7691E-03, -7.3061E-03, -1.0447E-02, -6.7558E-03, -5.3028E-03, -4.5919E-03, -3.5752E-03, -3.3239E-03, -3.3586E-03, -3.3679E-03, -3.3443E-03, -3.5184E-03, -1.6000E-03, -2.7235E-03, -2.2023E-03, -2.1572E-03, 1.2605E-03, 1.1386E-04, -2.0115E-03, -1.4996E-03, -2.6276E-03, -1.6889E-03, -2.0676E-03, -9.9676E-04, -9.8083E-04, -3.3572E-04, -2.1569E-04, -9.3434E-05, -1.2168E-04, -1.2691E-04, -5.9581E-05, -3.6944E-05, -2.0024E-06, 2.2023E-07); \n//The first 8 rows of the V matrix: \nfloat V[1016] = float[](-4.0560E-08, -4.0626E-07, -1.1689E-06, -2.4232E-06, -4.3205E-06, -7.3371E-06, -1.0366E-05, -1.3283E-05, -1.7876E-05, -2.6661E-05, -4.1659E-05, -3.7289E-05, -4.5122E-05, -5.0932E-05, -6.2483E-05, -6.6529E-05, -7.8474E-05, -8.9704E-05, -1.0291E-04, -1.2136E-04, -1.3834E-04, -1.4896E-04, -1.6407E-04, -1.8326E-04, -2.0360E-04, -2.2313E-04, -2.5784E-04, -2.7722E-04, -2.9957E-04, -3.0073E-04, -3.5880E-04, -3.8183E-04, -4.2341E-04, -4.6552E-04, -4.9116E-04, -5.2448E-04, -5.5809E-04, -5.9667E-04, -6.6199E-04, -7.1234E-04, -8.1250E-04, -8.3600E-04, -8.8302E-04, -9.2638E-04, -9.9054E-04, -1.1231E-03, -1.2340E-03, -1.3622E-03, -1.4120E-03, -1.5422E-03, -1.6289E-03, -1.7860E-03, -2.0306E-03, -2.2738E-03, -2.5888E-03, -2.7894E-03, -3.1568E-03, -3.6229E-03, -4.3806E-03, -5.6031E-03, -7.4077E-03, -1.0911E-02, -1.8938E-02, -8.6403E-02, -5.4678E-02, -1.6337E-02, -8.9915E-03, -6.7426E-03, -4.7868E-03, -3.8112E-03, -3.0963E-03, -2.6013E-03, -2.2945E-03, -2.0145E-03, -1.8253E-03, -1.5518E-03, -1.3632E-03, -1.2085E-03, -1.0664E-03, -9.9345E-04, -9.2006E-04, -8.4078E-04, -7.3407E-04, -6.7189E-04, -5.9277E-04, -5.2788E-04, -4.8632E-04, -4.5249E-04, -4.1273E-04, -3.5942E-04, -3.0702E-04, -2.7333E-04, -2.4229E-04, -2.2360E-04, -2.2654E-04, -2.1787E-04, -1.8650E-04, -1.5961E-04, -1.2435E-04, -1.0093E-04, -9.1354E-05, -1.0207E-04, -1.1099E-04, -1.0006E-04, -7.8609E-05, -4.9727E-05, -2.7173E-05, -2.2453E-05, -4.1255E-05, -4.6027E-05, -4.4826E-05, -3.8845E-05, -3.0548E-05, -1.3839E-05, -8.4681E-06, -1.3893E-05, -1.9984E-05, -2.6732E-05, -1.8135E-05, -9.8111E-06, -5.6260E-06, -3.4386E-06, -2.6902E-06, -1.8443E-06, -1.1458E-06, -4.6849E-07, -4.8747E-08, 4.1427E-09, 5.9485E-08, 2.0293E-07, 5.7744E-07, 9.0135E-07, 1.5350E-06, 3.2825E-06, 4.6007E-06, 1.2256E-05, 8.9220E-06, 5.7461E-06, 2.1317E-05, 1.6463E-05, 1.4172E-05, 8.7154E-06, 9.4366E-06, 1.0454E-05, 1.3281E-05, 1.6115E-05, 1.5910E-05, 1.5213E-05, 1.7335E-05, 2.3464E-05, 3.1168E-05, 2.5219E-05, 3.5207E-05, 3.6268E-05, 3.4441E-05, 3.1270E-05, 3.9408E-05, 4.6559E-05, 6.5493E-05, 5.5330E-05, 5.2947E-05, 5.5559E-05, 5.4084E-05, 5.9614E-05, 7.3723E-05, 6.7721E-05, 8.4431E-05, 9.0909E-05, 9.6004E-05, 1.1774E-04, 1.0265E-04, 9.2233E-05, 1.8103E-04, 1.4747E-04, 1.6374E-04, 1.5485E-04, 1.8228E-04, 1.9271E-04, 2.1377E-04, 2.1836E-04, 2.8028E-04, 3.4087E-04, 3.6097E-04, 5.0177E-04, 5.3661E-04, 8.9624E-04, 1.2516E-03, 2.4144E-03, 5.4027E-03, 1.3699E-02, -9.3176E-03, 3.5201E-03, 1.1839E-02, 3.7789E-03, 2.2072E-03, 1.0589E-03, 7.5203E-04, 5.1982E-04, 3.8439E-04, 3.6807E-04, 2.1326E-04, 2.5739E-04, 1.7986E-04, 2.0018E-04, 1.6147E-04, 1.2687E-04, 1.3974E-04, 9.3867E-05, 1.4961E-04, 1.1497E-04, 7.5357E-05, 9.0043E-05, 1.1637E-04, 6.8140E-05, 6.1853E-05, 6.1711E-05, 4.7506E-05, 4.8748E-05, 3.9391E-05, 2.6394E-05, 3.7103E-05, 3.8543E-05, 4.6716E-05, 5.0372E-05, 2.5778E-05, 2.8452E-05, 3.8910E-05, 2.4848E-05, 3.2436E-05, 2.4689E-05, 1.6132E-05, 2.6167E-05, 1.7047E-05, 1.2978E-05, 1.2913E-05, 1.0396E-05, 1.1761E-05, 9.1684E-06, 9.6291E-06, 6.8819E-06, 9.2066E-06, 1.1444E-05, 1.5092E-05, 1.6623E-05, 7.0725E-07, 1.1172E-05, 7.9277E-06, 3.7846E-06, 1.7605E-06, 9.9582E-07, 6.0473E-07, 2.7266E-07, 6.7569E-08, 4.3727E-09, 1.0404E-10, 1.2425E-08, 9.5860E-08, 2.4460E-07, 4.1698E-07, 2.8869E-07, 1.5672E-06, 2.5742E-06, 5.2553E-06, -9.6782E-06, 1.3490E-07, 2.2464E-06, 7.5401E-06, 8.0906E-06, 6.2611E-06, 9.1561E-06, 6.0188E-06, 5.9844E-06, 7.0737E-06, 5.0778E-06, 1.3088E-05, 1.0498E-05, 1.4859E-05, 7.4941E-06, 1.0834E-05, 1.3528E-05, 1.8767E-05, 2.3275E-05, 1.7075E-05, 1.4382E-05, 9.1739E-06, 2.9404E-05, 2.6641E-05, 3.6161E-05, 3.8820E-05, 2.3795E-05, 3.4498E-05, 3.8097E-05, 3.6464E-05, 5.4269E-05, 4.6567E-05, 5.6792E-05, 5.6473E-05, 3.8589E-05, 6.4943E-05, 6.2741E-05, 8.1464E-05, 8.7523E-05, 9.2495E-05, 7.9495E-05, 9.5805E-05, 1.2523E-04, 1.1283E-04, 1.7093E-04, 1.5174E-04, 2.1294E-04, 2.4516E-04, 2.8872E-04, 5.1937E-04, 6.1632E-04, 1.3872E-03, 2.2013E-03, 3.1529E-03, 6.4655E-03, -1.3635E-02, 3.1388E-03, 1.9597E-03, 8.9269E-04, 6.2775E-04, 3.5934E-04, 2.7026E-04, 2.0045E-04, 1.5805E-04, 1.4622E-04, 1.1965E-04, 9.9301E-05, 1.0369E-04, 5.9867E-05, 6.4634E-05, 7.6073E-05, 6.0950E-05, 6.6386E-05, 6.0367E-05, 3.5226E-05, 2.1277E-05, 5.8693E-05, 3.8447E-05, 3.9553E-05, 2.9658E-05, 2.1033E-05, 2.7512E-05, 2.1322E-05, 2.2052E-05, 1.8650E-05, 1.9219E-05, 2.1722E-05, 2.0256E-05, 1.2146E-05, -1.1082E-05, 1.9468E-05, 1.3132E-05, 1.7854E-05, 7.0756E-06, 1.5066E-06, 4.4850E-06, 7.2294E-06, 4.2075E-06, 5.3622E-06, 4.6265E-06, 5.2604E-06, 5.2291E-06, 5.2220E-06, 2.0807E-06, 5.9006E-06, 3.7837E-06, 6.0026E-06, -5.2784E-06, 3.3810E-06, -5.5313E-06, 3.0722E-06, 1.3393E-06, 3.5862E-07, 1.4186E-07, 8.1974E-08, 1.4389E-07, 3.6737E-08, 4.2531E-10, -2.1855E-09, -4.8183E-08, -2.4722E-07, -4.4172E-07, -1.0339E-06, -2.4231E-06, -4.2092E-06, -1.0520E-05, -2.6695E-06, -3.7255E-06, -4.4148E-06, -2.3779E-06, -2.7687E-05, -2.1889E-05, -1.5077E-05, -1.6918E-05, -1.4647E-05, -1.7795E-05, -2.0991E-05, -2.1219E-05, -2.6690E-05, -2.6819E-05, -3.0573E-05, -2.3541E-05, -3.3634E-05, -3.4654E-05, -4.5425E-05, -4.3096E-05, -4.0714E-05, -4.4392E-05, -4.2041E-05, -4.9920E-05, -7.6175E-05, -7.8084E-05, -7.4385E-05, -7.3842E-05, -8.4490E-05, -8.2444E-05, -9.9988E-05, -1.1571E-04, -1.3369E-04, -1.5359E-04, -9.2163E-05, -1.1241E-04, -1.2375E-04, -1.0721E-04, -1.9237E-04, -2.0655E-04, -2.3246E-04, -2.2944E-04, -2.4034E-04, -2.7086E-04, -3.0716E-04, -3.8551E-04, -4.1979E-04, -5.2958E-04, -6.3842E-04, -8.2966E-04, -1.3228E-03, -2.1097E-03, -4.2868E-03, -6.6301E-03, 4.4580E-03, 1.4473E-03, -5.3315E-04, 3.6998E-03, -7.0019E-03, -3.3463E-03, -1.8706E-03, -1.1406E-03, -7.1865E-04, -5.5728E-04, -4.0432E-04, -3.7799E-04, -2.9400E-04, -2.6320E-04, -2.0772E-04, -1.8417E-04, -1.7686E-04, -1.5273E-04, -1.5420E-04, -1.5480E-04, -8.0087E-05, -9.9763E-05, -6.9514E-05, -8.6816E-05, -1.0201E-04, -9.0184E-05, -7.6382E-05, -6.3632E-05, -5.8378E-05, -4.6581E-05, -4.4479E-05, -4.5071E-05, -4.9848E-05, -6.2378E-05, -2.0513E-05, -2.5070E-05, -2.8954E-05, -1.7295E-05, -4.3814E-05, -3.3086E-05, -2.1128E-05, -2.0418E-05, -1.5233E-05, -2.0877E-05, -1.7640E-05, -1.1781E-05, -1.3502E-05, -1.3325E-05, -1.1609E-05, -1.0641E-05, -1.2738E-05, -1.3628E-05, -1.8925E-05, -1.2707E-05, -1.6039E-07, -1.9634E-06, -5.2268E-07, -4.8456E-06, -5.1606E-06, -2.9846E-06, -1.2632E-06, -4.4111E-07, -2.6328E-07, -7.4318E-08, -3.4604E-09, 3.0765E-10, 2.9518E-08, 7.5014E-08, 2.9564E-07, 1.0607E-06, 2.9283E-06, 6.2079E-06, -1.9380E-06, 1.2748E-08, 1.6301E-06, 2.9936E-06, 4.1731E-06, -1.1433E-05, 2.2683E-05, 2.3803E-05, 1.9673E-05, 1.5693E-05, 1.3640E-05, 1.2442E-05, 2.0368E-05, 2.1108E-05, 2.4000E-05, 1.2881E-05, 2.0849E-05, 2.2808E-05, 2.7584E-05, 2.7086E-05, 2.2424E-05, 3.5190E-05, 3.5340E-05, 2.9465E-05, 3.1654E-05, 1.5647E-05, 6.3036E-05, 5.7442E-05, 5.6312E-05, 4.9849E-05, 5.4209E-05, 6.7253E-05, 9.0348E-05, 9.8468E-05, 3.3260E-05, 7.1626E-05, 7.1418E-05, 7.5651E-05, 8.9167E-05, 7.2964E-05, 1.4159E-04, 1.5592E-04, 1.7059E-04, 1.5485E-04, 1.8300E-04, 2.4626E-04, 2.5476E-04, 3.6175E-04, 3.9984E-04, 6.5040E-04, 8.3026E-04, 1.5865E-03, 3.0800E-03, 3.5738E-03, -4.7038E-03, 1.4071E-04, -4.0559E-04, -1.7963E-04, -3.0756E-05, -2.5816E-03, 4.6631E-03, 2.5182E-03, 1.4541E-03, 7.9614E-04, 5.2911E-04, 4.0284E-04, 2.6764E-04, 2.7508E-04, 1.6451E-04, 1.6307E-04, 1.4856E-04, 1.4401E-04, 1.4798E-04, 9.8304E-05, 3.7160E-05, 6.6925E-05, 6.2333E-05, 5.7489E-05, 2.1772E-05, 5.9916E-05, 8.9022E-05, 7.2952E-05, 4.2954E-05, 3.7677E-05, 4.0460E-05, 4.2864E-05, 5.0892E-05, 4.6654E-05, -5.4979E-07, 1.9871E-05, 2.5722E-05, 2.7764E-05, 2.5957E-05, -4.2428E-06, 2.0555E-05, 2.4890E-05, 1.5522E-05, 1.5058E-05, 6.8925E-06, 1.3922E-05, 1.6138E-05, 1.3254E-05, 1.0111E-05, 1.2876E-05, 1.2272E-05, 1.5101E-05, 1.6802E-05, 1.0325E-05, -5.2052E-06, 2.7889E-06, 2.0563E-06, 2.2334E-06, -1.0107E-06, 1.4021E-06, 3.0156E-06, 1.6477E-06, 5.1574E-07, 9.6182E-08, 1.5388E-08, 1.1472E-09, -9.4589E-10, -1.8381E-09, -9.7949E-08, -4.8260E-07, -1.5379E-06, -3.5385E-06, 2.5187E-06, -3.1261E-07, -8.1982E-07, -1.6130E-06, -2.7102E-06, -2.9854E-06, -5.3749E-06, 1.1265E-05, -1.7646E-05, -2.6108E-05, -2.0621E-05, -1.7309E-05, -1.9659E-05, -1.8875E-05, -1.9261E-05, -1.2136E-05, -1.9077E-05, -2.1875E-05, -2.9480E-05, -2.2344E-05, -1.0142E-05, -1.5934E-05, -2.4515E-05, -3.6000E-05, -3.3041E-05, -3.2467E-05, -3.7561E-05, -1.9646E-05, -5.9366E-05, -5.2202E-05, -6.3010E-05, -6.8941E-05, -7.9527E-05, -9.6389E-05, -3.9090E-05, -6.0161E-05, -6.8780E-05, -5.8626E-05, -7.6335E-05, -9.7565E-05, -9.4611E-05, -5.7401E-05, -1.5346E-04, -1.8218E-04, -1.8755E-04, -2.2630E-04, -2.4403E-04, -3.5808E-04, -4.4762E-04, -5.9594E-04, -9.5966E-04, -1.3274E-03, -2.3336E-03, -2.3054E-03, 3.2300E-03, -4.3511E-04, 1.9995E-05, 2.2932E-04, 1.1266E-04, 1.9388E-04, 2.1882E-04, 2.6861E-03, -2.8035E-03, -2.1150E-03, -1.2742E-03, -8.1431E-04, -5.0399E-04, -3.7419E-04, -2.9857E-04, -2.2027E-04, -2.0769E-04, -1.7422E-04, -1.6912E-04, -8.3005E-05, -5.3886E-05, -7.3360E-05, -6.4493E-05, -6.8803E-05, -5.6784E-05, -4.8814E-05, -2.0255E-05, -3.0117E-05, -9.1077E-05, -5.0524E-05, -5.2636E-05, -4.7189E-05, -4.8423E-05, -4.7231E-05, 2.8713E-06, -2.6744E-05, -2.3421E-05, -2.6408E-05, -3.2770E-05, -5.4575E-06, -1.3102E-05, 2.6037E-06, -2.2056E-05, -2.3068E-05, -1.7969E-05, -1.4106E-05, -7.7117E-06, -1.5745E-05, -1.5273E-05, -1.4366E-05, -1.5977E-05, -2.0079E-05, -1.8339E-05, -7.7230E-06, 6.3530E-06, -2.1022E-06, -1.8539E-06, -1.5450E-06, -9.6267E-07, -4.9281E-07, 1.1892E-06, 3.8612E-08, -1.6951E-06, -6.4221E-07, -1.4665E-07, 7.8817E-10, -9.1401E-10, 2.8591E-10, 1.6094E-08, 6.9741E-08, 9.6141E-08, 2.7943E-07, -2.4948E-07, -6.5518E-07, 4.7498E-06, -2.4125E-06, 8.8367E-07, 1.6850E-06, 6.2546E-06, -5.8853E-06, 2.7772E-07, -5.1780E-06, 5.6962E-06, 8.4048E-06, 6.3279E-06, 9.2723E-06, 7.3693E-06, 8.3664E-06, 1.0759E-05, 1.4258E-05, 9.1021E-06, 1.3469E-05, 1.1096E-05, 1.4923E-05, 1.0279E-06, 1.6104E-05, 1.7242E-05, 2.2679E-05, 3.0276E-05, 4.0980E-05, 1.5399E-05, 2.1861E-05, 3.1120E-05, 4.2819E-05, 4.5253E-05, 4.2770E-05, 3.1312E-05, 3.2992E-05, 4.6080E-05, 3.1328E-05, 5.5508E-05, 5.6536E-05, 5.5214E-05, 1.1669E-04, 3.6079E-05, 8.3957E-05, 6.9225E-05, 1.2273E-04, 1.2473E-04, 1.2324E-04, 2.1669E-04, 1.7784E-04, 3.2544E-04, 2.7434E-04, 3.9304E-04, 1.9683E-04, -1.1411E-03, 3.8066E-04, -3.0333E-03, 2.3454E-03, -2.9080E-05, -2.6970E-05, -2.3331E-03, 3.4948E-03, -1.0963E-03, -3.1326E-04, 2.4432E-04, 4.3717E-04, 3.5133E-04, 1.9504E-04, 2.9739E-04, 1.0322E-04, 1.6188E-04, 8.0120E-05, 9.4829E-05, 8.8803E-05, 2.4564E-05, 8.3642E-05, 6.0162E-07, 4.1875E-05, 2.9292E-05, 3.4439E-05, -2.4138E-05, 5.2836E-05, 2.1004E-05, 1.9543E-05, 2.9305E-05, 2.5540E-05, 2.3663E-05, 1.9338E-05, 9.1017E-06, 2.3367E-05, 2.1869E-05, 6.0331E-06, 6.2396E-06, 9.9920E-07, -5.0841E-06, 4.5947E-06, 3.2339E-06, -1.9026E-06, 6.7285E-06, 7.6016E-06, 3.3067E-06, 5.9648E-06, 2.7160E-06, 6.7814E-06, 4.8453E-06, 4.6000E-06, 3.1226E-06, 1.1827E-06, -5.2537E-06, 7.3462E-06, -5.5660E-06, 6.1196E-07, 4.0408E-07, 1.3228E-06, -1.3918E-08, 2.2442E-06, -3.7486E-07, -1.8754E-07, 1.9356E-07, 8.2093E-08, -5.3422E-09, 1.2252E-09, -1.5090E-09, 4.4204E-10, -1.1247E-07, -7.2768E-07, -9.5196E-07, 1.3259E-06, -6.0045E-07, -6.9856E-09, -2.6697E-06, -9.7818E-08, -2.0653E-06, -1.8382E-06, -3.8722E-06, -7.9283E-06, 8.5310E-06, -1.3081E-05, -2.6314E-05, -2.5846E-05, -2.7054E-05, -2.0534E-05, -1.4086E-05, -2.4103E-05, -2.3939E-05, -2.6941E-05, -1.8907E-05, -8.1211E-06, -1.7867E-05, -2.7650E-05, -1.6283E-05, -2.1280E-05, -3.1580E-05, -3.9585E-05, -3.3278E-05, -3.9107E-05, -1.8603E-05, -4.9623E-05, -8.0001E-05, -8.8524E-05, -6.9772E-05, -1.6695E-05, -3.6845E-05, -6.0485E-05, -6.6704E-05, -6.9867E-05, -7.4940E-05, -7.6158E-05, -8.0004E-05, -1.3402E-04, -5.7630E-05, -1.5889E-04, -2.0844E-04, -2.6210E-04, -3.5885E-04, -4.0866E-04, -6.5482E-04, -8.8421E-04, -1.4184E-03, -1.6827E-03, -6.1531E-04, 2.3553E-03, -5.2982E-04, -1.7656E-04, 9.2111E-04, 1.3879E-04, 4.7505E-05, -8.8394E-04, 7.0087E-04, -1.4540E-04, 2.0092E-03, -1.1659E-03, -1.7908E-03, -1.3216E-03, -7.5458E-04, -5.5785E-04, -3.8804E-04, -2.9402E-04, -2.6048E-04, -1.8853E-04, -1.1191E-04, -9.5011E-05, -8.9706E-05, -7.7328E-05, -4.9243E-05, -6.8638E-05, -5.7689E-05, -7.3813E-05, -4.6599E-05, -2.9500E-05, -2.3759E-05, -6.3654E-05, -6.8622E-05, -7.1993E-05, -3.7275E-05, -1.2875E-05, -3.2859E-05, -3.0903E-05, -3.1948E-05, -2.0636E-05, -7.5835E-06, -2.0395E-05, -1.4750E-05, -1.7624E-05, -4.7842E-06, -1.4858E-05, -2.2906E-05, -2.0636E-05, -1.5216E-05, -1.0787E-05, -1.6850E-05, -2.1365E-05, -2.5021E-05, -2.0606E-05, -3.7473E-06, 2.1635E-06, -3.1119E-06, -4.5331E-06, -2.2974E-06, -6.4970E-07, -2.7029E-07, -1.2578E-06, -2.8577E-07, 1.9964E-07, 1.7609E-07, -5.4128E-07, -1.5828E-07, -1.4164E-08, -2.0648E-09); \n//center of the convolution \nint Nc = 63; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 127; \n\n\n\n\n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 50.0\n\nvec2 pixPos;\nmat3 cammat;\nvec3 campos;\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\n//vec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n//{\n//    float r = region(pos);\n//    if(r < 0.5) return vec3(0.0);\n//    float temp = hash13(pos);\n//    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n//    vec3 spos = hash33(pos) + pos;\n//    vec4 screenPos = project(cammat, campos, iResolution.xy, spos);\n//    if(screenPos.z < 0.0) return vec3(0.0);\n//    float distr = k1(screenPos.xy - pixPos);\n//    return 100.0*heat * distr / (screenPos.w*screenPos.w);\n//}\n//\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.25*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec * pow(camdist, -2.25));\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    cammat = cam;\n    \n    ro = get(CamP).xyz;\n    campos = ro;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n    pixPos = floor(fragCoord);\n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(i, 0), 1);\n        vec3 pcolor = min(pow(pixel.xyz/(pixel.w+1e-6),vec3(1.3)), 5.0);\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x, coord.y + i);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 215, 215, 272], [274, 274, 297, 297, 342], [345, 345, 402, 402, 634]], "test": "untested"}
{"id": "clBSzm", "name": "JWST diffraction kernel", "author": "michael0884", "description": "8 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera", "svd"], "likes": 19, "viewed": 533, "published": 3, "date": "1675807724", "time_retrieved": "2024-07-30T18:11:37.734046", "image_code": "#define exposure 2.5\n#define sqrexposure 0.5\n#define gamma 1.3\n#define bloom 10.0\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*(1.0+sqrexposure*c)*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 1.0*acc.xyz/acc.w + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 10.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(1.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nvec4 project(mat3 cam_mat, vec3 cam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(cam_pos, p);\n    vec3 dir = (p - cam_pos)/td;\n    vec3 screen = dir*cam_mat;\n    return vec4(screen.xy*iRes.y/(FOV*screen.z) + 0.5*iRes.xy, screen.z, td);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n//center of the convolution \nint Nc = 128; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 257; \n\n\n\n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 150.0\n\nvec2 pixPos;\nmat3 cammat;\nvec3 campos;\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\n//vec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n//{\n//    float r = region(pos);\n//    if(r < 0.5) return vec3(0.0);\n//    float temp = hash13(pos);\n//    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n//    vec3 spos = hash33(pos) + pos;\n//    vec4 screenPos = project(cammat, campos, iResolution.xy, spos);\n//    if(screenPos.z < 0.0) return vec3(0.0);\n//    float distr = k1(screenPos.xy - pixPos);\n//    return 100.0*heat * distr / (screenPos.w*screenPos.w);\n//}\n//\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.25*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec * pow(camdist, -2.25));\n    bright /= 1e5 * CAM_ANGLE * CAM_ANGLE;\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    cammat = cam;\n    \n    ro = get(CamP).xyz;\n    campos = ro;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n    pixPos = floor(fragCoord);\n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//The first 8 columns of the U matrix: \nfloat U[2056] = float[](-9.3064E-09, -6.2540E-08, -1.5059E-07, -2.3127E-07, -2.7403E-07, -5.2400E-07, -5.5717E-07, -9.1952E-07, -1.0750E-06, -1.4150E-06, -2.2412E-06, -1.9396E-06, -2.9631E-06, -2.9163E-06, -4.3048E-06, -4.1777E-06, -4.5402E-06, -6.0569E-06, -6.0295E-06, -5.7045E-06, -6.9944E-06, -7.1242E-06, -1.0138E-05, -8.6457E-06, -9.6396E-06, -9.9045E-06, -1.0078E-05, -1.2042E-05, -1.1283E-05, -1.5585E-05, -1.7810E-05, -2.2608E-05, -1.9362E-05, -2.0662E-05, -2.4483E-05, -2.3685E-05, -2.9598E-05, -2.7160E-05, -2.7089E-05, -3.0545E-05, -2.7670E-05, -3.2719E-05, -3.4402E-05, -3.9286E-05, -4.5235E-05, -3.8583E-05, -5.2800E-05, -5.3293E-05, -6.6001E-05, -7.1495E-05, -8.0322E-05, -1.1989E-04, -1.3727E-04, -1.9703E-04, -2.1405E-04, -1.6042E-04, -1.1367E-04, -8.8173E-05, -8.8935E-05, -9.0152E-05, -7.5974E-05, -7.2682E-05, -7.1070E-05, -8.7405E-05, -7.8979E-05, -8.4043E-05, -9.3202E-05, -8.5261E-05, -1.1158E-04, -1.0233E-04, -1.2993E-04, -1.4479E-04, -1.3892E-04, -1.3907E-04, -1.4622E-04, -1.6743E-04, -1.4466E-04, -1.2868E-04, -1.3772E-04, -1.1461E-04, -1.6713E-04, -1.4149E-04, -1.5203E-04, -1.8411E-04, -1.5997E-04, -2.2362E-04, -1.7661E-04, -2.0551E-04, -2.2219E-04, -2.0751E-04, -3.0568E-04, -2.3044E-04, -3.3501E-04, -3.1015E-04, -2.9176E-04, -3.8539E-04, -2.9827E-04, -4.7527E-04, -3.8477E-04, -4.4127E-04, -5.5885E-04, -4.2880E-04, -6.8351E-04, -5.3125E-04, -7.4962E-04, -7.8321E-04, -6.7458E-04, -1.0590E-03, -8.9178E-04, -1.2075E-03, -1.1826E-03, -1.3100E-03, -1.8179E-03, -1.3229E-03, -2.2260E-03, -2.0777E-03, -2.5748E-03, -3.3302E-03, -2.7391E-03, -5.1881E-03, -4.5199E-03, -6.4976E-03, -8.4863E-03, -1.0205E-02, -1.8293E-02, -2.0276E-02, -5.1332E-02, -1.0302E-01, -3.8991E-01, -8.9230E-01, -1.7511E-01, -7.1701E-02, -2.8345E-02, -1.9877E-02, -1.4541E-02, -8.4724E-03, -8.3735E-03, -4.5405E-03, -5.2439E-03, -4.1029E-03, -2.7074E-03, -3.2085E-03, -2.0085E-03, -2.2688E-03, -1.6377E-03, -1.5444E-03, -1.7023E-03, -1.0290E-03, -1.3318E-03, -9.2632E-04, -9.6685E-04, -8.7533E-04, -6.4284E-04, -8.5999E-04, -5.4536E-04, -6.2960E-04, -5.2681E-04, -4.5685E-04, -5.6283E-04, -3.0901E-04, -4.6167E-04, -3.6283E-04, -3.4338E-04, -3.7569E-04, -2.6645E-04, -3.4781E-04, -2.5711E-04, -2.6070E-04, -2.5827E-04, -2.0279E-04, -2.2348E-04, -1.6857E-04, -1.9412E-04, -1.8988E-04, -1.5623E-04, -1.9587E-04, -1.3820E-04, -1.4906E-04, -1.2022E-04, -1.2726E-04, -1.4707E-04, -1.2261E-04, -1.5475E-04, -1.4258E-04, -1.4259E-04, -1.6048E-04, -1.2518E-04, -1.3455E-04, -9.9203E-05, -1.0236E-04, -9.0931E-05, -8.7813E-05, -9.0421E-05, -7.1139E-05, -7.7971E-05, -7.5347E-05, -8.5782E-05, -7.8262E-05, -6.8164E-05, -8.1663E-05, -8.1907E-05, -1.0434E-04, -1.4692E-04, -1.7910E-04, -1.6772E-04, -1.6669E-04, -1.3029E-04, -9.7845E-05, -6.0614E-05, -7.3569E-05, -4.4654E-05, -5.4878E-05, -4.2640E-05, -3.6700E-05, -4.3361E-05, -3.2807E-05, -3.4691E-05, -2.7142E-05, -2.6248E-05, -2.7811E-05, -2.4929E-05, -2.8542E-05, -2.5334E-05, -2.3407E-05, -1.9489E-05, -1.7362E-05, -1.8950E-05, -1.7667E-05, -1.7138E-05, -1.1694E-05, -1.0025E-05, -1.0489E-05, -6.5946E-06, -9.9687E-06, -7.1640E-06, -7.7112E-06, -7.9783E-06, -5.5467E-06, -5.7275E-06, -4.8617E-06, -4.2642E-06, -4.4404E-06, -3.7847E-06, -3.6126E-06, -2.3716E-06, -2.2540E-06, -1.9219E-06, -1.2920E-06, -1.3847E-06, -8.3414E-07, -7.3553E-07, -3.8079E-07, -3.0459E-07, -2.1531E-07, -8.8954E-08, -4.9293E-08, -4.3864E-09, 3.5171E-08, 4.2677E-07, 1.2969E-06, 2.5588E-06, 3.3606E-06, 5.4889E-06, 5.2288E-06, 8.8158E-06, 8.7014E-06, 1.1632E-05, 1.3313E-05, 1.5837E-05, 2.2171E-05, 1.9731E-05, 2.0717E-05, 2.9061E-05, 2.8519E-05, 4.0770E-05, 3.3416E-05, 5.0070E-05, 5.5039E-05, 5.2224E-05, 5.6117E-05, 4.9213E-05, 7.7858E-05, 7.8831E-05, 8.8486E-05, 1.0404E-04, 9.7901E-05, 1.1819E-04, 9.1643E-05, 9.9139E-05, 1.4181E-04, 1.4605E-04, 1.5715E-04, 1.2900E-04, 1.6623E-04, 1.7490E-04, 2.0336E-04, 2.5294E-04, 2.5845E-04, 3.0347E-04, 2.4645E-04, 2.7118E-04, 3.4176E-04, 3.3835E-04, 5.1916E-04, 5.1435E-04, 6.6496E-04, 8.0565E-04, 8.2884E-04, 9.1205E-04, 7.7707E-04, 2.6753E-04, 3.2313E-04, 7.0171E-04, 1.2009E-03, 1.0483E-03, 1.0909E-03, 9.4828E-04, 7.9332E-04, 7.0330E-04, 5.8185E-04, 6.4055E-04, 6.6651E-04, 6.5904E-04, 7.1506E-04, 6.7243E-04, 7.8931E-04, 7.2041E-04, 8.7447E-04, 7.2110E-04, 7.1315E-04, 8.6362E-04, 9.1776E-04, 8.9942E-04, 1.0028E-03, 1.0883E-03, 1.0873E-03, 8.5473E-04, 1.1839E-03, 1.0135E-03, 1.1057E-03, 1.1591E-03, 9.2415E-04, 1.4324E-03, 1.2111E-03, 1.4952E-03, 1.5789E-03, 1.4688E-03, 1.8758E-03, 1.4014E-03, 2.0951E-03, 2.0425E-03, 2.0373E-03, 2.7273E-03, 2.0167E-03, 3.2796E-03, 2.5827E-03, 3.0799E-03, 3.7594E-03, 2.9366E-03, 4.9786E-03, 3.9050E-03, 5.1299E-03, 5.7414E-03, 4.7616E-03, 7.8634E-03, 6.1746E-03, 8.7676E-03, 8.5059E-03, 9.7180E-03, 1.3732E-02, 1.0752E-02, 1.8192E-02, 1.6915E-02, 2.1593E-02, 2.8166E-02, 2.5810E-02, 4.7912E-02, 4.4558E-02, 6.9142E-02, 8.9637E-02, 1.2760E-01, 2.0665E-01, 2.7686E-01, 4.1574E-01, 3.6093E-01, 1.7203E-01, -2.5734E-01, 2.5116E-01, 3.8555E-01, 3.4884E-01, 2.3459E-01, 1.7246E-01, 9.9997E-02, 8.5828E-02, 5.1922E-02, 4.8119E-02, 3.7009E-02, 2.4275E-02, 2.7718E-02, 1.6803E-02, 1.8347E-02, 1.3145E-02, 1.1765E-02, 1.2657E-02, 7.8493E-03, 9.6836E-03, 6.9086E-03, 6.9126E-03, 6.7425E-03, 4.5163E-03, 6.1017E-03, 3.8587E-03, 4.4799E-03, 3.7681E-03, 3.2232E-03, 3.9917E-03, 2.2282E-03, 3.2221E-03, 2.4925E-03, 2.2692E-03, 2.5132E-03, 1.6852E-03, 2.2603E-03, 1.5006E-03, 1.6700E-03, 1.7988E-03, 1.4164E-03, 1.7099E-03, 1.1904E-03, 1.4134E-03, 1.1733E-03, 8.8708E-04, 1.2537E-03, 9.3735E-04, 1.0841E-03, 9.4647E-04, 1.0039E-03, 1.2043E-03, 8.8995E-04, 1.0127E-03, 7.6837E-04, 7.8775E-04, 7.7903E-04, 6.8945E-04, 8.4129E-04, 7.4891E-04, 7.8360E-04, 7.3610E-04, 6.4501E-04, 7.3493E-04, 5.6729E-04, 6.1499E-04, 5.8573E-04, 6.6431E-04, 7.8332E-04, 7.4000E-04, 8.8023E-04, 1.0607E-03, 1.0868E-03, 9.4641E-04, 5.6601E-04, 4.2500E-04, 5.0860E-04, 7.0311E-04, 8.3651E-04, 7.9226E-04, 6.8295E-04, 5.4530E-04, 5.0992E-04, 4.0465E-04, 3.4238E-04, 3.2407E-04, 2.3603E-04, 2.6421E-04, 2.2088E-04, 2.1665E-04, 2.2914E-04, 1.4495E-04, 1.6772E-04, 1.4397E-04, 1.3976E-04, 1.6064E-04, 1.1765E-04, 1.2956E-04, 8.9347E-05, 7.8016E-05, 1.0216E-04, 8.8248E-05, 8.5440E-05, 7.0123E-05, 7.4126E-05, 5.6697E-05, 5.4190E-05, 4.0393E-05, 3.6508E-05, 3.9030E-05, 3.3597E-05, 3.0583E-05, 3.0322E-05, 2.3019E-05, 2.1637E-05, 1.8472E-05, 1.7127E-05, 1.2944E-05, 1.0308E-05, 9.5219E-06, 5.6610E-06, 6.4478E-06, 3.8970E-06, 3.3005E-06, 1.9147E-06, 1.1174E-06, 4.7539E-07, 4.5651E-08, -9.2334E-10, 2.4972E-07, 1.1577E-06, 2.9916E-06, 5.5214E-06, 1.0271E-05, 1.2051E-05, 1.6849E-05, 1.4339E-05, 1.9313E-05, 2.5745E-05, 2.4405E-05, 2.6430E-05, 3.1941E-05, 3.3786E-05, 4.3321E-05, 3.3970E-05, 6.2722E-05, 5.2148E-05, 7.0326E-05, 5.9120E-05, 7.7766E-05, 1.0390E-04, 9.1284E-05, 9.6064E-05, 1.3979E-04, 1.5955E-04, 1.6420E-04, 1.2613E-04, 1.1183E-04, 1.6481E-04, 2.0535E-04, 1.6224E-04, 1.3142E-04, 2.5674E-04, 1.8007E-04, 2.7414E-04, 2.6782E-04, 2.5547E-04, 4.0871E-04, 4.3607E-04, 5.1930E-04, 4.7116E-04, 5.9741E-04, 7.2474E-04, 7.5999E-04, 1.0295E-03, 1.1771E-03, 1.0837E-03, 9.9629E-04, 6.3170E-04, 4.8577E-05, -1.9636E-04, 3.6019E-04, 3.3921E-04, -2.3040E-04, 3.0531E-04, 9.9825E-04, 1.9631E-03, 1.6888E-03, 1.7386E-03, 1.6564E-03, 1.4702E-03, 1.4198E-03, 1.3383E-03, 1.3160E-03, 1.3540E-03, 1.3840E-03, 1.2461E-03, 1.1557E-03, 1.1063E-03, 1.0708E-03, 1.0255E-03, 8.5328E-04, 5.5944E-04, 1.3049E-03, 1.3507E-03, 1.3797E-03, 1.6403E-03, 1.4701E-03, 2.0467E-03, 1.6485E-03, 1.6534E-03, 1.9465E-03, 1.8042E-03, 2.2215E-03, 1.9918E-03, 2.3378E-03, 2.4119E-03, 2.1647E-03, 3.0505E-03, 2.2893E-03, 3.1362E-03, 3.2091E-03, 3.0542E-03, 4.1399E-03, 3.5876E-03, 5.1739E-03, 4.4485E-03, 4.8818E-03, 6.2791E-03, 5.7110E-03, 7.7495E-03, 7.0872E-03, 8.6215E-03, 9.8857E-03, 9.2615E-03, 1.2612E-02, 1.1844E-02, 1.6150E-02, 1.6484E-02, 1.8616E-02, 2.5363E-02, 2.3757E-02, 3.4678E-02, 3.6735E-02, 4.8014E-02, 6.1698E-02, 6.6640E-02, 1.0356E-01, 1.1416E-01, 1.5730E-01, 1.9516E-01, 2.8001E-01, 2.7381E-01, 2.4274E-01, -1.4101E-01, -2.9951E-01, -1.2069E-01, 1.5289E-01, -4.0340E-01, -2.2966E-01, 8.6873E-02, 2.9394E-01, 2.9900E-01, 2.3692E-01, 1.7412E-01, 1.3967E-01, 1.1032E-01, 8.5725E-02, 5.9477E-02, 5.7403E-02, 3.9256E-02, 3.6738E-02, 2.7286E-02, 2.3159E-02, 2.3113E-02, 1.5533E-02, 1.7433E-02, 1.2490E-02, 1.2371E-02, 1.0811E-02, 8.3322E-03, 1.0572E-02, 6.4294E-03, 7.4343E-03, 6.2322E-03, 5.5555E-03, 6.3506E-03, 3.8667E-03, 5.1382E-03, 3.9190E-03, 3.6786E-03, 3.9425E-03, 2.8186E-03, 3.3337E-03, 2.5706E-03, 2.5569E-03, 2.5981E-03, 1.9889E-03, 2.5687E-03, 1.8076E-03, 2.1021E-03, 1.8949E-03, 1.6327E-03, 1.9549E-03, 1.5103E-03, 1.6732E-03, 1.7306E-03, 1.8637E-03, 1.9140E-03, 1.2145E-03, 1.1094E-03, 9.7197E-04, 9.3136E-04, 9.2626E-04, 8.8649E-04, 1.0207E-03, 9.7676E-04, 1.1313E-03, 1.2131E-03, 1.2489E-03, 1.3805E-03, 1.1343E-03, 1.2767E-03, 1.1708E-03, 1.3963E-03, 1.6928E-03, 1.7217E-03, 1.7350E-03, 1.0668E-03, 5.6205E-04, 4.0940E-05, 5.2843E-05, 1.3265E-04, -1.6447E-04, 1.1861E-04, 3.9343E-04, 6.8418E-04, 1.0386E-03, 1.1351E-03, 9.8810E-04, 8.7034E-04, 6.6820E-04, 6.6167E-04, 5.3432E-04, 5.1216E-04, 4.1117E-04, 3.2392E-04, 3.4715E-04, 2.6009E-04, 2.8756E-04, 1.8877E-04, 2.1460E-04, 1.4377E-04, 1.3760E-04, 1.5953E-04, 1.4757E-04, 1.5888E-04, 1.2631E-04, 1.1680E-04, 1.4293E-04, 1.2183E-04, 1.2673E-04, 8.1653E-05, 7.1054E-05, 8.9659E-05, 6.5717E-05, 6.8444E-05, 4.6072E-05, 4.5492E-05, 4.1313E-05, 3.3751E-05, 3.6720E-05, 2.1536E-05, 2.3924E-05, 2.0777E-05, 1.6075E-05, 1.6894E-05, 1.4028E-05, 1.1773E-05, 8.0451E-06, 6.4432E-06, 3.6616E-06, 1.7800E-06, 3.1056E-07, 2.1444E-08, -8.8101E-09, -2.2756E-07, 4.6411E-07, 1.2807E-06, 4.1841E-06, 7.9251E-06, 1.7628E-05, 2.6259E-05, 3.8596E-05, 4.3385E-05, 5.1168E-05, 5.2854E-05, 6.3953E-05, 6.3430E-05, 6.8681E-05, 8.3864E-05, 8.6535E-05, 8.7790E-05, 7.9514E-05, 1.0879E-04, 1.0899E-04, 1.5809E-04, 1.9008E-04, 1.8245E-04, 2.2666E-04, 2.3982E-04, 2.5071E-04, 2.5390E-04, 2.4480E-04, 3.6244E-04, 3.2275E-04, 3.1738E-04, 3.6860E-04, 3.9775E-04, 4.2472E-04, 4.3661E-04, 5.8366E-04, 6.6332E-04, 7.4143E-04, 9.2564E-04, 9.2342E-04, 1.2071E-03, 1.2268E-03, 1.4801E-03, 1.4443E-03, 1.6231E-03, 1.4959E-03, 1.2040E-03, 5.8495E-04, 1.2413E-04, 7.2497E-05, 4.6259E-04, 8.4334E-04, 6.9141E-04, 6.7295E-04, 1.0937E-03, 5.3340E-04, -1.7564E-05, 4.9219E-04, 1.3039E-03, 2.1616E-03, 3.0120E-03, 2.8946E-03, 3.2499E-03, 2.9212E-03, 3.1728E-03, 2.9056E-03, 2.5295E-03, 2.5521E-03, 2.1127E-03, 2.1166E-03, 1.8397E-03, 1.7552E-03, 2.7901E-03, 2.4227E-03, 2.4577E-03, 2.1084E-03, 2.3626E-03, 3.0292E-03, 2.6149E-03, 3.9396E-03, 3.3457E-03, 3.8261E-03, 4.1267E-03, 3.4000E-03, 4.8985E-03, 3.8333E-03, 4.7271E-03, 4.6330E-03, 4.3704E-03, 6.3240E-03, 4.6709E-03, 7.0922E-03, 6.6197E-03, 6.5756E-03, 8.7853E-03, 6.8967E-03, 1.0703E-02, 8.7443E-03, 1.0635E-02, 1.3315E-02, 1.1592E-02, 1.8020E-02, 1.4701E-02, 2.0235E-02, 2.1313E-02, 1.9775E-02, 3.0414E-02, 2.6955E-02, 3.8480E-02, 3.9797E-02, 4.6232E-02, 6.3149E-02, 5.8938E-02, 8.7446E-02, 9.3647E-02, 1.2513E-01, 1.5622E-01, 1.6269E-01, 2.2568E-01, 2.2302E-01, 2.2316E-01, 1.9658E-01, 6.4868E-02, -1.0923E-01, -3.5163E-01, -1.2023E-01, 1.5397E-01, 1.4572E-01, -1.1821E-01, 2.7519E-01, -5.6538E-02, -2.9575E-01, -1.8133E-01, -1.1217E-02, 1.5282E-01, 1.9593E-01, 2.3669E-01, 2.3138E-01, 2.0761E-01, 1.5538E-01, 1.4527E-01, 9.9884E-02, 9.1384E-02, 7.0122E-02, 5.8259E-02, 5.7991E-02, 3.7245E-02, 4.2492E-02, 3.0393E-02, 2.8376E-02, 2.5949E-02, 1.8399E-02, 2.2978E-02, 1.4790E-02, 1.6982E-02, 1.3780E-02, 1.1650E-02, 1.3801E-02, 8.1905E-03, 1.0700E-02, 8.3567E-03, 7.2818E-03, 8.5373E-03, 5.6566E-03, 7.4336E-03, 5.3546E-03, 5.4180E-03, 5.5853E-03, 4.3490E-03, 4.8514E-03, 3.7742E-03, 4.7217E-03, 4.3272E-03, 3.4628E-03, 4.2947E-03, 3.1924E-03, 3.5560E-03, 2.7687E-03, 2.7858E-03, 2.7246E-03, 2.0674E-03, 2.5675E-03, 2.1552E-03, 2.2536E-03, 2.2229E-03, 1.8680E-03, 2.2247E-03, 1.9784E-03, 2.2158E-03, 2.5880E-03, 2.5553E-03, 2.9983E-03, 2.7295E-03, 3.1104E-03, 2.7202E-03, 2.7523E-03, 2.8764E-03, 1.5798E-03, 1.3146E-03, 1.8712E-04, 1.5540E-04, 6.5237E-04, 7.2087E-04, 9.7966E-04, 8.7939E-04, 4.1581E-04, -2.4604E-05, 1.3591E-04, 4.0142E-04, 8.1882E-04, 1.3075E-03, 1.4718E-03, 1.4260E-03, 1.5658E-03, 1.2874E-03, 1.1984E-03, 9.5446E-04, 9.0106E-04, 8.4878E-04, 6.0796E-04, 6.0722E-04, 4.1755E-04, 4.6013E-04, 3.7166E-04, 3.4249E-04, 3.9207E-04, 2.7025E-04, 2.8964E-04, 2.6777E-04, 2.4366E-04, 2.1834E-04, 1.8977E-04, 2.1554E-04, 2.2477E-04, 1.5949E-04, 1.4614E-04, 9.0117E-05, 1.2767E-04, 7.5529E-05, 8.8249E-05, 7.1817E-05, 6.2848E-05, 6.3391E-05, 5.4169E-05, 5.6920E-05, 3.8482E-05, 3.9208E-05, 3.5734E-05, 2.7798E-05, 2.1934E-05, 1.4290E-05, 7.8982E-06, 2.6637E-06, 9.0213E-07, 1.9295E-07, -1.5802E-08, -2.4188E-08, -7.3835E-07, -4.3153E-07, -8.7460E-07, -1.0859E-06, -1.5803E-06, -4.4074E-06, -1.2864E-05, -2.6212E-05, -4.0420E-05, -5.8206E-05, -6.8652E-05, -8.2212E-05, -8.5482E-05, -9.0082E-05, -8.7927E-05, -9.0481E-05, -1.3452E-04, -1.4291E-04, -1.6357E-04, -1.6781E-04, -1.5708E-04, -1.9335E-04, -1.9022E-04, -2.4980E-04, -2.0592E-04, -2.5769E-04, -3.3474E-04, -2.7930E-04, -2.7028E-04, -3.2150E-04, -4.5014E-04, -5.2487E-04, -5.3976E-04, -6.8844E-04, -6.2301E-04, -6.4918E-04, -7.8105E-04, -9.2496E-04, -1.3102E-03, -1.4727E-03, -1.6166E-03, -1.2302E-03, -1.3994E-03, -8.8545E-04, -8.2773E-04, -1.0660E-04, 4.5803E-04, 1.7505E-04, -5.7535E-04, -8.4157E-04, -9.4865E-04, -5.2534E-04, -9.1958E-04, -1.0725E-03, -4.6711E-04, -1.5774E-03, -1.4196E-03, -5.5599E-04, 1.0558E-04, 1.8017E-04, -1.1930E-03, -1.7370E-03, -2.6782E-03, -2.5477E-03, -3.1993E-03, -3.3630E-03, -3.3035E-03, -3.3910E-03, -2.8470E-03, -2.8905E-03, -3.0288E-03, -3.1638E-03, -2.6400E-03, -2.3090E-03, -3.4216E-03, -3.6494E-03, -2.6341E-03, -2.8342E-03, -2.7271E-03, -4.1691E-03, -3.7576E-03, -3.7277E-03, -4.5053E-03, -3.8450E-03, -5.3454E-03, -5.2098E-03, -5.9160E-03, -5.9606E-03, -5.4395E-03, -7.1150E-03, -6.4252E-03, -8.2009E-03, -8.7050E-03, -8.7938E-03, -1.0690E-02, -9.1284E-03, -1.3134E-02, -1.2766E-02, -1.3157E-02, -1.7613E-02, -1.6293E-02, -2.2117E-02, -2.1528E-02, -2.5346E-02, -3.1292E-02, -3.0950E-02, -4.1981E-02, -4.4165E-02, -5.5585E-02, -6.3730E-02, -7.1901E-02, -9.3784E-02, -1.0024E-01, -1.2273E-01, -1.4643E-01, -1.7554E-01, -1.9688E-01, -1.9644E-01, -1.4609E-01, -9.1483E-02, 6.8272E-02, 1.3920E-01, 3.1196E-01, 1.7008E-01, -1.9392E-01, -1.0833E-01, 4.9890E-02, 4.4655E-02, -6.7094E-02, 3.0366E-01, -7.6022E-02, -3.0954E-01, 5.7384E-02, 2.5960E-01, 2.7809E-01, 1.2754E-01, -1.7945E-02, -1.3976E-01, -1.9341E-01, -2.0466E-01, -1.7982E-01, -1.5583E-01, -1.3067E-01, -1.0902E-01, -9.3421E-02, -8.4720E-02, -6.2989E-02, -6.1001E-02, -4.7012E-02, -4.3131E-02, -3.6666E-02, -2.8960E-02, -2.9586E-02, -2.0971E-02, -2.1883E-02, -1.8504E-02, -1.6334E-02, -1.6452E-02, -1.1487E-02, -1.3144E-02, -1.0323E-02, -1.0054E-02, -1.0208E-02, -7.8524E-03, -8.7974E-03, -6.2892E-03, -6.6838E-03, -6.1593E-03, -5.3996E-03, -6.2299E-03, -4.6065E-03, -5.0204E-03, -4.6892E-03, -4.1784E-03, -4.7330E-03, -3.3089E-03, -3.5640E-03, -2.7259E-03, -2.4185E-03, -2.9865E-03, -2.2220E-03, -2.9719E-03, -3.1866E-03, -3.0627E-03, -3.1295E-03, -2.7323E-03, -2.9423E-03, -2.5137E-03, -2.6725E-03, -3.2073E-03, -2.8031E-03, -3.2548E-03, -2.9575E-03, -2.8407E-03, -1.7510E-03, -8.5153E-04, -5.5866E-04, -3.0649E-05, 6.7777E-05, -8.6631E-04, -1.4123E-03, -1.5117E-03, -6.5281E-04, -6.7598E-04, -2.9935E-04, -1.1486E-03, -1.2802E-03, -5.1937E-04, 3.3339E-05, 2.5477E-04, 2.1581E-04, -2.9193E-04, -9.9897E-04, -1.1860E-03, -1.3519E-03, -1.5134E-03, -1.3185E-03, -1.3040E-03, -9.4230E-04, -8.5052E-04, -7.7073E-04, -5.4663E-04, -5.5305E-04, -5.4973E-04, -4.7326E-04, -4.5481E-04, -2.8566E-04, -2.9689E-04, -2.7553E-04, -2.5745E-04, -2.4041E-04, -1.9354E-04, -2.2222E-04, -1.6539E-04, -1.4211E-04, -1.5576E-04, -1.1591E-04, -1.4394E-04, -1.0673E-04, -1.0403E-04, -9.3137E-05, -8.2967E-05, -8.2343E-05, -6.3690E-05, -6.2441E-05, -5.4256E-05, -4.6291E-05, -3.5837E-05, -2.4631E-05, -1.3463E-05, -3.4976E-06, 3.0105E-07, -1.5272E-06, -3.4766E-07, -1.4042E-07, 1.0193E-08, -1.8406E-08, 1.5183E-07, 2.2465E-06, 5.4294E-06, 4.3465E-06, 7.7640E-06, 4.2840E-06, 5.9783E-06, 1.7010E-06, 1.9681E-05, 4.0971E-05, 8.0211E-05, 9.6322E-05, 1.2117E-04, 1.3033E-04, 1.8834E-04, 2.0666E-04, 2.3358E-04, 2.0986E-04, 2.1969E-04, 2.0621E-04, 2.5988E-04, 3.1199E-04, 2.5281E-04, 3.2439E-04, 3.4411E-04, 4.3010E-04, 4.0173E-04, 4.7923E-04, 6.7744E-04, 6.8096E-04, 8.1218E-04, 8.9108E-04, 9.6619E-04, 1.1691E-03, 1.1723E-03, 1.4073E-03, 1.4956E-03, 1.6053E-03, 1.8764E-03, 1.6677E-03, 1.4061E-03, 9.3458E-04, 7.5994E-05, -3.4453E-04, -5.1228E-04, -6.8311E-05, 7.1925E-04, 1.4094E-03, 1.4476E-03, 1.3499E-03, 1.2731E-03, 1.2864E-03, 1.3732E-03, 1.2045E-03, 1.6636E-03, 1.4474E-03, 1.7616E-03, 2.6518E-03, 2.4818E-03, 1.0929E-03, 1.9037E-04, -9.1962E-04, 4.7707E-04, 4.0780E-04, 2.1933E-03, 3.6562E-03, 3.9674E-03, 5.5404E-03, 5.0292E-03, 5.8068E-03, 5.1993E-03, 5.4362E-03, 5.9839E-03, 5.5119E-03, 5.0625E-03, 5.4163E-03, 5.7327E-03, 5.9974E-03, 4.5724E-03, 6.0731E-03, 5.0719E-03, 5.9859E-03, 6.9389E-03, 6.0226E-03, 9.4420E-03, 7.9760E-03, 1.0259E-02, 1.0437E-02, 1.0106E-02, 1.3386E-02, 1.1118E-02, 1.4911E-02, 1.4670E-02, 1.5650E-02, 1.9874E-02, 1.6715E-02, 2.5125E-02, 2.2705E-02, 2.7471E-02, 3.1895E-02, 3.0788E-02, 4.2506E-02, 4.0398E-02, 5.4033E-02, 6.0373E-02, 6.3216E-02, 8.2943E-02, 8.6609E-02, 1.1231E-01, 1.2142E-01, 1.4173E-01, 1.6557E-01, 1.6420E-01, 1.6781E-01, 1.6925E-01, 1.6202E-01, 1.0656E-01, -3.0691E-03, -1.7467E-01, -2.9632E-01, -1.8493E-01, -1.2939E-01, 1.6997E-01, 1.4019E-01, -2.8555E-02, -8.2589E-02, 1.1109E-02, 8.2213E-02, -5.8571E-02, 1.7681E-01, -1.2881E-01, -1.8514E-01, 1.5667E-01, 2.1267E-01, -2.3335E-02, -1.6137E-01, -3.0452E-01, -1.9662E-01, -7.8923E-02, 4.6960E-02, 1.1665E-01, 1.6483E-01, 1.6841E-01, 1.6691E-01, 1.5635E-01, 1.5687E-01, 1.2178E-01, 1.2047E-01, 9.6754E-02, 8.3192E-02, 7.4149E-02, 5.6177E-02, 6.0913E-02, 4.1672E-02, 4.2699E-02, 3.5313E-02, 2.8213E-02, 3.1580E-02, 2.0547E-02, 2.5674E-02, 2.0198E-02, 1.8467E-02, 1.8660E-02, 1.3199E-02, 1.5895E-02, 1.2381E-02, 1.1731E-02, 1.2182E-02, 9.5936E-03, 1.0493E-02, 8.0734E-03, 9.0711E-03, 7.2574E-03, 5.9585E-03, 7.2041E-03, 5.0030E-03, 5.8524E-03, 4.8615E-03, 5.5387E-03, 6.1588E-03, 5.0668E-03, 5.8132E-03, 4.8175E-03, 5.1830E-03, 5.2177E-03, 4.9881E-03, 5.9621E-03, 4.7385E-03, 5.1785E-03, 4.8460E-03, 3.8550E-03, 3.2215E-03, 1.1994E-03, 6.2399E-04, 2.3007E-04, 2.6484E-04, 8.2023E-04, 1.7806E-03, 2.8011E-03, 2.0783E-03, 1.3119E-03, 1.0751E-03, 1.3286E-03, 1.6007E-03, 1.5000E-03, 9.5319E-04, 8.5697E-04, 1.3825E-03, 1.6156E-03, 1.0193E-03, 3.4825E-04, -3.6509E-04, -3.6979E-04, -3.3350E-05, 6.9051E-04, 1.0085E-03, 1.5530E-03, 1.7214E-03, 1.6841E-03, 1.5437E-03, 1.2737E-03, 1.2239E-03, 1.1436E-03, 9.0815E-04, 8.6467E-04, 8.8093E-04, 6.5198E-04, 6.0117E-04, 4.6745E-04, 4.0589E-04, 4.5147E-04, 2.7633E-04, 3.1580E-04, 2.3424E-04, 2.4795E-04, 2.3410E-04, 2.3281E-04, 2.0476E-04, 2.0423E-04, 1.8214E-04, 1.7907E-04, 1.5389E-04, 1.4577E-04, 1.2824E-04, 9.2279E-05, 6.7409E-05, 4.8341E-05, 2.2500E-05, 7.8938E-06, -2.1064E-06, 1.7007E-06, 5.4564E-06, 3.3123E-06, 1.7245E-06, 2.8743E-07, 2.0286E-08, -2.8677E-08, 5.7521E-07, 5.9769E-07, 2.2196E-06, 7.2750E-06, 6.8045E-06, 1.7720E-05, 2.0077E-05, 1.5370E-05, 7.0031E-06, -6.8486E-06, 1.5333E-05, 4.4472E-05, 1.0362E-04, 1.5217E-04, 1.9236E-04, 2.4783E-04, 2.7856E-04, 2.7791E-04, 3.3397E-04, 3.3261E-04, 2.8040E-04, 4.1842E-04, 4.1098E-04, 5.2398E-04, 4.6004E-04, 4.9931E-04, 7.0996E-04, 7.6996E-04, 9.1640E-04, 9.1652E-04, 1.1609E-03, 1.2710E-03, 1.4272E-03, 1.5338E-03, 1.6199E-03, 1.5142E-03, 1.6492E-03, 1.6002E-03, 1.1004E-03, 3.5135E-04, -6.4882E-04, -4.1137E-04, -4.0564E-04, 7.7435E-04, 1.1350E-03, 2.0380E-03, 1.4011E-03, 1.2210E-03, 1.2612E-03, 8.4446E-04, 1.4830E-03, 1.5934E-03, 1.9099E-03, 2.0600E-03, 1.6683E-03, 1.9246E-03, 1.3984E-03, 1.5931E-03, 1.9010E-03, 2.0521E-03, 2.6194E-03, 1.3511E-03, 1.3233E-03, 6.1651E-04, 1.6559E-05, 5.5518E-04, 1.6730E-03, 4.8388E-03, 4.9006E-03, 6.5397E-03, 7.1693E-03, 7.5553E-03, 8.2124E-03, 6.9341E-03, 8.4653E-03, 7.8960E-03, 7.6121E-03, 7.7779E-03, 7.4745E-03, 9.3924E-03, 7.7790E-03, 7.9995E-03, 1.0177E-02, 8.9700E-03, 1.2423E-02, 1.0152E-02, 1.2646E-02, 1.4159E-02, 1.4110E-02, 1.9243E-02, 1.6747E-02, 2.1747E-02, 2.1665E-02, 2.2688E-02, 2.8434E-02, 2.4623E-02, 3.6595E-02, 3.5031E-02, 4.0566E-02, 4.9503E-02, 4.9062E-02, 6.7304E-02, 6.5556E-02, 8.2133E-02, 9.3807E-02, 9.8095E-02, 1.2194E-01, 1.2992E-01, 1.5357E-01, 1.6364E-01, 1.6858E-01, 1.6186E-01, 1.1836E-01, 5.0038E-02, -1.0990E-02, -1.2613E-01, -1.9018E-01, -2.6407E-01, -1.5307E-01, 4.2984E-02, 1.8721E-01, 1.9224E-01, -3.4262E-02, -1.5774E-01, -5.8977E-02, 3.7819E-02, 5.6464E-02, 1.2263E-02, 2.0456E-02, -2.0292E-01, 6.9586E-02, 1.7109E-01, -1.6167E-01, -1.5502E-01, 1.7408E-01, 1.2378E-01, 1.6143E-01, -8.1899E-02, -2.2311E-01, -2.4695E-01, -1.6975E-01, -7.3950E-02, 3.3631E-02, 8.5489E-02, 1.3934E-01, 1.6608E-01, 1.5962E-01, 1.6071E-01, 1.4048E-01, 1.2435E-01, 1.1084E-01, 8.9810E-02, 9.1479E-02, 6.7054E-02, 6.7067E-02, 5.5869E-02, 4.6191E-02, 4.7694E-02, 3.3200E-02, 3.7153E-02, 3.0172E-02, 2.7113E-02, 2.5721E-02, 1.9531E-02, 2.2817E-02, 1.7937E-02, 1.7559E-02, 1.6429E-02, 1.2480E-02, 1.4496E-02, 1.0394E-02, 1.0693E-02, 9.7361E-03, 8.6476E-03, 1.0087E-02, 7.3303E-03, 7.8001E-03, 7.5198E-03, 7.5927E-03, 8.1774E-03, 5.9772E-03, 7.9994E-03, 7.7444E-03, 7.8100E-03, 8.1547E-03, 6.2159E-03, 6.9251E-03, 4.8376E-03, 4.7829E-03, 2.9392E-03, 7.8812E-04, 8.2795E-04, -7.5202E-04, 6.1194E-04, 1.2040E-03, 1.5671E-03, 2.6110E-03, 1.9740E-03, 1.5335E-03, 1.1812E-03, 2.3152E-03, 2.0861E-03, 1.4495E-03, 1.5227E-03, 1.0555E-03, 1.8405E-03, 1.9089E-03, 9.5243E-04, 9.0305E-04, 1.3064E-03, 1.7584E-03, 1.2497E-03, 6.5306E-04, 3.1593E-04, -6.9819E-04, -7.6465E-04, -1.6168E-04, 6.4373E-04, 1.4168E-03, 1.5788E-03, 1.6995E-03, 1.2627E-03, 1.3861E-03, 1.2560E-03, 1.1771E-03, 1.1437E-03, 9.1661E-04, 8.4885E-04, 7.5969E-04, 6.6146E-04, 5.0093E-04, 4.0076E-04, 4.7936E-04, 3.6521E-04, 3.5314E-04, 3.1811E-04, 2.5377E-04, 2.8983E-04, 2.0799E-04, 2.4147E-04, 2.2216E-04, 2.0613E-04, 1.4865E-04, 1.0056E-04, 4.9694E-05, 2.4099E-05, -2.1922E-06, 3.0430E-07, 1.0787E-05, 1.7251E-05, 1.1732E-05, 5.6731E-06, 3.0951E-06, 1.6316E-06, 4.6512E-07, -4.9214E-08, 1.2290E-08, -2.0533E-07, 1.5901E-06, 4.9155E-06, 5.1703E-06, 9.9450E-06, 1.1770E-05, 2.3786E-05, 4.5728E-05, 4.8195E-05, 5.3247E-05, 1.6478E-05, 1.0558E-06, 1.9870E-05, 4.2171E-05, 6.8219E-05, 1.5674E-04, 1.8426E-04, 2.8187E-04, 2.8586E-04, 3.6271E-04, 3.7931E-04, 4.1985E-04, 3.9036E-04, 5.1143E-04, 6.5835E-04, 7.8737E-04, 7.2276E-04, 7.6204E-04, 9.2306E-04, 9.2722E-04, 1.2492E-03, 1.2921E-03, 1.2920E-03, 1.1487E-03, 1.0932E-03, 1.1256E-03, 5.7056E-04, 2.2952E-04, -8.6934E-04, -9.7523E-04, 1.7960E-05, 8.1206E-04, 1.4573E-03, 1.7263E-03, 1.2533E-03, 8.5324E-04, 7.2682E-04, 5.0629E-04, 1.3869E-03, 1.8593E-03, 1.4351E-03, 1.6854E-03, 1.5591E-03, 1.4450E-03, 1.6545E-03, 1.5715E-03, 2.1386E-03, 1.5389E-03, -7.3481E-04, 3.5000E-04, 2.5276E-03, 3.0137E-03, 3.6279E-03, 2.5718E-03, 1.1810E-03, 1.5477E-05, -8.6273E-04, 2.8560E-04, 1.0304E-03, 3.3517E-03, 4.6008E-03, 4.8954E-03, 8.7152E-03, 7.1401E-03, 8.7765E-03, 7.4217E-03, 6.9331E-03, 7.8226E-03, 6.5465E-03, 9.2401E-03, 8.7006E-03, 8.7817E-03, 1.0664E-02, 8.8599E-03, 1.2509E-02, 1.0926E-02, 1.2418E-02, 1.4602E-02, 1.3324E-02, 1.8489E-02, 1.6667E-02, 2.2561E-02, 2.3826E-02, 2.5043E-02, 3.0769E-02, 2.7661E-02, 4.0761E-02, 4.1236E-02, 4.5957E-02, 5.9033E-02, 5.9547E-02, 7.5324E-02, 7.5484E-02, 9.1880E-02, 1.0440E-01, 1.0452E-01, 1.1677E-01, 1.1977E-01, 1.2120E-01, 1.1185E-01, 7.3645E-02, 2.5817E-02, -6.0448E-02, -1.2945E-01, -1.9974E-01, -2.1875E-01, -1.2954E-01, 5.7783E-02, 1.8895E-01, 2.1768E-01, -1.2033E-01, -1.2229E-01, -1.2823E-01, 1.0955E-01, 1.5159E-01, -7.1778E-02, -4.6038E-02, 5.8517E-03, -2.9538E-02, 2.1797E-01, -1.1686E-01, -1.7547E-01, 2.4076E-01, 8.8138E-02, -3.0982E-01, -1.0236E-01, 6.0228E-02, 2.3647E-01, 1.6227E-01, -6.5948E-02, -1.6491E-01, -2.2615E-01, -1.3411E-01, -9.9514E-02, -1.1467E-02, 4.5239E-02, 9.3097E-02, 1.1863E-01, 1.2216E-01, 1.1954E-01, 1.1150E-01, 9.8786E-02, 1.0166E-01, 7.3634E-02, 7.4662E-02, 6.6220E-02, 5.5019E-02, 5.4044E-02, 3.8981E-02, 4.1954E-02, 3.3165E-02, 3.0061E-02, 2.8766E-02, 2.0880E-02, 2.4333E-02, 1.7867E-02, 1.7454E-02, 1.6789E-02, 1.2734E-02, 1.4283E-02, 1.0885E-02, 1.1811E-02, 1.0637E-02, 9.7365E-03, 1.0800E-02, 8.7678E-03, 9.0376E-03, 8.3916E-03, 6.7899E-03, 7.6198E-03, 7.9563E-03, 9.0669E-03, 7.4874E-03, 6.6214E-03, 6.0130E-03, 4.7266E-03, 5.1329E-03, 1.6123E-03, 5.0141E-04, -5.1786E-04, -5.3121E-04, 1.1928E-03, 2.1037E-03, 4.1933E-03, 2.7245E-03, 2.0509E-03, 5.4707E-04, -4.7034E-04, 1.4575E-03, 1.9547E-03, 1.2244E-03, 1.1824E-03, 1.4227E-03, 1.8357E-03, 1.9369E-03, 1.0688E-03, 8.5031E-04, 1.3245E-03, 1.6577E-03, 3.6975E-04, 1.6310E-04, 1.1219E-03, 1.5133E-03, 1.7496E-03, 1.0518E-03, 3.4487E-04, -1.0260E-03, -7.4791E-04, -3.6687E-04, 2.0206E-04, 8.9646E-04, 8.5999E-04, 1.2433E-03, 1.0724E-03, 1.1732E-03, 1.2343E-03, 1.0046E-03, 8.4068E-04, 5.6815E-04, 6.2368E-04, 7.1946E-04, 5.8102E-04, 4.9735E-04, 4.3755E-04, 3.8226E-04, 3.5751E-04, 2.8821E-04, 3.0837E-04, 2.0877E-04, 2.2116E-04, 1.2897E-04, 8.7713E-05, 5.4304E-05, 3.6013E-05, 2.6342E-06, 1.7462E-05, 1.9344E-05, 2.6850E-05, 2.9932E-05, 1.5890E-05, 1.1509E-05, 6.9733E-06, 3.5756E-06, 2.6067E-07, 7.0793E-08, 4.8272E-08); \n\n\n//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(0, i), 1);\n        vec3 pcolor = min(pow(pixel.xyz/(pixel.w+1e-6),vec3(1.3)), 5.0);\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//The first 8 rows of the V matrix: \nfloat V[2056] = float[](-4.9513E-09, -1.1082E-07, -1.1752E-07, -5.9194E-07, -3.6003E-07, -1.4258E-06, -7.0721E-07, -2.6143E-06, -1.2033E-06, -4.1467E-06, -2.1732E-06, -6.0526E-06, -3.3301E-06, -8.3675E-06, -4.6040E-06, -1.1125E-05, -5.6975E-06, -1.4494E-05, -6.4909E-06, -1.8317E-05, -8.4517E-06, -2.2368E-05, -6.6061E-06, -2.6330E-05, -6.7854E-06, -3.0005E-05, -8.4715E-06, -3.4425E-05, -1.3100E-05, -3.9120E-05, -1.7447E-05, -4.4387E-05, -2.0783E-05, -5.0899E-05, -2.1869E-05, -5.7920E-05, -2.1116E-05, -6.6068E-05, -1.7062E-05, -7.4997E-05, -1.1285E-05, -8.2377E-05, -1.0679E-05, -8.8145E-05, -1.9250E-05, -9.5500E-05, -3.1254E-05, -1.0347E-04, -4.1336E-05, -1.1209E-04, -4.8405E-05, -1.2216E-04, -4.9920E-05, -1.3352E-04, -4.6951E-05, -1.4612E-04, -3.7353E-05, -1.6157E-04, -2.2285E-05, -1.8168E-04, -1.8411E-05, -1.8854E-04, -3.5338E-05, -1.9744E-04, -5.9285E-05, -2.0909E-04, -7.8940E-05, -2.2152E-04, -9.1072E-05, -2.3740E-04, -9.5998E-05, -2.5402E-04, -9.1400E-05, -2.7388E-04, -7.3974E-05, -2.9759E-04, -4.3653E-05, -3.2539E-04, -3.5507E-05, -3.5660E-04, -6.2764E-05, -3.7291E-04, -1.0910E-04, -3.8948E-04, -1.4770E-04, -4.1087E-04, -1.7602E-04, -4.3766E-04, -1.8329E-04, -4.6493E-04, -1.8522E-04, -5.0403E-04, -1.5500E-04, -5.4641E-04, -1.1203E-04, -5.9838E-04, -1.2863E-04, -6.5832E-04, -1.5740E-04, -7.2787E-04, -2.2719E-04, -7.6957E-04, -3.1092E-04, -8.2413E-04, -3.7923E-04, -8.8880E-04, -4.2237E-04, -9.7563E-04, -4.3409E-04, -1.0842E-03, -3.9943E-04, -1.2246E-03, -4.0794E-04, -1.4103E-03, -4.9410E-04, -1.6569E-03, -6.1732E-04, -1.9987E-03, -8.0774E-04, -2.4639E-03, -1.2064E-03, -3.0779E-03, -1.7831E-03, -4.1712E-03, -2.7161E-03, -6.8102E-03, -5.4036E-03, -1.9836E-02, -8.9709E-02, -3.8285E-02, -7.1713E-03, -8.0395E-03, -2.6908E-03, -4.5444E-03, -1.7302E-03, -3.1950E-03, -1.3098E-03, -2.4829E-03, -1.1008E-03, -2.0113E-03, -9.9723E-04, -1.6229E-03, -8.8239E-04, -1.3554E-03, -7.3415E-04, -1.1563E-03, -6.1247E-04, -1.0092E-03, -5.4829E-04, -8.9457E-04, -5.0031E-04, -8.0672E-04, -4.6303E-04, -7.3613E-04, -4.3440E-04, -6.7970E-04, -4.1238E-04, -6.3158E-04, -3.9558E-04, -5.7428E-04, -3.8423E-04, -5.1277E-04, -3.4595E-04, -4.6038E-04, -3.1965E-04, -4.1882E-04, -2.9865E-04, -3.8187E-04, -2.8623E-04, -3.6029E-04, -2.6248E-04, -3.3189E-04, -2.4929E-04, -3.1010E-04, -2.3903E-04, -2.9126E-04, -2.3209E-04, -2.7499E-04, -2.2648E-04, -2.5269E-04, -2.1133E-04, -2.2717E-04, -1.9543E-04, -2.0557E-04, -1.8241E-04, -1.8800E-04, -1.7030E-04, -1.7302E-04, -1.6012E-04, -1.6072E-04, -1.5046E-04, -1.4892E-04, -1.4342E-04, -1.3916E-04, -1.3693E-04, -1.3030E-04, -1.3387E-04, -1.2416E-04, -1.2965E-04, -1.1107E-04, -1.1709E-04, -9.8575E-05, -1.0728E-04, -8.8174E-05, -9.8548E-05, -7.9488E-05, -9.1131E-05, -7.2894E-05, -8.4078E-05, -6.5918E-05, -7.7791E-05, -5.9716E-05, -7.2433E-05, -5.4574E-05, -6.7486E-05, -5.0474E-05, -6.3732E-05, -4.5310E-05, -5.9117E-05, -3.9264E-05, -5.2200E-05, -3.3520E-05, -4.6250E-05, -2.9023E-05, -4.0676E-05, -2.4768E-05, -3.6074E-05, -2.1538E-05, -3.1851E-05, -1.8797E-05, -2.7835E-05, -1.6237E-05, -2.4298E-05, -1.4780E-05, -2.1270E-05, -1.2906E-05, -1.7646E-05, -9.1881E-06, -1.5716E-05, -7.5655E-06, -1.2036E-05, -5.4110E-06, -9.1777E-06, -3.9933E-06, -6.8019E-06, -2.8299E-06, -4.8109E-06, -1.9327E-06, -3.2133E-06, -1.2631E-06, -1.8982E-06, -7.3855E-07, -9.3053E-07, -3.0330E-07, -2.9777E-07, -5.3082E-08, -1.2116E-08, 4.8784E-10, 1.4840E-08, 2.0516E-08, 8.4015E-08, 7.1405E-08, 2.0152E-07, 1.6680E-07, 4.1239E-07, 3.3916E-07, 7.4036E-07, 5.4288E-07, 1.0625E-06, 8.1972E-07, 1.4763E-06, 1.1960E-06, 2.4553E-06, 2.2830E-06, 4.3586E-06, 5.4173E-06, 5.5930E-06, 4.7529E-06, 5.8124E-06, 6.0541E-06, 6.0450E-06, 3.8992E-06, 5.3251E-06, 3.3435E-06, 5.8055E-06, 3.0818E-06, 5.7150E-06, 3.7668E-06, 7.1295E-06, 4.1801E-06, 7.8012E-06, 4.0070E-06, 8.6940E-06, 4.1212E-06, 1.0022E-05, 4.5104E-06, 1.0555E-05, 3.5700E-06, 1.0811E-05, 4.4520E-06, 1.2997E-05, 5.4533E-06, 1.5287E-05, 8.5564E-06, 1.7313E-05, 9.2086E-06, 1.7957E-05, 1.1044E-05, 1.8874E-05, 1.0889E-05, 1.9678E-05, 9.9970E-06, 2.0503E-05, 1.0593E-05, 2.5092E-05, 1.4539E-05, 2.5014E-05, 1.0088E-05, 3.2247E-05, 1.3748E-05, 3.1706E-05, 1.3008E-05, 3.0836E-05, 1.3733E-05, 3.1572E-05, 1.4814E-05, 3.1626E-05, 1.5690E-05, 3.5964E-05, 1.5917E-05, 3.9959E-05, 1.4593E-05, 4.3964E-05, 1.2455E-05, 4.9365E-05, 1.1641E-05, 4.8538E-05, 1.5797E-05, 5.4167E-05, 2.0499E-05, 5.6080E-05, 2.9650E-05, 6.2559E-05, 3.9237E-05, 7.4864E-05, 3.6381E-05, 7.0251E-05, 4.8921E-05, 7.6114E-05, 3.8492E-05, 8.3288E-05, 3.1787E-05, 8.5083E-05, 2.6357E-05, 8.8021E-05, 3.6472E-05, 1.1137E-04, 3.9332E-05, 1.1593E-04, 5.2346E-05, 1.2584E-04, 5.8791E-05, 1.3120E-04, 7.4114E-05, 1.4760E-04, 7.5735E-05, 1.5967E-04, 9.5588E-05, 1.9476E-04, 9.3241E-05, 2.2699E-04, 1.1330E-04, 2.7133E-04, 1.5556E-04, 3.5731E-04, 1.8077E-04, 4.3763E-04, 3.5531E-04, 7.0284E-04, 5.4522E-04, 1.0686E-03, 1.4681E-03, 2.9842E-03, 5.2828E-03, 8.7086E-03, -6.0637E-03, 5.1659E-03, 7.8877E-03, 3.8412E-03, 2.0333E-03, 1.3369E-03, 7.5476E-04, 7.2354E-04, 3.7722E-04, 4.6938E-04, 2.8898E-04, 3.6659E-04, 1.8021E-04, 2.5758E-04, 1.8461E-04, 2.2647E-04, 1.2890E-04, 1.7614E-04, 1.2520E-04, 1.6106E-04, 9.3484E-05, 1.3086E-04, 8.4313E-05, 1.2145E-04, 7.9978E-05, 1.0633E-04, 7.0350E-05, 1.0302E-04, 7.5987E-05, 1.0057E-04, 5.6223E-05, 8.3257E-05, 5.5768E-05, 7.2508E-05, 5.6724E-05, 7.0752E-05, 5.4078E-05, 7.0389E-05, 5.7732E-05, 6.3639E-05, 3.9524E-05, 5.2112E-05, 5.3424E-05, 5.6019E-05, 4.1344E-05, 4.5847E-05, 3.9147E-05, 4.3462E-05, 3.5004E-05, 3.8795E-05, 3.6049E-05, 3.5182E-05, 3.2945E-05, 3.4270E-05, 2.9511E-05, 3.0729E-05, 2.7702E-05, 2.7377E-05, 2.5865E-05, 2.5573E-05, 2.2770E-05, 2.1786E-05, 2.4630E-05, 2.2233E-05, 2.3352E-05, 2.2245E-05, 2.4446E-05, 2.3819E-05, 2.4980E-05, 2.3513E-05, 1.4874E-05, 1.9195E-05, 1.8457E-05, 1.7256E-05, 1.6497E-05, 1.3513E-05, 1.6690E-05, 1.5016E-05, 1.5433E-05, 1.1617E-05, 1.4267E-05, 1.1863E-05, 1.4514E-05, 1.1359E-05, 1.1731E-05, 9.6548E-06, 9.7401E-06, 7.3529E-06, 9.1673E-06, 6.6912E-06, 9.4642E-06, 6.0302E-06, 8.4475E-06, 5.4868E-06, 7.4922E-06, 5.0513E-06, 6.7298E-06, 5.0419E-06, 5.3534E-06, 3.8977E-06, 5.2190E-06, 3.6249E-06, 4.9212E-06, 3.8666E-06, 4.9592E-06, 4.4395E-06, 5.6875E-06, 6.7412E-06, 6.5217E-06, 3.7056E-06, 5.5861E-06, 4.5917E-06, 3.1389E-06, 1.9783E-06, 1.6332E-06, 1.1295E-06, 1.1684E-06, 7.0476E-07, 8.3134E-07, 4.9221E-07, 5.2510E-07, 2.8066E-07, 2.6725E-07, 1.3683E-07, 1.3264E-07, 5.3823E-08, 4.0303E-08, 8.9860E-09, 1.2225E-09, 8.1528E-11, 2.1023E-09, 9.6316E-09, 2.5325E-08, 4.2204E-08, 9.0841E-08, 1.0846E-07, 1.9666E-07, 1.8098E-07, 2.6718E-07, 3.4399E-07, 5.2549E-07, 6.9212E-07, 9.7823E-07, 1.2237E-06, 1.9772E-06, 2.8229E-06, 3.8639E-06, 1.5294E-06, -3.9524E-07, -1.0537E-06, 2.4697E-06, 5.5029E-06, 6.1585E-06, 4.5912E-06, 4.1524E-06, 3.4208E-06, 3.2792E-06, 2.6369E-06, 3.3365E-06, 2.0180E-06, 3.0069E-06, 2.4784E-06, 4.0784E-06, 2.4145E-06, 4.3024E-06, 3.1125E-06, 4.3430E-06, 2.6896E-06, 4.6802E-06, 3.4581E-06, 5.3675E-06, 3.5845E-06, 5.2209E-06, 4.5103E-06, 8.3187E-06, 6.2418E-06, 6.2603E-06, 2.8885E-06, 5.9334E-06, 4.5056E-06, 8.7766E-06, 8.3026E-06, 9.7588E-06, 8.1521E-06, 9.5747E-06, 1.0721E-05, 9.3065E-06, 3.3449E-06, 1.1802E-05, 2.0139E-06, 1.1088E-05, 1.1096E-05, 1.5693E-05, 9.3272E-06, 1.3954E-05, 8.5014E-06, 1.3836E-05, 8.5966E-06, 1.3022E-05, 5.6565E-06, 1.4878E-05, 9.6913E-06, 1.5197E-05, 1.0327E-05, 1.8679E-05, 9.7773E-06, 1.9146E-05, 7.1270E-06, 2.2688E-05, 8.3142E-06, 2.2282E-05, 1.5780E-05, 2.7886E-05, 2.2716E-05, 3.2599E-05, 2.4946E-05, 2.1948E-05, 8.3273E-06, 2.3157E-05, 1.2921E-05, 3.1003E-05, 3.6951E-05, 4.0474E-05, 2.7012E-05, 3.8069E-05, 2.4896E-05, 4.3142E-05, 1.9942E-05, 4.2244E-05, 2.5811E-05, 5.2111E-05, 2.1846E-05, 6.1340E-05, 3.0026E-05, 5.4184E-05, 3.8313E-05, 6.6893E-05, 4.6861E-05, 7.3347E-05, 6.0808E-05, 9.2745E-05, 6.8734E-05, 1.1717E-04, 1.0079E-04, 1.3588E-04, 1.1905E-04, 2.0976E-04, 1.9450E-04, 2.8729E-04, 3.2989E-04, 5.5319E-04, 6.9888E-04, 1.0914E-03, 1.7635E-03, 2.8916E-03, 3.3328E-03, -3.1904E-03, 1.4778E-03, -4.6144E-03, 9.4329E-04, 3.4622E-03, 2.3732E-03, 1.4101E-03, 8.4854E-04, 6.4464E-04, 4.1001E-04, 3.2948E-04, 2.1637E-04, 2.2504E-04, 1.3331E-04, 1.4757E-04, 1.0870E-04, 1.2089E-04, 7.5175E-05, 8.7718E-05, 6.7685E-05, 7.7435E-05, 4.8906E-05, 6.1257E-05, 4.4197E-05, 5.2125E-05, 4.2410E-05, 5.0237E-05, 3.7383E-05, 4.9011E-05, 2.7380E-05, 3.9969E-05, 2.7564E-05, 3.9502E-05, 2.8394E-05, 3.1448E-05, 2.9365E-05, 3.6630E-05, 2.9686E-05, 3.2786E-05, 2.6181E-05, 2.0399E-05, 1.4891E-05, 1.6486E-05, 2.3429E-05, 3.4881E-05, 2.4510E-05, 2.6366E-05, 1.8329E-05, 2.0565E-05, 1.6835E-05, 1.6137E-05, 1.5699E-05, 1.7364E-05, 1.3968E-05, 1.4471E-05, 1.4765E-05, 1.5728E-05, 1.1223E-05, 1.2234E-05, 1.0371E-05, 1.0975E-05, 1.0975E-05, 1.0074E-05, 1.1037E-05, 1.1438E-05, 1.1838E-05, 1.2779E-05, 1.3784E-05, 1.0186E-05, 3.4141E-06, 6.0080E-06, 1.1045E-05, 1.1737E-05, 7.5660E-06, 1.0152E-05, 9.3692E-06, 9.4953E-06, 9.7007E-06, 7.2853E-06, 8.4853E-06, 4.1779E-06, 5.5260E-06, 4.3803E-06, 6.7543E-06, 7.9174E-06, 5.7639E-06, 5.2478E-06, 4.5585E-06, 4.6275E-06, 3.7338E-06, 2.3659E-06, 3.9523E-06, 2.5091E-06, 4.1950E-06, 3.3326E-06, 3.1115E-06, 3.0454E-06, 2.7964E-06, 2.7255E-06, 2.7575E-06, 2.6531E-06, 2.5149E-06, 2.5591E-06, 3.3358E-06, 3.4781E-06, 3.8373E-06, 5.3391E-06, 5.6217E-06, 2.8012E-06, -1.1281E-07, -4.7257E-07, 4.5813E-07, 2.8030E-06, 3.5311E-06, 2.3615E-06, 1.3607E-06, 1.0633E-06, 8.1577E-07, 5.6676E-07, 4.1238E-07, 2.5320E-07, 1.7309E-07, 1.6999E-07, 1.3152E-07, 7.9085E-08, 4.3735E-08, 2.7853E-08, 1.4313E-08, 2.4992E-09, -1.3956E-11, -2.2830E-11, 3.5606E-09, 9.4078E-09, 2.7118E-08, 5.9865E-08, 1.3159E-07, 1.0557E-07, 1.7710E-07, 2.1424E-07, 4.0869E-07, 3.9927E-07, 8.3650E-07, 1.0995E-06, 1.6911E-06, 2.3215E-06, 3.2328E-06, 2.7754E-06, 6.6856E-07, -2.2196E-07, 2.0171E-06, 2.1403E-06, -7.2090E-08, -2.6639E-07, 4.5090E-06, 6.1423E-06, 7.4324E-06, 5.8982E-06, 5.4014E-06, 4.5746E-06, 4.1942E-06, 3.8518E-06, 4.5288E-06, 3.3190E-06, 4.2465E-06, 3.6981E-06, 5.3787E-06, 3.6135E-06, 5.6009E-06, 3.6751E-06, 5.3716E-06, 3.8654E-06, 6.9346E-06, 5.3262E-06, 7.3830E-06, 7.1851E-06, 8.0382E-06, 4.7517E-06, 7.4363E-06, 4.6470E-06, 8.8355E-06, 5.5400E-06, 8.6858E-06, 1.0543E-05, 1.2816E-05, 1.2611E-05, 1.0733E-05, 9.7938E-06, 1.2865E-05, 3.8705E-06, 1.0421E-05, 5.6014E-06, 1.1197E-05, 5.6970E-06, 1.3994E-05, 1.5586E-05, 1.8198E-05, 1.2430E-05, 1.8099E-05, 1.0860E-05, 1.7130E-05, 1.2257E-05, 1.7284E-05, 1.2069E-05, 1.9032E-05, 1.3021E-05, 2.0354E-05, 1.2023E-05, 2.3973E-05, 1.2057E-05, 2.7257E-05, 1.7162E-05, 2.9224E-05, 2.3971E-05, 3.5316E-05, 3.4759E-05, 3.4673E-05, 1.2742E-05, 2.0486E-05, 2.0263E-05, 3.0817E-05, 9.9819E-06, 3.2904E-05, 3.0536E-05, 4.6633E-05, 4.3954E-05, 5.5978E-05, 3.3810E-05, 5.3320E-05, 2.8182E-05, 5.8884E-05, 2.4868E-05, 5.4100E-05, 4.0137E-05, 7.2417E-05, 3.5765E-05, 7.2929E-05, 5.7860E-05, 8.4536E-05, 6.0071E-05, 9.7264E-05, 8.2960E-05, 1.2053E-04, 9.6468E-05, 1.5458E-04, 1.4137E-04, 2.0736E-04, 1.9563E-04, 3.2320E-04, 3.3944E-04, 4.7322E-04, 5.9176E-04, 9.5009E-04, 1.3183E-03, 1.8092E-03, 2.0514E-03, 9.8879E-04, -2.0535E-03, -1.9312E-04, -1.0118E-03, 1.9142E-03, -2.7346E-03, -4.1082E-04, 1.8441E-03, 1.9633E-03, 1.5560E-03, 1.1373E-03, 7.5471E-04, 5.4853E-04, 3.7833E-04, 3.5636E-04, 2.2595E-04, 2.1151E-04, 1.6218E-04, 1.6319E-04, 1.0929E-04, 1.1717E-04, 9.4568E-05, 1.0117E-04, 6.8173E-05, 7.7908E-05, 6.5113E-05, 6.9417E-05, 5.3431E-05, 5.7475E-05, 4.4787E-05, 5.8015E-05, 3.6578E-05, 5.1137E-05, 3.2346E-05, 4.3387E-05, 4.4289E-05, 5.2038E-05, 3.6405E-05, 5.0085E-05, 3.2455E-05, 2.8105E-05, 1.6910E-05, 2.2402E-05, 2.2558E-05, 2.5013E-05, 1.3238E-05, 2.2080E-05, 2.8270E-05, 3.4997E-05, 2.8525E-05, 2.5073E-05, 2.3029E-05, 2.2631E-05, 1.9850E-05, 1.8994E-05, 1.6566E-05, 1.8120E-05, 1.6781E-05, 1.5405E-05, 1.6556E-05, 1.5196E-05, 1.3357E-05, 1.2569E-05, 1.4408E-05, 1.3903E-05, 1.5281E-05, 1.6232E-05, 1.5901E-05, 1.5806E-05, 1.0947E-05, 9.7081E-06, 1.0870E-05, 1.1780E-05, 6.6661E-06, 7.0082E-06, 1.0171E-05, 1.2887E-05, 1.2502E-05, 1.3946E-05, 1.3119E-05, 6.7599E-06, 8.1177E-06, 6.3632E-06, 7.2847E-06, 5.1250E-06, 5.9462E-06, 5.7386E-06, 8.2716E-06, 8.4423E-06, 6.7281E-06, 4.8891E-06, 6.1691E-06, 5.1922E-06, 5.5538E-06, 3.7136E-06, 5.0837E-06, 4.3967E-06, 4.5495E-06, 3.9158E-06, 3.7866E-06, 3.4826E-06, 4.2739E-06, 3.9118E-06, 4.4079E-06, 4.7144E-06, 5.4224E-06, 5.9711E-06, 7.1895E-06, 5.5792E-06, 2.7474E-06, -8.9676E-07, 1.8383E-06, 1.8724E-06, 5.3080E-07, -7.9414E-07, 1.8515E-06, 2.7163E-06, 2.4392E-06, 1.8333E-06, 1.2212E-06, 8.4706E-07, 5.5191E-07, 3.5316E-07, 2.8614E-07, 1.6945E-07, 1.6609E-07, 9.1216E-08, 5.3449E-08, 3.2917E-08, 1.0869E-08, 4.3213E-10, -1.8717E-11, 6.1533E-11, 1.2991E-09, -5.8708E-09, -4.2357E-09, -1.2452E-08, -5.0910E-08, -6.0104E-08, -1.4715E-07, -2.0390E-07, -3.6002E-07, -5.3592E-07, -6.8298E-07, -1.1789E-06, -1.5987E-06, -1.8391E-06, -1.3244E-06, 5.2685E-07, 9.7286E-07, -1.1228E-06, -1.7867E-07, 2.2605E-07, -1.8640E-06, 2.5591E-07, 1.6294E-06, -1.5339E-06, -5.1601E-06, -5.5788E-06, -5.7602E-06, -4.7974E-06, -4.1008E-06, -3.4018E-06, -3.5695E-06, -2.8717E-06, -2.7884E-06, -2.8523E-06, -3.0185E-06, -2.7549E-06, -4.0589E-06, -3.3771E-06, -3.9101E-06, -3.6772E-06, -5.3478E-06, -5.2563E-06, -4.3532E-06, -3.9628E-06, -3.4893E-06, -3.0617E-06, -3.9828E-06, -4.6266E-06, -5.6473E-06, -5.0519E-06, -6.5493E-06, -5.1815E-06, -5.7766E-06, -8.0137E-06, -7.0227E-06, -1.4961E-06, -5.8024E-06, -8.0390E-06, -7.4876E-06, -5.2893E-06, -1.0786E-05, -2.4158E-06, -3.6289E-06, -8.1131E-06, -1.1981E-05, -1.1124E-05, -1.1948E-05, -9.5624E-06, -1.1018E-05, -9.1885E-06, -1.1372E-05, -7.6452E-06, -1.1105E-05, -8.6823E-06, -1.1338E-05, -8.8285E-06, -1.6094E-05, -1.1844E-05, -1.5206E-05, -1.3298E-05, -2.1610E-05, -2.1702E-05, -1.7426E-05, -1.1924E-05, -6.3542E-06, -4.8452E-06, -1.9534E-05, -1.0141E-05, -2.0023E-05, -1.7330E-05, -1.3117E-05, 2.2053E-06, -1.6655E-05, -3.2950E-05, -4.2052E-05, -2.7104E-05, -2.8653E-05, -2.6089E-05, -3.2725E-05, -2.8162E-05, -3.1063E-05, -3.0192E-05, -3.7295E-05, -3.1577E-05, -4.6686E-05, -4.4357E-05, -5.5462E-05, -4.8215E-05, -6.3925E-05, -7.0743E-05, -8.5849E-05, -8.6910E-05, -1.2061E-04, -1.4689E-04, -1.7305E-04, -2.0413E-04, -3.0539E-04, -3.9489E-04, -5.0561E-04, -6.6935E-04, -9.7045E-04, -1.2843E-03, -1.1346E-03, 5.9590E-05, 2.0157E-03, 4.1665E-05, -5.2105E-04, -4.2862E-04, 1.5337E-03, -1.7623E-03, 1.7027E-03, 1.0650E-03, -5.5323E-04, -1.3052E-03, -1.1201E-03, -8.6138E-04, -5.7793E-04, -4.2546E-04, -3.4650E-04, -2.5839E-04, -1.8819E-04, -1.4757E-04, -1.3480E-04, -9.7776E-05, -8.3040E-05, -7.6527E-05, -7.2034E-05, -5.4755E-05, -5.3037E-05, -5.1797E-05, -4.5046E-05, -3.3855E-05, -3.7765E-05, -2.5234E-05, -2.9066E-05, -2.9975E-05, -3.4577E-05, -2.6316E-05, -3.2703E-05, -2.6721E-05, -3.6426E-05, -2.0352E-05, -2.8598E-05, -1.4884E-05, -1.2514E-05, -1.0855E-05, -1.7281E-05, -9.4859E-06, -1.2837E-05, -8.1050E-06, -2.7219E-07, -9.0622E-06, -1.8135E-05, -2.0655E-05, -2.1705E-05, -1.8329E-05, -1.8121E-05, -1.2390E-05, -1.5110E-05, -1.0375E-05, -1.0586E-05, -6.6428E-06, -7.1157E-06, -1.1214E-05, -1.0075E-05, -9.7636E-06, -8.4767E-06, -1.1177E-05, -1.2226E-05, -1.1226E-05, -1.3016E-05, -7.8657E-06, -5.5672E-06, -2.4001E-06, -6.3194E-06, -5.5162E-06, -5.7641E-06, -7.7907E-06, -6.2246E-06, -6.0965E-06, -4.7383E-06, -7.0705E-06, -8.2743E-06, -7.3793E-06, -5.8829E-06, -5.4177E-06, -4.7990E-06, -5.1447E-06, -4.8396E-06, -3.0433E-06, -2.3252E-06, -3.9051E-06, -4.7957E-06, -5.0508E-06, -4.5699E-06, -4.1983E-06, -3.0883E-06, -4.1200E-06, -3.1742E-06, -3.4958E-06, -2.9071E-06, -2.6738E-06, -2.6019E-06, -3.0951E-06, -2.8572E-06, -3.2514E-06, -3.4974E-06, -4.0648E-06, -4.6210E-06, -5.7915E-06, -4.9244E-06, -3.7557E-06, 5.1332E-07, 1.7045E-06, -9.6923E-07, -8.5780E-07, -3.9157E-07, -8.7256E-07, -5.4556E-07, 9.4858E-07, -4.6040E-08, -1.7104E-06, -1.6452E-06, -1.2180E-06, -8.4395E-07, -5.3433E-07, -4.0497E-07, -1.9973E-07, -1.1638E-07, -6.0703E-08, -2.4006E-08, -3.7968E-08, -1.5143E-08, -4.2549E-09, -3.4466E-10, 2.1698E-10, -4.9333E-11, 6.2706E-10, 2.2918E-09, 1.9685E-08, 6.7310E-09, 2.0991E-08, 8.8654E-08, 1.7592E-07, 3.1513E-07, 4.9182E-07, 8.0186E-07, 1.0813E-06, 1.2183E-06, 1.1656E-06, 6.3110E-08, -1.4829E-06, -5.4983E-07, 1.6354E-06, 7.3958E-07, 1.1164E-06, 1.1998E-06, 4.0440E-07, 2.0542E-06, 9.6992E-08, -2.9924E-06, -5.9824E-07, 3.8733E-06, 5.8122E-06, 6.4949E-06, 6.0734E-06, 5.5832E-06, 4.9567E-06, 4.5996E-06, 4.4341E-06, 4.1519E-06, 3.7698E-06, 3.3082E-06, 5.1309E-06, 4.5365E-06, 5.2499E-06, 5.0284E-06, 4.9393E-06, 5.1057E-06, 4.0323E-06, 2.6317E-06, 4.1144E-06, 4.5275E-06, 5.0717E-06, 5.5528E-06, 6.8801E-06, 7.5074E-06, 8.7213E-06, 7.0018E-06, 5.3145E-06, 8.0122E-07, 8.0938E-06, 7.6599E-06, 9.5225E-06, 6.4186E-06, 8.4534E-06, 8.6273E-06, 8.0489E-06, 6.0227E-06, 7.3030E-06, 2.4201E-06, 8.4975E-06, 1.2224E-05, 1.6746E-05, 1.3338E-05, 1.6361E-05, 1.2241E-05, 1.5728E-05, 1.0809E-05, 1.3464E-05, 8.9819E-06, 1.4178E-05, 1.4205E-05, 1.8755E-05, 1.4752E-05, 2.6160E-05, 2.2426E-05, 2.5192E-05, 1.5871E-05, 1.4524E-05, -9.6862E-06, 1.2114E-05, 1.5729E-05, 1.6286E-05, 1.5337E-05, 1.6383E-05, 1.3838E-05, 2.4807E-05, 1.4891E-05, 1.7872E-05, 9.3162E-06, 3.2419E-05, 3.0288E-05, 4.1885E-05, 3.5735E-05, 4.9572E-05, 3.2399E-05, 4.8144E-05, 3.3893E-05, 4.8780E-05, 4.5573E-05, 5.5857E-05, 5.5944E-05, 7.4767E-05, 7.0724E-05, 9.2713E-05, 9.7740E-05, 1.2448E-04, 1.2974E-04, 1.8471E-04, 2.1517E-04, 2.6725E-04, 3.2376E-04, 4.7893E-04, 6.1396E-04, 7.5733E-04, 8.5467E-04, 8.8340E-04, 5.4713E-04, -6.7201E-04, -1.5280E-03, 2.9027E-04, 5.5140E-04, -4.8345E-04, -3.0327E-04, 6.4353E-04, -8.6714E-04, 1.1203E-03, -8.0768E-04, -1.3394E-03, -3.4047E-05, 7.4167E-04, 9.2681E-04, 8.2239E-04, 6.7248E-04, 5.3957E-04, 3.9826E-04, 2.9751E-04, 2.3478E-04, 2.0388E-04, 1.4594E-04, 1.2601E-04, 1.0719E-04, 9.7618E-05, 7.6605E-05, 7.3093E-05, 6.3926E-05, 6.1632E-05, 4.1427E-05, 5.2552E-05, 3.9932E-05, 4.4726E-05, 3.8963E-05, 4.5394E-05, 3.4963E-05, 3.6489E-05, 3.5908E-05, 2.9238E-05, 1.5313E-05, 1.0221E-05, 1.6144E-05, 2.5938E-05, 2.2192E-05, 1.5933E-05, 1.8898E-05, 1.7522E-05, 1.9969E-05, 1.9607E-05, 3.9887E-06, 4.1491E-06, 1.1426E-05, 2.0212E-05, 2.2934E-05, 2.3300E-05, 1.9970E-05, 1.7264E-05, 1.6539E-05, 1.6368E-05, 1.2722E-05, 1.1649E-05, 1.2074E-05, 1.4088E-05, 1.4099E-05, 1.4252E-05, 1.4486E-05, 1.4884E-05, 1.2299E-05, 1.1988E-05, 4.3364E-06, 2.7764E-06, 8.3319E-06, 6.7026E-06, 8.3539E-06, 9.1982E-06, 8.2299E-06, 1.0595E-05, 8.6144E-06, 4.1839E-06, 3.0368E-06, 2.7565E-06, 5.9393E-06, 8.1862E-06, 8.4320E-06, 7.0979E-06, 5.9001E-06, 4.8576E-06, 5.8669E-06, 4.1265E-06, 3.0227E-06, 2.2316E-06, 6.0278E-06, 5.7625E-06, 5.4358E-06, 5.5285E-06, 5.1461E-06, 5.0030E-06, 3.4533E-06, 3.2877E-06, 3.5762E-06, 3.4841E-06, 4.7492E-06, 4.5612E-06, 5.4180E-06, 5.7536E-06, 6.4253E-06, 6.0605E-06, 5.4326E-06, 1.9902E-06, -2.5215E-06, -1.8636E-06, 1.5677E-06, 1.0872E-06, 1.0218E-06, 8.0659E-07, 4.1820E-07, 8.7168E-07, 9.2890E-07, -1.2980E-06, -4.0810E-07, 6.3723E-07, 1.1328E-06, 1.0486E-06, 8.7283E-07, 5.5453E-07, 3.6315E-07, 1.7913E-07, 9.5006E-08, 4.4857E-08, 1.3513E-08, 6.1687E-09, 6.1727E-10, 1.1493E-10, 8.9331E-11, 8.6779E-11, -4.9088E-10, -1.5559E-10, 3.2004E-09, 1.9564E-08, 5.7434E-08, 8.3142E-08, 2.1167E-07, 3.3890E-07, 5.8747E-07, 7.9716E-07, 8.7475E-07, 4.2982E-07, -5.1425E-07, -1.1524E-06, 2.8640E-07, 1.1732E-06, -4.5722E-08, 4.6123E-07, 2.5670E-07, 3.1696E-07, 1.0474E-06, -1.7629E-07, 2.4468E-06, 2.0674E-06, -2.3171E-06, -2.5279E-06, 1.2873E-06, 4.6410E-06, 6.2566E-06, 6.4562E-06, 6.3763E-06, 5.5014E-06, 5.0578E-06, 4.2640E-06, 4.2002E-06, 4.2005E-06, 3.7177E-06, 4.7260E-06, 5.6700E-06, 5.0867E-06, 4.6390E-06, 2.0919E-06, 3.8345E-06, 3.2028E-06, 4.9369E-06, 5.1533E-06, 5.5749E-06, 6.0118E-06, 7.2121E-06, 7.3535E-06, 6.5496E-06, 2.4438E-06, 4.1923E-06, -6.4625E-07, 4.3965E-06, 4.7554E-06, 6.3679E-06, 8.6713E-06, 1.1512E-05, 6.2732E-06, 8.1995E-06, 7.1793E-06, 1.0226E-05, 4.1524E-06, 3.6916E-06, 3.1230E-06, 1.0786E-05, 1.3940E-05, 1.4780E-05, 1.1838E-05, 1.4805E-05, 1.0809E-05, 1.6001E-05, 1.1225E-05, 1.6984E-05, 1.4550E-05, 1.9545E-05, 1.8689E-05, 2.1878E-05, 1.7402E-05, 9.1390E-06, -3.4162E-06, 6.7292E-06, 1.2270E-05, 2.1855E-05, 9.7585E-06, 1.6679E-05, 1.5131E-05, 2.2680E-05, 1.4567E-05, 1.9587E-05, 2.6199E-05, 2.3327E-05, -2.9465E-06, 5.9396E-06, 1.7595E-05, 3.4617E-05, 3.8928E-05, 4.1641E-05, 3.8357E-05, 4.4762E-05, 4.1341E-05, 5.4158E-05, 4.2601E-05, 5.4102E-05, 6.0706E-05, 7.6599E-05, 7.7799E-05, 1.0359E-04, 1.1596E-04, 1.3970E-04, 1.5833E-04, 2.2812E-04, 2.7518E-04, 3.3183E-04, 4.1665E-04, 5.5976E-04, 6.9161E-04, 7.1829E-04, 4.9071E-04, -1.5094E-04, -9.0961E-04, -8.4379E-04, 6.4663E-04, 2.9255E-04, -7.0809E-04, 4.5376E-04, 1.3053E-04, -6.1320E-04, 3.9455E-04, -7.0834E-04, 9.3288E-04, -6.0277E-05, -1.1385E-03, -5.6461E-04, 2.6101E-04, 6.1788E-04, 7.2059E-04, 6.2824E-04, 5.0646E-04, 3.6851E-04, 2.9390E-04, 2.4522E-04, 1.8706E-04, 1.4809E-04, 1.2770E-04, 1.0977E-04, 8.8556E-05, 8.0368E-05, 6.2793E-05, 6.3224E-05, 4.9255E-05, 4.7814E-05, 4.8389E-05, 4.6420E-05, 4.0171E-05, 4.4839E-05, 4.1754E-05, 3.9347E-05, 2.9073E-05, 1.9935E-05, 1.3297E-05, 1.2647E-05, 1.8328E-05, 1.8676E-05, 1.1933E-05, 2.0949E-05, 1.1837E-05, 1.2971E-05, 1.2153E-05, 1.3939E-05, 1.7795E-05, 6.2361E-06, 2.1885E-06, 3.4411E-06, 1.4580E-05, 2.1357E-05, 2.0194E-05, 2.0381E-05, 1.6193E-05, 1.5874E-05, 1.5358E-05, 1.2929E-05, 1.2228E-05, 1.0643E-05, 1.4912E-05, 1.3655E-05, 1.4422E-05, 1.2343E-05, 6.3112E-06, 3.5151E-06, 3.7949E-06, 9.1489E-06, 5.1843E-06, 8.2558E-06, 7.7578E-06, 8.3555E-06, 9.9648E-06, 4.8101E-06, 6.8158E-06, 5.0532E-06, 2.3190E-06, 1.8312E-07, 1.4920E-06, 4.6478E-06, 6.6372E-06, 8.1242E-06, 6.2813E-06, 5.5032E-06, 5.7015E-06, 4.2188E-06, 3.7896E-06, 2.5520E-06, 2.6092E-06, 2.8814E-06, 5.1117E-06, 5.5395E-06, 5.2149E-06, 3.8158E-06, 4.1536E-06, 4.5145E-06, 4.2874E-06, 4.6071E-06, 4.9139E-06, 5.3411E-06, 6.1229E-06, 5.8846E-06, 5.7326E-06, 2.6630E-06, -5.4897E-07, -2.7910E-06, 4.7700E-07, 3.0066E-06, 1.1248E-06, -2.4596E-08, 1.0215E-06, 5.9188E-07, 4.8281E-07, -3.1781E-09, 6.5029E-07, 1.0899E-06, -7.3618E-07, -1.0384E-06, -4.7718E-08, 6.2262E-07, 7.7841E-07, 6.2100E-07, 3.8803E-07, 2.3541E-07, 1.0460E-07, 4.6962E-08, 7.4441E-09, -3.6249E-09, -3.7066E-11, -5.2372E-10, 5.6248E-11, -7.6271E-11, 7.2302E-11, -4.0397E-09, -9.3469E-09, 4.0655E-09, 2.7794E-08, 8.1791E-08, 1.5044E-07, 3.0742E-07, 3.7727E-07, 3.8762E-07, -5.0195E-08, -6.7138E-07, -8.6669E-07, 3.8450E-07, 1.2139E-06, -8.9148E-07, 1.5161E-07, 6.4578E-07, 7.2612E-07, 8.5279E-07, 2.2806E-08, 1.4569E-06, -1.0990E-06, 1.6829E-06, 2.8495E-06, -1.6534E-06, -2.3796E-06, -1.5511E-07, 2.6544E-06, 4.5856E-06, 5.0039E-06, 5.1309E-06, 4.1022E-06, 4.2867E-06, 3.7176E-06, 4.3219E-06, 3.8239E-06, 3.7659E-06, 2.7119E-06, 2.3091E-06, 1.7713E-06, 1.5185E-06, 2.1978E-06, 3.3006E-06, 4.0713E-06, 3.5932E-06, 3.9792E-06, 4.7081E-06, 3.8032E-06, 3.0338E-06, 1.3067E-06, -8.3386E-07, 6.0807E-07, 4.6074E-06, 1.0884E-06, -2.0469E-06, 2.1479E-06, 3.2344E-06, 2.2924E-06, 4.2900E-06, 4.2646E-06, 4.2921E-06, 4.9102E-06, 8.5761E-06, 6.1453E-06, 5.6739E-07, 2.0704E-06, 5.3064E-06, 8.0538E-06, 9.6334E-06, 9.4842E-06, 1.0619E-05, 1.1334E-05, 1.0767E-05, 1.2439E-05, 1.2885E-05, 1.5042E-05, 1.1511E-05, 8.4103E-06, 2.0716E-06, 3.8458E-07, -1.2483E-06, 8.1225E-06, 1.5734E-05, 7.1102E-06, 6.2680E-06, 1.1625E-05, 1.1102E-05, 8.9504E-06, 1.3206E-05, 1.2393E-05, -6.5486E-09, 9.6248E-06, 1.5422E-05, 8.4653E-06, 3.7927E-06, 1.3529E-05, 2.4241E-05, 2.9483E-05, 3.2779E-05, 3.5677E-05, 3.6121E-05, 4.0840E-05, 3.7885E-05, 4.6014E-05, 5.1540E-05, 5.8716E-05, 6.3532E-05, 8.8276E-05, 1.0475E-04, 1.2300E-04, 1.5863E-04, 2.0866E-04, 2.6538E-04, 3.1568E-04, 3.8689E-04, 4.3170E-04, 4.3369E-04, 2.3548E-04, -2.1341E-04, -7.9574E-04, -5.5308E-04, 7.6324E-04, 2.3974E-04, -8.7691E-04, 7.7450E-04, -5.1636E-04, -1.5939E-04, 5.0922E-04, -3.0749E-04, 3.9064E-04, -7.6837E-04, 7.5001E-04, 1.0088E-04, -7.6236E-04, -5.1717E-04, -1.6859E-05, 3.5002E-04, 4.6181E-04, 4.3723E-04, 3.3927E-04, 2.7531E-04, 2.3423E-04, 1.8426E-04, 1.3628E-04, 1.1232E-04, 9.9975E-05, 7.3351E-05, 6.2129E-05, 5.0498E-05, 4.8109E-05, 4.1987E-05, 3.8093E-05, 3.9992E-05, 3.2867E-05, 3.2573E-05, 3.3010E-05, 3.0635E-05, 1.2811E-05, 4.3472E-06, 3.4567E-06, 1.0559E-05, 1.6581E-05, 7.1199E-06, 9.1188E-06, 1.4300E-05, 8.1685E-06, 1.3511E-05, 9.6381E-06, 1.0638E-05, 3.0308E-06, 8.3118E-06, 1.6003E-05, 6.3918E-06, 3.0966E-06, -1.0836E-06, 6.5664E-06, 1.2291E-05, 1.3734E-05, 1.4363E-05, 9.7526E-06, 1.1615E-05, 1.1514E-05, 1.2405E-05, 1.1063E-05, 8.3982E-06, 8.6608E-06, 6.4118E-06, 5.7327E-06, -2.4104E-07, 1.6373E-06, 5.6608E-06, 6.8946E-06, 5.3889E-06, 5.1352E-06, 5.9627E-06, 5.0677E-06, 3.3460E-06, 3.9050E-06, 1.3445E-06, 1.4309E-07, 2.8707E-06, 3.0944E-06, -1.6632E-08, 8.6962E-07, 1.9677E-06, 3.7269E-06, 5.0849E-06, 4.5791E-06, 2.8646E-06, 3.8781E-06, 4.5755E-06, 3.1862E-06, 1.6089E-06, 1.8025E-06, 1.7232E-06, 3.0324E-06, 2.6906E-06, 4.1475E-06, 4.0347E-06, 3.7478E-06, 3.3696E-06, 4.7095E-06, 4.4020E-06, 5.2298E-06, 4.6892E-06, 3.7225E-06, 1.2182E-06, -1.4559E-06, -3.0458E-06, -3.1261E-08, 3.1078E-06, -3.2668E-07, -2.4480E-07, 1.3664E-06, 1.3277E-07, 1.0316E-06, 6.1777E-07, 5.0784E-07, -5.6459E-07, 5.9133E-08, 1.0310E-06, -4.0869E-07, -6.6624E-07, -3.3181E-07, 2.8273E-07, 3.4484E-07, 3.0234E-07, 1.9591E-07, 8.2853E-08, 5.0977E-08, 1.2856E-08, 2.4141E-09, -5.5037E-10, -7.7381E-11, -2.0559E-11); \n\n//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x + i, coord.y);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 104, 104, 161], [163, 163, 186, 186, 231], [234, 234, 291, 291, 523]], "test": "untested"}
{"id": "clBXzw", "name": "Energetic overflow", "author": "kishimisu", "description": "Wondering how this would render in VR...", "tags": ["raymarching", "tunnel", "animated", "psychedelic", "animation", "glow", "loop", "code", "infinite", "neon", "short", "golf", "golfing", "perfect"], "likes": 29, "viewed": 709, "published": 3, "date": "1675798958", "time_retrieved": "2024-07-30T18:11:38.494014", "image_code": "/* \"Energetic Overflow\" by @kishimisu (2023) - https://www.shadertoy.com/view/clBXzw\n   [472 chars without anti-aliasing]\n*/\n\n#define AA 1. // Antialiasing level\n\n#define e(p,r) mod(p, r) - r/2.\n\nvoid mainImage(out vec4 O, vec2 F) { \n_AA_START\n    vec2 R = iResolution.xy, u = F+F+o - R;\n    vec3 p, g;\n    float i = 0., d = i, t=iTime*.5, s, r;\n    \n    for (g *= i; i++ < 60.;) \n        p = abs(d*normalize(vec3(u/R.y, 1))),\n        p.z += t*12.73,\n        p.xy *= mat2(cos(d*.03+vec4(0,33,11,0))),\n        r = .5 + sin(t) * (sin(p.z*2.)*.1 + cos(p.z*4.)*.05),\n        d += min(s = min(\n            length(e(p, vec3(5,5,20))) - r, \n            length(vec2(length(p.xy)-8., e(p.z, 20.)))-.25), \n            length(e(p.xy, 5.)) - r),\n        g += 1. / (1. + pow(abs(s)*40., 1.3));\n    \n    T += (1.5 * (cos(d + t + vec3(0,1,2)) + 1.) * g + g) / exp(d*.01);\n_AA_END \n}\n\n/* [472 chars]:\n\n#define e(p,r) mod(p, r) - r/2.\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy; u += u - R;\n    vec3 p, g;\n    float i = 0., d = i, t=iTime*.5, s, r;\n    \n    for (g *= i; i++ < 60.; \n        p = abs(d*normalize(vec3(u/R.y, 1))),\n        p.z += t*12.73,\n        p.xy *= mat2(cos(d*.03+vec4(0,33,11,0))),\n        r = .5 + sin(t) * (sin(p.z*2.)*.1 + cos(p.z*4.)*.05),\n        d += min(s = min(\n            length(e(p, vec3(5,5,20))) - r, \n            length(vec2(length(p.xy)-8., e(p.z, 20.)))-.25), \n            length(e(p.xy, 5.)) - r),\n        g += 1. / (1. + pow(abs(s)*40., 1.3)))\n    \n    O.rgb = (1.5 * (cos(d + t + vec3(0,1,2)) + 1.) * g + g) / exp(d*.01);\n}*/", "image_inputs": [], "common_code": "/* Anti-aliasing code */\n\n#define _AA_START                  \\\nvec3 T;                            \\\nfor (float j = 0.; j < AA; j++)    \\\nfor (float k = 0.; k < AA; k++) {  \\\nvec2 o = vec2(j, k) / AA - 0.5;\n\n#define _AA_END                    \\\n} T /= AA*AA;                      \\\nO = vec4(T, 1);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clSXzw", "name": "Video but...", "author": "fishy", "description": "... you can't see it if you pause. https://www.shadertoy.com/view/4djSRW for hash. It would be interesting to see this code golfed more also", "tags": ["noise", "video", "effect", "greenscreen"], "likes": 1, "viewed": 193, "published": 3, "date": "1675798789", "time_retrieved": "2024-07-30T18:11:39.242014", "image_code": "// Inspired by https://www.youtube.com/watch?v=Myeatl2Q3wM\n// and https://www.shadertoy.com/view/4tsSWl\n\n#define INVERSE 0\n#define ANIMATED 0\n\nvec3 hash23(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = \n    #if INVERSE\n    1.-\n    #endif\n    step(0.0001, pow(1.-texture(iChannel0, fragCoord/iResolution.xy).ggg, vec3(10)));\n    \n    fragColor = vec4(hash23(fragCoord+col.r*100.\n    #if ANIMATED\n    *iTime\n    #endif\n    ), 1.);\n}\n/*\n// First attempt at golfing (I am terrible at it) (still 258 chars)\n// The hash function is the biggest thing right now\nvec3 hash23(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvoid mainImage( out vec4 r, in vec2 d )\n{\n    r = vec4(hash23(d+\n    step(1e-4, pow(1.-texture(iChannel0, d/iResolution.xy).g, 10.))\n    *10.), 1.);\n}\n*/", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 164, 164, 300]], "test": "untested"}
{"id": "ctBSzw", "name": "Segmented digits", "author": "fishy", "description": "Segments!", "tags": ["digits", "counting"], "likes": 6, "viewed": 200, "published": 3, "date": "1675797182", "time_retrieved": "2024-07-30T18:11:39.997993", "image_code": "#define AA(d) smoothstep(-px, px, d)\nfloat box(in vec2 uv, vec2 b)\n{\n    uv = abs(uv)-b; return max(uv.x, uv.y);\n}\n\nstruct displayInfo\n{\n    bool a, b, c, d, e, f, g;\n};\n\n#define t true\n#define f false\ndisplayInfo[] info = displayInfo[] (\ndisplayInfo(t, t, t, t, t, t, f),\ndisplayInfo(f, t, t, f, f, f, f),\ndisplayInfo(t, t, f, t, t, f, t),\ndisplayInfo(t, t, t, t, f, f, t),\ndisplayInfo(f, t, t, f, f, t, t),\ndisplayInfo(t, f, t, t, f, t, t),\ndisplayInfo(t, f, t, t, t, t, t),\ndisplayInfo(t, t, t, f, f, f, f),\ndisplayInfo(t, t, t, t, t, t, t),\ndisplayInfo(t, t, t, t, f, t, t));\n#undef t\n#undef f\n\n#define vc(p, z, s) if(z) d = min(s d, box(uv-size.xx*p.xy, size.yx+vec2(0, size.y-st*0.75)))\n#define ve(p, z, s) if(z) d = min(s d, box(uv-size.xx*p.xy, size.yx+vec2(0, size.y*10.)))\n#define hc(p, z, s) if(z) d = min(s d, box(uv-vec2(0, size.x*p*2.), size.xy+vec2(size.y-st, 0)))\nfloat segDisplay(vec2 uv, vec2 size, displayInfo i)\n{\n    float st = size.y/size.x; // Thickness of segments\n    float d = 1e20;\n    hc(1.,               i.a,  );\n    vc(vec2(1, 1),       i.b,  );\n    vc(vec2(1, -1),      i.c,  );\n    hc(-1.,              i.d,  );\n    vc(vec2(-1, -1),     i.e,  );\n    vc(vec2(-1, 1),      i.f,  );\n    hc(0.,               i.g,  );\n    hc(st ,               true, -);\n    hc(-st ,              true,  );\n    ve(vec2(1.-st*2., 0), true, );\n    ve(vec2(-1.+st*2., 0), true, );\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float px = 2./iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(AA(segDisplay(uv, vec2(0.3, 0.05), info[int(mod(iTime, 10.))])));\n    #define t true\n    col += vec3(AA(segDisplay(uv, vec2(0.3, 0.05), displayInfo(t, t, t, t, t, t, t))))*0.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 68, 68, 114], [1412, 1412, 1469, 1519, 1898]], "test": "untested"}
{"id": "DlSSzw", "name": "DOF Kernel convolution", "author": "michael0884", "description": "8 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera"], "likes": 21, "viewed": 389, "published": 3, "date": "1675797180", "time_retrieved": "2024-07-30T18:11:40.994329", "image_code": "#define exposure 1.2\n#define sqrexposure 0.6\n#define gamma 1.3\n#define bloom 20.0\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*c-sqrexposure*c*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 0.0*acc.xyz/acc.w + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 8 columns of the U matrix: \nfloat U[408] = float[](0.0000E+00, 0.0000E+00, 0.0000E+00, -2.4065E-02, -6.5613E-02, -8.8278E-02, -1.0483E-01, -1.1767E-01, -1.2821E-01, -1.3687E-01, -1.4408E-01, -1.5008E-01, -1.5533E-01, -1.5957E-01, -1.6274E-01, -1.6579E-01, -1.6779E-01, -1.6971E-01, -1.7091E-01, -1.7188E-01, -1.7259E-01, -1.7293E-01, -1.7312E-01, -1.7327E-01, -1.7335E-01, -1.7338E-01, -1.7335E-01, -1.7327E-01, -1.7312E-01, -1.7293E-01, -1.7259E-01, -1.7188E-01, -1.7091E-01, -1.6971E-01, -1.6779E-01, -1.6579E-01, -1.6274E-01, -1.5957E-01, -1.5533E-01, -1.5008E-01, -1.4408E-01, -1.3687E-01, -1.2821E-01, -1.1767E-01, -1.0483E-01, -8.8278E-02, -6.5613E-02, -2.4065E-02, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -7.8657E-02, -2.0407E-01, -2.4957E-01, -2.5999E-01, -2.4892E-01, -2.2292E-01, -1.8795E-01, -1.4837E-01, -1.0726E-01, -6.4409E-02, -2.4713E-02, 7.8910E-03, 4.1720E-02, 6.5488E-02, 8.9230E-02, 1.0478E-01, 1.1752E-01, 1.2691E-01, 1.3144E-01, 1.3412E-01, 1.3608E-01, 1.3722E-01, 1.3760E-01, 1.3722E-01, 1.3608E-01, 1.3412E-01, 1.3144E-01, 1.2691E-01, 1.1752E-01, 1.0478E-01, 8.9230E-02, 6.5488E-02, 4.1720E-02, 7.8910E-03, -2.4713E-02, -6.4409E-02, -1.0726E-01, -1.4837E-01, -1.8795E-01, -2.2292E-01, -2.4892E-01, -2.5999E-01, -2.4957E-01, -2.0407E-01, -7.8657E-02, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -1.2159E-01, -2.8133E-01, -2.6729E-01, -1.7707E-01, -6.2094E-02, 4.9607E-02, 1.3751E-01, 1.9436E-01, 2.1958E-01, 2.1503E-01, 1.8682E-01, 1.4863E-01, 9.5153E-02, 4.9404E-02, -1.6434E-03, -3.9463E-02, -7.1037E-02, -9.4906E-02, -1.0700E-01, -1.1441E-01, -1.1981E-01, -1.2299E-01, -1.2402E-01, -1.2299E-01, -1.1981E-01, -1.1441E-01, -1.0700E-01, -9.4906E-02, -7.1037E-02, -3.9463E-02, -1.6434E-03, 4.9404E-02, 9.5153E-02, 1.4863E-01, 1.8682E-01, 2.1503E-01, 2.1958E-01, 1.9436E-01, 1.3751E-01, 4.9607E-02, -6.2094E-02, -1.7707E-01, -2.6729E-01, -2.8133E-01, -1.2159E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -1.5600E-01, -2.9848E-01, -1.5615E-01, 5.1537E-02, 2.0095E-01, 2.4708E-01, 1.9967E-01, 9.7856E-02, -1.9441E-02, -1.2401E-01, -1.8650E-01, -2.0595E-01, -1.8556E-01, -1.4558E-01, -8.4390E-02, -2.6794E-02, 2.2816E-02, 6.2173E-02, 8.3731E-02, 9.7689E-02, 1.0788E-01, 1.1386E-01, 1.1582E-01, 1.1386E-01, 1.0788E-01, 9.7689E-02, 8.3731E-02, 6.2173E-02, 2.2816E-02, -2.6794E-02, -8.4390E-02, -1.4558E-01, -1.8556E-01, -2.0595E-01, -1.8650E-01, -1.2401E-01, -1.9441E-02, 9.7856E-02, 1.9967E-01, 2.4708E-01, 2.0095E-01, 5.1537E-02, -1.5615E-01, -2.9848E-01, -1.5600E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 1.8421E-01, 2.6232E-01, -2.4118E-02, -2.4041E-01, -2.3492E-01, -6.5998E-02, 1.2112E-01, 2.2395E-01, 2.1430E-01, 1.1027E-01, -2.1991E-02, -1.2625E-01, -1.8577E-01, -1.9158E-01, -1.5029E-01, -8.4109E-02, -2.4164E-02, 2.7729E-02, 5.9765E-02, 8.2056E-02, 9.8327E-02, 1.0789E-01, 1.1101E-01, 1.0789E-01, 9.8327E-02, 8.2056E-02, 5.9765E-02, 2.7729E-02, -2.4164E-02, -8.4109E-02, -1.5029E-01, -1.9158E-01, -1.8577E-01, -1.2625E-01, -2.1991E-02, 1.1027E-01, 2.1430E-01, 2.2395E-01, 1.2112E-01, -6.5998E-02, -2.3492E-01, -2.4041E-01, -2.4118E-02, 2.6232E-01, 1.8421E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.1130E-01, 1.8786E-01, -1.9313E-01, -2.4601E-01, 9.8258E-04, 2.1986E-01, 2.1564E-01, 4.4144E-02, -1.4399E-01, -2.2271E-01, -1.6410E-01, -3.6037E-02, 9.7248E-02, 1.7735E-01, 1.8342E-01, 1.2534E-01, 6.7683E-02, 8.4743E-03, -3.5175E-02, -6.8252E-02, -9.2395E-02, -1.0658E-01, -1.1121E-01, -1.0658E-01, -9.2395E-02, -6.8252E-02, -3.5175E-02, 8.4743E-03, 6.7683E-02, 1.2534E-01, 1.8342E-01, 1.7735E-01, 9.7248E-02, -3.6037E-02, -1.6410E-01, -2.2271E-01, -1.4399E-01, 4.4144E-02, 2.1564E-01, 2.1986E-01, 9.8258E-04, -2.4601E-01, -1.9313E-01, 1.8786E-01, 2.1130E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.3655E-01, -8.7412E-02, 2.7781E-01, 6.9412E-02, -2.3542E-01, -1.7407E-01, 9.6584E-02, 2.3436E-01, 1.3063E-01, -8.6081E-02, -2.0729E-01, -1.7278E-01, -3.5397E-02, 1.1059E-01, 1.7336E-01, 1.4387E-01, 1.0570E-01, 4.6991E-02, -8.8410E-03, -5.5153E-02, -8.8956E-02, -1.0882E-01, -1.1530E-01, -1.0882E-01, -8.8956E-02, -5.5153E-02, -8.8410E-03, 4.6991E-02, 1.0570E-01, 1.4387E-01, 1.7336E-01, 1.1059E-01, -3.5397E-02, -1.7278E-01, -2.0729E-01, -8.6081E-02, 1.3063E-01, 2.3436E-01, 9.6584E-02, -1.7407E-01, -2.3542E-01, 6.9412E-02, 2.7781E-01, -8.7412E-02, -2.3655E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.6541E-01, 3.2433E-02, 2.4425E-01, -1.5895E-01, -2.0625E-01, 1.3418E-01, 2.2791E-01, -1.3099E-02, -2.2190E-01, -1.4513E-01, 6.7305E-02, 2.0136E-01, 1.5005E-01, -9.3857E-03, -1.1571E-01, -1.3903E-01, -1.4195E-01, -9.2390E-02, -2.2036E-02, 4.2063E-02, 8.8849E-02, 1.1634E-01, 1.2531E-01, 1.1634E-01, 8.8849E-02, 4.2063E-02, -2.2036E-02, -9.2390E-02, -1.4195E-01, -1.3903E-01, -1.1571E-01, -9.3857E-03, 1.5005E-01, 2.0136E-01, 6.7305E-02, -1.4513E-01, -2.2190E-01, -1.3099E-02, 2.2791E-01, 1.3418E-01, -2.0625E-01, -1.5895E-01, 2.4425E-01, 3.2433E-02, -2.6541E-01, 0.0000E+00, 0.0000E+00, 0.0000E+00); \n//The first 8 rows of the V matrix: \nfloat V[408] = float[](0.0000E+00, 0.0000E+00, 0.0000E+00, -5.7941E-04, -1.5797E-03, -2.1254E-03, -2.5239E-03, -2.8331E-03, -3.0869E-03, -3.2953E-03, -3.4690E-03, -3.6134E-03, -3.7398E-03, -3.8420E-03, -3.9183E-03, -3.9915E-03, -4.0397E-03, -4.0860E-03, -4.1149E-03, -4.1384E-03, -4.1554E-03, -4.1635E-03, -4.1682E-03, -4.1717E-03, -4.1737E-03, -4.1743E-03, -4.1737E-03, -4.1717E-03, -4.1682E-03, -4.1635E-03, -4.1554E-03, -4.1384E-03, -4.1149E-03, -4.0860E-03, -4.0397E-03, -3.9915E-03, -3.9183E-03, -3.8420E-03, -3.7398E-03, -3.6134E-03, -3.4690E-03, -3.2953E-03, -3.0869E-03, -2.8331E-03, -2.5239E-03, -2.1254E-03, -1.5797E-03, -5.7941E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 4.5119E-04, 1.1706E-03, 1.4316E-03, 1.4914E-03, 1.4278E-03, 1.2787E-03, 1.0781E-03, 8.5108E-04, 6.1524E-04, 3.6946E-04, 1.4176E-04, -4.5264E-05, -2.3931E-04, -3.7565E-04, -5.1184E-04, -6.0105E-04, -6.7414E-04, -7.2797E-04, -7.5399E-04, -7.6934E-04, -7.8055E-04, -7.8714E-04, -7.8929E-04, -7.8714E-04, -7.8055E-04, -7.6934E-04, -7.5399E-04, -7.2797E-04, -6.7414E-04, -6.0105E-04, -5.1184E-04, -3.7565E-04, -2.3931E-04, -4.5264E-05, 1.4176E-04, 3.6946E-04, 6.1524E-04, 8.5108E-04, 1.0781E-03, 1.2787E-03, 1.4278E-03, 1.4914E-03, 1.4316E-03, 1.1706E-03, 4.5119E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -3.8974E-04, -9.0176E-04, -8.5676E-04, -5.6758E-04, -1.9903E-04, 1.5901E-04, 4.4076E-04, 6.2300E-04, 7.0383E-04, 6.8924E-04, 5.9881E-04, 4.7642E-04, 3.0500E-04, 1.5835E-04, -5.2677E-06, -1.2649E-04, -2.2770E-04, -3.0421E-04, -3.4296E-04, -3.6671E-04, -3.8404E-04, -3.9422E-04, -3.9754E-04, -3.9422E-04, -3.8404E-04, -3.6671E-04, -3.4296E-04, -3.0421E-04, -2.2770E-04, -1.2649E-04, -5.2677E-06, 1.5835E-04, 3.0500E-04, 4.7642E-04, 5.9881E-04, 6.8924E-04, 7.0383E-04, 6.2300E-04, 4.4076E-04, 1.5901E-04, -1.9903E-04, -5.6758E-04, -8.5676E-04, -9.0176E-04, -3.8974E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 3.4046E-04, 6.5140E-04, 3.4078E-04, -1.1248E-04, -4.3855E-04, -5.3924E-04, -4.3576E-04, -2.1356E-04, 4.2428E-05, 2.7064E-04, 4.0702E-04, 4.4946E-04, 4.0496E-04, 3.1771E-04, 1.8417E-04, 5.8477E-05, -4.9794E-05, -1.3569E-04, -1.8274E-04, -2.1320E-04, -2.3543E-04, -2.4850E-04, -2.5276E-04, -2.4850E-04, -2.3543E-04, -2.1320E-04, -1.8274E-04, -1.3569E-04, -4.9794E-05, 5.8477E-05, 1.8417E-04, 3.1771E-04, 4.0496E-04, 4.4946E-04, 4.0702E-04, 2.7064E-04, 4.2428E-05, -2.1356E-04, -4.3576E-04, -5.3924E-04, -4.3855E-04, -1.1248E-04, 3.4078E-04, 6.5140E-04, 3.4046E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.9724E-04, 4.2327E-04, -3.8916E-05, -3.8791E-04, -3.7906E-04, -1.0649E-04, 1.9544E-04, 3.6136E-04, 3.4578E-04, 1.7793E-04, -3.5484E-05, -2.0371E-04, -2.9976E-04, -3.0913E-04, -2.4250E-04, -1.3571E-04, -3.8991E-05, 4.4742E-05, 9.6434E-05, 1.3240E-04, 1.5866E-04, 1.7408E-04, 1.7912E-04, 1.7408E-04, 1.5866E-04, 1.3240E-04, 9.6434E-05, 4.4742E-05, -3.8991E-05, -1.3571E-04, -2.4250E-04, -3.0913E-04, -2.9976E-04, -2.0371E-04, -3.5484E-05, 1.7793E-04, 3.4578E-04, 3.6136E-04, 1.9544E-04, -1.0649E-04, -3.7906E-04, -3.8791E-04, -3.8916E-05, 4.2327E-04, 2.9724E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.6356E-04, -2.3433E-04, 2.4090E-04, 3.0686E-04, -1.2256E-06, -2.7424E-04, -2.6898E-04, -5.5063E-05, 1.7961E-04, 2.7780E-04, 2.0468E-04, 4.4951E-05, -1.2130E-04, -2.2122E-04, -2.2879E-04, -1.5634E-04, -8.4424E-05, -1.0570E-05, 4.3876E-05, 8.5134E-05, 1.1525E-04, 1.3294E-04, 1.3872E-04, 1.3294E-04, 1.1525E-04, 8.5134E-05, 4.3876E-05, -1.0570E-05, -8.4424E-05, -1.5634E-04, -2.2879E-04, -2.2122E-04, -1.2130E-04, 4.4951E-05, 2.0468E-04, 2.7780E-04, 1.7961E-04, -5.5063E-05, -2.6898E-04, -2.7424E-04, -1.2256E-06, 3.0686E-04, 2.4090E-04, -2.3433E-04, -2.6356E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, -2.3591E-04, -8.7177E-05, 2.7706E-04, 6.9226E-05, -2.3478E-04, -1.7360E-04, 9.6324E-05, 2.3373E-04, 1.3028E-04, -8.5850E-05, -2.0674E-04, -1.7232E-04, -3.5302E-05, 1.1029E-04, 1.7289E-04, 1.4348E-04, 1.0542E-04, 4.6865E-05, -8.8172E-06, -5.5004E-05, -8.8717E-05, -1.0853E-04, -1.1499E-04, -1.0853E-04, -8.8717E-05, -5.5004E-05, -8.8172E-06, 4.6865E-05, 1.0542E-04, 1.4348E-04, 1.7289E-04, 1.1029E-04, -3.5302E-05, -1.7232E-04, -2.0674E-04, -8.5850E-05, 1.3028E-04, 2.3373E-04, 9.6324E-05, -1.7360E-04, -2.3478E-04, 6.9226E-05, 2.7706E-04, -8.7177E-05, -2.3591E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 2.1458E-04, -2.6221E-05, -1.9747E-04, 1.2851E-04, 1.6674E-04, -1.0848E-04, -1.8426E-04, 1.0590E-05, 1.7940E-04, 1.1734E-04, -5.4415E-05, -1.6280E-04, -1.2131E-04, 7.5882E-06, 9.3550E-05, 1.1240E-04, 1.1477E-04, 7.4696E-05, 1.7816E-05, -3.4007E-05, -7.1833E-05, -9.4060E-05, -1.0131E-04, -9.4060E-05, -7.1833E-05, -3.4007E-05, 1.7816E-05, 7.4696E-05, 1.1477E-04, 1.1240E-04, 9.3550E-05, 7.5882E-06, -1.2131E-04, -1.6280E-04, -5.4415E-05, 1.1734E-04, 1.7940E-04, 1.0590E-05, -1.8426E-04, -1.0848E-04, 1.6674E-04, 1.2851E-04, -1.9747E-04, -2.6221E-05, 2.1458E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00); \n//center of the convolution \nint Nc = 25; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 51; \n\n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.5*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec / (camdist*camdist));\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(i, 0), 1);\n        vec3 pcolor = pow(pixel.xyz/(pixel.w+1e-6), vec3(1.25));\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x, coord.y + i);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 104, 104, 157], [159, 159, 182, 182, 227], [230, 230, 287, 287, 519]], "test": "untested"}
{"id": "clSSzw", "name": "Star Field + 6rank convolution", "author": "michael0884", "description": "6 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera"], "likes": 24, "viewed": 376, "published": 3, "date": "1675796532", "time_retrieved": "2024-07-30T18:11:42.065465", "image_code": "#define exposure 1.5\n#define sqrexposure 0.5\n#define gamma 1.3\n#define bloom 8.0\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*(1.0+sqrexposure*c)*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 1.0*acc.xyz/acc.w + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 6 columns of the U matrix: \nfloat U[846] = float[](-2.2571E-08, -2.2370E-07, -6.4930E-07, -1.3150E-06, -2.2365E-06, -3.4301E-06, -4.9133E-06, -6.7046E-06, -8.8242E-06, -1.1294E-05, -1.4137E-05, -1.7379E-05, -2.1047E-05, -2.5172E-05, -2.9785E-05, -3.4924E-05, -4.0626E-05, -4.6935E-05, -5.3896E-05, -6.1562E-05, -6.9989E-05, -7.9238E-05, -8.9379E-05, -1.0049E-04, -1.1265E-04, -1.2595E-04, -1.4050E-04, -1.5642E-04, -1.7384E-04, -1.9289E-04, -2.1375E-04, -2.3661E-04, -2.6166E-04, -2.8915E-04, -3.1935E-04, -3.5257E-04, -3.8916E-04, -4.2954E-04, -4.7417E-04, -5.2360E-04, -5.7848E-04, -6.3956E-04, -7.0772E-04, -7.8401E-04, -8.6967E-04, -9.6621E-04, -1.0754E-03, -1.1996E-03, -1.3413E-03, -1.5040E-03, -1.6918E-03, -1.9100E-03, -2.1653E-03, -2.4666E-03, -2.8252E-03, -3.2563E-03, -3.7806E-03, -4.4268E-03, -5.2352E-03, -6.2646E-03, -7.6028E-03, -9.3861E-03, -1.1835E-02, -1.5326E-02, -2.0542E-02, -2.8833E-02, -4.3174E-02, -7.1174E-02, -1.3698E-01, -3.4335E-01, -8.4202E-01, -3.4335E-01, -1.3698E-01, -7.1174E-02, -4.3174E-02, -2.8833E-02, -2.0542E-02, -1.5326E-02, -1.1835E-02, -9.3861E-03, -7.6028E-03, -6.2646E-03, -5.2352E-03, -4.4268E-03, -3.7806E-03, -3.2563E-03, -2.8252E-03, -2.4666E-03, -2.1653E-03, -1.9100E-03, -1.6918E-03, -1.5040E-03, -1.3413E-03, -1.1996E-03, -1.0754E-03, -9.6621E-04, -8.6967E-04, -7.8401E-04, -7.0772E-04, -6.3956E-04, -5.7848E-04, -5.2360E-04, -4.7417E-04, -4.2954E-04, -3.8916E-04, -3.5257E-04, -3.1935E-04, -2.8915E-04, -2.6166E-04, -2.3661E-04, -2.1375E-04, -1.9289E-04, -1.7384E-04, -1.5642E-04, -1.4050E-04, -1.2595E-04, -1.1265E-04, -1.0049E-04, -8.9379E-05, -7.9238E-05, -6.9989E-05, -6.1562E-05, -5.3896E-05, -4.6935E-05, -4.0626E-05, -3.4924E-05, -2.9785E-05, -2.5172E-05, -2.1047E-05, -1.7379E-05, -1.4137E-05, -1.1294E-05, -8.8242E-06, -6.7046E-06, -4.9133E-06, -3.4301E-06, -2.2365E-06, -1.3150E-06, -6.4930E-07, -2.2370E-07, -2.2571E-08, 9.4992E-08, 1.2289E-06, 3.8698E-06, 8.1813E-06, 1.4299E-05, 2.2351E-05, 3.2472E-05, 4.4799E-05, 5.9477E-05, 7.6664E-05, 9.6527E-05, 1.1924E-04, 1.4501E-04, 1.7404E-04, 2.0657E-04, 2.4283E-04, 2.8310E-04, 3.2767E-04, 3.7687E-04, 4.3106E-04, 4.9062E-04, 5.5597E-04, 6.2759E-04, 7.0598E-04, 7.9174E-04, 8.8548E-04, 9.8790E-04, 1.0998E-03, 1.2220E-03, 1.3556E-03, 1.5015E-03, 1.6611E-03, 1.8357E-03, 2.0268E-03, 2.2363E-03, 2.4661E-03, 2.7185E-03, 2.9962E-03, 3.3021E-03, 3.6396E-03, 4.0129E-03, 4.4266E-03, 4.8861E-03, 5.3978E-03, 5.9693E-03, 6.6096E-03, 7.3294E-03, 8.1416E-03, 9.0619E-03, 1.0109E-02, 1.1307E-02, 1.2685E-02, 1.4278E-02, 1.6134E-02, 1.8312E-02, 2.0889E-02, 2.3966E-02, 2.7679E-02, 3.2213E-02, 3.7826E-02, 4.4882E-02, 5.3915E-02, 6.5726E-02, 8.1554E-02, 1.0339E-01, 1.3454E-01, 1.8060E-01, 2.5039E-01, 3.4843E-01, 3.4410E-01, -4.7815E-01, 3.4410E-01, 3.4843E-01, 2.5039E-01, 1.8060E-01, 1.3454E-01, 1.0339E-01, 8.1554E-02, 6.5726E-02, 5.3915E-02, 4.4882E-02, 3.7826E-02, 3.2213E-02, 2.7679E-02, 2.3966E-02, 2.0889E-02, 1.8312E-02, 1.6134E-02, 1.4278E-02, 1.2685E-02, 1.1307E-02, 1.0109E-02, 9.0619E-03, 8.1416E-03, 7.3294E-03, 6.6096E-03, 5.9693E-03, 5.3978E-03, 4.8861E-03, 4.4266E-03, 4.0129E-03, 3.6396E-03, 3.3021E-03, 2.9962E-03, 2.7185E-03, 2.4661E-03, 2.2363E-03, 2.0268E-03, 1.8357E-03, 1.6611E-03, 1.5015E-03, 1.3556E-03, 1.2220E-03, 1.0998E-03, 9.8790E-04, 8.8548E-04, 7.9174E-04, 7.0598E-04, 6.2759E-04, 5.5597E-04, 4.9062E-04, 4.3106E-04, 3.7687E-04, 3.2767E-04, 2.8310E-04, 2.4283E-04, 2.0657E-04, 1.7404E-04, 1.4501E-04, 1.1924E-04, 9.6527E-05, 7.6664E-05, 5.9477E-05, 4.4799E-05, 3.2472E-05, 2.2351E-05, 1.4299E-05, 8.1813E-06, 3.8698E-06, 1.2289E-06, 9.4992E-08, 6.0990E-08, 2.5096E-06, 9.8909E-06, 2.3300E-05, 4.3496E-05, 7.1123E-05, 1.0678E-04, 1.5108E-04, 2.0460E-04, 2.6800E-04, 3.4192E-04, 4.2707E-04, 5.2420E-04, 6.3411E-04, 7.5767E-04, 8.9581E-04, 1.0495E-03, 1.2199E-03, 1.4082E-03, 1.6156E-03, 1.8436E-03, 2.0936E-03, 2.3675E-03, 2.6669E-03, 2.9939E-03, 3.3508E-03, 3.7400E-03, 4.1641E-03, 4.6261E-03, 5.1294E-03, 5.6775E-03, 6.2746E-03, 6.9252E-03, 7.6343E-03, 8.4076E-03, 9.2516E-03, 1.0173E-02, 1.1181E-02, 1.2283E-02, 1.3491E-02, 1.4816E-02, 1.6272E-02, 1.7874E-02, 1.9641E-02, 2.1592E-02, 2.3751E-02, 2.6147E-02, 2.8812E-02, 3.1783E-02, 3.5106E-02, 3.8833E-02, 4.3028E-02, 4.7765E-02, 5.3134E-02, 5.9243E-02, 6.6222E-02, 7.4226E-02, 8.3442E-02, 9.4089E-02, 1.0642E-01, 1.2072E-01, 1.3725E-01, 1.5616E-01, 1.7725E-01, 1.9930E-01, 2.1837E-01, 2.2300E-01, 1.8046E-01, 6.7147E-04, -3.9974E-01, 2.2485E-01, -3.9974E-01, 6.7147E-04, 1.8046E-01, 2.2300E-01, 2.1837E-01, 1.9930E-01, 1.7725E-01, 1.5616E-01, 1.3725E-01, 1.2072E-01, 1.0642E-01, 9.4089E-02, 8.3442E-02, 7.4226E-02, 6.6222E-02, 5.9243E-02, 5.3134E-02, 4.7765E-02, 4.3028E-02, 3.8833E-02, 3.5106E-02, 3.1783E-02, 2.8812E-02, 2.6147E-02, 2.3751E-02, 2.1592E-02, 1.9641E-02, 1.7874E-02, 1.6272E-02, 1.4816E-02, 1.3491E-02, 1.2283E-02, 1.1181E-02, 1.0173E-02, 9.2516E-03, 8.4076E-03, 7.6343E-03, 6.9252E-03, 6.2746E-03, 5.6775E-03, 5.1294E-03, 4.6261E-03, 4.1641E-03, 3.7400E-03, 3.3508E-03, 2.9939E-03, 2.6669E-03, 2.3675E-03, 2.0936E-03, 1.8436E-03, 1.6156E-03, 1.4082E-03, 1.2199E-03, 1.0495E-03, 8.9581E-04, 7.5767E-04, 6.3411E-04, 5.2420E-04, 4.2707E-04, 3.4192E-04, 2.6800E-04, 2.0460E-04, 1.5108E-04, 1.0678E-04, 7.1123E-05, 4.3496E-05, 2.3300E-05, 9.8909E-06, 2.5096E-06, 6.0990E-08, 3.9202E-07, 1.0707E-06, -5.5638E-06, -2.4920E-05, -6.0595E-05, -1.1535E-04, -1.9154E-04, -2.9125E-04, -4.1649E-04, -5.6920E-04, -7.5135E-04, -9.6493E-04, -1.2120E-03, -1.4948E-03, -1.8154E-03, -2.1764E-03, -2.5802E-03, -3.0297E-03, -3.5276E-03, -4.0771E-03, -4.6816E-03, -5.3446E-03, -6.0699E-03, -6.8619E-03, -7.7248E-03, -8.6637E-03, -9.6836E-03, -1.0790E-02, -1.1990E-02, -1.3290E-02, -1.4696E-02, -1.6217E-02, -1.7861E-02, -1.9638E-02, -2.1557E-02, -2.3629E-02, -2.5867E-02, -2.8283E-02, -3.0891E-02, -3.3706E-02, -3.6744E-02, -4.0023E-02, -4.3561E-02, -4.7378E-02, -5.1495E-02, -5.5934E-02, -6.0715E-02, -6.5862E-02, -7.1394E-02, -7.7329E-02, -8.3678E-02, -9.0445E-02, -9.7618E-02, -1.0516E-01, -1.1301E-01, -1.2104E-01, -1.2905E-01, -1.3672E-01, -1.4351E-01, -1.4862E-01, -1.5076E-01, -1.4794E-01, -1.3703E-01, -1.1319E-01, -6.9090E-02, 5.3226E-03, 1.1949E-01, 2.5994E-01, 2.8518E-01, -2.6692E-01, 9.7440E-02, -2.6692E-01, 2.8518E-01, 2.5994E-01, 1.1949E-01, 5.3226E-03, -6.9090E-02, -1.1319E-01, -1.3703E-01, -1.4794E-01, -1.5076E-01, -1.4862E-01, -1.4351E-01, -1.3672E-01, -1.2905E-01, -1.2104E-01, -1.1301E-01, -1.0516E-01, -9.7618E-02, -9.0445E-02, -8.3678E-02, -7.7329E-02, -7.1394E-02, -6.5862E-02, -6.0715E-02, -5.5934E-02, -5.1495E-02, -4.7378E-02, -4.3561E-02, -4.0023E-02, -3.6744E-02, -3.3706E-02, -3.0891E-02, -2.8283E-02, -2.5867E-02, -2.3629E-02, -2.1557E-02, -1.9638E-02, -1.7861E-02, -1.6217E-02, -1.4696E-02, -1.3290E-02, -1.1990E-02, -1.0790E-02, -9.6836E-03, -8.6637E-03, -7.7248E-03, -6.8619E-03, -6.0699E-03, -5.3446E-03, -4.6816E-03, -4.0771E-03, -3.5276E-03, -3.0297E-03, -2.5802E-03, -2.1764E-03, -1.8154E-03, -1.4948E-03, -1.2120E-03, -9.6493E-04, -7.5135E-04, -5.6920E-04, -4.1649E-04, -2.9125E-04, -1.9154E-04, -1.1535E-04, -6.0595E-05, -2.4920E-05, -5.5638E-06, 1.0707E-06, 3.9202E-07, -1.4704E-07, -1.3202E-05, -3.6444E-05, -5.3538E-05, -5.0987E-05, -1.8179E-05, 5.3515E-05, 1.7132E-04, 3.4153E-04, 5.6982E-04, 8.6144E-04, 1.2213E-03, 1.6543E-03, 2.1651E-03, 2.7583E-03, 3.4388E-03, 4.2113E-03, 5.0807E-03, 6.0520E-03, 7.1305E-03, 8.3215E-03, 9.6305E-03, 1.1063E-02, 1.2625E-02, 1.4323E-02, 1.6163E-02, 1.8152E-02, 2.0295E-02, 2.2599E-02, 2.5071E-02, 2.7718E-02, 3.0545E-02, 3.3560E-02, 3.6766E-02, 4.0170E-02, 4.3775E-02, 4.7584E-02, 5.1598E-02, 5.5815E-02, 6.0231E-02, 6.4838E-02, 6.9623E-02, 7.4565E-02, 7.9638E-02, 8.4803E-02, 9.0009E-02, 9.5187E-02, 1.0025E-01, 1.0508E-01, 1.0952E-01, 1.1338E-01, 1.1641E-01, 1.1828E-01, 1.1860E-01, 1.1683E-01, 1.1233E-01, 1.0428E-01, 9.1694E-02, 7.3374E-02, 4.7982E-02, 1.4157E-02, -2.9124E-02, -8.1707E-02, -1.4040E-01, -1.9506E-01, -2.2082E-01, -1.6617E-01, 4.4884E-02, 3.5089E-01, -1.5379E-01, 4.3140E-02, -1.5379E-01, 3.5089E-01, 4.4884E-02, -1.6617E-01, -2.2082E-01, -1.9506E-01, -1.4040E-01, -8.1707E-02, -2.9124E-02, 1.4157E-02, 4.7982E-02, 7.3374E-02, 9.1694E-02, 1.0428E-01, 1.1233E-01, 1.1683E-01, 1.1860E-01, 1.1828E-01, 1.1641E-01, 1.1338E-01, 1.0952E-01, 1.0508E-01, 1.0025E-01, 9.5187E-02, 9.0009E-02, 8.4803E-02, 7.9638E-02, 7.4565E-02, 6.9623E-02, 6.4838E-02, 6.0231E-02, 5.5815E-02, 5.1598E-02, 4.7584E-02, 4.3775E-02, 4.0170E-02, 3.6766E-02, 3.3560E-02, 3.0545E-02, 2.7718E-02, 2.5071E-02, 2.2599E-02, 2.0295E-02, 1.8152E-02, 1.6163E-02, 1.4323E-02, 1.2625E-02, 1.1063E-02, 9.6305E-03, 8.3215E-03, 7.1305E-03, 6.0520E-03, 5.0807E-03, 4.2113E-03, 3.4388E-03, 2.7583E-03, 2.1651E-03, 1.6543E-03, 1.2213E-03, 8.6144E-04, 5.6982E-04, 3.4153E-04, 1.7132E-04, 5.3515E-05, -1.8179E-05, -5.0987E-05, -5.3538E-05, -3.6444E-05, -1.3202E-05, -1.4704E-07, -2.1775E-06, 7.8028E-06, 9.3692E-05, 2.4587E-04, 4.3108E-04, 6.1532E-04, 7.6838E-04, 8.6463E-04, 8.8226E-04, 8.0272E-04, 6.1001E-04, 2.9028E-04, -1.6864E-04, -7.7768E-04, -1.5466E-03, -2.4843E-03, -3.5989E-03, -4.8978E-03, -6.3881E-03, -8.0759E-03, -9.9669E-03, -1.2066E-02, -1.4379E-02, -1.6907E-02, -1.9655E-02, -2.2624E-02, -2.5813E-02, -2.9223E-02, -3.2851E-02, -3.6690E-02, -4.0733E-02, -4.4971E-02, -4.9387E-02, -5.3964E-02, -5.8676E-02, -6.3495E-02, -6.8382E-02, -7.3291E-02, -7.8166E-02, -8.2939E-02, -8.7527E-02, -9.1833E-02, -9.5738E-02, -9.9103E-02, -1.0176E-01, -1.0353E-01, -1.0417E-01, -1.0343E-01, -1.0101E-01, -9.6579E-02, -8.9754E-02, -8.0133E-02, -6.7294E-02, -5.0825E-02, -3.0372E-02, -5.7158E-03, 2.3097E-02, 5.5550E-02, 9.0345E-02, 1.2493E-01, 1.5482E-01, 1.7275E-01, 1.6784E-01, 1.2563E-01, 3.1708E-02, -1.1356E-01, -2.5260E-01, -1.9028E-01, 2.9812E-01, -8.2496E-02, 1.9384E-02, -8.2496E-02, 2.9812E-01, -1.9028E-01, -2.5260E-01, -1.1356E-01, 3.1708E-02, 1.2563E-01, 1.6784E-01, 1.7275E-01, 1.5482E-01, 1.2493E-01, 9.0345E-02, 5.5550E-02, 2.3097E-02, -5.7158E-03, -3.0372E-02, -5.0825E-02, -6.7294E-02, -8.0133E-02, -8.9754E-02, -9.6579E-02, -1.0101E-01, -1.0343E-01, -1.0417E-01, -1.0353E-01, -1.0176E-01, -9.9103E-02, -9.5738E-02, -9.1833E-02, -8.7527E-02, -8.2939E-02, -7.8166E-02, -7.3291E-02, -6.8382E-02, -6.3495E-02, -5.8676E-02, -5.3964E-02, -4.9387E-02, -4.4971E-02, -4.0733E-02, -3.6690E-02, -3.2851E-02, -2.9223E-02, -2.5813E-02, -2.2624E-02, -1.9655E-02, -1.6907E-02, -1.4379E-02, -1.2066E-02, -9.9669E-03, -8.0759E-03, -6.3881E-03, -4.8978E-03, -3.5989E-03, -2.4843E-03, -1.5466E-03, -7.7768E-04, -1.6864E-04, 2.9028E-04, 6.1001E-04, 8.0272E-04, 8.8226E-04, 8.6463E-04, 7.6838E-04, 6.1532E-04, 4.3108E-04, 2.4587E-04, 9.3692E-05, 7.8028E-06, -2.1775E-06); \n//The first 6 rows of the V matrix: \nfloat V[846] = float[](-2.4998E-09, -2.4775E-08, -7.1910E-08, -1.4564E-07, -2.4770E-07, -3.7989E-07, -5.4415E-07, -7.4254E-07, -9.7729E-07, -1.2508E-06, -1.5657E-06, -1.9247E-06, -2.3310E-06, -2.7878E-06, -3.2988E-06, -3.8679E-06, -4.4994E-06, -5.1981E-06, -5.9691E-06, -6.8181E-06, -7.7513E-06, -8.7757E-06, -9.8988E-06, -1.1129E-05, -1.2476E-05, -1.3949E-05, -1.5561E-05, -1.7324E-05, -1.9253E-05, -2.1363E-05, -2.3673E-05, -2.6204E-05, -2.8979E-05, -3.2024E-05, -3.5368E-05, -3.9047E-05, -4.3100E-05, -4.7572E-05, -5.2515E-05, -5.7990E-05, -6.4068E-05, -7.0832E-05, -7.8381E-05, -8.6830E-05, -9.6317E-05, -1.0701E-04, -1.1911E-04, -1.3285E-04, -1.4855E-04, -1.6657E-04, -1.8737E-04, -2.1153E-04, -2.3981E-04, -2.7318E-04, -3.1289E-04, -3.6064E-04, -4.1871E-04, -4.9028E-04, -5.7981E-04, -6.9382E-04, -8.4202E-04, -1.0395E-03, -1.3107E-03, -1.6973E-03, -2.2750E-03, -3.1933E-03, -4.7816E-03, -7.8826E-03, -1.5171E-02, -3.8026E-02, -9.3254E-02, -3.8026E-02, -1.5171E-02, -7.8826E-03, -4.7816E-03, -3.1933E-03, -2.2750E-03, -1.6973E-03, -1.3107E-03, -1.0395E-03, -8.4202E-04, -6.9382E-04, -5.7981E-04, -4.9028E-04, -4.1871E-04, -3.6064E-04, -3.1289E-04, -2.7318E-04, -2.3981E-04, -2.1153E-04, -1.8737E-04, -1.6657E-04, -1.4855E-04, -1.3285E-04, -1.1911E-04, -1.0701E-04, -9.6317E-05, -8.6830E-05, -7.8381E-05, -7.0832E-05, -6.4068E-05, -5.7990E-05, -5.2515E-05, -4.7572E-05, -4.3100E-05, -3.9047E-05, -3.5368E-05, -3.2024E-05, -2.8979E-05, -2.6204E-05, -2.3673E-05, -2.1363E-05, -1.9253E-05, -1.7324E-05, -1.5561E-05, -1.3949E-05, -1.2476E-05, -1.1129E-05, -9.8988E-06, -8.7757E-06, -7.7513E-06, -6.8181E-06, -5.9691E-06, -5.1981E-06, -4.4994E-06, -3.8679E-06, -3.2988E-06, -2.7878E-06, -2.3310E-06, -1.9247E-06, -1.5657E-06, -1.2508E-06, -9.7729E-07, -7.4254E-07, -5.4415E-07, -3.7989E-07, -2.4770E-07, -1.4564E-07, -7.1910E-08, -2.4775E-08, -2.4998E-09, 2.0267E-09, 2.6220E-08, 8.2565E-08, 1.7455E-07, 3.0507E-07, 4.7688E-07, 6.9282E-07, 9.5582E-07, 1.2690E-06, 1.6357E-06, 2.0595E-06, 2.5442E-06, 3.0940E-06, 3.7134E-06, 4.4072E-06, 5.1809E-06, 6.0401E-06, 6.9911E-06, 8.0409E-06, 9.1970E-06, 1.0468E-05, 1.1862E-05, 1.3390E-05, 1.5063E-05, 1.6892E-05, 1.8892E-05, 2.1078E-05, 2.3465E-05, 2.6073E-05, 2.8923E-05, 3.2037E-05, 3.5441E-05, 3.9166E-05, 4.3245E-05, 4.7714E-05, 5.2617E-05, 5.8002E-05, 6.3926E-05, 7.0452E-05, 7.7655E-05, 8.5619E-05, 9.4445E-05, 1.0425E-04, 1.1517E-04, 1.2736E-04, 1.4102E-04, 1.5638E-04, 1.7371E-04, 1.9334E-04, 2.1569E-04, 2.4125E-04, 2.7064E-04, 3.0464E-04, 3.4424E-04, 3.9071E-04, 4.4569E-04, 5.1134E-04, 5.9056E-04, 6.8730E-04, 8.0704E-04, 9.5760E-04, 1.1503E-03, 1.4023E-03, 1.7400E-03, 2.2059E-03, 2.8706E-03, 3.8533E-03, 5.3424E-03, 7.4340E-03, 7.3418E-03, -1.0202E-02, 7.3418E-03, 7.4340E-03, 5.3424E-03, 3.8533E-03, 2.8706E-03, 2.2059E-03, 1.7400E-03, 1.4023E-03, 1.1503E-03, 9.5760E-04, 8.0704E-04, 6.8730E-04, 5.9056E-04, 5.1134E-04, 4.4569E-04, 3.9071E-04, 3.4424E-04, 3.0464E-04, 2.7064E-04, 2.4125E-04, 2.1569E-04, 1.9334E-04, 1.7371E-04, 1.5638E-04, 1.4102E-04, 1.2736E-04, 1.1517E-04, 1.0425E-04, 9.4445E-05, 8.5619E-05, 7.7655E-05, 7.0452E-05, 6.3926E-05, 5.8002E-05, 5.2617E-05, 4.7714E-05, 4.3245E-05, 3.9166E-05, 3.5441E-05, 3.2037E-05, 2.8923E-05, 2.6073E-05, 2.3465E-05, 2.1078E-05, 1.8892E-05, 1.6892E-05, 1.5063E-05, 1.3390E-05, 1.1862E-05, 1.0468E-05, 9.1970E-06, 8.0409E-06, 6.9911E-06, 6.0401E-06, 5.1809E-06, 4.4072E-06, 3.7134E-06, 3.0940E-06, 2.5442E-06, 2.0595E-06, 1.6357E-06, 1.2690E-06, 9.5582E-07, 6.9282E-07, 4.7688E-07, 3.0507E-07, 1.7455E-07, 8.2565E-08, 2.6220E-08, 2.0267E-09, 3.8066E-10, 1.5663E-08, 6.1732E-08, 1.4542E-07, 2.7147E-07, 4.4390E-07, 6.6647E-07, 9.4290E-07, 1.2770E-06, 1.6726E-06, 2.1340E-06, 2.6655E-06, 3.2717E-06, 3.9577E-06, 4.7289E-06, 5.5910E-06, 6.5504E-06, 7.6140E-06, 8.7890E-06, 1.0084E-05, 1.1506E-05, 1.3067E-05, 1.4776E-05, 1.6645E-05, 1.8686E-05, 2.0913E-05, 2.3342E-05, 2.5989E-05, 2.8873E-05, 3.2014E-05, 3.5435E-05, 3.9162E-05, 4.3222E-05, 4.7648E-05, 5.2474E-05, 5.7742E-05, 6.3494E-05, 6.9782E-05, 7.6663E-05, 8.4202E-05, 9.2473E-05, 1.0156E-04, 1.1156E-04, 1.2258E-04, 1.3476E-04, 1.4824E-04, 1.6319E-04, 1.7982E-04, 1.9837E-04, 2.1910E-04, 2.4237E-04, 2.6855E-04, 2.9811E-04, 3.3163E-04, 3.6976E-04, 4.1331E-04, 4.6327E-04, 5.2078E-04, 5.8724E-04, 6.6421E-04, 7.5344E-04, 8.5659E-04, 9.7463E-04, 1.1063E-03, 1.2439E-03, 1.3629E-03, 1.3918E-03, 1.1263E-03, 4.1908E-06, -2.4949E-03, 1.4034E-03, -2.4949E-03, 4.1908E-06, 1.1263E-03, 1.3918E-03, 1.3629E-03, 1.2439E-03, 1.1063E-03, 9.7463E-04, 8.5659E-04, 7.5344E-04, 6.6421E-04, 5.8724E-04, 5.2078E-04, 4.6327E-04, 4.1331E-04, 3.6976E-04, 3.3163E-04, 2.9811E-04, 2.6855E-04, 2.4237E-04, 2.1910E-04, 1.9837E-04, 1.7982E-04, 1.6319E-04, 1.4824E-04, 1.3476E-04, 1.2258E-04, 1.1156E-04, 1.0156E-04, 9.2473E-05, 8.4202E-05, 7.6663E-05, 6.9782E-05, 6.3494E-05, 5.7742E-05, 5.2474E-05, 4.7648E-05, 4.3222E-05, 3.9162E-05, 3.5435E-05, 3.2014E-05, 2.8873E-05, 2.5989E-05, 2.3342E-05, 2.0913E-05, 1.8686E-05, 1.6645E-05, 1.4776E-05, 1.3067E-05, 1.1506E-05, 1.0084E-05, 8.7890E-06, 7.6140E-06, 6.5504E-06, 5.5910E-06, 4.7289E-06, 3.9577E-06, 3.2717E-06, 2.6655E-06, 2.1340E-06, 1.6726E-06, 1.2770E-06, 9.4290E-07, 6.6647E-07, 4.4390E-07, 2.7147E-07, 1.4542E-07, 6.1732E-08, 1.5663E-08, 3.8066E-10, 7.3282E-10, 2.0015E-09, -1.0401E-08, -4.6583E-08, -1.1327E-07, -2.1564E-07, -3.5805E-07, -5.4444E-07, -7.7855E-07, -1.0640E-06, -1.4045E-06, -1.8038E-06, -2.2657E-06, -2.7942E-06, -3.3936E-06, -4.0684E-06, -4.8233E-06, -5.6635E-06, -6.5943E-06, -7.6215E-06, -8.7515E-06, -9.9908E-06, -1.1347E-05, -1.2827E-05, -1.4440E-05, -1.6195E-05, -1.8102E-05, -2.0171E-05, -2.2414E-05, -2.4843E-05, -2.7472E-05, -3.0315E-05, -3.3388E-05, -3.6709E-05, -4.0297E-05, -4.4171E-05, -4.8355E-05, -5.2871E-05, -5.7746E-05, -6.3008E-05, -6.8687E-05, -7.4816E-05, -8.1430E-05, -8.8566E-05, -9.6262E-05, -1.0456E-04, -1.1350E-04, -1.2312E-04, -1.3346E-04, -1.4455E-04, -1.5642E-04, -1.6907E-04, -1.8248E-04, -1.9659E-04, -2.1126E-04, -2.2627E-04, -2.4125E-04, -2.5557E-04, -2.6827E-04, -2.7782E-04, -2.8183E-04, -2.7656E-04, -2.5616E-04, -2.1158E-04, -1.2915E-04, 9.9497E-06, 2.2337E-04, 4.8592E-04, 5.3309E-04, -4.9897E-04, 1.8215E-04, -4.9897E-04, 5.3309E-04, 4.8592E-04, 2.2337E-04, 9.9497E-06, -1.2915E-04, -2.1158E-04, -2.5616E-04, -2.7656E-04, -2.8183E-04, -2.7782E-04, -2.6827E-04, -2.5557E-04, -2.4125E-04, -2.2627E-04, -2.1126E-04, -1.9659E-04, -1.8248E-04, -1.6907E-04, -1.5642E-04, -1.4455E-04, -1.3346E-04, -1.2312E-04, -1.1350E-04, -1.0456E-04, -9.6262E-05, -8.8566E-05, -8.1430E-05, -7.4816E-05, -6.8687E-05, -6.3008E-05, -5.7746E-05, -5.2871E-05, -4.8355E-05, -4.4171E-05, -4.0297E-05, -3.6709E-05, -3.3388E-05, -3.0315E-05, -2.7472E-05, -2.4843E-05, -2.2414E-05, -2.0171E-05, -1.8102E-05, -1.6195E-05, -1.4440E-05, -1.2827E-05, -1.1347E-05, -9.9908E-06, -8.7515E-06, -7.6215E-06, -6.5943E-06, -5.6635E-06, -4.8233E-06, -4.0684E-06, -3.3936E-06, -2.7942E-06, -2.2657E-06, -1.8038E-06, -1.4045E-06, -1.0640E-06, -7.7855E-07, -5.4444E-07, -3.5805E-07, -2.1564E-07, -1.1327E-07, -4.6583E-08, -1.0401E-08, 2.0015E-09, 7.3282E-10, -7.9865E-11, -7.1710E-09, -1.9795E-08, -2.9080E-08, -2.7694E-08, -9.8739E-09, 2.9067E-08, 9.3053E-08, 1.8551E-07, 3.0951E-07, 4.6790E-07, 6.6338E-07, 8.9856E-07, 1.1760E-06, 1.4982E-06, 1.8678E-06, 2.2874E-06, 2.7596E-06, 3.2872E-06, 3.8730E-06, 4.5199E-06, 5.2309E-06, 6.0091E-06, 6.8577E-06, 7.7800E-06, 8.7794E-06, 9.8593E-06, 1.1023E-05, 1.2275E-05, 1.3618E-05, 1.5055E-05, 1.6591E-05, 1.8228E-05, 1.9970E-05, 2.1819E-05, 2.3777E-05, 2.5846E-05, 2.8026E-05, 3.0317E-05, 3.2715E-05, 3.5218E-05, 3.7816E-05, 4.0501E-05, 4.3256E-05, 4.6062E-05, 4.8889E-05, 5.1702E-05, 5.4451E-05, 5.7073E-05, 5.9485E-05, 6.1582E-05, 6.3227E-05, 6.4246E-05, 6.4417E-05, 6.3458E-05, 6.1014E-05, 5.6643E-05, 4.9805E-05, 3.9854E-05, 2.6062E-05, 7.6895E-06, -1.5819E-05, -4.4380E-05, -7.6261E-05, -1.0595E-04, -1.1994E-04, -9.0258E-05, 2.4380E-05, 1.9059E-04, -8.3532E-05, 2.3432E-05, -8.3532E-05, 1.9059E-04, 2.4380E-05, -9.0258E-05, -1.1994E-04, -1.0595E-04, -7.6261E-05, -4.4380E-05, -1.5819E-05, 7.6895E-06, 2.6062E-05, 3.9854E-05, 4.9805E-05, 5.6643E-05, 6.1014E-05, 6.3458E-05, 6.4417E-05, 6.4246E-05, 6.3227E-05, 6.1582E-05, 5.9485E-05, 5.7073E-05, 5.4451E-05, 5.1702E-05, 4.8889E-05, 4.6062E-05, 4.3256E-05, 4.0501E-05, 3.7816E-05, 3.5218E-05, 3.2715E-05, 3.0317E-05, 2.8026E-05, 2.5846E-05, 2.3777E-05, 2.1819E-05, 1.9970E-05, 1.8228E-05, 1.6591E-05, 1.5055E-05, 1.3618E-05, 1.2275E-05, 1.1023E-05, 9.8593E-06, 8.7794E-06, 7.7800E-06, 6.8577E-06, 6.0091E-06, 5.2309E-06, 4.5199E-06, 3.8730E-06, 3.2872E-06, 2.7596E-06, 2.2874E-06, 1.8678E-06, 1.4982E-06, 1.1760E-06, 8.9856E-07, 6.6338E-07, 4.6790E-07, 3.0951E-07, 1.8551E-07, 9.3053E-08, 2.9067E-08, -9.8739E-09, -2.7694E-08, -2.9080E-08, -1.9795E-08, -7.1710E-09, -7.9865E-11, -3.2507E-10, 1.1649E-09, 1.3987E-08, 3.6706E-08, 6.4355E-08, 9.1859E-08, 1.1471E-07, 1.2908E-07, 1.3171E-07, 1.1984E-07, 9.1067E-08, 4.3336E-08, -2.5176E-08, -1.1610E-07, -2.3089E-07, -3.7087E-07, -5.3727E-07, -7.3119E-07, -9.5366E-07, -1.2056E-06, -1.4879E-06, -1.8014E-06, -2.1465E-06, -2.5240E-06, -2.9342E-06, -3.3774E-06, -3.8536E-06, -4.3627E-06, -4.9042E-06, -5.4773E-06, -6.0810E-06, -6.7136E-06, -7.3729E-06, -8.0561E-06, -8.7597E-06, -9.4790E-06, -1.0209E-05, -1.0941E-05, -1.1669E-05, -1.2382E-05, -1.3067E-05, -1.3709E-05, -1.4292E-05, -1.4795E-05, -1.5192E-05, -1.5456E-05, -1.5551E-05, -1.5441E-05, -1.5080E-05, -1.4418E-05, -1.3399E-05, -1.1963E-05, -1.0046E-05, -7.5876E-06, -4.5342E-06, -8.5330E-07, 3.4481E-06, 8.2930E-06, 1.3487E-05, 1.8650E-05, 2.3112E-05, 2.5790E-05, 2.5057E-05, 1.8755E-05, 4.7336E-06, -1.6954E-05, -3.7711E-05, -2.8406E-05, 4.4505E-05, -1.2316E-05, 2.8938E-06, -1.2316E-05, 4.4505E-05, -2.8406E-05, -3.7711E-05, -1.6954E-05, 4.7336E-06, 1.8755E-05, 2.5057E-05, 2.5790E-05, 2.3112E-05, 1.8650E-05, 1.3487E-05, 8.2930E-06, 3.4481E-06, -8.5330E-07, -4.5342E-06, -7.5876E-06, -1.0046E-05, -1.1963E-05, -1.3399E-05, -1.4418E-05, -1.5080E-05, -1.5441E-05, -1.5551E-05, -1.5456E-05, -1.5192E-05, -1.4795E-05, -1.4292E-05, -1.3709E-05, -1.3067E-05, -1.2382E-05, -1.1669E-05, -1.0941E-05, -1.0209E-05, -9.4790E-06, -8.7597E-06, -8.0561E-06, -7.3729E-06, -6.7136E-06, -6.0810E-06, -5.4773E-06, -4.9042E-06, -4.3627E-06, -3.8536E-06, -3.3774E-06, -2.9342E-06, -2.5240E-06, -2.1465E-06, -1.8014E-06, -1.4879E-06, -1.2056E-06, -9.5366E-07, -7.3119E-07, -5.3727E-07, -3.7087E-07, -2.3089E-07, -1.1610E-07, -2.5176E-08, 4.3336E-08, 9.1067E-08, 1.1984E-07, 1.3171E-07, 1.2908E-07, 1.1471E-07, 9.1859E-08, 6.4355E-08, 3.6706E-08, 1.3987E-08, 1.1649E-09, -3.2507E-10); \n//center of the convolution \nint Nc = 70; \n//number of ranks \nint Nr = 6; \n//convolution size \nint N = 141; \n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 1.25*CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    float bright = min(1000.0, 20.0 * dec * pow(camdist, -2.0));\n    return bright * smoothstep(mindist, 0.0, mdist) * heat;\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(i, 0), 1);\n        vec3 pcolor = pow(pixel.xyz/(pixel.w+1e-6),vec3(1.6));\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x, coord.y + i);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 160], [162, 162, 185, 185, 230], [233, 233, 290, 290, 522]], "test": "untested"}
{"id": "dt2SRD", "name": "single-pixel isolines", "author": "unnick", "description": "", "tags": ["2d", "contour", "isoline"], "likes": 18, "viewed": 479, "published": 3, "date": "1675785930", "time_retrieved": "2024-07-30T18:11:42.847374", "image_code": "#define reso iResolution.xy\n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x21f0aaadu;\n    x ^= x >> 15;\n    x *= 0xd35a2d97u;\n    x ^= x >> 15;\n    return x;\n}\n\nfloat u2f(uint x) {\n    return uintBitsToFloat(0x40000000u | (x & 0x007FFFFFu)) - 3.;\n}\n\nvec3 rand_grad(uvec3 p) {\n    uint tmp = hash(hash(hash(hash(p.x)) ^ hash(p.y)) ^ hash(p.z));\n    return vec3(u2f(hash(tmp ^ 0u)), u2f(hash(tmp ^ 1u)), u2f(hash(tmp ^ 2u)));\n}\n\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat perlin(vec3 p) {\n    p.xz *= rotmat(1.2);\n    p.xy *= rotmat(-3.2);\n    p.xz *= rotmat(6.2);\n    \n    uvec3 ip = uvec3(ivec3(floor(p)));\n    vec3 fp = p - floor(p);\n    \n    vec3 wa = fp*fp*fp*(fp*(fp*6.-15.)+10.);\n    vec3 wb = 1. - wa;\n    \n    float res = 0.;\n    res += dot(rand_grad(ip+uvec3(0,0,0)), fp-vec3(0,0,0)) * wb.x*wb.y*wb.z;\n    res += dot(rand_grad(ip+uvec3(1,0,0)), fp-vec3(1,0,0)) * wa.x*wb.y*wb.z;\n    res += dot(rand_grad(ip+uvec3(0,1,0)), fp-vec3(0,1,0)) * wb.x*wa.y*wb.z;\n    res += dot(rand_grad(ip+uvec3(1,1,0)), fp-vec3(1,1,0)) * wa.x*wa.y*wb.z;\n    res += dot(rand_grad(ip+uvec3(0,0,1)), fp-vec3(0,0,1)) * wb.x*wb.y*wa.z;\n    res += dot(rand_grad(ip+uvec3(1,0,1)), fp-vec3(1,0,1)) * wa.x*wb.y*wa.z;\n    res += dot(rand_grad(ip+uvec3(0,1,1)), fp-vec3(0,1,1)) * wb.x*wa.y*wa.z;\n    res += dot(rand_grad(ip+uvec3(1,1,1)), fp-vec3(1,1,1)) * wa.x*wa.y*wa.z;\n    return res;\n}\n\nint fn(ivec2 coord) {\n    //vec2 pos = (vec2(coord * 2) - reso.xy) / reso.y;\n    //return int(floor(sin(dot(pos,pos)*16.)*8.5));\n    return (int(floor(perlin(vec3(vec2(coord) * .02, iTime*.1)) * 10.)));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 pos = ivec2(coord);\n    \n    //int a = fn((pos+1)&~1);\n    //int b = fn((pos&~1)+1);\n    //col = vec4(float(abs(a-b)));\n    \n    ivec4 fns = ivec4(\n        fn(pos+ivec2(0,0)),\n        fn(pos+ivec2(1,0)),\n        fn(pos+ivec2(0,1)),\n        fn(pos+ivec2(1,1))\n    );\n    if(max(max(fns.x,fns.y),max(fns.z,fns.w)) - min(min(fns.x,fns.y),min(fns.z,fns.w)) >= 2) {\n        col = vec4(1);\n        return;\n    }\n    fns -= min(min(fns.x,fns.y),min(fns.z,fns.w));\n    int cnt = fns.x+fns.y+fns.z+fns.w;\n    col = cnt == 2 || cnt == 3 ? vec4(1) : vec4(0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2SRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 48, 48, 162], [164, 164, 183, 183, 251], [253, 253, 278, 278, 428], [430, 430, 452, 452, 525], [527, 527, 549, 549, 1429], [1637, 1637, 1682, 1682, 2242]], "test": "untested"}
{"id": "cljXzD", "name": "Super simple pixelator", "author": "peremptor", "description": "A very simple implementation of a pixelator.\nI wanted to have a reference implementation with clear explanation of how/why it works.\nI wanted the shader to just communicate that single technique as clearly as possible.", "tags": ["postprocessing", "educational", "easy", "pixelation"], "likes": 0, "viewed": 150, "published": 3, "date": "1675772485", "time_retrieved": "2024-07-30T18:11:43.597369", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //higher values = bigger pixels goes from 0 -> 1\n    float pixelationFactor = 0.2;\n    \n    vec2 pixelationModValue = vec2(pixelationFactor);\n    \n    //at the moment the rectangles that are created \n    //by the pixelation are influenced by the aspect ration\n    //(set the pixelation factor to 0.1 to see what i mean)\n    //the following line of code makes it so that pixels are squares\n    //you can prevent that by uncommenting this line\n    pixelationModValue.x /= iResolution.x/iResolution.y;\n    \n    /*\n    Essentially what is happening here is that\n    the normal range for the x and y coordinates are chunked.\n    If roughly applies the following transformation to the x and y-axis\n    if you were to use the pixelation factor 0.2\n    \n    Before:\n        |--------------------------------------->\n        0  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n    After:\n        |--------------------------------------->\n        0      0.2     0.4     0.6     0.8     1.0\n    Everything inbetween \n        0   and 0.2 is transformed to 0\n        0.2 and 0.4 is transformed to 0.2\n        0.4 and 0.6 is transformed to 0.4\n        and so on...\n    */\n    uv -= mod(uv,pixelationModValue);\n    \n    vec4 textureColor = texture(iChannel0, uv);\n    fragColor = textureColor;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1428]], "test": "untested"}
{"id": "mtSXR1", "name": "Water Heart", "author": "Sun_y20", "description": "wyn_heart,Ray_marching", "tags": ["raymarching"], "likes": 3, "viewed": 198, "published": 3, "date": "1675736814", "time_retrieved": "2024-07-30T18:11:44.357337", "image_code": "float rand(vec2 n) {\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n// low ~ highsin\nfloat sint(float low, float high) {\n  float t = sin(iTime*3.);\n  float tall = high - low;\n  return tall / 2. * t + tall / 2. + low;\n}\n// \nfloat Heart(vec2 uv, vec2 p, float r, float blur) {\n  uv *= vec2(.7, .95)*3.;\n  uv -= p;\n  float d = pow(uv.x, 2.) + pow(uv.y - pow(pow(uv.x, 2.), 1./3.), 2.) - 1.;\n  return smoothstep(r, r-blur, d);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n  vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.xx;\n  vec3 col = vec3(0.);\n  vec3 baseCol = vec3(1.);\n  uv *= 1.5;\n  \n  vec2 p = vec2(0., -.5);\n  float edge = Heart(uv*.8*length(uv*.8)*1.8, vec2(0., -.47), .3, .8);\n  vec3 col_edge = baseCol*edge;\n  col_edge -= baseCol * Heart(uv*1.1, p, .3, 0.01);\n  col_edge *= pow(rand(uv), 1./pow(length(uv), 4.*(2.2-sint(.7, 1.5))));\n\n  float innerAnim = sint(length(uv)*1.5, 1.);\n  float heart = Heart(uv * innerAnim, p, .3, 0.1);\n  col = baseCol * heart * pow(rand(uv), 1./pow(length(uv), 2.5*(2.3-sint(.8, 1.5))));\n\n  float border = Heart(uv * innerAnim, p, .3, .01);\n  vec3 borderCol = baseCol * border * pow(rand(uv), 1./pow(length(uv), 2.5*(2.3-sint(.8, 1.5))));\n  borderCol -= baseCol * Heart(uv * 2.0 * innerAnim, p, .3, .5);\n  col += col_edge + borderCol*.2;\n  col *= vec3(0.8, 0.1882, 0.2314)*1.5;\n  \n  col = mix(col,vec3(1.0,0.33,0.6),0.5);\n  \n  \n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [88, 120, 155, 155, 253], [254, 270, 321, 321, 471], [473, 473, 527, 527, 1462]], "test": "untested"}
{"id": "dlBSRD", "name": "3D Star Field 3", "author": "michael0884", "description": "2 rank convolution. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera"], "likes": 5, "viewed": 271, "published": 3, "date": "1675736760", "time_retrieved": "2024-07-30T18:11:45.710719", "image_code": "#define exposure 1.2\n#define sqrexposure 0.6\n#define gamma 1.3\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*c-sqrexposure*c*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy);\n    \n      ivec2 coord = ivec2(fragCoord);\n    \n    vec4 pixel = texelFetch(iChannel3, ivec2(coord.x, coord.y), 0);\n    vec3 val1, val2;\n    unpack2vec3(pixel.xyz, val1, val2);\n    \n    vec3 col = acc.xyz/acc.w + 10.0*bloom.xyz/bloom.w;\n    \n    \n    vec3 packed = pack2vec3(col, 2.0*col);\n    \n    \n    //unpack2vec3(packed, val1, val2);\n    \n    fragColor = vec4(saturate(col), 1.0);\n   // fragColor.xyz = 0.0001 * texture(iChannel3, fragCoord/iResolution.xy).xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    return min(vec3(100.0), 20.0*heat * smoothstep(mindist, 0.0, mdist) * dec / (camdist*camdist));\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n//The first 2 columns of the U matrix:\nfloat U1[257] = float[](\n    -9.447276371199465e-07,     -8.746306452089847e-06,     -2.435235298829273e-05,     -4.7654215714622334e-05,     -7.854043616277397e-05,     -0.00011689837526148944,     -0.000162614785398873,     -0.00021557608261832699,     -0.0002756685195746159,     -0.00034277828407665246,     -0.00041679158774765503,     -0.0004975947113244268,     -0.0005850740690194479,     -0.000679116233575867,     -0.0007796079795609152,     -0.0008864363157302569,     -0.000999488515888899,     -0.0011186521439984813,     -0.001243815084854518,     -0.001374865580785615,     -0.0015116922483710783,     -0.0016541841074021895,     -0.0018022306277955728,     -0.001955721732637126,     -0.002114547859009097,     -0.0022785999702936823,     -0.002447769595019475,     -0.0026219488784535883,     -0.0028010305999610265,     -0.00298490822358693,     -0.0031734759437216926,     -0.0033666287312007067,     -0.003564262375332959,     -0.0037662735401070603,     -0.0039725598198168555,     -0.004183019798092924,     -0.004397553111115977,     -0.004616060515365114,     -0.00483844396028876,     -0.00506460666632468,     -0.005294453208738164,     -0.005527889607795078,     -0.005764823425839191,     -0.00600516387190212,     -0.006248821914539559,     -0.0064957104036607455,     -0.00674574420199852,     -0.006998840325816297,     -0.007254918102417866,     -0.0075138993367360705,     -0.00777570849238033,     -0.008040272888239006,     -0.008307522910574261,     -0.008577392252832557,     -0.008849818167867002,     -0.009124741743159375,     -0.009402108204909668,     -0.009681867256121426,     -0.009963973434832457,     -0.010248386511940238,     -0.010535071937512108,     -0.010824001314988205,     -0.011115152934195538,     -0.011408512361213262,     -0.01170407307589016,     -0.012001837196350031,     -0.012301816263469672,     -0.012604032122672987,     -0.012908517900440761,     -0.013215319087189387,     -0.013524494753942717,     -0.013836118899000062,     -0.014150281968357244,     -0.014467092546800097,     -0.01478667927038489,     -0.015109192967726885,     -0.015434809084940859,     -0.015763730419994987,     -0.016096190224445427,     -0.016432455726227452,     -0.016772832136277675,     -0.017117667227796854,     -0.01746735656907537,     -0.017822349533857935,     -0.01818315621441528,     -0.018550355399260064,     -0.018924603811679215,     -0.01930664683543329,     -0.019697331014985088,     -0.020097618673154127,     -0.020508605064782796,     -0.02093153858763259,     -0.021367844689471106,     -0.021819154265302423,     -0.022287337539508754,     -0.02277454468006337,     -0.023283254720597283,     -0.023816334794185986,     -0.024377112244514897,     -0.024969462918938697,     -0.02559791993402917,     -0.026267808526236888,     -0.026985414390478437,     -0.027758195353824622,     -0.028595049604865294,     -0.02950665840038563,     -0.030505927795825512,     -0.031608563388968114,     -0.03283382569296869,     -0.03420553367429835,     -0.03575341350964996,     -0.03751493399193991,     -0.03953783773723997,     -0.041883682313747644,     -0.04463287072863554,     -0.047891915432344216,     -0.05180411383565565,     -0.05656557088341403,     -0.0624501174776393,     -0.06985142327113548,     -0.07936644027001014,     -0.09198604106444543,     -0.10951080243243982,     -0.1352058595745457,     -0.1741044577744155,     -0.23129432566121957,     -0.3059553997650019,     -0.3802350838907087,     -0.4139051784416186,     -0.3802350838907087,     -0.3059553997650019,     -0.23129432566121957,     -0.1741044577744155,     -0.1352058595745457,     -0.10951080243243982,     -0.09198604106444543,     -0.07936644027001014,     -0.06985142327113548,     -0.0624501174776393,     -0.05656557088341403,     -0.05180411383565565,     -0.047891915432344216,     -0.04463287072863554,     -0.041883682313747644,     -0.03953783773723997,     -0.03751493399193991,     -0.03575341350964996,     -0.03420553367429835,     -0.03283382569296869,     -0.031608563388968114,     -0.030505927795825512,     -0.02950665840038563,     -0.028595049604865294,     -0.027758195353824622,     -0.026985414390478437,     -0.026267808526236888,     -0.02559791993402917,     -0.024969462918938697,     -0.024377112244514897,     -0.023816334794185986,     -0.023283254720597283,     -0.02277454468006337,     -0.022287337539508754,     -0.021819154265302423,     -0.021367844689471106,     -0.02093153858763259,     -0.020508605064782796,     -0.020097618673154127,     -0.019697331014985088,     -0.01930664683543329,     -0.018924603811679215,     -0.018550355399260064,     -0.01818315621441528,     -0.017822349533857935,     -0.01746735656907537,     -0.017117667227796854,     -0.016772832136277675,     -0.016432455726227452,     -0.016096190224445427,     -0.015763730419994987,     -0.015434809084940859,     -0.015109192967726885,     -0.01478667927038489,     -0.014467092546800097,     -0.014150281968357244,     -0.013836118899000062,     -0.013524494753942717,     -0.013215319087189387,     -0.012908517900440761,     -0.012604032122672987,     -0.012301816263469672,     -0.012001837196350031,     -0.01170407307589016,     -0.011408512361213262,     -0.011115152934195538,     -0.010824001314988205,     -0.010535071937512108,     -0.010248386511940238,     -0.009963973434832457,     -0.009681867256121426,     -0.009402108204909668,     -0.009124741743159375,     -0.008849818167867002,     -0.008577392252832557,     -0.008307522910574261,     -0.008040272888239006,     -0.00777570849238033,     -0.0075138993367360705,     -0.007254918102417866,     -0.006998840325816297,     -0.00674574420199852,     -0.0064957104036607455,     -0.006248821914539559,     -0.00600516387190212,     -0.005764823425839191,     -0.005527889607795078,     -0.005294453208738164,     -0.00506460666632468,     -0.00483844396028876,     -0.004616060515365114,     -0.004397553111115977,     -0.004183019798092924,     -0.0039725598198168555,     -0.0037662735401070603,     -0.003564262375332959,     -0.0033666287312007067,     -0.0031734759437216926,     -0.00298490822358693,     -0.0028010305999610265,     -0.0026219488784535883,     -0.002447769595019475,     -0.0022785999702936823,     -0.002114547859009097,     -0.001955721732637126,     -0.0018022306277955728,     -0.0016541841074021895,     -0.0015116922483710783,     -0.001374865580785615,     -0.001243815084854518,     -0.0011186521439984813,     -0.000999488515888899,     -0.0008864363157302569,     -0.0007796079795609152,     -0.000679116233575867,     -0.0005850740690194479,     -0.0004975947113244268,     -0.00041679158774765503,     -0.00034277828407665246,     -0.0002756685195746159,     -0.00021557608261832699,     -0.000162614785398873,     -0.00011689837526148942,     -7.854043616277397e-05,     -4.7654215714622334e-05,     -2.4352352988292662e-05,     -8.746306452103537e-06,     -9.447276370389832e-07 \n);\nfloat U2[257] = float[](\n    3.615292652081603e-06,     3.034958188141701e-05,     8.251227428235364e-05,     0.000159728606358156,     0.0002616634953330754,     0.0003879831275138821,     0.0005383475093399692,     0.000712408760321564,     0.0009098114964470476,     0.0011301931047976322,     0.0013731847549022518,     0.0016384115459869674,     0.0019254936023212802,     0.0022340459968619767,     0.0025636793976814296,     0.002914000387154268,     0.0032846117458787353,     0.0036751125219508223,     0.004085098285812485,     0.004514161587243684,     0.0049618916284123755,     0.005427874339807163,     0.005911693088721383,     0.006412927663896293,     0.006931155384138883,     0.0074659502886282505,     0.00801688325417556,     0.008583522514548168,     0.009165432769286764,     0.009762175460789037,     0.010373308749922722,     0.010998387384318575,     0.011636962273097034,     0.012288580463218972,     0.012952784934817784,     0.01362911435576847,     0.014317102810778557,     0.015016279502536983,     0.01572616842224402,     0.016446287986606144,     0.017176150638112786,     0.017915262405112032,     0.018663122417866627,     0.01941922237639401,     0.0201830459654697,     0.020954068211695473,     0.021731754769109667,     0.02251556107432741,     0.02330493162029988,     0.024099298992718683,     0.024898082820905387,     0.02570068862052413,     0.026506506452306997,     0.027314909795563752,     0.02812525394362213,     0.028936874234666395,     0.029749084234138,     0.03056117394206785,     0.031372407335383816,     0.03218201984734595,     0.0329892159508219,     0.03379316582690479,     0.034593002101335125,     0.03538781630596291,     0.03617665440037838,     0.03695851256021167,     0.03773233177623397,     0.03849699228903231,     0.03925130724613867,     0.03999401545504584,     0.040723773641269626,     0.04143914728734179,     0.04213860088606108,     0.04282048645393346,     0.04348303110978645,     0.044124322621433724,     0.04474229346678801,     0.04533470253617213,     0.04589911455193886,     0.046432876726742726,     0.046933092080393306,     0.04739658931028152,     0.047819888131156854,     0.048199159895259136,     0.04853018237082193,     0.04880828781749755,     0.04902830339109665,     0.04918448230945037,     0.04927042441285721,     0.049278984207467284,     0.04920216406127891,     0.04903099001456379,     0.04875536695687932,     0.04836390927058729,     0.04784374236386539,     0.04718026947778564,     0.04635689697419406,     0.04535470989176122,     0.04415208786090945,     0.0427242492976653,     0.041042709283076795,     0.039074633490238424,     0.036782066961548655,     0.03412101239734203,     0.031040328086804115,     0.027480410930205423,     0.023371625914759185,     0.018632441320896285,     0.013167231710217098,     0.006863723786068318,     -0.0004099062502382582,     -0.008808201933106016,     -0.018511631031115368,     -0.029729299418335072,     -0.04270007633514081,     -0.057689926572364866,     -0.07498109623496449,     -0.09484455939687013,     -0.11747841570567924,     -0.14287551516002173,     -0.17053720142354464,     -0.19884609170274342,     -0.22374442115134854,     -0.23631411139227593,     -0.21948377082252632,     -0.14657724939494451,     0.007491048865397561,     0.2147579736250399,     0.3249140654356825,     0.2147579736250399,     0.007491048865397561,     -0.14657724939494451,     -0.21948377082252632,     -0.23631411139227593,     -0.22374442115134854,     -0.19884609170274342,     -0.17053720142354464,     -0.14287551516002173,     -0.11747841570567924,     -0.09484455939687013,     -0.07498109623496449,     -0.057689926572364866,     -0.04270007633514081,     -0.029729299418335072,     -0.018511631031115368,     -0.008808201933106016,     -0.0004099062502382582,     0.006863723786068318,     0.013167231710217098,     0.018632441320896285,     0.023371625914759185,     0.027480410930205423,     0.031040328086804115,     0.03412101239734203,     0.036782066961548655,     0.039074633490238424,     0.041042709283076795,     0.0427242492976653,     0.04415208786090945,     0.04535470989176122,     0.04635689697419406,     0.04718026947778564,     0.04784374236386539,     0.04836390927058729,     0.04875536695687932,     0.04903099001456379,     0.04920216406127891,     0.049278984207467284,     0.04927042441285721,     0.04918448230945037,     0.04902830339109665,     0.04880828781749755,     0.04853018237082193,     0.048199159895259136,     0.047819888131156854,     0.04739658931028152,     0.046933092080393306,     0.046432876726742726,     0.04589911455193886,     0.04533470253617213,     0.04474229346678801,     0.044124322621433724,     0.04348303110978645,     0.04282048645393346,     0.04213860088606108,     0.04143914728734179,     0.040723773641269626,     0.03999401545504584,     0.03925130724613867,     0.03849699228903231,     0.03773233177623397,     0.03695851256021167,     0.03617665440037838,     0.03538781630596291,     0.034593002101335125,     0.03379316582690479,     0.0329892159508219,     0.03218201984734595,     0.031372407335383816,     0.03056117394206785,     0.029749084234138,     0.028936874234666395,     0.02812525394362213,     0.027314909795563752,     0.026506506452306997,     0.02570068862052413,     0.024898082820905387,     0.024099298992718683,     0.02330493162029988,     0.02251556107432741,     0.021731754769109667,     0.020954068211695473,     0.0201830459654697,     0.01941922237639401,     0.018663122417866627,     0.017915262405112032,     0.017176150638112786,     0.016446287986606144,     0.01572616842224402,     0.015016279502536983,     0.014317102810778557,     0.01362911435576847,     0.012952784934817784,     0.012288580463218972,     0.011636962273097034,     0.010998387384318575,     0.010373308749922722,     0.009762175460789037,     0.009165432769286764,     0.008583522514548168,     0.00801688325417556,     0.0074659502886282505,     0.006931155384138883,     0.006412927663896293,     0.005911693088721383,     0.005427874339807163,     0.0049618916284123755,     0.004514161587243684,     0.004085098285812485,     0.0036751125219508223,     0.0032846117458787353,     0.002914000387154268,     0.0025636793976814296,     0.0022340459968619767,     0.0019254936023212802,     0.0016384115459869674,     0.0013731847549022518,     0.0011301931047976322,     0.0009098114964470476,     0.000712408760321564,     0.0005383475093399692,     0.00038798312751388205,     0.00026166349533307434,     0.00015972860635814247,     8.251227428221754e-05,     3.0349581881676408e-05,     3.6152926524011005e-06 \n);\n//The first 2 rows of the V matrix:\nfloat V1[257] = float[](\n    -9.447276370389931e-07,     -8.746306452311892e-06,     -2.4352352988296633e-05,     -4.7654215714622774e-05,     -7.85404361627747e-05,     -0.0001168983752614905,     -0.00016261478539887446,     -0.00021557608261832896,     -0.00027566851957461843,     -0.0003427782840766555,     -0.00041679158774765893,     -0.0004975947113244314,     -0.0005850740690194532,     -0.0006791162335758732,     -0.0007796079795609224,     -0.0008864363157302651,     -0.000999488515888908,     -0.0011186521439984919,     -0.0012438150848545291,     -0.0013748655807856271,     -0.0015116922483710917,     -0.0016541841074022047,     -0.0018022306277955895,     -0.0019557217326371438,     -0.0021145478590091165,     -0.0022785999702937027,     -0.0024477695950194975,     -0.002621948878453611,     -0.0028010305999610517,     -0.002984908223586957,     -0.0031734759437217212,     -0.0033666287312007384,     -0.003564262375332991,     -0.003766273540107095,     -0.003972559819816892,     -0.00418301979809296,     -0.004397553111116016,     -0.004616060515365156,     -0.004838443960288803,     -0.005064606666324725,     -0.005294453208738211,     -0.005527889607795124,     -0.005764823425839241,     -0.006005163871902173,     -0.006248821914539615,     -0.006495710403660803,     -0.006745744201998579,     -0.0069988403258163575,     -0.007254918102417928,     -0.007513899336736138,     -0.007775708492380402,     -0.00804027288823908,     -0.008307522910574332,     -0.008577392252832638,     -0.008849818167867078,     -0.009124741743159458,     -0.009402108204909752,     -0.009681867256121511,     -0.009963973434832548,     -0.010248386511940334,     -0.010535071937512198,     -0.010824001314988297,     -0.011115152934195634,     -0.011408512361213359,     -0.011704073075890258,     -0.012001837196350139,     -0.01230181626346978,     -0.012604032122673095,     -0.012908517900440867,     -0.013215319087189498,     -0.013524494753942835,     -0.013836118899000181,     -0.01415028196835736,     -0.014467092546800215,     -0.014786679270385008,     -0.015109192967727008,     -0.015434809084940984,     -0.015763730419995115,     -0.01609619022444556,     -0.016432455726227584,     -0.016772832136277806,     -0.01711766722779699,     -0.017467356569075505,     -0.017822349533858067,     -0.01818315621441542,     -0.018550355399260202,     -0.018924603811679357,     -0.019306646835433424,     -0.019697331014985234,     -0.020097618673154263,     -0.020508605064782935,     -0.020931538587632723,     -0.021367844689471244,     -0.021819154265302558,     -0.022287337539508883,     -0.022774544680063506,     -0.02328325472059741,     -0.023816334794186114,     -0.02437711224451503,     -0.024969462918938826,     -0.025597919934029285,     -0.026267808526236995,     -0.02698541439047853,     -0.027758195353824726,     -0.028595049604865377,     -0.029506658400385702,     -0.03050592779582558,     -0.03160856338896816,     -0.03283382569296872,     -0.03420553367429838,     -0.03575341350964996,     -0.03751493399193989,     -0.039537837737239935,     -0.04188368231374758,     -0.04463287072863543,     -0.047891915432344064,     -0.05180411383565545,     -0.05656557088341379,     -0.062450117477638976,     -0.06985142327113511,     -0.07936644027000965,     -0.0919860410644449,     -0.10951080243243924,     -0.13520585957454503,     -0.1741044577744149,     -0.2312943256612192,     -0.30595539976500186,     -0.38023508389070926,     -0.41390517844161956,     -0.38023508389070926,     -0.30595539976500186,     -0.2312943256612192,     -0.1741044577744149,     -0.13520585957454503,     -0.10951080243243924,     -0.0919860410644449,     -0.07936644027000965,     -0.06985142327113511,     -0.062450117477638976,     -0.05656557088341379,     -0.05180411383565545,     -0.047891915432344064,     -0.04463287072863543,     -0.04188368231374758,     -0.039537837737239935,     -0.03751493399193989,     -0.03575341350964996,     -0.03420553367429838,     -0.03283382569296872,     -0.03160856338896816,     -0.03050592779582558,     -0.029506658400385702,     -0.028595049604865377,     -0.027758195353824726,     -0.02698541439047853,     -0.026267808526236995,     -0.025597919934029285,     -0.024969462918938826,     -0.02437711224451503,     -0.023816334794186114,     -0.02328325472059741,     -0.022774544680063506,     -0.022287337539508883,     -0.021819154265302558,     -0.021367844689471244,     -0.020931538587632723,     -0.020508605064782935,     -0.020097618673154263,     -0.019697331014985234,     -0.019306646835433424,     -0.018924603811679357,     -0.018550355399260202,     -0.01818315621441542,     -0.017822349533858067,     -0.017467356569075505,     -0.01711766722779699,     -0.016772832136277806,     -0.016432455726227584,     -0.01609619022444556,     -0.015763730419995115,     -0.015434809084940984,     -0.015109192967727008,     -0.014786679270385008,     -0.014467092546800215,     -0.01415028196835736,     -0.013836118899000181,     -0.013524494753942835,     -0.013215319087189498,     -0.012908517900440867,     -0.012604032122673095,     -0.01230181626346978,     -0.012001837196350139,     -0.011704073075890258,     -0.011408512361213359,     -0.011115152934195634,     -0.010824001314988297,     -0.010535071937512198,     -0.010248386511940334,     -0.009963973434832548,     -0.009681867256121511,     -0.009402108204909752,     -0.009124741743159458,     -0.008849818167867078,     -0.008577392252832638,     -0.008307522910574332,     -0.00804027288823908,     -0.007775708492380402,     -0.007513899336736138,     -0.007254918102417928,     -0.0069988403258163575,     -0.006745744201998579,     -0.006495710403660803,     -0.006248821914539615,     -0.006005163871902173,     -0.005764823425839241,     -0.005527889607795124,     -0.005294453208738211,     -0.005064606666324725,     -0.004838443960288803,     -0.004616060515365156,     -0.004397553111116016,     -0.00418301979809296,     -0.003972559819816892,     -0.003766273540107095,     -0.003564262375332991,     -0.0033666287312007384,     -0.0031734759437217212,     -0.002984908223586957,     -0.0028010305999610517,     -0.002621948878453611,     -0.0024477695950194975,     -0.0022785999702937027,     -0.0021145478590091165,     -0.0019557217326371438,     -0.0018022306277955895,     -0.0016541841074022047,     -0.0015116922483710917,     -0.0013748655807856271,     -0.0012438150848545291,     -0.0011186521439984919,     -0.000999488515888908,     -0.0008864363157302651,     -0.0007796079795609224,     -0.0006791162335758732,     -0.0005850740690194532,     -0.0004975947113244314,     -0.00041679158774765893,     -0.0003427782840766555,     -0.00027566851957461843,     -0.00021557608261832896,     -0.00016261478539887446,     -0.0001168983752614905,     -7.85404361627747e-05,     -4.765421571462279e-05,     -2.43523529882929e-05,     -8.74630645210362e-06,     -9.447276370389932e-07 \n);\nfloat V2[257] = float[](\n    3.6152926524010912e-06,     3.0349581881115167e-05,     8.251227428246466e-05,     0.000159728606358156,     0.0002616634953330754,     0.00038798312751388135,     0.0005383475093399678,     0.0007124087603215624,     0.0009098114964470455,     0.0011301931047976292,     0.0013731847549022479,     0.0016384115459869633,     0.001925493602321275,     0.0022340459968619706,     0.0025636793976814235,     0.002914000387154261,     0.003284611745878726,     0.0036751125219508145,     0.004085098285812474,     0.004514161587243675,     0.004961891628412366,     0.005427874339807152,     0.005911693088721369,     0.006412927663896278,     0.006931155384138865,     0.007465950288628234,     0.008016883254175542,     0.008583522514548145,     0.009165432769286743,     0.00976217546078901,     0.010373308749922696,     0.01099838738431855,     0.011636962273097002,     0.012288580463218943,     0.012952784934817751,     0.013629114355768437,     0.01431710281077852,     0.01501627950253695,     0.015726168422243978,     0.016446287986606103,     0.017176150638112755,     0.017915262405111976,     0.018663122417866582,     0.01941922237639397,     0.020183045965469656,     0.020954068211695414,     0.021731754769109612,     0.022515561074327346,     0.02330493162029983,     0.024099298992718624,     0.024898082820905325,     0.025700688620524076,     0.026506506452306934,     0.027314909795563693,     0.028125253943622065,     0.028936874234666322,     0.029749084234137933,     0.030561173942067782,     0.03137240733538375,     0.032182019847345894,     0.03298921595082181,     0.03379316582690471,     0.034593002101335056,     0.03538781630596281,     0.0361766544003783,     0.036958512560211584,     0.03773233177623388,     0.03849699228903221,     0.039251307246138574,     0.03999401545504576,     0.04072377364126954,     0.041439147287341695,     0.04213860088606101,     0.04282048645393335,     0.04348303110978635,     0.04412432262143361,     0.04474229346678791,     0.04533470253617205,     0.045899114551938756,     0.04643287672674262,     0.04693309208039321,     0.04739658931028141,     0.047819888131156736,     0.04819915989525903,     0.04853018237082181,     0.04880828781749745,     0.049028303391096546,     0.04918448230945025,     0.0492704244128571,     0.049278984207467166,     0.0492021640612788,     0.04903099001456368,     0.04875536695687918,     0.04836390927058717,     0.047843742363865294,     0.047180269477785496,     0.04635689697419395,     0.0453547098917611,     0.04415208786090931,     0.04272424929766518,     0.04104270928307668,     0.03907463349023829,     0.036782066961548544,     0.034121012397341936,     0.031040328086804,     0.027480410930205302,     0.02337162591475908,     0.018632441320896156,     0.013167231710216982,     0.006863723786068246,     -0.0004099062502383979,     -0.008808201933106143,     -0.01851163103111544,     -0.02972929941833521,     -0.04270007633514095,     -0.05768992657236502,     -0.0749810962349646,     -0.09484455939687024,     -0.11747841570567934,     -0.14287551516002187,     -0.1705372014235449,     -0.19884609170274356,     -0.2237444211513489,     -0.23631411139227632,     -0.21948377082252676,     -0.14657724939494474,     0.007491048865396655,     0.21475797362503896,     0.3249140654356813,     0.21475797362503896,     0.007491048865396655,     -0.14657724939494474,     -0.21948377082252676,     -0.23631411139227632,     -0.2237444211513489,     -0.19884609170274356,     -0.1705372014235449,     -0.14287551516002187,     -0.11747841570567934,     -0.09484455939687024,     -0.0749810962349646,     -0.05768992657236502,     -0.04270007633514095,     -0.02972929941833521,     -0.01851163103111544,     -0.008808201933106143,     -0.0004099062502383979,     0.006863723786068246,     0.013167231710216982,     0.018632441320896156,     0.02337162591475908,     0.027480410930205302,     0.031040328086804,     0.034121012397341936,     0.036782066961548544,     0.03907463349023829,     0.04104270928307668,     0.04272424929766518,     0.04415208786090931,     0.0453547098917611,     0.04635689697419395,     0.047180269477785496,     0.047843742363865294,     0.04836390927058717,     0.04875536695687918,     0.04903099001456368,     0.0492021640612788,     0.049278984207467166,     0.0492704244128571,     0.04918448230945025,     0.049028303391096546,     0.04880828781749745,     0.04853018237082181,     0.04819915989525903,     0.047819888131156736,     0.04739658931028141,     0.04693309208039321,     0.04643287672674262,     0.045899114551938756,     0.04533470253617205,     0.04474229346678791,     0.04412432262143361,     0.04348303110978635,     0.04282048645393335,     0.04213860088606101,     0.041439147287341695,     0.04072377364126954,     0.03999401545504576,     0.039251307246138574,     0.03849699228903221,     0.03773233177623388,     0.036958512560211584,     0.0361766544003783,     0.03538781630596281,     0.034593002101335056,     0.03379316582690471,     0.03298921595082181,     0.032182019847345894,     0.03137240733538375,     0.030561173942067782,     0.029749084234137933,     0.028936874234666322,     0.028125253943622065,     0.027314909795563693,     0.026506506452306934,     0.025700688620524076,     0.024898082820905325,     0.024099298992718624,     0.02330493162029983,     0.022515561074327346,     0.021731754769109612,     0.020954068211695414,     0.020183045965469656,     0.01941922237639397,     0.018663122417866582,     0.017915262405111976,     0.017176150638112755,     0.016446287986606103,     0.015726168422243978,     0.01501627950253695,     0.01431710281077852,     0.013629114355768437,     0.012952784934817751,     0.012288580463218943,     0.011636962273097002,     0.01099838738431855,     0.010373308749922696,     0.00976217546078901,     0.009165432769286743,     0.008583522514548145,     0.008016883254175542,     0.007465950288628234,     0.006931155384138865,     0.006412927663896278,     0.005911693088721369,     0.005427874339807152,     0.004961891628412366,     0.004514161587243675,     0.004085098285812474,     0.0036751125219508145,     0.003284611745878726,     0.002914000387154261,     0.0025636793976814235,     0.0022340459968619706,     0.001925493602321275,     0.0016384115459869633,     0.0013731847549022479,     0.0011301931047976292,     0.0009098114964470454,     0.0007124087603215625,     0.0005383475093399678,     0.0003879831275138813,     0.0002616634953330736,     0.00015972860635814204,     8.251227428221734e-05,     3.0349581881676337e-05,     3.6152926524010917e-06 \n);\n//The first 2 singular values:\nfloat S[2] = float[](\n    0.024767292133289997,     0.002064586756323816 \n);\n//center of the convolution\nint Nc = 128;\n\n    //do a convolution in the x direction on iChannel0\n    vec3 sum1 = vec3(0.0);\n    vec3 sum2 = vec3(0.0);\n    ivec2 coord = ivec2(fragCoord);\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        vec4 pixel = texelFetch(iChannel0, ivec2(coord.x + i, coord.y), 0);\n        vec3 pcolor = pow(pixel.xyz/(pixel.w+1e-6),vec3(1.25));\n\n        sum1 += pcolor * U1[i + Nc];\n        sum2 += pcolor * U2[i + Nc];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum1, sum2), 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//The first 2 columns of the U matrix:\nfloat U1[257] = float[](\n    -9.447276371199465e-07,     -8.746306452089847e-06,     -2.435235298829273e-05,     -4.7654215714622334e-05,     -7.854043616277397e-05,     -0.00011689837526148944,     -0.000162614785398873,     -0.00021557608261832699,     -0.0002756685195746159,     -0.00034277828407665246,     -0.00041679158774765503,     -0.0004975947113244268,     -0.0005850740690194479,     -0.000679116233575867,     -0.0007796079795609152,     -0.0008864363157302569,     -0.000999488515888899,     -0.0011186521439984813,     -0.001243815084854518,     -0.001374865580785615,     -0.0015116922483710783,     -0.0016541841074021895,     -0.0018022306277955728,     -0.001955721732637126,     -0.002114547859009097,     -0.0022785999702936823,     -0.002447769595019475,     -0.0026219488784535883,     -0.0028010305999610265,     -0.00298490822358693,     -0.0031734759437216926,     -0.0033666287312007067,     -0.003564262375332959,     -0.0037662735401070603,     -0.0039725598198168555,     -0.004183019798092924,     -0.004397553111115977,     -0.004616060515365114,     -0.00483844396028876,     -0.00506460666632468,     -0.005294453208738164,     -0.005527889607795078,     -0.005764823425839191,     -0.00600516387190212,     -0.006248821914539559,     -0.0064957104036607455,     -0.00674574420199852,     -0.006998840325816297,     -0.007254918102417866,     -0.0075138993367360705,     -0.00777570849238033,     -0.008040272888239006,     -0.008307522910574261,     -0.008577392252832557,     -0.008849818167867002,     -0.009124741743159375,     -0.009402108204909668,     -0.009681867256121426,     -0.009963973434832457,     -0.010248386511940238,     -0.010535071937512108,     -0.010824001314988205,     -0.011115152934195538,     -0.011408512361213262,     -0.01170407307589016,     -0.012001837196350031,     -0.012301816263469672,     -0.012604032122672987,     -0.012908517900440761,     -0.013215319087189387,     -0.013524494753942717,     -0.013836118899000062,     -0.014150281968357244,     -0.014467092546800097,     -0.01478667927038489,     -0.015109192967726885,     -0.015434809084940859,     -0.015763730419994987,     -0.016096190224445427,     -0.016432455726227452,     -0.016772832136277675,     -0.017117667227796854,     -0.01746735656907537,     -0.017822349533857935,     -0.01818315621441528,     -0.018550355399260064,     -0.018924603811679215,     -0.01930664683543329,     -0.019697331014985088,     -0.020097618673154127,     -0.020508605064782796,     -0.02093153858763259,     -0.021367844689471106,     -0.021819154265302423,     -0.022287337539508754,     -0.02277454468006337,     -0.023283254720597283,     -0.023816334794185986,     -0.024377112244514897,     -0.024969462918938697,     -0.02559791993402917,     -0.026267808526236888,     -0.026985414390478437,     -0.027758195353824622,     -0.028595049604865294,     -0.02950665840038563,     -0.030505927795825512,     -0.031608563388968114,     -0.03283382569296869,     -0.03420553367429835,     -0.03575341350964996,     -0.03751493399193991,     -0.03953783773723997,     -0.041883682313747644,     -0.04463287072863554,     -0.047891915432344216,     -0.05180411383565565,     -0.05656557088341403,     -0.0624501174776393,     -0.06985142327113548,     -0.07936644027001014,     -0.09198604106444543,     -0.10951080243243982,     -0.1352058595745457,     -0.1741044577744155,     -0.23129432566121957,     -0.3059553997650019,     -0.3802350838907087,     -0.4139051784416186,     -0.3802350838907087,     -0.3059553997650019,     -0.23129432566121957,     -0.1741044577744155,     -0.1352058595745457,     -0.10951080243243982,     -0.09198604106444543,     -0.07936644027001014,     -0.06985142327113548,     -0.0624501174776393,     -0.05656557088341403,     -0.05180411383565565,     -0.047891915432344216,     -0.04463287072863554,     -0.041883682313747644,     -0.03953783773723997,     -0.03751493399193991,     -0.03575341350964996,     -0.03420553367429835,     -0.03283382569296869,     -0.031608563388968114,     -0.030505927795825512,     -0.02950665840038563,     -0.028595049604865294,     -0.027758195353824622,     -0.026985414390478437,     -0.026267808526236888,     -0.02559791993402917,     -0.024969462918938697,     -0.024377112244514897,     -0.023816334794185986,     -0.023283254720597283,     -0.02277454468006337,     -0.022287337539508754,     -0.021819154265302423,     -0.021367844689471106,     -0.02093153858763259,     -0.020508605064782796,     -0.020097618673154127,     -0.019697331014985088,     -0.01930664683543329,     -0.018924603811679215,     -0.018550355399260064,     -0.01818315621441528,     -0.017822349533857935,     -0.01746735656907537,     -0.017117667227796854,     -0.016772832136277675,     -0.016432455726227452,     -0.016096190224445427,     -0.015763730419994987,     -0.015434809084940859,     -0.015109192967726885,     -0.01478667927038489,     -0.014467092546800097,     -0.014150281968357244,     -0.013836118899000062,     -0.013524494753942717,     -0.013215319087189387,     -0.012908517900440761,     -0.012604032122672987,     -0.012301816263469672,     -0.012001837196350031,     -0.01170407307589016,     -0.011408512361213262,     -0.011115152934195538,     -0.010824001314988205,     -0.010535071937512108,     -0.010248386511940238,     -0.009963973434832457,     -0.009681867256121426,     -0.009402108204909668,     -0.009124741743159375,     -0.008849818167867002,     -0.008577392252832557,     -0.008307522910574261,     -0.008040272888239006,     -0.00777570849238033,     -0.0075138993367360705,     -0.007254918102417866,     -0.006998840325816297,     -0.00674574420199852,     -0.0064957104036607455,     -0.006248821914539559,     -0.00600516387190212,     -0.005764823425839191,     -0.005527889607795078,     -0.005294453208738164,     -0.00506460666632468,     -0.00483844396028876,     -0.004616060515365114,     -0.004397553111115977,     -0.004183019798092924,     -0.0039725598198168555,     -0.0037662735401070603,     -0.003564262375332959,     -0.0033666287312007067,     -0.0031734759437216926,     -0.00298490822358693,     -0.0028010305999610265,     -0.0026219488784535883,     -0.002447769595019475,     -0.0022785999702936823,     -0.002114547859009097,     -0.001955721732637126,     -0.0018022306277955728,     -0.0016541841074021895,     -0.0015116922483710783,     -0.001374865580785615,     -0.001243815084854518,     -0.0011186521439984813,     -0.000999488515888899,     -0.0008864363157302569,     -0.0007796079795609152,     -0.000679116233575867,     -0.0005850740690194479,     -0.0004975947113244268,     -0.00041679158774765503,     -0.00034277828407665246,     -0.0002756685195746159,     -0.00021557608261832699,     -0.000162614785398873,     -0.00011689837526148942,     -7.854043616277397e-05,     -4.7654215714622334e-05,     -2.4352352988292662e-05,     -8.746306452103537e-06,     -9.447276370389832e-07 \n);\nfloat U2[257] = float[](\n    3.615292652081603e-06,     3.034958188141701e-05,     8.251227428235364e-05,     0.000159728606358156,     0.0002616634953330754,     0.0003879831275138821,     0.0005383475093399692,     0.000712408760321564,     0.0009098114964470476,     0.0011301931047976322,     0.0013731847549022518,     0.0016384115459869674,     0.0019254936023212802,     0.0022340459968619767,     0.0025636793976814296,     0.002914000387154268,     0.0032846117458787353,     0.0036751125219508223,     0.004085098285812485,     0.004514161587243684,     0.0049618916284123755,     0.005427874339807163,     0.005911693088721383,     0.006412927663896293,     0.006931155384138883,     0.0074659502886282505,     0.00801688325417556,     0.008583522514548168,     0.009165432769286764,     0.009762175460789037,     0.010373308749922722,     0.010998387384318575,     0.011636962273097034,     0.012288580463218972,     0.012952784934817784,     0.01362911435576847,     0.014317102810778557,     0.015016279502536983,     0.01572616842224402,     0.016446287986606144,     0.017176150638112786,     0.017915262405112032,     0.018663122417866627,     0.01941922237639401,     0.0201830459654697,     0.020954068211695473,     0.021731754769109667,     0.02251556107432741,     0.02330493162029988,     0.024099298992718683,     0.024898082820905387,     0.02570068862052413,     0.026506506452306997,     0.027314909795563752,     0.02812525394362213,     0.028936874234666395,     0.029749084234138,     0.03056117394206785,     0.031372407335383816,     0.03218201984734595,     0.0329892159508219,     0.03379316582690479,     0.034593002101335125,     0.03538781630596291,     0.03617665440037838,     0.03695851256021167,     0.03773233177623397,     0.03849699228903231,     0.03925130724613867,     0.03999401545504584,     0.040723773641269626,     0.04143914728734179,     0.04213860088606108,     0.04282048645393346,     0.04348303110978645,     0.044124322621433724,     0.04474229346678801,     0.04533470253617213,     0.04589911455193886,     0.046432876726742726,     0.046933092080393306,     0.04739658931028152,     0.047819888131156854,     0.048199159895259136,     0.04853018237082193,     0.04880828781749755,     0.04902830339109665,     0.04918448230945037,     0.04927042441285721,     0.049278984207467284,     0.04920216406127891,     0.04903099001456379,     0.04875536695687932,     0.04836390927058729,     0.04784374236386539,     0.04718026947778564,     0.04635689697419406,     0.04535470989176122,     0.04415208786090945,     0.0427242492976653,     0.041042709283076795,     0.039074633490238424,     0.036782066961548655,     0.03412101239734203,     0.031040328086804115,     0.027480410930205423,     0.023371625914759185,     0.018632441320896285,     0.013167231710217098,     0.006863723786068318,     -0.0004099062502382582,     -0.008808201933106016,     -0.018511631031115368,     -0.029729299418335072,     -0.04270007633514081,     -0.057689926572364866,     -0.07498109623496449,     -0.09484455939687013,     -0.11747841570567924,     -0.14287551516002173,     -0.17053720142354464,     -0.19884609170274342,     -0.22374442115134854,     -0.23631411139227593,     -0.21948377082252632,     -0.14657724939494451,     0.007491048865397561,     0.2147579736250399,     0.3249140654356825,     0.2147579736250399,     0.007491048865397561,     -0.14657724939494451,     -0.21948377082252632,     -0.23631411139227593,     -0.22374442115134854,     -0.19884609170274342,     -0.17053720142354464,     -0.14287551516002173,     -0.11747841570567924,     -0.09484455939687013,     -0.07498109623496449,     -0.057689926572364866,     -0.04270007633514081,     -0.029729299418335072,     -0.018511631031115368,     -0.008808201933106016,     -0.0004099062502382582,     0.006863723786068318,     0.013167231710217098,     0.018632441320896285,     0.023371625914759185,     0.027480410930205423,     0.031040328086804115,     0.03412101239734203,     0.036782066961548655,     0.039074633490238424,     0.041042709283076795,     0.0427242492976653,     0.04415208786090945,     0.04535470989176122,     0.04635689697419406,     0.04718026947778564,     0.04784374236386539,     0.04836390927058729,     0.04875536695687932,     0.04903099001456379,     0.04920216406127891,     0.049278984207467284,     0.04927042441285721,     0.04918448230945037,     0.04902830339109665,     0.04880828781749755,     0.04853018237082193,     0.048199159895259136,     0.047819888131156854,     0.04739658931028152,     0.046933092080393306,     0.046432876726742726,     0.04589911455193886,     0.04533470253617213,     0.04474229346678801,     0.044124322621433724,     0.04348303110978645,     0.04282048645393346,     0.04213860088606108,     0.04143914728734179,     0.040723773641269626,     0.03999401545504584,     0.03925130724613867,     0.03849699228903231,     0.03773233177623397,     0.03695851256021167,     0.03617665440037838,     0.03538781630596291,     0.034593002101335125,     0.03379316582690479,     0.0329892159508219,     0.03218201984734595,     0.031372407335383816,     0.03056117394206785,     0.029749084234138,     0.028936874234666395,     0.02812525394362213,     0.027314909795563752,     0.026506506452306997,     0.02570068862052413,     0.024898082820905387,     0.024099298992718683,     0.02330493162029988,     0.02251556107432741,     0.021731754769109667,     0.020954068211695473,     0.0201830459654697,     0.01941922237639401,     0.018663122417866627,     0.017915262405112032,     0.017176150638112786,     0.016446287986606144,     0.01572616842224402,     0.015016279502536983,     0.014317102810778557,     0.01362911435576847,     0.012952784934817784,     0.012288580463218972,     0.011636962273097034,     0.010998387384318575,     0.010373308749922722,     0.009762175460789037,     0.009165432769286764,     0.008583522514548168,     0.00801688325417556,     0.0074659502886282505,     0.006931155384138883,     0.006412927663896293,     0.005911693088721383,     0.005427874339807163,     0.0049618916284123755,     0.004514161587243684,     0.004085098285812485,     0.0036751125219508223,     0.0032846117458787353,     0.002914000387154268,     0.0025636793976814296,     0.0022340459968619767,     0.0019254936023212802,     0.0016384115459869674,     0.0013731847549022518,     0.0011301931047976322,     0.0009098114964470476,     0.000712408760321564,     0.0005383475093399692,     0.00038798312751388205,     0.00026166349533307434,     0.00015972860635814247,     8.251227428221754e-05,     3.0349581881676408e-05,     3.6152926524011005e-06 \n);\n//The first 2 rows of the V matrix:\nfloat V1[257] = float[](\n    -9.447276370389931e-07,     -8.746306452311892e-06,     -2.4352352988296633e-05,     -4.7654215714622774e-05,     -7.85404361627747e-05,     -0.0001168983752614905,     -0.00016261478539887446,     -0.00021557608261832896,     -0.00027566851957461843,     -0.0003427782840766555,     -0.00041679158774765893,     -0.0004975947113244314,     -0.0005850740690194532,     -0.0006791162335758732,     -0.0007796079795609224,     -0.0008864363157302651,     -0.000999488515888908,     -0.0011186521439984919,     -0.0012438150848545291,     -0.0013748655807856271,     -0.0015116922483710917,     -0.0016541841074022047,     -0.0018022306277955895,     -0.0019557217326371438,     -0.0021145478590091165,     -0.0022785999702937027,     -0.0024477695950194975,     -0.002621948878453611,     -0.0028010305999610517,     -0.002984908223586957,     -0.0031734759437217212,     -0.0033666287312007384,     -0.003564262375332991,     -0.003766273540107095,     -0.003972559819816892,     -0.00418301979809296,     -0.004397553111116016,     -0.004616060515365156,     -0.004838443960288803,     -0.005064606666324725,     -0.005294453208738211,     -0.005527889607795124,     -0.005764823425839241,     -0.006005163871902173,     -0.006248821914539615,     -0.006495710403660803,     -0.006745744201998579,     -0.0069988403258163575,     -0.007254918102417928,     -0.007513899336736138,     -0.007775708492380402,     -0.00804027288823908,     -0.008307522910574332,     -0.008577392252832638,     -0.008849818167867078,     -0.009124741743159458,     -0.009402108204909752,     -0.009681867256121511,     -0.009963973434832548,     -0.010248386511940334,     -0.010535071937512198,     -0.010824001314988297,     -0.011115152934195634,     -0.011408512361213359,     -0.011704073075890258,     -0.012001837196350139,     -0.01230181626346978,     -0.012604032122673095,     -0.012908517900440867,     -0.013215319087189498,     -0.013524494753942835,     -0.013836118899000181,     -0.01415028196835736,     -0.014467092546800215,     -0.014786679270385008,     -0.015109192967727008,     -0.015434809084940984,     -0.015763730419995115,     -0.01609619022444556,     -0.016432455726227584,     -0.016772832136277806,     -0.01711766722779699,     -0.017467356569075505,     -0.017822349533858067,     -0.01818315621441542,     -0.018550355399260202,     -0.018924603811679357,     -0.019306646835433424,     -0.019697331014985234,     -0.020097618673154263,     -0.020508605064782935,     -0.020931538587632723,     -0.021367844689471244,     -0.021819154265302558,     -0.022287337539508883,     -0.022774544680063506,     -0.02328325472059741,     -0.023816334794186114,     -0.02437711224451503,     -0.024969462918938826,     -0.025597919934029285,     -0.026267808526236995,     -0.02698541439047853,     -0.027758195353824726,     -0.028595049604865377,     -0.029506658400385702,     -0.03050592779582558,     -0.03160856338896816,     -0.03283382569296872,     -0.03420553367429838,     -0.03575341350964996,     -0.03751493399193989,     -0.039537837737239935,     -0.04188368231374758,     -0.04463287072863543,     -0.047891915432344064,     -0.05180411383565545,     -0.05656557088341379,     -0.062450117477638976,     -0.06985142327113511,     -0.07936644027000965,     -0.0919860410644449,     -0.10951080243243924,     -0.13520585957454503,     -0.1741044577744149,     -0.2312943256612192,     -0.30595539976500186,     -0.38023508389070926,     -0.41390517844161956,     -0.38023508389070926,     -0.30595539976500186,     -0.2312943256612192,     -0.1741044577744149,     -0.13520585957454503,     -0.10951080243243924,     -0.0919860410644449,     -0.07936644027000965,     -0.06985142327113511,     -0.062450117477638976,     -0.05656557088341379,     -0.05180411383565545,     -0.047891915432344064,     -0.04463287072863543,     -0.04188368231374758,     -0.039537837737239935,     -0.03751493399193989,     -0.03575341350964996,     -0.03420553367429838,     -0.03283382569296872,     -0.03160856338896816,     -0.03050592779582558,     -0.029506658400385702,     -0.028595049604865377,     -0.027758195353824726,     -0.02698541439047853,     -0.026267808526236995,     -0.025597919934029285,     -0.024969462918938826,     -0.02437711224451503,     -0.023816334794186114,     -0.02328325472059741,     -0.022774544680063506,     -0.022287337539508883,     -0.021819154265302558,     -0.021367844689471244,     -0.020931538587632723,     -0.020508605064782935,     -0.020097618673154263,     -0.019697331014985234,     -0.019306646835433424,     -0.018924603811679357,     -0.018550355399260202,     -0.01818315621441542,     -0.017822349533858067,     -0.017467356569075505,     -0.01711766722779699,     -0.016772832136277806,     -0.016432455726227584,     -0.01609619022444556,     -0.015763730419995115,     -0.015434809084940984,     -0.015109192967727008,     -0.014786679270385008,     -0.014467092546800215,     -0.01415028196835736,     -0.013836118899000181,     -0.013524494753942835,     -0.013215319087189498,     -0.012908517900440867,     -0.012604032122673095,     -0.01230181626346978,     -0.012001837196350139,     -0.011704073075890258,     -0.011408512361213359,     -0.011115152934195634,     -0.010824001314988297,     -0.010535071937512198,     -0.010248386511940334,     -0.009963973434832548,     -0.009681867256121511,     -0.009402108204909752,     -0.009124741743159458,     -0.008849818167867078,     -0.008577392252832638,     -0.008307522910574332,     -0.00804027288823908,     -0.007775708492380402,     -0.007513899336736138,     -0.007254918102417928,     -0.0069988403258163575,     -0.006745744201998579,     -0.006495710403660803,     -0.006248821914539615,     -0.006005163871902173,     -0.005764823425839241,     -0.005527889607795124,     -0.005294453208738211,     -0.005064606666324725,     -0.004838443960288803,     -0.004616060515365156,     -0.004397553111116016,     -0.00418301979809296,     -0.003972559819816892,     -0.003766273540107095,     -0.003564262375332991,     -0.0033666287312007384,     -0.0031734759437217212,     -0.002984908223586957,     -0.0028010305999610517,     -0.002621948878453611,     -0.0024477695950194975,     -0.0022785999702937027,     -0.0021145478590091165,     -0.0019557217326371438,     -0.0018022306277955895,     -0.0016541841074022047,     -0.0015116922483710917,     -0.0013748655807856271,     -0.0012438150848545291,     -0.0011186521439984919,     -0.000999488515888908,     -0.0008864363157302651,     -0.0007796079795609224,     -0.0006791162335758732,     -0.0005850740690194532,     -0.0004975947113244314,     -0.00041679158774765893,     -0.0003427782840766555,     -0.00027566851957461843,     -0.00021557608261832896,     -0.00016261478539887446,     -0.0001168983752614905,     -7.85404361627747e-05,     -4.765421571462279e-05,     -2.43523529882929e-05,     -8.74630645210362e-06,     -9.447276370389932e-07 \n);\nfloat V2[257] = float[](\n    3.6152926524010912e-06,     3.0349581881115167e-05,     8.251227428246466e-05,     0.000159728606358156,     0.0002616634953330754,     0.00038798312751388135,     0.0005383475093399678,     0.0007124087603215624,     0.0009098114964470455,     0.0011301931047976292,     0.0013731847549022479,     0.0016384115459869633,     0.001925493602321275,     0.0022340459968619706,     0.0025636793976814235,     0.002914000387154261,     0.003284611745878726,     0.0036751125219508145,     0.004085098285812474,     0.004514161587243675,     0.004961891628412366,     0.005427874339807152,     0.005911693088721369,     0.006412927663896278,     0.006931155384138865,     0.007465950288628234,     0.008016883254175542,     0.008583522514548145,     0.009165432769286743,     0.00976217546078901,     0.010373308749922696,     0.01099838738431855,     0.011636962273097002,     0.012288580463218943,     0.012952784934817751,     0.013629114355768437,     0.01431710281077852,     0.01501627950253695,     0.015726168422243978,     0.016446287986606103,     0.017176150638112755,     0.017915262405111976,     0.018663122417866582,     0.01941922237639397,     0.020183045965469656,     0.020954068211695414,     0.021731754769109612,     0.022515561074327346,     0.02330493162029983,     0.024099298992718624,     0.024898082820905325,     0.025700688620524076,     0.026506506452306934,     0.027314909795563693,     0.028125253943622065,     0.028936874234666322,     0.029749084234137933,     0.030561173942067782,     0.03137240733538375,     0.032182019847345894,     0.03298921595082181,     0.03379316582690471,     0.034593002101335056,     0.03538781630596281,     0.0361766544003783,     0.036958512560211584,     0.03773233177623388,     0.03849699228903221,     0.039251307246138574,     0.03999401545504576,     0.04072377364126954,     0.041439147287341695,     0.04213860088606101,     0.04282048645393335,     0.04348303110978635,     0.04412432262143361,     0.04474229346678791,     0.04533470253617205,     0.045899114551938756,     0.04643287672674262,     0.04693309208039321,     0.04739658931028141,     0.047819888131156736,     0.04819915989525903,     0.04853018237082181,     0.04880828781749745,     0.049028303391096546,     0.04918448230945025,     0.0492704244128571,     0.049278984207467166,     0.0492021640612788,     0.04903099001456368,     0.04875536695687918,     0.04836390927058717,     0.047843742363865294,     0.047180269477785496,     0.04635689697419395,     0.0453547098917611,     0.04415208786090931,     0.04272424929766518,     0.04104270928307668,     0.03907463349023829,     0.036782066961548544,     0.034121012397341936,     0.031040328086804,     0.027480410930205302,     0.02337162591475908,     0.018632441320896156,     0.013167231710216982,     0.006863723786068246,     -0.0004099062502383979,     -0.008808201933106143,     -0.01851163103111544,     -0.02972929941833521,     -0.04270007633514095,     -0.05768992657236502,     -0.0749810962349646,     -0.09484455939687024,     -0.11747841570567934,     -0.14287551516002187,     -0.1705372014235449,     -0.19884609170274356,     -0.2237444211513489,     -0.23631411139227632,     -0.21948377082252676,     -0.14657724939494474,     0.007491048865396655,     0.21475797362503896,     0.3249140654356813,     0.21475797362503896,     0.007491048865396655,     -0.14657724939494474,     -0.21948377082252676,     -0.23631411139227632,     -0.2237444211513489,     -0.19884609170274356,     -0.1705372014235449,     -0.14287551516002187,     -0.11747841570567934,     -0.09484455939687024,     -0.0749810962349646,     -0.05768992657236502,     -0.04270007633514095,     -0.02972929941833521,     -0.01851163103111544,     -0.008808201933106143,     -0.0004099062502383979,     0.006863723786068246,     0.013167231710216982,     0.018632441320896156,     0.02337162591475908,     0.027480410930205302,     0.031040328086804,     0.034121012397341936,     0.036782066961548544,     0.03907463349023829,     0.04104270928307668,     0.04272424929766518,     0.04415208786090931,     0.0453547098917611,     0.04635689697419395,     0.047180269477785496,     0.047843742363865294,     0.04836390927058717,     0.04875536695687918,     0.04903099001456368,     0.0492021640612788,     0.049278984207467166,     0.0492704244128571,     0.04918448230945025,     0.049028303391096546,     0.04880828781749745,     0.04853018237082181,     0.04819915989525903,     0.047819888131156736,     0.04739658931028141,     0.04693309208039321,     0.04643287672674262,     0.045899114551938756,     0.04533470253617205,     0.04474229346678791,     0.04412432262143361,     0.04348303110978635,     0.04282048645393335,     0.04213860088606101,     0.041439147287341695,     0.04072377364126954,     0.03999401545504576,     0.039251307246138574,     0.03849699228903221,     0.03773233177623388,     0.036958512560211584,     0.0361766544003783,     0.03538781630596281,     0.034593002101335056,     0.03379316582690471,     0.03298921595082181,     0.032182019847345894,     0.03137240733538375,     0.030561173942067782,     0.029749084234137933,     0.028936874234666322,     0.028125253943622065,     0.027314909795563693,     0.026506506452306934,     0.025700688620524076,     0.024898082820905325,     0.024099298992718624,     0.02330493162029983,     0.022515561074327346,     0.021731754769109612,     0.020954068211695414,     0.020183045965469656,     0.01941922237639397,     0.018663122417866582,     0.017915262405111976,     0.017176150638112755,     0.016446287986606103,     0.015726168422243978,     0.01501627950253695,     0.01431710281077852,     0.013629114355768437,     0.012952784934817751,     0.012288580463218943,     0.011636962273097002,     0.01099838738431855,     0.010373308749922696,     0.00976217546078901,     0.009165432769286743,     0.008583522514548145,     0.008016883254175542,     0.007465950288628234,     0.006931155384138865,     0.006412927663896278,     0.005911693088721369,     0.005427874339807152,     0.004961891628412366,     0.004514161587243675,     0.004085098285812474,     0.0036751125219508145,     0.003284611745878726,     0.002914000387154261,     0.0025636793976814235,     0.0022340459968619706,     0.001925493602321275,     0.0016384115459869633,     0.0013731847549022479,     0.0011301931047976292,     0.0009098114964470454,     0.0007124087603215625,     0.0005383475093399678,     0.0003879831275138813,     0.0002616634953330736,     0.00015972860635814204,     8.251227428221734e-05,     3.0349581881676337e-05,     3.6152926524010917e-06 \n);\n//The first 2 singular values:\nfloat S[2] = float[](\n    0.024767292133289997,     0.002064586756323816 \n);\n//center of the convolution\nint Nc = 128;\n    //do a convolution in the y direction on iChannel0\n    vec3 sum = vec3(0.0);\n    ivec2 coord = ivec2(fragCoord);\n    for (int i = -Nc; i <= Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        vec4 pixel = texelFetch(iChannel0, ivec2(coord.x, coord.y + i), 0);\n        \n        vec3 val1, val2;\n        unpack2vec3(pixel.xyz, val1, val2);\n\n        sum += val1 * V1[i + Nc] * S[0];\n        sum += val2 * V2[i + Nc] * S[1];\n    }\n\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlBSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 138], [140, 140, 163, 163, 208], [211, 211, 268, 268, 861]], "test": "untested"}
{"id": "mlSXzW", "name": "3D Star Field 2", "author": "michael0884", "description": "Procedural field of stars. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera"], "likes": 2, "viewed": 230, "published": 3, "date": "1675730313", "time_retrieved": "2024-07-30T18:11:46.986308", "image_code": "#define exposure 1.2\n#define sqrexposure 0.6\n#define gamma 1.3\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*c-sqrexposure*c*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    vec3 col = acc.xyz/acc.w + 550.0*bloom.xyz/bloom.w;\n    \n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_b_code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = CAM_ANGLE*camdist;\n    float dec = smoothstep(SLICES, SLICES*0.8, camdist);\n    return min(vec3(100.0), 20.0*heat * smoothstep(mindist, 0.0, mdist) * dec / (camdist*camdist));\n}\n\nvec3 VoxelRaycast(vec3 ro, vec3 rd, float maxt)\n{\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    vec3 col = vec3(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        col += sampleVoxel(ro, rd, voxelPos);\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        traveled = dot(sideLength, mask);\n        \n        if(traveled > maxt) break;\n\t}\n    \n    ro = ro + rd*traveled;\n\treturn col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(VoxelRaycast(cp, rd, SLICES), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //first pass of separable convolution\n    \n//The first 1 columns of the U matrix:\nfloat U1[257] = float[](\n    -7.557296344273823e-09,     -7.876148527818927e-08,     -2.3117979596094795e-07,     -4.6914155456992363e-07,     -7.962351863561828e-07,     -1.2158569096862385e-06,     -1.73137192423984e-06,     -2.3461842283002694e-06,     -3.063775668624977e-06,     -3.887729909453427e-06,     -4.821750977079177e-06,     -5.869676926977158e-06,     -7.0354932213690655e-06,     -8.323343642568621e-06,     -9.737541866572847e-06,     -1.1282582589143565e-05,     -1.296315283073975e-05,     -1.4784143428122506e-05,     -1.6750661194356675e-05,     -1.8868041776592815e-05,     -2.1141862578623146e-05,     -2.3577956813496412e-05,     -2.6182428763773486e-05,     -2.8961668826155482e-05,     -3.19223709448007e-05,     -3.507154991021651e-05,     -3.8416560434431325e-05,     -4.1965117712114906e-05,     -4.572531857965874e-05,     -4.970566483964957e-05,     -5.391508803223462e-05,     -5.8362975911312206e-05,     -6.305920069598252e-05,     -6.801414959265162e-05,     -7.323875747411767e-05,     -7.874454198128607e-05,     -8.454364126638481e-05,     -9.064885460837994e-05,     -9.70736861541115e-05,     -0.00010383239206403088,     -0.00011094003136964075,     -0.00011841252088117362,     -0.00012626669451910085,     -0.00013452036748220727,     -0.00014319240570872507,     -0.00015230280113599675,     -0.00016187275331635382,     -0.00017192475799399502,     -0.00018248270342032322,     -0.0001935719750563917,     -0.0002052195695767992,     -0.00021745421912632148,     -0.00023030652687740992,     -0.00024380911520966136,     -0.0002579967876345579,     -0.0002729067060756482,     -0.00028857858522984115,     -0.00030505490592909695,     -0.00032238114944675006,     -0.0003406060553522691,     -0.00035978190569166,     -0.0003799648383069163,     -0.00040121519309561015,     -0.0004235978951050413,     -0.00044718287883896613,     -0.0004720455592991103,     -0.0004982673553056492,     -0.0005259362721790776,     -0.0005551475514238436,     -0.0005860043963696145,     -0.0006186187842269617,     -0.0006531123762904234,     -0.000689617540357378,     -0.0007282785011662933,     -0.0007692526377838233,     -0.0008127119495306639,     -0.0008588447161577431,     -0.000907857382078767,     -0.0009599767000016091,     -0.0010154521755436758,     -0.0010745588620684698,     -0.001137600564372823,     -0.0012049135208846331,     -0.001276870647949287,     -0.0013538864463342782,     -0.0014364226907244365,     -0.0015249950483367013,     -0.0016201808040860533,     -0.0017226279088993234,     -0.0018330656165747136,     -0.0019523170359852465,     -0.0020813140030855235,     -0.0022211147757790982,     -0.00237292518079984,     -0.002538124003987464,     -0.002718293625332086,     -0.0029152571739400786,     -0.0031311238375717836,     -0.003368344437075814,     -0.003629780010503165,     -0.003918787005245062,     -0.004239323835275993,     -0.004596085148844993,     -0.004994672351370317,     -0.005441812007524935,     -0.005945638108146458,     -0.006516060443573302,     -0.0071652504193862685,     -0.007908289063681344,     -0.008764042068807385,     -0.00975635732456618,     -0.010915727903530209,     -0.012281638652115748,     -0.013905936175421282,     -0.015857763491345687,     -0.018230943198151384,     -0.02115529233405898,     -0.02481443415607389,     -0.029474694208065796,     -0.03553359196587875,     -0.043604367113415345,     -0.05466967458531213,     -0.07037409178092902,     -0.0936064551954588,     -0.12969481008408512,     -0.1887589793394499,     -0.28852141207015086,     -0.44002348591634544,     -0.5426946241198759,     -0.44002348591634544,     -0.28852141207015086,     -0.1887589793394499,     -0.12969481008408512,     -0.0936064551954588,     -0.07037409178092902,     -0.05466967458531213,     -0.043604367113415345,     -0.03553359196587875,     -0.029474694208065796,     -0.02481443415607389,     -0.02115529233405898,     -0.018230943198151384,     -0.015857763491345687,     -0.013905936175421282,     -0.012281638652115748,     -0.010915727903530209,     -0.00975635732456618,     -0.008764042068807385,     -0.007908289063681344,     -0.0071652504193862685,     -0.006516060443573302,     -0.005945638108146458,     -0.005441812007524935,     -0.004994672351370317,     -0.004596085148844993,     -0.004239323835275993,     -0.003918787005245062,     -0.003629780010503165,     -0.003368344437075814,     -0.0031311238375717836,     -0.0029152571739400786,     -0.002718293625332086,     -0.002538124003987464,     -0.00237292518079984,     -0.0022211147757790982,     -0.0020813140030855235,     -0.0019523170359852465,     -0.0018330656165747136,     -0.0017226279088993234,     -0.0016201808040860533,     -0.0015249950483367013,     -0.0014364226907244365,     -0.0013538864463342782,     -0.001276870647949287,     -0.0012049135208846331,     -0.001137600564372823,     -0.0010745588620684698,     -0.0010154521755436758,     -0.0009599767000016091,     -0.000907857382078767,     -0.0008588447161577431,     -0.0008127119495306639,     -0.0007692526377838233,     -0.0007282785011662933,     -0.000689617540357378,     -0.0006531123762904234,     -0.0006186187842269617,     -0.0005860043963696145,     -0.0005551475514238436,     -0.0005259362721790776,     -0.0004982673553056492,     -0.0004720455592991103,     -0.00044718287883896613,     -0.0004235978951050413,     -0.00040121519309561015,     -0.0003799648383069163,     -0.00035978190569166,     -0.0003406060553522691,     -0.00032238114944675006,     -0.00030505490592909695,     -0.00028857858522984115,     -0.0002729067060756482,     -0.0002579967876345579,     -0.00024380911520966136,     -0.00023030652687740992,     -0.00021745421912632148,     -0.0002052195695767992,     -0.0001935719750563917,     -0.00018248270342032322,     -0.00017192475799399502,     -0.00016187275331635382,     -0.00015230280113599675,     -0.00014319240570872507,     -0.00013452036748220727,     -0.00012626669451910085,     -0.00011841252088117362,     -0.00011094003136964075,     -0.00010383239206403088,     -9.70736861541115e-05,     -9.064885460837994e-05,     -8.454364126638481e-05,     -7.874454198128607e-05,     -7.323875747411767e-05,     -6.801414959265162e-05,     -6.305920069598252e-05,     -5.8362975911312206e-05,     -5.391508803223462e-05,     -4.970566483964957e-05,     -4.572531857965874e-05,     -4.1965117712114906e-05,     -3.8416560434431325e-05,     -3.507154991021651e-05,     -3.19223709448007e-05,     -2.8961668826155482e-05,     -2.6182428763773486e-05,     -2.3577956813496412e-05,     -2.1141862578623146e-05,     -1.8868041776592815e-05,     -1.6750661194356675e-05,     -1.4784143428122506e-05,     -1.296315283073975e-05,     -1.1282582589143565e-05,     -9.737541866572847e-06,     -8.323343642568621e-06,     -7.0354932213690655e-06,     -5.869676926977158e-06,     -4.821750977079177e-06,     -3.887729909453427e-06,     -3.063775668624977e-06,     -2.3461842283002694e-06,     -1.73137192423984e-06,     -1.2158569096862387e-06,     -7.962351863561829e-07,     -4.691415545699213e-07,     -2.3117979596017633e-07,     -7.8761485167858e-08,     -7.557296412354428e-09 \n);\n//The first 1 rows of the V matrix:\nfloat V1[257] = float[](\n    -7.557296412354437e-09,     -7.876148544472272e-08,     -2.3117979594533544e-07,     -4.6914155456999817e-07,     -7.962351863561862e-07,     -1.2158569096862438e-06,     -1.731371924239848e-06,     -2.3461842283002813e-06,     -3.063775668624993e-06,     -3.887729909453448e-06,     -4.8217509770792015e-06,     -5.8696769269771874e-06,     -7.035493221369101e-06,     -8.32334364256866e-06,     -9.737541866572901e-06,     -1.1282582589143624e-05,     -1.2963152830739818e-05,     -1.4784143428122583e-05,     -1.675066119435676e-05,     -1.8868041776592923e-05,     -2.1141862578623268e-05,     -2.3577956813496548e-05,     -2.6182428763773636e-05,     -2.8961668826155642e-05,     -3.192237094480087e-05,     -3.50715499102167e-05,     -3.841656043443153e-05,     -4.196511771211514e-05,     -4.5725318579659e-05,     -4.970566483964984e-05,     -5.3915088032234884e-05,     -5.836297591131254e-05,     -6.305920069598286e-05,     -6.8014149592652e-05,     -7.323875747411808e-05,     -7.874454198128653e-05,     -8.454364126638527e-05,     -9.064885460838047e-05,     -9.707368615411205e-05,     -0.00010383239206403147,     -0.00011094003136964141,     -0.00011841252088117427,     -0.0001262666945191015,     -0.00013452036748220803,     -0.00014319240570872589,     -0.00015230280113599765,     -0.00016187275331635477,     -0.00017192475799399602,     -0.00018248270342032422,     -0.00019357197505639277,     -0.00020521956957680033,     -0.00021745421912632273,     -0.00023030652687741122,     -0.00024380911520966274,     -0.00025799678763455933,     -0.0002729067060756499,     -0.00028857858522984283,     -0.0003050549059290988,     -0.00032238114944675174,     -0.0003406060553522711,     -0.00035978190569166196,     -0.0003799648383069184,     -0.00040121519309561254,     -0.00042359789510504364,     -0.0004471828788389687,     -0.000472045559299113,     -0.0004982673553056519,     -0.0005259362721790804,     -0.0005551475514238468,     -0.000586004396369618,     -0.0006186187842269654,     -0.0006531123762904271,     -0.0006896175403573818,     -0.0007282785011662974,     -0.0007692526377838273,     -0.000812711949530668,     -0.0008588447161577481,     -0.000907857382078772,     -0.0009599767000016143,     -0.0010154521755436814,     -0.0010745588620684758,     -0.0011376005643728292,     -0.00120491352088464,     -0.0012768706479492937,     -0.0013538864463342852,     -0.0014364226907244448,     -0.0015249950483367093,     -0.0016201808040860618,     -0.0017226279088993323,     -0.0018330656165747238,     -0.0019523170359852565,     -0.0020813140030855343,     -0.00222111477577911,     -0.0023729251807998526,     -0.0025381240039874767,     -0.0027182936253321,     -0.0029152571739400925,     -0.0031311238375717997,     -0.0033683444370758305,     -0.0036297800105031834,     -0.003918787005245081,     -0.004239323835276013,     -0.004596085148845014,     -0.004994672351370339,     -0.005441812007524961,     -0.0059456381081464844,     -0.006516060443573333,     -0.0071652504193863015,     -0.007908289063681377,     -0.00876404206880742,     -0.009756357324566223,     -0.010915727903530258,     -0.012281638652115795,     -0.013905936175421336,     -0.015857763491345746,     -0.01823094319815145,     -0.021155292334059047,     -0.024814434156073963,     -0.0294746942080659,     -0.035533591965878894,     -0.043604367113415525,     -0.05466967458531236,     -0.07037409178092931,     -0.09360645519545911,     -0.12969481008408545,     -0.18875897933945018,     -0.28852141207015103,     -0.44002348591634527,     -0.5426946241198755,     -0.44002348591634527,     -0.28852141207015103,     -0.18875897933945018,     -0.12969481008408545,     -0.09360645519545911,     -0.07037409178092931,     -0.05466967458531236,     -0.043604367113415525,     -0.035533591965878894,     -0.0294746942080659,     -0.024814434156073963,     -0.021155292334059047,     -0.01823094319815145,     -0.015857763491345746,     -0.013905936175421336,     -0.012281638652115795,     -0.010915727903530258,     -0.009756357324566223,     -0.00876404206880742,     -0.007908289063681377,     -0.0071652504193863015,     -0.006516060443573333,     -0.0059456381081464844,     -0.005441812007524961,     -0.004994672351370339,     -0.004596085148845014,     -0.004239323835276013,     -0.003918787005245081,     -0.0036297800105031834,     -0.0033683444370758305,     -0.0031311238375717997,     -0.0029152571739400925,     -0.0027182936253321,     -0.0025381240039874767,     -0.0023729251807998526,     -0.00222111477577911,     -0.0020813140030855343,     -0.0019523170359852565,     -0.0018330656165747238,     -0.0017226279088993323,     -0.0016201808040860618,     -0.0015249950483367093,     -0.0014364226907244448,     -0.0013538864463342852,     -0.0012768706479492937,     -0.00120491352088464,     -0.0011376005643728292,     -0.0010745588620684758,     -0.0010154521755436814,     -0.0009599767000016143,     -0.000907857382078772,     -0.0008588447161577481,     -0.000812711949530668,     -0.0007692526377838273,     -0.0007282785011662974,     -0.0006896175403573818,     -0.0006531123762904271,     -0.0006186187842269654,     -0.000586004396369618,     -0.0005551475514238468,     -0.0005259362721790804,     -0.0004982673553056519,     -0.000472045559299113,     -0.0004471828788389687,     -0.00042359789510504364,     -0.00040121519309561254,     -0.0003799648383069184,     -0.00035978190569166196,     -0.0003406060553522711,     -0.00032238114944675174,     -0.0003050549059290988,     -0.00028857858522984283,     -0.0002729067060756499,     -0.00025799678763455933,     -0.00024380911520966274,     -0.00023030652687741122,     -0.00021745421912632273,     -0.00020521956957680033,     -0.00019357197505639277,     -0.00018248270342032422,     -0.00017192475799399602,     -0.00016187275331635477,     -0.00015230280113599765,     -0.00014319240570872589,     -0.00013452036748220803,     -0.0001262666945191015,     -0.00011841252088117427,     -0.00011094003136964141,     -0.00010383239206403147,     -9.707368615411205e-05,     -9.064885460838047e-05,     -8.454364126638527e-05,     -7.874454198128653e-05,     -7.323875747411808e-05,     -6.8014149592652e-05,     -6.305920069598286e-05,     -5.836297591131254e-05,     -5.3915088032234884e-05,     -4.970566483964984e-05,     -4.5725318579659e-05,     -4.196511771211514e-05,     -3.841656043443153e-05,     -3.50715499102167e-05,     -3.192237094480087e-05,     -2.8961668826155642e-05,     -2.6182428763773636e-05,     -2.3577956813496548e-05,     -2.1141862578623268e-05,     -1.8868041776592923e-05,     -1.675066119435676e-05,     -1.4784143428122583e-05,     -1.2963152830739818e-05,     -1.1282582589143624e-05,     -9.737541866572901e-06,     -8.32334364256866e-06,     -7.035493221369101e-06,     -5.8696769269771874e-06,     -4.8217509770792015e-06,     -3.887729909453448e-06,     -3.063775668624993e-06,     -2.3461842283002813e-06,     -1.7313719242398478e-06,     -1.215856909686244e-06,     -7.962351863561862e-07,     -4.6914155456992316e-07,     -2.311797959601771e-07,     -7.876148516785817e-08,     -7.557296412354435e-09 \n);\n//The first 1 singular values:\nfloat S[1] = float[](\n    0.045983058370594285 \n);\n//center of the convolution\nint Nc = 128;\n    \n    //do a convolution in the x direction on iChannel0\n    vec3 sum = vec3(0.0);\n    ivec2 coord = ivec2(fragCoord);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        vec4 pixel = texelFetch(iChannel0, ivec2(coord.x + i, coord.y), 0);\n        //multiply the pixel by the coefficient\n        pixel.xyz *= S[0] * U1[i + Nc] / (pixel.w+1e-5);\n        //add the pixel to the sum\n        sum += pixel.xyz;\n    }\n\n    //write the sum to the output\n    fragColor = vec4(sum, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //first pass of separable convolution\n    \n//The first 1 columns of the U matrix:\nfloat U1[257] = float[](\n    -7.557296344273823e-09,     -7.876148527818927e-08,     -2.3117979596094795e-07,     -4.6914155456992363e-07,     -7.962351863561828e-07,     -1.2158569096862385e-06,     -1.73137192423984e-06,     -2.3461842283002694e-06,     -3.063775668624977e-06,     -3.887729909453427e-06,     -4.821750977079177e-06,     -5.869676926977158e-06,     -7.0354932213690655e-06,     -8.323343642568621e-06,     -9.737541866572847e-06,     -1.1282582589143565e-05,     -1.296315283073975e-05,     -1.4784143428122506e-05,     -1.6750661194356675e-05,     -1.8868041776592815e-05,     -2.1141862578623146e-05,     -2.3577956813496412e-05,     -2.6182428763773486e-05,     -2.8961668826155482e-05,     -3.19223709448007e-05,     -3.507154991021651e-05,     -3.8416560434431325e-05,     -4.1965117712114906e-05,     -4.572531857965874e-05,     -4.970566483964957e-05,     -5.391508803223462e-05,     -5.8362975911312206e-05,     -6.305920069598252e-05,     -6.801414959265162e-05,     -7.323875747411767e-05,     -7.874454198128607e-05,     -8.454364126638481e-05,     -9.064885460837994e-05,     -9.70736861541115e-05,     -0.00010383239206403088,     -0.00011094003136964075,     -0.00011841252088117362,     -0.00012626669451910085,     -0.00013452036748220727,     -0.00014319240570872507,     -0.00015230280113599675,     -0.00016187275331635382,     -0.00017192475799399502,     -0.00018248270342032322,     -0.0001935719750563917,     -0.0002052195695767992,     -0.00021745421912632148,     -0.00023030652687740992,     -0.00024380911520966136,     -0.0002579967876345579,     -0.0002729067060756482,     -0.00028857858522984115,     -0.00030505490592909695,     -0.00032238114944675006,     -0.0003406060553522691,     -0.00035978190569166,     -0.0003799648383069163,     -0.00040121519309561015,     -0.0004235978951050413,     -0.00044718287883896613,     -0.0004720455592991103,     -0.0004982673553056492,     -0.0005259362721790776,     -0.0005551475514238436,     -0.0005860043963696145,     -0.0006186187842269617,     -0.0006531123762904234,     -0.000689617540357378,     -0.0007282785011662933,     -0.0007692526377838233,     -0.0008127119495306639,     -0.0008588447161577431,     -0.000907857382078767,     -0.0009599767000016091,     -0.0010154521755436758,     -0.0010745588620684698,     -0.001137600564372823,     -0.0012049135208846331,     -0.001276870647949287,     -0.0013538864463342782,     -0.0014364226907244365,     -0.0015249950483367013,     -0.0016201808040860533,     -0.0017226279088993234,     -0.0018330656165747136,     -0.0019523170359852465,     -0.0020813140030855235,     -0.0022211147757790982,     -0.00237292518079984,     -0.002538124003987464,     -0.002718293625332086,     -0.0029152571739400786,     -0.0031311238375717836,     -0.003368344437075814,     -0.003629780010503165,     -0.003918787005245062,     -0.004239323835275993,     -0.004596085148844993,     -0.004994672351370317,     -0.005441812007524935,     -0.005945638108146458,     -0.006516060443573302,     -0.0071652504193862685,     -0.007908289063681344,     -0.008764042068807385,     -0.00975635732456618,     -0.010915727903530209,     -0.012281638652115748,     -0.013905936175421282,     -0.015857763491345687,     -0.018230943198151384,     -0.02115529233405898,     -0.02481443415607389,     -0.029474694208065796,     -0.03553359196587875,     -0.043604367113415345,     -0.05466967458531213,     -0.07037409178092902,     -0.0936064551954588,     -0.12969481008408512,     -0.1887589793394499,     -0.28852141207015086,     -0.44002348591634544,     -0.5426946241198759,     -0.44002348591634544,     -0.28852141207015086,     -0.1887589793394499,     -0.12969481008408512,     -0.0936064551954588,     -0.07037409178092902,     -0.05466967458531213,     -0.043604367113415345,     -0.03553359196587875,     -0.029474694208065796,     -0.02481443415607389,     -0.02115529233405898,     -0.018230943198151384,     -0.015857763491345687,     -0.013905936175421282,     -0.012281638652115748,     -0.010915727903530209,     -0.00975635732456618,     -0.008764042068807385,     -0.007908289063681344,     -0.0071652504193862685,     -0.006516060443573302,     -0.005945638108146458,     -0.005441812007524935,     -0.004994672351370317,     -0.004596085148844993,     -0.004239323835275993,     -0.003918787005245062,     -0.003629780010503165,     -0.003368344437075814,     -0.0031311238375717836,     -0.0029152571739400786,     -0.002718293625332086,     -0.002538124003987464,     -0.00237292518079984,     -0.0022211147757790982,     -0.0020813140030855235,     -0.0019523170359852465,     -0.0018330656165747136,     -0.0017226279088993234,     -0.0016201808040860533,     -0.0015249950483367013,     -0.0014364226907244365,     -0.0013538864463342782,     -0.001276870647949287,     -0.0012049135208846331,     -0.001137600564372823,     -0.0010745588620684698,     -0.0010154521755436758,     -0.0009599767000016091,     -0.000907857382078767,     -0.0008588447161577431,     -0.0008127119495306639,     -0.0007692526377838233,     -0.0007282785011662933,     -0.000689617540357378,     -0.0006531123762904234,     -0.0006186187842269617,     -0.0005860043963696145,     -0.0005551475514238436,     -0.0005259362721790776,     -0.0004982673553056492,     -0.0004720455592991103,     -0.00044718287883896613,     -0.0004235978951050413,     -0.00040121519309561015,     -0.0003799648383069163,     -0.00035978190569166,     -0.0003406060553522691,     -0.00032238114944675006,     -0.00030505490592909695,     -0.00028857858522984115,     -0.0002729067060756482,     -0.0002579967876345579,     -0.00024380911520966136,     -0.00023030652687740992,     -0.00021745421912632148,     -0.0002052195695767992,     -0.0001935719750563917,     -0.00018248270342032322,     -0.00017192475799399502,     -0.00016187275331635382,     -0.00015230280113599675,     -0.00014319240570872507,     -0.00013452036748220727,     -0.00012626669451910085,     -0.00011841252088117362,     -0.00011094003136964075,     -0.00010383239206403088,     -9.70736861541115e-05,     -9.064885460837994e-05,     -8.454364126638481e-05,     -7.874454198128607e-05,     -7.323875747411767e-05,     -6.801414959265162e-05,     -6.305920069598252e-05,     -5.8362975911312206e-05,     -5.391508803223462e-05,     -4.970566483964957e-05,     -4.572531857965874e-05,     -4.1965117712114906e-05,     -3.8416560434431325e-05,     -3.507154991021651e-05,     -3.19223709448007e-05,     -2.8961668826155482e-05,     -2.6182428763773486e-05,     -2.3577956813496412e-05,     -2.1141862578623146e-05,     -1.8868041776592815e-05,     -1.6750661194356675e-05,     -1.4784143428122506e-05,     -1.296315283073975e-05,     -1.1282582589143565e-05,     -9.737541866572847e-06,     -8.323343642568621e-06,     -7.0354932213690655e-06,     -5.869676926977158e-06,     -4.821750977079177e-06,     -3.887729909453427e-06,     -3.063775668624977e-06,     -2.3461842283002694e-06,     -1.73137192423984e-06,     -1.2158569096862387e-06,     -7.962351863561829e-07,     -4.691415545699213e-07,     -2.3117979596017633e-07,     -7.8761485167858e-08,     -7.557296412354428e-09 \n);\n//The first 1 rows of the V matrix:\nfloat V1[257] = float[](\n    -7.557296412354437e-09,     -7.876148544472272e-08,     -2.3117979594533544e-07,     -4.6914155456999817e-07,     -7.962351863561862e-07,     -1.2158569096862438e-06,     -1.731371924239848e-06,     -2.3461842283002813e-06,     -3.063775668624993e-06,     -3.887729909453448e-06,     -4.8217509770792015e-06,     -5.8696769269771874e-06,     -7.035493221369101e-06,     -8.32334364256866e-06,     -9.737541866572901e-06,     -1.1282582589143624e-05,     -1.2963152830739818e-05,     -1.4784143428122583e-05,     -1.675066119435676e-05,     -1.8868041776592923e-05,     -2.1141862578623268e-05,     -2.3577956813496548e-05,     -2.6182428763773636e-05,     -2.8961668826155642e-05,     -3.192237094480087e-05,     -3.50715499102167e-05,     -3.841656043443153e-05,     -4.196511771211514e-05,     -4.5725318579659e-05,     -4.970566483964984e-05,     -5.3915088032234884e-05,     -5.836297591131254e-05,     -6.305920069598286e-05,     -6.8014149592652e-05,     -7.323875747411808e-05,     -7.874454198128653e-05,     -8.454364126638527e-05,     -9.064885460838047e-05,     -9.707368615411205e-05,     -0.00010383239206403147,     -0.00011094003136964141,     -0.00011841252088117427,     -0.0001262666945191015,     -0.00013452036748220803,     -0.00014319240570872589,     -0.00015230280113599765,     -0.00016187275331635477,     -0.00017192475799399602,     -0.00018248270342032422,     -0.00019357197505639277,     -0.00020521956957680033,     -0.00021745421912632273,     -0.00023030652687741122,     -0.00024380911520966274,     -0.00025799678763455933,     -0.0002729067060756499,     -0.00028857858522984283,     -0.0003050549059290988,     -0.00032238114944675174,     -0.0003406060553522711,     -0.00035978190569166196,     -0.0003799648383069184,     -0.00040121519309561254,     -0.00042359789510504364,     -0.0004471828788389687,     -0.000472045559299113,     -0.0004982673553056519,     -0.0005259362721790804,     -0.0005551475514238468,     -0.000586004396369618,     -0.0006186187842269654,     -0.0006531123762904271,     -0.0006896175403573818,     -0.0007282785011662974,     -0.0007692526377838273,     -0.000812711949530668,     -0.0008588447161577481,     -0.000907857382078772,     -0.0009599767000016143,     -0.0010154521755436814,     -0.0010745588620684758,     -0.0011376005643728292,     -0.00120491352088464,     -0.0012768706479492937,     -0.0013538864463342852,     -0.0014364226907244448,     -0.0015249950483367093,     -0.0016201808040860618,     -0.0017226279088993323,     -0.0018330656165747238,     -0.0019523170359852565,     -0.0020813140030855343,     -0.00222111477577911,     -0.0023729251807998526,     -0.0025381240039874767,     -0.0027182936253321,     -0.0029152571739400925,     -0.0031311238375717997,     -0.0033683444370758305,     -0.0036297800105031834,     -0.003918787005245081,     -0.004239323835276013,     -0.004596085148845014,     -0.004994672351370339,     -0.005441812007524961,     -0.0059456381081464844,     -0.006516060443573333,     -0.0071652504193863015,     -0.007908289063681377,     -0.00876404206880742,     -0.009756357324566223,     -0.010915727903530258,     -0.012281638652115795,     -0.013905936175421336,     -0.015857763491345746,     -0.01823094319815145,     -0.021155292334059047,     -0.024814434156073963,     -0.0294746942080659,     -0.035533591965878894,     -0.043604367113415525,     -0.05466967458531236,     -0.07037409178092931,     -0.09360645519545911,     -0.12969481008408545,     -0.18875897933945018,     -0.28852141207015103,     -0.44002348591634527,     -0.5426946241198755,     -0.44002348591634527,     -0.28852141207015103,     -0.18875897933945018,     -0.12969481008408545,     -0.09360645519545911,     -0.07037409178092931,     -0.05466967458531236,     -0.043604367113415525,     -0.035533591965878894,     -0.0294746942080659,     -0.024814434156073963,     -0.021155292334059047,     -0.01823094319815145,     -0.015857763491345746,     -0.013905936175421336,     -0.012281638652115795,     -0.010915727903530258,     -0.009756357324566223,     -0.00876404206880742,     -0.007908289063681377,     -0.0071652504193863015,     -0.006516060443573333,     -0.0059456381081464844,     -0.005441812007524961,     -0.004994672351370339,     -0.004596085148845014,     -0.004239323835276013,     -0.003918787005245081,     -0.0036297800105031834,     -0.0033683444370758305,     -0.0031311238375717997,     -0.0029152571739400925,     -0.0027182936253321,     -0.0025381240039874767,     -0.0023729251807998526,     -0.00222111477577911,     -0.0020813140030855343,     -0.0019523170359852565,     -0.0018330656165747238,     -0.0017226279088993323,     -0.0016201808040860618,     -0.0015249950483367093,     -0.0014364226907244448,     -0.0013538864463342852,     -0.0012768706479492937,     -0.00120491352088464,     -0.0011376005643728292,     -0.0010745588620684758,     -0.0010154521755436814,     -0.0009599767000016143,     -0.000907857382078772,     -0.0008588447161577481,     -0.000812711949530668,     -0.0007692526377838273,     -0.0007282785011662974,     -0.0006896175403573818,     -0.0006531123762904271,     -0.0006186187842269654,     -0.000586004396369618,     -0.0005551475514238468,     -0.0005259362721790804,     -0.0004982673553056519,     -0.000472045559299113,     -0.0004471828788389687,     -0.00042359789510504364,     -0.00040121519309561254,     -0.0003799648383069184,     -0.00035978190569166196,     -0.0003406060553522711,     -0.00032238114944675174,     -0.0003050549059290988,     -0.00028857858522984283,     -0.0002729067060756499,     -0.00025799678763455933,     -0.00024380911520966274,     -0.00023030652687741122,     -0.00021745421912632273,     -0.00020521956957680033,     -0.00019357197505639277,     -0.00018248270342032422,     -0.00017192475799399602,     -0.00016187275331635477,     -0.00015230280113599765,     -0.00014319240570872589,     -0.00013452036748220803,     -0.0001262666945191015,     -0.00011841252088117427,     -0.00011094003136964141,     -0.00010383239206403147,     -9.707368615411205e-05,     -9.064885460838047e-05,     -8.454364126638527e-05,     -7.874454198128653e-05,     -7.323875747411808e-05,     -6.8014149592652e-05,     -6.305920069598286e-05,     -5.836297591131254e-05,     -5.3915088032234884e-05,     -4.970566483964984e-05,     -4.5725318579659e-05,     -4.196511771211514e-05,     -3.841656043443153e-05,     -3.50715499102167e-05,     -3.192237094480087e-05,     -2.8961668826155642e-05,     -2.6182428763773636e-05,     -2.3577956813496548e-05,     -2.1141862578623268e-05,     -1.8868041776592923e-05,     -1.675066119435676e-05,     -1.4784143428122583e-05,     -1.2963152830739818e-05,     -1.1282582589143624e-05,     -9.737541866572901e-06,     -8.32334364256866e-06,     -7.035493221369101e-06,     -5.8696769269771874e-06,     -4.8217509770792015e-06,     -3.887729909453448e-06,     -3.063775668624993e-06,     -2.3461842283002813e-06,     -1.7313719242398478e-06,     -1.215856909686244e-06,     -7.962351863561862e-07,     -4.6914155456992316e-07,     -2.311797959601771e-07,     -7.876148516785817e-08,     -7.557296412354435e-09 \n);\n//The first 1 singular values:\nfloat S[1] = float[](\n    0.045983058370594285 \n);\n//center of the convolution\nint Nc = 128;\n    \n    \n    //do a convolution in the x direction on iChannel0\n    vec3 sum = vec3(0.0);\n    ivec2 coord = ivec2(fragCoord);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        vec4 pixel = texelFetch(iChannel0, ivec2(coord.x, coord.y + i), 0);\n        //multiply the pixel by the coefficient\n        pixel.xyz *= S[0] * V1[i + Nc] / (pixel.w+1e-5);\n        //add the pixel to the sum\n        sum += pixel.xyz;\n    }\n\n    //write the sum to the output\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSXzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 138], [140, 140, 163, 163, 208], [211, 211, 268, 268, 502]], "test": "untested"}
{"id": "mtSSzW", "name": "yYy_Audio_yYy", "author": "SnoopethDuckDuck", "description": "Make sure to click the music thingy in Buffer A!\n\nThis uses a buffer to smooth the audio and reduce \"jitter\" as it jumps up and down", "tags": ["e"], "likes": 19, "viewed": 366, "published": 3, "date": "1675725987", "time_retrieved": "2024-07-30T18:11:47.793151", "image_code": "// from Blacklemori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n#define t iTime\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define pal(a) .5+.5*cos(2.*pi*(a))\n\nfloat clength(vec2 a) {\n    float mx = step(a.y, 0.);\n    return mix(max(abs(a.x), abs(a.y)), length(a), mx);\n}\n\n// this codes a bit messy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    uv.x = -abs(uv.x);\n    vec2 ouv = uv;    \n    uv.x += 0.04 * cos(t + 4.*uv.y); // * tanh(0.1 * t);\n    uv.y -= 0.1 * t; // was + volume\n    \n    vec2 sc = vec2(16. + 3.*cos(t + 4.*uv.y), 16.);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;    \n    float h = hash(ipos.x, 100. * ipos.y);\n    h = 0.5 + 0.5 * sin(0.1 * t + 2. * pi * h);\n    //h = floor(10. * h) / 10.;\n    \n    float d = length(fpos);\n    \n    float r = texture(iChannel0, vec2(h)).a;\n    // r = (1. - 0.5 * tanh(0.1*t)) * floor(12. * r) / 12.;\n    r = tanh(0.5*t) * 0.5 * r;\n \n    vec4 audio1 = texture(iChannel0, vec2(0.5, 0));\n    float offy = 1.5 + .5 * cos(5. * ouv.y + 2. * pi * audio1.r);\n    vec3 off = 0.5 * vec3(.25, offy, 2)/3.;\n    vec3 pal1 = pal(0.1 * t + h + off);\n    \n    float a = atan(ouv.x, ouv.y);//mod(atan(ouv.x, ouv.y) + pi/2., 2. * pi);\n    vec4 audio2 = texture(iChannel0, vec2(.5+.5*cos(2.*a), 0.));\n    vec3 pal2 = pal(4. * audio2.g + off);\n    \n    // Offset small circles inside larger ones\n    float th = 2. * pi * h - 2. * t;\n    vec2 circleOff = 0.05 * vec2(cos(th), sin(th));\n \n    // Shield distance\n    float d2 = clength(ouv);\n    \n    // Volume\n    float vol = 0.6 * texture(iChannel0, 0.*fragCoord/res).g; //?\n    \n    // Grid circles\n    float k = sc.x / res.y;\n    vec3 col = mix(pal1, vec3(0), 1. - smoothstep(-k, k, r - d));\n    \n    // Draw small circles on top, darken if outside shield\n    float d3 = length(fpos - circleOff);    \n    col *= .5+.5*step(d2, vol) - 0.25 * smoothstep(-k, k, r-d3-0.075);\n   \n    // Darken outside shield\n    col *= 0.45 + 0.55 * step(d2, vol);\n    \n    // Shield border\n    k /= sc.x;\n    float s = smoothstep(-2. * k, 2. * k, 0.005 - abs(d2 - vol));\n    s += exp(-50. * abs(d2 - 1.05 * vol));\n    col += s * pal2;\n    \n    // Inside/outside shield colors\n    vec3 insideCol = col + vec3(0.1, 0.02, 0.15);\n    vec3 outsideCol = vec3(0.15 + 0.8 * length(col));\n    outsideCol += 4. * col * exp(-10. * (1.-vol) * abs(ouv.y));\n    col = mix(insideCol, outsideCol, (1.-2.*vol)*(1.-step(d2, vol)));\n    \n    // Border\n    vec3 bcol = mix(pal2, vec3(0), vol);\n    col += vol*bcol*exp(-50.*(1.-vol)*abs(abs(ouv.x) - 0.5*res.x/res.y));\n    col += vol*bcol*exp(-50.*(1.-vol)*abs(abs(ouv.y) - 0.5));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Heavily influenced by Kishimisu's shader:\n// https://www.shadertoy.com/view/dtl3Dr\n\nfloat getVol(float samples) {\n    float v = 0.;\n    for (float i = 0.; i < samples; i++) \n        v += texture(iChannel1, vec2((i + 0.5)/samples, 0.05)).x;\n    return v / samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //float sc = 32.;\n    //uv.x = floor(sc * uv.x + 0.5)/sc;\n    \n    vec4 ch0 = texture(iChannel0, uv);\n    float ch1 = 0.;\n    \n    // Number of samples in either direction\n    float n = 5.;\n    \n    // Sample spacing (value chosen because it looks good)\n    float s = 0.003;  //0.003 with n=5.\n    \n    // Average of samples, ch1\n    for (float i = -n; i <= n; i++) \n        ch1 = max(ch1, texture(iChannel1, vec2(uv.x + s * i, 0.25)).x);\n        //ch1 += log(1.+texture(iChannel1, vec2(uv.x + s * i, 0.25)).x);\n    //ch1 /= 2.*n + 1.;\n    \n    // Alpha scales with uv.x, since bassy tones are more prevalent\n    float r = mix(ch0.r, ch1, 0.4);\n    float g = mix(ch0.g, getVol(50.), 0.3);\n    float a = mix(ch0.a, ch1 * (1. + 0.55 * uv.x), 0.4);\n    \n    vec3 col = vec3(r, g, step(uv.y - a + 0.1, 0.008));\n\n    fragColor = vec4(col, a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32295, "src": "https://soundcloud.com/sycco/ripple?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtSSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 105, 105, 181], [295, 295, 318, 318, 406], [408, 434, 491, 491, 2872]], "test": "untested"}
{"id": "ctBXRD", "name": "3d points with color mixing", "author": "jildert", "description": "my test shader", "tags": ["3d"], "likes": 4, "viewed": 105, "published": 3, "date": "1675720892", "time_retrieved": "2024-07-30T18:11:48.752585", "image_code": "float distLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nfloat drawPoint(vec3 ro, vec3 rd, vec3 p) {\n    float d = distLine(ro, rd, p);\n    d = smoothstep(.2, .19, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(3.*sin(t) - .2, 2. + sin(t), -3.*cos(t) + .2);\n    \n    vec3 lookat = vec3(.5);\n    \n    float zoom = 1.;\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n \n    \n    float d = 0.;\n    d += drawPoint(ro, rd, vec3(0., 0., 0.));\n    d += drawPoint(ro, rd, vec3(0., 0., 1.));\n    d += drawPoint(ro, rd, vec3(0., 0., 0.));\n    d += drawPoint(ro, rd, vec3(0., 1., 0.));\n    d += drawPoint(ro, rd, vec3(0., 1., 1.));\n    d += drawPoint(ro, rd, vec3(1., 0., 0.));\n    d += drawPoint(ro, rd, vec3(1., 0., 1.));\n    d += drawPoint(ro, rd, vec3(1., 1., 0.));\n    d += drawPoint(ro, rd, vec3(1., 1., 1.));\n    d += sin(iTime) * .4;\n    \n    fragColor = vec4(d - uv.y + drawPoint(ro, rd, vec3(0., .5, 0.)), d - uv.x + drawPoint(ro, rd, vec3(0., .5, 1.)), uv.x + drawPoint(ro, rd, vec3(0., .5, .5)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 93], [95, 95, 138, 138, 221], [223, 223, 280, 280, 1354]], "test": "untested"}
{"id": "cllXWM", "name": "Very simple scrolling mosaic", "author": "maras", "description": "Very simple scrolling mosaic. I can't figure out how to scroll rows or columns by odd number of moves, so now mosaic will back to original position after 4 moves. I added changing colors in time to mask that XD (change line 21 to const to see this).", "tags": ["simple", "mosaic", "scrolling"], "likes": 3, "viewed": 229, "published": 3, "date": "1675715036", "time_retrieved": "2024-07-30T18:11:49.582367", "image_code": "#define PI 3.14159265\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(8.4325, 94.3412))) * 334.1243);\n}\n\nfloat timeShift(float min_speed, float offset, float ref) {\n    return min_speed * floor(mod(ref, offset));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 createMosaic(vec2 p, float tiles) {\n    p *= tiles;\n  \n    if (floor(mod(iTime / (PI / 2.0), 2.0)) < 1.0) p.x += timeShift(2.0, 4.0, p.y) * sin(iTime);\n    else p.y += timeShift(4.0, 2.0, p.x) * sin(iTime);\n        \n    if (mod(iTime / (PI / 2.0) + 1.0, 4.0) >= 2.0) p.x += timeShift(2.0, 4.0, p.y);\n    else p.y += timeShift(4.0, 2.0, p.x);\n    \n    float rand_col = rand(floor(p));\n    float time_change_color = iTime / 3.0;\n    return vec3(rand_col * abs(sin(time_change_color)),\n               rand_col * abs(cos(time_change_color)),\n               rand_col * abs(cos(time_change_color * rand_col)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n    p -= 0.5;\n    p *= scale(vec2(abs(sin(iTime / 10.0)) * 2.0 + 1.0));\n    p *= rotate(iTime / 7.0);\n    p += 0.5;\n    vec3 col = createMosaic(p, 12.0);\n       \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 43, 43, 111], [113, 113, 172, 172, 222], [224, 224, 248, 248, 311], [313, 313, 339, 339, 425], [427, 427, 467, 467, 1038], [1040, 1040, 1097, 1097, 1334]], "test": "untested"}
{"id": "DtSSzW", "name": "Mouse Walker", "author": "QuantumSuper", "description": "Strolling through the night.", "tags": ["cartoon"], "likes": 27, "viewed": 419, "published": 3, "date": "1675711892", "time_retrieved": "2024-07-30T18:11:50.333360", "image_code": "// Mouse Walker 0.8.230209\n// vector-based bufferless cartoon animation\n// by QuantumSuper.\n\n#define PI 3.14159265359 \n\nfloat amp;\n\nmat2 rotM(float deg){\n    deg /= 180./PI;\n    return mat2(cos(deg),-sin(deg),sin(deg),cos(deg));\n}\n\nvec2 rot(vec2 p, vec2 dP, vec3 myRot){\n    return (p-dP-myRot.xy)*rotM(myRot.z)+myRot.xy;\n}\nvec2 rot(vec2 pos, vec2 dPos, float myRot){ //overloaded, rotations around origin\n    return rot(pos, dPos, vec3(.0,.0,myRot));\n}\n\nfloat hash21(vec2 p){ //see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){ //a line between a and b in domain of p\n\tvec2 ab = b-a;\n\treturn .005/length(a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.)-p);\n}\n\nvoid elli(vec2 p, vec2 e, float fill){ //overloaded, not sure I ever need summed overlaps?\n    float d = length(p/e)-1.;\n    if (d<fwidth(d)) amp = fill*smoothstep(20.*fwidth(d),.0,d);\n}\n\nvoid horizon(vec2 p, vec2 a, vec2 b){ //horizon between a, b with a.x<b.x in domain of p\n\tvec2 ab = b-a;\n    ab = a+(ab)*clamp(dot(p-a,ab)/dot(ab,ab),0.,1.);\n    float d = length(ab-p);\n\tamp += -.5*smoothstep(2.*fwidth(d),.0,d);\n    if ((p.x>a.x) && (p.x<b.x) && (ab.y<p.y)) amp -= .3+.25*d; //sky\n    amp += step(a.y,.124)*.005/length(p-vec2(a.x+.1,1.5*a.y)); //lights\n}\n\nvoid rect(vec2 p, vec2 rect, float fill){ //smooth rectangle\n    vec2 dv = abs(p/rect)-.5; //dist per axis\n    //amp = smoothstep(1.5,-1.5,max(min(.0,min(dv.x,dv.y)),max(dv.x+dv.y,max(dv.x,dv.y)))); //full dist fun\n    //amp = smoothstep(2.5*max(rect.x/rect.y,max(sign(-dv.y),dot(vec2(1.,rect.x/rect.y),normalize(dv)))),.0,max(.0,max(dv.x+dv.y,max(dv.x,dv.y)))); //outer dist fun with smoothstep correction\n    float d = max(.0,max(dv.x+dv.y,max(dv.x,dv.y))); //outer dist fun\n    amp = mix(amp, fill, smoothstep(.025/rect.x,.0, d));\n}\n\nvoid house(vec2 pos, vec2 size, float fill){\n    rect(pos, size, fill); //building\n    float window = size.x/8.;\n    pos += size*vec2(3./8.,.5);\n    for (float n=1.;n<.5*size.y/window-1.; n++){\n        for (float m=.0;m<4.;m++){\n            if (hash21(size*vec2(m,n))<.3) rect(pos-2.*vec2(m*window,n*window), vec2(window), -fill); //windows\n        }\n    }\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float animTime = mod(2.*2.133333*iTime,2.*PI); //...buggy without mod at large iTime, ?overflow\n    float animFrame = floor(float(iFrame)/9.);\n\tvec3 col = vec3(0.5);\n\tamp = 0.;\n    \n    // Viewport\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); // max -1..1\n    uv *=1.5;\n\n    // Background\n    for (float n=.0; n<15.; n++){ //horizon & sky\n        horizon(uv, vec2(-1.5+.2*n, .12+.03*hash21(vec2(animFrame)+n)), vec2(-1.5+.2*(n+1.), .12+.03*hash21(vec2(animFrame)+n+1.)));\n    }\n    \n    animFrame *= .2;\n    //float flashx = 3.*hash21(vec2(floor(animFrame)*100.,floor(animFrame)))-1.5;\n    float flashx = 3.*hash21(vec2(floor(animFrame)))-1.5;\n    if (hash21(vec2(flashx,flashx*flashx))<.08){ //lightning\n        for (float n=.0; n<6.; n++){\n            amp += sin(fract(animFrame)*PI)*line(uv, vec2(flashx+.1*sin((100.*flashx+PI)*n),.7-.1*n), vec2(flashx+.1*sin((100.*flashx+PI)*(n+1.)),.6-.1*n));\n        }  \n    } \n    \n    animFrame *= .25;\n    house(uv-vec2(2.-4.*fract(animFrame),.2),vec2(.4+.1*sin(floor(animFrame)),.5+.3*sin(floor(animFrame))),-.2);\n    animFrame *= 1.4;\n    house(uv-vec2(2.-4.*fract(animFrame),.1),vec2(.5+.2*sin(floor(animFrame)),.8+.3*sin(floor(animFrame))),-.1);\n    \n    animFrame *= 1.6;\n    elli(uv-vec2(2.-4.*fract(animFrame),-.65+.15*sin(floor(animFrame))), vec2(.8+.3*sin(floor(animFrame)),.02), -.05);\n    \n    \n    // Figurine animation definition (delta position.xy, delta angle)\n    vec2 friction = 1.+.4*vec2(sin(animTime),sin(animTime-.9*PI)); //thanks @observer for the idea\n    vec3 mArmUL = vec3(.0,.07, 40.+45.*sin(animTime)*friction.y);\n    vec3 mArmUR = vec3(.0,.07, 40.+55.*sin(animTime-.9*PI)*friction.x);\n    \n    vec3 mLegUL = vec3(.0,.07, 45.*sin(animTime-.9*PI)*friction.x);\n    vec3 mLegLL = vec3(.0,.07, 45.*clamp(sin(animTime-73./8.*PI),-.0,1.));\n    vec3 mShoeUL = vec3(.0,.0, -45.*clamp(sin(animTime-.9*PI),-1.,.0));\n    \n    vec3 mLegUR = vec3(.0,.07, 45.*sin(animTime)*friction.y);\n    vec3 mLegLR = vec3(.0,.07, 45.*clamp(sin(animTime-PI/8.),-0.,1.));\n    vec3 mShoeUR = vec3(.0,.0, -45.*clamp(sin(animTime),-1.,.0));\n    \n    \n    // Figurine position definition\n    vec2 body = rot(uv, vec2(.0,.1), -20.);\n    vec2 belly = rot(body, vec2(-.005,-.08), 20.);\n    vec2 trouserM = rot(body, vec2(-.03,-.18), 20.);\n    vec2 buttonR = trouserM-vec2(.12,.02);\n    vec2 buttonL = trouserM-vec2(.03,-.02);\n    \n    vec2 shadow = rot(body, vec2(-.2,-.65), 20.);\n    \n    vec2 armUL = rot(body, vec2(-.08,-.02), mArmUL);\n    vec2 armLL = rot(armUL, vec2(.01,-.15), vec3(.0,.07, -90.));\n    vec2 handUL = armLL-vec2(.0,-.04);\n    vec2 handLL = handUL-vec2(.0,-.07);\n    \n    vec2 armUR = rot(body, vec2(.01,.0), mArmUR);\n    vec2 armLR = rot(armUR, vec2(.01,-.15), vec3(.0,.07, -90.));\n    vec2 handUR = armLR-vec2(.0,-.04);\n    vec2 handLR = handUR-vec2(.0,-.07);\n    \n    vec2 trouserL = trouserM-vec2(-.07,-.08); \n    vec2 legUL = rot(trouserL, vec2(.02,-.06), mLegUL);\n    vec2 legLL = rot(legUL, vec2(.0,-.15), mLegLL);\n    vec2 shoeUL = rot(legLL, vec2(.0,-.1), mShoeUL);\n    vec2 shoeLL = shoeUL-vec2(.06,-.07);\n\n    vec2 trouserR = trouserM-vec2(.07,-.06);\n    vec2 legUR = rot(trouserR, vec2(-.01,-.06), mLegUR);\n    vec2 legLR = rot(legUR, vec2(.0,-.15), mLegLR);\n    vec2 shoeUR = rot(legLR, vec2(.0,-.1), mShoeUR);\n    vec2 shoeLR = shoeUR-vec2(.06,-.07);\n    \n    vec2 head = rot(body, vec2(.02,.22), 20.);\n    vec2 earR = head-vec2(-.12,.22);\n    vec2 earL = head-vec2(-.25,-.02);\n    vec2 noseB = rot(head, vec2(.18,.0), 35.);\n    vec2 noseT = rot(noseB, vec2(.0,.12), vec3(.0,-.04,-15.));\n    vec2 cheek = rot(head, vec2(.01,-.09), 15.);\n    vec2 mouth = head-vec2(.06,-.05);\n    vec2 lipU = head-vec2(.05,-.02);\n    vec2 tongue = rot(mouth, vec2(.025,-.092), -15.);\n    \n    vec2 eyeRO = rot(head, vec2(.08,.09), 45.);\n    vec2 eyeRI = eyeRO-vec2(.0,.01);\n    vec2 eyeLO = rot(head, vec2(-.01,.05), 45.);\n    vec2 eyeLI = eyeLO-vec2(.0);\n    \n    \n    // Figurine assembly, order matters \n    elli(shadow, vec2(.3*sin(animTime),.02), -.2);\n    \n    elli(legUL, vec2(.02,.09), -.5);\n    elli(legLL, vec2(.02,.09), -.5);\n    elli(shoeUL, vec2(.04,.02), .5);\n    elli(shoeLL, vec2(.14,.06), .5);\n    \n    elli(legUR, vec2(.02,.09), -.5);\n    elli(legLR, vec2(.02,.09), -.5); \n    elli(shoeUR, vec2(.04,.02), .5);\n    elli(shoeLR, vec2(.14,.06), .5);\n    \n    elli(armUR, vec2(.02,.09), -.5);\n    elli(armLR, vec2(.02,.09), -.5);\n    elli(handLR, vec2(.08,.07), -.5);\n    elli(handLR, vec2(.07,.06), .5);\n    elli(handUR, vec2(.04,.02), .5);\n    \n    elli(body, vec2(.12,.2), -.5);\n    amp += -1.*smoothstep(.007,-.007, abs(trouserM.y+.03+.02*sin(20.*trouserM.x+2.*animTime)))*smoothstep(.05,.0,length(uv-vec2(-.4,.0))-.3); //tail\n    \n    elli(trouserL, vec2(.08,.06), .5);\n    elli(trouserR, vec2(.08,.06), .5);\n    elli(trouserM, vec2(.17,.12), .5);\n    elli(buttonR, vec2(.025,.045), -.5);\n    elli(buttonR, vec2(.015,.035), .5);\n    elli(buttonL, vec2(.025,.045), -.5);\n    elli(buttonL, vec2(.015,.035), .5);\n    \n    elli(belly, vec2(.12,.06), -.5);\n    \n    elli(armUL, vec2(.02,.09), -.5);\n    elli(armLL, vec2(.02,.09), -.5);\n    elli(handLL, vec2(.08,.07), -.5);\n    elli(handLL, vec2(.07,.06), .5);\n    elli(handUL, vec2(.04,.02), .5);\n\n    elli(head, vec2(.17), -.5);\n    elli(earL, vec2(.11), -.5);\n    elli(earR, vec2(.11), -.5);\n    \n    elli(cheek, vec2(.16,.09), .5);\n    elli(mouth, vec2(.1,.13), -.5);\n    elli(lipU, vec2(.15,.08), .5);\n    elli(tongue, vec2(.065,.022), .5);\n    \n    elli(noseB, vec2(.07,.1), .5);\n    elli(noseT, vec2(.025,.045), -.5);\n    \n    elli(eyeRO, vec2(.09,.05), .5);\n    elli(eyeLO, vec2(.1,.08), .5);\n    elli(eyeRI, vec2(.04,.02), -.5);\n    elli(eyeLI, vec2(.05,.03), -.5);\n    \n    \n    // Draw\n    col += vec3(amp);\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    col += .1*hash21(floor(111.*uv)*animTime)*(1.+.2*cos(20.*uv.y+animTime)); //noise\n    col *= vec3(244,239,223)/255.; //sepia tint\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 153, 153, 230], [232, 232, 270, 270, 323], [324, 324, 367, 405, 453], [455, 455, 476, 522, 615], [617, 617, 652, 692, 777], [779, 779, 817, 869, 965], [967, 967, 1004, 1055, 1338], [1340, 1340, 1381, 1400, 1875], [1877, 1877, 1921, 1921, 2235], [2238, 2238, 2294, 2294, 8284]], "test": "untested"}
{"id": "Dl2Xz1", "name": "Gradient descent visualization", "author": "NinjaKoala", "description": "Trajectory of a gradient descent (red) towards a conic section (blue) compared to the \"lagrange curve\" (yellow) and a\n\"corrected\" gradient descent for finding the nearest point (aka the intersection of the conic and its lagrange curve) (green).", "tags": ["2d", "lagrange", "gradientdescent"], "likes": 3, "viewed": 196, "published": 3, "date": "1675693155", "time_retrieved": "2024-07-30T18:11:51.090335", "image_code": "/*\nSee https://www.shadertoy.com/view/mlB3RD and the linked shaders for some background.\nWhat i call \"lagrange curve\" is probably called totally different in literature,\nbut i didn't really bother to find out the real name yet ^^\n*/\n\n//#define CORRECTION_VARIANT\n\nconst float pi = 3.1415925;\n\nconst int num_segments1 = 32; //number of segments moving forward\nconst int num_segments2 = 128; //number of segments moving backward\nconst float step_size = .07; //segment size\n\nconst float zoom = 3.;\n\nconst float random_offset_factor=.2;\n\nconst float line_width = .004;\nconst float dot_size = .02;\n\nconst vec3 bg_col = vec3(1);\nconst vec3 raster_col = vec3(0);\nconst vec3 traj_col = vec3(0,1,0);\nconst vec3 corr_col = vec3(1,0,0);\nconst vec3 conic_col = vec3(0,0,1);\nconst vec3 lagrange_col = vec3(1,1,0);\nconst vec3 dot_col = vec3(0);\n\nconst float a_param = 5.;\nconst float b_param = -5.;\nconst float c_param = 0.;\nconst float d_param = 0.;\n\nfloat conic_curve(vec2 p, out vec2 grad){\n\tgrad = vec2(2.*p.x*a_param + c_param, 2.*p.y*b_param + d_param);\n\treturn p.x*(p.x*a_param + c_param) + p.y*(p.y*b_param + d_param) + 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n    grad = vec2(2.*(a_param*(p.y-p2.y)-p.y*b_param) - d_param,\n                2.*(b_param*(p2.x-p.x)+p.x*a_param) + c_param);\n    return 2.*(p.x*a_param*(p.y-p2.y)-p.y*b_param*(p.x-p2.x)) + c_param*(p.y-p2.y) - d_param*(p.x-p2.x);\n}\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat trajectory_segments_dis_sq(vec2 uv, vec2 p, bool corr){\n    float d0 = 1e38;\n    vec2 a = p;\n    for( int i=1; i<num_segments1; i++ )\n    {\n\t\tvec2 b = a;\n        vec2 nor;\n        float val = conic_curve(a, nor);\n        vec2 tang = vec2(nor.y,-nor.x);      \n        \n        if(!corr){\n            b += step_size*val*nor/dot(nor,nor);\n        }\n        else{\n            b += step_size*val*nor/dot(nor,nor);\n            vec2 nor2;\n            #ifdef CORRECTION_VARIANT\n            float val2 = conic_curve(b,nor2);\n            vec2 tang = vec2(nor2.y, -nor2.x);\n            b += step_size*dot(b-p,tang)/dot(tang,tang) * tang;\n            #else\n            float val2 = lagrange_curve(b, p, nor2);\n            b += step_size*val2*nor2/dot(nor2,nor2);\n            #endif\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n\n\ta = p;\n\n    for( int i=1; i<num_segments2; i++ )\n    {\n\t\tvec2 b = a;\n        vec2 nor;\n        float val = conic_curve(a, nor);\n        vec2 tang = vec2(nor.y,-nor.x);\n        if(!corr){\n            b -= step_size*val*nor/dot(nor,nor);\n        }\n        else{\n            b -= step_size*val*nor/dot(nor,nor);\n            vec2 nor2;\n            #ifdef CORRECTION_VARIANT\n            float val2 = conic_curve(b,nor2);\n            vec2 tang = vec2(nor2.y, -nor2.x);\n            b -= step_size*dot(b-p,tang)/dot(tang,tang) * tang;\n            #else\n            float val2 = lagrange_curve(b, p, nor2);\n            b -= step_size*val2*nor2/dot(nor2,nor2);\n            #endif\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n    \n    return d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n\tmouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 1./iResolution.y;\n\n\tfloat dis = 1e38;\n\n\tuv *= zoom;\n\tborder *= zoom;\n\tmouse *= zoom;\n    \n    vec3 col = bg_col;\n    \n    vec2 nor1;\n    float val1 = conic_curve(uv, nor1);\n    col = vec3(mix(clamp(pow(cos(abs(val1)*3.),10.),0.,1.),1.,.8));\n    dis = abs(val1) / length(nor1) - line_width;\n    col = mix(conic_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    vec2 nor2;\n    float val2 = lagrange_curve(uv, mouse, nor2);\n    dis = abs(val2) / length(nor2) - line_width;\n    col = mix(lagrange_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n\tdis = sqrt(trajectory_segments_dis_sq(uv,mouse,true))-line_width;\n    col = mix(traj_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = sqrt(trajectory_segments_dis_sq(uv,mouse,false))-line_width;\n    col = mix(corr_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = distance(uv,mouse)-dot_size;\n    col = mix(dot_col,col,clamp(sqrt(dis/border),0.,1.));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2Xz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[938, 938, 979, 979, 1119], [1121, 1121, 1174, 1174, 1408], [1410, 1410, 1435, 1435, 1454], [1456, 1456, 1503, 1503, 1614], [1616, 1616, 1677, 1677, 3243], [3245, 3245, 3302, 3302, 4442]], "test": "untested"}
{"id": "ct2SR1", "name": "Mriya Over Metropolis", "author": "dr2", "description": "Huge plane (Antonov 225, sadly deceased), lots of skyscrapers, truck traffic...", "tags": ["flight", "traffic", "skyscraper", "cybertruck", "antonov"], "likes": 29, "viewed": 353, "published": 3, "date": "1675684565", "time_retrieved": "2024-07-30T18:11:52.022842", "image_code": "// \"Mriya Over Metropolis\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Includes bits from \"Mighty Mriya\", \"Spherical Metropolis\" and more)\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flyerMat;\nvec4 csWm, csWt;\nvec3 flyerPos, flPos, qHit, sunDir, mistCol, dwf, dwr;\nvec2 cId, cIdT, bIdV, cTimeV;\nfloat dstFar, tCur, cCar, qcCar, cDir, flrHt, bShape, bWid, bWidU, bHt, bHtU,\n   tWid, twHt, nFloor, flSzFac, angWm, drpWm, angWt, drpWt;\nint idObj;\nbool wlDown;\nconst float pi = 3.1415927;\nconst int idBldgF = 1, idBldgC = 2, idTwr = 3, idTwrTop = 4, idRoad = 5, idSWalk = 6, idTrLight = 7,\n   idStLight = 8, idPool = 9, idTrnk = 10, idTree = 11, idCarBdy = 12, idCarWhl = 13, idFus = 21,\n   idCkp = 22, idEng = 23, idWngM = 24, idWngT = 25, idFin = 26, idWhl = 27, idLeg = 28, idFr = 29;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q;\n  vec2 ww;\n  float dMin, d, s, w, t, wg;\n  dMin = dstFar / flSzFac;\n  p = flyerMat * (p - flyerPos) / flSzFac;\n  q = p;\n  w = 1.;\n  s = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    s *= 0.026;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.05 * s;\n    s *= -0.02;\n  }\n  d = PrCapsDf (q - vec3 (0., s, 0.), w, 7.);\n  if (wlDown) d = max (d, - min (PrBoxDf (vec3 (abs (q.x) - 0.45, q.y + 1., q.z - 0.4),\n     vec3 (0.2, 0.25, 1.6)), PrBoxDf (vec3 (abs (q.x) - 0.2, q.y + 1., q.z - 4.8),\n     vec3 (0.1, 0.3, 0.2))));\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.65, 0.1, 6.);\n  d = PrCapsDf (q, 0.02, 0.3);\n  DMINQ (idFr);\n  q = p;\n  q.z -= -0.7;\n  q.xz = abs (q.xz);\n  q -= vec3 (0.2, 0.8, 4.);\n  d = PrCapsDf (q.xzy, 0.07, 0.2);\n  DMINQ (idFr);\n  q = p;\n  q.yz -= vec2 (0.4, 3.5);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  ww = vec2 (4., 1.4);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.7, 1.3);\n  q.xy = Rot2Cs (q.xy, csWm.xy);\n  q.xz = Rot2Cs (q.xz, csWm.zw);\n  t = ww.y * (1. - 0.3 * q.x / ww.x);\n  s = 1.1 * (q.z - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.15 * (t - s * s), t), abs (abs (p.x) - ww.x) - ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (p.x) - 6.9, q.z - 0.085 * q.x + 1.2),\n     vec2 (0.85, 0.2))), 0.03);\n  DMINQ (idWngM);\n  for (float k = 0.; k < 4.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.1) * dwr + vec3 (0., 0.65, 0.1);\n    d = PrCapsDf (q, 0.05, 0.25);\n    DMINQ (idFr);\n  }\n  for (float k = 0.; k < 3.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.3) * dwf + vec3 (0., 0.22, 2.8);\n    d = max (PrRoundCylDf (q.yzx - vec3 (0.25, -0.1, 0.), 0.25, 0.05, 0.), 0.3 - q.y);\n    DMINQ (idFr);\n    d = min (SmoothMax (abs (PrCapsDf (q, 0.3 * (1. - 0.5 * q.z * q.z), 0.9)) - 0.02,\n       abs (q.z + 0.1) - 0.55, 0.02), PrCylDf (q, 0.28, 0.25));\n    s = q.z + 0.2;\n    d = max (min (d, PrCapsDf (q + vec3 (0., 0., 0.2), 0.25 * (1. - 2. * s * s), 0.7)),\n       - PrCylDf (vec3 (q.xy, q.z + 0.8), 0.07, 0.2));\n    DMINQ (idEng);\n  }\n  ww = vec2 (1.3, 0.85);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.8, -5.8);\n  q.xy = Rot2Cs (q.xy, csWt.xy);\n  q.xz = Rot2Cs (q.xz, csWt.zw);\n  d = min (ww.x - abs (abs (p.x) - ww.x), abs (PrBox2Df (vec2 (abs (p.x) - 1.7,\n     q.z - 0.07 * q.x + 0.6), vec2 (0.7, 0.25))));\n  t = ww.y * (1. - 0.25 * q.x / ww.x);\n  s = (q.z - 0.1) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.03);\n  DMINQ (idWngT);\n  ww = vec2 (1.5, 0.65);\n  q = p;\n  q.x = abs (q.x);\n  q.xy = Rot2Cs (q.xy, sin (drpWt + vec2 (0.5 * pi, 0.)));\n  q -= vec3 (2.7, 0.8, -6.9);\n  t = ww.y * (1. - 0.25 * abs (q.y) / ww.x);\n  s = (q.z + 0.1 * abs (q.y) / ww.x - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.1 * abs (q.y) / ww.x), 0.1 * (t - s * s), t),\n     abs (q.y - 0.35 * ww.x) - 0.65 * ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (q.y - 0.8, q.z + 0.3), vec2 (0.5, 0.2))), 0.03);\n  DMINQ (idFin);\n  q.z -= -0.3;\n  d = PrCapsDf (q, 0.05, 0.2);\n  DMINQ (idFr);\n  if (wlDown) {\n    q = p;\n    q.yz -= vec2 (-1., 0.4);\n    t = 0.45;\n    s = abs (q.z) - 3.5 * t;\n    q.z = mod (q.z + 0.5 * t, t) - 0.5 * t;\n    q.x = abs (q.x) - 0.5;\n    d = max (PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.09), 0.16, 0.03, 0.02), s);\n    DMINQ (idWhl);\n    d = max (min (PrCylDf (q.yzx, 0.05, 0.09), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2)), s);\n    DMINQ (idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.2, -1.06, 4.8);\n    d = PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.07), 0.1, 0.03, 0.01);\n    DMINQ (idWhl);\n    d = min (PrCylDf (q.yzx, 0.05, 0.07), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2));\n    DMINQ (idLeg);\n  }\n  return 0.6 * flSzFac * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FlyerSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.005;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = FlyerDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvoid SetBldgParms ()\n{ //  (based on \"Urban Growth\")\n  float hiMid;\n  if (Hashfv2 (16. * cId) > 0.5 || mod (cId.x, 4.) + mod (cId.y, 4.) != 0.) {\n    bHt = (0.25 * Hashfv2 (13. * cId) + 0.05) * (1. + 0.15 / flrHt) + 0.1;\n    nFloor = floor (bHt * (0.6 + 0.4 * length (sin (0.125 * pi * cId))) / flrHt);\n    bHt = (nFloor + 0.3) * flrHt;\n    bWid = floor ((0.17 + Hashfv2 (11. * cId) * 0.1) / flrHt + 0.5) * flrHt;\n    bShape = Hashfv2 (17. * cId);\n    cIdT = mod (cId + 8., vec2 (16.)) - 8.;\n    hiMid = 0.75 * clamp (4. / max (length (cIdT), 1.), 0., 1.);\n    bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * cId)) / flrHt + 0.5) * flrHt;\n    bHt = (0.5 * Hashfv2 (13. * cId) + 0.05) * hiMid * (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n    bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * cId) - 0.5) * hiMid + 0.05;\n    bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n    bHtU = floor (bHtU / flrHt) * flrHt;\n    bHtU += 0.2 * flrHt * step (0., bHtU);\n    if (cIdT == vec2 (0.) && length (cId) > 40.) {\n      bHt = max (bHt, 30.2 * flrHt);\n      bHtU = max (bHtU, 10.2 * flrHt);\n    }\n    tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n  } else {\n    bHt = 0.;\n  }\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 pp, q;\n  vec2 s;\n  float d;\n  q = p;\n  d = q.y;\n  DMINQ (idRoad);\n  pp = p;\n  pp.xz = fract (pp.xz) - vec2 (0.5);\n  q = pp;\n  q.y -= 0.0015;\n  d = PrBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  DMINQ (idSWalk);\n  if (bHt > 0.) {\n    q.y -= bHt - 0.2 * flrHt + 0.0005;\n    if (bShape > 0.25) {\n      d = PrBoxDf (q, vec3 (bWid, bHt, bWid));\n      DMINQ (idBldgF);\n    } else {\n      d = PrCylDf (q.xzy, bWid, bHt);\n      DMINQ (idBldgC);\n    }\n    q.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n    if (bHtU > 0.) {\n      if (bShape > 0.5) {\n        d = max (PrBoxDf (q, vec3 (bWidU, bHtU, bWidU)),\n           - PrBoxDf (q - vec3 (0., bHtU, 0.), vec3 (tWid, 0.1 * flrHt, tWid)));\n        DMINQ (idBldgF);\n      } else {\n        d = max (PrCylDf (q.xzy, bWidU, bHtU),\n           - PrCylDf ((q - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n        DMINQ (idBldgC);\n      }\n    }\n    q.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (q.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      DMINQ (idBldgC);\n    } else if (bShape > 0.7) {\n      d = PrBoxDf (q, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      DMINQ (idBldgF);\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      q.y -= twHt;\n      d = PrCapsDf (q.xzy, 0.3 * flrHt, twHt);\n      DMINQ (((q.y > 0.9 * twHt) ? idTwrTop : idTwr));\n    }\n    if (cIdT == vec2 (0.)) {\n      q = pp;\n      q.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (q.xzy, 0.3, flrHt);\n      DMINQ (idBldgC);\n    }\n  } else {\n    d = PrCylDf (q.xzy, 0.19, 0.005);\n    DMINQ (idPool);\n    q.xz = abs (q.xz) - 0.21;\n    q.y -= 0.7 * flrHt;\n    d = PrCylDf (q.xzy, 0.005, 0.7 * flrHt);\n    DMINQ (idTrnk);\n    q.y -= 0.6 * flrHt;\n    d = PrSphDf (q, 0.4 * flrHt);\n    DMINQ (idTree);\n  }\n  q = pp;\n  q.y -= 0.025;\n  q.xz = mod (q.xz + 0.05, 0.1) - 0.05;\n  s = abs (pp.xz) - vec2 (0.5);\n  d = max (min (PrCylDf (q.xzy, 0.0012, 0.025), PrCylDf ((q - vec3 (0., 0.025, 0.)).xzy, 0.005, 0.0007)),\n     - min (PrBox2Df (pp.xz, vec2 (0.45)), max (PrBox2Df (s, vec2 (0.18)), - PrBox2Df (s, vec2 (0.05)))));\n  DMINQ (idStLight);\n  q = pp;\n  q.y -= 0.023;\n  q.xz = abs (q.xz) - vec2 (0.345);\n  d = PrCylDf (q.xzy, 0.002, 0.02);\n  DMINQ (idTrLight);\n  return dMin;\n}\n\nvec3 CarPos (vec3 p)\n{ // (noncolliding traffic flow from \"Gotham City\")\n  vec3 q, s;\n  float vDir, fqx;\n  s.xz = abs (fract (p.xz) - 0.5) - 0.35;\n  vDir = (cDir == 0. && s.z > 0. || cDir == 1. && s.x < 0.) ? 0. : 1.;\n  if (vDir == 0.) p.xz = vec2 (- p.z, p.x);\n  q = p;\n  fqx = floor (q.x);\n  q.x -= fqx + 0.5;\n  q.z += 3. * fqx;\n  q.z *= sign (q.x);\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * (step (0.6, Hashff (11. * cCar)) + 0.5 * Hashff (13. * cCar));\n  return q;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{  // (simplified version from \"Truck Driving\")\n  vec3 q, qq, b;\n  float d, h, bf, szFac;\n  szFac = 0.06;\n  q = CarPos (p);\n  bf = PrBox2Df (q.xz + vec2 (0., -0.1), vec2 (0.015, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  dMin /= szFac;\n  q /= szFac;\n  q.y -= 0.15;\n  b = vec3 (0.13, 0.09, 0.3);\n  qq = q;\n  b.x -= 0.2 * abs (qq.y + 0.02 * qq.z + 0.01);\n  h = ((qq.z > 0.05) ? 0.21 : 0.13) * abs (qq.z - 0.05);\n  qq.y -= - h;\n  b.yz -= vec2 (h, 0.1 * abs (qq.y - 0.03));\n  d = max (PrBoxDf (qq, b), - PrBoxDf (q - vec3 (0., 0.01, -0.2), vec3 (0.115, 0.05, 0.09)));\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (0.11, 0.2);\n  h = 0.15 * abs (qq.z);\n  qq.y += 0.08 + h;\n  d = max (d, - PrBoxDf (qq, vec3 (0.015, 0.04, 0.06) - vec3 (0., h, 0.06 * qq.y)));\n  d = max (d, bf);\n  if (d < dMin) qcCar = cCar;\n  DMINQ (idCarBdy);\n  qq = q;\n  qq.y -= -0.088;\n  d = PrBoxDf (qq, vec3 (0.13, 0.003, 0.14));\n  d = max (d, bf);\n  if (d < dMin) qcCar = cCar;\n  DMINQ (idCarBdy);\n  qq = vec3 (abs (q.xz) - vec2 (0.118, 0.2), q.y + 0.095).xzy;\n  d = PrRoundCylDf (qq.yzx, 0.048, 0.007, 0.02);\n  d = max (d, bf);\n  DMINQ (idCarWhl);\n  return 0.7 * szFac * dMin;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  float z, r, s;\n  col4 = vec4 (HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.5,\n     0.4 + 0.6 * vec3 (Hashff (qcCar * 47.)))), 0.5);\n  if (idObj == idCarBdy) {\n    z = abs (qHit.z - 0.05);\n    if (qHit.y > 0.015 && abs (z - 0.078) < 0.072 && (abs (qHit.x) < 0.12 - 0.2 * qHit.y ||\n       qHit.y < 0.085 - 2. * ((qHit.z > 0.05) ? 0.21 : 0.13) * z)) col4 = vec4 (0., 0., 0., -2.);\n    else if (qHit.z < - 0.298 && abs (qHit.y + 0.01) < 0.005 && abs (qHit.x) < 0.125)\n       col4 = vec4 (1., 0., 0., -1.);\n    else if (qHit.z > 0.298 && abs (qHit.y + 0.02) < 0.005 && abs (qHit.x) < 0.125)\n       col4 = vec4 (1., 1., 0.8, -1.);\n    else if (qHit.y < - 0.075 || abs (qHit.y) < 0.085 && z < 0.0008 || \n       abs (qHit.y + 0.009) < 0.031 && abs (qHit.z - 0.201) < 0.0008 ||\n       abs (qHit.y + 0.015) < 0.061 && abs (qHit.z + 0.101) < 0.0008) col4.rgb *= 0.6;\n    else if (qHit.z > 0.28 && abs (qHit.y + 0.05) < 0.015 && abs (qHit.x) < 0.08)\n       col4.rgb *= 1. - 0.3 * step (0.2, cos (80. * pi * qHit.x));\n    else if (qHit.y > -0.05 && abs (qHit.x) < 0.11 && abs (qHit.z + 0.2) < 0.085)\n       col4.rgb *= 0.9 + 0.1 * cos (160. * pi * qHit.x);\n  } else if (idObj == idCarWhl) {\n    s = sign (qHit.z);\n    qHit = vec3 (abs (qHit.xz) - vec2 (0.118, 0.2), qHit.y + 0.095).xzy;\n    r = length (qHit.yz);\n    if (r < 0.02) {\n      qHit.yz = Rot2D (qHit.yz, - pi * tCur * s);\n      if (abs (abs (qHit.y) - abs (qHit.z)) < 0.01) col4 = vec4 (0.9, 0.9, 1., 0.3);\n    } else if (r > 0.03) col4 = vec4 (0.3, 0.3, 0.3, 0.);\n  }\n  return col4;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, rdi;\n  float dHit, d;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = 0.01;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    d = ObjDf (p);\n    dHit += min (d, 0.001 + max (0., Minv2 ((cId + step (0., rd.xz) - p.xz) * rdi.xy)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p, qHitT;\n  vec2 cIdP;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  qHitT = qHit;\n  sh = 1.;\n  cIdP = vec2 (-999.);\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    h = BldgDf (p, dstFar);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 BldgCol (vec3 vn)\n{\n  vec4 col4;\n  vec2 g;\n  float wFac, f;\n  wFac = 1.;\n  col4 = vec4 (HsvToRgb (vec3 (0.7 * Hashfv2 (19. * cId), 0.2,\n     0.4 + 0.2 * Hashfv2 (21. * cId))), 0.3);\n  if (abs (vn.y) < 0.05) {\n    f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n    wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n       0.801 * step (abs (f), 0.22);\n    if (wFac < 0.2) {\n      f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n         length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n      wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n         (1. + Hashfv2 (51. * cId))), 1.);\n    }\n    col4.rgb *= wFac;\n  } else if (vn.y > 0.95) {\n    g = step (0.05, fract (qHit.xz * 70.));\n    col4.rgb *= mix (0.8, 1., g.x * g.y);\n  }\n  if (vn.y < 0.95 && wFac > 0.5)\n     col4.rgb *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  if (wFac < 0.5) col4.a = -2.;\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  vec2 g, b;\n  float f, ff, y, fDayLt;\n  col4 = vec4 (0.);\n  fDayLt = 1.;\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col4 = BldgCol (vn);\n  } else if (idObj == idTwr) {\n    col4 = vec4 (0.3);\n  } else if (idObj == idTwrTop) {\n    col4 = vec4 (1., 0., 0., -2.);\n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col4.rgb = mix (vec3 (0.1, 0.1, 0.12), vec3 (0.1), step (g.x, 0.355));\n    f = ((step (abs (g.x - 0.495), 0.002) + step (abs (g.x - 0.365), 0.002)) +\n       step (abs (g.x - 0.44), 0.0015) * step (fract (g.y * 18. + 0.25), 0.7)) *\n       step (g.y, 0.29);\n    col4.rgb = mix (col4.rgb, vec3 (0.6, 0.5, 0.1), f);\n    f = step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) * step (abs (g.y - 0.32), 0.02);\n    col4 = mix (col4, vec4 (0.7, 0.7, 0.7, 0.2), f);\n    g = abs (g) - 0.493;\n    f = step (0., Minv2 (g));\n    col4 = mix (col4, vec4 (0.7, 0.7, 0.7, 0.2), f);\n    if (fDayLt > 0.5) {\n      b = CarPos (ro).xz;\n      g = abs (b + vec2 (0., -0.1)) - vec2 (0.015, 0.2);\n      if (Maxv2 (g) < 0.) col4 *= 0.6 + 0.4 * smoothstep (0.001, 0.003,\n         length (max (abs (vec2 (b.x, mod (b.y, 0.05) - 0.025)) - 0.06 * vec2 (0.13, 0.3), 0.)));\n    } else {\n      g = abs (fract (qHit.xz) - 0.5);\n      f = 1.3 * (1. - smoothstep (0.05, 0.2, length (g - 0.5)));\n      if (g.x < g.y) g = g.yx;\n      f += step (g.y, 0.35) * (1. - smoothstep (0.02, 0.05,\n         length ((vec2 (0.8 * abs (g.x - 0.437) - 0.015, mod (g.y + 0.05, 0.1) - 0.05)))));\n      col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.7), 0.2 * f);\n    }\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col4.rgb = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n    if (bHt > 0.) {\n      f = ((bShape > 0.25) ? max (abs (qHit.x), abs (qHit.z)) : length (qHit.xz)) - bWid;\n      if (f < 0.02) col4.rgb *= 2.;\n      else if (f < 0.025) col4 = vec4 (vec3 (1., 1., 0.7) * max (0.5 - 0.5 * rd.y, 0.), -1.);\n    } else {\n      if (length (abs (qHit.xz) - 0.21) < 0.01) col4.rgb *= 0.7;\n    }\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) / pi + 1.) + 0.5;\n    ff = floor (f);\n    y = qHit.y - 0.014;\n    if (abs (y) < 0.004 && abs (f - ff) > 0.3) {\n      col4 = vec4 (mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.), step (0., y)), -1.);\n      col4.rgb *= 1. - 0.8 * step (0., y * sign (cDir - 0.5) * sign (mod (ff, 2.) - 0.5));\n    } else {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.5);\n    }\n  } else if (idObj == idStLight) {\n    if (qHit.y > 0.024 && vn.y < 0.1) {\n      col4 = vec4 (vec3 (0.8, 0.8, 0.4) * (0.7 - 0.3 * vn.y), -1.);\n    } else {\n      col4 = vec4 (vec3 (0.5, 0.5, 0.55) * (1. + 0.3 * sin (128. * 2. * pi * qHit.y)), 0.5);\n    }\n  } else if (idObj == idPool) {\n    col4 = (length (qHit.xz) < 0.18) ? vec4 (0.4, 0.4, 0.5, -2.) :\n       vec4 (0.2, 0.3, 0.5, 0.1) * (0.6 + 0.4 * fDayLt);\n  } else if (idObj == idTrnk) {\n    col4 = vec4 (0.4, 0.2, 0., 0.1);\n  } else if (idObj == idTree) {\n    col4 = vec4 (0., 0.5, 0.1, 0.1);\n  } else if (idObj == idCarBdy || idObj == idCarWhl) {\n    col4 = CarCol ();\n    if (idObj == idCarBdy && fDayLt < 0.5 && col4.a > 0.) {\n      g = abs (fract (ro.xz) - 0.5);\n      f = 1.3 * (1. - smoothstep (0.05, 0.2, length (g - 0.5)));\n      if (g.x < g.y) g = g.yx;\n      f += step (g.y, 0.35) * (1. - smoothstep (0.02, 0.05, length ((vec2 (0.8 *\n         abs (g.x - 0.437) - 0.015, mod (g.y + 0.05, 0.1) - 0.05)))));\n      col4.rgb = mix (col4.rgb, vec3 (0.7, 0.7, 0.5), 0.4 * f);\n    }\n  }\n  return col4;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, colY4, colB4;\n  vec2 s;\n  float t;\n  col4 = vec4 (1., 1., 0.95, 0.2);\n  colY4 = vec4 (0.8, 0.8, 0., 0.2);\n  colB4 = vec4 (0.2, 0.2, 1., 0.2);\n  if (idObj == idFus) {\n    col4 = mix (colB4, col4, smoothstep (0.07, 0.08, abs (qHit.y + 0.6)));\n    col4 = mix (colY4, col4, smoothstep (0.07, 0.08, abs (qHit.y + 0.35)));\n    if (PrCylDf (qHit - vec3 (0., 0., 0.4), 0.98, 1.7) < 0. ||\n       abs (qHit.x) < 0.4 && qHit.y < 0. && PrCylDf (qHit - vec3 (0., 0., 4.7), 0.93, 0.3) < 0.)\n       col4 *= vec4 (vec3 (0.2), 0.);\n    if (! wlDown && qHit.y < 0.) col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.012, \n       min (abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.45) - 0.1, qHit.z - 0.4), vec2 (0.1, 1.6))),\n       abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.2) - 0.05, qHit.z - 4.8), vec2 (0.05, 0.2)))));\n    col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.01, abs (PrRoundBox2Df (qHit.yz - vec2 (-0.4, 3.5),\n       vec2 (0.3, 0.15), 0.05)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.4 && abs (qHit.y - 0.45) < 0.07 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.35) - 0.2) > 0.03) col4 = vec4 (0., 0., 0., -1.);\n  } else if (idObj == idEng) {\n    t = length (qHit.xy);\n    if (PrCapsDf (qHit, 0.3 * (1. - 0.5 * qHit.z * qHit.z), 0.85) < 0.) {\n      if (qHit.z > 0. && t < 0.14) col4 = vec4 (1., 0., 0., 0.2);\n      else col4 *= vec4 (vec3 (0.3), 0.);\n    } else {\n      if (abs (qHit.z + 0.1) > 0.5) col4 = colY4;\n      else col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (qHit.z - 0.3)));\n    }\n  } else if (idObj == idWngM) {\n    t = qHit.z + 0.1 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.04, 0.05, abs (t - 1.2)));\n    col4 = mix (colY4, col4, smoothstep (0.04, 0.05, abs (t - 1.)));\n    if (qHit.y < 0.) {\n      if (abs (abs (qHit.x) - 3.9) < 2.1) col4 *= 0.7 + 0.3 *\n         smoothstep (0.008, 0.012, abs (qHit.z - 0.1 * abs (qHit.x) + 1.));\n    } else {\n      s = Rot2D (qHit.xz - vec2 (3.5, -0.3), -0.1 * pi);\n      s.x = abs (abs (s.x) - 0.8) - 0.3;\n      col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.012, abs (PrBox2Df (s, vec2 (0.3, 0.15))));\n    }\n  } else if (idObj == idWngT) {\n    t = qHit.z + 0.15 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (t - 0.7)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.03, abs (t - 0.6)));\n  } else if (idObj == idFin) {\n    t = qHit.z + 0.15 * abs (qHit.y);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (t - 0.4)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.03, abs (t - 0.3)));\n  } else if (idObj == idWhl) {\n    col4 = mix (vec4 (0.7, 0.7, 0.75, 0.1), vec4 (0.3, 0.3, 0.3, 0.),\n       step (0.07, length (qHit.yz)));\n  } else if (idObj == idLeg) {\n     col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n  }\n  return col4;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skCol, clCol;\n  vec2 p;\n  float fd, d, f, ff;\n  rd = normalize (rd);\n  col = mistCol;\n  if (rd.y >= 0.) {\n    p = 0.01 * (ro.xz + rd.xz * (200. - ro.y) / max (rd.y, 0.0001) + 4. * tCur);\n    ff = Fbm2 (p);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (p + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (mistCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvoid FlyerParms ()\n{\n  angWm = 0.1 * pi;\n  drpWm = 0.02 * pi;\n  csWm = vec4 (sin (drpWm + vec2 (0.5 * pi, 0.)), sin (angWm + vec2 (0.5 * pi, 0.)));\n  angWt = 0.12 * pi;\n  drpWt = -0.03 * pi;\n  csWt = vec4 (sin (drpWt + vec2 (0.5 * pi, 0.)), sin (angWt + vec2 (0.5 * pi, 0.)));\n  dwr = vec3 (1.4, 0., 0.);\n  dwr.xy = Rot2Cs (dwr.xy, sin (- drpWm + vec2 (0.5 * pi, 0.)));\n  dwr.xz = Rot2Cs (dwr.xz, sin (-0.7 * angWm + vec2 (0.5 * pi, 0.)));\n  dwf = vec3 (1.5, 0., 0.);\n  dwf.xy = Rot2Cs (dwf.xy, sin (-0.9 * drpWm + vec2 (0.5 * pi, 0.)));\n  dwf.xz = Rot2Cs (dwf.xz, sin (-1.3 * angWm + vec2 (0.5 * pi, 0.)));\n  wlDown = (mod (0.05 * tCur, 2.) > 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rdr, roo, qHitF;\n  vec2 g, vf;\n  float dstObj, dstFlyer, nDotL, sh, s, f;\n  int idObjF;\n  FlyerParms ();\n  flrHt = 0.07;\n  vf = vec2 (0.);\n  mistCol = 0.3 + 0.8 * vec3 (0.4, 0.5, 0.8);\n  dstFlyer = FlyerRay (ro, rd);\n  idObjF = idObj;\n  qHitF = qHit;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < min (dstFlyer, dstFar)) {\n    ro += dstObj * rd;\n    cId = floor (ro.xz);\n    SetBldgParms ();\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      if (idObj == idRoad) vf = vec2 (512., 1.);\n      else if (idObj == idBldgF || idObj == idBldgC) vf = vec2 (512., 0.5);\n      else if (idObj == idTrnk) vf = vec2 (256., 0.5);\n      else if (idObj == idTree) vf = vec2 (128., 2.);\n      else if (idObj == idSWalk && bHt == 0.) {\n        s = length (qHit.xz) - 0.2;\n        vn = normalize (vec3 ((1. - smoothstep (0., 0.02,\n           abs (s))) * sign (s) * normalize (qHit.xz), 2.)).xzy;\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col * (0.3 + 0.3 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.2 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         step (0.95, sh) * col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    }\n    if (col4.a == -2.) {\n      rdr = reflect (rd, vn);\n      g = Rot2D (rdr.xz, 5.1 * atan (20. + cId.y, 20. + cId.x));\n      f = step (1., 0.3 * ro.y + 4. * rdr.y -\n         0.1 * floor (5. * IFbm1 (0.6 * atan (g.y, g.x) + pi) + 0.05));\n      if (idObj == idBldgF || idObj == idBldgC) {\n        if (f == 1.) col = mix (0.3 * col, BgCol (ro, rdr), 0.5);\n        else col *= 0.3;\n      } else if (idObj == idPool) {\n        if (f == 1.) col = 0.9 * BgCol (ro, rdr);\n        else col *= 0.3;\n      } else if (idObj == idCarBdy) {\n        if (f == 1.) col = mix (0.3 * col, BgCol (ro, rdr), 0.5);\n        else col *= 0.3;\n      }\n    }\n    if (col4.a == -2.) col *= 1. - 0.95 * smoothstep (0.4, 0.7, dstObj / dstFar);\n    col = mix (mistCol, col, exp2 (min (0., 7. * (1. - 2. * dstObj / dstFar))));\n  } else if (dstFlyer < dstFar) {\n    idObj = idObjF;\n    qHit = qHitF;\n    ro += dstFlyer * rd;\n    vn = FlyerNf (ro);\n    col4 = FlyerCol ();\n    sh = FlyerSShadow (ro + 0.01 * vn, sunDir);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (col4.a > 0.) nDotL *= nDotL;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.1 * max (- vn.y, 0.) +\n         0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (dot (sunDir,\n         reflect (rd, vn)), 0.), 32.);\n    } else col = BgCol (ro, reflect (rd, vn));\n  } else col = (rd.y < 0.) ? mistCol : BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPos (float t)\n{\n  vec3 r;\n  vec2 cs;\n  t *= 0.05 / (2. * pi);\n  t = mod (t, 1.);\n  cs = sin (2. * pi * t + vec2 (0.5 * pi, 0.));\n  r.xz = vec2 (1., cs.y);\n  r.xz = 40. * cs.x * r.xz / dot (r.xz, r.xz);\n  r.y = 5. + 0.4 * sin (2. * pi * t);\n  return r;\n}\n\nvoid FlyerPM (float t, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  dt = 1.;\n  flPos = TrkPos (t);\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  va = cross (acc, vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 2. * length (va) * sign (va.y);\n  oRl = smoothstep (0.01, 0.03, abs (oRl)) * oRl;\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vuPos, vd;\n  vec2 canvas, uv, uvv;\n  float zmFac, el, az, asp, sr, cTime, flyVel, tPos;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  flSzFac = 0.07;\n  flyVel = 1.2;\n  tPos = flyVel * tCur;\n  FlyerPM (tPos, flyerPos, flyerMat);\n  vuPos = TrkPos (tPos - 2.);\n  vuPos.y += 1. + 2. * sin (0.2 * tCur);\n  vuPos.xz = Rot2D (vuPos.xz - flyerPos.xz, 0.05 * tCur) + flyerPos.xz;\n  zmFac = 6.;\n  vd = normalize (flyerPos - vuPos);\n  az = 0.5 * pi + atan (- vd.z, vd.x);\n  el = asin (vd.y);\n  if (mPtr.z > 0.) {\n    az += 0.3 * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (1., 2., -1.));\n  cTime = 0.15 * tCur;\n  cDir = mod (floor (cTime), 2.);\n  cTimeV = vec2 (floor (0.5 * floor (cTime)), fract (cTime));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    uvv /= vec2 (asp, 1.) * zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (vuPos, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2SR1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1739, 1739, 1763, 1763, 5528], [5530, 5530, 5565, 5565, 5751], [5753, 5753, 5776, 5776, 6030], [6032, 6032, 6071, 6071, 6303], [6305, 6305, 6327, 6357, 7465], [7467, 7467, 7502, 7502, 9741], [9743, 9743, 9765, 9815, 10322], [10324, 10324, 10358, 10404, 11495], [11497, 11497, 11513, 11513, 13057], [13059, 13059, 13081, 13081, 13182], [13184, 13184, 13217, 13217, 13752], [13754, 13754, 13775, 13775, 14032], [14034, 14034, 14071, 14071, 14566], [14568, 14568, 14592, 14592, 15513], [15515, 15515, 15556, 15556, 19086], [19088, 19088, 19106, 19106, 21859], [21861, 21861, 21892, 21892, 22435], [22437, 22437, 22457, 22457, 23087], [23089, 23089, 23124, 23124, 25891], [25893, 25893, 25916, 25916, 26154], [26156, 26156, 26212, 26212, 26767], [26769, 26769, 26825, 26825, 28325], [28327, 28327, 28359, 28359, 28459], [28461, 28461, 28494, 28494, 28583], [28585, 28585, 28632, 28632, 28679], [28681, 28681, 28714, 28714, 28741], [28743, 28743, 28785, 28785, 28836], [28838, 28838, 28895, 28895, 28971], [28973, 28973, 29016, 29016, 29080], [29082, 29082, 29126, 29126, 29186], [29188, 29188, 29210, 29210, 29237], [29239, 29239, 29261, 29261, 29288], [29290, 29290, 29335, 29335, 29427], [29429, 29429, 29474, 29474, 29512], [29514, 29514, 29571, 29571, 29654], [29656, 29656, 29692, 29692, 29898], [29900, 29900, 29930, 29930, 30043], [30045, 30045, 30076, 30076, 30140], [30142, 30142, 30166, 30166, 30283], [30317, 30317, 30341, 30341, 30378], [30380, 30380, 30404, 30404, 30464], [30466, 30466, 30490, 30490, 30543], [30545, 30545, 30569, 30569, 30681], [30683, 30683, 30707, 30707, 30850], [30852, 30852, 30877, 30877, 31023], [31025, 31025, 31050, 31050, 31236], [31238, 31238, 31261, 31261, 31425], [31427, 31427, 31448, 31448, 31603], [31605, 31605, 31634, 31634, 31846], [31848, 31848, 31887, 31887, 32139]], "test": "untested"}
{"id": "dtSSz1", "name": "spqr: street map extruded", "author": "spqr", "description": "a", "tags": ["a"], "likes": 7, "viewed": 227, "published": 3, "date": "1675674396", "time_retrieved": "2024-07-30T18:11:52.853620", "image_code": "\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return max(max(q.x,q.y),q.z);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat a = 3.141592;\n\n\nfloat tick(float t,float n){\n    float i = floor(t);\n    float r = pow(fract(t),n);\n    return i+r;\n}\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\nvec3 moda ( vec3 p, float rep ) {\n    vec2 rp = vec2(atan(p.z,p.x)/(2.*PI), length(p.xz));\n    rp.x =(fract(rp.x*rep-0.5)-0.5)/rep;\n    rp.x *= 2. *PI;\n    return vec3(cos(rp.x)*rp.y, p.y, sin(rp.x)*rp.y);\n}\n\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<7;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.53;//\n        q*=2.1;\n    }\n    return res;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\n\n\nfloat pi = 3.141592;\nfloat surge (float t) {\n\n   float i = floor(t);\n   float r = fract(t);\n   r = smoothstep(0.,1.,r);\n   r = pow(r, 3.);\n   \n   return i + r;\n   \n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\n\n\n\nfloat pulse ( float x, float t ){\n    x *= .1;\n    \n    float f1 = 11.;\n    t = -t;\n    float u = atan(f1 * sin((sin(x) + t * 2.))/atan(f1)) * .5 + .5;\n \n    return u;\n\n}\n\n\nint matter;\n\n\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd *= 1.7;\n  off.x += sin(dd)*13.;\n  off.x += cos(dd*2.1)*6.1;\n  off.y += sin(dd*0.7)*26.;\n  off.y += cos(dd*1.5)*11.;\n  \n  \n  return off;\n}\nfloat glow = 0.;\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <6.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv*.8);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\n\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 2.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.); // kilroy\n           \n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.0));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) {\n\n    float a = hash31(vec3(p.x, p.y,cos(32.) * 77.191));\n    float b = hash31(vec3(p.y, p.x,cos(21.) * 45.432));\n    return fract(a+b);\n    //float a = fract( sin(p.x*5612.431) * 937.442 + sin(p.y*2489.289) * 818.632);\n    //float b = fract(sin(a * 2093.441) * 9433.313);\n    //return b;\n}\nvec2 kifs(vec2 p) {\n    for ( float i=0.; i < 3.;i++) {\n        p *= rot((i + iTime * .3) * pi/2.);\n        p = abs(p) - 60.;\n        p *= 1.2;\n    }\n    return p;\n}\n// ink\nconst float domain_width = 197.;\nconst float domain_height = 21.;\nconst vec3 domain = vec3(domain_width,domain_height,domain_width);\nfloat decal(vec3 p, vec3 domain) {\n\n  \n  vec3 id = floor(p/(domain));\n  // motion\n float f1 = fract(hash31(id) + iTime/23.1 + hash31(id));\n //float f1 = fract(hash31(id) + hash31(id));\n\n  p = mod(p,domain) - domain/2.;\n  \n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(400.));\n  float final = max(one,two);\n  return final;\n}\n\nfloat map (vec3 p){\n\n    // geo\n    \n    vec3 q = p;\n    float u = decal(q,domain)*.1;\n  \n    \n    p.y = mod(p.y,20.) - 10.;\n    float f = box(p, vec3(100.,9.,100.));\n    \n   \n    return max(u,-f) ;\n   \n  \n\n}\n\nvec3 getnorm(vec3 p, vec2 off) {\n  \n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  \n\n\n vec3 s = vec3(0,-100,.1);\n vec3 arm = vec3(1);\n \n float tt = iTime;\n arm.xy *= rot(sin(tt*.2));\n arm.xz *= rot(sin(tt*.53));\n arm.yz *= rot(sin(tt*.44));\n \n \n \n vec3 t = s + arm;\n \n \n vec3 adv = vec3(0,21,0) * iTime;\n \n s += adv;\n t += adv;\n \n vec3 slat = lattice(iTime*.3)*10.;\n vec3 tlat = lattice(iTime*.3+111.)*10.;\n slat*=9.;\n tlat*=2.;\n s += slat;\n t += tlat;\n \n\n\n\n\n \n \n\n  \n\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  \n  vec3 cy=normalize(cross(cz,cx));\n  \n\n  \n  // fisheye\n  cz -= dot(uv,uv)/10.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n  \n  // march\n  \n  \n  float dd;\n  vec3 p = s;\n  float i;\n  float d;\n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.01) {\n      hit = true;\n    \n      break;\n    }\n    if ( dd > 1000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  \n\n    \n\n\n  \n\n\n  vec3 n = getnorm(p, vec2(.01, .0));\n  vec3 light = normalize(vec3(1)); \n \n  float diff = max(0.,dot(n,light));\n  vec3 col = vec3(0);\n  col +=  pow( dd/333., 1.4);\n \n  \n\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 179], [183, 183, 212, 212, 260], [261, 261, 290, 290, 347], [350, 350, 397, 397, 443], [467, 467, 495, 495, 568], [569, 569, 596, 596, 664], [666, 666, 694, 694, 718], [720, 720, 762, 762, 869], [871, 871, 899, 899, 925], [927, 927, 955, 955, 988], [991, 991, 1038, 1038, 1084], [1087, 1087, 1120, 1120, 1294], [1298, 1298, 1355, 1355, 1450], [1451, 1451, 1477, 1477, 1951], [1953, 1953, 1974, 1974, 2174], [2176, 2176, 2215, 2215, 2292], [2294, 2294, 2330, 2330, 2408], [2409, 2409, 2432, 2432, 2510], [2535, 2535, 2558, 2558, 2681], [2685, 2685, 2706, 2706, 2755], [2757, 2757, 2782, 2782, 3251], [3263, 3263, 3296, 3296, 3433], [3451, 3451, 3471, 3471, 3513], [3515, 3515, 3546, 3546, 3648], [3650, 3650, 3671, 3671, 3857], [3877, 3877, 3896, 3896, 3975], [3978, 3978, 3997, 3997, 4559], [4562, 4562, 4581, 4581, 4980], [4986, 4986, 5014, 5014, 5667], [5668, 5668, 5695, 5695, 6315], [6355, 6355, 6378, 6378, 6493], [6495, 6495, 6517, 6517, 6807], [6808, 6808, 6827, 6827, 6973], [7114, 7114, 7148, 7148, 7447], [7449, 7449, 7468, 7480, 7657], [7659, 7659, 7691, 7691, 7786], [7788, 7788, 7845, 7845, 9065]], "test": "untested"}
{"id": "7scfD4", "name": "spqr: street map", "author": "spqr", "description": "a", "tags": ["a"], "likes": 1, "viewed": 168, "published": 3, "date": "1675665128", "time_retrieved": "2024-07-30T18:11:53.640516", "image_code": "\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return max(max(q.x,q.y),q.z);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat a = 3.141592;\n\n\nfloat tick(float t,float n){\n    float i = floor(t);\n    float r = pow(fract(t),n);\n    return i+r;\n}\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\nvec3 moda ( vec3 p, float rep ) {\n    vec2 rp = vec2(atan(p.z,p.x)/(2.*PI), length(p.xz));\n    rp.x =(fract(rp.x*rep-0.5)-0.5)/rep;\n    rp.x *= 2. *PI;\n    return vec3(cos(rp.x)*rp.y, p.y, sin(rp.x)*rp.y);\n}\n\n\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<7;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.53;//\n        q*=2.1;\n    }\n    return res;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\n\n\nfloat pi = 3.141592;\nfloat surge (float t) {\n\n   float i = floor(t);\n   float r = fract(t);\n   r = smoothstep(0.,1.,r);\n   r = pow(r, 3.);\n   \n   return i + r;\n   \n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\n\n\n\nfloat pulse ( float x, float t ){\n    x *= .1;\n    \n    float f1 = 11.;\n    t = -t;\n    float u = atan(f1 * sin((sin(x) + t * 2.))/atan(f1)) * .5 + .5;\n \n    return u;\n\n}\n\n\nint matter;\n\n\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd *= 1.7;\n  off.x += sin(dd)*13.;\n  off.x += cos(dd*2.1)*6.1;\n  off.y += sin(dd*0.7)*26.;\n  off.y += cos(dd*1.5)*11.;\n  \n  \n  return off;\n}\nfloat glow = 0.;\nfloat map (vec3 p){\n\n    \n    float ground = -p.y;\n  \n    return ground ;\n   \n  \n\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <6.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv*.8);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\n\nfloat m2(vec2 uv) {\n \n  vec2 uv2 = uv;\n  float q = 1.4;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n   \n    uv.x *= q;\n    \n   \n    \n    uv *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off);\n    z = min(z,a1);\n  \n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 2.1);\n  float u = length(uv2  + arm) -2.;\n  \n  glow += .01/(.02 + u);\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.); // kilroy\n           \n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.0));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) {\n\n    float a = hash31(vec3(p.x, p.y,cos(32.) * 77.191));\n    float b = hash31(vec3(p.y, p.x,cos(21.) * 45.432));\n    return fract(a+b);\n    //float a = fract( sin(p.x*5612.431) * 937.442 + sin(p.y*2489.289) * 818.632);\n    //float b = fract(sin(a * 2093.441) * 9433.313);\n    //return b;\n}\nvec2 kifs(vec2 p) {\n    for ( float i=0.; i < 3.;i++) {\n        p *= rot((i + iTime * .3) * pi/2.);\n        p = abs(p) - 60.;\n        p *= 1.2;\n    }\n    return p;\n}\n// ink\nconst float domain_width = 197.;\nconst float domain_height = 41.;\nconst vec3 domain = vec3(domain_width,domain_height,domain_width);\nfloat decal(vec3 p, vec3 domain) {\n\n  \n  vec3 id = floor(p/(domain));\n  float f1 = fract(hash31(id) + iTime/23.1 + hash31(id));\n\n  p = mod(p,domain) - domain/2.;\n  \n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(400.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n \n\n  // nav\n  \n\n\n vec3 source = vec3(0,-350,1);\n vec3 target = vec3(0);\n\n float time = iTime;\n float advance = time * 14. ;\n source.z += advance;\n target.z += advance;\n\n\n \n \n\n  \n\n  \n  vec3 cz=normalize(target-source);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  \n  vec3 cy=normalize(cross(cz,cx));\n  \n\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n  // fisheye\n  //r.z+=.1*length(uv);\n \n  \n  // march\n  \n  \n  float dd;\n  vec3 p = source;\n  float i;\n  float d;\n  bool hit = false;\n  for(float z=0.; z <500.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n    \n      break;\n    }\n    if ( dd > 700.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  \n\n    \n  vec3 alt_domain = domain ;\n  //alt_domain.x -= 253.1;\n\n  float decal_val = decal(p,alt_domain);\n  vec3 col;\n  if ( decal_val < 0.) {\n     col = vec3(.8,.4,.3)*1.4;\n  }\n  \n\n\n\n\n\n  vec3 n = norm(p);\n  vec3 light =normalize(vec3(0,-1,0));\n\n  \n\n \n  float fren = pow(1. + dot(n,r),4.);\n  float spec =pow(max(dot(reflect(-light,n),-r),1.),2.);\n  vec3 fog = vec3(1);\n   \n  //col += spec * .15;\n  col += fren * 1.65;\n\n \n\n \n    \n  if (! hit) {\n      col = mix(vec3(.6), vec3(.4), pow(abs(r.y),.3));\n  }\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 179], [183, 183, 212, 212, 260], [261, 261, 290, 290, 347], [350, 350, 397, 397, 443], [467, 467, 495, 495, 568], [569, 569, 596, 596, 664], [666, 666, 694, 694, 718], [720, 720, 762, 762, 869], [871, 871, 899, 899, 925], [927, 927, 955, 955, 988], [991, 991, 1038, 1038, 1084], [1087, 1087, 1120, 1120, 1294], [1298, 1298, 1355, 1355, 1450], [1451, 1451, 1477, 1477, 1951], [1953, 1953, 1974, 1974, 2174], [2176, 2176, 2215, 2215, 2292], [2294, 2294, 2330, 2330, 2408], [2409, 2409, 2432, 2432, 2510], [2535, 2535, 2558, 2558, 2681], [2685, 2685, 2706, 2706, 2755], [2757, 2757, 2782, 2782, 3251], [3263, 3263, 3296, 3296, 3433], [3451, 3451, 3471, 3471, 3513], [3515, 3515, 3546, 3546, 3648], [3650, 3650, 3671, 3671, 3857], [3875, 3875, 3894, 3894, 3958], [3959, 3959, 3978, 3978, 4097], [4100, 4100, 4119, 4119, 4198], [4201, 4201, 4220, 4220, 4782], [4785, 4785, 4804, 4804, 5203], [5209, 5209, 5237, 5237, 5890], [5891, 5891, 5918, 5918, 6538], [6578, 6578, 6601, 6601, 6716], [6718, 6718, 6740, 6740, 7030], [7031, 7031, 7050, 7050, 7196], [7337, 7337, 7371, 7371, 7613], [7617, 7617, 7674, 7674, 9008]], "test": "untested"}
{"id": "dtSXRh", "name": "Rippling lava (Molten metal)", "author": "jarble", "description": "An infinite scrolling pattern that looks like a sea of lava or molten metal.\n", "tags": ["lava"], "likes": 37, "viewed": 565, "published": 3, "date": "1675653685", "time_retrieved": "2024-07-30T18:11:54.501215", "image_code": "mat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// based on the follow tweet:\n// https://twitter.com/zozuar/status/1621229990267310081\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 n = vec2(0);\n    vec2 q = vec2(0);\n    vec2 p = uv;\n    p.x += iTime/16.;\n    float S = 12.;\n    float a = 0.0;\n    mat2 m = rotate2D(5.);\n\n    for (float j = 0.; j < 20.; j++) {\n        p *= rotate2D(5.);\n        n *= m;\n        q = p * S + t + j + n; // wtf???\n        a += sin(q.x)/S;\n        n -= cos(q);\n        S *= 1.2;\n    }\n\n    col = vec3(4, 2, 1) * (a + .2) + a + a;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 76], [78, 165, 222, 272, 835]], "test": "untested"}
{"id": "DlSSz1", "name": "ultra lazy moon rendering", "author": "ArmandB", "description": "yup", "tags": ["2d"], "likes": 4, "viewed": 157, "published": 3, "date": "1675643266", "time_retrieved": "2024-07-30T18:11:55.309055", "image_code": "float smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi2d(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = smin(n,distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv),8.0);\n        }\n    }\n    return n;\n}\n\nvec4 renderMoon(vec2 uv, float spin, float stage){\n    float l = uv.x*uv.x + uv.y*uv.y;\n    if (l < 1.0){\n        uv /= sqrt(1.0 - l) + 1.0;\n        vec2 p = vec2(uv.x - spin, uv.y);\n        float v = abs(voronoi2d(p*3.0) - 0.3) + abs(voronoi2d(p*7.0)*0.4 - 0.1) +  abs(voronoi2d(p*15.0)*0.1 - 0.05);\n        vec3 lightColor = vec3(1);\n        vec3 darkColor = vec3(0,0.05,0.1);\n        vec3 shadowColor = vec3(0,0.025,0.05);\n        vec4 col = vec4(mix(darkColor,lightColor,1.0 - v),smoothstep(1.0,0.97,l));\n        float k = (2.0*asin(mod(stage,2.0) - 1.0)/3.14159)*sqrt((1.0 - uv.y*uv.y));\n        float s = sign(mod(stage,4.0) - 2.0);\n        if (s*uv.x < s*k){\n            col.rgb = mix(col.rgb,shadowColor,smoothstep(0.0,0.1,s*(k - uv.x))*0.75);\n        }\n        return col;\n    }\n    return vec4(0,0,0,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y - 0.5)*5.0;\n    vec4 moon = renderMoon(uv,iTime,iTime);\n    vec3 col = mix(vec3(0),moon.rgb,moon.a);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 119], [121, 140, 161, 161, 294], [296, 296, 321, 321, 542], [544, 544, 594, 594, 1359], [1361, 1361, 1418, 1418, 1592]], "test": "untested"}
{"id": "cl2Xzz", "name": "voronoi second closest dist", "author": "jonasfrey", "description": "this is my attempt to re-create my voronoi i drew by hand\n", "tags": ["voronoi"], "likes": 3, "viewed": 154, "published": 3, "date": "1675639021", "time_retrieved": "2024-07-30T18:11:56.061045", "image_code": "// var a_n = [1,2,3,4,5,6,7,8,9]\n// var n_dist_min1 = 10.;\n// var n_dist_min2 = 10.;\n// for(var n of a_n){\n//     if(n < n_dist_min1){\n        \n//         n_dist_min1 = n;\n//     }\n//     if(n > n_dist_min1 && n < n_dist_min2){\n\n//         n_dist_min2 = n;\n//     }\n    \n// }\n// console.log(\"n_dist_min1\")\n// console.log(n_dist_min1)\n// console.log(\"n_dist_min2\")\n// console.log(n_dist_min2)\n// for(var n of a_n){\n//     if(n < n_dist_min1){\n//         n_dist_min2 = n_dist_min1;\n//         n_dist_min1 = n;\n//     }\n//     if(n > n_dist_min1 && n < n_dist_min2){\n\n//         n_dist_min2 = n;\n//     }\n    \n// }\n// console.log(\"n_dist_min1\")\n// console.log(n_dist_min1)\n// console.log(\"n_dist_min2\")\n// console.log(n_dist_min2)\n\n\n\nfloat f_n_dist_line_by_iq(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n#define n_tau 6.2831\nfloat f_n_rnd(vec2 o)\n{\n\treturn fract(sin(dot(o.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat f_n_dist_euclidean(vec2 o_p1, vec2 o_p2){\n    vec2 o_delta = o_p1-o_p2;\n    \n    return sqrt(\n        pow(o_delta.x,2.)\n        + pow(o_delta.y,2.)\n    );\n}\nfloat f_n_dist_manhatten(vec2 o_p1, vec2 o_p2){\n    return abs(o_p1.x-o_p2.x) + abs(o_p1.y-o_p2.y);\n}\nvec2 f_o_rnd_from_o_fc_floor(vec2 o_fc_floor){\n\n    float n_rnd = f_n_rnd(o_fc_floor);\n    float n_rnd2 = f_n_rnd(o_fc_floor*20.);\n    vec2 o_prnd = (vec2(n_rnd, n_rnd2)-.5)*sin(iTime);\n    return o_prnd;\n}\n\nvec4 f_o_voronoi(vec2 o_fc_nor){\n\n    vec2 o_fc_nor_floor = floor(o_fc_nor);\n    vec2 o_fc_nor_fract = fract(o_fc_nor);\n    float n_t = iTime*0.5;\n    vec2 o_scl_krnl = vec2(3.);\n    vec2 o_scl_krnl_half_floor = floor(o_scl_krnl/2.);\n    float n_dist_min = 1.;\n    float n_dist_min2 = 1.;\n    vec2 o_fc_nor_min = vec2(0.);\n    vec2 o_trn_knrl_min = vec2(0.);\n    for(float n_x = -o_scl_krnl_half_floor.x; n_x <= o_scl_krnl_half_floor.x; n_x+=1.){\n        for(float n_y = -o_scl_krnl_half_floor.y; n_y <= o_scl_krnl_half_floor.y; n_y+=1.){\n            \n            // this is a unique absolute x y coordinate, (23, 13) or (243, 88)...\n            vec2 o_fc_nor_krnl_floor = vec2(n_x, n_y) + o_fc_nor_floor;\n            // this is the relative coordinate with floating points\n            // (0.13, 0.33), (1.23, -1.32) ... \n  \n            vec2 o_rnd = f_o_rnd_from_o_fc_floor(o_fc_nor_krnl_floor);\n            \n            vec2 o_fc_nor_krnl_plus_fract = vec2(n_x, n_y) - o_fc_nor_fract + o_rnd;\n            \n            float n_dist = length(o_fc_nor_krnl_plus_fract);\n            \n            if(n_dist < n_dist_min){\n                o_trn_knrl_min = vec2(n_x, n_y);\n                o_fc_nor_min = vec2(n_x, n_y) + o_rnd;\n                n_dist_min2 = n_dist_min;\n                n_dist_min = n_dist;\n            }\n            if(\n                n_dist > n_dist_min\n                && \n                n_dist < n_dist_min2\n            ){\n                n_dist_min2 = n_dist;\n            }\n        }\n    }\n    \n    return vec4(n_dist_min, n_dist_min2, o_fc_nor_min);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    vec2 o_mc_nor = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 o_fc_nor_nooff = fragCoord.xy/iResolution.xy;\n    \n    vec2 o_fc_nor_zoomed = o_fc_nor*10.;\n    vec4 o_voronoi = f_o_voronoi(o_fc_nor_zoomed);\n    \n    \n    float n_idx = float(o_fc_nor.x > 0.);\n    fragColor = vec4(o_voronoi[int(n_idx)]);\n    if(o_fc_nor.y > 0.){\n        float n_min1_minus_min2 =  o_voronoi.x - o_voronoi.y;\n        fragColor = vec4(abs(sin(n_min1_minus_min2*n_tau*2.)));//sin(sqrt(n_min1_minus_min2)*n_tau*10.));\n    }\n    float n_radius = (1./0.09);\n    float n_outline = (2.);\n    float n_dist_o_fc_nor_zoomed_point = length((fract(o_fc_nor_zoomed-.5)-.5));\n    n_dist_o_fc_nor_zoomed_point = smoothstep(1., 0.5, n_dist_o_fc_nor_zoomed_point*n_radius);\n    float n_dist_o_fc_nor_zoomed_point2 = smoothstep(1., 0.5, n_dist_o_fc_nor_zoomed_point*(n_radius+n_outline));\n    fragColor *= vec4(1.)*(1.-n_dist_o_fc_nor_zoomed_point);\n    fragColor *= vec4(n_dist_o_fc_nor_zoomed_point2);\n    fragColor += vec4(0., 1.,0., 1.)*n_dist_o_fc_nor_zoomed_point;\n    \n    float n_dist_o_min = length(o_voronoi.x);\n    n_dist_o_min = smoothstep(1., 0.5, n_dist_o_min*n_radius);\n    float n_dist_o_min2 = smoothstep(1., 0.5, n_dist_o_min*(n_radius+n_outline));\n    fragColor *= vec4(1.)*(1.-n_dist_o_min);\n    fragColor *= vec4(n_dist_o_min2);\n    fragColor += vec4(1., 1.,0., 1.)*n_dist_o_min;\n    \n    vec2 o = fract(o_fc_nor_zoomed)-vec2(0.5);\n    float n_d_grid = max(abs(o.x), abs(o.y));\n    n_d_grid = .5-n_d_grid;\n    \n    float n_th = 0.01;\n    float n_aa = 1./iResolution.x;\n    n_d_grid = smoothstep(n_th, n_th+n_aa, n_d_grid);\n    fragColor *= vec4(n_d_grid);\n    \n\n\n    vec2 o_rnd = o_voronoi.zw;\n    //vec2 o_p_in_quadrat = (vec2(1.)/5.)*floor(fract(o_fc_nor_zoomed)*5.);\n    //o_p_in_quadrat = vec2(0.);\n    //    float n_dist_line = f_n_dist_line_by_iq(\n    //        fract(o_fc_nor_zoomed),\n    //        o_p_in_quadrat,\n    //        o_rnd\n    //    );\n    //n_dist_line = smoothstep(n_th, n_th+n_aa, n_dist_line);\n    \n    // i think i still have to loop ... \n    n_th = 0.005;\n    float n_its = 5.;\n    float n_dist_line = 0.;\n    for(float n_x = 0.; n_x <= 1.; n_x+= 1./n_its){\n        for(float n_y = 0. ; n_y <= 1.; n_y+= 1./n_its){\n            \n            float n = f_n_dist_line_by_iq(\n                fract(o_fc_nor_zoomed),\n                vec2(n_x, n_y),//o_p_in_quadrat,\n                o_rnd\n            );\n            n_dist_line += smoothstep(n_th+n_aa, n_th, n);\n        }\n    }\n    \n    \n    if(o_fc_nor.x >= .0 && o_fc_nor.y > 0.){\n        fragColor = vec4(1.-n_dist_line);\n        fragColor *= pow(o_voronoi.x,1./2.);\n    \n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2Xzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 791, 791, 911], [934, 934, 957, 957, 1025], [1027, 1027, 1074, 1074, 1189], [1190, 1190, 1237, 1237, 1291], [1292, 1292, 1338, 1338, 1498], [1500, 1500, 1532, 1532, 3070], [3071, 3071, 3128, 3178, 5904]], "test": "untested"}
{"id": "DtBXRz", "name": "Edgy Hallway", "author": "frettini", "description": "My first shader which uses a buffer to do some post processing. Applying some sobel and gaussian effects to a warped repeated geometry.", "tags": ["raymarching", "postprocessing", "edge", "repeatinggeometry"], "likes": 2, "viewed": 173, "published": 3, "date": "1675630347", "time_retrieved": "2024-07-30T18:11:57.057381", "image_code": "#define AA 2\n\n// Post Processing Kernels ----------------------------------------\nmat3 sobelY = mat3(-1.,0.,1.,\n                   -2.,0.,2.,\n                   -1.,0.,1.);\n                  \nmat3 sobelX = mat3(-1.,-2.,-1.,\n                    0.,0.,0.,\n                    1.,2.,1.);\n\nmat3 gaussian = 0.0625 * mat3(1.,2.,1.,\n                              2.,4.,2.,\n                              1.,2.,1.);\n                             \n// Post Processing Functions --------------------------------------                      \nfloat SobelFilter(vec2 fragCoord)\n{\n    float sumX = 0.;\n    float sumY = 0.;\n    float sumNormX = 0.;\n    float sumNormY = 0.;\n \n\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    {\n        vec2 uvOffset = (fragCoord + vec2(i , j))/iResolution.xy;\n        sumX += sobelX[i+1][j+1] * texture(iChannel0, uvOffset).r;\n        sumY += sobelY[i+1][j+1] * texture(iChannel0, uvOffset).r;\n        sumNormX += dot( sobelX[i+1][j+1] * texture(iChannel0, uvOffset).gba, vec3(1.,1.,1.) );\n        sumNormY += dot( sobelY[i+1][j+1] * texture(iChannel0, uvOffset).gba, vec3(1.,1.,1.) );\n    }\n    \n    float filteredValue = step(1.-sqrt(sumX*sumX + sumY*sumY),0.3);\n    filteredValue = step(1.-sqrt(sumNormX*sumNormX + sumNormY*sumNormY),0.3);\n    return filteredValue;\n}\n\nfloat GaussianFilter(vec2 fragCoord)\n{\n    float sumGaussian = 0.;\n    \n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    {\n        vec2 uvOffset = (fragCoord + vec2(i , j))/iResolution.xy;\n        sumGaussian += gaussian[i+1][j+1] * texture(iChannel0, uvOffset).r, vec3(1.,1.,1.);\n    }\n    \n    return sumGaussian;\n}\n// ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 result = vec3(0.);\n    \n#if AA>1\n    for(int hOffset = 0; hOffset < AA; hOffset++)\n    for(int vOffset = 0; vOffset < AA; vOffset++)\n    {\n\n        vec2 pixelOffset = vec2(float(hOffset), float(vOffset)) / float(AA) - 0.5;\n        // Normalized pixel coordinates (from -1.0 to 1.0)\n        vec2 uv = ((fragCoord + pixelOffset)*2.0 - iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n#endif\n      \n        vec3 chromaOffset = vec3(-2.5 + cos(uv.y*1.+iTime*3.)*2. + sin(uv.y+iTime*5.)*0.8, \n                            cos(uv.y+iTime*3.)*1. + sin(uv.y+iTime*5.)*0.8, \n                            2.5 + sin(uv.y*4.+iTime*1.)*1.5 - cos(uv.x*1.+iTime*4.)*1.) ;\n\n        vec3 col = vec3(0.);\n        \n        // Apply post processing filters\n        col.x = GaussianFilter( fragCoord * vec2(1.01,1.) + vec2(chromaOffset.x, 0.) );\n        col.y = SobelFilter( fragCoord + vec2(chromaOffset.y, 0.) );\n        col.z = GaussianFilter( fragCoord * vec2(1.01,1.) + vec2(chromaOffset.z, 0.) );\n\n        float gaussFactor = abs(col.x-col.z);\n        float sobelFactor = col.y; \n        col = vec3(6. * gaussFactor * vec3(0.6, 0.8, 1.) + 0.04 * sobelFactor * vec3(1., 1.,1.));\n        \n        result += col;\n#if AA>1\n    }\n    result /= float(AA*AA);\n#endif\n        \n    // Output to screen\n    fragColor = vec4(result,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RAYMARCHSTEPS 100\n\n#define MATERIAL1 1\n#define MATERIAL2 2\n\n#define MINDIST 0.5\n#define MAXDIST 30.0\n\n#define AA 2\n\nstruct Hit\n{\n    float rayDist;\n    int matID;\n};\n\nmat3 LookAt(vec3 pos, vec3 target)\n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward,vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, forward));\n        \n    return mat3(right,\n                up,\n                forward);\n}\n\n// OPERATIONs ----------------------------------------------------\nHit Union(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist < hit2.rayDist){ return hit1; }\n    else{ return hit2; }\n}\n\nHit Substract(Hit hit1, Hit hit2)\n{\n    if(-hit1.rayDist > hit2.rayDist){ return  Hit( -hit1.rayDist, hit1.matID ); }\n    else{ return hit2; };\n}\n\nHit Intersect(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist > hit2.rayDist){ return  hit1; }\n    else{ return hit2; };\n}\n\n\nHit SmoothUnion( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp( 0.5 + 0.5*(hit2.rayDist-hit1.rayDist)/k, 0.0, 1.0 );\n    result.rayDist = mix( hit2.rayDist, hit1.rayDist, h ) - k*h*(1.0-h); \n    result.matID = hit1.matID; // TODO : this s a simplification for now\n    return result;\n}\n\nHit SmoothIntersect( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp(0.5-0.5*(hit2.rayDist - hit1.rayDist)/k, 0.0, 1.0);\n    result.rayDist = mix(hit2.rayDist, hit1.rayDist, h) + k*h*(1.0-h);\n    result.matID = hit1.matID; // TODO : this is a simplification for now\n    return result;\n}\n\n// ---------------------------------------------------------------\n\n// SDFs ----------------------------------------------------------\n\nfloat SDPlane(vec3 pos, vec3 planeNormal, float planeHeight)\n{\n    // planeNormal must be normalized\n    return dot(pos, planeNormal) + planeHeight;\n}\n\nfloat SDSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat SDRoundedCube(vec3 pos, vec3 cubeOrigin, vec3 cubeExtent, float cubeRadius)\n{\n    vec3 q = abs(pos - cubeOrigin)  - cubeExtent;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - cubeRadius;\n}\n\nfloat SDRoundedPillar(vec3 pos, vec3 cubeOrigin, vec3 cubeExtent, float cubeRadius)\n{\n    vec3 q = abs(pos - cubeOrigin)  - cubeExtent;\n    return length(max(vec2(q.xz),0.0)) + min(max(q.x,q.z),0.0) - cubeRadius;\n}\n\nfloat SDSemiRingXY(vec3 pos, vec3 ringOrigin, float ringRadius, float ringThickness)\n{\n    vec3 localPos = pos - ringOrigin;\n    float dist =  abs(length( pos.xy - ringOrigin.xy ) - ringRadius) - ringThickness;\n    return max(-localPos.y,max(abs(localPos.z)-0.1, dist));\n}\n\nfloat SDSemiRingYZ(vec3 pos, vec3 ringOrigin, float ringRadius, float ringThickness)\n{\n    vec3 localPos = pos - ringOrigin;\n    float dist =  abs(length( pos.yz - ringOrigin.yz ) - ringRadius) - ringThickness;\n    return max(-localPos.y,max(abs(localPos.x)-0.1, dist));\n}\n\n// ---------------------------------------------------------------\n\n// from the position, return the distance and material of the closest object\nHit GetDistance(vec3 pos)\n{\n    // add vertical deformation\n    pos += sin(min(pos.y*1.5,10.) + iTime*0.4 )*0.1 * pos.y + cos(pos.x*pos.y)*0.1;\n     \n    // Geometry Definition \n    vec3 cubeOrigin = vec3(0., 0., 0.);\n    vec3 cubeExtent = vec3( 0.12, 0.1, 0.12);\n    float cubeRadius = 0.01;\n    \n    vec3 ringOriginXY =  vec3(0.5,0.75,0.);\n    vec3 ringOriginYZ =  vec3(0.,-0.25,0.5);\n    float ringRadius = 0.4;\n    float ringThickness = 0.075;\n    \n    vec3 planeNormal = vec3(0., 1., 0.);\n    float planeHeight = 0.;\n    \n    \n    // Repeat Coordinates\n    vec3 repeat1 = vec3(1., 0.0, 1.);\n    vec3 repeatCoord1 = mod(pos+0.5*repeat1,repeat1)-0.5*repeat1;\n    \n    vec3 repeat2 = vec3(2., 2.5, 2.);\n    vec3 repeatCoord2 = mod(pos+0.5*repeat2,repeat2)-0.5*repeat2;\n    \n    // SDF calculation starts here\n    Hit rayHit = Hit(MAXDIST,-1);\n    rayHit = Union( Hit(SDRoundedCube(repeatCoord1, cubeOrigin, vec3(0.15,0.05,0.15), cubeRadius), MATERIAL2), rayHit);\n    rayHit = SmoothUnion( Hit(SDRoundedPillar(repeatCoord1, cubeOrigin, cubeExtent, cubeRadius), MATERIAL2), rayHit,0.05);\n    \n    rayHit = Union( Hit(SDSemiRingXY(repeatCoord2, ringOriginXY, ringRadius, ringThickness), MATERIAL2), rayHit);\n    rayHit = Union( Hit(SDSemiRingXY(repeatCoord2, ringOriginXY*vec3(-1.,1.,1.), ringRadius, ringThickness), MATERIAL2), rayHit);\n    \n    rayHit = Union( Hit(SDSemiRingYZ(repeatCoord2, ringOriginYZ , ringRadius, ringThickness), MATERIAL2), rayHit);\n    rayHit = Union( Hit(SDSemiRingYZ(repeatCoord2, ringOriginYZ*vec3(1.,1.,-1.), ringRadius, ringThickness), MATERIAL2), rayHit);\n    \n    \n    rayHit = Union( Hit(SDPlane(pos, planeNormal, planeHeight), MATERIAL1), rayHit);\n    \n    return rayHit;\n}\n\n// using the specified ray, step through the ray and check against the SDF until the distance is small\n// enough to say that we have hit something.\nvoid Raymarch(vec3 rayOrigin, vec3 rayDirection, out Hit resultHit)\n{\n    float tmin = MINDIST;\n    float tmax = MAXDIST;\n    \n    float t = tmin;\n    for(int i = 0; i < RAYMARCHSTEPS && t < tmax; i++)\n    {\n        vec3 testPos = rayOrigin + rayDirection * t;\n        \n        Hit rayHit = GetDistance(testPos);\n        \n        // if distance is smaller than a given threshold, consider that a Hit\n        if(abs(rayHit.rayDist) < 0.001*t )\n        {\n            // return the distance along the ray and the material ID of what we Hit\n            resultHit = Hit(t, rayHit.matID);\n            break;\n        }\n        \n        t += rayHit.rayDist;\n    }\n}\n\n// from : https://iquilezles.org/articles/normalsSDF/\n// tetrahedon method to get the normal of a SDF\nvec3 GetNormal(vec3 pos)\n{\n    // trick the compiler to avoid inlining the Map function\n    #define ZERO (min(0, iFrame))\n    \n    float eps = 0.0001;\n    \n    vec3 normal = vec3(0.);\n    \n    for(int i = ZERO; i < 4 ; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += e*GetDistance(pos+e*eps).rayDist;\n    }\n    \n    return normalize(normal);\n}\n\n\n// Once we know what we hit, we can start material calculations\nvec4 GetColour(vec3 rayOrigin, vec3 rayDirection, Hit rayHit)\n{\n    vec3 backgroundCol = vec3(0.15);\n    vec3 col = backgroundCol;\n    vec3 normal = vec3(0.);\n    \n    if(rayHit.matID > 0)\n    {\n        vec3 pos = rayOrigin + rayDirection * rayHit.rayDist;\n        \n        // PLANE\n        if(rayHit.matID == 1)\n        {\n            ivec2 gridCoord = ivec2(floor(mod(pos.xz, 2.)));\n            col =  gridCoord.x == gridCoord.y ? vec3(0.2) : vec3(0.6);\n            normal = vec3(0.,1.,0.);\n            \n        }\n        // MATERIAL2\n        else if(rayHit.matID == 2)\n        {\n            normal = GetNormal(pos);\n            vec3 reflect = reflect(rayDirection, normal);\n            \n            \n            col = vec3((normal + 1.0)/2.0);\n            \n            // some kind of lighting\n            vec3 dirLightCol = vec3( 0.99,0.95,0.1);\n            vec3 dirLightDir = normalize(vec3(-0.5, -1.0,0.));\n            float dirLightIntensity = 4.0;\n            col *= dot(normal, -dirLightDir) * dirLightCol;   \n        }\n        \n#if 0\n        float absorptionCoef = 0.08;\n        float transmittance = exp( - absorptionCoef * rayHit.rayDist);\n        col = (1.0 - transmittance) * backgroundCol + transmittance * col;\n#else  \n        // smooth out things in the background ( could use beer lambert law but makes everything a bit darker)\n        float normDist = rayHit.rayDist / MAXDIST;\n        float smoothDist = smoothstep(0.2,1.0, normDist);\n        col = mix(col, backgroundCol, smoothDist);\n#endif\n    }\n    \n    float luminance = dot(col,vec3(0.2126, 0.7152, 0.0722));\n    \n    // IMPORTANT : we are not returning a color, encoding grayscale and Normal instead\n    return vec4(luminance, normal);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modTime = -mod( iTime*0.2,50.);\n    float focalDistance = 1.5;\n    vec3 rayOrigin = vec3(0.5,0.2,2.0 + modTime);\n    vec3 rayTarget = vec3(0.5 + cos(iTime*0.2)*0.9 + cos(iTime*0.09), \n                          sin(0.7*iTime)*0.1 + 0.5, \n                          0.7+modTime + cos(iTime*0.1 + 3.)*1.);\n    \n    mat3 lookAt = LookAt(rayOrigin, rayTarget);  \n    \n    vec4 result = vec4(0.);\n    \n#if AA>1\n    for(int hOffset = 0; hOffset < AA; hOffset++)\n    for(int vOffset = 0; vOffset < AA; vOffset++)\n    {\n\n        vec2 pixelOffset = vec2(float(hOffset), float(vOffset)) / float(AA) - 0.5;\n        // Normalized pixel coordinates (from -1.0 to 1.0)\n        vec2 uv = ((fragCoord + pixelOffset)*2.0 - iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n#endif\n      \n        // Get the ray direction by building the ray in camera space and transforming it using the lookAt matrix\n        vec3 cameraRayDir =  normalize( vec3(uv, focalDistance) );\n        vec3 rayDirection = normalize(lookAt * cameraRayDir);\n\n        Hit rayHit = Hit(MAXDIST, -1);\n        Raymarch( rayOrigin, rayDirection, rayHit);\n        vec4 data = GetColour(rayOrigin, rayDirection, rayHit);\n        \n        result += data;\n#if AA>1\n    }\n    result.x /= float(AA*AA);\n    result.gba = normalize(result.gba);\n#endif\n    \n    \n    // Output to screen\n    fragColor = result;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 527, 562, 562, 1306], [1308, 1308, 1346, 1346, 1646]], "test": "untested"}
{"id": "DtBSRh", "name": "Colorful star travelling", "author": "mrange", "description": "CC0: Colorful star travelling\nnspired by Xor's colorful tweet:\nhttps://twitter.com/XorDev/status/1621603585996775430?s=20&t=omyxMpuu2nELIw6_AEi72A\n", "tags": ["colors", "stars"], "likes": 64, "viewed": 1039, "published": 3, "date": "1675626055", "time_retrieved": "2024-07-30T18:11:57.815435", "image_code": "// CC0: Colorful star travelling\n//  Inspired by Xor's colorful tweet:\n//  https://twitter.com/XorDev/status/1621603585996775430?s=20&t=omyxMpuu2nELIw6_AEi72A\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPM         (145.0*0.5)\n\nconst float planeDist = 1.0-0.82;\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash3(vec3 r)  {\n  return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 soff(float h0) {\n  float h1 = fract(h0*8677.0);\n  return -1.0+2.0*vec2(h0, h1);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -mix(0.0, 0.1, smoothstep(40.0, 50.0, TIME))*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.55, 0.9, 0.035));\n  vec2 pp = rd.xy;\n  return gcol/dot(pp, pp);\n}\n\nvec3 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float l = distance(ro, pp);\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n\n  p *= 1.0+l*l;\n  \n  const float csz = 0.15;\n  const float co  = 0.33*csz;\n\n  vec3 col = vec3(0.0);\n  \n  const float cnt = 5.0;\n  const float icnt = 1.0/cnt;\n  for (float i = 0.0; i < 1.0; i += icnt) {\n    vec2 cp = p;\n    vec2 cn = mod2(cp, vec2(csz));\n    \n    float h0 = hash3(vec3(cn, n)+123.4+i);\n    float h1 = fract(3677.0*h0);\n    \n    cp += soff(h0)*co;\n    \n    float cl = length(cp);\n    float d = (cl-0.0005);    \n    d = max(d, 0.0001);\n  \n    vec3 bcol = 0.000005*(1.0+sin(vec3(0.0, 1.0, 2.0)+ TAU*h1));\n    bcol *= smoothstep(0.17*csz, 0.05*csz, cl)*0.15/(d*d*(l*l+0.01));\n    \n    col += bcol;\n    p += icnt;\n    p *= ROT(1.0);\n  }\n  \n\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 3.0;\n  \n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 9;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 col = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol *= fadeOut*fadeIn;\n\n      col += pcol; \n    }\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= .1*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col *= smoothstep(1.0, 15.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 32225, "src": "https://soundcloud.com/digicult/digicult-star-travel?si=fa25051755e3415fbcdeb113d9e686d8&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 580, 580, 726], [1021, 1121, 1140, 1140, 1227], [1228, 1335, 1361, 1361, 1545], [1547, 1607, 1629, 1629, 1715], [1717, 1803, 1839, 1839, 1933], [1935, 1935, 1956, 1956, 2021], [2023, 2023, 2045, 2045, 2217], [2219, 2219, 2242, 2242, 2320], [2322, 2322, 2346, 2346, 2426], [2428, 2428, 2461, 2461, 2562], [2564, 2564, 2632, 2632, 3386], [3388, 3388, 3444, 3444, 4493], [4495, 4495, 4525, 4525, 5001], [5003, 5003, 5060, 5060, 5236]], "test": "untested"}
{"id": "mljXRz", "name": "3D Star Field", "author": "michael0884", "description": "Procedural field of stars. WASD QE and mouse to move. Press R to stop movement.", "tags": ["camera"], "likes": 29, "viewed": 748, "published": 3, "date": "1675624148", "time_retrieved": "2024-07-30T18:11:58.770800", "image_code": "#define exposure 1.2\n#define sqrexposure 0.6\n#define gamma 1.3\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*c-sqrexposure*c*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 32.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = get(CamP).w;\n    if(pressed(keyR)) mode = 1.0 - mode;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        mode = 1.0;\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(0.0,1,0.)), -1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv + 5.0*iTimeDelta*vec3(1,0,0)*mode;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nfloat CAM_ANGLE = 0.003;\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_b_code": "#define SLICES 50.0\n\nfloat minimum_distance(vec3 v, vec3 w, vec3 p) \n{\n  vec3 dx = w - v;\n  float l2 = dot(dx, dx);  \n  if (l2 == 0.0) return distance(p, v);   \n  float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n  vec3 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvec3 blackBody(float T)\n{\n    vec3 O = vec3(0.0);\n    for (float i=0.; i<3.; i++) \n    { \n        float f = 1.+.5*i; \n        O[int(i)] += 10. * (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat region(vec3 pos)\n{\n    return texture(iChannel1, pos/200.0).x;\n}\n\nvec3 sampleVoxel(vec3 ro, vec3 rd, vec3 pos)\n{\n    float r = region(pos);\n    if(r < 0.5) return vec3(0.0);\n    float temp = hash13(pos);\n    vec3 heat = pow(blackBody(temp*temp*temp*20000.), vec3(1.0));\n    vec3 spos = hash33(pos) + pos;\n    float mdist = minimum_distance(ro, ro + rd*100.0, spos);\n    float camdist = distance(ro, spos);\n    float mindist = 0.25*CAM_ANGLE*camdist;\n    float dec = smoothstep(0.9*SLICES, SLICES*0.8, camdist);\n    return 5e-4*heat*1.0/(mdist*mdist + mindist*mindist) * smoothstep(0.75, 0.0, mdist) * dec / (camdist);\n}\n\nvec3 SliceTrace(vec3 ro, vec3 rd)\n{\n    vec3 sliceDir = vec3(0.0);\n    vec3 sliceX = vec3(0.0);\n    vec3 sliceY = vec3(0.0);\n    \n    vec3 rda = abs(rd);\n    if(rda.x > max(rda.y,rda.z)) {sliceDir.x = 1.0; sliceX = vec3(0,1,0); sliceY = vec3(0,0,1);} else \n    if(rda.y > max(rda.x,rda.z)) {sliceDir.y = 1.0; sliceX = vec3(1,0,0); sliceY = vec3(0,0,1);} else\n    if(rda.z > max(rda.y,rda.x)) {sliceDir.z = 1.0; sliceX = vec3(0,1,0); sliceY = vec3(1,0,0);}\n\n    float dt = 1.0/(abs(dot(rd,sliceDir)) + 1e-5);\n    vec3 col = vec3(0.0);\n    float rad = (dt > sqrt(1.5))?2.0:1.0;\n    float t = -rad*dt;\n\tfor(float s = 0.0; s < SLICES; s++) \n\t{\n       vec3 voxPos = floor(ro + rd * t);\n       \n       for(float x = -rad; x <= rad; x++)\n       for(float y = -rad; y <= rad; y++)\n       {\n           vec3 pos = voxPos + x*sliceX + y*sliceY;\n           col += sampleVoxel(ro, rd, pos);\n       }\n       \n       t += dt;\n\t}\n   // return vec3((dt > sqrt(1.5))?((dt > sqrt(1.9))?3.0:2.0):1.0);\n    return col;\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    return vec4(SliceTrace(cp, rd), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAM_ANGLE = 1.5 * FOV / iResolution.y;\n    fragColor = vec4(0.0);   \n\n    fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 138], [140, 140, 163, 163, 208], [211, 211, 268, 268, 383]], "test": "untested"}
{"id": "WstGzX", "name": "fruity pacman?", "author": "jildert", "description": "gradient", "tags": ["gradient"], "likes": 3, "viewed": 121, "published": 3, "date": "1675623804", "time_retrieved": "2024-07-30T18:11:59.587616", "image_code": "#define PI 3.1415926538\n#define TWO_PI 6.28318530718\n\nfloat circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat triangle(vec2 uvin, vec2 p, float size, float blur, float angle) {\n    vec2 uv = uvin - p;\n    float scale = ((sin(iTime * PI)+ 1.0) * 4.0) + 1.0;\n    uv.y *= scale;\n    uv = rotate2d(angle * PI / 180.0) * uv;\n    float n = 3.0;\n    float a = atan(uv.x,uv.y) + PI;\n    float r = TWO_PI / n;\n    float d = cos(floor(0.5 + a / r) * r - a) * length(uv);\n    return smoothstep(size,size-blur*scale/10.0,d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = rotate2d(iTime) * uv;\n    vec2 normaluv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse;\n    float dis = distance(m.xy, fragCoord);\n    \n    uv -=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 p = vec2(0.0,0.0);\n    float c = circle(uv, p, 0.4, 0.008);\n    \n    c -= circle(uv, vec2(.03, .15), 0.05, 0.008);\n    if (c < 0.0) c = 0.0;\n    if (c == 0.0) {\n            fragColor = vec4(uv.x * .5,uv.y,.2,0);\n            return;\n    }\n    \n    c -= triangle(uv, vec2(0.4, 0.0), 0.2, 0.1, 90.0);\n   \n    if (c < 0.0) c = 0.0;\n    \n    if (c == 0.0) {\n        if (dis < 50.0) {\n            fragColor = vec4(uv.x,uv.y,0,0);\n            return;\n        }\n        \n        fragColor = texture(iChannel0, vec2(normaluv.x, normaluv.y));\n        if (fragColor[1] > 0.3 && fragColor[2] < 0.4 && fragColor[0] < 0.3) {\n            fragColor = vec4(uv.y, uv.x, uv.y + 0.2, 1.0);\n        }\n    }\n    else {    \n        fragColor = vec4(c * (uv.x + 0.5), c * (uv.y + 0.5), 0, 1);\n    }\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 106, 106, 197], [199, 199, 227, 227, 313], [315, 315, 387, 387, 725], [727, 727, 783, 783, 1826]], "test": "untested"}
{"id": "dt2XRR", "name": "Independence Day (50 secs)", "author": "dean_the_coder", "description": "Based on the Independence Day movie.", "tags": ["3d", "raymarching", "space", "fog", "glow", "stars", "modelling", "lazer", "movie", "cineshader"], "likes": 66, "viewed": 3126, "published": 3, "date": "1675604980", "time_retrieved": "2024-07-30T18:12:00.508155", "image_code": "// 'Independence Day' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/dt2XRR\n// (YouTube: https://youtu.be/54QtASjzvBY)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on the Independence Day movie.\n// I learnt a few more tricks in this one, and trying\n// to improve my lighting and effects skills. (I'm no artist!)\n// It's funny how adding a few barely noticeable effects can\n// make such a difference when added together. (See the faint\n// glow around the Earth. Subtle, but effective.)\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//     E.g. Precalculated rotation matrices, and SDF functions (cone())\n//     that can have hard-coded constants in them.\n//   - Check if the ray point is too far away from an object\n//     to bother with modelling fine details.\n//     (See the ship() SDF).\n//   - Lots of domain repetition and axis mirroring.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t2e-4\n#define START_DIST\t1.\n#define MAX_DIST\t3e2\n#define MAX_STEPS\t1e2\n#define MAX_RDIST\t10.\n#define MAX_RSTEPS\t40.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(.4, 1, 1.5)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat t, // Global time.\n      fade = 1.;\nvec3 g; // 'Glow'\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid minH(inout Hit h, Hit h2) { U(h, h2.d, h2.id, h2.p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p, vec2 s) {\n\tvec2 ns;\n\tfor (int i = I0; i < 2; i++)\n\t\tns[i] = n31(p * s[i]);\n\n\treturn ns;\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rxy(vec3 p, float a) {\n\tp.xy *= rot(a);\n\treturn p;\n}\n\nvec3 rxz(vec3 p, float a) {\n\tp.xz *= rot(a);\n\treturn p;\n}\n\nvec3 ryz(vec3 p, float a) {\n\tp.yz *= rot(a);\n\treturn p;\n}\n\nvec3 ax(vec3 p) { return vec3(abs(p.x) - .2, p.yz); }\n\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\nfloat rep(float p) { return p - 48. * floor(p / 48. + .5); }\n\nvec2 rep2(vec2 p) { return p - vec2(7, 10) * floor(p / vec2(7, 10) + .5); }\n\nvec2 mody2(vec2 p) { return vec2(p.x, mod(p.y, 102.)); }\n\nfloat box(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.)); }\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.z -= clamp(p.z, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, float r1, float r2) { return length(vec2(length(p.xz) - r1, p.y)) - r2; }\n\nfloat cone(vec3 p, float h) {\n\tvec2 q = vec2(length(p.xz), p.y),\n\t     k1 = vec2(2.4, h),\n\t     k2 = vec2(2.4, 2. * h),\n\t     ca = vec2(q.x - min(q.x, (q.y < 0.) ? 0. : 2.4), abs(q.y) - h),\n\t     cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0., 1.);\n\treturn ((cb.x < 0. && ca.y < 0.) ? -1. : 1.) * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdOctahedron(vec3 p) {\n\tp = abs(p);\n\treturn (p.x + p.y + p.z - 20.) * .57735027;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .35 + .6) / 1.7;\n}\n\nvec3 starz(vec3 rd) {\n\tfloat f,\n\t      st = t - 36.;\n\trd.xy *= rot(st * .08);\n\n\t// Earth.\n\tvec2 s,\n\t     ns = n331(rd, vec2(67.821, 20.0948));\n\trd.y += 15.55;\n\n\t// Land.\n\tf = length(rd.xy) - 15.;\n\tvec3 c = S(.1, .05, f + .05) * vec3(1, 1.8, 2);\n\tc *= .7 + S(.24, .7, dot(ns, vec2(.1, .4)));\n\n\t// Atmosphere/Glow\n\tc += (S(.1, -.2, abs(f)) + S(.5, -6., f)) * vec3(1.5, 1.5, 2.5);\n\n\t// Stars (faded out near Earth).\n\trd *= 22.;\n\ts = h22(floor(rd.xy));\n\tc += vec3(s.y * S(.05 * s.x * s.y, 0., length(fract(rd.xy) - .1 - s * .8)) * S(0., .35, f));\n\treturn c;\n}\n\nvec3 skyCol(vec3 rd) {\n\tfloat f = fakeEnv(rd);\n\tf *= .6 + .4 * S(40., 37., t);\n\treturn vec3(.03, .13, .2) * f * f;\n}\n\nfloat scratches(vec3 p) {\n\tfloat f = 0.;\n\tfor (float i = 1.; i <= 3.; i++)\n\t\tf = max(f, S(.01, 0., abs(fract(rxz(p + 10. + i, i * .31).z) - .5)));\n\n\treturn f;\n}\n\n#define SKY_ID\t0\n#define METAL_ID\t1\n#define METAL_DARK_ID\t2\n#define LAZER_ID\t3\n#define BELOW_ARE_REFLECTIVE\t7\n#define GLASS_ID\t8\n\nHit ship(vec3 p) {\n\tvec3 op,\n\t     oop = p;\n\n\t// Mirror on x - Half the work. :)\n\tp.x = abs(p.x);\n\n\t// Subtle glow around the ship.\n\tg.x += .003 / (.1 + dot(p, p)) * S(1., 0., p.z + 1.5);\n\top = p;\n\n\t// Body.\n\tfloat d, b, x, l,\n\t      f = S(0., -3.6, p.z - 1.);\n\tp.z *= -.25 * f + 1. - .1 * sign(p.z);\n\tp.x += f * .4;\n\tp.x += S(-1., 2., p.z - 1.) * .4;\n\td = length(p + vec3(0, 4.4, 0)) - 5.1;\n\td = smin(d, length(p - vec3(0, 8.5, 0)) - 9., -.1);\n\n\t// Ray too far away? Skip the details...\n\tif (d > 2.) return Hit(d, METAL_ID, p);\n\tf = abs(abs(1.4 - op.x) - 1.5) + abs(op.z * .5);\n\td += .02 * max(S(.06, .03, op.x), S(1.13, 1.1, f) - S(1., .97, f));\n\n\t// Nose cut-out.\n\tb = d;\n\tf = cone(ryz(op, -.15) - vec3(0, .64, -2.25), 1. - .02 * S(.7, .9, sin(atan(p.x, p.z + 2.5) * 32.)));\n\td = smin(d, -f, -.05);\n\n\t// Sail thing.\n\tp = ryz(op - vec3(-.35 - .12 * p.z, 1.13, -.3), .25 + .01 * p.z * p.z);\n\tf = cap(p, 2.8, .7);\n\tf = smin(f, .15 - d, -.1);\n\tx = f;\n\tf = smin(f, .06 - op.x, -.02);\n\n\t// Sail side cut-outs.\n\tf = smin(f, -cap(rxz(p - vec3(.9, .1, 1), -.06), 2., .3), -.05);\n\n\t// Sail cut-out design.\n\tl = length(op.yz - vec2(1.3, -.28));\n\tf += .015 * S(0., -.03, abs(l - .2) - .04);\n\tf += .015 * S(-.03, -.1, op.z) * S(-.38, -.3, op.z) * step(op.y, 1.3) * S(.25, .3, l);\n\td = min(d, f);\n\n\t// Scratch design.\n\td -= .003 * scratches(oop);\n\n\t// Gun blisters.\n\td = smin(d, cap(op - vec3(2, -.18, -.5), .5, .13), .1);\n\n\t// Grills.\n\td = min(d, tor(ay(ay(op.yxz + vec3(.17, 0, 1.68), .12), .05), .15, .012));\n\tHit h = Hit(d, METAL_ID, p);\n\n\t// Sail thing inner.\n\tx = max(x + .03, op.x - .08);\n\tx = min(x, max(abs(length(op.xy - vec2(0, 1)) - .025) - .001, abs(op.z) - 1.));\n\n\t// Gunz.\n\tp = op - vec3(2, -.23 + op.z * .15, -.6);\n\tx = min(x, cap(p, .5, .06 - .002 * abs(sin(p.z * 120.))));\n\tx = smin(x, .04 - length(p.xy), -.02);\n\tU(h, x, METAL_DARK_ID, op);\n\n\t// Cockpit window.\n\tf = tor(op + vec3(0, .56, -.3), 1., 1.18);\n\td = smin(f, b + .02, -.1);\n\tU(h, d, GLASS_ID, op);\n\tif (h.id == GLASS_ID) {\n\t\tf = S(0., .15, abs(op.y - .25) - .16);\n\t\tf = max(f, S(.03, 0., abs(op.y - op.x * 1.5 + .1)) * .5);\n\t\tf = max(f, S(.05, .03, abs(op.x * .12 + .04 - op.y)) * 1.9);\n\t\td = min(d, d - f * .01);\n\t\tU(h, d, METAL_DARK_ID, op);\n\t}\n\n\t// Sail mount.\n\td = .03 - .07 * p.z;\n\td += sat(sin(p.z * 40.) * .0125);\n\td = box(op - vec3(0, .7, .6), vec3(d, .14, 1)) - .17;\n\n\t// Rear fins.\n\tp = op;\n\tp.x -= .65;\n\tp.y += .05;\n\tp.z -= 2.6 - .5 * p.x;\n\tx = .007 * sin(p.x * 73.);\n\td = min(d, box(p, vec3(.5, .1 + x - .3 * p.z, .18 + x) - .03) - .03);\n\tU(h, d, METAL_DARK_ID, op);\n\treturn h;\n}\n\n// Two combined twisting cubes with infinite length.\nfloat twisty(vec2 p, float l, float s) {\n\tfloat d = box2d(p.xy * rot(l), vec2(s));\n\treturn d < 3. ? smin(d, box2d(p.xy * rot(-l), vec2(s)), .3) : d;\n}\n\nfloat shipRack(vec3 p) {\n\tfloat d = length(ax(p - vec3(0, 1.8, -.5))) - .02;\n\tg.x += 3e-4 / (d * d);\n\tp.y -= 1.8;\n\treturn min(d, twisty(p.xy, p.z, .1));\n}\n\nfloat backTower(vec3 p) {\n\tfloat d, f,\n\t      gy = dot(sin(p * 2.4), cos(p.yzx * 2.4));\n\tgy = S(0., .1, abs(gy) - 1.2);\n\tp.yz -= vec2(5, 50);\n\tp = ay(p, 13.);\n\tp = ay(p, 13.);\n\tp = ay(p, 13.);\n\tp.xz *= mat2(.96891, .2474, -.2474, .96891);\n\td = sdOctahedron(p);\n\n\t// Lights.\n\tf = abs(p.y + 4.);\n\tf = max(d, abs(f - .4));\n\tf = max(f, -gy);\n\tg.y += gy * 5e-5 / (.005 + f * f);\n\treturn d;\n}\n\nfloat columns(vec3 p) {\n\tp.z += 24. * sat(p.x);\n\tp.x = abs(p.x) - 20. - h11(floor(p.z / 48.)) * 20.;\n\tp.z = rep(p.z - 24.);\n\treturn twisty(p.xz, p.y * .05, 3. + n21(p.xy) * .5) - 1.;\n}\n\nvec3 lazerP(vec3 p) {\n\tp.z += mod(t, 3.) * 220. - 30.;\n\treturn p;\n}\n\nvec2 shipTunnelPos(vec2 p, float st) { return (.2 + .8 * S(10., 7.7, st)) * vec2(sin(st * -.765625 + 3.141) * 5. * S(0., 3., st), 3. + sin(st * -1.828125) * 2.125); }\n\nHit sdf(vec3 p) {\n\t// sr - Ship rotation.\n\tvec3 op = p,\n\t     sr = vec3(0);\n\tHit h;\n\th.d = 1e7;\n\tif (t < 16.) {\n\t\t//\n\t\t// Stage 1 - Racked scene.\n\t\t//\n\t\tU(h, backTower(p), METAL_DARK_ID, p);\n\n\t\t// We need ships. Lots of ships...\n\t\tp.xz = rep2(p.xz);\n\n\t\t// Ship racks.\n\t\tU(h, shipRack(p), METAL_DARK_ID, p);\n\n\t\t// Too far away from ships/racks - Squeeze a few more FPS...\n\t\tif (p.y > 3. || p.y < -9.) return h;\n\n\t\t// Add the ship(s).\n\t\tfloat x = floor((abs(op.x) - 3.5) / 7.),\n\t\t      z = floor((op.z - 5.) / 10.),\n\t\t      chaser = sat(x + z + 2.),\n\t\t      drop = S(9.5, 14., t - 2.5 * chaser + x * .4) * 3.2 * float(x <= z && z <= 0.);\n\t\tp.y += drop * drop * drop * 3.;\n\t\tp.z -= drop;\n\t\tsr = vec3(-.5 * drop, -2.5 * S(.3, 1.5, drop), .5 * S(.1, 1., drop));\n\t\tsr.x += (1. - chaser) * sin(t * 2.) * sin(t * 2.) * .1 * S(5.5, 6., t) * S(10., 9.5, t);\n\t}\n\telse if (t < 36.) {\n\t\t//\n\t\t// Stage 2,3 - Pillars.\n\t\t//\n\t\tfloat adv = 140. * t,\n\t\t      d = 1e7;\n\t\tU(h, columns(p - vec3(0, 0, adv)), METAL_DARK_ID, p);\n\t\tif (t > 17.5 && t < 34.) {\n\t\t\td = cap(lazerP(op), 10., .01);\n\t\t\tU(h, d, LAZER_ID, p);\n\t\t\tg.y += .001 / (.001 + d * d);\n\t\t}\n\n\t\tsr.z += cos(t + 1.) * .2;\n\t\tp.xy += sin(t) * vec2(3, 2);\n\t\tp.yz += vec2(2, S(34., 37., t) * MAX_DIST);\n\t}\n\telse {\n\t\t//\n\t\t// Stage 4 - Escape tunnel.\n\t\t//\n\t\tfloat st = t - 36.,\n\t\t      d = 1e7;\n\t\tst *= 1.2;\n\t\tvec3 tp = rxy(p, st * .09 - .6);\n\t\ttp.z += 50. - st * 35.;\n\t\tfor (float i = 0.; i < 3.; i++) {\n\t\t\t// Wall.\n\t\t\tfloat td = tp.y + 20.;\n\n\t\t\t// Cut-out trough.\n\t\t\ttd = smin(td, -box2d(tp.xy + vec2(-10, 20), vec2(6, 2)), -.2);\n\n\t\t\t// Beams.\n\t\t\tvec2 cp = tp.xz + vec2(i * 4. + 4., 1e2 + 20. * i);\n\t\t\tcp.x += 10. * sin(12.9 * floor(cp.y / 102.));\n\t\t\td = min(d, twisty(mody2(cp), tp.y * .2, 1.));\n\t\t\ttp.xy *= mat2(-.50485, .86321, -.86321, -.50485);\n\t\t\td = smin(d, td, 2.);\n\t\t}\n\n\t\td = max(d, -tp.z - 3e2);\n\t\tif (d < .2) d -= .025 * scratches(tp * .1);\n\t\tU(h, d, METAL_DARK_ID, tp);\n\t\tp.xy += shipTunnelPos(p.xy, st);\n\t\tp.z += 6.;\n\t\tsr.z += shipTunnelPos(p.xy, st + 2.).x * .05;\n\t}\n\n\tp = rxz(p, sr.y);\n\tp = ryz(p, sr.x);\n\tp = rxy(p, sr.z);\n\tminH(h, ship(p));\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .01,\n\t      mxt = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.01, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.2, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld) { return S01(sdf(.05 * ld + p).d / .05); }\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tvec3 lp, ld, c, l, col,\n\t     sky = skyCol(rd);\n\tif (h.id == SKY_ID) return t > 36. ? starz(rd) : sky;\n\tfloat fg,\n\t      ss = 0.,\n\t      shine = 1.;\n\tlp = t < 16. ? vec3(20, 8, -10) : vec3(-5, 1, -10);\n\tif (t > 36.) lp = vec3(30, -3.4, 35. * t - 1640.);\n\tld = normalize(lp - p);\n\tc = vec3(.5, .4, .3);\n\n\t// Cache noise.\n\tvec2 ns = n331(h.p, vec2(20, 38));\n\tif (h.id == METAL_ID) {\n\t\tshine = 1. - sum2(ns) * .1;\n\t\tc *= shine;\n\t\tss = sss(p, ld) * .5;\n\t}\n\telse if (h.id == METAL_DARK_ID) {\n\t\tshine = 1. - sum2(ns) * .1;\n\t\tc *= shine * .2;\n\t\tss = sss(p, ld) * .5;\n\t}\n\telse if (h.id == GLASS_ID) {\n\t\tshine = 1. - sum2(ns) * .95;\n\t\tc *= shine * .02;\n\t}\n\telse c = vec3(9); // Lazer\n\t// Specular imperfections.\n\tshine = .2 + .8 * ns.x * ns.y;\n\n\t// Key light, reverse, sky.\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\tif (h.id != LAZER_ID) {\n\t\t// Subsurface scattering.\n\t\tl.x += ss;\n\n\t\t// Diffuse.\n\t\tl.xy = .1 + .9 * l.xy;\n\n\t\t// Ambient occlusion.\n\t\tl.yz *= .1 + .9 * ao(p, n);\n\n\t\t// Light contributions (key, reverse, sky).\n\t\tl *= vec3(1, .4, .2);\n\n\t\t// Specular (Blinn-Phong)\n\t\tl.x += pow(sat(dot(normalize(ld - rd), n)), 10.) * shine;\n\n\t\t// Shadow.\n\t\tl.x *= .1 + .9 * shadow(p, lp, ld, n);\n\n\t\t// Light falloff\n\t\tl.x *= dot(lp, lp) / (1. + dot3(lp - p));\n\n\t\t// Lazer light-up.\n\t\tif (t > 16. && t < 34.) {\n\t\t\tlp = lazerP(p) - vec3(0, 0, 5);\n\t\t\tc += S(20., 10., abs(lp.z - p.z)) * S(5., 0., abs(p.x)) * sat(.5 + dot(normalize(p - lp), n)) * vec3(.01, 1, .01);\n\t\t}\n\t}\n\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, S(.7, 1., 1. + dot(rd, n)) * .2);\n\tfg = t < 36. ? 4e-4 : 2e-5;\n\tfg = exp(dot3(p - ro) * -fg); // Distance Fog.\n\treturn mix(sky, col, fg);\n}\n\nfloat addFade(float a) { return min(1., 2. * abs(t - a)); }\n\nvec4 march(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tvec3 dv, n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\t// Floaty particles.\n\tdv = rd;\n\tfor (i = 1.5; i < d && t < 16.; i += 4.) {\n\t\tvec3 vp = ro + dv * i;\n\t\tvp.yz -= t * .05;\n\t\tg.x += .2 * (1. - S(0., mix(.05, .02, sat((i - 1.) / 19.)), length(fract(vp - ro) - .5)));\n\t\tdv.xz *= mat2(.87758, .47943, -.47943, .87758);\n\t}\n\n\tcol = g.x * LIGHT_RGB + g.y * vec3(.1, 1.5, .3);\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += .2 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\tcol = pow(max(vec3(0), col), vec3(.4545));\n    return vec4(col, (1. - sat(3. * d / MAX_DIST)) * 0.25);\n}\n\n#define rgba(col)\tcol * fade\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 50.);\n\tfade = addFade(0.) * addFade(16.) * addFade(36.) * addFade(50.);\n\tg = vec3(0);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 lookAt = vec3(0),\n\t     ro = vec3(0, .001, -6);\n\tif (t < 16.) {\n\t\t// Stage 1 - Hanging.\n\t\tro = mix(vec3(-4, 2, -1), vec3(-1, -1, -7), S(0., 7., t));\n\t\tfloat st = S(6.5, 13., t);\n\t\tro = mix(ro, vec3(1, .8, -6), st);\n\t\tlookAt = vec3(0, st, 0);\n\t}\n\telse if (t < 22.)\n        // Stage 2 - Pillar corridor.\n        ro = vec3(sin(t), 6, 14);\n\telse if (t < 36.) {\n\t\t// Stage 3 - Side-on pillars.\n\t\tro = vec3(8, 0, 3. * cos(t * .6) - 3.);\n\t\tro += S(30., 34., t) * vec3(-9, 0, 15);\n\t\tlookAt.y = -1.;\n\t}\n\telse {\n\t\t// Stage 4 - Escape tunnel.\n\t\tro.y++;\n\t\tro.z += 15.;\n\t}\n    \n\t// View bob.\n\tro += .1 * sin(iTime * vec3(.9, .7, .3));\n    \n\tvec4 col = march(ro, rayDir(ro, lookAt, uv));\n    \n\tcol.rgb *= 1. - .3 * dot(uv, uv); // Vignette.\n\tcol.rgb += (h21(fc) - .5) / 64.; // Grain\n    \n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2XRR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1779, 1779, 1825, 1825, 1859], [1861, 1861, 1893, 1893, 1920], [1922, 1922, 1942, 1942, 1966], [1968, 1968, 1988, 1988, 2012], [2014, 2014, 2034, 2034, 2054], [2056, 2056, 2076, 2076, 2102], [2104, 2165, 2185, 2185, 2256], [2258, 2258, 2276, 2276, 2396], [2398, 2398, 2418, 2418, 2515], [2517, 2517, 2536, 2536, 2557], [2559, 2559, 2578, 2578, 2920], [2922, 2958, 2985, 2985, 3065], [3067, 3067, 3086, 3086, 3112], [3114, 3114, 3153, 3153, 3235], [3237, 3237, 3256, 3256, 3323], [3325, 3325, 3352, 3352, 3382], [3384, 3384, 3411, 3411, 3441], [3443, 3443, 3470, 3470, 3500], [3502, 3502, 3519, 3519, 3555], [3557, 3557, 3583, 3583, 3622], [3624, 3624, 3644, 3644, 3684], [3686, 3686, 3705, 3705, 3761], [3763, 3763, 3783, 3783, 3819], [3821, 3821, 3848, 3848, 3886], [3888, 3888, 3917, 3917, 3988], [3990, 3990, 4027, 4027, 4079], [4081, 4081, 4120, 4120, 4172], [4174, 4174, 4203, 4203, 4521], [4523, 4523, 4551, 4551, 4611], [4613, 4613, 4657, 4657, 4793], [4795, 4795, 4818, 4838, 4887], [4889, 4889, 4910, 4910, 5444], [5446, 5446, 5468, 5468, 5562], [5564, 5564, 5589, 5589, 5724], [5856, 5856, 5874, 5874, 8415], [8417, 8470, 8510, 8510, 8620], [8622, 8622, 8646, 8646, 8776], [8778, 8778, 8803, 8803, 9164], [9166, 9166, 9189, 9189, 9350], [9352, 9352, 9373, 9373, 9419], [9421, 9421, 9459, 9459, 9587], [9589, 9589, 9606, 9630, 11738], [11740, 11740, 11765, 11765, 11972], [11974, 11974, 12022, 12069, 12351], [12353, 12389, 12415, 12415, 12545], [12547, 12591, 12619, 12619, 12660], [12662, 12662, 12716, 12716, 14383], [14385, 14385, 14409, 14409, 14444], [14446, 14446, 14476, 14497, 15641], [15673, 15673, 15718, 15718, 16662]], "test": "untested"}
{"id": "dt2SRR", "name": "Mouse circle cursor", "author": "spit1ire", "description": "Just circle cursor", "tags": ["mousecircle"], "likes": 1, "viewed": 189, "published": 3, "date": "1675600056", "time_retrieved": "2024-07-30T18:12:01.358880", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float asp = iResolution.x / iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n     \n    vec2 mUv = iMouse.xy/iResolution.xy;\n    float len = length(uv - vec2(mUv.x*asp, mUv.y));\n    \n    float pixels = 10.;\n    float p = pixels / iResolution.y;\n\n    if (len > p) discard;\n    \n\n    // Output to screen\n    fragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2SRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 444]], "test": "untested"}
{"id": "Dl2XRz", "name": "Paper Plane Sonar UI ", "author": "yasuo", "description": "Paper Plane Sonar UI ", "tags": ["ui", "cineshader"], "likes": 63, "viewed": 2701, "published": 3, "date": "1675582829", "time_retrieved": "2024-07-30T18:12:02.599563", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\nfloat rand (vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dSlopeLines(vec2 p){\n    float lineSize = 80.;\n    float d = tan((mix(p.x,p.y,0.5)+(-iTime*5./lineSize))*lineSize)*lineSize;\n    return d;\n}\n\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(40.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    //d = max(d2,d);\n    //d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.9;\n    p.y-=size*3.2;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.06;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=SkewX(-0.4);\n    float d = seg0(p)*checkChar(seg_0,char);\n    d += seg1(p)*checkChar(seg_1,char);\n    d += seg2(p)*checkChar(seg_2,char);\n    d += seg3(p)*checkChar(seg_3,char);\n    d += seg4(p)*checkChar(seg_4,char);\n    d += seg5(p)*checkChar(seg_5,char);\n    d += seg6(p)*checkChar(seg_6,char);\n    d += seg7(p)*checkChar(seg_7,char);\n    d += seg8(p)*checkChar(seg_8,char);\n    d += seg9(p)*checkChar(seg_9,char);\n    \n    return d;\n}\n\nvec3 paperPlane(vec2 p, vec3 col){\n    p.y-=0.1;\n    p*=1.5;\n    vec2 prevP = p;\n    p *= vec2(1.,0.4);\n    float d = Tri(p,vec2(0.1,0.1),radians(45.));\n    \n    p = prevP;\n    \n    p.y+=0.23;\n    p *= vec2(2.,2.);\n    \n    float d2 = Tri(p,vec2(0.1,0.1),radians(45.));    \n    d = max(-d2,d);\n    \n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    p = prevP;\n    p *= vec2(6.,0.4);\n    d = Tri(p,vec2(0.1,0.1),radians(45.));\n    p = prevP;\n    \n    p.y+=0.23;\n    p *= vec2(2.,2.);\n    \n    d2 = Tri(p,vec2(0.1,0.1),radians(45.));    \n    d = max(-d2,d);\n    col = mix(col,vec3(0.75),S(d,0.0));\n    \n    \n    \n    p = prevP;\n    p *= vec2(1.,0.4);\n    d = Tri(p,vec2(0.1,0.1),radians(45.));\n    \n    p = prevP;\n    p.y+=0.16;\n    p *= vec2(0.9,1.);\n    \n    d2 = Tri(p,vec2(0.1,0.1),radians(45.));    \n    d = max(-d2,d);\n        \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n\n    \n    p = prevP;\n    p *= vec2(11.,0.59);\n    d = Tri(p,vec2(0.1,0.1),radians(45.));\n    p = prevP;\n    \n    p.y+=0.23;\n    p *= vec2(2.,2.);\n    \n    d2 = Tri(p,vec2(0.1,0.1),radians(45.));    \n    d = max(-d2,d);\n    col = mix(col,vec3(0.85),S(d,0.0));\n\n    p = prevP;\n    p.y+=0.18;\n    p.x*=1.2;\n    d = Tri(p,vec2(0.01),radians(-45.));    \n    col = mix(col,vec3(0.85),S(d,0.0));\n    \n    p = prevP;\n    d = B(p-vec2(0.0,-0.12),vec2(0.004,0.11));\n    col = mix(col,vec3(0.95),S(d,-0.01));\n    \n    return col;\n}\n\nvec3 radar(vec2 p,vec3 col){\n    vec2 prevP = p;\n    p*=Rot(radians(25.0*iTime));\n    float a = atan(p.x,p.y);\n    float d = length(p)-0.4;\n    col = mix(col,vec3(1.)*a*0.01,S(d,0.0));\n    \n    d = length(p)-0.4;\n    a = radians(1.);\n    p.x = abs(p.x);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 grids(vec2 p,vec3 col){\n    vec2 prevP = p;\n    p.y+= iTime*0.1;\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.00001;\n    float d = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    p = prevP;\n    float c = length(p)-0.4;\n    d = max(c,d);\n\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    p*=Rot(radians(-20.*iTime));\n    p=DF(p,40.);\n    p-=vec2(0.28);\n    p*=Rot(radians(45.));\n    d = B(p,vec2(0.001,0.01));\n    \n    p = prevP;\n    p*=Rot(radians(-20.*iTime));\n    p=DF(p,10.);\n    p-=vec2(0.27);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.02));\n    d = min(d,d2);\n\n    col = mix(col,vec3(1.),S(d,0.0));\n\n    int num = 8;\n    d = 10.;\n    for(int i = 0; i<num; i++){\n        float r = radians(135.0+(360.0/float(num))*float(i));\n        float dist = 3.7;\n        float x = cos(r)*dist;\n        float y = sin(r)*dist;\n        p = prevP;\n        p*=8.0;\n        d2 = drawFont(p-vec2(x,y),(num-1)-int(mod(float(i),10.)));\n        d = min(d,d2);\n    }\n    col = mix(col,vec3(0.6),S(d,0.0));\n\n    p = prevP;\n    p*=Rot(radians(20.*iTime));\n    p=DF(p,30.);\n    p-=vec2(0.3);\n    p*=Rot(radians(45.));\n    d = B(p,vec2(0.001,0.008));\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 objects(vec2 p, vec3 col){\n    vec2 prevP = p;\n    p.y+= iTime*0.1;\n    p*=5.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    vec2 prevGr = gr;\n    float r = rand(id);\n    \n    float d = 10.;\n    float bd = 10.;\n    if(r<0.2){\n        gr.x*=1.7;\n        d = Tri(gr-vec2(0.0,-0.09),vec2(0.15),radians(-45.));\n        gr = prevGr;\n        float d2 = abs(length(gr)-0.16)-0.02;\n        float dir = (r>=0.1)?-1.:1.;\n        gr*=Rot(radians(iTime*30.*dir));\n        d2 = max(-(abs(gr.x)-0.05),d2);\n        d = min(d,d2);\n    } else if(r>=0.2 && r<0.35){\n        bd = B(gr,vec2(0.2,0.11));\n        gr.x = abs(gr.x)-0.2;\n        bd = min(B(gr,vec2(0.07,0.2)),bd);\n        gr = prevGr;\n        bd = max(dSlopeLines(gr),bd);\n    }\n    \n    p = prevP;\n    float c = length(p)-0.4;\n    d = max(c,d);\n    bd = max(c,bd);\n    \n    col = mix(col,vec3(0.5),S(d,0.0));\n    col = mix(col,vec3(0.4),S(bd,0.0));\n    return col;\n}\n\nvec3 graph0(vec2 p, vec3 col){\n    p*=1.3;\n    vec2 prevP = p;\n    p.x+=iTime*0.2;\n    p*=120.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float r = rand(vec2(id.x,id.x))*10.;\n    gr.y = p.y;\n    float d = B(gr,vec2(0.35,0.3+r));\n    \n    p = prevP;\n    \n    float d2 = B(p,vec2(0.25,0.12));\n    d = max(d2,d);\n    d2 = abs(d2)-0.0005;\n    d2 = max(-min(abs(p.x)-0.23,abs(p.y)-0.1),d2);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 graph1(vec2 p, vec3 col){\n    p*=1.3;\n    vec2 prevP = p;\n    p.y+=0.11;\n    p.x+=-iTime*0.1;\n    p*=50.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float r = rand(vec2(id.x,id.x))*10.;\n    gr.y = p.y;\n    float d = B(gr,vec2(0.4,(0.5+abs(sin(0.3+0.2*iTime*r))*r)));\n    \n    \n    p = prevP;\n    float d2 = B(p,vec2(0.25,0.12));\n    d = max(d2,d);\n    p.y+=0.11;\n    d = max(-p.y,d);\n    \n    p = prevP;\n    d2 = B(p,vec2(0.25,0.12));\n    d2 = abs(d2)-0.0005;\n    d2 = max(-min(abs(p.x)-0.23,abs(p.y)-0.1),d2);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 graph2(vec2 p, vec3 col){\n    p*=1.3;\n    vec2 prevP = p;\n    p*=15.;\n    p.x+=iTime*1.5;\n    float d = sin(p.y*0.6)*0.3+cos(p.x*1.5)*0.2;\n    d = abs(d)-0.005;\n\n    p = prevP;\n    p*=15.;\n    p.x+=-iTime*1.2;\n    float d3 = sin(-p.y*0.7)*0.3+cos(-p.x*1.2)*0.2;\n    d3 = abs(d3)-0.005;\n    d = min(d,d3);\n\n    p = prevP;\n    float d2 = B(p,vec2(0.25,0.12));\n    d = max(d2,d);\n    d2 = abs(d2)-0.0005;\n    d2 = max(-min(abs(p.x)-0.23,abs(p.y)-0.1),d2);\n    d = min(d,d2);\n\n\n    col = mix(col,vec3(1.),S(d,0.0));\n\n    d = max(abs(p.x)-0.25,abs(p.y)-0.0001);\n\n    col = mix(col,vec3(0.5),S(d,0.0));\n    \n    d = max(abs(p.x)-0.0001,abs(p.y)-0.15);\n\n    p.x+=iTime*0.05;\n    p.x = mod(p.x,0.02)-0.01;\n    d2 = B(p,vec2(0.001,0.01));\n    d = min(d,d2);\n    p = prevP;\n    d = max(abs(p.x)-0.25,d);\n\n    p = prevP;\n    p.y-=iTime*0.05;\n    p.y = mod(p.y,0.02)-0.01;\n    d2 = B(p,vec2(0.01,0.001));\n    d = min(d,d2);\n    p = prevP;\n    d = max(abs(p.y)-0.11,d);\n\n    col = mix(col,vec3(0.5),S(d,0.0));\n    \n\n    return col;\n}\n\nvec3 graph3(vec2 p, vec3 col){\n    p*=1.3;\n    vec2 prevP = p;\n    \n    p.x+=iTime*0.2;\n    p = mod(p,0.03)-0.015;\n    float thickness = 0.0001;\n    float d = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    p = prevP;\n    d = max(B(p,vec2(0.24,0.11)),d);\n    col = mix(col,vec3(0.3),S(d,0.0));\n    \n    \n    p.x+=iTime*0.2;\n    p*=12.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float r = rand(id);\n\n    d = length(gr+r*0.5)-0.08;\n    if(r>0.5)d = 10.;\n    p = prevP;\n    \n    float d2 = B(p,vec2(0.25,0.12));\n    d = max(B(p,vec2(0.25,0.08)),d);\n    d2 = abs(d2)-0.0005;\n    d2 = max(-min(abs(p.x)-0.23,abs(p.y)-0.1),d2);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 smallCircleUI(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(20.*iTime));\n    p=DF(p,15.);\n    p-=vec2(0.09);\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.001,0.01));\n    \n    p = prevP;\n    p*=Rot(radians(20.*iTime));\n    p=DF(p,5.);\n    p-=vec2(0.1);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.012));\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    \n    p.y*=-1.;\n    p*=Rot(radians(25.0*iTime));\n    float a = atan(p.x,p.y);\n    d = length(p)-0.1;\n    col = mix(col,vec3(1.)*a*0.05,S(d,0.0));\n    \n    d = length(p)-0.1;\n    a = radians(1.);\n    p.x = abs(p.x);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    p.y*=-1.;\n    p*=Rot(radians(25.0*iTime));\n    d = max(p.y,d);\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    \n    p = prevP;\n    d2 = abs(length(p)-0.1)-0.0001;\n    d = min(d,d2);\n    d2 = abs(length(p)-0.07)-0.0001;\n    d = min(d,d2);\n    d2 = abs(length(p)-0.04)-0.0001;\n    d = min(d,d2);\n    d2 = max(length(p)-0.1,min(abs(p.x)-0.0001,abs(p.y)-0.0001));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    \n    return col;\n}\n\nvec3 smallCircleUI2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-25.*iTime));\n    p=DF(p,15.);\n    p-=vec2(0.09);\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.001,0.01));\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    p*=3.5;\n    d = drawFont(p-vec2(-0.1,0.0),int(mod(iTime*5.,10.0)));\n    float d2 = drawFont(p-vec2(0.1,0.0),int(mod(iTime*10.,10.0)));\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    d = abs(length(p)-0.1)-0.01;\n    col = mix(col,vec3(.2),S(d,0.0));\n    \n    d = abs(length(p)-0.1)-0.01;\n    p*=Rot(radians(20.*iTime));\n    float a = radians(60.);\n    p.x = abs(p.x);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    col = mix(col,vec3(.7),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime)*160.));\n    d = abs(length(p)-0.152)-0.003;\n    d = max(abs(p.y)-0.08,d);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 smallCircleUI3(vec2 p, vec3 col, float dir){\n    vec2 prevP = p;\n    \n    float d = length(p)-0.007;\n    float d2 = abs(length(p)-0.03)-0.0005;\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p*=Rot(radians(22.0*iTime*dir));\n    float a = radians(30.);\n    d2 = abs(length(p)-0.03)-0.016;\n    p.x = abs(p.x);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    p = prevP;\n    p*=Rot(radians(22.0*iTime*dir));\n    p.x = abs(p.x);\n    p*=Rot(radians(-120.));\n    float d3 = abs(length(p)-0.03)-0.016;\n    p.x = abs(p.x);\n    float d4 = max(dot(p,vec2(cos(a),sin(a))),d3);\n    d2 = min(d2,d4);\n    \n    col = mix(col,vec3(0.3),S(d2,0.0));\n    return col;\n}\n\nvec3 smallUI0(vec2 p, vec3 col){\n    float d = B(p,vec2(0.001,0.03));\n    float d2 = B(p,vec2(0.03,0.001));\n    d = min(d,d2);\n    d = max(-B(p,vec2(0.01)),d);\n    col = mix(col,vec3(0.5),S(d,0.0));\n    return col;\n}\n\nvec3 smallUI1(vec2 p, vec3 col){\n    float d = abs(length(p-vec2(0,-0.015))-0.01)-0.0005;\n    p.x = abs(p.x);\n    float d2 = abs(length(p-vec2(0.017,0.015))-0.01)-0.0005;\n    d = min(d,d2);\n    col = mix(col,vec3(0.5),S(d,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.);\n    \n    col = radar(p,col);\n    col = grids(p,col);\n    col = objects(p,col);\n    col = paperPlane(p,col);\n\n    col = graph0(p-vec2(-0.6,0.35),col);\n    col = graph1(p-vec2(-0.6,-0.35),col);\n    \n    col = graph2(p-vec2(0.6,0.35),col);\n    col = graph3(p-vec2(0.6,-0.35),col);\n    \n    col = smallCircleUI(p-vec2(-0.64,0.0),col);\n    col = smallCircleUI2(p-vec2(0.64,0.0),col);\n    \n    p = abs(p);\n    col = smallCircleUI3(p-vec2(0.48,0.18),col,1.);\n    \n    p = prevP;\n    p = abs(p);\n    col = smallUI0(p-vec2(0.32,0.41),col);\n        \n    p = prevP;\n    p = abs(p);\n    col = smallUI1(p-vec2(0.76,0.18),col);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2XRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 667, 667, 739], [741, 741, 767, 767, 887], [890, 890, 912, 912, 1407], [1409, 1409, 1428, 1428, 1578], [1580, 1580, 1599, 1599, 1910], [1912, 1912, 1931, 1931, 2219], [2221, 2221, 2240, 2240, 2535], [2537, 2537, 2556, 2556, 2844], [2846, 2846, 2865, 2865, 3153], [3155, 3155, 3174, 3174, 3444], [3446, 3446, 3465, 3465, 3648], [3651, 3651, 3670, 3670, 3856], [3858, 3858, 3877, 3877, 4147], [4149, 4149, 4191, 4191, 4251], [4253, 4253, 4286, 4286, 4732], [4734, 4734, 4768, 4768, 6127], [6129, 6129, 6157, 6157, 6487], [6489, 6489, 6517, 6517, 7703], [7705, 7705, 7736, 7736, 8629], [8631, 8631, 8661, 8661, 9115], [9117, 9117, 9147, 9147, 9730], [9732, 9732, 9762, 9762, 10757], [10759, 10759, 10789, 10789, 11479], [11481, 11481, 11518, 11518, 12632], [12634, 12634, 12672, 12672, 13563], [13565, 13565, 13614, 13614, 14243], [14245, 14245, 14277, 14277, 14461], [14463, 14463, 14495, 14495, 14709], [14711, 14711, 14768, 14768, 15559]], "test": "untested"}
{"id": "DtjSRz", "name": "3D Circle music spectre", "author": "MiniByte", "description": "3D Circle music spectre", "tags": ["3d"], "likes": 7, "viewed": 233, "published": 3, "date": "1675579617", "time_retrieved": "2024-07-30T18:12:03.523094", "image_code": "// ##############################\n// BEGIN\tIQ methods\n// ##############################\n\n// Calculate matrix for camera looking at a specific target\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.2);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n// ##############################\n// END\t\tIQ methods\n// ##############################\n\n\n#define PI 3.14159265\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 5.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/1.5)) c = abs(c);\n\treturn c;\n}\n\n\n// ##############################\n// BEGIN\tCamera helpers\n// ##############################\nuniform float iCamPosX;\nuniform float iCamPosY;\nuniform float iCamPosZ;\nuniform float iCamRotX;\nuniform float iCamRotY;\nuniform float iCamRotZ;\n\nvec3 calcCameraPos()\n{\n\treturn vec3(iCamPosX, iCamPosY, iCamPosZ);\n}\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov/5.5*3.14159/180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 5.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 3.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// ##############################\n// END\t\tCamera helpers\n// ##############################\n\n// Change this to change repetition interval\nfloat afFrequencies[20];\n\nfloat cubeCircle(vec3 point, float radius, int count, vec3 cubeSize)\n{\n\tfloat c = pModPolar(point.xz, float(count));\n\tfloat index = floor(c + float(count)/2. -1.);\n\n\treturn fBox( point-vec3(radius,0,0), cubeSize + vec3(0, 0.2 + 0.7*afFrequencies[int(mod(index,float(afFrequencies.length())))] , 0));\n}\n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec3 point )\n{\n\t//\tparameters\n\tint circleTiles = 400;\n\tfloat radius = 5.;\n\tvec3 cubeSize = vec3(0.02);\n\n\t//\tdistance to floor plane\n\tfloat planeDist = sdPlane(point);\n\n\t//\tdistances to the cube circles\n\tfloat cubesCircleBigDist = cubeCircle(point, radius, circleTiles, cubeSize);\n\tfloat cubesCircleSmallDist = cubeCircle(point, radius/2., circleTiles/2, cubeSize);\n\n\t//\tblack cube in the center\n\tpoint.y -= 1.0;\n\trotateAxis(point.yz, radians(45.0));\n\trotateAxis(point.xy, PI/4.);\n\tfloat boxDist = fBox( point, 5.*cubeSize*afFrequencies[2] );\n\n\t//\treturn closest object\n\treturn min(min(min(cubesCircleBigDist, boxDist), cubesCircleSmallDist), planeDist);\n}\n\nvec3 getNormal( in vec3 pos )\n{\n\t// IQ\n\tvec2 e = vec2( 1.0,-1.0 ) * 0.001;\n\treturn normalize( e.xyy*distFunc( pos + e.xyy ) +\n\te.yyx*distFunc( pos + e.yyx ) +\n\te.yxy*distFunc( pos + e.yxy ) +\n\te.xxx*distFunc( pos + e.xxx ) );\n}\n\nvec3 getMaterialColor(vec3 point)\n{\n\t//\tfloor color\n\tif(point.y < 0.0001)\n\t{\n\t\treturn vec3( 0.5 );\n\t}\n\n\t//\tcolor for center area\n\tif(length(point.xz) < 1.0)\n\t{\n\t\treturn vec3( 0.0, 0.0, 0.0 );\n\t}\n\n\t//\totherwise determine color based on angle\n\tfloat count = 64.;\n\n\t//\tCalculate ID for each segment of the circular rotation\n\tfloat c = pModPolar(point.xz, count);\n\n\treturn vec3(0.45*sin(((c+iTime)/count)*2.*PI)+0.55);\n}\n\nfloat softshadow(const vec3 origin, in vec3 dir, in float mint, in float tmax, float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = distFunc( origin + dir*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat ambientOcclusion(vec3 point, float delta, int samples)\n{\n\tvec3 normal = getNormal(point);\n\tfloat occ = 0.;\n\tfor(float i = 1.; i < float(samples); ++i)\n\t{\n\t\tocc += (2.0/i) * (i * delta - distFunc(point + i * delta * normal));\n\t}\n\t// occ = clamp(occ, 0, 1);\n\treturn 1. - occ;\n}\n\n\n//\tLighting settings\n#define ENABLE_SHADOWS\n//#define ENABLE_OCCLUSION\n\nconst float lightAttenuation = 0.00;\n\nvec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )\n{\n\t//\tlight relative to camera position\n\tvec3 lightPosition = vec3(sin(iTime), 3.0, cos(iTime));\n\n\t//\tSpecular highlight factor\n\tfloat materialShininess = 64.0;\n\tvec3 materialSpecularColor = vec3( 1.0 );\n\n\t//\tOutput color\n\tvec3 outputColor = vec3( 0.0 );\n\n\t//\tCalculate eye vector and its reflection\n\tvec3 surfaceToLight = normalize(lightPosition - hitPosition);\n\tvec3 surfaceToCamera = normalize(cameraPosition - hitPosition);\n\n\t//\tsurface color\n\tvec3 surfaceColor = getMaterialColor(hitPosition);\n\n\t//\tambient component\n    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*smoothstep(-0.3, 1.0, afFrequencies[0]);\n\tvec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor\n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n\tvec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 0.0;\n\tif(diffuseCoefficient > 0.0) {\n\t\t//specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n\t}\n\tvec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - hitPosition);\n\tfloat attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.0));\n\n\t//\tsoft shadows (optional)\n\tfloat shadow = 1.0;\n\t#ifdef ENABLE_SHADOWS\n\tshadow = max(0.2, softshadow(hitPosition, surfaceToLight, 0.01, 5.0, 8.0));\n\t#endif\n\n\t//\tambient occlusion (optional)\n\tfloat occlusionCoefficient = 1.0;\n\t#ifdef ENABLE_OCCLUSION\n\tocclusionCoefficient = ambientOcclusion(hitPosition, 0.01, 10);\n\t#endif\n\n\t//\tcalculate final color\n\toutputColor = ambientColor + occlusionCoefficient * shadow * attenuation*(diffuseColor + specularColor);\n\n\t//\tgamma correction\n\t//vec3 gamma = vec3(1.0/2.2);\n\t//outputColor = vec3(pow(outputColor, gamma));\n\n\t//\treturn shading result\n\treturn outputColor;\n}\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 256;\nconst float maxT = 20.0;\nfloat trace(vec3 ro, vec3 rd, out vec3 point, out bool objectHit)\n{\n\tfloat t = 0.0;\n\tpoint = ro;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n\t{\n\t\t//check how far the point is from the nearest surface\n\t\tfloat dist = distFunc(point);\n\t\t//if we are very close\n\t\tif(epsilon > dist)\n\t\t{\n\t\t\tobjectHit = true;\n\t\t\tbreak;\n\t\t}\n\t\t//not so close -> we can step at least dist without hitting anything\n\t\tt += dist;\n\t\t// return immediately if maximum t is reached\n\t\tif(t > maxT)\n\t\t{\n\t\t\tobjectHit = false;\n\t\t\treturn maxT;\n\t\t}\n\t\t//calculate new point\n\t\tpoint = ro + t * rd;\n\t}\n\n\treturn t;\n}\n\nvoid populateSoundArray()\n{\n    // Get FFT values from texture\n    for (int i = 0; i < afFrequencies.length(); i++)\n    {\n        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.25) ).x;\n    }\n}\n\nconst int reflectionBounces = 1;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fill arrays for sound things\n    populateSoundArray();\n    \n\t//\tSet up Camera\n\tvec3 camP = calcCameraPos(); // Camera position\n\n\t//\tMove camera in a circle\n\tcamP += vec3(5.0*cos(iTime*0.25), 1.5*cos(iTime*0.2)+2.5,  5.0*sin(iTime*0.25));\n\n\t//\tAlways look at center\n\tvec3 target = vec3(0.0);\n\tmat3 cameraMatrix = setCamera( camP, target, 0.0 );\n\tvec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n\tvec3 camDir = cameraMatrix * normalize( vec3(p.xy, 2.0) );\n\n\t//\tSet up ray\n\tvec3 point;\t\t// Set in trace()\n\tbool objectHit;\t// Set in trace()\n\n\t//\tInitialize color\n\tvec3 color = vec3(0.0);\n\n\tfloat t = trace(camP, camDir, point, objectHit);\n\tif(objectHit)\n\t{\n\t\t//\tLighting calculations\n\t\tvec3 normal = getNormal(point);\n\t\tcolor = getShadedColor( point, normal, camP );\n\n\t\t//\tReflections\n\t\tfor(int i = 0; i < reflectionBounces; i++)\n\t\t{\n\t\t\tvec3 pointRef;\t// Set in trace()\n\t\t\tcamDir = reflect(camDir, normal);\n\t\t\ttrace(point + camDir*0.001, camDir, pointRef, objectHit);\n\t\t\tif(objectHit)\n\t\t\t{\n\t\t\t\t// Get color of reflection\n\t\t\t\tcolor += 0.1 * getShadedColor( pointRef, getNormal(pointRef), point );\n\t\t\t}\n\t\t\tpoint = pointRef;\n\t\t}\n\t}\n\n\t//\tfog\n\tvec3 fogColor = vec3( 0.1, 0.3, 0.8);\n\tfloat FogDensity = 0.005;\n\tfloat fogFactor = 1.0 /exp(t * FogDensity);\n\tfogFactor = clamp( fogFactor, 0.0, 1.0 );\n\tcolor = mix(fogColor, color, fogFactor);\n\n\tfragColor = vec4(color, clamp((t-6.0)/15.0, 0.0, 1.0));\n}", "image_inputs": [{"id": 32222, "src": "https://soundcloud.com/cristi-covlea/trance-uplifting-progressive-all-time-favorites-minibyte-2022-vol-2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 149, 201, 201, 375], [487, 487, 507, 507, 542], [543, 543, 571, 571, 652], [653, 653, 678, 678, 693], [695, 808, 858, 858, 1249], [1489, 1489, 1511, 1511, 1557], [1558, 1558, 1598, 1598, 1640], [1641, 1641, 1708, 1708, 1988], [2152, 2152, 2222, 2222, 2453], [2455, 2510, 2540, 2555, 3181], [3183, 3183, 3214, 3221, 3410], [3412, 3412, 3447, 3463, 3828], [3830, 3830, 3919, 3919, 4152], [4154, 4154, 4216, 4216, 4435], [4548, 4548, 4623, 4661, 6601], [6684, 6684, 6751, 6751, 7261], [7263, 7263, 7290, 7325, 7495], [7530, 7530, 7587, 7623, 8999]], "test": "untested"}
{"id": "sltyz7", "name": "paint state test 1", "author": "NEAR_DREAM_UNITY", "description": "    Restart | Backspace  -- Clear the canvas, reset CC to White.\n    W / Q                -- Set CC to White / Black.\n    R / E                -- Set CC to Red / Turquoise.\n    G / F                -- Set CC to Green / Purple.\n    B / V                -- ", "tags": ["paintstatetest1"], "likes": 3, "viewed": 177, "published": 3, "date": "1675568702", "time_retrieved": "2024-07-30T18:12:04.478540", "image_code": "/*\n    Restart | Backspace  -- Clear the canvas, reset CC to White.\n    W / Q                -- Set CC to White / Black.\n    R / E                -- Set CC to Red / Turquoise.\n    G / F                -- Set CC to Green / Purple.\n    B / V                -- Set CC to Blue / Vomit.\n    Mouse Drag           -- Paint.\n*/\n\n\nvoid  mainImage  (out vec4 o, vec2 p) {\n    o = texelFetch(iChannel0, ivec2(p), 0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define  iMouse_down  (iMouse.z > 0.)\n#define  onKey(K)     (texelFetch(iChannel1, ivec2((K), 1), 0).x > 0.)\n#define  CC           vec3(texelFetch(iChannel0, ivec2(0, 0), 0))\n\n#define  C_W  vec3(0.1)\n#define  C_R  vec3(0.3, 0., 0.)\n#define  C_G  vec3(0., 0.15, 0.)\n#define  C_B  vec3(0., 0., 0.35)\n\n\nvec3  Paint  (float dist) {\n    return max(0., 0.002 * (40. - dist)) * CC;\n}\n\n\nvoid  mainImage  (out vec4 o, vec2 p) {\n    o = texelFetch(iChannel0, ivec2(p), 0);\n    bool reset = iFrame < 20 || onKey(8);\n    bool store_CC = p.x == 0.5 && p.y == 0.5;\n    bool view_CC = p.x < 20. && p.y < 20.;\n\n    if (store_CC) {\n        if (reset)      o = vec4(C_W, 1.);\n        if (onKey(87))  o = vec4(C_W, 1.);\n        if (onKey(81))  o = vec4(-C_W, 1.);\n        if (onKey(82))  o = vec4(C_R, 1.);\n        if (onKey(69))  o = vec4(-C_R, 1.);\n        if (onKey(71))  o = vec4(C_G, 1.);\n        if (onKey(70))  o = vec4(-C_G, 1.);\n        if (onKey(66))  o = vec4(C_B, 1.);\n        if (onKey(86))  o = vec4(-C_B, 1.);\n    } else if (view_CC) {\n        o = vec4(0.5 + 8888. * CC, 1.);\n    } else {\n\n        if (reset) {\n            o = vec4(0.5, 0.5, 0.5, 1.);\n            return;\n        }\n        \n        if (iMouse_down) {\n            float dist = length(iMouse.xy - p);\n            o += vec4(Paint(dist), 0.);\n        }\n        \n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 361, 361, 407]], "test": "untested"}
{"id": "sltfz7", "name": "Bouncing Balls Test 1", "author": "NEAR_DREAM_UNITY", "description": "Bouncing Balls Test 1", "tags": ["balls", "bouncing"], "likes": 2, "viewed": 192, "published": 3, "date": "1675568621", "time_retrieved": "2024-07-30T18:12:05.232523", "image_code": "\n\nvoid  mainImage  (out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.y;\n\n    float v = 0.;\n    for (int ball = 0; ball < TotalBalls; ball++) {\n        vec4 data = BallData(ball);\n        float tocore = 1. - length(uv - data.Position) / BallRadius;\n        if (tocore >= 0.)\n            v = max(v, tocore);\n    }\n    \n    color.rgb = vec3(1. - pow(v, 0.4));\n    color.g = 0.5 + 0.5 * color.g;\n    color.a = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define  TotalBalls      (50)\n#define  BallRadius      (0.03)\n#define  TemporalAA      (8)\n#define  Gravity         vec2(0., -0.00006)\n#define  BounceIn        (0.12)\n#define  BounceOut       (0.1)\n\n#define  Tau             (6.283185307179586476925286766559)\n#define  IsDataPoint(P)  ((P).y == 0 && (P).x < TotalBalls)\n#define  Init            (iFrame < 50)\n#define  AspectRatio     (iResolution.x / iResolution.y)\n#define  AspectGap       ((AspectRatio - 1.) / 2.)\n#define  IC0(P)          (texelFetch(iChannel0, (P), 0))\n#define  BallData(B)     IC0(ivec2((B), 0))\n#define  Position        xy\n#define  Velocity        zw\n", "buffer_a_code": "\n\n\nvoid  mainImage  (out vec4 data, vec2 addr_float) {\n    ivec2 addr = ivec2(addr_float);\n    if (!IsDataPoint(addr))\n        discard;\n\n    data = IC0(addr);\n    if (Init) {\n        float progress = pow(0.2 + 0.7 * float(addr.x) / float(TotalBalls), 1.8);\n        data.Position.x = 0.5 + 0.4 * (1.1 - progress) * -cos(22. * progress) + AspectGap;\n        data.Position.y = 0.5 + 0.4 * (1.1 - progress) * sin(22. * progress);\n        data.Velocity = vec2(0.);\n    }\n    \n    for (int i = 0; i < TemporalAA; i++) {\n    \n        for (int ball2 = 0; ball2 < TotalBalls; ball2++) if (addr.x != ball2) {\n            \n            vec4 data2 = BallData(ball2);\n            \n            vec2 ball_out_n = data.Position - data2.Position;\n            float ball_out_l = length(ball_out_n);\n            ball_out_n /= ball_out_l;\n            ball_out_l = 2. * BallRadius - ball_out_l;\n            \n            if (ball_out_l > 0.)\n                data.Velocity += ball_out_n * ball_out_l * BounceIn;\n        }\n        \n        float floor_inter = BallRadius - data.Position.y;\n        if (floor_inter > 0.)\n            data.Velocity.y += floor_inter * (\n                data.Velocity.y < 0. ? BounceIn : BounceOut\n            );\n        \n        data.Velocity += Gravity;\n    \n        data.Position += data.Velocity;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 49, 49, 426]], "test": "untested"}
{"id": "dtBSRz", "name": "Voxel fractal", "author": "michael0884", "description": "Hmm, idk just random thing I decided to do. WASD QE and mouse to move", "tags": ["camera"], "likes": 45, "viewed": 951, "published": 3, "date": "1675567231", "time_retrieved": "2024-07-30T18:12:06.422342", "image_code": "#define exposure 1.0\n#define sqrexposure 0.5\n#define gamma 1.3\n#define bloom 0.3\n\nvec3 expose(vec3 c)\n{\n    return 1.0 - exp(-exposure*(1.0+sqrexposure*c)*c);\n}\n\nvec3 saturate(vec3 c)\n{\n    return pow(expose(c),vec3(1.0/gamma));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 convol = texture(iChannel1, 0.5*fragCoord/iResolution.xy);\n    \n    vec3 col = 1.0*acc.xyz + bloom*convol.xyz;\n\n    fragColor = vec4(saturate(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 8.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp =  vec3(6,6,5);\n        ca = aa2q( normalize(vec3(-0.1,1,-0.2)), 1.15);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(1,0.8,-0.6));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxzz)) * \n           vec4(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y),cos(TWO_PI * Z.w),sin(TWO_PI * Z.w));\n}\n\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n//The first 8 columns of the U matrix: \nfloat U[1016] = float[](-1.1842E-07, -1.1268E-06, -1.8904E-06, -3.1583E-06, -5.3096E-06, -1.0118E-05, -1.4520E-05, -1.9462E-05, -2.0183E-05, -2.6224E-05, -3.1880E-05, -4.3602E-05, -5.1091E-05, -5.1760E-05, -6.1062E-05, -7.6017E-05, -9.4007E-05, -1.1207E-04, -1.2179E-04, -1.5626E-04, -1.4159E-04, -1.6448E-04, -1.8274E-04, -2.9349E-04, -3.4950E-04, -4.4876E-04, -7.0126E-04, -6.1299E-04, -5.3111E-04, -4.6782E-04, -3.9730E-04, -4.1987E-04, -4.1421E-04, -3.5734E-04, -5.5319E-04, -5.8685E-04, -6.3378E-04, -6.1371E-04, -7.0697E-04, -5.2489E-04, -7.3274E-04, -7.7262E-04, -1.1158E-03, -9.6932E-04, -1.1427E-03, -9.4501E-04, -1.3424E-03, -1.7172E-03, -2.2912E-03, -2.3970E-03, -2.0727E-03, -2.3740E-03, -2.8899E-03, -4.7924E-03, -6.1480E-03, -7.9435E-03, -5.8779E-03, -1.0120E-02, -1.0679E-02, -2.6083E-02, -3.9506E-02, -6.9328E-02, -1.2810E-01, -5.3082E-01, -7.8470E-01, -2.6500E-01, -7.7895E-02, -3.6887E-02, -2.0966E-02, -1.0654E-02, -1.1517E-02, -9.3575E-03, -8.7508E-03, -5.6306E-03, -3.8273E-03, -2.2770E-03, -3.1324E-03, -2.6593E-03, -2.6659E-03, -2.0236E-03, -1.3645E-03, -1.0555E-03, -1.1805E-03, -1.2382E-03, -1.0703E-03, -9.4232E-04, -5.7082E-04, -6.9208E-04, -5.0356E-04, -7.2157E-04, -6.0580E-04, -6.6006E-04, -4.1296E-04, -4.8194E-04, -3.4413E-04, -4.1653E-04, -3.7708E-04, -3.3201E-04, -4.1427E-04, -3.6365E-04, -6.6114E-04, -4.0746E-04, -5.8100E-04, -2.9378E-04, -2.4748E-04, -1.5735E-04, -1.6160E-04, -1.5220E-04, -1.2811E-04, -1.1806E-04, -8.5893E-05, -8.3745E-05, -5.9893E-05, -8.0787E-05, -4.2347E-05, -4.4772E-05, -2.7607E-05, -2.6821E-05, -1.7801E-05, -2.0396E-05, -1.3303E-05, -7.9177E-06, -5.3451E-06, -3.1342E-06, -1.6786E-06, -7.0085E-07, -1.1687E-07, 1.4463E-07, 1.4833E-06, 1.6108E-05, 1.8564E-05, 3.3743E-05, 3.4312E-05, 5.5497E-05, 4.9054E-05, 7.6169E-05, 9.2412E-05, 1.3336E-04, 1.2618E-04, 2.2849E-04, 2.4331E-04, 2.4988E-04, 2.8219E-04, 2.3151E-04, 3.9522E-04, 5.5677E-04, 6.3214E-04, 7.5057E-04, 8.8708E-04, 9.0286E-04, 1.9325E-03, 1.6495E-03, 9.2766E-04, -4.7289E-04, 2.5727E-04, 1.3712E-03, 3.3028E-03, 2.6754E-03, 2.1479E-03, 1.9157E-03, 1.8775E-03, 1.8521E-03, 1.5187E-03, 2.1556E-03, 2.0944E-03, 1.8656E-03, 2.3806E-03, 3.0628E-03, 2.9234E-03, 3.7553E-03, 3.5235E-03, 3.8380E-03, 3.0398E-03, 4.6163E-03, 6.2841E-03, 8.7218E-03, 9.3776E-03, 8.4922E-03, 9.3318E-03, 1.1138E-02, 2.1680E-02, 2.7147E-02, 3.8475E-02, 3.1002E-02, 6.5136E-02, 5.9308E-02, 1.8594E-01, 2.9989E-01, 5.3655E-01, 3.1424E-01, -3.3517E-01, -1.6647E-02, 1.5694E-01, 4.7189E-01, 2.7447E-01, 1.5780E-01, 7.5950E-02, 7.2050E-02, 4.9178E-02, 4.0426E-02, 2.5631E-02, 1.7025E-02, 9.8987E-03, 1.2105E-02, 1.0120E-02, 1.0654E-02, 7.0982E-03, 4.9285E-03, 3.3771E-03, 4.0624E-03, 4.3698E-03, 4.0031E-03, 3.2964E-03, 2.1512E-03, 3.0137E-03, 1.9981E-03, 2.9746E-03, 1.8669E-03, 1.2566E-03, 1.3391E-03, 1.8105E-03, 1.9485E-03, 1.8028E-03, 1.9581E-03, 1.8266E-03, 3.3485E-03, 1.1361E-03, 1.4591E-04, 5.6091E-04, 3.8344E-04, 1.3298E-03, 2.1011E-03, 8.2035E-04, 8.8784E-04, 7.7448E-04, 5.4267E-04, 4.3268E-04, 2.6727E-04, 2.6458E-04, 1.9542E-04, 2.1589E-04, 2.1453E-04, 2.2156E-04, 1.1407E-04, 1.0476E-04, 8.0254E-05, 7.2416E-05, 5.3804E-05, 3.4371E-05, 2.2517E-05, 1.4718E-05, 1.2217E-05, 4.6752E-06, 4.5840E-07, -1.3986E-07, 1.4055E-06, 7.1329E-06, 7.3636E-06, 2.2637E-05, 2.5255E-05, 3.9108E-05, 4.0821E-05, 4.7760E-05, 1.5074E-05, 4.8742E-05, 8.5952E-05, 1.6267E-04, 1.6654E-04, -6.2004E-06, 2.0443E-04, 2.9354E-04, 3.3853E-04, 1.7896E-04, 2.0102E-04, 4.4367E-04, 6.9715E-04, 5.7989E-04, 9.7945E-04, 3.7509E-04, -6.4461E-04, 1.5830E-03, 5.5595E-04, -6.8815E-04, 1.3470E-03, 1.5266E-03, 1.5022E-03, 1.5055E-03, 1.2135E-03, 1.1252E-03, 9.0971E-04, 4.4536E-05, 9.7942E-04, 1.9424E-03, 1.6564E-03, 1.6649E-03, 2.2395E-03, 3.3719E-03, 2.6467E-03, 2.9967E-03, 2.0581E-03, 1.9493E-03, 4.2649E-03, 7.0853E-03, 6.2122E-03, 5.1677E-03, 5.3765E-03, 5.1721E-03, 1.3677E-02, 2.2610E-02, 2.7237E-02, 1.5351E-02, 4.5004E-02, 3.1812E-02, 1.1541E-01, 1.7171E-01, 2.0486E-01, -6.0355E-01, 1.2002E-01, 1.7822E-01, -6.5902E-01, 2.0725E-01, 8.1584E-02, 9.1843E-02, 4.5420E-02, 4.9064E-02, 3.2752E-02, 3.4261E-02, 1.7524E-02, 1.1157E-02, 5.8959E-03, 8.4160E-03, 7.1582E-03, 8.5606E-03, 4.3777E-03, 2.5106E-03, 2.4818E-03, 2.3451E-03, 3.0409E-03, 2.9541E-03, 1.4197E-03, 1.3194E-03, 2.2430E-03, 1.1572E-03, 7.8224E-04, 1.4828E-03, 1.5843E-03, 8.0175E-04, 1.8164E-04, 1.0363E-03, 1.2883E-03, 1.7222E-03, 1.2470E-03, 1.5805E-03, 1.5452E-04, -2.0298E-05, 3.1041E-04, -5.9129E-04, 4.1049E-04, 9.5067E-04, 4.9391E-04, 6.8072E-04, 5.3541E-04, 3.6504E-04, 4.5690E-04, 9.7131E-05, 1.5461E-06, 1.4411E-04, 1.8709E-04, 1.2732E-04, 1.0275E-04, 3.7932E-05, 7.2567E-05, 4.9384E-05, 7.2063E-05, 1.1900E-05, 1.4089E-05, 9.5806E-06, 1.0888E-05, 7.1190E-06, 2.1145E-06, -2.8481E-07, -2.0808E-07, -1.1441E-06, 2.6323E-06, -2.2197E-05, -9.6269E-05, -7.6502E-05, -1.1998E-04, -1.3400E-04, -1.3794E-04, -1.9616E-04, -2.7960E-04, -2.7116E-04, -4.3342E-04, -4.4178E-04, -5.2718E-04, -5.4154E-04, -6.9522E-04, -1.0287E-03, -1.2396E-03, -1.4470E-03, -2.0271E-03, -2.4781E-03, -2.2805E-03, -8.0694E-04, -3.1239E-04, -1.2126E-03, -6.9329E-04, -1.0721E-03, -1.0577E-03, -5.6391E-04, -3.3837E-03, -5.0182E-03, -6.2891E-03, -3.4780E-03, -4.5980E-03, -4.6762E-03, -5.0195E-03, -5.3199E-03, -5.0057E-03, -4.1086E-03, -7.3481E-03, -7.6870E-03, -9.1904E-03, -8.5119E-03, -1.0481E-02, -8.9974E-03, -1.3308E-02, -1.6309E-02, -2.0217E-02, -2.3409E-02, -2.4379E-02, -2.9541E-02, -3.3726E-02, -5.9753E-02, -6.8949E-02, -1.2552E-01, -9.1361E-02, -2.4857E-01, -1.9051E-01, -4.9997E-01, 6.9002E-02, 2.5769E-01, -5.9676E-02, 1.2377E-01, -8.8209E-02, 1.2719E-02, 3.4866E-01, -2.1607E-02, -4.7137E-01, -2.5582E-01, -2.4290E-01, -1.4195E-01, -1.1893E-01, -7.3712E-02, -5.9086E-02, -2.8825E-02, -3.7095E-02, -2.5824E-02, -2.6522E-02, -1.8905E-02, -1.2832E-02, -1.0055E-02, -1.1751E-02, -1.0168E-02, -9.5540E-03, -8.4060E-03, -6.1575E-03, -6.9206E-03, -4.5594E-03, -4.8506E-03, -4.8827E-03, -4.0758E-03, -3.8925E-03, -3.4163E-03, -4.9951E-03, -4.4902E-03, -6.6062E-03, -3.4508E-03, -1.8571E-04, -1.4733E-03, -8.4898E-04, -1.3663E-03, -9.8791E-04, -6.2882E-04, 1.4457E-05, -2.5731E-03, -2.7623E-03, -1.9252E-03, -1.3962E-03, -1.1285E-03, -7.6226E-04, -7.4392E-04, -5.2286E-04, -3.3325E-04, -4.9703E-04, -3.7282E-04, -2.5934E-04, -2.0216E-04, -1.6318E-04, -1.1700E-04, -1.0089E-04, -8.4809E-05, -6.0893E-05, -3.8105E-05, -1.4640E-05, -1.1315E-06, 1.0142E-07, -5.6986E-09, 4.5482E-06, 1.1972E-05, 9.7439E-06, -8.2800E-06, 6.8823E-05, 1.9695E-04, 2.0334E-04, 2.9505E-04, 3.0152E-04, 4.0002E-04, 4.1516E-04, 5.1860E-04, 5.4109E-04, 7.3302E-04, 9.5887E-04, 1.1809E-03, 1.5416E-03, 1.9864E-03, 2.6092E-03, 3.4977E-03, 2.3385E-04, 3.4315E-04, 7.4666E-04, 1.4387E-03, 2.1693E-03, 1.2732E-03, 2.1410E-03, 2.1069E-03, 2.6995E-03, 1.7910E-03, -6.6255E-05, 3.7772E-03, 4.4252E-03, 8.6983E-03, 7.5941E-03, 8.2457E-03, 7.8083E-03, 7.1344E-03, 6.0625E-03, 5.9307E-03, 8.2654E-03, 1.4955E-02, 1.2896E-02, 1.5264E-02, 1.2642E-02, 1.6662E-02, 2.2948E-02, 3.6684E-02, 4.0494E-02, 3.6111E-02, 5.2751E-02, 5.1962E-02, 1.1070E-01, 1.4511E-01, 2.7768E-01, 1.6304E-01, 4.3346E-01, 2.5565E-02, -3.2357E-01, -8.2099E-02, 8.9262E-03, 3.5360E-02, -9.4649E-02, 7.3490E-02, -4.9100E-02, 6.3324E-03, 2.3862E-02, -4.5834E-01, -5.4193E-02, 3.6193E-01, 2.7427E-01, 2.6304E-01, 1.3232E-01, 1.1203E-01, 5.1831E-02, 6.5850E-02, 4.5660E-02, 4.3296E-02, 2.9091E-02, 2.0250E-02, 1.6593E-02, 1.6724E-02, 1.6259E-02, 1.5814E-02, 1.1095E-02, 6.6219E-03, 6.5643E-03, 6.6001E-03, 7.6387E-03, 6.3453E-03, 6.0779E-03, 7.3917E-03, 6.0495E-03, 8.1008E-03, 4.8710E-03, 2.1384E-05, 1.4095E-03, 2.3949E-03, 2.0756E-03, 1.7863E-03, 1.8432E-03, 1.6779E-03, 1.5548E-03, 1.0560E-03, -6.5864E-04, -9.9490E-04, 1.7738E-03, 2.9236E-03, 2.1578E-03, 1.3039E-03, 1.1549E-03, 7.8047E-04, 7.3195E-04, 5.1827E-04, 3.3413E-04, 3.2212E-04, 2.6121E-04, 2.5788E-04, 2.2388E-04, 2.0696E-04, 1.0483E-04, 6.3773E-05, 2.4840E-06, -5.7251E-06, 2.1219E-06, 1.5386E-07, -1.9325E-07, -3.3843E-06, -1.6232E-05, -3.5978E-05, -5.4628E-05, -5.2994E-05, -6.6725E-05, -2.2568E-04, -4.4814E-04, -4.2902E-04, -7.0873E-04, -6.3746E-04, -1.0746E-03, -1.3314E-03, -9.6957E-04, -1.7371E-03, -2.4332E-03, -2.8118E-03, -3.6241E-03, -1.1888E-03, 2.1266E-03, -1.1036E-03, -1.3934E-03, -2.5291E-03, -2.4587E-03, -2.8037E-03, -2.2383E-03, -3.5312E-03, -3.6468E-03, -3.1406E-03, -3.2082E-03, -4.8709E-03, 3.7874E-04, -1.8714E-03, -4.4649E-03, -1.2736E-02, -1.4626E-02, -1.4508E-02, -1.4339E-02, -1.3506E-02, -1.9189E-02, -1.9148E-02, -2.0512E-02, -2.3396E-02, -3.1659E-02, -2.9315E-02, -4.2450E-02, -4.8158E-02, -5.7996E-02, -9.0616E-02, -8.7779E-02, -1.3413E-01, -1.3095E-01, -2.3123E-01, -2.1518E-01, -3.8294E-01, -4.7607E-02, 4.6165E-01, 7.0595E-02, 1.8216E-02, 5.8674E-02, -2.4327E-02, -2.5407E-02, 9.4394E-02, -7.6313E-02, 4.3834E-02, 6.2640E-02, -1.2994E-02, -6.6501E-02, 4.5464E-02, 3.8608E-01, 8.6325E-02, -2.8019E-01, -2.3640E-01, -2.7927E-01, -1.1657E-01, -1.6194E-01, -9.4289E-02, -9.1289E-02, -6.2279E-02, -4.3740E-02, -3.3795E-02, -3.6711E-02, -2.8607E-02, -2.5586E-02, -2.1220E-02, -1.4112E-02, -1.7727E-02, -1.2365E-02, -1.3160E-02, -1.4973E-02, -1.3335E-02, -1.1514E-02, -9.9264E-03, 1.3642E-03, -1.9429E-03, -4.1643E-03, -2.9805E-03, -2.6087E-03, -2.8601E-03, -2.9031E-03, -2.5890E-03, -2.9460E-03, -1.7891E-03, -1.8489E-03, -1.3324E-03, -1.6377E-03, 1.0290E-03, 4.6797E-04, -2.6960E-03, -2.3670E-03, -2.7855E-03, -1.4945E-03, -1.3426E-03, -9.2186E-04, -9.5868E-04, -4.4823E-04, -5.3964E-04, -3.6392E-04, -3.3482E-04, -1.4800E-04, -8.9772E-05, 5.6629E-06, -2.8370E-05, -1.8058E-05, -3.5979E-06, 8.7336E-08, -1.4846E-07, -7.6951E-07, 1.0130E-05, 2.7537E-05, 3.4182E-05, 2.6285E-05, 3.6084E-05, 3.1324E-05, -8.4586E-05, 7.3620E-05, 3.2184E-04, 2.9374E-04, 4.1289E-04, 3.8378E-04, 5.9049E-04, 7.2917E-04, 4.9481E-04, 5.1693E-04, -4.1205E-06, -4.6489E-04, -5.5999E-04, 4.2064E-03, 9.7307E-04, -1.2896E-03, 2.0495E-03, 9.6883E-04, 8.8919E-04, 1.0859E-03, 1.5529E-03, 4.0707E-03, -2.4763E-03, 1.5676E-03, 8.3307E-03, 3.6040E-03, -1.4926E-03, 2.5850E-03, 4.6116E-03, 4.9138E-03, 7.9128E-03, 5.7110E-03, 8.7634E-03, 9.4021E-03, 1.0801E-02, 1.0315E-02, 1.7466E-02, 1.8266E-02, 2.0595E-02, 3.0293E-02, 2.5627E-02, 3.0977E-02, 2.8452E-02, 5.1451E-02, 3.6071E-02, 4.8361E-02, -1.4958E-02, -1.5883E-01, -5.8910E-02, -5.6192E-02, 9.7888E-02, 3.1809E-01, -5.3469E-01, -3.6185E-02, 6.5131E-02, 8.9556E-03, 1.5256E-02, -1.0577E-01, 1.6840E-01, 3.5046E-01, -4.3787E-01, 3.8137E-01, -4.2987E-02, -1.6431E-01, -1.2289E-01, 2.4638E-02, 3.1976E-02, 2.9520E-02, 5.2585E-02, 2.2756E-02, 3.6097E-02, 3.7465E-02, 1.9496E-02, 1.8912E-02, 2.1733E-02, 1.1341E-02, 1.1243E-02, 1.3835E-02, 9.5422E-03, 6.6832E-03, 6.4901E-03, 7.5146E-03, 6.1211E-03, 5.7607E-03, 1.3228E-03, 3.6667E-03, 3.3190E-04, -1.4869E-03, 6.5831E-03, 3.2047E-03, -4.6947E-04, 1.2519E-03, 7.8573E-04, 4.7969E-05, 1.4014E-03, 9.6334E-04, 1.7361E-03, 9.4349E-04, 1.9203E-04, 2.2358E-03, 2.2370E-04, -4.6138E-04, 1.3741E-05, 5.1833E-04, 2.8487E-04, 3.5370E-04, 3.0995E-04, 5.4557E-04, 1.9191E-04, 2.1404E-04, 8.0855E-05, 7.6876E-05, -1.6503E-06, 1.7532E-05, 3.0436E-05, 4.0315E-05, -1.9764E-05, 2.8286E-07, 4.2190E-07, 1.0808E-07, -8.8005E-06, -2.4938E-05, -5.4878E-05, -9.3547E-05, -1.5711E-04, -1.8324E-04, -2.0489E-04, -6.7677E-05, -7.1627E-04, -1.0888E-03, -1.3584E-03, -2.5041E-03, -2.3521E-03, -2.4585E-03, -2.9089E-03, -2.4915E-03, -4.8879E-04, 1.5836E-03, -8.3815E-04, -2.8598E-03, -2.1934E-03, -2.8042E-03, -4.3956E-03, -3.0688E-03, -4.2693E-03, -2.5438E-03, -3.7542E-03, -2.3067E-03, -5.2950E-03, -7.9212E-03, -7.6980E-03, -8.0600E-03, -7.5677E-03, -6.8961E-03, -5.1231E-03, -1.5650E-02, -2.0023E-02, -2.5566E-02, -2.3810E-02, -3.2229E-02, -3.5659E-02, -4.9800E-02, -4.7440E-02, -5.7319E-02, -5.7981E-02, -8.1028E-02, -9.9538E-02, -1.4565E-01, -2.0783E-01, -1.7831E-01, -2.6517E-01, -1.7910E-01, -1.5650E-01, -5.2811E-02, 4.4968E-01, 7.3049E-02, -8.2157E-02, 1.9113E-03, 1.0139E-01, -2.1165E-01, 1.4336E-02, -1.5300E-02, 1.1079E-01, -8.8319E-02, 2.5443E-02, 1.1459E-01, 7.5825E-02, -1.1198E-02, 7.5323E-02, -9.7695E-02, 5.6158E-02, 3.5723E-01, 7.0282E-02, -1.8135E-01, -1.3712E-01, -3.1946E-01, -1.9152E-01, -2.0738E-01, -1.2991E-01, -8.9762E-02, -6.7066E-02, -7.8146E-02, -5.5899E-02, -4.8227E-02, -4.1727E-02, -2.8759E-02, -3.9586E-02, -2.5691E-02, -2.8319E-02, -2.1719E-02, -1.5658E-02, -7.8352E-04, -5.7691E-03, -7.3061E-03, -1.0447E-02, -6.7558E-03, -5.3028E-03, -4.5919E-03, -3.5752E-03, -3.3239E-03, -3.3586E-03, -3.3679E-03, -3.3443E-03, -3.5184E-03, -1.6000E-03, -2.7235E-03, -2.2023E-03, -2.1572E-03, 1.2605E-03, 1.1386E-04, -2.0115E-03, -1.4996E-03, -2.6276E-03, -1.6889E-03, -2.0676E-03, -9.9676E-04, -9.8083E-04, -3.3572E-04, -2.1569E-04, -9.3434E-05, -1.2168E-04, -1.2691E-04, -5.9581E-05, -3.6944E-05, -2.0024E-06, 2.2023E-07); \n//The first 8 rows of the V matrix: \nfloat V[1016] = float[](-4.0560E-08, -4.0626E-07, -1.1689E-06, -2.4232E-06, -4.3205E-06, -7.3371E-06, -1.0366E-05, -1.3283E-05, -1.7876E-05, -2.6661E-05, -4.1659E-05, -3.7289E-05, -4.5122E-05, -5.0932E-05, -6.2483E-05, -6.6529E-05, -7.8474E-05, -8.9704E-05, -1.0291E-04, -1.2136E-04, -1.3834E-04, -1.4896E-04, -1.6407E-04, -1.8326E-04, -2.0360E-04, -2.2313E-04, -2.5784E-04, -2.7722E-04, -2.9957E-04, -3.0073E-04, -3.5880E-04, -3.8183E-04, -4.2341E-04, -4.6552E-04, -4.9116E-04, -5.2448E-04, -5.5809E-04, -5.9667E-04, -6.6199E-04, -7.1234E-04, -8.1250E-04, -8.3600E-04, -8.8302E-04, -9.2638E-04, -9.9054E-04, -1.1231E-03, -1.2340E-03, -1.3622E-03, -1.4120E-03, -1.5422E-03, -1.6289E-03, -1.7860E-03, -2.0306E-03, -2.2738E-03, -2.5888E-03, -2.7894E-03, -3.1568E-03, -3.6229E-03, -4.3806E-03, -5.6031E-03, -7.4077E-03, -1.0911E-02, -1.8938E-02, -8.6403E-02, -5.4678E-02, -1.6337E-02, -8.9915E-03, -6.7426E-03, -4.7868E-03, -3.8112E-03, -3.0963E-03, -2.6013E-03, -2.2945E-03, -2.0145E-03, -1.8253E-03, -1.5518E-03, -1.3632E-03, -1.2085E-03, -1.0664E-03, -9.9345E-04, -9.2006E-04, -8.4078E-04, -7.3407E-04, -6.7189E-04, -5.9277E-04, -5.2788E-04, -4.8632E-04, -4.5249E-04, -4.1273E-04, -3.5942E-04, -3.0702E-04, -2.7333E-04, -2.4229E-04, -2.2360E-04, -2.2654E-04, -2.1787E-04, -1.8650E-04, -1.5961E-04, -1.2435E-04, -1.0093E-04, -9.1354E-05, -1.0207E-04, -1.1099E-04, -1.0006E-04, -7.8609E-05, -4.9727E-05, -2.7173E-05, -2.2453E-05, -4.1255E-05, -4.6027E-05, -4.4826E-05, -3.8845E-05, -3.0548E-05, -1.3839E-05, -8.4681E-06, -1.3893E-05, -1.9984E-05, -2.6732E-05, -1.8135E-05, -9.8111E-06, -5.6260E-06, -3.4386E-06, -2.6902E-06, -1.8443E-06, -1.1458E-06, -4.6849E-07, -4.8747E-08, 4.1427E-09, 5.9485E-08, 2.0293E-07, 5.7744E-07, 9.0135E-07, 1.5350E-06, 3.2825E-06, 4.6007E-06, 1.2256E-05, 8.9220E-06, 5.7461E-06, 2.1317E-05, 1.6463E-05, 1.4172E-05, 8.7154E-06, 9.4366E-06, 1.0454E-05, 1.3281E-05, 1.6115E-05, 1.5910E-05, 1.5213E-05, 1.7335E-05, 2.3464E-05, 3.1168E-05, 2.5219E-05, 3.5207E-05, 3.6268E-05, 3.4441E-05, 3.1270E-05, 3.9408E-05, 4.6559E-05, 6.5493E-05, 5.5330E-05, 5.2947E-05, 5.5559E-05, 5.4084E-05, 5.9614E-05, 7.3723E-05, 6.7721E-05, 8.4431E-05, 9.0909E-05, 9.6004E-05, 1.1774E-04, 1.0265E-04, 9.2233E-05, 1.8103E-04, 1.4747E-04, 1.6374E-04, 1.5485E-04, 1.8228E-04, 1.9271E-04, 2.1377E-04, 2.1836E-04, 2.8028E-04, 3.4087E-04, 3.6097E-04, 5.0177E-04, 5.3661E-04, 8.9624E-04, 1.2516E-03, 2.4144E-03, 5.4027E-03, 1.3699E-02, -9.3176E-03, 3.5201E-03, 1.1839E-02, 3.7789E-03, 2.2072E-03, 1.0589E-03, 7.5203E-04, 5.1982E-04, 3.8439E-04, 3.6807E-04, 2.1326E-04, 2.5739E-04, 1.7986E-04, 2.0018E-04, 1.6147E-04, 1.2687E-04, 1.3974E-04, 9.3867E-05, 1.4961E-04, 1.1497E-04, 7.5357E-05, 9.0043E-05, 1.1637E-04, 6.8140E-05, 6.1853E-05, 6.1711E-05, 4.7506E-05, 4.8748E-05, 3.9391E-05, 2.6394E-05, 3.7103E-05, 3.8543E-05, 4.6716E-05, 5.0372E-05, 2.5778E-05, 2.8452E-05, 3.8910E-05, 2.4848E-05, 3.2436E-05, 2.4689E-05, 1.6132E-05, 2.6167E-05, 1.7047E-05, 1.2978E-05, 1.2913E-05, 1.0396E-05, 1.1761E-05, 9.1684E-06, 9.6291E-06, 6.8819E-06, 9.2066E-06, 1.1444E-05, 1.5092E-05, 1.6623E-05, 7.0725E-07, 1.1172E-05, 7.9277E-06, 3.7846E-06, 1.7605E-06, 9.9582E-07, 6.0473E-07, 2.7266E-07, 6.7569E-08, 4.3727E-09, 1.0404E-10, 1.2425E-08, 9.5860E-08, 2.4460E-07, 4.1698E-07, 2.8869E-07, 1.5672E-06, 2.5742E-06, 5.2553E-06, -9.6782E-06, 1.3490E-07, 2.2464E-06, 7.5401E-06, 8.0906E-06, 6.2611E-06, 9.1561E-06, 6.0188E-06, 5.9844E-06, 7.0737E-06, 5.0778E-06, 1.3088E-05, 1.0498E-05, 1.4859E-05, 7.4941E-06, 1.0834E-05, 1.3528E-05, 1.8767E-05, 2.3275E-05, 1.7075E-05, 1.4382E-05, 9.1739E-06, 2.9404E-05, 2.6641E-05, 3.6161E-05, 3.8820E-05, 2.3795E-05, 3.4498E-05, 3.8097E-05, 3.6464E-05, 5.4269E-05, 4.6567E-05, 5.6792E-05, 5.6473E-05, 3.8589E-05, 6.4943E-05, 6.2741E-05, 8.1464E-05, 8.7523E-05, 9.2495E-05, 7.9495E-05, 9.5805E-05, 1.2523E-04, 1.1283E-04, 1.7093E-04, 1.5174E-04, 2.1294E-04, 2.4516E-04, 2.8872E-04, 5.1937E-04, 6.1632E-04, 1.3872E-03, 2.2013E-03, 3.1529E-03, 6.4655E-03, -1.3635E-02, 3.1388E-03, 1.9597E-03, 8.9269E-04, 6.2775E-04, 3.5934E-04, 2.7026E-04, 2.0045E-04, 1.5805E-04, 1.4622E-04, 1.1965E-04, 9.9301E-05, 1.0369E-04, 5.9867E-05, 6.4634E-05, 7.6073E-05, 6.0950E-05, 6.6386E-05, 6.0367E-05, 3.5226E-05, 2.1277E-05, 5.8693E-05, 3.8447E-05, 3.9553E-05, 2.9658E-05, 2.1033E-05, 2.7512E-05, 2.1322E-05, 2.2052E-05, 1.8650E-05, 1.9219E-05, 2.1722E-05, 2.0256E-05, 1.2146E-05, -1.1082E-05, 1.9468E-05, 1.3132E-05, 1.7854E-05, 7.0756E-06, 1.5066E-06, 4.4850E-06, 7.2294E-06, 4.2075E-06, 5.3622E-06, 4.6265E-06, 5.2604E-06, 5.2291E-06, 5.2220E-06, 2.0807E-06, 5.9006E-06, 3.7837E-06, 6.0026E-06, -5.2784E-06, 3.3810E-06, -5.5313E-06, 3.0722E-06, 1.3393E-06, 3.5862E-07, 1.4186E-07, 8.1974E-08, 1.4389E-07, 3.6737E-08, 4.2531E-10, -2.1855E-09, -4.8183E-08, -2.4722E-07, -4.4172E-07, -1.0339E-06, -2.4231E-06, -4.2092E-06, -1.0520E-05, -2.6695E-06, -3.7255E-06, -4.4148E-06, -2.3779E-06, -2.7687E-05, -2.1889E-05, -1.5077E-05, -1.6918E-05, -1.4647E-05, -1.7795E-05, -2.0991E-05, -2.1219E-05, -2.6690E-05, -2.6819E-05, -3.0573E-05, -2.3541E-05, -3.3634E-05, -3.4654E-05, -4.5425E-05, -4.3096E-05, -4.0714E-05, -4.4392E-05, -4.2041E-05, -4.9920E-05, -7.6175E-05, -7.8084E-05, -7.4385E-05, -7.3842E-05, -8.4490E-05, -8.2444E-05, -9.9988E-05, -1.1571E-04, -1.3369E-04, -1.5359E-04, -9.2163E-05, -1.1241E-04, -1.2375E-04, -1.0721E-04, -1.9237E-04, -2.0655E-04, -2.3246E-04, -2.2944E-04, -2.4034E-04, -2.7086E-04, -3.0716E-04, -3.8551E-04, -4.1979E-04, -5.2958E-04, -6.3842E-04, -8.2966E-04, -1.3228E-03, -2.1097E-03, -4.2868E-03, -6.6301E-03, 4.4580E-03, 1.4473E-03, -5.3315E-04, 3.6998E-03, -7.0019E-03, -3.3463E-03, -1.8706E-03, -1.1406E-03, -7.1865E-04, -5.5728E-04, -4.0432E-04, -3.7799E-04, -2.9400E-04, -2.6320E-04, -2.0772E-04, -1.8417E-04, -1.7686E-04, -1.5273E-04, -1.5420E-04, -1.5480E-04, -8.0087E-05, -9.9763E-05, -6.9514E-05, -8.6816E-05, -1.0201E-04, -9.0184E-05, -7.6382E-05, -6.3632E-05, -5.8378E-05, -4.6581E-05, -4.4479E-05, -4.5071E-05, -4.9848E-05, -6.2378E-05, -2.0513E-05, -2.5070E-05, -2.8954E-05, -1.7295E-05, -4.3814E-05, -3.3086E-05, -2.1128E-05, -2.0418E-05, -1.5233E-05, -2.0877E-05, -1.7640E-05, -1.1781E-05, -1.3502E-05, -1.3325E-05, -1.1609E-05, -1.0641E-05, -1.2738E-05, -1.3628E-05, -1.8925E-05, -1.2707E-05, -1.6039E-07, -1.9634E-06, -5.2268E-07, -4.8456E-06, -5.1606E-06, -2.9846E-06, -1.2632E-06, -4.4111E-07, -2.6328E-07, -7.4318E-08, -3.4604E-09, 3.0765E-10, 2.9518E-08, 7.5014E-08, 2.9564E-07, 1.0607E-06, 2.9283E-06, 6.2079E-06, -1.9380E-06, 1.2748E-08, 1.6301E-06, 2.9936E-06, 4.1731E-06, -1.1433E-05, 2.2683E-05, 2.3803E-05, 1.9673E-05, 1.5693E-05, 1.3640E-05, 1.2442E-05, 2.0368E-05, 2.1108E-05, 2.4000E-05, 1.2881E-05, 2.0849E-05, 2.2808E-05, 2.7584E-05, 2.7086E-05, 2.2424E-05, 3.5190E-05, 3.5340E-05, 2.9465E-05, 3.1654E-05, 1.5647E-05, 6.3036E-05, 5.7442E-05, 5.6312E-05, 4.9849E-05, 5.4209E-05, 6.7253E-05, 9.0348E-05, 9.8468E-05, 3.3260E-05, 7.1626E-05, 7.1418E-05, 7.5651E-05, 8.9167E-05, 7.2964E-05, 1.4159E-04, 1.5592E-04, 1.7059E-04, 1.5485E-04, 1.8300E-04, 2.4626E-04, 2.5476E-04, 3.6175E-04, 3.9984E-04, 6.5040E-04, 8.3026E-04, 1.5865E-03, 3.0800E-03, 3.5738E-03, -4.7038E-03, 1.4071E-04, -4.0559E-04, -1.7963E-04, -3.0756E-05, -2.5816E-03, 4.6631E-03, 2.5182E-03, 1.4541E-03, 7.9614E-04, 5.2911E-04, 4.0284E-04, 2.6764E-04, 2.7508E-04, 1.6451E-04, 1.6307E-04, 1.4856E-04, 1.4401E-04, 1.4798E-04, 9.8304E-05, 3.7160E-05, 6.6925E-05, 6.2333E-05, 5.7489E-05, 2.1772E-05, 5.9916E-05, 8.9022E-05, 7.2952E-05, 4.2954E-05, 3.7677E-05, 4.0460E-05, 4.2864E-05, 5.0892E-05, 4.6654E-05, -5.4979E-07, 1.9871E-05, 2.5722E-05, 2.7764E-05, 2.5957E-05, -4.2428E-06, 2.0555E-05, 2.4890E-05, 1.5522E-05, 1.5058E-05, 6.8925E-06, 1.3922E-05, 1.6138E-05, 1.3254E-05, 1.0111E-05, 1.2876E-05, 1.2272E-05, 1.5101E-05, 1.6802E-05, 1.0325E-05, -5.2052E-06, 2.7889E-06, 2.0563E-06, 2.2334E-06, -1.0107E-06, 1.4021E-06, 3.0156E-06, 1.6477E-06, 5.1574E-07, 9.6182E-08, 1.5388E-08, 1.1472E-09, -9.4589E-10, -1.8381E-09, -9.7949E-08, -4.8260E-07, -1.5379E-06, -3.5385E-06, 2.5187E-06, -3.1261E-07, -8.1982E-07, -1.6130E-06, -2.7102E-06, -2.9854E-06, -5.3749E-06, 1.1265E-05, -1.7646E-05, -2.6108E-05, -2.0621E-05, -1.7309E-05, -1.9659E-05, -1.8875E-05, -1.9261E-05, -1.2136E-05, -1.9077E-05, -2.1875E-05, -2.9480E-05, -2.2344E-05, -1.0142E-05, -1.5934E-05, -2.4515E-05, -3.6000E-05, -3.3041E-05, -3.2467E-05, -3.7561E-05, -1.9646E-05, -5.9366E-05, -5.2202E-05, -6.3010E-05, -6.8941E-05, -7.9527E-05, -9.6389E-05, -3.9090E-05, -6.0161E-05, -6.8780E-05, -5.8626E-05, -7.6335E-05, -9.7565E-05, -9.4611E-05, -5.7401E-05, -1.5346E-04, -1.8218E-04, -1.8755E-04, -2.2630E-04, -2.4403E-04, -3.5808E-04, -4.4762E-04, -5.9594E-04, -9.5966E-04, -1.3274E-03, -2.3336E-03, -2.3054E-03, 3.2300E-03, -4.3511E-04, 1.9995E-05, 2.2932E-04, 1.1266E-04, 1.9388E-04, 2.1882E-04, 2.6861E-03, -2.8035E-03, -2.1150E-03, -1.2742E-03, -8.1431E-04, -5.0399E-04, -3.7419E-04, -2.9857E-04, -2.2027E-04, -2.0769E-04, -1.7422E-04, -1.6912E-04, -8.3005E-05, -5.3886E-05, -7.3360E-05, -6.4493E-05, -6.8803E-05, -5.6784E-05, -4.8814E-05, -2.0255E-05, -3.0117E-05, -9.1077E-05, -5.0524E-05, -5.2636E-05, -4.7189E-05, -4.8423E-05, -4.7231E-05, 2.8713E-06, -2.6744E-05, -2.3421E-05, -2.6408E-05, -3.2770E-05, -5.4575E-06, -1.3102E-05, 2.6037E-06, -2.2056E-05, -2.3068E-05, -1.7969E-05, -1.4106E-05, -7.7117E-06, -1.5745E-05, -1.5273E-05, -1.4366E-05, -1.5977E-05, -2.0079E-05, -1.8339E-05, -7.7230E-06, 6.3530E-06, -2.1022E-06, -1.8539E-06, -1.5450E-06, -9.6267E-07, -4.9281E-07, 1.1892E-06, 3.8612E-08, -1.6951E-06, -6.4221E-07, -1.4665E-07, 7.8817E-10, -9.1401E-10, 2.8591E-10, 1.6094E-08, 6.9741E-08, 9.6141E-08, 2.7943E-07, -2.4948E-07, -6.5518E-07, 4.7498E-06, -2.4125E-06, 8.8367E-07, 1.6850E-06, 6.2546E-06, -5.8853E-06, 2.7772E-07, -5.1780E-06, 5.6962E-06, 8.4048E-06, 6.3279E-06, 9.2723E-06, 7.3693E-06, 8.3664E-06, 1.0759E-05, 1.4258E-05, 9.1021E-06, 1.3469E-05, 1.1096E-05, 1.4923E-05, 1.0279E-06, 1.6104E-05, 1.7242E-05, 2.2679E-05, 3.0276E-05, 4.0980E-05, 1.5399E-05, 2.1861E-05, 3.1120E-05, 4.2819E-05, 4.5253E-05, 4.2770E-05, 3.1312E-05, 3.2992E-05, 4.6080E-05, 3.1328E-05, 5.5508E-05, 5.6536E-05, 5.5214E-05, 1.1669E-04, 3.6079E-05, 8.3957E-05, 6.9225E-05, 1.2273E-04, 1.2473E-04, 1.2324E-04, 2.1669E-04, 1.7784E-04, 3.2544E-04, 2.7434E-04, 3.9304E-04, 1.9683E-04, -1.1411E-03, 3.8066E-04, -3.0333E-03, 2.3454E-03, -2.9080E-05, -2.6970E-05, -2.3331E-03, 3.4948E-03, -1.0963E-03, -3.1326E-04, 2.4432E-04, 4.3717E-04, 3.5133E-04, 1.9504E-04, 2.9739E-04, 1.0322E-04, 1.6188E-04, 8.0120E-05, 9.4829E-05, 8.8803E-05, 2.4564E-05, 8.3642E-05, 6.0162E-07, 4.1875E-05, 2.9292E-05, 3.4439E-05, -2.4138E-05, 5.2836E-05, 2.1004E-05, 1.9543E-05, 2.9305E-05, 2.5540E-05, 2.3663E-05, 1.9338E-05, 9.1017E-06, 2.3367E-05, 2.1869E-05, 6.0331E-06, 6.2396E-06, 9.9920E-07, -5.0841E-06, 4.5947E-06, 3.2339E-06, -1.9026E-06, 6.7285E-06, 7.6016E-06, 3.3067E-06, 5.9648E-06, 2.7160E-06, 6.7814E-06, 4.8453E-06, 4.6000E-06, 3.1226E-06, 1.1827E-06, -5.2537E-06, 7.3462E-06, -5.5660E-06, 6.1196E-07, 4.0408E-07, 1.3228E-06, -1.3918E-08, 2.2442E-06, -3.7486E-07, -1.8754E-07, 1.9356E-07, 8.2093E-08, -5.3422E-09, 1.2252E-09, -1.5090E-09, 4.4204E-10, -1.1247E-07, -7.2768E-07, -9.5196E-07, 1.3259E-06, -6.0045E-07, -6.9856E-09, -2.6697E-06, -9.7818E-08, -2.0653E-06, -1.8382E-06, -3.8722E-06, -7.9283E-06, 8.5310E-06, -1.3081E-05, -2.6314E-05, -2.5846E-05, -2.7054E-05, -2.0534E-05, -1.4086E-05, -2.4103E-05, -2.3939E-05, -2.6941E-05, -1.8907E-05, -8.1211E-06, -1.7867E-05, -2.7650E-05, -1.6283E-05, -2.1280E-05, -3.1580E-05, -3.9585E-05, -3.3278E-05, -3.9107E-05, -1.8603E-05, -4.9623E-05, -8.0001E-05, -8.8524E-05, -6.9772E-05, -1.6695E-05, -3.6845E-05, -6.0485E-05, -6.6704E-05, -6.9867E-05, -7.4940E-05, -7.6158E-05, -8.0004E-05, -1.3402E-04, -5.7630E-05, -1.5889E-04, -2.0844E-04, -2.6210E-04, -3.5885E-04, -4.0866E-04, -6.5482E-04, -8.8421E-04, -1.4184E-03, -1.6827E-03, -6.1531E-04, 2.3553E-03, -5.2982E-04, -1.7656E-04, 9.2111E-04, 1.3879E-04, 4.7505E-05, -8.8394E-04, 7.0087E-04, -1.4540E-04, 2.0092E-03, -1.1659E-03, -1.7908E-03, -1.3216E-03, -7.5458E-04, -5.5785E-04, -3.8804E-04, -2.9402E-04, -2.6048E-04, -1.8853E-04, -1.1191E-04, -9.5011E-05, -8.9706E-05, -7.7328E-05, -4.9243E-05, -6.8638E-05, -5.7689E-05, -7.3813E-05, -4.6599E-05, -2.9500E-05, -2.3759E-05, -6.3654E-05, -6.8622E-05, -7.1993E-05, -3.7275E-05, -1.2875E-05, -3.2859E-05, -3.0903E-05, -3.1948E-05, -2.0636E-05, -7.5835E-06, -2.0395E-05, -1.4750E-05, -1.7624E-05, -4.7842E-06, -1.4858E-05, -2.2906E-05, -2.0636E-05, -1.5216E-05, -1.0787E-05, -1.6850E-05, -2.1365E-05, -2.5021E-05, -2.0606E-05, -3.7473E-06, 2.1635E-06, -3.1119E-06, -4.5331E-06, -2.2974E-06, -6.4970E-07, -2.7029E-07, -1.2578E-06, -2.8577E-07, 1.9964E-07, 1.7609E-07, -5.4128E-07, -1.5828E-07, -1.4164E-08, -2.0648E-09); \n//center of the convolution \nint Nc = 63; \n//number of ranks \nint Nr = 8; \n//convolution size \nint N = 127; \n\n\n\nvec3 pack2vec3(vec3 a, vec3 b) \n{\n    uvec3 packed = uvec3(packHalf2x16(vec2(a.x,b.x)), packHalf2x16(vec2(a.y,b.y)), packHalf2x16(vec2(a.z,b.z)));\n    return vec3(uintBitsToFloat(packed.x), uintBitsToFloat(packed.y), uintBitsToFloat(packed.z));\n}\n\nvoid unpack2vec3(vec3 packed, out vec3 a, out vec3 b) \n{\n    uvec3 unpacked = uvec3(floatBitsToUint(packed.x), floatBitsToUint(packed.y), floatBitsToUint(packed.z));\n    vec2 unpackedA = unpackHalf2x16(unpacked.x);\n    vec2 unpackedB = unpackHalf2x16(unpacked.y);\n    vec2 unpackedC = unpackHalf2x16(unpacked.z);\n    a = vec3(unpackedA.x, unpackedB.x, unpackedC.x);\n    b = vec3(unpackedA.y, unpackedB.y, unpackedC.y);\n}\n", "buffer_b_code": "#define SPP 1\n#define VOX_SIZE 0.01\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nconst vec2 mp = vec2(-1.,1.);\n\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\n\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i <11; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), sdBox(p, vec3(6.0))/scale);\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 12;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n//Around the world\nLevel(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1 + 0.0*sin(3.1);\n    iFracAng2 = LVL.FracAng2+ 0.0*cos(3.1);\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    ro = get(CamP).xyz;\n   \n    rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    return true;\n}\n\nvec3 toVoxel(vec3 pos)\n{\n    return pos / VOX_SIZE;\n}\n\nvec3 fromVoxel(vec3 pos)\n{\n    return pos * VOX_SIZE;\n}\n\nint getVoxel(vec3 pos, out vec3 col)\n{\n    pos = fromVoxel(pos);\n    vec4 map = fractal(pos);\n    float sdf = map.w;\n    col = clamp(map.xyz, 0., 1.0);\n    return int(round(sdf/VOX_SIZE));\n}\n\nbool VoxelRaycast(inout vec3 ro, vec3 rd, out vec3 N, out vec3 col, float maxt)\n{\n    ro = toVoxel(ro);\n\tvec3 voxelPos = floor(ro);\n\t\n    vec3 rayInv = 1.0/rd;\n    vec3 rayMask = vec3(greaterThan(rd, vec3(0.0)));\n\tvec3 rayStep = rayMask * 2.0 - 1.0;          \n\tvec3 offset = (rayMask - ro) * rayInv;\n\n\tvec3 mask = vec3(0.0);\n    vec3 sideLength = vec3(0.0);\n    \n    float traveled = 0.0;\n    float curTraveled = 0.0;\n    \n\tbool hit = false;\n\tfor(int i = 0; i < MAX_STEPS; i++) \n\t{\n        int sdfi = getVoxel(voxelPos, col);\n\t\tif(sdfi <= 0) { hit = true; break; }\n\t\t\n        if(sdfi > 2)\n        {\n            float dt = dot(sideLength, mask) + max(0.0, float(sdfi) - 2.0);\n            traveled += dt;\n            ro = ro + rd*dt;\n            voxelPos = floor(ro);\n            offset = (rayMask - ro) * rayInv;\n        }\n        \n        sideLength = voxelPos * rayInv + offset;\n        mask = vec3(lessThanEqual(sideLength.xyz, min(sideLength.yzx, sideLength.zxy)));\n        voxelPos += mask * rayStep;\n        curTraveled = traveled + dot(sideLength, mask);\n        \n        if(curTraveled > maxt) break;\n\t}\n\t\n\tN = -rayStep * mask;\n    ro = fromVoxel(ro + rd*dot(sideLength, mask));\n\treturn hit;\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = light;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,1000.);\n\treturn pow(sky_col,vec3(1.5f)); \n}\n\n\nbool trace_ray(inout vec3 ro, inout vec3 rd, inout vec3 inc, inout vec3 k)\n{\n    vec3 fcol, N, col;\n    if(VoxelRaycast(ro, rd, N, col, 20.0/VOX_SIZE))\n    {\n        const float roughness = 0.15;\n        \n        vec3 dum0, dum1;\n        vec3 shadowPos = ro+light*0.0001;\n        vec3 L = normalize(light + 0.03*udir(rand2()));\n        float shadow = 1.0 - float(VoxelRaycast(shadowPos, L, dum0, dum1, 4.0/VOX_SIZE));\n        \n        vec3 V = -rd;\n        vec3 R = reflect(rd, N);\n        vec3 H = normalize(V + L);\n\n        vec3 kS = fresnel(V, N, vec3(0.1));\n        vec3 kD = 1.0 - kS;\n\n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n\n        float selfshadow = G_ggx(NdotL,roughness)*G_ggx(NdotV,roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, roughness);  \n\n        vec3 direct = shadow*(kD * col/ PI + specular) * NdotL ;\n        fcol = 4.*direct + 0.*col;\n        \n        inc += k * fcol;\n        k *= col;\n        \n        rd = normalize(N + udir(rand2()));\n        ro += N*0.001;\n        \n        return true;\n\n    }\n    else \n    {\n        inc += k * sky_color(rd);\n        return false;\n    }\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += rand2();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 ro = cp;\n    vec3 inc = vec3(0.0), k = vec3(1.0);\n    for(int i = 0; i < 4; i++)\n    {\n        if(!trace_ray(ro, rd, inc, k)) break;\n    }\n\n   \n\n    return vec4(inc, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LoadLevel(Levels[1]);\n    \n    rng_initialize(fragCoord, iFrame);\n    \n    fragColor = vec4(0.0);   \n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        \n   fragColor.xyz *= fragColor.w;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n       \n   fragColor.xyz /= max(fragColor.w, 0.0001);\n       \n   fragColor.xyz = clamp(fragColor.xyz, vec3(0.0), vec3(1e2));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//first pass of separable convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //do a convolution in the x direction on iChannel0\n    //since we have 6 ranks and we can only store 2 in a vec3 we need to do the partial sums in 1/2 resolution chunks in a single buffer(which means max 8 ranks)\n    ivec2 coord = ivec2(fragCoord.xy) % ivec2(iResolution.xy/2.0);\n    ivec2 block = ivec2(fragCoord.xy) / ivec2(iResolution.xy/2.0);\n    int rank_offset = 2 * (block.x + block.y * 2);\n\n    if(rank_offset >= Nr)\n        discard;\n\n    vec3 sum0 = vec3(0.0);\n    vec3 sum1 = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        //since we are doing it at 1/2 resolution we need to use 1 mip level higher\n        vec4 pixel = texelFetch(iChannel0, coord + ivec2(i, 0), 1);\n        vec3 pcolor = pow(pixel.xyz,vec3(1.6));\n        \n        //get the rank index\n        int offset = i + Nc;\n        sum0 += pcolor * U[offset + rank_offset * N];\n        sum1 += pcolor * U[offset + (rank_offset + 1) * N];\n    }\n\n    //write the sum packed to the output\n    fragColor = vec4(pack2vec3(sum0, sum1), 1.0);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//second pass: do the convolution in the y direction\n//and write the result to the output    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //do a convolution in the y direction on iChannel0\n    ivec2 resol = ivec2(iResolution.xy/2.0);\n    ivec2 coord = ivec2(fragCoord.xy) % resol;\n    ivec2 block = ivec2(fragCoord.xy) / resol;\n\n    //we only need 1 block, since we can sum all the ranks here\n    if(block.x + block.y * 2 >= 1)\n        discard;\n\n    vec3 sum = vec3(0.0);\n    for (int i = -Nc; i < Nc; i++) \n    {\n        //use texelFetch to get the pixel at the current index\n        ivec2 pos = ivec2(coord.x, coord.y + i);\n\n        //skip if the coordinate is outside the image\n        if(pos.x < 0 || pos.x >= resol.x || pos.y < 0 || pos.y >= resol.y)\n            continue;\n        \n        //loop over pairs of ranks\n        for(int j = 0; j < Nr; j += 2)\n        {\n            int block_id = j / 2;\n            ivec2 block_offset = ivec2(block_id % 2, block_id / 2);\n            vec4 pixel = texelFetch(iChannel0, pos + block_offset * resol, 0);\n\n            //unpack the values\n            vec3 val1, val2;\n            unpack2vec3(pixel.xyz, val1, val2);\n\n            //add the values to the sum\n            sum += val1 * V[i + Nc + j * N];\n            sum += val2 * V[i + Nc + (j + 1) * N];\n        }\n    }\n\n    //return the sum\n    fragColor = vec4(sum, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 160], [162, 162, 185, 185, 230], [233, 233, 290, 290, 516]], "test": "untested"}
{"id": "DlfXWS", "name": "Infinite Dodecahedron", "author": "xjorma", "description": "use the mouse to look around.", "tags": ["wireframe", "antialias", "mirror", "infinite", "dodecahedron", "infinity"], "likes": 45, "viewed": 760, "published": 3, "date": "1675559325", "time_retrieved": "2024-07-30T18:12:07.201259", "image_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = separableBlur(iChannel0, ivec2(fragCoord), 10, 1, ivec2(iResolution)).rgb * 0.8 + texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    fragColor = vec4(sqrt(c), 1.0);\n}\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int nbRef = 5;     // 5 max! Not enought bits in a float.\nconst int nbBits = 3;\n\n#define NO_UNROLL_ZERO min(0, iFrame)\n\nconst float PI = radians(180.0);\n\nvec4 separableBlur(in sampler2D tex, in ivec2 c, in int radius, in int axis, ivec2 res)\n{\n    vec4 acc = vec4(0);\n    for(int i = -radius; i <= radius; i ++)\n    {\n        ivec2 uv = c;\n        uv[axis] += i;\n        float t = float(i) / float(radius);\n        float w = exp(-4.0*t*t);\n\t\tacc += texelFetch(tex, uv, 0)*w;\n    }\n    return acc / (0.5 * float(radius) * sqrt(PI));    // Gaussian integral\n}\n\nconst int numPlanes = 12;\n\nconst vec3 planes[numPlanes / 2] = vec3[](\nvec3(0.0, 1.00747072906e-07, -1.0),\nvec3(0.0, 0.89442718029, -0.447213709354),\nvec3(0.850650787354, 0.27639311552, -0.447213679552),\nvec3(0.52573120594, -0.723606586456, -0.447213947773),\nvec3(-0.525731146336, -0.723606586456, -0.447213888168),\nvec3(-0.850650787354, 0.276393145323, -0.447213739157));\n\nconst int numVertices = 20;\n\nconst vec3 vextexplanes[numVertices] = vec3[](\nvec3(0.356822151585, 0.491123815541, -0.794654232951),\nvec3(0.577350469481, -0.187592375793, -0.794654349975),\nvec3(0.0, -0.607062228519, -0.794654296349),\nvec3(-0.577350469481, -0.187592375793, -0.794654349975),\nvec3(-0.356822151585, 0.491123815541, -0.794654232951),\nvec3(-0.577350217029, 0.794654569487, -0.187592222894),\nvec3(-0.934172366371, -0.303531064052, -0.187592332104),\nvec3(0.0, -0.982246973058, -0.187592334382),\nvec3(0.934172366371, -0.303531064052, -0.187592332104),\nvec3(0.577350217029, 0.794654569487, -0.187592222894),\nvec3(0.0, 0.982246969732, 0.187592351794),\nvec3(-0.934172366371, 0.303531064052, 0.187592332104),\nvec3(-0.577350217029, -0.794654569487, 0.187592222894),\nvec3(0.577350217029, -0.794654569487, 0.187592222894),\nvec3(0.934172366371, 0.303531064052, 0.187592332104),\nvec3(0.0, 0.607062228519, 0.794654296349),\nvec3(0.577350469481, 0.187592375793, 0.794654349975),\nvec3(0.356822151585, -0.491123815541, 0.794654232951),\nvec3(-0.356822151585, -0.491123815541, 0.794654232951),\nvec3(-0.577350469481, 0.187592375793, 0.794654349975) );\n\nconst int totalPlane = numPlanes + numVertices;\n\nfloat clipTriangle(float t)\n{\n    float v = 1.5 - abs((t - floor(t * 0.5) * 2.0) - 1.0) * 2.0;\n    return clamp(v, 0.0, 1.0);\n}\n\nvec4 getPlane(in int id, in float t)\n{\n    if(id < numPlanes / 2)\n    {\n        return vec4(planes[id % (numPlanes / 2)], -1.0);\n    }\n    else if(id < numPlanes)\n    {\n        return vec4(-planes[id % (numPlanes / 2)], -1.0);\n    }\n    return vec4(vextexplanes[id - numPlanes], mix(-1.25840880545, -1.0981855332, clipTriangle(t * 0.2)));\n}\n\nint getid(in int id)\n{\n    if(id < numPlanes)\n    {\n        return id % (numPlanes / 2);\n    }\n    return 6;\n}\n\n", "buffer_a_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst float fltMax = 100000.;\nconst float fltMin = -100000.;\n\n\nbool convexIntersect( in vec3 ro, in vec3 rd, out vec2 oDis, out vec3 oOutNor,out vec3 oInNor, out ivec2 ids)\n{\n    oDis = vec2(fltMin, fltMax);\n    oOutNor =  oInNor = vec3(0);\n    ids = ivec2(-1);\n    for(int i = 0 ;i < totalPlane; i++)\n    {\n        vec4 plane = getPlane(i, iTime);\n        float t = -(plane.w + dot(plane.xyz, ro)) / dot(plane.xyz, rd);\n        if(dot(plane.xyz, rd) < 0.) // enter\n        {\n            if(t > oDis.x)\n            {\n                oDis.x = t;\n                oOutNor = plane.xyz;\n                ids.x = getid(i);\n            }\n        }\n        else  // exit\n        {\n            if(t < oDis.y)\n            {\n                oDis.y = t;\n                oInNor = - plane.xyz;\n                ids.y = getid(i);\n            }\n        }\n    }\n    return oDis.x < oDis.y;\n}\n\nfloat render(in vec3 ro,in vec3 rd)\n{\n    float  col = 0.0;\n    vec3  oN, iN;\n    ivec2 ids;\n    vec2  d;\n    if(convexIntersect(ro, rd, d, oN, iN, ids))\n    {\n        // polyhedron interior + exterior\n        col = float(ids.x) * float(1 << (nbBits * (nbRef + 1))) + float(ids.y) * float(1 << (nbBits * nbRef));\n        // Reflection\n        for(int i = 0; i < nbRef; i++)\n        {\n            ro += rd * d.y;\n            rd = reflect(rd, iN);\n            convexIntersect(ro, rd, d, oN, iN, ids);\n            col += float(ids.y) * float(1 << (nbBits * (nbRef - 1 - i)));            \n        }\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 tot = vec4(0.0);      \n\tvec2 rook[4] = vec2[](vec2( 1./8., 3./8.), vec2( 3./8.,-1./8.), vec2(-1./8.,-3./8.), vec2(-3./8., 1./8.));\n    for( int n = NO_UNROLL_ZERO; n < 4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // camera        \n        float theta\t= radians(360.) * (iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(110.) * (iMouse.y/iResolution.y-0.5) - radians(90.);\n        vec3 ro = 2.3 * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        tot[n] = render(ro ,rd);  \n    }\n    fragColor = tot;\n}\n", "buffer_a_inputs": [], "buffer_b_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec4 logn(in vec4 v, float n)\n{\n    return log(v) / log(n);\n}\n\n\nfloat sobelFilter(in sampler2D tex, in ivec2 c)\n{\n    ivec4 tleft  = ivec4(texelFetch(tex, c + ivec2(-1, 1), 0));\n    ivec4 left   = ivec4(texelFetch(tex, c + ivec2(-1, 0), 0));\n    ivec4 bleft  = ivec4(texelFetch(tex, c + ivec2(-1,-1), 0));\n    ivec4 top    = ivec4(texelFetch(tex, c + ivec2( 0, 1), 0));\n    ivec4 bottom = ivec4(texelFetch(tex, c + ivec2( 0,-1), 0));\n    ivec4 tright = ivec4(texelFetch(tex, c + ivec2( 1, 1), 0));\n    ivec4 right  = ivec4(texelFetch(tex, c + ivec2( 1, 0), 0));\n    ivec4 bright = ivec4(texelFetch(tex, c + ivec2( 1,-1), 0));\n    \n    ivec4 x = (tleft ^ tright) | (left ^ right) | (bleft ^ bright);\n    ivec4 y = (tleft ^ bleft) | (top ^ bottom) | (tright ^ bright);\n    \n    ivec4 m = x | y;\n    \n    vec4 b = ceil(logn(vec4(m) + 1.0 , float(1 << nbBits))) / float( 2 + nbRef);\n    return dot(b, vec4(0.25));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c = vec3(sobelFilter(iChannel0, ivec2(fragCoord)));\n    fragColor = vec4(pow(vec3(c), vec3(4,3.5,2.5)), 1.0);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = separableBlur(iChannel0, ivec2(fragCoord), 10, 0, ivec2(iResolution));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfXWS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[115, 115, 172, 172, 353]], "test": "untested"}
{"id": "mllSDS", "name": "Veach 1997 Fig 9.12", "author": "Reedbeta", "description": "Simpler test scene compared to the classic MIS one. This shows how MIS is useful even in this very simple scene, as BRDF sampling or light sampling is more favored depending how far you are from the area light.", "tags": ["raymarching", "mis", "progressive", "pbrt"], "likes": 6, "viewed": 356, "published": 3, "date": "1675555339", "time_retrieved": "2024-07-30T18:12:08.190615", "image_code": "// Final gather \n\n// INPUTS\n\n// 1 := select brdf importance sampling only\n// 2 := select light importance sampling only\n// 3 := select multiple importance sampling\n// 4 := turn on green coloring of brdf importance samples, red coloring of light importance samples\n// SPACE := reset to no coloring and multiple importance sampling\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_frame = 0.;\n\nvoid setup_globals()\n{\n    g_frame = float(iFrame) - texture(iChannel1, vec2(0., 0.), -100.).r ;\n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_globals();\n    vec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec3 scol = vec3(0.);\n    if (g_frame > .5)\n    {\n\t\tscol = texture( iChannel0, uv ).xyz;\n        scol /= g_frame;\n        scol = scol/(vec3(1.0)+scol);\n        scol = pow( scol, vec3(0.4545) );\n    }\n    \n    fragColor = vec4(scol, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A is used to store persistent state in one pixel\n\n// r = start frame\n// g = sampling type (brdf, light, multiple)\n// b = color samples? (green for brdf importance samples, red for light importance samples)\n\n// INPUTS\n\n// 1 := select brdf importance sampling only\n// 2 := select light importance sampling only\n// 3 := select multiple importance sampling\n// 4 := turn on green coloring of brdf importance samples, red coloring of light importance samples\n// SPACE := reset to no coloring and multiple importance sampling\n\n// **************************************************************************\n// CONSTANTS\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_ONE = 49.5/256.0;\nconst float KEY_TWO = 50.5/256.0;\nconst float KEY_THREE = 51.5/256.0;\nconst float KEY_FOUR = 52.5/256.0;\n\nconst float BRDF_IMPORTANCE_SAMPLING = 2.;\nconst float LIGHT_IMPORTANCE_SAMPLING = 1.;\nconst float MULTIPLE_IMPORTANCE_SAMPLING = 0.;\n\nbool this_pixel_is_being_rendered(vec2 fragCoord, vec2 r)\n{\n    return (step(r.y-.2, fragCoord.y) * step(fragCoord.y, r.y+1.2) * \n            step(r.x-.2, fragCoord.x) * step(fragCoord.x, r.x+1.2)) > .5;\n}\n\nbool this_pixel_is_in_the_range(vec2 fragCoord, vec2 r0, vec2 r1)\n{\n    return (step(r0.y-.2, fragCoord.y) * step(fragCoord.y, r1.y+1.2) * \n            step(r0.x-.2, fragCoord.x) * step(fragCoord.x, r1.x+1.2)) > .5;\n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvec3 process_inputs(vec2 fragCoord)\n{\n    \n\tvec3 resultingColor = vec3(0.);\n    \n    vec3 storedState = texture(iChannel0, vec2(0., 0.), -100.).rgb;\n\n    float initialFrame = storedState.r;\n    float samplingType = storedState.g;\n    float colorSamples = storedState.b;\n\n    // space bar resets coloring and sampling to default\n    float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n    if (pressSpace > .5 || iFrame == 0) \n    { \n        initialFrame = float(iFrame);         \n        samplingType = MULTIPLE_IMPORTANCE_SAMPLING; \n        colorSamples = 0.;\n    }\t\n\n    // one enables brdf sampling only\n    float pressOne = texture( iChannel1, vec2(KEY_ONE,0.25) ).x;\n    if (pressOne > .5) { \n        initialFrame = float(iFrame); \n        samplingType = BRDF_IMPORTANCE_SAMPLING; \n    }\t\n\n    // two enables lighting sampling only\n    float pressTwo = texture( iChannel1, vec2(KEY_TWO,0.25) ).x;\n    if (pressTwo > .5) { \n        initialFrame = float(iFrame); \n        samplingType = LIGHT_IMPORTANCE_SAMPLING; \n    }\t\n\n    // three enables multiple importance sampling\n    float pressThree = texture( iChannel1, vec2(KEY_THREE,0.25) ).x;\n    if (pressThree > .5) { \n        initialFrame = float(iFrame); \n        samplingType = MULTIPLE_IMPORTANCE_SAMPLING; \n    }\t\n\n    // four enables color sampling - green for brdf, red for light\n    float pressFour = texture( iChannel1, vec2(KEY_FOUR,0.25) ).x;\n    if (pressFour > .5) { \n        initialFrame = float(iFrame); \n        colorSamples = 1.;\n    }\n    \n    \n    if (this_pixel_is_being_rendered(fragCoord, vec2(0., 0.)))\n    {        \n\t\tresultingColor = vec3(initialFrame, samplingType, colorSamples);\n    }\n                \n    return resultingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\n    if (!this_pixel_is_in_the_range(fragCoord, vec2(0., 0.), vec2(1., 0.)))\n    {\n        discard;\n    }\n    \n    vec3 finalColor = process_inputs(fragCoord);\n    \n    fragColor = vec4(finalColor,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B does the sampling and accumulation work\n\n// **************************************************************************\n// DEFINES\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define INV_TWO_PI .159155\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define FLOOR_ID 1.\n#define LIGHT_ID 2.\n\n#define BACKDROP_ID 3.\n#define ENVIRONMENT_ID 4.\n\n// **************************************************************************\n// CONSTANTS\n\nconst int BRDF_IMPORTANCE_SAMPLING = 2;\nconst int LIGHT_IMPORTANCE_SAMPLING = 1;\nconst int MULTIPLE_IMPORTANCE_SAMPLING = 0;\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_frame        = 0.;\nint g_samplingType = MULTIPLE_IMPORTANCE_SAMPLING;\nfloat g_colorSamples = 0.;\n\n\n// vec4 g_light0 = vec4(-2.,1.8, -3., .1);\n// vec4 g_light1 = vec4(-.666,1.8, -3., .2);\n// vec4 g_light2 = vec4(.666,1.8, -3., .3);\n// vec4 g_light3 = vec4(2.,1.8, -3., .4);\n\n// **************************************************************************\n// MATH UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n\n// --------------------------------------\n// from dave hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --------------------------------------\n\nfloat dist_squared(vec3 v1, vec3 v2)\n{\n    return (v1.x - v2.x) * (v1.x - v2.x) +\n        (v1.y - v2.y) * (v1.y - v2.y) +\n        (v1.z - v2.z) * (v1.z - v2.z);\n}\n\n// vec4 intersect_sphere(vec3 ro, vec3 rd, vec3 sphc, float sphr)\n// {\n//     if (dist_squared(ro,sphc) < sphr * sphr)\n//     {\n//         return vec4(-1., vec3(0.));\n//     }\n\n//     vec3 sphro = ro - sphc;\n//     float a = dot(rd, rd);\n//     float b = dot(sphro, rd);\n//     float c = dot(sphro, sphro) - sphr * sphr;\n//     float sign = mix(-1., 1., step(0., a));\n//     float t = (-b + sign * sqrt(b*b - a*c))/a;\n\n//     vec3 n = normalize(ro + t * rd - sphc);\n//     return vec4(step(0., t), n);\n\n// }\n\nvec3 polar_to_cartesian(float sinTheta,\n                        float cosTheta,\n                        float sinPhi,\n                        float cosPhi)\n{\n    return vec3(sinTheta * cosPhi,\n                sinTheta * sinPhi,\n                cosTheta);\n}\n\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat sphere_df( vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat envsphere_df ( vec3 p, float r)\n{\n    return r - length(p);\n}\n\nfloat roundbox_df ( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.))-r;\n}\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct RaySampleInfo\n{\n    vec3 origin;\n    vec3 direction;\n    vec2 imagePlaneUV;\n};\n\n#define INIT_RAY_INFO() RaySampleInfo(vec3(0.) /* origin */, vec3(0.) /* direction */, vec2(0.) /* imagePlaneUV */)\n\nstruct SurfaceInfo\n{\n    float id;\n    vec3 incomingRayDir;\n    vec3 point;\n    vec3 normal;\n    float incomingRayLength;\n    float rayDepth;\n\n};\n#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInfo(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, 0. /* incomingRayLength */, 0. /* rayDepth */)\n\nstruct MaterialInfo\n{\n    float seed;\n    float specExponent;\n    float specIntensity;\n    vec3  baseColor;\n};\n#define INIT_MATERIAL_INFO(seed) MaterialInfo(seed, 1. /* specExponent */, 1. /* specIntensity */, vec3(.8) /* baseColor */)\n\n// **************************************************************************\n// SETUP WORLD\n\nvoid setup_globals()\n{\n\n    vec3 storedState = texture(iChannel1, vec2(0., 0.), -100.).rgb;\n    g_frame = float(iFrame) - storedState.r ;\n    g_samplingType = int(storedState.g + .5);\n    g_colorSamples = storedState.b;\n}\n\n// vec4 get_light(int i)\n// {\n//     if (i == 0) { return g_light0; }\n//     if (i == 1) { return g_light1; }\n//     if (i == 2) { return g_light2; }\n//     else { return g_light3; }\n// }\n\nRaySampleInfo setup_cameraRay(vec2 aaoffset)\n{\n\n    vec3 origin = vec3(0.0, 2., 6.0);\n    vec3 cameraPointsAt = vec3(0., .5, 0.);\n\n    float invAspectRatio = iResolution.y / iResolution.x;\n    vec2 imagePlaneUV = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    imagePlaneUV.y *= invAspectRatio;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( cameraPointsAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( imagePlaneUV.x * ix + imagePlaneUV.y * iy + .8 * iz );\n\n    return RaySampleInfo(origin, direction, imagePlaneUV);\n\n}\n\n// **************************************************************************\n// LIGHT\n\nconst float light_width = 5.0;\nconst float light_height = 5.0;\nconst float light_area = light_width * light_height;\nconst vec3 light_normal = vec3(1.0, 0.0, 0.0);\nconst vec3 light_corner0 = vec3(-2.75 + 0.01, -0.6,                -1.5 - light_width/2.0);\nconst vec3 light_corner1 = vec3(-2.75 + 0.01, -0.6 + light_height, -1.5 + light_width/2.0);\n\nvec4 intersect_light(vec3 ro, vec3 rd)\n{\n\tfloat t = dot(light_corner0 - ro, light_normal) / dot(rd, light_normal);\n\tif (t < 0.0)\n\t\treturn vec4(-1.0, vec3(0.0));\n\tvec3 pos = ro + t * rd;\n\tif (any(lessThan(pos.yz, light_corner0.yz)) || any(greaterThan(pos.yz, light_corner1.yz)))\n\t\treturn vec4(-1.0, vec3(0.0));\n\treturn vec4(t, light_normal);\n}\n\nfloat light_pdf( vec3 light_point, SurfaceInfo surface )\n{\n\treturn dist_squared(light_point, surface.point) / (light_area * abs(dot(light_normal, normalize(light_point - surface.point))));\n}\n\nvec3 sample_light( SurfaceInfo surface,\n                   MaterialInfo material,\n                 out float pdf )\n{\n    vec2 u12 = hash21(material.seed);\n\n\tvec3 light_point = light_corner0;\n\tlight_point.z += light_width * u12.x;\n\tlight_point.y += light_height * u12.y;\n\n\tvec3 light_dir = normalize(light_point - surface.point);\n\tif (dot(light_dir, surface.normal) < 0.0)\n\t{\n\t\tpdf = 0.0;\n\t\treturn vec3(0.0);\n\t}\n\n\tpdf = light_pdf(light_point, surface);\n    return light_dir;\n}\n\nfloat light_df(vec3 p)\n{\n\treturn roundbox_df(p - vec3(-2.75, -0.6, -1.5), vec3(.02, light_height, light_width), .01);\n}\n\n// **************************************************************************\n// MARCH\n\nvec2 union_obj(vec2 o1, vec2 o2)\n{\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec2 map(float depth, vec3 p)\n{\n\tvec2 floorObj = vec2(roundbox_df(p - vec3(0.0, -0.6, -1.5), vec3(5.5, .05, 5.0), .02), FLOOR_ID);\n\n    vec2 resultObj = floorObj;\n\n    float backdropDF = roundbox_df(p + vec3(0., 1., 0.), vec3(20.,.2,10.), 0.);\n    backdropDF = min(backdropDF, roundbox_df(rotate_xaxis(p - vec3(0., -3.8, -3.2), cos(.5), sin(.5)), vec3(20., 10., .2), 0.));\n    vec2 backdropObjs = vec2(backdropDF, BACKDROP_ID);\n    resultObj = union_obj(resultObj, backdropObjs);\n\n    if (depth < .5)\n    {\n        vec2 lightObjs = vec2(light_df(p), LIGHT_ID);\n        resultObj = union_obj(resultObj, lightObjs);\n    }\n\n    resultObj = union_obj(resultObj, vec2( envsphere_df(p, 11.), ENVIRONMENT_ID) );\n\n    return resultObj;\n}\n\nvec3 calc_normal(vec3 p)\n{\n\n    vec3 epsilon = vec3(0.001, 0., 0.);\n\n    vec3 n = vec3(map(1., p + epsilon.xyy).x - map(1., p - epsilon.xyy).x,\n                  map(1., p + epsilon.yxy).x - map(1., p - epsilon.yxy).x,\n                  map(1., p + epsilon.yyx).x - map(1., p - epsilon.yyx).x);\n\n    return normalize(n);\n}\n\nSurfaceInfo dist_march(float depth, vec3 ro, vec3 rd)\n{\n    SurfaceInfo surface = INIT_SURFACE_INFO(rd);\n\n    float t = 0.;\n    vec3 p = ro;\n    vec2 obj = vec2(0.);\n    float d = REALLY_BIG_NUMBER;\n\n    for (int i = 0; i < 64; i++)\n    {\n        obj = map(depth, p);\n        d = obj.x;\n\n        t += d;\n        p += rd * d;\n\n        if (d < .001) { break; }\n        obj.y = 0.;\n\n    }\n\n    surface.id = obj.y;\n    surface.point = p;\n    surface.normal = calc_normal(surface.point);\n    surface.incomingRayLength = t;\n    surface.rayDepth = depth;\n\n    return surface;\n}\n\nvoid calc_binormals(vec3 normal,\n                    out vec3 tangent,\n                    out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y))\n    {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    else\n    {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n\n    binormal = cross(normal, tangent);\n}\n\n// vec3 uniform_sample_cone(vec2 u12,\n//                          float cosThetaMax,\n//                          vec3 xbasis, vec3 ybasis, vec3 zbasis)\n// {\n//     float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n//     float sinTheta = sqrt(1. - cosTheta * cosTheta);\n//     float phi = u12.y * TWO_PI;\n//     vec3 samplev = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n//     return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;\n// }\n\nvec3 brdf(vec3 wi,\n          vec3 wo,\n          vec3 n,\n          MaterialInfo material)\n{\n\n    float cosThetaN_Wi = abs(dot(n, wi));\n    float cosThetaN_Wo = abs(dot(n, wo));\n    vec3 wh = normalize(wi + wo);\n    float cosThetaN_Wh = abs(dot(n, wh));\n\n    // Compute geometric term of blinn microfacet\n    float cosThetaWo_Wh = abs(dot(wo, wh));\n    float G = min(1., min((2. * cosThetaN_Wh * cosThetaN_Wo / cosThetaWo_Wh),\n                           (2. * cosThetaN_Wh * cosThetaN_Wi / cosThetaWo_Wh)));\n\n    // Compute distribution term\n    float D = (material.specExponent+2.) * INV_TWO_PI * pow(max(0., cosThetaN_Wh), material.specExponent);\n\n    // assume no fresnel\n    float F = 1.;\n\n    return material.baseColor * D * G * F / (4. * cosThetaN_Wi * cosThetaN_Wo);\n}\n\n\nconst vec3 light_color = 20.0 * vec3(1., .98, .95);\nvec3 light_emission(vec3 p, vec3 lp, vec3 ln)\n{\n    return light_color / dist_squared(p, lp);\n}\n\nfloat calc_visibility( vec3 ro, vec3 rd, float ray_extent )\n{\n    SurfaceInfo surface = dist_march(1., ro, rd);\n    return step(ray_extent, surface.incomingRayLength);\n}\n\n// float light_pdf( vec4 light,\n//                 SurfaceInfo surface )\n// {\n\n\n//     float sinThetaMax2 = light.w * light.w / dist_squared(light.xyz, surface.point);\n//     float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n//     return 1. / (TWO_PI * (1. - cosThetaMax));\n// }\n\n// vec3 sample_light( SurfaceInfo surface,\n//                    MaterialInfo material,\n//                    vec4 light,\n//                  out float pdf )\n// {\n//     vec2 u12 = hash21(material.seed);\n\n//     vec3 tangent = vec3(0.), binormal = vec3(0.);\n//     vec3 ldir = normalize(light.xyz - surface.point);\n//     calc_binormals(ldir, tangent, binormal);\n\n//     float sinThetaMax2 = light.w * light.w / dist_squared(light.xyz, surface.point);\n//     float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n//     vec3 light_sample = uniform_sample_cone(u12, cosThetaMax, tangent, binormal, ldir);\n\n//     pdf = -1.;\n//     if (dot(light_sample, surface.normal) > 0.)\n//     {\n//         pdf = 1. / (TWO_PI * (1. - cosThetaMax));\n//     }\n\n//     return light_sample;\n\n// }\n\nfloat brdf_pdf( vec3 wi, vec3 wo,\n                SurfaceInfo surface,\n                MaterialInfo material )\n{\n    vec3 wh = normalize(wi + wo);\n    float cosTheta = abs(dot(wh, surface.normal));\n\n    float pdf = 0.0;\n    if (dot(wo, wh) > 0.)\n    {\n        pdf = ((material.specExponent + 1.) * pow(max(0., cosTheta), material.specExponent))/(TWO_PI * 4. * dot(wo, wh));\n    }\n\n    return pdf;\n}\n\n\nvec3 sample_brdf( SurfaceInfo surface,\n                 MaterialInfo material,\n                out float pdf)\n{\n\n    vec2 u12 = hash21(material.seed);\n\n    float cosTheta = pow(max(0., u12.x), 1./(material.specExponent+1.));\n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    float phi = u12.y * TWO_PI;\n\n    vec3 whLocal = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n\n    vec3 tangent = vec3(0.), binormal = vec3(0.);\n    calc_binormals(surface.normal, tangent, binormal);\n\n    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * surface.normal;\n\n    vec3 wo = -surface.incomingRayDir;\n    if (dot(wo, wh) < 0.)\n    {\n       wh *= -1.;\n    }\n\n    vec3 wi = reflect(surface.incomingRayDir, wh);\n\n    pdf = ((material.specExponent + 1.) * pow(clamp(abs(dot(wh, surface.normal)),0.,1.), material.specExponent))/(TWO_PI * 4. * dot(wo, wh));\n    return wi;\n}\n\nfloat power_heuristic(float nf,\n                      float fPdf,\n                      float ng,\n                      float gPdf)\n{\n    float f = nf * fPdf;\n    float g = ng * gPdf;\n    return (f*f)/(f*f + g*g);\n}\n\nvec3 integrate_lighting( SurfaceInfo surface,\n                       MaterialInfo material,\n                       vec3 wi)\n{\n    vec3 lcol = vec3(0.);\n    // for (int i = 0; i < 4; i += 1)\n    {\n        if (g_samplingType == LIGHT_IMPORTANCE_SAMPLING ||\n            g_samplingType == MULTIPLE_IMPORTANCE_SAMPLING)\n        {\n            // sample light\n            float lpdf = -1.;\n            vec3 lightSample = sample_light(surface, material, lpdf);\n\n\n            if (lpdf > 0.)\n            {\n                vec4 r = intersect_light(surface.point, lightSample);\n                if (r.x > .0)\n                {\n                    vec3 colorSamples = mix(vec3(1.), vec3(1., .4, .4), g_colorSamples);\n                    float bpdf = brdf_pdf(wi, lightSample, surface, material);\n                    float misWeight = power_heuristic(1., lpdf, 1., bpdf);\n                    if (g_samplingType == LIGHT_IMPORTANCE_SAMPLING)\n                    {\n                        misWeight = 1.;\n                    }\n\n                    float visibility = calc_visibility( surface.point + lightSample * .01, lightSample, r.x);\n                    vec3 le = light_emission(surface.point, surface.point + lightSample * r.x, r.yzw);\n                    // specular\n                    lcol += material.specIntensity * colorSamples * visibility * brdf(wi, lightSample, surface.normal, material) *\n                                le * abs(dot(lightSample, surface.normal)) *\n                                (misWeight/lpdf);\n\n                    // diffuse - cheated lambertian\n                    // reuse visibility\n                    lcol += material.baseColor * visibility * abs(dot(surface.normal, lightSample)) * le * INV_TWO_PI*\n                        (misWeight/lpdf);\n\n\n                }\n            }\n        }\n\n\n\n        if (g_samplingType == BRDF_IMPORTANCE_SAMPLING ||\n            g_samplingType == MULTIPLE_IMPORTANCE_SAMPLING)\n        {\n            // sample brdf\n            float bpdf = -1.;\n            vec3 brdfSample = sample_brdf(surface, material, bpdf);\n            if (bpdf > 0.)\n            {\n                vec4 r = intersect_light(surface.point, brdfSample);\n                if (r.x > 0.)\n                {\n                    vec3 colorSamples = mix(vec3(1.), vec3(.4, 1., .4), g_colorSamples);\n\n                    float lpdf = light_pdf(surface.point + brdfSample * r.x, surface);\n                    float misWeight = power_heuristic(1., bpdf, 1., lpdf);\n                    if (g_samplingType == BRDF_IMPORTANCE_SAMPLING)\n                    {\n                        misWeight = 1.;\n                    }\n\n                    float visibility = calc_visibility( surface.point + brdfSample * .01, brdfSample, r.x);\n\n                    vec3 le = light_emission(surface.point, surface.point + brdfSample * r.x, r.yzw);\n                    // specular\n                    lcol += material.specIntensity * colorSamples * visibility * brdf(wi, brdfSample, surface.normal, material) *\n                        le *\n                        abs(dot(brdfSample, surface.normal)) *\n                        (misWeight/bpdf);\n\n                    // diffuse - cheated lambertian\n                    // reuse visibility\n                    lcol += material.baseColor * visibility * abs(dot(surface.normal, brdfSample)) * le * INV_TWO_PI *\n                        (misWeight/bpdf);\n\n                }\n            }\n        }\n\n\n    }\n\n    return lcol;\n}\n\nvec3 calc_pixelColor( float seed )\n{\n\n    vec3 pcol = vec3(0.);\n\n    RaySampleInfo currSample = setup_cameraRay( sin(.712 * seed) * vec2(.6 * cos(.231 * seed), .6 * sin(.231 * seed)) );\n\n\n    for (float depth = 0.; depth < 1.; depth+=1.)\n    {\n        SurfaceInfo surface = dist_march(depth,\n                                         currSample.origin,\n                                         currSample.direction);\n\n        MaterialInfo material = INIT_MATERIAL_INFO(seed);\n        float roughness = 1.;\n\n        if (surface.id < .5)\n        {\n            break;\n        }\n        else if (MATCHES_ID(surface.id, LIGHT_ID))\n        {\n            pcol = light_color;\n            break;\n        }\n        else if (MATCHES_ID(surface.id, FLOOR_ID))\n        {\n            roughness = 1.0;\n            material.baseColor = vec3(.05);\n        }\n        else if (MATCHES_ID(surface.id, BACKDROP_ID))\n        {\n            roughness = 1.;\n            material.baseColor = vec3(.015, .012, .012);\n        }\n        else\n        {\n            break;\n        }\n\n        material.specExponent = floor(max(1., (1. - pow(roughness, .15)) * 40000.));\n        material.specIntensity = 15.;\n\n        pcol += integrate_lighting(surface, material, -surface.incomingRayDir);\n\n        currSample.direction = reflect(surface.incomingRayDir, surface.normal);\n        currSample.origin = surface.point + .01 * currSample.direction;\n    }\n\n    return pcol;\n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    setup_globals();\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // ----------------------------------\n    // SAMPLING\n\n    float seed = g_frame + hash12( uv );\n    //float seed = float(floor(float(g_frame)/10.));\n\n    vec3 currPixelColor = calc_pixelColor( seed );\n\n    // ----------------------------------\n    // FINAL GATHER\n\n    vec3 finalColor = vec3(0.);\n\n    if (g_frame > .5)\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\n\n    finalColor += currPixelColor;\n\n    fragColor = vec4(finalColor,1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 442, 464, 464, 540], [635, 635, 692, 692, 1011]], "test": "untested"}
{"id": "dtSSRz", "name": "xXx_Monolith_xXx", "author": "SnoopethDuckDuck", "description": "make sure to click the sound!\n\nsame as fork, very very messy code", "tags": ["h"], "likes": 16, "viewed": 240, "published": 3, "date": "1675551828", "time_retrieved": "2024-07-30T18:12:09.007430", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 80.\n#define SURF_DIST .001\n\n#define t iTime\n#define smx 0.4\n\n//https://www.shadertoy.com/view/sslGzN\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(float n){\n    return pow(Semitone,(n-8.))*440./48000.;\n}\n\nfloat smh(float a, float b, float k) {\n    return clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float a = 0.14*t+pi/4.;\n    float r = 12. + 6. * sin(a);\n    r = mix(r, 7., tanh(0.005*t));\n    vec3 ro = vec3(r*cos(a), 1.8 + 1. * sin(a), r*sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {\n    p.y -= 0.005 * dot(p.xz, p.xz);\n    float pd = p.y - 0.5;\n    \n    //p.xz -= 13.5-.2 * t;\n    float sc = 1.;//0.25;\n    float y1 = texture(iChannel2, sc * 0.1 * (p.xz - 0.2*t)).r;\n    float y2 = texture(iChannel2, sc * 0.05 * (p.xz - 0.2*t)).r;\n    float y3 = texture(iChannel2, sc * 0.12 * (p.xz - 0.2*t)).r;\n    //pd += smin(y2,y1, .5+.5*cos(t));\n   // pd += y1 + y2 + y3;\n    //pd += .5*cos(pi*abs(y1)/(1.+abs(y2)));\n    pd += 0.2*smoothstep(-0.3,0.1, 0.05 - abs(y3 - 0.5));\n\n    /*\n    vec3 ip = 10. * p;\n    ip.xz = floor(ip.xz) + 0.5;\n    vec3 fp = 10. * p;\n    fp.y += -5.+5.*cos(pi*abs(y1)/(1.+abs(y2)));\n    fp.xz = fract(fp.xz) - 0.5;\n    //*/\n    \n    //float d = box(fp, vec3(0.5 * y3)) - 0.05; \n   // pd = smin(td,pd,smx);\n    //smh(td,pd,smx\n    float band = KeyToFrequency(33.);\n    float s = texture(iChannel0, vec2(band, 0.25)).x;\n    //d = min(d, length(p) - 2. * s);\n    p.xz *= rot(0.2*t + 0.5*pd);\n    float sd = length(p-vec3(0,1.5,0)) -0.5 - 2.5*exp(-0.2*pd);\n    \n    sd = mix(sd, mlength(p.xz)-1., 0.5);\n   // d = smin(d,pd, 0.2);\n   // pd = min(pd, sd);//, 0.5*s*s);\n    if (sd < pd)\n        return vec2(sd, 0.);\n    //if (sd < d)\n    //    return vec2(sd, 0.);\n    return vec2(pd, 20000.);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        m.x *= 0.9 + 0.1 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return exp(-14.*clamp(occ,0.,1.));//clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0,2,0), 1.5);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    \n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = normalize(p + vec3(100,22.5,0));//normalize(vec3(1,2,3));\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 16.);\n        float fres = pow(.5 + .5 * dot(rd, n), 2.*exp(-0.1*length(p.xz)));\n     \n        col = vec3(dif);\n        float c = .5+.5*cos(10.*p.y);\n        col *= texture(iChannel1, vec2(0.02*m.z,c)).rgb;//(.8+.2*cos(2.*pi*ao));  \n        float sh = shadow(p + (2.+hash(p.x,p.z)) * SURF_DIST * n, ld);\n        float ao = AO(p, n);\n        col *= 0.2 + 0.8 * sh;\n        col *= 0.1 + 0.9 * ao;\n        vec3 c2 = vec3(1,-.5,-5.);// mix(vec3(1,0,0),vec3(0,0,1),rd);\n        col = mix(col,c2 +vec3(200,143,112)/255., fres);\n        col = clamp(col, 0., 1.);\n        if (m.z == 0.)\n            col *= m.z;\n       // col *= 0.1 + 0.9 * ao;\n    }\n    col = mix(col, vec3(200,143,112)/255., 1.-exp(-0.08 * length(p.xz)));\n    vec3 tx = texture(iChannel1, vec2(0.5*m.z)).rgb;\n    col = mix(col, tx, (1.-exp(-0.01 * m.y)));\n    \n    col = 1.-pow(1.-col, vec3(1./1.8));\t// gamma correction\n    vec3 col2 = tanh(vec3(4.2,3.5,3.4)*col);\n    \n    // -- everything below here I've given up on understanding --\n    \n    float a = 0.14*t+pi/4.;\n    float sz = 0.5 + 0.5 * sin(a);\n    sz = mix(sz, -2., tanh(0.05*max(0.,t-28.)));\n   // float sz = 0.4 - 0.2 * sin(a);\n    //float s = texture(iChannel0, vec2(uv.y,0.25)).y;\n    float k = 1. / iResolution.y;\n    float mx = smoothstep(-k, k, mix(0.6,0.2,sz) - abs(uv.x));\n    \n    float wav = texture(iChannel0, vec2((0.5-0.4*tanh(0.1*t))*abs(uv.x)+0.5, 0.25)).x;\n    float ss = exp(-20.*abs(uv.y) + 1.*(wav-0.55));\n    float ss2 = step(abs(uv.y), tanh(0.019*t) + tanh(0.1*t)*(wav));\n    float ss3 = smoothstep(-k, k, -wav + 0.5 - uv.y) \n              - smoothstep(-k, k, -wav + 0.5 - uv.y - 0.02);\n    ss3 *= exp(-10.*abs(uv.x));\n    float mx2 = 1.-step(1., m.z);\n    col = mix(col, col2, mx);\n    col *= mix(2.*(1.-tanh(0.03*t))*ss, 4.*ss3, mx2)\n    + ss2 * vec3(1,tanh(t), tanh(0.1*t));\n    col = pow(col, vec3(1.2));\n    //col = pow(col, vec3(1.-exp(-abs(uv.x + s))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32210, "src": "https://soundcloud.com/beatsantique/bassnectar-so-butterfly-beats-antique-remix-ft-sorne?in=madison-davis-734836374/sets/beebooboobop&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//        Tater - raymarching\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 279, 279, 326], [328, 328, 366, 366, 419], [421, 421, 448, 448, 535], [537, 537, 549, 549, 827], [829, 829, 847, 847, 2070], [2072, 2072, 2111, 2111, 2619], [2621, 2621, 2640, 2640, 2822], [2824, 2824, 2868, 2868, 3059], [3061, 3061, 3093, 3093, 3357], [3359, 3359, 3397, 3397, 3740], [3742, 3742, 3799, 3799, 6228]], "test": "untested"}
{"id": "dlSXRR", "name": "Abstract gravitational well", "author": "mrange", "description": "CC0: Abstract gravitational well\nOnce again inspired from various twitter art tried to create\nsomething that looks like a gravitational\nTurned out good enough to share\n", "tags": ["gravity"], "likes": 37, "viewed": 491, "published": 3, "date": "1675545315", "time_retrieved": "2024-07-30T18:12:09.891067", "image_code": "// CC0: Abstract gravitational well\n//  Once again inspired from various twitter art tried to create\n//  something that looks like a gravitational\n//  Turned out good enough to share\n\n//  I am a bit annoyed by the need for high iteration counts, \n//   and alias effects around the near throat of the well.\n\n//#define I_DO_NOT_LIKE_THE_FLASH_EFFECT\n\n// The \"CLASSIC\" Version that suffers from alias effects\n//  I have attempted to fix them here but I published a new shader so I wanted\n//  this shader to still have alias effects to demonstrate the difference\n//  The updated version: https://www.shadertoy.com/view/43G3Wc\n//  If you like to see the \"fixed\" version uncomment next line\n#define CLASSIC\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.001\n#define MAX_RAY_LENGTH  30.0\n#define MAX_RAY_MARCHES 100\n#define NORM_OFF        0.05\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.025, 0.85, 0.5));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions/\nfloat sphereD(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n\t\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat parabola(vec2 pos, float k) {\n  pos = pos.yx;\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat parabola(vec3 p, float k, float o) {\n  vec2 q = vec2(length(p.xz) - o, p.y);\n  return parabola(q, k);\n}\n\nfloat df(vec3 p) {\n  return parabola(p, .9, 0.5);\n}\n\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += clamp(vec3(0.0025/max(abs(rd.y), 0.5*fwidth(rd.y)))*glowCol, 0.0, 1.0);\n  col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += 2.0*sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\n\nvec3 render1(vec3 ro, vec3 rd) {\n  float t = rayMarch(ro, rd);\n\n  vec3 col = vec3(0.0);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float fre = 1.0+dot(rd, n);\n  fre *= fre;\n  float dif = dot(sunDir1, n); \n\n  if (t < MAX_RAY_LENGTH) {\n    col = vec3(0.0);\n    \n    const float ExpBy = log2(1.5);\n    float a = 0.2*TIME;\n    vec2 pp = toPolar(p.xz);\n    float la = length(pp.x*exp2(ExpBy*fract(a)));\n    la = log2(la)/ExpBy;\n    mod1(la, 1.0);\n    float lo = pp.y;\n    mod1(lo, TAU/12.0);\n    \n    float fo = 1.0/(1.0+0.25*pp.x);\n    float gd = pmin(abs(la*fo)-0.0025, abs(lo)-0.0025*fo, 0.0125);\n#ifndef CLASSIC    \n    gd = max(gd, 1E-3*(1.+10.*smoothstep(.33,1., fre)));\n#endif\n\n    vec3 gcol = 0.01*glowCol/max(gd, 0.0001);\n#ifndef CLASSIC    \n    gcol *= smoothstep(1.0, 0.85, fre);\n#endif\n    float mm = max(max(gcol.x, gcol.y), gcol.z);\n    \n    col += gcol;\n    col += mix(0.33, 1.0, fre)*render0(p, r);\n    col += smoothstep(0.66, 1.0, fre)*skyCol*0.25;\n    col += sunCol1*dif*dif*diffCol;\n    \n#ifdef I_DO_NOT_LIKE_THE_FLASH_EFFECT\n    const float flash = 0.;\n#else\n    float flash = exp(-6.*fract(a+0.15));\n#endif\n    float sd = sphereD(ro, rd, vec4(0.,-0.25,0.,1.+flash), t);\n    col += sd*sd*mix(20.,60., flash)*glowCol;\n  }\n\n\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = TIME*0.5;\n  \n  vec3 ro = 1.0*vec3(5.0, 3.0, 0.);\n  ro.xz *= ROT(-0.1*tm);\n  const vec3 la = vec3(0.0, 0.5, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  col -= 0.015*vec3(3.,2.,1.)*(length(p)+0.25);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1170, 1170, 1192, 1192, 1338], [2028, 2128, 2147, 2147, 2234], [2237, 2337, 2376, 2376, 2461], [2463, 2570, 2596, 2596, 2780], [2782, 2877, 2935, 2935, 3415], [3417, 3503, 3542, 3542, 3667], [3669, 3757, 3779, 3779, 3823], [3825, 3918, 3960, 3960, 4007], [4009, 4127, 4154, 4154, 4230], [4232, 4350, 4385, 4385, 4737], [4739, 4832, 4874, 4874, 4941], [4943, 4943, 4961, 4961, 4994], [4997, 4997, 5020, 5020, 5228], [5230, 5230, 5264, 5264, 5596], [5598, 5598, 5630, 5630, 6306], [6309, 6309, 6341, 6341, 7592], [7594, 7594, 7624, 7624, 8171], [8173, 8173, 8230, 8230, 8421]], "test": "untested"}
{"id": "clXSDl", "name": "minimal distances (voronoi)", "author": "jonasfrey", "description": "left                                      right\ncircle (euclidean)                square (manhattan/cityblock/taxicab, whatoever)\n", "tags": ["voronoi"], "likes": 6, "viewed": 188, "published": 3, "date": "1675543923", "time_retrieved": "2024-07-30T18:12:10.738801", "image_code": "#define n_tau 6.2831\nfloat f_n_rnd(vec2 o)\n{\n\treturn fract(sin(dot(o.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 f_o_rgb_from_hsl( in vec3 c )\n{\n    vec3 rgb = clamp(\n        abs(\n            mod(\n                c.x*6.0\n                 +vec3(0.0,4.0,2.0)\n                , 6.0\n               )\n             -3.0\n           )\n         -1.0,\n        0.0,\n        1.0\n    );\n\n    return \n        c.z \n         + c.y \n         * (rgb-0.5)\n         *(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat f_n_dist_euclidean(vec2 o_p1, vec2 o_p2){\n    vec2 o_delta = o_p1-o_p2;\n    \n    return sqrt(\n        pow(o_delta.x,2.)\n        + pow(o_delta.y,2.)\n    );\n}\nfloat f_n_dist_manhatten(vec2 o_p1, vec2 o_p2){\n    return abs(o_p1.x-o_p2.x) + abs(o_p1.y-o_p2.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    vec2 o_mc_nor = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 o_fc_nor_nooff = fragCoord.xy/iResolution.xy;\n    vec2 o_mc_offset_iresratio = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n    if(float(iMouse.z>0.)!= 1.){\n        o_mc_offset_iresratio = vec2(\n            sin(iTime)*0.2,\n            cos(iTime)*0.2\n        );\n    }\n    \n    vec2 o_mc_nor_nooff = iMouse.xy/iResolution.xy;\n    float n_resratio_xtoy = iResolution.x / iResolution.y;\n    float n_its = 333.;\n    float n_deuc_min = 1.;\n    float n_dman_min = 1.;\n    float n_iteuc_min_nor = 0.;\n    float n_itman_min_nor = 0.;\n    for(float n_it = 0.; n_it< n_its; n_it+=1.){\n        float n_it_nor = n_it/n_its;\n        float n_rnd = f_n_rnd(vec2(n_it, 1.-n_it));\n        float n_rnd2 = f_n_rnd(vec2(n_rnd, 1.-n_rnd));\n        vec2 o_p_nor = (vec2(n_rnd, n_rnd2)-.5)*vec2(n_resratio_xtoy, 1.);\n        float n_deuc = f_n_dist_euclidean(o_p_nor,o_fc_nor);\n        if(n_deuc < n_deuc_min){\n            n_deuc_min = n_deuc;\n            n_iteuc_min_nor = n_it/n_its;\n        }\n        float n_dman = f_n_dist_manhatten(o_p_nor,o_fc_nor);\n        if(n_dman < n_dman_min){\n            n_dman_min = n_dman;\n            n_itman_min_nor = n_it/n_its;\n        }\n    }\n    \n    float n_bx = float(o_fc_nor.x > o_mc_nor.x);\n    float n_by = float(o_fc_nor.y > o_mc_nor.y);\n    \n    float n_d = n_bx*n_iteuc_min_nor + (1.-n_bx)*n_itman_min_nor;\n    float n_dmin = n_bx*n_deuc_min + (1.-n_bx)*n_dman_min;\n    \n    vec3 o_colman = f_o_rgb_from_hsl(vec3(n_itman_min_nor, 1., 0.5));\n\n    vec3 o_coleuc = f_o_rgb_from_hsl(vec3(n_iteuc_min_nor, 1., 0.5));\n    vec3 o_col = n_bx*o_coleuc+(1.-n_bx)*o_colman;\n\n\n    \n    o_col = n_by*o_col + (1.-n_by)*vec3(n_d);\n    \n    //o_col += vec3(o_collncntr,1.);\n    \n    vec3[] a_o_col = vec3[] (\n        \n        vec3(sqrt(n_deuc_min)),\n        vec3(sqrt(n_dman_min)),\n        \n        vec3(n_iteuc_min_nor),\n        vec3(n_itman_min_nor),\n        \n        f_o_rgb_from_hsl(vec3(n_iteuc_min_nor, 1., 0.5)),\n        f_o_rgb_from_hsl(vec3(n_itman_min_nor, 1., 0.5))\n        \n    );\n    vec2 o_scl = vec2(2.,3.);\n    float n_len_a_o_col = float(a_o_col.length());\n    vec2 o_trn = \n        (\n         (o_fc_nor_nooff-o_mc_offset_iresratio) / (1./o_scl)\n    );\n    vec2 o_trn_flr = floor(o_trn);\n\n    float n_thick = 0.01;\n    float n_aa = 1./iResolution.x;\n    \n    float n_d_line_x = smoothstep(\n        n_thick+n_aa, \n        n_thick, \n        fract(o_trn.x)\n    );\n    float n_d_line_y = smoothstep(\n        (n_thick+n_aa)*n_resratio_xtoy, \n        (n_thick)*n_resratio_xtoy, \n        fract(o_trn.y)\n    );\n    float n_d_line = \n        n_d_line_x+\n        n_d_line_y;\n        \n    float n_idx = o_trn_flr.x+o_scl.x*o_trn_flr.y;\n    \n    vec3 o_color = a_o_col[int(n_idx)];\n    o_color += vec3(n_d_line);\n    vec2 o_dlt = o_fc_nor_nooff-o_mc_offset_iresratio;\n    float b_inside = \n        float(\n            o_dlt.x > 0. && o_dlt.x < 1.\n            &&\n            o_dlt.y > 0. && o_dlt.y < 1.\n            );\n    fragColor = vec4(o_color*b_inside, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 112], [114, 114, 150, 150, 478], [480, 480, 527, 527, 642], [643, 643, 690, 690, 744]], "test": "untested"}
{"id": "DlXSDl", "name": "Engine Exhaust", "author": "natsew", "description": "My first attempt at shaders after watching some YouTube videos.  Creating space engine 2D exhaust using some parabolas.\nNext, I want to try to write a pixelated version of this to use in my hobby game project as a random exhaust generator.", "tags": ["space", "spaceship", "engine", "exhaust"], "likes": 0, "viewed": 219, "published": 3, "date": "1675529459", "time_retrieved": "2024-07-30T18:12:11.549633", "image_code": "//Creates an engine exhaust from parabolas. \n\n//offset.x for moving parabola left\\right\n//offset.y for moving it up\\down\n//that's same as in standart math\n//anims.x for animating brightest part\n//anims.y used for blur on the exhaust's edges\nvec4 Exhaust(vec2 uv, float sharpness, vec2 offset, vec2 anims) { \n    vec4 col = vec4(.0);\n    //base color\n    vec4 fire = vec4(.0, .7, .8, 0.);\n    \n    //current parabola point for uv.x\n    vec2 f_point = vec2(uv.x, pow(uv.x + offset.x, 2.) * sharpness + offset.y); \n    \n    //lowest brigthness layer\n    fire.a = smoothstep(f_point.y-anims.y-.1, f_point.y, uv.y);      \n    col += fire;\n     \n    //middle brigthness layer\n    //move created parabole up taking care of offsets\n    f_point.y += .3 * (1. - offset.y);\n    fire *= smoothstep(f_point.y-.1-anims.y, f_point.y, uv.y) * .25; \n    col.rgb += fire.rgb;       \n       \n    //highest brightness layer\n    f_point.y += .3 * (1. - offset.y);\n    //sqrt function to interpolate between it and original parabola\n    vec2 s_point = vec2(uv.x, sqrt(abs(uv.x + offset.x)) * 1.8 + offset.y); \n    \n    vec2 n_point = vec2(uv.x, mix(s_point.y, f_point.y, anims.x));\n    \n    fire *= smoothstep(n_point.y-.1-anims.y, n_point.y, uv.y); \n    col.rgb += fire.rgb;\n\n    return col;\n}\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x -= .5;\n    uv.y -= .1;\n    uv.x *= iResolution.x / iResolution.y;    \n     \n    vec4 col = vec4(vec3(0.), 1.);\n    \n    float inside = 0.3 * sin(iTime*5.)/2.+.5;\n    float outside = 0.05 + (sin(iTime*5.)+1.) / 100.;\n    \n    //just to test 'starting' animation\n    float starting = (sin(iTime*3.)+1.)/2.*.5;\n    starting = 0.; //comment here to try it\n    \n    vec4 left = Exhaust(uv, 20., vec2(.4, .5+starting), vec2(inside, outside));\n    col = mix(col, left, left.a);\n    \n    vec4 rigth = Exhaust(uv, 20., vec2(-.4, .5+starting), vec2(inside, outside));\n    col = mix(col, rigth, rigth.a);\n       \n    vec4 main = Exhaust(uv, 7., vec2(0, .1+starting), vec2(inside, outside));    \n    col = mix(col, main, main.a);\n  \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 241, 306, 306, 1272], [1274, 1277, 1334, 1334, 2135]], "test": "untested"}
{"id": "dtl3zj", "name": "CoposDeNieve", "author": "Ninomocos", "description": "Copos de nieve cayendo", "tags": ["3dpointssnow"], "likes": 5, "viewed": 213, "published": 3, "date": "1675519188", "time_retrieved": "2024-07-30T18:12:12.377420", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 camera = vec3(.0,.0,-20.0);\n    \n    vec3 pointOnScreen = vec3( uv , 0.0);\n    \n    float t = 4.0;\n    \n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0 ; i < 250.0 ; i++)\n    {\n        float d = 10000.0;\n        float originRad = 1000.0;\n        float randx = -originRad/2.0 + random(vec2(i+1.0)) * originRad;\n        float randy = -originRad/2.0 + random(vec2(i+2.0)) * originRad;\n        float randz = random(vec2(i+3.0)) * 1000.0;\n        float offsetTime = random(vec2(i)) * 4.0;\n\n        float seedRandom = floor( ( iTime + offsetTime  ) / t);\n        \n        //float x = -25.0 + random( vec2(seedRandom) ) * 50.0;\n        //float y = -75.0 + random( vec2(seedRandom) ) * 500.0;\n        float z =  d - fract( ( iTime + offsetTime ) / t) * d;\n        \n        vec3 point = vec3(randx , randy , z + randz);\n        float rotvel = 3.14;\n        float rotamp = 30.0;\n        point.x += cos((iTime+offsetTime)*rotvel) * rotamp;\n        point.y += sin((iTime+offsetTime)*rotvel) * rotamp;\n        float h =  length( cross(pointOnScreen - camera, point) ) / distance(camera , pointOnScreen);\n        h = 1.0 - h/2.0;\n        h = smoothstep( 0.0 , 0.5, h);\n        col += vec3(h);\n        \n        \n        \n\n    }\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtl3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [102, 102, 159, 195, 1592]], "test": "untested"}
{"id": "ctBSRR", "name": "Colorful interference pattern", "author": "mrange", "description": "CC0: Colorful interference pattern\n Saw some classic interference patterns on twitter.\n Tried it out myself and then tinkered a bit with the colors to spice it up a bit\n\n", "tags": ["2d", "interference"], "likes": 32, "viewed": 505, "published": 3, "date": "1675518895", "time_retrieved": "2024-07-30T18:12:13.235126", "image_code": "// CC0: Colorful interference pattern\n//  Saw some classic interference patterns on twitter.\n//  Tried it out myself and then tinkered a bit with the colors to spice it up a bit\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nfloat df(vec2 p) {\n  const float m = 0.25;\n  float l = length(p);\n  l = mod(l+(0.5*m), m)-(0.5*m);\n  return abs(l)-(m*0.25);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  float tm = TIME*0.3;\n  vec2 p0 = p+sin(vec2(1.0, sqrt(0.5))*(tm+100.0));\n  vec2 p1 = p+sin(1.2*vec2(1.0, sqrt(0.5))*(tm+200.0));\n  float sm = 0.0666*length(p);\n  float d0 = df(p0);\n  float d1 = df(p1);\n  float d = d0;\n  d = pmax(d, d1, sm);\n  float dd = -d0;\n  dd = pmax(dd, -d1, sm);\n  d =  min(d, dd);\n  const float so = 8.0;\n  const float co = 0.5;\n  vec3 bcol0 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p0)+1.0-TIME))/(so*dot(p0, p0)+0.0001);\n  vec3 bcol1 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p1)+3.0+TIME))/(so*dot(p1, p1)+0.0001);\n  vec3 bcol = (bcol0+bcol1);\n  vec3 col = vec3(0.0);\n  col += 0.005*bcol/(max(dd+0.005, 0.0)+0.0001);\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  col -= 0.25*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBSRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 256, 256, 364], [366, 466, 505, 505, 590], [592, 680, 719, 719, 748], [750, 750, 780, 780, 1665], [1667, 1667, 1722, 1722, 1897]], "test": "untested"}
{"id": "dllSWs", "name": "True Voronoi for data vis+alpha", "author": "grey_shades", "description": "No-approximation for data visualisation. I wanted to see how slow it would get with a realistic count of data points.\nThis version adds the alpha channel to the source-data colour so that the data can be blended with the background.\n", "tags": ["voronoi", "data", "real"], "likes": 1, "viewed": 154, "published": 3, "date": "1675509090", "time_retrieved": "2024-07-30T18:12:14.084854", "image_code": "// the idea is to visualize up to a low count of data points (~100-200) with a true voronoi rasterizer.\n// the algorithm is very simple and probably slow, but I want to know just how slow is it (that is, is it fast enough)\n\n// generate array with 10x8 = 80 points\n#define N_data_row 8\n#define N_data_col 6\n#define N_data N_data_row * N_data_col\nvec2[N_data] data_locations;\nvec4[N_data] data_colors;\n\n#define MARKER_RADIUS 0.008\n#define DRAW_MARKERS\n\n// use \"distance\" or \"fastdistance\"\n#define DISTANCE_FN distance\n// on a good GPU, it makes nearly no difference, as the hypot() is likely a hardware unit function.\n\nfloat fastdistance( in vec2 pt1, in vec2 pt2 ) \n{\n vec2 a= abs(pt1-pt2);\n float b = a.x+a.y;\n return b;\n}\n\n\nvoid init_pt_locations_2()\n{\n int idx_ptr = 0;\n for (int idx_row=0; idx_row<N_data_row; idx_row++)\n {\n  for (int idx_col=0; idx_col<N_data_col; idx_col++)\n   {\n    float f_row = float((1+idx_row))/float((N_data_row+1));\n    float f_col = float(1+idx_col)/float(N_data_col+1);\n    f_col += 1.0/sqrt(3.0)*f_row - 0.3 + 0.3*f_row*f_row; // tilt the grid to create \"non-uniform, nearly hexagons\" effect.\n    data_locations[idx_ptr] = vec2(f_row,f_col); \n    data_colors[idx_ptr] = vec4(\n        f_row,\n        f_col,\n        0.0+1.1*pow(cos(16.0*(f_row+f_col+0.01*iTime)),6.0), // a delicate time-moving effect to demonstrate that these are not static.\n        // min(1.0,max(-0.3,1.0-2.0*pow(cos(12.0*f_row),2.0))) // alpha. Allow some colour inversion (negative alpha)\n        smoothstep(0.4,0.6,f_row)-0.00 // Alpha. Simpler function to make it look less funky.\n        );\n    idx_ptr++;\n   }\n }\n}\n\nvoid find_color_2( out vec4 color, in vec2 uv)\n{\n    float min_distance = 1000.0;\n    int target_index = 0; \n    for (int pt_idx=0; pt_idx<N_data; pt_idx++)\n        {\n        float this_distance = DISTANCE_FN(uv,data_locations[pt_idx]);\n        if (this_distance<min_distance)\n            {\n            target_index=pt_idx;\n            min_distance=this_distance;\n            }\n        }\n   vec4 data_color = data_colors[target_index];\n   vec4 background_color = texture(iChannel0, vec2(uv.x, uv.y*0.70+0.25));\n   // float ddr = dFdx(background_color.r);\n   float ddx = abs(dFdx(background_color.r));\n   float ddy = abs(dFdy(background_color.r));\n   float dwidth = ddx*ddx+ddy*ddy;\n   vec3 sharper = 112.0*vec3(dwidth,dwidth,dwidth);\n   color = vec4(mix(data_color.rgb,background_color.rgb+sharper,data_color.a),1.0);\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_pt_locations_2();\n    \n    // move random item in a random direction to demonstrate that the point locations are not fixed\n    const float item_move_timeslot_length = 1.0;\n    int item_to_move = int(iTime * item_move_timeslot_length) % ( N_data ) ;\n    float amount_to_move = fract(iTime * item_move_timeslot_length);\n    \n    data_locations[item_to_move].x +=0.08* sin(6.28*amount_to_move);\n    data_locations[item_to_move].y +=0.04* sin(2.0*6.28*amount_to_move);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // move two elements using time. This is to demonstrate the intraction between cells.\n    data_locations[12].x=0.4*cos(0.3*iTime)+0.5;    \n    data_locations[12].y=0.1*cos(3.0*iTime)+0.5;    \n    data_locations[13].x=0.4*cos(0.35*iTime)+0.5;    \n    data_locations[13].y=0.1*cos(3.1*iTime)+0.5;    \n    \n    \n    // write mouse location to demonstrate that thing is interactive and not precomputed\n    data_locations[15].xy = iMouse.xy/iResolution.xy;\n    \n    \n    // for each pixel, find the colour by doing voronoi test. \n    vec4 col;\n    find_color_2(col, uv);\n    \n    // overlay-draw the source points\n#ifdef DRAW_MARKERS\n    for (int pt_idx=0; pt_idx<N_data; pt_idx++)\n    {\n        float this_distance =  DISTANCE_FN(uv,data_locations[pt_idx]);\n        if (this_distance<MARKER_RADIUS)\n            {\n                float mix_ratio = (MARKER_RADIUS-this_distance)/(MARKER_RADIUS);\n                col = mix(col, 1.0-data_colors[pt_idx],mix_ratio);\n                \n            }\n    }\n#endif\n\n    // Output to screen\n    //float ddx = abs(fwidth(max(max(col.r,col.g),col.b)));\n        \n    fragColor = vec4(col.xyz,1.0);\n    \n    \n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 666, 666, 722], [725, 725, 753, 753, 1621], [1623, 1623, 1671, 1671, 2446], [2449, 2449, 2506, 2506, 4220]], "test": "untested"}
{"id": "clXXDs", "name": "Stochastic CatmullRom filter", "author": "bartwronski", "description": "This is an example demonstrating the \"positivization\" technique for stochastically evaluating the CatmullRom filter compared to a stochastic and deterministic bilinear filter.\nhttps://research.nvidia.com/labs/rtr/publication/pharr2024stochtex/", "tags": ["textures", "filtering", "stochastic", "dsp"], "likes": 8, "viewed": 1470, "published": 3, "date": "1675464975", "time_retrieved": "2024-07-30T18:12:14.975473", "image_code": "// This is an example demonstrating the discrete sampling technique for stochastically evaluating the bilinear/biquadratic/Gaussian filters.\n// https://research.nvidia.com/labs/rtr/publication/pharr2024stochtex/\n// Starting from top, going clockwise:\n// Full bilinear, stochastic bilinear, stochastic Catmull-Rom (bi)quadratic, full (expensive) Catmull-Rom.\n\n// Click somewhere in the shader to disable the temporal accumulation.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec4 cat_rom(in float t) {\n    return vec4(t*((2.0-t)*t - 1.0) / 2.0, (t*t*(3.0*t - 5.0) + 2.0) / 2.0,\n           t*((4.0 - 3.0*t)*t + 1.0) / 2.0, (t-1.0)*t*t / 2.0);\n}\n\n\nvec3 full_cat_rom(in vec2 uv, in vec2 rand) {\n    vec2 uv_full = uv * iChannelResolution[0].xy - 0.5;\n    vec2 left_top = floor(uv_full);\n    ivec2 left_top_i = ivec2(uv_full);\n    vec2 fract_part = uv_full - left_top;\n    left_top = (left_top + 0.5) / iChannelResolution[0].xy;\n    vec4 cr_x = cat_rom(fract_part.x);\n    vec4 cr_y = cat_rom(fract_part.y);\n\n    vec3 accum = vec3(0.0);\n    for (int dy = -1; dy <= 2; dy +=1) {\n        for (int dx = -1; dx <= 2; dx +=1) {\n            accum += texture(iChannel0, left_top + vec2(dx, dy)/ iChannelResolution[0].xy).xyz * cr_x[dx+1]  * cr_y[dy+1];\n        }\n    }\n\n    return accum;\n}\n\n\nvec2 sample_select_neg(in float[16] w, in float rand) {\n    float wa[] = float[](abs(w[1]), abs(w[2]), abs(w[4]), abs(w[7]), abs(w[8]), abs(w[11]), abs(w[13]), abs(w[14]));\n    float sum = (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6]+wa[7]);\n    float ws_cdf[] = float[](wa[0]/sum,\n                           (wa[0]+wa[1])/sum,\n                           (wa[0]+wa[1]+wa[2])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6])/sum, \n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6]+wa[7])/sum);\n    if (rand <= ws_cdf[0])\n        return vec2(1, -sum);\n    if (rand <= ws_cdf[1])\n        return vec2(2, -sum);\n    if (rand <= ws_cdf[2])\n        return vec2(4, -sum);\n    if (rand <= ws_cdf[3])\n        return vec2(7, -sum);\n    if (rand <= ws_cdf[4])\n        return vec2(8, -sum);\n    if (rand <= ws_cdf[5])\n        return vec2(11, -sum);\n    if (rand <= ws_cdf[6])\n        return vec2(13, -sum);\n    return vec2(14, -sum);\n\n}\n\nvec2 sample_select_pos(in float[16] w, in float rand) {\n    float wa[] = float[](abs(w[0]), abs(w[3]), abs(w[5]), abs(w[6]), abs(w[9]), abs(w[10]), abs(w[12]), abs(w[15]));\n    float sum = (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6]+wa[7]);\n    float ws_cdf[] = float[](wa[0]/sum,\n                           (wa[0]+wa[1])/sum,\n                           (wa[0]+wa[1]+wa[2])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5])/sum,\n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6])/sum, \n                           (wa[0]+wa[1]+wa[2]+wa[3]+wa[4]+wa[5]+wa[6]+wa[7])/sum);\n    if (rand <= ws_cdf[0])\n        return vec2(0, sum);\n    if (rand <= ws_cdf[1])\n        return vec2(3, sum);\n    if (rand <= ws_cdf[2])\n        return vec2(5, sum);\n    if (rand <= ws_cdf[3])\n        return vec2(6, sum);\n    if (rand <= ws_cdf[4])\n        return vec2(9, sum);\n    if (rand <= ws_cdf[5])\n        return vec2(10, sum);\n    if (rand <= ws_cdf[6])\n        return vec2(12, sum);\n    return vec2(15, sum);\n}\n\nvec3 stochastic_cat_rom(in vec2 uv, in vec2 rand) {\n    vec2 uv_full = uv * iChannelResolution[0].xy - 0.5;\n    vec2 left_top = floor(uv_full);\n    ivec2 left_top_i = ivec2(uv_full);\n    vec2 fract_part = uv_full - left_top;\n    left_top = (left_top + 0.5) / iChannelResolution[0].xy;\n    vec4 cr_x = cat_rom(fract_part.x);\n    vec4 cr_y = cat_rom(fract_part.y);\n  \n    float[16] all_samp = float[16](cr_x[0]*cr_y[0], cr_x[1]*cr_y[0], cr_x[2]*cr_y[0], cr_x[3]*cr_y[0],\n                     cr_x[0]*cr_y[1], cr_x[1]*cr_y[1], cr_x[2]*cr_y[1], cr_x[3]*cr_y[1],\n                     cr_x[0]*cr_y[2], cr_x[1]*cr_y[2], cr_x[2]*cr_y[2], cr_x[3]*cr_y[2],\n                     cr_x[0]*cr_y[3], cr_x[1]*cr_y[3], cr_x[2]*cr_y[3], cr_x[3]*cr_y[3]);\n    vec2 sample_ind0 = sample_select_neg(all_samp, rand.x);\n    vec2 sample_ind1 = sample_select_pos(all_samp, rand.y);\n\n    float dx0 = float(int(sample_ind0)%4)-1.0;\n    float dx1 = float(int(sample_ind1)%4)-1.0;\n    float dy0 = float(int(sample_ind0)/4)-1.0;\n    float dy1 = float(int(sample_ind1)/4)-1.0;\n    \n    vec3 accum = vec3(0.0);\n    accum += texelFetch(iChannel0, left_top_i + ivec2(dx0, dy0), 0).xyz * sample_ind0.y;\n    accum += texelFetch(iChannel0, left_top_i + ivec2(dx1, dy1), 0).xyz * sample_ind1.y;\n   \n\n    return accum;\n}\n\n\nvec3 stochastic_bilin(in vec2 uv, in vec2 rand) {\n  vec2 uv_full = uv * iChannelResolution[0].xy - 0.5;\n  vec2 left_top = floor(uv_full);\n  ivec2 left_top_i = ivec2(uv_full);\n  vec2 fract_part = uv_full - left_top;\n  left_top = (left_top + 0.5) / iChannelResolution[0].xy;\n  \n  vec4 ws = vec4((1.0-fract_part.x)*(1.0-fract_part.y),\n                 fract_part.x*(1.0-fract_part.y),\n                 (1.0-fract_part.x)*fract_part.y,\n                 fract_part.x*fract_part.y);\n  ws = vec4(ws.x, ws.x+ws.y, ws.x+ws.y+ws.z, ws.x+ws.y+ws.z+ws.w);\n  ws /= ws.w;\n  \n  int sel = 3;\n  if (rand.x < ws.x)\n  {\n      sel = 0;\n  } else if (rand.x < ws.y) {\n      sel = 1;\n  } else if (rand.x < ws.z) {\n      sel = 2;\n  }\n  \n  float dx = (sel == 1 || sel == 3) ? 1.0 : 0.0;\n  float dy = (sel == 2 || sel == 3) ? 1.0 : 0.0;\n\n  return texelFetch(iChannel0, left_top_i + ivec2(dx, dy), 0).xyz;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 orig_uv = uv;\n    uv *= 0.04;\n    uv += 0.1;\n    // \n    vec4 random = texture(iChannel2, orig_uv+vec2(rand(float(iFrame)), rand(iTime)));\n    vec3 col = orig_uv.x < orig_uv.y ? full_cat_rom(uv, random.xy) : stochastic_cat_rom(uv, random.xy);\n\n    if (1.0-orig_uv.x < orig_uv.y) {\n        col = texture(iChannel0, uv).xyz;\n        if (orig_uv.x > orig_uv.y) {\n            col = stochastic_bilin(uv, random.xy);\n        }\n    }\n    if (abs(1.0-orig_uv.x - orig_uv.y) < 0.005)\n        col = vec3(1,1,1);\n    if (abs(orig_uv.x - orig_uv.y) < 0.005)\n        col = vec3(1,1,1);    \n    \n    if (iTime > 0.1 && iMouse.z < fragCoord.x) {\n        col = col * 0.02 + texture(iChannel1, orig_uv).xyz * 0.98;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 489, 539, 680]], "test": "untested"}
{"id": "dtXXWl", "name": "reaction diffusion with video in", "author": "mds2", "description": "mixing video input with reaction-diffusion", "tags": ["mouse", "cellular", "reaction"], "likes": 0, "viewed": 114, "published": 3, "date": "1675464301", "time_retrieved": "2024-07-30T18:12:15.942887", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define CHAOS_FILL 0 // set to 1 for more interesting fill patterns.  Looks very nice with color_to_val_3\n\nconst float diffuse_weight = 0.35; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.2; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels, in vec2 offset) {\n    return mod(in_pixels + offset, iResolution.xy) / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    vec4 color = texture(iChannel1, to_uv(p, vec2(0.0)));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n    \n   \n    \n    color = diffuse_weight * texture(iChannel0, to_uv(p, vec2(0.0)));\n    \n    color.rgb = mix(smoothstep(vec3(0.0), vec3(1.0), texture(iChannel2, to_uv(p, vec2(0.0))).rgb), color.rgb, 0.95);\n\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(1.1, 0.0))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(0.0, 1.1))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(-1.1, 0.0))).rgb;\n    color.rgb = color.rgb +  w * texture(iChannel0, to_uv(p, vec2(0.0, -1.1))).rgb;\n    \n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    color.a = 1.0;\n    \n    color.rgb = max(vec3(0.0), min(vec3(1.0), color.rgb));\n    \n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color += 0.005 * delta;\n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 281]], "test": "untested"}
{"id": "mllSWX", "name": "Diamond_champignon", "author": "S_h", "description": "c'est l'essentiel", "tags": ["abouge"], "likes": 0, "viewed": 150, "published": 3, "date": "1675437580", "time_retrieved": "2024-07-30T18:12:16.950193", "image_code": "//SOULEYMA\n//PARTIEL APREM\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q= abs(p)-b;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat map(vec3 pos) {\n    float v = 0.0;\n\n    vec3 sp1 = pos + vec3(3.0, 0.0, 0.0);\n    vec3 sp2 = pos + vec3(-3.0, 0.0, 0.0);\n    \n    v = sdSphere(sp1, 2.0);\n    v = mix(sdBox(pos, vec3(3.0)), sdSolidAngle(pos, vec2(1.0), 1.0),sin(iTime));\n    \n    //v = opSmoothUnion(v, sdSphere(sp2, 3.0), 1.0);\n    \n    return v;\n}\n\nfloat CastRay(vec3 ro, vec3 rd){\n    float contact = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        float ray= map(ro+rd*contact);\n        if(ray < (0.0001*contact))\n        {\n            return float(i)/32.;\n        }\n        contact +=ray;\n    }\n    return -1.0;\n}\n\nvec3 GetNormal (vec3 pos)\n{\n    float v = map(pos);\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy),\n        map(pos+e.yxy),\n        map(pos+e.yyx)\n        ) - v);\n}\n\n\nvec3  render(vec3 ro, vec3 rd){\n    float contact = CastRay(ro, rd);\n    vec3 col = vec3(0.0);\n\n\n    if(contact == -1.0){\n        col = vec3(0.0);}\n    else {\n        col = vec3(1.0-contact);}\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 9.0, -15.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    //cameraPos.xy = rot(cameraPos.xz, iTime)*1.0;\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n\n    vec3 col = render(cameraPos, viewDir);\n    col*= (vec3(1.0)* vec3(1.1, 1.0, 1.5) -0.3 + 0.2*cos(iTime));\n    col+= vec3(0.4,sin(iTime),1.4)/3.0;\n\n    fragColor = vec4(col,1.0);\n}\n\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 55, 55, 132], [135, 135, 173, 173, 453], [456, 456, 502, 537, 697], [699, 699, 728, 728, 814], [816, 816, 849, 849, 875], [877, 877, 898, 898, 1197], [1199, 1199, 1231, 1231, 1465], [1467, 1467, 1494, 1494, 1665], [1668, 1668, 1699, 1699, 1879], [1881, 1881, 1938, 1938, 2606]], "test": "untested"}
{"id": "DlsXDf", "name": "Shader Morphing - carla", "author": "carlito", "description": "^^", "tags": ["morphing"], "likes": 1, "viewed": 170, "published": 3, "date": "1675437283", "time_retrieved": "2024-07-30T18:12:18.538945", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox (vec3  p, vec3 b){\n    vec3 q = abs(p) -b;\n    return length(max(q,0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphere2(vec3 p, float t )\n{\n  return length(p)-t;\n}\n\nfloat map(vec3 pos){\n    float v= 0.0;\n\n    vec3 sp1 = pos + vec3(3.0, 0.0, 0.0);\n    vec3 sp2 = pos + vec3(-3.0, 0.0, 0.0);\n    \n    v = sdSphere(sp1, 1.0);\n    //v = mix(sdSphere(pos, 1.0), sdBox(pos, vec3(1.0)), sin(iTime));\n    v = mix(sdBoxFrame(pos, vec3(1.0,1.0,1.0), 0.5), sdOctahedron(pos,1.0), sin(iTime));\n    \n    \n    //v = opSmoothUnion(v, sdSphere(sp2, 3.0), 1.0);\n    \n    return v;\n}\n\n\nfloat CastRay(vec3 ro, vec3 rd){\n    float contact = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        float ray= map(ro+rd*contact);\n        if(ray < (0.0001*contact))\n        {\n            return float(i)/32.;\n        }\n        contact +=ray;\n    }\n    return -1.0;\n}\n\n\nvec3  render(vec3 ro, vec3 rd){\n    float contact = CastRay(ro, rd);\n    vec3 col = vec3(0.0);\n    \n    \n    if(contact == -1.0){\n        col = vec3(0.0);}\n    else {\n        col = vec3(1.0-contact);}\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float rand = fract(sin(uv.x*54.345))*13.456;\n    vec3 col2 = vec3(rand);\n    \n    \n    vec3 cameraPos = vec3(0.0, 5.0, -5.);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    cameraPos.xy = rot(cameraPos.xy, iTime*2.0);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up +2.0 * forward);\n\n    vec3 col = render(cameraPos, viewDir);\n    col*= (vec3(1.0) * vec3(1.1, 1.0, 1.5) -0.3 + 0.2*cos(iTime));\n    col += vec3(0.4,sin(iTime),1.4)/3.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 117, 147, 147, 239], [242, 242, 277, 277, 301], [303, 303, 341, 341, 621], [623, 623, 651, 651, 728], [730, 730, 775, 775, 1062], [1064, 1064, 1097, 1097, 1121], [1123, 1123, 1143, 1143, 1523], [1526, 1526, 1558, 1558, 1792], [1795, 1795, 1826, 1826, 2013], [2015, 2015, 2072, 2072, 2847]], "test": "untested"}
{"id": "DtlXWf", "name": "Rock'n blob", "author": "sanivel", "description": "GLSL Partiel 2023 \nJade (Hyunsun) Park\n\nBased on @Shane's Lunar Debris\nUsing Voronoi Algorithm (https://thebookofshaders.com/12/?lan=kr)", "tags": ["voronoi", "rock"], "likes": 5, "viewed": 293, "published": 3, "date": "1675436777", "time_retrieved": "2024-07-30T18:12:20.087804", "image_code": "// ATI Jade (Hyunsun) Park\n// Based on @Shane's Lunar Debris\n\n#define PI 3.14159265\n#define FAR 60.\n#define SMOOTHING \n\n// Rotation matrix\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \nmat2 rot2( float a )\n{ \n    vec2 v = sin(vec2(1.570796, 0) + a);\t\n    \n    return mat2(v, -v.y, v.x); \n}\n\n// Texture blending \nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{ \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y \n        + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Smooth\nfloat smaxP(float a, float b, float s)\n{   \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    \n    return mix(b, a, h) + h*(1.0-h)*s;\n}\nvec2 sminP(vec2 a, vec2 b , float s)\n{    \n    vec2 h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    \n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat sminP(float a, float b , float s)\n{    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Rock \nfloat drawObject(in vec3 p)\n{  \n    p = fract(p)-.5;\n    \n    return dot(p, p);    \n}  \nfloat cellTile(in vec3 p)\n{ \n    vec4 v, d; \n    \n    d.x = drawObject(p - vec3(iTime*0.3));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(iTime*0.1));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(iTime*0.1));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(iTime*.2));\n\n    #ifdef SMOOTHING\n    v.xy = sminP(d.xz, d.yw, .3); \n    #else\n    v.xy = min(d.xz, d.yw);\n    #endif\n    \n    #ifdef SMOOTHING\n    return  sminP(v.x, v.y, .05)*5.0; \n    #else\n    return  min(v.x, v.y)*2.5; \n    #endif        \n}\n\n// Path\nvec2 path(in float z)\n{  \n\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n}\n\n// Noise\nfloat n3D(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    return mix(h.x, h.y, p.z);\n}\n\n// Field\nfloat map(vec3 p)\n{   \n    p.xy -= path(p.z);\n    \n    p/=2.;\n    \n    vec3 q = p + (cos(p*2.52 - sin(p.zxy*3.5)))*.2;\n    float sf = max(cellTile(q/5.), 0.); \n    \n    p += (cos(p*.945 + sin(p.zxy*2.625)))*.05;\n    #ifdef SMOOTHING\n    float t = .1 - abs(p.x*.05) - abs(p.y);\n    #else\n    float t = .05 - abs(p.x*.05) - abs(p.y);\n    #endif  \n\n    float n = smaxP(t, (.68 - (1.-sqrt(sf)))*2., 1.);\n   \n    return n*1.;   \n}\n\n// Surface\nfloat bumpSurf3D( in vec3 p, in vec3 n)\n{ \n    return (cellTile(p/2.))*.8 + (cellTile(p*1.5))*.2;   \n}\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor)\n{\n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\t\n}\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.1, 0);\n       \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), \n                   tex3D(tx, p - e.yxy, n), \n                   tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.3)*m;\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; \n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf );   \n}\n\n// Raymarch\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++)\n    {\n        h = map(ro+rd*t);\n        if(abs(h)<0.0025*(t*.125 + 1.) || t>FAR) break;\n        t += h*.8;      \n    }\n\n    return min(t, FAR);   \n}\n\n// Ambient occlusion\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 2.0;\n    for( float i=1.; i< nbIte+.5; i++ )\n    {  \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist; \n        ao += (l - map( p + n*l ))/(1.+ l);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Normal\nvec3 calcNormal(in vec3 p)\n{\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) \n                    + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Shadow\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k)\n{\n    float shade = 3.0;\n    const int shadIter = 36; \n\n    float dist = start;\n\n    for (int i=0; i<shadIter; i++)\n    {\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera\n\tvec3 lookAt = vec3(0, 0, iTime*2.0 + 0.1);\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1);\n\n    // Light position\n \tvec3 lightPos = camPos + vec3(0, 14, 35.0);\n\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n    \n    // Ray\n    float FOV = PI/3.;\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n\tfloat t = trace(camPos, rd);    \n\n    // Scene Color\n    vec3 sceneCol = vec3(0);\n\t\n\tif(t<FAR)\n    {\n\t    vec3 sp = camPos + rd*t;\n        vec3 sn = calcNormal(sp);\n        vec3 snNoBump = sn;\n        \n        const float tSize0 = 1./2.;\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.1);\n        vec3 tsp =  sp;\n\n        sn = doBumpMap(tsp, sn, .5);\n          \n\t    float ao = calculateAO(sp, sn);\n        \n\t    vec3 ld = lightPos-sp;\n\n\t    float lDist = max(length(ld), 0.001);\n    \t\n\t    ld /= lDist;\n\n\t    float atten = 1./(1. + lDist*.007);\n    \t\n\t    float ambience = 0.25;\n    \t\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n    \n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n\t    vec3 texCol = vec3(.8, .9, 1.);\n\t    texCol *= min(tex3D(iChannel0, sp*tSize0, sn)*3.5, 1.);\n        texCol *= bumpSurf3D(sp, sn)*.5 + .5;\n        \n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n\n        sceneCol = texCol*(diff + spec + ambience);\n        \n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 1.)*.5;\n\n        sceneCol *= atten*shading*ao;\n\n\t\n\t}\n       \n    // Fog\n    vec3 fog = vec3(0.666, 0.21256, 0.345664)/2.*(rd.y*0.5 + 0.5);    \n    sceneCol = mix(sceneCol, fog, smoothstep(0.0, 0.95, t/FAR));\n\n    // Interaction with Sound\n    int s;\n    float fData = texelFetch( iChannel1, ivec2(s,0), 0 ).x;\n    float wave = texelFetch( iChannel1, ivec2(s,1), 0 ).x;\n    vec3 mCol = vec3( fData, 2.0*fData*(1.0-fData), 1.0-fData ) * fData;   \n\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0.0, 1.0))+mCol, 1.0);\n\t\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 213, 213, 295], [297, 318, 369, 369, 545], [547, 557, 597, 597, 695], [696, 696, 734, 734, 833], [834, 834, 875, 875, 970], [972, 981, 1010, 1010, 1066], [1069, 1069, 1096, 1096, 1571], [1573, 1581, 1604, 1604, 1713], [1715, 1724, 1743, 1743, 2034], [2036, 2045, 2064, 2064, 2470], [2472, 2483, 2524, 2524, 2585], [2586, 2586, 2644, 2644, 3040], [3041, 3041, 3104, 3104, 3466], [3468, 3480, 3517, 3517, 3721], [3723, 3744, 3787, 3787, 4072], [4074, 4084, 4112, 4112, 4293], [4295, 4305, 4386, 4386, 4730], [4734, 4734, 4791, 4791, 7004]], "test": "untested"}
{"id": "DllXWf", "name": "Soleil d'hiver et reflets du lac", "author": "raphaeldl", "description": "je ddie ce Hak  ma mre <3", "tags": ["haku"], "likes": 0, "viewed": 130, "published": 3, "date": "1675435695", "time_retrieved": "2024-07-30T18:12:20.998369", "image_code": "float random (in vec2 st) {                                                     //NOISE PREPARATION\n    return fract(sin(dot(st.xy, vec2 (12.9898, 78.233)))*43758.5453123);\n    }\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract (st);\n    \n    float a = random (i);\n    float b = random (i + vec2(.0, 0.0));\n    float c = random (i + vec2(5.0, 1.0));\n    float d = random (i + vec2(1.0, 50.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 -u.x) + (d- b) * u.x *u.y;\n}\n    \n    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //UV\n    uv.y += sin((mix(uv.x, uv.y, iTime)));\n    vec2 uv1 = uv + vec2(-0.25, 0.0) + sin(uv.y * 40.0) * 1.2;\n    vec2 uv2 = uv + vec2(0.25, 0.0);\n    vec2 uv3 = 2.0 * fragCoord/iResolution.xy - 1.0; //UV de base\n    \n   \n    float MonNoise = noise(uv1);\n    //FORMES\n                //Circles\n    float circle1 = step(length(uv1)*MonNoise, sin(iTime*3.));   //propagation rouge\n    float circle2 = step(length(uv2)*MonNoise, sin(iTime*4.));   //propagation bleu\n    float circle3 = step(length(uv), sin(iTime*50.) + 1.6);\n    \n    float r = (length(uv.x * uv.y));\n    \n    float circle4 = step(length(uv3), 0.9);\n     \n    \n    \n    \n    float l = length( uv );                                          //NOISE\n\tfloat a = atan( uv.x, uv.y );\n\tfloat w = texture( iChannel0, vec2( abs(a)/6.28,1.0) ).x;\t\n\tfloat t = 3.0*sqrt(abs(w-0.5));\n\tfloat f = 0.0;\n\tif( r<t ) f = (1.0-r/t);\n    \n    \n    \n    //COLOR\n    vec3 col = vec3(1.0,0.0,0.0) * circle1;\n    col += vec3(0.0, 1.0, 1.0) * circle2;\n    col += step(fract(uv.x *  20.0), 0.5) * circle3;\n    col += step(length(uv), 1.1) * r; \n    col += vec3(abs(ceil(mix(uv.x, uv.y, 0.8)))), 0.0, floor((uv3.y)*0.1) * circle4;\n    col += pow( vec3(f), vec3(1.5,1.1,0.8) ); \n     \n     \n    //col += step(fract(noise(uv*5.0)), 0.5) ;\n    \n    \n    fragColor = vec4(col, 1.0);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 99, 178], [180, 180, 206, 206, 532], [549, 549, 606, 606, 2030]], "test": "untested"}
{"id": "ctsSWX", "name": "Truc_rotation", "author": "S_h", "description": "un shader ", "tags": ["rotation"], "likes": 1, "viewed": 131, "published": 3, "date": "1675425969", "time_retrieved": "2024-07-30T18:12:21.896967", "image_code": "// SOULEYMA \n// PARTIEL 1\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.3*c,c)-0.3*c;\n}\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(3.));\n    return length(p)-0.5;\n}\n\n\n\n\nfloat map(vec3 pos){\n\n    float v= 0.0;\n    pos = opRep(pos,vec3(4.0));\n    \n    return v;\n}\n\nfloat CastRay(vec3 ro, vec3 rd){\n    float contact = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        float ray= map(ro+rd*contact);\n        if(ray < (0.0001*contact))\n        {\n            return float(i)/32.;\n        }\n        contact +=ray;\n    }\n    return -1.0;\n}\n\nvec3  render(vec3 ro, vec3 rd){\n    float contact = CastRay(ro, rd);\n    vec3 col = vec3(0.0);\n    \n    \n    if(contact == -1.0){\n        col = vec3(0.0);}\n    else {\n        col = vec3(1.0-contact);}\n    return col;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uv1 = uv + vec2(-0.25,0.0);\n    \n    uv = rot(uv+uv1*.2, iTime*0.5);   \n    \n    vec3 p = vec3 (0.0,0.,iTime);\n    vec3 dir = normalize(vec3(uv,2.));\n    \n    float shad = 1.;\n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/64.;\n            break;\n        }\n        p += d*dir*3.;\n    }\n    \n    \n    vec3 cameraPos = vec3(-0.5, 0.0, 2.0*iTime-5.0);\n    vec3 cameraTar = vec3(-0.5, 0.0, 2.0*iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up +2.0 * forward);\n\n    vec3 col1 = render(cameraPos, viewDir) ;\n    \n    \n    \n    vec3 col = vec3(1.2 - shad)* cos(iTime*vec3(0.9,0.2,0.3)-.2) + col1 ;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 55, 55, 132], [134, 134, 169, 169, 204], [206, 206, 225, 225, 281], [286, 286, 306, 306, 378], [380, 380, 412, 412, 646], [648, 648, 679, 679, 866], [872, 872, 929, 929, 1916]], "test": "untested"}
{"id": "DllSWX", "name": "Flower - carla", "author": "carlito", "description": "c bo", "tags": ["flower"], "likes": 0, "viewed": 141, "published": 3, "date": "1675425926", "time_retrieved": "2024-07-30T18:12:22.791575", "image_code": "// CARLA VERDUCI\n// partiel 1\n\nvec3 opRep( in vec3 pos, in vec3 c)\n{\n    return mod(pos+0.5*c,c)-0.5*c;\n}\n\n\nfloat sdSphere( vec3 pos, float s )\n{\n  return length(pos)-s;\n}\n\nfloat sdSphere1( vec3 pos, float t )\n{\n  return length(pos)-t;\n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat map(vec3 pos) {\n    float v = 0.0;\n    \n    vec3 spherePos = pos;\n    spherePos.x += sin(pos.y+iTime);\n    \n    \n    float sphereMB = sdSphere(pos+vec3(0.0, 0.0, 0.0), 2.0);\n    float sphereMM = sdSphere1(spherePos+vec3(0.0, -1.0, 0.0), 1.0);\n    \n    pos = opRep(pos, vec3(1.5));\n    return (length(pos)-0.4) + (sphereMM);\n    \n    v = opSmoothUnion(sphereMM, sphereMB, 0.5);\n    \n    return v;\n}\n    \n\nfloat CastRay(vec3 ro, vec3 rd){\n    float contact = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        float ray= map(ro+rd*contact);\n        if(ray < (0.0001*contact))\n        {\n            return float(i)/32.;\n        }\n        contact +=ray;\n    }\n    return -1.0;\n}\n\nvec3  render(vec3 ro, vec3 rd){\n    float contact = CastRay(ro, rd);\n    vec3 col = vec3(0.0);\n    \n    \n    if(contact == -1.0){\n        col = vec3(0.0);}\n    else {\n        col = vec3(1.0-contact);}\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 pos = vec3 (0.7,0.5,-3.);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    float shad = 1.;\n    \n    for (int i=0;i<60;i++)\n    {\n        float d = map(pos);\n        if (d<0.001)\n        {\n            shad = float(i)/64.;\n            break;\n        }\n        pos += d*dir;\n    }\n    \n    vec3 cameraPos = vec3(-0.5, 0.0, 2.0*iTime-5.0);\n    vec3 cameraTar = vec3(-0.5, 0.0, 2.0*iTime);\n    \n    cameraPos.xz = rot(cameraPos.xz, iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up +2.0 * forward);\n\n    vec3 col = render(cameraPos, viewDir) + vec3(1.0 - shad) * vec3(1.1, 1.0, 1.5) -0.3 + 0.2*cos(iTime) ;\n    \n    //vec3 col = vec3(1.0 - shad) + 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))* vec3(0.3, 0.5, 0.2);\n    vec3 col2 = vec3(1.0 - shad) * vec3(1.1, 1.0, 1.5) -0.3 + 0.2*cos(iTime);\n\n    fragColor = vec4(col2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 68, 68, 105], [108, 108, 145, 145, 171], [173, 173, 211, 211, 237], [239, 239, 267, 267, 344], [346, 346, 398, 398, 497], [503, 503, 524, 524, 906], [913, 913, 945, 945, 1179], [1181, 1181, 1212, 1212, 1399], [1401, 1401, 1458, 1458, 2560]], "test": "untested"}
{"id": "dlfSDf", "name": "Bote de nuit raphaeldl", "author": "raphaeldl", "description": "boom boom dans les oreilles, paf paf dans les yeux.", "tags": ["boomboom"], "likes": 1, "viewed": 128, "published": 3, "date": "1675425748", "time_retrieved": "2024-07-30T18:12:23.760983", "image_code": "// 2057\n// based on \"le crateur aka le tout puissant\"\n//Raphael de Lemos M1 ATI (ww)\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.1*c,c)-0.1*c;\n}\n\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(4.));\n    return length(p)-1.1;\n}\n\n vec2 rotate(vec2 st, float a)                                 //Declarer Rotation\n{\n        st = mat2(cos(a), -sin(a), sin(a), cos(a))*(st-0.5);\n        return st+0.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )        //SET UP\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;      //centrer\n    uv.x *= iResolution.x/iResolution.y;             //x=y      \n    \n    \n    vec2 uv1 = uv + vec2(-0.25,0.0);      //UV a gauche\n    vec2 uv2 = uv + vec2(0.25,0.0);       //UV a droite\n    \n    uv = rotate(uv2+uv1, iTime);\n    uv.y += cos(iTime) + cos(iTime*5.0)/1.5;                  //Harmonique y\n    uv.x += cos(iTime) + cos(iTime*5.0)/7.0;                  //Harmonique x\n    \n                   //Rotation\n    \n    \n    float smth = smoothstep(0.1, 0.5+cos(iTime*4.0), 0.2);     //Smooth et Flash \n    float smth2 = smoothstep(4.8, .1, 1.2+cos(iTime));\n    float smth3 = smoothstep(0.8+cos(iTime), 0.2, 0.2);\n    \n    \n    vec3 p = vec3 (iTime,0.,-1.);\n    vec3 dir = normalize(vec3(uv,0.02));\n    \n   \n    \n    float shad = .9;\n    \n    \n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/14.;\n            break;\n        }\n        p += d*dir;\n    }\n    \n   \n    \n    \n    vec3 col = vec3(1.2 - shad);\n    col += ((vec3(0.0, 1.0, 1.0) * (smth / smth2)*smth3 + 0.5*cos(uv.y+vec3(2,4,30)) -0.2 + 0.6*cos(iTime))*sin(iTime));     //couleur cercle \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 128, 128, 163], [166, 166, 185, 185, 241], [244, 244, 327, 327, 413], [418, 418, 491, 491, 1714]], "test": "untested"}
{"id": "mtXSDf", "name": "Bote de nuit", "author": "raphaeldl", "description": "boom boom dans les oreilles, paf paf dans les yeux.", "tags": ["boomboom"], "likes": 2, "viewed": 163, "published": 3, "date": "1675425532", "time_retrieved": "2024-07-30T18:12:24.639634", "image_code": "// 2057\n// based on \"le crateur aka le tout puissant\"\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.1*c,c)-0.1*c;\n}\n\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(4.));\n    return length(p)-1.1;\n}\n\n vec2 rotate(vec2 st, float a)                                 //Declarer Rotation\n{\n        st = mat2(cos(a), -sin(a), sin(a), cos(a))*(st-0.5);\n        return st+0.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )        //SET UP\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;      //centrer\n    uv.x *= iResolution.x/iResolution.y;             //x=y      \n    \n    \n    vec2 uv1 = uv + vec2(-0.25,0.0);      //UV a gauche\n    vec2 uv2 = uv + vec2(0.25,0.0);       //UV a droite\n    \n    uv = rotate(uv2+uv1, iTime);\n    uv.y += cos(iTime) + cos(iTime*5.0)/1.5;                  //Harmonique y\n    uv.x += cos(iTime) + cos(iTime*5.0)/7.0;                  //Harmonique x\n    \n                   //Rotation\n    \n    \n    float smth = smoothstep(0.1, 0.5+cos(iTime*4.0), 0.2);     //Smooth et Flash \n    float smth2 = smoothstep(4.8, .1, 1.2+cos(iTime));\n    float smth3 = smoothstep(0.8+cos(iTime), 0.2, 0.2);\n    \n    \n    vec3 p = vec3 (iTime,0.,-1.);\n    vec3 dir = normalize(vec3(uv,0.02));\n    \n   \n    \n    float shad = .9;\n    \n    \n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/14.;\n            break;\n        }\n        p += d*dir;\n    }\n    \n   \n    \n    \n    vec3 col = vec3(1.2 - shad);\n    col += ((vec3(0.0, 1.0, 1.0) * (smth / smth2)*smth3 + 0.5*cos(uv.y+vec3(2,4,30)) -0.2 + 0.6*cos(iTime))*sin(iTime));     //couleur cercle \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 93, 93, 128], [131, 131, 150, 150, 206], [209, 209, 292, 292, 378], [383, 383, 456, 456, 1679]], "test": "untested"}
{"id": "dtXSDf", "name": "Gnrique Netflix", "author": "raphaeldl", "description": "ma tl est casse, mais comme elle est inintressante et que netflix nous formate, je prfre regarder directement les interfrences entre moi et elle, entre l'homme et la machine. \nMa petite tl je te aime <3", "tags": ["netflix"], "likes": 2, "viewed": 172, "published": 3, "date": "1675425351", "time_retrieved": "2024-07-30T18:12:25.400599", "image_code": "// 2057\n// based on \"le crateur aka le tout puissant\"\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.1*c,c)-0.1*c;\n}\n\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(4.));\n    return length(p)-1.1;\n}\n\n vec2 rotate(vec2 st, float a)                                 //Declarer Rotation\n{\n        st = mat2(cos(a), -sin(a), sin(a), cos(a))*(st-0.5);\n        return st+0.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )        //SET UP\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;      //centrer\n    uv.x *= iResolution.x/iResolution.y;             //x=y      \n    \n    \n    vec2 uv1 = uv + vec2(-0.25,0.0);      //UV a gauche\n    vec2 uv2 = uv + vec2(0.25,0.0);       //UV a droite\n    \n    //uv.y += cos(iTime) + cos(iTime*5.0)/1.5;                  //Harmonique y\n    //uv.x += cos(iTime) + cos(iTime*5.0)/7.0;                  //Harmonique x\n    \n    uv = rotate(uv2/uv1, iTime);               //Rotation\n    \n    \n    float smth = smoothstep(0.1, 0.5+cos(iTime*4.0), 0.2);     //Smooth et Flash \n    float smth2 = smoothstep(4.8, .1, 1.2+cos(iTime));\n    float smth3 = smoothstep(0.8+cos(iTime), 0.2, 0.2);\n    \n    \n    vec3 p = vec3 (iTime,0.,-1.);\n    vec3 dir = normalize(vec3(uv,0.02));\n    \n   \n    \n    float shad = .9;\n    \n    \n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/14.;\n            break;\n        }\n        p += d*dir;\n    }\n    \n   \n    \n    \n    vec3 col = vec3(1.2 - shad);\n    col += ((vec3(0.0, 1.0, 1.0) * (smth / smth2)*smth3 + 0.5*cos(uv.y+vec3(2,4,30)) -0.2 + 0.6*cos(iTime))*sin(iTime));     //couleur cercle \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 93, 93, 128], [131, 131, 150, 150, 206], [209, 209, 292, 292, 378], [383, 383, 456, 456, 1678]], "test": "untested"}
{"id": "dlfXWf", "name": "LeSensDynamique", "author": "raphaeldl", "description": "Ernesto tait en Rave party hier soir, Ernesto a mang un papier color et a appris les plaisirs de shaderToy.\nErnesto est content.", "tags": ["lsd"], "likes": 2, "viewed": 163, "published": 3, "date": "1675425000", "time_retrieved": "2024-07-30T18:12:26.244344", "image_code": "// 2057\n// based on \"le crateur aka le tout puissant\"\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.1*c,c)-0.1*c;\n}\n\n\nfloat SDF(vec3 p)\n{\n    p = opRep(p, vec3(4.));\n    return length(p)-1.1;\n}\n\n vec2 rotate(vec2 st, float a)                                 //Declarer Rotation\n{\n        st = mat2(cos(a), -sin(a), sin(a), cos(a))*(st-0.5);\n        return st+0.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )        //SET UP\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;      //centrer\n    uv.x *= iResolution.x/iResolution.y;             //x=y      \n    \n    \n    vec2 uv1 = uv + vec2(-0.25,0.0);      //UV a gauche\n    vec2 uv2 = uv + vec2(0.25,0.0);       //UV a droite\n    \n    //uv.y += cos(iTime) + cos(iTime*5.0)/1.5;                  //Harmonique y\n    //uv.x += cos(iTime) + cos(iTime*5.0)/7.0;                  //Harmonique x\n    \n    uv = rotate(uv2*uv1*2., iTime);               //Rotation\n    \n    \n    float smth = smoothstep(0.1, 0.5+cos(iTime*4.0), 0.2);     //Smooth et Flash \n    float smth2 = smoothstep(4.8, .1, 1.2+cos(iTime));\n    float smth3 = smoothstep(0.8+cos(iTime), 0.2, 0.2);\n    \n    \n    vec3 p = vec3 (iTime,0.,-1.);\n    vec3 dir = normalize(vec3(uv,0.02));\n    \n   \n    \n    float shad = .9;\n    \n    \n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/14.;\n            break;\n        }\n        p += d*dir;\n    }\n    \n   \n    \n    \n    vec3 col = vec3(1.2 - shad);\n    col += ((vec3(0.0, 1.0, 1.0) * (smth / smth2)*smth3 + 0.5*cos(uv.y+vec3(2,4,30)) -0.2 + 0.6*cos(iTime))*sin(iTime));     //couleur cercle \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 93, 93, 128], [131, 131, 150, 150, 206], [209, 209, 292, 292, 378], [383, 383, 456, 456, 1681]], "test": "untested"}
{"id": "DtfXDB", "name": "God damn Path Tracer", "author": "phoshp", "description": "Toy Path tracer with BSDF, BTDF and importance sampling microfacet GGX.\n\nUse your mouse to rotate around scene center.", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer", "brdf", "ggx", "btdf"], "likes": 4, "viewed": 310, "published": 3, "date": "1675416386", "time_retrieved": "2024-07-30T18:12:27.202781", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 o = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0, o, 0);\n    vec3 col = data.rgb / data.w;\n    \n    col = pow(col, vec3(1.0 / GAMMA)); // gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define GAMMA 2.2\n#define SAMPLES 5.0\n#define MAX_RENDER_DISTANCE 10000.0\n#define EPSILON 0.001\n#define PATH_LENGTH 12\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat3 GetTangentSpace(vec3 normal)\n{\n    vec3 helper = vec3(1, 0, 0);\n    if (abs(normal.x) > 0.99) helper = vec3(0, 0, 1);\n    vec3 tangent = normalize(cross(normal, helper));\n    vec3 binormal = normalize(cross(normal, tangent));\n    return mat3(tangent, binormal, normal);\n}\n\nvec3 SampleHemisphere(float seed, vec3 normal, float alpha) {\n\tfloat cosTheta = pow(hash1(seed), 1.0 / (alpha + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = 2.0 * PI * hash1(seed);\n    vec3 tangentSpaceDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    return GetTangentSpace(normal) * tangentSpaceDir;\n}\n\nfloat CosineSamplingPDF(float NdotL) {\n    return NdotL / PI;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0) {\n    return clamp(F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom = a2;\n    float denom = max(NdotH2 * (a - 1.0) + 1.0, 0.0000001);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = abs(dot(N, V));\n    float NdotL = abs(dot(N, L));\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 ImportanceSampleGGX(float x, float y, vec3 N, vec3 V, float roughness) {\n    float a = roughness * roughness;\n\n    float phi = 2.0 * PI * x;\n    float cosTheta = sqrt((1.0 - y) / (1.0 + (a * a - 1.0) * y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    // from tangent-space vector to world-space sample vector\n    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\n    vec3 halfVec = tangent * H.x + bitangent * H.y + N * H.z;\n    halfVec = normalize(halfVec);\n    \n    return halfVec;\n\n}\n\nfloat ImportanceSampleGGX_PDF(float NDF, float NdotH, float VdotH) {\n    return NDF * NdotH / (4.0 * VdotH);\n}\n\nfloat CalculateFresnel(vec3 I, vec3 N, float ior) {\n    float kr;\n    float cosi = clamp(-1.0, 1.0, dot(I, N));\n    float etai = 1.0;\n\tfloat etat = ior;\n    if (cosi > 0.0) {\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n    }\n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    // Total internal reflection\n    if (sint >= 1.0) {\n        kr = 1.0;\n    } else {\n        float cost = sqrt(max(0.f, 1.0 - sint * sint));\n        cosi = abs(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        kr = (Rs * Rs + Rp * Rp) / 2.0;\n    }\n    return kr;\n}\n\nvec3 RefractionBTDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N, vec3 H, float etaIn, float etaOut) {  \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n            \n    float VdotH = abs(dot(V, H));\n    float LdotH = abs(dot(L, H));\n            \n    \n    float term1 = VdotH * LdotH / (NdotV * NdotL);\n    vec3 term2 = etaOut * etaOut * (1.0 - F) * G * D;\n    float term3 = (etaIn * VdotH + etaOut * LdotH) * (etaIn * VdotH + etaOut * LdotH) + 0.001f;\n    vec3 refractionBrdf = term1 * term2 / term3;\n    \n    return refractionBrdf;\n}\n\nvec3 SpecularBRDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N) {        \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n    vec3 nominator = D * G * F;\n    float denominator = 4.0 * NdotV * NdotL + 0.001;\n    vec3 specularBrdf = nominator / denominator;\n    \n    return specularBrdf;\n}\n\nvec3 DiffuseBRDF(vec3 albedo) {\n    return albedo / PI;\n}\n\nvec3 Reinhard(vec3 color) {\n    return color / (color + 1.0);\n}\n\n#define SUN_DIR normalize(vec3(-0.4,0.3,-0.6))\n\nvec3 getSkyColor(vec3 rd) {\n    vec3 col = mix(vec3(1),vec3(1,0.7,0.5), 0.5+0.5*rd.y);\n    float sun = clamp(dot(SUN_DIR,rd), 0.0, 1.0);\n    float sun2 = pow(sun, 32.0);\n    col += vec3(1,0.6,0.1) * (pow(sun2, 12.0) + 2.0*pow(sun2, 16.0));\n    return max(col, vec3(0));\n}", "buffer_a_code": "struct Material {\n    vec3 albedo;\n    vec4 emissive;\n    float metallic;\n    float roughness;\n    vec3 specular;\n    float specTrans;\n    float ior;\n};\n\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    uint mat;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    uint mat;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n    vec3 color;\n    uint mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct HitData {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 normal;\n    vec3 albedo;\n    Material mat;\n};\n\nMaterial[4] g_materials;\nPlane[1] g_planes;\nSphere[3] g_spheres;\nBox[1] g_boxes;\n\nHitData createHitData() {\n    HitData hit;\n    hit.hit = false;\n    hit.pos = vec3(0);\n    hit.dist = MAX_RENDER_DISTANCE;\n    hit.normal = vec3(1.0);\n    hit.albedo = vec3(0.0);\n    \n    return hit;\n}\n\nRay setCamera(vec3 orig, vec3 forward, vec2 uv) {\n    const float focal_dist = 1.2;\n    const vec3 up_vec = vec3(0, 1, 0);\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    float i = (uv.x - 0.5) * focal_dist * aspect_ratio;\n    float j = (uv.y - 0.5) * focal_dist;\n    \n    vec3 right = cross(forward, up_vec);\n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(forward + (right * i) + (up * j));\n    \n    return Ray(orig, dir);\n}\n\nvoid hitMaterial(Ray ray, inout HitData hit, float dist, vec3 color, uint matId) {\n    hit.hit = true;\n    hit.pos = ray.origin + ray.dir * dist;\n    hit.dist = dist;\n    hit.mat = g_materials[matId];\n    hit.albedo = color * hit.mat.albedo;\n}\n\nvoid hitSphere(Ray ray, inout HitData hit, Sphere sphere) {\n    vec3 base = sphere.pos - ray.origin;\n    float d1 = dot(base, ray.dir);\n    float d2Sqrt = d1 * d1 - dot(base, base) + sphere.radius * sphere.radius;\n    if (d2Sqrt < 0.0) {\n        return;\n    }\n    float d2 = sqrt(d2Sqrt);\n    float t = (d1 - d2) > 0.0 ? d1 - d2 : d1 + d2;\n    if (t > EPSILON && t < hit.dist) {\n        hitMaterial(ray, hit, t, sphere.color, sphere.mat);\n        hit.normal = normalize((hit.pos - sphere.pos) / sphere.radius);\n    }\n}\n\nvoid hitPlane(Ray ray, inout HitData hit, Plane plane) {\n    float d = dot(plane.normal, ray.dir);\n    if (d != 0.0) {\n        float t = dot(plane.pos - ray.origin, plane.normal) / d;\n        if (t > EPSILON && t < hit.dist) {\n            hitMaterial(ray, hit, t, plane.color, plane.mat);\n            hit.normal = plane.normal;\n            hit.albedo = hit.mat.albedo * texture(iChannel1, hit.pos.xz/ 2.0, 0.0).rgb;\n        }\n    }\n}\n\nfloat safe_inv(float v) {\n    return v == 0.0 ? v : 1.0 / v;\n}\n\nvec3 safe_inv3(vec3 v) {\n    return vec3(safe_inv(v.x), safe_inv(v.y), safe_inv(v.z));\n}\n\nvoid hitBox(Ray ray, inout HitData hit, Box box) {\n    vec3 t1 = safe_inv3(ray.dir) * (box.min - ray.origin);\n    vec3 t2 = safe_inv3(ray.dir) * (box.max - ray.origin);\n    vec3 tminv = min(t1, t2);\n    vec3 tmaxv = max(t1, t2);\n\n    float tmin = max(max(tminv.x, tminv.y), tminv.z);\n    float tmax = min(min(tmaxv.x, tmaxv.y), tmaxv.z);\n\n    if (tmin <= 0.0) tmin = tmax; // we are inside of box\n    \n    if (tmax > max(tmin, 0.0) && tmin < hit.dist) {\n        hitMaterial(ray, hit, tmin, box.color, box.mat);\n        vec3 norm = -sign(ray.dir) * step(tminv.yzx, tminv.xyz) * step(tminv.zxy, tminv.xyz);\n        hit.normal = norm;\n    }\n}\n\nHitData hitScene(Ray ray) {\n    HitData hit = createHitData();\n    for (int i = 0; i < g_spheres.length(); ++i) {\n        hitSphere(ray, hit, g_spheres[i]);\n    }\n    for (int i = 0; i < g_planes.length(); ++i) {\n        hitPlane(ray, hit, g_planes[i]);\n    }\n    for (int i = 0; i < g_boxes.length(); ++i) {\n        hitBox(ray, hit, g_boxes[i]);\n    }\n    return hit;\n}\n\nvec3 tracePath(Ray ray, bool daytime, inout float seed, inout vec3 radi, inout vec3 irradi) {\n    vec3 direct = vec3(0.0);\n    vec3 energy = vec3(1.0);\n    bool is_direct = true;\n    \n    for (int i = 0; i < PATH_LENGTH; ++i) {\n        HitData hit = hitScene(ray);\n        \n        if (!hit.hit) {\n            vec3 sky = daytime ? getSkyColor(ray.dir) : vec3(0);\n            radi += sky;\n            irradi += sky * energy;\n            return direct;\n        }\n        \n        vec4 e = hit.mat.emissive;\n        radi += e.rgb * e.w * e.w;\n        \n        float roulette = hash1(seed);\n        float blender = hash1(seed); //used to blend BSDF and BRDF\n        \n        if (blender < 1.0 - hit.mat.specTrans) {\n            if (is_direct) {\n                direct += hit.albedo * energy;\n            } else {\n                irradi += hit.albedo * energy;\n            }\n            vec3 reflectionDir;\n            \n            float diffuseRatio = 0.5 * (1.0 - hit.mat.metallic);\n            float specularRatio = 1.0 - diffuseRatio;\n            vec3 V = normalize(-ray.dir);\n            \n            if (roulette < diffuseRatio) { //sample diffuse\n                reflectionDir = SampleHemisphere(seed, hit.normal, 1.0);\n            } else {\n                vec3 halfVec = ImportanceSampleGGX(hash1(seed), hash1(seed), hit.normal, V, hit.mat.roughness);\n                reflectionDir = reflect(ray.dir, halfVec);\n                reflectionDir = normalize(reflectionDir);\n            }\n            \n            vec3 L = normalize(reflectionDir);\n            vec3 H = normalize(V + L);\n        \n            float NdotL = abs(dot(hit.normal, L));\n            float NdotH = abs(dot(hit.normal, H));\n            float VdotH = abs(dot(V, H));\n            \n            float NdotV = abs(dot(hit.normal, V));\n            \n            vec3 F0 = mix(hit.mat.specular, hit.albedo, hit.mat.metallic);\n        \n            float NDF = DistributionGGX(hit.normal, H, hit.mat.roughness);\n            float G = GeometrySmith(hit.normal, V, L, hit.mat.roughness);\n            vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n        \n            vec3 kS = F;\n            vec3 kD = (1.0 - kS) * (1.0 - hit.mat.metallic);\n        \n            vec3 specularBrdf = SpecularBRDF(NDF, G, F, V, L, hit.normal);\n            float specularPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            vec3 diffuseBrdf = DiffuseBRDF(hit.albedo);\n            float diffusePdf = CosineSamplingPDF(NdotL);\n\n            vec3 totalBrdf = (diffuseBrdf * kD + specularBrdf) * NdotL;\n            float totalPdf = diffuseRatio * diffusePdf + specularRatio * specularPdf;\n                \n            ray.origin = hit.pos + hit.normal * EPSILON;\n            ray.dir = reflectionDir;\n            if (totalPdf > 0.0) {\n                energy *= totalBrdf / totalPdf;\n            }\n        } else {\n            bool fromOutside = dot(ray.dir, hit.normal) < 0.0;\n            vec3 N = fromOutside ? hit.normal : -hit.normal;\n            vec3 bias = N * EPSILON;\n            \n            float etai = 1.0;\n            float etat = hit.mat.ior;\n            \n            vec3 V = normalize(-ray.dir);\n            vec3 H = ImportanceSampleGGX(hash1(seed), hash1(seed), N, V, hit.mat.roughness);\n            \n            vec3 F0 = hit.mat.specular;\n            vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n            \n            float kr = CalculateFresnel(ray.dir, hit.normal, hit.mat.ior);\n            \n            float specularRatio = kr;\n            float refractionRatio = 1.0 - kr;\n            \n            vec3 L; \n            if (roulette <= specularRatio) {\n                ray.origin = hit.pos + bias;\n                L = normalize(reflect(ray.dir, H));\n                ray.dir = L;\n            } else {\n                float eta = fromOutside ? etai / etat : etat / etai;\n                L = normalize(refract(ray.dir, H, eta));\n                ray.origin = hit.pos - bias;\n                ray.dir = L;\n                L = N;\n                if (!fromOutside) {\n                    //since the BTDF is not reciprocal, we need to invert the direction of our vectors.\n                    vec3 temp = L;\n                    L = V;\n                    V = temp;\n                        \n                    N = -N;\n                    H = -H;\n                }\n            }\n            \n            float NdotL = abs(dot(N, L));\n            float NdotV = abs(dot(N, V));\n            \n            float NdotH = abs(dot(N, H));\n            float VdotH = abs(dot(V, H));\n            float LdotH = abs(dot(L, H));\n            \n            float NDF = DistributionGGX(N, H, hit.mat.roughness);\n            float G = GeometrySmith(N, V, L, hit.mat.roughness);\n\n            vec3 specularBrdf = SpecularBRDF(NDF, G, F, V, L, N);\n            float specularPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //refraction\n            float etaOut = etat;\n            float etaIn = etai;\n            \n            vec3 refractionBtdf = RefractionBTDF(NDF, G, F, V, L, N, H, etaIn, etaOut);\n            float refractionPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //BSDF = BRDF + BTDF\n            vec3 totalBrdf = (specularBrdf + refractionBtdf * hit.albedo) * NdotL;\n            float totalPdf = specularRatio * specularPdf + refractionRatio * refractionPdf;\n            if (totalPdf > 0.0) {\n                energy *= totalBrdf / totalPdf;\n            }\n        }\n        is_direct = false;\n    }\n    return direct;\n}\n\nvoid initScene() {\n    Material mate1;\n    mate1.albedo = vec3(1.0);\n    mate1.emissive = vec4(0);\n    mate1.metallic = 0.0;\n    mate1.roughness = 0.2;\n    mate1.specular = vec3(0.2);\n    mate1.specTrans = 1.0;\n    mate1.ior = 1.05;\n    \n    Material mate2;\n    mate2.albedo = vec3(1.0);\n    mate2.emissive = vec4(0);\n    mate2.metallic = 0.6;\n    mate2.roughness = 0.35;\n    mate2.specular = vec3(0.2);\n    mate2.specTrans = 0.0;\n    mate2.ior = 1.0;\n    \n    Material mate3;\n    mate3.albedo = vec3(1.0);\n    mate3.emissive = vec4(0);\n    mate3.metallic = 1.0;\n    mate3.roughness = 0.01;\n    mate3.specular = vec3(1.0);\n    mate3.specTrans = 0.0;\n    mate3.ior = 1.0;\n    \n    Material mate4;\n    mate4.albedo = vec3(1.0);\n    mate4.emissive = vec4(1, 1, 1, 2);\n    mate4.metallic = 0.0;\n    mate4.roughness = 1.0;\n    mate4.specular = vec3(0.0);\n    mate4.specTrans = 0.0;\n    mate4.ior = 1.0;\n    \n    g_materials[0] = mate1;\n    g_materials[1] = mate2;\n    g_materials[2] = mate3;\n    g_materials[3] = mate4;\n    \n    g_planes[0] = Plane(vec3(0, 0, 0), vec3(0, 1, 0), vec3(1, 0, 0), 1u);\n    g_spheres[0] = Sphere(vec3(0, 5.01, 0.0), 5.0, vec3(0.9, 0.1, 0.1), 0u);\n    g_spheres[1] = Sphere(vec3(-14.3, 6.01, 8.7), 6.0, vec3(1, 0.1, 0), 2u);\n    g_spheres[2] = Sphere(vec3(13.2, 4.01, -6.2), 4.0, vec3(1, 1, 1), 3u);\n    \n    g_boxes[0] = Box(vec3(-15, 0, -15), vec3(-5, 10, -5), vec3(0.4, 0.5, 0.02), 0u);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n    float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n    initScene();\n    \n    const vec3 scene_center = vec3(0.0, 5.0, 0.0);\n    const float camera_dist = 30.0;\n    vec2 rot = abs(iMouse.xy) / iResolution.xy - 0.5;\n    vec3 ss = vec3(cos(1.5 + 6.0 * rot.x), 1.0 + 2.0 * rot.y, sin(1.5 + 6.0 * rot.x));\n    vec3 origin = scene_center + camera_dist * ss;\n    vec3 forward = normalize(scene_center - origin);\n    \n    bool reset = false;\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    float daytime = mod(floor(iTime / 5.0), 2.0);\n    \n    if (daytime != data.w\n        || round(rot * iResolution.xy) != round(data.xy)\n        || round(data.z) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n\t\tfragColor = vec4(rot * iResolution.xy, iResolution.x, daytime);\n        return;\n    }\n    \n    vec3 color = vec3(0);\n    vec3 radi = vec3(0);\n    vec3 irradi = vec3(0);\n    for (float i = 0.0; i < SAMPLES; ++i) {\n        Ray ray = setCamera(origin, forward, (fragCoord + hash2(seed)) / iResolution.xy);\n        \n        vec3 r = vec3(0);\n        vec3 ir = vec3(0);\n        vec3 t = tracePath(ray, daytime == 0.0, seed, r, ir);\n        radi += r;\n        irradi += ir;\n        color += t;\n    }\n    color /= SAMPLES;\n    radi /= SAMPLES;\n    irradi /= SAMPLES;\n    \n    color = (color + irradi) * radi;\n    \n    if (reset) {\n       fragColor = vec4(color, 1.0); \n    } else {\n       fragColor = vec4(color, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 293]], "test": "untested"}
{"id": "dtsXD2", "name": "marching spheres ", "author": "maxg123", "description": "i got this idea from my friand and he help me a lot for this shader. and a little of ray marching for dummies on YouTube. ", "tags": ["spheres"], "likes": 1, "viewed": 170, "published": 3, "date": "1675394405", "time_retrieved": "2024-07-30T18:12:27.997656", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {  // this makes the spheres \n    vec4 s = vec4(0, 1, 0, .4);\n    p.xyz = mod(p.xyz,2.)-1.;\n    float sphereDist = length(p)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return sphereDist;\n}\nfloat RayMarch(vec3 ro, vec3 rd) {  // this is the shader \n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // this is the checkered color \n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 ro = vec3(0, 3.5, iTime);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd);\n    if(d>MAX_DIST) return;\n    vec3 p =(ro + rd * d)*2.0;\n    vec3 fp = vec3(floor(p));\n    vec3 col = vec3(int(fp.x+fp.y+fp.z)%2)*exp(-d*0.1);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 118, 317], [318, 318, 352, 376, 588], [591, 591, 680, 680, 1080]], "test": "untested"}
{"id": "clBGD3", "name": "Fake bounce lighting", "author": "fishy", "description": "Using the color output from the AO (which is already an approximation) I can get a fake bounce lighting effect", "tags": ["raymarching"], "likes": 9, "viewed": 216, "published": 3, "date": "1675377796", "time_retrieved": "2024-07-30T18:12:28.875309", "image_code": "#define AA 3.0\n#define FOCAL_LEN 1.\n\n#define AO_STR 1.\n#define AO_DIST 0.2\n#define AO_POW 4.\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    float scale = 0.02;\n    p /= scale;\n    //p = rotZ(p, iTime);\n    float d = 1e20;\n    join(d, sdBox(p, vec3(20.)));\n    float d0 = sdBox(p, vec3(30., 10., 10.));\n    join(d0, sdBox(p, vec3(10., 30., 10.)));\n    join(d0, sdBox(p, vec3(10., 10., 30.)));\n    outMat = marchMat(vec3(0.9), 0);\n    if(d0 < d)\n        outMat = marchMat(vec3(1, 0, 0), 0);\n    join(d, d0);\n    d *= scale;\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.00001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\n#define light(l, c, a, str) lighting += vec3(c)*(max(0., dot(n, l))+a)*str;\nvec3 getLighting(vec3 n)\n{\n    //return dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))+0.5*max(0., n.z);\n    return vec3(max(0., dot(n, normalize(vec3(1))))+0.1);\n    //vec3 lighting = vec3(0);\n    //light(vec3(1), vec3(1.000,0.933,0.800), 0.05, 0.8);\n    //light(vec3(0, -1, 0), vec3(1.000,0.561,0.169), 0., 0.1);\n    //light(vec3(0, 1, 0), vec3(0.169,0.541,1.000), 0., 0.2);\n    //return lighting;\n}\n\n#define displayVarH(n) mix(vec4(.9), displayVar(n), vec4(res.hit))\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982+iTime*0.2) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    vec3 lighting = getLighting(n);\n    marchMat aoMat;\n    vec3 aoPos = res.pos+AO_DIST*n;\n    float aoDist = sceneDist(aoPos, aoMat);\n    vec3 aoNorm = calcNormal(aoPos);\n    vec3 ao = (1.-aoMat.color)*(pow(1.-saturate(aoDist/AO_DIST), AO_POW))*pow(lighting, vec3(0.5));\n    \n    vec3 envMap = texture(iChannel0, reflect(rd, n), texture(iChannel2, res.pos*0.5).r*5.0).rgb;\n    envMap *= envMap;\n    \n    res.mat.color = res.mat.color + envMap*1.0;\n\n    return displayVar(mix(vec3(0.9), res.mat.color*lighting*(1.-ao*AO_STR), vec3(res.hit)));\n    //return displayVarH(1.-ao);\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/(AA-1.);\n    res += getColorAtPix(fc, m);\n    if(AA > 1.)\n    {\n        for(float x = 0.; x < 1.; x += st)\n        {\n            res += getColorAtPix(fc + (hash22((x+iTime+fc)*25.)-0.5), m);\n        }\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = sqrt(col) + displayVar(printFR((fragCoord-iResolution.xy*0.5)/iResolution.y*0.55, iFrameRate));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 116, 116, 254], [256, 256, 277, 277, 413], [455, 455, 499, 499, 535], [537, 537, 576, 576, 616], [618, 618, 667, 667, 764], [766, 766, 787, 787, 836], [839, 839, 867, 867, 902], [904, 904, 932, 932, 967], [969, 969, 997, 997, 1032], [1034, 1034, 1180, 1180, 1264], [1401, 1401, 1435, 1435, 1453], [1454, 1454, 1494, 1494, 1511], [1513, 1513, 1568, 1568, 1649], [1651, 1651, 1707, 1707, 1805], [1807, 1807, 1867, 1867, 1908], [1910, 1910, 1970, 1970, 2014], [2016, 2016, 2049, 2049, 2075], [2077, 2077, 2117, 2117, 2204], [2206, 2206, 2246, 2246, 2324], [2326, 2326, 2364, 2364, 2394], [2396, 2396, 2430, 2430, 2477], [2479, 2479, 2522, 2522, 2573], [2575, 2575, 2640, 2640, 2752], [2754, 2754, 2800, 2800, 3202], [3204, 3204, 3229, 3229, 3275], [3277, 3277, 3351, 3351, 3732], [3734, 3734, 3773, 3773, 4036], [4114, 4114, 4140, 4239, 4536], [4606, 4606, 4643, 4643, 5649], [5651, 5651, 5683, 5683, 5902], [5904, 5904, 5940, 5940, 6211], [6213, 6213, 6270, 6270, 6432]], "test": "untested"}
{"id": "DtlSRl", "name": "lame spheres", "author": "SandStuido", "description": "this is my first shader ", "tags": ["raymarching"], "likes": 2, "viewed": 137, "published": 3, "date": "1675371508", "time_retrieved": "2024-07-30T18:12:29.664200", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) { // this makes spheres\n    vec4 s = vec4(0, 1, 0, 0.4);\n    p.xyz = mod(p.xyz,2.0)-1.0;\n    float sphereDist = length(p)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return sphereDist;\n}\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p  = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 ro = vec3(0, 3, iTime);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd);\n   if(d>MAX_DIST) return;\n    vec3 p = (ro + rd * d)* 2.0;\n    vec3 fp = vec3(floor(p));\n    vec3 col = vec3(int(fp.x+fp.y+fp.z)%2)*exp(-d*0.1);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 112, 314], [315, 315, 349, 349, 562], [564, 564, 621, 621, 1020]], "test": "untested"}
{"id": "cllXDj", "name": "My 6th Raytracing", "author": "SONENEIS", "description": "Credits: \"Cheesy by P_Malin\", \"Raytracing Booleans by iq\".\n", "tags": ["3d", "raytracing", "flat", "sun", "cube", "shadow", "sphere", "intersection", "box", "plane", "directional", "difference", "union", "subtraction", "hardshadow", "flatshadow"], "likes": 4, "viewed": 236, "published": 3, "date": "1675362435", "time_retrieved": "2024-07-30T18:12:30.707411", "image_code": "#define AA 2\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nstruct Hit{\n\tfloat t;\n\tfloat id;\n\tvec3 nor;\n} kEmpty = Hit(9.9e20,-1.0,vec3(0.0));\n\nstruct Inter{\n\tHit a; //positive\n\tHit b; //negative\n} iEmpty = Inter(Hit(9.9e20,-1.0,vec3(0.0)),Hit(9.9e20,-1.0,vec3(0.0)));\n\nInter iUn(Inter a,Inter b){\n\tif(b.a.t >= b.b.t){\n\t\tif(a.a.t >= a.b.t) return iEmpty;\n\t\telse return a;\n\t}else if(a.a.t >= a.b.t) return b;\n\telse{\n\t\tInter res = iEmpty;\n\t  if(a.a.t < b.a.t) res.a = a.a;\n\t  else res.a = b.a;\n\t\tif(a.b.t > b.b.t) res.b = a.b;\n\t\telse res.b = b.b;\n  \treturn res;\n\t}\n}\n\nInter iIn(Inter a,Inter b){\n  if(a.a.t < b.a.t){\n    if(a.b.t < b.a.t) return iEmpty;\n    if(a.b.t < b.b.t) return Inter(b.a,a.b);\n    return b;\n  }else if(a.a.t < b.b.t){\n    if(a.b.t < b.b.t) return a;\n    return Inter(a.a,b.b);\n  }else return iEmpty;\n}\n\nInter iDi(Inter b,Inter a){\n  if(a.a.t < b.a.t){\n    if(a.b.t < b.a.t) return b;\n    if(a.b.t < b.b.t) return Inter(a.b,b.b);\n    return iEmpty;\n  }else if(a.a.t < b.b.t){\n    if(a.b.t < b.b.t) return Inter(b.a,a.a);\n    return Inter(b.a,a.b);\n  }else return b;\n}\n\nInter iSphere(float id,vec3 ro,vec3 rd,float r){\n\tInter res;\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return iEmpty;\n\tres.a.t = -b - sqrt(h);\n\tres.b.t = -b + sqrt(h);\n\tres.a.nor = normalize((ro+rd*res.a.t)/r);\n\tres.b.nor = normalize(-(ro+rd*res.b.t)/r);\n\tres.a.id = id;\n\tres.b.id = id;\n\treturn res;\n}\n\nInter iBox(float id,vec3 ro,vec3 rd,vec3 b){\n\tInter res;\n\tvec3 m = 1.0/rd;\n\tvec3 n = ro * m;\n\tvec3 k = abs(m) * b;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(t1.x,max(t1.y,t1.z));\n\tfloat tF = min(t2.x,min(t2.y,t2.z));\n\tif(tF < tN || tF < 0.0) return iEmpty;\n\tres.a.t = tN;\n\tres.b.t = tF;\n\tres.a.nor = normalize(sign(-rd) * step(vec3(res.a.t),t1));\n\tres.b.nor = normalize(sign(-rd) * step(t2,vec3(res.b.t)));\n\tres.a.id = id;\n\tres.b.id = id;\n\treturn res;\n}\n\nInter scene(vec3 ro,vec3 rd){\n  Inter scn = iEmpty;\n\n  scn = iUn(scn,iIn(\n  \tiBox(3.0,ro-vec3(3.0,0.0,0.0),rd,vec3(1)),\n    iSphere(1.0,ro-vec3(3.0,0.0,0.0),rd,1.22)\n  ));\n\n  scn = iUn(scn,iDi(\n  \tiBox(3.0,ro-vec3(-3.0,0.0,0.0),rd,vec3(1)),\n    iSphere(1.0,ro-vec3(-3.0,0.0,0.0),rd,1.22)\n  ));\n\n  scn = iUn(scn,iDi(\n    iSphere(1.0,ro-vec3(0.0,0.0,3.0),rd,1.22),\n  \tiBox(3.0,ro-vec3(0.0,0.0,3.0),rd,vec3(1))\n  ));\n\n  scn = iUn(scn,iUn(\n  \tiBox(3.0,ro-vec3(0.0,0.0,-3.0),rd,vec3(1)),\n    iSphere(1.0,ro-vec3(0.0,0.0,-3.0),rd,1.22)\n  ));\n  \n  scn = iUn(scn,iBox(3.0,ro-vec3(0.0,-3.0,0.0),rd,vec3(1)));\n  scn = iUn(scn,iSphere(1.0,ro-vec3(0.0,3.0,0.0),rd,1.22));\n  \n  scn = iUn(scn,iBox(0.0,ro-vec3(ro.x,-4.0,ro.z),rd,vec3(9.9e20,0.00001,9.9e20)));\n\n  return scn;\n}\n\nHit raytrace(vec3 ro,vec3 rd){\n\tHit res = kEmpty;\n\n  Inter scn = scene(ro,rd);\n\n\tif(scn.a.t > 0.0 && scn.a.t < res.t){\n\t\tres.t = scn.a.t;\n\t\tres.id = scn.a.id;\n\t\tres.nor = scn.a.nor;\n\t}\n\n\treturn res;\n}\n\nfloat dirLight(vec3 rd,Hit h,vec3 pos,float r){\n\tfloat lig = 1.0;\n\n\tfloat a = length(rd-normalize(pos));\n\tif(h.id == -1.0) lig = a;\n\n\treturn r/1500.0 / (lig*lig);\n}\n\nvec3 render(vec2 uv){\n\tvec3 col = vec3(0.0);\n\t\n  vec3 ro = vec3(0.0,0.0,9.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  //ro.y += 3.5;\n  //rd.zy *= rot(0.5);\n\n  ro.xz *= rot(iTime*0.5);\n  rd.xz *= rot(iTime*0.5);\n\n  vec3 bg = mix(vec3(0.25,0.5,1.0),vec3(0.5,0.95,1),0.5-3.0*clamp(rd.y,0.0,1.0));\n\n  Hit hit = raytrace(ro,rd);\n\n  if(hit.id != -1.0){\n    vec3 nor = hit.nor;\n  \tvec3 pos = ro + rd*hit.t + nor*0.00001;\n    vec3 ref = reflect(rd,nor);\n    vec3 mate = vec3(0.0);\n\n    if(hit.id == 0.0){\n    \tmate += 0.5+0.5*mod(dot(floor(pos*5.0),vec3(1.0)),2.0);\n    }else if(hit.id == 1.0){\n    \tmate += vec3(1,0,0);\n    }else if(hit.id == 2.0){\n    \tmate += vec3(0,1,0);\n    }else if(hit.id == 3.0){\n    \tmate += vec3(0,0,1);\n    }\n\n    {\n    \tvec3 lig = normalize(vec3(0.3,0.45,0.6));\n    \tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n    \tfloat sha = step(length(pos-lig),raytrace(pos,lig).t);\n    \tdif *= sha;\n    \tfloat spe = clamp(dot(ref,lig),0.0,1.0);\n    \tspe = dif * 0.5*pow(spe,64.0);\n\n    \tcol += mate * dif + spe;\n\n      float Bdif = clamp(dot(nor,-lig),0.0,1.0);\n    \tfloat Bspe = clamp(dot(ref,-lig),0.0,1.0);\n    \tcol += mate * Bdif*0.01;\n    \tcol += mate * Bdif*pow(Bspe,2.0)*0.01;\n    }\n\n    {\n    \tfloat dif = clamp(nor.y*0.5+0.5,0.0,1.0);\n    \tfloat spe = smoothstep(-0.6,0.6,ref.y);\n    \tspe *= 0.3+0.96*pow(clamp(1.0+dot(rd,nor),0.0,1.0),5.0);\n    \t//spe *= dif;\n\n    \tcol += (mate*0.75+0.25) * bg * dif*0.05;\n    \tcol += (mate*0.75+0.25) * 2.0*bg * spe*0.05;\n    }\n  }\n\n  col = pow(col,vec3(1.0/2.2));\n\n  col = mix(col,bg,clamp(1.0-exp(-0.025*hit.t),0.0,1.0));\n  \n  col = mix(col,vec3(1),clamp(dirLight(rd,hit,vec3(0.3,0.225,0.6),1.0),0.0,1.0));\n  \n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n#if AA>1\n  for(int i=0;i<AA;i++)\n  for(int j=0;j<AA;j++){\n    vec2 o = vec2(float(i),float(j)) / float(AA) - 0.5;\n    vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    col += render(uv);\n#if AA>1\n  }\n  col /= float(AA*AA);\n#endif\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 32, 32, 75], [287, 287, 314, 314, 581], [583, 583, 610, 610, 838], [840, 840, 867, 867, 1103], [1105, 1105, 1153, 1153, 1449], [1451, 1451, 1495, 1495, 1916], [1918, 1918, 1947, 1947, 2680], [2682, 2682, 2712, 2712, 2882], [2884, 2884, 2931, 2931, 3048], [3050, 3050, 3071, 3071, 4729]], "test": "untested"}
{"id": "WlySDV", "name": "Midterm 6 - Tornado ", "author": "santreal", "description": "Tornado ", "tags": ["tornado"], "likes": 2, "viewed": 140, "published": 3, "date": "1675348491", "time_retrieved": "2024-07-30T18:12:31.500291", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - .5 *iResolution.xy)/iResolution.y;\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 polar =  vec2(atan(uv.x,uv.y), length(uv));\n    \n    uv = vec2(polar.x/6.2831+.5 + iTime * sin(.5) - polar.y, polar.y);\n    \n    float sizeTime = abs(sin(iTime * .9) * 2.0);\n   \tfloat x = uv.x * 10.;\n    float m = min(fract(x),fract(10.-x)); \n    float c = smoothstep(0.2,.1,m* sizeTime+.5-uv.y);\n    \n    vec2 center2 = vec2(0.5*ratio  /*sin(iTime)*/, 0.5);\n    float dist = distance(uv, center2);\n                  \n    // Time varying pixel color\n\tvec3 color = c * vec3(1);\n    color += vec3(0.,0,abs(cos(iTime)) +1.);\n    color *= dist;\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 825]], "test": "untested"}
{"id": "DlXSRs", "name": "SimplexTiledSierpinski", "author": "EvilRyu", "description": "Try some tiling techniques", "tags": ["fractal", "simplex", "tiling", "sierpinski"], "likes": 18, "viewed": 239, "published": 3, "date": "1675348037", "time_retrieved": "2024-07-30T18:12:32.381934", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define sqrt3 1.732050808\n\nbool reverse = false;\nfloat rnd = 0.;\n\nfloat hash12(vec2 p)\n{\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4337);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 *(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k *h *(1.0 - h);\n}\n\n// distance to equilateral triangle\n// Equilateral triangle is defined by\n// max(-2y, y-x*sqrt3, y+x*sqrt3) = R\n// R is the circumradius\nfloat tri(vec2 p, float r)\n{\n    return abs(max(-2.*p.y, max(p.y-sqrt3*p.x, p.y+sqrt3*p.x))-r);\n}\n\nfloat noise(vec2 p)\n{\n    if(reverse) p.y = -p.y;\n    return abs(tri(p+.55*tri(p.yx*2., 0.5+.5*rnd), 0.1));\n}\n\nvec3 drawTri(vec2 p, float r)\n{    \n    return 1.-smoothstep(0.0, 0.015, abs(tri(p, r))-0.03 + 0.02 * noise(p)) * vec3(1.); \n}\n\nvec2 symm(float a, float b, float c, vec2 p)\n{\n    float x = ((b*b-a*a)*p.x-2.0*a*b*p.y-2.0*a*c) / (a*a+b*b);\n    float y = ((a*a-b*b)*p.y-2.0*a*b*p.x-2.0*b*c) / (a*a+b*b);\n    return vec2(x,y);\n}\n\n// distance of p to the line segment of p1, p2\nfloat distToEdge(vec2 p1, vec2 p2, vec2 p)\n{\n    vec2 d = p2 - p1;\n    vec2 v = vec2(1,-1);\n    return abs(dot(d.yx*v, p) + dot(d*v, p1.yx)) / length(d);\n}\n\nvec2 p0, p1, p2;\n\nfloat distToEdges(vec2 p)\n{\n    float d = distToEdge(p0, p2, p);\n    float d2 = distToEdge(p0, p1, p);\n    float d3 = distToEdge(p1, p2, p);\n    return smin(d,smin(d2,d3,.05),.05);\n}\n\n\n// use the distance to the edges as height, for calculating normal\nfloat height(vec2 p)\n{\n    float d = min(0.13, distToEdges(p));\n    return min(d, 0.03 * noise(p) + 0.1);\n}\n\nvec3 getNormal(vec2 p)\n{\n    vec2 eps=vec2(0.03,0.0);\n    vec3 n=vec3(height(p-eps.xy)-height(p+eps.xy),\n                height(p-eps.yx)-height(p+eps.yx),\n                2.0*eps.x);\n  \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    //p*=1.2;\n    p.x += iTime * 0.1;\n    \n    // simplex tiling\n    vec2 i = floor(p + vec2(0.5*p.y, 0.)); \n    vec2 a = p - i + vec2(0.5*i.y, 0.); \n    \n    // check which triangle the current pixel is in\n    float m = step(a.y, 2. * a.x); \n    vec2 o = vec2(m, 1. - m);\n      \n    // the coord of the three vertices\n    p0 = vec2(0);\n    p1 = o - vec2(.5 * (1. - m), 0.);\n    p2 = vec2(.5, 1.);\n    \n    vec2 center = (p0 + p1 + p2) / 3.;\n    \n    p0 -= center;\n    p1 -= center;\n    p2 -= center;\n    a -= center;\n    \n    // min distance to the 3 edges of the triangle\n    float d = distToEdges(a);\n\n    vec3 col = vec3(1);\n    \n    reverse = m > 0.;\n    rnd = hash12(i);\n    \n    d = smoothstep(0., 0.1, d);\n    vec3 n = getNormal(a), ld = normalize(vec3(1.,1.,2.)); \n    \n    // shading\n    col *= 1.1*max(0., dot(n, ld)) * vec3(1., .8, 0.5) + \n            pow(max(0.0,dot(reflect(normalize(vec3(3,0,-1.)),n),ld)),32.);\n    col *= .5 + .5 * cos(6.28318 * (vec3(6) * d + vec3(0.23,0.2,0.15)));\n    \n    // darken the edge between triangles\n    col *= smoothstep(.0,0.1,d);\n\n\n    // drawing the sierpinski\n    if(reverse) a.y = -a.y;\n\n    p = a*vec2(2.5, 2.2) * 1.35;\n    float s=1.0;\n\n    float iter = mod(floor(iTime),9.0);\n    for(int i = 0; i < 4; ++i)\n    {\n        if(i < int(iter+0.5))\n        {\n            s*=0.5;\n            col += drawTri(p,s) * .1;\n\n            if(p.y+sqrt3*p.x>s)// Bottom right triangle\n                p=symm(sqrt3/3., 1.0, 0., p);// Folding along y+1/3*x\n\n            if(p.y-sqrt3*p.x>s)// Bottom left triangle\n                p=symm(-sqrt3/3., 1.0, 0., p);// Folding along y-1/3*x\n\n            p.y+=s;\n        }\n        else\n        {\n            // The animation\n            float a=-2.0*fract(iTime);\n            col+=drawTri(vec2(p.x*cos(a)-p.y*sin(a), p.y*cos(a)+p.x*sin(a)),\n                     fract(iTime)*s*0.5) * .05;\n        }\n    }\n    col*=pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n    fragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXSRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[177, 177, 199, 199, 332], [334, 334, 373, 373, 467], [469, 606, 634, 634, 703], [705, 705, 726, 726, 814], [816, 816, 847, 847, 942], [944, 944, 990, 990, 1140], [1142, 1189, 1233, 1233, 1344], [1364, 1364, 1391, 1391, 1546], [1549, 1616, 1638, 1638, 1723], [1725, 1725, 1749, 1749, 1938], [1940, 1940, 1997, 1997, 4073]], "test": "untested"}
{"id": "mlXXWj", "name": "Matrix Filter", "author": "TimoKinnunen", "description": "Edge sharpen filter from Media Player Classic-Home Cinema, changed into creating a Matrix-style result. Discovered by accident, as it so often happens.", "tags": ["video", "filter", "greenscreen", "matrix", "mpc"], "likes": 1, "viewed": 191, "published": 3, "date": "1675346558", "time_retrieved": "2024-07-30T18:12:33.296488", "image_code": "/****************************************/\n/* Matrix Filter by Timo Kinnunen, 2023 */\n/****************************************/\n/*\n * (C) 2003-2006 Gabest\n * (C) 2006-2013 see Authors.txt\n *\n * This file is part of MPC-HC.\n *\n * MPC-HC is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * MPC-HC is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n//sampler s0 : register(s0);\n//float4 p0 :  register(c0);\n\n//#define width  (p0[0])\n//#define height (p0[1])\n//#define counter (p0[2])\n//#define clock   (p0[3])\n\n#define NbPixel     2.5\n#define Edge_threshold  0.2\n#define Sharpen_val0    2.0\n#define Sharpen_val1    ((Sharpen_val0) * 0.125 - 0.125)\n\n//float4 main(float2 tex : TEXCOORD0) : COLOR\nfloat4 mainCOLOR(float2 tex)\n{\n\tfloat fracY = saturate(0.5+0.5*sin(clock* -3.0+tex.y*1.0+2.*(sin(clock*.5+tex.x*5.0)*2.0+(1.5+0.5*sin(clock*1.5+tex.x*36.0))*(3.0+sin(clock* -0.5+tex.x*47.0)))));\n\tfloat fracX = saturate(8.0*(sin((clock-tex.y*0.75)* -0.375) - 0.75));\n    float4 Res = float4(0);\n\n\t// size of NbPixel pixels\n\tfloat dx = 1.0 / width;\n\tfloat dy = 1.0 / height;\n\tdx *= round(1.0+(NbPixel-1.0)*fracY+0.5*sin(1.1*fracY+0.333*clock+tex.x*256.));\n\tdy *= round(1.0+(NbPixel-1.0)*fracY+0.5*sin(1.3*fracY+0.331*clock+tex.y*256.));\n\t//float4 Res = 0;\n\n\t// Edge detection using Prewitt operator\n\t// Get neighbor points\n\t// [ 1, 2, 3 ]\n\t// [ 4, 0, 5 ]\n\t// [ 6, 7, 8 ]\n\tfloat4 c0 = tex2D(s0, tex);\n\tfloat4 c1 = tex2D(s0, tex + float2(-dx, -dy));\n\tfloat4 c2 = tex2D(s0, tex + float2(  0, -dy));\n\tfloat4 c3 = tex2D(s0, tex + float2( dx, -dy));\n\tfloat4 c4 = tex2D(s0, tex + float2(-dx,   0));\n\tfloat4 c5 = tex2D(s0, tex + float2( dx,   0));\n\tfloat4 c6 = tex2D(s0, tex + float2(-dx,  dy));\n\tfloat4 c7 = tex2D(s0, tex + float2(  0,  dy));\n\tfloat4 c8 = tex2D(s0, tex + float2( dx,  dy));\n\n\t// Computation of the 3 derived vectors (hor, vert, diag1, diag2)\n\tfloat4 delta1 = (c6 + c4 + c1 - c3 - c5 - c8);\n\tfloat4 delta2 = (c4 + c1 + c2 - c5 - c8 - c7);\n\tfloat4 delta3 = (c1 + c2 + c3 - c8 - c7 - c6);\n\tfloat4 delta4 = (c2 + c3 + c5 - c7 - c6 - c4);\n\n\t// Computation of the Prewitt operator\n\tfloat value = length(abs(delta1) + abs(delta2) + abs(delta3) + abs(delta4)) / 6.;\n\n\t// If we have an edge (vector length > Edge_threshold) => apply sharpen filter\n\t{\n\t\tfloat f = value*(2.0/Edge_threshold)-1.0;\n\t\tif (f > 0.0) {\n\t\t\tRes = c0 * Sharpen_val0 - (c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8) * Sharpen_val1;\n\t\t\tif (f <  1.0) {\n\t\t\t\tRes = (Res - c0) * (f)+ c0;\n\t\t\t}\n\t\t} else {\n\t\t\tRes = c0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat4  Res2 = frac(abs(Res-c0)*16.0);\n\t\tRes2.g = saturate(value*32.0);\n\t\tRes = lerp(Res2, Res, saturate(1.5*fracX-0.125-0.25*fracY));\n\t}\n\treturn Res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = mainCOLOR(uv);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 texmix(vec4 a, vec4 b) {\n    vec4 gs = vec4(13,163,37,0)/255.;\n    float d = distance(gs.rgb,b.rgb);\n    const float threshold = 0.625;\n    float t = smoothstep(0.,threshold,d);\n    float t2 = smoothstep(0.5*threshold,0.75*threshold,d);\n    return mix(a,mix(b-gs,b,t2),t);\n}\n#define s0 iChannel0\n#define width  iResolution.x\n#define height iResolution.y\n#define clock   iTime\n#define float4 vec4\n#define float2 vec2\n#define saturate(a) clamp((a), 0., 1.)\n#define frac fract\n#define lerp mix\n//#define tex2D(a,b) texelFetch(a, ivec2(b), 0)\n#define tex2D(a,b) texmix(texture(a, b),texture(iChannel1, b))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXXWj.jpg", "access": "api", "license": "gpl-3.0-plus", "functions": [[1168, 1214, 1244, 1244, 3156], [3158, 3158, 3215, 3265, 3454]], "test": "untested"}
{"id": "ctXSD2", "name": "Dynamic Block Grid 2", "author": "dr2", "description": "More varying randomly sized mobile blocks", "tags": ["grid", "raymarch", "block"], "likes": 10, "viewed": 244, "published": 3, "date": "1675342535", "time_retrieved": "2024-07-30T18:12:34.060446", "image_code": "// \"Dynamic Block Grid 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Based on \"Dynamic Block Grid\")\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\n\nvec3 ltDir;\nvec2 pMid[4], pEdge[4], qcMin, ip;\nfloat tCur, dstFar, eFac, eRound, gSize;\nconst float pi = 3.1415927;\n\n#define H(z) (0.5 + 0.5 * cos (1.5 * tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nvoid CellParms ()\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 ee[4];\n  float hp;\n  e = vec3 (-1., 0., 1.);\n  ee[0] = e.xz;\n  ee[1] = e.zz;\n  ee[2] = e.zx;\n  ee[3] = e.xx;\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5) + pEdge[k] * ee[k];\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, bs;\n  vec2 qc;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < 4; k ++) {\n    qc = ip + pMid[k];\n    q.xz = p.xz - gSize * qc;\n    qc = floor (qc);\n    bs.xz = pEdge[k] - 0.01;\n    bs.y = 1.5 * (bs.x + bs.z) + 0.2 * Hashfv2 (qc);\n    q.y = p.y - gSize * bs.y;\n    d = gSize * PrRound4BoxDf (q / gSize, bs - eRound, eRound);\n    if (d < dMin) {\n      dMin = d;\n      qcMin = qc;\n    }\n    q.y -= gSize * bs.y;\n    bs *= 0.4;\n    bs.y = smoothstep (0.6, 0.7, bs.y);\n    if (bs.y > 0.) {\n      q.y -= gSize * bs.y;\n      d = gSize * PrRound4BoxDf (q / gSize, bs - eRound, eRound);\n      if (d < dMin) {\n        dMin = d;\n        qcMin = qc;\n      }\n    }\n  }\n  return dMin;\n}\n\n#if 1\n\nfloat ObjRay (vec3 ro, vec3 rd)  // (cell-based ray-marching)\n{\n  vec3 p, rdi;\n  vec2 fp, ipP;\n  float dHit, d, eps;\n  eps = 0.001;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  dHit = eps;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    fp = p.xz + 0.5;\n    ip = floor (fp / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    d = ObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((gSize * (ip + step (0., rd.xz)) - fp) * rdi.xz)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\n#else\n\nfloat ObjRay (vec3 ro, vec3 rd)  // (simple ray-marching - visual artifacts)\n{\n  vec3 p;\n  vec2 ipP;\n  float dHit, d;\n  dHit = 0.;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    ip = floor ((p.xz + 0.5) / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\n#endif\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 ipP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    ip = floor ((p.xz + 0.5) / gSize);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  eFac = 0.2;\n  eRound = 0.02;\n  gSize = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (HsvToRgb (vec3 (Hashfv2 (qcMin), 0.1, 0.9)), 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, normalize (vec3 (- ltDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0., 0., 0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 11.;\n  az = 0.;\n  el = -0.35 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * sin (0.1 * pi * tCur);\n    el -= 0.15 * pi * SmoothBump (0.25, 0.75, 0.2, fract (0.02 * tCur));\n  }\n  el = clamp (el, -0.6 * pi, -0.12 * pi);\n  ltDir = normalize (vec3 (0.7, 2., -1.));\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.07 * tCur, 20., 0.2 * tCur);\n  zmFac = 5.;\n  dstFar = 120.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXSD2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[705, 705, 724, 724, 1754], [1756, 1756, 1778, 1778, 2469], [3619, 3619, 3640, 3640, 3895], [3897, 3897, 3934, 3934, 4344], [4346, 4346, 4381, 4381, 5028], [5030, 5030, 5086, 5086, 6278], [6280, 6280, 6327, 6327, 6394], [6396, 6396, 6418, 6418, 6445], [6447, 6447, 6504, 6504, 6587], [6589, 6589, 6625, 6625, 6831], [6833, 6833, 6863, 6863, 6976], [6978, 6978, 7002, 7002, 7119], [7153, 7153, 7177, 7177, 7237]], "test": "untested"}
{"id": "clXXDB", "name": "Modular Flow Overlap", "author": "mla", "description": "Overlapped version - examine 4 regions around pixel point. <mouse-y> sets disc radius \n\n[url]https://twitter.com/matthen2/status/1604117218027077634[/url]\n[url]https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html[/url]", "tags": ["flow", "modular", "eigenvector", "eigenvalue"], "likes": 3, "viewed": 100, "published": 3, "date": "1675325165", "time_retrieved": "2024-07-30T18:12:34.826398", "image_code": "////////////////////////////////////////////////////////////////////////\n//\n// Modular Flow Overlap,mla, 2023\n//\n// Now with overlapping discs - mouse-y sets disc radius\n//\n// Apply a stretch and squeeze transform (x,y)-> (kx,y/k) to a lattice, \n// add just the right skew, and you get a nice looping flow pattern.\n// \n// Inspiration:\n// https://twitter.com/matthen2/status/1604117218027077634\n// https://twitter.com/etiennejcb/status/1604946331411292166 (@Bleuje)\n//\n// For the maths:\n// https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html\n//\n// mouse-x: zoom\n// mouse-y: disc radius\n// r: image rotation\n// x: show disc rotation\n//\n////////////////////////////////////////////////////////////////////////\n\n// Find a canonical representative under the group action - generally\n// the length of the vector decreases to a minimum, then increases\n// again, so just iterate both ways to find the smallest (breaking ties\n// the same way if two vectors are minimal).\nvec2 reduce(vec2 p, mat2 A, mat2 Ainv) {\n  if (p == vec2(0)) return p;\n  while (true) {\n    vec2 p1 = A*p;\n    if (dot(p1,p1) >= dot(p,p)) break;\n    p = p1;\n  }\n  while (true) {\n    vec2 p1 = Ainv*p;\n    if (dot(p1,p1) > dot(p,p)) break;\n    p = p1;\n  }\n  return p;\n}\n\nvec3 getcol(vec2 ix) {\n  //if (ix == vec2(0)) return vec3(1); // Show centre point\n  uint h = uint(int(ix.x)*12345^int(ix.y));\n  h = ihash(h);\n  return 0.2+0.6*h2rgb(float(h)/exp2(32.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // A can be any suitable element of the modular group. This\n    // one has nice eigenvectors. Since determinant is 1, the\n    // eigenvalues are real and distinct if Tr(A) > 2, and the\n    // product of the eigenvalues is 1. If this is the case,\n    // we have an eigendecomposition A = P'XP where P is the\n    // matrix of eigenvectors and X is the diagonal matrix\n    // of the eigenvalues k,1/k.\n    mat2 A = mat2(2,1,1,1); // Must have Tr(A) > 2 and det(A) = 1\n    //A = mat2(0,-1,1,3);\n    float a = A[0][0], b = A[1][0], c = A[0][1], d = A[1][1];\n    assert(a+d > 2.0);\n    assert(a*d - b*c == 1.0);\n    float trace = a+d;\n    float disc = trace*trace-4.0;\n    float l0 = 0.5*(trace-sqrt(disc));\n    float l1 = 0.5*(trace+sqrt(disc)); // l1 = 2.618\n    vec2 e0 = normalize(vec2(-b,a-l0));\n    vec2 e1 = normalize(vec2(-b,a-l1));\n    mat2 P = mat2(e0,e1); // Eigenvector matrix\n    //P = mat2(-1, 1.618034,-1,-0.618034); // For A = (2,1,1,1) (unnormalized)\n    mat2 Ainv = inverse(A);\n    mat2 Pinv = inverse(P);\n    float cycle = log(l1); // Largest eigenvalue\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    if (!key(CHAR_R)) {\n      p += 0.25; p = rotate(p,0.1*iTime); p -= 0.25;\n    }\n    p *= 10.0;\n    if (iMouse.x > 10.0) p *= exp2(3.0*iMouse.x/iResolution.x-1.0);\n    float px = fwidth(p.x);\n    float k = exp(cycle*fract(0.25*iTime)-0.5); // Time loop (repeat every 4 seconds)\n    p *= vec2(k,1.0/k); p = P*p; // Map to skewed space\n    vec2 ix = round(p); p -= ix; // Base cell index and coordinates\n    vec3 col = vec3(1,1,0.75);\n    float radius = 0.8;\n    if (iMouse.y > 10.0) radius = iMouse.y/iResolution.y;\n    int t[] = int[](-1,-1,\n                     -1,0, 0,-1, \n                     -1,1, 0,0, 1,-1, \n                     0,1, 1,0,\n                     1,1); \n    for (int ii = 0; ii < 18; ii += 2) {\n         int i = t[ii], j = t[ii+1];\n         vec2 ix1 = ix + vec2(i,j);\n         vec2 p1 = p - vec2(i,j);\n         p1 = Pinv*p1; p1 *= vec2(1.0/k,k); // Map back to unskewed to draw discs\n         ix1 = reduce(ix1,A,Ainv);\n         vec3 disccol = getcol(ix1);\n         float linewidth = 0.01;\n         vec2 radial = rotate(vec2(1,0),0.25*ix1.x*iTime);\n         if (key(CHAR_X)) disccol *= smoothstep(0.0,px,segment(p1,-radial,radial)-linewidth); \n         col = mix(disccol,col,vec3(smoothstep(0.0,px,length(p1)-radius)));\n         col *= smoothstep(0.0,px,abs(length(p1)-radius)-linewidth);\n    }   \n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nint assert(bool b) {\n if (!b) alert = true;\n return 0;\n}\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n#define sin(x) sin(mod((x),TWOPI))\n#define cos(x) cos(mod((x),TWOPI))\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_SHIFT = 16;\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[736, 990, 1030, 1030, 1258], [1260, 1260, 1282, 1342, 1449]], "test": "untested"}
{"id": "dllXRl", "name": "4D Interactive Ball Pit", "author": "fenix", "description": "Explore 4D physics! This is a simulation of 200 Lisa Frank colored hyperspheres in a hyperbox, but only one 3D slice is rendered at a time, with analytic soft shadows.\n\n*mouse to control sliders and grab/throw balls*\n*space to reset simulation*", "tags": ["3d", "collision", "simulation", "interactive", "shadow", "particles", "shadows", "balls", "4d", "dynamics", "physics", "analytic", "softshadow"], "likes": 31, "viewed": 423, "published": 3, "date": "1675315758", "time_retrieved": "2024-07-30T18:12:35.975326", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Explore 4D physics! This is a simulation of 200 Lisa Frank colored hyperspheres in a\n//  hyperbox, but only one 3D slice is rendered at a time, with analytic soft shadows.\n//  The 3D projection of the balls appears to shrink whenever we're rendering a slice\n//  that is not through their W centers.\n//\n//  Only the bare skeleton is shared with its predecessor this time, the simulation and\n//  rendering of course having to be modified to take the fourth dimension into account.\n//  I've done shadows with voronoi before, for example:\n//\n//    Cloth Draping + Shadows    https://shadertoy.com/view/cdjGRR\n//\n//  But previously I was rendering the particles into a depth buffer and creating shadows\n//  from that. Rendering the shadows directly from the voronoi buffer allows me to use\n//  analytic soft shadows, which I haven't done before. Everything casts shadows on\n//  everything else, barring failures of the voronoi tracking to find all the correct\n//  particles. I was inpsired to make this after watching this video of a project called\n//  4D Toys:\n//\n//    https://www.youtube.com/watch?v=0t4aKJuKP0Q\n//\n//  Their simulation is much more advanced than mine, with polyhedra in addition to\n//  spheres (and more stable for sure). But I've got two light sources :)\n//\n//  The reason the hyperspheres shrink and grow is that we are looking at different\n//  slices in the fourth dimension (W), as controlled by the right-side slider (which\n//  moves automatically at boot and after a period of inactivity). The balls will also\n//  knock each other in W directions as they collide, causing them to grow or shrink. At\n//  the ends of the W view range, you can see all the balls become the same size before\n//  they disappear; this is because those balls are pressed against one of the W walls\n//  in the physics simulation.\n//\n//  It was surprisingly easy to adapt the simulation to four dimensions. I just went thru\n//  replacing vec3s with vec4s basically. I was afraid that I'd need more than sixteen\n//  simulation neighbors per particle due to the extra dimension, but apparently this is\n//  enough (but this time, again, 8 neighbors is not really enough). I probably spent more\n//  time on the simulation trying to get it a bit more stable, with mixed results as you\n//  can see. The stack does seem to eventually settle down into a nice 4D sphere packing\n//  solution, so, good enough? I probably spent more time than that on the lighting.\n//\n//  The right slider controls the W slice being rendered, and the left slider controls\n//  the camera. You can drag the hyperspheres around, during which they are locked into\n//  the w slice where you grabbed them (so their 3D projections do not change size). You\n//  can also throw them (only in X, Y, Z directions) if you release them with a mouse drag.\n//\n//  I think it's interesting that while this shader displays a 3D view of a 4D scene, it's\n//  also responsible for displaying that 3D view onto your 2D screen. I guess I feel that's\n//  why all the shading helps, to make the 3D -> 2D projection easier to believe.\n//\n//  There are a few compile options at the top of the common tab that might be worth trying.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C computes nearest particles to each light A space \"pixel\"\n//  Buffer D computes nearest particles to each light B space \"pixel\"\n//  Image performs rendering\n//\n// ---------------------------------------------------------------------------------------\n\n// some parameters for the four vertical cylinder \"posts\" that define the box visually\nconst float POST_RADIUS = .05;\nconst vec3 POST_AXIS = vec3(0, 1, 0);\n\n// compute the material color based on the id\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\nvec3 materialColor(int c)\n{\n    // sphere colors (Lisa Frank palette)\n    switch(c % 5)\n    {\n        case 0: return RGB(233,0,141);\n        case 1: return RGB(255,82,27);\n        case 2: return RGB(255,240,8);\n        case 3: return RGB(50,255,20);\n        case 4: return RGB(5,173,255); \n    }\n}\n\n// compute shadow cast by one particle\nfloat shadowFromParticle(vec3 pos, int id, float maxT, fxParticle p, vec3 ro, vec3 rd, float viewW)\n{\n    float size = sizeById(id);\n    float t = sphIntersect(vec4(ro, viewW), vec4(-rd, 0), p.pos, size * 1.1);\n    t = abs(t);\n    size = max(0., size - abs(viewW - p.pos.w));\n    if (size > 0. && t < maxT)\n        return sphSoftShadow(ro, -rd, vec4(p.pos.xyz, size), 100.);\n    \n    return 1.;\n}\n\n// compute the shadow cast by the entire scene onto one position in 3D\nfloat calcShadow(sampler2D vor, vec3 p, int exclId, int exclPost, vec3 pp, mat4 w2l, vec3 lightDir, vec3 lightPos, fxState state)\n{\n    vec3 sp = (w2l * vec4(p, 1)).xyz;\n    sp.xy /= sp.z;\n    \n    // render analytic shadows for the particles\n    float sh = 1.;\n    vec2 r = iResolution.xy;\n    vec2 coord = (sp.xy * .5 * vec2(r.y / r.x, 1) + .5) * r.xy;\n    if (coord.x >= 0. && coord.y >= 0. && coord.x < r.x && coord.y < r.y)\n    {\n#if RENDER_ALL_PARTICLES\n        for (int id = 0; id < MAX_PARTICLES; ++id)\n        {\n#else\n        ivec4 old = fxGetClosestImpl(vor, ivec2(coord));      \n        for (int j = 0; DONT_UNROLL && j < 4; j++)\n        {\n            int id = old[j];\n#endif\n            if (id == exclId) continue;\n            if (id < 0) break;\n            \n            fxParticle data = fxGetParticle(id);\n            if (dot(data.pos.xyz - pp, lightDir) > 0.)\n                sh *= shadowFromParticle(p, id, sp.z, data, lightPos, lightDir, state.viewW);\n                \n            if (sh <= 0.) break;\n        }\n        \n        sh = mix(sh, 1., smoothstep(r.y * .9, r.y, coord.y)); // fade in shadows at the top to prevent hard line\n    }\n    \n    // render analytic shadows for the posts\n    const float POST_SHADOW_K = 12.;\n    if (exclPost != 0) sh *= cylSoftShadow(p, lightDir, vec3( 1, 0,  1), POST_AXIS, POST_RADIUS, POST_SHADOW_K);\n    if (exclPost != 1) sh *= cylSoftShadow(p, lightDir, vec3(-1, 0,  1), POST_AXIS, POST_RADIUS, POST_SHADOW_K);\n    if (exclPost != 2) sh *= cylSoftShadow(p, lightDir, vec3( 1, 0, -1), POST_AXIS, POST_RADIUS, POST_SHADOW_K);\n    if (exclPost != 3) sh *= cylSoftShadow(p, lightDir, vec3(-1, 0, -1), POST_AXIS, POST_RADIUS, POST_SHADOW_K);\n\n    return sh;\n}\n\n// compute contribution of one light source\nvec3 oneLight(fxState state, sampler2D sampler, vec3 lightPos, vec3 lightColor, vec3 matColor, float shiny, vec3 hitPos, vec3 normal, int id, int postId, mat4 w2l, vec3 pc)\n{\n    vec3 lightDelta = lightPos - hitPos;\n    vec3 lightDir = normalize(lightDelta);\n    float lightDist2 = length2(lightDelta);\n    vec3 reflection = reflect(-lightDir, normal);\n    float spec = pow(max(dot(normal, reflection), 0.), 15.);\n    float diff = max(0., dot(normal, lightDir));\n    float sh = calcShadow(sampler, hitPos, id, postId, hitPos, w2l, lightDir, lightPos, state);\n    return 40. * (matColor * diff + spec * .5) * lightColor * sh / lightDist2;\n}\n\n// combine the two light sources\nvec3 lighting(vec3 hitPos, vec3 pc, int id, vec3 matColor, float shiny, int postId, vec3 normal, mat4 w2lA, mat4 w2lB, fxState state)\n{\n    vec3 lightA = oneLight(state, iChannel2, LIGHT_POSA, LIGHT_COLORA, matColor, shiny, hitPos, normal, id, postId, w2lA, pc);\n    vec3 lightB = oneLight(state, iChannel3, LIGHT_POSB, LIGHT_COLORB, matColor, shiny, hitPos, normal, id, postId, w2lB, pc);\n    \n    return lightA + lightB;\n}\n\n// https://www.shadertoy.com/view/4dffRH\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec3 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = f*f*(3.0-2.0*f);\n    vec3 du = 6.0*f*(1.0-f);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, f-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, f-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, f-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, f-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, f-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, f-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, f-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, f-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nmat3 rot3Dx(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat3(sc.y, -sc.x, 0, sc.x, sc.y, 0, 0, 0, 1);\n}\n\nmat3 rot3Dz(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat3(1, 0, 0, 0, sc.y, -sc.x, 0, sc.x, sc.y);\n}\n\n// draw one ball\nvoid renderParticle(fxState state, int id, fxParticle p, vec3 ro, vec3 rd, inout vec4 pix, float viewW, mat4 w2lA, mat4 w2lB)\n{\n    float size = sizeById(id);\n    float t = sphIntersect(vec4(ro, viewW), vec4(rd, 0), p.pos, size);\n    if (t > 0. && t <= pix.w && p.pos != vec4(0))\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.pos.xyz);\n\n#if BUMPY_BALLS\n        // rotating the normal by xz gives the vague impression the balls can roll\n        // few people really have a good intuitive feel for what a 4D object really looks like when it rolls anyway,\n        // so maybe I'll fool a few people if they don't read this comment :)\n        vec3 noiseNormal = rot3Dx(p.pos.x * -3.) * rot3Dz(p.pos.z * 3.) * normal; \n        normal = normalize(normal + noised(noiseNormal * 10. + float(id)).xyz * .15);\n#endif\n\n        pix.rgb = lighting(hitPos, p.pos.xyz, id, materialColor(id), 1., -1, normal, w2lA, w2lB, state);\n        pix.w = t;\n    }\n}\n\n// draw a \"post\" (one of the four vertical cylinders surrounding the play area)\nvoid renderPost(vec3 cameraPos, vec3 rayDir, fxState state, inout vec4 pix, mat4 w2lA, mat4 w2lB, int postId, vec2 offset)\n{\n    float t = cylIntersect(cameraPos, rayDir, vec3(offset.x, 0, offset.y), POST_AXIS, POST_RADIUS).x;\n    \n    if (t > 0. && t < pix.w)\n    {\n        vec3 hitPos = cameraPos + t * rayDir;\n        vec3 normal = normalize(vec3(hitPos.x - offset.x, 0, hitPos.z - offset.y));\n        \n        pix.rgb = lighting(hitPos, vec3(offset.x, hitPos.y, offset.y), -1, vec3(1), 0., postId, normal, w2lA, w2lB, state);\n        pix.w = t;\n    }\n}\n\nfloat boxDist(vec2 a, vec2 b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }\n\n// generates a checkerboard pattern\n// aa allows reduction of aliasing at steep angles\nfloat checker(vec2 p, float aa)\n{\n    vec2 m = mod(p, vec2(2.));\n    float sd = boxDist(vec2(1), m);\n    sd = min(sd, boxDist(vec2(0, 0), m));\n    sd = min(sd, boxDist(vec2(2, 2), m));\n    sd = min(sd, boxDist(vec2(2, 0), m));\n    sd = min(sd, boxDist(vec2(0, 2), m));\n    return smoothstep(-aa, aa, .5 - sd) * .25 + .75;\n}\n\n// render background\nvoid renderScene(vec3 cameraPos, vec3 rayDir, fxState state, inout vec4 pix, mat4 w2lA, mat4 w2lB)\n{\n    float t = -cameraPos.y / rayDir.y;\n    if (t > 0.)\n    {\n        vec3 hitPos = cameraPos + t * rayDir;\n        vec3 normal = vec3(0, 1, 0);\n        vec3 matColor = vec3(checker(hitPos.xz, t / iResolution.y));\n\n        pix.rgb = lighting(hitPos, vec3(0, -1000, 0), -1, matColor, 0., -1, normal, w2lA, w2lB, state);\n        pix.w = t;\n    }\n\n    renderPost(cameraPos, rayDir, state, pix, w2lA, w2lB, 0, vec2( 1,  1));\n    renderPost(cameraPos, rayDir, state, pix, w2lA, w2lB, 1, vec2(-1,  1));\n    renderPost(cameraPos, rayDir, state, pix, w2lA, w2lB, 2, vec2( 1, -1));\n    renderPost(cameraPos, rayDir, state, pix, w2lA, w2lB, 3, vec2(-1, -1));\n}\n\n// render one slider\nvoid renderSlider(inout vec4 fragColor, vec2 p, vec2 center, float val)\n{\n    float slider = sdRoundBox(p - center, SLIDER_SIZE, vec4(0));\n    float sliderShadow = sdRoundBox(p - center - vec2(-.002, -.002), SLIDER_SIZE, vec4(0));\n    fragColor = mix(fragColor, vec4(0), smoothstep(.002 + 3. / iResolution.y, .002, abs(sliderShadow - .02)));\n    fragColor = mix(fragColor, vec4(.3), smoothstep(.002 + 3. / iResolution.y, .002, abs(slider - .02)));\n\n    float thumb = sdRoundBox(p - center - vec2(0, .38 * val), vec2(.04, .01), vec4(0));\n    float thumbShadow = sdRoundBox(p - center - vec2(-.002, .38 * val - .002), vec2(.04, .01), vec4(0));\n\n    fragColor = mix(fragColor, vec4(0), smoothstep(.002 + 3. / iResolution.y, .002, thumbShadow));\n    fragColor = mix(fragColor, vec4(.3), smoothstep(.002 + 3. / iResolution.y, .002, thumb));\n}\n\n// render both sliders\nvoid renderUI(fxState state, inout vec4 fragColor, vec2 fragCoord)\n{\n    vec2 p = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    renderSlider(fragColor, p, vec2( .5 * iResolution.x / iResolution.y - SLIDER_DIST_FROM_X_SIDE, 0), state.viewW / W_SIZE);\n    renderSlider(fragColor, p, vec2(-.5 * iResolution.x / iResolution.y + SLIDER_DIST_FROM_X_SIDE, 0), state.camOrbit / ORBIT_SIZE);\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainRender(out vec4 fragColor, vec2 fragCoord, vec3 cameraPos, vec3 rayDir, fxState state, mat4 w2lA, mat4 w2lB)\n{\n    fragColor.w = FAR_CLIP;\n    renderScene(cameraPos, rayDir, state, fragColor, w2lA, w2lB);\n\n    // render particles\n#if RENDER_ALL_PARTICLES\n    for (int id = 0; id < MAX_PARTICLES; ++id)\n    {\n#else\n    ivec4 old = fxGetClosestCamera( ivec2(fragCoord) );      \n    for (int j = 0; DONT_UNROLL && j < 4; j++)\n    {\n        int id = old[j];\n#endif\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(state, id, data, cameraPos, rayDir, fragColor, state.viewW, w2lA, w2lB);\n    }\n    \n    renderUI(state, fragColor, fragCoord);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraFwd, cameraLeft, cameraUp;\n    vec3 cameraPos = fxCalcCameraPos(state);\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 lightFwdA, lightLeftA, lightUpA;\n    fxCalcCamera(LOOK_AT, LIGHT_POSA, lightFwdA, lightLeftA, lightUpA);\n\n    // xform from world into light A space, used for shadows\n    mat4 l2wA = fxCalcCameraMat(iResolution, lightLeftA, lightUpA, lightFwdA, LIGHT_POSA, LIGHT_ZOOM);\n    mat4 w2lA = inverse(l2wA);\n\n    vec3 lightFwdB, lightLeftB, lightUpB;\n    fxCalcCamera(LOOK_AT, LIGHT_POSB, lightFwdB, lightLeftB, lightUpB);\n\n    // xform from world into light B space, used for shadows\n    mat4 l2wB = fxCalcCameraMat(iResolution, lightLeftB, lightUpB, lightFwdB, LIGHT_POSB, LIGHT_ZOOM);\n    mat4 w2lB = inverse(l2wB);\n\n    fragColor = vec4(0);\n    \n#if MSAA > 1\n    for (int x = 0; x < MSAA; ++x)\n    for (int y = 0; y < MSAA; ++y)\n    {\n        vec2 offset = vec2(x, y) / float(MSAA - 1) - .5 * float(MSAA - 1);\n        vec3 rayDir = fxCalcRay(fragCoord + offset, iResolution, cameraFwd, cameraUp, cameraLeft, CAM_ZOOM);\n\n        vec4 subsample;\n        mainRender(subsample, fragCoord + offset, cameraPos, rayDir, state, w2lA, w2lB);\n        \n        fragColor.rgb += subsample.rgb;\n    }\n    \n    fragColor.rgb /= float(MSAA * MSAA);\n#else\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft, CAM_ZOOM);\n\n    mainRender(fragColor, fragCoord, cameraPos, rayDir, state, w2lA, w2lB);\n#endif\n\n    fragColor.rgb = pow(ACESFilm(fragColor.rgb), vec3(1./2.2));\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CONSTANTS\n\n// fun/informative compile options\n#define VARIABLE_SIZED_BALLS 0 // make the balls vary from .5 to 1. in size...seemed like it just added confusion on top of the balls changing size\n#define MODE_3D 0 // tired of all those balls disappearing? turn this on to return to the comforting familiarity of 3D\n#define RENDER_ALL_PARTICLES 0 // test ground truth; disasble voroni tracking and render all particles\n#define EIGHT_NBS 0 // only track 8 physics neighbors per particle (vs 16)...enable for speed at considerable cost to simulation stability\n#define PARTICLE_SPAWN_FRAMES 5 // how many frames to space out the particle spawning after reset\n#define BUMPY_BALLS 1 // disable to make the balls smooth\n\n#define MSAA 1\n// set to 2+ to enable multisample antialiasing if your GPU is expensive enough: 2 is 4x, 3 is 9x, etc\n// In my tests, an iMac with a Radeon 570X can run 4xMSAA (MSAA == 2) with barely a slowdown (50+ FPS at 1600x900)\n// but MSAA > 2 slows it down which is not as much fun. Frame rate is so important in simulations.\n// On a PC with a GeForce RTX Super, it runs at 30 FPS at any normal resolution and MSAA == 4 doesn't even seem to\n// slow it down, but turning on MSAA seems to double the compile time. I guess it's unrolling the entire render loop?\n// Ultimately it's the PC compile time that causes me to leave this disabled, so it doesn't clog the public lists.\n// I'd set it to 2 (4xMSAA) on my iMac and 4 (16xMSAA) on my PC if compile times were not a consideration.\n\n// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .21;\nconst float FAR_CLIP = 1e6; // a t value for when we miss something\nconst float W_SIZE = .5; // the W size of the box holding the hyperspheres\nconst float CAM_ZOOM = 1.;\nconst float LIGHT_ZOOM = .75; // zoomed out more than camera to give wider (taller) coverage\nconst float ORBIT_SIZE = 2. * PI; // scalar on the camera orbit rate\nconst vec3 LIGHT_POSA = vec3(-3, 10, -6); // position of light A\nconst vec3 LIGHT_COLORA = vec3(1, .4, .7); // color of light A\nconst vec3 LIGHT_POSB = vec3(3, 10, -6);  // position of light B\nconst vec3 LIGHT_COLORB = vec3(.4, 1, 1); // color of light B\nconst vec3 LOOK_AT = vec3(0, 1, 0); // where the party at\n\n// ui related\nconst float SLIDER_DIST_FROM_X_SIDE = .2; // how far away the sliders are from the edges\nconst vec2 SLIDER_SIZE = vec2(0, .4); // how big are the sliders\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosestCamera(X) fxGetClosestImpl(iChannel1, X)\n\n#if EIGHT_NBS\n#define L_NEIGHBORS 0\n#define R_NEIGHBORS 1\n#define POS 2\n#define RPOS 3\n#define VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n#else\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 7\n#endif\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec4 pos;\n    vec4 vel;\n#if EIGHT_NBS\n    ivec4 nbs[2];\n#else\n    ivec4 nbs[4];\n#endif\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n#if EIGHT_NBS\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, L_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, R_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.pos = particleData2;\n    particle.vel = particleData3;\n#else\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4;\n    particle.vel = particleData5;\n#endif\n\n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n#if 0 // we don't actually call this function for neighbors, since it's a different code path, but it's notionally handled here\n#if EIGHT_NBS\n    case L_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case R_NEIGHBORS:\n        return vec4(p.nbs[1]);\n#else\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n#endif\n#endif\n    case POS:  \n        return vec4(p.pos);\n    case VEL:  \n        return vec4(p.vel);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 200;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticlesImpl(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n#define computeMaxParticles() computeMaxParticlesImpl(iResolution)\n\n// returns the size of a particlar ball (which is a constant if we have same-sized balls)\n#if VARIABLE_SIZED_BALLS\n#define sizeById(id) (PARTICLE_SIZE * (sin(float(id)) * .25 + .75))\n#else\n#define sizeById(id) PARTICLE_SIZE\n#endif\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec4 grabOffset;\n    vec2 lastMouse;\n    vec2 lastLastMouse;\n    float resolution;\n    float camOrbit;\n    float viewW;\n    int grabId;\n    int attractCounter;\n    bool wSliderActive;\n    bool orbitSliderActive;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.grabOffset = vec4(0);\n    state.lastMouse = vec2(0);\n    state.lastLastMouse = vec2(0);\n    state.resolution = -iResolution.x * iResolution.y;\n    state.camOrbit = 0.;\n    state.viewW = 0.;\n    state.grabId = -1;\n    state.attractCounter = 0;\n    state.wSliderActive = false;\n    state.orbitSliderActive = false;\n}\n\n#define fxInitState(state) fxInitStateImpl(state, iResolution)\n\nconst int W_SLIDER_ACTIVE_BIT     = 1<<0;\nconst int ORBIT_SLIDER_ACTIVE_BIT = 1<<1;\nconst int MAX_ATTRACT_COUNTER     = 0x3ff;\n\nfxState fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    vec4 data2 = texelFetch(sampler, ivec2(2, 0), 0);\n    vec4 data3 = texelFetch(sampler, ivec2(3, 0), 0);\n    \n    fxState state;\n    state.grabOffset = data0;\n    state.lastMouse = data1.xy;\n    state.lastLastMouse = data1.zw;\n    state.resolution = data2.x;\n    state.camOrbit = data2.y;\n    state.viewW = data2.z;\n    state.grabId = int(data2.w);\n    state.attractCounter = int(data3.x);\n    state.wSliderActive = data3.y != 0.;\n    state.orbitSliderActive = data3.z != 0.;\n    \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return state.grabOffset;\n    }\n    else if (ifc == ivec2(1, 0))\n        return vec4(state.lastMouse, state.lastLastMouse);\n    else if (ifc == ivec2(2, 0))\n        return vec4(state.resolution, state.camOrbit, state.viewW, state.grabId);\n    else\n        return vec4(state.attractCounter, state.wSliderActive ? 1. : 0., state.orbitSliderActive ? 1. : 0., 0);\n}\n\n// CAMERA\n\nmat2 rotMat(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nvec3 fxCalcCameraPos(fxState state)\n{\n    vec3 p = vec3(4, 3, 0);\n    p.xz *= rotMat(state.camOrbit - PI * .5);\n    return p * 1.;\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos, float zoom)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0) * zoom,\n                vec4(-0.5*cameraUp, 0.0) * zoom,\n                vec4(cameraFwd, 0.0),\n                vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft, in float zoom)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft * zoom - screenPos.y * cameraUp * zoom);\n}\n\n// SDFS\n\nfloat sdBox(vec4 p, vec4 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, max(p.z, p.w))), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat physicsScene(vec4 p)\n{\n    return -sdBox(p - vec4(0, 20, 0, 0), vec4(1, 20, 1, W_SIZE));\n}\n\nvec4 physicsNormal(vec4 p)\n{\n    const vec2 e = vec2(1,0)*0.1;\n    return normalize( vec4(physicsScene(p + e.xyyy) - physicsScene(p - e.xyyy), \n                           physicsScene(p + e.yxyy) - physicsScene(p - e.yxyy),\n                           physicsScene(p + e.yyxy) - physicsScene(p - e.yyxy),\n                           physicsScene(p + e.yyyx) - physicsScene(p - e.yyyx) ));\n}\n\n// UTILITY\n\n#define DONT_UNROLL min(iFrame,0) >= 0\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n#define KEY_A 65\n#define KEY_S 83\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\t\n\tfloat d = -sph.w + sqrt( max(0.0,sph.w*sph.w-h));\n\tfloat t = -b     - sqrt( max(0.0,h) );\n\treturn (t<0.0) ? 1.0 : smoothstep( 0.0, 1.0, k*d/t );\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec4 ro, in vec4 rd, in vec4 sc, in float r )\n{\n\tvec4 oc = ro - sc;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r * r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// https://iquilezles.org/articles/intersectors/\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// I made this by combining cylIntersect with sphSoftShadow...it's not right...help?\n// Need some other special exit condition other than t < 0.\nfloat cylSoftShadow( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr, float k )\n{\n    if (ro.z < -2.) return 1.; // nasty hack to fix shadow in the wrong direction...need \n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    \n\tfloat d = -cr + sqrt( max(0.0,cr*cr-h));\n\tfloat t = -b     - sqrt( max(0.0,h) );\n\treturn (t < 0. /*|| ??? */ ) ? 1. : smoothstep(0., 1., k*d/t);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// VORONOI\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nfloat fxLineRayDist2(vec3 a, vec3 b, vec3 p)\n{\n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\nfloat distance2Particle(sampler2D sampler, int resWidth, int id, vec3 ro, vec3 rd, float viewW, bool forShadow)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec4 worldPos = fxGetParticleDataImpl(sampler, resWidth, id, POS);\n    float size = sizeById(id);\n    float VOR_EPS = 1.01; // tiny additional margin to make sure the voronoi region does not define the edge of the sphere, so aa works\n    float t = sphIntersect(vec4(ro, viewW), vec4(rd, 0), worldPos, size * VOR_EPS);\n    \n    // if we actually hit the sphere, the distance (priority) is the t value\n    if (t > 0. && worldPos != vec4(0))\n    {\n        return t;\n    }\n\n    if (forShadow)\n    {\n        // if we missed the sphere, and this is for a shadow, keep the next particles that are closest to the ray, if they hit the penumbra\n        float ss = sphSoftShadow(ro, rd, vec4(worldPos.xyz, max(0., size - abs(viewW - worldPos.w))), 80.);\n        if (ss < 1.)\n        {\n            float d = fxLineRayDist2(ro, ro + rd, worldPos.xyz) - size;\n            float x = dot(rd, worldPos.xyz - ro);\n            return 1e3 + d + x * x;\n        }\n    }\n    \n    return FAR_CLIP;\n}\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\nvec4 voronoiImpl(sampler2D particles, vec3 res, int frame, fxState state, sampler2D self, ivec2 ifc, vec3 cameraPos, vec2 fragCoord, bool forShadow, float zoom)\n{\n    vec3 cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, res, cameraFwd, cameraUp, cameraLeft, zoom);\n\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e6);\n    int resWidth = int(res.x);\n\n    if (frame > 0)\n    {\n        ivec4 old = fxGetClosestImpl(self, ifc);\n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            \n            // make sure we consider whatever the previous best were for this pixel, to keep continuity\n            float d2 = distance2Particle(particles, resWidth, id, cameraPos, rayDir, state.viewW, forShadow);\n            insertion_sort( new, dis, id, d2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, frame, j)));\n            ivec4 nbs = ivec4(fxGetParticleDataImpl(particles, int(res.x), id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float d2 = distance2Particle(particles, resWidth, nid, cameraPos, rayDir, state.viewW, forShadow);\n                insertion_sort( new, dis, nid, d2 );\n            }\n        }\n\n        // search nearby pixels for particles that should really also be in our pixel\n        float searchRange = .5 * res.y;\n        uint searchCount = 8u + uint(.0025 * res.y);\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            vec2 h = hash3(uvec3(ifc.x * ifc.y, frame, i)).xy;\n            h -= .5;\n            h *= h * h; // favor closer samples, but take a few farther away too\n            ivec4 old = fxGetClosestImpl(self, ifc + ivec2( h * searchRange) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float d2 = distance2Particle(particles, resWidth, id, cameraPos, rayDir, state.viewW, forShadow);\n                insertion_sort( new, dis, id, d2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = 4 + int(.001 * res.y);\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, frame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(particles, resWidth, id, cameraPos, rayDir, state.viewW, forShadow));\n        }\n    }\n    \n    return vec4(new);\n}\n\n#define voronoi(A, B, C, D, E, F, G) voronoiImpl(iChannel0, iResolution, iFrame, A, B, C, D, E, F, G)\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// 4D Particle simulation\n// ---------------------------------------------------------------------------------------\n\nconst vec4 GRAVITY = vec4(0,-.0005,0,0);\n\nvoid particleStep(inout fxParticle p, int id, fxState state)\n{\n    vec3 h = hash3( uvec3(id, id * iFrame, iFrame) );\n    vec3 h2 = hash3( uvec3(h.x, id, iFrame) );\n\n    // init\n    const vec4 LIMBO = vec4(0, -10, 0, 0);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init particles in the holding pen\n        p.pos = LIMBO;\n        p.vel = vec4(0);\n        for (int i = 0; i < 4; ++i) p.nbs[i] = ivec4(-1);\n        \n        return;\n    }\n    \n    // deactivate particles off the screen until we want to drop them\n    if (p.pos.y <= LIMBO.y)\n    {        \n        if ((iFrame % (MAX_PARTICLES * PARTICLE_SPAWN_FRAMES)) == id * PARTICLE_SPAWN_FRAMES)\n        {\n            // selected for being dropped\n            p.pos = vec4(2.*h.y - 1., 6., 2.*h.z - 1., W_SIZE * (h2.x - .5));\n            p.vel = vec4(0, -.01, 0, 0);\n            for (int i = 0; i < 4; ++i) p.nbs[i] = ivec4(-1);\n        }\n        else\n        {\n            // off-screen holding pen\n            p.pos = LIMBO;\n            p.vel = vec4(0);\n        }\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .995; // damping\n    float velMag = length(p.vel);\n    const float MAX_SPEED = .1; // clamping\n    const float MIN_SPEED = GRAVITY.y * -.5;\n    if (velMag > MAX_SPEED)\n    {\n        p.vel = p.vel * MAX_SPEED / velMag;\n    }\n    else if (velMag < MIN_SPEED)\n    {\n        p.vel = vec4(0); // combat jitters by zeroing out small velocities\n    }\n    p.vel += GRAVITY;\n    p.pos += p.vel; // integrate (this is done before collision so that the rendered results are position-corrected)\n    float size = sizeById(id);\n    \n    // handle mouse grab\n    if (state.grabId == id)\n    {\n        vec3 cameraPos = fxCalcCameraPos(state);\n        vec3 cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        // need xform matrix in camera space to figure out where the user is pulling the ball\n        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos, CAM_ZOOM);\n        vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n\n        // compute new world space 4D position of particle being grabbed\n        vec3 cp = vec3(m, 0) + state.grabOffset.xyz;\n        cp.xy *= cp.z;\n        vec3 wp = (c2w * vec4(cp, 1)).xyz;\n        p.pos.xyz = wp;\n        p.pos.w = state.viewW + state.grabOffset.w;\n        \n        // compute world space velocity based on mouse velocity\n        vec3 cv = 1.*vec3(m - state.lastLastMouse, 0);\n        cv.xy *= cp.z;\n        vec3 wv = (c2w * vec4(cv, 0)).xyz; // nb: 0 in W component because here we transform a normal\n        p.vel = vec4(wv, 0);\n    }\n\n    // solve for new position and velocity\n    for (int iter = 0; DONT_UNROLL && iter < 10; ++iter)\n    {\n        // collide with boundary\n        float boundary = physicsScene(p.pos);\n        if (boundary < size)\n        {\n            vec4 normal = physicsNormal(p.pos);\n\n            // position correction\n            if (iter < 5)\n                p.pos += normal * (size - boundary);\n\n            // clip velocity\n            p.vel -= min(0., dot(p.vel, normal)) * normal * 1.;\n        }\n\n        // collide with neighbors\n        for (int i = 0; DONT_UNROLL && i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n        {\n            for (int j = 0; DONT_UNROLL && j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0 ) break;\n                fxParticle nb = fxGetParticle(nid);\n                vec4 dir = p.pos - nb.pos;\n                float dist = distance(nb.pos, p.pos) + 0.001;\n                dir = normalize(dir);\n                float nbSize = sizeById(nid);\n                float relMass = nbSize * nbSize / (nbSize * nbSize + size * size);\n\n                if (dist < size + nbSize)\n                {\n                    float f = 1.; // relVel factor\n                    float r = 1.; // restitution\n                    if (dir.y > 0.)\n                    {\n                        // position correction (only applied on particles below us; stability hack)\n                        if (iter < 5)\n                            p.pos = mix(p.pos, nb.pos + dir * (size + nbSize), .1 * relMass);\n                    }\n                    else\n                    {\n                        // particles above us can barely move us (stability hack)\n                        f = .5;\n                        r = .5;\n                    }\n\n                    // velocity correction\n                    vec4 relVel = p.vel - nb.vel * f;\n                    p.vel -= dot(relVel, dir) * dir * r * relMass;\n                }\n            }\n        }\n    }\n    \n#if MODE_3D\n    p.pos.w = 0.; // in 3D mode, all particles stay on the w == 0. plane\n#endif\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX.xyz - myParticle.pos.xyz;\n    \n#if EIGHT_NBS\n    int dir = int(float(dx.x > 0.) * .5 + .5);\n#else\n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n#endif\n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant (ignoring y and w)\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < ((EIGHT_NBS == 1) ? 2 : 4); ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // randomly consider one of the neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % ((EIGHT_NBS == 1) ? 2 : 4);\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n                for (int y = 0; y < 2; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles();\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, id, state);\n    fragColor = fxSaveParticle(p, dataType);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer for particle render, also state update\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nvec4 updateState(fxState state, ivec2 ifc)\n{\n    if (iFrame == 0)\n    {\n        fxInitState(state);\n    }\n    else\n    {\n        if (abs(state.resolution) != iResolution.x * iResolution.y || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y; // resolution going negative signals balls to reset (necessary on resolution changes)\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n        }\n\n        vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n\n        if (iMouse.z > 0.)\n        {\n            state.attractCounter = MAX_ATTRACT_COUNTER; // user clicked, reset attract counter\n            \n            // rember last mouse so we can compute velocity\n            state.lastLastMouse = state.lastMouse;\n            state.lastMouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n            if (iMouse.w > 0.)\n            {\n                // check for slider interaction\n                if (abs(m.x - (.5 * iResolution.x / iResolution.y - SLIDER_DIST_FROM_X_SIDE)) < SLIDER_SIZE.x + .1)\n                {\n                    state.wSliderActive = true;\n                }\n                else if (abs(m.x + (.5 * iResolution.x / iResolution.y - SLIDER_DIST_FROM_X_SIDE)) < SLIDER_SIZE.x + .1)\n                {\n                    state.orbitSliderActive = true;\n                }\n                else\n                {\n                    // set up mouse grab using screen space voronoi\n                    ivec4 old = fxGetClosestCamera(ivec2(iMouse.xy));      \n                    int cid = old[0];\n                    if (cid >= 0)\n                    {\n                        state.grabId = cid;\n\n                        fxParticle p = fxGetParticle(cid);\n\n                        vec3 cameraPos = fxCalcCameraPos(state);\n                        vec3 cameraFwd, cameraLeft, cameraUp;\n                        fxCalcCamera(LOOK_AT, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    \n                        // get xform matrix from world to camera\n                        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos, CAM_ZOOM);\n                        mat4 w2c = inverse(c2w);\n\n                        m *= 2.;\n                        \n                        // compute screen space position of ball\n                        vec3 sp = (w2c * vec4(p.pos.xyz, 1)).xyz;\n                        sp.xy /= sp.z;\n\n                        // compute grab offset\n                        state.grabOffset.xyz = sp;\n                        state.grabOffset.xy -= m; \n                        state.grabOffset.w = p.pos.w - state.viewW;\n                    }\n                }\n                \n                state.lastLastMouse = state.lastMouse; // we just clicked so lastLastMouse is state, don't use it\n            }\n        }\n        else\n        {\n            // no mouse click, reset grab and sliders\n            state.grabId = -1;\n            state.grabOffset = vec4(0);\n            state.orbitSliderActive = state.wSliderActive = false;\n        }\n\n        // handle attract mode\n        if (state.attractCounter > 0)\n        {\n            --state.attractCounter;\n        }\n        else\n        {\n            float dt = float(iFrame);\n            state.camOrbit += cos(dt * .002) * .001;\n            state.viewW += cos(dt * .005) * .0023;\n            state.viewW *= .999; // apply some drag so we don't bump into the ends every time we swing\n        }\n\n        // handle slider interaction\n        if (state.wSliderActive)\n        {\n            state.viewW = m.y * W_SIZE / SLIDER_SIZE.y;\n        }\n\n        if (state.orbitSliderActive)\n        {\n            state.camOrbit = m.y * ORBIT_SIZE / SLIDER_SIZE.y;\n        }\n\n        state.viewW = clamp(state.viewW, -W_SIZE * 1.01, W_SIZE * 1.01); // go a little past so shadows disappear\n #if MODE_3D\n        state.viewW = 0.;\n #endif\n        state.camOrbit = clamp(state.camOrbit, -ORBIT_SIZE, ORBIT_SIZE);\n    }\n    \n    return fxPutState(state, ifc);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    computeMaxParticles();\n    fxState state = fxGetState();\n    \n   \tivec2 ifc = ivec2(fragCoord);\n    if(ifc == ivec2(0) ||\n       ifc == ivec2(1, 0) ||\n       ifc == ivec2(2, 0) ||\n       ifc == ivec2(3, 0))\n    {\n        fragColor = updateState(state, ifc);\n        return;\n    }\n\n    fragColor = voronoi(state, iChannel1, ifc, fxCalcCameraPos(state), fragCoord, false, CAM_ZOOM);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer for light source A\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    computeMaxParticles();\n\n    fragColor = voronoi(fxGetState(), iChannel2, ivec2(fragCoord), LIGHT_POSA, fragCoord, true, LIGHT_ZOOM);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer for light source B\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    computeMaxParticles();\n\n    fragColor = voronoi(fxGetState(), iChannel2, ivec2(fragCoord), LIGHT_POSB, fragCoord, true, LIGHT_ZOOM);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllXRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[4049, 4049, 4076, 4118, 4346], [4348, 4387, 4488, 4488, 4783]], "test": "untested"}
{"id": "ctlXDB", "name": "scroll feedback", "author": "jackwitherell", "description": "look at the buffer A and you can figure out what's goin on", "tags": ["test", "reference", "buffer", "democode"], "likes": 3, "viewed": 189, "published": 3, "date": "1675303163", "time_retrieved": "2024-07-30T18:12:36.808099", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch(iChannel1,ivec2(fragCoord),0).rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //scroll parameter\n    vec2 offset = vec2(1.0, 0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    if (int(fragCoord.x)+1==int(iResolution.x)){\n        //right edge code\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else{\n        col = texelFetch(iChannel1,ivec2(fragCoord+offset),0).rgb;\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 131]], "test": "untested"}
{"id": "clfSWS", "name": "Raytracer  (Release v1.6)", "author": "raymarchingenthusiast", "description": "A raytracer. Added light objects support (Uses a single extra line).\nAdded boxes.\nThere is an error in flat surfaces that I find impossible to fix (Streaks of light values).", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 6, "viewed": 257, "published": 3, "date": "1675300277", "time_retrieved": "2024-07-30T18:12:37.592003", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n    irand(float(iFrame)*8.,i);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define F float(iFrame)+1.\nstruct Material {\n    float roughness;\n    float shininess;\n    float refrIdx;\n    vec3 color;\n};\n\nstruct Light {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};\n\n\n#define sfloor(a) sign(a)*floor(abs(a))\n\n#define A vec3(2903.,347.,503.)\n#define B vec3(4139.,1459.,1723.)\nfloat seed;\nbool mode = false;\nfloat rand(void){\n  vec3 a = mode?A:B;\n  mode = !mode;\n  seed = mod(seed*a.x+a.y,a.z)/a.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  vec3 a = mode?A:B;\n  mode = !mode;\n  return mod(s*a.x+a.y,a.z)/a.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(srand(p.x+p.y*t)*p.y-t*p.x);\n  mode = sign(p.y*p.y-t*p.x)<0.?true:false;\n}\nvec3 boxSurfP(vec3 b) {\n    vec3 p = vec3(rand(),rand2());\n    float f = floor(rand()*6.);\n    if(f==0.) p.x = 0.;\n    if(f==1.) p.x = 1.;\n    if(f==2.) p.y = 0.;\n    if(f==3.) p.y = 1.;\n    if(f==4.) p.z = 0.;\n    if(f==5.) p.z = 1.;\n    p = 2.*p-1.;\n    p *= b;\n    return p;\n}\nvec3 aabbNor(vec3 p,vec3 b){\n    vec3 n = sfloor(p/b);\n    return normalize(n);\n}", "buffer_a_code": "void mainImage(out vec4 o,in vec2 i) {\n    vec4 prev = texelFetch(iChannel0,ivec2(i),0);\n    vec4 new = prev;\n    \n    o = new;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 d,float t) {\n    return vec3(0.);//.5,.65,.95\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd,int lId,float t) {\n    float d0 = sphInt(ro,rd,vec3(-1.,-.2,3.),.8).x;\n    if(d0 < 0.||lId==0) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    float d2 = sphInt(ro,rd,vec3(-2.5,1.,5.),2.).x;\n    if(d2 < 0.) d2 = Inf;\n    float d3 = sphInt(ro,rd,vec3(2.,.5,4.5),1.5).x;\n    if(d3 < 0.) d3 = Inf;\n    float d4 = boxInt(ro-vec3(1.75,1.,2.),rd,vec3(.9,.3,.6)).x;\n    if(d4 < 0.) d4 = Inf;\n    float d5 = boxInt(ro-vec3(0.,3.5,5.5),rd,vec3(1.)).x;\n    if(d5 < 0.||lId==2) d5 = Inf;\n    \n    \n    float d = min(min(d0,min(d2,min(min(d3,d5),d4))),d1);\n    //d = min(min(min(d4,d5),d0),d1);\n    if(d==Inf) return vec2(-1.);\n    \n    float m = -1.;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    if(d==d2) m = 3.;\n    if(d==d3) m = 4.;\n    if(d==d4) m = 5.;\n    if(d==d5) m = 6.;\n    \n    return vec2(d,m);\n}\n\nLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return Light(i,c,p+o);\n}\nLight genLight(float i,vec3 c,vec3 p,vec3 b){\n    vec3 o = boxSurfP(b)+p;\n    return Light(i,c,o);\n}\n\nvec3 getCam(float t,out vec3 uu,out vec3 vv,out vec3 ww,vec2 m) {\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n    //Keep above\n    \n    //Write below\n    \n    \n    \n    //Keep below\n    uu = normalize(uu);\n    vv = normalize(vv);\n    ww = normalize(ww);\n    return vec3(0.,1.,0.);\n}\n\nvec3 getObjectNorm(vec3 p, float id,float t) {\n    if(id==1.) return normalize(p-vec3(-1.,-.2,3.));\n    if(id==2.) return normalize(vec3(0.,1.,0.));\n    if(id==3.) return normalize(p-vec3(-2.5,1.,5.));\n    if(id==4.) return normalize(p-vec3(2.,.5,4.));\n    if(id==5.) return normalize(aabbNor(p-vec3(1.75,1.,2.),vec3(.9,.3,.6)));\n    if(id==6.) return normalize(aabbNor(p-vec3(0.,3.5,5.5),vec3(1.)));\n    //return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id,float t) {\n    if(id==1.) return Material(.85,5.,.05,vec3(.2,.2,.2));\n    if(id==2.) return Material(.95,45.,.5,vec3(.2,.2,.2));\n    if(id==3.) return Material(.01,20.,.05,vec3(.2,.2,.2));\n    if(id==4.) return Material(.9,40.,.5,vec3(.05,.2,.125));\n    if(id==5.) return Material(.85,60.,.05,vec3(.2,.2,.2));\n    if(id==6.) return Material(.05,5.,.2,vec3(.2,.2,.2));\n}\n//Glossiness (3rd comp) and Roughness (1st comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = normalize(reflect(rd,n)*(1.-r)+uniformVector()*r);\n}\n\nbool inLight(vec3 ro,vec4 ld,int lID,float t){\n    vec2 tres = worldInt(ro,normalize(ld.xyz),lID,t);\n    return tres.x>=ld.w||tres.y<0.||tres.x==-1.;\n    return true;\n}\n\n\n#define   spp   5.\n#define numLvls 3\n#define    rt   false\n//Set to true if the camera or \n//objects can move\n\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    float ftime = rt?iTime:0.;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    //.6 is shutter aperture\n    float ctime = ftime + (.5/24.)*rand();\n    \n    vec3 uu;vec3 vv;vec3 ww;\n    vec3 ro = getCam(ctime,uu,vv,ww,iMouse.xy);\n    \n    vec3 er = normalize(vec3( p.xy, 1. ));\n    vec3 rd = er.x*uu+er.y*vv+er.z*ww;\n    \n    //.0015 is blur amount\n    vec3 go = .002*vec3( -1. + 2.*rand2(), 0.);\n    //1.3 is focus distance\n    vec3 gd = normalize( er*1.3 - go );\n    \n    ro += go.x*uu+go.y*vv;\n    rd += gd.x*uu+gd.y*vv;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    for(int i = 0; i < numLvls; i++){\n        vec2 tres = worldInt(ro,rd,-1,ctime);\n    \n        if(tres.y<0.) {tcol+=fcol*getSky(rd,ctime);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y,ctime);\n        vec3 ofp     = pos + nor*.001;\n        Material dat = getObjectData(pos,tres.y,ctime);\n        \n        vec3 color = vec3(0.);\n        {\n            Light l = genLight(30.,vec3(1.,.5,0.),vec3(-1.,-.2,3.),.8);\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==1.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,0,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n            Light l = genLight(40.,vec3(.1,.55,1.),vec3(0.,3.5,5.5),vec3(.99));\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==6.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,2,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n             vec4 ld = vec4(cosDir(nor),Inf);\n             if(inLight(ofp,ld,1,ctime)) color += getSky(ld.xyz,ctime)*fcol*dat.color;\n        }\n        \n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,ofp,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(clamp(getPixCol(I),0.,1.),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 126]], "test": "untested"}
{"id": "dtXSzs", "name": "sound filtering", "author": "jonasfrey", "description": "picking out some interesting frequencies\nusefull \nhttps://www.szynalski.com/tone-generator/", "tags": ["frequencies"], "likes": 1, "viewed": 135, "published": 3, "date": "1675294508", "time_retrieved": "2024-07-30T18:12:38.365934", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc_nooff = (fragCoord)/ iResolution.xy;\n\n    vec4 o_cbufa = texture(iChannel0, o_fc_nooff);\n    \n    fragColor = o_cbufa;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define fp_n_log10(v) log(v)/log(10.)\n\n\nvec3 f_o_hsl_from_rgb( in vec3 c )\n{\n    // from here https://www.shadertoy.com/view/XljGzV\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nooff = (fragCoord)/ iResolution.xy;\n    vec2 o_mc_nooff = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_cbufa = texture(iChannel1, o_fc_nooff);\n    float x = o_fc_nooff.x;\n    float l = .5;//\n    float n_x_logarhitmic = fp_n_log10(1.-x)*-l;\n    float n_x_pow = pow(x,2.);\n    float n_amp = texture(iChannel0, vec2(n_x_logarhitmic,(1./4.)*0.)).r;\n    float n_amp_linear = texture(iChannel0, vec2(x,(1./4.)*0.)).r;\n    float n_amp_pow = texture(iChannel0, vec2(n_x_pow,(1./4.)*0.)).r;\n    \n    vec4 o_col = vec4(1.);\n    \n    float n_hz_max = iSampleRate/4.;\n    float n_hz_min = 40.;\n    float n_hz_range = n_hz_max-n_hz_min;\n\n    float n_hz_current_in_loga = (n_x_logarhitmic*n_hz_range)+n_hz_min;\n    float n_hz_current_in_pow = (n_x_pow*n_hz_range)+n_hz_min;\n    float n_hz_current_in_linear = (x*n_hz_range)+n_hz_min;\n\n    // o_freq = vec4(hz_start, hz_end, amp_thresh_nor, n_amp_sum_avg);\n    //float n_hz = o_mc_nooff.x*n_hz_max;\n    //n_hz = 524.;\n    float n_hz_width = 18.;\n    vec4[] a_o_freq = vec4[] (\n        vec4(524.-n_hz_width, 524.+n_hz_width, 0.8, 0.),\n        //vec4(n_hz, n_hz+n_hz_width, 0.3, 0.), \n        //vec4(524.-n_hz_width, 524.+n_hz_width, 0.3, 0.),\n        vec4(591.-n_hz_width, 591.+n_hz_width, 0.8, 0.),\n        vec4(654.-n_hz_width, 654.+n_hz_width, 0.8, 0.),\n        vec4(702.-n_hz_width, 702.+n_hz_width, 0.8, 0.),\n        vec4(784.-n_hz_width, 784.+n_hz_width, 0.8, 0.)\n    );\n    \n    float n_freq_linear_nor_one = 1./iResolution.x;\n    \n    float n_d_hz_avg = 0.;\n    float n_d_hz_thresh = 0.;\n    vec3 o_col_min = vec3(1.);\n    float n_col_freq_thrsh = 0.;\n    float n_amp_avg_thresh_diff = 0.;\n    vec3 o_col_xyl = vec3(0.);\n    for(int n_idx_a_o_freq = 0; n_idx_a_o_freq < a_o_freq.length(); n_idx_a_o_freq+=1){\n        float n_idx_nor = float(n_idx_a_o_freq)/float(a_o_freq.length());\n        vec4 o_freq = a_o_freq[n_idx_a_o_freq];\n        vec4 o_freq_linear_nor = (o_freq - n_hz_min) / n_hz_range;\n        \n        float n_amp_sum = 0.;\n        float n_c = 0.;\n        for(\n            float n_frq_lin_nor = o_freq_linear_nor[0];\n            n_frq_lin_nor < o_freq_linear_nor[1];\n            n_frq_lin_nor+=n_freq_linear_nor_one\n        ){\n            n_c+=1.;\n            n_amp_sum+=texture(iChannel0, vec2(n_frq_lin_nor,(1./4.)*0.)).r;\n        }\n        float n_amp_avg = n_amp_sum/n_c;\n        o_freq_linear_nor[3] = n_amp_avg;\n        vec3 o_col_idx = f_o_hsl_from_rgb(vec3(n_idx_nor, 0.5, 0.5));\n        \n        \n        if(\n            n_hz_current_in_loga > o_freq[0] \n            && n_hz_current_in_loga < o_freq[1] \n        ){\n            n_amp_avg_thresh_diff = n_amp_avg - o_freq[2];\n            n_d_hz_avg = abs(o_fc_nooff.y -n_amp_avg);\n            float n_th = 0.001;\n            float n_aa = 1./iResolution.x;\n            n_d_hz_avg=smoothstep(n_th+n_aa*10., n_th,n_d_hz_avg);\n            n_d_hz_thresh=smoothstep(n_th+n_aa*10., n_th,abs(o_fc_nooff.y -o_freq[2]));\n            o_col_min = o_col_idx;\n            \n        \n        }\n\n        o_col_idx = f_o_hsl_from_rgb(vec3(n_idx_nor, 0.5, 0.5));\n        vec2 o = ((o_fc_nooff-.5)+vec2(-0.1, -0.2))*vec2(5.,1.+n_idx_nor);\n        o*=vec2(-4.);\n        o+=vec2(n_idx_nor*7., 0.);\n        o= abs(o);\n        float n_d_sqr = max(o.x, o.y);\n        float n_d_outline = smoothstep(0.1, 0.01,abs(n_d_sqr-.5));\n        n_d_sqr = smoothstep(0.5, 0.4, n_d_sqr);\n        float n_adf =n_amp_avg - o_freq[2];\n        o_col_xyl += (n_adf*vec3(n_d_sqr)*10.)*o_col_idx;\n        o_col_xyl += vec3(n_d_outline)*o_col_idx;\n        o_col_xyl = clamp(o_col_xyl, 0., 1.);\n\n    \n    }\n    \n\n\n    float n = float(o_fc_nooff.y > n_amp);\n    \n    vec4 o_colr = vec4((1.-n)*vec4(o_col_min,1.));\n    \n    o_colr+=n_d_hz_avg*vec4(o_col_min,1.);\n    o_colr+=n_d_hz_thresh*vec4(o_col_min,1.);\n    o_colr+= float(n_amp_avg_thresh_diff>0.)*vec4(1.)*vec4(o_col_min,1.);\n    o_colr+=vec4(o_col_xyl,1.);\n    fragColor = o_colr;\n\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32167, "src": "https://soundcloud.com/hoertmalher/xylophon?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 197]], "test": "untested"}
{"id": "mlfSWB", "name": "Sierpinski Percolation", "author": "akaimos", "description": "Sierpinksi-triangle inspired percolation / erosion patterns. I find it pretty mesmerizing to stare at in full screen.", "tags": ["pixel", "sierpinksi", "greyscale"], "likes": 9, "viewed": 2250, "published": 3, "date": "1675288829", "time_retrieved": "2024-07-30T18:12:39.369251", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.25 / (iResolution.x / 1280.0);\n    float colorResolution = 256.0;\n    \n    int x = int(floor(fragCoord.x));\n    int y = int(floor(fragCoord.y));\n    int positionFactor = (x - y) & (y + x);\n    float speedFactor = iTime * speed;\n    float outColor = \n    mod(\n        mod(\n            float(positionFactor) * (speedFactor), \n            float(iResolution.x)\n        ), \n        colorResolution\n    ) / colorResolution;\n    fragColor = vec4(outColor, outColor, outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 554]], "test": "untested"}
{"id": "dllSRX", "name": "lens flare 35476", "author": "ArmandB", "description": "it does", "tags": ["flare"], "likes": 13, "viewed": 459, "published": 3, "date": "1675288705", "time_retrieved": "2024-07-30T18:12:40.351625", "image_code": "//https://www.shadertoy.com/view/Xd2GR3\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\n//fakes x^n for specular effects (k is 0-1)\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}\n\nvec3 renderLensFlare(vec2 uv, vec2 light){\n    vec3 col = vec3(0);\n    //ghosts\n    col += renderhex(uv, -light*0.25, 1.4, vec3(0.25,0.75,0));\n    col += renderhex(uv, light*0.25, 0.5, vec3(1,0.5,0.5));\n    col += renderhex(uv, light*0.1, 1.6, vec3(1,1,1));\n    col += renderhex(uv, light*1.8, 2.0, vec3(0,0.5,0.75));\n    col += renderhex(uv, light*1.25, 0.8, vec3(1,1,0.5));\n    col += renderhex(uv, -light*1.25, 5.0, vec3(0.5,0.5,0.25));\n    //circular ghost\n    col += fpow(1.0 - abs(distance(light*0.8,uv) - 0.7),0.985)*vec3(0.1,0.05,0);\n    //flare\n    col += vec3(1.0,0.6,0.4)*fpow(textureLod(iChannel0,normalize(light-uv)*0.25,0.0).r,0.3)*0.04/distance(light,uv);\n    //bloom\n    col += vec3(1.0,0.6,0.4)*fpow(max(1.0 - distance(light,uv),0.0),0.5);\n    \n    return col/(1.0 + distance(uv,light));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y*2.0;\n    vec2 light = (iMouse.xy - iResolution.xy/2.0)/iResolution.y*2.0;\n\n    fragColor = vec4(vec3(0.6,0.7,0.8) + renderLensFlare(uv,light),1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 60, 60, 174], [176, 220, 249, 249, 300], [302, 302, 353, 353, 559], [561, 561, 603, 603, 1367], [1369, 1369, 1426, 1426, 1637]], "test": "untested"}
{"id": "cllSzl", "name": "Deeper System", "author": "kishimisu", "description": "Playing around with raymarching", "tags": ["raymarching", "lines", "light", "space", "repetition", "psychedelic", "loop", "infinite", "neon", "squiggle"], "likes": 42, "viewed": 777, "published": 3, "date": "1675272958", "time_retrieved": "2024-07-30T18:12:41.120569", "image_code": "/* \"Deeper System\" by @kishimisu (2023) - https://www.shadertoy.com/view/cllSzl\n   [465 chars]\n   \n   Playing around with raymarching and neon lights\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n#define r(a) mat2(cos(a + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 r  = iResolution.xy; u += u - r;\n    float d=0., m=d, t=iTime, c;\n    vec3 g, p, q;\n    \n    for (g*=d; m++<60.; \n        p  = abs(d*normalize(vec3(u/r.y*r(t*.3), 1)))) \n        g += (cos(d*.2+vec3(0,1,2))*.5+1.) / (1.+pow(abs(\n        c  = length(vec2(length(p.xy)-1.,mod(p.z+t*4.,14.)-7.))-.05)*40.,1.3)),\n        q  = fract(p) - .5,\n        d += min(c, length(q.xy*r(t) + \n          vec2(0, sin(q.z*6.28+t/.1)*sin(t+length(p.xy))/6.)) - .1) - d*d/5e2;\n    \n    O.rgb = (cos(d*4.+t+vec3(0,1,2))+1.) / exp(d*.2) * g + g;   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllSzl.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[376, 376, 412, 412, 948]], "test": "untested"}
{"id": "dtlSzs", "name": "multiplication dist point", "author": "jonasfrey", "description": "multiplication", "tags": ["multiplication"], "likes": 2, "viewed": 138, "published": 3, "date": "1675267147", "time_retrieved": "2024-07-30T18:12:42.121892", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 o_mc = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 o_fc_nooff = (fragCoord.xy)/iResolution.xy;\n    vec2 o_mc_nooff = (iMouse.xy )/iResolution.xy;\n    \n    vec2 o_scl = vec2(9., 9.);\n    vec2 o_scl_one_nor = 1./o_scl;\n    float n_its = o_scl.x*o_scl.y;\n        \n    float n_d_sum = 0.;\n    float n_d_sum_pow = 0.;\n    float n_d_min = 1.;\n    float n_d_sum_currlast = 0.;\n    float n_d_last = 0.;\n    float n_d;\n    float n_d_prod = 1.;\n    float n_d_prod_pow = 1.;\n    float n_it_min = 0.;\n    float n_tau = 6.2831;\n    float n_d_mouse = length(o_fc - o_mc);\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n            float n_x = mod(n_it , o_scl.x);\n            float n_y = floor(n_it / o_scl.x);\n            float n_it_nor = n_it /n_its;\n            \n            vec2 o_p = vec2(n_x, n_y);\n            vec2 o_p_nor = (o_p / o_scl)+o_scl_one_nor*.5;\n            float n_d_mouse2 = length(o_p_nor-o_mc_nooff);\n            n_d = length(o_fc_nooff-o_p_nor);//*min(o_scl.x, o_scl.y);\n            n_d_sum += n_d;\n            n_d_prod *= (1.-n_d);\n            n_d_mouse2 = n_d_mouse2*1.2;\n            n_d_prod_pow *= pow(n_d*(2.+(sin(iTime*2.)*0.5+0.5)), 1.);//n_d_mouse*20.);//(sin(n_it_nor*n_tau*33.+iTime))*3.);\n            n_d_sum_pow += pow(n_d,1.);//pow(n, 1./(sin(iTime)*.5+.5+.5));\n            if(n_d < n_d_min){\n                n_d_min = n_d;\n                n_it_min = n_it;\n            }\n            n_d_sum_currlast = (n_d + n_d_last)/2.;\n            n_d_last = n_d_sum_currlast;//n_d;\n\n    }\n    float nmin = pow(n_d_min, 1./2.);\n    float n_d_sum_nor = n_d_sum / n_its;\n    float n_d_sum_pow_nor = n_d_sum_pow / n_its;\n    //fragColor = vec4(n_d_prod*n_its*10000000000000000000.);\n    fragColor = vec4(pow(n_d_prod_pow,1.));//sin(iTime)*0.2));\n    //fragColor = vec4(n_d_mouse);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1936]], "test": "untested"}
{"id": "dlXXRs", "name": "Raytracer  (Release v1.3)", "author": "raymarchingenthusiast", "description": "A raytracer. Fixed some issues. Added light objects support (Uses a single extra line).", "tags": ["raytracing", "raytracer", "pathtracing", "pathtracer"], "likes": 2, "viewed": 202, "published": 3, "date": "1675253605", "time_retrieved": "2024-07-30T18:12:42.961646", "image_code": "void mainImage(out vec4 c,in vec2 i){\n    c = texelFetch(iChannel0,ivec2(i),0);\n    c /= c.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define F float(iFrame)+1.\nstruct Material {\n    float roughness;\n    float shininess;\n    float glossiness;\n    vec3 color;\n};\n\nstruct PLight {\n    float intensity;\n    vec3 color;\n    vec3 pos;\n};\n\n#define A vec3(29.,11.,17.)\nfloat seed;\nfloat rand(void){\n  seed = mod(seed*A.x+A.y,A.z)/A.z;\n  return seed;\n}\nvec2 rand2(void){return\nvec2(rand(),rand());}\nfloat srand(float s) {\n  return mod(s*A.x+A.y,A.z)/A.z;\n}\nvoid irand(float t, vec2 p) {\n  seed = abs(-t*p.y*sin(p.y)+t*p.x*cos(p.x));\n}", "buffer_a_code": "#define Inf 9999.\n#define IG 2.2\n#define G 1./IG\n\nvec3 cosDir(in vec3 nor){\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = rand();\n    float a = 6.283185 * rand();\n\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n//Above and below are from Ingo Quilezles\nvec3 uniformVector()\n{\n    float a = 3.141593*rand();\n    float b = 6.283185*rand();\n    return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n}\n\nvec3 getSky(vec3 d,float t) {\n    return vec3(.5,.65,.95);//.5,.65,.95\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nvec2 sphInt( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\nvec2 worldInt(in vec3 ro, in vec3 rd,int lId,float t) {\n    float d0 = sphInt(ro,rd,vec3(-1.,-.2,3.),.8).x;\n    if(d0 < 0.||lId==0) d0 = Inf;\n    float d1 = planeInt(ro,rd,vec4(0.,1.,0.,1.));\n    if(d1 < 0.) d1 = Inf;\n    float d2 = sphInt(ro,rd,vec3(-2.5,1.,5.),2.).x;\n    if(d2 < 0.) d2 = Inf;\n    float d3 = sphInt(ro,rd,vec3(2.,.5,4.5),1.5).x;\n    if(d3 < 0.) d3 = Inf;\n    float d4 = sphInt(ro,rd,vec3(1.75,0.,2.),.3).x;\n    if(d4 < 0.||lId==2) d4 = Inf;\n    \n    float d = min(min(d0,min(d2,min(d3,d4))),d1);\n    //d = min(d0,d1);\n    if(d==Inf) return vec2(-1.);\n    \n    float m = -1.;\n    if(d==d0) m = 1.;\n    if(d==d1) m = 2.;\n    if(d==d2) m = 3.;\n    if(d==d3) m = 4.;\n    if(d==d4) m = 5.;\n    \n    return vec2(d,m);\n}\n\nPLight genLight(float i,vec3 c,vec3 p,float r){\n    vec3 o = r*normalize(-1.+2.*vec3(rand2(),rand()));\n    return PLight(i,c,p+o);\n}\n\nvec3 getCam(float t,out vec3 uu,out vec3 vv,out vec3 ww) {\n    uu = vec3(1.,0.,0.);\n    vv = vec3(0.,1.,0.);\n    ww = vec3(0.,0.,1.);\n    //Keep above\n    \n    //Write below\n    \n    \n    \n    //Keep below\n    uu = normalize(uu);\n    vv = normalize(vv);\n    ww = normalize(ww);\n    return vec3(0.,1.,0.);\n}\n\nvec3 getObjectNorm(vec3 p, float id,float t) {\n    if(id==1.) return normalize(p-vec3(-1.,-.2,3.));\n    if(id==2.) return normalize(vec3(0.,1.,0.));\n    if(id==3.) return normalize(p-vec3(-2.5,1.,5.));\n    if(id==4.) return normalize(p-vec3(2.,.5,4.));\n    if(id==5.) return normalize(p-vec3(1.75,0.,2.));\n    //return vec3(0.,1.,0.);\n}\n\nMaterial getObjectData(vec3 pos,float id,float t) {\n    if(id==1.) return Material(.85,35.,.05,vec3(.2,.2,.2));\n    if(id==2.) return Material(.95,15.,.5,vec3(.2,.2,.2));\n    if(id==3.) return Material(.01,15.,.05,vec3(.2,.2,.2));\n    if(id==4.) return Material(.9,15.,.5,vec3(.05,.2,.125));\n    if(id==5.) return Material(.85,35.,.05,vec3(.2,.2,.2));\n}\n//Glossiness (3rd comp) and Roughness (1st comp) should NEVER be 0.\nvoid getRay(out vec3 ro,inout vec3 rd,float r,vec3 p,vec3 n){\n    ro = p;\n    rd = normalize(reflect(rd,n)*(1.-r)+uniformVector()*r);\n}\n\nbool inLight(vec3 ro,vec4 ld,int lID,float t){\n    vec2 tres = worldInt(ro,normalize(ld.xyz),lID,t);\n    return tres.x>=ld.w||tres.y<0.||tres.x==-1.;\n    return true;\n}\n\n//Lower this if rt is false?\n#define  spp    1.\n#define numLvls 5\n#define   rt    false\n//Set to true if the camera or \n//objects can move\n\nvec3 getPixCol(vec2 I) {\n    float frame = F*spp;\n    float ftime = rt?iTime:0.;\n    vec3 ttcol = vec3(0.);\n    for(float i=0.;i<spp;i++) {\n    irand(frame,I);\n    vec2 p = (-R + 2.*(I+rand2()))/R.y;\n    \n    //.6 is shutter aperture\n    float ctime = ftime + (.6/24.)*rand();\n    \n    vec3 uu;vec3 vv;vec3 ww;\n    vec3 ro = getCam(ctime,uu,vv,ww);\n    \n    vec3 er = normalize(vec3( p.xy, 1. ));\n    vec3 rd = er.x*uu+er.y*vv+er.z*ww;\n    \n    //.0015 is blur amount\n    vec3 go = .0015*vec3( -1. + 2.*rand2(), 0.);\n    //1.3 is focus distance\n    vec3 gd = normalize( er*1.3 - go );\n    \n    ro += go.x*uu+go.y*vv;\n    rd += gd.x*uu+gd.y*vv;\n    rd = normalize(rd);\n    \n    vec3 tcol = vec3(0.);\n    vec3 fcol = vec3(1.);\n    //3 is number of levels\n    for(int i = 0; i < numLvls; i++){\n        vec2 tres = worldInt(ro,rd,-1,ctime);\n    \n        if(tres.y<0.) {tcol+=fcol*getSky(rd,ctime);break;}\n    \n        vec3 pos = ro + rd * tres.x;\n     \n        vec3 nor     = getObjectNorm(pos,tres.y,ctime);\n        vec3 ofp     = pos + nor*.001;\n        //ofp = pos;\n        Material dat = getObjectData(pos,tres.y,ctime);\n        dat.shininess = 2./(dat.glossiness*(1.-dat.roughness));\n        \n        vec3 color = vec3(0.);\n        {\n            PLight l = genLight(30.,vec3(1.,.5,0.),vec3(-1.,-.2,3.),.8);\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==1.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,0,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n            PLight l = genLight(8.,vec3(.1,.55,1.),vec3(1.75,0.,2.),.3);\n            vec4 ld = vec4(l.pos-pos,length(l.pos-pos));\n            if(tres.y==5.){color+=l.color*fcol;}\n            else{if(inLight(ofp,ld,2,ctime)){\n                vec3 nld = normalize(ld.xyz);\n                float i = l.intensity/(ld.w*ld.w);\n                color += dat.color*dat.roughness*l.color*i*fcol*max(dot(nor,nld),0.);\n                vec3 h = normalize(ld.xyz+(ro-pos));\n                color += (1.-dat.roughness)*fcol*i*l.color*pow(max(0.,dot(h,nor)),dat.shininess);\n            }}\n        }\n        {\n             vec4 ld = vec4(cosDir(nor),Inf);\n             if(inLight(ofp,ld,1,ctime)) color += getSky(ld.xyz,ctime)*fcol*dat.color;\n        }\n        \n        fcol *= dat.color;\n        tcol += color;\n        getRay(ro,rd,dat.roughness,ofp,nor);\n    }\n    ttcol += tcol;\n    frame++;\n    }\n    return ttcol/spp;\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    O = vec4(clamp(getPixCol(I),0.,1.),1.);\n    O.xyz = pow(O.xyz,vec3(G));\n    if(iFrame>0&&!rt) O += texelFetch(iChannel0,ivec2(I),0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 95]], "test": "untested"}
